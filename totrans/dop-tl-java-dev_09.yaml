- en: Chapter 9\. Mobile Workflows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Stephen Chin
  prefs: []
  type: TYPE_NORMAL
- en: Program testing can be a very effective way to show the presence of bugs, but
    is hopelessly inadequate for showing their absence.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Edsger Dijkstra
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Coverage of DevOps wouldn’t be complete without talking about mobile development
    and smartphones, which is the fastest growing segment of computer ownership. The
    past decade has seen a meteoric rise in smartphone usage, with billions of smartphones
    owned globally, as shown in [Figure 9-1](#smartphone_users).
  prefs: []
  type: TYPE_NORMAL
- en: Smartphone ownership is expected to continue to rise since many large countries
    such as India and China have less than 70% ownership. With over 3.6 billion smartphones
    in the world today and an expected 4.3 billion smartphones by the year 2023, this
    is a market and user base that can’t be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'Smartphones also have another property that makes DevOps an essential practice:
    they fall into a class of internet-connected devices where continuous updates
    are expected by default, because they are targeted at consumers who are less technical
    and need to maintain their devices with minimal user involvement. This has been
    propelled by the app ecosystem built around smartphones, which makes downloading
    new software as well as receiving software updates easy and relatively low risk
    for end users.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chart showing growth of smartphone ownership from 2012 through 2023](Images/dtjd_0901.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-1\. Number of smartphone users in the world from 2012 through 2023
    according to [Statista](https://oreil.ly/k8dk1) (prediction for 2023 marked with
    *)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You may want to update your app for several functional reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding new features for users
  prefs: []
  type: TYPE_NORMAL
- en: Most apps are released quickly and with a minimum viable set of features to
    reduce time to market. This allows for frequent small feature updates to add useful
    functionality for end users.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing bugs and improving the stability of your application
  prefs: []
  type: TYPE_NORMAL
- en: More mature applications have lots of updates that fix small bugs, stability
    issues, and user experience improvements. These changes are typically minor and
    can be released frequently.
  prefs: []
  type: TYPE_NORMAL
- en: Patching security vulnerabilities or exploits
  prefs: []
  type: TYPE_NORMAL
- en: Mobile applications typically have a large attack surface that includes the
    locally installed app, the backend that supplies data, and user authentication
    workflows for app and cloud service logins.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, a lot of app updates are driven by the need to increase market
    share and improve engagement with users. Some examples of updates that help to
    grow market share of your app include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Aligning with major platform releases
  prefs: []
  type: TYPE_NORMAL
- en: Whenever a major platform release occurs, apps that are certified against the
    new version and updated to take advantage of new functionality will see an increase
    in downloads.
  prefs: []
  type: TYPE_NORMAL
- en: Raising visibility of your app in the store
  prefs: []
  type: TYPE_NORMAL
- en: App stores reward apps that frequently update by retaining user ratings between
    releases and highlighting new releases. The release notes also give you a chance
    to increase searchable content in the store. In contrast, if your app stagnates
    with no updates, it will naturally drop in search engine optimization.
  prefs: []
  type: TYPE_NORMAL
- en: Reminding current users about your application to increase utilization
  prefs: []
  type: TYPE_NORMAL
- en: Mobile platforms prompt users about updates to their existing apps and sometimes
    display badges or other reminders that will increase engagement.
  prefs: []
  type: TYPE_NORMAL
- en: The top applications in the app stores know the importance of continuous updates
    and update frequently. According to [Appbot](https://oreil.ly/CdW2A), of the 200
    top free apps, the median time since the last update was 7.8 days! With this pace
    of updates, if you do not use a continuous release process, you won’t be able
    to keep up.
  prefs: []
  type: TYPE_NORMAL
- en: Java developers have great options for building mobile applications. These include
    mobile-focused web development with responsive web apps that adapt to constrained
    devices. Other options include dedicated mobile applications written in Java for
    Android devices. Finally, several cross-platform options for building applications
    work across Android and iOS devices, including Gluon Mobile and Electron.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter focuses primarily on Android application development. However,
    all the same mobile DevOps techniques and considerations apply across these Java-based
    mobile platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Fast-Paced DevOps Workflows for Mobile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some of the business benefits you will realize from investing in mobile
    DevOps:'
  prefs: []
  type: TYPE_NORMAL
- en: Better customer experience
  prefs: []
  type: TYPE_NORMAL
- en: With the easy and accessible rating systems available in the app store, customer
    experience is king. By being able to respond quickly to customer issues and test
    on a large variety of devices, you will ensure an optimal customer experience.
  prefs: []
  type: TYPE_NORMAL
- en: Faster innovation
  prefs: []
  type: TYPE_NORMAL
- en: By continuously releasing to production, you will be able to get new features
    and capabilities to your customers at a higher velocity than your competitors.
  prefs: []
  type: TYPE_NORMAL
- en: Higher software quality
  prefs: []
  type: TYPE_NORMAL
- en: With the large number and high fragmentation of Android devices, thoroughly
    testing your application manually is impossible. But with an automated mobile
    testing strategy that hits the key device characteristics of your user base, you
    will reduce the number of issues reported by end users.
  prefs: []
  type: TYPE_NORMAL
- en: Reduced risk
  prefs: []
  type: TYPE_NORMAL
- en: The majority of executable code in modern applications has open source dependencies
    that expose you to known security vulnerabilities. By having a mobile DevOps pipeline
    that allows you to test new versions of dependencies and update frequently, you
    will be able to quickly fix any known vulnerabilities in your application before
    they can be taken advantage of.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same principles and best practices outlined in the rest of this book apply
    to mobile application development, but are amplified 10 times by the size and
    expectations of this market. When planning out a mobile DevOps pipeline for Android
    devices, here are the stages you need to consider:'
  prefs: []
  type: TYPE_NORMAL
- en: Build.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Android build scripts are usually written in Gradle. As a result, you can use
    any continuous integration server of your choice, including Jenkins, CircleCI,
    Travis CI, or JFrog Pipelines.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unit tests
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Android unit tests are typically written in JUnit, which can easily be automated.
    Higher-level Android unit tests are often written in some sort of UI test framework
    like Espresso, Appium, Calabash, or Robotium.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Integration tests
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Besides testing your own application, it is important to test interactions between
    applications with tools like UI Automator that are focused on integration testing
    and can test across multiple Android applications.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Functional tests
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Overall application verification is important. You can do this manually, but
    automated tools can simulate user input like the previously mentioned UI automation
    tools. Another option is to run robotic crawler tools like Google’s App Crawler
    in order to inspect your application’s user interface and automatically issue
    user actions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the package step, you aggregate all of the scripts, configuration files,
    and binaries needed for deployment. By using a package management tool like Artifactory,
    you retain all the build and test information and can easily track dependencies
    for traceability and debugging.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Release.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One of the best parts of mobile app development is that releasing mobile applications
    ends with the app store submission; the final deployment to devices is managed
    by the Google Play infrastructure. The challenging parts are that you have to
    prepare your build to make sure the app store submission is successful, and you’ll
    be penalized for any mistakes in building, testing, and packaging by delays if
    you do not fully automate the submission process.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As you can see, the biggest difference in DevOps for Android development comes
    with testing. There is a lot of investment in UI test frameworks for Android apps,
    because automated testing is the only solution to the problem of testing across
    a highly fragmented device ecosystem. We will find out exactly how severe the
    Android device fragmentation is in the next section and talk about ways to mitigate
    this later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Android Device Fragmentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The iOS ecosystem is tightly controlled by Apple, which limits the number of
    hardware models available, the variations in screen size, and the set of hardware
    sensors and features on its phones. Since 2007 when the first iPhone debuted,
    only 29 different devices have been produced, only 7 of which are currently sold.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, the Android ecosystem is open to a plethora of device manufacturers
    who customize everything from the screen size and resolution to the processor
    and hardware sensors, and even produce unique form factors like foldable screens.
    There are over 24,000 different devices from 1,300 different manufacturers, which
    is 1,000 times more fragmentation than for iOS devices. This makes testing for
    Android platforms much more difficult to execute.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to fragmentation, several key differences make it hard to uniformly
    test different Android devices:'
  prefs: []
  type: TYPE_NORMAL
- en: Android version
  prefs: []
  type: TYPE_NORMAL
- en: Android device manufacturers do not always provide updates for older devices
    to the latest Android version, so users may be stuck on old Android OS versions
    until they buy a new device. The drop-off in use of old Android versions is gradual,
    with active devices still running Android 4.*x* releases that are more than seven
    years old, including Jelly Bean and KitKat.
  prefs: []
  type: TYPE_NORMAL
- en: Screen size and resolution
  prefs: []
  type: TYPE_NORMAL
- en: Android devices come in a wide array of form factors and hardware configurations,
    with a trend toward larger and more pixel-dense displays. A well-designed application
    needs to scale in order to work well across a range of screen sizes and resolutions.
  prefs: []
  type: TYPE_NORMAL
- en: 3D support
  prefs: []
  type: TYPE_NORMAL
- en: Particularly for games, it is critical to know what level of 3D support you
    will get on devices, in terms of APIs and performance.
  prefs: []
  type: TYPE_NORMAL
- en: Hardware features
  prefs: []
  type: TYPE_NORMAL
- en: Most Android devices come with basic hardware sensors (camera, accelerometer,
    GPS), but support varies for newer hardware APIs such as near-field communication
    (NFC), barometers, magnetometers, proximity and pressure sensors, thermometers,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Android OS Fragmentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Android version fragmentation affects device testing at two levels. The first
    is the major Android version, which determines the number of Android API versions
    you need to build for and test against. And the second is the OS customization
    done by original equipment manufacturers (OEMs) to support specific hardware configurations.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of iOS, since Apple controls the hardware and the operating system,
    it is able to push out updates for all supported devices simultaneously. This
    keeps the adoption level of minor updates for performance and security fixes high.
    Apple also puts a lot of features and marketing into major releases to push the
    installed base to upgrade to the latest version quickly. As a result, Apple was
    able to achieve [86% adoption](https://oreil.ly/3GYL8) of iOS 14 only seven months
    after its initial release.
  prefs: []
  type: TYPE_NORMAL
- en: The Android market is significantly more complex since OEMs modify and test
    custom versions of Android OSs for their devices. In addition, they are reliant
    on system-on-a-chip (SoC) manufacturers to provide code updates for different
    hardware components. This means that devices created by major vendors are likely
    to receive only a couple of major OS version updates, and devices from smaller
    vendors may never see an OS upgrade even when they are under support.
  prefs: []
  type: TYPE_NORMAL
- en: To help you decide how far back you should support different Android OS versions,
    Google provides information in Android Studio on the device adoption by API level.
    The distribution of users as of August 2021 is shown in [Figure 9-2](#android_version_usage).
    To achieve > 86% adoption comparable to the latest iOS version, you need to support
    at least Android 5.1 Lollipop, a release that came out in 2014\. Even then you
    are still missing out on over 5% of users who are still using Android 4–based
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: '![List of Android versions with information on usage and features](Images/dtjd_0902.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-2\. Android Studio showing the distribution of users on different versions
    of the Android platform (Android 11 has < 1% adoption)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: To further complicate the situation, every OEM modifies the Android OS it ships
    for its devices, so it is not enough to simply test one device per major Android
    version. This is a result of the way Android uses the Linux kernel to access hardware
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: The Linux kernel is the heart of the operating system and provides the low-level
    device driver code to access cameras, accelerometers, the display, and other hardware
    on the device. To the Linux kernel that Android is based on, Google adds in Android-specific
    features and patches, SoC vendors add in hardware-specific support, and OEMs further
    modify it for their specific devices. Therefore, each device has a range of variation
    in performance, security, and potential bugs that could affect your application
    when a user runs it on a new device.
  prefs: []
  type: TYPE_NORMAL
- en: Google worked toward improving this situation with Android 8.0 Oreo, which includes
    a new hardware abstraction layer allowing device-specific code to run outside
    the kernel. This allows OEMs to update to new Android kernel versions from Google
    without waiting for device driver updates from SoC vendors, which reduces the
    amount of redevelopment and testing required for OS upgrades. However, other than
    Pixel devices that Google handles OS updates for, the majority of Android device
    upgrades are in the hands of OEMs, which are still slow to upgrade to new Android
    versions.
  prefs: []
  type: TYPE_NORMAL
- en: Building for Disparate Screens
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Given the diversity in hardware manufacturers and over 24,000 models, as discussed
    in the previous section, it should be no surprise that a huge variation also exists
    in screen sizes and resolutions. New screen dimensions are constantly being introduced,
    such as the enormous HP Slate 21, which uses a 21.5-inch touchscreen, and the
    Samsung Galaxy Fold with a vertical 1680 × 720 cover display that opens to reveal
    a double-wide inner display with a resolution of 2152 × 1536.
  prefs: []
  type: TYPE_NORMAL
- en: Besides the huge variation in screen sizes, there is a constant battle over
    achieving higher pixel density as well. Higher pixel densities allow for clearer
    text and sharper graphics, providing a better viewing experience.
  prefs: []
  type: TYPE_NORMAL
- en: The current front-runner in pixel density is the Sony Xperia XZ, which packs
    a 3840 × 2160 UHS-1 display in a screen that measures only 5.2 inches diagonally.
    This gives a density of 806.93 pixels per inch (PPI), which is getting close to
    the maximum resolution the human eye can distinguish.
  prefs: []
  type: TYPE_NORMAL
- en: Applied Materials, one of the leading manufacturers of LCD and OLED displays,
    did research on human perception of pixel density on handheld displays. It found
    that at a distance of 4 inches from the eye, [a human with 20/20 vision can distinguish
    876 PPI](https://oreil.ly/OecRt). Therefore, smartphone displays are quickly approaching
    the theoretical limit on pixel density; however, other form factors like virtual
    reality headsets may drive the density even further.
  prefs: []
  type: TYPE_NORMAL
- en: 'To handle variation in pixel densities, Android categorizes screens into the
    following pixel density ranges:'
  prefs: []
  type: TYPE_NORMAL
- en: ldpi, ~120 dpi (.75x scale)
  prefs: []
  type: TYPE_NORMAL
- en: Used on a limited number of very low-resolution devices like the HTC Tattoo,
    Motorola Flipout, and Sony X10 Mini, all of which have a screen resolution of
    240 × 320 pixels.
  prefs: []
  type: TYPE_NORMAL
- en: mdpi, ~160 dpi (1x scale)
  prefs: []
  type: TYPE_NORMAL
- en: This is the original screen resolution for Android devices such as the HTC Hero
    and Motorola Droid.
  prefs: []
  type: TYPE_NORMAL
- en: tvdpi, ~213 dpi (1.33x scale)
  prefs: []
  type: TYPE_NORMAL
- en: Resolution intended for televisions such as the Google Nexus 7, but not considered
    a “primary” density group.
  prefs: []
  type: TYPE_NORMAL
- en: hdpi, ~240 dpi (1.5x scale)
  prefs: []
  type: TYPE_NORMAL
- en: The second generation of phones such as the HTC Nexus One and Samsung Galaxy
    Ace increased resolution by 50%.
  prefs: []
  type: TYPE_NORMAL
- en: xhdpi, ~320 dpi (2x scale)
  prefs: []
  type: TYPE_NORMAL
- en: One of the first phones to use this 2*x* resolution was the Sony Xperia S, followed
    by phones like the Samsung Galaxy S III and HTC One.
  prefs: []
  type: TYPE_NORMAL
- en: xxhdpi, ~480 dpi (3x scale)
  prefs: []
  type: TYPE_NORMAL
- en: The first xxhdpi device was the Nexus 10 by Google, which was only 300 dpi but
    needed large icons since it was in tablet form.
  prefs: []
  type: TYPE_NORMAL
- en: xxxhdpi, ~640 dpi (4x scale)
  prefs: []
  type: TYPE_NORMAL
- en: This is currently the highest resolution used by devices like the Nexus 6 and
    Samsung Galaxy S6 Edge.
  prefs: []
  type: TYPE_NORMAL
- en: As displays continue to increase in pixel density, Google probably wishes it
    had chosen a better convention for high-resolution displays than just adding more
    *x*s!
  prefs: []
  type: TYPE_NORMAL
- en: To give the best user experience for your end users, it is important to have
    your application look and behave consistently across the full range of available
    resolutions. Given the wide variety of screen resolutions, it is not enough to
    simply hardcode your application for each resolution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some best practices to make sure that your application will work across
    the full range of resolutions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Always use density-independent and scalable pixels:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Density-independent pixels (dp)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Pixel unit that adjusts based on the resolution of the device. For an mdpi screen,
    1 pixel (px) = 1 dp. For other screen resolutions, px = dp × (dpi / 160).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Scalable pixels (sp)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Scalable pixel unit used for text or other user-resizable elements. This starts
    at 1 sp = 1 dp and adjusts based on the user-defined text zoom value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Provide alternate bitmaps for all available resolutions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android allows you to provide alternate bitmaps for different resolutions by
    putting them in subfolders named *drawable-?dpi*, where *?dpi* is one of the supported
    density ranges.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The same applies for your app icon, except you should use subfolders named *mipmap-?dpi*
    so the resources aren’t removed when you build density-specific APKs, because
    app icons are often upscaled beyond the device resolution.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Better yet, use vector graphics whenever possible:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android Studio provides a tool called Vector Asset Studio that allows you to
    convert an SVG or PSD into an Android Vector file that can be used as a resource
    in your application, as shown in [Figure 9-3](#convert_svg).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Dialog from Android Studio for converting SVG and PSD files to vector resources](Images/dtjd_0903.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-3\. Conversion of an SVG file to an Android Vector format
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Building applications that cleanly scale to different screen sizes and resolutions
    is complicated to get right and needs to be tested on devices with differing resolutions.
    To help focus your testing efforts, Google provides user-mined [data](https://oreil.ly/Aqw18)
    on the usage of different device resolutions, as shown in [Table 9-1](#sizes_and_densities).
  prefs: []
  type: TYPE_NORMAL
- en: Table 9-1\. Android screen size and density distribution
  prefs: []
  type: TYPE_NORMAL
- en: '|  | ldpi | mdpi | tvdpi | hdpi | xdpi | xxhdpi | Total |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Small | 0.1% |  |  |  | 0.1% |  | 0.2% |'
  prefs: []
  type: TYPE_TB
- en: '| Normal |  | 0.3% | 0.3% | 14.8% | 41.3% | 26.1% | 82.8% |'
  prefs: []
  type: TYPE_TB
- en: '| Large |  | 1.7% | 2.2% | 0.8% | 3.2% | 2.0% | 9.9% |'
  prefs: []
  type: TYPE_TB
- en: '| Xlarge |  | 4.2% | 0.2% | 2.3% | 0.4% |  | 7.1% |'
  prefs: []
  type: TYPE_TB
- en: '| Total | 0.1% | 6.2% | 2.7% | 17.9% | 45.0% | 28.1% |  |'
  prefs: []
  type: TYPE_TB
- en: As you can see, some resolutions are not prevalent and, unless your application
    targets these users or legacy device types, you can prune them from your device-testing
    matrix. The ldpi density is used on only a small segment of Android devices and
    with only 0.1% market share—few applications are optimized for this very small
    resolution screen. Also, tvdpi is a niche screen resolution with only 2.7% usage
    and can be safely ignored since Android will automatically downscale hdpi assets
    in order to fit this screen resolution.
  prefs: []
  type: TYPE_NORMAL
- en: This still leaves you with five device densities to support and a potentially
    innumerable number of screen resolutions and aspect ratios to test. I discuss
    testing strategies later, but you will likely be using a mix of emulated devices
    and physical devices to make sure that you provide the best user experience across
    the fragmented Android ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Hardware and 3D Support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The very first Android device was the HTC Dream (a.k.a. T-Mobile G1), shown
    in [Figure 9-4](#tmobile_g1). It had a medium density touchscreen of 320 × 480
    px, a hardware keyboard, speaker, microphone, five buttons, a clickable trackball,
    and a rear-mounted camera. While primitive by modern smartphone standards, it
    was a great platform to launch Android, which lacked support for software keyboards
    at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compared to modern smartphone standards, this was a modest hardware set. The
    Qualcomm MSM7201A processor that drove the HTC Dream was a 528 MHz Arm11 processor
    with support for only OpenGL ES 1.1\. In comparison, the Samsung Galaxy S21 Ultra
    5G sports a 3200 × 1440 resolution screen with the following sensors:'
  prefs: []
  type: TYPE_NORMAL
- en: 2.9 GHz 8-core processor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arm Mali-G78 MP14 GPU with support for Vulkan 1.1, OpenGL ES 3.2, and OpenCL
    2.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Five cameras (one front, four rear)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Three microphones (one bottom, two top)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stereo speakers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ultrasonic fingerprint reader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accelerometer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Barometer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gyro sensor (gyroscope)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Geomagnetic sensor (magnetometer)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hall sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proximity sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ambient light sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NFC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Photo of a smartphone with the screen retracted to show a hardware keyboard.](Images/dtjd_0904.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-4\. The T-Mobile G1 (a.k.a. HTC Dream), which was the [first smartphone](https://oreil.ly/ijUOh)
    to run the Android operating system (photo used under [Creative Commons license](https://oreil.ly/GLSPZ))
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The flagship Samsung phones are at the high end of the spectrum when it comes
    to hardware support, and include almost all of the supported sensor types. Phones
    meant for mass market may choose to use less powerful chipsets and leave off sensors
    to reduce cost. Android uses the data from the available physical sensors to also
    create “virtual” sensors in software that are used by applications:'
  prefs: []
  type: TYPE_NORMAL
- en: Game rotation vector
  prefs: []
  type: TYPE_NORMAL
- en: Combination of data from the accelerometer and gyroscope
  prefs: []
  type: TYPE_NORMAL
- en: Gravity
  prefs: []
  type: TYPE_NORMAL
- en: Combination of data from the accelerometer and gyroscope (or magnetometer if
    no gyroscope is present)
  prefs: []
  type: TYPE_NORMAL
- en: Geomagnetic rotational vector
  prefs: []
  type: TYPE_NORMAL
- en: Combination of data from the accelerometer and magnetometer
  prefs: []
  type: TYPE_NORMAL
- en: Linear acceleration
  prefs: []
  type: TYPE_NORMAL
- en: Combination of data from the accelerometer and gyroscope (or magnetometer if
    no gyroscope is present)
  prefs: []
  type: TYPE_NORMAL
- en: Rotation vector
  prefs: []
  type: TYPE_NORMAL
- en: Combination of data from the accelerometer, magnetometer, and gyroscope
  prefs: []
  type: TYPE_NORMAL
- en: Significant motion
  prefs: []
  type: TYPE_NORMAL
- en: Data from the accelerometer (and possibly substitutes other sensor data when
    in low-power mode)
  prefs: []
  type: TYPE_NORMAL
- en: Step detector/counter
  prefs: []
  type: TYPE_NORMAL
- en: Data from the accelerometer (and possibly substitutes other sensor data when
    in low-power mode)
  prefs: []
  type: TYPE_NORMAL
- en: These virtual sensors are available only if a sufficient set of physical sensors
    is present. Most phones contain an accelerometer, but may choose to omit either
    a gyroscope or magnetometer or both, reducing the precision of motion detection
    and disabling certain virtual sensors.
  prefs: []
  type: TYPE_NORMAL
- en: Hardware sensors can be emulated, but it is much harder to simulate real-world
    conditions for testing. Also, much more variation occurs in hardware chipset and
    SoC vendor-driver implementation, producing a huge test matrix required to verify
    your application across a range of devices.
  prefs: []
  type: TYPE_NORMAL
- en: The other aspect of hardware that is particularly important for game developers,
    but increasingly is part of the basic graphics stack and expected performance
    of applications, is 3D API support. Almost all mobile processors support some
    basic 3D APIs, including the first Android phone, which had support for OpenGL
    ES 1.1, a mobile-specific version of the OpenGL 3D standard. Modern phones support
    later versions of the OpenGL ES standard, including OpenGL ES 2.0, 3.0, 3.1, and
    now 3.2.
  prefs: []
  type: TYPE_NORMAL
- en: OpenGL ES 2.0 introduced a dramatic shift in the programming model, switching
    from a functional pipeline to a programmable pipeline, allowing for more direct
    control to create complex effects through the use of shaders. OpenGL ES 3.0 further
    increased the performance and hardware independence of 3D graphics by supporting
    features like vertex array objects, instanced rendering, and device-independent
    compression formats (ETC2/EAC).
  prefs: []
  type: TYPE_NORMAL
- en: OpenGL ES adoption has been rather quick, with all modern devices supporting
    at least OpenGL ES 2.0\. According to Google’s device data shown in [Figure 9-5](#opengl_es_adoption),
    the majority of devices (67.54%) support OpenGL ES 3.2, the latest version of
    the standard released in August 2015.
  prefs: []
  type: TYPE_NORMAL
- en: '![Pie chart showing of OpenGL ES version adoption](Images/dtjd_0905.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-5\. Percentage of Android devices adopting different versions of OpenGL
    ES from [Google’s Distribution Dashboard](https://oreil.ly/18xDQ)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Vulkan is a newer graphics API that modern graphics chipsets support. It has
    the advantage of being portable between desktop and mobile devices, allowing for
    easier porting of desktop code as computing platforms continue to converge. Also,
    it allows an even finer level of control over threads and memory management, and
    an asynchronous API for buffering and sequencing commands across multiple threads,
    making better use of multicore processors and high-end hardware.
  prefs: []
  type: TYPE_NORMAL
- en: Since Vulkan is a newer API, adoption has not been as quick as OpenGL ES; however,
    64% of Android devices have some level of Vulkan support. According to Google’s
    device statistics visualized in [Figure 9-6](#vulkan_adoption), this is split
    between Vulkan 1.1, which is supported by 42% of devices, and the remaining 22%
    of devices that support only the Vulkan 1.0.3 API level.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to hardware sensor testing, a large variety of 3D chipsets are implemented
    by different manufacturers. Therefore, the only way to reliably test for bugs
    and performance issues in your application is to execute device testing on different
    phone models, covered in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: '![Pie chart showing Vulkan version adoption](Images/dtjd_0906.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-6\. Percentage of Android devices adopting different versions of Vulkan
    from [Google’s Distribution Dashboard](https://oreil.ly/K9FZd)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Continuous Testing on Parallel Devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The preceding section discussed the large amount of fragmentation in the Android
    device ecosystem. This is forced by technological factors like the Android OS
    architecture as well as the complex ecosystem of OEMs and SoC vendors. Also, the
    sheer popularity of the Android platform, with 1,300 manufacturers producing over
    24,000 devices, creates a continuous testing and deployment challenge.
  prefs: []
  type: TYPE_NORMAL
- en: Device emulators are great for development and basic testing of applications,
    but cannot possibly simulate the complex interactions of unique hardware configurations,
    device drivers, custom kernels, and real-world sensor behavior. Therefore, a high
    level of manual and automated testing on devices is required to ensure a good
    experience for end users.
  prefs: []
  type: TYPE_NORMAL
- en: Two basic approaches are used for hardware testing at scale. The first is to
    build out your own device lab with shared devices. This is a practical approach
    to get started with testing, since you likely have a large collection of Android
    devices available that could be put to better use with proper infrastructure and
    automation. However, depending on the number of device configurations you want
    to support, this can be quite a large and expensive endeavor. Also, the ongoing
    maintenance and upkeep for a large device farm can be costly in both materials
    and labor.
  prefs: []
  type: TYPE_NORMAL
- en: The second option is to outsource your device testing to a cloud service. Given
    the advances in remote control of Android devices and stability of the platform,
    it is convenient to be able to select your matrix of devices and have your automated
    tests fired off in the cloud. Most cloud services offer detailed screenshots and
    diagnostic logs that can be used to trace build failures as well as the ability
    to manually control a device for debugging purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Building a Device Farm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Building your own device farm, even at a small scale, is a great way to leverage
    Android devices that you already have and increase their utility for your entire
    organization. At scale, device farms can significantly reduce the run rate cost
    of Android development once you have made the up-front investment in hardware.
    Keep in mind, though, running a large device lab is a full-time job and has ongoing
    costs that need to be accounted for.
  prefs: []
  type: TYPE_NORMAL
- en: A popular open source library for managing Android devices is Device Farmer
    (formerly Open STF). Device Farmer allows you to remotely control an Android device
    from your web browser with a real-time view of the device screen, as shown in
    [Figure 9-7](#device_farmer). For manual tests, you can type from your desktop
    keyboard and use your mouse to input single or multitouch gestures. For automated
    tests, a REST API allows you to use test automation frameworks like Appium.
  prefs: []
  type: TYPE_NORMAL
- en: '![Picture of a volunteer built device lab at a conference](Images/dtjd_0907.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-7\. Device Farmer [user interface](https://oreil.ly/2MQpN) (photo used
    under [Creative Commons](https://oreil.ly/bPhIL))
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Device Farmer also helps you manage your inventory of devices. It shows you
    which devices are connected, who is using each device, and the hardware spec for
    your devices, and it assists with physically locating devices in a large lab.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, Device Farmer also has a system for booking and partitioning groups
    of devices. You can split your device inventory into distinct groups that have
    owners and associated properties. These groups can then be permanently allocated
    to projects or organizations or they can be booked for a specific time period.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up a device lab, you also need hardware to support the devices. The
    basic hardware setup includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Driver computer
  prefs: []
  type: TYPE_NORMAL
- en: Even though Device Farmer can run on any operating system, it is recommended
    to run it on a Linux-based host for ease of administration and the best stability.
    A good option for getting started with this is a compact, but powerful, computer
    like the Intel NUC.
  prefs: []
  type: TYPE_NORMAL
- en: USB hub
  prefs: []
  type: TYPE_NORMAL
- en: Both for device connectivity and to supply stable power, a powered USB hub is
    recommended. Getting a reliable USB hub is important since this will affect the
    stability of your lab.
  prefs: []
  type: TYPE_NORMAL
- en: Wireless router
  prefs: []
  type: TYPE_NORMAL
- en: The devices will get their network connectivity from a wireless router, so this
    is an important part of the device setup. Having a dedicated network for your
    devices will increase reliability and reduce contention with other devices on
    your network.
  prefs: []
  type: TYPE_NORMAL
- en: Android devices
  prefs: []
  type: TYPE_NORMAL
- en: And the most important part, of course, is having plenty of Android devices
    to test against. Start with devices that are the most common and popular with
    your target user base and add devices to hit the desired test matrix of Android
    OS versions, screen sizes, and hardware support as discussed in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Plenty of cables
  prefs: []
  type: TYPE_NORMAL
- en: You will need longer cables than usual for efficient cable management of devices
    to the USB hub. It is important to leave enough space between individual devices
    and hardware components to avoid overheating.
  prefs: []
  type: TYPE_NORMAL
- en: With a little bit of work, you will be able to create a fully automated device
    lab similar to [Figure 9-8](#open_device_lab), which was the world’s first conference
    device lab featured at the beyond tellerrand conference in Düsseldorf, Germany.
  prefs: []
  type: TYPE_NORMAL
- en: '![Picture of a volunteer built device lab at a conference](Images/dtjd_0908.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-8\. [Open device lab](https://oreil.ly/QgEr9) at the beyond tellerrand
    conference in Düsseldorf, Germany (photo used under [Creative Commons](https://oreil.ly/Xv18U))
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Device Farmer is split into microservices to allow for scalability of the platform
    to thousands of devices. Out of the box, it easily supports 15 devices, after
    which you will run into port limitations with Android Debug Bridge (ADB). This
    can be scaled out by running multiple instances of the Device Farmer ADB and Provider
    services up to the limit of the number of USB devices that your machine can support.
    For Intel architectures, this is 96 endpoints (including other peripherals), and
    for AMD, you can get up to 254 USB endpoints. By using multiple Device Farmer
    servers, you can scale into the thousands of devices, which should be enough to
    support mobile testing and verification of enterprise Android applications.
  prefs: []
  type: TYPE_NORMAL
- en: One example of a large-scale mobile device lab is Facebook’s mobile device lab
    at its Prineville, Oregon, data center, shown in [Figure 9-9](#facebook_mobile_device_lab).
    The company built a customer server rack enclosure for holding mobile devices
    that is deigned to block WiFi signals to prevent interference among devices in
    the data center. Each enclosure can support 32 devices and is powered by 4 OCP
    Leopard servers that connect to the devices. This provides a stable and scalable
    hardware setup that allowed the company to reach its target device farm size of
    2,000 devices.
  prefs: []
  type: TYPE_NORMAL
- en: '![Photo of a data center holding mobile devices in rack enclosures.](Images/dtjd_0909.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-9\. The Facebook mobile device lab in its Prineville data center ([photo
    by Antoine Reversat](https://oreil.ly/fbj35))
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Running a large-scale device lab has challenges:'
  prefs: []
  type: TYPE_NORMAL
- en: Device maintenance
  prefs: []
  type: TYPE_NORMAL
- en: Android devices are not meant to be run 24/7 for automated testing. As a result,
    you are likely to experience higher than normal device failure and have to replace
    batteries or entire devices every year or two. Spacing out devices and keeping
    them well cooled will help with this.
  prefs: []
  type: TYPE_NORMAL
- en: WiFi interference/connectivity
  prefs: []
  type: TYPE_NORMAL
- en: WiFi networks, especially consumer-targeted WiFi routers, are not highly stable,
    especially with a large number of devices. Reducing the broadcast signal power
    of the WiFi routers and making sure they are on noncompeting network bands can
    reduce interference.
  prefs: []
  type: TYPE_NORMAL
- en: Cable routing
  prefs: []
  type: TYPE_NORMAL
- en: Running cables among all the devices and the USB hubs or computers can create
    a tangled mess. Besides being hard to maintain, this can also cause connectivity
    and charging issues. Make sure to remove all loops in the cables and use shielded
    cables and ferrite cores as necessary to reduce electromagnetic interference.
  prefs: []
  type: TYPE_NORMAL
- en: Device reliability
  prefs: []
  type: TYPE_NORMAL
- en: Running a device lab on consumer devices comes with the general risk that consumer
    devices are not reliable. Limiting automated test runs to a finite duration will
    help prevent tests from becoming blocked on nonresponsive devices. Between tests,
    some housekeeping to remove data and free memory will help with performance and
    reliability. Finally, the Android devices as well as the servers running them
    will need to be rebooted periodically.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Starting on a small scale with devices you already own is easy and can improve
    the ability to test across a range of devices and fire off automated tests in
    parallel. At a large scale, this is an effective solution to solving testing across
    the fragmented Android ecosystem, but comes with high up-front costs and ongoing
    support and maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: The next section talks about device labs that you can get started with today
    on a simple pay-as-you-go basis.
  prefs: []
  type: TYPE_NORMAL
- en: Mobile Pipelines in the Cloud
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the prospect of building your own device lab seems daunting, an easy and
    inexpensive way to get started with testing across a large range of devices is
    to use a device farm running on public cloud infrastructure. Mobile device clouds
    have the advantage of being easy to get started with and maintenance free for
    the end user. You simply select the devices you want to run tests on, and fire
    off either manual or automated tests of your application against a pool of devices.
  prefs: []
  type: TYPE_NORMAL
- en: Some mobile device clouds also support automated robot tests that will attempt
    to exercise all the visible UI elements of your application to identify performance
    or stability issues with your application. Once tests are run, you get a full
    report of any failures, device logs for debugging, and screenshots for tracing
    issues.
  prefs: []
  type: TYPE_NORMAL
- en: Many mobile device clouds are available, with some dating back to the feature
    phone era. However, the most popular and modern device clouds have ended up aligning
    with the top three cloud providers—Amazon, Google, and Microsoft. They all have
    sizable investments in mobile test infrastructure that you can try for a reasonable
    price and have a large range of emulated and real devices to test against.
  prefs: []
  type: TYPE_NORMAL
- en: AWS device farm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Amazon offers a mobile device cloud as part of its public cloud services. Using
    AWS Device Farm, you can run automated tests on a variety of real-world devices
    by using your AWS account.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps to create a new AWS Device Farm test are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Upload your APK file*: To start, upload your compiled APK file or choose from
    recently updated files.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Configure your test automation*: AWS Device Farm supports a variety of test
    frameworks, including Appium tests (written in Java, Python, Node.js, or Ruby),
    Calabash, Espresso, Robotium, or UI Automator. If you don’t have automated tests,
    AWS provides two robot app testers called Fuzz and Explorer.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Select devices to run on*: Pick the devices that you want to run your test
    on from a user-created pool of devices or the default pool of the five most popular
    devices, as shown in [Figure 9-10](#aws_device_farm_select_device).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Set up the device state*: To set up the device before starting the tests,
    you can specify data or other dependent apps to install, set the radio states
    (WiFi, Bluetooth, GPS, and NFC), change the GPS coordinates, change the locale,
    and set up a network profile.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Run your test*: Finally, you can run your test on the selected devices with
    a specified execution time-out of up to 150 minutes per device. If your tests
    execute more quickly, this can finish earlier, but this also sets a maximum cap
    on the cost of your test run.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Screenshot of creating a new run on the AWS Device Farm.](Images/dtjd_0910.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-10\. Selecting devices to run on in the AWS Device Farm wizard
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: AWS Device Farm offer a free quota for individual developers to get started
    with test automation, low per-minute pricing for additional device testing, and
    monthly plans to do parallel testing on multiple devices at once. All of these
    plans operate on a shared pool of devices, which at the time of writing included
    91 total devices, 54 of which were Android devices, as shown in [Figure 9-11](#aws_device_farm_list).
    However, most of these devices were highly available, indicating that they had
    a large number of identical devices to test against. This means that you are less
    likely to get blocked in a queue or have a device you need to test against become
    unavailable.
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of a table of devices.](Images/dtjd_0911.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-11\. List of available devices in the AWS Device Farm
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Finally, AWS Device Farm offers a couple of integrations to run automated tests.
    From within Android Studio, you can run tests on the AWS Device Farm by using
    its Gradle plug-in. If you want to launch AWS Device Farm tests from your continuous
    integration system, Amazon offers a Jenkins plug-in that you can use to start
    device tests right after your local build and test automation completes.
  prefs: []
  type: TYPE_NORMAL
- en: Google Firebase Test Lab
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After Google’s acquisition of Firebase, it has been continually expanding and
    improving the offering. Firebase Test Lab is its mobile device-testing platform
    that provides similar functionality to AWS Device Farm. To get started, Google
    offers a free quota for developers to run a limited number of tests per day. Beyond
    that, you can upgrade to a pay-as-you-go plan with a flat fee per device hour.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firebase Test Lab offers several ways you can fire off tests on the service:'
  prefs: []
  type: TYPE_NORMAL
- en: Android Studio
  prefs: []
  type: TYPE_NORMAL
- en: Firebase Test Lab is integrated in Android Studio and allows you to run tests
    in its mobile device cloud just as easily as you would on local devices.
  prefs: []
  type: TYPE_NORMAL
- en: Firebase Web UI
  prefs: []
  type: TYPE_NORMAL
- en: From the Firebase web console, you can upload your APK and will start by running
    your first app in an automated Robo test, as shown in [Figure 9-12](#firebase_test_lab_robo).
    In addition, you can run your own automated tests using Espresso, Robotium, or
    UI Automator. Game developers have the option to run an integrated game loop that
    simulates user scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Automated command-line scripts
  prefs: []
  type: TYPE_NORMAL
- en: You can easily integrate Firebase Test Lab into your CI system by using its
    command-line API. This allows you to integrate with Jenkins, CircleCI, JFrog Pipelines,
    or your favorite CI/CD system.
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of the Firebase web console testing an app.](Images/dtjd_0912.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-12\. Firebase web user interface running an automated Robo test
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: At the time of writing, Firebase Test Lab offered a larger collection of Android
    devices than AWS Device Farm, with 109 devices supported, as well as multiple
    API levels for popular devices. Given the tight integration with Google’s Android
    tooling and the generous free quota for individuals, this is an easy way to get
    your development team started building test automation.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft Visual Studio App Center
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Microsoft Visual Studio App Center, formerly Xamarin Test Cloud, offers the
    most impressive device list of any of the clouds, with 349 Android device types
    for you to run tests on, as shown in [Figure 9-13](#vs_app_center_devices). However,
    unlike AWS Device Farm and Firebase Test Lab, no free tier exists for developers
    to use the service. Microsoft does offer a 30-day trial on its service to use
    a single physical device to run tests, and paid plans where you pay by the number
    of concurrent devices you want to use, which makes sense for large enterprises.
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of the device list in VS App Center.](Images/dtjd_0913.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-13\. Visual Studio App Center device selection screen
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Visual Studio App Center also is missing some of the user-friendly features
    like a robot tester and simple test execution via the web console. Instead, it
    focuses on the command-line integration with the App Center CLI. From the App
    Center CLI, you can easily fire off automated tests using Appium, Calabash, Espresso,
    or XamarainUITest. Also, this makes integration with CI/CD tools straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, Visual Studio App Center wins on device coverage and has a clear focus
    on enterprise mobile device testing. However, for independent developers or smaller
    teams, it is less approachable and has higher up-front costs, but it will work
    well as you scale.
  prefs: []
  type: TYPE_NORMAL
- en: Planning a Device-Testing Strategy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you’ve seen the basics of setting up your own device lab and leveraging
    cloud infrastructure, you should have a better idea of how these map to your mobile
    device-testing needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are advantages of going with a cloud service:'
  prefs: []
  type: TYPE_NORMAL
- en: Low startup costs
  prefs: []
  type: TYPE_NORMAL
- en: Cloud plans often offer a limited number of free device tests for developers
    and utilization-based pricing for testing on devices. When starting out with device
    testing, this is the easiest and least costly way to begin exploring manual and
    automated device testing.
  prefs: []
  type: TYPE_NORMAL
- en: Large selection of devices
  prefs: []
  type: TYPE_NORMAL
- en: Since cloud testing providers support a large installed base of customers, they
    have a huge inventory of current and legacy phones to test against. This makes
    it possible to precisely target the device types, profiles, and configurations
    that your users are most likely to have.
  prefs: []
  type: TYPE_NORMAL
- en: Fast scale-out
  prefs: []
  type: TYPE_NORMAL
- en: App development is all about viral marketing and scaling quickly. Rather than
    investing in costly infrastructure up front, cloud services allow you to scale
    up the testing as the size and popularity of your application requires a larger
    device test matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Reduced capital expenditures
  prefs: []
  type: TYPE_NORMAL
- en: Building a large device lab is a costly up-front capital expenditure. By paying
    as you go for cloud infrastructure, you can delay the costs, maximizing your capital
    efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: Global access
  prefs: []
  type: TYPE_NORMAL
- en: With remote and distributed teams becoming the norm, clouds by design allow
    for easy access from your entire team, no matter where they are located.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, even given all of these benefits, the traditional approach of building
    a device lab has unique advantages. Here are some reasons you may want to build
    your own device lab:'
  prefs: []
  type: TYPE_NORMAL
- en: Reduced cost at scale
  prefs: []
  type: TYPE_NORMAL
- en: The total cost of ownership for a device lab that you run and maintain at scale
    is much lower than the total monthly costs from a cloud provider over the device’s
    usable lifetime. For a small team, this threshold is hard to hit, but if you are
    a large mobile corporation, this can be significant savings.
  prefs: []
  type: TYPE_NORMAL
- en: Fast and predictable cycle time
  prefs: []
  type: TYPE_NORMAL
- en: With control over the device farm, you can guarantee that the tests will run
    in parallel and complete in a predictable time frame to enable responsive builds.
    Cloud providers have limited device availability and queued wait times for popular
    configurations that can limit your ability to iterate quickly.
  prefs: []
  type: TYPE_NORMAL
- en: No session limits
  prefs: []
  type: TYPE_NORMAL
- en: Device clouds typically put hardcoded session limits on their service to prevent
    tests from hanging because of test or device failure. As the complexity of your
    test suite grows, a 30-minute hard limit can become an obstacle to completing
    testing of a complex user flow.
  prefs: []
  type: TYPE_NORMAL
- en: Regulatory requirements
  prefs: []
  type: TYPE_NORMAL
- en: In certain regulated industries such as finance and defense, security requirements
    can restrict or prohibit the ability to deploy applications and execute tests
    outside the corporate firewall. This class of corporations would require an on-premises
    device lab setup.
  prefs: []
  type: TYPE_NORMAL
- en: IoT device integration
  prefs: []
  type: TYPE_NORMAL
- en: If your use case requires the integration of mobile devices with IoT devices
    and sensors, this is not a configuration that cloud providers would provide as
    a service out of the box. You are probably better off creating a device lab with
    the IoT and mobile configuration that best matches your real-world scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In some scenarios, it also makes sense to do a mix of both cloud testing and
    local device lab testing. Based on your specific requirements for cycle time,
    maintenance cost, device scale-out, and regulatory requirements, this can allow
    you to get the best of both approaches to testing.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Android is the most popular mobile platform on the planet, because of its huge
    ecosystem of manufacturers and application developers. However, this is also the
    challenge with Android development: an incredibly fragmented device market with
    thousands of manufacturers producing tens of thousands of devices. Given this
    scale of fragmentation and device inconsistency, having a fully automated DevOps
    pipeline for mobile development is a necessity for success.'
  prefs: []
  type: TYPE_NORMAL
- en: The equivalent to DevOps for web application development would be if, instead
    of three major browsers, there were thousands of unique browser types. You would
    be forced to automate to obtain any level of quality assurance, which is exactly
    why there is so much focus in the mobile space on UI test automation running on
    real devices.
  prefs: []
  type: TYPE_NORMAL
- en: Using the tools and techniques you learned in this chapter, paired with the
    overall DevOps knowledge on source control, build promotion, and security, you
    should be ahead of your mobile DevOps peers to face the challenge of continuous
    deployments to millions of devices globally.
  prefs: []
  type: TYPE_NORMAL
