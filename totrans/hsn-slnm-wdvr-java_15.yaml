- en: Appendix B. Driver Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As discussed in [Chapter 1](ch01.html#ch01), driver management involves three
    steps: download, setup, and maintenance. Manual driver management is costly in
    terms of effort and potentially problematic regarding maintainability. For this
    reason, I use WebDriverManager to carry out this process in an automated and automaintained
    manner in all the examples of this book. For completeness, this appendix also
    describes the involved steps (download, setup, and maintenance) in manual driver
    management.'
  prefs: []
  type: TYPE_NORMAL
- en: 'WebDriverManager: Automated Driver Management'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[WebDriverManager](https://bonigarcia.dev/webdrivermanager) is an open source
    Java library that manages the drivers required by Selenium WebDriver (e.g., chromedriver,
    geckodriver, msedgedriver, etc.) in an automated manner. WebDriverManager provides
    a set of *managers* for different browsers, namely Chrome, Firefox, Edge, Opera,
    Chromium, and Internet Explorer.'
  prefs: []
  type: TYPE_NORMAL
- en: WebDriverManager internally executes a *resolution algorithm* to manage the
    drivers required by each browser. This algorithm aims to automatically discover,
    download, set up, and maintain these drivers.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure B-1](#wdm-algorithm) represents this algorithm in the context of the
    methodology implemented by WebDriverManager. For each manager (e.g., `chromedriver()`,
    `firefoxdriver()`, etc.), the resolution algorithm works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: WebDriverManager tries to find the browser version (e.g., Chrome) installed
    in the local machine. For that, it uses an internal knowledge database called
    *commands database*. This database contains a list of shell commands (in different
    operating systems) that allow discovering the browser versions (e.g., `google-chrome
    --version` in Linux).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the found major browser version (e.g., Chrome 89), WebDriverManager determines
    the correct driver version (e.g., chromedriver 89.0.4389.23). I call this process
    *version resolution*. To ease this process, several driver maintainers (i.e.,
    chromedriver and msedgedriver) publish the specific driver version in their online
    repositories using simple text files (e.g., *https://chromedriver.storage.googleapis.com/LATEST_RELEASE_89*).
    Unfortunately, this information is not available for other drivers, such as geckodriver
    or operadriver. For this reason, WebDriverManager uses another internal knowledge
    database (called *versions database*) to keep the association between the versions
    of browsers and drivers. Both versions and commands databases synchronize their
    values using an online master reference stored on GitHub.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: WebDriverManager downloads the specific driver for the local operating system
    (Windows, Linux, or macOS) and stores it in the local file system in the *driver
    cache* (by default, in the path `~/.cache/selenium`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, WebDriverManager exports the downloaded driver path using the proper
    Java system property (e.g., `webdriver.chrome.driver`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the sake of performance and maintainability, WebDriverManager internally
    uses a *resolution cache*. This cache (by default stored in the driver cache as
    a properties file) keeps the relationship between the resolved driver versions.
    This relationship is valid following a *time-to-live* (TTL) approach. The default
    value of this TTL is one day for drivers (e.g., chromedriver 89.0.4389.23) and
    one hour for browsers (e.g., Chrome 89). The resolution algorithm resolves drivers
    using the cached files in the subsequent invocations (this usually happens in
    a Selenium WebDriver test suite). Then, when a TTL expires, the resolution algorithm
    tries to resolve a new driver release. Finally, when a different browser version
    is detected, WebDriverManager downloads the new driver (if required). Thanks to
    this process, the version compliance of browser and driver is guaranteed even
    for evergreen browsers.
  prefs: []
  type: TYPE_NORMAL
- en: '![hosw ab01](assets/hosw_ab01.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure B-1\. WebDriverManager methodology
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Generic Manager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to the browser-specific managers (e.g., `chromedriver()`, `firefoxdriver()`,
    etc.), WebDriverManager provides a *generic* manager, i.e., a manager that can
    be parameterized to act as a specific manager (for Chrome, Firefox, etc.). This
    feature is available using the method `getInstance()` of the WebDriverManager
    API. There are different options to invoke this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getInstance(Class<? extends WebDriver> webDriverClass)`'
  prefs: []
  type: TYPE_NORMAL
- en: Where `webDriverClass` is a class of the `WebDriver` hierarchy, such as `ChromeDriver.class`,
    `FirefoxDriver.class`, etc.
  prefs: []
  type: TYPE_NORMAL
- en: '`getInstance(DriverManagerType driverManagerType)`'
  prefs: []
  type: TYPE_NORMAL
- en: Where `driverManagerType` is an enumeration provided by WebDriverManager to
    identify the available managers. The possible values of this enumeration are `CHROME`,
    `FIREFOX`, `EDGE`, `OPERA`, `CHROMIUM`, `IEXPLORER`, and `SAFARI`.
  prefs: []
  type: TYPE_NORMAL
- en: '`getInstance(String browserName)`'
  prefs: []
  type: TYPE_NORMAL
- en: Where `browserName` is the browser name as case-insensitive string. The possible
    values are `Chrome`, `Firefox`, `Edge`, `Opera`, `Chromium`, `IExplorer`, and
    `Safari`.
  prefs: []
  type: TYPE_NORMAL
- en: '`getInstance()`'
  prefs: []
  type: TYPE_NORMAL
- en: When no parameter is specified, the configuration key `wdm.defaultBrowser` is
    used to select the manager (Chrome by default).
  prefs: []
  type: TYPE_NORMAL
- en: Advanced Configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'WebDriverManager provides different ways of configuration. First, you can use
    its Java API through each manager. This API allows concatenating several methods
    to specify custom options or preferences. You can find the complete description
    of the WebDriverManager API in its [documentation](https://bonigarcia.dev/webdrivermanager).
    For example, the following command shows how to set up a proxy for the network
    connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The second way to configure WebDriverManager is using Java system properties.
    Each WebDriverManager API method has an equivalent configuration key. For instance,
    the API method `cachePath()` (used to specify the driver cache folder) works the
    same way as the configuration key `wdm.cachePath`. These types of configuration
    keys can be passed, for example, using the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Finally, you can also use environment variables to configure WebDriverManager.
    The variable names derive from each configuration key (e.g., `wdm.cachePath`),
    converting them to uppercase and replacing the symbol `.` with `_` (e.g., `WDM_CACHEPATH`).
    This mechanism can be convenient for configuring global parameters at the operating
    system level.
  prefs: []
  type: TYPE_NORMAL
- en: Other Uses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to serving as a Java dependency, WebDriverManager can be used in
    other ways, namely:'
  prefs: []
  type: TYPE_NORMAL
- en: As a command-line interface (CLI) tool
  prefs: []
  type: TYPE_NORMAL
- en: This mode allows you to resolve drivers (e.g., chromedriver, geckodriver). In
    addition, this mode allows you to execute browsers in Docker containers and interact
    with them through a remote desktop session.
  prefs: []
  type: TYPE_NORMAL
- en: As a server
  prefs: []
  type: TYPE_NORMAL
- en: The WebDriverManager Server is based on HTTP and offers two types of services.
    First, it exposes a simple RESTlike API to resolve drivers. Second, it acts as
    a regular Selenium Server, and therefore, you can use it with different language
    bindings than Java.
  prefs: []
  type: TYPE_NORMAL
- en: As a Java agent
  prefs: []
  type: TYPE_NORMAL
- en: In this case, and using the JVM instrumentation API, WebDriverManager uses the
    Java instrumentation API to check the objects being created in the JVM. When WebDriver
    objects are instantiated (`ChromeDriver`, `FirefoxDriver`, etc.), the required
    manager is used to resolve its driver (`chromedriver`, `geckodriver`, etc.). Thanks
    to this approach, you can get rid of the WebDriverManager call from your tests.
  prefs: []
  type: TYPE_NORMAL
- en: Manual Driver Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section describes how to manually implement the driver management process
    (download, setup, and maintenance).
  prefs: []
  type: TYPE_NORMAL
- en: Download
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first step for driver management is to download the proper driver. [Table B-1](#driver_websites)
    shows the websites to obtain the drivers for the main browsers. You need to find
    the correct driver version and platform (Windows, Linux, macOS) for the browser
    you plan to use. Regarding the version, the Chrome and Edge (although not Firefox,
    unfortunately) maintainers follow the same versioning schema for drivers and browsers
    to ease this process. So, for instance, if you use Chrome or Edge 91.x, you also
    need to use chromedriver and msedgedriver 91.x. You will find the specific driver
    version in the documentation provided on the websites. For instance, to use Chrome
    91, you need to download ChromeDriver 91.0.4472.19.
  prefs: []
  type: TYPE_NORMAL
- en: Table B-1\. Java system properties to set up drivers
  prefs: []
  type: TYPE_NORMAL
- en: '| Browser | Driver | Download website |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Chrome/Chromium | chromedriver | [*https://chromedriver.chromium.org/downloads*](https://chromedriver.chromium.org/downloads)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Edge | msedgedriver | [*https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver*](https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Firefox | geckodriver | [*https://github.com/mozilla/geckodriver/releases*](https://github.com/mozilla/geckodriver/releases)
    |'
  prefs: []
  type: TYPE_TB
- en: Setup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once you have the required driver for your WebDriver script, you need to set
    it up correctly. There are two ways to carry out this process. The first one is
    adding the driver location (the full path or the parent folder that contains the
    driver) to your `PATH` environmental variable (*env*). The `PATH` env is standard
    in Unix-like (e.g., Linux and macOS) and Windows operating systems. This environmental
    variable allows specifying a set of folders where the operating system locates
    executable programs. The way we configure `PATH` (and other environmental variables)
    depends on the specific operating system. For example, in Windows systems, we
    can do it using its GUI (Control Panel → System → Advanced → Environment Variables).
    In a Unix-like system, we can use the command line to carry out this process,
    for instance, using the following command (or equivalent):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The second way to set up the driver is using *Java system properties*, which
    are configuration attributes (in the form of name/value) passed to the JVM. [Table B-2](#system_props)
    summarizes the names for the main drivers in Selenium WebDriver. The value for
    these properties is the full path of a given driver (e.g., `/path/to/drivers/chromedriver`).
  prefs: []
  type: TYPE_NORMAL
- en: Table B-2\. Java system properties to set up drivers
  prefs: []
  type: TYPE_NORMAL
- en: '| Browser | Driver | Java system property name |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Chrome/Chromium | chromedriver | `webdriver.chrome.driver` |'
  prefs: []
  type: TYPE_TB
- en: '| Edge | msedgedriver | `webdriver.edge.driver` |'
  prefs: []
  type: TYPE_TB
- en: '| Firefox | geckodriver | `webdriver.gecko.driver` |'
  prefs: []
  type: TYPE_TB
- en: 'There are two ways to configure these properties: the command line (passing
    the system property using the `-Dname=value` syntax) or Java code. For example,
    [Example B-1](#shell_props) shows the Maven and Gradle commands to execute all
    the tests of a given project while passing the properties to set up the drivers
    for Chrome, Edge, and Firefox. Then, [Example B-2](#java_props) shows how to make
    the same configuration, but this time using Java.'
  prefs: []
  type: TYPE_NORMAL
- en: Example B-1\. Maven and Gradle commands to configure system properties in the
    command line
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Example B-2\. Java commands to configure system properties
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Maintenance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Last but not least, the final step of driver management is to maintain these
    drivers. This maintenance is necessary because evergreen browsers (such as Chrome,
    Edge, or Firefox) upgrade themselves automatically. Although appealing from a
    user perspective, this automated upgrade is problematic for Selenium WebDriver
    scripts where the driver management is manual. In this case, driver and browser
    compatibility is not guaranteed in the long run.
  prefs: []
  type: TYPE_NORMAL
- en: 'A specific driver (e.g., chromedriver version 84.0.4147.30) is typically compatible
    with a given browser version (e.g., Chrome 84). Eventually, this compatibility
    is not guaranteed because of the automatic upgrade. As a result, a Selenium WebDriver
    script based on this driver stops working (i.e., the test is said to be broken).
    In practice, Selenium WebDriver developers experience this problem when tests
    fail because of driver and browser incompatibility. For instance, when using Chrome
    as a browser, a broken test due to driver incompatibility reports the following
    error message: “this version of chromedriver only supports Chrome version N” (where
    N is the latest version of Chrome supported by a particular version of chromedriver).
    To illustrate this problem, [Figure B-2](#google-trends) shows the worldwide search
    interest of that error message on Google during 2019 and 2020, together with the
    release date of the different Chrome versions in this period. As you can see,
    the interest over time concerning this error message is related to some Chrome
    releases.'
  prefs: []
  type: TYPE_NORMAL
- en: '![hosw ab02](assets/hosw_ab02.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure B-2\. Worldwide relative interest over time of the search term “this
    version of chromedriver only supports chrome version” in Google Trends together
    with the release dates of Chrome during 2019 and 2020
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Selenium WebDriver is a library that allows you to control web browsers programmatically.
    The automation is based on the native capabilities of each browser. Therefore,
    we need to place a platform-dependent binary file called *driver* between the
    script/test using the Selenium WebDriver API and the browser. Some examples of
    drivers are chromedriver (for Chrome), geckodriver (for Firefox), and msedgedriver
    (for Edge). This appendix presented the driver management process. This process
    has three steps (download, setup, and maintenance), and it can be done either
    manually or automatically. By default, I recommend you use an automated driver
    management approach. To that aim, the reference tool in Java is WebDriverManager.
  prefs: []
  type: TYPE_NORMAL
