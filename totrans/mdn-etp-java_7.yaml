- en: 'Chapter 7\. Tomorrow’s Solutions: Serverless'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。明日的解决方案：无服务器
- en: The second industrial revolution, unlike the first, does not present us with
    such crushing images as rolling mills and molten steel, but with “bits” in a flow
    of information traveling along with circuits in the form of electronic impulses.
    The iron machines still exist, but they obey the orders of weightless bits.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第二次工业革命与第一次不同，没有给我们带来滚动的钢铁和熔化的金属的令人压抑的景象，而是“位”在信息流中传输，沿着电路以电子脉冲的形式。铁器仍然存在，但它们服从于无重量位的命令。
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Italo Calvino
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 伊塔洛·卡尔维诺
- en: The serverless computing model has great momentum with public cloud offerings,
    and recently also within the open source community thanks to many projects that
    enable it for any platform. But, what is serverless, exactly? What are some use
    cases for serverless? And, how can it be used for modern Java applications?
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器计算模型在公共云提供的强大推动下，最近也在开源社区内因许多项目的支持而受到关注。但究竟什么是无服务器？无服务器有哪些用例？它如何用于现代Java应用？
- en: What Is Serverless?
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是无服务器？
- en: 'The best definition of serverless comes from the [CNCF Serverless Whitepaper](https://oreil.ly/yYbmP):'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器的最佳定义来自[CNCF无服务器白皮书](https://oreil.ly/yYbmP)：
- en: Serverless computing refers to the concept of building and running applications
    that do not require server management. It describes a finer-grained deployment
    model where applications, bundled as one or more functions, are uploaded to a
    platform and then executed, scaled, and billed in response to the exact demand
    needed at the moment.
  id: totrans-7
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 无服务器计算是指构建和运行不需要服务器管理的应用程序的概念。它描述了一种更细粒度的部署模型，其中应用程序作为一个或多个函数捆绑上传到平台，然后根据实际需求在响应时执行、扩展和计费。
- en: Running an application that “does not require server management” is the most
    relevant part of that definition. In the previous chapters, we explored how Kubernetes
    helps with functional requirements for modern architectures, and how container
    images represent a convenient way to package and ship applications to any cloud
    platform. There are still servers in serverless, however, they are abstracted
    away from app development. While a third party handles the complexity of maintaining
    and managing such servers, developers can simply package their code in containers
    for deployment.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 运行一个“不需要服务器管理”的应用程序是该定义中最相关的部分。在前几章中，我们探讨了Kubernetes如何帮助现代架构的功能要求，以及容器镜像如何代表一种方便的方式将应用程序打包并部署到任何云平台。在无服务器中仍然有服务器，但它们被抽象出来，与应用开发无关。虽然第三方负责维护和管理这些服务器的复杂性，开发人员只需将他们的代码打包到容器中进行部署。
- en: The main differentiator between the deployment model that we discussed in Kubernetes
    and the serverless model is the so-called *scale-to-zero* approach. With this
    approach, an application is automatically launched on demand when called, and
    idle when not used. This execution model is also called event-driven, and it is
    the core foundation of serverless. We discuss event-driven serverless architectures
    later in this chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论的部署模型在Kubernetes和无服务器模型之间的主要区别是所谓的*零扩展*方法。通过这种方法，应用程序在被调用时自动启动，并在不使用时处于空闲状态。这种执行模型也称为事件驱动，是无服务器的核心基础。我们稍后在本章讨论事件驱动的无服务器架构。
- en: Typically, a series of events can trigger the launch of the application, which
    will produce an outcome, as you can see in [Figure 7-1](#fig7-1). This can be
    a single action or a chain of actions where the output of one app is the input
    of the subsequent app. The event can be anything, such as an HTTP request, a Kafka
    message, or a database transaction. The application can be autoscaled to multiple
    replicas proportional to the needed amount to handle the traffic load, and then
    scaled down when there isn’t any activity.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一系列事件可以触发应用程序的启动，这将产生结果，正如您在[图7-1](#fig7-1)中所见。这可以是单个操作，也可以是一系列操作，其中一个应用程序的输出是下一个应用程序的输入。事件可以是任何形式，例如HTTP请求、Kafka消息或数据库事务。应用程序可以按需自动扩展到多个副本，以处理流量负载，当没有活动时则会缩减规模。
- en: '![Serverless execution model](Images/moej_0701.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![无服务器执行模型](Images/moej_0701.png)'
- en: Figure 7-1\. Serverless execution model
  id: totrans-12
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-1。无服务器执行模型
- en: Architectural Evolution
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 架构演进
- en: The serverless model is not good for all use cases. In general, any asynchronous,
    concurrent, easy-to-parallelize-into-independent-units-of-work application is
    a good fit for this model. If you look at the diagram in [Figure 7-2](#fig7-2),
    you can see how the microservices-based architectures evolution started from a
    monolithic applications approach using the service-oriented architectures (SOA)
    model, and it is now evolving again into a new model of *functions*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器模型并不适用于所有使用案例。一般来说，任何异步、并发、易于并行化为独立工作单元的应用程序都非常适合这种模型。如果您查看 [图 7-2](#fig7-2)
    中的图表，您可以看到基于微服务的架构演变始于使用面向服务的体系结构（SOA）模型的单片应用程序方法，现在正在演变为一个新的*函数*模型。
- en: '![Architectural evolution](Images/moej_0702.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![架构演变](Images/moej_0702.png)'
- en: Figure 7-2\. Architectural evolution
  id: totrans-16
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-2\. 架构演变
- en: 'These functions represent a minimal computing unit that accomplishes a specific
    scope or task. Examples are:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数代表了完成特定范围或任务的最小计算单元。例如：
- en: Processing web hooks
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理 Web 钩子
- en: Data transformation (image, video)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据转换（图像、视频）
- en: PDF generation
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PDF 生成
- en: Single-page apps for mobile devices
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动设备的单页应用程序
- en: Chatbots
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聊天机器人
- en: With this approach, you can focus on convenience, as it is generally offered
    as *best-effort*. Failures are tolerated, and short actions are preferred. That’s
    why the serverless model is not good for use cases such as real-time applications,
    long-running tasks, or contexts where reliability and/or atomicity are key. It’s
    up to the developer to take care of verifying that inputs and outputs have been
    successfully processed by any serverless function involved. This gives great flexibility
    and high scalability to at least some part of the overall architecture.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，您可以专注于方便性，因为它通常作为*尽力而为*提供。容忍失败，并优先短期操作。这就是为什么无服务器模型不适合实时应用程序、长时间运行的任务或可靠性和/或原子性关键的使用案例。开发者需要负责验证所有涉及的无服务器函数是否成功处理了输入和输出。这为整体架构的某些部分提供了极大的灵活性和高可扩展性。
- en: 'Use Cases: Data, AI, and Machine Learning'
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用案例：数据、人工智能和机器学习
- en: The serverless model helps avoid common headaches for capacity planning for
    projects, as it mitigates overprovisioning and underprovisioning, thereby reducing
    the IT cost of idle resources. With serverless, all of the resources consumed
    are tailored to the actual usage as the applications start only when invoked,
    and there’s no need to preallocate or measure-and-update hardware resources.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器模型有助于避免项目容量规划中的常见问题，因为它减少了过度配置和不足配置，从而降低了闲置资源的IT成本。通过无服务器，所有消耗的资源都是根据实际使用量定制的，因为应用程序仅在被调用时启动，无需预先分配或测量和更新硬件资源。
- en: This is very important when you have to analyze in real time a large amount
    of data, and that’s why serverless is gaining lots of attention from data scientists
    and ML experts, as the functions that can process data for analysis are flexible
    and leave a minimal footprint. On the other hand, serverless doesn’t pair well
    with all of the design principles of existing ML frameworks. A certain amount
    of tolerance is also required, in particular for processes that may take longer
    such as model training.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要实时分析大量数据时，这一点非常重要，这也是为什么无服务器模型在数据科学家和机器学习专家中引起了极大关注，因为能够处理分析数据的函数灵活且占用资源极少。另一方面，无服务器与现有机器学习框架的所有设计原则并不完全匹配。需要一定的容忍度，特别是对于可能需要更长时间（例如模型训练）的过程。
- en: If you look at [Figure 7-3](#fig7-3), you will see an example of a serverless-driven
    architecture for machine learning for classification and prediction. The process
    starts with a trigger to get an inference of a group of objects from a trained
    model. This starts a sequence of asynchronous functions that run in parallel,
    used to predict the class of the object based on its characteristics and return
    the classification as output. The tolerance we expect is that one of these functions
    may fail or not complete the task in time. However, those are all independent
    workloads. It’s important to have workloads that can run in parallel without a
    specific order so any failure to a single function is not affecting the whole
    system. In addition, the autoscaling component of the serverless architecture
    will make sure that any high data load will be processed faster on demand than
    with traditional approaches.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看[图7-3](#fig7-3)，您将看到一个基于无服务器驱动的机器学习分类和预测架构的示例。该过程从触发器开始，以从经过训练的模型中获取一组对象的推断。这启动了一系列并行运行的异步函数，用于基于其特征预测对象的类别并返回分类作为输出。我们期望的容忍度是这些函数中的一个可能会失败或无法及时完成任务。但这些都是独立的工作负载。重要的是要有可以并行运行的工作负载，无需特定顺序，因此单个功能的任何失败不会影响整个系统。此外，无服务器架构的自动缩放组件将确保任何高数据负载将比传统方法更快地按需处理。
- en: '![Machine learning with serverless](Images/moej_0703.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![使用无服务器进行机器学习](Images/moej_0703.png)'
- en: Figure 7-3\. Machine Learning with serverless
  id: totrans-29
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-3\. 使用无服务器进行机器学习
- en: 'Use Cases: Edge Computing and IoT'
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用案例：边缘计算和IoT
- en: Edge and IoT devices are everywhere. From vocal assistants to home automation,
    nowadays nearly every item in our house can be connected to the internet, talking
    to some controller application. As a developer, you may be responsible for either
    the backend logic or the device application logic.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 边缘和IoT设备无处不在。从语音助手到家庭自动化，如今我们家里几乎每件物品都可以连接到互联网，与某个控制应用程序进行通信。作为开发人员，您可能负责后端逻辑或设备应用程序逻辑的任何一部分。
- en: An example of this scenario for Java developers comes from the [Quarkus for
    IoT](https://oreil.ly/0Lmiu) project, which aims to collect pollution data from
    sensors with [Raspberry Pi devices](https://raspberrypi.org) using Quarkus and
    containers both on the device and the server-side backend. The latter is running
    a serverless application to provide on-demand high scalability of the huge amount
    of sensor data that may come in some bursty way.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Java开发人员的一个示例情景来自于[用于IoT的Quarkus](https://oreil.ly/0Lmiu)项目，该项目旨在使用Quarkus和容器在设备和服务器端后端上收集传感器的污染数据，后者正在运行一个无服务器应用程序，以提供对大量传感器数据的按需高可扩展性处理，可能以突发方式传入。
- en: The project also offers a very good reference on how IoT architectures should
    be implemented on top of Red Hat OpenShift, as shown in [Figure 7-4](#fig7-4).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目还提供了如何在Red Hat OpenShift上实现IoT架构的很好参考，如[图7-4](#fig7-4)所示。
- en: '![Quarkus for IoT project architecture](Images/moej_0704.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![用于IoT项目的Quarkus架构](Images/moej_0704.png)'
- en: Figure 7-4\. Quarkus for IoT project architecture
  id: totrans-35
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-4\. 用于IoT项目的Quarkus架构
- en: Serverless is used to scale up Quarkus microservices from device messages using
    the MQTT protocol for data ingestion, with Kafka streams used in the architecture
    as well as for data collectors. This makes the architecture complete and reliable,
    but also cost-efficient as there’s no allocation of resources until they are needed.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器用于使用MQTT协议进行数据摄入的Quarkus微服务的扩展，使用Kafka流作为架构和数据收集器。这使得架构既完整又可靠，同时由于没有资源的分配直到需要时才会成本效益。
- en: 'Knative: Serverless for Kubernetes'
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Knative：Kubernetes的无服务器
- en: Serverless can be considered the engine of functions as a service (FaaS), which
    is a more convenient way for developers to package and deploy apps. Often, particularly
    with public clouds, serverless and FaaS fit together, since packaging apps in
    containers is also automated. However, a scale-to-zero app is not necessarily
    a function. As we discussed, serverless is not just a prerogative of public clouds.
    For instance, anyone can also adopt this model on any Kubernetes cluster thanks
    to an open source project called [Knative](https://knative.dev).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器可以被认为是函数即服务（FaaS）的引擎，这是开发人员更方便地打包和部署应用程序的一种方式。通常情况下，特别是在公共云中，无服务器和FaaS是匹配的，因为将应用程序打包到容器中也是自动化的。然而，零级扩展的应用程序不一定是一个函数。正如我们讨论的，无服务器不仅仅是公共云的专利。例如，任何人也可以通过一个名为[Knative](https://knative.dev)的开源项目在任何Kubernetes集群上采用这种模型。
- en: Note
  id: totrans-39
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: We will discuss FaaS in more detail later in this chapter.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后将在本章中更详细地讨论 FaaS。
- en: Knative enables serverless on Kubernetes, supporting event-driven scale-to-zero
    applications. It provides a higher level of abstraction for common app use cases.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Knative 在 Kubernetes 上实现了无服务器，支持面向事件驱动的规模缩减至零的应用程序。它为常见应用用例提供了更高级别的抽象。
- en: Tip
  id: totrans-42
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Knative can easily be installed on Kubernetes through an Operator from [OperatorHub.io](https://oreil.ly/ni1wkr).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Knative 可通过来自 [OperatorHub.io](https://oreil.ly/ni1wkr) 的运算符轻松安装到 Kubernetes
    上。
- en: 'There are two main components in Knative:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Knative 有两个主要组件：
- en: Knative Serving
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Knative 服务
- en: Takes care of scale-to-zero, creating all Kubernetes resources needed (e.g.,
    Pod, Deployment, Service, Ingress)
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 处理规模缩减至零，创建所有 Kubernetes 资源所需的操作（例如 Pod、Deployment、Service、Ingress）
- en: Knative Eventing
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Knative 事件
- en: A subscription, delivery, and management component for handling events on-cluster
    and off-cluster (e.g., Kafka messages, external services)
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 处理集群内外事件（例如 Kafka 消息、外部服务）的订阅、传递和管理组件
- en: It’s easy to make an app serverless in Kubernetes with Knative. An example of
    a Knative Service for the Inventory Quarkus microservice that you created in [Chapter 2](ch02.xhtml#changing_technologies)
    follows.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Knative 在 Kubernetes 上轻松实现无服务器应用程序。以下是您在[第 2 章](ch02.xhtml#changing_technologies)中创建的
    Inventory Quarkus 微服务的 Knative 服务示例。
- en: 'You can also find the example in this [book’s GitHub repository](https://oreil.ly/kyQfu):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在本[书籍的 GitHub 存储库](https://oreil.ly/kyQfu)中找到示例：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[![1](Images/1.png)](#co_tomorrow_s_solutions__serverless_CO1-1)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_tomorrow_s_solutions__serverless_CO1-1)'
- en: This is the definition of Knative Service, a Custom Resource representing a
    serverless workload on Kubernetes.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Knative 服务的定义，它是 Kubernetes 上表示无服务器工作负载的自定义资源。
- en: '[![2](Images/2.png)](#co_tomorrow_s_solutions__serverless_CO1-2)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_tomorrow_s_solutions__serverless_CO1-2)'
- en: It is using the same container image we used for the Deployment object. With
    Knative Service, a Deployment and a Service are automatically created for you.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用我们为 Deployment 对象使用的相同容器映像。使用 Knative 服务时，将为您自动创建一个 Deployment 和一个 Service。
- en: 'To create a serverless version for the Inventory microservice, you can create
    a Knative Service object with the following command:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要为 Inventory 微服务创建一个无服务器版本，您可以使用以下命令创建一个 Knative 服务对象：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-58
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Knative also provides a convenient CLI called `kn` to create Knative Services
    and manage all Knative serverless components. You can find more info about it
    in the [official documentation](https://oreil.ly/vDtU2).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Knative 还提供了一个方便的 CLI，称为 `kn`，用于创建 Knative 服务和管理所有 Knative 无服务器组件。您可以在[官方文档](https://oreil.ly/vDtU2)中找到更多信息。
- en: 'Immediately, you can verify that a new Knative Service has been created with
    this command:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 立即，您可以使用以下命令验证是否已创建新的 Knative 服务：
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You should get output similar to the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该获得类似以下的输出：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As you can see, all of the Kubernetes manifests, such as Pod, Deployment, and
    Service, have been created automatically from the Knative Service. There’s no
    need to maintain them in this case, since you can rely on a single object that
    controls deployment and networking:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，所有 Kubernetes 清单（如 Pod、Deployment 和 Service）都已从 Knative 服务自动创建。在这种情况下，无需维护它们，因为您可以依赖一个控制部署和网络的单个对象：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Under the hood, the traffic to a Knative Service is routed into the cluster
    through the Knative networking. Invoking the Inventory microservice will also
    trigger the Pod creation if the application is idling:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，对 Knative 服务的流量通过 Knative 网络路由到集群中。调用 Inventory 微服务也将触发 Pod 创建，如果应用程序处于空闲状态：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You should get output similar to the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该获得类似以下的输出：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After a certain amount of time with no new requests, the scale-to-zero model
    applies and the Pod number is scaled down to zero:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在一段时间没有新请求后，将应用规模缩减至零模型，并将 Pod 数量缩减至零：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Event-Driven Serverless Architectures
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向事件驱动的无服务器架构
- en: Events are everywhere. As we discussed in the previous section, an HTTP request
    can trigger the start of an application that can be idling when not used, which
    is consistent with the serverless execution model represented in [Figure 7-1](#fig7-1).
    But there are plenty of events out there, such as a Kafka message, a database
    stream, or any event from Kubernetes, that an application may want to subscribe
    to.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 事件无处不在。正如我们在上一节中讨论的那样，一个 HTTP 请求可以触发一个应用程序的启动，在不使用时可能处于空闲状态，这与[图 7-1](#fig7-1)中表示的无服务器执行模型一致。但是，有很多事件存在，比如
    Kafka 消息、数据库流或来自 Kubernetes 的任何事件，一个应用程序可能希望订阅这些事件。
- en: A popular pattern in this scenario is the [publish-subscribe messaging pattern](https://oreil.ly/ThcHL)
    where many senders can send messages to an entity on the server, often called
    a topic, and receivers can subscribe to said topic to get messages. According
    to the serverless model, your application can be registered and connected to process
    incoming events. One example for Kubernetes is the [Knative Eventing](https://oreil.ly/NF2gB)
    component, which implements [CloudEvents](https://cloudevents.io), a specification
    for describing event data from multiple protocols and formats (such as Kafka,
    AMQP, and MQTT) [in a common way](https://oreil.ly/oGI1q).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下的一种流行模式是[发布-订阅消息传递模式](https://oreil.ly/ThcHL)，其中许多发送方可以向服务器上的一个实体发送消息，通常称为主题，接收者可以订阅该主题以获取消息。根据无服务器模型，你的应用程序可以注册并连接以处理传入事件。Kubernetes
    的一个例子是[Knative Eventing](https://oreil.ly/NF2gB)组件，它实现了[CloudEvents](https://cloudevents.io)，这是一种描述多种协议和格式的事件数据
    (如 Kafka、AMQP 和 MQTT) [的通用方式](https://oreil.ly/oGI1q)的规范。
- en: With Knative Eventing, event producers and event consumers are independent.
    A Knative Service is triggered by a source of events through a broker, as you
    can see in [Figure 7-5](#fig7-5). The goal of the eventing framework is to decouple
    everything. The sender doesn’t directly call the subscriber or even know how many
    subscribers there are. Instead, brokers and triggers handle the communication.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Knative Eventing，事件生产者和事件消费者是独立的。Knative 服务通过经纪人触发事件源，正如你可以在[图 7-5](#fig7-5)中看到的那样。事件框架的目标是解耦一切。发送方不直接调用订阅者，甚至不知道有多少个订阅者。而是经纪人和触发器处理通信。
- en: '![Knative eventing architecture](Images/moej_0705.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![Knative 事件架构](Images/moej_0705.png)'
- en: Figure 7-5\. Knative Eventing architecture
  id: totrans-78
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-5\. Knative Eventing 架构
- en: Rather than relying on the inbound request cascading through all the microservices,
    you could use an arbitrary HTTP event as an example of an event to wake up the
    Inventory service.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 与依赖于入站请求级联通过所有微服务不同，你可以使用任意 HTTP 事件作为唤醒 Inventory 服务的示例事件。
- en: 'First, we need to create a Knative Broker. An example of a Knative Broker for
    the Inventory Quarkus microservice that we created in [Chapter 2](ch02.xhtml#changing_technologies)
    is listed below, which you can also find in this [book’s GitHub repository](https://oreil.ly/8Gwys):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个 Knative Broker。下面列出了我们在 [第二章](ch02.xhtml#changing_technologies)
    中创建的 Inventory Quarkus 微服务的 Knative Broker 示例，你也可以在这本[书的 GitHub 仓库](https://oreil.ly/8Gwys)中找到它：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create the Broker:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 Broker：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You should get output similar to the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会得到类似以下的输出：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-86
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: We are using the internal Kubernetes networking for this part, so any endpoint
    we are using is a Kubernetes Service in the fully qualified domain name (FQDN)
    format accessible only within the cluster.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此部分，我们正在使用内部 Kubernetes 网络，因此我们使用的任何端点都是 Kubernetes Service，格式为完全限定域名 (FQDN)，只能在集群内部访问。
- en: Now let’s create a Trigger to wake up the Inventory microservice. It can be
    any event compliant with the CloudEvents specification. In this case, you can
    use an HTTP request from another Pod.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个触发器来唤醒 Inventory 微服务。它可以是符合 CloudEvents 规范的任何事件。在这种情况下，你可以使用另一个 Pod
    的 HTTP 请求。
- en: 'An example of a Knative Trigger for the Inventory Quarkus microservice that
    you created in [Chapter 2](ch02.xhtml#changing_technologies) follows; you can
    find it in this [book’s GitHub repository](https://oreil.ly/GmG6r):'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第二章](ch02.xhtml#changing_technologies) 中创建的 Inventory Quarkus 微服务的 Knative
    触发器示例如下；你可以在这本[书的 GitHub 仓库](https://oreil.ly/GmG6r)中找到它：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[![1](Images/1.png)](#co_tomorrow_s_solutions__serverless_CO2-1)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![1](Images/1.png)](#co_tomorrow_s_solutions__serverless_CO2-1)'
- en: Name of the Broker.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Broker 的名称。
- en: '[![2](Images/2.png)](#co_tomorrow_s_solutions__serverless_CO2-2)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '![2](Images/2.png)](#co_tomorrow_s_solutions__serverless_CO2-2)'
- en: Attribute type. This can be used to filter which event to wake up.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 属性类型。这可用于过滤要唤醒的事件。
- en: '[![3](Images/3.png)](#co_tomorrow_s_solutions__serverless_CO2-3)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '![3](Images/3.png)](#co_tomorrow_s_solutions__serverless_CO2-3)'
- en: Name of the Knative Service to connect to and wake up to field the event.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接到的 Knative 服务的名称，并在事件字段中唤醒它。
- en: 'Let’s create the Knative Trigger as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建 Knative 触发器如下：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You should get output similar to the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会得到类似以下的输出：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now you can simulate an external event that can wake up your microservice. In
    this case, it’s a simple HTTP call, but it can also be something like a database
    stream with Debezium or a Kafka message.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以模拟一个可以唤醒你的微服务的外部事件。在这种情况下，它是一个简单的 HTTP 调用，但也可以是像 Debezium 的数据库流或 Kafka
    消息这样的东西。
- en: Tip
  id: totrans-102
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: '[Debezium.io](https://debezium.io) is an open source data capture platform
    that enables streaming from popular databases such as PostgreSQL, MySQL, etc.
    Check out the [online documentation](https://oreil.ly/bFEJi) to learn more.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[Debezium.io](https://debezium.io)是一个开源数据捕获平台，可以从流行的数据库（如PostgreSQL、MySQL等）进行流式处理。请查看[在线文档](https://oreil.ly/bFEJi)以了解更多信息。'
- en: 'Run this command to download a minimal container image containing the `curl`
    command to run directly on Kubernetes as a Pod, sending an HTTP `POST` to the
    Knative Broker to trigger the microservice start:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令以下载包含`curl`命令的最小容器映像，直接在Kubernetes上作为Pod运行，并发送HTTP `POST`到Knative Broker以触发微服务启动：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[![1](Images/1.png)](#co_tomorrow_s_solutions__serverless_CO3-1)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_tomorrow_s_solutions__serverless_CO3-1)'
- en: The attribute we defined in the Knative Broker before.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Knative Broker中定义的属性。
- en: '[![2](Images/2.png)](#co_tomorrow_s_solutions__serverless_CO3-2)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_tomorrow_s_solutions__serverless_CO3-2)'
- en: A name for the event.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 事件的名称。
- en: 'You should get output similar to the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 应该获得类似以下的输出：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You should now see the Inventory Pod has been started:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该看到已启动库存Pod：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Function as a Service for Java Applications
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于Java应用程序的函数即服务
- en: 'We previously discussed how Knative Serving helps to reduce the complexity
    of maintaining multiple Kubernetes objects, and how scale-to-zero helps optimize
    resource usage by scaling down and scaling up applications on demand when needed.
    But there is another layer of abstraction that helps with automatically building
    and deploying the application following the serverless model: the FaaS model,
    which we introduced earlier.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们先前讨论过，Knative Serving如何帮助减少维护多个Kubernetes对象的复杂性，以及如何通过按需缩放来优化资源使用。但还有另一层抽象帮助根据无服务器模型自动构建和部署应用程序：我们早先介绍过的FaaS模型。
- en: FaaS is an event-driven computing execution model where developers write apps
    that are automatically deployed in containers fully managed by a platform, then
    executed on demand following the scale-to-zero model. As a developer, you don’t
    have to write anything like a Kubernetes manifest with this model. You can simply
    write the application logic and let the platform package the application as a
    container and deploy it on the cluster as a scale-to-zero serverless app.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: FaaS是一种事件驱动的计算执行模型，开发人员编写的应用程序会自动部署在由平台完全管理的容器中，然后根据按需缩放模型在需要时执行。作为开发人员，您无需编写像Kubernetes清单这样的东西。您只需简单地编写应用程序逻辑，让平台将应用程序打包为容器，并将其作为按需缩放的无服务器应用程序部署到集群中。
- en: Popular public cloud serverless solutions such as AWS Lambda, Azure Functions,
    or Google Cloud Run provide a convenient SDK to start developing functions written
    in the most popular programming languages, to be packaged and deployed in the
    FaaS model. There are also open source solutions available, such as [Apache OpenWhisk](https://openwhisk.apache.org)
    or [Fn project](https://fnproject.io), that implement FaaS with Docker. In the
    following sections, we will focus on Knative and Kubernetes, as we have discussed
    throughout the book how Kubernetes provides a complete ecosystem for easing the
    migration of Java enterprise applications to the cloud native paradigm.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如AWS Lambda、Azure Functions或Google Cloud Run等流行的公共云无服务器解决方案提供了便捷的SDK，以开始开发用最流行的编程语言编写的函数，并在FaaS模型中打包和部署。还有一些开源解决方案可用，例如[Apache
    OpenWhisk](https://openwhisk.apache.org)或[Fn项目](https://fnproject.io)，它们使用Docker实现了FaaS。在接下来的章节中，我们将专注于Knative和Kubernetes，因为我们已经在本书中讨论了Kubernetes如何为简化Java企业应用程序向云原生范式迁移提供完整的生态系统。
- en: Functions Deployment for Java Applications
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用于Java应用程序的函数部署
- en: Functions are a piece of code delivered according to the serverless model and
    are portable between different infrastructure configurations. The life cycle of
    a function is described in [Figure 7-6](#fig7-6) starting with code writing, as
    well as specification and metadata. The building phase automatically happens afterward,
    and the deployment publishes the function in the platform. This enables a mechanism
    of updates that will trigger a new build and a new publish when a new change is
    needed.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是根据无服务器模型交付的代码片段，可以在不同的基础设施配置之间移植。函数的生命周期在[图 7-6](#fig7-6)中描述，从编写代码、规范和元数据开始。构建阶段随后自动发生，并且部署将函数发布到平台上。这使得当需要进行新变更时，触发新的构建和新的发布的更新机制成为可能。
- en: '![Functions deployment model](Images/moej_0706.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![函数部署模型](Images/moej_0706.png)'
- en: Figure 7-6\. Functions deployment model
  id: totrans-121
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-6\. 函数部署模型
- en: Boson Function CLI (func)
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Boson Function CLI（func）
- en: '[Boson Function CLI](https://oreil.ly/lKYKc) is an open source CLI and framework
    that connects to Knative to provide FaaS capabilities to Kubernetes. With this
    tool, you can avoid writing Kubernetes manifests and building the container image
    yourself, as it will be done automatically:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[Boson Function CLI](https://oreil.ly/lKYKc) 是一个开源 CLI 和框架，连接到 Knative 以提供
    Kubernetes 的 FaaS 能力。使用此工具，您可以避免手动编写 Kubernetes 清单和构建容器映像：'
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Tip
  id: totrans-125
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: You can download the latest `func` CLI from the [official website](https://oreil.ly/d6oXo)
    and configure it to your system.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[官方网站](https://oreil.ly/d6oXo)下载最新的`func` CLI，并将其配置到您的系统中。
- en: Functions can be deployed to any Kubernetes cluster that has been configured
    to support serverless workloads, such as with Knative.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以部署到任何已配置以支持无服务器工作负载的 Kubernetes 集群，例如 Knative。
- en: 'Currently, `func` CLI supports these programming languages and frameworks:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`func` CLI 支持以下编程语言和框架：
- en: Golang
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Golang
- en: Node.js
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js
- en: Python
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python
- en: Quarkus
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Quarkus
- en: Rust
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust
- en: Let’s create a Quarkus function inside the `coolstore` namespace that you created
    in the previous sections. You can also find this function in this [book’s GitHub
    repository](https://oreil.ly/M3yPE).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在您之前创建的 `coolstore` 命名空间内创建一个 Quarkus 函数。您还可以在此[书籍的 GitHub 存储库](https://oreil.ly/M3yPE)中找到此函数。
- en: 'To create a new Quarkus function, run this command specifying the `-l` option
    to select the language as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建新的 Quarkus 函数，请运行以下命令，并指定 `-l` 选项来选择语言：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You should get a similar output:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该获得类似的输出：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This created a skeleton of a Maven project for Quarkus, with a POM file containing
    all dependencies needed:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个 Quarkus 的 Maven 项目骨架，其中包含所有需要的依赖项的 POM 文件：
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[![1](Images/1.png)](#co_tomorrow_s_solutions__serverless_CO4-1)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_tomorrow_s_solutions__serverless_CO4-1)'
- en: This is the file containing configuration information for your function project.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这是包含函数项目配置信息的文件。
- en: '[![2](Images/2.png)](#co_tomorrow_s_solutions__serverless_CO4-2)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_tomorrow_s_solutions__serverless_CO4-2)'
- en: The POM file for this Quarkus project.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Quarkus 项目的 POM 文件。
- en: '[![3](Images/3.png)](#co_tomorrow_s_solutions__serverless_CO4-3)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_tomorrow_s_solutions__serverless_CO4-3)'
- en: The Java class containing annotations and code to run the function.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 包含注解和代码以运行函数的 Java 类。
- en: 'Let’s add some content for the `func.yaml` function’s configuration file to
    transform your function into a runnable container image on Kubernetes:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为`func.yaml`函数配置文件添加一些内容，以在 Kubernetes 上将您的函数转换为可运行的容器映像：
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[![1](Images/1.png)](#co_tomorrow_s_solutions__serverless_CO5-1)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_tomorrow_s_solutions__serverless_CO5-1)'
- en: Name of the function.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的名称。
- en: '[![2](Images/2.png)](#co_tomorrow_s_solutions__serverless_CO5-2)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_tomorrow_s_solutions__serverless_CO5-2)'
- en: The Kubernetes namespace where your function will be deployed.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 将部署函数的 Kubernetes 命名空间。
- en: '[![3](Images/3.png)](#co_tomorrow_s_solutions__serverless_CO5-3)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_tomorrow_s_solutions__serverless_CO5-3)'
- en: The language runtime for your function declared at creation time.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建时声明函数的语言运行时。
- en: '[![4](Images/4.png)](#co_tomorrow_s_solutions__serverless_CO5-4)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_tomorrow_s_solutions__serverless_CO5-4)'
- en: This is the image name for your function after it has been built.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这是函数构建后的映像名称。
- en: '[![5](Images/5.png)](#co_tomorrow_s_solutions__serverless_CO5-5)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](Images/5.png)](#co_tomorrow_s_solutions__serverless_CO5-5)'
- en: The invocation event that triggers your function. For example, `http` for plain
    HTTP requests such as in this case, or `event` for CloudEvent-triggered functions.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 触发函数的调用事件。例如，在这种情况下为`http`用于纯HTTP请求，或`event`用于云事件触发的函数。
- en: '[![6](Images/6.png)](#co_tomorrow_s_solutions__serverless_CO5-6)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](Images/6.png)](#co_tomorrow_s_solutions__serverless_CO5-6)'
- en: Specifies the buildpack builder image to use when building the function.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 指定构建函数时要使用的 Buildpack 构建器映像。
- en: '[![7](Images/7.png)](#co_tomorrow_s_solutions__serverless_CO5-7)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](Images/7.png)](#co_tomorrow_s_solutions__serverless_CO5-7)'
- en: Reference to any environment variables that will be available to your function
    at runtime.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时可用于函数的任何环境变量的引用。
- en: '[![8](Images/8.png)](#co_tomorrow_s_solutions__serverless_CO5-8)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](Images/8.png)](#co_tomorrow_s_solutions__serverless_CO5-8)'
- en: Annotations for the function to be used to tag items.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 用于标记项目中的功能的注释。
- en: Tip
  id: totrans-165
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: '`func` builds functions and transforms them in container images with [Buildpack](https://buildpacks.io),
    a popular open source project used to build source code into a runnable application
    container image.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`func` 会使用 [Buildpack](https://buildpacks.io) 将函数构建并转换为容器映像，Buildpack 是一个流行的开源项目，用于将源代码构建为可运行的应用程序容器映像。'
- en: 'Let’s review the POM file:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来审查一下POM文件：
- en: '[PRE23]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[![1](Images/1.png)](#co_tomorrow_s_solutions__serverless_CO6-1)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_tomorrow_s_solutions__serverless_CO6-1)'
- en: Version of Quarkus
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus的版本
- en: '[![2](Images/2.png)](#co_tomorrow_s_solutions__serverless_CO6-2)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_tomorrow_s_solutions__serverless_CO6-2)'
- en: Quarkus Funqy dependency, a Java API for FaaS environments
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus Funqy依赖项，一个用于FaaS环境的Java API
- en: '[![3](Images/3.png)](#co_tomorrow_s_solutions__serverless_CO6-3)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_tomorrow_s_solutions__serverless_CO6-3)'
- en: Native profile for building Quarkus native applications
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 用于构建Quarkus本机应用程序的本机配置文件
- en: '[Quarkus Funqy](https://oreil.ly/1CNPK) is part of Quarkus’s support for serverless
    workloads and aims to provide a portable Java API to write functions deployable
    to various FaaS environments, such as AWS Lambda, Azure Functions, Knative, and
    Knative Events (Cloud Events). Funqy is an abstraction that spans multiple different
    FaaS providers and protocols. It is optimized for small workloads and faster execution
    while providing a simple framework with no overhead.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[Quarkus Funqy](https://oreil.ly/1CNPK)是Quarkus对无服务器工作负载的支持的一部分，旨在提供一个便携的Java
    API，用于编写可部署到各种FaaS环境（如AWS Lambda、Azure Functions、Knative和Knative Events（Cloud
    Events））的函数。Funqy是一个跨多个不同FaaS提供商和协议的抽象。它针对小型工作负载和更快的执行进行了优化，同时提供了一个简单的框架，没有额外的开销。'
- en: 'Let’s look at the source code of the Java function generated in the `src/main/java/functions/Function.java`
    path:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下在`src/main/java/functions/Function.java`路径下生成的Java函数的源代码：
- en: '[PRE24]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[![1](Images/1.png)](#co_tomorrow_s_solutions__serverless_CO7-1)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_tomorrow_s_solutions__serverless_CO7-1)'
- en: To enable a function, you simply need to annotate your method with the `@Funq`
    annotation that comes from Quarkus Funqy API.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用函数，您只需使用来自Quarkus Funqy API的`@Funq`注解标记您的方法。
- en: '[![2](Images/2.png)](#co_tomorrow_s_solutions__serverless_CO7-2)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_tomorrow_s_solutions__serverless_CO7-2)'
- en: Java classes can also be used as input and output. They must follow the JavaBean
    convention and have a default constructor. Here we are using `Input` and `Output`
    Beans.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Java类也可以用作输入和输出。它们必须遵循JavaBean约定并具有默认构造函数。在这里，我们正在使用`Input`和`Output` Beans。
- en: 'Let’s look at the source code of the `Input` JavaBean generated in the `src/main/java/functions/Input.java`
    path that will be used to represent input messages to the function:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下在`src/main/java/functions/Input.java`路径下生成的`Input` JavaBean的源代码，该JavaBean用于表示函数的输入消息：
- en: '[PRE25]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'And let’s have a look at the source code of the `Output` JavaBean generated
    in the `src/main/java/functions/Ouput.java` path:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下在`src/main/java/functions/Output.java`路径下生成的`Output` JavaBean的源代码：
- en: '[PRE26]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We are now ready to build the function. By default, the Boson CLI will connect
    to the local Docker instance locally to create the container with buildpacks and
    then push to the container registry you declared in the `func.yaml` configuration
    file:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好构建该函数了。默认情况下，Boson CLI将连接到本地Docker实例，使用构建包创建容器，然后推送到您在`func.yaml`配置文件中声明的容器注册表：
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Tip
  id: totrans-188
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: In future versions, Boson CLI will also delegate the building phase to Kubernetes
    via Tekton.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来的版本中，Boson CLI还将通过Tekton将构建阶段委托给Kubernetes。
- en: 'After a few minutes, you should get a similar output:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 几分钟后，您应该会得到类似于以下内容的输出：
- en: '[PRE28]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'After the function has been built, you can test it locally as a running container
    image before deploying it to Kubernetes:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 函数构建完成后，您可以将其作为运行中的容器映像在本地测试，然后再部署到Kubernetes：
- en: '[PRE29]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You should get an output similar to this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会得到类似于以下内容的输出：
- en: '[PRE30]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In another terminal, verify the process is running:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个终端中，验证进程是否正在运行：
- en: '[PRE32]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Try to access it:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试访问它：
- en: '[PRE33]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You should get an output similar to this:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会得到类似于以下内容的输出：
- en: '[PRE34]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now let’s deploy it to Kubernetes and let Knative use it as a scale-to-zero
    application. When we invoke the function via HTTP, Knative will start it automatically,
    and it will scale down to zero when not used:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将其部署到Kubernetes，并让Knative将其用作零缩放应用程序。当我们通过HTTP调用该函数时，Knative将自动启动它，并在不使用时将其缩减为零：
- en: '[PRE35]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'After a few seconds, you should see an output similar to this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 几秒钟后，您应该会看到类似于以下内容的输出：
- en: '[PRE36]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Finally, start your Quarkus function on Kubernetes!
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在Kubernetes上启动您的Quarkus函数！
- en: '[PRE37]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You should get an output similar to this:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会得到类似于以下内容的输出：
- en: '[PRE38]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You can verify that a new pod has started in your Kubernetes cluster inside
    the `coolstore` namespace:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以验证在`coolstore`命名空间内的Kubernetes集群中已启动了一个新的pod：
- en: '[PRE39]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'And, you should see that a new Knative Service has been created:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 并且，您应该看到已创建了一个新的Knative服务：
- en: '[PRE40]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You can now see all the details of your newly deployed function with the following
    command:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以通过以下命令查看新部署的函数的所有详细信息：
- en: '[PRE41]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You should get an output similar to this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Summary
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we analyzed how Java developers can create modern applications
    following the serverless execution model. We outlined some of the most common
    use cases and architectures that Java developers are likely to work with today,
    and tomorrow. Edge computing, Internet of Things, data ingestion, and machine
    learning are all contexts where event-driven architectures are a natural choice,
    and where serverless and Java can play a strategic and supporting role. We discussed
    FaaS, which represents the latest evolution in software development, and how Kubernetes
    can automate the whole life cycle of applications deployed as decoupled, asynchronous,
    easy-to-parallelize processes called functions.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: With this chapter, we complete this “Concise Cloud Native Guide for Developers.”
    From microservices to functions, Java developers today have a complete set of
    frameworks, tools, and platforms such as Kubernetes that can help them modernize
    their architectures, innovate their solutions, and look ahead to solve the next
    challenges in today’s IT context. This context is one that is ever more heterogeneous,
    ubiquitous, large scale, and cloud native.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: To you I have given wings, on which you may fly aloft
  id: totrans-222
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-223
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Above the boundless sea and all the earth […]
  id: totrans-224
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-225
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To all who care for them, even to those who are not yet born, you will be
  id: totrans-226
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-227
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Alike a theme of song, so long as Earth and Sun exist.
  id: totrans-228
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-229
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Theognis of Megara
  id: totrans-230
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
