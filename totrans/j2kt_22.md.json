["```java\nclass TableReaderAcceptanceTests {\n    @Test\n    fun test() {\n    }\n}\n```", "```java\nclass TableReaderAcceptanceTests {\n    data class Measurement(\n        val t: Double,\n        val x: Double,\n        val y: Double,\n    )\n\n    @Test\n    fun `acceptance test`() {\n        val input = listOf(\n            \"time,x,y\",\n            \"0.0,  1,  1\",\n            \"0.1,1.1,1.2\",\n            \"0.2,1.2,1.4\",\n        )\n        val expected = listOf(\n            Measurement(0.0, 1.0, 1.0),\n            Measurement(0.1, 1.1, 1.2),\n            Measurement(0.2, 1.2, 1.4)\n        )\n        assertEquals(\n            expected,\n            someFunction(input)\n        )\n    }\n\n    private fun someFunction(input: List<String>): List<Measurement> {\n        TODO(\"Not yet implemented\")\n    }\n}\n```", "```java\nprivate fun someFunction(input: List<String>): List<Measurement> =\n    readTable(input) ![1](assets/1.png)\n        .map { record -> ![2](assets/2.png) ![3](assets/3.png)\n        Measurement(\n            record[\"time\"].toDouble(), ![4](assets/4.png)\n            record[\"x\"].toDouble(), ![4](assets/4.png)\n            record[\"y\"].toDouble(), ![4](assets/4.png)\n        )\n    }\n```", "```java\nprivate fun readTable(input: List<String>): Any {\n    TODO(\"Not yet implemented\")\n}\n```", "```java\nprivate fun someFunction(input: List<String>): List<Measurement> =\n    readTable(input).map { record ->\n        Measurement(\n            record[\"time\"]?.toDoubleOrNull() ?: error(\"in time\"),\n            record[\"x\"]?.toDoubleOrNull() ?: error(\"in x\"),\n            record[\"y\"]?.toDoubleOrNull() ?: error(\"in y\"),\n        )\n    }\n\nfun readTable(input: List<String>): List<Map<String, String>> {\n    TODO(\"Not yet implemented\")\n}\n```", "```java\nfun readTable(input: List<String>): List<Map<String, String>> {\n    TODO(\"Not yet implemented\")\n}\n```", "```java\n@Disabled\n@Test\nfun `acceptance test`() {\n    val input = listOf(\n        \"time,x,y\",\n        \"0.0,  1,  1\",\n        \"0.1,1.1,1.2\",\n        \"0.2,1.2,1.4\",\n    )\n    val expected = listOf(\n        Measurement(0.0, 1.0, 1.0),\n        Measurement(0.1, 1.1, 1.2),\n        Measurement(0.2, 1.2, 1.4)\n    )\n    assertEquals(\n        expected,\n        readTable(input).map { record ->\n            Measurement(\n                t = record[\"time\"]?.toDoubleOrNull() ?: error(\"in time\"),\n                x = record[\"x\"]?.toDoubleOrNull() ?: error(\"in x\"),\n                y = record[\"y\"]?.toDoubleOrNull() ?: error(\"in y\"),\n            )\n        }\n    )\n}\n```", "```java\nclass TableReaderTests {\n    @Test\n    fun `empty list returns empty list`() {\n        val input: List<String> = emptyList()\n        val expectedResult: List<Map<String, String>> = emptyList()\n        assertEquals(\n            expectedResult,\n            readTable(input)\n        )\n    }\n}\n```", "```java\nfun readTable(input: List<String>): List<Map<String, String>> {\n    return emptyList()\n}\n```", "```java\n@Test\nfun `empty list returns empty list`() {\n    assertEquals(\n        emptyList<Map<String, String>>(),\n        readTable(emptyList())\n    )\n}\n\n@Test\nfun `one line of input with default field names`() {\n    assertEquals(\n        listOf(\n            mapOf(\"0\" to \"field0\", \"1\" to \"field1\")\n        ),\n        readTable(listOf(\n            \"field0,field1\"\n        ))\n    )\n}\n```", "```java\nfun readTable(lines: List<String>): List<Map<String, String>> {\n    return if (lines.isEmpty())\n        emptyList()\n    else listOf(\n        mapOf(\"0\" to \"field0\", \"1\" to \"field1\")\n    )\n}\n```", "```java\nfun readTable(lines: List<String>): List<Map<String, String>> {\n    return lines.map {\n        mapOf(\"0\" to \"field0\", \"1\" to \"field1\")\n    }\n}\n```", "```java\nfun readTable(lines: List<String>): List<Map<String, String>> {\n    return lines.map(::parseLine)\n}\n\nprivate fun parseLine(line: String) = mapOf(\"0\" to \"field0\", \"1\" to \"field1\")\n```", "```java\nprivate fun parseLine(line: String): Map<String, String> {\n    val keys = listOf(\"0\", \"1\")\n    val values = listOf(\"field0\", \"field1\")\n    return keys.zip(values).toMap()\n}\n```", "```java\nprivate fun parseLine(line: String): Map<String, String> {\n    val values = listOf(\"field0\", \"field1\")\n    val keys = values.indices.map(Int::toString)\n    return keys.zip(values).toMap()\n}\n```", "```java\nprivate fun parseLine(line: String): Map<String, String> {\n    val values = line.split(\",\")\n    val keys = values.indices.map(Int::toString)\n    return keys.zip(values).toMap()\n}\n```", "```java\n@Test\nfun `empty line returns empty map`() {\n    assertEquals(\n        listOf(\n            emptyMap<String, String>()\n        ),\n        readTable(listOf(\n            \"\"\n        ))\n    )\n}\n```", "```java\norg.opentest4j.AssertionFailedError:\nExpected :[{}]\nActual   :[{0=}]\n```", "```java\nprivate fun parseLine(line: String): Map<String, String> {\n    val values = if (line.isEmpty()) emptyList() else line.split(\",\")\n    val keys = values.indices.map(Int::toString)\n    return keys.zip(values).toMap()\n}\n```", "```java\nprivate fun parseLine(line: String): Map<String, String> {\n    val values = splitFields(line)\n    val keys = values.indices.map(Int::toString)\n    return keys.zip(values).toMap()\n}\n\nprivate fun splitFields(line: String): List<String> =\n    if (line.isEmpty()) emptyList() else line.split(\",\")\n```", "```java\nprivate fun parseLine(line: String): Map<String, String> {\n    val values = line.splitFields(\",\")\n    val keys = values.indices.map(Int::toString)\n    return keys.zip(values).toMap()\n}\n\nprivate fun String.splitFields(separators: String): List<String> =\n    if (isEmpty()) emptyList() else split(separators)\n```", "```java\n@Test\nfun `two lines of input with default field names`() {\n    assertEquals(\n        listOf(\n            mapOf(\"0\" to \"row0field0\", \"1\" to \"row0field1\"),\n            mapOf(\"0\" to \"row1field0\", \"1\" to \"row1field1\")\n        ),\n        readTable(listOf(\n            \"row0field0,row0field1\",\n            \"row1field0,row1field1\"\n        ))\n    )\n}\n```", "```java\n@Test\nfun `takes headers from header line`() {\n    assertEquals(\n        listOf(\n            mapOf(\"H0\" to \"field0\", \"H1\" to \"field1\")\n        ),\n        readTableWithHeader(\n            listOf(\n                \"H0,H1\",\n                \"field0,field1\"\n            )\n        )\n    )\n}\n```", "```java\nfun readTableWithHeader(lines: List<String>): List<Map<String, String>> {\n    return readTable(lines)\n}\n\nfun readTable(lines: List<String>): List<Map<String, String>> {\n    return lines.map(::parseLine)\n}\n```", "```java\norg.opentest4j.AssertionFailedError:\nExpected :[{H0=field0, H1=field1}]\nActual   :[{0=H0, 1=H1}, {0=field0, 1=field1}]\n```", "```java\nprivate fun parseLine(line: String): Map<String, String> {\n    val values = line.splitFields(\",\")\n    val keys = values.indices.map(Int::toString)\n    return keys.zip(values).toMap()\n}\n```", "```java\nprivate fun parseLine(line: String): Map<String, String> {\n    val values = line.splitFields(\",\")\n    val headerProvider: (Int) -> String = Int::toString\n    val keys = values.indices.map(headerProvider)\n    return keys.zip(values).toMap()\n}\n```", "```java\nprivate fun parseLine(\n    line: String,\n    headerProvider: (Int) -> String\n): Map<String, String> {\n    val values = line.splitFields(\",\")\n    val keys = values.indices.map(headerProvider)\n    return keys.zip(values).toMap()\n}\n```", "```java\nfun readTableWithHeader(lines: List<String>): List<Map<String, String>> {\n    return readTable(lines)\n}\n\nfun readTable(lines: List<String>): List<Map<String, String>> {\n    return lines.map(::parseLine) ![1](assets/1.png)\n}\n```", "```java\nfun readTableWithHeader(lines: List<String>): List<Map<String, String>> {\n    return readTable(lines)\n}\n\nfun readTable(lines: List<String>): List<Map<String, String>> {\n    return lines.map { parseLine(it, Int::toString) }\n}\n```", "```java\nfun readTableWithHeader(lines: List<String>): List<Map<String, String>> {\n    return readTable(lines)\n}\n\nfun readTable(\n    lines: List<String>,\n    headerProvider: KFunction1<Int, String> = Int::toString ![1](assets/1.png)\n): List<Map<String, String>> {\n    return lines.map { parseLine(it, headerProvider) }\n}\n```", "```java\nfun readTableWithHeader(lines: List<String>): List<Map<String, String>> {\n    return readTable(lines)\n}\n\nfun readTable(\n    lines: List<String>,\n    headerProvider: (Int) -> String = Int::toString\n): List<Map<String, String>> {\n    return lines.map { parseLine(it, headerProvider) }\n}\n```", "```java\nfun readTableWithHeader(lines: List<String>): List<Map<String, String>> {\n    return readTable(\n        lines.drop(1),\n        headerProviderFrom(lines.first())\n    )\n}\n```", "```java\nfun headerProviderFrom(header: String): (Int) -> String {\n    TODO(\"Not yet implemented\")\n}\n```", "```java\nprivate fun headerProviderFrom(header: String): (Int) -> String {\n    val headers = header.splitFields(\",\")\n    return { index -> headers[index] }\n}\n```", "```java\n@Test\nfun `takes headers from header line`() {\n    assertEquals(\n        listOf(\n            mapOf(\"H0\" to \"field0\", \"H1\" to \"field1\")\n        ),\n        readTableWithHeader(\n            listOf(\n                \"H0,H1\",\n                \"field0,field1\"\n            )\n        )\n    )\n}\n```", "```java\n@Test\nfun `readTableWithHeader on empty list returns empty list`() {\n    assertEquals(\n        emptyList<String>(),\n        readTableWithHeader(\n            emptyList()\n        )\n    )\n}\n```", "```java\nfun readTableWithHeader(lines: List<String>): List<Map<String, String>> {\n    return readTable(\n        lines.drop(1),\n        headerProviderFrom(lines.first())\n    )\n}\n```", "```java\nfun readTableWithHeader(\n    lines: List<String>\n): List<Map<String, String>> =\n    when {\n        lines.isEmpty() -> emptyList()\n        else -> readTable(\n            lines.drop(1),\n            headerProviderFrom(lines.first())\n        )\n    }\n\nfun readTable(\n    lines: List<String>,\n    headerProvider: (Int) -> String = Int::toString\n): List<Map<String, String>> =\n    lines.map { parseLine(it, headerProvider) }\n```", "```java\n@Test\nfun `can specify header names when there is no header row`() {\n    val headers = listOf(\"apple\", \"banana\")\n    assertEquals(\n        listOf(\n            mapOf(\n                \"apple\" to \"field0\",\n                \"banana\" to \"field1\",\n            )\n        ),\n        readTable(\n            listOf(\"field0,field1\"),\n            headers::get\n        )\n    )\n}\n```", "```java\n@Disabled\n@Test\nfun `acceptance test`() {\n    val input = listOf(\n        \"time,x,y\",\n        \"0.0,  1,  1\",\n        \"0.1,1.1,1.2\",\n        \"0.2,1.2,1.4\",\n    )\n    val expected = listOf(\n        Measurement(0.0, 1.0, 1.0),\n        Measurement(0.1, 1.1, 1.2),\n        Measurement(0.2, 1.2, 1.4)\n    )\n    assertEquals(\n        expected,\n        readTable(input).map { record ->\n            Measurement(\n                t = record[\"time\"]?.toDoubleOrNull() ?: error(\"in time\"),\n                x = record[\"x\"]?.toDoubleOrNull() ?: error(\"in x\"),\n                y = record[\"y\"]?.toDoubleOrNull() ?: error(\"in y\"),\n            )\n        }\n    )\n}\n```", "```java\nassertEquals(\n    expected,\n    readTableWithHeader(input).map { record ->\n        Measurement(\n            t = record[\"time\"]?.toDoubleOrNull() ?: error(\"in time\"),\n            x = record[\"x\"]?.toDoubleOrNull() ?: error(\"in x\"),\n            y = record[\"y\"]?.toDoubleOrNull() ?: error(\"in y\"),\n        )\n    }\n```", "```java\nprivate fun headerProviderFrom(header: String): (Int) -> String {\n    val headers = header.splitFields(\",\")\n    return { index -> headers[index] }\n}\n\nprivate fun parseLine(\n    line: String,\n    headerProvider: (Int) -> String\n): Map<String, String> {\n    val values = line.splitFields(\",\")\n    val keys = values.indices.map(headerProvider)\n    return keys.zip(values).toMap()\n}\n\nprivate fun String.splitFields(separators: String): List<String> =\n    if (isEmpty()) emptyList() else split(separators)\n```", "```java\nfun readTable(\n    lines: List<String>,\n    headerProvider: (Int) -> String = Int::toString\n): List<Map<String, String>> =\n    lines.map {\n        parseLine(it, headerProvider) { line -> ![1](assets/1.png)\n            line.splitFields(\",\")\n        }\n    }\n\n...\n\nprivate fun parseLine(\n    line: String,\n    headerProvider: (Int) -> String,\n    splitter: (String) -> List<String>, ![2](assets/2.png)\n): Map<String, String> {\n    val values = splitter(line)\n    val keys = values.indices.map(headerProvider)\n    return keys.zip(values).toMap()\n}\n```", "```java\nfun readTable(\n    lines: List<String>,\n    headerProvider: (Int) -> String = Int::toString\n): List<Map<String, String>> =\n    lines.map {\n        val splitOnComma: (String) -> List<String> = { line ->\n            line.splitFields(\",\")\n        }\n        parseLine(it, headerProvider, splitOnComma)\n    }\n```", "```java\nfun readTable(\n    lines: List<String>,\n    headerProvider: (Int) -> String = Int::toString\n): List<Map<String, String>> =\n    lines.map {\n        parseLine(it, headerProvider, splitOnComma)\n    }\n\nval splitOnComma: (String) -> List<String> = { line ->\n    line.splitFields(\",\")\n}\n```", "```java\nfun readTable(\n    lines: List<String>,\n    headerProvider: (Int) -> String = Int::toString,\n    splitter: (String) -> List<String> = splitOnComma\n): List<Map<String, String>> =\n    lines.map {\n        parseLine(it, headerProvider, splitter)\n    }\n\nval splitOnComma: (String) -> List<String> = { line ->\n    line.splitFields(\",\")\n}\n```", "```java\nprivate fun headerProviderFrom(header: String): (Int) -> String {\n    val headers = header.splitFields(\",\")\n    return { index -> headers[index] }\n}\n```", "```java\nfun readTableWithHeader(\n    lines: List<String>\n): List<Map<String, String>> =\n    when {\n        lines.isEmpty() -> emptyList()\n        else -> readTable(\n            lines.drop(1),\n            headerProviderFrom(lines.first()) { header -> ![1](assets/1.png)\n                header.splitFields(\",\")\n            }\n        )\n    }\n\n...\n\nval splitOnComma: (String) -> List<String> = { line ->\n    line.splitFields(\",\")\n}\n\nprivate fun headerProviderFrom(\n    header: String,\n    splitter: (String) -> List<String> ![2](assets/2.png)\n): (Int) -> String {\n    val headers = splitter(header)\n    return { index -> headers[index] }\n}\n```", "```java\nfun readTableWithHeader(\n    lines: List<String>\n): List<Map<String, String>> =\n    when {\n        lines.isEmpty() -> emptyList()\n        else -> readTable(\n            lines.drop(1),\n            headerProviderFrom(lines.first(), splitOnComma)\n        )\n    }\n\n...\n\nval splitOnComma: (String) -> List<String> = { line ->\n    line.splitFields(\",\")\n}\n```", "```java\nfun readTableWithHeader(\n    lines: List<String>,\n    splitter: (String) -> List<String> = splitOnComma\n): List<Map<String, String>> =\n    when {\n        lines.isEmpty() -> emptyList()\n        else -> readTable(\n            lines.drop(1),\n            headerProviderFrom(lines.first(), splitter)\n        )\n    }\n```", "```java\nfun readTableWithHeader(\n    lines: List<String>,\n    splitter: (String) -> List<String> = splitOnComma\n): List<Map<String, String>> =\n    when {\n        lines.isEmpty() -> emptyList()\n        else -> readTable(\n            lines.drop(1),\n            headerProviderFrom(lines.first(), splitter),\n            splitter ![1](assets/1.png)\n        )\n    }\n\nfun readTable(\n    lines: List<String>,\n    headerProvider: (Int) -> String = Int::toString,\n    splitter: (String) -> List<String> = splitOnComma\n): List<Map<String, String>> =\n    lines.map {\n        parseLine(it, headerProvider, splitter)\n    }\n```", "```java\nval splitOnComma: (String) -> List<String> = { line ->\n    line.splitFields(\",\")\n}\n```", "```java\nfun splitOn(\n    separators: String\n): (String) -> List<String> = { line: String ->\n    line.splitFields(separators)\n}\n\nval splitOnComma: (String) -> List<String> = splitOn(\",\")\nval splitOnTab: (String) -> List<String> = splitOn(\"\\t\")\n```", "```java\n@Test\nfun `can specify splitter`() {\n    assertEquals(\n        listOf(\n            mapOf(\n                \"header1\" to \"field0\",\n                \"header2\" to \"field1\",\n            )\n        ),\n        readTableWithHeader(\n            listOf(\n                \"header1\\theader2\",\n                \"field0\\tfield1\"\n            ),\n            splitOnTab\n        )\n    )\n}\n```", "```java\nfun readTable(\n    lines: List<String>,\n    headerProvider: (Int) -> String = Int::toString,\n    splitter: (String) -> List<String> = splitOnComma\n): List<Map<String, String>> =\n    lines.map {\n        parseLine(it, headerProvider, splitter)\n    }\n```", "```java\nfun readTable(\n    lines: List<String>,\n    headerProvider: (Int) -> String = Int::toString,\n    splitter: (String) -> List<String> = splitOnComma\n): List<Map<String, String>> =\n    lines\n        .asSequence()\n        .map {\n            parseLine(it, headerProvider, splitter)\n        }\n        .toList()\n```", "```java\nfun readTable(\n    lines: List<String>,\n    headerProvider: (Int) -> String = Int::toString,\n    splitter: (String) -> List<String> = splitOnComma\n): List<Map<String, String>> =\n    readTable(\n        lines.asSequence(),\n        headerProvider,\n        splitter\n    ).toList()\n\nfun readTable(\n    lines: Sequence<String>,\n    headerProvider: (Int) -> String = Int::toString,\n    splitter: (String) -> List<String> = splitOnComma\n) = lines.map {\n        parseLine(it, headerProvider, splitter)\n    }\n```", "```java\nfun readTableWithHeader(\n    lines: List<String>,\n    splitter: (String) -> List<String> = splitOnComma\n): List<Map<String, String>> =\n    when {\n        lines.isEmpty() -> emptyList()\n        else -> readTable(\n            lines.drop(1),\n            headerProviderFrom(lines.first(), splitter),\n            splitter\n        )\n    }\n```", "```java\nfun readTableWithHeader(\n    lines: List<String>,\n    splitter: (String) -> List<String> = splitOnComma\n): List<Map<String, String>> =\n    when {\n        lines.isEmpty() -> emptyList()\n        else -> readTable(\n            lines.drop(1).asSequence(),\n            headerProviderFrom(lines.first(), splitter),\n            splitter\n        ).toList()\n    }\n```", "```java\nfun readTableWithHeader(\n    lines: List<String>,\n    splitter: (String) -> List<String> = splitOnComma\n): List<Map<String, String>> {\n    val linesAsSequence = lines.asSequence()\n    return when {\n        linesAsSequence.isEmpty() -> emptySequence() ![1](assets/1.png)\n        else -> {\n            readTable(\n                linesAsSequence.drop(1),\n                headerProviderFrom(linesAsSequence.first(), splitter),\n                splitter\n            )\n        }\n    }.toList()\n}\n```", "```java\nfun readTableWithHeader(\n    lines: List<String>,\n    splitter: (String) -> List<String> = splitOnComma\n): List<Map<String, String>> {\n    val linesAsSequence = lines.asSequence()\n    return when {\n        linesAsSequence.firstOrNull() == null -> emptySequence()\n        else -> {\n            readTable(\n                linesAsSequence.drop(1),\n                headerProviderFrom(linesAsSequence.first(), splitter),\n                splitter\n            )\n        }\n    }.toList()\n}\n```", "```java\nfun readTableWithHeader(\n    lines: List<String>,\n    splitter: (String) -> List<String> = splitOnComma\n): List<Map<String, String>> =\n    readTableWithHeader(\n        lines.asSequence(),\n        splitter\n    ).toList()\n\nfun readTableWithHeader(\n    lines: Sequence<String>,\n    splitter: (String) -> List<String> = splitOnComma\n) = when {\n    lines.firstOrNull() == null -> emptySequence()\n    else -> {\n        readTable(\n            lines.drop(1),\n            headerProviderFrom(lines.first(), splitter),\n            splitter\n        )\n    }\n}\n```", "```java\nfun readTableWithHeader(\n    lines: Sequence<String>,\n    splitter: (String) -> List<String> = splitOnComma\n): Sequence<Map<String, String>> =\n    when {\n        lines.firstOrNull() == null -> emptySequence()\n        else -> readTable(\n            lines.drop(1),\n            headerProviderFrom(lines.first(), splitter),\n            splitter\n        )\n    }\n\nfun readTable(\n    lines: Sequence<String>,\n    headerProvider: (Int) -> String = Int::toString,\n    splitter: (String) -> List<String> = splitOnComma\n): Sequence<Map<String, String>> =\n    lines.map {\n        parseLine(it, headerProvider, splitter)\n    }\n\nval splitOnComma: (String) -> List<String> = splitOn(\",\")\nval splitOnTab: (String) -> List<String> = splitOn(\"\\t\")\n\nfun splitOn(\n    separators: String\n) = { line: String ->\n    line.splitFields(separators)\n}\n```", "```java\nprivate fun headerProviderFrom(\n    header: String,\n    splitter: (String) -> List<String>\n): (Int) -> String {\n    val headers = splitter(header)\n    return { index -> headers[index] }\n}\n\nprivate fun parseLine(\n    line: String,\n    headerProvider: (Int) -> String,\n    splitter: (String) -> List<String>,\n): Map<String, String> {\n    val values = splitter(line)\n    val keys = values.indices.map(headerProvider)\n    return keys.zip(values).toMap()\n}\n\n// Necessary because String.split returns a list of an empty string\n// when called on an empty string.\nprivate fun String.splitFields(separators: String): List<String> =\n    if (isEmpty()) emptyList() else split(separators)\n```", "```java\n@Test\nfun `read from reader`() {\n    val fileContents = \"\"\"\n        H0,H1\n        row0field0,row0field1\n        row1field0,row1field1\n    \"\"\".trimIndent()\n    StringReader(fileContents).useLines { lines ->\n        val result = readTableWithHeader(lines).toList()\n        assertEquals(\n            listOf(\n                mapOf(\"H0\" to \"row0field0\", \"H1\" to \"row0field1\"),\n                mapOf(\"H0\" to \"row1field0\", \"H1\" to \"row1field1\")\n            ),\n            result\n        )\n    }\n}\n```", "```java\nfun readTableWithHeader(\n    lines: Sequence<String>,\n    splitter: (String) -> List<String> = splitOnComma\n): Sequence<Map<String, String>> =\n    when {\n        lines.firstOrNull() == null -> emptySequence()\n        else -> readTable(\n            lines.drop(1),\n            headerProviderFrom(lines.first(), splitter),\n            splitter\n        )\n    }\n```", "```java\nfun <T> Sequence<T>.destruct()\n    : Pair<T, Sequence<T>>? {\n    val iterator = this.iterator()\n    return when {\n        iterator.hasNext() ->\n            iterator.next() to iterator.asSequence()\n        else -> null\n    }\n}\n```", "```java\nfun readTableWithHeader(\n    lines: Sequence<String>,\n    splitter: (String) -> List<String> = splitOnComma\n): Sequence<Map<String, String>> =\n    when {\n        lines.firstOrNull() == null -> emptySequence()\n        else -> readTable(\n            lines.drop(1),\n            headerProviderFrom(lines.first(), splitter),\n            splitter\n        )\n    }\n```", "```java\nfun readTableWithHeader(\n    lines: Sequence<String>,\n    splitter: (String) -> List<String> = splitOnComma\n): Sequence<Map<String, String>> {\n    val firstAndRest = lines.destruct()\n    return when {\n        firstAndRest == null -> emptySequence()\n        else -> readTable(\n            firstAndRest.second,\n            headerProviderFrom(firstAndRest.first, splitter),\n            splitter\n        )\n    }\n}\n```", "```java\nfun readTableWithHeader(\n    lines: Sequence<String>,\n    splitter: (String) -> List<String> = splitOnComma\n): Sequence<Map<String, String>> =\n    lines.destruct()?.let { (first, rest) ->\n        readTable(\n            rest,\n            headerProviderFrom(first, splitter),\n            splitter\n        )\n    } ?: emptySequence()\n\nfun readTable(\n    lines: Sequence<String>,\n    headerProvider: (Int) -> String = Int::toString,\n    splitter: (String) -> List<String> = splitOnComma\n): Sequence<Map<String, String>> =\n    lines.map {\n        parseLine(it, headerProvider, splitter)\n    }\n\nval splitOnComma: (String) -> List<String> = splitOn(\",\")\nval splitOnTab: (String) -> List<String> = splitOn(\"\\t\")\n\nfun splitOn(\n    separators: String\n) = { line: String ->\n    line.splitFields(separators)\n}\n```", "```java\nclass TableReaderTests {\n    @Test\n    fun `empty input returns empty`() {\n        checkReadTable(\n            lines = emptyList(),\n            shouldReturn = emptyList()\n        )\n    }\n\n    @Test\n    fun `one line of input with default field names`() {\n        checkReadTable(\n            lines = listOf(\"field0,field1\"),\n            shouldReturn = listOf(\n                mapOf(\"0\" to \"field0\", \"1\" to \"field1\")\n            )\n        )\n    }\n\n    ...\n    @Test\n    fun `can specify header names when there is no header row`() {\n        val headers = listOf(\"apple\", \"banana\")\n        checkReadTable(\n            lines = listOf(\"field0,field1\"),\n            withHeaderProvider = headers::get,\n            shouldReturn = listOf(\n                mapOf(\n                    \"apple\" to \"field0\",\n                    \"banana\" to \"field1\",\n                )\n            )\n        )\n    }\n\n    @Test\n    fun `readTableWithHeader takes headers from header line`() {\n        checkReadTableWithHeader(\n            lines = listOf(\n                \"H0,H1\",\n                \"field0,field1\"\n            ),\n            shouldReturn = listOf(\n                mapOf(\"H0\" to \"field0\", \"H1\" to \"field1\")\n            )\n        )\n    }\n\n    ...\n}\n\nprivate fun checkReadTable(\n    lines: List<String>,\n    withHeaderProvider: (Int) -> String = Int::toString,\n    shouldReturn: List<Map<String, String>>,\n) {\n    assertEquals(\n        shouldReturn,\n        readTable(\n            lines.asSequence().constrainOnce(),\n            headerProvider = withHeaderProvider,\n            splitter = splitOnComma\n        ).toList()\n    )\n}\n\nprivate fun checkReadTableWithHeader(\n    lines: List<String>,\n    withSplitter: (String) -> List<String> = splitOnComma,\n    shouldReturn: List<Map<String, String>>,\n) {\n    assertEquals(\n        shouldReturn,\n        readTableWithHeader(\n            lines.asSequence().constrainOnce(),\n            splitter = withSplitter\n        ).toList()\n    )\n}\n```", "```java\n@Test\nfun example() {\n    reader.useLines { lines ->\n        val measurements: Sequence<Measurement> =\n            readTableWithHeader(lines, splitOnComma)\n                .map { record ->\n                    Measurement(\n                        t = record[\"time\"]?.toDoubleOrNull()\n                            ?: error(\"in time\"),\n                        x = record[\"x\"]?.toDoubleOrNull()\n                            ?: error(\"in x\"),\n                        y = record[\"y\"]?.toDoubleOrNull()\n                            ?: error(\"in y\"),\n                    )\n                }\n        assertEquals(\n            expected,\n            measurements.toList()\n        )\n    }\n}\n```", "```java\n@Test\nfun `commons csv`() {\n    reader.use { reader ->\n        val parser = CSVParser.parse(\n            reader,\n            CSVFormat.DEFAULT.withFirstRecordAsHeader()\n        )\n        val measurements: Sequence<Measurement> = parser\n            .asSequence()\n            .map { record ->\n                Measurement(\n                    t = record[\"time\"]?.toDoubleOrNull()\n                        ?: error(\"in time\"),\n                    x = record[\"x\"]?.toDoubleOrNull()\n                        ?: error(\"in x\"),\n                    y = record[\"y\"]?.toDoubleOrNull()\n                        ?: error(\"in y\"),\n                )\n            }\n        assertEquals(\n            expected,\n            measurements.toList()\n        )\n    }\n}\n```", "```java\n.map { record ->\n    Measurement(\n        t = record[\"time\"]?.toDoubleOrNull()\n            ?: error(\"in time\"),\n        x = record[\"x\"]?.toDoubleOrNull()\n            ?: error(\"in x\"),\n        y = record[\"y\"]?.toDoubleOrNull()\n            ?: error(\"in y\"),\n    )\n}\n```", "```java\n@Test\nfun `configuration example`() {\n    reader.use { reader ->\n        val measurements = splitOnComma.readTableWithHeader(reader)\n            .map { record ->\n                Measurement(\n                    t = record[\"time\"]?.toDoubleOrNull()\n                        ?: error(\"in time\"),\n                    x = record[\"x\"]?.toDoubleOrNull()\n                        ?: error(\"in x\"),\n                    y = record[\"y\"]?.toDoubleOrNull()\n                        ?: error(\"in y\"),\n                )\n            }\n        assertEquals(\n            expected,\n            measurements.toList()\n        )\n    }\n}\n```", "```java\nfun ((String) -> List<String>).readTableWithHeader(\n    reader: StringReader\n): Sequence<Map<String, String>> =\n    readTableWithHeader(reader.buffered().lineSequence(), this)\n```", "```java\n@Test\nfun `Table contains headers`() {\n    val result: Table = readTableWithHeader(\n        listOf(\n            \"H0,H1\",\n            \"field0,field1\"\n        ).asSequence()\n    )\n    assertEquals(\n        listOf(\"H0\", \"H1\"),\n        result.headers\n    )\n}\n\n@Test\nfun `Table contains empty headers for empty input`() {\n    assertEquals(\n        emptyList<String>(),\n        readTableWithHeader(emptySequence()).headers\n    )\n}\n```", "```java\nclass Table(\n    val headers: List<String>,\n    val records: Sequence<Map<String, String>>\n) : Sequence<Map<String, String>> by records\n\nfun readTableWithHeader(\n    lines: Sequence<String>,\n    splitter: (String) -> List<String> = splitOnComma\n): Table =\n    lines.destruct()?.let { (first, rest) ->\n        tableOf(splitter, first, rest)\n    } ?: Table(emptyList(), emptySequence())\n\nprivate fun tableOf(\n    splitter: (String) -> List<String>,\n    first: String,\n    rest: Sequence<String>\n): Table {\n    val headers = splitter(first)\n    val sequence = readTable(\n        lines = rest,\n        headerProvider = headers::get,\n        splitter = splitter\n    )\n    return Table(headers, sequence)\n}\n```"]