- en: Chapter 10\. Beyond Selenium
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter closes this book by presenting several complementary technologies
    to Selenium. First, we analyze the basics of mobile apps and introduce Appium,
    a popular testing framework for mobile testing. Then, you will learn how to test
    REST (REpresentational State Transfer) services with an open source Java library
    called REST Assured. Finally, you will be introduced to alternative tools to Selenium
    WebDriver for implementing end-to-end tests for web applications, namely: Cypress,
    WebDriverIO, TestCafe, Puppeteer, and Playwright.'
  prefs: []
  type: TYPE_NORMAL
- en: Mobile Apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Mobile applications (usually called mobile apps, or simply apps) are software
    applications designed to run on mobile devices, such as smartphones, tablets,
    or wearables. There are two principal operating systems for mobile devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Android](https://www.android.com)'
  prefs: []
  type: TYPE_NORMAL
- en: An open source (Apache 2.0 license) mobile operating system based on a modified
    version of Linux. It was initially developed by a startup named Android, acquired
    by Google in 2005.
  prefs: []
  type: TYPE_NORMAL
- en: '[iOS](https://www.apple.com/ios)'
  prefs: []
  type: TYPE_NORMAL
- en: A proprietary mobile operating system created by Apple exclusively for its hardware
    (e.g., iPhone, iPad, or Watch).
  prefs: []
  type: TYPE_NORMAL
- en: 'A common way to classify mobile apps is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Native apps
  prefs: []
  type: TYPE_NORMAL
- en: Mobile apps developed for a particular mobile operating system (e.g., Android
    or iOS).
  prefs: []
  type: TYPE_NORMAL
- en: Web-based apps
  prefs: []
  type: TYPE_NORMAL
- en: Web applications rendered into a mobile browser (e.g., Chrome, Safari, or Firefox
    Mobile). These apps are typically designed to be *responsive* (i.e., adaptable
    to different screen sizes and viewports).
  prefs: []
  type: TYPE_NORMAL
- en: Hybrid apps
  prefs: []
  type: TYPE_NORMAL
- en: Mobile applications developed using client-side web standards (i.e., HTML, CSS,
    and JavaScript) and deployed to mobile devices using a native container called
    *webview*. Examples of frameworks that enable the development of hybrid apps are
    [Ionic](https://ionicframework.com), [React Native](https://reactnative.dev),
    or [Flutter](https://flutter.dev).
  prefs: []
  type: TYPE_NORMAL
- en: Progressive web apps (PWAs)
  prefs: []
  type: TYPE_NORMAL
- en: Web applications built with modern web standard APIs (for installability, responsiveness,
    etc.) intended to work on multiple platforms, including desktop and mobile devices.
  prefs: []
  type: TYPE_NORMAL
- en: Mobile Testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Testing is an essential process in the development of mobile apps. Mobile testing
    involves different challenges such as hardware compatibility, network connectivity,
    or operating system specifics. Different approaches to carry out mobile testing
    include:'
  prefs: []
  type: TYPE_NORMAL
- en: Using desktop browsers with mobile emulation
  prefs: []
  type: TYPE_NORMAL
- en: We can use Selenium WebDriver for this type of mobile testing. To that aim,
    you can use browser-specific features (as explained in [“Device Emulation”](ch05.html#sect-caps-device-emulation))
    or use the CDP with Chromium-based browsers (as explained in [“Device emulation”](ch05.html#sect-cdp-device-emulation)).
  prefs: []
  type: TYPE_NORMAL
- en: Using virtual devices
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of virtual mobile devices:'
  prefs: []
  type: TYPE_NORMAL
- en: Emulators
  prefs: []
  type: TYPE_NORMAL
- en: Desktop applications that virtualize all aspects of mobile devices, including
    the hardware and the operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Simulators
  prefs: []
  type: TYPE_NORMAL
- en: Desktop apps that mimic certain features of a mobile operating system. They
    are primarily intended for iOS since Android devices are emulated easily.
  prefs: []
  type: TYPE_NORMAL
- en: Using real devices
  prefs: []
  type: TYPE_NORMAL
- en: Using actual devices and their native Android or iOS APIs in real conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Appium
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Appium](https://appium.io) is an open source test automation framework for
    mobile apps. Appium provides a cross-platform API that allows testing native,
    hybrid, and mobile web apps for iOS and Android on virtual or real devices. Furthermore,
    Appium enables automated testing for desktop applications on Windows and macOS.'
  prefs: []
  type: TYPE_NORMAL
- en: The story of Appium started in 2011 when Dan Cuellar created an automation tool
    for iOS applications developed in C# called iOSAuto. He met Jason Huggins (the
    co-creator of Selenium) during the SeleniumConf 2012 in London. Jason contributed
    to the project by adding a web server and using the WebDriver wire protocol over
    HTTP, making iOSAuto compatible with any Selenium WebDriver client. They changed
    the project name to Appium (the *Selenium for Apps*). In January 2013, Sauce Labs
    decided to support Appium and provide more developer power. The new team rewrote
    Appium using Node.js since it is a well-known, efficient framework for the server
    side.
  prefs: []
  type: TYPE_NORMAL
- en: As depicted in [Figure 10-1](#appium-arch), Appium follows a client-server architecture.
    Appium is a web server that exposes a REST API that carries out an automated session
    on mobile or desktop apps. To that aim, the Appium server receives incoming requests
    from clients, executes those commands on target devices/apps, and responds with
    an HTTP response representing the command execution result. Appium client libraries
    communicate with the Appium server using the Mobile JSON Wire Protocol (an official
    draft extension to the original WebDriver protocol). The Appium server and its
    client also use the W3C Webdriver specification. There are different Appium client
    libraries. [Table 10-1](#appium-clients) summarizes these libraries, both officially
    maintained by the Appium project and community.
  prefs: []
  type: TYPE_NORMAL
- en: '![hosw 1001](assets/hosw_1001.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-1\. Appium architecture
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Table 10-1\. Appium client libraries
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Language | License | Maintainer | Website |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Appium java-client | Java | Apache 2.0 | Appium team | [*https://github.com/appium/java-client*](https://github.com/appium/java-client)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Appium ruby_lib | Ruby | Apache 2.0 | Appium team | [*https://github.com/appium/ruby_lib*](https://github.com/appium/ruby_lib)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Appium Python Client | Python | Apache 2.0 | Appium team | [*https://github.com/appium/python-client*](https://github.com/appium/python-client)
    |'
  prefs: []
  type: TYPE_TB
- en: '| appium-dotnet-driver | C# | Apache 2.0 | Appium team | [*https://github.com/appium/appium-dotnet-driver*](https://github.com/appium/appium-dotnet-driver)
    |'
  prefs: []
  type: TYPE_TB
- en: '| WebdriverIO | JavaScript (Node.js) | MIT | WebdriverIO team | [*https://webdriver.io*](https://webdriver.io)
    |'
  prefs: []
  type: TYPE_TB
- en: '| web2driver | JavaScript (browser) | Apache 2.0 | HeadSpin | [*https://github.com/projectxyzio/web2driver*](https://github.com/projectxyzio/web2driver)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Appium library for RobotFramework | Python | Apache 2.0 | Serhat Bolsu |
    [*https://github.com/serhatbolsu/robotframework-appiumlibrary*](https://github.com/serhatbolsu/robotframework-appiumlibrary)
    |'
  prefs: []
  type: TYPE_TB
- en: In Appium, the support for the automation of a particular platform is provided
    by a component called *driver* in Appium jargon. These drivers were tightly coupled
    with the Appium Server in version 1\. Nevertheless, in Appium 2 (the latest version
    of Appium at the time of this writing), these drivers are segregated from the
    Appium Server (see [Figure 10-1](#appium-arch)) and are installed separately.
  prefs: []
  type: TYPE_NORMAL
- en: Table 10-2\. Appium drivers
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Target | Description | Repository |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| XCUITest Driver | iOS and tvOS apps | Leverages Apple’s XCUITest libraries
    to enable automation | [*https://github.com/appium/appium-xcuitest-driver*](https://github.com/appium/appium-xcuitest-driver)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Espresso Driver | Android apps | Enables automation through Espresso (a testing
    framework for Android) | [*https://github.com/appium/appium-espresso-driver*](https://github.com/appium/appium-espresso-driver)
    |'
  prefs: []
  type: TYPE_TB
- en: '| UiAutomator2 Driver | Android apps | Leverages Google UiAutomator2 technology
    to enable automation on an Android device or emulator | [*https://github.com/appium/appium-uiautomator2-driver*](https://github.com/appium/appium-uiautomator2-driver)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Windows Driver | Windows desktop apps | Uses WinAppDriver, a WebDriver server
    for Windows desktop apps | [*https://github.com/appium/appium-windows-driver*](https://github.com/appium/appium-windows-driver)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Mac Driver | macOS desktop apps | Uses Apple’s XCTest framework for automating
    macOS applications | [*https://github.com/appium/appium-mac2-driver*](https://github.com/appium/appium-mac2-driver)
    |'
  prefs: []
  type: TYPE_TB
- en: A basic Appium test
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This section presents a basic test case using Appium server 2 and the Appium
    Java client. For simplicity, I use the UiAutomator2 Driver and an emulated Android
    device. The SUT will be a web application, concretely, the practice site used
    throughout this book. The calls to the Appium Java clients are embedded in the
    different unit testing frameworks used in the rest of the examples (i.e., JUnit
    4 and 5, TestNG, and Selenium-Jupiter). As usual, you can find the complete source
    code in the examples repository. The requisites for running this test are:'
  prefs: []
  type: TYPE_NORMAL
- en: Install Appium server 2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install UiAutomator2 Driver.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install Android SDK (i.e., the official software development kit for Android).
    You can easily install this SDK by installing [Android Studio](https://developer.android.com/studio)
    on your computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an Android Virtual Device (AVD) using the AVD Manager in Android Studio.
    [Figure 10-2](#android-studio) shows the menu option to open this tool, and [Figure 10-3](#avd)
    shows the virtual device used in the test (a Nexus 5 mobile phone using the Android
    API level 30).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the virtual device and Appium server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![hosw 1002](assets/hosw_1002.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-2\. Android Studio
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![hosw 1003](assets/hosw_1003.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-3\. AVD Manager
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'As explained previously, the Appium server is a Node.js application. Therefore,
    you need Node.js installed in your system to run Appium. The following commands
    summarize how to install the Appium server 2 and the UiAutomator2 Driver, and
    how to start the Appium server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_beyond_selenium_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We use npm (the default package manager for Node.js) to install Appium 2.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_beyond_selenium_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We use Appium to install the UiAutomator2 Driver.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_beyond_selenium_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We start the Appium server (by default, it listens to port 4723). We include
    a flag to let Appium manage the required browser drivers (e.g., chromedriver)
    for automating web applications (just like in Selenium WebDriver).
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 10-1](#appium-java-client-test) shows a complete test using the Appium
    Java client. As you can see, this test is quite similar to the regular Selenium
    WebDriver tests explained in this book. The main difference, in this case, is
    that we use an instance of `AppiumDriver`, a class provided by the Appium Java
    client. This class extends to the `RemoteWebDriver` class of the Selenium WebDriver
    API. Therefore, we can leverage the Selenium WebDriver API to test web applications
    on mobile devices. [Figure 10-4](#android-device) shows the emulated mobile device
    (a Nexus 5) during this test.'
  prefs: []
  type: TYPE_NORMAL
- en: '![hosw 1004](assets/hosw_1004.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-4\. Android device
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Example 10-1\. Test using Appium Java client
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_beyond_selenium_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We specify the Appium server URL.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_beyond_selenium_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We make an assumption using the endpoint `/status` of the Appium server URL.
    If this URL is not online, the test is skipped.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_beyond_selenium_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We use Chrome options to specify capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_beyond_selenium_CO2-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The first mandatory capability when using Appium is the platform name (`Android`
    in this case).
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_beyond_selenium_CO2-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The following required capability is the device name. This name must match the
    name defined in the AVD manager (see [Figure 10-3](#avd)).
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_beyond_selenium_CO2-6)'
  prefs: []
  type: TYPE_NORMAL
- en: The last mandatory capability is the driver name (`UiAutomator2` in this case).
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_beyond_selenium_CO2-7)'
  prefs: []
  type: TYPE_NORMAL
- en: We create an instance of `AppiumDriver` using the Appium server URL and the
    browser options.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_beyond_selenium_CO2-8)'
  prefs: []
  type: TYPE_NORMAL
- en: We use the `driver` object to exercise the SUT as usual.
  prefs: []
  type: TYPE_NORMAL
- en: REST Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: REST (REpresentational State Transfer) is an architectural style for designing
    distributed services. Roy Fielding coined this term in his 2000 doctoral dissertation.
    REST is a popular way of creating web services on top of the HTTP protocol.
  prefs: []
  type: TYPE_NORMAL
- en: REST follows a client-server architecture. The server handles a set of *resources*,
    listening for incoming requests made by clients. These resources are the building
    blocks of REST services and define the type of information transferred. Each resource
    is identified uniquely. In HTTP, we use URLs (also known as *endpoints*) for accessing
    individual resources. Each resource has a representation, a machine-readable explanation
    of the current state of a resource. We use a data-interchange format for defining
    representations, such as JSON, YAML, or XML. REST services expose a set of *actions*
    on the resources, such as CRUD (create, retrieve, update, and delete). We can
    use the HTTP methods (the so-called *verbs*) to map REST actions. [Table 10-3](#http-method-rest)
    summarizes the HTTP methods used to create REST services. Finally, we can use
    the HTTP status codes to identify the response associated with REST actions. [Table 10-4](#http-status-rest)
    summarizes the typical HTTP status codes used in REST. [Figure 10-5](#rest-example)
    shows a sequence of requests and responses of an example REST service that uses
    different HTTP methods and response codes.
  prefs: []
  type: TYPE_NORMAL
- en: Table 10-3\. HTTP methods for creating REST services
  prefs: []
  type: TYPE_NORMAL
- en: '| HTTP Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Read a resource |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | Send a new resource to the server |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT` | Update a resource |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | Eliminate a resource |'
  prefs: []
  type: TYPE_TB
- en: '| `PATCH` | Partially update a resource |'
  prefs: []
  type: TYPE_TB
- en: '| `HEAD` | Ask if a given resource exists without returning any of its representations
    |'
  prefs: []
  type: TYPE_TB
- en: '| `OPTIONS` | Retrieve the available verbs for a given resource |'
  prefs: []
  type: TYPE_TB
- en: Table 10-4\. HTTP status codes for creating REST services
  prefs: []
  type: TYPE_NORMAL
- en: '| Status Code | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `200 OK` | The request was successful, and the content requested was returned
    (e.g., in a `GET` request). |'
  prefs: []
  type: TYPE_TB
- en: '| `201 Created` | The resource was created (e.g., in a `POST` or `PUT` request).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `204 No content` | The action was successful, but no content was returned.
    This status code is useful in actions that do not require a response body (e.g.,
    in a DELETE request). |'
  prefs: []
  type: TYPE_TB
- en: '| `301 Moved permanently` | The resource was moved to another location. |'
  prefs: []
  type: TYPE_TB
- en: '| `400 Bad request` | The request has some problems (e.g., missing parameters).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `401 Unauthorized` | The requested resource is not accessible for the user
    that made the request. |'
  prefs: []
  type: TYPE_TB
- en: '| `403 Forbidden` | The resource is not accessible, but unlike `401`, authentication
    will not affect the response. |'
  prefs: []
  type: TYPE_TB
- en: '| `404 Not found` | The provided endpoint does not identify any resource. |'
  prefs: []
  type: TYPE_TB
- en: '| `405 Method not allowed` | The used verb is not allowed (e.g., when using
    `PUT` in a read-only resource). |'
  prefs: []
  type: TYPE_TB
- en: '| `500 Internal server error` | Generic unexpected condition in the server
    side. |'
  prefs: []
  type: TYPE_TB
- en: '![hosw 1005](assets/hosw_1005.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-5\. Example of a REST service
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: REST Assured
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: REST APIs are ubiquitous. As usual, it is highly recommended to implement automated
    tests for verifying these services, for instance, by using [REST Assured](https://rest-assured.io).
    REST Assured is a popular open source (Apache 2.0 license) Java library for testing
    REST services. It provides a fluent API for testing and validating REST services.
    A convenient way to create readable assertions with REST Assured is to generate
    POJOs (Plain Old Java Objects) to map the REST responses (e.g., in JSON format)
    as Java classes. Then, we can use a library like AssertJ to verify the expected
    conditions using the accessors (i.e., the getter methods) of these POJOs. [Example 10-2](#rest-assured-test)
    shows a test case using this approach. [Example 10-3](#rest-assured-pojo) contains
    the POJO used in this test.
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-2\. Test using REST Assured
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_beyond_selenium_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We use REST Assured to request an online public REST service using the `GET`
    HTTP method. This line also verifies the expected status code (`200`) and converts
    the response payload (in JSON) to a Java class (shown in [Example 10-3](#rest-assured-pojo)).
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_beyond_selenium_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We assert the header list (using the corresponding accessor method) contains
    a given key value.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_beyond_selenium_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We assert that the origin is not blank.
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-3\. POJO class for testing a REST service
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_beyond_selenium_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: This POJO defines a set of attributes to map the JSON response payload using
    Java.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_beyond_selenium_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We define accessors (getters) and mutators (setters) for each class attribute.
    Modern IDEs allow generating these methods automatically from the class attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatives to Selenium
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Selenium is currently the leading technology for implementing end-to-end tests.
    Nevertheless, it is not the only alternative available. This section provides
    an overview of other frameworks and libraries that also allow implementing end-to-end
    tests for web applications. In addition, the following subsections also review
    the main pros and cons of each of these alternatives. In my opinion, Selenium
    is still the reference solution for end-to-end testing since it is built to promote
    web standards (i.e., the W3C WebDriver and WebDriver BiDi) to support the automation
    process and, therefore, it guarantees cross-browser compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: Cypress
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Cypress](https://www.cypress.io) is a JavaScript end-to-end automated testing
    framework. As illustrated in [Figure 10-6](#cypress-arch), the Cypress architecture
    consists of a Node.js process plus a tool called *Test Runner* executed in a browser.'
  prefs: []
  type: TYPE_NORMAL
- en: '![hosw 1006](assets/hosw_1006.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-6\. Cypress architecture
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The Test Runner is an interactive web application that embeds a test based on
    [Mocha](https://mochajs.org) (a JavaScript unit testing framework) plus the web
    application under test as two iframes. Test code and the application code run
    in the same browser tab (i.e., in the same JavaScript loop). The Node.js process
    communicates with the Test Runner using a WebSocket. Finally, the Node.js process
    is a proxy for the HTTP traffic between the Test Runner and the web application
    under test.
  prefs: []
  type: TYPE_NORMAL
- en: The Cypress Test Runner is open source, licensed under the terms of the MIT
    license. The Cypress team also provides commercial support for advanced features.
    One of them is the Cypress Dashboard, a cloud-managed web application that allows
    tracking the tests executed in Test Runner. [Table 10-5](#cypress-pros-cons) summarizes
    some of the most relevant pros and cons of Cypress.
  prefs: []
  type: TYPE_NORMAL
- en: Table 10-5\. Cypress pros and cons
  prefs: []
  type: TYPE_NORMAL
- en: '| Pros | Cons |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Automatic waiting and fast execution, since the test and the application run
    in the same browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Live reload (the Test Runner automatically keeps track of changes in the tests)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'Only some browsers supported: Firefox and Chromium-based (including Chrome,
    Edge, and Electron), but not other browsers like Safari or Opera'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since the application is executed in a browser iframe, certain operations are
    not allowed (e.g., drive different browsers or multiple tabs)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: The following commands show how to install Cypress locally and execute it. After
    executing these commands, you will see the Cypress GUI (like in [Figure 10-7](#cypress-process)).
    You can use this GUI to execute tests with Cypress.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_beyond_selenium_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We can use `npm` (the default package manager in Node.js) for installing Cypress.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_beyond_selenium_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We can use `npx` (an `npm` package runner) for running the Cypress process.
  prefs: []
  type: TYPE_NORMAL
- en: '![hosw 1007](assets/hosw_1007.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-7\. Cypress GUI
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: By default, in the Cypress GUI, you can find introductory test examples in the
    folders `1-getting-started` and `2-advanced-examples`. In addition, we can create
    new tests using the button New Spec File. For instance, [Example 10-4](#cypress-helloworld)
    shows a brand-new basic test using Cypress (i.e., a *hello world* in Cypress).
    This test is called `hello-world-cypress.spec.js` (the extension `spec.js` is
    used by default in Mocha tests), and it is stored in the path `cypress/integration`
    of the Cypress installation. [Figure 10-8](#cypress-test-runner) shows a screenshot
    of the Cypress Test Runner during the execution of this test.
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-4\. Hello world test using Cypress
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_beyond_selenium_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We open the login page in the practice site.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_beyond_selenium_CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We type the correct credentials (username and password).
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_beyond_selenium_CO6-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We click on the Submit button.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_beyond_selenium_CO6-4)'
  prefs: []
  type: TYPE_NORMAL
- en: We verify the resulting page contains the message for successful login.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_beyond_selenium_CO6-5)'
  prefs: []
  type: TYPE_NORMAL
- en: We make a browser screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: '![hosw 1008](assets/hosw_1008.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-8\. Cypress Test Runner
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: WebDriverIO
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[WebDriverIO](https://webdriver.io) is an automated testing framework for web
    and mobile applications. It is entirely open source (MIT license) and based on
    web standards such as the W3C WebDriver protocol. [Figure 10-9](#webdriverio-arch)
    illustrates its architecture. WebDriverIO is written in JavaScript and runs on
    Node.js. It uses several *services* to support automation: chromedriver (for local
    Chrome browsers), Selenium Server (for other browsers), Appium Server (for mobile
    devices), Chrome DevTools (for Chromium-based local browsers using the CDP), and
    cloud providers (such as Sauce Labs, BrowserStack, or TestingBot). These services
    manipulate the corresponding browsers and mobile devices. [Table 10-6](#webdriverio-pros-cons)
    summarizes some of the pros and cons of WebDriverIO.'
  prefs: []
  type: TYPE_NORMAL
- en: '![hosw 1009](assets/hosw_1009.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-9\. WebDriverIO architecture
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Table 10-6\. WebDriverIO pros and cons
  prefs: []
  type: TYPE_NORMAL
- en: '| Pros | Cons |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Support for multiple browsers and mobile devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Works with different testing and reporting frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Based on web standards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Only available using JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `npm` command installs WebDriverIO locally. This installer displays
    a command-line wizard that asks for several options, such as the services (chomedriver,
    Selenium Server, Appium Server, CDP, or cloud providers), testing framework (Mocha,
    Jasmine, or Cucumber), or reporter tool (JUnit or Allure, among others):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When the previous command finishes, we can create our custom tests. For instance,
    [Example 10-5](#webdriverio-helloworld) shows a basic WebDriverIO using Mocha.
    We locate this test under the folder `test` of the project scaffolding and run
    it through the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Example 10-5\. Hello world test using WebDriverIO
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: TestCafe
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[TestCafe](https://testcafe.io) is an open source (MIT license) cross-browser
    automation testing tool. The core idea of TestCafe is to avoid external drivers
    to support the automation process and emulate the user actions using a hybrid
    client-server architecture (see [Figure 10-10](#testcafe-arch)). The server side
    is implemented in Node.js and contains a *proxy* that intercepts the HTTP traffic
    with the web application under test. TestCafe tests are also written as Node.js
    scripts and are executed on the server side. The *automation scripts* that emulate
    the user activity run on the client side on the tested page in the browser. [Table 10-7](#testcafe-pros-cons)
    summarizes some advantages and limitations of TestCafe.'
  prefs: []
  type: TYPE_NORMAL
- en: '![hosw 1010](assets/hosw_1010.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-10\. TestCafe architecture
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Table 10-7\. TestCafe pros and cons
  prefs: []
  type: TYPE_NORMAL
- en: '| Pros | Cons |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Full cross-browser support (since TestCafe only launches browsers, it can automate
    any browser)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: It supports only JavaScript and TypeScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some actions cannot be automated since it is not possible with JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can install TestCafe easily using `npm`. Then, we can use the TestCafe CLI
    tool to run TestCafe scripts from the command line. The following snippet illustrates
    how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_beyond_selenium_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We install TestCafe globally.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_beyond_selenium_CO7-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We start a TestCafe basic script ([Example 10-6](#testcafe-helloworld)) using
    Chrome as a browser.
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-6\. Hello world test using TestCafe
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Puppeteer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Puppeteer](https://pptr.dev) is an open source (MIT license) Node.js library
    that provides a high-level API to control Chromium-based browsers over the DevTools
    Protocol. Puppeteer is maintained by the Chrome DevTools team at Google. [Figure 10-11](#puppeter-arch)
    illustrates the architecture of Puppeteer. [Table 10-8](#puppeter-pros-cons) presents
    the main advantages and drawbacks of Puppeteer.'
  prefs: []
  type: TYPE_NORMAL
- en: '![hosw 1011](assets/hosw_1011.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-11\. Puppeteer architecture
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Table 10-8\. Puppeteer pros and cons
  prefs: []
  type: TYPE_NORMAL
- en: '| Pros | Cons |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Fast execution and comprehensive automation capabilities (due to direct communication
    with the browser using CDP)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Limited cross-browser support (only Chromium-based browsers, although there
    is experimental Firefox support at the time of writing)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supports only JavaScript and TypeScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can install Puppeteer using `npm`. Then, we need to use Node.js to run Puppeteer
    tests (for instance, [Example 10-7](#puppeter-helloworld)). The following snippet
    shows these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Example 10-7\. Hello world test using Puppeteer
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_beyond_selenium_CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Puppeteer runs browsers in headless mode by default. It can be configured to
    use nonheadless browsers simply by changing this statement to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Playwright
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Playwright](https://playwright.dev) is an open source (Apache 2.0 license)
    library for browser automation supported by Microsoft. Playwright originally started
    as a Node.js library. In addition to JavaScript, it now supports other programming
    languages, namely Python, Java, and .NET C#.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Playwright supports three types of web engines: Chromium, Firefox, and WebKit
    (i.e., the web browser engine used by Safari). The idea of supporting these engines
    is that they cover most of the browser market. Thus, the Playwright team maintains
    a patched version of these browsers that expose the necessary capabilities to
    enable the automation. These patched versions provide an event-driven architecture
    to access different internal browser processes (e.g., the render, network, browser,
    or service worker processes). [Figure 10-12](#playwright-arch) illustrates this
    architecture. [Table 10-9](#playwright-pros-cons) contains some of the most relevant
    pros and cons for Playwright.'
  prefs: []
  type: TYPE_NORMAL
- en: '![hosw 1012](assets/hosw_1012.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-12\. Playwright architecture
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Table 10-9\. Playwright pros and cons
  prefs: []
  type: TYPE_NORMAL
- en: '| Pros | Cons |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Autowaiting for elements to be ready
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multilanguage API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provides a test generator by recording user actions in the browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows browser session recording
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intercepts network traffic for stubbing and mocking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Uses patched browser versions instead of actual releases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use Playwright, we need first to install the patched browser binaries. We
    can use `npm` to that aim. The following command downloads the proper browser
    binaries for Chromium, Firefox, and WebKit for the operating system running this
    command (Windows, Linux, and macOS are supported):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can implement Playwright scripts using one supported API. For instance,
    when using the JavaScript API, we can use a third-party test runner (e.g., Jest,
    Jasmine, Mocha, etc.) or use the Playwright Test (i.e., the test runner provided
    by the Playwright team). To use the latter, we need to install it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 10-8](#webdriverio-playwright) contains a basic Playwright JavaScript
    test to be executed with the Playwright runner. This command supposes that this
    test (called `helloworld-playwright.spec.mjs`) is located under the `tests` directory.
    We can invoke the Playwright runner as shown in the following snippet to run this
    test. This command runs Playwright tests in headless mode by default. To run browsers
    in nonheadless mode, you need to include the flag `--headed` at the of the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Example 10-8\. Hello world test using Playwright
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Summary and Final Remarks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Web development is a heterogeneous discipline that involves many different
    technologies, such as client side, server side, or integration with external services,
    to name a few. For this reason, this chapter introduced two complementary technologies
    for Selenium that can be helpful in testing web applications: Appium (an open
    source test automation framework for mobile apps) and REST Assured (an open source
    Java library for testing REST services). You also learned the basics of alternative
    tools for implementing end-to-end tests for web applications, namely Cypress,
    WebDriverIO, TestCafe, Puppeteer, and Playwright. Although these alternatives
    deliver remarkable advantages compared to Selenium (e.g., automated waiting),
    in my opinion, Selenium provides a more comprehensive automation model since it
    is built on top of web standards, such as the W3C WebDriver and WebDriver BiDi.
    In addition, the Selenium project actively participates in the deelopment of these
    specifications.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter concludes your journey through the development of end-to-end tests
    with Selenium. The next step is to put all the knowledge presented in this book
    into practice in your projects. This way, you can build your custom automation
    framework for your team, project, company, etc. There are many decisions you need
    to make, such as the project setup (e.g., Maven, Gradle), unit testing framework
    (e.g., JUnit, TestNG), browser infrastructure (e.g., Docker, cloud providers),
    and integration with third-party utilities. To deal with all of this complexity,
    as a final word, I recommend you play with the provided examples in this book.
    In other words: clone the repository, run the tests, and edit the code to fulfill
    your needs. I will maintain the GitHub repo after the book is published. And remember:
    it is an open source software project, so feel free to create a pull request to
    improve it if you want to contribute.'
  prefs: []
  type: TYPE_NORMAL
