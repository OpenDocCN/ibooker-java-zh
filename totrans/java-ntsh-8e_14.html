<html><head></head><body>
<div id="sbo-rt-content"><section data-nutshell-tab="Modules" data-pdf-bookmark="Chapter 12. Java Platform Modules" data-type="chapter" epub:type="chapter"><div class="chapter" id="javanut8-CHP-12">
<h1><span class="label">Chapter 12. </span>Java Platform Modules</h1>
<p><a data-primary="Java Platform Modules System (JPMS)" data-type="indexterm" id="ix_ch12-asciidoc0"/>In this chapter, we will provide a basic introduction to the <em>Java Platform Modules System</em> (JPMS).
However, this is a large, complex subject—​interested readers may well require a more in-depth reference, such as <a class="orm:hideurl" href="http://shop.oreilly.com/product/0636920049494.do"><em>Java 9 Modularity</em></a> by Sander Mak and Paul Bakker (O’Reilly).</p>
<p><a data-primary="modules" data-seealso="Java Platform Modules System [JPMS]" data-type="indexterm" id="idm45927701124320"/>Modules, a relatively advanced feature, are primarily about packaging and deploying entire applications and their dependencies.
They were added to the platform roughly 20 years after the first version of Java and so can be seen as orthogonal to the rest of the language syntax.</p>
<p>Java’s strong promotion of backwards compatibility also plays a role here, as non-modular applications must continue to run.
This has led the architects and stewards of the Java platform to adopt a pragmatic view of the necessity of teams to adopt modules.</p>
<blockquote>
<p>There is no need to switch to modules.</p>
<p>There has never been a need to switch to modules.</p>
<p><a data-primary="Java 9" data-primary-sortas="Java 09" data-secondary="platform modules" data-type="indexterm" id="idm45927701121200"/>Java 9 and later releases support traditional JAR files on the traditional classpath, via the concept of the unnamed
module, and will likely do so until the heat death of the universe.</p>
<p>Whether to start using modules is entirely up to you.</p>
<p data-type="attribution">Mark Reinhold <br/>https://oreil.ly/4RjDH</p>
</blockquote>
<p>Due to the advanced nature of modules, this chapter assumes you are familiar with a modern Java build tool, such as Gradle or Maven.</p>
<p>If you are new to Java, you can safely ignore references to those tools and just read the chapter to get a first, high-level overview of JPMS.
It is not necessary for a new Java programmer to fully understand this topic while still learning how to write Java programs.</p>
<section data-pdf-bookmark="Why Modules?" data-type="sect1"><div class="sect1" id="idm45927701117472">
<h1>Why Modules?</h1>
<p><a data-primary="Java Platform Modules System (JPMS)" data-secondary="reasons for creation of" data-type="indexterm" id="idm45927701115872"/>There were several major motivating reasons for wanting to add modules to the Java platform.
These included a desire for:</p>
<ul>
<li>
<p>Strong encapsulation</p>
</li>
<li>
<p>Well-defined interfaces</p>
</li>
<li>
<p>Explicit dependencies</p>
</li>
</ul>
<p>These are all language (and application design) level, and they were combined with the promise of new platform-level capabilities as well:</p>
<ul>
<li>
<p>Scalable development</p>
</li>
<li>
<p>Improved performance (especially startup time) and reduced footprint</p>
</li>
<li>
<p>Reduced attack surface and better security</p>
</li>
<li>
<p>Evolvable internals</p>
</li>
</ul>
<p>The encapsulation point was driven by the fact that the original language specification supports only private, public, protected, and package-private visibility levels.
There is no way to control access in a more fine-grained way to express concepts such as:</p>
<ul>
<li>
<p>Only specified packages are available as an API—others are internal and may not be accessed</p>
</li>
<li>
<p>Certain packages can be accessed by this list of packages but no others</p>
</li>
<li>
<p>Defining a strict exporting mechanism</p>
</li>
</ul>
<p>The lack of these and related capabilities has been a significant shortcoming when architecting larger Java systems.
Not only that, but without a suitable protection mechanism, it would be very difficult to evolve the internals of the JDK—as nothing prevents user applications from directly accessing implementation classes.</p>
<p>The modules system attempts to address all of these concerns at once and to provide a solution that works both for the JDK and for user applications.</p>
<section data-pdf-bookmark="Modularizing the JDK" data-type="sect2"><div class="sect2" id="idm45927700965920">
<h2>Modularizing the JDK</h2>
<p><a data-primary="Java Platform Modules System (JPMS)" data-secondary="modularizing the JDK" data-type="indexterm" id="ix_ch12-asciidoc1"/><a data-primary="JDK (Java Development Kit)" data-secondary="modularizing of" data-type="indexterm" id="ix_ch12-asciidoc2"/>The monolithic JDK that shipped with Java 8 was the first target for the modules system, and the familiar <code>rt.jar</code> was broken up into modules.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Java 8 had begun the work of modularization, by shipping a feature called <em>Compact Profiles</em> that tidied up the code and made it possible to ship a reduced runtime footprint.</p>
</div>
<p><a data-primary="java.base" data-type="indexterm" id="idm45927700959184"/><code>java.base</code> is the module that represents the minimum that’s actually needed for a Java application to start up.
It contains core packages, such as:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">java</code><code class="p">.</code><code class="na">io</code><code class="w"/>
<code class="n">java</code><code class="p">.</code><code class="na">lang</code><code class="w"/>
<code class="n">java</code><code class="p">.</code><code class="na">math</code><code class="w"/>
<code class="n">java</code><code class="p">.</code><code class="na">net</code><code class="w"/>
<code class="n">java</code><code class="p">.</code><code class="na">nio</code><code class="w"/>
<code class="n">java</code><code class="p">.</code><code class="na">security</code><code class="w"/>
<code class="n">java</code><code class="p">.</code><code class="na">text</code><code class="w"/>
<code class="n">java</code><code class="p">.</code><code class="na">time</code><code class="w"/>
<code class="n">java</code><code class="p">.</code><code class="na">util</code><code class="w"/>
<code class="n">javax</code><code class="p">.</code><code class="na">crypto</code><code class="w"/>
<code class="n">javax</code><code class="p">.</code><code class="na">net</code><code class="w"/>
<code class="n">javax</code><code class="p">.</code><code class="na">security</code><code class="w"/></pre>
<p>along with some subpackages and nonexported implementation packages such as <code>sun.text.resources</code>.
Some of the differences in compilation behavior between Java 8 and modular Java can be seen in this simple program, which extends an internal public class contained in <code>java.base</code>:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kn">import</code><code class="w"> </code><code class="nn">java.util.Arrays</code><code class="p">;</code><code class="w"/>
<code class="kn">import</code><code class="w"> </code><code class="nn">sun.text.resources.FormatData</code><code class="p">;</code><code class="w"/>

<code class="kd">public</code><code class="w"> </code><code class="kd">final</code><code class="w"> </code><code class="kd">class</code> <code class="nc">FormatStealer</code><code class="w"> </code><code class="kd">extends</code><code class="w"> </code><code class="n">FormatData</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kd">static</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">main</code><code class="p">(</code><code class="n">String</code><code class="o">[]</code><code class="w"> </code><code class="n">args</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">FormatStealer</code><code class="w"> </code><code class="n">fs</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">FormatStealer</code><code class="p">();</code><code class="w"/>
<code class="w">        </code><code class="n">fs</code><code class="p">.</code><code class="na">run</code><code class="p">();</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="kd">private</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">run</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">String</code><code class="o">[]</code><code class="w"> </code><code class="n">s</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="n">String</code><code class="o">[]</code><code class="p">)</code><code class="w"> </code><code class="n">handleGetObject</code><code class="p">(</code><code class="s">"japanese.Eras"</code><code class="p">);</code><code class="w"/>
<code class="w">        </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">Arrays</code><code class="p">.</code><code class="na">toString</code><code class="p">(</code><code class="n">s</code><code class="p">));</code><code class="w"/>

<code class="w">        </code><code class="n">Object</code><code class="o">[][]</code><code class="w"> </code><code class="n">contents</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">getContents</code><code class="p">();</code><code class="w"/>
<code class="w">        </code><code class="n">Object</code><code class="o">[]</code><code class="w"> </code><code class="n">eraData</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">contents</code><code class="o">[</code><code class="mi">14</code><code class="o">]</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="n">Object</code><code class="o">[]</code><code class="w"> </code><code class="n">eras</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="n">Object</code><code class="o">[]</code><code class="p">)</code><code class="n">eraData</code><code class="o">[</code><code class="mi">1</code><code class="o">]</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">Arrays</code><code class="p">.</code><code class="na">toString</code><code class="p">(</code><code class="n">eras</code><code class="p">));</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Attempting to compile the code on Java 11 produces this error message:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">$</code><code class="w"> </code><code class="n">javac</code><code class="w"> </code><code class="n">javanut8</code><code class="o">/</code><code class="n">ch12</code><code class="o">/</code><code class="n">FormatStealer</code><code class="p">.</code><code class="na">java</code><code class="w"/>
<code class="n">javanut8</code><code class="o">/</code><code class="n">ch12</code><code class="o">/</code><code class="n">FormatStealer</code><code class="p">.</code><code class="na">java</code><code class="p">:</code><code class="mi">4</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="n">error</code><code class="p">:</code><code class="w"> </code><code class="kn">package</code><code class="w"> </code><code class="nn">sun.text.resources</code><code class="w"> </code><code class="n">is</code><code class="w"> </code><code class="n">not</code><code class="w"> </code><code class="n">visible</code><code class="w"/>
<code class="kn">import</code><code class="w"> </code><code class="nn">sun.text.resources.FormatData</code><code class="p">;</code><code class="w"/>
<code class="w">               </code><code class="o">^</code><code class="w"/>
<code class="w">  </code><code class="p">(</code><code class="kn">package</code><code class="w"> </code><code class="nn">sun.text.resources</code><code class="w"> </code><code class="n">is</code><code class="w"> </code><code class="n">declared</code><code class="w"> </code><code class="n">in</code><code class="w"> </code><code class="n">module</code><code class="w"/>
<code class="w">        </code><code class="n">java</code><code class="p">.</code><code class="na">base</code><code class="p">,</code><code class="w"> </code><code class="n">which</code><code class="w"> </code><code class="n">does</code><code class="w"> </code><code class="n">not</code><code class="w"> </code><code class="n">export</code><code class="w"> </code><code class="n">it</code><code class="w"> </code><code class="n">to</code><code class="w"> </code><code class="n">the</code><code class="w"> </code><code class="n">unnamed</code><code class="w"> </code><code class="n">module</code><code class="p">)</code><code class="w"/>
<code class="n">javanut8</code><code class="o">/</code><code class="n">ch12</code><code class="o">/</code><code class="n">FormatStealer</code><code class="p">.</code><code class="na">java</code><code class="p">:</code><code class="mi">14</code><code class="p">:</code><code class="w"> </code><code class="n">error</code><code class="p">:</code><code class="w"> </code><code class="n">cannot</code><code class="w"> </code><code class="n">find</code><code class="w"> </code><code class="n">symbol</code><code class="w"/>
<code class="w">        </code><code class="n">String</code><code class="o">[]</code><code class="w"> </code><code class="n">s</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="n">String</code><code class="o">[]</code><code class="p">)</code><code class="w"> </code><code class="n">handleGetObject</code><code class="p">(</code><code class="s">"japanese.Eras"</code><code class="p">);</code><code class="w"/>
<code class="w">                                </code><code class="o">^</code><code class="w"/>
<code class="w">  </code><code class="n">symbol</code><code class="p">:</code><code class="w">   </code><code class="n">method</code><code class="w"> </code><code class="nf">handleGetObject</code><code class="p">(</code><code class="n">String</code><code class="p">)</code><code class="w"/>
<code class="w">  </code><code class="n">location</code><code class="p">:</code><code class="w"> </code><code class="kd">class</code> <code class="nc">FormatStealer</code><code class="w"/>
<code class="n">javanut8</code><code class="o">/</code><code class="n">ch12</code><code class="o">/</code><code class="n">FormatStealer</code><code class="p">.</code><code class="na">java</code><code class="p">:</code><code class="mi">17</code><code class="p">:</code><code class="w"> </code><code class="n">error</code><code class="p">:</code><code class="w"> </code><code class="n">cannot</code><code class="w"> </code><code class="n">find</code><code class="w"> </code><code class="n">symbol</code><code class="w"/>
<code class="w">        </code><code class="n">Object</code><code class="o">[][]</code><code class="w"> </code><code class="n">contents</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">getContents</code><code class="p">();</code><code class="w"/>
<code class="w">                              </code><code class="o">^</code><code class="w"/>
<code class="w">  </code><code class="n">symbol</code><code class="p">:</code><code class="w">   </code><code class="n">method</code><code class="w"> </code><code class="nf">getContents</code><code class="p">()</code><code class="w"/>
<code class="w">  </code><code class="n">location</code><code class="p">:</code><code class="w"> </code><code class="kd">class</code> <code class="nc">FormatStealer</code><code class="w"/>
<code class="mi">3</code><code class="w"> </code><code class="n">errors</code><code class="w"/></pre>
<p>With a modular Java, even classes that are public cannot be accessed unless they are explicitly exported by the module they are defined in.
We can temporarily force the compiler to use the internal package (basically reasserting the old access rules) with the <code>--add-exports</code> switch, like this:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">$</code><code class="w"> </code><code class="n">javac</code><code class="w"> </code><code class="o">--</code><code class="n">add</code><code class="o">-</code><code class="n">exports</code><code class="w"> </code><code class="n">java</code><code class="p">.</code><code class="na">base</code><code class="o">/</code><code class="n">sun</code><code class="p">.</code><code class="na">text</code><code class="p">.</code><code class="na">resources</code><code class="o">=</code><code class="n">ALL</code><code class="o">-</code><code class="n">UNNAMED</code><code class="w"> </code><code class="err">\</code><code class="w"/>
<code class="w">        </code><code class="n">javanut8</code><code class="o">/</code><code class="n">ch12</code><code class="o">/</code><code class="n">FormatStealer</code><code class="p">.</code><code class="na">java</code><code class="w"/>
<code class="n">javanut8</code><code class="o">/</code><code class="n">ch12</code><code class="o">/</code><code class="n">FormatStealer</code><code class="p">.</code><code class="na">java</code><code class="p">:</code><code class="mi">5</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="n">warning</code><code class="p">:</code><code class="w"> </code><code class="n">FormatData</code><code class="w"> </code><code class="n">is</code><code class="w"> </code><code class="n">internal</code><code class="w"> </code><code class="n">proprietary</code><code class="w"> </code><code class="n">API</code><code class="w"> </code><code class="n">and</code><code class="w"> </code><code class="n">may</code><code class="w"> </code><code class="n">be</code><code class="w"/>
<code class="w">        </code><code class="n">removed</code><code class="w"> </code><code class="n">in</code><code class="w"> </code><code class="n">a</code><code class="w"> </code><code class="n">future</code><code class="w"> </code><code class="n">release</code><code class="w"/>
<code class="kn">import</code><code class="w"> </code><code class="nn">sun.text.resources.FormatData</code><code class="p">;</code><code class="w"/>
<code class="w">                         </code><code class="o">^</code><code class="w"/>
<code class="n">javanut8</code><code class="o">/</code><code class="n">ch12</code><code class="o">/</code><code class="n">FormatStealer</code><code class="p">.</code><code class="na">java</code><code class="p">:</code><code class="mi">7</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="n">warning</code><code class="p">:</code><code class="w"> </code><code class="n">FormatData</code><code class="w"> </code><code class="n">is</code><code class="w"> </code><code class="n">internal</code><code class="w"> </code><code class="n">proprietary</code><code class="w"> </code><code class="n">API</code><code class="w"> </code><code class="n">and</code><code class="w"> </code><code class="n">may</code><code class="w"> </code><code class="n">be</code><code class="w"/>
<code class="w">        </code><code class="n">removed</code><code class="w"> </code><code class="n">in</code><code class="w"> </code><code class="n">a</code><code class="w"> </code><code class="n">future</code><code class="w"> </code><code class="n">release</code><code class="w"/>
<code class="kd">public</code><code class="w"> </code><code class="kd">final</code><code class="w"> </code><code class="kd">class</code> <code class="nc">FormatStealer</code><code class="w"> </code><code class="kd">extends</code><code class="w"> </code><code class="n">FormatData</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">                                         </code><code class="o">^</code><code class="w"/>
<code class="mi">2</code><code class="w"> </code><code class="n">warnings</code><code class="w"/></pre>
<p>We need to specify that the export is being granted to the <em>unnamed module</em>, as we are compiling our class standalone and not as part of a module.
The compiler warns us that we’re using an internal API and that this might break with a future release of Java.
When compiled and run under Java 11, this produces a list of Japanese eras, like this:</p>
<pre data-type="programlisting">[, Meiji, Taisho, Showa, Heisei, Reiwa]
[, Meiji, Taisho, Showa, Heisei, Reiwa]</pre>
<p>However, if we try to run under Java 17, then we have a different result:</p>
<pre data-code-language="bash" data-type="programlisting">$<code class="w"> </code>java<code class="w"> </code>javanut8.ch12.FormatStealer<code class="w"/>

Error:<code class="w"> </code>LinkageError<code class="w"> </code>occurred<code class="w"> </code><code class="k">while</code><code class="w"> </code>loading<code class="w"> </code>main<code class="w"> </code>class<code class="w"/>
<code class="w">        </code>javanut8.ch12.FormatStealer<code class="w"/>

java.lang.IllegalAccessError:<code class="w"> </code>superclass<code class="w"> </code>access<code class="w"> </code>check<code class="w"> </code>failed:<code class="w"/>

class<code class="w"> </code>javanut8.ch12.FormatStealer<code class="w"> </code><code class="o">(</code><code class="k">in</code><code class="w"> </code>unnamed<code class="w"> </code>module<code class="w"> </code>@0x647c3190<code class="o">)</code><code class="w"/>
<code class="w">        </code>cannot<code class="w"> </code>access<code class="w"> </code>class<code class="w"> </code>sun.text.resources.FormatData<code class="w"> </code><code class="o">(</code><code class="k">in</code><code class="w"> </code>module<code class="w"/>
<code class="w">        </code>java.base<code class="o">)</code><code class="w"> </code>because<code class="w"> </code>module<code class="w"> </code>java.base<code class="w"> </code>does<code class="w"> </code>not<code class="w"> </code><code class="nb">export</code><code class="w"/>
<code class="w">        </code>sun.text.resources<code class="w"> </code>to<code class="w"> </code>unnamed<code class="w"> </code>module<code class="w"> </code>@0x647c3190<code class="w"/></pre>
<p><a data-primary="Java 17" data-secondary="modularizing the JDK" data-type="indexterm" id="idm45927700174640"/>This is because Java 17 now enforces additional checks as part of the tightening up of encapsulation of the internals.
To get the program to run, we need to add the <code>--add-exports</code> runtime flag as well:</p>
<pre data-code-language="bash" data-type="programlisting">$<code class="w"> </code>java<code class="w"> </code>--add-exports<code class="w"> </code>java.base/sun.text.resources<code class="o">=</code>ALL-UNNAMED<code class="w"> </code><code class="se">\</code>
<code class="w">        </code>javanut8.ch12.FormatStealer<code class="w"/>
<code class="o">[</code>,<code class="w"> </code>Meiji,<code class="w"> </code>Taisho,<code class="w"> </code>Showa,<code class="w"> </code>Heisei,<code class="w"> </code>Reiwa<code class="o">]</code><code class="w"/>
<code class="o">[</code>,<code class="w"> </code>Meiji,<code class="w"> </code>Taisho,<code class="w"> </code>Showa,<code class="w"> </code>Heisei,<code class="w"> </code>Reiwa<code class="o">]</code><code class="w"/></pre>
<p>Although <code>java.base</code> is the absolute runtime minimum that an application needs to start up, at compile time we want the visible platform to be as close to the old (Java 8) experience as possible.</p>
<p><a data-primary="java.se module" data-type="indexterm" id="idm45927700087728"/><a data-primary="umbrella module" data-type="indexterm" id="idm45927700087088"/>This means that we use a much larger set of modules, contained under an <em>umbrella</em> module, <code>java.se</code>.
This module has a dependency graph, shown in <a data-type="xref" href="#javanut8-CHP-12-FIG-1">Figure 12-1</a>.</p>
<figure><div class="figure" id="javanut8-CHP-12-FIG-1">
<img alt="JN7 1201" height="288" src="assets/jns8_1201.png" width="600"/>
<h6><span class="label">Figure 12-1. </span>Module dependency graph of java.se</h6>
</div></figure>
<p>This brings in almost all of the classes and packages that most Java developers expect to be available.</p>
<p>However, one important exception is that the Java 8 packages defining the CORBA and Java EE APIs (now know as Jakarta EE) have been removed and are not part of <code>java.se</code>.
This means that any project that depends on those APIs will not compile by default on Java 11 onward and a special build config must be used, to explicitly depend upon external libraries that provide these APIs.</p>
<p>Along with these changes to compilation visibility, due to the modularization of the JDK, the modules system is also intended to allow developers to modularize their own code.<a data-startref="ix_ch12-asciidoc2" data-type="indexterm" id="idm45927700080880"/><a data-startref="ix_ch12-asciidoc1" data-type="indexterm" id="idm45927700080176"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Writing Your Own Modules" data-type="sect1"><div class="sect1" id="idm45927700964848">
<h1>Writing Your Own Modules</h1>
<p><a data-primary="Java Platform Modules System (JPMS)" data-secondary="writing your own modules" data-type="indexterm" id="ix_ch12-asciidoc3"/>In this section, we will discuss the basic concepts needed to start writing modular Java applications.</p>
<section data-pdf-bookmark="Basic Modules Syntax" data-type="sect2"><div class="sect2" id="idm45927700076416">
<h2>Basic Modules Syntax</h2>
<p><a data-primary="Java Platform Modules System (JPMS)" data-secondary="basic modules syntax" data-type="indexterm" id="idm45927700074848"/><a data-primary="module descriptor" data-type="indexterm" id="idm45927700073904"/><a data-primary="module-info.java file" data-type="indexterm" id="idm45927700073232"/>The key to modularizing is the new file <em>module-info.java</em>, which contains a description of a module. This is referred to as a <em>module descriptor</em>.</p>
<p>A module is laid out for compilation correctly on the filesystem in the following way:</p>
<ul>
<li>
<p>Below the source root of the project (<em>src</em>), there needs to be a directory named the same as the module (the <em>moduledir</em>).</p>
</li>
<li>
<p>Inside the <em>moduledir</em> is the <em>module-info.java</em>, at the same level as where the packages start from.</p>
</li>
</ul>
<p>The module info is compiled to a binary format, <em>module-info.class</em>, which contains the metadata that will be used when a modular runtime attempts to link and run our application.
Let’s look at a simple example of a <em>module-info.java</em>:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">module</code><code class="w"> </code><code class="n">httpchecker</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">requires</code><code class="w"> </code><code class="n">java</code><code class="p">.</code><code class="na">net</code><code class="p">.</code><code class="na">http</code><code class="p">;</code><code class="w"/>

<code class="w">    </code><code class="n">exports</code><code class="w"> </code><code class="n">httpchecker</code><code class="p">.</code><code class="na">main</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>This introduces some new syntax: <code>module</code>, <code>exports</code>, and <code>requires</code>—but these are not really full keywords in the accepted sense. As stated in the Java Language Specification SE 11:</p>
<blockquote>
<p><a data-primary="restricted keywords" data-type="indexterm" id="idm45927700034496"/>A further ten character sequences are restricted keywords: <code>open</code>, <code>module</code>, <code>requires</code>, <code>transitive</code>, <code>exports</code>, <code>opens</code>, <code>to</code>, <code>uses</code>, <code>provides</code>, and  <code>with</code>. These character sequences are tokenized as keywords solely where they appear as terminals in the <code>ModuleDeclaration</code> and <code>ModuleDirective</code> <span class="keep-together">productions</span>.</p></blockquote>
<p>This means that these restricted keywords can appear only in the module metadata and are compiled into the binary format by <code>javac</code>.
The meanings of the major restricted keywords are:</p>
<dl>
<dt><code>module</code></dt>
<dd>
<p><a data-primary="module keyword" data-type="indexterm" id="idm45927700005264"/>Starts the module’s metadata declaration</p>
</dd>
<dt><code>requires</code></dt>
<dd>
<p><a data-primary="requires keyword" data-type="indexterm" id="idm45927700003264"/>Lists a module on which this module depends</p>
</dd>
<dt><code>exports</code></dt>
<dd>
<p><a data-primary="exports keyword" data-type="indexterm" id="idm45927700001152"/>Declares which packages are exported as an API</p>
</dd>
</dl>
<p>The remaining (module-related) restricted keywords will be introduced throughout the rest of the chapter.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The concept of <em>restricted keyword</em> is considerably expanded in Java 17, and as a result the description is much longer and less clear. We use the older specification here because it refers specifically to the modules system and is more suited to our purposes.</p>
</div>
<p>In our example, this means that we’re declaring a module <code>httpchecker</code> that depends upon the module <code>java.net.http</code> that was standardized in Java 11 (as well as an implicit dependency on <code>java.base</code>).
The module exports a single package, <code>httpchecker.main</code>, which is the only package in this module that will be accessible from other modules at compile time.</p>
</div></section>
<section data-pdf-bookmark="Building a Simple Modular Application" data-type="sect2"><div class="sect2" id="idm45927700075824">
<h2>Building a Simple Modular Application</h2>
<p><a data-primary="Java Platform Modules System (JPMS)" data-secondary="building a simple modular application" data-type="indexterm" id="idm45927699965520"/>As an example, let’s build a simple tool that checks whether websites are using HTTP/2 yet, using the API that we met in <a data-type="xref" href="ch10.xhtml#javanut8-CHP-10">Chapter 10</a>:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kn">import static</code><code class="w"> </code><code class="nn">java.net.http.HttpResponse.BodyHandlers.ofString</code><code class="p">;</code><code class="w"/>

<code class="kd">public</code><code class="w"> </code><code class="kd">final</code><code class="w"> </code><code class="kd">class</code> <code class="nc">HTTP2Checker</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kd">static</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">main</code><code class="p">(</code><code class="n">String</code><code class="o">[]</code><code class="w"> </code><code class="n">args</code><code class="p">)</code><code class="w"> </code><code class="kd">throws</code><code class="w"> </code><code class="n">Exception</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">args</code><code class="p">.</code><code class="na">length</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">0</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="n">System</code><code class="p">.</code><code class="na">err</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="s">"Provide URLS to check"</code><code class="p">);</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">        </code><code class="k">for</code><code class="w"> </code><code class="p">(</code><code class="kd">final</code><code class="w"> </code><code class="kd">var</code><code class="w"> </code><code class="n">location</code><code class="w"> </code><code class="p">:</code><code class="w"> </code><code class="n">args</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="kd">var</code><code class="w"> </code><code class="n">client</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">HttpClient</code><code class="p">.</code><code class="na">newBuilder</code><code class="p">().</code><code class="na">build</code><code class="p">();</code><code class="w"/>
<code class="w">            </code><code class="kd">var</code><code class="w"> </code><code class="n">uri</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">URI</code><code class="p">(</code><code class="n">location</code><code class="p">);</code><code class="w"/>
<code class="w">            </code><code class="kd">var</code><code class="w"> </code><code class="n">req</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">HttpRequest</code><code class="p">.</code><code class="na">newBuilder</code><code class="p">(</code><code class="n">uri</code><code class="p">).</code><code class="na">build</code><code class="p">();</code><code class="w"/>

<code class="w">            </code><code class="kd">var</code><code class="w"> </code><code class="n">response</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">client</code><code class="p">.</code><code class="na">send</code><code class="p">(</code><code class="n">req</code><code class="p">,</code><code class="w"/>
<code class="w">                    </code><code class="n">ofString</code><code class="p">(</code><code class="n">Charset</code><code class="p">.</code><code class="na">defaultCharset</code><code class="p">()));</code><code class="w"/>
<code class="w">            </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">location</code><code class="w"> </code><code class="o">+</code><code class="s">": "</code><code class="o">+</code><code class="w"> </code><code class="n">response</code><code class="p">.</code><code class="na">version</code><code class="p">());</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>This relies on two modules—<code>java.net.http</code> and the ubiquitous <code>java.base</code>.
The module file for the app is very simple:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">module</code><code class="w"> </code><code class="n">http2checker</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">requires</code><code class="w"> </code><code class="n">java</code><code class="p">.</code><code class="na">net</code><code class="p">.</code><code class="na">http</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="n">exports</code><code class="w"> </code><code class="n">httpchecker</code><code class="p">.</code><code class="na">main</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Assuming a simple, standard module layout, this can be compiled like this:</p>
<pre data-code-language="bash" data-type="programlisting">$<code class="w"> </code>javac<code class="w"> </code>-d<code class="w"> </code>out/httpchecker<code class="w"> </code><code class="se">\</code>
<code class="w">        </code>httpchecker/httpchecker/main/HTTP2Checker.java<code class="w"> </code><code class="se">\</code>
<code class="w">        </code>httpchecker/module-info.java<code class="w"/></pre>
<p>This creates a compiled module in the <em>out/</em> directory.
For use, it needs to be packaged as a JAR file:</p>
<pre data-code-language="bash" data-type="programlisting">$<code class="w"> </code>jar<code class="w"> </code>--create<code class="w"> </code>--file<code class="w"> </code>httpchecker.jar<code class="w"> </code><code class="se">\</code>
<code class="w">        </code>--main-class<code class="w"> </code>httpchecker.main.HTTP2Checker<code class="w"> </code><code class="se">\</code>
<code class="w">        </code>-C<code class="w"> </code>out/httpchecker<code class="w"> </code>.<code class="w"/></pre>
<p>The <code>--create</code> switch tells <code>jar</code> to create a new jar, which will include the classes contained in the directory.
The final <code>.</code> at the end of the command is mandatory and signifies that all of the class files (relative to the path specified with <code>-C</code>) should be packaged into the jar.</p>
<p>We used the <code>--main-class</code> switch to set an <em>entry point</em> for the module—​that is, a class to be executed when we use the module as an application.
Let’s see it in action:</p>
<pre data-code-language="bash" data-type="programlisting">$<code class="w"> </code>java<code class="w"> </code>-jar<code class="w"> </code>httpchecker.jar<code class="w"> </code>http://www.google.com<code class="w"/>
http://www.google.com:<code class="w"> </code>HTTP_1_1<code class="w"/>
$<code class="w"> </code>java<code class="w"> </code>-jar<code class="w"> </code>httpchecker.jar<code class="w"> </code>https://www.google.com<code class="w"/>
https://www.google.com:<code class="w"> </code>HTTP_2<code class="w"/></pre>
<p>This shows that, at the time of writing, Google’s website was using HTTP/2 to serve its main page over HTTPS but still using HTTP/1.1 for the legacy unencrypted HTTP service.</p>
<p>Now that we have seen how to compile and run a simple modular application, let’s meet some more of the core features of modularity that are needed to build and run full-size applications.</p>
</div></section>
<section data-pdf-bookmark="The Module Path" data-type="sect2"><div class="sect2" id="idm45927699966112">
<h2>The Module Path</h2>
<p><a data-primary="Java Platform Modules System (JPMS)" data-secondary="module path" data-type="indexterm" id="idm45927699621680"/><a data-primary="module path" data-type="indexterm" id="idm45927699586448"/>Many Java developers are familiar with the concept of the classpath.
When working with modular Java applications, we instead need to work with the <em>module path</em>.
This is a new concept for modules that replaces the classpath wherever possible.</p>
<p>Modules carry metadata about their exports and dependencies—they are not just a long list of types.
This means a graph of module dependencies can be built easily and module resolution can proceed efficiently.</p>
<p>Code that is not yet modularized continues to be placed on the classpath.
This code is loaded into the <em>unnamed module</em>, which is special and can read all other modules that can be reached from <code>java.se</code>.
Using the unnamed module happens automatically when classes are placed
on the classpath.</p>
<p>This provides a migration path to adopting a modular Java runtime without having to migrate to a fully modular application path.
However, it does have two major drawbacks: none of the benefits of modules will be available until the app is fully migrated, and the self-consistency of the classpath must be maintained by hand until modularization is complete.</p>
</div></section>
<section data-pdf-bookmark="Automatic Modules" data-type="sect2"><div class="sect2" id="idm45927699582832">
<h2>Automatic Modules</h2>
<p><a data-primary="automatic modules" data-type="indexterm" id="idm45927699581552"/><a data-primary="Java Platform Modules System (JPMS)" data-secondary="automatic modules" data-type="indexterm" id="idm45927699580848"/>One of the constraints of the modules system is that we can’t reference JARs on the classpath from named modules.
This is a safety feature—the designers of the module system wanted the module dependency graph to utilize full metadata and be able to rely on the completeness of that metadata.</p>
<p>However, there may be times when modular code needs to reference packages that have not yet been modularized.
The solution for this is to place the unmodified JAR onto the module path directly (and remove it from the classpath).
A JAR placed on the module path like this becomes an <em>automatic module</em>.</p>
<p>This has the following features:</p>
<ul>
<li>
<p>Module name derived from JAR name (or read from <code>MANIFEST.MF</code>)</p>
</li>
<li>
<p>Exports every package</p>
</li>
<li>
<p>Requires all other modules (including the unnamed module)</p>
</li>
</ul>
<p>This is another feature designed to mitigate and help with migration, but some safety is still being given up by using automatic modules.</p>
</div></section>
<section data-pdf-bookmark="Open Modules" data-type="sect2"><div class="sect2" id="javanut8-CHP-12-SECT-2-5">
<h2>Open Modules</h2>
<p><a data-primary="Java Platform Modules System (JPMS)" data-secondary="open modules" data-type="indexterm" id="ix_ch12-asciidoc4"/><a data-primary="open modules" data-type="indexterm" id="ix_ch12-asciidoc5"/>As noted, simply marking a method <code>public</code> no longer guarantees that the element will be accessible everywhere.
Instead, accessibility also now depends upon whether the package containing that element is exported by its defining module.
Another major issue in the design of modules is the use of reflection to access classes.</p>
<p>Reflection is such a wide-ranging, general-purpose mechanism that it is difficult to see, at first glance, how it can be reconciled with the strong encapsulation goals of JPMS.
Worse yet, so many of the Java ecosystem’s most important libraries and frameworks rely on reflection (e.g., unit testing, dependency injection, and many more) that not having a solution for reflection would make modules impossible to adopt for any real application.</p>
<p>The solution provided is twofold.
First, a module can declare itself an <code>open</code> module, like this:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">open</code><code class="w"> </code><code class="n">module</code><code class="w"> </code><code class="n">jin8</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">exports</code><code class="w"> </code><code class="n">jin8</code><code class="p">.</code><code class="na">api</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>This declaration has the effect that:</p>
<ul>
<li>
<p>All packages in the module can be accessed via reflection</p>
</li>
<li>
<p>Compile-time access is <em>not</em> provided for nonexported packages</p>
</li>
</ul>
<p>This means that the configuration behaves like a standard module at compile time.
The overall intent is to provide simple compatibility with existing code and 
<span class="keep-together">frameworks</span> and ease migration pain.
With an open module, the previous expectation of being able to reflectively access code is restored.
In addition, the <code>setAccessible()</code> hack that allows access to <code>private</code> and other methods that would not normally permit access is preserved for open modules.</p>
<p>Finer-grained control over reflective access is also provided via the <code>opens</code> restricted keyword.
This does not create an open module but instead selectively opens specific packages for reflective access by explicitly declaring certain packages to be accessible via reflection:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">module</code><code class="w"> </code><code class="n">ojin8</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">exports</code><code class="w"> </code><code class="n">ojin8</code><code class="p">.</code><code class="na">api</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="n">opens</code><code class="w"> </code><code class="n">ojin8</code><code class="p">.</code><code class="na">domain</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p><a data-primary="object-relational mapping (ORM)" data-type="indexterm" id="idm45927699515792"/><a data-primary="ORM (object-relational mapping)" data-type="indexterm" id="idm45927699524528"/>This type of usage is likely to be useful when, for example, you are providing a domain model to be used by a module-aware <em>object-relational mapping</em> (ORM) system that needs full reflective access to the core domain types of a module.</p>
<p>It is possible to go further and restrict reflective access to specific client packages, using the <code>to</code> restricted keyword.
Where possible, this can be a good design principle, but of course such a technique will not work well with a general-purpose framework such as an ORM.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>In a similar way, it is possible to restrict the export of a package to only specific external packages. However, this feature was added largely to help with the modularization of the JDK itself, and it has limited applicability to user modules.</p>
</div>
<p>Not only that, it is also possible to both export and open a package, but this is not recommended—during migration, access to a package should ideally be either compile-time or reflective but not both.</p>
<p>In the case where reflective access is required to a package now contained in a module, the platform provides some switches to act as band-aids for the transitional period.</p>
<p>In particular, the <code>java</code> option <code>--add-opens module/package=ALL-UNNAMED</code> can be used to open a specific package of module for reflective access to all code from the classpath, overriding the behavior of the modules system.
For code that is already modular, it can also be used to allow reflective access to a specific module.</p>
<p>When you are migrating to modular Java, any code that reflectively accesses internal code of another module should be run with that switch at first, until the situation can be remediated.</p>
<p>Related to this issue of reflective access (and a special case of it) is the issue of widespread use of internal platform APIs by frameworks.
This is usually characterized as the “Unsafe problem” and we will encounter it toward the end of the chapter.<a data-startref="ix_ch12-asciidoc5" data-type="indexterm" id="idm45927699477456"/><a data-startref="ix_ch12-asciidoc4" data-type="indexterm" id="idm45927699476752"/></p>
</div></section>
<section data-pdf-bookmark="Providing Services" data-type="sect2"><div class="sect2" id="idm45927699573872">
<h2>Providing Services</h2>
<p><a data-primary="Java Platform Modules System (JPMS)" data-secondary="providing services" data-type="indexterm" id="idm45927699474672"/><a data-primary="services mechanism (JPMS)" data-type="indexterm" id="idm45927699473728"/>The modules system includes the <em>services</em> mechanism, to mitigate another problem with an advanced form of encapsulation.
This problem is simply explained by considering a familiar piece of code:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kn">import</code><code class="w"> </code><code class="nn">com.example.Service</code><code class="p">;</code><code class="w"/>

<code class="n">Service</code><code class="w"> </code><code class="n">s</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">ServiceImpl</code><code class="p">();</code><code class="w"/></pre>
<p>Even if <code>Service</code> lives in an exported API package, this line of code still will not compile unless the package containing <code>ServiceImpl</code> is also exported.
What we need is a mechanism to allow fine-grained access to classes implementing service classes without needing the entire package to be imported.
For example, we could write something like:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">module</code><code class="w"> </code><code class="n">jin8</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">exports</code><code class="w"> </code><code class="n">jin8</code><code class="p">.</code><code class="na">api</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="n">requires</code><code class="w"> </code><code class="n">othermodule</code><code class="p">.</code><code class="na">services</code><code class="p">;</code><code class="w"/>

<code class="w">    </code><code class="n">provides</code><code class="w"> </code><code class="n">services</code><code class="p">.</code><code class="na">Service</code><code class="w"> </code><code class="n">with</code><code class="w"> </code><code class="n">jin8</code><code class="p">.</code><code class="na">services</code><code class="p">.</code><code class="na">ServiceImpl</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Now the <code>ServiceImpl</code> class is accessible at compile time as an implementation of the <code>Service</code> interface.
Note that the <code>services</code> package must be contained in another module, which is required by the current module for this provision to work.</p>
</div></section>
<section data-pdf-bookmark="Multi-Release JARs" data-type="sect2"><div class="sect2" id="idm45927699380416">
<h2>Multi-Release JARs</h2>
<p><a data-primary="JAR (Java archive) files" data-secondary="multi-release" data-type="indexterm" id="ix_ch12-asciidoc6"/><a data-primary="Java Platform Modules System (JPMS)" data-secondary="multi-release JARs" data-type="indexterm" id="ix_ch12-asciidoc7"/>To explain the problem that is solved by multi-release JARs, let’s consider a simple example: finding the process ID (PID) of the currently executing process (i.e., the JVM that’s executing our code).</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>We don’t use the HTTP/2 example from earlier on, as Java 8 doesn’t have an HTTP/2 API—so we would have had to do a huge amount of work (essentially a full backport!) to provide the equivalent functionality for 8.</p>
</div>
<p>This may seem like a simple task, but on Java 8 this requires a surprising amount of boilerplate code:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="kd">class</code> <code class="nc">GetPID</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kd">static</code><code class="w"> </code><code class="kt">long</code><code class="w"> </code><code class="nf">getPid</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="c1">// This rather clunky call uses JMX to return the name that</code><code class="w"/>
<code class="w">        </code><code class="c1">// represents the currently running JVM. This name is in the</code><code class="w"/>
<code class="w">        </code><code class="c1">// format &lt;pid&gt;@&lt;hostname&gt;—on OpenJDK and Oracle VMs only—there</code><code class="w"/>
<code class="w">        </code><code class="c1">// is no guaranteed portable solution for this on Java 8</code><code class="w"/>
<code class="w">        </code><code class="kd">final</code><code class="w"> </code><code class="n">String</code><code class="w"> </code><code class="n">jvmName</code><code class="w"> </code><code class="o">=</code><code class="w"> </code>
<code class="w">            </code><code class="n">ManagementFactory</code><code class="p">.</code><code class="na">getRuntimeMXBean</code><code class="p">().</code><code class="na">getName</code><code class="p">();</code><code class="w"/>
<code class="w">        </code><code class="kd">final</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">index</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">jvmName</code><code class="p">.</code><code class="na">indexOf</code><code class="p">(</code><code class="sc">'@'</code><code class="p">);</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">index</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="mi">1</code><code class="p">)</code><code class="w"/>
<code class="w">            </code><code class="k">return</code><code class="w"> </code><code class="o">-</code><code class="mi">1</code><code class="p">;</code><code class="w"/>

<code class="w">        </code><code class="k">try</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="k">return</code><code class="w"> </code><code class="n">Long</code><code class="p">.</code><code class="na">parseLong</code><code class="p">(</code><code class="n">jvmName</code><code class="p">.</code><code class="na">substring</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="n">index</code><code class="p">));</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"> </code><code class="k">catch</code><code class="w"> </code><code class="p">(</code><code class="n">NumberFormatException</code><code class="w"> </code><code class="n">nfe</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="k">return</code><code class="w"> </code><code class="o">-</code><code class="mi">1</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>As we can see, this is nowhere near as straightforward as we might like.
Worse still, it is not supported in a standard way across all Java 8 implementations.
<a data-primary="ProcessHandle API" data-type="indexterm" id="idm45927699333664"/>Fortunately, from Java 11 onward, we can use the new <code>ProcessHandle</code> API, like this:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="kd">class</code> <code class="nc">GetPID</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kd">static</code><code class="w"> </code><code class="kt">long</code><code class="w"> </code><code class="nf">getPid</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="c1">// Use new Java 9 Process API...</code><code class="w"/>
<code class="w">        </code><code class="n">ProcessHandle</code><code class="w"> </code><code class="n">processHandle</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">ProcessHandle</code><code class="p">.</code><code class="na">current</code><code class="p">();</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="n">processHandle</code><code class="p">.</code><code class="na">getPid</code><code class="p">();</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>This now utilizes a standard API, but it leads to an essential problem: how can the developer write code that is guaranteed to run on all current Java versions?</p>
<p>What we want is to build and run a project correctly in multiple Java versions.
We want to depend on library classes that are only available in later versions but still run on an earlier version by using some code “shims.”
The end result must be a single JAR, and we do not require the project to switch to a multimodule format—​in fact, the JAR must work as an automatic module.</p>
<p><a data-primary="Java 11" data-secondary="multi-release JARs" data-type="indexterm" id="idm45927699155312"/>Let’s look at an example project that has to run correctly in both Java 8 and Java 11 or higher.
The main codebase is built with Java 8, and the Java 11 portion must be built with Java 11.
This part of the build must be isolated from the main codebase to prevent compilation failures, although it can depend on the build artifacts of the Java 8 build.</p>
<p>To keep the build configuration simple, this feature is controlled using an entry in <code>MANIFEST.MF</code> within the JAR file:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">Multi</code><code class="o">-</code><code class="n">Release</code><code class="p">:</code><code class="w"> </code><code class="n">True</code><code class="w"/></pre>
<p>The variant code (i.e., that for a later version) is then stored in a special directory in <em>META-INF</em>.
In our case, this is <em>META-INF/versions/11</em>.</p>
<p>For a Java runtime that implements this feature, any classes in the version-specific directory override the versions in the content root.
On the other hand, for Java 8 and earlier versions, both the manifest entry and the <em>versions/</em> directory are ignored and only the classes in the content root are found.</p>
</div></section>
<section data-pdf-bookmark="Converting to a Multi-Release JAR" data-type="sect2"><div class="sect2" id="idm45927699379824">
<h2>Converting to a Multi-Release JAR</h2>
<p><a data-primary="Java Platform Modules System (JPMS)" data-secondary="deploying software as multi-release JAR" data-type="indexterm" id="idm45927699066752"/>To start deploying your software as a multi-release JAR, follow this outline:</p>
<ol>
<li>
<p>Isolate code that is JDK-version-specific</p>
</li>
<li>
<p>If possible, place that code into a package or group of packages</p>
</li>
<li>
<p>Get the version 8 project building cleanly</p>
</li>
<li>
<p>Create a new, separate project for the supplementary classes</p>
</li>
<li>
<p>Set up a single dependency for the new project (the version 8 artifact)</p>
</li>
</ol>
<p><a data-primary="Gradle" data-type="indexterm" id="idm45927699061008"/>For Gradle, you can also use the concept of a <em>source set</em> and compile the v11 code using a different (later) compiler.
This can then be built into a JAR using a stanza like this:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">jar</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="n">into</code><code class="p">(</code><code class="err">'</code><code class="n">META</code><code class="o">-</code><code class="n">INF</code><code class="o">/</code><code class="n">versions</code><code class="o">/</code><code class="mi">11</code><code class="err">'</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">     </code><code class="n">from</code><code class="w"> </code><code class="n">sourceSets</code><code class="p">.</code><code class="na">java11</code><code class="p">.</code><code class="na">output</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>

<code class="w">  </code><code class="n">manifest</code><code class="p">.</code><code class="na">attributes</code><code class="p">(</code><code class="w"/>
<code class="w">     </code><code class="err">'</code><code class="n">Multi</code><code class="o">-</code><code class="n">Release</code><code class="err">'</code><code class="p">:</code><code class="w"> </code><code class="err">'</code><code class="kc">true</code><code class="err">'</code><code class="w"/>
<code class="w">  </code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p><a data-primary="Maven" data-type="indexterm" id="idm45927699041776"/>For Maven, the current easiest route is to use the Maven Dependency Plug-in and add the modular classes to the overall JAR as part of the separate <code>generate-resources</code> phase.<a data-startref="ix_ch12-asciidoc7" data-type="indexterm" id="idm45927699004080"/><a data-startref="ix_ch12-asciidoc6" data-type="indexterm" id="idm45927699003408"/></p>
</div></section>
<section data-pdf-bookmark="Migrating to Modules" data-type="sect2"><div class="sect2" id="idm45927699002608">
<h2>Migrating to Modules</h2>
<p><a data-primary="Java Platform Modules System (JPMS)" data-secondary="decision to migrate applications to use modules" data-type="indexterm" id="idm45927699001040"/>Many Java developers are facing the question of whether, and when, they should migrate their applications to use modules.</p>
<div data-type="tip"><h6>Tip</h6>
<p>Modules should be the default for all greenfield apps, especially those that are architected in a microservices style.</p>
</div>
<p>Many applications will not need to be migrated at all.
However, modularizing existing code bases can be worthwhile because the better encapsulation and overall architectural benefits do pay off over the longer term—allowing new developers to be brought onto the team faster and providing a clear structure that is easier to understand and maintain.</p>
<p>When considering migration of an existing app (especially a monolithic design), you can use the following roadmap:</p>
<ol>
<li>
<p>First upgrade the application runtime to Java 17 (running from the classpath initially)</p>
</li>
<li>
<p>Identify any application dependencies that have been modularized and migrate those dependencies to modules</p>
</li>
<li>
<p>Retain any nonmodularized dependencies as automatic modules</p>
</li>
<li>
<p>Introduce a single <em>monolithic module</em> of all application code</p>
</li>
</ol>
<p>At this point, a minimally modularized application should be ready for production deployment.
This module will usually be an <code>open</code> module at this stage of the process.
The next step is architectural refactoring; at this point, applications can be broken out into individual modules as needed.</p>
<p>Once the application code runs in modules, it can make sense to limit reflective access to your code via <code>opens</code>.
This access can be restricted to specific modules (such as ORM or dependency injection modules) as a first step toward removing any unnecessary access.</p>
<p>For Maven users, it’s worth remembering that Maven is not a modules system, but it does have dependencies—and (unlike JPMS dependencies) they are versioned.
The Maven tooling is still evolving to fully integrate with JPMS (and many plug-ins have not caught up at the time of this writing).
However, some general guidelines for modular Maven projects are emerging, specifically:</p>
<ul>
<li>
<p>Aim to produce one module per Maven POM</p>
</li>
<li>
<p>Don’t modularize a Maven project until you are ready (or have an immediate need to)</p>
</li>
<li>
<p><a data-primary="Java 11" data-secondary="migrating to modules" data-type="indexterm" id="idm45927698946864"/>Remember that running on a Java 11+ runtime does not require building on a Java 11+ toolchain</p>
</li>
</ul>
<p>The last point indicates that one path for migration of Maven projects is to start by building as a Java 8 project and ensuring that those Maven artifacts can deploy cleanly (as automatic modules) on a Java 11 (or 17) runtime.
Only once that first step is working properly should a full modularization be undertaken.</p>
<p>Some good tooling support is available to help with the modularization process.
Java 8 and up ships with <code>jdeps</code> (see <a data-type="xref" href="ch13.xhtml#javanut8-CHP-13">Chapter 13</a>), a tool for determining which packages and modules your code depends upon.
This is very helpful for migrations from Java 8 and the use of <code>jdeps</code> when rearchitecting is recommended.</p>
</div></section>
<section data-pdf-bookmark="Custom Runtime Images" data-type="sect2"><div class="sect2" id="idm45927698942832">
<h2>Custom Runtime Images</h2>
<p><a data-primary="custom runtime images, JMPS and" data-type="indexterm" id="idm45927698941280"/><a data-primary="Java Platform Modules System (JPMS)" data-secondary="custom runtime images" data-type="indexterm" id="idm45927698940608"/>One of the key goals of JPMS is the possibility that applications may need not every class present in the traditional monolithic runtime of Java 8 and instead can manage with a smaller subset of modules.
Such applications can have a much smaller footprint in terms of startup time and memory overhead.
This can be taken further: if not all classes are needed, then why not ship an application together with a reduced, custom runtime image that includes only what’s necessary?</p>
<p>To demonstrate the idea, let’s package the HTTP/2 checker into a standalone tool with a custom runtime.
We can use the <code>jlink</code> tool (which has been part of the platform since Java 9) to achieve this:</p>
<pre data-code-language="bash" data-type="programlisting">$<code class="w"> </code>jlink<code class="w"> </code>--module-path<code class="w"> </code>httpchecker.jar:<code class="nv">$JAVA_HOME</code>/jmods<code class="w"> </code><code class="se">\</code>
<code class="w">      </code>--add-modules<code class="w"> </code>httpchecker,jdk.crypto.ec<code class="w"> </code><code class="se">\</code>
<code class="w">      </code>--launcher<code class="w"> </code><code class="nv">http2chk</code><code class="o">=</code>httpchecker<code class="w"> </code><code class="se">\</code>
<code class="w">      </code>--output<code class="w"> </code>http2chk-image<code class="w"/></pre>
<p>Note that this assumes that JAR file <em>httpchecker.jar</em> was created with a main class (aka entry point).
The result is an output directory, <em>http2chk-image</em>, which is about 39M in size, much less than the full image.
This also notes that because the tool uses the new HTTP module, it requires the libraries for security, crypto, and so on when connecting using HTTPS.</p>
<p>From within the custom image directory, we can run the <code>http2chk</code> tool directly and see that it works even when the machine does not have the required version of <code>java</code>:</p>
<pre data-type="programlisting">$ java -version
java version "1.8.0_144"
Java(TM) SE Runtime Environment (build 1.8.0_144-b01)
Java HotSpot(TM) 64-Bit Server VM (build 25.144-b01, mixed mode)
$ ./bin/http2chk https://www.google.com
https://www.google.com: HTTP_2</pre>
<p>The deployment of custom runtime images is still quite a new tool, but it has great potential to reduce your code footprint and help Java remain competitive in the age of microservices.
In the future, <code>jlink</code> could even be combined with new approaches to compilation, including an ahead-of-time (AOT) compiler.<a data-startref="ix_ch12-asciidoc3" data-type="indexterm" id="idm45927698892416"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Issues with Modules" data-type="sect1"><div class="sect1" id="idm45927700078912">
<h1>Issues with Modules</h1>
<p><a data-primary="Java Platform Modules System (JPMS)" data-secondary="issues with modules" data-type="indexterm" id="ix_ch12-asciidoc8"/>The modules system, despite being the flagship feature of Java 9 and having had a large amount of engineering time devoted to it, is not without its problems.
This was, perhaps, inevitable—the feature fundamentally changes how Java applications are architected and delivered.
It would have been almost impossible for modules to avoid running up against some problems when trying to retrofit over the large, mature ecosystem that is Java.</p>
<section data-pdf-bookmark="Unsafe and Related Problems" data-type="sect2"><div class="sect2" id="idm45927698885968">
<h2>Unsafe and Related Problems</h2>
<p><a data-primary="Java Platform Modules System (JPMS)" data-secondary="Unsafe class and related problems" data-type="indexterm" id="idm45927698884720"/><a data-primary="sun.misc.Unsafe class" data-type="indexterm" id="idm45927698883872"/><code>sun.misc.Unsafe</code> is a class that is both widely used and popular with framework writers and other implementors within the Java world.
However, it is an internal implementation class and is not part of the standard API of the Java platform (as the package name clearly indicates).
The class name also provides a fairly strong clue that this is not really intended for use by Java applications.</p>
<p><code>Unsafe</code> is an unsupported, internal API and so could be withdrawn or modified by any new Java version, without regard to the effect on user applications.
Any code that does use it is technically directly coupled to the HotSpot JVM and is also potentially nonstandard and may not run on other implementations.</p>
<p>Although not an official part of Java SE in any way, <code>Unsafe</code> has become a de facto standard and key part of the implementation of basically every major framework in one way or another.
Over subsequent versions it has evolved into a kind of dumping ground for nonstandard but necessary features.
This admixture of features is a real mixed bag, with varying degrees of safety provided by each capability.
Example uses of <code>Unsafe</code> include:</p>
<ul>
<li>
<p>Fast serialization/deserialization</p>
</li>
<li>
<p>Threadsafe 64-bit sized native memory access (e.g., offheap)</p>
</li>
<li>
<p>Atomic memory operations (e.g., Compare-and-Swap)</p>
</li>
<li>
<p>Fast field/memory access</p>
</li>
<li>
<p>Multi-operating system replacement for JNI</p>
</li>
<li>
<p>Access to array items with volatile semantics (see <a data-type="xref" href="ch06.xhtml#javanut8-CHP-6">Chapter 6</a>)</p>
</li>
</ul>
<p>The essential problem is that many frameworks and libraries were unable to move to a modular JDK without replacement for some <code>Unsafe</code> features.
In turn, this impacts everyone using any libraries from a wide range of frameworks—basically every application in the Java ecosystem.</p>
<p>To fix this problem, Oracle created new, supported APIs for some of the needed functionality and segregated APIs that could not be encapsulated in time into a module, <code>jdk.unsupported</code>.
This makes it clear this is not a supported API and that developers use it at their own risk.
This gives <code>Unsafe</code> a temporary pass (which is strictly limited time) while encouraging library and framework developers to move to the new APIs.</p>
<p>An example of a replacement API is VarHandles.
These extend the <em>Method Handles</em> concept (from <a data-type="xref" href="ch11.xhtml#javanut8-CHP-11">Chapter 11</a>) and add new functionality, such as concurrency barrier modes for Java 11.
These, along with some modest updates to JMM, are intended to produce a standard API for accessing new low-level processor features without allowing developers full access to dangerous capabilities, as were found in <code>Unsafe</code>.</p>
<p>More details about <code>Unsafe</code> and related low-level platform techniques can be found in <a class="orm:hideurl" href="http://shop.oreilly.com/product/0636920121718.do"><em>Optimizing Java</em></a> (O’Reilly).</p>
</div></section>
<section class="pagebreak-before" data-pdf-bookmark="Lack of Versioning" data-type="sect2"><div class="sect2" id="idm45927698867520">
<h2>Lack of Versioning</h2>
<p><a data-primary="Java Platform Modules System (JPMS)" data-secondary="lack of versioning" data-type="indexterm" id="idm45927698865872"/><a data-primary="versioning, as JPMS deficiency" data-type="indexterm" id="idm45927698864928"/>The JPMS standard as of Java 17 does not include the versioning of dependencies.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>This was a deliberate design decision to reduce the complexity of the delivered system and does not preclude the possibility that modules could include versioned dependencies in the future.</p>
</div>
<p>The current situation requires external tools to handle the versioning of module dependencies.
In the case of Maven, this will be within the Project Object Model (POM).
An advantage to this approach is that the download and management of versions are also handled within the local repository of the build tool.</p>
<p>However it is done, though, the simple fact is that the dependency version information must be stored out of the module and does not form part of the JAR artifact.</p>
<p>There’s no getting away from it—this is pretty ugly, but the counterpoint is that the situation is no worse than it was with dependencies being deduced from the <span class="keep-together">classpath</span>.</p>
</div></section>
<section data-pdf-bookmark="Slow Adoption Rates" data-type="sect2"><div class="sect2" id="idm45927698860864">
<h2>Slow Adoption Rates</h2>
<p><a data-primary="Java Platform Modules System (JPMS)" data-secondary="adoption rates" data-type="indexterm" id="idm45927698859296"/>With the release of Java 9, the Java release model fundamentally changed.
<a data-primary="Java 9" data-primary-sortas="Java 09" data-secondary="keystone release model" data-type="indexterm" id="idm45927698858176"/><a data-primary="keystone release model" data-type="indexterm" id="idm45927698856960"/>Java 8 and 9 used the “keystone release” model—where one keystone (or landmark) feature such as lambdas for Java 8 or modules for Java 9—essentially defined the release and so the ship date was determined by when the feature was complete.</p>
<p>The problem with this model is that it can cause inefficiencies due to uncertainty about when versions will ship.
In particular, a small feature that just misses a release will have to wait a long time for the next major release.
As a result, from Java 10 onward, a new release model was adopted, which introduces <em>strict time-based versioning</em>.</p>
<p>This means:</p>
<ul>
<li>
<p>Java releases are now classified as <em>feature</em> releases, which occur at a regular cadence of once every six months.</p>
</li>
<li>
<p>Features are not merged into the platform until they are essentially complete.</p>
</li>
<li>
<p>The mainline repo is in a releasable state at all times.</p>
</li>
</ul>
<p>These releases are good for only six months, after which time they are no longer supported.
<a data-primary="long-term support (LTS) releases" data-type="indexterm" id="idm45927698850688"/><a data-primary="LTS (long-term support) releases" data-type="indexterm" id="idm45927698849920"/>Certain releases are designated by Oracle as <em>long-term support</em> (LTS) releases.
These have extended, paid-for support available from Oracle.</p>
<p>The release cadence of these LTS releases was initially three years but at time of writing is expected to change to two years.
This means that Oracle LTS releases are currently 8 (retrospectively added), 11, and 17; the expected next release will be Java 21 in September 2023.</p>
<p>However, as well as Oracle, builds of OpenJDK are available from other providers including Amazon, Azul, Eclipse Adoptium, IBM, Microsoft, Red Hat, and SAP.
These vendors offer various ways to get JDK updates (including security) at zero cost.</p>
<p>There are also new and existing paid support models available from several of the above vendors.</p>
<p>For an in-depth write-up of this topic, please see the guide: <a href="https://oreil.ly/Cz61R">“Java Is Still Free”</a> by the  <a href="https://oreil.ly/NGIpB">Java Champions community</a>, an independent body of Java leaders in the software industry.</p>
<p>Although the Java community is generally positive on the new faster release cycle, adoption rates of Java 9 and above have been much smaller than for previous releases.
This may be due to the desire of teams to have longer support cycles, rather than upgrading to each feature release after only six months.
In practice, only the LTS releases are seeing widespread adoption, and even that has been slow compared to the rapid uptake of Java 8.</p>
<p>It is also the case that the upgrade from Java 8 to 11 (or 17) is not a drop-in replacement (unlike 7 to 8, and to a lesser extent 6 to 7).
The modules subsystem fundamentally changes many aspects of the Java platform, even if end-user applications do not take advantage of modules.</p>
<p>Four years after the release of Java 11, it seems to have finally overtaken Java 8, with more workloads now running on Java 11 than 8.
It remains to be seen how quickly Java 17 will be adopted and what the impact of Java 21 will be (assuming that 21 is indeed the next LTS).<a data-startref="ix_ch12-asciidoc8" data-type="indexterm" id="idm45927698844304"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm45927698843216">
<h1>Summary</h1>
<p>The modules feature, first introduced in Java 9, aims to solve several problems at once.
The aims of shorter startup time, lower footprint, and reduced complexity by denying access to internals have all been met.
The longer-term goals of enabling better architecture of applications and starting to think about new approaches for compilation and deployment are still in progress.</p>
<p>However, the plain fact is that, as of the release of Java 17, not many teams and projects have moved wholeheartedly to the modular world.
This is to be expected, as modularity is a long-term project that has a slow payoff and relies on network effects within the ecosystem to achieve the full benefit.</p>
<p>New applications should definitely consider building in a modular way from the get-go, but the overall story of platform modularity within the Java ecosystem is still only beginning.<a data-startref="ix_ch12-asciidoc0" data-type="indexterm" id="idm45927698841088"/></p>
</div></section>
</div></section></div></body></html>