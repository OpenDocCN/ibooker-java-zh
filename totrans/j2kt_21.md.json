["```java\nfun Sequence<String>.toHighValueCustomerReport(): Sequence<String> {\n    val valuableCustomers = this\n        .withoutHeader()\n        .map(String::toCustomerData)\n        .filter { it.score >= 10 }\n        .sortedBy(CustomerData::score)\n        .toList()\n    return sequenceOf(\"ID\\tName\\tSpend\") +\n        valuableCustomers.map(CustomerData::outputLine) +\n        valuableCustomers.summarised()\n}\n\nprivate fun List<CustomerData>.summarised(): String =\n    sumByDouble { it.spend }.let { total ->\n        \"\\tTOTAL\\t${total.toMoneyString()}\"\n    }\n\nprivate fun Sequence<String>.withoutHeader() = drop(1)\n\ninternal fun String.toCustomerData(): CustomerData =\n    split(\"\\t\").let { parts ->\n        CustomerData(\n            id = parts[0],\n            givenName = parts[1],\n            familyName = parts[2],\n            score = parts[3].toInt(),\n            spend = if (parts.size == 4) 0.0 else parts[4].toDouble()\n        )\n    }\n\nprivate val CustomerData.outputLine: String\n    get() = \"$id\\t$marketingName\\t${spend.toMoneyString()}\"\n\nprivate fun Double.toMoneyString() = this.formattedAs(\"%#.2f\")\n\nprivate fun Any?.formattedAs(format: String) = String.format(format, this)\n\nprivate val CustomerData.marketingName: String\n    get() = \"${familyName.toUpperCase()}, $givenName\"\n```", "```java\nprivate val CustomerData.marketingName: String\n    get() = \"${familyName.toUpperCase()}, $givenName\"\n```", "```java\nprivate fun Any?.formattedAs(format: String) = String.format(format, this)\n```", "```java\nprivate val CustomerData.outputLine: String\n    get() = \"$id\\t$marketingName\\t${spend.toMoneyString()}\"\n```", "```java\ninternal fun String.toCustomerData(): CustomerData =\n    split(\"\\t\").let { parts ->\n        CustomerData(\n            id = parts[0],\n            givenName = parts[1],\n            familyName = parts[2],\n            score = parts[3].toInt(),\n            spend = if (parts.size == 4) 0.0 else parts[4].toDouble()\n        )\n    }\n```", "```java\ninternal fun String.toCustomerData(): CustomerData? =\n    split(\"\\t\").let { parts ->\n        if (parts.size < 4)\n            null\n        else\n            CustomerData(\n                id = parts[0],\n                givenName = parts[1],\n                familyName = parts[2],\n                score = parts[3].toInt(),\n                spend = if (parts.size == 4) 0.0 else parts[4].toDouble()\n            )\n    }\n```", "```java\nfun Sequence<String>.toHighValueCustomerReport(): Sequence<String> {\n    val valuableCustomers = this\n        .withoutHeader()\n        .map(String::toCustomerData)\n        .filter { it.score >= 10 } ![1](assets/1.png)\n        .sortedBy(CustomerData::score)\n        .toList()\n    return sequenceOf(\"ID\\tName\\tSpend\") +\n        valuableCustomers.map(CustomerData::outputLine) +\n        valuableCustomers.summarised()\n}\n```", "```java\nfun Sequence<String>.toHighValueCustomerReport(): Sequence<String> {\n    val valuableCustomers = this\n        .withoutHeader()\n        .map(String::toCustomerData)\n        .filterNotNull()\n        .filter { it.score >= 10 }\n        .sortedBy(CustomerData::score)\n        .toList()\n    return sequenceOf(\"ID\\tName\\tSpend\") +\n        valuableCustomers.map(CustomerData::outputLine) +\n        valuableCustomers.summarised()\n}\n```", "```java\ninternal fun String.toCustomerData(): CustomerData? =\n    split(\"\\t\").let { parts ->\n        if (parts.size < 4)\n            return null\n        val score = parts[3].toIntOrNull() ?:\n            return null\n        val spend = if (parts.size == 4) 0.0 else parts[4].toDoubleOrNull() ?:\n            return null\n        CustomerData(\n            id = parts[0],\n            givenName = parts[1],\n            familyName = parts[2],\n            score = score,\n            spend = spend\n        )\n    }\n```", "```java\n@Test\nfun `calls back on parsing error`() {\n    val lines = listOf(\n        \"ID\\tFirstName\\tLastName\\tScore\\tSpend\",\n        \"INVALID LINE\",\n        \"1\\tFred\\tFlintstone\\t11\\t1000.00\",\n    )\n\n    val errorCollector = mutableListOf<String>()\n    val result = lines\n        .asSequence()\n        .constrainOnce()\n        .toHighValueCustomerReport { badLine -> ![1](assets/1.png)\n            errorCollector += badLine\n        }\n        .toList()\n\n    assertEquals(\n        listOf(\n            \"ID\\tName\\tSpend\",\n            \"1\\tFLINTSTONE, Fred\\t1000.00\",\n            \"\\tTOTAL\\t1000.00\"\n        ),\n        result\n    )\n    assertEquals(\n        listOf(\"INVALID LINE\"),\n        errorCollector\n    )\n}\n```", "```java\nfun Sequence<String>.toHighValueCustomerReport(\n    onErrorLine: (String) -> Unit = {}\n): Sequence<String> {\n    val valuableCustomers = this\n        .withoutHeader()\n        .map { line ->\n            val customerData = line.toCustomerData()\n            if (customerData == null)\n                onErrorLine(line)\n            customerData\n        }\n        .filterNotNull()\n        .filter { it.score >= 10 }\n        .sortedBy(CustomerData::score)\n        .toList()\n    return sequenceOf(\"ID\\tName\\tSpend\") +\n        valuableCustomers.map(CustomerData::outputLine) +\n        valuableCustomers.summarised()\n}\n```", "```java\nfun main() {\n    System.`in`.reader().use { reader ->\n        System.out.writer().use { writer ->\n            val errorLines = mutableListOf<String>()\n            val reportLines = reader\n                .asLineSequence()\n                .toHighValueCustomerReport {\n                    errorLines += it\n                }\n            if (errorLines.isNotEmpty()) {\n                System.err.writer().use { error ->\n                    error.appendLine(\"Lines with errors\")\n                    errorLines.asSequence().writeTo(error)\n                }\n                exitProcess(-1)\n            } else {\n                reportLines.writeTo(writer)\n            }\n        }\n    }\n}\n```", "```java\ninternal fun String.toCustomerData(): Result<CustomerData, ParseFailure> =\n    split(\"\\t\").let { parts ->\n        if (parts.size < 4)\n            return Failure(NotEnoughFieldsFailure(this))\n        val score = parts[3].toIntOrNull() ?:\n            return Failure(ScoreIsNotAnIntFailure(this))\n        val spend = if (parts.size == 4) 0.0 else parts[4].toDoubleOrNull() ?:\n            return Failure(SpendIsNotADoubleFailure(this))\n        Success(\n            CustomerData(\n                id = parts[0],\n                givenName = parts[1],\n                familyName = parts[2],\n                score = score,\n                spend = spend\n            )\n        )\n    }\n```", "```java\nsealed class ParseFailure(open val line: String)\ndata class NotEnoughFieldsFailure(override val line: String) :\n    ParseFailure(line)\ndata class ScoreIsNotAnIntFailure(override val line: String) :\n    ParseFailure(line)\ndata class SpendIsNotADoubleFailure(override val line: String) :\n    ParseFailure(line)\n```", "```java\nfun Sequence<String>.toHighValueCustomerReport(\n    onErrorLine: (String) -> Unit = {}\n): Sequence<String> {\n    val valuableCustomers = this\n        .withoutHeader()\n        .map { line ->\n            line.toCustomerData().recover {\n                onErrorLine(line)\n                null\n            }\n        }\n        .filterNotNull()\n        .filter { it.score >= 10 }\n        .sortedBy(CustomerData::score)\n        .toList()\n    return sequenceOf(\"ID\\tName\\tSpend\") +\n        valuableCustomers.map(CustomerData::outputLine) +\n        valuableCustomers.summarised()\n}\n```", "```java\nval errorCollector = mutableListOf<ParseFailure>()\nval result = lines\n    .asSequence()\n    .constrainOnce()\n    .toHighValueCustomerReport { badLine ->\n        errorCollector += badLine\n    }\n    .toList()\nassertEquals(\n    listOf(NotEnoughFieldsFailure(\"INVALID LINE\")),\n    errorCollector\n)\n```", "```java\nfun Sequence<String>.toHighValueCustomerReport(\n    onErrorLine: (ParseFailure) -> Unit = {}\n): Sequence<String> {\n    val valuableCustomers = this\n        .withoutHeader()\n        .map { line ->\n            line.toCustomerData().recover {\n                onErrorLine(it)\n                null\n            }\n        }\n        .filterNotNull()\n        .filter { it.score >= 10 }\n        .sortedBy(CustomerData::score)\n        .toList()\n    return sequenceOf(\"ID\\tName\\tSpend\") +\n        valuableCustomers.map(CustomerData::outputLine) +\n        valuableCustomers.summarised()\n}\n```", "```java\nif (errorLines.isNotEmpty()) {\n    System.err.writer().use { error ->\n        error.appendLine(\"Lines with errors\")\n        errorLines.asSequence().map { parseFailure ->\n            \"${parseFailure::class.simpleName} in ${parseFailure.line}\"\n        }.writeTo(error)\n    }\n    exitProcess(-1)\n} else {\n    reportLines.writeTo(writer)\n}\n```", "```java\nfun Sequence<String>.toHighValueCustomerReport(\n    onErrorLine: (ParseFailure) -> Unit = {}\n): Sequence<String> {\n    val valuableCustomers = this\n        .withoutHeader()\n        .map { line ->\n            line.toCustomerData().recover {\n                onErrorLine(it)\n                null\n            }\n        }\n        .filterNotNull()\n        .filter { it.score >= 10 }\n        .sortedBy(CustomerData::score)\n        .toList()\n    return sequenceOf(\"ID\\tName\\tSpend\") +\n        valuableCustomers.map(CustomerData::outputLine) +\n        valuableCustomers.summarised()\n}\n```", "```java\ninternal fun String.toCustomerData(): Result<CustomerData, ParseFailure> =\n    split(\"\\t\").let { parts ->\n        if (parts.size < 4)\n            return Failure(NotEnoughFieldsFailure(this))\n        val score = parts[3].toIntOrNull() ?:\n            return Failure(ScoreIsNotAnIntFailure(this))\n        val spend = if (parts.size == 4) 0.0 else parts[4].toDoubleOrNull() ?:\n            return Failure(SpendIsNotADoubleFailure(this))\n        Success(\n            CustomerData(\n                id = parts[0],\n                givenName = parts[1],\n                familyName = parts[2],\n                score = score,\n                spend = spend\n            )\n        )\n    }\n```", "```java\ninternal fun String.toCustomerData(): Result<CustomerData, ParseFailure> =\n    split(\"\\t\").let { parts ->\n        parts\n            .takeUnless { it.size < 4 }\n            .asResultOr { NotEnoughFieldsFailure(this) }\n            .flatMap { parts ->\n                parts[3].toIntOrNull()\n                    .asResultOr { ScoreIsNotAnIntFailure(this) }\n                    .flatMap { score: Int ->\n                        (if (parts.size == 4) 0.0\n                        else parts[4].toDoubleOrNull())\n                            .asResultOr { SpendIsNotADoubleFailure(this) }\n                            .flatMap { spend ->\n                                Success(\n                                    CustomerData(\n                                        id = parts[0],\n                                        givenName = parts[1],\n                                        familyName = parts[2],\n                                        score = score,\n                                        spend = spend\n                                    )\n                                )\n                            }\n                    }\n            }\n    }\n```", "```java\nfun main() {\n    System.`in`.reader().use { reader ->\n        System.out.writer().use { writer ->\n            val errorLines = mutableListOf<ParseFailure>()\n            val reportLines = reader\n                .asLineSequence()\n                .toHighValueCustomerReport {\n                    errorLines += it\n                }\n            if (errorLines.isNotEmpty()) {\n                System.err.writer().use { error ->\n                    error.appendLine(\"Lines with errors\")\n                    errorLines.asSequence().map { parseFailure ->\n                        \"${parseFailure::class.simpleName} in ${parseFailure.line}\"\n                    }.writeTo(error)\n                }\n                exitProcess(-1)\n            } else {\n                reportLines.writeTo(writer)\n            }\n        }\n    }\n}\n```", "```java\nfun main() {\n    val statusCode = using(\n        System.`in`.reader(),\n        System.out.writer(),\n        System.err.writer()\n    ) { reader, writer, error ->\n        val errorLines = mutableListOf<ParseFailure>()\n        val reportLines = reader\n            .asLineSequence()\n            .toHighValueCustomerReport {\n                errorLines += it\n            }\n        if (errorLines.isEmpty()) {\n            reportLines.writeTo(writer)\n            0\n        } else {\n            errorLines.writeTo(error)\n            -1\n        }\n    }\n    exitProcess(statusCode)\n}\n\ninline fun <A : Closeable, B : Closeable, C : Closeable, R> using(\n    a: A,\n    b: B,\n    c: C,\n    block: (A, B, C) -> R\n): R =\n    a.use {\n        b.use {\n            c.use {\n                block(a, b, c)\n            }\n        }\n    }\n\nprivate fun List<ParseFailure>.writeTo(error: OutputStreamWriter) {\n    error.appendLine(\"Lines with errors\")\n    asSequence().map { parseFailure ->\n        \"${parseFailure::class.simpleName} in ${parseFailure.line}\"\n    }.writeTo(error)\n}\n```", "```java\nfun main() {\n    val statusCode = try {\n        using(\n            System.`in`.reader(),\n            System.out.writer(),\n            System.err.writer()\n        ) { reader, writer, error ->\n            val errorLines = mutableListOf<ParseFailure>()\n            val reportLines = reader\n                .asLineSequence()\n                .toHighValueCustomerReport {\n                    errorLines += it\n                }\n            if (errorLines.isEmpty()) {\n                reportLines.writeTo(writer)\n                0\n            } else {\n                errorLines.writeTo(error)\n                -1\n            }\n        }\n    } catch (x: IOException) {\n        System.err.println(\"IO error processing report ${x.message}\")\n        -1\n    }\n    exitProcess(statusCode)\n}\n```"]