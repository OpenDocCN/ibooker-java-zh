<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Preface" data-type="preface" epub:type="preface"><div class="preface" id="idm45115254437552">
<h1>Preface</h1>
<blockquote>
<p>A mind that is stretched by a new experience can never go back to its old dimensions.</p>
<p data-type="attribution">Oliver Wendell Holmes Jr.</p>
</blockquote>
<p><br/></p>
<p>Developing software is quite a complex endeavor.
As Java developers, we usually try to tame this complexity with object-oriented programming (OOP) as a metaphor to represent the things we are developing, such as data structures, and use a primarily imperative-focused coding style to handle our program’s state.
Although OOP is a well-known and battle-tested approach to developing sensible software, not every problem is a good match for it.
We might introduce a certain amount of unnecessary complexity by forcing OOP principles on every problem instead of using more appropriate tools and paradigms also available to us.
The functional programming (FP) paradigm offers an alternative approach to solving problems.</p>
<p>Functional programming isn’t a new idea.
In fact, it’s even older than object-oriented programming!
It first appeared in the early years of computing, in the 1950s, in the <em>Lisp</em>⁠<sup><a data-type="noteref" href="preface01.xhtml#idm45115267496480" id="idm45115267496480-marker">1</a></sup> programming language and has been used quite commonly in academia and niche fields.
In recent years, however, there has been an increasing interest in functional paradigms.</p>
<p>Many new functional languages emerged, and non-functional languages are including functional features to various degrees.
The ideas and concepts behind FP are now adopted in almost every mainstream multi-paradigm and general-purpose language, allowing us to use some form of functional programming regardless of the context and chosen language.
Nothing stops us from taking the best parts of FP and augmenting our existing way of programming and software development tools — and that’s what this book is about!</p>
<p>In this book, you’ll learn the fundamentals of functional programming and how to apply this knowledge to your daily work using Java.</p>
<section data-pdf-bookmark="New Hardware Needs a New Way of Thinking" data-type="sect1"><div class="sect1" id="_00-preface_new-hardware">
<h1>New Hardware Needs a New Way of Thinking</h1>
<p>Hardware is evolving in a new direction.
For quite some time, single-core performance improvements haven’t been as significant as with each previous processor generation.
<em>Moore’s law</em>⁠<sup><a data-type="noteref" href="preface01.xhtml#idm45115253372352" id="idm45115253372352-marker">2</a></sup> seems to slow down, but such a slowdown doesn’t mean that hardware isn’t improving anymore.
But instead of primarily focussing on single-core performance and even higher GHz numbers, the manufacturers favor more and more cores.<sup><a data-type="noteref" href="preface01.xhtml#idm45115268991152" id="idm45115268991152-marker">3</a></sup>
So, for modern workloads to reap all the benefits of new hardware that favors more cores rather than faster ones, we need to adopt techniques that can use more cores to its advantage without compromising productivity or introducing additional complexity.</p>
<p>Scaling your software <em>horizontally</em> through parallelism isn’t an easy task in OOP.
Not every problem is a good fit for parallelism.
More painters might paint a room faster, but you can’t speed up pregnancy by involving more people.
If the problem consists of serial or interdependent tasks, concurrency is preferable to parallelism.
But parallelism really shines if a problem breaks down into smaller, non-related sub-problems.
That’s where functional programming comes in.
The stateless and immutable nature of idiomatic FP provides all the tools necessary to build small, reliable, reusable, and higher-quality tasks that elegantly fit into parallel and concurrent environments.</p>
<p>Adopting a functional mindset adds another set of tools to your toolbelt that will allow you to tackle your daily development problems in a new way and scale your code easier and safer than before.</p>
<p>Next, let’s look at why Java can be a good choice for functional programming.</p>
</div></section>
<section data-pdf-bookmark="Java can be Functional, too" data-type="sect1"><div class="sect1" id="idm45115254293776">
<h1>Java can be Functional, too</h1>
<p>There are many programming languages out there that are great for functional programming.
<a href="https://www.haskell.org"><em>Haskell</em></a> is a favorite if you prefer a <em>pure</em> functional language with almost no support for an imperative coding style.
<a href="https://elixir-lang.org/"><em>Elixir</em></a> is another exciting option that leverages the <a href="https://www.erlang.org/"><em>Erlang VM</em></a><sup><a data-type="noteref" href="preface01.xhtml#idm45115261275136" id="idm45115261275136-marker">4</a></sup>.
However, you don’t have to leave the vast JVM ecosystem behind to find FP-capable languages.
<a href="https://www.scala-lang.org/"><em>Scala</em></a> shines in combining OOP and FP paradigms into a concise, high-level language.
Another popular choice, <a href="https://clojure.org/"><em>Clojure</em></a>, was designed from the ground up as a functional language with a dynamic type system at heart.</p>
<p>In a perfect world, you’d have the luxury of choosing the perfect functional language for your next project.
In reality, you might not have a choice at all about what language to use, and you’ll have to play the cards you’re dealt.</p>
<p>As a Java developer, you’d use Java, which was historically seen as not ideal for functional programming.
Before we continue, though, I need to stress that you can implement most functional principles in Java, regardless of deeply integrated language level support<sup><a data-type="noteref" href="preface01.xhtml#idm45115272990288" id="idm45115272990288-marker">5</a></sup>.
Still, the resulting code won’t be as concise and easy to reason with as it would in other languages that allow a functional approach in the first place.
This caveat scares many developers away from even trying to apply functional principles to Java, despite the fact that it might have provided a more productive approach or better overall solution.</p>
<p>In the past, many people thought of Java as a slow-moving behemoth, a “too big to become extinct” enterprise language, like a more modern version of COBOL or <a href="https://fortran-lang.org/">Fortran</a>.
And in my opinion, that’s partially true, at least in the past.
The pace didn’t pick up until Java 9 and the shortened release timeframes<sup><a data-type="noteref" href="preface01.xhtml#idm45115273019824" id="idm45115273019824-marker">6</a></sup>.
It took Java five years to go from version 6 to 7 (2006-2011).
And even though there were significant new features, like <a href="https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.xhtml"><code>try-with-resources</code></a>, none of them were “ground-breaking.”
The few and slow changes in the past led to projects and developers not adopting the “latest and greatest” Java Development Kit (JDK) and missing out on many language improvements.
Three years later, in 2014, the next version, Java 8, was released.
This time, it introduced one of the most significant changes to Java’s future: <em>lambda expressions</em>.</p>
<p>A better foundation for functional programming had finally arrived in arguably the most prominent object-oriented programming language of the world, changing the language and its idioms significantly:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">Runnable</code> <code class="n">runnable</code> <code class="o">=</code> <code class="p">()</code> <code class="o">-&gt;</code> <code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="s">"hello, functional world!"</code><code class="p">);</code></pre>
<p>The addition of lambda expressions was monumental in making it possible to finally use functional programming in Java as an integrated language and runtime feature.
Not only that, but a whole new world of ideas and concepts was made available to Java developers.
Many of the JDK’s new features, like Streams, the <code>Optional</code> type, or <code>CompletableFuture</code>, are only possible in such a concise and straightforward way thanks to language-level lambda expressions and Java’s other functional additions.</p>
<p>These new idioms and new ways of doing things with FP in Java may seem strange and might not come naturally, especially if you’re primarily accustomed to OOP.
Throughout this book, I’ll show you how to develop a mindset that’ll help you apply FP principles to your code and how to make it better without needing to go “fully functional.”</p>
</div></section>
<section data-pdf-bookmark="Why I Wrote This Book" data-type="sect1"><div class="sect1" id="idm45115261253136">
<h1>Why I Wrote This Book</h1>
<p>After using another multi-purpose language with excellent functional programming support — <a href="https://www.swift.org/"><em>Swift</em></a> — and seeing the benefits first-hand, I gradually introduced more and more functional principles in my Java-based projects, too.
Thanks to lambda expressions and all the other features introduced in Java 8 and later, all the tools necessary were readily available.
But after using these tools more frequently and discussing them with my colleagues, I realized something: <em>How</em> to use lambdas, Streams, and all the other functional goodies provided by Java is easy to grasp.
But without a deeper understanding of <em>why</em> and <em>when</em> you should use them — and when not to — you won’t unlock their full potential, and it will just be “new wine in old wineskins.”</p>
<p>So I decided to write this book to highlight the different concepts that make a language <em>functional</em>, and how you can incorporate them into your Java code, either with the tools provided by the JDK or by creating them yourself.
A functional approach to your Java code will most likely challenge the status quo and go against <em>best practices</em> you were using before.
But by embracing a more functional way of doing things, like <em>immutability</em> and <em>pure functions</em>, you will be able to write more concise, more reasonable, and future-proof code that is less prone to bugs.</p>
</div></section>
<section data-pdf-bookmark="Who Should Read This Book" data-type="sect1"><div class="sect1" id="idm45115253601312">
<h1>Who Should Read This Book</h1>
<p>This book is for you if you are curious about functional programming and want to know what all the fuss is about and apply it to your Java code.
You might already be using some functional Java types but desire a more profound knowledge of why and how to apply them more effectively.</p>
<p>There is no need to be an expert on OOP, but the book is not a beginner’s guide to Java or OOP.
You should already be familiar with the Java standard library.
No prior knowledge of functional programming is required.
Every concept is introduced with an explanation and examples.</p>
<p>The book covers Java 17 as the latest Long-Term-Support (LTS) version available at publication.
Knowing that many developers need to support projects with earlier versions, the general baseline will be the previous LTS, Java 11.
But even if you’re stuck on Java 8, many of the discussed topics are relevant, too.
Although, some chapters will rely on newer features, like <em>Records</em>, which were introduced in Java 14.</p>
<p>This book might not be for you if you are looking for a compartmentalized, recipe-style book presenting “ready-to-implement” solutions.
Its main intention is to introduce functional concepts and idioms and teach you how to incorporate them into your Java code.</p>
</div></section>
<section data-pdf-bookmark="What You Will Learn" data-type="sect1"><div class="sect1" id="idm45115253430672">
<h1>What You Will Learn</h1>
<p>By the end of this book, you will have a fundamental knowledge of functional programming and its underlying concepts and how to apply this knowledge to your daily work.
Every Java functional type will be at your disposal, and you will be able to build anything missing from the JDK by yourself, if necessary.</p>
<p>You will learn about the concepts and importance of:</p>
<ul>
<li>
<p><em>Composition</em>: Build modular and easy composable blocks.</p>
</li>
<li>
<p><em>Expressiveness</em>: Write more concise code that clearly expresses its intent.</p>
</li>
<li>
<p><em>Safer code</em>: Safer data structures without side effects that don’t need to deal with race conditions or locks, which are hard to use without introducing bugs.</p>
</li>
<li>
<p><em>Modularity</em>: Break down larger projects into more easily manageable modules.</p>
</li>
<li>
<p><em>Maintainability</em>: Smaller functional blocks with less interconnection make changes and refactoring safer without breaking other parts of your code.</p>
</li>
<li>
<p><em>Data manipulation</em>: Build efficient data manipulation pipelines with less complexity.</p>
</li>
<li>
<p><em>Performance</em>: Immutability and predictability allow scaling horizontally with parallelism without much thought about it.</p>
</li>
</ul>
<p>Even without going <em>fully functional</em>, your code will benefit from the concepts and idioms presented in this book.
And not only your Java code.
You will tackle development challenges with a functional mindset, improving your programming regardless of the used language or paradigm.</p>
</div></section>
<section data-pdf-bookmark="What About Android?" data-type="sect1"><div class="sect1" id="idm45115253604576">
<h1>What About Android?</h1>
<p>It’s hard to talk about Java without bringing up Android as well.
Even though you can write Android applications in Java, the underlying API and runtime aren’t the same.
So, what does this mean for adopting a functional approach to Java for Android apps?
To better understand that, we first need to look at what makes Java for Android different from “normal” Java.</p>
<p>Android doesn’t run Java bytecode directly on a minimalistic JVM optimized for smaller devices, like <a href="https://www.oracle.com/java/technologies/javameoverview.xhtml">Java Platform Micro Edition</a>.
Instead, the bytecode gets recompiled.
The <em>Dex-compiler</em> creates <em>Dalvik bytecode</em>, which is then run on a specialized runtime: the <em>Android Runtime</em> (ART), and previously on the <em>Dalvik virtual machine</em>⁠<sup><a data-type="noteref" href="preface01.xhtml#idm45115254361520" id="idm45115254361520-marker">7</a></sup>.</p>
<p>Recompiling Java bytecode to <em>Dalvik bytecode</em> allows the devices to run highly optimized code, getting the most out of their hardware constraints.
For you as a developer, however, that means that even though your code looks and feels like Java on the surface — most of the public API is identical --⁠, there isn’t a feature parity between the JDK and Android SDK you can rely on.
For example, the cornerstones of this book — <em>lambda expressions</em> and <em>Streams</em> — were among the missing features in Android for a long time.</p>
<p>The Android Gradle plugin started supporting some of the missing functional features (lambda expressions, method references, default and static interface methods) with version 3.0.0 by using so-called <em>desugaring</em>: the compiler uses bytecode transformations to replicate a feature <em>behind the scenes</em> without supporting the new syntax or providing an implementation in the runtime itself.
The next major version, 4.0.0, added even more functional features: Streams, Optionals, and the <code>java.util.function</code> package.
That allows you to benefit from the functional paradigms and tools discussed in this book, even as an Android developer.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Even though most of the JDK’s functional features are available on Android too, they are not verbatim copies<sup><a data-type="noteref" href="preface01.xhtml#idm45115253306592" id="idm45115253306592-marker">8</a></sup> and might have different performance characteristics and edge-cases.
The available features are listed in the <a href="https://developer.android.com/studio/write/java8-support">official documentation on the Java 8+ support</a>.</p>
</div>
<section data-pdf-bookmark="A Functional Approach to Android" data-type="sect2"><div class="sect2" id="idm45115254541856">
<h2>A Functional Approach to Android</h2>
<p>In 2019, <a href="https://kotlinlang.org">Kotlin</a> replaced Java as the preferred language for Android developers.
It’s a multi-platform language that mainly targets the JVM but also compiles to JavaScript and multiple native platforms, too<sup><a data-type="noteref" href="preface01.xhtml#idm45115253702896" id="idm45115253702896-marker">9</a></sup>.
It aims to be a “modern and more concise” Java, fixing many of Java’s debatable shortcomings and cruft accumulated over the years due to backward compatibility, without forgoing all the frameworks and libraries available to Java.
And it’s 100% interoperable: you can easily mix Java and Kotlin in the same project.</p>
<p>One obvious advantage of Kotlin over Java is that many functional concepts and idioms are integral to the language itself.
Still, as a different language, Kotlin has its own idioms and best practices that differ from Java’s.
The generated bytecode might differ, too, like how to generate lambdas<sup><a data-type="noteref" href="preface01.xhtml#idm45115253442784" id="idm45115253442784-marker">10</a></sup>.
The most significant advantage of Kotlin is its attempt to create a more concise and predictable language compared to Java.
And just like you can be more functional in Java without going <em>fully functional</em>, you can use Kotlin-only features without going <em>full Kotlin</em> in your Android projects, too.
By mixing Java and Kotlin, you can pick the best features from both languages.</p>
<p>Keep in mind that this book’s primary focus is the Java language and the JDK.
Still, most of the ideas behind what you will learn are transferrable to Android, even if you use Kotlin.
But there won’t be any special considerations for Android or Kotlin throughout the book.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Navigating This Book" data-type="sect1"><div class="sect1" id="idm45115254349216">
<h1>Navigating This Book</h1>
<p>This book consists of two different parts:</p>
<ul>
<li>
<p><a data-type="xref" href="part01.xhtml#_01-part-1">Part I</a>, <em>Functional Basics</em>, introduces the history and core concepts of functional programming, how Java implements these concepts, and what types are already available to us as developers.</p>
</li>
<li>
<p><a data-type="xref" href="part02.xhtml#_02-part-2">Part II</a>, <em>A Functional Approach</em>, is a topic-based deep-dive through the more generalized programming concepts and how to augment them with functional principles and the newly available tools.
Certain features, like <em>Records</em> and <em>Streams</em>, are highlighted with extended examples and use cases.</p>
</li>
</ul>
<p>Reading the chapters in their respective order will let you get the most out of them because they usually build on each other.
But feel free to skim for the bits that might interest you and jump around.
Any necessary connections are cross-referenced to fill in any blanks if needed.</p>
</div></section>
<section data-pdf-bookmark="Conventions Used in This Book" data-type="sect1"><div class="sect1" id="idm45115253864816">
<h1>Conventions Used in This Book</h1>
<p>The following typographical conventions are used in this book:</p>
<dl>
<dt><em>Italic</em></dt>
<dd>
<p>Indicates new terms, URLs, email addresses, filenames, and file extensions.</p>
</dd>
<dt><code>Constant width</code></dt>
<dd>
<p>Used for program listings, as well as within paragraphs, to refer to program elements such as variable or function names, databases, data types, environment variables, statements, and keywords.</p>
</dd>
<dt><strong><code>Constant width bold</code></strong></dt>
<dd>
<p>Shows commands or other text that should be typed literally by the user.</p>
</dd>
<dt><em><code>Constant width italic</code></em></dt>
<dd>
<p>Shows text that should be replaced with user-supplied values or by values determined by context.</p>
</dd>
</dl>
<div data-type="tip"><h6>Tip</h6>
<p>This element signifies a tip or suggestion.</p>
</div>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>This element signifies a general note.</p>
</div>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>This element indicates a warning or caution.</p>
</div>
</div></section>
<section data-pdf-bookmark="Using Code Examples" data-type="sect1"><div class="sect1" id="idm45115253336640">
<h1>Using Code Examples</h1>
<p>The source code for the book is available on GitHub: <a class="bare" href="https://github.com/benweidig/a-functional-approach-to-java"><em class="hyperlink">https://github.com/benweidig/a-functional-approach-to-java</em></a>.
Besides compilable Java code, there are also <em>JShell</em> scripts available to run the code more easily.
See the <a href="https://github.com/benweidig/a-functional-approach-to-java/README.md">README.md</a> for instructions on how to use them.</p>
<!--PROD: Please reach out to author to find out if they will be uploading code examples to oreilly.com or their own site (e.g., GitHub). If there is no code download, delete this whole section. If there is, when you email digidist with the link, let them know what you filled in for title_title (should be as close to book title as possible, i.e., learning_python_2e). This info will determine where digidist loads the files.-->
<p>If you have a technical question or a problem using the code examples, please send email to <a class="email" href="mailto:bookquestions@oreilly.com"><em>bookquestions@oreilly.com</em></a>.</p>
<p>This book is here to help you get your job done. In general, if example code is offered with this book, you may use it in your programs and documentation. You do not need to contact us for permission unless you’re reproducing a significant portion of the code. For example, writing a program that uses several chunks of code from this book does not require permission. Selling or distributing examples from O’Reilly books does require permission. Answering a question by citing this book and quoting example code does not require permission. Incorporating a significant amount of example code from this book into your product’s documentation does require permission.</p>
<p>We appreciate, but generally do not require, attribution. An attribution usually includes the title, author, publisher, and ISBN. For example: “<em>A Functional Approach to Java</em> by Ben Weidig (O’Reilly). Copyright 2023 Ben Weidig, 978-1-098-10992-9.”</p>
<p>If you feel your use of code examples falls outside fair use or the permission given above, feel free to contact us at <a class="email" href="mailto:permissions@oreilly.com"><em>permissions@oreilly.com</em></a>.</p>
</div></section>
<section data-pdf-bookmark="O’Reilly Online Learning" data-type="sect1"><div class="sect1" id="idm45115253722192">
<h1>O’Reilly Online Learning</h1>
<div class="ormenabled" data-type="note" epub:type="note"><h6>Note</h6>
<p>For more than 40 years, <a class="orm:hideurl" href="https://oreilly.com"><em class="hyperlink">O’Reilly Media</em></a> has provided technology and business training, knowledge, and insight to help companies succeed.</p>
</div>
<p>Our unique network of experts and innovators share their knowledge and expertise through books, articles, and our online learning platform. O’Reilly’s online learning platform gives you on-demand access to live training courses, in-depth learning paths, interactive coding environments, and a vast collection of text and video from O’Reilly and 200+ other publishers. For more information, visit <a class="orm:hideurl" href="https://oreilly.com"><em>https://oreilly.com</em></a>.</p>
<p>Please address comments and questions concerning this book to the publisher:</p>
<ul class="simplelist">
<li>O’Reilly Media, Inc.</li>
<li>1005 Gravenstein Highway North</li>
<li>Sebastopol, CA 95472</li>
<li>800-998-9938 (in the United States or Canada)</li>
<li>707-829-0515 (international or local)</li>
<li>707-829-0104 (fax)</li>
</ul>
<p>We have a web page for this book, where we list errata, examples, and any additional information. You can access this page at <a class="bare" href="https://oreil.ly/functional-approach-to-java-1e"><em class="hyperlink">https://oreil.ly/functional-approach-to-java-1e</em></a>.</p>
<!--Don't forget to update the link above.-->
<p>Email <a class="email" href="mailto:bookquestions@oreilly.com"><em>bookquestions@oreilly.com</em></a> to comment or ask technical questions about this book.</p>
<p>For news and information about our books and courses, visit <a class="bare" href="https://oreilly.com"><em class="hyperlink">https://oreilly.com</em></a>.</p>
<p>Find us on LinkedIn: <a class="bare" href="https://linkedin.com/company/oreilly-media"><em class="hyperlink">https://linkedin.com/company/oreilly-media</em></a></p>
<p>Follow us on Twitter: <a class="bare" href="https://twitter.com/oreillymedia"><em class="hyperlink">https://twitter.com/oreillymedia</em></a></p>
<p>Watch us on YouTube: <a class="bare" href="https://www.youtube.com/oreillymedia"><em class="hyperlink">https://www.youtube.com/oreillymedia</em></a></p>
</div></section>
<section data-pdf-bookmark="Acknowledgments" data-type="sect1"><div class="sect1" id="idm45115261236944">
<h1>Acknowledgments</h1>
<p>This book is for Alexander Neumer, the best mentor I could’ve wished for in my early career.
Without him, I wouldn’t be the developer I am today.</p>
<p>I want especially like to thank Zan McQuade for her encouragement and for proposing to aggregate my ramblings about functional Java into a book in the first place.</p>
<p>The technical reviewers deserve special thanks, too: Dean Wampler, Venkat Subramaniam, Thiago H. de Paula Figueiredo, and
A.N.M. Bazlur Rahman.
Their support, suggestions, and sometimes harsh critique throughout the different stages of the book made it better than I could have done it all by myself.</p>
<p>I would also like to thank Felix Gonschorek and Benjamin Quenzer, the two friends and colleagues that “suffered” with me from the beginning and provided invaluable feedback up to the end.</p>
<p>Last but not least, I want to thank my Acquisitions Editor Brian Guerin and everyone at O’Reilly.
My Editor Rita Fernando, who always found a way to polish a few rough edges and get the best out of what I wrote.
Ashley Stussy, the Production Editor that made all my layout requests possible.
Nick and Theresa from the O’Reilly Tools Team, who patiently helped me through any Asciidoc issues that arose.
And all the other ones involved behind the scenes.
Thank you!</p>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="idm45115267496480"><sup><a href="preface01.xhtml#idm45115267496480-marker">1</a></sup> Originally specified in 1958, <em>Lisp</em> is the second-oldest high-level programming language still in common use. It also builds the foundation of a variety of programming languages, like <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/index.xhtml"><em>Emacs Lisp</em></a>, or the functional JVM language <a href="https://clojure.org/"><em>Clojure</em></a>.</p><p data-type="footnote" id="idm45115253372352"><sup><a href="preface01.xhtml#idm45115253372352-marker">2</a></sup> <em>Moore’s law</em> was coined in 1965 as the observation of transistor counts doubling every two years and, therefore, the performance per core available to us. Edwards, Chris. 2021. “Moore’s Law: What Comes Next?” <a href="https://doi.org/10.1145/3440992">Communications of the ACM, February 2021, Vol. 64 No. 2, 12–14</a></p><p data-type="footnote" id="idm45115268991152"><sup><a href="preface01.xhtml#idm45115268991152-marker">3</a></sup> Thompson, N. C., and Svenja Spanuth. 2021. “The decline of computers as a general-purpose technology.” <a href="https://doi.org/10.1145/3430936"><em>Communications of the ACM</em>, Vol. 64, No. 3, 64-72</a>.</p><p data-type="footnote" id="idm45115261275136"><sup><a href="preface01.xhtml#idm45115261275136-marker">4</a></sup> <a href="https://www.erlang.org/"><em>Erlang</em></a> is a functional and concurrency-oriented programming language that is known for building low-latency, distributed, and fault-tolerant systems.</p><p data-type="footnote" id="idm45115272990288"><sup><a href="preface01.xhtml#idm45115272990288-marker">5</a></sup> Dean Wampler shows in his book <a href="http://oreilly.com/catalog/9781449311032/">“Functional Programming for Java Developers”</a> quite detailed how to implement and facilitate the missing functional programming features in Java all by yourself. He showed many techniques that weren’t easily feasible before version 8. But now, many of the shortcomings and gaps in the JDK are closed up, and it provides many of the tools necessary to incorporate FP concisely and more straightforwardly.</p><p data-type="footnote" id="idm45115273019824"><sup><a href="preface01.xhtml#idm45115273019824-marker">6</a></sup> Oracle introduced a faster <a href="https://www.oracle.com/java/technologies/java-se-support-roadmap.xhtml">release schedule</a> for Java with the release of version 9. Instead of releasing infrequently, there’s now a fixed release cadence of six months. To meet such a tight schedule, not every release is considered “long-term-support”, in favor of releasing features faster than before.</p><p data-type="footnote" id="idm45115254361520"><sup><a href="preface01.xhtml#idm45115254361520-marker">7</a></sup> The Android Open Source project provides <a href="https://source.android.com/devices/tech/dalvik">a good overview</a> of the features and the reasoning behind Android’s runtime.</p><p data-type="footnote" id="idm45115253306592"><sup><a href="preface01.xhtml#idm45115253306592-marker">8</a></sup> Jack Wharton, a well-known Android developer, provides a <a href="https://jakewharton.com/androids-java-8-support/">detailed insight</a> on how Android desugars modern Java code.</p><p data-type="footnote" id="idm45115253702896"><sup><a href="preface01.xhtml#idm45115253702896-marker">9</a></sup> See the official Kotlin documentation for <a href="https://kotlinlang.org/docs/multiplatform-dsl-reference.xhtml">an overview of supported platforms</a>.</p><p data-type="footnote" id="idm45115253442784"><sup><a href="preface01.xhtml#idm45115253442784-marker">10</a></sup> Each lambda compiles to an anonymous class extending <code>kotlin.jvm.internal.FunctionImpl</code>, as explained in the <a href="https://github.com/JetBrains/kotlin/blob/aabc00f53faa72f7c070c2512e655abffad37597/spec-docs/function-types.md">function type specs</a>.</p></div></div></section></div></body></html>