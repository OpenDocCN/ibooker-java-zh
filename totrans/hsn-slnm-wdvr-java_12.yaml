- en: Chapter 9\. Third-Party Integrations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章：第三方集成
- en: This chapter introduces different third-party technologies (such as libraries
    or frameworks) that we can use with Selenium WebDriver. We need to use these technologies
    when the Selenium WebDriver API is insufficient to carry out specific tasks. This
    is the case for file downloading, in which we need to use a third-party utility
    to wait until the files are correctly downloaded or, alternatively, use an HTTP
    client to control the download. We also capture the HTTP traffic using a third-party
    proxy.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了不同的第三方技术（如库或框架），我们可以与 Selenium WebDriver 结合使用。当 Selenium WebDriver API
    不足以执行特定任务时，我们需要使用这些技术，比如文件下载，我们需要使用第三方工具来等待文件正确下载，或者使用 HTTP 客户端来控制下载。我们还可以使用第三方代理来捕获
    HTTP 流量。
- en: Another scenario in which we need to use external utilities with Selenium WebDriver
    is when implementing nonfunctional tests, such as performance, security, accessibility,
    or A/B testing. We can also use third-party libraries to develop Selenium WebDriver
    tests using a fluent API, generate fake test data, or improve test reporting.
    Finally, we can integrate relevant frameworks such as Cucumber for Behavior Driven
    Development (BDD) or the Spring Framework (for developing web applications). We
    will go through all of these uses in this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个场景是我们需要使用 Selenium WebDriver 与外部工具结合来实现非功能性测试，比如性能、安全性、可访问性或 A/B 测试。我们还可以使用第三方库开发
    Selenium WebDriver 测试，使用流畅的 API，生成虚拟测试数据，或者改进测试报告。最后，我们可以集成相关框架如 Cucumber 用于行为驱动开发（BDD），或者
    Spring Framework（用于开发 Web 应用）。本章节将详细介绍所有这些用途。
- en: Tip
  id: totrans-3
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: To use the third-party utilities presented in this chapter, you must first include
    the required dependencies in your project. You can find the details for resolving
    each dependency using Maven and Gradle in [Appendix C](app03.html#appendix03).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用本章介绍的第三方工具，你必须首先在项目中包含所需的依赖项。你可以在 [附录 C](app03.html#appendix03) 中找到使用 Maven
    和 Gradle 解决每个依赖项的详细信息。
- en: File Download
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件下载
- en: Selenium WebDriver has limited support for file downloading because its API
    does not expose download progress. In other words, we can use Selenium WebDriver
    to download files from web applications, but we cannot control the required time
    to copy these files into the local file system. For this reason, we can use third-party
    libraries to enhance the experience of web downloads with Selenium WebDriver.
    There are different alternatives to this aim. The following subsections explain
    how.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium WebDriver 对文件下载的支持有限，因为其 API 不公开下载进度。换句话说，我们可以使用 Selenium WebDriver
    下载来自 Web 应用的文件，但无法控制将这些文件复制到本地文件系统所需的时间。因此，我们可以使用第三方库来增强使用 Selenium WebDriver
    进行 Web 下载的体验。有不同的替代方案来实现这个目标。下面的小节将详细解释如何做到这一点。
- en: Using Browser-Specific Capabilities
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用浏览器特定的能力
- en: We can use browser-specific capabilities (as we did in [Chapter 5](ch05.html#ch05))
    to configure several parameters for file downloading, such as the target folder.
    This approach is convenient since these features are available in the Selenium
    WebDriver API out of the box, but it also has several disadvantages. First, it
    is incompatible with different browser types (Chrome, Firefox, etc.). In other
    words, the required capabilities are distinct for individual browsers. Second,
    and more importantly, we do not have the control to track download progress. To
    solve this problem, we need to use a third-party library. In this book, I propose
    using the open source library [Awaitility](http://www.awaitility.org).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用特定于浏览器的能力（就像我们在 [第 5 章](ch05.html#ch05) 中所做的那样）来配置文件下载的各种参数，例如目标文件夹。这种方法很方便，因为这些功能在
    Selenium WebDriver API 中是开箱即用的，但它也有几个缺点。首先，它与不同的浏览器类型（如 Chrome、Firefox 等）不兼容。换句话说，每个浏览器的所需能力是不同的。其次，更重要的是，我们无法控制跟踪下载进度。为了解决这个问题，我们需要使用第三方库。在本书中，我建议使用开源库
    [Awaitility](http://www.awaitility.org)。
- en: Awaitility is a popular library that provides features to handle asynchronous
    operations. This way, it provides a fluent API for managing threads, timeouts,
    and concurrency issues. In the case of downloading files with Selenium WebDriver,
    we use the Awaitility API to wait until the downloaded files are stored in the
    file system. [Example 9-1](#file-download-1) shows an example using Chrome and
    Awaitility. [Example 9-2](#file-download-2) shows the equivalent test setup when
    using Firefox.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Awaitility 是一个流行的库，提供处理异步操作的功能。它通过提供流畅的 API 来管理线程、超时和并发问题。在使用 Selenium WebDriver
    下载文件的情况下，我们使用 Awaitility API 等待直到文件存储在文件系统中。[示例 9-1](#file-download-1) 展示了使用 Chrome
    和 Awaitility 的示例。[示例 9-2](#file-download-2) 展示了使用 Firefox 时等效的测试设置。
- en: Example 9-1\. Test download files using Chrome and Awaitility
  id: totrans-10
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 9-1\. 使用 Chrome 和 Awaitility 测试下载文件
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[![1](assets/1.png)](#co_third_party_integrations_CO1-1)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_third_party_integrations_CO1-1)'
- en: We specify a folder to save the downloaded files. Nevertheless, you should be
    aware that Chrome allows only certain directories for download. For example, it
    allows the download directory (and subfolder) but forbids employing other paths,
    such as the desktop folder or the home directory.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定一个文件夹保存下载的文件。但是需要注意，Chrome 只允许特定的目录用于下载。例如，它允许下载目录（及其子文件夹），但禁止使用其他路径，如桌面文件夹或主目录。
- en: '[![2](assets/2.png)](#co_third_party_integrations_CO1-2)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_third_party_integrations_CO1-2)'
- en: We use a Chrome preference to specify the target folder.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Chrome 首选项指定目标文件夹。
- en: '[![3](assets/3.png)](#co_third_party_integrations_CO1-3)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_third_party_integrations_CO1-3)'
- en: We use a web page available on the practice site to download different files
    by clicking on buttons (see [Figure 9-1](#download-files)).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用练习网站上提供的网页通过点击按钮下载不同的文件（见[图 9-1](#download-files)）。
- en: '[![4](assets/4.png)](#co_third_party_integrations_CO1-4)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_third_party_integrations_CO1-4)'
- en: 'We click on two of the buttons available on the page. As a result, the browser
    starts downloading two files: a PNG picture and a PDF document, respectively.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们点击页面上的两个按钮。结果，浏览器开始下载两个文件：一个 PNG 图片和一个 PDF 文档。
- en: '[![5](assets/5.png)](#co_third_party_integrations_CO1-5)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_third_party_integrations_CO1-5)'
- en: We use Awaitility to configure a wait timeout of five seconds.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Awaitility 配置了五秒的等待超时。
- en: '[![6](assets/6.png)](#co_third_party_integrations_CO1-6)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_third_party_integrations_CO1-6)'
- en: We wait until the first file is in the file system.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们等待直到第一个文件在文件系统中。
- en: '[![7](assets/7.png)](#co_third_party_integrations_CO1-7)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_third_party_integrations_CO1-7)'
- en: We also wait until the second file is downloaded.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还等待第二个文件下载完成。
- en: Example 9-2\. Test setup for downloading files using Firefox
  id: totrans-26
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-2\. 使用 Firefox 下载文件的测试设置
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[![1](assets/1.png)](#co_third_party_integrations_CO2-1)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_third_party_integrations_CO2-1)'
- en: Firefox allows specifying any folder for downloading files. In this case, we
    use the local project folder.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Firefox 允许指定任何文件夹来下载文件。在这种情况下，我们使用本地项目文件夹。
- en: '[![2](assets/2.png)](#co_third_party_integrations_CO2-2)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_third_party_integrations_CO2-2)'
- en: We use a Firefox preference to specify a custom download directory.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Firefox 首选项指定自定义下载目录。
- en: '[![3](assets/3.png)](#co_third_party_integrations_CO2-3)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_third_party_integrations_CO2-3)'
- en: We need to set to `2` the preference `browser.download.folderList` to select
    a custom download folder. The other possible values are `0` to download files
    into the user desktop and `1` to use the download folder (default value).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将首选项 `browser.download.folderList` 设置为 `2` 以选择自定义下载文件夹。其他可能的值为 `0`（将文件下载到用户桌面）和
    `1`（使用下载文件夹，即默认值）。
- en: '[![4](assets/4.png)](#co_third_party_integrations_CO2-4)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_third_party_integrations_CO2-4)'
- en: We specify the content types that Firefox will not ask to save in the local
    file system.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定 Firefox 不会要求保存在本地文件系统中的内容类型。
- en: '[![5](assets/5.png)](#co_third_party_integrations_CO2-5)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_third_party_integrations_CO2-5)'
- en: We disable the previsualization of PDF files.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们禁用 PDF 文件的预览。
- en: '![hosw 0901](assets/hosw_0901.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![hosw 0901](assets/hosw_0901.png)'
- en: Figure 9-1\. Practice web page for downloading file
  id: totrans-39
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-1\. 用于下载文件的练习网页
- en: Using an HTTP Client
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 HTTP 客户端
- en: An alternative mechanism to download files with Selenium WebDriver is to use
    an HTTP client library. I propose using [Apache HttpClient](https://hc.apache.org/httpcomponents-client-5.1.x),
    since WebDriverManager internally uses this library, and therefore, you can use
    it as a transitive dependency in your project. [Example 9-3](#file-download-3)
    shows a complete test case that downloads several files with Apache HttpClient
    from the practice site. Notice that in this case, it is not necessary to explicitly
    wait until the file download finishes since Apache HttpClient handles the HTTP
    responses synchronously.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Selenium WebDriver下载文件的另一种机制是使用HTTP客户端库。我建议使用[Apache HttpClient](https://hc.apache.org/httpcomponents-client-5.1.x)，因为WebDriverManager内部使用了这个库，因此你可以在项目中作为传递依赖使用它。[示例 9-3](#file-download-3)
    展示了使用Apache HttpClient从实践站点下载多个文件的完整测试用例。注意，在这种情况下，不需要显式等待文件下载完成，因为Apache HttpClient同步处理HTTP响应。
- en: Example 9-3\. Test download files using an HTTP client
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-3\. 使用HTTP客户端下载文件的测试
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[![1](assets/1.png)](#co_third_party_integrations_CO3-1)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_third_party_integrations_CO3-1)'
- en: We use the practice web page again for downloading files.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用实践网页下载文件。
- en: '[![2](assets/2.png)](#co_third_party_integrations_CO3-2)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_third_party_integrations_CO3-2)'
- en: We click on a button to download a file.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们点击一个按钮来下载一个文件。
- en: '[![3](assets/3.png)](#co_third_party_integrations_CO3-3)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_third_party_integrations_CO3-3)'
- en: We refactor the common logic for downloading files in the class method `download`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重构了类方法`download`中下载文件的通用逻辑。
- en: '[![4](assets/4.png)](#co_third_party_integrations_CO3-4)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_third_party_integrations_CO3-4)'
- en: We repeat the operation for a second file to be downloaded.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为第二个要下载的文件重复操作。
- en: '[![5](assets/5.png)](#co_third_party_integrations_CO3-5)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_third_party_integrations_CO3-5)'
- en: We create an Apache HTTPClient instance inside a try-with-resources. This client
    is automatically closed at the end of the statement scope.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在try-with-resources中创建了一个Apache HTTPClient实例。这个客户端在语句作用域结束时会自动关闭。
- en: '[![6](assets/6.png)](#co_third_party_integrations_CO3-6)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_third_party_integrations_CO3-6)'
- en: We use another try-with-resources statement to send an HTTP request to the provided
    URL and, as a result, get an HTTP response.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用另一个try-with-resources语句向提供的URL发送HTTP请求，并获得HTTP响应。
- en: '[![7](assets/7.png)](#co_third_party_integrations_CO3-7)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_third_party_integrations_CO3-7)'
- en: We copy the resulting file in the local file system.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将生成的文件复制到本地文件系统中。
- en: Capture Network Traffic
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捕获网络流量
- en: '[“Network monitoring”](ch05.html#section-network-monitoring) and [“Network
    interceptor”](ch05.html#network-interceptor) explain how to use browser-specific
    capabilities to capture the HTTP traffic between Selenium WebDriver and the web
    application under test. The drawback of this mechanism is that it is only available
    in browsers that support CDP. Nevertheless, we can use a third-party proxy for
    other browsers. In this book, I propose you use [BrowserMob](https://bmp.lightbody.net)
    proxy for this purpose.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '[“网络监控”](ch05.html#section-network-monitoring) 和 [“网络拦截器”](ch05.html#network-interceptor)
    解释了如何使用特定于浏览器的功能来捕获Selenium WebDriver和测试中的Web应用程序之间的HTTP流量。这种机制的缺点是只有支持CDP的浏览器才能使用。然而，我们可以为其他浏览器使用第三方代理。在本书中，我建议您为此目的使用[BrowserMob](https://bmp.lightbody.net)代理。'
- en: BrowserMob is an open source proxy that allows manipulating HTTP traffic using
    a Java library. [Example 9-4](#capture-network-proxy) shows a complete test using
    this proxy in a Selenium WebDriver test. In this example, we use the BrowserMob
    proxy to intercept the HTTP traffic between the test and the target website, tracing
    this traffic (request-response) as logging traces.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: BrowserMob是一个开源代理，允许使用Java库操纵HTTP流量。[示例 9-4](#capture-network-proxy) 展示了在Selenium
    WebDriver测试中使用此代理的完整测试。在此示例中，我们使用BrowserMob代理拦截测试和目标网站之间的HTTP流量，并跟踪这些流量（请求-响应）作为日志跟踪。
- en: Example 9-4\. Test capturing network traffic through BrowserMob proxy
  id: totrans-61
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-4\. 通过BrowserMob代理捕获网络流量的测试
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[![1](assets/1.png)](#co_third_party_integrations_CO4-1)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_third_party_integrations_CO4-1)'
- en: We create an instance of a BrowserMob.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个BrowserMob的实例。
- en: '[![2](assets/2.png)](#co_third_party_integrations_CO4-2)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_third_party_integrations_CO4-2)'
- en: We start this proxy.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们启动这个代理。
- en: '[![3](assets/3.png)](#co_third_party_integrations_CO4-3)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_third_party_integrations_CO4-3)'
- en: We capture the HTTP traffic using HAR (HTTP Archive), a JSON-based file format
    used to capture and export this traffic.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用HAR（HTTP存档）来捕获HTTP流量，这是一种基于JSON的文件格式，用于捕获和导出这些流量。
- en: '[![4](assets/4.png)](#co_third_party_integrations_CO4-4)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: We enable capturing the exchanged HTTP requests and responses.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_third_party_integrations_CO4-5)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: We transform the BrowserMob server into a Selenium WebDriver proxy.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_third_party_integrations_CO4-6)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: We set this proxy as a browser option (in this case, for Firefox).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_third_party_integrations_CO4-7)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: We need to allow insecure certificates since the communication with the proxy
    is done using HTTP (and not HTTPS).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_third_party_integrations_CO4-8)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: We stop the proxy after the test.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[![9](assets/9.png)](#co_third_party_integrations_CO4-9)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: We use the proxy instance to gather the HTTP traffic (requests and responses).
    We use a logger to write this information in the standard output in this basic
    example.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Nonfunctional Testing
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As explained in [Chapter 1](ch01.html#ch01), Selenium WebDriver is primarily
    used to assess the functional requirements of web applications. In other words,
    testers use the Selenium WebDriver API to verify that a web application under
    test behaves as expected. Nevertheless, we can leverage this API to test nonfunctional
    requirements, i.e., quality attributes such as performance, security, accessibility,
    etc. A common strategy to accomplish this goal is to integrate with specific third-party
    utilities. The following subsections explain different integrations with Selenium
    WebDriver for nonfunctional testing.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Performance testing evaluates the responsiveness and stability of a SUT under
    a particular workload. Instead of Selenium WebDriver, testers usually adopt specific
    tools like [Apache JMeter](https://jmeter.apache.org) for performance testing.
    Apache JMeter is an open source tool that allows sending multiple HTTP requests
    to a given URL endpoint while measuring the response time and other metrics. Although
    the direct integration between Selenium WebDriver and Apache JMeter is not trivial,
    we can leverage an existing Selenium WebDriver test as a JMeter test plan (i.e.,
    the series of steps that JMeter executes). The benefit of this approach is that
    the resulting JMeter test plan will mimic the same user workflow used in the Selenium
    WebDriver test, reusing the same HTTP traffic the browser makes (e.g., for JavaScript
    libraries, CSS, etc.). To that aim, I propose the following procedure:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Use the BrowserMob proxy (introduced in the previous section) to capture the
    exchanged network traffic in Selenium WebDriver as a HAR file.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert the resulting HAR file to a JMeter test plan. Test plans in JMeter are
    stored as XML-based files with the extension JMX.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load the JMX test plan in JMeter and tune it for simulating concurrent users
    and including result listeners
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the test plan and evaluate the results.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Example 9-5](#har-creation) shows a complete test case that implements the
    first step. As you can see, the required login to start and create the HAR file
    is done before and after each test. You can use this approach to leverage existing
    functional tests (i.e., the logic in the `@Test` methods) as performance tests
    (to be executed in JMeter).'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 9-5](#har-creation) 展示了实现第一步的完整测试案例。正如您所见，需要登录才能开始并创建 HAR 文件的步骤在每次测试前后都已完成。您可以使用此方法将现有的功能测试（即
    `@Test` 方法中的逻辑）作为性能测试来执行（在 JMeter 中执行）。'
- en: Example 9-5\. Test creating a HAR file
  id: totrans-90
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-5\. 创建 HAR 文件的测试。
- en: '[PRE4]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[![1](assets/1.png)](#co_third_party_integrations_CO5-1)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_third_party_integrations_CO5-1)'
- en: We start BrowserMob before the test and configure it in the `WebDriver` session.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在测试前启动 BrowserMob 并在 `WebDriver` 会话中配置它。
- en: '[![2](assets/2.png)](#co_third_party_integrations_CO5-2)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_third_party_integrations_CO5-2)'
- en: We get the HAR file after the test and write it as a local file.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试后，我们获取 HAR 文件并将其写入本地文件。
- en: 'After running the previous test, we get a HAR file called `login.har`. Now,
    we need to convert it to a JMeter test plan. There are different alternatives
    to do that. You can find several programs (e.g., in Ruby or Java) that make this
    job freely available on the web. Also, you can use online converters services,
    such as the [BlazeMeter JMX Converter](https://converter.blazemeter.com). In this
    example, I use this online service and open the resulting JMX test plan in JMeter.
    At this point, you can tune the JMeter configuration at your convenience (you
    can find further information about JMeter in its official [user manual](https://jmeter.apache.org/usermanual/index.html)).
    For instance, [Figure 9-2](#jmeter-screenshots-1) shows the JMeter GUI after loading
    the resulting JMX test plan plus the following changes:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的测试后，我们获得一个名为 `login.har` 的 HAR 文件。现在，我们需要将其转换为 JMeter 测试计划。有多种替代方案可供选择。您可以找到多个程序（例如
    Ruby 或 Java）在网上免费提供此服务。此外，您还可以使用在线转换服务，如 [BlazeMeter JMX Converter](https://converter.blazemeter.com)。在本示例中，我使用了这个在线服务，并在
    JMeter 中打开生成的 JMX 测试计划。此时，您可以根据需要调整 JMeter 配置（您可以在官方的 [用户手册](https://jmeter.apache.org/usermanual/index.html)
    中找到有关 JMeter 的更多信息）。例如，[图 9-2](#jmeter-screenshots-1) 显示了加载生成的 JMX 测试计划后 JMeter
    GUI 的更改情况：
- en: Increase the number of concurrent users to one hundred (in the “Thread Group”
    tab)
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将并发用户数增加到一百（在“Thread Group”选项卡中）
- en: Include some result listeners, such as “Aggregate Graph” and “Graph Results
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包括一些结果监听器，例如“聚合图”和“图形结果”。
- en: '![hosw 0902](assets/hosw_0902.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![hosw 0902](assets/hosw_0902.png)'
- en: Figure 9-2\. JMeter GUI loading the resulting test plan
  id: totrans-100
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-2\. JMeter GUI 加载生成的测试计划。
- en: Now, we can run the test plan with JMeter (for example, clicking on the button
    with a green triangle in the JMeter GUI). As a result, a load of one hundred concurrent
    users is generated following the interactions initially developed as a Selenium
    WebDriver test ([Example 9-5](#har-creation)). [Figure 9-3](#jmeter-screenshots-results)
    shows the results for the previously added listeners.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用 JMeter 运行测试计划（例如，在 JMeter GUI 中单击绿色三角形按钮）。结果是，根据最初开发的互动，生成了一百个并发用户的负载，作为
    Selenium WebDriver 测试的一部分（[示例 9-5](#har-creation)）。[图 9-3](#jmeter-screenshots-results)
    显示了之前添加的监听器的结果。
- en: '![hosw 0903](assets/hosw_0903.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![hosw 0903](assets/hosw_0903.png)'
- en: Figure 9-3\. JMeter results
  id: totrans-103
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-3\. JMeter 结果。
- en: Using browsers to generate the load
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用浏览器生成负载
- en: Using tools like JMeter is convenient for many performance testing scenarios
    for web applications. Nevertheless, this approach is unsuitable when you need
    actual browsers to recreate the complete user workflow (e.g., in videoconferencing
    web apps). In that case, a possible solution is to use WebDriverManager in conjunction
    with Docker. [Example 9-6](#load-wdm-docker) demonstrates this use. As you can
    see in this test, WebDriverManager allows creating a list of `WebDriver` instances
    simply by specifying the size as a parameter in the `create()` method. Then, for
    example, we can use standard Java to exercise the web application under test in
    parallel using a thread pool.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多 Web 应用性能测试场景，使用像 JMeter 这样的工具非常方便。然而，在需要实际浏览器重现完整用户工作流程（例如视频会议 Web 应用程序）时，此方法不适合。在这种情况下，一种可能的解决方案是与
    Docker 一起使用 WebDriverManager。[示例 9-6](#load-wdm-docker) 展示了这种用法。正如您在本测试中所见，WebDriverManager
    允许通过在 `create()` 方法中指定大小参数来简单地创建 `WebDriver` 实例列表。然后，例如，我们可以使用标准的 Java 使用线程池并行执行测试的
    Web 应用程序。
- en: Example 9-6\. Load test using WebDriverManager and Docker
  id: totrans-106
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-6\. 使用 WebDriverManager 和 Docker 进行负载测试。
- en: '[PRE5]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[![1](assets/1.png)](#co_third_party_integrations_CO6-1)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_third_party_integrations_CO6-1)'
- en: We create an instance of the Chrome manager, using Docker to execute the browsers
    as containers.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个 Chrome 管理器实例，使用 Docker 将浏览器作为容器执行。
- en: '[![2](assets/2.png)](#co_third_party_integrations_CO6-2)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_third_party_integrations_CO6-2)'
- en: We assume that Docker is installed in the machine running this test. Otherwise,
    the test is skipped.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设运行此测试的机器上已安装 Docker。否则，将跳过此测试。
- en: '[![3](assets/3.png)](#co_third_party_integrations_CO6-3)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_third_party_integrations_CO6-3)'
- en: We create a `WebDriver` list (containing five instances in this example).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个 `WebDriver` 列表（本示例中包含五个实例）。
- en: '[![4](assets/4.png)](#co_third_party_integrations_CO6-4)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_third_party_integrations_CO6-4)'
- en: We create a thread pool using the same size as the `WebDriver` list.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用与 `WebDriver` 列表相同大小的线程池。
- en: '[![5](assets/5.png)](#co_third_party_integrations_CO6-5)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_third_party_integrations_CO6-5)'
- en: We use the thread pool to execute in parallel the SUT assessment.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用线程池来并行执行 SUT 评估。
- en: '[![6](assets/6.png)](#co_third_party_integrations_CO6-6)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_third_party_integrations_CO6-6)'
- en: We wait until each parallel evaluation finishes. We use a synchronization method
    based on a counter latch to do that.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们等待每个并行评估完成。我们使用基于计数器门闩的同步方法来实现。
- en: Security
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全性
- en: A relevant organization in the software security domain is [OWASP](https://owasp.org)
    (Open Web Application Security Project), a nonprofit foundation that promotes
    open solutions to improve software security. One of the most popular OWASP projects
    is the Zed Attack Proxy (ZAP). [OWASP ZAP](https://www.zaproxy.org) is an open
    source web application security scanner used to implement *vulnerability assessment*
    (i.e., look for security issues) or *penetration testing* (i.e., a simulated cyberattack)
    to find exploitable web application vulnerabilities.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 软件安全领域的一个相关组织是 [OWASP](https://owasp.org)（开放网络应用安全项目），这是一个促进开放解决方案以提高软件安全性的非营利基金会。其中最流行的
    OWASP 项目之一是 Zed Attack Proxy（ZAP）。[OWASP ZAP](https://www.zaproxy.org) 是一个开源的
    Web 应用安全性扫描工具，用于实施*漏洞评估*（即寻找安全问题）或*渗透测试*（即模拟的网络攻击）以发现可利用的 Web 应用漏洞。
- en: We can use OWASP ZAP as a standalone desktop application. [Figure 9-4](#zap-gui)
    shows a screenshot of its GUI.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 OWASP ZAP 作为独立的桌面应用程序使用。[Figure 9-4](#zap-gui) 显示了其 GUI 的截图。
- en: '![hosw 0904](assets/hosw_0904.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![hosw 0904](assets/hosw_0904.png)'
- en: Figure 9-4\. OWASP ZAP GUI
  id: totrans-124
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-4\. OWASP ZAP GUI
- en: This GUI provides different features for automated scans to detect security
    threats that a web application might face, such as SQL injection, cross-site scripting
    (XSS), or cross-site request forgery (CSRF), to name a few.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 此 GUI 提供不同的功能以自动化扫描，以检测 Web 应用可能面临的安全威胁，如 SQL 注入、跨站点脚本（XSS）或跨站点请求伪造（CSRF）等。
- en: 'In addition to the standalone application, we can integrate a Selenium WebDriver
    test with ZAP. [Example 9-7](#zap-proxy-test) provides a test case illustrating
    this integration. The steps required to execute this test properly are:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 除了独立应用程序外，我们还可以将 Selenium WebDriver 测试与 ZAP 集成。[示例 9-7](#zap-proxy-test) 提供了一个说明此集成的测试用例。执行此测试所需的步骤包括：
- en: Start OWAS ZAP in the localhost. By default, OWASP starts a proxy that listens
    to port 8080\. You can change this port using the OWASP GUI using the menu option
    Tools → Options → Local Proxies.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本地主机上启动 OWASP ZAP。默认情况下，OWASP 启动一个代理，监听端口 8080。您可以使用 OWASP GUI 中的菜单选项 Tools
    → Options → Local Proxies 更改此端口。
- en: Disable the API key (or copy its value in the Selenium WebDriver test). You
    can change this value in the menu option Tools → Options → API.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 禁用 API 密钥（或在 Selenium WebDriver 测试中复制其值）。您可以在菜单选项 Tools → Options → API 中更改此值。
- en: Implement a Selenium WebDriver test that uses OWASP ZAP as a proxy (like [Example 9-7](#zap-proxy-test)).
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个使用 OWASP ZAP 作为代理的 Selenium WebDriver 测试（类似于 [示例 9-7](#zap-proxy-test)）。
- en: Execute the Selenium WebDriver test. At this point, you should see the generated
    vulnerability report in the ZAP GUI.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行 Selenium WebDriver 测试。此时，您应该在 ZAP GUI 中看到生成的漏洞报告。
- en: Example 9-7\. Test using OWASP ZAP as security scanner
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-7\. 使用 OWASP ZAP 作为安全扫描器的测试
- en: '[PRE6]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[![1](assets/1.png)](#co_third_party_integrations_CO7-1)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_third_party_integrations_CO7-1)'
- en: We configure the address and port where the ZAP local proxy is listening.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们配置 ZAP 本地代理监听的地址和端口。
- en: '[![2](assets/2.png)](#co_third_party_integrations_CO7-2)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_third_party_integrations_CO7-2)'
- en: If the ZAP API key is not disabled, we need to set its value here.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未禁用 ZAP API 密钥，则需要在这里设置其值。
- en: '[![3](assets/3.png)](#co_third_party_integrations_CO7-3)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_third_party_integrations_CO7-3)'
- en: We configure ZAP as a Selenium WebDriver proxy.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 ZAP 配置为 Selenium WebDriver 代理。
- en: '[![4](assets/4.png)](#co_third_party_integrations_CO7-4)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_third_party_integrations_CO7-4)'
- en: We interact with ZAP using its API.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用其 API 与 ZAP 进行交互。
- en: '[![5](assets/5.png)](#co_third_party_integrations_CO7-5)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_third_party_integrations_CO7-5)'
- en: After the test, we create an HTML report with vulnerabilities found during the
    execution of the Selenium WebDriver test. [Figure 9-5](#zap-report) shows a screenshot
    of this report.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试结束后，我们生成一个HTML报告，报告中包含在执行 Selenium WebDriver 测试期间发现的漏洞。[图 9-5](#zap-report)
    显示了此报告的屏幕截图。
- en: Note
  id: totrans-143
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: We can also use OWASP ZAP as a standalone GUI, as introduced previously. The
    potential benefit of the integration with Selenium WebDriver could be reusing
    existing functional tests for assessing security or automated security assessment
    (e.g., a regression test suite executed by a CI server).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以作为独立的 GUI 使用 OWASP ZAP，如前所介绍。与 Selenium WebDriver 集成的潜在好处可能是重用现有的功能测试以评估安全性或自动化安全评估（例如，由
    CI 服务器执行的回归测试套件）。
- en: '![hosw 0905](assets/hosw_0905.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![hosw 0905](assets/hosw_0905.png)'
- en: Figure 9-5\. Report generated by ZAP after executing a Selenium WebDriver test
  id: totrans-146
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-5\. ZAP 在执行 Selenium WebDriver 测试后生成的报告
- en: Accessibility
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可访问性
- en: Digital accessibility refers to the ability of users with disabilities to effectively
    use software systems such as websites, mobile apps, etc. An essential reference
    in this domain is the [Web Content Accessibility Guidelines](https://www.w3.org/WAI/standards-guidelines/wcag)
    (WCAG), which are a set of standard recommendations created by the W3C [Web Accessibility
    Initiative](https://www.w3.org/WAI) (WAI) that explain how to make web content
    more accessible to people with disabilities.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 数字可访问性指的是残障用户有效使用软件系统（如网站、移动应用等）的能力。在这一领域的一个重要参考是 [Web内容可访问性指南](https://www.w3.org/WAI/standards-guidelines/wcag)（WCAG），这是由
    W3C [Web可访问性倡议](https://www.w3.org/WAI)（WAI）制定的一套标准建议，解释如何使网页内容对残障人士更易访问。
- en: There are several methods to test the accessibility of web applications. The
    most common approach consists of checking the WCAG recommendations. To that aim,
    we can use automated accessibility scanners like [Axe](https://www.deque.com/axe),
    an open source engine for automated accessibility testing of web applications
    following WCAG rules. Axe provides seamless integration with the Java bindings
    of Selenium WebDriver using a [helper library](https://github.com/dequelabs/axe-core-maven-html).
    [Example 9-8](#axe-test) shows a test using this library.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以测试Web应用的可访问性。最常见的方法是检查 WCAG 建议。为此，我们可以使用自动化可访问性扫描器，如 [Axe](https://www.deque.com/axe)，这是一个开源引擎，用于按照
    WCAG 规则自动测试Web应用的可访问性。Axe 通过 Selenium WebDriver 的 Java 绑定与一个 [辅助库](https://github.com/dequelabs/axe-core-maven-html)
    实现无缝集成。[示例 9-8](#axe-test) 展示了使用此库进行测试。
- en: Example 9-8\. Test using Axe to generate an accessibility report
  id: totrans-150
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-8\. 使用 Axe 生成可访问性报告的测试
- en: '[PRE7]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[![1](assets/1.png)](#co_third_party_integrations_CO8-1)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_third_party_integrations_CO8-1)'
- en: We analyze the current `WebDriver` session with Axe. This way, all pages loaded
    in the browser will be scanned by Axe.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Axe 分析当前的 `WebDriver` 会话。这样，浏览器中加载的所有页面都将由 Axe 扫描。
- en: '[![2](assets/2.png)](#co_third_party_integrations_CO8-2)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_third_party_integrations_CO8-2)'
- en: We get a report of the accessibility violations found.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获得了可访问性违规的报告。
- en: '[![3](assets/3.png)](#co_third_party_integrations_CO8-3)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_third_party_integrations_CO8-3)'
- en: 'We log each violation in the standard output. In this example, the found issues
    are:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将每个违规记录在标准输出中。在此示例中，发现的问题包括：
- en: color-contrast
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 色彩对比
- en: Elements must have sufficient color contrast.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 元素必须具有足够的颜色对比度。
- en: heading-order
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 标题顺序
- en: Heading levels should only increase by one.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 标题级别应仅增加一级。
- en: image-alt
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图片替代文本
- en: Images must have alternate text.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图像必须具有替代文本。
- en: link-name
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 链接名称
- en: Links must have discernible text.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 链接必须具有可识别的文本。
- en: '[![4](assets/4.png)](#co_third_party_integrations_CO8-4)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_third_party_integrations_CO8-4)'
- en: We write the results as a local JSON file.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将结果写入本地的 JSON 文件中。
- en: A/B Testing
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A/B 测试
- en: A/B testing is a form of usability evaluation that compares variations of the
    same application to discover which one is more effective to its end users. Different
    commercial products facilitate advanced features for A/B tests in Selenium WebDriver
    tests. For example, [Applitools Eyes](https://applitools.com/products-eyes) provides
    an automated visual comparison of multiple web page variations. Another option
    is [Optimizely](https://www.optimizely.com), a company that provides tools for
    customizing and experimenting with A/B testing.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: A/B 测试是一种评估可用性的形式，它比较同一应用程序的不同变体，以发现哪一个对最终用户更有效。不同的商业产品为 Selenium WebDriver
    测试提供了 A/B 测试的高级功能。例如，[Applitools Eyes](https://applitools.com/products-eyes) 提供了多个网页变体的自动视觉比较。另一个选择是
    [Optimizely](https://www.optimizely.com)，这是一家提供定制和实验 A/B 测试工具的公司。
- en: Another way to carry out A/B testing is to use the vanilla Selenium WebDriver
    API and custom conditions for the different variations of a web page. [Example 9-9](#basic-ab-testing)
    shows a basic test following a manual approach for a multivariant web page. Notice
    that this test shows a simple way to implement an A/B test based on assessing
    the different page variations.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种进行 A/B 测试的方法是使用原始的 Selenium WebDriver API 和自定义条件来处理网页的不同变体。[示例 9-9](#basic-ab-testing)
    展示了一个基于手动方法实现多变体网页的基本测试。请注意，这个测试展示了一种基于评估不同页面变体的 A/B 测试的简单方法。
- en: Example 9-9\. Basic A/B test using Selenium WebDriver
  id: totrans-171
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-9\. 使用 Selenium WebDriver 的基本 A/B 测试
- en: '[PRE8]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[![1](assets/1.png)](#co_third_party_integrations_CO9-1)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_third_party_integrations_CO9-1)'
- en: We open a multivariant practice web page. The content of this page is randomly
    loaded 50% of the time.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打开一个多变体练习网页。该页面的内容每次随机加载的概率为 50%。
- en: '[![2](assets/2.png)](#co_third_party_integrations_CO9-2)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_third_party_integrations_CO9-2)'
- en: We check the page variations are as expected.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查页面的变体是否符合预期。
- en: Fluent API
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流畅 API
- en: As introduced in [Chapter 1](ch01.html#ch01), Selenium is the foundation technology
    for other frameworks and libraries. For instance, we can find several libraries
    wrapping Selenium WebDriver to expose a fluent API for creating end-to-end tests
    for web applications. An example of this kind of library is [Selenide](https://selenide.org),
    an open source (MIT license) library that defines a concise fluent API on top
    of Selenium WebDriver. Selenide provides several benefits, such as automated waiting
    for web elements or support for AJAX applications.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如在 [第 1 章](ch01.html#ch01) 中介绍的，Selenium 是其他框架和库的基础技术。例如，我们可以找到几个封装了 Selenium
    WebDriver 的库，以便为 Web 应用程序创建端到端测试的流畅 API。这类库的一个例子是 [Selenide](https://selenide.org)，这是一个开源（MIT
    许可证）的库，它在 Selenium WebDriver 之上定义了一个简洁的流畅 API。Selenide 提供多种好处，例如自动等待 Web 元素或支持
    AJAX 应用程序。
- en: A relevant difference of a Selenide test compared to Selenium WebDriver is that
    Selenide handles the `WebDriver` objects internally. For that, it uses WebDriverManager
    to resolve the required driver (e.g., chromedriver, geckodriver, etc.), holding
    the `WebDriver` instance in a separate thread that is closed at the end of the
    test. As a result, the required test boilerplate related to the creation and termination
    of `WebDriver` objects is not required. [Example 9-10](#selenide-test) demonstrates
    this feature by showing a basic Selenide test.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Selenium WebDriver 相比，Selenide 的一个显著区别在于它在内部处理 `WebDriver` 对象。为此，它使用 WebDriverManager
    来解析所需的驱动程序（例如 chromedriver、geckodriver 等），将 `WebDriver` 实例保持在一个单独的线程中，在测试结束时关闭。因此，不需要创建和终止
    `WebDriver` 对象所需的测试样板代码。[示例 9-10](#selenide-test) 通过展示一个基本的 Selenide 测试演示了这个特性。
- en: Example 9-10\. Test using Selenide
  id: totrans-180
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-10\. 使用 Selenide 进行测试
- en: '[PRE9]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[![1](assets/1.png)](#co_third_party_integrations_CO10-1)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_third_party_integrations_CO10-1)'
- en: We use the static method `open` provided by Selenide to navigate a given URL.
    By default, Selenide uses a local Chrome, although the browser can be changed
    using a configuration class (e.g., `Configuration.browser = "firefox";`) or using
    a Java system property (e.g., `-Dselenide.browser=firefox`).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Selenide 提供的 `open` 静态方法来访问给定的 URL。默认情况下，Selenide 使用本地的 Chrome 浏览器，尽管可以通过配置类（例如
    `Configuration.browser = "firefox";`）或使用 Java 系统属性（例如 `-Dselenide.browser=firefox`）来更改浏览器。
- en: '[![2](assets/2.png)](#co_third_party_integrations_CO10-2)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_third_party_integrations_CO10-2)'
- en: The Selenide method `$` allows you to locate web elements by CSS selector or
    using Selenium WebDriver `By` locators. This line of code uses the latter to type
    text into an input field.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Selenide 的 `$` 方法允许您通过 CSS 选择器或使用 Selenium WebDriver 的 `By` 定位器定位 Web 元素。此行代码使用后者向输入字段输入文本。
- en: '[![3](assets/3.png)](#co_third_party_integrations_CO10-3)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_third_party_integrations_CO10-3)'
- en: We locate another web element, this time by CSS selector, and click on it.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过CSS选择器定位另一个网页元素，并单击它。
- en: '[![4](assets/4.png)](#co_third_party_integrations_CO10-4)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_third_party_integrations_CO10-4)'
- en: We verify that the web element for successful login is present on the page and
    contains the expected text.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们验证登录成功的网页元素是否存在，并包含预期的文本。
- en: Test Data
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试数据
- en: 'A relevant part of any test case is the test data, i.e., the input data used
    to exercise the SUT. The selection of suitable test data is paramount for implementing
    effective tests. Differing techniques in classic testing theory for test data
    selection include:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 任何测试用例的相关部分都是测试数据，即用于执行SUT的输入数据。选择适当的测试数据对于实施有效的测试至关重要。经典测试理论中用于测试数据选择的不同技术包括：
- en: Equivalence partitioning
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 等价分区
- en: The process of testing by dividing all possible input test data into value sets
    that we assume to be processed in the same way.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将所有可能的输入测试数据分成我们假定以相同方式处理的值集的过程来进行测试。
- en: Boundary testing
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 边界测试
- en: The process of testing between extreme ends or between partitions of the input
    values. The basic idea of this approach is to select the representative limit
    values in an input domain (for example, below the minimum, minimum, just above
    the minimum, nominal, just below the maximum, maximum, and above the maximum value).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入值的极端端点或分区之间进行测试的过程。这种方法的基本思想是在输入域中选择代表性极限值（例如，最小值以下、最小值、略高于最小值、标称值、略低于最大值、最大值和超过最大值的值）。
- en: These approaches can be impractical in end-to-end testing since the required
    number of tests (and the resulting execution time) to carry out these strategies
    can be enormous. Alternatively, we typically select some representative test data
    manually to verify the *happy path* (i.e., *positive* testing), and optionally,
    some test data for unexpected conditions (*negative* testing).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法在端到端测试中可能并不实用，因为执行这些策略所需的测试数目（以及随之而来的执行时间）可能是巨大的。相反，我们通常手动选择一些代表性测试数据来验证*快乐路径*（即*正向*测试），并可选择一些用于意外情况的测试数据（*负向*测试）。
- en: Another alternative for selecting test data is using *fake* data, i.e., random
    data of different domains, such as personal names, surnames, addresses, countries,
    emails, phone numbers, etc. A simple alternative to this aim is using [Java Faker](https://dius.github.io/java-faker),
    a port of the popular [faker](https://github.com/faker-ruby/faker) Ruby gem. [Example 9-11](#javafaker-test)
    shows a test using this library. This test uses fake data to submit a web form
    available on the practice site. [Figure 9-6](#fake-data) shows this web page after
    submitting the form with that fake data.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 选择测试数据的另一种选择是使用*假*数据，即不同域的随机数据，如个人姓名、姓氏、地址、国家、电子邮件、电话号码等。实现这一目标的一个简单替代方法是使用[Java
    Faker](https://dius.github.io/java-faker)，这是流行的[Ruby faker](https://github.com/faker-ruby/faker)库的Java移植版。[示例 9-11](#javafaker-test)展示了使用该库进行测试的示例。此测试使用假数据提交了一个练习站点上可用的Web表单。[图 9-6](#fake-data)展示了在使用该假数据提交表单后的网页。
- en: Example 9-11\. Test using Java Faker to generate different types of fake data
  id: totrans-198
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-11\. 使用Java Faker生成不同类型的假数据进行测试
- en: '[PRE10]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[![1](assets/1.png)](#co_third_party_integrations_CO11-1)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_third_party_integrations_CO11-1)'
- en: We create an instance of Java Faker.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个Java Faker实例。
- en: '[![2](assets/2.png)](#co_third_party_integrations_CO11-2)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_third_party_integrations_CO11-2)'
- en: We send random data of different types (name, address, country, etc.).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发送不同类型的随机数据（姓名、地址、国家等）。
- en: '[![3](assets/3.png)](#co_third_party_integrations_CO11-3)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_third_party_integrations_CO11-3)'
- en: We verify that the data is submitted correctly.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们验证数据是否被正确提交。
- en: '[![4](assets/4.png)](#co_third_party_integrations_CO11-4)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_third_party_integrations_CO11-4)'
- en: We check there are no errors on the page.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查页面上是否没有错误。
- en: '![hosw 0906](assets/hosw_0906.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![hosw 0906](assets/hosw_0906.png)'
- en: Figure 9-6\. Practice page using fake data
  id: totrans-209
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9-6\. 使用假数据的实践页面
- en: Reporting
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 报告
- en: 'A *test report* is a document that summarizes the results after executing a
    test suite. This document typically contains the number of tests executed plus
    their verdicts (pass, fail, skip) and execution time. There are different ways
    to obtain a test report in our Java project. For example, when using Maven, we
    can create a basic test report using the following commands:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '*测试报告*是在执行测试套件后总结结果的文档。这份文档通常包括执行的测试数量及其判定结果（通过、失败、跳过）和执行时间。在我们的Java项目中，有不同的方法可以获得测试报告。例如，在使用Maven时，我们可以使用以下命令创建基本的测试报告：'
- en: '[PRE11]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[![1](assets/1.png)](#co_third_party_integrations_CO12-1)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_third_party_integrations_CO12-1)'
- en: We execute the test with Maven. As a result, the Maven Surefire plug-in generated
    a set of XML files in the `target` folder. These files contain the results of
    the test execution.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Maven执行测试。因此，Maven Surefire插件在`target`文件夹中生成了一组XML文件。这些文件包含了测试执行的结果。
- en: '[![2](assets/2.png)](#co_third_party_integrations_CO12-2)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_third_party_integrations_CO12-2)'
- en: We convert the XML reports into an HTML report. You can find this HTML report
    in your project folder `target/site`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将XML报告转换为HTML报告。您可以在项目文件夹`target/site`中找到此HTML报告。
- en: '[![3](assets/3.png)](#co_third_party_integrations_CO12-3)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_third_party_integrations_CO12-3)'
- en: We force a copy of the CSS and images required in the HTML report. [Figure 9-7](#surefire-report)
    shows a screenshot of this report.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强制复制CSS和HTML报告中所需的图像。[图9-7](#surefire-report)显示了这份报告的屏幕截图。
- en: '![hosw 0907](assets/hosw_0907.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![hosw 0907](assets/hosw_0907.png)'
- en: Figure 9-7\. Test report generated with Maven
  id: totrans-220
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9-7。使用Maven生成的测试报告
- en: We can also generate an equivalent report using Gradle. After executing a test
    suite with this build tool, Gradle automatically generates an HTML report in the
    folder `build/reports`. [Figure 9-8](#gradle-report) shows an example of the test
    report generated for executing a group of tests (using the shell command `gradle
    test --tests Hello*`).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用Gradle生成等效的报告。在使用此构建工具执行测试套件后，Gradle会自动在文件夹`build/reports`中生成一个HTML报告。[图9-8](#gradle-report)展示了执行一组测试（使用shell命令`gradle
    test --tests Hello*`）时生成的测试报告示例。
- en: '![hosw 0908](assets/hosw_0908.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![hosw 0908](assets/hosw_0908.png)'
- en: Figure 9-8\. Test report generated with Gradle
  id: totrans-223
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9-8。使用Gradle生成的测试报告
- en: In addition to Maven and Gradle, we can use existing reporting libraries to
    create richer reports. A possible alternative is [Extent Reports](https://www.extentreports.com),
    a library to create interactive test reports. Extent Reports provides professional
    (commercial) and community (open source) editions. [Example 9-12](#extentreports-test)
    shows a test using the latter.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Maven和Gradle，我们还可以使用现有的报告库来创建更丰富的报告。一个可能的替代方案是[Extent Reports](https://www.extentreports.com)，一个用于创建交互式测试报告的库。Extent
    Reports提供专业（商业）和社区（开源）版本。示例9-12展示了使用后者的测试。
- en: Example 9-12\. Test using Extent Reports to generate an HTML report
  id: totrans-225
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例9-12。使用Extent Reports生成HTML报告的测试
- en: '[PRE12]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[![1](assets/1.png)](#co_third_party_integrations_CO13-1)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_third_party_integrations_CO13-1)'
- en: We create an instance of the test reporter.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个测试报告生成器的实例。
- en: '[![2](assets/2.png)](#co_third_party_integrations_CO13-2)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_third_party_integrations_CO13-2)'
- en: We configure it to generate an HTML report.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对其进行配置，以生成一个HTML报告。
- en: '[![3](assets/3.png)](#co_third_party_integrations_CO13-3)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_third_party_integrations_CO13-3)'
- en: After each test, we create an entry in the test report using the test name as
    an identifier. In JUnit 5, we use `TestInfo`, a built-in parameter resolver that
    allows retrieving information about the current test.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次测试后，我们使用测试名称作为标识符在测试报告中创建一个条目。在JUnit 5中，我们使用`TestInfo`，这是一个内置的参数解析器，允许检索关于当前测试的信息。
- en: '[![4](assets/4.png)](#co_third_party_integrations_CO13-4)'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_third_party_integrations_CO13-4)'
- en: As usual, you can find the complete source code in the [examples repository](https://github.com/bonigarcia/selenium-webdriver-java).
    In particular, this class has two test methods. [Figure 9-9](#extent-report) shows
    the resulting test report generated when this test class is executed.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，您可以在[示例仓库](https://github.com/bonigarcia/selenium-webdriver-java)中找到完整的源代码。特别是，这个类有两个测试方法。图9-9展示了当执行这个测试类时生成的测试报告的结果。
- en: '![hosw 0909](assets/hosw_0909.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![hosw 0909](assets/hosw_0909.png)'
- en: Figure 9-9\. Test report generated with Extent Reports
  id: totrans-236
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9-9。使用Extent Reports生成的测试报告
- en: An inconvenience of Extent Reports is that we need to add each test explicitly
    to the reporter. A possible solution to this problem is using custom test listeners
    (as explained in [“Test Listeners”](ch08.html#sect-test-listeners)) to group the
    common logic for reporting.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Extent Reports的一个不便之处是我们需要显式地将每个测试添加到报告器中。解决此问题的一个可能方法是使用自定义测试监听器（如[“测试监听器”](ch08.html#sect-test-listeners)中所述）来组织报告的公共逻辑。
- en: Another possible library for generating rich test reports is [Allure](http://allure.qatools.ru),
    an open source reporting framework for generating test reports for different programming
    languages, including Java, Python, and JavaScript, among others. A notable difference
    between Allure and Extent Reports is that Allure uses a test listener configured
    in the build tool Maven or Gradle (see [Appendix C](app03.html#appendix03) for
    further details about this configuration). This way, we did not need to change
    our test suite for generating Allure reports. [Table 9-1](#allure-commands) summarizes
    the necessary commands to create Allure reports with Maven and Gradle.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个生成丰富测试报告的可能库是[Allure](http://allure.qatools.ru)，一个开源报告框架，用于生成Java、Python和JavaScript等不同编程语言的测试报告。Allure和Extent
    Reports之间一个显著的区别在于Allure使用了在构建工具Maven或Gradle中配置的测试监听器（详见[附录C](app03.html#appendix03)了解有关此配置的详细信息）。因此，我们无需更改测试套件即可生成Allure报告。[表格9-1](#allure-commands)总结了使用Maven和Gradle创建Allure报告所需的命令。
- en: Table 9-1\. Maven and Gradle commands to generate test reports with Allure
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 表格9-1\. 使用Allure生成测试报告的Maven和Gradle命令
- en: '| Maven | Gradle | Description |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| Maven | Gradle | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '|'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE13]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '|'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE14]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '| Run test cases Create the reports on the target folder'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '| 运行测试用例，生成目标文件夹中的报告'
- en: Open the HTML report using a local web server (as shown in [Figure 9-10](#allure-report))
    |
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本地Web服务器打开HTML报告（如[图9-10](#allure-report)所示） |
- en: '![hosw 0910](assets/hosw_0910.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![hosw 0910](assets/hosw_0910.png)'
- en: Figure 9-10\. Test report generated with Allure and served locally
  id: totrans-249
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9-10\. 使用Allure生成并本地展示的测试报告
- en: Behavior Driven Development
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行为驱动开发
- en: 'As introduced in [Chapter 1](ch01.html#ch01), Behavior Driven Development (BDD)
    is a software methodology that promotes the development and testing of software
    systems using high-level user scenarios. Different tools implement the BDD methodology.
    One of the most popular is [Cucumber](https://cucumber.io). Cucumber executes
    tests based on user stories written in *Gherkin*, a human-readable notation based
    on natural languages (e.g., English and others). Gherkin was designed to be used
    by nonprogrammers (e.g., customers or end users), and its main keywords are listed
    next (see the [Gherkin user manual](https://cucumber.io/docs/gherkin) for further
    information):'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第1章](ch01.html#ch01)介绍的，行为驱动开发（BDD）是一种软件方法论，促进使用高级用户场景开发和测试软件系统。不同的工具实现了BDD方法论。其中最流行的之一是[Cucumber](https://cucumber.io)。Cucumber根据用*Gherkin*语言编写的用户故事执行测试，这种语言是一种基于自然语言（如英语和其他语言）的人类可读标记。Gherkin旨在供非程序员（例如客户或最终用户）使用，其主要关键字如下（详见[Gherkin用户手册](https://cucumber.io/docs/gherkin)获取更多信息）：
- en: Feature
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 特性
- en: High-level description of the software feature tested.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 被测试的软件功能的高级描述。
- en: Scenario
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 场景
- en: 'Concrete test that illustrates a business rule. Scenarios describe different
    pieces of information (called *steps* in the Gherkin jargon), such as:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 描述业务规则的具体测试。场景描述了Gherkin行话中称为*步骤*的不同信息，例如：
- en: Given
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 给定
- en: Preconditions and initial state
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 前提条件和初始状态
- en: When
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 当
- en: User actions
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 用户动作
- en: And
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 并且
- en: Additional user actions
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 附加用户操作
- en: Then
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 然后
- en: Expected outcome
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 预期结果
- en: '[Example 9-13](#gherkin-scenario) shows a Gherkin feature containing two scenarios
    for a test login (successful and failed).'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例9-13](#gherkin-scenario)展示了一个包含两个场景（登录成功和失败）的Gherkin特性。'
- en: Example 9-13\. Gherkin scenarios for login into the practice site
  id: totrans-265
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例9-13\. 用于登录实践站点的Gherkin场景
- en: '[PRE15]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[![1](assets/1.png)](#co_third_party_integrations_CO14-1)'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_third_party_integrations_CO14-1)'
- en: Feature description
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 功能描述
- en: '[![2](assets/2.png)](#co_third_party_integrations_CO14-2)'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_third_party_integrations_CO14-2)'
- en: First scenario (login successful)
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个场景（登录成功）
- en: '[![3](assets/3.png)](#co_third_party_integrations_CO14-3)'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_third_party_integrations_CO14-3)'
- en: Browser to be used
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用的浏览器
- en: '[![4](assets/4.png)](#co_third_party_integrations_CO14-4)'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_third_party_integrations_CO14-4)'
- en: Web page URL
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 网页URL
- en: '[![5](assets/5.png)](#co_third_party_integrations_CO14-5)'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_third_party_integrations_CO14-5)'
- en: Set of actions (type credentials and click the Submit button)
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 一组动作（输入凭据并点击提交按钮）
- en: '[![6](assets/6.png)](#co_third_party_integrations_CO14-6)'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_third_party_integrations_CO14-6)'
- en: Expected message
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的消息
- en: '[![7](assets/7.png)](#co_third_party_integrations_CO14-7)'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_third_party_integrations_CO14-7)'
- en: Second scenario (login failed)
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个场景（登录失败）
- en: To run Gherkin scenarios as test cases, we must first create the corresponding
    *step definitions*. A step definition is a *glue code* that exercises the SUT
    using the information specified in the scenario. In Java, we use annotations (such
    as `@Given`, `@Then`, `@When`, or `@And`) to decorate methods implementing each
    step. These annotations contain a string value to map each step definition and
    the parameters. [Example 9-14](#cucumber-steps) shows a step definition for the
    Gherkin scenario defined on [Example 9-13](#gherkin-scenario). We use the Selenium
    WebDriver API to implement the required actions for navigation, web element interaction,
    etc.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 要将Gherkin场景作为测试用例运行，我们首先必须创建相应的*步骤定义*。步骤定义是使用在场景中指定信息的*glue code*来执行SUT。在Java中，我们使用注解（如`@Given`、`@Then`、`@When`或`@And`）来装饰实现每个步骤的方法。这些注解包含一个字符串值，用于映射每个步骤定义和参数。[Example 9-14](#cucumber-steps)展示了用于Gherkin场景的步骤定义，该场景在[Example 9-13](#gherkin-scenario)中定义。我们使用Selenium
    WebDriver API来执行导航、网页元素交互等所需的操作。
- en: Example 9-14\. Steps to log in to the practice site with Cucumber
  id: totrans-282
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 9-14\. 使用Cucumber登录练习站点的步骤
- en: '[PRE16]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[![1](assets/1.png)](#co_third_party_integrations_CO15-1)'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_third_party_integrations_CO15-1)'
- en: We use the first step to create a `WebDriver` instance.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用第一步创建一个`WebDriver`实例。
- en: '[![2](assets/2.png)](#co_third_party_integrations_CO15-2)'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_third_party_integrations_CO15-2)'
- en: We open the URL.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打开URL。
- en: '[![3](assets/3.png)](#co_third_party_integrations_CO15-3)'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_third_party_integrations_CO15-3)'
- en: We type the credentials.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们输入凭据。
- en: '[![4](assets/4.png)](#co_third_party_integrations_CO15-4)'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_third_party_integrations_CO15-4)'
- en: We click on the Submit button.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们点击提交按钮。
- en: '[![5](assets/5.png)](#co_third_party_integrations_CO15-5)'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_third_party_integrations_CO15-5)'
- en: We verify that the expected message is on the page.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们验证页面上是否有预期的消息。
- en: Finally, we need to run our step definition as a test case. As usual, we create
    that test using a unit testing framework. This test is unit testing framework-dependent
    in the integration with Cucumber. In other words, the required code is different
    in JUnit 4 (see [Example 9-15](#cucumber-junit4)), JUnit 5 (see [Example 9-16](#cucumber-junit5)),
    and TestNG (see [Example 9-17](#cucumber-testng)). The resulting tests are executed
    in the usual way (i.e., using the shell or an IDE).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将步骤定义作为测试用例运行。通常情况下，我们使用单元测试框架创建该测试。这个测试在与Cucumber集成时依赖于单元测试框架，换句话说，不同的是在JUnit
    4中（见[Example 9-15](#cucumber-junit4)），JUnit 5中（见[Example 9-16](#cucumber-junit5)）和TestNG中（见[Example 9-17](#cucumber-testng)）。生成的测试以通常的方式执行（即使用Shell或IDE）。
- en: Note
  id: totrans-295
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Selenium-Jupiter does not provide any additional features for integrating with
    Cucumber, so the default JUnit 5 procedure is the same in the Selenium-Jupiter
    project in the examples repository.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium-Jupiter在与Cucumber集成时并未提供任何额外功能，因此在示例存储库中的Selenium-Jupiter项目中，使用的是默认的JUnit
    5过程。
- en: Example 9-15\. Cucumber test using JUnit 4
  id: totrans-297
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 9-15\. 使用JUnit 4进行Cucumber测试
- en: '[PRE17]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[![1](assets/1.png)](#co_third_party_integrations_CO16-1)'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_third_party_integrations_CO16-1)'
- en: We use the Cucumber runner to execute the step definitions as test cases.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Cucumber运行器来执行步骤定义作为测试用例。
- en: '[![2](assets/2.png)](#co_third_party_integrations_CO16-2)'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_third_party_integrations_CO16-2)'
- en: We specify the location of the Gherkin scenarios. In this case, the feature
    is the folder `io/github/bonigarcia` in the project classpath (concretely, in
    the `src/test/resources` folder). This annotation also specified the initial package
    to search the glue code (i.e., the steps definition).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定了Gherkin场景的位置。在这种情况下，特性位于项目类路径中的文件夹`io/github/bonigarcia`（具体而言，在`src/test/resources`文件夹中）。此注解还指定了要搜索glue
    code（即步骤定义）的初始包。
- en: Example 9-16\. Cucumber test using JUnit 5
  id: totrans-303
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 9-16\. 使用JUnit 5进行Cucumber测试
- en: '[PRE18]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[![1](assets/1.png)](#co_third_party_integrations_CO17-1)'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_third_party_integrations_CO17-1)'
- en: We need to use the JUnit 5 suite module to run Cucumber tests.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用JUnit 5套件模块来运行Cucumber测试。
- en: '[![2](assets/2.png)](#co_third_party_integrations_CO17-2)'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_third_party_integrations_CO17-2)'
- en: We include the Cucumber engine in the JUnit Platform.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在JUnit平台中包含了Cucumber引擎。
- en: '[![3](assets/3.png)](#co_third_party_integrations_CO17-3)'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_third_party_integrations_CO17-3)'
- en: We specify the path for features within the project classpath.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定了项目类路径中特性文件的路径。
- en: '[![4](assets/4.png)](#co_third_party_integrations_CO17-4)'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_third_party_integrations_CO17-4)'
- en: We set the initial package to search the glue code.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将初始包设定为搜索粘合代码。
- en: Example 9-17\. Cucumber test using TestNG
  id: totrans-313
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例 9-17。使用 TestNG 进行 Cucumber 测试
- en: '[PRE19]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[![1](assets/1.png)](#co_third_party_integrations_CO18-1)'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_third_party_integrations_CO18-1)'
- en: We specify the location of the Gherkin scenarios and the package to search the
    glue code.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定 Gherkin 场景的位置和搜索粘合代码的包的位置。
- en: '[![2](assets/2.png)](#co_third_party_integrations_CO18-2)'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_third_party_integrations_CO18-2)'
- en: We extend a TestNG parent test class for Cucumber tests.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们扩展 TestNG 父类以运行 Cucumber 测试。
- en: Web Frameworks
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web 框架
- en: Web frameworks are software frameworks designed to support the development of
    web applications and services. One of the most popular frameworks for the Java
    language is the [Spring Framework](https://spring.io). Spring is an open source
    framework for building Java applications, including enterprise web applications
    and services. The core technology of Spring is known as *Inversion of Control*
    (IoC), which is a procedure to create instances outside the class in which these
    objects are used. These objects, called *beans* or *components* in the Spring
    jargon, are later injected on demand as dependencies by the Spring IoC container.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: Web 框架是旨在支持 Web 应用程序和服务开发的软件框架。Java 语言中最流行的框架之一是 [Spring Framework](https://spring.io)。Spring
    是一个用于构建 Java 应用程序（包括企业 Web 应用程序和服务）的开源框架。Spring 的核心技术被称为*控制反转*（IoC），它是一种在使用这些对象的类之外创建实例的过程。Spring
    术语中称这些对象为*bean*或*component*，它们稍后按需作为依赖项由 Spring IoC 容器注入。
- en: The following examples show basic tests that verify a local web application
    created with [Spring-Boot](https://spring.io/projects/spring-boot), a subproject
    of the Spring portfolio that simplifies the development of Spring-based applications
    thanks to convention over configuration and autodiscovery features. In addition,
    Spring-Boot provides an embedded web server to ease the development of web applications.
    The integration with Selenium WebDriver in this kind of project facilitates the
    testing process of Spring-based web applications by deploying automatically in
    the embedded web server per test case.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了用 [Spring-Boot](https://spring.io/projects/spring-boot) 创建的本地 Web 应用程序的基本测试，Spring-Boot
    是 Spring 系列的一个子项目，通过惯例优于配置和自动发现功能简化了基于 Spring 的应用程序的开发。此外，Spring-Boot 提供了一个嵌入式
    Web 服务器，以便轻松开发 Web 应用程序。在这种项目中与 Selenium WebDriver 的集成有助于通过在每个测试案例中自动部署在嵌入式 Web
    服务器中来简化 Spring 基础 Web 应用程序的测试过程。
- en: The code to integrate Spring-Boot with Selenium WebDriver and the unit testing
    frameworks used in this book is different. [Example 9-18](#spring-junit4) shows
    a test integrating Spring-Boot and JUnit 4\. [Example 9-19](#spring-testng) shows
    the differences when using TestNG, [Example 9-20](#spring-junit5) illustrates
    how to use JUnit 5, and finally, [Example 9-21](#spring-sel-jup) shows a Spring
    test based on JUnit 5 with Selenium-Jupiter.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 用于集成 Spring-Boot 与 Selenium WebDriver 和本书中使用的单元测试框架的代码是不同的。[示例 9-18](#spring-junit4)
    显示了一个集成 Spring-Boot 和 JUnit 4 的测试。[示例 9-19](#spring-testng) 展示了使用 TestNG 时的差异，[示例
    9-20](#spring-junit5) 说明了如何使用 JUnit 5，最后，[示例 9-21](#spring-sel-jup) 展示了一个基于 JUnit
    5 和 Selenium-Jupiter 的 Spring 测试。
- en: Example 9-18\. Test using Spring-Boot and JUnit 4
  id: totrans-323
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例 9-18。使用 Spring-Boot 和 JUnit 4 进行测试
- en: '[PRE20]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[![1](assets/1.png)](#co_third_party_integrations_CO19-1)'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_third_party_integrations_CO19-1)'
- en: We use the Spring runner in JUnit 4.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 JUnit 4 中使用 Spring 运行器。
- en: '[![2](assets/2.png)](#co_third_party_integrations_CO19-2)'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_third_party_integrations_CO19-2)'
- en: We use a Spring-Boot annotation for tests to define the Spring-Boot class name.
    Also, we specify the web application is deployed using a random available port.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Spring-Boot 的测试注解来定义 Spring-Boot 类名。此外，我们指定 Web 应用程序使用随机可用端口部署。
- en: '[![3](assets/3.png)](#co_third_party_integrations_CO19-3)'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_third_party_integrations_CO19-3)'
- en: We inject the web application port as a class attribute.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 Web 应用程序端口注入为类属性。
- en: Example 9-19\. Test using Spring-Boot and TestNG
  id: totrans-331
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例 9-19。使用 Spring-Boot 和 TestNG 进行测试
- en: '[PRE21]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[![1](assets/1.png)](#co_third_party_integrations_CO20-1)'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_third_party_integrations_CO20-1)'
- en: We use the annotation `@SpringBootTest` in the same way in JUnit 4.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 JUnit 4 中也同样使用 `@SpringBootTest` 注解。
- en: '[![2](assets/2.png)](#co_third_party_integrations_CO20-2)'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_third_party_integrations_CO20-2)'
- en: We extend a TestNG parent to run this test using the Spring context.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们扩展 TestNG 父类以使用 Spring 上下文运行此测试。
- en: Example 9-20\. Test using Spring-Boot and JUnit 5
  id: totrans-337
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例 9-20。使用 Spring-Boot 和 JUnit 5 进行测试
- en: '[PRE22]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[![1](assets/1.png)](#co_third_party_integrations_CO21-1)'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_third_party_integrations_CO21-1)'
- en: We use the JUnit 5 Spring extension to integrate the Spring context in a Jupiter
    test.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 JUnit 5 的 Spring 扩展将 Spring 上下文集成到 Jupiter 测试中。
- en: '[![2](assets/2.png)](#co_third_party_integrations_CO21-2)'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_third_party_integrations_CO21-2)'
- en: We use Spring-Boot to start our Spring application context as in the previous
    examples.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Spring-Boot 来启动我们的 Spring 应用程序上下文，就像之前的例子中一样。
- en: Example 9-21\. Test using Spring-Boot and JUnit 5 plus Selenium-Jupiter
  id: totrans-343
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-21\. 使用 Spring-Boot 和 JUnit 5 加上 Selenium-Jupiter 进行测试
- en: '[PRE23]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[![1](assets/1.png)](#co_third_party_integrations_CO22-1)'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_third_party_integrations_CO22-1)'
- en: In the case of Selenium-Jupiter, we use two JUnit 5 extensions (for Spring and
    Selenium WebDriver).
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Selenium-Jupiter 的情况下，我们使用了两个 JUnit 5 扩展（用于 Spring 和 Selenium WebDriver）。
- en: '[![2](assets/2.png)](#co_third_party_integrations_CO22-2)'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_third_party_integrations_CO22-2)'
- en: As usual in Selenium-Jupiter, we use the JUnit 5 parameter resolution mechanism
    to declare the type of `WebDriver` instance we use in this test.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 如同在 Selenium-Jupiter 中一贯的做法，我们使用了 JUnit 5 的参数解析机制来声明在本测试中使用的 `WebDriver` 实例的类型。
- en: Summary and Outlook
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结与展望
- en: 'This chapter provided a practical overview for integrating different technologies
    (such as tools, libraries, and frameworks) in the development of end-to-end tests
    for web applications with Selenium WebDriver. First, we used Awaitility (a library
    to handle asynchronous operations) for waiting until files are downloaded with
    Selenium WebDriver. An alternative library to execute the same use case (i.e.,
    downloading files) is Apache HttpClient. Then, we used the BrowserMob proxy to
    intercept the HTTP traffic exchanged by a Selenium WebDriver test. The next group
    of technologies focused on enabling nonfunctional testing with Selenium WebDriver:
    BrowserMob (to create a JMeter test plan for performance testing), OWASP ZAP (for
    security testing), and Axe (for accessibility testing). Then, we used the fluent
    API provided by Selenide, Java Faker, to create fake test data for Selenium WebDriver
    tests, and Extent Reports and Allure to generate rich test reports. Finally, we
    discovered how to integrate Cucumber (a BDD framework) and Spring (a Java and
    web framework) with Selenium WebDriver.'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为使用 Selenium WebDriver 进行端到端测试的不同技术（如工具、库和框架）集成提供了实际概述。首先，我们使用 Awaitility（处理异步操作的库）等待
    Selenium WebDriver 下载文件。执行相同用例（即下载文件）的另一种库是 Apache HttpClient。然后，我们使用 BrowserMob
    代理拦截 Selenium WebDriver 测试交换的 HTTP 流量。接下来的技术组集中于使用 Selenium WebDriver 进行非功能测试：BrowserMob（为性能测试创建
    JMeter 测试计划）、OWASP ZAP（安全测试）和 Axe（可访问性测试）。然后，我们使用 Selenide 提供的流畅 API 和 Java Faker
    为 Selenium WebDriver 测试创建虚拟测试数据，并使用 Extent Reports 和 Allure 生成丰富的测试报告。最后，我们了解了如何将
    Cucumber（BDD 框架）和 Spring（Java 和 Web 框架）与 Selenium WebDriver 集成。
- en: 'The next chapter concludes this book by presenting complementary frameworks
    to Selenium WebDriver, namely REST Assured (for testing REST services) and Appium
    (for testing mobile applications). Finally, the chapter presents several popular
    alternatives to Selenium WebDriver in the browser automation space: Cypress, WebDriverIO,
    TestCafe, Puppeteer, and Playwright.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章通过介绍 Selenium WebDriver 的补充框架来总结本书，即用于测试 REST 服务的 REST Assured 和用于测试移动应用程序的
    Appium。最后，本章介绍了几个流行的 Selenium WebDriver 浏览器自动化空间的替代品：Cypress、WebDriverIO、TestCafe、Puppeteer
    和 Playwright。
