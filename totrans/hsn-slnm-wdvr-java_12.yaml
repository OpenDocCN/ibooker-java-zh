- en: Chapter 9\. Third-Party Integrations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduces different third-party technologies (such as libraries
    or frameworks) that we can use with Selenium WebDriver. We need to use these technologies
    when the Selenium WebDriver API is insufficient to carry out specific tasks. This
    is the case for file downloading, in which we need to use a third-party utility
    to wait until the files are correctly downloaded or, alternatively, use an HTTP
    client to control the download. We also capture the HTTP traffic using a third-party
    proxy.
  prefs: []
  type: TYPE_NORMAL
- en: Another scenario in which we need to use external utilities with Selenium WebDriver
    is when implementing nonfunctional tests, such as performance, security, accessibility,
    or A/B testing. We can also use third-party libraries to develop Selenium WebDriver
    tests using a fluent API, generate fake test data, or improve test reporting.
    Finally, we can integrate relevant frameworks such as Cucumber for Behavior Driven
    Development (BDD) or the Spring Framework (for developing web applications). We
    will go through all of these uses in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: To use the third-party utilities presented in this chapter, you must first include
    the required dependencies in your project. You can find the details for resolving
    each dependency using Maven and Gradle in [Appendix C](app03.html#appendix03).
  prefs: []
  type: TYPE_NORMAL
- en: File Download
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Selenium WebDriver has limited support for file downloading because its API
    does not expose download progress. In other words, we can use Selenium WebDriver
    to download files from web applications, but we cannot control the required time
    to copy these files into the local file system. For this reason, we can use third-party
    libraries to enhance the experience of web downloads with Selenium WebDriver.
    There are different alternatives to this aim. The following subsections explain
    how.
  prefs: []
  type: TYPE_NORMAL
- en: Using Browser-Specific Capabilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can use browser-specific capabilities (as we did in [Chapter 5](ch05.html#ch05))
    to configure several parameters for file downloading, such as the target folder.
    This approach is convenient since these features are available in the Selenium
    WebDriver API out of the box, but it also has several disadvantages. First, it
    is incompatible with different browser types (Chrome, Firefox, etc.). In other
    words, the required capabilities are distinct for individual browsers. Second,
    and more importantly, we do not have the control to track download progress. To
    solve this problem, we need to use a third-party library. In this book, I propose
    using the open source library [Awaitility](http://www.awaitility.org).
  prefs: []
  type: TYPE_NORMAL
- en: Awaitility is a popular library that provides features to handle asynchronous
    operations. This way, it provides a fluent API for managing threads, timeouts,
    and concurrency issues. In the case of downloading files with Selenium WebDriver,
    we use the Awaitility API to wait until the downloaded files are stored in the
    file system. [Example 9-1](#file-download-1) shows an example using Chrome and
    Awaitility. [Example 9-2](#file-download-2) shows the equivalent test setup when
    using Firefox.
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-1\. Test download files using Chrome and Awaitility
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_third_party_integrations_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We specify a folder to save the downloaded files. Nevertheless, you should be
    aware that Chrome allows only certain directories for download. For example, it
    allows the download directory (and subfolder) but forbids employing other paths,
    such as the desktop folder or the home directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_third_party_integrations_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We use a Chrome preference to specify the target folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_third_party_integrations_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We use a web page available on the practice site to download different files
    by clicking on buttons (see [Figure 9-1](#download-files)).
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_third_party_integrations_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We click on two of the buttons available on the page. As a result, the browser
    starts downloading two files: a PNG picture and a PDF document, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_third_party_integrations_CO1-5)'
  prefs: []
  type: TYPE_NORMAL
- en: We use Awaitility to configure a wait timeout of five seconds.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_third_party_integrations_CO1-6)'
  prefs: []
  type: TYPE_NORMAL
- en: We wait until the first file is in the file system.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_third_party_integrations_CO1-7)'
  prefs: []
  type: TYPE_NORMAL
- en: We also wait until the second file is downloaded.
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-2\. Test setup for downloading files using Firefox
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_third_party_integrations_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Firefox allows specifying any folder for downloading files. In this case, we
    use the local project folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_third_party_integrations_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We use a Firefox preference to specify a custom download directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_third_party_integrations_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We need to set to `2` the preference `browser.download.folderList` to select
    a custom download folder. The other possible values are `0` to download files
    into the user desktop and `1` to use the download folder (default value).
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_third_party_integrations_CO2-4)'
  prefs: []
  type: TYPE_NORMAL
- en: We specify the content types that Firefox will not ask to save in the local
    file system.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_third_party_integrations_CO2-5)'
  prefs: []
  type: TYPE_NORMAL
- en: We disable the previsualization of PDF files.
  prefs: []
  type: TYPE_NORMAL
- en: '![hosw 0901](assets/hosw_0901.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-1\. Practice web page for downloading file
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Using an HTTP Client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An alternative mechanism to download files with Selenium WebDriver is to use
    an HTTP client library. I propose using [Apache HttpClient](https://hc.apache.org/httpcomponents-client-5.1.x),
    since WebDriverManager internally uses this library, and therefore, you can use
    it as a transitive dependency in your project. [Example 9-3](#file-download-3)
    shows a complete test case that downloads several files with Apache HttpClient
    from the practice site. Notice that in this case, it is not necessary to explicitly
    wait until the file download finishes since Apache HttpClient handles the HTTP
    responses synchronously.
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-3\. Test download files using an HTTP client
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_third_party_integrations_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We use the practice web page again for downloading files.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_third_party_integrations_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We click on a button to download a file.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_third_party_integrations_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We refactor the common logic for downloading files in the class method `download`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_third_party_integrations_CO3-4)'
  prefs: []
  type: TYPE_NORMAL
- en: We repeat the operation for a second file to be downloaded.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_third_party_integrations_CO3-5)'
  prefs: []
  type: TYPE_NORMAL
- en: We create an Apache HTTPClient instance inside a try-with-resources. This client
    is automatically closed at the end of the statement scope.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_third_party_integrations_CO3-6)'
  prefs: []
  type: TYPE_NORMAL
- en: We use another try-with-resources statement to send an HTTP request to the provided
    URL and, as a result, get an HTTP response.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_third_party_integrations_CO3-7)'
  prefs: []
  type: TYPE_NORMAL
- en: We copy the resulting file in the local file system.
  prefs: []
  type: TYPE_NORMAL
- en: Capture Network Traffic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[“Network monitoring”](ch05.html#section-network-monitoring) and [“Network
    interceptor”](ch05.html#network-interceptor) explain how to use browser-specific
    capabilities to capture the HTTP traffic between Selenium WebDriver and the web
    application under test. The drawback of this mechanism is that it is only available
    in browsers that support CDP. Nevertheless, we can use a third-party proxy for
    other browsers. In this book, I propose you use [BrowserMob](https://bmp.lightbody.net)
    proxy for this purpose.'
  prefs: []
  type: TYPE_NORMAL
- en: BrowserMob is an open source proxy that allows manipulating HTTP traffic using
    a Java library. [Example 9-4](#capture-network-proxy) shows a complete test using
    this proxy in a Selenium WebDriver test. In this example, we use the BrowserMob
    proxy to intercept the HTTP traffic between the test and the target website, tracing
    this traffic (request-response) as logging traces.
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-4\. Test capturing network traffic through BrowserMob proxy
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_third_party_integrations_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We create an instance of a BrowserMob.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_third_party_integrations_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We start this proxy.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_third_party_integrations_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We capture the HTTP traffic using HAR (HTTP Archive), a JSON-based file format
    used to capture and export this traffic.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_third_party_integrations_CO4-4)'
  prefs: []
  type: TYPE_NORMAL
- en: We enable capturing the exchanged HTTP requests and responses.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_third_party_integrations_CO4-5)'
  prefs: []
  type: TYPE_NORMAL
- en: We transform the BrowserMob server into a Selenium WebDriver proxy.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_third_party_integrations_CO4-6)'
  prefs: []
  type: TYPE_NORMAL
- en: We set this proxy as a browser option (in this case, for Firefox).
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_third_party_integrations_CO4-7)'
  prefs: []
  type: TYPE_NORMAL
- en: We need to allow insecure certificates since the communication with the proxy
    is done using HTTP (and not HTTPS).
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_third_party_integrations_CO4-8)'
  prefs: []
  type: TYPE_NORMAL
- en: We stop the proxy after the test.
  prefs: []
  type: TYPE_NORMAL
- en: '[![9](assets/9.png)](#co_third_party_integrations_CO4-9)'
  prefs: []
  type: TYPE_NORMAL
- en: We use the proxy instance to gather the HTTP traffic (requests and responses).
    We use a logger to write this information in the standard output in this basic
    example.
  prefs: []
  type: TYPE_NORMAL
- en: Nonfunctional Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As explained in [Chapter 1](ch01.html#ch01), Selenium WebDriver is primarily
    used to assess the functional requirements of web applications. In other words,
    testers use the Selenium WebDriver API to verify that a web application under
    test behaves as expected. Nevertheless, we can leverage this API to test nonfunctional
    requirements, i.e., quality attributes such as performance, security, accessibility,
    etc. A common strategy to accomplish this goal is to integrate with specific third-party
    utilities. The following subsections explain different integrations with Selenium
    WebDriver for nonfunctional testing.
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Performance testing evaluates the responsiveness and stability of a SUT under
    a particular workload. Instead of Selenium WebDriver, testers usually adopt specific
    tools like [Apache JMeter](https://jmeter.apache.org) for performance testing.
    Apache JMeter is an open source tool that allows sending multiple HTTP requests
    to a given URL endpoint while measuring the response time and other metrics. Although
    the direct integration between Selenium WebDriver and Apache JMeter is not trivial,
    we can leverage an existing Selenium WebDriver test as a JMeter test plan (i.e.,
    the series of steps that JMeter executes). The benefit of this approach is that
    the resulting JMeter test plan will mimic the same user workflow used in the Selenium
    WebDriver test, reusing the same HTTP traffic the browser makes (e.g., for JavaScript
    libraries, CSS, etc.). To that aim, I propose the following procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the BrowserMob proxy (introduced in the previous section) to capture the
    exchanged network traffic in Selenium WebDriver as a HAR file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert the resulting HAR file to a JMeter test plan. Test plans in JMeter are
    stored as XML-based files with the extension JMX.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load the JMX test plan in JMeter and tune it for simulating concurrent users
    and including result listeners
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the test plan and evaluate the results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Example 9-5](#har-creation) shows a complete test case that implements the
    first step. As you can see, the required login to start and create the HAR file
    is done before and after each test. You can use this approach to leverage existing
    functional tests (i.e., the logic in the `@Test` methods) as performance tests
    (to be executed in JMeter).'
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-5\. Test creating a HAR file
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_third_party_integrations_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We start BrowserMob before the test and configure it in the `WebDriver` session.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_third_party_integrations_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We get the HAR file after the test and write it as a local file.
  prefs: []
  type: TYPE_NORMAL
- en: 'After running the previous test, we get a HAR file called `login.har`. Now,
    we need to convert it to a JMeter test plan. There are different alternatives
    to do that. You can find several programs (e.g., in Ruby or Java) that make this
    job freely available on the web. Also, you can use online converters services,
    such as the [BlazeMeter JMX Converter](https://converter.blazemeter.com). In this
    example, I use this online service and open the resulting JMX test plan in JMeter.
    At this point, you can tune the JMeter configuration at your convenience (you
    can find further information about JMeter in its official [user manual](https://jmeter.apache.org/usermanual/index.html)).
    For instance, [Figure 9-2](#jmeter-screenshots-1) shows the JMeter GUI after loading
    the resulting JMX test plan plus the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: Increase the number of concurrent users to one hundred (in the “Thread Group”
    tab)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Include some result listeners, such as “Aggregate Graph” and “Graph Results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![hosw 0902](assets/hosw_0902.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-2\. JMeter GUI loading the resulting test plan
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now, we can run the test plan with JMeter (for example, clicking on the button
    with a green triangle in the JMeter GUI). As a result, a load of one hundred concurrent
    users is generated following the interactions initially developed as a Selenium
    WebDriver test ([Example 9-5](#har-creation)). [Figure 9-3](#jmeter-screenshots-results)
    shows the results for the previously added listeners.
  prefs: []
  type: TYPE_NORMAL
- en: '![hosw 0903](assets/hosw_0903.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-3\. JMeter results
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Using browsers to generate the load
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using tools like JMeter is convenient for many performance testing scenarios
    for web applications. Nevertheless, this approach is unsuitable when you need
    actual browsers to recreate the complete user workflow (e.g., in videoconferencing
    web apps). In that case, a possible solution is to use WebDriverManager in conjunction
    with Docker. [Example 9-6](#load-wdm-docker) demonstrates this use. As you can
    see in this test, WebDriverManager allows creating a list of `WebDriver` instances
    simply by specifying the size as a parameter in the `create()` method. Then, for
    example, we can use standard Java to exercise the web application under test in
    parallel using a thread pool.
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-6\. Load test using WebDriverManager and Docker
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_third_party_integrations_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We create an instance of the Chrome manager, using Docker to execute the browsers
    as containers.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_third_party_integrations_CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We assume that Docker is installed in the machine running this test. Otherwise,
    the test is skipped.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_third_party_integrations_CO6-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We create a `WebDriver` list (containing five instances in this example).
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_third_party_integrations_CO6-4)'
  prefs: []
  type: TYPE_NORMAL
- en: We create a thread pool using the same size as the `WebDriver` list.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_third_party_integrations_CO6-5)'
  prefs: []
  type: TYPE_NORMAL
- en: We use the thread pool to execute in parallel the SUT assessment.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_third_party_integrations_CO6-6)'
  prefs: []
  type: TYPE_NORMAL
- en: We wait until each parallel evaluation finishes. We use a synchronization method
    based on a counter latch to do that.
  prefs: []
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A relevant organization in the software security domain is [OWASP](https://owasp.org)
    (Open Web Application Security Project), a nonprofit foundation that promotes
    open solutions to improve software security. One of the most popular OWASP projects
    is the Zed Attack Proxy (ZAP). [OWASP ZAP](https://www.zaproxy.org) is an open
    source web application security scanner used to implement *vulnerability assessment*
    (i.e., look for security issues) or *penetration testing* (i.e., a simulated cyberattack)
    to find exploitable web application vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: We can use OWASP ZAP as a standalone desktop application. [Figure 9-4](#zap-gui)
    shows a screenshot of its GUI.
  prefs: []
  type: TYPE_NORMAL
- en: '![hosw 0904](assets/hosw_0904.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-4\. OWASP ZAP GUI
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This GUI provides different features for automated scans to detect security
    threats that a web application might face, such as SQL injection, cross-site scripting
    (XSS), or cross-site request forgery (CSRF), to name a few.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the standalone application, we can integrate a Selenium WebDriver
    test with ZAP. [Example 9-7](#zap-proxy-test) provides a test case illustrating
    this integration. The steps required to execute this test properly are:'
  prefs: []
  type: TYPE_NORMAL
- en: Start OWAS ZAP in the localhost. By default, OWASP starts a proxy that listens
    to port 8080\. You can change this port using the OWASP GUI using the menu option
    Tools → Options → Local Proxies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Disable the API key (or copy its value in the Selenium WebDriver test). You
    can change this value in the menu option Tools → Options → API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a Selenium WebDriver test that uses OWASP ZAP as a proxy (like [Example 9-7](#zap-proxy-test)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the Selenium WebDriver test. At this point, you should see the generated
    vulnerability report in the ZAP GUI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Example 9-7\. Test using OWASP ZAP as security scanner
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_third_party_integrations_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We configure the address and port where the ZAP local proxy is listening.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_third_party_integrations_CO7-2)'
  prefs: []
  type: TYPE_NORMAL
- en: If the ZAP API key is not disabled, we need to set its value here.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_third_party_integrations_CO7-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We configure ZAP as a Selenium WebDriver proxy.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_third_party_integrations_CO7-4)'
  prefs: []
  type: TYPE_NORMAL
- en: We interact with ZAP using its API.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_third_party_integrations_CO7-5)'
  prefs: []
  type: TYPE_NORMAL
- en: After the test, we create an HTML report with vulnerabilities found during the
    execution of the Selenium WebDriver test. [Figure 9-5](#zap-report) shows a screenshot
    of this report.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We can also use OWASP ZAP as a standalone GUI, as introduced previously. The
    potential benefit of the integration with Selenium WebDriver could be reusing
    existing functional tests for assessing security or automated security assessment
    (e.g., a regression test suite executed by a CI server).
  prefs: []
  type: TYPE_NORMAL
- en: '![hosw 0905](assets/hosw_0905.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-5\. Report generated by ZAP after executing a Selenium WebDriver test
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Accessibility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Digital accessibility refers to the ability of users with disabilities to effectively
    use software systems such as websites, mobile apps, etc. An essential reference
    in this domain is the [Web Content Accessibility Guidelines](https://www.w3.org/WAI/standards-guidelines/wcag)
    (WCAG), which are a set of standard recommendations created by the W3C [Web Accessibility
    Initiative](https://www.w3.org/WAI) (WAI) that explain how to make web content
    more accessible to people with disabilities.
  prefs: []
  type: TYPE_NORMAL
- en: There are several methods to test the accessibility of web applications. The
    most common approach consists of checking the WCAG recommendations. To that aim,
    we can use automated accessibility scanners like [Axe](https://www.deque.com/axe),
    an open source engine for automated accessibility testing of web applications
    following WCAG rules. Axe provides seamless integration with the Java bindings
    of Selenium WebDriver using a [helper library](https://github.com/dequelabs/axe-core-maven-html).
    [Example 9-8](#axe-test) shows a test using this library.
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-8\. Test using Axe to generate an accessibility report
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_third_party_integrations_CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We analyze the current `WebDriver` session with Axe. This way, all pages loaded
    in the browser will be scanned by Axe.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_third_party_integrations_CO8-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We get a report of the accessibility violations found.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_third_party_integrations_CO8-3)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We log each violation in the standard output. In this example, the found issues
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: color-contrast
  prefs: []
  type: TYPE_NORMAL
- en: Elements must have sufficient color contrast.
  prefs: []
  type: TYPE_NORMAL
- en: heading-order
  prefs: []
  type: TYPE_NORMAL
- en: Heading levels should only increase by one.
  prefs: []
  type: TYPE_NORMAL
- en: image-alt
  prefs: []
  type: TYPE_NORMAL
- en: Images must have alternate text.
  prefs: []
  type: TYPE_NORMAL
- en: link-name
  prefs: []
  type: TYPE_NORMAL
- en: Links must have discernible text.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_third_party_integrations_CO8-4)'
  prefs: []
  type: TYPE_NORMAL
- en: We write the results as a local JSON file.
  prefs: []
  type: TYPE_NORMAL
- en: A/B Testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A/B testing is a form of usability evaluation that compares variations of the
    same application to discover which one is more effective to its end users. Different
    commercial products facilitate advanced features for A/B tests in Selenium WebDriver
    tests. For example, [Applitools Eyes](https://applitools.com/products-eyes) provides
    an automated visual comparison of multiple web page variations. Another option
    is [Optimizely](https://www.optimizely.com), a company that provides tools for
    customizing and experimenting with A/B testing.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to carry out A/B testing is to use the vanilla Selenium WebDriver
    API and custom conditions for the different variations of a web page. [Example 9-9](#basic-ab-testing)
    shows a basic test following a manual approach for a multivariant web page. Notice
    that this test shows a simple way to implement an A/B test based on assessing
    the different page variations.
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-9\. Basic A/B test using Selenium WebDriver
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_third_party_integrations_CO9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We open a multivariant practice web page. The content of this page is randomly
    loaded 50% of the time.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_third_party_integrations_CO9-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We check the page variations are as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Fluent API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As introduced in [Chapter 1](ch01.html#ch01), Selenium is the foundation technology
    for other frameworks and libraries. For instance, we can find several libraries
    wrapping Selenium WebDriver to expose a fluent API for creating end-to-end tests
    for web applications. An example of this kind of library is [Selenide](https://selenide.org),
    an open source (MIT license) library that defines a concise fluent API on top
    of Selenium WebDriver. Selenide provides several benefits, such as automated waiting
    for web elements or support for AJAX applications.
  prefs: []
  type: TYPE_NORMAL
- en: A relevant difference of a Selenide test compared to Selenium WebDriver is that
    Selenide handles the `WebDriver` objects internally. For that, it uses WebDriverManager
    to resolve the required driver (e.g., chromedriver, geckodriver, etc.), holding
    the `WebDriver` instance in a separate thread that is closed at the end of the
    test. As a result, the required test boilerplate related to the creation and termination
    of `WebDriver` objects is not required. [Example 9-10](#selenide-test) demonstrates
    this feature by showing a basic Selenide test.
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-10\. Test using Selenide
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_third_party_integrations_CO10-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We use the static method `open` provided by Selenide to navigate a given URL.
    By default, Selenide uses a local Chrome, although the browser can be changed
    using a configuration class (e.g., `Configuration.browser = "firefox";`) or using
    a Java system property (e.g., `-Dselenide.browser=firefox`).
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_third_party_integrations_CO10-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The Selenide method `$` allows you to locate web elements by CSS selector or
    using Selenium WebDriver `By` locators. This line of code uses the latter to type
    text into an input field.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_third_party_integrations_CO10-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We locate another web element, this time by CSS selector, and click on it.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_third_party_integrations_CO10-4)'
  prefs: []
  type: TYPE_NORMAL
- en: We verify that the web element for successful login is present on the page and
    contains the expected text.
  prefs: []
  type: TYPE_NORMAL
- en: Test Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A relevant part of any test case is the test data, i.e., the input data used
    to exercise the SUT. The selection of suitable test data is paramount for implementing
    effective tests. Differing techniques in classic testing theory for test data
    selection include:'
  prefs: []
  type: TYPE_NORMAL
- en: Equivalence partitioning
  prefs: []
  type: TYPE_NORMAL
- en: The process of testing by dividing all possible input test data into value sets
    that we assume to be processed in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: Boundary testing
  prefs: []
  type: TYPE_NORMAL
- en: The process of testing between extreme ends or between partitions of the input
    values. The basic idea of this approach is to select the representative limit
    values in an input domain (for example, below the minimum, minimum, just above
    the minimum, nominal, just below the maximum, maximum, and above the maximum value).
  prefs: []
  type: TYPE_NORMAL
- en: These approaches can be impractical in end-to-end testing since the required
    number of tests (and the resulting execution time) to carry out these strategies
    can be enormous. Alternatively, we typically select some representative test data
    manually to verify the *happy path* (i.e., *positive* testing), and optionally,
    some test data for unexpected conditions (*negative* testing).
  prefs: []
  type: TYPE_NORMAL
- en: Another alternative for selecting test data is using *fake* data, i.e., random
    data of different domains, such as personal names, surnames, addresses, countries,
    emails, phone numbers, etc. A simple alternative to this aim is using [Java Faker](https://dius.github.io/java-faker),
    a port of the popular [faker](https://github.com/faker-ruby/faker) Ruby gem. [Example 9-11](#javafaker-test)
    shows a test using this library. This test uses fake data to submit a web form
    available on the practice site. [Figure 9-6](#fake-data) shows this web page after
    submitting the form with that fake data.
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-11\. Test using Java Faker to generate different types of fake data
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_third_party_integrations_CO11-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We create an instance of Java Faker.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_third_party_integrations_CO11-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We send random data of different types (name, address, country, etc.).
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_third_party_integrations_CO11-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We verify that the data is submitted correctly.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_third_party_integrations_CO11-4)'
  prefs: []
  type: TYPE_NORMAL
- en: We check there are no errors on the page.
  prefs: []
  type: TYPE_NORMAL
- en: '![hosw 0906](assets/hosw_0906.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-6\. Practice page using fake data
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Reporting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A *test report* is a document that summarizes the results after executing a
    test suite. This document typically contains the number of tests executed plus
    their verdicts (pass, fail, skip) and execution time. There are different ways
    to obtain a test report in our Java project. For example, when using Maven, we
    can create a basic test report using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_third_party_integrations_CO12-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We execute the test with Maven. As a result, the Maven Surefire plug-in generated
    a set of XML files in the `target` folder. These files contain the results of
    the test execution.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_third_party_integrations_CO12-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We convert the XML reports into an HTML report. You can find this HTML report
    in your project folder `target/site`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_third_party_integrations_CO12-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We force a copy of the CSS and images required in the HTML report. [Figure 9-7](#surefire-report)
    shows a screenshot of this report.
  prefs: []
  type: TYPE_NORMAL
- en: '![hosw 0907](assets/hosw_0907.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-7\. Test report generated with Maven
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We can also generate an equivalent report using Gradle. After executing a test
    suite with this build tool, Gradle automatically generates an HTML report in the
    folder `build/reports`. [Figure 9-8](#gradle-report) shows an example of the test
    report generated for executing a group of tests (using the shell command `gradle
    test --tests Hello*`).
  prefs: []
  type: TYPE_NORMAL
- en: '![hosw 0908](assets/hosw_0908.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-8\. Test report generated with Gradle
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In addition to Maven and Gradle, we can use existing reporting libraries to
    create richer reports. A possible alternative is [Extent Reports](https://www.extentreports.com),
    a library to create interactive test reports. Extent Reports provides professional
    (commercial) and community (open source) editions. [Example 9-12](#extentreports-test)
    shows a test using the latter.
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-12\. Test using Extent Reports to generate an HTML report
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_third_party_integrations_CO13-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We create an instance of the test reporter.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_third_party_integrations_CO13-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We configure it to generate an HTML report.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_third_party_integrations_CO13-3)'
  prefs: []
  type: TYPE_NORMAL
- en: After each test, we create an entry in the test report using the test name as
    an identifier. In JUnit 5, we use `TestInfo`, a built-in parameter resolver that
    allows retrieving information about the current test.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_third_party_integrations_CO13-4)'
  prefs: []
  type: TYPE_NORMAL
- en: As usual, you can find the complete source code in the [examples repository](https://github.com/bonigarcia/selenium-webdriver-java).
    In particular, this class has two test methods. [Figure 9-9](#extent-report) shows
    the resulting test report generated when this test class is executed.
  prefs: []
  type: TYPE_NORMAL
- en: '![hosw 0909](assets/hosw_0909.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-9\. Test report generated with Extent Reports
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: An inconvenience of Extent Reports is that we need to add each test explicitly
    to the reporter. A possible solution to this problem is using custom test listeners
    (as explained in [“Test Listeners”](ch08.html#sect-test-listeners)) to group the
    common logic for reporting.
  prefs: []
  type: TYPE_NORMAL
- en: Another possible library for generating rich test reports is [Allure](http://allure.qatools.ru),
    an open source reporting framework for generating test reports for different programming
    languages, including Java, Python, and JavaScript, among others. A notable difference
    between Allure and Extent Reports is that Allure uses a test listener configured
    in the build tool Maven or Gradle (see [Appendix C](app03.html#appendix03) for
    further details about this configuration). This way, we did not need to change
    our test suite for generating Allure reports. [Table 9-1](#allure-commands) summarizes
    the necessary commands to create Allure reports with Maven and Gradle.
  prefs: []
  type: TYPE_NORMAL
- en: Table 9-1\. Maven and Gradle commands to generate test reports with Allure
  prefs: []
  type: TYPE_NORMAL
- en: '| Maven | Gradle | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '| Run test cases Create the reports on the target folder'
  prefs: []
  type: TYPE_NORMAL
- en: Open the HTML report using a local web server (as shown in [Figure 9-10](#allure-report))
    |
  prefs: []
  type: TYPE_NORMAL
- en: '![hosw 0910](assets/hosw_0910.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-10\. Test report generated with Allure and served locally
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Behavior Driven Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As introduced in [Chapter 1](ch01.html#ch01), Behavior Driven Development (BDD)
    is a software methodology that promotes the development and testing of software
    systems using high-level user scenarios. Different tools implement the BDD methodology.
    One of the most popular is [Cucumber](https://cucumber.io). Cucumber executes
    tests based on user stories written in *Gherkin*, a human-readable notation based
    on natural languages (e.g., English and others). Gherkin was designed to be used
    by nonprogrammers (e.g., customers or end users), and its main keywords are listed
    next (see the [Gherkin user manual](https://cucumber.io/docs/gherkin) for further
    information):'
  prefs: []
  type: TYPE_NORMAL
- en: Feature
  prefs: []
  type: TYPE_NORMAL
- en: High-level description of the software feature tested.
  prefs: []
  type: TYPE_NORMAL
- en: Scenario
  prefs: []
  type: TYPE_NORMAL
- en: 'Concrete test that illustrates a business rule. Scenarios describe different
    pieces of information (called *steps* in the Gherkin jargon), such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Given
  prefs: []
  type: TYPE_NORMAL
- en: Preconditions and initial state
  prefs: []
  type: TYPE_NORMAL
- en: When
  prefs: []
  type: TYPE_NORMAL
- en: User actions
  prefs: []
  type: TYPE_NORMAL
- en: And
  prefs: []
  type: TYPE_NORMAL
- en: Additional user actions
  prefs: []
  type: TYPE_NORMAL
- en: Then
  prefs: []
  type: TYPE_NORMAL
- en: Expected outcome
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 9-13](#gherkin-scenario) shows a Gherkin feature containing two scenarios
    for a test login (successful and failed).'
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-13\. Gherkin scenarios for login into the practice site
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_third_party_integrations_CO14-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Feature description
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_third_party_integrations_CO14-2)'
  prefs: []
  type: TYPE_NORMAL
- en: First scenario (login successful)
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_third_party_integrations_CO14-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Browser to be used
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_third_party_integrations_CO14-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Web page URL
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_third_party_integrations_CO14-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Set of actions (type credentials and click the Submit button)
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_third_party_integrations_CO14-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Expected message
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_third_party_integrations_CO14-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Second scenario (login failed)
  prefs: []
  type: TYPE_NORMAL
- en: To run Gherkin scenarios as test cases, we must first create the corresponding
    *step definitions*. A step definition is a *glue code* that exercises the SUT
    using the information specified in the scenario. In Java, we use annotations (such
    as `@Given`, `@Then`, `@When`, or `@And`) to decorate methods implementing each
    step. These annotations contain a string value to map each step definition and
    the parameters. [Example 9-14](#cucumber-steps) shows a step definition for the
    Gherkin scenario defined on [Example 9-13](#gherkin-scenario). We use the Selenium
    WebDriver API to implement the required actions for navigation, web element interaction,
    etc.
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-14\. Steps to log in to the practice site with Cucumber
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_third_party_integrations_CO15-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We use the first step to create a `WebDriver` instance.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_third_party_integrations_CO15-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We open the URL.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_third_party_integrations_CO15-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We type the credentials.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_third_party_integrations_CO15-4)'
  prefs: []
  type: TYPE_NORMAL
- en: We click on the Submit button.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_third_party_integrations_CO15-5)'
  prefs: []
  type: TYPE_NORMAL
- en: We verify that the expected message is on the page.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to run our step definition as a test case. As usual, we create
    that test using a unit testing framework. This test is unit testing framework-dependent
    in the integration with Cucumber. In other words, the required code is different
    in JUnit 4 (see [Example 9-15](#cucumber-junit4)), JUnit 5 (see [Example 9-16](#cucumber-junit5)),
    and TestNG (see [Example 9-17](#cucumber-testng)). The resulting tests are executed
    in the usual way (i.e., using the shell or an IDE).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Selenium-Jupiter does not provide any additional features for integrating with
    Cucumber, so the default JUnit 5 procedure is the same in the Selenium-Jupiter
    project in the examples repository.
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-15\. Cucumber test using JUnit 4
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_third_party_integrations_CO16-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We use the Cucumber runner to execute the step definitions as test cases.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_third_party_integrations_CO16-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We specify the location of the Gherkin scenarios. In this case, the feature
    is the folder `io/github/bonigarcia` in the project classpath (concretely, in
    the `src/test/resources` folder). This annotation also specified the initial package
    to search the glue code (i.e., the steps definition).
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-16\. Cucumber test using JUnit 5
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_third_party_integrations_CO17-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We need to use the JUnit 5 suite module to run Cucumber tests.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_third_party_integrations_CO17-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We include the Cucumber engine in the JUnit Platform.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_third_party_integrations_CO17-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We specify the path for features within the project classpath.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_third_party_integrations_CO17-4)'
  prefs: []
  type: TYPE_NORMAL
- en: We set the initial package to search the glue code.
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-17\. Cucumber test using TestNG
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_third_party_integrations_CO18-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We specify the location of the Gherkin scenarios and the package to search the
    glue code.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_third_party_integrations_CO18-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We extend a TestNG parent test class for Cucumber tests.
  prefs: []
  type: TYPE_NORMAL
- en: Web Frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web frameworks are software frameworks designed to support the development of
    web applications and services. One of the most popular frameworks for the Java
    language is the [Spring Framework](https://spring.io). Spring is an open source
    framework for building Java applications, including enterprise web applications
    and services. The core technology of Spring is known as *Inversion of Control*
    (IoC), which is a procedure to create instances outside the class in which these
    objects are used. These objects, called *beans* or *components* in the Spring
    jargon, are later injected on demand as dependencies by the Spring IoC container.
  prefs: []
  type: TYPE_NORMAL
- en: The following examples show basic tests that verify a local web application
    created with [Spring-Boot](https://spring.io/projects/spring-boot), a subproject
    of the Spring portfolio that simplifies the development of Spring-based applications
    thanks to convention over configuration and autodiscovery features. In addition,
    Spring-Boot provides an embedded web server to ease the development of web applications.
    The integration with Selenium WebDriver in this kind of project facilitates the
    testing process of Spring-based web applications by deploying automatically in
    the embedded web server per test case.
  prefs: []
  type: TYPE_NORMAL
- en: The code to integrate Spring-Boot with Selenium WebDriver and the unit testing
    frameworks used in this book is different. [Example 9-18](#spring-junit4) shows
    a test integrating Spring-Boot and JUnit 4\. [Example 9-19](#spring-testng) shows
    the differences when using TestNG, [Example 9-20](#spring-junit5) illustrates
    how to use JUnit 5, and finally, [Example 9-21](#spring-sel-jup) shows a Spring
    test based on JUnit 5 with Selenium-Jupiter.
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-18\. Test using Spring-Boot and JUnit 4
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_third_party_integrations_CO19-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We use the Spring runner in JUnit 4.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_third_party_integrations_CO19-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We use a Spring-Boot annotation for tests to define the Spring-Boot class name.
    Also, we specify the web application is deployed using a random available port.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_third_party_integrations_CO19-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We inject the web application port as a class attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-19\. Test using Spring-Boot and TestNG
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_third_party_integrations_CO20-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We use the annotation `@SpringBootTest` in the same way in JUnit 4.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_third_party_integrations_CO20-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We extend a TestNG parent to run this test using the Spring context.
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-20\. Test using Spring-Boot and JUnit 5
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_third_party_integrations_CO21-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We use the JUnit 5 Spring extension to integrate the Spring context in a Jupiter
    test.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_third_party_integrations_CO21-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We use Spring-Boot to start our Spring application context as in the previous
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-21\. Test using Spring-Boot and JUnit 5 plus Selenium-Jupiter
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_third_party_integrations_CO22-1)'
  prefs: []
  type: TYPE_NORMAL
- en: In the case of Selenium-Jupiter, we use two JUnit 5 extensions (for Spring and
    Selenium WebDriver).
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_third_party_integrations_CO22-2)'
  prefs: []
  type: TYPE_NORMAL
- en: As usual in Selenium-Jupiter, we use the JUnit 5 parameter resolution mechanism
    to declare the type of `WebDriver` instance we use in this test.
  prefs: []
  type: TYPE_NORMAL
- en: Summary and Outlook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter provided a practical overview for integrating different technologies
    (such as tools, libraries, and frameworks) in the development of end-to-end tests
    for web applications with Selenium WebDriver. First, we used Awaitility (a library
    to handle asynchronous operations) for waiting until files are downloaded with
    Selenium WebDriver. An alternative library to execute the same use case (i.e.,
    downloading files) is Apache HttpClient. Then, we used the BrowserMob proxy to
    intercept the HTTP traffic exchanged by a Selenium WebDriver test. The next group
    of technologies focused on enabling nonfunctional testing with Selenium WebDriver:
    BrowserMob (to create a JMeter test plan for performance testing), OWASP ZAP (for
    security testing), and Axe (for accessibility testing). Then, we used the fluent
    API provided by Selenide, Java Faker, to create fake test data for Selenium WebDriver
    tests, and Extent Reports and Allure to generate rich test reports. Finally, we
    discovered how to integrate Cucumber (a BDD framework) and Spring (a Java and
    web framework) with Selenium WebDriver.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next chapter concludes this book by presenting complementary frameworks
    to Selenium WebDriver, namely REST Assured (for testing REST services) and Appium
    (for testing mobile applications). Finally, the chapter presents several popular
    alternatives to Selenium WebDriver in the browser automation space: Cypress, WebDriverIO,
    TestCafe, Puppeteer, and Playwright.'
  prefs: []
  type: TYPE_NORMAL
