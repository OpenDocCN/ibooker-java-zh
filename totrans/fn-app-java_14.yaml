- en: Chapter 12\. Recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recursion is an approach to solving a problem that can be broken down into smaller
    versions of itself. Many developers see *recursion* as another — often complicated — approach
    to iteration-based problem-solving. Still, it’s good to know different techniques
    for particular groups of problems in a functional way.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter shows the general idea behind recursion, how you implement recursive
    methods, and their place in your Java code compared to other forms of iteration.
  prefs: []
  type: TYPE_NORMAL
- en: What is Recursion?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [“Recursion”](ch01.xhtml#_01-an-introduction_recursion), you’ve seen an illustration
    of calculating factorials — the product of all positive integers less than or
    equal to the input parameter. Many books, guides, and tutorials use factorials
    to demonstrate recursion because it’s a perfect problem to solve partially, and
    it’ll be the first example of this chapter, too.
  prefs: []
  type: TYPE_NORMAL
- en: Every step of calculating factorials breaks down into the product of the input
    parameter and the result of the next factorial operation. When the calculation
    reaches `fac(1)` — defined as “1" — the chain terminates and provides the value
    to the previous step. The complete steps can be seen in [Equation 12-1](#_02-recursion_factorial_steps).
  prefs: []
  type: TYPE_NORMAL
- en: Equation 12-1\. Formal representation of a factorial calculation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: <math alttext="StartLayout 1st Row 1st Column Blank 2nd Column f a c left-parenthesis
    n right-parenthesis 2nd Row 1st Column right-arrow 2nd Column n asterisk f a c
    left-parenthesis n minus 1 right-parenthesis 3rd Row 1st Column right-arrow 2nd
    Column n asterisk left-parenthesis n minus 1 right-parenthesis asterisk f a c
    left-parenthesis n minus 2 right-parenthesis 4th Row 1st Column right-arrow 2nd
    Column 4 asterisk left-parenthesis n minus 1 right-parenthesis asterisk left-parenthesis
    n minus 2 right-parenthesis asterisk ellipsis asterisk f a c left-parenthesis
    1 right-parenthesis 5th Row 1st Column right-arrow 2nd Column 4 asterisk left-parenthesis
    n minus 1 right-parenthesis asterisk left-parenthesis n minus 2 right-parenthesis
    asterisk ellipsis asterisk 1 EndLayout" display="block"><mtable displaystyle="true"><mtr><mtd
    columnalign="left"><mrow><mi>f</mi> <mi>a</mi> <mi>c</mi> <mo>(</mo> <mi>n</mi>
    <mo>)</mo></mrow></mtd></mtr> <mtr><mtd columnalign="right"><mo>→</mo></mtd> <mtd
    columnalign="left"><mrow><mi>n</mi> <mo>*</mo> <mi>f</mi> <mi>a</mi> <mi>c</mi>
    <mo>(</mo> <mi>n</mi> <mo>-</mo> <mn>1</mn> <mo>)</mo></mrow></mtd></mtr> <mtr><mtd
    columnalign="right"><mo>→</mo></mtd> <mtd columnalign="left"><mrow><mi>n</mi>
    <mo>*</mo> <mo>(</mo> <mi>n</mi> <mo>-</mo> <mn>1</mn> <mo>)</mo> <mo>*</mo> <mi>f</mi>
    <mi>a</mi> <mi>c</mi> <mo>(</mo> <mi>n</mi> <mo>-</mo> <mn>2</mn> <mo>)</mo></mrow></mtd></mtr>
    <mtr><mtd columnalign="right"><mo>→</mo></mtd> <mtd columnalign="left"><mrow><mn>4</mn>
    <mo>*</mo> <mo>(</mo> <mi>n</mi> <mo>-</mo> <mn>1</mn> <mo>)</mo> <mo>*</mo> <mo>(</mo>
    <mi>n</mi> <mo>-</mo> <mn>2</mn> <mo>)</mo> <mo>*</mo> <mo>⋯</mo> <mo>*</mo> <mi>f</mi>
    <mi>a</mi> <mi>c</mi> <mo>(</mo> <mn>1</mn> <mo>)</mo></mrow></mtd></mtr> <mtr><mtd
    columnalign="right"><mo>→</mo></mtd> <mtd columnalign="left"><mrow><mn>4</mn>
    <mo>*</mo> <mo>(</mo> <mi>n</mi> <mo>-</mo> <mn>1</mn> <mo>)</mo> <mo>*</mo> <mo>(</mo>
    <mi>n</mi> <mo>-</mo> <mn>2</mn> <mo>)</mo> <mo>*</mo> <mo>⋯</mo> <mo>*</mo> <mn>1</mn></mrow></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'This generalization of the calculation steps visualizes the underlying concept
    of recursion: solving a problem by combining smaller instances of the same problem.
    This is done using methods that call themselves with modified arguments until
    a base condition is reached.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Recursion consists of two distinct operation types:'
  prefs: []
  type: TYPE_NORMAL
- en: Base conditions
  prefs: []
  type: TYPE_NORMAL
- en: A base condition is a predefined case — a *solution* to the problem — which
    will return an actual value and unwind the recursive call chain. It provides its
    value to the previous step, which can now calculate a result and return it to
    its predecessor, and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: Recursive call
  prefs: []
  type: TYPE_NORMAL
- en: Until the call chain reaches its *base condition*, every step will create another
    one by calling itself with modified input parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 12-1](#_02-recursion_smalller_problems) shows the general flow of a
    recursive call chain.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Solving problems with smaller problems](assets/afaj_1201.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-1\. Solving problems with smaller problems
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The problem becomes smaller until a solution is found for the smallest part.
    This solution will then become an input for the next bigger problem, and so on
    until the sum of all parts builds the solution to the original problem.
  prefs: []
  type: TYPE_NORMAL
- en: Head Versus Tail Recursion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Recursive calls fall into two categories, *head* and *tail* recursion, depending
    on the location of the recursive call in the method body:'
  prefs: []
  type: TYPE_NORMAL
- en: Head recursion
  prefs: []
  type: TYPE_NORMAL
- en: Other statements/expressions are executed/evaluated after the recursive method
    call, making it not the last statement.
  prefs: []
  type: TYPE_NORMAL
- en: Tail recursion
  prefs: []
  type: TYPE_NORMAL
- en: The recursive call is the last statement of the method without any further calculations
    linking its result to the current call.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at calculating a factorial with both types to illustrate their differences
    better. [Example 12-1](#_02-recursion_factorial_head) shows how to use head recursion.
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-1\. Calculating factorials with head recursion
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_recursion_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The method signature only contains the input parameter of the current recursive
    step. No intermediate state moves between the recursive calls.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_recursion_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The base condition must come before the recursive call.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_recursion_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The return value is an expression depending on the result of the recursive call,
    making it not the sole last statement in the method.
  prefs: []
  type: TYPE_NORMAL
- en: Now it’s time to look at tail recursion, as shown in [Example 12-2](#_02-recursion_factorial_tail).
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-2\. Calculating factorials with tail recursion
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_recursion_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The method signature contains an accumulator.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_recursion_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The base condition hasn’t changed compared to head recursion.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_recursion_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of returning an expression dependent on the next recursive call, both
    `factorialTail` parameters are evaluated beforehand. The method only returns the
    recursive call itself.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_recursion_CO2-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The accumulator requires an initial value. It reflects the base condition.
  prefs: []
  type: TYPE_NORMAL
- en: The main difference between head and tail recursion is how the call stack is
    constructed.
  prefs: []
  type: TYPE_NORMAL
- en: With *head recursion*, the recursive call is performed before returning a value.
    Therefore, the final result won’t be available until the runtime has returned
    from each recursive call.
  prefs: []
  type: TYPE_NORMAL
- en: With *tail recursion*, the broken-down problem is solved first before the result
    is passed on to the next recursive call. Essentially, the return value of any
    given recursive step is the same as the result of the next recursive call. This
    allows for optimizing the call stack if the runtime supports it, as you will see
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Recursion and the Call Stack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you look at [Figure 12-1](#_02-recursion_smalller_problems) again, you can
    think of every box as a separate method call and, therefore, a new stack frame
    on the call stack. That is a necessity because every box must be isolated from
    previous calculations so that their arguments won’t affect each other. The total
    recursive call count is only constrained by how long it takes to reach a base
    condition. The problem is, though, that the available stack size is finite. Too
    many calls will fill up the available stack space and eventually throw a `StackOverflowError`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A stack frame contains the state of a single method invocation. Each time your
    code calls a method, the JVM creates and pushes a new frame on the thread’s stack.
    After returning from a method, its stack frame gets popped and discarded.
  prefs: []
  type: TYPE_NORMAL
- en: The actual maximum stack depth depends on the available stack size^([1](ch12.xhtml#idm45115220279984)),
    and what’s stored in the individual frames.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent the stack from overflowing, many modern compilers use *tail-call
    optimization/elimination* to remove no longer required frames in recursive call
    chains. If no additional calculations take place after a recursive call, the stack
    frame is no longer needed and can be removed. That reduces the stack frame space
    complexity of the recursive call from `O(N)` to `O(1)`, resulting in faster and
    more memory-friendly machine code without an overflowing stack.
  prefs: []
  type: TYPE_NORMAL
- en: Sadly, the Java compiler and runtime lack that particular ability yet, as of
    early 2023.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, recursion is still a valuable tool for a subset of particular
    problems, even without optimization of the call stack.
  prefs: []
  type: TYPE_NORMAL
- en: A More Complex Example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As good as calculating a factorial is for explaining recursion, it isn’t a
    typical “real-world” problem. That’s why it’s time to look at a more realistic
    example: traversing a tree-like data structure, as seen in [Figure 12-2](#_02-recursion_tree).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tree-like data structure traversal](assets/afaj_1202.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-2\. Tree-like data structure traversal
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The data structure has a single root node, and every node has an optional left
    and right child node. Their numbers are for identification, not the order of any
    traversal.
  prefs: []
  type: TYPE_NORMAL
- en: The nodes are represented by a generic Record `Node<T>`, as shown in [Example 12-3](#_02-recursion_tree-node).
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-3\. Tree node structure
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The goal is to traverse the tree “in order.” That means every node’s left child
    node is traversed first until no other left node is found. Then it will continue
    traversing down its right child’s left nodes before going up again.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will implement the tree-traversal with an iterative approach and then
    compare it to a recursive one.
  prefs: []
  type: TYPE_NORMAL
- en: Iterative Tree-Traversal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the help of a `while` loop, traversing the tree is as you would expect.
    It requires temporary variables and coordination boilerplate for traversal, as
    seen in [Example 12-4](#_02-recursion_tree-iterative).
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-4\. Iterative tree traversal
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_recursion_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Auxiliary variables are required to save the current state of the iteration.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_recursion_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Iterate until no node is present, or `nodeStack` isn’t empty.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_recursion_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: A `java.util.Stack` saves all nodes until the bottom is reached.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_recursion_CO3-4)'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the loop can’t go deeper because it encountered `current == null`,
    so it sets `current` to the last node saved in `tmpNodes`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_recursion_CO3-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Output the node value.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_recursion_CO3-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Rinse and repeat with the right child node.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is as expected: *748251396*.'
  prefs: []
  type: TYPE_NORMAL
- en: Although it works as intended, the code isn’t very concise and requires mutable
    auxiliary variables to work properly.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at the recursive approach to see if it’s an improvement over
    iteration.
  prefs: []
  type: TYPE_NORMAL
- en: Recursive Tree-Traversal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create a recursive solution to traverse the tree, you must first clearly
    define the different steps needed, including the base condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Traversing the tree requires two recursive calls, an action, and a base condition:'
  prefs: []
  type: TYPE_NORMAL
- en: Traverse the left node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traverse the right node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Print a node’s value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stop if no further nodes are found
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Java implementation of these different steps in their correct order is shown
    in [Example 12-5](#_02-recursion_tree-iterative-simple).
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-5\. Recursive tree traversal
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_recursion_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The base condition to stop the traversal if no nodes remain.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_recursion_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: First, recursively traverse the left child node. This will call `traverse` again
    as long as a left node exists.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_recursion_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Second, because no more left child nodes exist, the current value needs to be
    printed.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_recursion_CO4-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Third, traverse the possible right child node with the same logic as before.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is the same as before: *748251396*.'
  prefs: []
  type: TYPE_NORMAL
- en: The code no longer requires an external iterator or auxiliary variables to hold
    the state, and the actual processing logic is reduced to a minimum. The traversal
    is no longer in the imperative mindset of *what to do*. Instead, it reflects the
    functional approach of *how to achieve* a goal in a more declarative way.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s make the tree traversal even more functional by moving the traversal process
    into the type itself and accepting a `Consumer<Node<T>>` for its action, as shown
    in [Example 12-6](#_02-recursion_tree-node-recursive).
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-6\. Extend `Node<T>` with traversal method
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_recursion_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The previous `traverse` method can easily be refactored into a `private static`
    method on the original type.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_recursion_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The new `traverse` method accepts a `Consumer<Node<T>>` to support any kind
    of action.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_recursion_CO5-3)'
  prefs: []
  type: TYPE_NORMAL
- en: A `public` method for traversal simplifies the call be omitting `this` as its
    first argument.
  prefs: []
  type: TYPE_NORMAL
- en: Traversing the type became even easier. The type itself is now responsible for
    the best way to traverse itself and provides a flexible solution for anyone using
    it.
  prefs: []
  type: TYPE_NORMAL
- en: It’s concise, functional, and easier to understand compared to the iterative
    approach. Still, there are advantages to using a loop. The biggest one is the
    performance discrepancy, trading the needed stack space for available heap space.
    Instead of creating a new stack frame for every recursive traversal operation,
    the nodes accumulate on the heap in `tmpNodes`. That makes the code more robust
    for larger graphs that might otherwise lead to a stack overflow.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, there’s no easy answer to which approach is best. It always
    depends highly on the kind of data structure and how much data you need to process.
    Even then, your personal preference and familiarity with a particular approach
    might be more important than the “best” solution to a problem to write straightforward
    and bug-free processing code.
  prefs: []
  type: TYPE_NORMAL
- en: Recursion-like Streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java’s runtime might not support tail-call optimization, however, you can still
    implement a recursive-like experience with lambda expressions and Streams that
    don’t suffer from overflowing stack issues.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to the lazy nature of Streams, you can build a pipeline that runs infinitely
    until the recursive problem is solved. But instead of calling a lambda expression
    recursively, it returns a new expression instead. This way, the stack depth will
    remain constant, regardless of the number of performed recursive steps.
  prefs: []
  type: TYPE_NORMAL
- en: This approach is quite convoluted compared to recursion or even using loops.
    It’s not commonly used, but it illustrates how to combine various new functional
    components of Java to solve recursive problems. Take a look at the book’s [code
    repository](https://github.com/benweidig/a-functional-approach-to-java) if you’d
    like to learn more.
  prefs: []
  type: TYPE_NORMAL
- en: Final Thoughts on Recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recursion is an often overlooked technique because it’s so easy to get it wrong.
    For example, a faulty base condition may be impossible to fulfill, which inevitably
    leads to a stack overflow. The recursive flow, in general, is harder to follow
    and more difficult to understand if you’re not used to it. Because Java does not
    have *tail-call optimization*, you will have to factor in the unavoidable overhead,
    which results in slower execution times than iterative structures, in addition
    to the possibility of a `StackOverflowError` if your call stack is too deep.
  prefs: []
  type: TYPE_NORMAL
- en: You should always consider the additional overhead and stack-overflow problems
    when choosing between recursion and its alternatives. If you’re running in a JVM
    with ample available memory and a big enough stack size, even bigger recursive
    call chains won’t be an issue. But if your problem size is unknown or not fixed,
    an alternative approach might be more sensible to prevent a `StackOverflowError`
    in the long run.
  prefs: []
  type: TYPE_NORMAL
- en: Some scenarios are better suited for a recursive approach, even in Java with
    its lack of tail-call optimization. Recursion will feel like a more natural way
    to solve particular problems with self-referencing data structures like linked
    lists or trees. Traversing tree-like structures can also be done iteratively but
    will most likely result in more complex code that’s harder to reason with.
  prefs: []
  type: TYPE_NORMAL
- en: But remember, choosing the best solution for a problem solely from a technical
    viewpoint might undermine the readability and reasonability of your code, which
    will affect long-time maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 12-1](#_02-recursion_vs-iteration) gives you an overview of the differences
    between recursion and iteration, so you can use them to choose more effectively.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 12-1\. Recursion versus iteration
  prefs: []
  type: TYPE_NORMAL
- en: '|  | Recursion | Iteration |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Approach | Self-calling function | Loop construct |'
  prefs: []
  type: TYPE_TB
- en: '| State | Stored on Stack | Stored in control variables (e.g., a loop index)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Progression | Towards base condition | Towards control value condition |'
  prefs: []
  type: TYPE_TB
- en: '| Termination | Base condition reached | Control variable condition reached
    |'
  prefs: []
  type: TYPE_TB
- en: '| Verbosity | Lower verbosity Minimal boilerplate and coordination code required
    | Higher verbosity Explicit coordination of control variables and state. |'
  prefs: []
  type: TYPE_TB
- en: '| If not terminated | `StackOverflowError` | Endless loop |'
  prefs: []
  type: TYPE_TB
- en: '| Overhead | Higher overhead of repeated method calls. | Lower overhead with
    constant stack depth. |'
  prefs: []
  type: TYPE_TB
- en: '| Performance | Lower performance due to overhead and missing tail-call optimization.
    | Better performance thanks to constant call stack depth. |'
  prefs: []
  type: TYPE_TB
- en: '| Memory Usage | Each call requires stack space. | No additional memory besides
    control variables. |'
  prefs: []
  type: TYPE_TB
- en: '| Execution speed | Slower | Faster |'
  prefs: []
  type: TYPE_TB
- en: Which to choose — recursion or iteration — depends highly on the problem you
    want to solve and in which environment your code runs. Recursion is often the
    preferred tool for solving more abstract problems, and iteration is a better match
    for more low-level code. Iteration might provide better runtime performance, but
    recursion can improve your productivity as a programmer.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t forget that you can always start with a familiar iterative approach and
    convert it to use recursion later.
  prefs: []
  type: TYPE_NORMAL
- en: Takeaways
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recursion is the functional alternative to “traditional” iteration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recursion is best used for partially solvable problems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java lacks tail-call-optimization, which can lead to `StackOverflowExceptions`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t force recursion for functional’s sake. You can always start with an iterative
    approach and convert it to a recursive approach later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ^([1](ch12.xhtml#idm45115220279984-marker)) The default stack size of most JVM
    implementations is one megabyte. You can set a bigger stack size with the flag
    `-Xss`. See the [Oracle Java Tools Documentation](https://docs.oracle.com/en/java/javase/11/tools/java.xhtml#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE__GUID-72BC3B70-49FF-4588-979F-7F8A32FEE6DA)
    for more information.
  prefs: []
  type: TYPE_NORMAL
