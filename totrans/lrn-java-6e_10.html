<html><head></head><body><section data-pdf-bookmark="Chapter 10. File Input and Output" data-type="chapter" epub:type="chapter"><div class="chapter" id="learnjava6-CHP-10">&#13;
<h1><span class="label">Chapter 10. </span>File Input and Output</h1>&#13;
&#13;
&#13;
<p>The ability to store data in files and retrieve it later is crucial to desktop and enterprise applications. <a data-primary="java.nio package" data-type="indexterm" id="id1905"/>In this chapter, we’ll look at some of the most popular classes in the <code>java.io</code> and <code>java.nio</code> packages. These packages offer a rich set of tools for basic input and output (I/O) and also provide the framework on which all file and network communication in Java is built. <a data-type="xref" href="#learnjava6-CHP-10-FIG-io-classes">Figure 10-1</a> shows the breadth of the <code>java.io</code> package.</p>&#13;
&#13;
<p>We’ll start by looking at the <a data-primary="input/output (I/O)" data-type="indexterm" id="ix_io_ch10"/><a data-primary="java.io package" data-type="indexterm" id="ix_java_io_pkg"/>stream classes in <code>java.io</code>, which are subclasses of the basic <code>InputStream</code>, <code>OutputStream</code>, <code>Reader</code>, and <code>Writer</code> classes. Then we’ll <a data-primary="File class" data-type="indexterm" id="id1906"/><a data-primary="java.io package" data-secondary="File class" data-type="indexterm" id="id1907"/>examine the <code>File</code> class and discuss how you can read and write files using classes in <code>java.io</code>. We also take a quick look at data compression and serialization. Along the way, we introduce the <code>java.nio</code> package. The “new” I/O package (or NIO) adds significant functionality tailored for building high-performance services. NIO centers on working with <em>buffers</em> (where you store stuff to make more efficient use of other resources) and <em>channels</em> (where you can efficiently put stuff that can be just as efficiently picked up by others). In some cases, NIO also provides better APIs that can be used in place of some <code>java.io</code> <span class="keep-together">features</span>.<sup><a data-type="noteref" href="ch10.html#id1908" id="id1908-marker">1</a></sup></p>&#13;
&#13;
<figure><div class="figure" id="learnjava6-CHP-10-FIG-io-classes">&#13;
<img alt="ljv6 1001" src="assets/ljv6_1001.png"/>&#13;
<h6><span class="label">Figure 10-1. </span>The <code>java.io</code> class hierarchy</h6>&#13;
</div></figure>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Streams" data-type="sect1"><div class="sect1" id="learnjava6-CHP-10-SECT-1">&#13;
<h1>Streams</h1>&#13;
&#13;
<p>Most I/O in <a data-primary="streams (java.io)" data-type="indexterm" id="ix_streams_ch10"/>Java is based on streams. Conceptually, a <em>stream</em> represents a flow of data with a <em>writer</em> at one end and a <em>reader</em> at the other. <a data-primary="channels" data-type="indexterm" id="id1909"/>When you are working with the <code>java.io</code> package to perform terminal input and output, reading or writing files, or communicating through network sockets in Java (more on networking in <a data-type="xref" href="ch13.html#learnjava6-CHP-13">Chapter 13</a>), you are using various types of streams. When we look at the NIO package, we’ll find a similar concept called a <em>channel</em>. The main difference between the two is that streams are oriented around bytes or characters, while channels are oriented around “buffers” containing those data types. <a data-primary="buffers" data-type="indexterm" id="id1910"/>A <em>buffer</em> is typically a fast, temporary storage for data that makes it easier to optimize throughput. They both perform roughly the same job. Let’s start with streams. Here’s a quick overview of the most popular stream classes:</p>&#13;
<dl>&#13;
<dt><code>InputStream</code>, <code>OutputStream</code></dt>&#13;
<dd>&#13;
<p>Abstract <a data-primary="OutputStream class" data-type="indexterm" id="id1911"/><a data-primary="InputStream class" data-type="indexterm" id="id1912"/><a data-primary="classes" data-secondary="abstract classes" data-type="indexterm" id="id1913"/><a data-primary="abstract classes" data-secondary="streams" data-type="indexterm" id="id1914"/>classes that define the basic functionality for reading or writing an unstructured sequence of bytes. All other byte streams in Java are built on top of the basic <code>InputStream</code> and <code>OutputStream</code>.</p>&#13;
</dd>&#13;
<dt><code>Reader</code>, <code>Writer</code></dt>&#13;
<dd>&#13;
<p>Abstract <a data-primary="Reader class" data-type="indexterm" id="id1915"/><a data-primary="Writer class" data-type="indexterm" id="id1916"/>classes that define the basic functionality for reading or writing a sequence of character data, with support for Unicode. All other character streams in Java are built on top of <code>Reader</code> and <code>Writer</code>.</p>&#13;
</dd>&#13;
<dt><code>InputStreamReader</code>, <code>OutputStreamWriter</code></dt>&#13;
<dd>&#13;
<p>Classes that <a data-primary="InputStreamReader class" data-type="indexterm" id="id1917"/><a data-primary="OutputStreamWriter class" data-type="indexterm" id="id1918"/>bridge byte and character streams by converting according to a specific character-encoding scheme such as ASCII or Unicode. (Remember: in Unicode, a character is not necessarily one byte!)</p>&#13;
</dd>&#13;
<dt><code>DataInputStream</code>, <code>DataOutputStream</code></dt>&#13;
<dd>&#13;
<p>Specialized <a data-primary="DataInputStream class" data-type="indexterm" id="id1919"/><a data-primary="DataOutputStream class" data-type="indexterm" id="id1920"/>stream filters that add the ability to read and write multibyte data types, such as numeric primitives and <code>String</code> objects in a standardized format.</p>&#13;
</dd>&#13;
<dt><code>ObjectInputStream</code>, <code>ObjectOutputStream</code></dt>&#13;
<dd>&#13;
<p>Specialized <a data-primary="ObjectInputStream class" data-type="indexterm" id="id1921"/><a data-primary="ObjectOutputStream class" data-type="indexterm" id="id1922"/>stream filters that are capable of writing whole groups of serialized Java objects and reconstructing them.</p>&#13;
</dd>&#13;
<dt><code>BufferedInputStream</code>, <code>BufferedOutputStream</code>, <code>BufferedReader</code>, <code>BufferedWriter</code></dt>&#13;
<dd>&#13;
<p>Specialized <a data-primary="BufferedInputStream class" data-type="indexterm" id="id1923"/><a data-primary="BufferedOutputStream class" data-type="indexterm" id="id1924"/><a data-primary="BufferedReader class" data-type="indexterm" id="id1925"/><a data-primary="BufferedWriter class" data-type="indexterm" id="id1926"/>stream filters that add buffering for additional efficiency. For real-world I/O, a buffer is almost always used.</p>&#13;
</dd>&#13;
<dt><code>PrintStream</code>, <code>PrintWriter</code></dt>&#13;
<dd>&#13;
<p>Specialized <a data-primary="PrintWriter class" data-type="indexterm" id="id1927"/><a data-primary="PrintStream class" data-type="indexterm" id="id1928"/>streams that simplify printing text.</p>&#13;
</dd>&#13;
<dt><code>PipedInputStream</code>, <code>PipedOutputStream</code>, <code>PipedReader</code>, <code>PipedWriter</code></dt>&#13;
<dd>&#13;
<p>Paired <a data-primary="PipedInputStream class" data-type="indexterm" id="id1929"/><a data-primary="PipedOutputStream class" data-type="indexterm" id="id1930"/><a data-primary="PipedReader class" data-type="indexterm" id="id1931"/><a data-primary="PipedWriter class" data-type="indexterm" id="id1932"/>classes that move data within an application. Data written into a <code>PipedOutputStream</code> or <code>PipedWriter</code> is read from its corresponding <code>PipedInputStream</code> or <code>PipedReader</code>.</p>&#13;
</dd>&#13;
<dt><code>FileInputStream</code>, <code>FileOutputStream</code>, <code>FileReader</code>, <code>FileWriter</code></dt>&#13;
<dd>&#13;
<p>Implementations of <code>InputStream</code>, <code>OutputStream</code>, <code>Reader</code>, and <code>Writer</code> that <a data-primary="FileInputStream class" data-type="indexterm" id="id1933"/><a data-primary="FileOutputStream class" data-type="indexterm" id="id1934"/><a data-primary="FileReader class" data-type="indexterm" id="id1935"/><a data-primary="FileWriter class" data-type="indexterm" id="id1936"/>read from and write to files on the local filesystem.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Streams in Java are one-way streets. The <code>java.io</code> input and output classes represent only the ends of a simple stream. For bidirectional conversations, you’ll use one of each type of stream.</p>&#13;
&#13;
<p><code>InputStream</code> and <code>OutputStream</code>, as shown in <a data-type="xref" href="#learnjava6-CHP-10-FIG-1">Figure 10-2</a>, are abstract classes that define the lowest-level interface for all byte streams. <a data-primary="classes" data-secondary="abstract classes" data-type="indexterm" id="id1937"/><a data-primary="abstract classes" data-secondary="streams" data-type="indexterm" id="id1938"/>They contain methods for reading or writing an unstructured flow of byte-level data. Because these classes are abstract, you can’t create a generic input or output stream.</p>&#13;
&#13;
<figure><div class="figure" id="learnjava6-CHP-10-FIG-1">&#13;
<img alt="ljv6 1002" src="assets/ljv6_1002.png"/>&#13;
<h6><span class="label">Figure 10-2. </span>Basic input and output stream functionality</h6>&#13;
</div></figure>&#13;
&#13;
<p>Java implements subclasses of these for activities such as reading from and writing to files or communicating with network connections. Because all byte streams inherit the structure of <code>InputStream</code> or <code>OutputStream</code>, the various kinds of byte streams can be used interchangeably. A method specifying an <code>InputStream</code> as an argument can accept any subclass of <code>InputStream</code>. Specialized types of streams can also be layered or wrapped around basic streams to add features such as buffering, filtering, compression, or handling higher-level data types.</p>&#13;
&#13;
<p><code>Reader</code> and <code>Writer</code> are very much like <code>InputStream</code> and <code>OutputStream</code>, except that they deal with characters instead of bytes. As true character streams, these classes correctly handle Unicode characters, which is not always the case with byte streams. Often, a bridge is needed between these character streams and the byte streams of physical devices, such as disks and networks. <code>InputStreamReader</code> and <code>OutputStreamWriter</code> are special classes that use a character-encoding scheme like ASCII or UTF-8 to translate between character and byte streams.</p>&#13;
&#13;
<p>This section describes several stream types, with the exception of <code>FileInputStream</code>, <code>FileOutputStream</code>, <code>FileReader</code>, and <code>FileWriter</code>. We postpone the discussion of file streams until the next section, where we cover accessing the filesystem in Java.<a data-primary="" data-startref="ix_java_io_pkg" data-type="indexterm" id="id1939"/></p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Basic I/O" data-type="sect2"><div class="sect2" id="learnjava6-CHP-10-SECT-1.1">&#13;
<h2>Basic I/O</h2>&#13;
&#13;
<p>The prototypical <a data-primary="InputStream class" data-type="indexterm" id="id1940"/><a data-primary="java.lang package" data-secondary="System class" data-type="indexterm" id="id1941"/><a data-primary="System class" data-type="indexterm" id="id1942"/>example of an <code>InputStream</code> object is the <em>standard input</em> of a Java application. Like <code>stdin</code> in C or <code>cin</code> in C++, this is the source of input to a <span class="keep-together">command-line</span> (non-GUI) program. It is an input stream from the environment—usually a terminal window or possibly the output of another command. The <code>java.lang.System</code> class, a general repository for system-related resources, provides a reference to the standard input stream in the static variable <code>System.in</code>. It also <a data-primary="System.err variable" data-type="indexterm" id="id1943"/><a data-primary="System.in variable" data-type="indexterm" id="id1944"/><a data-primary="System.out variable" data-type="indexterm" id="id1945"/>provides a <em>standard output stream</em> and a <em>standard error stream</em> in the <code>out</code> and <code>err</code> variables, respectively.<sup><a data-type="noteref" href="ch10.html#id1946" id="id1946-marker">2</a></sup> The following example shows the correspondence:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">InputStream</code><code class="w"> </code><code class="n">stdin</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">System</code><code class="p">.</code><code class="na">in</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">OutputStream</code><code class="w"> </code><code class="n">stdout</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">OutputStream</code><code class="w"> </code><code class="n">stderr</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">System</code><code class="p">.</code><code class="na">err</code><code class="p">;</code><code class="w"/></pre>&#13;
&#13;
<p>This snippet hides the fact that <code>System.out</code> and <code>System.err</code> aren’t just <code>OutputStream</code> objects but more specialized and useful <code>PrintStream</code> objects. We’ll explain these later in <a data-type="xref" href="#learnjava6-CHP-10-SECT-1.3.3">“PrintWriter and PrintStream”</a>, but for now we can reference <code>out</code> and <code>err</code> as <code>OutputStream</code> objects because they are derived from <code>OutputStream</code>.</p>&#13;
&#13;
<p>You can read a <a data-primary="abstract methods" data-type="indexterm" id="id1947"/><a data-primary="read() method" data-secondary="InputStream" data-type="indexterm" id="ix_read_input_str"/>single byte at a time from standard input with the <code>InputStream</code>’s <code>read()</code> method. If you look closely at the <a href="https://oreil.ly/GSEj0">online documentation</a>, you’ll see that the <code>read()</code> method of the base <code>InputStream</code> class is an abstract method. What lies behind <code>System.in</code> is a particular implementation of <code>InputStream</code> that provides the real implementation of the <code>read()</code> method:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="k">try</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="kt">int</code><code class="w"> </code><code class="n">val</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">System</code><code class="p">.</code><code class="na">in</code><code class="p">.</code><code class="na">read</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"> </code><code class="k">catch</code><code class="w"> </code><code class="p">(</code><code class="n">IOException</code><code class="w"> </code><code class="n">e</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="c1">// ...</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>Although we said that the <code>read()</code> method reads a byte value, the return type in the example is <code>int</code>, not <code>byte</code>. That’s because the <code>read()</code> method of basic input streams in Java uses a convention carried over from the C language to indicate the end of a stream with a special value. Byte values are returned in the range 0 to 255, and the special value of <code>-1</code> is used to indicate that the end of the stream has been reached. You test for this condition when using the simple <code>read()</code> method. You can then cast the value to a byte, if needed. The following example reads each byte from an input stream and prints its value:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="k">try</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="kt">int</code><code class="w"> </code><code class="n">val</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">      </code><code class="k">while</code><code class="p">((</code><code class="n">val</code><code class="o">=</code><code class="n">System</code><code class="p">.</code><code class="na">in</code><code class="p">.</code><code class="na">read</code><code class="p">())</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="o">-</code><code class="mi">1</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">        </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">((</code><code class="kt">byte</code><code class="p">)</code><code class="n">val</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"> </code><code class="k">catch</code><code class="w"> </code><code class="p">(</code><code class="n">IOException</code><code class="w"> </code><code class="n">e</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="c1">// Oops. Handle the error or print an error message</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>As we’ve shown in the <a data-primary="EOFException" data-type="indexterm" id="id1948"/><a data-primary="IOException" data-type="indexterm" id="id1949"/>examples, the <code>read()</code> method can also throw an <code>IOException</code> if there is an error reading from the underlying stream source. Various subclasses of <code>IOException</code> may indicate that a source (such as a file or network connection) has had an error. Additionally, higher-level streams that read data types more complex than a single byte may throw <code>EOFException</code> (“end of file”), which indicates an unexpected or premature end of a stream.</p>&#13;
&#13;
<p>An <a data-primary="bytes available for reading" data-type="indexterm" id="id1950"/>overloaded form of <code>read()</code> fills a byte array with as much data as possible up to the capacity of the array and returns the number of bytes read:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="kt">byte</code><code class="w"> </code><code class="o">[]</code><code class="w"> </code><code class="n">buff</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="kt">byte</code><code class="w"> </code><code class="o">[</code><code class="mi">1024</code><code class="o">]</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="kt">int</code><code class="w"> </code><code class="n">got</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">System</code><code class="p">.</code><code class="na">in</code><code class="p">.</code><code class="na">read</code><code class="p">(</code><code class="n">buff</code><code class="p">);</code><code class="w"/></pre>&#13;
&#13;
<p>In theory, we can also check the number of bytes available for reading at a given time on an <code>InputStream</code> using the <code>available()</code> method. With that information, we could create an array of exactly the right size:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="kt">int</code><code class="w"> </code><code class="n">waiting</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">System</code><code class="p">.</code><code class="na">in</code><code class="p">.</code><code class="na">available</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">waiting</code><code class="w"> </code><code class="o">&gt;</code><code class="w"> </code><code class="mi">0</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="kt">byte</code><code class="w"> </code><code class="o">[]</code><code class="w"> </code><code class="n">data</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="kt">byte</code><code class="w"> </code><code class="o">[</code><code class="w"> </code><code class="n">waiting</code><code class="w"> </code><code class="o">]</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">System</code><code class="p">.</code><code class="na">in</code><code class="p">.</code><code class="na">read</code><code class="p">(</code><code class="n">data</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">      </code><code class="c1">// ...</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>However, the reliability of this technique depends on whether the underlying stream implementation can detect how much data it can retrieve. It generally works for files but should not be relied upon for all types of streams.</p>&#13;
&#13;
<p>These <code>read()</code> methods <a data-primary="blocking data during read" data-type="indexterm" id="id1951"/>block until at least some data is read (at least one byte). You must, in general, check the returned value to determine how much data you got and if you need to read more. (We look at nonblocking I/O later in this chapter.) The <code>skip()</code> method of <code>InputStream</code> provides a way of jumping over a number of bytes. Depending on the implementation of the stream, skipping bytes may be more efficient than reading them.<a data-primary="" data-startref="ix_read_input_str" data-type="indexterm" id="id1952"/></p>&#13;
&#13;
<p class="pagebreak-before">The <code>close()</code> method <a data-primary="close() method" data-secondary="InputStream" data-type="indexterm" id="id1953"/><a data-primary="InputStreamReader class" data-type="indexterm" id="id1954"/><a data-primary="java.io package" data-secondary="Closeable class" data-type="indexterm" id="id1955"/><a data-primary="try with resources" data-type="indexterm" id="id1956"/>shuts down the stream and frees up any associated system resources. It’s important for performance to remember to close most types of streams when you are finished using them. In some cases, streams may close automatically when objects are garbage-collected, but it is not a good idea to rely on this behavior. The <code>try</code><em>-with-resources</em> feature discussed in <a data-type="xref" href="ch06.html#learnjava6-CHP-6-SECT-1.9">“try with Resources”</a> makes automatically closing streams and other closeable entities easier. We’ll see some examples of that in <a data-type="xref" href="#learnjava6-CHP-10-SECT-1.5">“File Streams”</a>. The interface <code>java.io.Closeable</code> identifies all types of stream, channel, and related utility classes that can be closed.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Character Streams" data-type="sect2"><div class="sect2" id="learnjava6-CHP-10-SECT-1.2">&#13;
<h2>Character Streams</h2>&#13;
&#13;
<p>In early <a data-primary="streams (java.io)" data-secondary="character" data-type="indexterm" id="ix_str_char_enc"/><a data-primary="strings" data-secondary="reading and writing with java.io" data-type="indexterm" id="ix_string_read_write"/><a data-primary="character encoding" data-secondary="streams" data-type="indexterm" id="ix_char_enc_str"/><a data-primary="OutputStreamWriter class" data-type="indexterm" id="id1957"/>versions of Java, some <code>InputStream</code> and <code>OutputStream</code> types included methods for reading and writing strings, but most of them operated by naively assuming that a 16-bit Unicode character was equivalent to an 8-bit byte in the stream. This works for Latin-1 (ISO 8859-1) characters, but not for the world of other encodings used with different languages.</p>&#13;
&#13;
<p>The <code>java.io Reader</code> and <code>Writer</code> character <a data-primary="Reader class" data-type="indexterm" id="id1958"/><a data-primary="Writer class" data-type="indexterm" id="id1959"/>stream classes were introduced as streams that handle character data only. When you use these classes, you think only in terms of characters and string data. You allow the underlying implementation to handle the conversion of bytes to a specific character encoding. As you’ll see, there are some direct implementations of <code>Reader</code> and <code>Writer</code>, such as those for reading and writing files.</p>&#13;
&#13;
<p>More generally, two special classes, <code>InputStreamReader</code> and <code>OutputStreamWriter</code>, bridge the gap between character streams and byte streams. These are, respectively, a <code>Reader</code> and a <code>Writer</code> that can be wrapped around any underlying byte stream to make it a character stream. An encoding scheme converts between the bytes (which may come in groups representing multibyte characters) and Java’s two-byte characters. An encoding scheme can be specified by name in the constructor of <code>InputStreamReader</code> or <code>OutputStreamWriter</code>. For convenience, the default constructor uses the system’s default encoding scheme.</p>&#13;
&#13;
<p>Let’s see how to use <a data-primary="java.text package" data-type="indexterm" id="id1960"/><a data-primary="NumberFormat class" data-type="indexterm" id="id1961"/><a data-primary="System.in variable" data-type="indexterm" id="id1962"/>readers and the <code>java.text.NumberFormat</code> class to retrieve numeric input from the user at the command line. We’ll assume that the bytes coming from <code>System.in</code> use the system’s default encoding scheme:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="c1">// file: ch10/examples/ParseKeyboard.java</code><code class="w"/>&#13;
&#13;
<code class="w">    </code><code class="k">try</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">InputStream</code><code class="w"> </code><code class="n">in</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">System</code><code class="p">.</code><code class="na">in</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">InputStreamReader</code><code class="w"> </code><code class="n">charsIn</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">InputStreamReader</code><code class="p">(</code><code class="n">in</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">BufferedReader</code><code class="w"> </code><code class="n">bufferedCharsIn</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">BufferedReader</code><code class="p">(</code><code class="n">charsIn</code><code class="p">);</code><code class="w"/>&#13;
&#13;
<code class="w">      </code><code class="n">String</code><code class="w"> </code><code class="n">line</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">bufferedCharsIn</code><code class="p">.</code><code class="na">readLine</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">      </code><code class="kt">int</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">NumberFormat</code><code class="p">.</code><code class="na">getInstance</code><code class="p">().</code><code class="na">parse</code><code class="p">(</code><code class="n">line</code><code class="p">).</code><code class="na">intValue</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">      </code><code class="c1">// ...</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"> </code><code class="k">catch</code><code class="w"> </code><code class="p">(</code><code class="n">IOException</code><code class="w"> </code><code class="n">e</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="c1">// ...</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"> </code><code class="k">catch</code><code class="w"> </code><code class="p">(</code><code class="n">ParseException</code><code class="w"> </code><code class="n">pe</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="c1">// ...</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>First, we <a data-primary="BufferedReader class" data-type="indexterm" id="id1963"/>wrap an <code>InputStreamReader</code> around <code>System.in</code>. This reader converts the incoming bytes of <code>System.in</code> to characters using the default encoding scheme. Then, we wrap a <code>BufferedReader</code> around the <code>InputStreamReader</code>. <code>BufferedReader</code> adds the <code>readLine()</code> method, which we can use to grab a full line of text (up to a <span class="keep-together">platform-specific,</span> line-terminator character combination) into a <code>String</code>. The string is then parsed into an integer using the techniques described in <a data-type="xref" href="ch08.html#learnjava6-CHP-8">Chapter 8</a>. Try it yourself. When prompted, try providing different input. What happens if you enter a “0”? What if you only enter your first name?</p>&#13;
&#13;
<p>We have just taken a byte-oriented input stream, <code>System.in</code>, and safely converted it to a <code>Reader</code> for reading characters. If we wished to use an encoding other than the system default, we could have specified it in the <code>InputStreamReader</code>’s constructor, like so:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">InputStreamReader</code><code class="w"> </code><code class="n">reader</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">InputStreamReader</code><code class="p">(</code><code class="n">System</code><code class="p">.</code><code class="na">in</code><code class="p">,</code><code class="w"> </code><code class="s">"UTF-8"</code><code class="p">);</code><code class="w"/></pre>&#13;
&#13;
<p>For each character that is read from the reader, the <code>InputStreamReader</code> reads one or more bytes and performs the necessary conversion to Unicode.</p>&#13;
&#13;
<p>We’ll return to the <a data-primary="Charset codec" data-type="indexterm" id="id1964"/><a data-primary="java.nio.charset package" data-type="indexterm" id="id1965"/>topic of character encodings in <a data-type="xref" href="#learnjava6-CHP-10-SECT-2">“The New I/O File API”</a> when we discuss the <code>java.nio.charset</code> package, which allows you to find and use encoders and decoders. Both <code>InputStreamReader</code> and <code>OutputStreamWriter</code> can accept a <code>Charset</code> codec object as well as a character-encoding name.<a data-primary="" data-startref="ix_char_enc_str" data-type="indexterm" id="id1966"/><a data-primary="" data-startref="ix_str_char_enc" data-type="indexterm" id="id1967"/><a data-primary="" data-startref="ix_string_read_write" data-type="indexterm" id="id1968"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Stream Wrappers" data-type="sect2"><div class="sect2" id="learnjava6-CHP-10-SECT-1.3">&#13;
<h2>Stream Wrappers</h2>&#13;
&#13;
<p>What if you <a data-primary="wrappers" data-secondary="for streams" data-secondary-sortas="streams" data-type="indexterm" id="ix_wrap_str"/><a data-primary="streams (java.io)" data-secondary="stream wrappers" data-type="indexterm" id="ix_stream_str_wrap"/><a data-primary="BufferedInputStream class" data-type="indexterm" id="id1969"/>want to do more than read and write a sequence of bytes or characters? We can use a <em>filter stream</em>, which is a type of <code>InputStream</code>, <code>OutputStream</code>, <code>Reader</code>, or <code>Writer</code> that wraps another stream and adds new features. A filter stream takes the target stream as an argument in its constructor, does some additional processing of its own, and then delegates calls to the target. For example, we can construct a <code>BufferedInputStream</code> to wrap the system standard input:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">InputStream</code><code class="w"> </code><code class="n">bufferedIn</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">BufferedInputStream</code><code class="p">(</code><code class="n">System</code><code class="p">.</code><code class="na">in</code><code class="p">);</code><code class="w"/></pre>&#13;
&#13;
<p>The <code>BufferedInputStream</code> reads ahead and buffers a certain amount of data. It wraps an additional layer of functionality around the underlying stream. <a data-type="xref" href="#learnjava6-CHP-10-FIG-2">Figure 10-3</a> shows this arrangement for a <code>DataInputStream</code>, which can read higher-level data types, such as Java primitives and strings.</p>&#13;
&#13;
<figure><div class="figure" id="learnjava6-CHP-10-FIG-2">&#13;
<img alt="ljv6 1003" src="assets/ljv6_1003.png"/>&#13;
<h6><span class="label">Figure 10-3. </span>Layered streams</h6>&#13;
</div></figure>&#13;
&#13;
<p>As you can see from the previous code snippet, the <code>BufferedInputStream</code> filter is a type of <code>InputStream</code>. Because filter streams are themselves subclasses of the basic stream types, they can be used as arguments to the construction of other filter streams. This allows filter streams to be layered on top of one another to provide different combinations of features. For example, we could first wrap our <code>System.in</code> with a <code>BufferedInputStream</code> to benefit from buffering our input, and then wrap the <code>BufferedInputStream</code> with a <code>DataInputStream</code> for reading special data types with buffering.</p>&#13;
&#13;
<p>Java provides base <a data-primary="FilterInputStream class" data-type="indexterm" id="id1970"/><a data-primary="FilterOutputStream class" data-type="indexterm" id="id1971"/><a data-primary="FilterReader class" data-type="indexterm" id="id1972"/><a data-primary="FilterWriter class" data-type="indexterm" id="id1973"/>classes for creating new types of filter streams: <code>FilterInputStream</code>, <code>FilterOutputStream</code>, <code>FilterReader</code>, and <code>FilterWriter</code>. These superclasses provide the basic machinery for a filter by delegating all their method calls to their underlying stream. To create your own filter stream, you can extend these classes and override various methods to add the additional processing you need.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Data streams" data-type="sect3"><div class="sect3" id="learnjava6-CHP-10-SECT-1.3.1">&#13;
<h3>Data streams</h3>&#13;
&#13;
<p><code>DataInputStream</code> and <code>DataOutputStream</code> are <a data-primary="streams (java.io)" data-secondary="data streams" data-type="indexterm" id="id1974"/><a data-primary="data streams" data-type="indexterm" id="ix_data_str"/><a data-primary="DataInputStream class" data-type="indexterm" id="id1975"/><a data-primary="DataOutputStream class" data-type="indexterm" id="id1976"/>filter streams that let you read or write strings (as opposed to individual characters) and primitive data types composed of more than a single byte. <code>DataInputStream</code> and <code>DataOutputStream</code> implement the <code>DataInput</code> and <code>DataOutput</code> interfaces, respectively. These interfaces define methods for reading or writing strings and all of the Java primitive types, including numbers and Boolean values. <code>DataOutputStream</code> encodes these values in a way that can be read back correctly on any machine and then writes them to its underlying byte stream. <code>DataInputStream</code> picks up the encoded data from its underlying byte stream and decodes it into its original types and values.</p>&#13;
&#13;
<p>You can construct a <code>DataInputStream</code> from an <code>InputStream</code> and then use a method such as <code>readDouble()</code> to read a primitive data type:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">DataInputStream</code><code class="w"> </code><code class="n">dis</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">DataInputStream</code><code class="p">(</code><code class="n">System</code><code class="p">.</code><code class="na">in</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="kt">double</code><code class="w"> </code><code class="n">d</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">dis</code><code class="p">.</code><code class="na">readDouble</code><code class="p">();</code><code class="w"/></pre>&#13;
&#13;
<p>This <a data-primary="little-endian and big-endian approaches to byte order" data-type="indexterm" id="id1977"/><a data-primary="big-endian and little-endian approaches to byte order" data-type="indexterm" id="id1978"/><a data-primary="byte order" data-type="indexterm" id="id1979"/><a data-primary="network byte order" data-type="indexterm" id="id1980"/><a data-primary="readDouble() method, DataInputStream" data-type="indexterm" id="id1981"/>snippet wraps the standard input stream in a <code>DataInputStream</code> and uses it to read a <code>double</code> value. The <code>readDouble()</code> method reads bytes from the stream and constructs a <code>double</code> from them. The <code>DataInputStream</code> methods expect the bytes of numeric data types to be in <em>network byte order</em>, a standard that specifies that the high-order bytes of any multibyte values are sent first (also known as <em>big-endian</em>; see <a data-type="xref" href="#learnjava6-CHP-10-SECT-3.5.3">“Byte order”</a>).</p>&#13;
&#13;
<p>The <code>DataOutputStream</code> class provides write methods that correspond to the read methods in <code>DataInputStream</code>. The complement to our input snippet looks like this:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="kt">double</code><code class="w"> </code><code class="n">d</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mf">3.1415926</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">DataOutputStream</code><code class="w"> </code><code class="n">dos</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">DataOutputStream</code><code class="p">(</code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">dos</code><code class="p">.</code><code class="na">writeDouble</code><code class="p">(</code><code class="n">d</code><code class="p">);</code><code class="w"/></pre>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p><code>DataOutputStream</code> and <code>DataInputStream</code> work with binary data, not human-readable text. Typically, you would use a <code>DataInputStream</code> to read content that was produced by a <code>DataOutputStream</code>. These filter streams are perfect for working directly with things like image files.</p>&#13;
</div>&#13;
&#13;
<p>The <code>readUTF()</code> and <code>writeUTF()</code> methods of <code>DataInputStream</code> and <code>DataOutputStream</code> read and write a Java <code>String</code> of <a data-primary="readUTF() method, DataInputStream" data-type="indexterm" id="id1982"/><a data-primary="writeUTF() method, DataOutputStream" data-type="indexterm" id="id1983"/>Unicode characters using the UTF-8 character encoding. As discussed in <a data-type="xref" href="ch08.html#learnjava6-CHP-8">Chapter 8</a>, UTF-8 is an ASCII-compatible encoding of Unicode characters that is very widely used. Not all encodings are guaranteed to preserve all Unicode characters, but UTF-8 does. You can also use UTF-8 with <code>Reader</code> and <code>Writer</code> streams by specifying it as the encoding name.<a data-primary="" data-startref="ix_data_str" data-type="indexterm" id="id1984"/><a data-primary="" data-startref="ix_streams_data_str" data-type="indexterm" id="id1985"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Buffered streams" data-type="sect3"><div class="sect3" id="learnjava6-CHP-10-SECT-1.3.2">&#13;
<h3>Buffered streams</h3>&#13;
&#13;
<p>The <code>BufferedInputStream</code>, <code>BufferedOutputStream</code>, <code>BufferedReader</code>, and <code>BufferedWriter</code> classes add a <a data-primary="buffers" data-type="indexterm" id="id1986"/>data buffer of a specified size to the stream path. A buffer can increase efficiency by reducing the number of physical read or write operations that correspond to <code>read()</code> or <code>write()</code> method calls, as seen in <a data-type="xref" href="#learnjava6-CHP-10-FIG-buffered">Figure 10-4</a>.</p>&#13;
&#13;
<figure><div class="figure" id="learnjava6-CHP-10-FIG-buffered">&#13;
<img alt="ljv6 1004" src="assets/ljv6_1004.png"/>&#13;
<h6><span class="label">Figure 10-4. </span>Reading data with and without a buffer</h6>&#13;
</div></figure>&#13;
&#13;
<p>You create a <a data-primary="BufferedInputStream class" data-type="indexterm" id="id1987"/>buffered stream with an appropriate input or output stream and a buffer size. (You can also wrap another stream around a buffered stream so that it benefits from the buffering.) Here’s a simple buffered input stream:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">BufferedInputStream</code><code class="w"> </code><code class="n">bis</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">BufferedInputStream</code><code class="p">(</code><code class="n">myInputStream</code><code class="p">,</code><code class="w"> </code><code class="mi">32768</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">// bis will store up to 32K of data from myInputStream at a time</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">// we can then read from bis at any time</code><code class="w"/>&#13;
<code class="w">    </code><code class="kt">byte</code><code class="w"> </code><code class="n">b</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">bis</code><code class="p">.</code><code class="na">read</code><code class="p">();</code><code class="w"/></pre>&#13;
&#13;
<p>In this example, we <a data-primary="read() method" data-secondary="buffering" data-type="indexterm" id="id1988"/>specify a buffer size of 32 KB. If we leave off the size of the buffer in the constructor, Java creates a reasonably sized buffer for us. (Currently the default is 8 KB.) On our first call to <code>read()</code>, <code>bis</code> tries to fill our entire 32 KB buffer with data, if it’s available. Thereafter, calls to <code>read()</code> retrieve data from the buffer, which is refilled as necessary.</p>&#13;
&#13;
<p>A <code>BufferedOutputStream</code> works in a <a data-primary="BufferedOutputStream class" data-type="indexterm" id="id1989"/><a data-primary="write() method" data-secondary="buffering" data-type="indexterm" id="id1990"/>similar way. Calls to <code>write()</code> store the data in a buffer; data is actually written to the underlying stream only when the buffer fills up. You can also use the <code>flush()</code> method to write out the contents of a <code>BufferedOutputStream</code> at any time. The <code>flush()</code> method is actually a method of the <code>OutputStream</code> class itself. It allows you to be sure that all data in any underlying streams has been saved or sent.</p>&#13;
&#13;
<p>The <code>BufferedReader</code> and <code>BufferedWriter</code> classes work just like their byte-based counterparts, except that they operate on characters instead of bytes.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="PrintWriter and PrintStream" data-type="sect3"><div class="sect3" id="learnjava6-CHP-10-SECT-1.3.3">&#13;
<h3>PrintWriter and PrintStream</h3>&#13;
&#13;
<p>Another useful <a data-primary="streams (java.io)" data-secondary="PrintWriter and PrintStream" data-type="indexterm" id="id1991"/>wrapper is <code>java.io.PrintWriter</code>. This <a data-primary="print() method, streams" data-type="indexterm" id="id1992"/>class provides a suite of overloaded <code>print()</code> methods that turn their arguments into strings and push them out the stream. A <a data-primary="convenience methods" data-type="indexterm" id="id1993"/><a data-primary="printf() method" data-type="indexterm" id="id1994"/>complementary set of <code>println()</code> convenience methods appends a new line to the end of the strings. For formatted text output, <code>printf()</code> and the identical <code>format()</code> methods allow you to write C <code>printf</code>-style formatted text to the stream.</p>&#13;
&#13;
<p><code>PrintWriter</code> is an unusual <a data-primary="PrintWriter class" data-type="indexterm" id="id1995"/>character stream because it can wrap either an <code>OutputStream</code> or another <code>Writer</code>. <code>PrintWriter</code> is the more capable big brother of the legacy <code>PrintStream</code> byte stream. The <code>System.out</code> and <code>System.err</code> streams are <code>PrintStream</code> objects, which you have already seen throughout this book:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">print</code><code class="p">(</code><code class="s">"Hello, world...\n"</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="s">"Hello, world..."</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">printf</code><code class="p">(</code><code class="s">"The answer is %d\n"</code><code class="p">,</code><code class="w"> </code><code class="mi">17</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="mf">3.14</code><code class="p">);</code><code class="w"/></pre>&#13;
&#13;
<p>When you create a <code>PrintWriter</code> object, you can pass an additional Boolean value to the constructor, specifying whether it should “auto-flush.” If this value is <code>true</code>, the <code>PrintWriter</code> automatically performs a <code>flush()</code> on the underlying <code>OutputStream</code> or <code>Writer</code> each time it sends a newline:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="c1">// Stream automatically flushes after a newline.</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">PrintWriter</code><code class="w"> </code><code class="n">pw</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">PrintWriter</code><code class="p">(</code><code class="n">myOutputStream</code><code class="p">,</code><code class="w"> </code><code class="kc">true</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">pw</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="s">"Hello!"</code><code class="p">);</code><code class="w"/></pre>&#13;
&#13;
<p>When you use this technique with a buffered output stream, it acts like a terminal that outputs data line by line.</p>&#13;
&#13;
<p>The other <a data-primary="PrintStream class" data-type="indexterm" id="id1996"/>big advantage that <code>PrintStream</code> and <code>PrintWriter</code> have over regular character streams is that they shield you from exceptions thrown by the underlying streams. Unlike methods in other stream classes, the methods of <code>PrintWriter</code> and <code>PrintStream</code> do not throw <code>IOException</code>s. Instead, they provide a method to explicitly check for errors, if required. This makes the common operation of printing text a lot easier. You can check for errors with the <code>checkError()</code> method:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">reallyLongString</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">checkError</code><code class="p">())</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="c1">// uh oh</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>This feature of <code>PrintStream</code> and <code>PrintWriter</code> means you can generally output text to a variety of destinations without wrapping every print statement in a <code>try</code> block. But it still gives you access to any errors that occur if you are writing important information and want to guarantee that nothing went wrong.<a data-primary="" data-startref="ix_stream_str_wrap" data-type="indexterm" id="id1997"/><a data-primary="" data-startref="ix_wrap_str" data-type="indexterm" id="id1998"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The java.io.File Class" data-type="sect2"><div class="sect2" id="learnjava6-CHP-10-SECT-1.4">&#13;
<h2>The java.io.File Class</h2>&#13;
&#13;
<p>A popular <a data-primary="java.io package" data-secondary="File class" data-type="indexterm" id="ix_java_io_file_class"/><a data-primary="streams (java.io)" data-secondary="File class" data-type="indexterm" id="ix_stream_java_io_file_class"/><a data-primary="File class" data-type="indexterm" id="ix_file_class"/>destination for printed output is a file. The <code>java.io.File</code> class encapsulates access to information about a file or directory. You <a data-primary="attributes" data-secondary="getting information on file" data-type="indexterm" id="id1999"/>can use <code>File</code> to get attribute information about a file, list the entries in a directory, and perform basic filesystem operations, such as deleting a file or making a new directory. While the <code>File</code> object handles these “meta” operations, it doesn’t provide the API for reading and writing file data; you’ll need file streams for that.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="File constructors" data-type="sect3"><div class="sect3" id="learnjava6-CHP-10-SECT-1.4.1">&#13;
<h3>File constructors</h3>&#13;
&#13;
<p>You can <a data-primary="String class" data-secondary="and file constructing" data-secondary-sortas="file constructing" data-type="indexterm" id="id2000"/>create an instance of <code>File</code> from a <code>String</code> pathname:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">File</code><code class="w"> </code><code class="n">fooFile</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">File</code><code class="p">(</code><code class="s">"/tmp/foo.txt"</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">File</code><code class="w"> </code><code class="n">barDir</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">File</code><code class="p">(</code><code class="s">"/tmp/bar"</code><code class="p">);</code><code class="w"/></pre>&#13;
&#13;
<p>You can also create a file with a relative path that starts in the current working directory of the JVM:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">File</code><code class="w"> </code><code class="n">f</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">File</code><code class="p">(</code><code class="s">"foo"</code><code class="p">);</code><code class="w"/></pre>&#13;
&#13;
<p>You can determine the current working directory by reading the <code>user.dir</code> property in the <code>System</code> properties list:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">System</code><code class="p">.</code><code class="na">getProperty</code><code class="p">(</code><code class="s">"user.dir"</code><code class="p">);</code><code class="w"> </code><code class="c1">// e.g.,"/Users/pat"</code><code class="w"/></pre>&#13;
&#13;
<p>An overloaded version of the <code>File</code> constructor lets you specify the directory path and filename as separate <code>String</code> objects:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">File</code><code class="w"> </code><code class="n">fooFile</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">File</code><code class="p">(</code><code class="s">"/tmp"</code><code class="p">,</code><code class="w"> </code><code class="s">"foo.txt"</code><code class="p">);</code><code class="w"/></pre>&#13;
&#13;
<p>With yet another variation, you can specify the directory with a <code>File</code> object and the filename with a <code>String</code>:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">File</code><code class="w"> </code><code class="n">tmpDir</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">File</code><code class="p">(</code><code class="s">"/tmp"</code><code class="p">);</code><code class="w"> </code><code class="c1">// File for directory /tmp</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">File</code><code class="w"> </code><code class="n">fooFile</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">File</code><code class="w"> </code><code class="p">(</code><code class="n">tmpDir</code><code class="p">,</code><code class="w"> </code><code class="s">"foo.txt"</code><code class="p">);</code><code class="w"/></pre>&#13;
&#13;
<p>None of these <code>File</code> constructors actually creates a file or directory, and it is not an error to create a <code>File</code> object for a nonexistent file. The <code>File</code> object is just a handle for a file or directory whose properties you may wish to read, write, or test. For example, you can use the <code>exists()</code> instance method to learn whether the file or directory exists. Many applications perform this test prior to saving to a file, for example. If the chosen file doesn’t exist, hooray! The application can safely save its data. If the file does already exist, you often get an overwrite warning to make sure you want to replace the old file.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Path localization" data-type="sect3"><div class="sect3" id="learnjava6-CHP-10-SECT-1.4.2">&#13;
<h3>Path localization</h3>&#13;
&#13;
<p>In Java, pathnames are expected to follow the conventions of the local filesystem. The <a data-primary="path localization" data-type="indexterm" id="ix_path_local"/><a data-primary="localization, path" data-type="indexterm" id="ix_local_path"/><a data-primary="variables" data-secondary="separators for pathnames" data-type="indexterm" id="id2001"/><a data-primary="pathnames, separator variable for" data-type="indexterm" id="id2002"/><a data-primary="separator variables, for pathnames" data-type="indexterm" id="id2003"/><a data-primary="Windows" data-type="indexterm" id="id2004"/>Windows filesystem uses distinct <em>roots</em> (top-level directories) with drive letters (for example, “C:”) and a backslash (\) <a data-primary="\ (backslash), preceding escape sequences" data-type="indexterm" id="id2005"/><a data-primary="backslash (\), preceding escape sequences" data-type="indexterm" id="id2006"/><a data-primary="Linux" data-type="indexterm" id="id2007"/><a data-primary="macOS" data-type="indexterm" id="id2008"/>instead of the single root and forward slash (/) path separator that is used in Linux and macOS systems.</p>&#13;
&#13;
<p>Java tries to compensate for this difference. For example, on Windows platforms, it accepts paths with either forward slashes or backslashes. On macOS and Linux, however, it only accepts forward slashes.</p>&#13;
&#13;
<p>Your best bet is to make sure you follow the <a data-primary="filename conventions, host system" data-type="indexterm" id="id2009"/><a data-primary="JFileChooser class" data-type="indexterm" id="id2010"/>filename conventions of the host filesystem. If your application has a GUI that is opening and saving files at the user’s request, you should be able to handle that functionality with the Swing <code>JFileChooser</code> class. This class encapsulates a graphical file-selection dialog box. The methods of the <code>JFileChooser</code> take care of system-dependent filename features for you.</p>&#13;
&#13;
<p>If your application needs to deal with files on its own behalf, however, things get a little more complicated. The <code>File</code> class contains a few <code>static</code> variables to make this task easier. <code>File.separator</code> defines a <code>String</code> that specifies the file separator on the local host (e.g., <code>/</code> on Unix and macOS systems, and <code>\</code> on Windows systems); <code>File.separatorChar</code> provides the same information as a <code>char</code>.</p>&#13;
&#13;
<p>You can use this system-dependent information in several ways. Probably the simplest way to localize pathnames is to pick a convention that you use internally, such as the forward slash (/), and do a <code>String</code> replace to substitute for the localized separator character:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="c1">// we'll use forward slash as our standard</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">String</code><code class="w"> </code><code class="n">path</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"mail/2023/june"</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">path</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">path</code><code class="p">.</code><code class="na">replace</code><code class="p">(</code><code class="sc">'/'</code><code class="p">,</code><code class="w"> </code><code class="n">File</code><code class="p">.</code><code class="na">separatorChar</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">File</code><code class="w"> </code><code class="n">mailbox</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">File</code><code class="p">(</code><code class="n">path</code><code class="p">);</code><code class="w"/></pre>&#13;
&#13;
<p>Alternatively, you could work with the components of a pathname and build the local pathname when you need it:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">String</code><code class="w"> </code><code class="o">[]</code><code class="w"> </code><code class="n">path</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="s">"mail"</code><code class="p">,</code><code class="w"> </code><code class="s">"2004"</code><code class="p">,</code><code class="w"> </code><code class="s">"june"</code><code class="p">,</code><code class="w"> </code><code class="s">"merle"</code><code class="w"> </code><code class="p">};</code><code class="w"/>&#13;
&#13;
<code class="w">    </code><code class="n">StringBuffer</code><code class="w"> </code><code class="n">sb</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">StringBuffer</code><code class="p">(</code><code class="n">path</code><code class="o">[</code><code class="mi">0</code><code class="o">]</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">i</code><code class="o">=</code><code class="mi">1</code><code class="p">;</code><code class="w"> </code><code class="n">i</code><code class="o">&lt;</code><code class="w"> </code><code class="n">path</code><code class="p">.</code><code class="na">length</code><code class="p">;</code><code class="w"> </code><code class="n">i</code><code class="o">++</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">sb</code><code class="p">.</code><code class="na">append</code><code class="p">(</code><code class="n">File</code><code class="p">.</code><code class="na">separator</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">path</code><code class="o">[</code><code class="n">i</code><code class="o">]</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">File</code><code class="w"> </code><code class="n">mailbox</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">File</code><code class="p">(</code><code class="n">sb</code><code class="p">.</code><code class="na">toString</code><code class="p">());</code><code class="w"/></pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Remember that Java interprets backslash characters (<code>\</code>) in source code as escape characters when they’re used in a <code>String</code>. To get a literal backslash, you have to double up: <code>\\</code>.</p>&#13;
</div>&#13;
&#13;
<p>To grapple with the issue of <a data-primary="listRoots() method, File" data-type="indexterm" id="id2011"/>filesystems with multiple “roots” (for example, <code>C:\</code> on Windows), the <code>File</code> class provides the static method <code>listRoots()</code>, which returns an array of <code>File</code> objects corresponding to the filesystem root directories. You can try this out in <em>jshell</em>:</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; import java.io.File;&#13;
&#13;
// On a Linux box:&#13;
jshell&gt; File.listRoots()&#13;
$2 ==&gt; File[1] { / }&#13;
&#13;
// On Windows:&#13;
jshell&gt; File.listRoots()&#13;
$3 ==&gt; File[2] { C:\, D:\ }</pre>&#13;
&#13;
<p>Again, in a GUI application, a graphical file chooser dialog generally shields you from this problem.<a data-primary="" data-startref="ix_local_path" data-type="indexterm" id="id2012"/><a data-primary="" data-startref="ix_path_local" data-type="indexterm" id="id2013"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="File operations" data-type="sect3"><div class="sect3" id="learnjava6-CHP-10-SECT-1.4.3">&#13;
<h3>File operations</h3>&#13;
&#13;
<p>Once we have a <code>File</code> object, we can use it to <a data-primary="file operations" data-type="indexterm" id="ix_file_ops"/><a data-primary="isAbsolute() method, File" data-type="indexterm" id="id2014"/><a data-primary="isDirectory() method, File" data-type="indexterm" id="id2015"/><a data-primary="isFile() method, File" data-type="indexterm" id="id2016"/>perform a number of standard operations on the file or directory it represents. Several methods let us ask questions about the <code>File</code>. For example, <code>isFile()</code> returns <code>true</code> if the <code>File</code> represents a regular file, while <code>isDirectory()</code> returns <code>true</code> if it’s a directory. <code>isAbsolute()</code> indicates whether the <code>File</code> encapsulates an absolute or relative <a data-primary="absolute file path" data-type="indexterm" id="id2017"/><a data-primary="path" data-secondary="absolute" data-type="indexterm" id="id2018"/><a data-primary="path" data-secondary="relative" data-type="indexterm" id="id2019"/><a data-primary="relative file path" data-type="indexterm" id="id2020"/>path specification. A <em>relative path</em> is relative to the application’s working directory. An <em>absolute path</em> is a system-dependent notion that means that the path isn’t tied to the working directory or current drive. In Unix and macOS, an absolute path starts with a forward slash: <em>/Users/pat/foo.txt</em>. In Windows, it is a full path including the drive letter: <em>C:\Users\pat\foo.txt</em> (and, again, it can be on a different drive letter than the working directory if there are multiple drives in the system).</p>&#13;
&#13;
<p>Components of the <a data-primary="getName() method, File" data-type="indexterm" id="id2021"/><a data-primary="getParent() method, File" data-type="indexterm" id="id2022"/><a data-primary="getPath() method, File" data-type="indexterm" id="id2023"/><a data-primary="getAbsolutePath() method, File" data-type="indexterm" id="id2024"/>pathname are available through the methods <code>getName()</code>, <code>getPath()</code>, <code>getAbsolutePath()</code>, and <code>getParent()</code>. The <code>getName()</code> method returns a <code>String</code> for the filename without any directory information. If the <code>File</code> has an absolute path specification, <code>getAbsolutePath()</code> returns that path. Otherwise, it returns the relative path appended to the current working directory (attempting to make it an absolute path). The <code>getParent()</code> method returns the parent directory of the file or directory.</p>&#13;
&#13;
<p>The string <a data-primary="getCanonicalPath() method, File" data-type="indexterm" id="id2025"/>returned by <code>getPath()</code> or <code>getAbsolutePath()</code> may not follow the same case conventions as the underlying filesystem. You can retrieve the filesystem’s own (or “canonical”) version of the file’s path by using the method <code>getCanonicalPath()</code>. In Windows, for example, you can create a <code>File</code> object whose <code>getAbsolutePath()</code> is <em>C:\Autoexec.bat</em> but whose <code>getCanonicalPath()</code> is <em>C:\AUTOEXEC.BAT</em>; both actually point to the same file. This is useful for comparing filenames or for showing them to the user.</p>&#13;
&#13;
<p>You can get or set the <a data-primary="epoch" data-type="indexterm" id="id2026"/><a data-primary="lastModified() method, File" data-type="indexterm" id="id2027"/><a data-primary="setLastModified() method, File" data-type="indexterm" id="id2028"/><a data-primary="length() method" data-secondary="File object" data-type="indexterm" id="id2029"/>modification time of a file or directory with the &#13;
<span class="keep-together"><code>lastModified()</code></span> and <code>setLastModified()</code> methods. The value is a <code>long</code> that is the number of milliseconds since the <em>epoch</em> (the name for the “first” date in Unix: January 1, 1970, 00:00:00 GMT). We can also get the size of the file, in bytes, with <code>length()</code>.</p>&#13;
&#13;
<p>Here’s a fragment of code that prints some information about a file:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">File</code><code class="w"> </code><code class="n">fooFile</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">File</code><code class="p">(</code><code class="s">"/tmp/foo.txt"</code><code class="p">);</code><code class="w"/>&#13;
&#13;
<code class="w">    </code><code class="n">String</code><code class="w"> </code><code class="n">type</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">fooFile</code><code class="p">.</code><code class="na">isFile</code><code class="p">()</code><code class="w"> </code><code class="o">?</code><code class="w"> </code><code class="s">"File "</code><code class="w"> </code><code class="p">:</code><code class="w"> </code><code class="s">"Directory "</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">String</code><code class="w"> </code><code class="n">name</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">fooFile</code><code class="p">.</code><code class="na">getName</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">    </code><code class="kt">long</code><code class="w"> </code><code class="n">len</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">fooFile</code><code class="p">.</code><code class="na">length</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">type</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">name</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="s">", "</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">len</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="s">" bytes "</code><code class="p">);</code><code class="w"/></pre>&#13;
&#13;
<p>If the <code>File</code> object corresponds to a directory, we can list the files in the directory with the <code>list()</code> method or the <code>listFiles()</code> method:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">File</code><code class="w"> </code><code class="n">tmpDir</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">File</code><code class="p">(</code><code class="s">"/tmp"</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">String</code><code class="w"> </code><code class="o">[]</code><code class="w"> </code><code class="n">fileNames</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">tmpDir</code><code class="p">.</code><code class="na">list</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">File</code><code class="w"> </code><code class="o">[]</code><code class="w"> </code><code class="n">files</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">tmpDir</code><code class="p">.</code><code class="na">listFiles</code><code class="p">();</code><code class="w"/></pre>&#13;
&#13;
<p><code>list()</code> returns an <a data-primary="list() method, File" data-type="indexterm" id="id2030"/><a data-primary="listFiles() method, File" data-type="indexterm" id="id2031"/>array of <code>String</code> objects that contains filenames. <code>listFiles()</code> returns an array of <code>File</code> objects. Note that in neither case are the files guaranteed to be in any kind of order (alphabetical, for example). You can use the Collections API to sort strings alphabetically, like so:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">List</code><code class="w"> </code><code class="n">list</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Arrays</code><code class="p">.</code><code class="na">asList</code><code class="p">(</code><code class="n">fileNames</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">Collections</code><code class="p">.</code><code class="na">sort</code><code class="p">(</code><code class="n">list</code><code class="p">);</code><code class="w"/></pre>&#13;
&#13;
<p>If the <code>File</code> refers to a <a data-primary="mkdir() method, File" data-type="indexterm" id="id2032"/><a data-primary="mkdirs() method, File" data-type="indexterm" id="id2033"/><a data-primary="renameTo() method, File" data-type="indexterm" id="id2034"/><a data-primary="delete() method, File" data-type="indexterm" id="id2035"/>nonexistent directory, we can create the directory with <code>mkdir()</code> or <code>mkdirs()</code>. The <code>mkdir()</code> method creates at most a single directory level, so any intervening directories in the path must already exist. <code>mkdirs()</code> creates all directory levels necessary to create the full path of the <code>File</code> specification. In either case, if the directory cannot be created, the method returns <code>false</code>. Use <code>renameTo()</code> to rename a file or directory, and <code>delete()</code> to delete a file or directory.</p>&#13;
&#13;
<p>Although you can <a data-primary="createNewFile() method" data-type="indexterm" id="id2036"/>create a directory using the <code>File</code> object, you don’t typically use <code>File</code> to create a file; that’s normally done implicitly when you write data to <span class="keep-together">it with</span> a <code>FileOutputStream</code> or <code>FileWriter</code>, as we’ll discuss in a moment. The exception is the <code>createNewFile()</code> method, which you can use to create a new zero-length file at the <code>File</code>’s location.</p>&#13;
&#13;
<p>The <code>createNewFile()</code> operation is <a data-primary="deleteOnExit() method, File" data-type="indexterm" id="id2037"/>guaranteed to be atomic<sup><a data-type="noteref" href="ch10.html#id2038" id="id2038-marker">3</a></sup> with respect to all other file creation in the filesystem. Java returns a Boolean value from <code>createNewFile()</code> that tells <span class="keep-together">you whether</span> the file was created or not. Creating a new file this way is useful when you also use <code>deleteOnExit()</code>, which flags the file to be automatically removed when the Java VM exits. This combination allows you to guard resources or make an application that can only be run in a single instance at a time.</p>&#13;
&#13;
<p>Another file <a data-primary="createTempFile() method" data-type="indexterm" id="id2039"/>creation method that is related to the <code>File</code> class itself is the static method <code>createTempFile()</code>, which creates a file in a specified location using an automatically generated, unique name. You typically use <code>createTempFile()</code> in conjunction with <code>deleteOnExit()</code>. Network applications use this combination frequently to create short-lived files for storing requests or building responses.</p>&#13;
&#13;
<p>The <code>toURL()</code> method <a data-primary="toURL() method" data-type="indexterm" id="id2040"/>converts a file path to a <code>file:</code> URL object. URLs are a kind of abstraction that allow you to point to any kind of object anywhere on a network. Converting a <code>File</code> reference to a URL may be useful for consistency with more general utilities that deal with URLs. Java’s NIO, for example, uses URLs to reference new types of filesystems that are implemented directly in Java code.<a data-primary="" data-startref="ix_file_class" data-type="indexterm" id="id2041"/><a data-primary="" data-startref="ix_java_io_file_class" data-type="indexterm" id="id2042"/><a data-primary="" data-startref="ix_stream_java_io_file_class" data-type="indexterm" id="id2043"/><a data-primary="" data-startref="ix_file_ops" data-type="indexterm" id="id2044"/></p>&#13;
&#13;
<p><a data-type="xref" href="#learnjava6-CHP-10-TABLE-1">Table 10-1</a> summarizes the methods provided by the <code>File</code> class.</p>&#13;
<table id="learnjava6-CHP-10-TABLE-1">&#13;
<caption><span class="label">Table 10-1. </span>File methods</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Method</th>&#13;
<th>Return type</th>&#13;
<th>Description</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p><code>canExecute()</code></p></td>&#13;
<td><p><code>boolean</code></p></td>&#13;
<td><p>Is the file executable?</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>canRead()</code></p></td>&#13;
<td><p><code>boolean</code></p></td>&#13;
<td><p>Is the file (or directory) readable?</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>canWrite()</code></p></td>&#13;
<td><p><code>boolean</code></p></td>&#13;
<td><p>Is the file (or directory) writable?</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>createNewFile()</code></p></td>&#13;
<td><p><code>boolean</code></p></td>&#13;
<td><p>Creates a new file.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>createTempFile (String</code> <em><code>pfx</code></em>, <code>String</code><em><code>sfx</code></em><code>)</code></p></td>&#13;
<td><p><code>File</code></p></td>&#13;
<td><p>Static method to create a new file, with the specified prefix and suffix, in the default temp file directory.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>delete()</code></p></td>&#13;
<td><p><code>boolean</code></p></td>&#13;
<td><p>Deletes the file (or directory).</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>deleteOnExit()</code></p></td>&#13;
<td><p><code>Void</code></p></td>&#13;
<td><p>When it exits, the Java runtime system deletes the file.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>exists()</code></p></td>&#13;
<td><p><code>boolean</code></p></td>&#13;
<td><p>Does the file (or directory) exist?</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>getAbsolutePath()</code></p></td>&#13;
<td><p><code>String</code></p></td>&#13;
<td><p>Returns the absolute path of the file (or directory).</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>getCanonicalPath()</code></p></td>&#13;
<td><p><code>String</code></p></td>&#13;
<td><p>Returns the absolute, case-correct, and relative-element-resolved path of the file (or directory).</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>getFreeSpace()</code></p></td>&#13;
<td><p><code>long</code></p></td>&#13;
<td><p>Gets the number of bytes of unallocated space on the partition holding this path or 0 if the path is invalid.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>getName()</code></p></td>&#13;
<td><p><code>String</code></p></td>&#13;
<td><p>Returns the name of the file (or directory).</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>getParent()</code></p></td>&#13;
<td><p><code>String</code></p></td>&#13;
<td><p>Returns the name of the parent directory of the file (or directory).</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>getPath()</code></p></td>&#13;
<td><p><code>String</code></p></td>&#13;
<td><p>Returns the path of the file (or directory). (Not to be confused with <code>toPath()</code>.)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>getTotalSpace()</code></p></td>&#13;
<td><p><code>long</code></p></td>&#13;
<td><p>Gets the size of the partition that contains the file path, in bytes, or 0 if the path is invalid.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>getUseableSpace()</code></p></td>&#13;
<td><p><code>long</code></p></td>&#13;
<td><p>Gets the number of bytes of user-accessible unallocated space on the partition holding this path or 0 if the path is invalid. This method attempts to take into account user write permissions.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>isAbsolute()</code></p></td>&#13;
<td><p><code>boolean</code></p></td>&#13;
<td><p>Is the filename (or directory name) absolute?</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>isDirectory()</code></p></td>&#13;
<td><p><code>boolean</code></p></td>&#13;
<td><p>Is the item a directory?</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>isFile()</code></p></td>&#13;
<td><p><code>boolean</code></p></td>&#13;
<td><p>Is the item a file?</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>isHidden()</code></p></td>&#13;
<td><p><code>boolean</code></p></td>&#13;
<td><p>Is the item hidden? (System dependent.)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>lastModified()</code></p></td>&#13;
<td><p><code>long</code></p></td>&#13;
<td><p>Returns the last modification time of the file (or directory).</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>length()</code></p></td>&#13;
<td><p><code>long</code></p></td>&#13;
<td><p>Returns the length of the file.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>list()</code></p></td>&#13;
<td><p><code>String []</code></p></td>&#13;
<td><p>Returns a list of files in the directory.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>listFiles()</code></p></td>&#13;
<td><p><code>File[]</code></p></td>&#13;
<td><p>Returns the contents of the directory as an array of <code>File</code> objects.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>listRoots()</code></p></td>&#13;
<td><p><code>File[]</code></p></td>&#13;
<td><p>Returns an array of root filesystems, if any (e.g., C:/, D:/).</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>mkdir()</code></p></td>&#13;
<td><p><code>boolean</code></p></td>&#13;
<td><p>Creates the directory.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>mkdirs()</code></p></td>&#13;
<td><p><code>boolean</code></p></td>&#13;
<td><p>Creates all directories in the path.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>renameTo(File</code> <em><code>dest</code></em> <code>)</code></p></td>&#13;
<td><p><code>boolean</code></p></td>&#13;
<td><p>Renames the file (or directory).</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>setExecutable()</code></p></td>&#13;
<td><p><code>boolean</code></p></td>&#13;
<td><p>Sets execute permissions for the file.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>setLastModified()</code></p></td>&#13;
<td><p><code>boolean</code></p></td>&#13;
<td><p>Sets the last-modified time of the file (or directory).</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>setReadable()</code></p></td>&#13;
<td><p><code>boolean</code></p></td>&#13;
<td><p>Sets read permissions for the file.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>setReadOnly()</code></p></td>&#13;
<td><p><code>boolean</code></p></td>&#13;
<td><p>Sets the file to read-only status.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>setWriteable()</code></p></td>&#13;
<td><p><code>boolean</code></p></td>&#13;
<td><p>Sets the write permissions for the file.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>toPath()</code></p></td>&#13;
<td><p><code>java.nio.file.Path</code></p></td>&#13;
<td><p>Convert the file to an NIO file path. (Not to be confused with <code>getPath()</code>.)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>toURL()</code></p></td>&#13;
<td><p><code>java.net.URL</code></p></td>&#13;
<td><p>Generates a URL object for the file (or directory).</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="File Streams" data-type="sect2"><div class="sect2" id="learnjava6-CHP-10-SECT-1.5">&#13;
<h2>File Streams</h2>&#13;
&#13;
<p>You’re probably sick of <a data-primary="file streams" data-type="indexterm" id="ix_file_str_ch10"/><a data-primary="streams (java.io)" data-secondary="file streams" data-type="indexterm" id="ix_stream_file_str_ch10"/><a data-primary="FileOutputStream class" data-type="indexterm" id="id2045"/><a data-primary="FileInputStream class" data-type="indexterm" id="ix_file_input_str"/>hearing about files already—and we haven’t even written a byte yet! Well, now the fun begins. Java provides two fundamental streams for reading from and writing to files: <code>FileInputStream</code> and <code>FileOutputStream</code>. These streams provide the basic byte-oriented <code>InputStream</code> and <code>OutputStream</code> functionality that is applied to reading and writing files. They can be combined with the filter streams described earlier to work with files in the same way as other stream <span class="keep-together">communications.</span></p>&#13;
&#13;
<p>You can create a <code>FileInputStream</code> from a <code>String</code> pathname or a <code>File</code> object:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">FileInputStream</code><code class="w"> </code><code class="n">in</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">FileInputStream</code><code class="p">(</code><code class="s">"/etc/motd"</code><code class="p">);</code><code class="w"/></pre>&#13;
&#13;
<p>When you create a <code>FileInputStream</code>, the Java runtime system attempts to open the specified file. Thus, the <code>FileInputStream</code> constructors can throw a &#13;
<span class="keep-together"><code>FileNotFoundException</code></span> if the specified file doesn’t exist, or an <code>IOException</code> if some other I/O error occurs. You must catch these exceptions in your code. Wherever possible, it’s a good idea to get in the habit of using the <code>try</code>-with-resources construct to automatically close files for you when you are finished with them:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">  </code><code class="k">try</code><code class="w"> </code><code class="p">(</code><code class="n">FileInputStream</code><code class="w"> </code><code class="n">fin</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">FileInputStream</code><code class="p">(</code><code class="s">"/etc/motd"</code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">// ....</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">// fin will be closed automatically if needed</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">// upon exiting the try clause.</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>When you first create the <a data-primary="length() method" data-secondary="File object" data-type="indexterm" id="id2046"/><a data-primary="available() method, InputStream" data-type="indexterm" id="id2047"/>stream, its <code>available()</code> method and the <code>File</code> object’s <code>length()</code> method should return the same value.</p>&#13;
&#13;
<p>To read <a data-primary="FileReader class" data-type="indexterm" id="id2048"/><a data-primary="InputStreamReader class" data-type="indexterm" id="id2049"/>characters from a file as a <code>Reader</code>, you can wrap an <code>InputStreamReader</code> around a <code>FileInputStream</code>. You can also use the <code>FileReader</code> class, which is provided as a convenience. <code>FileReader</code> is just a <code>FileInputStream</code> wrapped in an <code>InputStreamReader</code> with some defaults.</p>&#13;
&#13;
<p>The following <a data-primary="ListIt class" data-type="indexterm" id="id2050"/>class, <code>ListIt</code>, is a small utility that prints the contents of a file or directory to standard output:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="c1">//file: ch10/examples/ListIt.java</code><code class="w"/>&#13;
<code class="kn">import</code><code class="w"> </code><code class="nn">java.io.*</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="kd">class</code> <code class="nc">ListIt</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="kd">static</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">main</code><code class="w"> </code><code class="p">(</code><code class="n">String</code><code class="w"> </code><code class="n">args</code><code class="o">[]</code><code class="p">)</code><code class="w"> </code><code class="kd">throws</code><code class="w"> </code><code class="n">Exception</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">File</code><code class="w"> </code><code class="n">file</code><code class="w"> </code><code class="o">=</code><code class="w">  </code><code class="k">new</code><code class="w"> </code><code class="n">File</code><code class="p">(</code><code class="n">args</code><code class="o">[</code><code class="mi">0</code><code class="o">]</code><code class="p">);</code><code class="w"/>&#13;
&#13;
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="o">!</code><code class="n">file</code><code class="p">.</code><code class="na">exists</code><code class="p">()</code><code class="w"> </code><code class="o">||</code><code class="w"> </code><code class="o">!</code><code class="n">file</code><code class="p">.</code><code class="na">canRead</code><code class="p">())</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="s">"Can't read "</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">file</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">      </code><code class="k">return</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/>&#13;
&#13;
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">file</code><code class="p">.</code><code class="na">isDirectory</code><code class="p">())</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">String</code><code class="w"> </code><code class="o">[]</code><code class="w"> </code><code class="n">files</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">file</code><code class="p">.</code><code class="na">list</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">      </code><code class="k">for</code><code class="w"> </code><code class="p">(</code><code class="n">String</code><code class="w"> </code><code class="n">file</code><code class="w"> </code><code class="p">:</code><code class="w"> </code><code class="n">files</code><code class="p">)</code><code class="w"/>&#13;
<code class="w">        </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">file</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"> </code><code class="k">else</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="k">try</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">        </code><code class="n">Reader</code><code class="w"> </code><code class="n">ir</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">InputStreamReader</code><code class="p">(</code><code class="w"/>&#13;
<code class="w">            </code><code class="k">new</code><code class="w"> </code><code class="n">FileInputStream</code><code class="p">(</code><code class="n">file</code><code class="p">)</code><code class="w"> </code><code class="p">);</code><code class="w"/>&#13;
&#13;
<code class="w">        </code><code class="n">BufferedReader</code><code class="w"> </code><code class="n">in</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">BufferedReader</code><code class="p">(</code><code class="n">ir</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">        </code><code class="n">String</code><code class="w"> </code><code class="n">line</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">        </code><code class="k">while</code><code class="w"> </code><code class="p">((</code><code class="n">line</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">in</code><code class="p">.</code><code class="na">readLine</code><code class="p">())</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">null</code><code class="p">)</code><code class="w"/>&#13;
<code class="w">          </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">line</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">      </code><code class="k">catch</code><code class="w"> </code><code class="p">(</code><code class="n">FileNotFoundException</code><code class="w"> </code><code class="n">e</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">          </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="s">"File Disappeared"</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p><code>ListIt</code> constructs a <code>File</code> object from its first command-line argument and tests the <code>File</code> to see whether it exists and is readable. If the <code>File</code> is a directory, <code>ListIt</code> outputs the names of the files in the directory. Otherwise, <code>ListIt</code> reads and outputs the file, line by line. Give it a try! Can you use <code>ListIt</code> on <em>ListIt.java</em>?<a data-primary="" data-startref="ix_file_input_str" data-type="indexterm" id="id2051"/></p>&#13;
&#13;
<p>For writing <a data-primary="FileNotFoundException" data-type="indexterm" id="id2052"/><a data-primary="FileOutputStream class" data-type="indexterm" id="id2053"/><a data-primary="IOException" data-type="indexterm" id="id2054"/>files, you can create a <code>FileOutputStream</code> from a <code>String</code> pathname or a <code>File</code> object. Unlike <code>FileInputStream</code>, however, the <code>FileOutputStream</code> constructors don’t throw a <code>FileNotFoundException</code>. If the specified file doesn’t exist, the <code>FileOutputStream</code> creates the file. The <code>FileOutputStream</code> constructors can throw an <code>IOException</code> if some other I/O error occurs, so you still need to handle this exception.</p>&#13;
&#13;
<p>If the <a data-primary="write() method" data-secondary="FileOutputStream" data-type="indexterm" id="id2055"/>specified file does exist, the <code>FileOutputStream</code> opens it for writing. When you subsequently call the <code>write()</code> method, the new data overwrites the current contents of the file. If you need to append data to an existing file, you can use a form of the constructor that accepts a Boolean <code>append</code> flag:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">FileOutputStream</code><code class="w"> </code><code class="n">fooOut</code><code class="w"> </code><code class="o">=</code><code class="w"/>&#13;
<code class="w">        </code><code class="k">new</code><code class="w"> </code><code class="n">FileOutputStream</code><code class="p">(</code><code class="n">fooFile</code><code class="p">);</code><code class="w"> </code><code class="c1">// overwrite fooFile</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">FileOutputStream</code><code class="w"> </code><code class="n">pwdOut</code><code class="w"> </code><code class="o">=</code><code class="w"/>&#13;
<code class="w">        </code><code class="k">new</code><code class="w"> </code><code class="n">FileOutputStream</code><code class="p">(</code><code class="s">"/etc/passwd"</code><code class="p">,</code><code class="w"> </code><code class="kc">true</code><code class="p">);</code><code class="w"> </code><code class="c1">// append</code><code class="w"/></pre>&#13;
&#13;
<p>Another way to append data to files is with <code>RandomAccessFile</code>, which we’ll discuss shortly.</p>&#13;
&#13;
<p>Just as with <a data-primary="OutputStreamWriter class" data-type="indexterm" id="id2056"/>reading, to write characters (instead of bytes) to a file, you can wrap an <code>OutputStreamWriter</code> around a <code>FileOutputStream</code>. If you want to use the default character-encoding scheme, you can use the <code>FileWriter</code> class instead, which is provided as a convenience.</p>&#13;
&#13;
<p>The following snippet reads a line of data from standard input and writes it to the file <em>/tmp/foo.txt</em>:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">String</code><code class="w"> </code><code class="n">s</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">BufferedReader</code><code class="p">(</code><code class="w"/>&#13;
<code class="w">        </code><code class="k">new</code><code class="w"> </code><code class="n">InputStreamReader</code><code class="p">(</code><code class="n">System</code><code class="p">.</code><code class="na">in</code><code class="p">)</code><code class="w"> </code><code class="p">).</code><code class="na">readLine</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">File</code><code class="w"> </code><code class="n">out</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">File</code><code class="p">(</code><code class="s">"/tmp/foo.txt"</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">FileWriter</code><code class="w"> </code><code class="n">fw</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">FileWriter</code><code class="w"> </code><code class="p">(</code><code class="n">out</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">PrintWriter</code><code class="w"> </code><code class="n">pw</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">PrintWriter</code><code class="p">(</code><code class="n">fw</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">pw</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">s</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">pw</code><code class="p">.</code><code class="na">close</code><code class="p">();</code><code class="w"/></pre>&#13;
&#13;
<p>Notice how we <a data-primary="close() method" data-secondary="OutputStream" data-type="indexterm" id="id2057"/>wrapped the <code>FileWriter</code> in a <code>PrintWriter</code> to facilitate writing the data. Also, to be a good filesystem citizen, call the <code>close()</code> method when you’re done. Here, closing the <code>PrintWriter</code> closes the underlying <code>Writer</code> for us.<a data-primary="" data-startref="ix_file_str_ch10" data-type="indexterm" id="id2058"/><a data-primary="" data-startref="ix_stream_file_str_ch10" data-type="indexterm" id="id2059"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="RandomAccessFile" data-type="sect2"><div class="sect2" id="learnjava6-CHP-10-SECT-1.6">&#13;
<h2>RandomAccessFile</h2>&#13;
&#13;
<p>The <code>java.io.RandomAccessFile</code> class <a data-primary="streams (java.io)" data-secondary="RandomAccessFile" data-type="indexterm" id="id2060"/><a data-primary="java.io package" data-secondary="RandomAccessFile class" data-type="indexterm" id="id2061"/><a data-primary="RandomAccessFile class" data-type="indexterm" id="id2062"/>provides the ability to read <em>and</em> write data at any location in a file. <code>RandomAccessFile</code> implements both the <code>DataInput</code> and <code>DataOutput</code> interfaces, so you can use it to read and write strings and primitive types anywhere in the file just as if it were a <code>DataInputStream</code> and <code>DataOutputStream</code>. However, because the class provides random, rather than sequential, access to file data, it’s not a subclass of either <code>InputStream</code> or <code>OutputStream</code>.</p>&#13;
&#13;
<p>You can create a <code>RandomAccessFile</code> from a <code>String</code> pathname or a <code>File</code> object. The constructor also takes a second <code>String</code> argument that specifies the mode of the file. Use the string <code>"r"</code> for a read-only file or <code>"rw"</code> for a read/write file:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="k">try</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">RandomAccessFile</code><code class="w"> </code><code class="n">users</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">RandomAccessFile</code><code class="p">(</code><code class="s">"Users"</code><code class="p">,</code><code class="w"> </code><code class="s">"rw"</code><code class="p">)</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"> </code><code class="k">catch</code><code class="w"> </code><code class="p">(</code><code class="n">IOException</code><code class="w"> </code><code class="n">e</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="p">...</code><code class="w"> </code><code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>When you <a data-primary="IOException" data-type="indexterm" id="id2063"/>create a <code>RandomAccessFile</code> in read-only mode, Java tries to open the specified file. If the file doesn’t exist, <code>RandomAccessFile</code> throws an <code>IOException</code>. If, however, you’re creating a <code>RandomAccessFile</code> in read/write mode, the object creates the file if it doesn’t exist. The constructor can still throw an <code>IOException</code> if some other I/O error occurs, so you still need to handle this exception.</p>&#13;
&#13;
<p>After you have created a <code>RandomAccessFile</code>, you can call any of the normal reading and writing methods, just as you would with a <code>DataInputStream</code> or <code>DataOutputStream</code>. If you try to write to a read-only file, the write method throws an &#13;
<span class="keep-together"><code>IOException</code></span>.</p>&#13;
&#13;
<p>What <a data-primary="seek() method, RandomAccessFile" data-type="indexterm" id="id2064"/><a data-primary="getFilePointer() method, RandomAccessFile" data-type="indexterm" id="id2065"/>makes a <code>RandomAccessFile</code> special is the <code>seek()</code> method. This method takes a <code>long</code> value and uses it to set the location for reading and writing in the file. You can use the <code>getFilePointer()</code> method to get the current location. If you need to append data to the end of the file, use <code>length()</code> to determine that location, then <code>seek()</code> to it. You can write or seek beyond the end of a file, but you can’t read beyond the end of a file. The <code>read()</code> method throws an <code>EOFException</code> if you try to do this.</p>&#13;
&#13;
<p>Here’s an example of writing data for a simple database:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">users</code><code class="p">.</code><code class="na">seek</code><code class="p">(</code><code class="n">userNum</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">RECORDSIZE</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">users</code><code class="p">.</code><code class="na">writeUTF</code><code class="p">(</code><code class="n">userName</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">users</code><code class="p">.</code><code class="na">writeInt</code><code class="p">(</code><code class="n">userID</code><code class="p">);</code><code class="w"/></pre>&#13;
&#13;
<p>In this snippet, we assume that the <code>String</code> length for <code>userName</code>, along with any data that comes after it, fits within the specified record size.<a data-primary="" data-startref="ix_streams_ch10" data-type="indexterm" id="id2066"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The New I/O File API" data-type="sect1"><div class="sect1" id="learnjava6-CHP-10-SECT-2">&#13;
<h1>The New I/O File API</h1>&#13;
&#13;
<p>We are now <a data-primary="input/output (I/O)" data-secondary="NIO File API" data-type="indexterm" id="ix_io_nio_api"/>going to turn our attention from the original, “classic” Java File API to the NIO File API. As we mentioned earlier, the NIO File API can be thought of as either a replacement for or a complement to the classic API. The new API moves Java toward a higher performance and more flexible style of I/O supporting <em>selectable</em> and asynchronously interruptible <em>channels</em>. (More on selecting and using channels soon.) When working with files, the new API’s strength is providing a fuller abstraction of the filesystem in Java.</p>&#13;
&#13;
<p>In addition to better support for existing, real-world filesystem types—including the new and welcomed ability to copy and move files, manage links, and get detailed file attributes like owners and permissions—NIO allows you to implement entirely new types of filesystems directly in Java. The best example of this is the ZIP filesystem provider. You can “mount” a ZIP archive file as a filesystem. You can work with the files within the archive directly using the standard APIs, just like any other filesystem.</p>&#13;
&#13;
<p>The NIO File package also provides some utilities that would have saved Java developers a lot of repeated code over the years, including directory tree change monitoring, filesystem traversal, filename “globbing” (the jargon for using wildcards in filenames), and convenience methods to read entire files directly into memory.</p>&#13;
&#13;
<p>We’ll cover the basic NIO File API in this section and return to the topic of buffers and channels at the end of the chapter. In particular, we’ll talk about <code>ByteChannel</code>s and <code>FileChannel</code>, which you can think of as alternate, buffer-oriented streams for reading and writing files and other types of data.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="FileSystem and Path" data-type="sect2"><div class="sect2" id="learnjava6-CHP-10-SECT-2.1">&#13;
<h2>FileSystem and Path</h2>&#13;
&#13;
<p>There are three <a data-primary="NIO File API" data-secondary="Filesystem and Path" data-type="indexterm" id="ix_nio_file_api_sys_path"/><a data-primary="java.nio.file package" data-type="indexterm" id="id2067"/>main players in the <code>java.nio.file</code> package:</p>&#13;
<dl>&#13;
<dt><code>FileSystem</code></dt>&#13;
<dd>&#13;
<p>An <a data-primary="FileSystem class" data-type="indexterm" id="id2068"/>underlying storage mechanism and serves as a factory<sup><a data-type="noteref" href="ch10.html#id2069" id="id2069-marker">4</a></sup> for <code>Path</code> objects.</p>&#13;
</dd>&#13;
<dt><code>FileSystems</code></dt>&#13;
<dd>&#13;
<p>A <a data-primary="FileSystems factory" data-type="indexterm" id="id2070"/>factory for <code>FileSystem</code> objects.</p>&#13;
</dd>&#13;
<dt><code>Path</code></dt>&#13;
<dd>&#13;
<p>The <a data-primary="Path interface" data-type="indexterm" id="id2071"/><a data-primary="java.nio package" data-secondary="Path interface" data-type="indexterm" id="id2072"/>location of a file or directory within the filesystem.</p>&#13;
</dd>&#13;
<dt><code>Files</code></dt>&#13;
<dd>&#13;
<p>A utility <a data-primary="Files utility class" data-type="indexterm" id="id2073"/>class that contains a rich set of static methods for manipulating <code>Path</code> objects to perform all of the basic file operations analogous to the classic API.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>The <code>FileSystems</code> (plural) class is our starting point. Let’s create a couple of &#13;
<span class="keep-together">filesystems</span>:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="c1">// The default host computer filesystem</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">FileSystem</code><code class="w"> </code><code class="n">fs</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">FileSystems</code><code class="p">.</code><code class="na">getDefault</code><code class="p">();</code><code class="w"/>&#13;
&#13;
<code class="w">    </code><code class="c1">// A custom filesystem for ZIP files, no special properties</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">Map</code><code class="o">&lt;</code><code class="n">String</code><code class="p">,</code><code class="n">String</code><code class="o">&gt;</code><code class="w"> </code><code class="n">props</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">HashMap</code><code class="o">&lt;&gt;</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">URI</code><code class="w"> </code><code class="n">zipURI</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">URI</code><code class="p">.</code><code class="na">create</code><code class="p">(</code><code class="s">"jar:file:/Users/pat/tmp/MyArchive.zip"</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">FileSystem</code><code class="w"> </code><code class="n">zipfs</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">FileSystems</code><code class="p">.</code><code class="na">newFileSystem</code><code class="p">(</code><code class="n">zipURI</code><code class="p">,</code><code class="w"> </code><code class="n">props</code><code class="p">);</code><code class="w"/></pre>&#13;
&#13;
<p>As shown in this <a data-primary="Uniform Resource Locators (URLs)" data-type="indexterm" id="id2074"/><a data-primary="URLs (uniform resource locators)" data-type="indexterm" id="id2075"/><a data-primary="jar:file protocol" data-type="indexterm" id="id2076"/>snippet, we ask for the default filesystem to manipulate files in the host computer’s environment. We also use the <code>FileSystems</code> class to construct another <code>FileSystem</code> by taking a <em>uniform resource identifier</em> (or URI, a special identifier similar to a URL) that references a custom filesystem type. We use <code>jar:file</code> as our URI protocol to indicate we are working with a JAR or ZIP file.</p>&#13;
&#13;
<p><code>FileSystem</code> implements <code>Closeable</code>, and <a data-primary="Closeable class" data-type="indexterm" id="id2077"/>when a <code>FileSystem</code> is closed, all open file channels and other streaming objects associated with it are closed as well. Attempting to read or write to those channels will throw an exception at that point. Note that the default filesystem (associated with the host computer) cannot be closed.</p>&#13;
&#13;
<p>Once you have a <code>FileSystem</code>, you can use it as a factory for <code>Path</code> objects that represent files or directories. You can obtain a <code>Path</code> using a string representation just like the classic <code>File</code> class. Subsequently, you can use that <code>Path</code> object with methods of the <code>Files</code> utility to create, read, write, or delete the item:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">Path</code><code class="w"> </code><code class="n">fooPath</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">fs</code><code class="p">.</code><code class="na">getPath</code><code class="p">(</code><code class="s">"/tmp/foo.txt"</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">OutputStream</code><code class="w"> </code><code class="n">out</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Files</code><code class="p">.</code><code class="na">newOutputStream</code><code class="p">(</code><code class="n">fooPath</code><code class="p">);</code><code class="w"/></pre>&#13;
&#13;
<p>This example opens an <code>OutputStream</code> to write to the file <em>foo.txt</em>. By default, if the file does not exist, it will be created, and if it does exist, it will be truncated (set to zero length) before new data is written—but you can change these results using options. We’ll talk more about <code>Files</code> methods in the next section.</p>&#13;
&#13;
<p>The <code>Path</code> class <a data-primary="java.lang package" data-secondary="Iterable interface" data-type="indexterm" id="id2078"/><a data-primary="Iterable interface" data-type="indexterm" id="id2079"/><a data-primary="java.nio package" data-secondary="Watchable interface" data-type="indexterm" id="id2080"/><a data-primary="Watchable interface" data-type="indexterm" id="id2081"/>implements the <code>java.lang.Iterable</code> interface, which can be used to iterate through its literal path components, such as the slash-separated <code>tmp</code> and <code>foo.txt</code> in the preceding snippet. (If you want to traverse the path to find other files or directories, you might be more interested in the <code>DirectoryStream</code> and &#13;
<span class="keep-together"><code>FileVisitor</code></span> that we’ll discuss later.) <code>Path</code> also implements the <code>java.nio.file.Watchable</code> interface, which allows it to be monitored for changes.</p>&#13;
&#13;
<p><code>Path</code> has <a data-primary="convenience methods" data-type="indexterm" id="id2082"/>convenience methods for resolving paths relative to a file or directory:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">Path</code><code class="w"> </code><code class="n">patPath</code><code class="w"> </code><code class="o">=</code><code class="w">  </code><code class="n">fs</code><code class="p">.</code><code class="na">getPath</code><code class="p">(</code><code class="s">"/User/pat/"</code><code class="p">);</code><code class="w"/>&#13;
&#13;
<code class="w">    </code><code class="n">Path</code><code class="w"> </code><code class="n">patTmp</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">patPath</code><code class="p">.</code><code class="na">resolve</code><code class="p">(</code><code class="s">"tmp"</code><code class="p">);</code><code class="w"> </code><code class="c1">// "/User/pat/tmp"</code><code class="w"/>&#13;
&#13;
<code class="w">    </code><code class="c1">// Same as above, using a Path</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">Path</code><code class="w"> </code><code class="n">tmpPath</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">fs</code><code class="p">.</code><code class="na">getPath</code><code class="p">(</code><code class="s">"tmp"</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">Path</code><code class="w"> </code><code class="n">patTmp</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">patPath</code><code class="p">.</code><code class="na">resolve</code><code class="p">(</code><code class="n">tmpPath</code><code class="p">);</code><code class="w"> </code><code class="c1">// "/User/pat/tmp"</code><code class="w"/>&#13;
&#13;
<code class="w">    </code><code class="c1">// Resolving a given absolute path against any path just yields given path</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">Path</code><code class="w"> </code><code class="n">absPath</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">patPath</code><code class="p">.</code><code class="na">resolve</code><code class="p">(</code><code class="s">"/tmp"</code><code class="p">);</code><code class="w"> </code><code class="c1">// "/tmp"</code><code class="w"/>&#13;
&#13;
<code class="w">    </code><code class="c1">// Resolve sibling to Pat (same parent)</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">Path</code><code class="w"> </code><code class="n">danPath</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">patPath</code><code class="p">.</code><code class="na">resolveSibling</code><code class="p">(</code><code class="s">"dan"</code><code class="p">);</code><code class="w"> </code><code class="c1">// "/Users/dan"</code><code class="w"/></pre>&#13;
&#13;
<p>In this <a data-primary="resolve() method, Path" data-type="indexterm" id="id2083"/><a data-primary="resolveSibling() method, Path" data-type="indexterm" id="id2084"/>snippet, we’ve shown the <code>Path</code> methods <code>resolve()</code> and <code>resolveSibling()</code> used to find files or directories relative to a given <code>Path</code> object. The <code>resolve()</code> method is generally used to append a relative path to an existing <code>Path</code> representing a directory. If the argument provided to the <code>resolve()</code> method is an absolute path, it will just yield the absolute path (it acts kind of like the Unix or DOS <code>cd</code> command). The <code>resolveSibling()</code> method works the same way, but it is relative to the parent of the target <code>Path</code>; this method is useful for describing the target of a <code>move()</code> operation.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Path to classic files and back" data-type="sect3"><div class="sect3" id="learnjava6-CHP-10-SECT-2.1.1">&#13;
<h3>Path to classic files and back</h3>&#13;
&#13;
<p>To bridge the classic and new APIs, corresponding <code>toPath()</code> and <code>toFile()</code> methods have been provided in <code>java.io.File</code> and <code>java.nio.file.Path</code>, respectively, to convert to the other form. Of course, the only types of <code>Path</code>s that can be produced from <code>File</code> are paths representing files and directories in the default host filesystem:<a data-primary="" data-startref="ix_nio_file_api_sys_path" data-type="indexterm" id="id2085"/></p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">Path</code><code class="w"> </code><code class="n">tmpPath</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">fs</code><code class="p">.</code><code class="na">getPath</code><code class="p">(</code><code class="s">"/tmp"</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">File</code><code class="w"> </code><code class="n">file</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">tmpPath</code><code class="p">.</code><code class="na">toFile</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">File</code><code class="w"> </code><code class="n">tmpFile</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">File</code><code class="p">(</code><code class="s">"/tmp"</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">Path</code><code class="w"> </code><code class="n">path</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">tmpFile</code><code class="p">.</code><code class="na">toPath</code><code class="p">();</code><code class="w"/></pre>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="NIO File Operations" data-type="sect2"><div class="sect2" id="learnjava6-CHP-10-SECT-2.2">&#13;
<h2>NIO File Operations</h2>&#13;
&#13;
<p>Once we <a data-primary="NIO File API" data-secondary="file operations" data-type="indexterm" id="ix_nio_file_api_file_ops"/><a data-primary="java.nio.file package" data-secondary="Files class" data-type="indexterm" id="ix_java_nio_files"/>have a <code>Path</code>, we can <a data-primary="file operations" data-type="indexterm" id="ix_file_ops_nio"/>operate on it with static methods of the <code>Files</code> utility to create the path as a file or directory, read and write to it, and interrogate and set its properties. We’ll list the bulk of them and then discuss some of the more important ones as we proceed.</p>&#13;
&#13;
<p><a data-type="xref" href="#learnjava6-CHP-10-TABLE-2">Table 10-2</a> summarizes these methods of the <code>java.nio.file.Files</code> class.<a data-primary="methods" data-secondary="NIO Files list" data-type="indexterm" id="id2086"/><a data-primary="Files class" data-type="indexterm" id="ix_files_class_nio"/><a data-primary="methods" data-secondary="Files class list (NIO)" data-type="indexterm" id="ix_method_files_class"/> As you might expect, because the <code>Files</code> class handles all types of file operations, it contains a large number of methods. To make the table more readable, we have elided overloaded forms of the same method (those taking different kinds of arguments), and we grouped corresponding and related types of methods together.</p>&#13;
<table id="learnjava6-CHP-10-TABLE-2">&#13;
<caption><span class="label">Table 10-2. </span>NIO Files methods</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Method</th>&#13;
<th>Return type</th>&#13;
<th>Description</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p><code>copy()</code></p></td>&#13;
<td><p>long or <code>Path</code></p></td>&#13;
<td><p>Copy a stream to a file path, file path to stream, or path to path. Returns the number of bytes copied or the target <code>Path</code>. A target file may optionally be replaced if it exists (the default is to fail if the target exists). Copying a directory results in an empty directory at the target (the contents are not copied). Copying a symbolic link copies the linked file’s data (producing a regular file copy).</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>createDirectory()</code>, <span class="keep-together"><code>createDirectories()</code></span></p></td>&#13;
<td><p><code>Path</code></p></td>&#13;
<td><p>Create a single directory or all directories in a specified path. <code>createDirectory()</code> throws an exception if the directory already exists. <code>createDirectories()</code> will ignore existing directories and only create as needed.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>createFile()</code></p></td>&#13;
<td><p><code>Path</code></p></td>&#13;
<td><p>Create an empty file. The operation is atomic and will only succeed if the file does not exist. (This property can be used to create flag files to guard resources, etc.)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>createLink()</code>, <span class="keep-together"><code>createSymbolicLink()</code></span>, <span class="keep-together"><code>isSymbolicLink()</code></span>, <span class="keep-together"><code>readSymbolicLink()</code></span>, <span class="keep-together"><code>createLink()</code></span></p></td>&#13;
<td><p>boolean or <code>Path</code></p></td>&#13;
<td><p>Create a hard or symbolic link, test to see if a file is a symbolic link, or read the target file pointed to by the symbolic link. Symbolic links are files that reference other files. Regular (“hard”) links are low-level mirrors of a file where two filenames point to the same underlying data. If you don’t know which to use, use a symbolic link.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>createTempDirectory()</code>, <span class="keep-together"><code>createTempFile()</code></span></p></td>&#13;
<td><p><code>Path</code></p></td>&#13;
<td><p>Create a temporary, guaranteed, uniquely named directory or file with the specified prefix. Optionally, place it in the system default temp directory.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>delete()</code>, <code>deleteIfExists()</code></p></td>&#13;
<td><p>void</p></td>&#13;
<td><p>Delete a file or an empty directory. <code>delete</code><code>IfExists()</code> will not throw an exception if the file does not exist.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>exists()</code>, <code>notExists()</code></p></td>&#13;
<td><p>boolean</p></td>&#13;
<td><p>Determine whether the file exists (<code>notExists()</code> simply returns the opposite). Optionally, specify whether links should be followed (by default they are).</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>getAttribute()</code>, <code>set​Attri⁠bute()</code>, <code>getFile​Attri⁠buteView()</code>, <span class="keep-together"><code>readAttributes()</code></span></p></td>&#13;
<td><p><code>Object</code>, <code>Map</code>, or <code>FileAttributeView</code></p></td>&#13;
<td><p>Get or set filesystem-specific file attributes such as access and update times, detailed permissions, and owner information using implementation-specific names.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>getFileStore()</code></p></td>&#13;
<td><p><code>FileStore</code></p></td>&#13;
<td><p>Get a <code>FileStore</code> object that represents the device, volume, or other type of partition of the filesystem on which the path resides.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>getLastModifiedTime()</code>, <code>setLastModifiedTime()</code></p></td>&#13;
<td><p><code>FileTime</code> or <code>Path</code></p></td>&#13;
<td><p>Get or set the last modified time of a file or directory.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>getOwner()</code>, <code>setOwner()</code></p></td>&#13;
<td><p><code>UserPrincipal</code></p></td>&#13;
<td><p>Get or set a <code>UserPrincipal</code> object representing the owner of the file. Use <code>toString()</code> or <code>getName()</code> to get a string representation of the username.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>getPosixFile​Permis⁠sions()</code>, <code>setPosixFilePermissions()</code></p></td>&#13;
<td><p><code>Set</code> or <code>Path</code></p></td>&#13;
<td><p>Get or set the full POSIX user-group-other style read and write permissions for the path as a Set of <code>PosixFile​Per⁠mission</code> enum values.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>isDirectory()</code>, <span class="keep-together"><code>isExecutable()</code></span>, <code>isHidden()</code>, <span class="keep-together"><code>isReadable()</code></span>, <code>isRegularFile()</code>, <code>isWriteable()</code></p></td>&#13;
<td><p>boolean</p></td>&#13;
<td><p>Test file features such as whether the path is a directory and other basic attributes.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>isSameFile()</code></p></td>&#13;
<td><p>boolean</p></td>&#13;
<td><p>Test to see whether the two paths reference the same file (which may potentially be true even if the paths are not identical).</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>move()</code></p></td>&#13;
<td><p><code>Path</code></p></td>&#13;
<td><p>Move a file or directory by renaming or copying it, optionally specifying whether to replace any existing target. Rename will be used unless a copy is required to move a file across file stores or filesystems. Directories can be moved using this method only if the simple rename is possible or if the directory is empty. If a directory move requires copying files across file stores or filesystems, the method throws an <code>IOException</code>. (In this case, you must copy the files yourself. See <code>walkFileTree()</code>.)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>newBufferedReader()</code>, <code>newBufferedWriter()</code></p></td>&#13;
<td><p><code>BufferedReader</code> or <code>BufferedWriter</code></p></td>&#13;
<td><p>Open a file for reading via a <code>BufferedReader</code>, or create and open a file for writing via a <code>BufferedWriter</code>. In both cases, a character encoding is specified.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>newByteChannel()</code></p></td>&#13;
<td><p><code>SeekableByteChannel</code></p></td>&#13;
<td><p>Create a new file or open an existing file as a seekable byte channel. (See the full discussion of NIO later in this chapter.) Consider using <code>FileChannel</code><code>open()</code> as an alternative.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>newDirectoryStream()</code></p></td>&#13;
<td><p><code>DirectoryStream</code></p></td>&#13;
<td><p>Return a <code>DirectoryStream</code> for iterating over a directory hierarchy. Optionally, supply a glob pattern or filter object to match files.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>newInputStream()</code>, <span class="keep-together"><code>newOutputStream()</code></span></p></td>&#13;
<td><p><code>InputStream</code> or <code>OutputStream</code></p></td>&#13;
<td><p>Open a file for reading via an <code>InputStream</code>, or create and open a file for writing via an <code>OutputStream</code>. Optionally, specify file truncation for the output stream; if overwriting, the default is to truncate the existing file.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>probeContentType()</code></p></td>&#13;
<td><p><code>String</code></p></td>&#13;
<td><p>Return the MIME type of the file if it can be determined by installed <code>FileTypeDetector</code> services or <code>null</code> if unknown.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>readAllBytes()</code>, <code>readAllLines()</code></p></td>&#13;
<td><p>byte[] or <code>List</code>&lt;<code>String</code>&gt;</p></td>&#13;
<td><p>Read all data from the file as a byte [] or all characters as a list of strings using a specified character encoding.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>size()</code></p></td>&#13;
<td><p>long</p></td>&#13;
<td><p>Get the size, in bytes, of the file at the specified path.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>walkFileTree()</code></p></td>&#13;
<td><p><code>Path</code></p></td>&#13;
<td><p>Apply a <code>FileVisitor</code> to the specified directory tree, optionally specifying whether to follow links and a maximum depth of traversal.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>write()</code></p></td>&#13;
<td><p><code>Path</code></p></td>&#13;
<td><p>Write an array of bytes or a collection of strings (with a specified character encoding) to the file at the specified path and close the file, optionally specifying append and truncation behavior. The default is to truncate and write the data.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>With these methods, we can fetch input or output streams, or buffered readers and writers, to a given file. We can also create paths as files and directories, and iterate through file hierarchies. We’ll discuss directory operations in the next section.<a data-primary="" data-startref="ix_method_files_class" data-type="indexterm" id="id2087"/></p>&#13;
&#13;
<p>As a <a data-primary="copy() method, NIO Files" data-type="indexterm" id="id2088"/><a data-primary="move() method, NIO Files" data-type="indexterm" id="id2089"/><a data-primary="resolve() method, Path" data-type="indexterm" id="id2090"/><a data-primary="resolveSibling() method, Path" data-type="indexterm" id="id2091"/>reminder, the <code>resolve()</code> and <code>resolveSibling()</code> methods of <code>Path</code> are useful for constructing targets for the <code>copy()</code> and <code>move()</code> operations:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="c1">// Move the file /tmp/foo.txt to /tmp/bar.txt</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">Path</code><code class="w"> </code><code class="n">foo</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">fs</code><code class="p">.</code><code class="na">getPath</code><code class="p">(</code><code class="s">"/tmp/foo.txt"</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">Files</code><code class="p">.</code><code class="na">move</code><code class="p">(</code><code class="n">foo</code><code class="p">,</code><code class="w"> </code><code class="n">foo</code><code class="p">.</code><code class="na">resolveSibling</code><code class="p">(</code><code class="s">"bar.txt"</code><code class="p">));</code><code class="w"/></pre>&#13;
&#13;
<p>For quickly reading and writing the contents of files without streaming, we can use the various <code>readAll…​</code> and <code>write</code> methods that move byte arrays or strings in and out of files in a single operation:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="c1">// Read and write collection of String (e.g., lines of text)</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">Charset</code><code class="w"> </code><code class="n">asciiCharset</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Charset</code><code class="p">.</code><code class="na">forName</code><code class="p">(</code><code class="s">"US-ASCII"</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code><code class="w"> </code><code class="n">csvData</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Files</code><code class="p">.</code><code class="na">readAllLines</code><code class="p">(</code><code class="n">csvPath</code><code class="p">,</code><code class="w"> </code><code class="n">asciiCharset</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">Files</code><code class="p">.</code><code class="na">write</code><code class="p">(</code><code class="n">newCSVPath</code><code class="p">,</code><code class="w"> </code><code class="n">csvData</code><code class="p">,</code><code class="w"> </code><code class="n">asciiCharset</code><code class="p">);</code><code class="w"/>&#13;
&#13;
<code class="w">    </code><code class="c1">// Read and write bytes</code><code class="w"/>&#13;
<code class="w">    </code><code class="kt">byte</code><code class="w"> </code><code class="o">[]</code><code class="w"> </code><code class="n">data</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Files</code><code class="p">.</code><code class="na">readAllBytes</code><code class="p">(</code><code class="n">dataPath</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">Files</code><code class="p">.</code><code class="na">write</code><code class="p">(</code><code class="n">newDataPath</code><code class="p">,</code><code class="w"> </code><code class="n">data</code><code class="p">);</code><code class="w"/></pre>&#13;
&#13;
<p>These are convenient for files that easily fit into memory.<a data-primary="" data-startref="ix_file_ops_nio" data-type="indexterm" id="id2092"/><a data-primary="" data-startref="ix_java_nio_files" data-type="indexterm" id="id2093"/><a data-primary="" data-startref="ix_nio_file_api_file_ops" data-type="indexterm" id="id2094"/><a data-primary="" data-startref="ix_files_class_nio" data-type="indexterm" id="id2095"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The NIO Package" data-type="sect1"><div class="sect1" id="learnjava6-CHP-10-SECT-3">&#13;
<h1>The NIO Package</h1>&#13;
&#13;
<p>Let’s <a data-primary="input/output (I/O)" data-secondary="java.nio package" data-type="indexterm" id="ix_io_nio_ch10"/><a data-primary="java.nio package" data-type="indexterm" id="ix_java_nio_pkg_ch10"/><a data-primary="java.io package" data-secondary="and NIO package" data-secondary-sortas="NIO package" data-type="indexterm" id="id2096"/>return to the <code>java.nio</code> package and round out our discussion of core Java I/O. One aspect of NIO is simply to update and enhance features of the classic <code>java.io</code> package. Much of the general NIO functionality does indeed overlap with existing APIs. However, NIO was first introduced to address specific issues of scalability for large systems, especially in networked applications. The following sections outline the basic elements of NIO.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Asynchronous I/O" data-type="sect2"><div class="sect2" id="learnjava6-CHP-10-SECT-3.1">&#13;
<h2>Asynchronous I/O</h2>&#13;
&#13;
<p>Most of the <a data-primary="java.nio package" data-secondary="asynchronous I/O" data-type="indexterm" id="id2097"/><a data-primary="asynchronous channels" data-type="indexterm" id="id2098"/><a data-primary="selectable I/O with NIO package" data-type="indexterm" id="id2099"/>need for the NIO package was driven by the desire to add <em>nonblocking</em> and <em>selectable</em> I/O to Java. <a data-primary="threads" data-secondary="and asynchronous I/O" data-secondary-sortas="asynchronous I/O" data-type="indexterm" id="id2100"/>Prior to NIO, most read and write operations in Java were bound to threads and were forced to block for unpredictable amounts of time. Although certain APIs, such as Sockets (which we’ll see in <a data-type="xref" href="ch13.html#learnjava6-CHP-13-SECT-5">“Sockets”</a>), provided specific means to limit how long an I/O call could take, this was a workaround to compensate for the lack of a more general mechanism. In many languages, even those without threading, I/O could still be done efficiently by setting I/O streams to a nonblocking mode and testing them for their readiness to send or receive data. In a nonblocking mode, a read or write does only as much work as can be done immediately—filling or emptying a buffer and then returning. Combined with the ability to test for readiness, this allows a single-threaded application to continuously service many channels efficiently. The main thread “selects” a channel that is ready, works with it until it blocks, and then moves on to another. On a single-processor system, this is fundamentally equivalent to using multiple threads.</p>&#13;
&#13;
<p>In addition to nonblocking and selectable I/O, the NIO package enables closing and interrupting I/O operations asynchronously. As discussed in <a data-type="xref" href="ch09.html#learnjava6-CHP-9">Chapter 9</a>, prior to NIO there was no reliable way to stop or wake up a thread blocked in an I/O operation. With NIO, threads blocked in I/O operations always wake up when interrupted or when another thread closes the channel. Additionally, if you interrupt a thread while it is blocked in an NIO operation, its channel is automatically closed. (Closing the channel because the thread is interrupted might seem too strong, but usually it’s the right thing to do. Leaving it open could result in unexpected behavior or subject the channel to unwanted manipulation.)</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Performance" data-type="sect2"><div class="sect2" id="learnjava6-CHP-10-SECT-3.2">&#13;
<h2>Performance</h2>&#13;
&#13;
<p>Channel I/O is <a data-primary="java.nio package" data-secondary="performance" data-type="indexterm" id="id2101"/><a data-primary="performance" data-secondary="NIO package" data-type="indexterm" id="id2102"/><a data-primary="buffers" data-type="indexterm" id="ix_buffers_ch10"/><a data-primary="channels" data-secondary="buffers" data-type="indexterm" id="id2103"/><a data-primary="direct buffers, NIO package" data-type="indexterm" id="id2104"/>designed around the concept of buffers, which are a sophisticated form of array, tailored to communication tasks. The NIO package supports the concept of <em>direct buffers</em>—buffers that maintain their memory outside the Java VM in the host operating system. Because all real I/O operations ultimately have to work with the host OS by maintaining the buffer space there, using direct buffers can make many operations more efficient. Data moving between two external endpoints can be transferred without first copying it into Java and back out.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Mapped and Locked Files" data-type="sect2"><div class="sect2" id="learnjava6-CHP-10-SECT-3.3">&#13;
<h2>Mapped and Locked Files</h2>&#13;
&#13;
<p>NIO provides two <a data-primary="locking files, NIO package" data-type="indexterm" id="id2105"/><a data-primary="mapped files, NIO package" data-type="indexterm" id="id2106"/><a data-primary="MappedByteBuffer class" data-type="indexterm" id="id2107"/><a data-primary="file locking, NIO package" data-type="indexterm" id="id2108"/><a data-primary="java.nio package" data-secondary="mapped and locked files" data-type="indexterm" id="id2109"/><a data-primary="memory-mapped files, NIO package" data-type="indexterm" id="id2110"/>general-purpose file-related features not found in <code>java.io</code>: memory-mapped files and file locking. A <em>memory-mapped</em> file behaves as if all of its content is in an array in memory rather than on a disk. Memory-mapped files are beyond the scope of this chapter, but if you work with lots of data and occasionally need really fast read/write access, look up the <a href="https://oreil.ly/yNLMn"><code>MappedByteBuffer</code> documentation</a> online.</p>&#13;
&#13;
<p>File locking supports both shared and exclusive locks on regions of files—useful for concurrent access by multiple applications. We’ll look at file locking in <a data-type="xref" href="#learnjava6-CHP-10-SECT-3.7.2">“File locking”</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Channels" data-type="sect2"><div class="sect2" id="learnjava6-CHP-10-SECT-3.4">&#13;
<h2>Channels</h2>&#13;
&#13;
<p>While <code>java.io</code> deals with <a data-primary="java.nio package" data-secondary="channels" data-type="indexterm" id="id2111"/><a data-primary="channels" data-secondary="NIO package" data-type="indexterm" id="id2112"/>streams, <code>java.nio</code> works with channels. A <em>channel</em> is an endpoint for communication. Although in practice channels are similar to streams, the underlying notion of a channel is simultaneously more abstract and more primitive. Whereas streams in <code>java.io</code> are defined in terms of input or output with methods to read and write bytes, the basic channel interface says nothing about how communications happen. <a data-primary="close() method" data-secondary="channels in NIO package" data-type="indexterm" id="id2113"/><a data-primary="isOpen() method, channels in NIO package" data-type="indexterm" id="id2114"/>It simply has the notion of being open or closed, supported via the methods <code>isOpen()</code> and <code>close()</code>. Implementations of channels for files, network sockets, or arbitrary devices then add their own methods for operations, such as reading, writing, or transferring data. <a data-primary="DatagramChannel" data-type="indexterm" id="id2115"/><a data-primary="FileChannel" data-type="indexterm" id="id2116"/><a data-primary="Pipe.SinkChannel" data-type="indexterm" id="id2117"/><a data-primary="Pipe.SourceChannel" data-type="indexterm" id="id2118"/><a data-primary="ServerSocketChannel" data-type="indexterm" id="id2119"/><a data-primary="SocketChannel" data-type="indexterm" id="id2120"/>NIO provides the following channels:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>FileChannel</code></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<ul class="less_space pagebreak-before">&#13;
<li>&#13;
<p><code>Pipe.SinkChannel</code>, <code>Pipe.SourceChannel</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>SocketChannel</code>, <code>ServerSocketChannel</code>, <code>DatagramChannel</code></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>We’ll cover <code>FileChannel</code> and its <a data-primary="java.nio.file package" data-secondary="FileChannel" data-type="indexterm" id="id2121"/><a data-primary="channels" data-secondary="FileChannel" data-type="indexterm" id="id2122"/><a data-primary="asynchronous channels" data-type="indexterm" id="id2123"/><a data-primary="AsynchronousFileChannel" data-type="indexterm" id="id2124"/>asynchronous cousin, <code>AsynchronousFileChannel</code>, in <a data-type="xref" href="#learnjava6-CHP-10-SECT-3.7">“FileChannel”</a>. (The asynchronous version essentially buffers all of its operations through a thread pool and reports results back through an asynchronous API.) The <code>Pipe</code> channels are simply the channel equivalents of the <code>java.io Pipe</code> facilities. The socket and datagram channels play in Java’s networking world, which we’ll look at in <a data-type="xref" href="ch13.html#learnjava6-CHP-13">Chapter 13</a>. The network-related channels have asynchronous versions as well: <code>AsynchronousSocketChannel</code>, <code>AsynchronousServerSocketChannel</code>, and <code>AsynchronousDatagramChannel</code>.</p>&#13;
&#13;
<p>All these <a data-primary="java.nio package" data-secondary="ByteChannel" data-type="indexterm" id="id2125"/><a data-primary="ByteBuffer class" data-type="indexterm" id="ix_byte_buffer"/><a data-primary="arrays" data-secondary="versus buffers" data-secondary-sortas="buffers" data-type="indexterm" id="id2126"/><a data-primary="ByteChannel interface" data-type="indexterm" id="id2127"/>basic channels implement the <code>ByteChannel</code> interface, designed for channels that have read and write methods like I/O streams. <code>ByteChannel</code>s, however, read and write <code>ByteBuffer</code>s, as opposed to plain byte arrays.</p>&#13;
&#13;
<p>In addition to these channel implementations, you can bridge channels with <code>java.io</code> I/O streams and readers and writers for interoperability. However, if you mix these features, you may not get the full benefits and performance NIO offers.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Buffers" data-type="sect2"><div class="sect2" id="learnjava6-CHP-10-SECT-3.5">&#13;
<h2>Buffers</h2>&#13;
&#13;
<p>Most of the <a data-primary="java.nio package" data-secondary="buffers" data-type="indexterm" id="ix_java_nio_buffer"/><a data-primary="byte arrays" data-type="indexterm" id="ix_byte_array"/>utilities of the <code>java.io</code> and <code>java.net</code> packages operate on byte arrays. The corresponding tools of the NIO package are built around <code>ByteBuffer</code>s (with a character-based buffer, <code>CharBuffer</code>, for text). Byte arrays are simple, so why are buffers necessary? They serve several purposes:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>They <a data-primary="BufferedInputStream class" data-type="indexterm" id="id2128"/>formalize the usage patterns for buffered data, provide for things like read-only buffers, and keep track of read/write positions and limits within a <span class="keep-together">large buffer</span> space. They also provide a mark/reset facility like that of <code>java.io​.BufferedInputStream</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>They provide additional APIs for working with raw data representing primitive types. You can create buffers that “view” your byte data as a series of larger primitives, such as <code>short</code>s, <code>int</code>s, or <code>float</code>s. The most general type of data buffer, <code>ByteBuffer</code>, includes methods that let you read and write all primitive types just like  <code>DataInputStream</code> and <code>DataOutputStream</code> do for streams.</p>&#13;
</li>&#13;
<li>&#13;
<p>They <a data-primary="java.nio.file package" data-secondary="Channel facilities" data-type="indexterm" id="id2129"/><a data-primary="Channel facilities" data-type="indexterm" id="id2130"/>abstract the underlying storage of the data, allowing Java to optimize throughput. Specifically, buffers may be allocated as direct buffers that use native buffers of the host operating system instead of arrays in Java’s memory. The NIO <code>Channel</code> facilities that work with buffers can recognize direct buffers automatically and try to optimize their interactions with them. For example, a read from a file channel into a Java byte array normally requires Java to copy the data for the read from the host operating system into Java’s memory. With a direct buffer, the data can remain in the host operating system, outside Java’s normal memory space, until and unless it is needed.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Buffer operations" data-type="sect3"><div class="sect3" id="learnjava6-CHP-10-SECT-3.5.1">&#13;
<h3>Buffer operations</h3>&#13;
&#13;
<p>The base <code>java.nio.Buffer</code> class is <a data-primary="Buffer class" data-type="indexterm" id="id2131"/>something like an array with state. It does not specify what type of elements it holds (that is for subtypes to decide), but it does define functionality that is common to all data buffers. A <code>Buffer</code> has a fixed size, called its <em>capacity</em>. Although all the standard <code>Buffer</code>s provide “random access” to their contents, a <code>Buffer</code> generally expects to be read and written sequentially, so <code>Buffer</code>s maintain the notion of a <em>position</em> where the next element is read or written. In addition to position, a <code>Buffer</code> can maintain two other pieces of state information: a <em>limit</em>, which typically denotes the available data in read mode and the capacity of the file in write mode, and a <em>mark</em>, which can be used to remember an earlier position for future recall.</p>&#13;
&#13;
<p>Implementations of <code>Buffer</code> add specific, <a data-primary="get() method" data-secondary="ByteBuffer" data-type="indexterm" id="id2132"/><a data-primary="put() method" data-secondary="ByteBuffer" data-type="indexterm" id="id2133"/>typed get and put methods that read and write the buffer contents. For example, <code>ByteBuffer</code> is a buffer of bytes and it has <code>get()</code> and <code>put()</code> methods that read and write bytes and arrays of bytes (along with many other useful methods we’ll discuss later). Getting from and putting to the <code>Buffer</code> changes the position marker, so the <code>Buffer</code> keeps track of its contents somewhat like a stream. <a data-primary="BufferOverflowException" data-type="indexterm" id="id2134"/><a data-primary="BufferUnderflowException" data-type="indexterm" id="id2135"/>Attempting to read or write past the limit marker generates a <code>BufferUnderflowException</code> or <code>BufferOverflowException</code>, respectively.</p>&#13;
&#13;
<p>The mark, position, limit, and capacity values always obey the following formula:</p>&#13;
&#13;
<pre data-type="programlisting">    mark &lt;= position &lt;= limit &lt;= capacity</pre>&#13;
&#13;
<p>The position for reading and writing the <code>Buffer</code> is always between the mark, which serves as a lower bound, and the limit, which serves as an upper bound. The capacity represents the physical extent of the buffer space.</p>&#13;
&#13;
<p>You can set the <a data-primary="methods" data-secondary="ByteBuffer" data-type="indexterm" id="id2136"/><a data-primary="position() method, ByteBuffer" data-type="indexterm" id="id2137"/><a data-primary="reset() method" data-secondary="ByteBuffer" data-type="indexterm" id="id2138"/><a data-primary="limit() method" data-secondary="ByteBuffer" data-type="indexterm" id="id2139"/><a data-primary="clear() method, ByteBuffer" data-type="indexterm" id="id2140"/>position and limit markers explicitly with the <code>position()</code> and <code>limit()</code> methods. Several <a data-primary="convenience methods" data-type="indexterm" id="id2141"/>convenience methods are provided for common usage patterns. The <code>reset()</code> method sets the position back to the mark. If no mark has been set, an <code>InvalidMarkException</code> is thrown. The <code>clear()</code> method resets the position to <code>0</code> and makes the limit the capacity, readying the buffer for new data (the mark is discarded). Note that the <code>clear()</code> method does not actually do anything to the data in the buffer; it simply changes the position markers.</p>&#13;
&#13;
<p>The <code>flip()</code> method is used for the <a data-primary="flip() method, ByteBuffer" data-type="indexterm" id="id2142"/><a data-primary="rewind() method, ByteBuffer" data-type="indexterm" id="id2143"/>common pattern of writing data into the buffer and then reading it back out. <code>flip</code> makes the current position the limit and then resets the current position to <code>0</code> (any mark is thrown away), which saves having to keep track of how much data was read. Another method, <code>rewind()</code>, simply resets the position to <code>0</code>, leaving the limit alone. You might use it to write the same size of data again. Here is a snippet of code that uses these methods to read data from a channel and write it to two channels:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">ByteBuffer</code><code class="w"> </code><code class="n">buff</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">...</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">while</code><code class="w"> </code><code class="p">(</code><code class="n">inChannel</code><code class="p">.</code><code class="na">read</code><code class="p">(</code><code class="n">buff</code><code class="p">)</code><code class="w"> </code><code class="o">&gt;</code><code class="w"> </code><code class="mi">0</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="c1">// position = ?</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">buff</code><code class="p">.</code><code class="na">flip</code><code class="p">();</code><code class="w">    </code><code class="c1">// limit = position; position = 0;</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">outChannel</code><code class="p">.</code><code class="na">write</code><code class="p">(</code><code class="n">buff</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">buff</code><code class="p">.</code><code class="na">rewind</code><code class="p">();</code><code class="w">  </code><code class="c1">// position = 0</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">outChannel2</code><code class="p">.</code><code class="na">write</code><code class="p">(</code><code class="n">buff</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">buff</code><code class="p">.</code><code class="na">clear</code><code class="p">();</code><code class="w">   </code><code class="c1">// position = 0; limit = capacity</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>This might be confusing the first time you look at it because here, the read from the <code>Channel</code> is actually a write to the <code>Buffer</code> and vice versa. Because this example writes all the available data up to the limit, either <code>flip()</code> or <code>rewind()</code> have the same effect in this case.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Buffer types" data-type="sect3"><div class="sect3" id="learnjava6-CHP-10-SECT-3.5.2">&#13;
<h3>Buffer types</h3>&#13;
&#13;
<p>The various buffer implementations add get and put methods for reading and writing specific data types. Each of the Java primitive types has an associated buffer type: <code>ByteBuffer</code>, <code>CharBuffer</code>, <code>ShortBuffer</code>, <code>IntBuffer</code>, <code>LongBuffer</code>, <code>FloatBuffer</code>, and <code>DoubleBuffer</code>. Each provides get and put methods for reading and writing its type and arrays of its type. Of these, <code>ByteBuffer</code> is the most flexible. Because it has the “finest grain” of all the buffers, it has been given a full complement of get and put methods for reading and writing all the other data types as well as <code>byte</code>. Here are some <code>ByteBuffer</code> methods:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="kt">byte</code><code class="w"> </code><code class="nf">get</code><code class="p">()</code><code class="w"/>&#13;
<code class="w">    </code><code class="kt">char</code><code class="w"> </code><code class="nf">getChar</code><code class="p">()</code><code class="w"/>&#13;
<code class="w">    </code><code class="kt">short</code><code class="w"> </code><code class="nf">getShort</code><code class="p">()</code><code class="w"/>&#13;
<code class="w">    </code><code class="kt">int</code><code class="w"> </code><code class="nf">getInt</code><code class="p">()</code><code class="w"/>&#13;
<code class="w">    </code><code class="kt">long</code><code class="w"> </code><code class="nf">getLong</code><code class="p">()</code><code class="w"/>&#13;
<code class="w">    </code><code class="kt">float</code><code class="w"> </code><code class="nf">getFloat</code><code class="p">()</code><code class="w"/>&#13;
<code class="w">    </code><code class="kt">double</code><code class="w"> </code><code class="nf">getDouble</code><code class="p">()</code><code class="w"/>&#13;
&#13;
<code class="w">    </code><code class="kt">void</code><code class="w"> </code><code class="nf">put</code><code class="p">(</code><code class="kt">byte</code><code class="w"> </code><code class="n">b</code><code class="p">)</code><code class="w"/>&#13;
<code class="w">    </code><code class="kt">void</code><code class="w"> </code><code class="nf">put</code><code class="p">(</code><code class="n">ByteBuffer</code><code class="w"> </code><code class="n">src</code><code class="p">)</code><code class="w"/>&#13;
<code class="w">    </code><code class="kt">void</code><code class="w"> </code><code class="nf">put</code><code class="p">(</code><code class="kt">byte</code><code class="o">[]</code><code class="w"> </code><code class="n">src</code><code class="p">,</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">offset</code><code class="p">,</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">length</code><code class="p">)</code><code class="w"/>&#13;
<code class="w">    </code><code class="kt">void</code><code class="w"> </code><code class="nf">put</code><code class="p">(</code><code class="kt">byte</code><code class="o">[]</code><code class="w"> </code><code class="n">src</code><code class="p">)</code><code class="w"/>&#13;
<code class="w">    </code><code class="kt">void</code><code class="w"> </code><code class="nf">putChar</code><code class="p">(</code><code class="kt">char</code><code class="w"> </code><code class="n">value</code><code class="p">)</code><code class="w"/>&#13;
<code class="w">    </code><code class="kt">void</code><code class="w"> </code><code class="nf">putShort</code><code class="p">(</code><code class="kt">short</code><code class="w"> </code><code class="n">value</code><code class="p">)</code><code class="w"/>&#13;
<code class="w">    </code><code class="kt">void</code><code class="w"> </code><code class="nf">putInt</code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">value</code><code class="p">)</code><code class="w"/>&#13;
<code class="w">    </code><code class="kt">void</code><code class="w"> </code><code class="nf">putLong</code><code class="p">(</code><code class="kt">long</code><code class="w"> </code><code class="n">value</code><code class="p">)</code><code class="w"/>&#13;
<code class="w">    </code><code class="kt">void</code><code class="w"> </code><code class="nf">putFloat</code><code class="p">(</code><code class="kt">float</code><code class="w"> </code><code class="n">value</code><code class="p">)</code><code class="w"/>&#13;
<code class="w">    </code><code class="kt">void</code><code class="w"> </code><code class="nf">putDouble</code><code class="p">(</code><code class="kt">double</code><code class="w"> </code><code class="n">value</code><code class="p">)</code><code class="w"/></pre>&#13;
&#13;
<p>All the standard buffers also support random access. For each of the aforementioned methods of <code>ByteBuffer</code>, an additional form takes an index, for example:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">getLong</code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">index</code><code class="p">)</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">putLong</code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">index</code><code class="p">,</code><code class="w"> </code><code class="kt">long</code><code class="w"> </code><code class="n">value</code><code class="p">)</code><code class="w"/></pre>&#13;
&#13;
<p>But that’s not all! <code>ByteBuffer</code> can also <a data-primary="ShortBuffer view" data-type="indexterm" id="id2144"/>provide “views” of itself as any of the coarse-grained types. For example, you can fetch a <code>ShortBuffer</code> view of a <code>ByteBuffer</code> with the <code>asShortBuffer()</code> method. The <code>ShortBuffer</code> view is <em>backed</em> by the <code>ByteBuffer</code>, which means that they work on the same data, and changes to either one affect the other. The view buffer’s extent starts at the <code>ByteBuffer</code>’s current position, and its capacity is a function of the remaining number of bytes, divided by the new type’s size. (For example, <code>short</code>s consume two bytes each, <code>float</code>s four, and <code>long</code>s and <code>double</code>s take eight.) View buffers are convenient for reading and writing large blocks of a contiguous type within a <code>ByteBuffer</code>.</p>&#13;
&#13;
<p><code>CharBuffer</code>s are <a data-primary="String class" data-secondary="and CharBuffer" data-secondary-sortas="CharBuffer" data-type="indexterm" id="id2145"/><a data-primary="CharBuffer" data-type="indexterm" id="id2146"/>interesting as well, primarily because of their integration with <code>String</code>s. Both <code>CharBuffer</code>s and <code>String</code>s implement the <code>java.lang.CharSequence</code> interface. This is the interface that provides the standard <code>charAt()</code> and <code>length()</code> methods. Many other parts of Java (such as the <code>java.util.regex</code> package) allow you to use a <code>CharBuffer</code> or a <code>String</code> interchangeably. In this case, the <code>CharBuffer</code> acts like a modifiable <code>String</code> with user-configurable, logical start and end positions.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Byte order" data-type="sect3"><div class="sect3" id="learnjava6-CHP-10-SECT-3.5.3">&#13;
<h3>Byte order</h3>&#13;
&#13;
<p>Because we’re <a data-primary="byte order" data-type="indexterm" id="id2147"/><a data-primary="big-endian and little-endian approaches to byte order" data-type="indexterm" id="id2148"/><a data-primary="little-endian and big-endian approaches to byte order" data-type="indexterm" id="id2149"/>talking about reading and writing types larger than a byte, the question arises: in what order do the bytes of multibyte values (like <code>short</code>s and <code>int</code>s) get written? There are two camps in this world: <em>big-endian</em> and <em>little-endian</em>.<sup><a data-type="noteref" href="ch10.html#id2150" id="id2150-marker">5</a></sup> Big-endian means that the most significant bytes come first; little-endian is the reverse. If you’re writing binary data for consumption by some native application, this is important. Intel-compatible computers use little-endian, and many workstations that run Unix use big-endian. The <code>ByteOrder</code> class encapsulates the choice. You can specify the byte order to use with the <code>ByteBuffer order()</code> method, using the identifiers <code>ByteOrder.BIG_ENDIAN</code> and <code>ByteOrder.LITTLE_ENDIAN</code>, like so:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">byteArray</code><code class="p">.</code><code class="na">order</code><code class="p">(</code><code class="n">ByteOrder</code><code class="p">.</code><code class="na">BIG_ENDIAN</code><code class="p">);</code><code class="w"/></pre>&#13;
&#13;
<p>You can <a data-primary="nativeOrder() method, ByteOrder" data-type="indexterm" id="id2151"/>retrieve the native ordering for your platform using the static &#13;
<span class="keep-together"><code>ByteOrder.nativeOrder()</code></span> method. We know you’re curious:</p>&#13;
&#13;
<pre class="jshell" data-type="programlisting">jshell&gt; import java.nio.ByteOrder;&#13;
&#13;
jshell&gt; ByteOrder.nativeOrder()&#13;
$4 ==&gt; LITTLE_ENDIAN</pre>&#13;
&#13;
<p>We ran this on a Linux desktop with an Intel chip. Give it a try on your own system!</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Allocating buffers" data-type="sect3"><div class="sect3" id="learnjava6-CHP-10-SECT-3.5.4">&#13;
<h3>Allocating buffers</h3>&#13;
&#13;
<p>You can <a data-primary="allocate() method, Buffer" data-type="indexterm" id="id2152"/><a data-primary="wrap() method, Buffer" data-type="indexterm" id="id2153"/>create a buffer either by allocating it explicitly using <code>allocate()</code> or by wrapping an existing plain Java array type. Each buffer type has a static <code>allocate()</code> method that takes a capacity (size), and a <code>wrap()</code> method that takes an existing array:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">CharBuffer</code><code class="w"> </code><code class="n">cbuf</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">CharBuffer</code><code class="p">.</code><code class="na">allocate</code><code class="p">(</code><code class="mi">64</code><code class="o">*</code><code class="mi">1024</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">ByteBuffer</code><code class="w"> </code><code class="n">bbuf</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">ByteBuffer</code><code class="p">.</code><code class="na">wrap</code><code class="p">(</code><code class="n">someExistingArray</code><code class="p">);</code><code class="w"/></pre>&#13;
&#13;
<p>A direct buffer is allocated in the same way, with the <code>allocateDirect()</code> method:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">ByteBuffer</code><code class="w"> </code><code class="n">bbuf2</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">ByteBuffer</code><code class="p">.</code><code class="na">allocateDirect</code><code class="p">(</code><code class="mi">64</code><code class="o">*</code><code class="mi">1024</code><code class="p">);</code><code class="w"/></pre>&#13;
&#13;
<p>As we described earlier, direct buffers can use operating system memory structures that are optimized for use with some kinds of I/O operations. The trade-off is that allocating a direct buffer is a little slower and heavier-weight operation than a plain buffer, so you should try to use them for longer-term buffers.<a data-primary="" data-startref="ix_buffers_ch10" data-type="indexterm" id="id2154"/><a data-primary="" data-startref="ix_byte_array" data-type="indexterm" id="id2155"/><a data-primary="" data-startref="ix_java_nio_buffer" data-type="indexterm" id="id2156"/><a data-primary="" data-startref="ix_byte_buffer" data-type="indexterm" id="id2157"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Character Encoders and Decoders" data-type="sect2"><div class="sect2" id="learnjava6-CHP-10-SECT-3.6">&#13;
<h2>Character Encoders and Decoders</h2>&#13;
&#13;
<p>Character <a data-primary="java.nio.charset package" data-type="indexterm" id="id2158"/><a data-primary="java.nio package" data-secondary="character encoders" data-type="indexterm" id="ix_nio_char_enc"/><a data-primary="character encoding" data-secondary="NIO package" data-type="indexterm" id="ix_char_enc_nio"/>encoders and decoders turn characters into raw bytes and vice versa, mapping from the Unicode standard to particular encoding schemes. Encoders and decoders have long existed in Java for use by <code>Reader</code> and <code>Writer</code> streams and in the methods of the <code>String</code> class that work with byte arrays. However, early on there was no API for working with encoding explicitly; you simply referred to encoders and decoders wherever necessary by name as a <code>String</code>. The <code>java.nio.charset</code> package formalized the idea of a Unicode character set encoding with the <code>Charset</code> class.</p>&#13;
&#13;
<p>The <code>Charset</code> class is a <a data-primary="Charset class" data-type="indexterm" id="id2159"/><a data-primary="forName() method, Charset" data-type="indexterm" id="id2160"/>factory for <code>Charset</code> instances, which know how to encode character buffers to byte buffers and decode byte buffers to character buffers. You can look up a character set by name with the static <code>Charset.forName()</code> method and use it in conversions:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">Charset</code><code class="w"> </code><code class="n">charset</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Charset</code><code class="p">.</code><code class="na">forName</code><code class="p">(</code><code class="s">"US-ASCII"</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">CharBuffer</code><code class="w"> </code><code class="n">charBuff</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">charset</code><code class="p">.</code><code class="na">decode</code><code class="p">(</code><code class="n">byteBuff</code><code class="p">);</code><code class="w">  </code><code class="c1">// to ascii</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">ByteBuffer</code><code class="w"> </code><code class="n">byteBuff</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">charset</code><code class="p">.</code><code class="na">encode</code><code class="p">(</code><code class="n">charBuff</code><code class="p">);</code><code class="w">  </code><code class="c1">// and back</code><code class="w"/></pre>&#13;
&#13;
<p>You can also <a data-primary="isSupported() method, Charset" data-type="indexterm" id="id2161"/>test to see if an encoding is available with the static <code>Charset.isSupported()</code> method.</p>&#13;
&#13;
<p>The following character sets are guaranteed to be supplied:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>US-ASCII</p>&#13;
</li>&#13;
<li>&#13;
<p>ISO-8859-1</p>&#13;
</li>&#13;
<li>&#13;
<p>UTF-8</p>&#13;
</li>&#13;
<li>&#13;
<p>UTF-16BE (big-endian)</p>&#13;
</li>&#13;
<li>&#13;
<p>UTF-16LE (little-endian)</p>&#13;
</li>&#13;
<li>&#13;
<p>UTF-16</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>You can <a data-primary="availableCharsets() method" data-type="indexterm" id="id2162"/>list all the encoders available on your platform using the static <code>availableCharsets()</code> method:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">Map</code><code class="w"> </code><code class="n">map</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Charset</code><code class="p">.</code><code class="na">availableCharsets</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">Iterator</code><code class="w"> </code><code class="n">it</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">map</code><code class="p">.</code><code class="na">keySet</code><code class="p">().</code><code class="na">iterator</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">while</code><code class="w"> </code><code class="p">(</code><code class="n">it</code><code class="p">.</code><code class="na">hasNext</code><code class="p">())</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">it</code><code class="p">.</code><code class="na">next</code><code class="p">());</code><code class="w"/></pre>&#13;
&#13;
<p>The result of <code>availableCharsets()</code> is a map, because character sets may have “aliases” and appear under more than one name.</p>&#13;
&#13;
<p>In addition to the buffer-oriented classes of the <code>java.nio</code> package, the <code>InputStreamReader</code> and <code>OutputStreamWriter</code> bridge classes of the <code>java.io</code> package work with <code>Charset</code> as well. You can specify the encoding as a <code>Charset</code> object or by name.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="CharsetEncoder and CharsetDecoder" data-type="sect3"><div class="sect3" id="learnjava6-CHP-10-SECT-3.6.1">&#13;
<h3>CharsetEncoder and CharsetDecoder</h3>&#13;
&#13;
<p>You can get <a data-primary="CharsetDecoder" data-type="indexterm" id="id2163"/><a data-primary="CharsetEncoder" data-type="indexterm" id="id2164"/><a data-primary="decode() method, Charset" data-type="indexterm" id="id2165"/><a data-primary="encode() method" data-secondary="Charset" data-type="indexterm" id="id2166"/><a data-primary="newDecoder() method, Charset" data-type="indexterm" id="id2167"/><a data-primary="newEncoder() method, Charset" data-type="indexterm" id="id2168"/>more control over the encoding and decoding process by creating an instance of <code>CharsetEncoder</code> or <code>CharsetDecoder</code> (a codec) with the <code>Charset newEncoder()</code> and <code>newDecoder()</code> methods. In the previous snippet, we assumed that all the data was available in a single buffer. More often, however, we might have to process data as it arrives in chunks. The encoder/decoder API allows for this by providing more general <code>encode()</code> and <code>decode()</code> methods that take a flag specifying whether more data is expected. The codec needs to know this because it might have been left hanging in the middle of a multibyte character conversion when the data ran out. If it knows that more data is coming, it does not throw an error on this incomplete conversion.</p>&#13;
&#13;
<p>In the following snippet, we use a decoder to read from a <code>ByteBuffer bbuff</code> and accumulate character data into a <code>CharBuffer cbuff</code>:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">CharsetDecoder</code><code class="w"> </code><code class="n">decoder</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Charset</code><code class="p">.</code><code class="na">forName</code><code class="p">(</code><code class="s">"US-ASCII"</code><code class="p">).</code><code class="na">newDecoder</code><code class="p">();</code><code class="w"/>&#13;
&#13;
<code class="w">    </code><code class="kt">boolean</code><code class="w"> </code><code class="n">done</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="kc">false</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">while</code><code class="w"> </code><code class="p">(</code><code class="o">!</code><code class="n">done</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">bbuff</code><code class="p">.</code><code class="na">clear</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">done</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="n">in</code><code class="p">.</code><code class="na">read</code><code class="p">(</code><code class="n">bbuff</code><code class="p">)</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="o">-</code><code class="mi">1</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">bbuff</code><code class="p">.</code><code class="na">flip</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">decoder</code><code class="p">.</code><code class="na">decode</code><code class="p">(</code><code class="n">bbuff</code><code class="p">,</code><code class="w"> </code><code class="n">cbuff</code><code class="p">,</code><code class="w"> </code><code class="n">done</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">cbuff</code><code class="p">.</code><code class="na">flip</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">// use cbuff. . .</code><code class="w"/></pre>&#13;
&#13;
<p>Here, we <a data-primary="ByteBuffer class" data-type="indexterm" id="id2169"/><a data-primary="flip() method, ByteBuffer" data-type="indexterm" id="id2170"/>look for the end of input condition on the <code>in</code> channel to set the flag <code>done</code>. Note that we take advantage of the <code>flip()</code> method on <code>ByteBuffer</code> to set the limit to the amount of data read and reset the position, setting us up for the decode operation in one step. In case of problems, both <code>encode()</code> and <code>decode()</code> return a result object, <code>CoderResult</code>, that can determine the progress of encoding. The methods <code>isError()</code>, <code>isUnderflow()</code>, and <code>isOverflow()</code> on the <code>CoderResult</code> specify why encoding stopped: for an error, a lack of bytes on the input buffer, or a full output buffer, respectively.<a data-primary="" data-startref="ix_char_enc_nio" data-type="indexterm" id="id2171"/><a data-primary="" data-startref="ix_nio_char_enc" data-type="indexterm" id="id2172"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="FileChannel" data-type="sect2"><div class="sect2" id="learnjava6-CHP-10-SECT-3.7">&#13;
<h2>FileChannel</h2>&#13;
&#13;
<p>Now that we’ve <a data-primary="java.nio.file package" data-secondary="FileChannel" data-type="indexterm" id="ix_java_nio_file_fchan"/><a data-primary="FileChannel" data-type="indexterm" id="ix_file_chan"/><a data-primary="channels" data-secondary="FileChannel" data-type="indexterm" id="ix_chan_file_chan"/><a data-primary="RandomAccessFile class" data-type="indexterm" id="id2173"/><a data-primary="java.io package" data-secondary="RandomAccessFile class" data-type="indexterm" id="id2174"/>covered the basics of channels and buffers, it’s time to look at a real channel type. The <code>FileChannel</code> is the NIO equivalent of the <code>java.io.RandomAccessFile</code>, but it provides several enhanced features in addition to some performance optimizations. In particular, you can use a <code>FileChannel</code> in place of a plain <code>java.io</code> file stream if you wish to use file locking, memory-mapped file access, or highly optimized data transfer between files or between file and network channels. These are all fairly advanced use cases, but if you do backend work or handle large quantities of data, they will definitely come in handy.</p>&#13;
&#13;
<p>You can <a data-primary="open() method, FileChannel" data-type="indexterm" id="id2175"/>create a <code>FileChannel</code> for a <code>Path</code> using the static <code>FileChannel.open()</code> method:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">FileSystem</code><code class="w"> </code><code class="n">fs</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">FileSystems</code><code class="p">.</code><code class="na">getDefault</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">Path</code><code class="w"> </code><code class="n">p</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">fs</code><code class="p">.</code><code class="na">getPath</code><code class="p">(</code><code class="s">"/tmp/foo.txt"</code><code class="p">);</code><code class="w"/>&#13;
&#13;
<code class="w">    </code><code class="c1">// Open default for reading</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">try</code><code class="w"> </code><code class="p">(</code><code class="n">FileChannel</code><code class="w"> </code><code class="n">channel</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">FileChannel</code><code class="p">.</code><code class="na">open</code><code class="p">(</code><code class="n">p</code><code class="p">))</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="c1">// read from the channel ...</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/>&#13;
&#13;
<code class="w">    </code><code class="c1">// Open with options for writing</code><code class="w"/>&#13;
<code class="w">    </code><code class="kn">import static</code><code class="w"> </code><code class="nn">java.nio.file.StandardOpenOption.*</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="w">    </code><code class="k">try</code><code class="w"> </code><code class="p">(</code><code class="n">FileChannel</code><code class="w"> </code><code class="n">channel</code><code class="w"> </code><code class="o">=</code><code class="w"/>&#13;
<code class="w">        </code><code class="n">FileChannel</code><code class="p">.</code><code class="na">open</code><code class="p">(</code><code class="n">p</code><code class="p">,</code><code class="w"> </code><code class="n">WRITE</code><code class="p">,</code><code class="w"> </code><code class="n">APPEND</code><code class="p">,</code><code class="w"> </code><code class="p">...)</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="c1">// append to foo.txt if it already exists,</code><code class="w"/>&#13;
<code class="w">      </code><code class="c1">// otherwise, create it and start writing ...</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>By default, <code>open()</code> creates a read-only channel for the file. We can open a <a data-primary="java.nio package" data-secondary="StandardOpenOption" data-type="indexterm" id="id2176"/>channel for writing or appending and control other, more advanced features such as atomic create and data syncing by passing additional options, as shown in the second part of the previous example. <a data-type="xref" href="#learnjava6-CHP-10-TABLE-3">Table 10-3</a> summarizes these options.</p>&#13;
<table id="learnjava6-CHP-10-TABLE-3">&#13;
<caption><span class="label">Table 10-3. </span><code>java.nio.file.StandardOpenOption</code></caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Option</th>&#13;
<th>Description</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p><code>APPEND</code></p></td>&#13;
<td><p>Open the file for writing; all writes are positioned at the end of the file.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>CREATE</code></p></td>&#13;
<td><p>Use with <code>WRITE</code> to open the file and create it if needed.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>CREATE_NEW</code></p></td>&#13;
<td><p>Use with <code>WRITE</code> to create a file atomically; failing if the file already exists.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>DELETE_ON_CLOSE</code></p></td>&#13;
<td><p>Attempt to delete the file when it is closed or, if open, when the VM exits.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>READ</code>, <code>WRITE</code></p></td>&#13;
<td><p>Open the file for read-only or write-only (default is read-only). Use both for read-write.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>SPARSE</code></p></td>&#13;
<td><p>Use when creating a new file; requests the file be sparse. On filesystems where this is supported, a sparse file handles very large, mostly empty files without allocating as much real storage for empty portions.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>SYNC</code>, <code>DSYNC</code></p></td>&#13;
<td><p>Wherever possible, guarantee that write operations block until all data is written to storage. <code>SYNC</code> does this for all file changes including data and metadata (attributes), whereas <code>DSYNC</code> adds this requirement only for the data content of the file.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>TRUNCATE_EXISTING</code></p></td>&#13;
<td><p>Use <code>WRITE</code> on an existing file; set the file length to zero upon opening it.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>A <code>FileChannel</code> can also be <a data-primary="FileInputStream class" data-type="indexterm" id="id2177"/><a data-primary="FileOutputStream class" data-type="indexterm" id="id2178"/>constructed from a classic <code>FileInputStream</code>, <code>FileOutputStream</code>, or <code>RandomAccessFile</code>:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">FileChannel</code><code class="w"> </code><code class="n">readOnlyFc</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">FileInputStream</code><code class="p">(</code><code class="s">"file.txt"</code><code class="p">)</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">.</code><code class="na">getChannel</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">FileChannel</code><code class="w"> </code><code class="n">readWriteFc</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">RandomAccessFile</code><code class="p">(</code><code class="s">"file.txt"</code><code class="p">,</code><code class="w"> </code><code class="s">"rw"</code><code class="p">)</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">.</code><code class="na">getChannel</code><code class="p">();</code><code class="w"/></pre>&#13;
&#13;
<p><code>FileChannel</code>s created from these file input and output streams are read-only or write-only, respectively. To get a read/write <code>FileChannel</code>, you must construct a <code>RandomAccessFile</code> with read/write options, as in the previous example.</p>&#13;
&#13;
<p>Using a <code>FileChannel</code> is <a data-primary="ByteBuffer class" data-type="indexterm" id="id2179"/>just like a <code>RandomAccessFile</code>, but it works with a <code>ByteBuffer</code> instead of byte arrays:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">ByteBuffer</code><code class="w"> </code><code class="n">bbuf</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">ByteBuffer</code><code class="p">.</code><code class="na">allocate</code><code class="p">(...);</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">bbuf</code><code class="p">.</code><code class="na">clear</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">readOnlyFc</code><code class="p">.</code><code class="na">position</code><code class="p">(</code><code class="n">index</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">readOnlyFc</code><code class="p">.</code><code class="na">read</code><code class="p">(</code><code class="n">bbuf</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">bbuf</code><code class="p">.</code><code class="na">flip</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">readWriteFc</code><code class="p">.</code><code class="na">write</code><code class="p">(</code><code class="n">bbuf</code><code class="p">);</code><code class="w"/></pre>&#13;
&#13;
<p>You can control how much data is read and written either by setting buffer position and limit markers or using another form of read/write that takes a buffer starting position and length. You can also read and write to a random position by supplying indexes with the read and write methods:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">readWriteFc</code><code class="p">.</code><code class="na">read</code><code class="p">(</code><code class="n">bbuf</code><code class="p">,</code><code class="w"> </code><code class="n">index</code><code class="p">)</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">readWriteFc</code><code class="p">.</code><code class="na">write</code><code class="p">(</code><code class="n">bbuf</code><code class="p">,</code><code class="w"> </code><code class="n">index2</code><code class="p">);</code><code class="w"/></pre>&#13;
&#13;
<p>In each case, the actual number of bytes read or written depends on several factors. The operation tries to read or write to the limit of the buffer, and the vast majority of the time, that is what happens with local file access. The operation is guaranteed to block only until at least one byte has been processed. Whatever happens, the number of bytes processed is returned and the buffer position is updated accordingly, preparing you to repeat the operation until it is complete, if needed. This is one of the conveniences of working with buffers; they can manage the count for you. Like standard streams, the channel <code>read()</code> method returns <code>-1</code> upon reaching the end of input.</p>&#13;
&#13;
<p>The <a data-primary="size() method, FileChannel" data-type="indexterm" id="id2180"/><a data-primary="truncate() method, FileChannel" data-type="indexterm" id="id2181"/>size of the file is always available with the <code>size()</code> method. It can change if you write past the end of the file. Conversely, you can truncate the file to a specified length with the <code>truncate()</code> method.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Concurrent access" data-type="sect3"><div class="sect3" id="learnjava6-CHP-10-SECT-3.7.1">&#13;
<h3>Concurrent access</h3>&#13;
&#13;
<p><code>FileChannel</code>s are safe for use by <a data-primary="concurrency" data-type="indexterm" id="id2182"/>multiple threads and guarantee a consistent view of that data across channels in the same VM. Unless you specify the <code>SYNC</code> or <code>DSYNC</code> options, however, channels do not guarantee how quickly writes are propagated to the storage mechanism. <a data-primary="force() method, FileChannel" data-type="indexterm" id="id2183"/>If you only intermittently need to be sure that data is safe before moving on, you can use the <code>force()</code> method to flush changes to disk. This method takes a Boolean argument indicating whether file metadata, including timestamp and permissions, must be included. Some systems keep track of reads on files as well as writes, so you can save a lot of updates if you set the flag to <code>false</code>, which indicates that you don’t care about syncing that metadata <span class="keep-together">immediately.</span></p>&#13;
&#13;
<p>As <a data-primary="channels" data-secondary="ClosedChannelException" data-type="indexterm" id="id2184"/><a data-primary="ClosedChannelException" data-type="indexterm" id="id2185"/>with all <code>Channel</code>s, any thread may close a <code>FileChannel</code>. Once closed, all the channel’s read/write and position-related methods throw a <code>ClosedChannelException</code>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="File locking" data-type="sect3"><div class="sect3" id="learnjava6-CHP-10-SECT-3.7.2">&#13;
<h3>File locking</h3>&#13;
&#13;
<p><code>FileChannel</code>s support <a data-primary="FileLock object" data-type="indexterm" id="id2186"/>exclusive and shared locks on regions of files through the <code>lock()</code> method:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">FileLock</code><code class="w"> </code><code class="n">bigLock</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">fileChannel</code><code class="p">.</code><code class="na">lock</code><code class="p">();</code><code class="w"/>&#13;
&#13;
<code class="w">    </code><code class="kt">int</code><code class="w"> </code><code class="n">start</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="n">len</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">fileChannel2</code><code class="p">.</code><code class="na">size</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">FileLock</code><code class="w"> </code><code class="n">readLock</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">fileChannel2</code><code class="p">.</code><code class="na">lock</code><code class="p">(</code><code class="n">start</code><code class="p">,</code><code class="w"> </code><code class="n">len</code><code class="p">,</code><code class="w"> </code><code class="kc">true</code><code class="p">);</code><code class="w"/></pre>&#13;
&#13;
<p>Locks may be <a data-primary="shared file locks" data-type="indexterm" id="id2187"/><a data-primary="exclusive file locks" data-type="indexterm" id="id2188"/>either shared or exclusive. An <em>exclusive</em> lock prevents others from acquiring a lock of any kind on the specified file or file region. A <em>shared</em> lock allows others to acquire overlapping shared locks but not exclusive locks. These are useful as write and read locks, respectively. When you are writing, you don’t want others to be able to write until you’re done, but when reading, you need only to block others from writing, not from reading.</p>&#13;
&#13;
<p>The <code>lock()</code> method with no <a data-primary="lock() method, FileChannel" data-type="indexterm" id="id2189"/>arguments in the previous example attempts to acquire an exclusive lock for the whole file. The second form accepts starting and length parameters, as well as a flag indicating whether the lock should be shared (<code>true</code>) or exclusive (<code>false</code>). The <code>FileLock</code> object returned by the <code>lock()</code> method can be used to release the lock:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">bigLock</code><code class="p">.</code><code class="na">release</code><code class="p">();</code><code class="w"/></pre>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>File locks are only guaranteed to be <em>cooperative</em>. They work when all threads honor them; they do not necessarily prevent a non-cooperating thread from reading or writing a locked file. In general, the only way to guarantee that locks are obeyed is for both parties to attempt to acquire the lock and proceed only if that attempt is successful.</p>&#13;
&#13;
<p>Also, shared locks are not implemented on some systems, in which case all requested locks are exclusive. You can <a data-primary="isShared() method, FileChannel" data-type="indexterm" id="id2190"/>test whether a lock is shared with the <code>isShared()</code> method.</p>&#13;
</div>&#13;
&#13;
<p><code>FileChannel</code> locks are held until the channel is closed or interrupted, so performing locks within a <code>try</code>-with-resources statement will help ensure that locks are released more robustly:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">  </code><code class="k">try</code><code class="w"> </code><code class="p">(</code><code class="n">FileChannel</code><code class="w"> </code><code class="n">channel</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">FileChannel</code><code class="p">.</code><code class="na">open</code><code class="p">(</code><code class="n">p</code><code class="p">,</code><code class="w"> </code><code class="n">WRITE</code><code class="p">)</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">channel</code><code class="p">.</code><code class="na">lock</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">// ...</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/></pre>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="FileChannel Example" data-type="sect2"><div class="sect2" id="learnjava6-CHP-10-SECT-3.8">&#13;
<h2>FileChannel Example</h2>&#13;
&#13;
<p>Let’s see some concrete usage of our channels and buffers. We’ll create a small text file that includes a count of how many times it has been accessed by our program. Our program, then, will open the file, read the current count, increment that count, and then write (well, overwrite) the count back to the file. You can try out a complete version of the snippets below in the <em>AccessNIO.java</em> file in the <em>ch10/examples</em> folder.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>You could absolutely tackle this project using the standard I/O classes in <code>java.io</code>. The NIO suite is not meant to replace the old classes wholesale, but to add functionality that is missing in the standard classes without breaking any code that relies on those classes. If you find NIO a little complex or dense, feel free to ignore it until you need some of those missing features, like file locking or manipulating metadata.</p>&#13;
</div>&#13;
&#13;
<p class="pagebreak-before">Our first task is to see if our access-counting file exists (<em>access.txt</em> in this example, but the name is arbitrary). If not, we need to create it (and set the internal access counter to 1). We can use a <code>Path</code> object with the <code>Files</code> static helper methods to get going:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="kd">class</code> <code class="nc">AccessNIO</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="n">String</code><code class="w"> </code><code class="n">accessFileName</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"access.txt"</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">  </code><code class="n">Path</code><code class="w">   </code><code class="n">accessFilePath</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Path</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="n">accessFileName</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">  </code><code class="kt">int</code><code class="w">    </code><code class="n">accessCount</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">  </code><code class="n">FileChannel</code><code class="w"> </code><code class="n">accessChannel</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="nf">AccessNIO</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">// ...</code><code class="w"/>&#13;
<code class="w">    </code><code class="kt">boolean</code><code class="w"> </code><code class="n">initial</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">!</code><code class="n">Files</code><code class="p">.</code><code class="na">exists</code><code class="p">(</code><code class="n">accessFilePath</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">accessChannel</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">FileChannel</code><code class="p">.</code><code class="na">open</code><code class="p">(</code><code class="n">accessFilePath</code><code class="p">,</code><code class="w"> </code><code class="n">CREATE</code><code class="p">,</code><code class="w"> </code><code class="n">READ</code><code class="p">,</code><code class="w"> </code><code class="n">WRITE</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">// ...</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>If the file doesn’t exist yet, we can write out an initial message (“This file has been accessed 0 times.”) and then rewind to the beginning of the new file. This gives us the same baseline to work from as though the file had existed all along:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">initial</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">String</code><code class="w"> </code><code class="n">msg</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">buildMessage</code><code class="p">();</code><code class="w"> </code><code class="c1">// helper for consistency</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">accessChannel</code><code class="p">.</code><code class="na">write</code><code class="p">(</code><code class="n">ByteBuffer</code><code class="p">.</code><code class="na">wrap</code><code class="p">(</code><code class="n">msg</code><code class="p">.</code><code class="na">getBytes</code><code class="p">()));</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">accessChannel</code><code class="p">.</code><code class="na">position</code><code class="p">(</code><code class="mi">0</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>If the file does exist, we need to make sure we can read from and write to it. We can gather this information with the <code>accessChannel</code> object we created in the constructor. We could certainly add other tests and more verbose error messages, but these minimal checks are useful:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="kt">boolean</code><code class="w"> </code><code class="nf">isReady</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="n">accessChannel</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">null</code><code class="w"> </code><code class="o">&amp;&amp;</code><code class="w"> </code><code class="n">accessChannel</code><code class="p">.</code><code class="na">isOpen</code><code class="p">());</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>Now we come to our primary use case. The file exists and has some content. We have the appropriate permissions for everything we want to do. We’ll start by opening the file in a read/write mode and reading its contents into a string:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="kt">int</code><code class="w"> </code><code class="n">fsize</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="kt">int</code><code class="p">)</code><code class="n">accessChannel</code><code class="p">.</code><code class="na">size</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">// Give ourselves extra room in case the count</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">// goes over a digit boundary (9 -&gt; 10, 99 -&gt; 100, etc.)</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">ByteBuffer</code><code class="w"> </code><code class="n">in</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">ByteBuffer</code><code class="p">.</code><code class="na">allocate</code><code class="p">(</code><code class="n">fsize</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mi">2</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">accessChannel</code><code class="p">.</code><code class="na">read</code><code class="p">(</code><code class="n">in</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">String</code><code class="w"> </code><code class="n">current</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">String</code><code class="p">(</code><code class="n">in</code><code class="p">.</code><code class="na">array</code><code class="p">());</code><code class="w"/></pre>&#13;
&#13;
<p class="pagebreak-before">We want the file to be human-readable on its own, so we won’t take advantage of <code>FileChannel</code>’s ability to read and write binary data. We can use our knowledge of how the single line of text is structured to parse our access count:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="kt">int</code><code class="w"> </code><code class="n">countStart</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">28</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">// We know where the count number starts, so get</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">// everything from that position to the next space</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">String</code><code class="w"> </code><code class="n">rawCount</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">current</code><code class="p">.</code><code class="na">substring</code><code class="p">(</code><code class="n">countStart</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">        </code><code class="n">current</code><code class="p">.</code><code class="na">indexOf</code><code class="p">(</code><code class="s">" "</code><code class="p">,</code><code class="w"> </code><code class="n">countStart</code><code class="p">));</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">accessCount</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Integer</code><code class="p">.</code><code class="na">parseInt</code><code class="p">(</code><code class="n">rawCount</code><code class="p">)</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mi">1</code><code class="p">;</code><code class="w"/></pre>&#13;
&#13;
<p>Finally, we can reset our position and overwrite the previous line with our new, updated line. Notice that we also truncate our file to the end of the saved message. We gave ourselves extra room to accommodate a bigger number, but we don’t want excess space in the actual file:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="n">String</code><code class="w"> </code><code class="n">msg</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">buildMessage</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">accessChannel</code><code class="p">.</code><code class="na">position</code><code class="p">(</code><code class="mi">0</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">accessChannel</code><code class="p">.</code><code class="na">write</code><code class="p">(</code><code class="n">ByteBuffer</code><code class="p">.</code><code class="na">wrap</code><code class="p">(</code><code class="n">msg</code><code class="p">.</code><code class="na">getBytes</code><code class="p">()));</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">accessChannel</code><code class="p">.</code><code class="na">truncate</code><code class="p">(</code><code class="n">accessChannel</code><code class="p">.</code><code class="na">position</code><code class="p">());</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">accessChannel</code><code class="p">.</code><code class="na">close</code><code class="p">();</code><code class="w"/></pre>&#13;
&#13;
<p>Try compiling and running this example a few times. Does the count go up as expected? What happens if you open the file in another program like a text editor? Unfortunately, Java NIO only <em>feels</em> like magic. Accessing the file using any other program will not necessarily change its contents according to the rules of our little example.<a data-primary="" data-startref="ix_io_nio_api" data-type="indexterm" id="id2191"/><a data-primary="" data-startref="ix_io_nio_ch10" data-type="indexterm" id="id2192"/><a data-primary="" data-startref="ix_java_nio_pkg_ch10" data-type="indexterm" id="id2193"/><a data-primary="" data-startref="ix_chan_file_chan" data-type="indexterm" id="id2194"/><a data-primary="" data-startref="ix_file_chan" data-type="indexterm" id="id2195"/><a data-primary="" data-startref="ix_java_nio_file_fchan" data-type="indexterm" id="id2196"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="wrap() Up" data-type="sect1"><div class="sect1" id="learnjava6-CHP-10-SECT-4">&#13;
<h1>wrap() Up</h1>&#13;
&#13;
<p>Almost any application bound for distribution will need to handle file I/O. Java has robust support for working efficiently with local files, including access to metadata for both files and directories. Java’s commitment to a broad compatibility shows up in the range of character encodings available when working with text files. Java is certainly known for working with nonlocal files, as well. We’ll tackle network I/O and web resources in <a data-type="xref" href="ch13.html#learnjava6-CHP-13">Chapter 13</a>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Review Questions" data-type="sect2"><div class="sect2" id="learnjava6-CHP-10-SECT-4.1">&#13;
<h2>Review Questions</h2>&#13;
<ol>&#13;
<li>&#13;
<p>How could you check to see if a given file already exists?</p>&#13;
</li>&#13;
<li>&#13;
<p>If you have to work with a legacy text file using an old encoding scheme, such as ISO 8859, how might you set up a reader to properly convert that content to something like UTF-8?</p>&#13;
</li>&#13;
<li>&#13;
<p>Which package has the best classes for nonblocking file I/O?</p>&#13;
</li>&#13;
<li>&#13;
<p>Which type of input stream might you use to parse a binary file, such as a JPEG-compressed image?</p>&#13;
</li>&#13;
<li>&#13;
<p>What are the three standard text streams built into the <code>System</code> class?</p>&#13;
</li>&#13;
<li>&#13;
<p>Absolute paths begin at a root (<em>/</em> or <em>C:\</em>, for example). Where do relative paths begin? More specifically, where are relative paths relative to?</p>&#13;
</li>&#13;
<li>&#13;
<p>How do you retrieve a NIO channel from an existing <code>FileInputStream</code>?</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Code Exercises" data-type="sect2"><div class="sect2" id="learnjava6-CHP-10-SECT-4.2">&#13;
<h2>Code Exercises</h2>&#13;
&#13;
<p>For these exercises, a skeleton <code>Count.java</code> file is in the <em>ch10/exercises</em> folder, but feel free to start with your own class. We iterate on a single project, so you can use your solution from the first exercise as the starting point for the second, and so on. Because testing the program requires supplying different files on the command line, you may find it easier to run this program from a terminal or command window. You can certainly use the terminal tab in your IDE, too:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Using the classes of the <code>java.io</code> package, create a small program that will print the size of a file specified on the command line. For example:</p>&#13;
<div class="openblock">&#13;
<pre data-type="programlisting">C:\&gt; java Count ../examples/ListIt.java&#13;
Analyzing ListIt.java&#13;
  Size: 1011 bytes</pre>&#13;
&#13;
<p>If no file argument is given, print an error message to <code>System.err</code>.</p>&#13;
</div>&#13;
</li>&#13;
<li>&#13;
<p>Expand on the previous exercise to open the given file and count the number of lines. (For these simple exercises, it’s OK to assume the file being analyzed is a text file.) If you want a little practice with some of the tools from <a data-type="xref" href="ch08.html#learnjava6-CHP-8">Chapter 8</a>, split each line based on whitespace and include a word count in the output. (You can use regular expressions to split words on fancier patterns such as punctuation, but that’s not required.)</p>&#13;
<div class="openblock">&#13;
<pre data-type="programlisting">C:\&gt; java Count ../examples/ListIt.java&#13;
Analyzing ListIt.java&#13;
  Size: 1011 bytes&#13;
  Lines: 36&#13;
  Words: 178</pre>&#13;
&#13;
<p>As before, if no file argument is given, print an error message to <code>System.err</code>.</p>&#13;
</div>&#13;
</li>&#13;
<li>&#13;
<p>Convert your previous solution to use NIO classes like <code>Path</code> and <code>Files</code> instead of readers. You can use any part of the <code>java.nio</code> and <code>java.nio.file</code> packages that you like. You will almost certainly still need the <code>java.io.IOException</code> class from the “old” I/O, of course.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="Advanced Exercises" data-type="sect2"><div class="sect2" id="learnjava6-CHP-10-SECT-4.3">&#13;
<h2>Advanced Exercises</h2>&#13;
<ol>&#13;
<li>&#13;
<p>Accept a second command-line containing the name of a statistics log file. Rather than printing the various counts back to the terminal, append a line containing the current timestamp, the name of the file, and its three counts. The exact format of the line isn’t really important, but it should look something like this:</p>&#13;
<div class="openblock">&#13;
<pre data-type="programlisting">2023-02-02 08:14:25 Count1.java  36  147  1002</pre>&#13;
&#13;
<p>You can use either your NIO or your old I/O (OIO?) solution as your starting point. If you go with the NIO version, try to use a <code>ByteBuffer</code> and a &#13;
<span class="keep-together"><code>FileChannel</code></span> to do the writing.<a data-primary="" data-startref="ix_io_ch10" data-type="indexterm" id="id2197"/></p>&#13;
&#13;
<p>If only one command-line argument is provided, revert to printing the stats out to the screen as before. If no arguments are provided, or if the second argument is not writable, print an error to <code>System.err</code>.</p>&#13;
&#13;
<p>Run this version a few times on a few files. Check your log to make sure each new result is correctly appended to the end of the log file and is not overwriting it.</p>&#13;
</div>&#13;
</li>&#13;
&#13;
</ol>&#13;
</div></section>&#13;
</div></section>&#13;
<div data-type="footnotes"><p data-type="footnote" id="id1908"><sup><a href="ch10.html#id1908-marker">1</a></sup> While NIO was introduced with Java 1.4—so not very new anymore—it was newer than the original, basic package and the name has stuck.</p><p data-type="footnote" id="id1946"><sup><a href="ch10.html#id1946-marker">2</a></sup> Standard error (<code>stderr</code>) is a stream usually reserved for error-related text messages that should be shown to the user of a command-line application. It is different from standard output (<code>stdout</code>), which is often redirected to a log file or another application and not seen by the user.</p><p data-type="footnote" id="id2038"><sup><a href="ch10.html#id2038-marker">3</a></sup> The term is borrowed from the world of threads and means the same thing: an atomic file creation cannot be interrupted by another thread.</p><p data-type="footnote" id="id2069"><sup><a href="ch10.html#id2069-marker">4</a></sup> In OO programming, the term <em>factory</em> typically refers to a static helper that can construct and tailor some object. A factory (or factory method) is similar to a constructor, but that additional tailoring can add details to the new object that might be difficult (or impossible) to specify in a constructor.</p><p data-type="footnote" id="id2150"><sup><a href="ch10.html#id2150-marker">5</a></sup> The terms <em>big-endian</em> and <em>little-endian</em> come from Jonathan Swift’s novel <em>Gulliver’s Travels</em>, where they denoted two camps of Lilliputians: those who eat eggs from the big end and those who eat them from the little end.</p></div></div></section></body></html>