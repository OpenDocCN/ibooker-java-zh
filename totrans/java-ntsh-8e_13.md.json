["```java\nClass<?> myClass = getClass();\n```", "```java\nClass<?> c = o.getClass();\n```", "```java\n// Express a class literal as a type name followed by \".class\"\nc = String.class; // Same as \"a string\".getClass()\nc = byte[].class; // Type of byte arrays\n```", "```java\n// Obtain a Class object for primitive types with various\n// predefined constants\nc = Void.TYPE; // The special \"no-return-value\" type\nc = Byte.TYPE; // Class object that represents a byte\nc = Integer.TYPE; // Class object that represents an int\nc = Double.TYPE; // etc.; see also Short, Character, Long, Float\n```", "```java\nc = int.class; // Same as Integer.TYPE\n```", "```java\n// outputs true\nSystem.out.printf(\"%b%n\", Integer.TYPE == int.class);\n\n// outputs false\nSystem.out.printf(\"%b%n\", Integer.class == int.class);\n\n// outputs false\nSystem.out.printf(\"%b%n\", Integer.class == Integer.TYPE);\n```", "```java\nClass<?> clz =  ... // Get class from somewhere, e.g. loaded from disk\nfor (Method m : clz.getMethods()) {\n  for (Annotation a : m.getAnnotations()) {\n    if (a.annotationType() == Deprecated.class) {\n      System.out.println(m.getName());\n    }\n  }\n}\n```", "```java\npublic static Class<?> commonAncestor(Class<?> cl1, Class<?> cl2) {\n  if (cl1 == null || cl2 == null) return null;\n  if (cl1.equals(cl2)) return cl1;\n  if (cl1.isPrimitive() || cl2.isPrimitive()) return null;\n\n  List<Class<?>> ancestors = new ArrayList<>();\n  Class<?> c = cl1;\n  while (!c.equals(Object.class)) {\n    if (c.equals(cl2)) return c;\n    ancestors.add(c);\n    c = c.getSuperclass();\n  }\n  c = cl2;\n  while (!c.equals(Object.class)) {\n    for (Class<?> k : ancestors) {\n      if (c.equals(k)) return c;\n    }\n    c = c.getSuperclass();\n  }\n\n  return Object.class;\n}\n```", "```java\nmov eax, [STAT] ; Move 4 bytes from addr STAT into eax\n```", "```java\nvar current = new File( \".\" ).getCanonicalPath();\nvar urls = new URL[] {new URL(\"file://\"+ current + \"/\")};\ntry (URLClassLoader loader = new URLClassLoader(urls)) {\n  Class<?> clz = loader.loadClass(\"com.example.DFACaller\");\n  System.out.println(clz.getName());\n}\n```", "```java\nClass<?> jdbcClz = Class.forName(\"oracle.jdbc.driver.OracleDriver\");\n```", "```java\nClass.forName(String name, boolean inited, ClassLoader classloader);\n```", "```java\npublic static class DiskLoader extends ClassLoader {\n  public DiskLoader() {\n    super(DiskLoader.class.getClassLoader());\n  }\n\n  public Class<?> loadFromDisk(String clzPath) throws IOException {\n    byte[] b = Files.readAllBytes(Paths.get(clzPath));\n\n    return defineClass(null, b, 0, b.length);\n  }\n}\n```", "```java\nvar clzForInstance = \"Hi\".getClass();\nvar clzForName = Class.forName(\"java.lang.String\");\n```", "```java\nvar clz = Class.forName(\"java.lang.String\");\n\n// Returns list of all publicly visible methods on clz\nvar publicMethods = clz.getMethods();\n\n// Returns named method from clz, or throws\nvar toString = clz.getMethod(\"toString\", new Class[] {});\n```", "```java\nvar clz = Class.forName(\"java.lang.String\");\nvar toString = clz.getMethod(\"toString\", new Class[] {});\n\n// The method's name\nString name = toString.getName();\n\n// Generic type information for the method\nTypeVariable[] typeParams = toString.getTypeParameters();\n\n// List of method annotations with RUNTIME retention\nAnnotation[] ann = toString.getAnnotations();\n\n// List of checked exception types declared by method\nClass[] exceptions = toString.getExceptionTypes();\n\n// List of Parameter objects for callling the method\nParameter[] params = toString.getParameters();\n\n// List of just the `Class` for each parameter to the method\nClass[] paramTypes = toString.getParameterTypes();\n\n// Class of the method's return type\nClass ret = toString.getReturnType();\n```", "```java\nObject rcvr = \"a\";\ntry {\n  Class<?>[] argTypes = new Class[] { };\n  Object[] args = null;\n\n  Method meth = rcvr.getClass().getMethod(\"hashCode\", argTypes);\n  Object ret = meth.invoke(rcvr, args);\n  System.out.println(ret);\n\n} catch (IllegalArgumentException | NoSuchMethodException |\n         SecurityException e) {\n  e.printStackTrace();\n} catch (IllegalAccessException | InvocationTargetException x) {\n  x.printStackTrace();\n}\n```", "```java\nClass<?> clz = ... // Get some class object\nObject rcvr = clz.getDeclaredConstructor().newInstance();\n```", "```java\npublic class CustomClassloadingExamples {\n    public static class DiskLoader extends ClassLoader {\n\n        public DiskLoader() {\n            super(DiskLoader.class.getClassLoader());\n        }\n\n        public Class<?> loadFromDisk(String clzName)\n          throws IOException {\n            byte[] b = Files.readAllBytes(Paths.get(clzName));\n\n            return defineClass(null, b, 0, b.length);\n        }\n    }\n\n    public void findDeprecatedMethods(Class<?> clz) {\n        for (Method m : clz.getMethods()) {\n            for (Annotation a : m.getAnnotations()) {\n                if (a.annotationType() == Deprecated.class) {\n                    System.out.println(m.getName());\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args)\n      throws IOException, ClassNotFoundException {\n        var rfx = new CustomClassloadingExamples();\n\n        if (args.length > 0) {\n            DiskLoader dlr = new DiskLoader();\n            Class<?> clzToTest = dlr.loadFromDisk(args[0]);\n            rfx.findDeprecatedMethods(clzToTest);\n        }\n    }\n}\n```", "```java\npublic class MyCache {\n  private void flush() {\n    // Flush the cache...\n  }\n}\n\nClass<?> clz = MyCache.class;\ntry {\n  Object rcvr = clz.newInstance();\n  Class<?>[] argTypes = new Class[] { };\n  Object[] args = null;\n\n  Method meth = clz.getDeclaredMethod(\"flush\", argTypes);\n  meth.setAccessible(true);\n  meth.invoke(rcvr, args);\n} catch (IllegalArgumentException | NoSuchMethodException |\n         InstantiationException | SecurityException e) {\n  e.printStackTrace();\n} catch (IllegalAccessException | InvocationTargetException x) {\n  x.printStackTrace();\n}\n```", "```java\nInvocationHandler handler = (proxy, method, args) -> {\n    String name = method.getName();\n    System.out.println(\"Called as: \"+ name);\n    return switch (name) {\n        case \"isOpen\" -> Boolean.TRUE;\n        case \"close\" -> null;\n        default -> null;\n    };\n};\n\nChannel c = (Channel) Proxy.newProxyInstance(\n        Channel.class.getClassLoader(),\n        new Class[] { Channel.class },\n        handler);\nSystem.out.println(\"Open? \"+ c.isOpen());\nc.close();\n```", "```java\npublic class RememberingList implements InvocationHandler {\n  private final List<String> proxied = new ArrayList<>();\n\n  @Override\n  public Object invoke(Object proxy, Method method, Object[] args)\n                         throws Throwable {\n    String name = method.getName();\n    switch (name) {\n      case \"clear\":\n        return null;\n      case \"remove\":\n      case \"removeAll\":\n        return false;\n    }\n\n    return method.invoke(proxied, args);\n  }\n}\n\nRememberingList hList = new RememberingList();\n\nvar l = (List<String>) Proxy.newProxyInstance(\n                                List.class.getClassLoader(),\n                                new Class[] { List.class },\n                                hList);\nl.add(\"cat\");\nl.add(\"bunny\");\nl.clear();\nSystem.out.println(l);\n```", "```java\n// Matching method type for toString()\nMethodType m2Str = MethodType.methodType(String.class);\n\n// Matching method type for Integer.parseInt()\nMethodType mtParseInt =\n  MethodType.methodType(Integer.class, String.class);\n\n// Matching method type for defineClass() from ClassLoader\nMethodType mtdefClz = MethodType.methodType(Class.class, String.class,\n                                            byte[].class, int.class,\n                                            int.class);\n```", "```java\n// String.toString only has return type with no parameter\nMethodType mtToString = MethodType.methodType(String.class);\n\ntry {\n  Lookup l = MethodHandles.lookup();\n  MethodHandle mh = l.findVirtual(String.class, \"toString\",\n                                  mtToString);\n  System.out.println(mh);\n} catch (NoSuchMethodException | IllegalAccessException e) {\n  e.printStackTrace();\n}\n```", "```java\npublic static void lookupDefineClass(Lookup l) {\n  MethodType mt = MethodType.methodType(Class.class, String.class,\n                                        byte[].class, int.class,\n                                        int.class);\n\n  try {\n    MethodHandle mh =\n      l.findVirtual(ClassLoader.class, \"defineClass\", mt);\n    System.out.println(mh);\n  } catch (NoSuchMethodException | IllegalAccessException e) {\n    e.printStackTrace();\n  }\n}\n\nLookup l = MethodHandles.lookup();\nlookupDefineClass(l);\n```", "```java\npublic class SneakyLoader extends ClassLoader {\n  public SneakyLoader() {\n    super(SneakyLoader.class.getClassLoader());\n  }\n\n  public Lookup getLookup() {\n    return MethodHandles.lookup();\n  }\n}\n\nSneakyLoader snLdr = new SneakyLoader();\nl = snLdr.getLookup();\nlookupDefineClass(l);\n```", "```java\nObject rcvr = \"a\";\ntry {\n  MethodType mt = MethodType.methodType(int.class);\n  MethodHandles.Lookup l = MethodHandles.lookup();\n  MethodHandle mh = l.findVirtual(rcvr.getClass(), \"hashCode\", mt);\n\n  int ret;\n  try {\n    ret = (int)mh.invoke(rcvr);\n    System.out.println(ret);\n  } catch (Throwable t) {\n    t.printStackTrace();\n  }\n} catch (IllegalArgumentException |\n  NoSuchMethodException | SecurityException e) {\n  e.printStackTrace();\n} catch (IllegalAccessException x) {\n  x.printStackTrace();\n}\n```"]