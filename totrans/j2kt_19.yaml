- en: Chapter 19\. Throwing to Returning
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java uses checked and unchecked exceptions to represent and handle errors. Kotlin
    supports exceptions, but doesn’t build checked exceptions into the language in
    the same way. Why did Kotlin reject Java’s approach, and what should we use instead?
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You don’t have program computers for long to discover that things go wrong…
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: …in *so many* ways.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Early in their careers, your authors tended to gloss over errors. We often still
    do, at least early in a project. As the system grows, though, we learn how failures
    affect the application and start to add code to cope—at first piecemeal, later
    with some strategy informed by experience. In this respect our error handling
    evolves in the same way as other aspects of our software design. Sometimes we
    design up front, making use of our experience of similar systems; other times
    we allow the writing of the software to teach us what it needs.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: In the absence of a more deliberate strategy, most systems default to raising
    exceptions when something goes wrong, and catching and logging those exceptions
    at some outer level. Command-line utilities will just exit in this case, hopefully
    having provided enough information for the user to correct the problem and try
    again. A server app, or a GUI with an event loop, will usually abort only the
    current interaction and get on with the next.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Often this is just a poor experience for our users, but sometimes the error
    will corrupt the persistent state of the system, so correcting the initial problem
    and retrying does not work. This is the source of the sage advice to “turn it
    off and on again.” Our systems mainly start in a safe state, so that after a restart
    a retry should succeed. If not, well, you’ve probably been in a situation where
    the only solution has been to reinstall the operating system—the ultimate way
    of removing corrupted persistent state.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: If errors are not well managed, but despite this the system becomes successful,
    diagnosing and fixing corruption due to errors can expand to fill all the team’s
    time. This is not a great place for a software project to be. Ask us how we know!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: So we don’t want errors because they annoy our users and may result in corruption
    that takes a lot of effort to fix, if we can fix it at all. What sort of errors
    do we see?
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Programs can go wrong for many reasons. When we say *program*, we also mean
    functions, methods, procedures—any code that we invoke. And when we say *go wrong*,
    we mean fail to do the job that we expected them to do.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'Reasons for this failure include:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes programs need to talk to other systems and that communication fails
    in some way.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Often we don’t give software the correct input it needs to do its job.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Apparently some programmers make errors: even instructing their computers to
    dereference null references or read past the ends of collections!'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The environment that we are running in fails for some reason; for example, it
    might run out of memory or not be able to load a class.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are failures that don’t fit into these categories, but most do.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 有些失败情况不属于这些类别，但大多数情况下是适用的。
- en: That doesn’t seem to be too long a list, and yet as an industry we don’t have
    a great reputation for reliability. Error handling just seems to be hard. Why
    is that?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎不是一个太长的列表，然而作为一个行业，我们在可靠性方面并不享有很好的声誉。错误处理似乎很难。为什么呢？
- en: Well, for a start we often don’t know whether an operation can fail and, if
    so, how it can fail. If we do know, then knowledge about how to handle an error
    may be in code a long way from where the problem is detected. Then the code that
    detects an error, and the code that recovers from it, are hard to isolate from
    the happy path and so are hard to test. Combine these with the tendency for errors
    to leave our system in unrecoverable states, and we end up with a situation where
    most developers would rather hope for the best than take on the hard work and
    still get it wrong.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们经常不知道操作是否会失败，以及如果失败的话会是怎样的失败。如果我们知道，那么处理错误的知识可能在离问题检测点很远的代码中。然后检测错误的代码和从错误中恢复的代码很难与正常路径分离，因此很难测试。再加上错误可能使我们的系统陷入无法恢复的状态，我们最终面临的情况是，大多数开发者宁愿抱有乐观期望，而不愿承担艰苦的工作并且最终还是会出错。
- en: Hard work *and* error-prone? Weren’t computers supposed to free us from tasks
    like these, taking on the drudge work, so that we can focus on the fun creative
    stuff? Yes they were, so we will focus on error handling through the lens of how
    our programming language can make things safer and easier for programmers.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 艰苦的工作 *和* 容易出错？计算机不是应该解放我们，从事这些苦活使我们能专注于有趣的创造性工作吗？是的，它们确实应该，因此我们将通过编程语言如何使程序员的工作更安全更简单的角度来关注错误处理。
- en: Error Handling Before Exceptions
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常之前的错误处理
- en: Most error handling these days is based on exceptions, but other techniques
    have been used and are still applicable in some circumstances. We’ll look at the
    pros and cons of those techniques first. The cons will show us why exceptions
    now dominate; the pros may give us options when exceptions aren’t appropriate.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数错误处理如今都基于异常，但在某些情况下仍然可以使用其他技术。我们将首先看看这些技术的优缺点。缺点将告诉我们为什么异常现在占据主导地位；而优点则可能在异常不适用时为我们提供选择。
- en: Ignoring errors
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略错误
- en: We can ignore errors. Either the failing routine does nothing to bring them
    to the attention of the caller, or the caller doesn’t bother to check.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以忽略错误。要么失败的例程不做任何事情来引起调用者的注意，要么调用者根本不去检查。
- en: This may lead to corruption of persistent data and silent failure to do the
    job, so in most cases we need to aim higher.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能导致持久数据的损坏和静默地未能完成任务，所以在大多数情况下，我们需要有更高的要求。
- en: Just crashing
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅崩溃
- en: Some programs just exit when an error is detected.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一些程序在检测到错误时会直接退出。
- en: Combined with a supervisor to restart on error and careful coding to prevent
    corruption of persistent state, this is a battle-tested strategy that may be appropriate.
    Throwing an exception to abort an operation is the application of this technique
    to a procedure rather than to a whole program.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 结合错误重启的监控程序和仔细编码以防止持久状态的破坏，这是一种经过考验的战略，可能是适当的。抛出异常来中止操作是将这种技术应用于过程而不是整个程序的表现。
- en: Returning a special value
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个特殊值
- en: Returning a special value to signify an error can be a useful technique. For
    example, a function can return `-1` instead of an index when an item is not found
    in a list.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个特殊值来表示错误可以是一种有用的技术。例如，当在列表中找不到项时，函数可以返回`-1`而不是索引。
- en: This technique cannot be used when all return values are valid results for a
    function. It can also be dangerous, because the caller has to know (and remember)
    the convention. If we try to calculate the distance between two items in a list
    by subtracting their indices, when one of them is not found and returns -1, our
    calculation will be incorrect unless we explicitly handle the special case. We
    can’t lean on the type checker to help us avoid errors.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有返回值都是函数的有效结果时，此技术无法使用。它也可能很危险，因为调用者必须了解（并记住）约定。如果我们尝试通过减去它们的索引来计算列表中两个项之间的距离，当其中一个找不到并返回`-1`时，除非我们明确处理特殊情况，否则我们的计算将是错误的。我们不能依赖类型检查器来帮助我们避免错误。
- en: A special case of returning a special value is returning null on error. This
    is quite dangerous in most languages, because if the caller doesn’t explicitly
    check for null, then using the result will throw a `NullPointerException`, which
    may be worse than the initial problem. In Kotlin, though, the type checker forces
    callers to deal with null, making this a safe and effective technique.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Setting a global flag
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: One problem with returning special values is that they make it hard to signal
    which of several possible errors occurred. To solve this we can combine the special
    value with setting a global variable. When the special value is detected, the
    caller can read `errno`, for example, to establish what the problem was.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: This technique was popular in C but was largely superseded by exception-based
    error handling.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Returning a status code
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Another technique from the days before exceptions is returning a status code.
    This is possible when a function either returns no value (it is entirely side
    effect) or returns a value in another way, often by mutating a parameter passed
    by reference.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Invoking a special function
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Invoking a special function when an error occurs is sometimes a good strategy.
    Usually the error function is passed as a parameter to the invoked function. If
    a problem is detected, the error function is invoked with a value representing
    the error as a parameter. Sometimes the error function can signal by its return
    value if the failed operation should be retried or aborted. Another technique
    is for the error function to provide the value that should be returned by the
    invoked function.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: This technique is an example of the strategy pattern applied to error handling.
    Even when exceptions are available, it is a useful tool in niche situations.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Error Handling with Exceptions
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All these techniques suffer from the drawback that the calling code is able,
    to a greater or lesser extent, to ignore that an error occurred.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions solve this problem. The operation automatically aborts on error,
    and the caller explicitly handles the exception. If the caller does not handle
    it, the exception propagates further down the call stack until something does,
    and if nothing handles the exception, the thread terminates.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Java and Checked Exceptions
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exceptions were relatively new when Java was released, and the language designers
    decided to innovate in this area. They made the exceptions that a method could
    throw part of its signature. This way, callers could know that, for example, a
    method might fail because the network resource that it was reading was no longer
    available. If a method declared that it could fail in this way, then every caller
    of that method would either have to deal with the failure (by specifying in a
    `catch` block how it should be handled) or declare that it, too, was liable to
    fail with the same exception. This ensures that the programmer takes account of
    the possibility of these errors. Such exceptions are called *checked exceptions*,
    because the compiler checks that they are handled (or redeclared to be thrown
    by the calling method).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当Java发布时，异常相对较新，语言设计者决定在这一领域进行创新。他们使方法可能引发的异常成为其签名的一部分。这样，调用者可以知道，例如，一个方法可能因为它正在读取的网络资源不再可用而失败。如果一个方法声明它可能以这种方式失败，那么调用该方法的每个调用者都必须处理该失败（通过指定在`catch`块中如何处理）或声明它也可能因相同的异常而失败。这确保了程序员考虑到这些错误的可能性。这些异常称为*检查异常*，因为编译器检查它们是否已处理（或重新声明为调用方法抛出）。
- en: 'Checked exceptions were designed for when the programmer might reasonably be
    able to find a way to recover: retrying a database write or reopening a socket,
    for example. The language designers identified two other types: errors and runtime
    exceptions.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 检查异常设计用于当程序员可能合理地找到一种恢复方法时：例如重试数据库写入或重新打开套接字。语言设计者确定了另外两种类型：错误和运行时异常。
- en: Errors
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 错误
- en: Subclasses of `java.lang.Error` are reserved for failures so severe that the
    JVM can no longer guarantee the correct functioning of the runtime. Maybe a class
    cannot be loaded, or the system runs out of memory. These conditions can happen
    at any point in the execution of a program, and so could cause any function to
    fail. Because any method could fail in this way, there is no value in including
    them in every method signature, so `Error`s do not have to be declared.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.lang.Error`的子类专门用于严重到JVM无法保证运行时正确功能的故障。可能是无法加载类，或者系统内存耗尽。这些情况可能发生在程序执行的任何时刻，因此可能导致任何函数执行失败。由于任何方法都可能以这种方式失败，所以在每个方法签名中包含它们是没有价值的，因此不需要声明`Error`。'
- en: Runtime Exceptions
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时异常
- en: Subclasses of `RuntimeException` represent other errors. The intention was that
    these would be reserved for problems caused by programmer mistakes, such as accessing
    a null reference or trying to read outside the bounds of a collection. In both
    these cases the programmer could have been more careful. Again though, every piece
    of code is subject to programmer error, so `RuntimeExceptions` are also exempted
    from having to be declared.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`RuntimeException`的子类代表其他错误。其意图是这些错误应该保留给程序员错误造成的问题，例如访问空引用或尝试读取集合的边界外。在这两种情况下，程序员本可以更加谨慎。尽管如此，每一行代码都可能存在程序员错误，因此`RuntimeExceptions`也免除了必须声明的义务。'
- en: This scheme forces developers to deal with operations that can fail due to I/O
    errors or other things that are out of their control (the checked exceptions),
    allowing defensive programming where it is economical. At the other extreme, if
    an `Error` is thrown, the best default approach is exit the process as quickly
    as possible, before any more damage can be done to persistent state.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方案迫使开发人员处理可能因I/O错误或其他超出其控制范围的事物（检查异常）而失败的操作，允许经济有效的防御性编程。在另一极端，如果抛出`Error`，最好的默认方法是尽快退出进程，以免对持久状态造成更多损害。
- en: '`RuntimeException`s are a middle ground. If they represent a programmer error,
    we should probably assume that we have just proved that we don’t really know what
    is going on in our program and abort the current operation or whole application.
    Otherwise, we might try to recover, especially if our system has been designed
    to limit the damage that can be done to persistent state.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`RuntimeException`是一个折中的情况。如果它们代表了程序员的错误，我们可能应该假设我们刚刚证明了我们并不真正知道我们的程序正在做什么，并中止当前操作或整个应用程序。否则，我们可能会尝试恢复，特别是如果我们的系统已被设计为限制对持久状态可能造成的损害。'
- en: 'Your authors both really liked checked exceptions, but it seems they were in
    the minority, because checked exceptions fell out of favor in Java over the years.
    Checked exceptions were hampered from the start by the odd decision to make the
    unchecked `RuntimeException` a subclass of the otherwise checked `Exception`,
    so that code that wanted to handle all checked exceptions found itself catching
    unchecked ones as well, hiding programming errors. They were also not helped by
    the fact that the Java APIs used them inconsistently. Take extracting data from
    a string for example: the `URL` constructor `URL(String)` throws the *checked*
    `MalformedURLException`, while `Integer.​par⁠seInt(String)` throws the *unchecked*
    `NumberFormatException`.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Confusion over what type of exception to use multiplied, and it wasn’t long
    before the default was that the only checked exceptions that most Java libraries
    declared were `IOExceptions`. Even then, database libraries such as Hibernate,
    which were definitely talking over the network and definitely subject to `IOExceptions`,
    would throw only `RuntimeExceptions`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Once a good proportion of the code that you call just uses unchecked exceptions,
    the game is up. You can’t rely on checked exceptions to warn you about how a function
    might fail. Instead, you are reduced to some tactical defensive programming and
    the age-old technique of putting it into production, seeing what errors you log,
    and adding code to handle those you don’t like the look of.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: The final nail in the coffin of checked exceptions was the introduction of lambdas
    in Java 8. The decision was taken not to declare an exception type in the signature
    of the functional interfaces introduced to support lambdas (`Producer`, `Consumer`,
    etc.), so these cannot propagate checked exceptions. This wasn’t an insurmountable
    problem, but to be fair, your authors would probably have given up there too.
    The net result, though, is that the old standard Java API declares checked exceptions
    (in particular, `IOException`) that the new standard API (in particular streams)
    forces developers to deny.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin and Exceptions
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kotlin has exceptions, because it runs on the JVM, and exceptions are built
    into the platform. It does not treat checked exceptions specially though, because
    Java had already lost that fight, and, as with Java, they are hard to reconcile
    with higher-order functions. Kotlin is able to largely ignore checked exceptions
    because they are not a feature of the JVM but, rather, of the Java compiler. The
    compiler does record in the bytecode what checked exceptions a method declares
    (to be able to check them), but the JVM itself does not care.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: The result is that Kotlin programs are by default no better or worse than most
    Java programs when it comes to error handling.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'An exception (lowercase e) to this is that, as we observed earlier, Kotlin
    can use `null` to indicate an error, safe in the knowledge that callers will have
    to take the possibility of `null` into consideration. An example of this is the
    `<T> Iterable<T>.firstOrNull(): T?` in the runtime. Tellingly, though, the runtime
    also defines `first()`, which throws `NoSuchElementException` if the collection
    is empty.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'Beyond Exceptions: Functional Error Handling'
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Statically typed functional programming languages often reject exceptions in
    favor of another error handling technique based on *Either Types*. We’ll see what
    an Either Type is shortly, but why don’t functional programmers like exceptions?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'A distinguishing feature of functional programming is *referential transparency*.
    When an expression is referentially transparent, we can safely replace it with
    the result of its evaluation. So if we write:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: then we can replace `60 * 60` with `3600` or `60 * 24` with `1440` without affecting
    the results. In fact, the compiler may decide to replace the whole expression
    with `86400` for us, and (unless we examine the bytecode or use a debugger) we
    will be none the wiser.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: is not referentially transparent, because `today()` will yield a different result
    than it did yesterday, and any day may have a leap second applied. As a result,
    the value of `secondsIn(today())` may differ depending on when we call it, and
    we can’t just substitute the same value for the expression every time we use it.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: This is the same concept as we saw in [Chapter 7](ch07.html#actions-to-calculations).
    [“Calculations”](ch07.html#calculations) are referentially transparent; [“Actions”](ch07.html#actions)
    are not.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Why should we care? Because referential transparency makes it a lot easier to
    reason about the behavior of a program, which in turn leads to fewer errors and
    more opportunities to refactor and optimize. If we want these things (and at the
    very least we don’t want more errors and fewer opportunities), then we should
    strive for referential transparency.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: What does this have to do with error handling? Let’s return to our `Integer.​par⁠seInt(String)`
    example and see. For a given valid input, `parseInt` will always return the same
    value, so it could be referentially transparent. In the cases where the `String`
    doesn’t represent an integer, though, `parseInt` throws an exception rather than
    returning a result. We can’t replace the result of the function invocation with
    an exception, because the type of the expression is `Int`, and an `Exception`
    isn’t an `Int`. Exceptions break referential transparency.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: If instead of using exceptions we returned to the old trick of using a special
    value to represent errors, we would have referential transparency, because that
    error value can replace the expression. In Kotlin, `null` would be great here,
    so we could define `parseInt` to return `Int?`. But what if we needed to know
    which was the first character that wasn’t a digit? We can convey that information
    in an exception but not in a return type of `Int?`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Can we find a way for our function to return *either* the `Int`, or the way
    that it failed?
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer, as they say, is in the question. We define a type `Either`, which
    can hold one of two types, but only one at a time:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In Kotlin, sealed classes ([Chapter 18](ch18.html#open-to-sealed-classes)) are
    excellent for this, because we can define our own subtypes but know that no one
    else can.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'When `Either` is used for error handling, the convention is that `Right` is
    used for a result, `Left` for an error. If we stick to this convention, we could
    define:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'How would we use this? As we saw in [Chapter 18](ch18.html#open-to-sealed-classes),
    `when` expressions and smart casting work really nicely to let us write things
    like:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'By returning an `Either`, we force our clients to deal with the fact that we
    may have failed. This gives some of the advantages of checked exceptions in a
    functional form. To embrace this style, we make all functions that in Java we
    would have declared to throw a checked exception return an `Either`. The callers
    then either unwrap the success and act on it or pass on any failure:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Although using `when` to unwrap an `Either` is logical, it is also verbose.
    This particular pattern occurs so much that we define `map` to be:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This allows us to write the previous function as:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Why is that function called `map` and not `invokeUnlessLeft`? Well, if you squint
    you may be able to see that it is kind of the same thing as `List.map`. It applies
    a function to the contents of a container, returning the result in another container.
    In the case of `Either`, `map` applies the function only if it is a `Right` (nonerror);
    otherwise, it passes `Left`s on unchanged.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'Practice that squinting, because we are now going to define:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This unpacks our value and uses it to invoke a function that in turn might
    fail (as it returns `Either`). What can we do with that? Well, let’s say we want
    to read from a `Reader` and print double the result. We can define a wrapper for
    `readLine` that returns an `Either` rather than failing with an exception:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This lets us combine `eitherReadLine` and `doubleString` with `flatMap`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This code will return a `Left` with the failure if `eitherReadLine` fails; otherwise,
    it will return the result of `doubleString`, which may itself be either a `Left`
    for failure or a `Right` with the final `Int` result. In this way a chain of `map`
    and/or `flatMap` calls acts like a series of expressions, which might throw an
    exception; the first failure aborts the rest of the computation.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: If you come from an object-oriented background, this style does take some getting
    used to. In our experience no amount of reading helps; you just have to knuckle
    down and start writing code this way until it becomes less strange. We’ll share
    your pain by pairing with you in the worked example later.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Error Handling in Kotlin
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know the error handling options open to us, which should we use
    in our Kotlin projects, and how do we migrate our Java code?
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: As usual, it depends.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Using nullable types to represent failure is very effective, provided that you
    don’t need to convey any information about the reason for failure.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: You won’t be fired for using exceptions as your default strategy. The lack of
    type checking makes it hard to communicate what code is subject to what failure,
    though, which in turn makes it hard to build reliable systems. Adding insult to
    this injury, you will lose the benefits of referential transparency, making it
    harder to refactor and fix your unreliable system.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'Our preference is to return an `Either` type from those operations that would
    have thrown a checked exception in Java, either because of I/O problems, or because,
    like `parseInt`, they cannot give a result for all inputs. This allows us to reserve
    the use of exceptions for more pernicious problems. `Errors` are still appropriate
    for unrecoverable program errors: in this case we should design our systems so
    that the program exits and is restarted by some other process. `RuntimeExceptions`
    are still good for signaling when we have made an error as programmers: `IndexOutOfBounds`
    and the like. If we have carefully designed our system, it should be able to survive
    these issues and process other inputs that do not run into the same problem.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Which `Either` type should you choose? The built-in Kotlin `Result` type is,
    at the time of writing, a frustrating placeholder which just teases and gets in
    the way. It is designed for coroutines, is restricted to an `Exception` (actually
    `Throwable`) as its error value, and IntelliJ moans if you use it as a property
    type. This would be reasonable if it wasn’t published in the `kotlin` package.
    It is, though, so if you try to use a more useful type called `Result`, you get
    strange error messages until you remember that the compiler is assuming that `Result`
    refers to the `kotlin.Result` type that you aren’t supposed to use.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Plenty of other result types are available, but for this book we will use [Result4k](https://oreil.ly/F5Y4M),
    not coincidentally written by Nat. Compared to the generic `Either` type we introduced
    earlier, Result4k defines `Result<SuccessType, FailureType>`, with subtypes `Success`
    and `Failure` rather than `Left` and `Right`. Because it is specialized for representing
    errors, Result4k reverses the `Either` convention by having the success type as
    the first of the generic parameters. It can also offer operations, such as `onFailure`
    and `recover`, that would not make sense on `Either`. We’ll see some of these
    operations as we refactor.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他的结果类型可用，但是在本书中我们将使用 [Result4k](https://oreil.ly/F5Y4M)，这不是巧合，它是由 Nat 编写的。与我们之前介绍的通用
    `Either` 类型相比，Result4k 定义了 `Result<SuccessType, FailureType>`，具有子类型 `Success`
    和 `Failure`，而不是 `Left` 和 `Right`。由于它专门用于表示错误，Result4k 通过将成功类型作为泛型参数的第一个来反转 `Either`
    惯例。它还可以提供诸如 `onFailure` 和 `recover` 等操作，在 `Either` 上是不合理的。在重构时，我们将看到其中的一些操作。
- en: Refactoring Exceptions to Errors
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将异常重构为错误
- en: Now that we know the error handling options available to us, let’s refactor
    some Java code to Kotlin, converting the error handling as we go.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了可用的错误处理选项，让我们重构一些 Java 代码到 Kotlin，逐步转换错误处理。
- en: 'There is an HTTP endpoint in Travelator that allows the client app to register
    a `Customer`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Travelator 中有一个 HTTP 端点，允许客户端应用注册一个 `Customer`：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[Example 19.1 [errors.0:src/main/java/travelator/handlers/CustomerRegistrationHandler.java]](https://java-to-kotlin.dev/code.html?ref=19.1&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.1&show=diff)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.1 [errors.0:src/main/java/travelator/handlers/CustomerRegistrationHandler.java]](https://java-to-kotlin.dev/code.html?ref=19.1&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.1&show=diff)'
- en: '`CustomerRegistrationHandler`’s job is to extract data from the request body,
    pass it to `registration` for processing, and return a response with either a
    JSON representation of a `Customer` or a suitable error status code.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`CustomerRegistrationHandler` 的工作是从请求体中提取数据，将其传递给 `registration` 进行处理，并返回一个
    JSON 表示的 `Customer` 或适当的错误状态码响应。'
- en: '`CustomerRegistration` implements the business rules, which is that potential
    customers should be vetted against an `ExclusionList`. We don’t want to allow
    known undesirables to register and abuse our services, so we reject them at this
    point:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`CustomerRegistration` 实现了业务规则，即潜在客户应该经过 `ExclusionList` 的审核。我们不希望允许已知的不良分子注册并滥用我们的服务，因此我们在这一点上拒绝他们：'
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[Example 19.2 [errors.0:src/main/java/travelator/CustomerRegistration.java]](https://java-to-kotlin.dev/code.html?ref=19.2&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.2&show=diff)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.2 [errors.0:src/main/java/travelator/CustomerRegistration.java]](https://java-to-kotlin.dev/code.html?ref=19.2&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.2&show=diff)'
- en: 'Look at the `throws` clause of `register`. It tells us that the method can
    fail because of the explicit exclusion, but also that `customers.add` can fail
    with a `DuplicateException`. Here is the `Customers` interface:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 `register` 方法的 `throws` 子句。它告诉我们，这个方法可能因为明确的排除而失败，但也可能因为 `customers.add`
    导致 `DuplicateException` 失败。这是 `Customers` 接口：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[Example 19.3 [errors.0:src/main/java/travelator/Customers.java]](https://java-to-kotlin.dev/code.html?ref=19.3&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.3&show=diff)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.3 [errors.0:src/main/java/travelator/Customers.java]](https://java-to-kotlin.dev/code.html?ref=19.3&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.3&show=diff)'
- en: 'Finally, `Customer` is another value type. Here it is after conversion to Kotlin:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Customer` 是另一个值类型。在这里它转换为 Kotlin 后的样子：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[Example 19.4 [errors.1:src/main/java/travelator/Customer.kt]](https://java-to-kotlin.dev/code.html?ref=19.4&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.4&show=diff)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.4 [errors.1:src/main/java/travelator/Customer.kt]](https://java-to-kotlin.dev/code.html?ref=19.4&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.4&show=diff)'
- en: This is typical of your authors’ Java style. It expresses the things that might
    reasonably go wrong as the checked `ExcludedException` and `DuplicateException`,
    and these are all caught at the top level in `handle`, where they are reported
    to the caller, in this case as HTTP status codes. Your style might be to use unchecked
    exceptions, in which case this code would be similar but without the exceptions
    as part of the method signatures.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你们作者的典型 Java 风格。它表达了可能发生的事情，如检查的 `ExcludedException` 和 `DuplicateException`，这些都在
    `handle` 的顶层捕获，然后作为 HTTP 状态码报告给调用者。你的风格可能是使用未检查的异常，在这种情况下，这段代码的写法会类似，但方法签名中不包括异常。
- en: One thing we don’t see is any checked exception related to failures to persist
    a `Customer` in `Customers::add`. This method will be talking across the network
    to a database, but our query code is evidently swallowing `IOException` at some
    point and raising a `RuntimeException` in its place. These will propagate out
    of `Customer​Regis⁠tration::register`, be caught at the top level of `CustomerRegistrationHandler`,
    and passed back to clients as `HTTP_INTERNAL_ERROR` (500). It’s a shame that we
    aren’t logging any information about those stray `RuntimeException`s, because
    they might reveal systematic connection issues or be hiding a frequent `NullPointer​Excep⁠tion`
    in some lower-level code. Someone should probably address that, but in the meantime
    at least we have a shorter example to show in this book.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看不到与将`Customer`持久化到`Customers::add`失败相关的任何检查异常。这个方法将通过网络与数据库通信，但显然我们的查询代码在某个点上吞掉了`IOException`并替换为`RuntimeException`。这些异常将传播到`Customer​Regis⁠tration::register`的顶层，被`CustomerRegistrationHandler`捕获，并作为`HTTP_INTERNAL_ERROR`（500）传递回客户端。很遗憾我们没有记录关于这些零散`RuntimeException`的任何信息，因为它们可能揭示系统性连接问题或者在一些低级代码中隐藏着频繁的`NullPointer​Excep⁠tion`。在此期间，有人应该解决这个问题，但与此同时，至少我们在本书中展示了一个较短的示例。
- en: Our Conversion Strategy
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的转换策略
- en: If we were just to convert this code to Kotlin, we would lose the advantages
    of checked exceptions to tell us what could go wrong and show where we are handling
    those problems. So as we convert, we will replace exception-based error handling
    with a functional alternative using Result4k.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仅将此代码转换为 Kotlin，我们将失去检查异常提供的优势，无法告诉我们可能出现什么问题以及我们在哪里处理了这些问题。因此，在转换过程中，我们将使用
    Result4k 替换基于异常的错误处理功能性替代方案。
- en: In this example, we’ll start at the lowest level and work our way up, keeping
    higher levels working until the predictable error cases (those that are currently
    expressed as checked exceptions) no longer use exceptions. At the same time, we
    have to be mindful that pretty much any instruction in the JVM can fail, so we
    need to defend against these runtime issues.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将从最底层开始，逐步向上工作，保持更高级别的工作，直到那些当前表达为检查异常的可预测错误案例不再使用异常。与此同时，我们必须注意，JVM
    中几乎任何指令都可能失败，因此我们需要防范这些运行时问题。
- en: Starting at the Bottom
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从底层开始
- en: 'If we convert `Customers` to Kotlin, we get:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`Customers`转换为 Kotlin，我们得到：
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[Example 19.5 [errors.3:src/main/java/travelator/Customers.kt]](https://java-to-kotlin.dev/code.html?ref=19.5&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.5&show=diff)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.5 [errors.3:src/main/java/travelator/Customers.kt]](https://java-to-kotlin.dev/code.html?ref=19.5&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=19.5&show=diff)'
- en: '[![1](assets/1.png)](#co_introduction_CO42-1)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_introduction_CO42-1)'
- en: Although Kotlin doesn’t have checked exceptions, the `@Throws` annotation allows
    interop with Java code by adding the exception to the method’s signature in the
    bytecode. Without it, a Java implementation of `Customers` that does throw `DuplicateException`
    cannot implement the method. Worse, Java code that calls the method on the interface
    would not be able to catch the exception or declare that it is passed on, because
    it is a compile error for Java code to handle a checked exception that the compiler
    cannot see is possible.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Kotlin 没有检查异常，但`@Throws`注解允许通过将异常添加到方法的字节码签名中与 Java 代码进行互操作。如果没有它，一个 Java
    实现的`Customers`如果抛出`DuplicateException`将无法实现该方法。更糟的是，调用接口上的方法的 Java 代码将无法捕获异常或声明它被传递，因为
    Java 代码处理编译器无法看到的检查异常将是一个编译错误。
- en: Our strategy is to add to our interface a version of `Customers::add` that,
    instead of throwing an exception, returns `Result<Customer, DuplicateException>`.
    If we were starting from scratch, we wouldn’t use `DuplicateException` as the
    error type, but here it lets us interoperate with Java easily. We are going to
    keep the current throwy version around for now so that we don’t break existing
    callers. Then we will convert those callers to use the `Result` version and then
    remove the old version when we can. That’s right, it’s our old friend [“Expand-and-Contract
    Refactoring”](ch04.html#expand-contract).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的策略是在接口中添加`Customers::add`的一个版本，该版本不会抛出异常，而是返回`Result<Customer, DuplicateException>`。如果我们从头开始，我们不会将`DuplicateException`作为错误类型使用，但在这里它让我们可以轻松地与
    Java 进行交互。目前我们会保留当前的抛出版本，以免破坏现有的调用者。然后，当我们可以时，我们将转换这些调用者以使用`Result`版本，然后删除旧版本。没错，这是我们的老朋友[“扩展和收缩重构”](ch04.html#expand-contract)。
- en: 'What should we call the method that works like `Customers::add` but returns
    a `Result`? We can’t name it `add` too, because both have the same parameters,
    so we call it `addToo` for now. If the new method delegates to `add`, we can make
    it a default method so that it is available to all implementations:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该如何称呼像`Customers::add`但返回`Result`的方法？我们不能再命名为`add`，因为两者具有相同的参数，所以暂时称其为`addToo`。如果新方法委托给`add`，我们可以将其作为默认方法，以便所有实现都可以使用：
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[Example 19.6 [errors.5:src/main/java/travelator/Customers.kt]](https://java-to-kotlin.dev/code.html?ref=19.6&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.6&show=diff)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.6 [errors.5:src/main/java/travelator/Customers.kt]](https://java-to-kotlin.dev/code.html?ref=19.6&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=19.6&show=diff)'
- en: 'Now that we have both exception and result versions of the method, we can migrate
    the callers of the exception version. Although we can use Result4k from Java,
    it’s a lot more convenient from Kotlin. So let’s take `CustomerRegistration` (the
    caller of `add`):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们既有异常版本又有结果版本的方法，我们可以迁移调用异常版本的调用者。虽然我们可以从Java中使用Result4k，但从Kotlin更加方便。因此，让我们来看看`CustomerRegistration`（调用`add`的地方）：
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[Example 19.7 [errors.5:src/main/java/travelator/CustomerRegistration.java]](https://java-to-kotlin.dev/code.html?ref=19.7&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.7&show=diff)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.7 [errors.5:src/main/java/travelator/CustomerRegistration.java]](https://java-to-kotlin.dev/code.html?ref=19.7&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=19.7&show=diff)'
- en: 'Converting this to Kotlin gives:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 将其转换为Kotlin如下：
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[Example 19.8 [errors.6:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.8&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.8&show=diff)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.8 [errors.6:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.8&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=19.8&show=diff)'
- en: 'That `customers.add` expression is the one that can throw `DuplicateException`.
    We’re going to replace it with a call to `addToo` but keeping the behavior the
    same. So we pull out `result` as a local:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 那个`customers.add`表达式就是可能抛出`DuplicateException`的表达式。我们将其替换为调用`addToo`，但保持行为不变。因此，我们将`result`作为局部变量提取出来：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[Example 19.9 [errors.7:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.9&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.9&show=diff)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.9 [errors.7:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.9&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=19.9&show=diff)'
- en: 'If we now call `addToo` instead, it will no longer throw, but the exception
    will be returned in the `Result`. This won’t compile yet:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在调用`addToo`而不是`add`，它将不再抛出异常，但异常将在`Result`中返回。但这暂时无法编译：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[Example 19.10 [errors.8:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.10&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.10&show=diff)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.10 [errors.8:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.10&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=19.10&show=diff)'
- en: '[![1](assets/1.png)](#co_introduction_CO43-1)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_introduction_CO43-1)'
- en: '`Type mismatch. Required: Customer Found: Result<Customer,` `Duplicate​Excep⁠tion>`'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`类型不匹配。要求：Customer 实际：Result<Customer,` `Duplicate​Excep⁠tion>`'
- en: 'We have a `Result`, so we need to unpack it. When it is `Success`, we want
    to return the wrapped value; when `Failure`, throw the wrapped `DuplicateException`
    (to keep the current behavior of `register`):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个`Result`，所以我们需要解开它。当它是`Success`时，我们希望返回包装的值；当是`Failure`时，抛出包装的`DuplicateException`（以保持`register`的当前行为）：
- en: '[PRE21]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[Example 19.11 [errors.9:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.11&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.11&show=diff)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.11 [errors.9:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.11&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=19.11&show=diff)'
- en: 'As it happens, where the error type is an `Exception`, Result4k has a function
    to shortcut this case: `Result::orThrow`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 恰巧的是，当错误类型是`Exception`时，Result4k有一个函数来简化此情况：`Result::orThrow`：
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[Example 19.12 [errors.10:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.12&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.12&show=diff)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.12 [errors.10:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.12&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=19.12&show=diff)'
- en: 'Now we can inline to get back to a shorter form:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以内联以回到更简洁的形式：
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[Example 19.13 [errors.11:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.13&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.13&show=diff)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.13 [errors.11:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.13&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.13&show=diff)'
- en: Finally, that nesting is too confusing for comfort, so let’s simplify it by
    using “Replace ‘if’ with ‘when’”, “Replace return with ‘when’ expression”, and
    “Remove braces from all ‘when’ entries”. Alt-Enter all the things!
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，嵌套过多让人感到困惑，所以让我们通过使用“用‘when’替换‘if’”、“用‘when’表达式替换return”和“从所有‘when’条目中删除大括号”来简化它。Alt-Enter
    一切！
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[Example 19.14 [errors.12:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.14&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.14&show=diff)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.14 [errors.12:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.14&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.14&show=diff)'
- en: Splendid. We’ve replaced one of the uses of exceptions with a result type; let’s
    have a little rest.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 卓越的。我们用结果类型替换了异常的一种用法；让我们稍作休息。
- en: Contract
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合同
- en: Ready to go again? Good.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好再开始了吗？好的。
- en: We now have to choose whether to proceed depth- or breadth-first. Depth-first
    would address the caller of `CustomerRegistration::register`; breadth-first would
    first fix up the other callers of `Customers::add` so that we can remove it. As
    it happens, our example code has no other callers of `add`, so breadth-first isn’t
    an option, and we can get on with the contract phase of expand and contract.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在必须选择是深度优先还是广度优先。深度优先会解决`CustomerRegistration::register`的调用者；广度优先会先修复`Customers::add`的其他调用者，以便我们可以删除它。恰好，我们的示例代码没有`add`的其他调用者，所以广度优先不是一个选项，我们可以继续扩展和收缩的合同阶段。
- en: 'We currently have two implementations of `Customers::add`. One is the production
    implementation that talks to the database, the other a test implementation. Our
    code now calls them via the default implementation of `Customers::addToo` that
    we added to the interface. We want to delete the `add` implementations, so we
    need to implement `addToo` directly. Let’s look at the (not thread-safe) test
    version:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前有两个`Customers::add`的实现。一个是与数据库交互的生产实现，另一个是测试实现。我们的代码现在通过我们添加到接口的`Customers::addToo`的默认实现来调用它们。我们想要删除`add`实现，因此我们需要直接实现`addToo`。让我们看一下（不是线程安全的）测试版本：
- en: '[PRE25]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[Example 19.15 [errors.12:src/test/java/travelator/InMemoryCustomers.java]](https://java-to-kotlin.dev/code.html?ref=19.15&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.15&show=diff)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.15 [errors.12:src/test/java/travelator/InMemoryCustomers.java]](https://java-to-kotlin.dev/code.html?ref=19.15&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.15&show=diff)'
- en: 'The easiest way to implement `addToo` here is probably just to duplicate `add`
    and fix it up, returning `Failure` where we had thrown and `Success` for the happy
    path:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里实现`addToo`的最简单方法可能就是复制`add`并修复它，将我们抛出的地方返回`Failure`，将快乐路径返回`Success`：
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[Example 19.16 [errors.13:src/test/java/travelator/InMemoryCustomers.java]](https://java-to-kotlin.dev/code.html?ref=19.16&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.16&show=diff)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.16 [errors.13:src/test/java/travelator/InMemoryCustomers.java]](https://java-to-kotlin.dev/code.html?ref=19.16&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.16&show=diff)'
- en: 'We can also use this strategy to add `addToo` to our production implementations
    of `Customers`; we’ll skip the details. Once we are done, we can delete the unused
    `add` from the implementations and the interface and then rename `addToo` to `add`,
    leaving us with:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '我们也可以使用这种策略将`addToo`添加到`Customers`的生产实现中；我们将跳过细节。完成后，我们可以从实现和接口中删除未使用的`add`，然后将`addToo`重命名为`add`，留下： '
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[Example 19.17 [errors.14:src/main/java/travelator/Customers.kt]](https://java-to-kotlin.dev/code.html?ref=19.17&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.17&show=diff)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.17 [errors.14:src/main/java/travelator/Customers.kt]](https://java-to-kotlin.dev/code.html?ref=19.17&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.17&show=diff)'
- en: 'The clients of `Customers` are now back to calling `add`, albeit the version
    returning a `Result` rather than declaring checked exceptions:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`Customers`的客户现在又开始调用`add`，尽管是返回`Result`的版本，而不是声明受检异常：'
- en: '[PRE28]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[Example 19.18 [errors.14:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.18&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.18&show=diff)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.18 [errors.14:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.18&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.18&show=diff)'
- en: We left `InMemoryCustomers` as Java really just to demonstrate that we could
    return Result4k types from our old code, but we can’t resist the conversion, because
    the code now has a number of warnings of the type `Not annotated [X] overrides
    @NotNull [X]`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `InMemoryCustomers` 保留为 Java 仅仅是为了演示我们可以从旧代码返回 `Result4k` 类型，但我们无法抵制转换，因为现在代码有许多类型为
    `Not annotated [X] overrides @NotNull [X]` 的警告。
- en: 'After conversion, including moving from streams to Kotlin collection operations
    ([Chapter 13](ch13.html#streams-to-sequences)), we have:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 转换后，包括从流操作到 Kotlin 集合操作的移动（[第 13 章](ch13.html#streams-to-sequences)），我们有：
- en: '[PRE29]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[Example 19.19 [errors.15:src/test/java/travelator/InMemoryCustomers.kt]](https://java-to-kotlin.dev/code.html?ref=19.19&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.19&show=diff)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.19 [errors.15:src/test/java/travelator/InMemoryCustomers.kt]](https://java-to-kotlin.dev/code.html?ref=19.19&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.19&show=diff)'
- en: 'Let’s recap where we are now. `Customers` is now Kotlin, and `add` returns
    a `Result` instead of throwing `DuplicateException`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们现在的状态。`Customers` 现在是 Kotlin，`add` 返回 `Result` 而不是抛出 `DuplicateException`：
- en: '[PRE30]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[Example 19.20 [errors.15:src/main/java/travelator/Customers.kt]](https://java-to-kotlin.dev/code.html?ref=19.20&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.20&show=diff)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.20 [errors.15:src/main/java/travelator/Customers.kt]](https://java-to-kotlin.dev/code.html?ref=19.20&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.20&show=diff)'
- en: '`IRegisterCustomers` is still Java and still throws two types of exception:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`IRegisterCustomers` 仍然是 Java，并且仍然会抛出两种类型的异常：'
- en: '[PRE31]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[Example 19.21 [errors.15:src/main/java/travelator/IRegisterCustomers.java]](https://java-to-kotlin.dev/code.html?ref=19.21&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.21&show=diff)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.21 [errors.15:src/main/java/travelator/IRegisterCustomers.java]](https://java-to-kotlin.dev/code.html?ref=19.21&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.21&show=diff)'
- en: '`CustomerRegistration` is now Kotlin and is where we now thunk between `Result.Error`
    and `DuplicateException`, using `orThrow`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`CustomerRegistration` 现在是 Kotlin，我们现在在 `Result.Error` 和 `DuplicateException`
    之间进行 thunk 操作，使用 `orThrow`：'
- en: '[PRE32]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[Example 19.22 [errors.15:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.22&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.22&show=diff)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.22 [errors.15:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.22&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.22&show=diff)'
- en: We have converted a whole layer of our interaction to use a result type and
    can move out to the next.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将交互的整个层次转换为使用结果类型，并可以继续到下一个阶段。
- en: Stepping Out
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 走出去
- en: If we are to follow the same pattern with `IRegisterCustomers::register` as
    we did with `Customers`—providing a default implementation of an adapter between
    exception-throwing and error-returning—we will have to address the issue of how
    to express the result of a function that can fail for two reasons. That’s because
    `register` is currently declaring that it throws both `ExcludedException` and
    `DuplicateException` checked exceptions. In code, we want something like `Result<Customer,`
    `Either​<Exclu⁠dedException,` `DuplicateException>>`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要像处理 `Customers` 的 `IRegisterCustomers::register` 一样遵循相同的模式——提供异常抛出和错误返回之间的适配器的默认实现——我们将不得不解决一个函数可能由于两个原因失败的结果表达的问题。这是因为
    `register` 目前声明同时抛出 `ExcludedException` 和 `DuplicateException` 检查异常。在代码中，我们希望得到类似
    `Result<Customer, Either​<Exclu⁠dedException, DuplicateException>>` 的东西。
- en: 'We *could* use a generic `Either` type, but that only gets us so far as a strategy.
    Unlike Java, where the order that we declare exceptions doesn’t matter, `Either<Exclu⁠ded​Excep⁠tion,
    DuplicateException>` is not the same thing as `Either<DuplicateException,` `ExcludedException>`.
    The `Either` is at best really confusing and will get even worse if we ever have
    more than two exceptions: `OneOf<ExcludedException, Duplicate​Ex⁠cep⁠tion, SomeOtherProblem>`
    is just horrible.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们*可以*使用通用的 `Either` 类型，但这只能作为一种策略，这和 Java 不同，我们声明异常的顺序不重要，`Either<Exclu⁠ded​Excep⁠tion,
    DuplicateException>` 不同于 `Either<DuplicateException, ExcludedException>`。`Either`
    最多只是令人困惑的东西，如果我们有超过两个异常，情况将变得更糟：`OneOf<ExcludedException, Duplicate​Ex⁠cep⁠tion,
    SomeOtherProblem>` 简直糟透了。
- en: 'Another option is to move up to the common superclass of the two exceptions
    and declare the return type as `Result<Customer, Exception>`. This fails the communication
    test: we can’t look at the signature and gain any clues about what types of errors
    we are expecting.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是提升到这两个异常的共同超类，并将返回类型声明为 `Result<Customer, Exception>`。这不符合通信测试：我们无法查看签名并获取任何关于我们期望的错误类型的线索。
- en: Instead, our best strategy here is not to try to express the error in terms
    of existing types, but to map to a new type.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们在这里的最佳策略不是试图用现有类型来表达错误，而是映射到一个新类型。
- en: 'As *exception* and *error* are all overloaded terms, we’ve chosen `RegistrationProblem`,
    with subtypes of `Excluded` (which carries no additional information and so can
    be an `object`), and `Duplicate` (which carries any message from the original
    `DuplicateException`):'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 由于“异常”和“错误”都是负载过重的术语，我们选择了`RegistrationProblem`，其子类型有`Excluded`（不携带额外信息，因此可以是一个`object`）和`Duplicate`（携带原始`DuplicateException`的任何消息）：
- en: '[PRE33]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[Example 19.23 [errors.16:src/main/java/travelator/IRegisterCustomers.kt]](https://java-to-kotlin.dev/code.html?ref=19.23&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.23&show=diff)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.23 [errors.16:src/main/java/travelator/IRegisterCustomers.kt]](https://java-to-kotlin.dev/code.html?ref=19.23&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.23&show=diff)'
- en: By making `RegistrationProblem` a sealed class, we know at compile time what
    subclasses can exist and, hence, what errors have to be handled—very much like
    the checked exception signature of a method.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`RegistrationProblem`定义为密封类，我们在编译时知道哪些子类可能存在，因此知道必须处理的错误，这非常类似于方法的检查异常签名。
- en: 'We can use this `RegistrationProblem` when we follow the pattern from earlier,
    adding a default implementation of `registerToo` to the interface that returns
    `Result<Customer, RegistrationProblem>`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们遵循先前的模式时，我们可以在接口中添加`registerToo`的默认实现，并使用返回`Result<Customer, RegistrationProblem>`：
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[Example 19.24 [errors.16:src/main/java/travelator/IRegisterCustomers.kt]](https://java-to-kotlin.dev/code.html?ref=19.24&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.24&show=diff)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.24 [errors.16:src/main/java/travelator/IRegisterCustomers.kt]](https://java-to-kotlin.dev/code.html?ref=19.24&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.24&show=diff)'
- en: 'Now we can migrate callers of `register` to `registerToo`. We’ll start with
    `Customer​Regis⁠trationHandler`, converting it to Kotlin first:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将`register`的调用者迁移到`registerToo`。我们将从`Customer​Regis⁠trationHandler`开始，首先将其转换为
    Kotlin：
- en: '[PRE35]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[Example 19.25 [errors.17:src/main/java/travelator/handlers/CustomerRegistrationHandler.kt]](https://java-to-kotlin.dev/code.html?ref=19.25&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.25&show=diff)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.25 [errors.17:src/main/java/travelator/handlers/CustomerRegistrationHandler.kt]](https://java-to-kotlin.dev/code.html?ref=19.25&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.25&show=diff)'
- en: 'Now, as we did before, we swap to calling the new method (`registerToo`) instead
    of the old one (`register`) and interpret the return type with a `when` expression:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，就像之前一样，我们转而调用新方法（`registerToo`）而不是旧方法（`register`），并使用`when`表达式解释返回类型：
- en: '[PRE36]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[Example 19.26 [errors.18:src/main/java/travelator/handlers/CustomerRegistrationHandler.kt]](https://java-to-kotlin.dev/code.html?ref=19.26&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.26&show=diff)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.26 [errors.18:src/main/java/travelator/handlers/CustomerRegistrationHandler.kt]](https://java-to-kotlin.dev/code.html?ref=19.26&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.26&show=diff)'
- en: 'Finally, we can remove the unnecessary exception cases and simplify the error
    case with `map` and `recover`. `Result::recover` is a Result4k extension function
    that unwraps the result if it is `Success`, otherwise returning the result of
    mapping the failure’s `reason`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以删除不必要的异常情况，并使用`map`和`recover`简化错误情况。`Result::recover`是一个 Result4k 的扩展函数，如果是`Success`则解包结果，否则返回映射失败的`reason`的结果：
- en: '[PRE37]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[Example 19.27 [errors.19:src/main/java/travelator/handlers/CustomerRegistrationHandler.kt]](https://java-to-kotlin.dev/code.html?ref=19.27&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.27&show=diff)'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.27 [errors.19:src/main/java/travelator/handlers/CustomerRegistrationHandler.kt]](https://java-to-kotlin.dev/code.html?ref=19.27&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.27&show=diff)'
- en: 'Note that this code is still not exception-free. First, the `ObjectMapper`
    can still throw `JSONProcessingException`. That is the reality of Java (and frankly
    most Kotlin) APIs, but the code is safe and communicates well, because the throwing
    and catching are in the same method. Second, we still have to consider other `RuntimeException`s
    that could be thrown from anywhere: `NullPointerException` and so on. These could
    have crossed function boundaries and leaked up to here, where the buck stops at
    the top-level catch-all, which returns `HTTP_INTERNAL_ERROR`. The reality is that
    we can still have *unexpected* exceptions, but the *expected* failure cases are
    now expressed by `Results` and communicated in our code.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这段代码仍然不是无异常的。首先，`ObjectMapper`仍然可以抛出`JSONProcessingException`。这是Java（实际上大多数Kotlin）API的现实，但代码是安全的且表达清晰，因为抛出和捕获在同一个方法中。其次，我们仍然需要考虑可能从任何地方抛出的其他`RuntimeException`，例如`NullPointerException`等。这些异常可能已经跨越了函数边界并最终泄漏到这里，在这里的顶级全捕捉中返回`HTTP_INTERNAL_ERROR`。现实情况是，我们仍然可能会遇到*意外*的异常，但*预期的*失败情况现在由`Results`表示并在我们的代码中传达。
- en: More Fixup
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多修复
- en: We can now confess that the `RegistrationHandlerTests` got broken a few steps
    ago. Ordinarily we would have fixed them straightaway, but that would have interrupted
    our explanation.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以承认，`RegistrationHandlerTests`在几步之前就已经出问题了。通常我们会立即修复它们，但那样会打断我们的解释。
- en: 'The problem is that the tests are mock tests, which expect calls to `IRegister.register`,
    but we are now calling `registerToo`. For example:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于这些测试是模拟测试，期望调用`IRegister.register`，但我们现在却调用了`registerToo`。例如：
- en: '[PRE38]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[Example 19.28 [errors.20:src/test/java/travelator/handlers/CustomerRegistrationHandlerTests.java]](https://java-to-kotlin.dev/code.html?ref=19.28&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.28&show=diff)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.28 [errors.20:src/test/java/travelator/handlers/CustomerRegistrationHandlerTests.java]](https://java-to-kotlin.dev/code.html?ref=19.28&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.28&show=diff)'
- en: 'To fix the tests, we need to change the call from `register`, returning `Customer`
    or throwing, to `registerToo`, returning `Result<Customer, RegistrationProblem>`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复测试，我们需要将调用`register`改为调用`registerToo`，后者返回`Result<Customer, RegistrationProblem>`或抛出异常：
- en: '[PRE39]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[Example 19.29 [errors.21:src/test/java/travelator/handlers/CustomerRegistrationHandlerTests.java]](https://java-to-kotlin.dev/code.html?ref=19.29&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.29&show=diff)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.29 [errors.21:src/test/java/travelator/handlers/CustomerRegistrationHandlerTests.java]](https://java-to-kotlin.dev/code.html?ref=19.29&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.29&show=diff)'
- en: The tests are actually simplified, because instead of having to choose `thenReturn`
    or `thenThrow`, we are now always mocking with `thenReturn`, with `Success` or
    `Failure`, respectively.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的测试变得更简单了，因为我们不再需要选择`thenReturn`或`thenThrow`，而是总是使用`thenReturn`进行模拟，分别返回`Success`或`Failure`。
- en: 'Now that our tests are passing again, we can return to production code and
    implement `CustomerRegistration::registerToo` directly. In lieu of any cleverer
    idea, we do this by duplicating the `register` method and fettling the error handling.
    We do this using `Result::mapFailure` (part of Result4k) to convert `DuplicateException`
    to `Duplicate`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的测试再次通过了，我们可以返回到生产代码并直接实现`CustomerRegistration::registerToo`。如果没有更聪明的想法，我们可以通过复制`register`方法并调整错误处理来做到这一点。我们使用`Result::mapFailure`（Result4k的一部分）将`DuplicateException`转换为`Duplicate`：
- en: '[PRE40]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[Example 19.30 [errors.22:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.30&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.30&show=diff)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.30 [errors.22:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.30&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.30&show=diff)'
- en: '[![1](assets/1.png)](#co_introduction_CO44-1)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_introduction_CO44-1)'
- en: Note that we explicitly specify the type of the lambda parameter in `mapFailure`.
    As we will see later, this way if we change the return type of `add` to have a
    different failure type, the compiler will force us to change how we handle it.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在`mapFailure`中我们显式指定了lambda参数的类型。正如我们后面将看到的，这样做可以在我们将`add`的返回类型更改为不同的失败类型时，强制我们更改处理方式。
- en: 'There are two problems with this. First, `registerToo` has no test code, and
    second, we have the duplicate logic caused by our duplicating `register` to create
    `registerToo`. We can fix both by implementing `register` in terms of `registerToo`—the
    opposite of what we did in `Customers`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个问题。首先，`registerToo`没有测试代码；其次，我们由于复制`register`来创建`registerToo`而导致重复逻辑。我们可以通过将`register`实现为`registerToo`的调用来解决这两个问题，这与我们在`Customers`中所做的相反：
- en: '[PRE41]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[Example 19.31 [errors.23:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.31&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.31&show=diff)'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[![1](assets/1.png)](#co_introduction_CO45-1)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Delegate to `registerToo` and process `Error` type.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'Now our `CustomerRegistrationTests`, which work in terms of `register`, will
    be testing `registerToo` for us:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[Example 19.32 [errors.23:src/test/java/travelator/CustomerRegistrationTests.java]](https://java-to-kotlin.dev/code.html?ref=19.32&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.32&show=diff)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'This would be a good way to keep both `register` and `registerToo` while we
    migrate away from Java and exceptions to Kotlin and an error type. In this case,
    though, the tests are actually the last callers of `register`, so let’s convert
    them to call `registerToo`. We could take the time to show how to use Result4k
    in Java, but we’re all pretty tired of this example now, so we’ll convert the
    tests to Kotlin and then have them call `register` with the immortal words, “Here’s
    one I made earlier”:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[Example 19.33 [errors.24:src/test/java/travelator/CustomerRegistrationTests.kt]](https://java-to-kotlin.dev/code.html?ref=19.33&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.33&show=diff)'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have no callers of `register`, we can finally remove it and rename
    `registerToo` to `register`, ending up with exception-free Kotlin:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[Example 19.34 [errors.25:src/main/java/travelator/IRegisterCustomers.kt]](https://java-to-kotlin.dev/code.html?ref=19.34&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.34&show=diff)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[Example 19.35 [errors.25:src/main/java/travelator/Customers.kt]](https://java-to-kotlin.dev/code.html?ref=19.35&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.35&show=diff)'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Hmm, not quite exception-free because of that `DuplicateException`. It is not
    actually *thrown* from anywhere anymore, just created and put into a `Failure`.
    We can fix this either by renaming the class to `DuplicateCustomerProblem` and
    stop it from extending `Exception`, or reuse the existing `Duplicate` subclass
    of `RegistrationProblem`. Which is better?
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Layers
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we think in terms of layers, `Customers` is in a lower layer than `Registration`,
    which depends on it. So `Customers` should not depend on the higher-level `Registration​Pro⁠blem`.
    We could try to invert the dependency so that the `Duplicate` subclass of `RegistrationProblem`
    is a subtype (or even just the same type) of `DuplicateCustomer​Pro⁠blem` declared
    in the repository layer. That would work here, but is a bit of a dead-end if `Customers::add`
    ever needs to declare another way that it might fail. If, for example, we want
    to show in our result that database communications might fail, we can’t (well,
    shouldn’t) make that a subtype of `DuplicateCustomerProblem`. So we will be back
    to the problem of expressing more than one error type in a single result.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s chase that through. If `Customers::add` needs to declare more than one
    way that it can fail—our previous `DuplicateCustomerProblem` and our new `DatabaseCustomer​Pro⁠blem`—we
    introduce a sealed `CustomersProblem` as the error type and make the two known
    problems its only subclasses:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[Example 19.36 [errors.27:src/main/java/travelator/Customers.kt]](https://java-to-kotlin.dev/code.html?ref=19.36&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.36&show=diff)'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '`CustomerRegistration` was calling `Customers::add` and handling just `DuplicateCustomerProblem`
    in `mapFailure`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[Example 19.37 [errors.26:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.37&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.37&show=diff)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'This no longer compiles, because the type of the failure is now the `CustomersProblem`
    base class. You can see that we are getting the advantages of checked exceptions:
    code is communicating the ways in which it can fail and forcing us to deal with
    the cases.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that `Customers::add` admits that it can fail in a new and interesting
    way, `register` is also forced to handle the truth. It decides to pass the knowledge
    on to its callers (well OK, we decide for it) by adding a new `DatabaseProblem`
    subtype of the existing `RegistrationProblem` sealed class:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[Example 19.38 [errors.27:src/main/java/travelator/IRegisterCustomers.kt]](https://java-to-kotlin.dev/code.html?ref=19.38&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.38&show=diff)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can fix `register` by converting between the ways that `add` can fail
    (`DuplicateCustomerProblem` and `DatabaseCustomerProblem`) and the ways that `register`
    can fail (`Duplicate` and `DatabaseProblem`, respectively). This now makes the
    choice of `map​Fai⁠lure` clear:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[Example 19.39 [errors.27:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.39&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.39&show=diff)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, because we’ve added to the `RegistrationProblem` sealed hierarchy,
    the compiler now forces us to consider the `DatabaseProblem` in the next layer
    up by failing to compile `CustomerRegistrationHandler`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[Example 19.40 [errors.27:src/main/java/travelator/handlers/CustomerRegistrationHandler.kt]](https://java-to-kotlin.dev/code.html?ref=19.40&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.40&show=diff)'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[![1](assets/1.png)](#co_introduction_CO46-1)'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: We have to add a case for `DatabaseProblem` to get the `when` expression to
    compile.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Because the `CustomerRegistrationHandler` is the entry point for this interaction,
    our work is now done.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Moving On
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This has been a long chapter, but its length is in proportion to its importance.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Your Java project may already have declared exception bankruptcy, with no systematic
    use of checked exceptions. In this case, Kotlin’s policy of treating everything
    as an unchecked exception will be fine.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: If you do lean on checked exceptions and want to translate to Kotlin, or want
    to raise your error handling game as part of the conversion, then using a result
    type is the best strategy. Where an operation can fail in multiple ways, we can
    use sealed classes to enumerate the failure modes, at the expense of not being
    able to propagate the same type through multiple layers. When we have multiple
    layers, things return to being tedious, but at least they are not very error prone.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: We could (and maybe should) write a whole book on error handling, but in the
    meantime you can follow Duncan’s journey down the rabbit hole on [his blog](https://oreil.ly/kfvAn).
    As well as the material covered here, this shows how to reduce the number of functions
    that are subject to failure because they are [partial functions](https://oreil.ly/8RoO4).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: 'Reducing the number of our functions that can fail is important, because code
    that is subject to error is very similar to the actions that we saw in [Chapter 7,
    *Actions to Calculations*](ch07.html#actions-to-calculations). Actions pollute
    their callers: by default, code that calls an action becomes an action. In the
    same way, code that calls code that is subject to failure is itself subject to
    failure. We can mitigate the effects of both actions and errors by moving them
    as close as we can to the entry points to our system, so that they taint the least
    code.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: We touched briefly in this chapter on making our code robust to errors when
    they occur. Actions are a problem here too, because they affect the state of our
    system. State can be corrupted when two things need to be updated, and the first
    action writes, but the second doesn’t because an error happened before it was
    invoked. A rigorous focus on the difference between actions and calculations is
    the key to making robust software.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: We will return to error handling in [Chapter 21, *Exceptions to Values*](ch21.html#exceptions-to-values).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
