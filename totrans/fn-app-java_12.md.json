["```java\ntry {\n  return doCalculation(input);\n} catch (ArithmeticException e) {\n  this.log.error(\"Calculation failed\", e);\n  return null;\n}\n```", "```java\ntry {\n  return doCalculation(input);\n} catch (ArithmeticException | IllegalArgumentException e) {\n  this.log.error(\"Calculation failed\", e);\n  return null;\n}\n```", "```java\ntry (var fileReader = new FileReader(file);\n     var bufferedReader = new BufferedReader(fileReader)) {\n\n    var firstLine = bufferedReader.readLine();\n    System.out.println(firstLine);\n} catch (IOException e) {\n  System.err.printlin(\"Couldn't read first line of \" + file);\n}\n```", "```java\npublic static String readString(Path path) throws IOException {\n  // ...\n}\n```", "```java\nStream.of(path1, path2, path3)\n      .map(Files::readString)\n      .forEach(System.out::println);\n\n// Compiler Error:\n// incompatible thrown types java.io.IOException in functional expression\n```", "```java\nStream.of(path1, path2, path3)\n      .map(path -> {\n        try {\n          return Files.readString(path);\n        } catch (IOException e) {\n          return null;\n        }\n      })\n      .forEach(System.out::println);\n```", "```java\nString safeReadString(Path path) { ![1](assets/1.png)\n  try { ![2](assets/2.png)\n    return Files.readString(path);\n  } catch (IOException e) {\n    return null;\n  }\n}\n\nStream.of(path1, path2, path3)\n      .map(this::safeReadString) ![3](assets/3.png)\n      .filter(Objects::nonNull) ![4](assets/4.png)\n      .forEach(System.out::println);\n```", "```java\n@FunctionalInterface\npublic interface ThrowingFunction<T, U> extends Function<T, U> { ![1](assets/1.png)\n\n  U applyThrows(T elem) throws Exception; ![2](assets/2.png)\n\n  @Override\n  default U apply(T t) { ![3](assets/3.png)\n    try {\n      return applyThrows(t);\n    } catch (Exception e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  public static <T, U> Function<T, U> uncheck(ThrowingFunction<T, U> fn) { ![4](assets/4.png)\n    return fn::apply;\n  }\n}\n```", "```java\nThrowingFunction<Path, String> throwingFn = Files::readString; ![1](assets/1.png)\n\nStream.of(path1, path2, path3)\n      .map(ThrowingFunction.uncheck(Files::readString)) ![2](assets/2.png)\n      .filter(Objects::nonNull)\n      .forEach(System.out::println);\n```", "```java\nString sneakyRead(File input) {\n\n  // ...\n\n  if (fileNotFound) {\n    sneakyThrow(new IOException(\"File '\" + file + \"' not found.\"));\n  }\n\n  // ...\n}\n```", "```java\n<E extends Throwable> void sneakyThrow(Throwable e) throws E {\n  throw (E) e;\n}\n```", "```java\nOptional<String> safeReadString(Path path) { ![1](assets/1.png)\n  try {\n    var content = Files.readString(path);\n    return Optional.of(content);\n  } catch (IOException e) {\n    return Optional.empty(); ![2](assets/2.png)\n  }\n}\n```", "```java\nfunc safeReadString(path string) (string, error) {\n  // ...\n}\n\ncontent, err := safeReadString(\"location/content.md\")\nif err != nil {\n  // error handling code\n}\n```", "```java\npublic record Result<V, E extends Throwable>(V value, ![1](assets/1.png)\n                                             E throwable,\n                                             boolean isSuccess) {\n\n  public static <V, E extends Throwable> Result<V, E> success(V value) { ![2](assets/2.png)\n    return new Result<>(value, null, true);\n  }\n\n  public static <V, E extends Throwable> Result<V, E> failure(E throwable) { ![2](assets/2.png)\n    return new Result<>(null, throwable, false);\n  }\n}\n```", "```java\nResult<String, IOException> safeReadString(Path path) {\n  try {\n    return Result.success(Files.readString(path));\n  } catch (IOException e) {\n    return Result.failure(e);\n  }\n}\n\nStream.of(path1, path2, path3)\n      .map(this::safeReadString)\n      .filter(Result::isSuccess)\n      .forEach(System.out::println);\n```", "```java\npublic record Result<V, E extends Throwable> (V value,\n                                              E throwable,\n                                              boolean isSuccess) {\n  // ...\n\n  public <R> Optional<R> mapSuccess(Function<V, R> fn) { ![1](assets/1.png)\n    return this.isSuccess ? Optional.ofNullable(this.value).map(fn)\n                          : Optional.empty();\n  }\n\n  public <R> Optional<R> mapFailure(Function<E, R> fn) { ![1](assets/1.png)\n    return this.isSuccess ? Optional.empty()\n                          : Optional.ofNullable(this.throwable).map(fn);\n  }\n\n  public <R> R map(Function<V, R> successFn, ![2](assets/2.png)\n                   Function<E, R> failureFn) {\n    return this.isSuccess ? successFn.apply(this.value) //\n                          : failureFn.apply(this.throwable);\n  }\n}\n```", "```java\n// HANDLE ONLY SUCCESS CASE\n\nStream.of(path1, path2, path3)\n      .map(this::safeReadString)\n      .map(result -> result.mapSuccess(String::toUpperCase))\n      .flatMap(Optional::stream)\n      .forEach(System.out::println);\n\n// HANDLE BOTH CASES\n\nvar result = safeReadString(path).map(\n  success -> success.toUpperCase(),\n  failure -> \"IO-Error: \" + failure.getMessage()\n);\n```", "```java\npublic record Result<V, E extends Throwable> (V value,\n                                              E throwable,\n                                              boolean isSuccess) {\n  // ...\n\n  public void ifSuccess(Consumer<? super V> action) {\n    if (this.isSuccess) {\n      action.accept(this.value);\n    }\n  }\n\n  public void ifFailure(Consumer<? super E> action) {\n    if (!this.isSuccess) {\n      action.accept(this.throwable);\n    }\n  }\n\n  public void handle(Consumer<? super V> successAction,\n                     Consumer<? super E> failureAction) {\n    if (this.isSuccess) {\n      successAction.accept(this.value);\n    } else {\n      failureAction.accept(this.throwable);\n    }\n  }\n}\n```", "```java\npublic record Result<V, E extends Throwable>(V value,\n                                             E throwable,\n                                             boolean isSuccess) {\n  // ...\n\n  public V orElse(V other) {\n    return this.isSuccess ? this.value\n                          : other;\n  }\n\n  public V orElseGet(Supplier<? extends V> otherSupplier) {\n    return this.isSuccess ? this.value\n                          : otherSupplier.get();\n  }\n}\n```", "```java\npublic record Result<V, E extends Throwable>(V value,\n                                             E throwable,\n                                             boolean isSuccess) {\n  // ...\n\n  private <E extends Throwable> void sneakyThrow(Throwable e) throws E {\n    throw (E) e;\n  }\n\n  public V orElseThrow() {\n    if (!this.isSuccess) {\n      sneakyThrow(this.throwable);\n      return null;\n    }\n\n    return this.value;\n  }\n}\n```", "```java\ndef readString(path: Path): Try[String] = Try { ![1](assets/1.png)\n  // code that will throw an Exception }\n\nval path = Path.of(...);\n\nreadString(path) match { ![2](assets/2.png)\n  case Success(value) => println(value.toUpperCase) ![3](assets/3.png)\n  case Failure(e) => println(\"Couldn't read file: \" + e.getMessage) ![4](assets/4.png)\n}\n```", "```java\npublic class Try<T, R> { ![1](assets/1.png)\n\n  private final Function<T, R>                fn; ![2](assets/2.png)\n  private final Function<RuntimeException, R> failureFn; ![2](assets/2.png)\n\n  public static <T, R> Try<T, R> of(ThrowingFunction<T, R> fn) { ![3](assets/3.png)\n    Objects.requireNonNull(fn);\n\n    return new Try<>(fn,\n                     null);\n  }\n\n  private Try(Function<T, R> fn, ![4](assets/4.png)\n              Function<RuntimeException, R> failureFn) {\n    this.fn = fn;\n    this.failureFn = failureFn;\n  }\n}\n```", "```java\nvar trySuccessFailure = Try.<Path, String> of(Files::readString);\n```", "```java\npublic class Try<T, R> {\n\n  // ...\n\n  public Try<T, R> success(Function<R, R> successFn) {\n    Objects.requireNonNull(successFn);\n\n    var composedFn = this.fn.andThen(successFn); ![1](assets/1.png)\n    return new Try<>(composedFn,\n                     this.failureFn);\n  }\n\n  public Try<T, R> failure(Function<RuntimeException, R> failureFn) {\n    Objects.requireNonNull(failureFn);\n\n    return new Try<>(this.fn, ![2](assets/2.png)\n                     failureFn);\n  }\n}\n```", "```java\nvar trySuccessFailure =\n  Try.<Path, String> of(Files::readString)\n                    .success(String::toUpperCase)\n                    .failure(str -> null);\n```", "```java\npublic class Try<T, R> {\n\n  // ...\n\n  public Optional<R> apply(T value) {\n    try {\n      var result = this.fn.apply(value);\n      return Optional.ofNullable(result); ![1](assets/1.png)\n    }\n    catch (RuntimeException e) {\n      if (this.failureFn != null) { ![2](assets/2.png)\n        var result = this.failureFn.apply(e);\n        return Optional.ofNullable(result);\n      }\n    }\n\n    return Optional.empty(); ![3](assets/3.png)\n  }\n}\n```", "```java\nvar path = Path.of(\"location\", \"content.md\");\n\nOptional<String> content =\n  Try.<Path, String> of(Files::readString)\n                    .success(String::toUpperCase)\n                    .failure(str -> null)\n                    .apply(path);\n```", "```java\npublic class Try<T, R> implements Function<T, Optional<R>> {\n\n  // ...\n\n  @Override\n  public Optional<R> apply(T value) {\n    // ...\n  }\n}\n```", "```java\nFunction<Path, Optional<String>> fileLoader =\n  Try.<Path, String> of(Files::readString)\n                    .success(String::toUpperCase)\n                    .failure(str -> null);\n\nStream.of(path1, path2, path3)\n      .map(fileLoader)\n      .flatMap(Optional::stream)\n      .toList();\n```"]