- en: Chapter 1\. Introduction to Serverless, Amazon Web Services, and AWS Lambda
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To start off your serverless journey, we’re going to take you on a brief tour
    of the cloud and then define serverless. After that, we dive into Amazon Web Services
    (AWS)—this will be new to some of you and a refresher to others.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: With those foundations set, we introduce Lambda—what it is, why you might use
    it, what you can build with Lambda, and how Java and Lambda work together.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: A Quick History Lesson
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s travel back in time to 2006\. No one has an iPhone yet, Ruby on Rails
    is a hot new programming environment, and Twitter is being launched. More germane
    to us, however, is that at this point in time many people are hosting their server-side
    applications on physical servers that they own and have racked in a data center.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: In August 2006 something happened that would fundamentally change this model.
    Amazon’s new IT division, AWS, announced the launch of [Elastic Compute Cloud
    (EC2)](https://aws.amazon.com/ec2).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: EC2 was one of the first infrastructure-as-a-service (IaaS) products. IaaS allows
    companies to rent compute capacity—that is, a host to run their internet-facing
    server applications—rather than buying their own machines. It also allows them
    to provision hosts just in time, with the delay from requesting a machine to its
    availability being on the order of minutes. In 2006 this was all possible because
    of the advances in *virtualization* technology—all EC2 hosts at that time were
    *virtual machines*.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: 'EC2’s five key advantages are:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Reduced labor cost
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Before IaaS, companies needed to hire specific technical operations staff who
    would work in data centers and manage their physical servers. This meant everything
    from power and networking to racking and installing to fixing physical problems
    with machines like bad RAM to setting up the operating system (OS). With IaaS
    all of this goes away and instead becomes the responsibility of the IaaS service
    provider (AWS in the case of EC2).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Reduced risk
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: When managing their own physical servers, companies are exposed to problems
    caused by unplanned incidents like failing hardware. This introduces downtime
    periods of highly volatile length since hardware problems are usually infrequent
    and can take a long time to fix. With IaaS, the customer, while still having some
    work to do in the event of a hardware failure, no longer needs know what to do
    to fix the hardware. Instead the customer can simply request a new machine instance,
    available within a few minutes, and reinstall the application, limiting exposure
    to such issues.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Reduced infrastructure cost
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'In many scenarios the cost of a connected EC2 instance is cheaper than running
    your own hardware when you take into account power, networking, etc. This is especially
    valid when you want to run hosts for a only few days or weeks, rather than many
    months or years at a stretch. Similarly, renting hosts by the hour rather than
    buying them outright allows different accounting: EC2 machines are an operating
    expense (Opex) rather than the capital expense (Capex) of physical machines, typically
    allowing much more favorable accounting flexibility.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Scaling
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Infrastructure costs drop significantly when considering the scaling benefits
    IaaS brings. With IaaS, companies have far more flexibility in scaling the numbers
    and types of servers they run. There is no longer a need to buy 10 high-end servers
    up front because you think you might need them in a few months’ time. Instead,
    you can start with one or two low-powered, inexpensive virtual machines (VMs)
    and then scale your number and types of VMs up and down over time without any
    negative cost impact.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Lead time
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: In the bad old days of self-hosted servers, it could take months to procure
    and provision a server for a new application. If you came up with an idea you
    wanted to try within a few weeks, then that was just too bad. With IaaS, lead
    time goes from months to minutes. This has ushered in the age of rapid product
    experimentation, as encouraged by the ideas in [Lean Startup](http://theleanstartup.com).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: The Cloud Grows
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: IaaS was one of the first key elements of the cloud, along with storage (e.g.,
    AWS [Simple Storage Service (S3)](https://aws.amazon.com/s3)). AWS was an early
    mover in cloud services, and is still a leading provider, but there are many other
    cloud vendors such as Microsoft and Google.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: The next evolution of the cloud was platform as a service (PaaS). One of the
    most popular PaaS providers is Heroku. PaaS layers on top of IaaS, abstracting
    the management of the host’s operating system. With PaaS you deploy just applications,
    and the platform is responsible for OS installation, patch upgrades, system-level
    monitoring, service discovery, etc.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: An alternative to using a PaaS is to use containers. [Docker](https://www.docker.com)
    has become incredibly popular over the last few years as a way to more clearly
    delineate an application’s system requirements from the nitty-gritty of the operating
    system itself. There are cloud-based services to host and manage/orchestrate containers
    on a team’s behalf, and these are often referred to as containers-as-a-service
    (CaaS) products. Amazon, Google, and Microsoft all offer CaaS platforms. Managing
    fleets of Docker containers has been made easier by use of tools like [Kubernetes](https://kubernetes.io),
    either in a self-managed form or as part of a CaaS (e.g., GKE from Google, EKS
    from Amazon, or AKS from Microsoft).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: All three of these ideas—IaaS, PaaS, and CaaS—can be grouped as *compute as
    a service*; in other words, they are different types of generic environments that
    we can run our own specialized software in. PaaS and CasS differ from IaaS by
    raising the level of abstraction further, allowing us to hand off more of our
    “heavy lifting” to others.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Enter Serverless
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Serverless is the next evolution of cloud computing and can be divided into
    two ideas: backend as a service and functions as a service.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Backend as a Service
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Backend as a service (BaaS) allows us to replace server-side components that
    we code and/or manage ourselves with off-the-shelf services. It’s closer in concept
    to software as a service (SaaS) than it is to things like virtual instances and
    containers. SaaS is typically about outsourcing business processes, though—think
    HR or sales tools or, on the technical side, products like GitHub—whereas with
    BaaS, we’re breaking up our applications into smaller pieces and implementing
    some of those pieces entirely with externally hosted products.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: BaaS services are domain-generic remote components (i.e., not in-process libraries)
    that we can incorporate into our products, with an application programming interface
    (API) being a typical integration paradigm.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: BaaS has become especially popular with teams developing mobile apps or single-page
    web apps. Many such teams are able to rely significantly on third-party services
    to perform tasks that they would otherwise have needed to do themselves. Let’s
    look at a couple of examples.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'First up we have services like Google’s [Firebase](https://firebase.google.com).
    Firebase is a database product that is fully managed by a vendor (Google in this
    case) that can be accessed directly from a mobile or web application without the
    need for our own intermediary application server. This represents one aspect of
    BaaS: services that manage data components on our behalf.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: BaaS services also allow us to rely on application logic that someone else has
    implemented. A good example here is authentication—many applications implement
    their own code to perform sign-up, login, password management, etc., but more
    often than not this code is similar across many apps. Such repetition across teams
    and businesses is ripe for extraction into an external service, and that’s precisely
    the aim of products like [Auth0](https://auth0.com) and Amazon’s [Cognito](https://aws.amazon.com/cognito).
    Both of these products allow mobile apps and web apps to have fully featured authentication
    and user management, but without a development team having to write or manage
    any of the code to implement those features.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: The term *BaaS* came to prominence with the rise in mobile application development;
    in fact, the term is sometimes referred to as *mobile backend as a service* (MBaaS).
    However, the key idea of using fully externally managed products as part of our
    application development is not unique to mobile development, or even frontend
    development in general.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*BaaS*一词随着移动应用程序开发的兴起而显现出来；事实上，有时这个术语被称为*移动后端即服务*（MBaaS）。然而，使用完全外部管理的产品作为我们应用程序开发的一部分的关键思想并不局限于移动开发，甚至不限于前端开发。'
- en: Functions as a Service
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作为服务的功能
- en: The other half of serverless is functions as a service (FaaS). FaaS, like IaaS,
    PaaS, and CaaS, is another form of compute as a service—a generic environment
    within which we can run our own software. Some people like to use the term *serverless
    compute* instead of FaaS.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器的另一半是函数即服务（FaaS）。FaaS，像IaaS、PaaS和CaaS一样，是计算作为服务的另一种形式—一个通用的环境，在其中我们可以运行我们自己的软件。有些人喜欢使用术语*无服务器计算*来代替FaaS。
- en: With FaaS we deploy our code as independent functions or operations, and we
    configure those functions to be called, or triggered, when a specific event or
    request occurs within the FaaS platform. The platform itself calls our functions
    by instantiating a dedicated environment *for each event*—this environment consists
    of an ephemeral, fully managed lightweight virtual machine, or container; the
    FaaS runtime; and our code.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用FaaS，我们将我们的代码部署为独立的函数或操作，并配置这些函数在FaaS平台内发生特定事件或请求时被调用或触发。平台本身通过为每个事件实例化专用环境来调用我们的函数—这个环境由一个临时的、完全托管的轻量级虚拟机或容器；FaaS运行时；和我们的代码组成。
- en: The result of this type of environment is that we have no concern for the runtime
    management of our code, unlike any other style of compute platform.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这种环境的结果是，我们不必关心我们代码的运行时管理，这与任何其他计算平台的风格都不同。
- en: Furthermore, because of several factors of serverless in general that we describe
    in a moment, with FaaS we have no concern for hosts or processes, and scaling
    and resource management are handled on our behalf.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于我们稍后将描述的无服务器的几个因素，使用FaaS时我们不必担心主机或进程，并且缩放和资源管理由平台代为处理。
- en: Differentiating Serverless
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 区分无服务器
- en: The idea of using externally hosted application components, as we do with BaaS,
    is not new—people have been using hosted SQL databases for a decade or more—so
    what makes some of these services qualify as backends as a service? And what aspects
    do BaaS and FaaS have in common that cause us to group them into the idea of serverless
    computing?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用外部托管的应用程序组件的想法，就像我们使用BaaS一样，不是新鲜事—人们已经使用托管的SQL数据库十年甚至更长时间了—那么是什么使得这些服务有资格作为后端服务呢？BaaS和FaaS有哪些共同点，使我们将它们归为无服务器计算的概念？
- en: 'There are five key criteria that differentiate serverless services—both BaaS
    and FaaS—that allow us to approach architecting applications in a new way. These
    criteria are as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 有五个关键标准可以区分无服务器服务—包括BaaS和FaaS—使我们能够以新的方式设计应用程序。这些标准如下：
- en: Does not require managing a long-lived host or application instance
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要管理长期运行的主机或应用程序实例
- en: 'This is the core of serverless. Most other ways of operating server-side software
    require us to deploy, run, and monitor an instance of an application (whether
    programmed by us or others), and that application’s lifetime spans more than one
    request. Serverless implies the opposite of this: there is no long-lived server
    process, or server host, that we need to manage. That’s not to say those servers
    don’t exist—they absolutely do—but they are not our concern or responsibility.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这是无服务器的核心。操作服务器端软件的大多数其他方式都要求我们部署、运行和监视一个应用程序实例（无论是我们自己编写的还是其他人编写的），并且该应用程序的生命周期跨越一个以上的请求。无服务器则意味着相反：我们不需要管理长期运行的服务器进程或服务器主机。这并不意味着这些服务器不存在—它们绝对存在—但它们不是我们的关注或责任。
- en: Self auto-scales and auto-provisions, dependent on load
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 自动按负载自动调整和自动分配资源
- en: Auto-scaling is the ability of a system to adjust capacity requirements dynamically
    based upon load. Most existing auto-scaling solutions require some amount of work
    by the utilizing team. Serverless services self auto-scale from the first time
    you use them with no effort at all.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 自动缩放是系统根据负载动态调整容量需求的能力。大多数现有的自动缩放解决方案需要利用团队做一定的工作。无服务器服务从第一次使用起就能自动自动调整，无需任何努力。
- en: Serverless services also auto-provision when they perform auto-scaling. They
    remove all the effort of allocating capacity, both in terms of number and size
    of underlying resources. This is a huge operational burden lifted.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器服务在执行自动扩展时也会自动进行配置。它们消除了分配容量的所有工作，包括底层资源的数量和大小。这是一个巨大的操作负担减轻。
- en: Has costs that are based on precise usage, up from and down to zero usage
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 具有基于精确使用量的成本，从零到零的使用量
- en: This is closely tied to the previous point—serverless costs are precisely correlated
    with usage. The cost of using a BaaS database, for instance, should be closely
    tied to usage, not predefined capacity. This cost should be largely derived from
    actual amount of storage used and/or requests made.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这与前一点密切相关——无服务器成本与使用量精确相关。例如，使用 BaaS 数据库的成本应与使用量紧密相关，而不是预定义的容量。此成本应主要来自实际使用的存储量和/或发出的请求。
- en: Note that we’re not saying costs should be solely based on usage—there may be
    some overhead cost for using the service in general—but the lion’s share of the
    costs should be proportional to fine-grained usage.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们并不是说成本应仅基于使用量——通常可能会有一些使用服务的基本成本——但是大部分成本应与细粒度的使用成正比。
- en: Has performance capabilities defined in terms other than host size/count
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 具有以除主机大小/数量外的其他术语定义的性能能力
- en: It’s reasonable and useful for a serverless platform to expose some performance
    configuration. However, this configuration should be completely abstracted from
    whatever underlying instance or host types are being used.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于无服务器平台来说，暴露一些性能配置是合理且有用的。但是，这种配置应完全抽象出所使用的任何基础实例或主机类型。
- en: Has implicit high availability
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 具有隐式高可用性
- en: When operating applications, we typically use the term high availability (HA)
    to mean that a service will continue to process requests even when an underlying
    component fails. With a serverless service we expect the vendor to provide HA
    transparently for us.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行应用程序时，我们通常使用高可用性（HA）一词来表示即使底层组件失败，服务也将继续处理请求。对于无服务器服务，我们期望供应商为我们提供透明的 HA。
- en: As an example, if we’re using a BaaS database, we assume that the provider is
    doing whatever is necessary to handle the failure of individual hosts or internal
    components.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们正在使用 BaaS 数据库，我们假设提供商正在执行处理单个主机或内部组件失败所需的所有操作。
- en: What Is AWS?
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 AWS？
- en: We’ve talked about AWS a few times already in this chapter, and now it’s time
    to look at this behemoth of cloud providers in a little more detail.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经几次谈到了 AWS，现在是时候稍微详细地看一下这个云服务提供商的巨头了。
- en: Since its launch in 2006, AWS has grown at a mind-boggling rate, in terms of
    the number and type of service offered, the capacity that the AWS cloud provides,
    and the number of companies using it. Let’s look at all of those aspects.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 自 2006 年推出以来，AWS 以令人难以置信的速度增长，涉及的服务数量和类型，AWS 云提供的容量以及使用它的公司数量。让我们来看看所有这些方面。
- en: Types of Service
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务类型
- en: AWS has more than a hundred different services. Some of these are fairly low
    level—networking, virtual machines, basic block storage. Above these services,
    in abstraction, come the component services—databases, platforms as a service,
    message buses. Then on top of all of these come true application components—user
    management, machine learning, data analysis.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: AWS 拥有一百多种不同的服务。其中一些是相当低级的——网络、虚拟机、基本块存储。在这些服务之上，在抽象层面上，是组件服务——数据库、平台即服务、消息总线。然后在所有这些服务之上，真正的应用程序组件——用户管理、机器学习、数据分析。
- en: Sideways of this stack are the management services necessary to work with AWS
    at scale—security, cost reporting, deployment, monitoring, etc.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个堆栈的侧面是必要的管理服务，用于以规模使用 AWS——安全性、成本报告、部署、监视等。
- en: This combination of services is shown in [Figure 1-1](#aws-service-layers).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这些服务的组合如[图 1-1](#aws-service-layers)所示。
- en: '![images/ch01_image01.png](assets/awsl_0101.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![images/ch01_image01.png](assets/awsl_0101.png)'
- en: Figure 1-1\. AWS service layers
  id: totrans-61
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-1\. AWS 服务层
- en: AWS likes to pitch itself as the ultimate IT “Lego brick” provider—it provides
    a vast number of pluggable types of resources that can be joined together to create
    huge, massively scalable, enterprise-grade applications.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: AWS 喜欢将自己宣传为终极 IT “乐高积木”提供商——它提供了大量可插拔类型的资源，可以组合在一起创建庞大、高度可扩展的企业级应用程序。
- en: Capacity
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容量
- en: AWS houses its computers in more than 60 data centers spread around the world
    as shown in [Figure 1-2](#aws-regions). In AWS terminology, each data center corresponds
    to an *Availability Zone (AZ)*, and clusters of data centers in close proximity
    to each other are grouped into *regions*. AWS has more than 20 different regions,
    across 5 continents.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: AWS将其计算机设施分布在全球60多个数据中心，如[图1-2](#aws-regions)所示。在AWS术语中，每个数据中心对应一个*可用区（AZ）*，而紧邻的数据中心群组成*区域*。AWS在5个大陆上拥有20多个不同的区域。
- en: That’s a lot of computers.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 那是很多计算机。
- en: While the total number of regions continues to grow, so does the capacity within
    each region. A vast number of US-based internet companies run their systems in
    the us-east-1 region in Northern Virginia (just outside Washington DC)—and the
    more companies that run their systems there, the more confident AWS is in increasing
    the number of servers available. This is a virtuous cycle between Amazon and its
    customers.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管区域总数继续增长，但每个区域内的容量也在增加。大量美国互联网公司在北弗吉尼亚州的us-east-1区域（华盛顿特区外）运行其系统——公司在那里运行系统越多，AWS在增加可用服务器数量方面就越有信心。这是亚马逊与其客户之间的良性循环。
- en: '![images/ch01_image02.png](assets/awsl_0102.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![images/ch01_image02.png](assets/awsl_0102.png)'
- en: 'Figure 1-2\. AWS regions (source: [AWS](https://oreil.ly/61Ztd))'
  id: totrans-68
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-2\. AWS区域（来源：[AWS](https://oreil.ly/61Ztd)）
- en: When you use some of Amazon’s lower-level services, like EC2, you’ll typically
    specify an Availability Zone to use. With the higher-level services, though, you’ll
    usually specify only a region, and Amazon will handle any problems for you on
    an individual data center level.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用亚马逊的一些低级服务，比如EC2时，通常会指定要使用的可用区。不过，对于高级服务，你通常只需指定一个区域，亚马逊将为你在单个数据中心级别处理任何问题。
- en: A compelling aspect of Amazon’s region model is that each region is largely
    independent, logistically and from a software management point of view. That means
    that if a physical problem like a power outage, or a software problem like a deployment
    bug, happens in one region, the others will almost certainly be unaffected. The
    region model does make for some extra work from our point of view as users, but
    overall it works well.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 亚马逊的区域模型的一个引人注目的方面是，从物流和软件管理的角度来看，每个区域基本上是独立的。这意味着，如果一个区域出现了像停电这样的物理问题，或者像部署错误这样的软件问题，其他区域几乎肯定不会受到影响。从我们用户的角度来看，区域模型确实会增加一些额外的工作量，但总体上它运行良好。
- en: Who Uses AWS?
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 谁在使用AWS？
- en: AWS has a vast number of customers, spread all around the planet. Massive enterprises,
    governments, startups, individuals, and everyone in between use AWS. Many of the
    internet services you use are probably hosted on AWS.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: AWS拥有遍布全球的大量客户。大型企业、政府、初创公司、个人以及中间的所有人都在使用AWS。你使用的许多互联网服务可能都托管在AWS上。
- en: AWS is not just for websites. Many companies have moved a lot of their “backend”
    IT infrastructure to AWS, finding it a more compelling option than running their
    own physical infrastructure.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: AWS不仅适用于网站。许多公司已经将大部分“后端”IT基础设施迁移到AWS上，发现这比运行自己的物理基础设施更具吸引力。
- en: AWS, of course, doesn’t have a monopoly. Google and Microsoft are their biggest
    competitors, at least in the English-speaking world, while Alibaba Cloud competes
    with them in the growing Chinese market. And there are plenty of other cloud providers
    offering services suited to specific types of customer.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，AWS并不垄断。在英语世界至少，谷歌和微软是它们最大的竞争对手，而阿里云则在不断增长的中国市场上与它们竞争。还有许多其他云服务提供商，提供适合特定类型客户的服务。
- en: How Do You Use AWS?
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你如何使用AWS？
- en: Your first interaction with AWS will likely be via the [AWS Web Console](https://console.aws.amazon.com).
    To do this, you will need some kind of access credential, which will give you
    permissions within an *account*. An account is a construct that maps to billing
    (i.e., paying AWS for the services you use), but it is also a grouping of defined
    service configurations within AWS. Companies tend to run a number of production
    applications in one account. (Accounts can also have *subaccounts*, but we won’t
    be talking about them too much in this book—just know that if you’re using credentials
    supplied by a company, they might be for a specific subaccount.)
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: If you haven’t been given credentials by your company, you’ll need to create
    an account. You can do this by supplying AWS with your credit card details, but
    know that AWS supplies a generous *free tier*, and if you just stick to the basic
    exercises in this book, you shouldn’t end up needing to pay AWS anything.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Your credentials may be in the form of a typical username and password or may
    be via a single sign-on (SSO) workflow (e.g., via Google Apps or Microsoft Active
    Directory). Either way, eventually you’ll successfully log in to the web console.
    Using the web console for the first time can be a daunting experience, with all
    100+ AWS services craving your attention—Amazon Polly shouting “PICK ME!!!” in
    equal measure to a strange thing called Macie. And then of course what about all
    of those services known only by an acronym—what *are* they?
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Part of the reason for the overwhelming nature of the home page of the AWS Console
    is because it really isn’t developed as one product—it’s developed as a hundred
    different products, all given a link on the home page. Also, drilling into one
    product may look quite different from another because each product is given a
    good amount of autonomy within the AWS universe. Sometimes using AWS might feel
    like a spelunking exercise in navigating the AWS corporate organization—don’t
    worry, we all feel that way.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the web console, the other way of interacting with AWS is via its
    extensive API. One great aspect that Amazon has had from very early in its history,
    even before the times of AWS, is that each service must be fully usable via a
    public API, and this means that for all intents and purposes anything that is
    possible to configure in AWS can be done via the API.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Layered on top of the API is the CLI—the command line interface—which we use
    in this book. The CLI is most simply described as a thin client application that
    communicates with the AWS API. We talk about configuring the CLI in the next chapter
    ([“AWS Command Line Interface”](ch02.html#aws-cli)).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: What Is AWS Lambda?
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lambda is Amazon’s FaaS platform. We briefly mentioned FaaS earlier, but now
    it’s time to dig into it in some more detail.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Functions as a Service
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we introduced before, FaaS is a new way of building and deploying server-side
    software, oriented around deploying individual functions or operations. FaaS is
    where a lot of the buzz about serverless comes from; in fact, many people think
    that serverless *is* FaaS, but they’re missing out on the complete picture. While
    this book focuses on FaaS, we encourage you to consider BaaS too as you build
    out bigger applications.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前介绍的，FaaS 是一种围绕部署单个函数或操作的构建和部署服务器端软件的新方式。FaaS 是关于无服务器的许多噪音的来源；事实上，许多人认为无服务器
    *就是* FaaS，但他们忽略了完整的图景。虽然本书专注于 FaaS，我们鼓励您在构建更大型应用程序时也考虑 BaaS。
- en: When we deploy traditional server-side software, we start with a host instance,
    typically a VM instance or a container (see [Figure 1-3](#server-side-software-deployment)).
    We then deploy our application, which usually runs as an operating system process,
    within the host. Usually our application contains code for several different but
    related operations; for instance, a web service may allow both retrieval and updating
    resources.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们部署传统的服务器端软件时，我们首先使用主机实例，通常是 VM 实例或容器（参见 [图 1-3](#server-side-software-deployment)）。然后我们部署我们的应用程序，在主机内作为操作系统进程运行。通常，我们的应用程序包含多个不同但相关的操作的代码；例如，Web
    服务可能允许检索和更新资源。
- en: '![images/ch01_image03.png](assets/awsl_0103.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![images/ch01_image03.png](assets/awsl_0103.png)'
- en: Figure 1-3\. Traditional server-side software deployment
  id: totrans-88
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-3\. 传统服务器端软件部署
- en: From an ownership point of view, we as users are responsible for all three aspects
    of this configuration—host instance, application process, and of course program
    operations.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 从所有权的角度来看，我们作为用户对此配置的三个方面负责——主机实例、应用程序进程，当然还有程序操作。
- en: FaaS changes this model of deployment and ownership (see [Figure 1-4](#faas-software-deployment)).
    We strip away both the host instance and the application process from our model.
    Instead, we focus on just the individual operations or functions that express
    our application’s logic. We upload those functions individually to a FaaS platform,
    which itself is the responsibility of the cloud vendor and not us.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: FaaS 改变了部署和所有权的模型（参见 [图 1-4](#faas-software-deployment)）。我们从模型中剥离了主机实例和应用程序进程。相反，我们专注于表达应用程序逻辑的单个操作或函数。我们将这些函数单独上传到
    FaaS 平台，这个平台由云供应商负责，而不是我们。
- en: '![images/ch01_image04.png](assets/awsl_0104.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![images/ch01_image04.png](assets/awsl_0104.png)'
- en: Figure 1-4\. FaaS software deployment
  id: totrans-92
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-4\. FaaS 软件部署
- en: The functions are not constantly active in an application process, though, sitting
    idle until they need to be run as they would in a traditional system. Instead,
    the FaaS platform is configured to listen for a specific event for each operation.
    When that event occurs, the platform instantiates the FaaS function and then calls
    it, passing the triggering event.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 函数在应用程序进程中不是持续活动的，而是处于空闲状态，直到需要运行它们，就像传统系统中的方式。相反，FaaS 平台被配置为为每个操作监听特定的事件。当事件发生时，平台实例化
    FaaS 函数，然后调用它，传递触发事件。
- en: Once the function has finished executing, the FaaS platform is free to tear
    it down. Alternatively, as an optimization, it may keep the function around for
    a little while until there’s another event to be processed.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数执行完成后，FaaS 平台可以自由地将其销毁。或者作为优化，它可以将函数保留一段时间，直到有另一个事件需要处理。
- en: FaaS as Implemented by Lambda
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lambda 实现的 FaaS
- en: AWS Lambda was launched in 2014, and it continues to grow in scope, maturity,
    and usage. Some Lambda functions might be very low throughput—perhaps just executing
    once per day, or even less frequently than that. But others may be executed billions
    of times per day.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: AWS Lambda 在 2014 年推出，并且在范围、成熟度和使用率方面不断增长。某些 Lambda 函数可能吞吐量非常低——可能每天只执行一次，甚至更少。但是其他函数可能每天执行数十亿次。
- en: Lambda implements the FaaS pattern by instantiating ephemeral, managed, Linux
    environments to host each of our function instances. Lambda guarantees that only
    one event is processed per environment at a time. At the time of writing, Lambda
    also requires that the function completes processing of the event within 15 minutes;
    otherwise, the execution is aborted.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 通过实例化短暂的托管 Linux 环境来实现 FaaS 模式，以托管每个函数实例。Lambda 保证每次只处理一个环境中的事件。在撰写本文时，Lambda
    还要求函数在 15 分钟内完成对事件的处理；否则，执行将被中止。
- en: Lambda provides an exceptionally lightweight programming and deployment model—we
    just provide a function, and associated dependencies, in a ZIP or JAR file, and
    Lambda fully manages the runtime environment.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Lambda is tightly integrated with many other AWS services. This corresponds
    to many different types of event source that can trigger Lambda functions, and
    this leads to the ability to build many different types of applications using
    Lambda.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'Lambda is a fully serverless service, as defined by our differentiating criteria
    from earlier, specifically:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Does not require managing a long-lived host or application instance
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: With Lambda we are fully abstracted from the underlying host running our code.
    Furthermore, we do not manage a long-lived application—once our code has finished
    processing a particular event, AWS is free to terminate the runtime environment.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Self auto-scales and auto-provisions, dependent on load
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: This is one of the key benefits of Lambda—resource management and scaling is
    completely transparent. Once we upload our function code, the Lambda platform
    will create just enough environments to handle the load at any particular time.
    If one environment is enough then Lambda will create the environment when it is
    needed. If on the other hand hundreds of separate instances are required, then
    Lambda will scale out quickly and without any effort on our part.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Has costs that are based on precise usage, up from and down to zero usage
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: AWS charges for Lambda only for the time that our code is executing per environment,
    down to a 100 ms precision. If our function is active for 200 ms every 5 minutes,
    then we’ll be charged only for 2.4 seconds of usage per hour. This precise usage
    cost structure is the same whether one instance of our function is required or
    a thousand.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Has performance capabilities defined in terms other than host size/count
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Since we are fully abstracted from the underlying host with Lambda, we can’t
    specify a number or type of underlying EC2 instances to use. Instead, we specify
    how much RAM our function requires (up to a maximum of 3GB), and other aspects
    of performance are tied to this too. We explore this in more detail later in the
    book—see [“Memory and CPU”](ch03.html#memory-and-cpu).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Has implicit high availability
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: If a particular underlying host fails, then Lambda will automatically start
    environments on a different host. Similarly, if a particular data center/*Availability
    Zone* fails, then Lambda will automatically start environments in a different
    AZ in the same *region*. Note that it’s on us as AWS customers to handle a *region-wide*
    failure, and we talk about this toward the end of the book—see [“Globally Distributed
    Applications”](ch09.html#globally-distributed-applications).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Why Lambda?
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The basic benefits of the cloud, as we described earlier, apply to Lambda—it’s
    often cheaper to run in comparison to other types of host platform; it requires
    less effort and time to operate a Lambda application; and the scaling flexibility
    of Lambda surpasses any other compute option within AWS.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所描述的，云的基本好处也适用于Lambda——与其他类型的主机平台相比，它通常更便宜；运行Lambda应用程序需要的操作和时间更少；Lambda的伸缩性灵活性超过了AWS内的任何其他计算选项。
- en: However, the key benefit from our perspective is how quickly you can build applications
    with Lambda when combined with other AWS services. We often hear of companies
    building brand new applications, deployed to production, in just a day or two.
    Being able to remove ourselves from so much of the infrastructure-related code
    we often write in regular applications is a huge time-saver.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从我们的角度来看，最大的好处在于与其他AWS服务结合使用时，Lambda可以多快地构建应用程序。我们经常听说公司可以在一两天内构建全新的应用程序，并将其部署到生产环境中。能够摆脱我们通常在常规应用程序中编写的大量基础设施相关代码，这是一个巨大的时间节省者。
- en: Lambda also has more capacity, more maturity, and more integration points than
    any other FaaS platform. It’s not perfect, and some other products in our opinion
    offer better “developer UX” than Lambda. But absent any strong tie to an existing
    cloud vendor, we would recommend AWS Lambda for all of the reasons listed earlier.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda还比任何其他FaaS平台拥有更多的容量、成熟度和集成点。它并不完美，我们认为一些其他产品在开发者体验上比Lambda更好。但是在没有与现有云供应商的强大联系的情况下，我们会推荐AWS
    Lambda，原因正如前面列出的那些。
- en: What Does a Lambda Application Look Like?
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lambda应用程序是什么样子？
- en: Traditional long-running server applications often have at least one of two
    ways of starting work for a particular stimulus—they either open up a TCP/IP socket
    and wait for inbound connections or have an internal scheduling mechanism that
    will cause them to reach out to a remote resource to check for new work. Since
    Lambda is fundamentally an event-oriented platform and since Lambda enforces a
    timeout, neither of these patterns is applicable to a Lambda application. So how
    *do* we build a Lambda application?
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的长时间运行的服务器应用通常有两种启动工作的方式之一：它们可以打开TCP/IP套接字并等待传入连接，或者有一个内部调度机制，使它们可以访问远程资源以检查新的工作。由于Lambda基本上是一个事件驱动的平台，并且Lambda强制执行超时，所以这两种模式都不适用于Lambda应用程序。那么我们如何构建Lambda应用程序呢？
- en: 'The first point to consider is that at the lowest level Lambda functions can
    be invoked (called) in one of two ways:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要考虑的第一点是，Lambda函数在最低级别上可以通过两种方式调用：
- en: Lambda functions can be called *synchronously*—named `RequestResponse` by AWS.
    In this scenario, an upstream component calls the Lambda function and waits for
    whatever response the Lambda function generates.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda函数可以被称为同步调用，由AWS称为`RequestResponse`。在这种情况下，上游组件调用Lambda函数，并等待Lambda函数生成的任何响应。
- en: Alternatively, a Lambda function may be invoked *asynchronously*—named `Event`
    by AWS. This time the request from the upstream caller is responded to immediately
    by the Lambda *platform*, while the Lambda *function* proceeds with processing
    the request. No further response is returned to the caller in this scenario.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，Lambda函数可以异步调用，由AWS称为`Event`。这时来自上游调用者的请求会立即由Lambda平台响应，而Lambda函数继续处理请求。在这种情况下，不会向调用者返回进一步的响应。
- en: These two invocation models have various other behaviors, which we get into
    later, starting with [“Invocation Types”](ch03.html#invocation_types_explanation).
    For now let’s see how they are used in some example applications.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种调用模型有各种其他行为，我们稍后会深入探讨，从[“调用类型”](ch03.html#invocation_types_explanation)开始。现在让我们看看它们在一些示例应用中的使用方式。
- en: Web API
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Web API
- en: An obvious question to ask is whether Lambda can be used in the implementation
    of an HTTP API, and fortunately the answer is yes! While Lambda functions aren’t
    HTTP servers themselves, we can use another AWS component, *API Gateway*, to provide
    the HTTP protocol and routing logic that we typically have within a web service
    (see [Figure 1-5](#web-api)).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一个显而易见的问题是Lambda是否可以用于实现HTTP API，幸运的是答案是肯定的！虽然Lambda函数本身不是HTTP服务器，但我们可以使用另一个AWS组件*API
    Gateway*来提供HTTP协议和路由逻辑，这些通常在Web服务中使用（见[图1-5](#web-api)）。
- en: '![images/ch01_image05.png](assets/awsl_0105.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![images/ch01_image05.png](assets/awsl_0105.png)'
- en: Figure 1-5\. Web API using AWS Lambda
  id: totrans-124
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-5\. 使用AWS Lambda的Web API
- en: The above diagram shows a typical API as used by a single-page web app or by
    a mobile application. The user’s client makes various calls, via HTTP, to the
    backend to retrieve data and/or initiate requests. In our case, the component
    that handles the HTTP aspects of the request is Amazon API Gateway—it is an HTTP
    server.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 上图显示了单页Web应用程序或移动应用程序使用的典型API。用户客户端通过HTTP进行各种调用，以从后端检索数据和/或发起请求。在我们的情况下，处理请求的组件是亚马逊API网关——它是一个HTTP服务器。
- en: We configure API Gateway with a mapping from request to handler (e.g., if a
    client makes a request to `GET /restaurants/123`, then we can set up API Gateway
    to call a Lambda function named `RestaurantsFunction`, passing the details of
    the request). API Gateway will invoke the Lambda function *synchronously* and
    will wait for the function to evaluate the request and return a response.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将请求映射到处理程序来配置API网关（例如，如果客户端发出`GET /restaurants/123`请求，则可以设置API网关调用名为`RestaurantsFunction`的Lambda函数，并传递请求的详细信息）。API网关将*同步*调用Lambda函数，并等待函数评估请求并返回响应。
- en: Since the Lambda function instance isn’t itself a remotely callable API, the
    API Gateway actually makes a call to the Lambda platform, specifying the Lambda
    function to invoke, the type of invocation (`RequestResponse`), and the request
    parameters. The Lambda platform then instantiates an instance of `RestaurantsFunction`
    and invokes that with the request parameters.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Lambda函数实例本身不是可远程调用的API，API网关实际上会调用Lambda平台，指定要调用的Lambda函数、调用类型（`RequestResponse`）和请求参数。Lambda平台随后会实例化一个`RestaurantsFunction`实例，并使用请求参数调用它。
- en: The Lambda platform does have a few limitations, like the maximum timeout we’ve
    already mentioned, but apart from that, it’s pretty much a standard Linux environment.
    In `RestaurantsFunction` we can, for example, make a call to a database—Amazon’s
    DynamoDB is a popular database to use with Lambda, partly due to the similar scaling
    capabilities of the two services.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda平台确实有一些限制，例如我们已经提到的最大超时时间，但除此之外，它基本上是一个标准的Linux环境。在`RestaurantsFunction`中，例如，我们可以调用数据库——亚马逊的DynamoDB是与Lambda一起使用的流行数据库之一，部分原因是两个服务的类似扩展能力。
- en: Once the function has finished its work, it returns a response, since it was
    called in a synchronous fashion. This response is passed by the Lambda platform
    back to API Gateway, which transforms the response into an HTTP response message,
    which is itself passed back to the client.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦函数完成其工作，它会返回一个响应，因为它以同步方式调用。Lambda平台将此响应传回API网关，后者将响应转换为HTTP响应消息，并将其传递回客户端。
- en: Typically a web API will satisfy multiple types of requests, mapped to different
    HTTP *paths* and *verbs* (like GET, PUT, POST, etc.). When developing a Lambda-backed
    web API, you will usually implement different types of requests as different Lambda
    functions, although you are not forced to use such a design—you can handle all
    requests as one function if you’d like and switch logic inside the function based
    on the original HTTP request path and verb.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Web API将满足多种类型的请求，映射到不同的HTTP *路径* 和 *动词*（如GET、PUT、POST等）。在开发由Lambda支持的Web
    API时，通常会将不同类型的请求实现为不同的Lambda函数，尽管您不必使用这样的设计——如果愿意，可以将所有请求作为一个函数处理，并根据原始HTTP请求路径和动词在函数内部切换逻辑。
- en: File processing
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件处理
- en: A common use case for Lambda is file processing. Let’s imagine a mobile application
    that can upload photos to a remote server, which we then want to make available
    to other parts of our product suite, but at different image sizes, as shown in
    [Figure 1-6](#file-processing).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda的常见用例是文件处理。让我们想象一个移动应用程序可以将照片上传到远程服务器，然后我们希望以不同的图像尺寸在我们的产品套件的其他部分中使用，如[图1-6](#file-processing)所示。
- en: '![images/ch01_image06.png](assets/awsl_0106.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![images/ch01_image06.png](assets/awsl_0106.png)'
- en: Figure 1-6\. File processing using AWS Lambda
  id: totrans-134
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-6\. 使用AWS Lambda进行文件处理
- en: S3 is Amazon’s Simple Storage Service—the very same that was launched in 2006\.
    Mobile applications can upload files to S3 via the AWS API, in a secure fashion.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: S3是亚马逊的简单存储服务，即2006年推出的同一服务。移动应用可以通过AWS API安全地将文件上传到S3。
- en: S3 can be configured to invoke the Lambda platform when the file is uploaded,
    specifying the function to be called, and passing a path to the file. As with
    the previous example, the Lambda platform then instantiates the Lambda function
    and calls it with the request details passed this time by S3\. The difference
    now, though, is that this is an *asynchronous* invocation (S3 specified the `Event`
    invocation type)—no value is returned to S3 nor does S3 wait for a return value.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当文件上传时，可以配置 S3 来调用 Lambda 平台，指定要调用的函数，并传递文件路径。与前面的示例类似，Lambda 平台会实例化 Lambda
    函数，并使用 S3 传递的请求详细信息调用它。但是，此时的调用是*异步*调用（S3 指定了`Event`调用类型）——不会向 S3 返回任何值，S3 也不会等待返回值。
- en: This time our Lambda function exists solely for the purpose of a *side effect*—it
    loads the file specified by the request parameter and then creates new, resized
    versions of the file in a different S3 bucket. With the side effects complete,
    the Lambda function’s work is done. Since it created files in an S3 bucket, we
    may choose to add a Lambda trigger to that bucket also, invoking further Lambda
    functions that process these generated files, creating a processing pipeline.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们的 Lambda 函数仅存在于*副作用*的目的——它加载由请求参数指定的文件，然后在不同的 S3 存储桶中创建新的调整大小版本的文件。副作用完成后，Lambda
    函数的工作就完成了。由于它在 S3 存储桶中创建了文件，我们可以选择向该存储桶添加 Lambda 触发器，还可以调用进一步处理这些生成文件的 Lambda
    函数，从而创建处理管道。
- en: Other examples of Lambda applications
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Lambda 应用程序的其他示例
- en: 'The previous two examples show two scenarios, with two different Lambda event
    sources. There are many other event sources that enable us to build many other
    types of applications. Just some of these are as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个示例展示了两种不同的 Lambda 事件源的场景。还有许多其他事件源可以使我们构建许多其他类型的应用程序。其中一些如下：
- en: We can build message-processing applications, using message buses like Simple
    Notification Service (SNS), Simple Queue Service (SQS), EventBridge, or Kinesis
    as the event source.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以构建消息处理应用程序，使用消息总线，如简单通知服务（SNS）、简单队列服务（SQS）、事件桥或 Kinesis 作为事件源。
- en: We can build email-processing applications, using Simple Email Service (SES)
    as the event source.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以构建邮件处理应用程序，使用简单电子邮件服务（SES）作为事件源。
- en: We can build scheduled-task applications, similar to cron programs, using CloudWatch
    Scheduled Events as the trigger.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以构建类似于 cron 程序的定时任务应用程序，使用 CloudWatch 计划事件作为触发器。
- en: Note that many of these services other than Lambda are *BaaS* services and therefore
    also serverless. Combining FaaS and BaaS to produce *serverless architectures*
    is an extraordinarily powerful technique due to their similar scaling, security,
    and cost characteristics. In fact, it’s such combinations of service that are
    driving the popularity of serverless computing.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，除 Lambda 外的许多服务都是*BaaS*服务，因此也是无服务器的。结合 FaaS 和 BaaS 来生成*无服务器架构*是一种非常强大的技术，因为它们具有类似的扩展性、安全性和成本特性。事实上，正是这些服务的组合推动了无服务器计算的流行。
- en: We talk in depth about building applications in this way in [Chapter 5](ch05.html#ch05).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第5章](ch05.html#ch05)中深入讨论了以这种方式构建应用程序的内容。
- en: AWS Lambda in the Java World
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AWS Lambda 在 Java 世界中
- en: AWS Lambda natively supports a large number of languages. JavaScript and Python
    are very popular “getting started” languages for Lambda (as well as for significant
    production applications) partly because of their dynamically typed, noncompiled
    nature allowing for very fast development cycles.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: AWS Lambda 原生支持大量编程语言。JavaScript 和 Python 是 Lambda 的非常流行的“入门”语言（以及重要的生产应用程序语言），部分原因是它们的动态类型和非编译性质使得开发周期非常快速。
- en: 'We both got our start, however, using Lambda with Java. Java occasionally has
    a bad reputation in the Lambda world—some of which is fair, and some not. If what
    you need in a Lambda function can be expressed in 10 lines or so, it’s typically
    quicker to put something together in JavaScript or Python. However, for larger
    applications, there are many excellent reasons to implement Lambda functions in
    Java, a couple of which are as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们起步时都使用 Java 与 Lambda。Java 在 Lambda 的世界中偶尔会有不良声誉——其中有些是合理的，有些则不是。然而，如果 Lambda
    函数所需的内容可以用大约 10 行或更少的代码表达，通常在 JavaScript 或 Python 中快速组合会更快。但是，对于较大的应用程序，有许多很好的理由在
    Java 中实现 Lambda 函数，其中一些如下：
- en: If you or your team is more familiar with Java than the other Lambda-supported
    languages, then you’ll have the ability to reuse these skills and libraries in
    a new runtime platform. Java is as much a “first-class language” in the Lambda
    ecosystem as JavaScript, Python, Go, etc., are—Lambda is not limiting you if you
    use Java. Further, if you already have a lot of code implemented in Java, then
    porting some of this to Lambda can be a significant time-to-market advantage,
    in comparison to reimplementing in a different language.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您或您的团队比其他Lambda支持的语言更熟悉Java，那么您将能够在一个新的运行时平台中重用这些技能和库。在Lambda生态系统中，Java与JavaScript、Python、Go等一样是“一流语言”—Lambda不会因为您使用Java而对您造成限制。此外，如果您已经在Java中实现了大量代码，则与其重新实现为其他语言相比，将其移植到Lambda可能会带来显著的时间市场优势。
- en: In high throughput messaging systems, the typical runtime performance benefit
    of Java over JavaScript or Python can be significant. Not only is “faster” normally
    “better” in any system, with Lambda “faster” can also result in tangible cost
    benefits due to Lambda’s pricing model.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在高吞吐量消息系统中，相比于JavaScript或Python，Java通常能带来显著的运行时性能优势。在任何系统中，“更快”通常意味着“更好”，而在Lambda中，“更快”还可能导致实际的成本优势，这是由于Lambda的定价模型。
- en: For JVM workloads, Lambda natively supports, at the time of writing, the Java
    8 and Java 11 runtimes. The Lambda platform will instantiate a version of the
    Java Runtime Environment within its Linux environment and then run our code within
    that Java VM. Our code, therefore, must be compatible with that runtime environment,
    but we’re not restricted to just using the Java language. Scala, Clojure, Kotlin,
    and more, can all be run on Lambda (see more at [“Other JVM Languages and Lambda”](ch08.html#other-jvm-languages)).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对于JVM工作负载，在撰写本文时，Lambda原生支持Java 8和Java 11运行时。Lambda平台将在其Linux环境中实例化一个Java运行环境版本，然后在该Java虚拟机中运行我们的代码。因此，我们的代码必须与该运行时环境兼容，但我们不仅仅局限于使用Java语言。Scala、Clojure、Kotlin等都可以在Lambda上运行（详见[“其他JVM语言和Lambda”](ch08.html#other-jvm-languages)）。
- en: There’s also an advanced option with Lambda to define your own runtime if neither
    of these Java versions is sufficient—we discuss this further in [“Custom Runtimes”](ch08.html#custom-runtimes).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda还有一个高级选项，即定义自己的运行时环境，如果这两个Java版本都不够用，我们在[“自定义运行时”](ch08.html#custom-runtimes)中进一步讨论这一点。
- en: The Lambda platform supplies a few basic libraries with the runtime (e.g., a
    small subset of the AWS Java library) but any other libraries that your code needs
    must be supplied with your code itself. You will learn how to do that in [“Build
    and Package”](ch04.html#build-and-package).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda平台提供了一些基本的库与运行时（例如AWS Java库的一个小子集），但您的代码需要的任何其他库必须随代码本身提供。您将在[“构建和打包”](ch04.html#build-and-package)中学习如何做到这一点。
- en: Finally, while Java has the programming construct of [*Lambda expressions*](https://oreil.ly/nnjwh),
    these are unrelated to AWS Lambda functions. You are free to use Java Lambda expressions
    within your AWS Lambda function if you’d like (since AWS Lambda supports Java
    8 and later) or not.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，虽然Java具有[*Lambda表达式*](https://oreil.ly/nnjwh)的编程构造，但这与AWS Lambda函数无关。如果您愿意，您可以在AWS
    Lambda函数中使用Java Lambda表达式（因为AWS Lambda支持Java 8及更高版本），也可以选择不使用。
- en: Summary
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: In this chapter, you learned how serverless computing is the next evolution
    of the cloud—a way of building applications by relying on services that handle
    resource management, scaling, and more, transparently and without configuration.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解到无服务器计算是云计算的下一个演进阶段—一种通过依赖处理资源管理、扩展等服务来构建应用程序的方式，而无需配置。
- en: Further, you now understand that functions as a service (FaaS) and backend as
    a service (BaaS) are the two halves of serverless, with FaaS being the general-purpose
    computing paradigm within serverless. For more information on serverless in general,
    we refer you to our free O’Reilly ebook [*What Is Serverless?*](https://oreil.ly/5YbLa)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您现在了解到函数即服务（FaaS）和后端即服务（BaaS）是无服务器的两个组成部分，其中FaaS是无服务器中的通用计算范式。有关无服务器的更多信息，请参阅我们的免费O’Reilly电子书[*什么是无服务器？*](https://oreil.ly/5YbLa)
- en: You also have at least a basic knowledge of Amazon Web Services—one of the world’s
    most popular cloud platforms. You’ve learned about the vast capacity that AWS
    has to host our applications and how you access AWS both via the web console and
    the API/CLI.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您还至少对亚马逊Web服务有基本的了解—这是全球最流行的云平台之一。您了解到AWS具有托管应用程序的巨大容量，并且了解到如何通过Web控制台以及API/CLI访问AWS。
- en: You’ve been introduced to AWS Lambda—Amazon’s FaaS product. We compared “thinking
    in Lambda” to a traditionally built application, talked about why you may want
    to use Lambda versus other FaaS implementations, and then gave some examples of
    applications built using Lambda.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经了解了AWS Lambda—亚马逊的函数即服务产品。我们将“思考Lambda”与传统构建的应用程序进行了比较，讨论了为什么您可能希望使用Lambda而不是其他函数即服务的实现，然后给出了一些使用Lambda构建的应用程序示例。
- en: Finally, you saw a quick overview of Java as a Lambda language option.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您看到了Java作为Lambda语言选项的快速概述。
- en: In [Chapter 2](ch02.html#ch02) we implement our first Lambda function—get ready
    for a brave new world!
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html#ch02)中，我们实现了我们的第一个Lambda函数—为一个全新的世界做好准备！
- en: Exercises
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Acquire credentials for an [AWS account](https://aws.amazon.com). The easiest
    way to do this is by creating a new account. As we mentioned earlier, if you do
    this, you’ll need to supply a credit card number, but everything we do in this
    book should be covered by the free tier, unless you get very enthusiastic with
    tests!
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取一个[AWS账户](https://aws.amazon.com)的凭据。最简单的方法是创建一个新账户。正如我们之前提到的，如果您这样做，您将需要提供信用卡号码，但我们在本书中所做的一切应该都在免费层范围内，除非您在测试中非常热情！
- en: Alternatively you can use an existing AWS account, but if so, we recommend using
    a “development” account so as not to interfere with any “production” systems.
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者您可以使用现有的AWS账户，但如果这样做，我们建议使用一个“开发”账户，以免干扰任何“生产”系统。
- en: We also strongly recommend that whatever access you use grants you full administrative
    permissions within the account; otherwise, you’ll be bogged down by distracting
    security issues.
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还强烈建议，无论您使用何种访问方式，都应该为您授予账户内的完全管理员权限；否则，您将因分散注意力的安全问题而陷入困境。
- en: Log in to the [AWS Console](https://console.aws.amazon.com). Find the Lambda
    section—are there any functions there yet?
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到[AWS控制台](https://console.aws.amazon.com)。找到Lambda部分—那里已经有任何函数了吗？
- en: '*Extended task*: Look at [Amazon’s serverless marketing page](https://aws.amazon.com/serverless),
    specifically where it describes the various services in its “serverless platform.”
    Which of these services fully satisfy the differentiating criteria of a serverless
    service we described earlier? Which don’t, and in what ways are they “mostly”
    serverless?'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*扩展任务*: 查看[Amazon的无服务器营销页面](https://aws.amazon.com/serverless)，特别是它描述“无服务器平台”中各种服务的部分。哪些服务完全满足我们之前描述的无服务器服务的区分标准？哪些不满足，并且以什么方式它们“大部分”是无服务器的？'
