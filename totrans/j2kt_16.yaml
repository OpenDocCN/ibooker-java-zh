- en: Chapter 16\. Interfaces to Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Java, we use interfaces to specify a contract between code that defines some
    functionality and code that needs it. Those interfaces couple the two parties
    together, which can make our software harder to maintain. How do function types
    help solve this problem?
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Imagine, if you can, that you need to send email from some code that you are
    writing. Just that for now—not receive mail, or list sent messages—just fire and
    forget.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'The code that describes the email is simple enough:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Given an `Email`, client code would *like* to call the simplest possible function
    to send it, which is:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Of course when we come to implement this function, we discover that to actually
    send email, we require all sorts of other information. Not information about the
    email itself but, rather, configuration about how to send it. Things like the
    sending server’s hostname and security credentials—all the things that your nontechnical
    relative doesn’t know, but you need to set up their new computer. We’ll add three
    extra parameters to `sendEmail` to stand in for all this configuration:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As a client, things have just become a lot less convenient. Everywhere we want
    to send email has to know this configuration; we’ll be passing it around from
    the top to the bottom of the codebase. Solving that problem by hiding the details
    in global variables works fine until we discover that every run of the unit test
    suite now sends 50 emails! There must be a better way of hiding these petty details.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Object-Oriented Encapsulation
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Object-oriented languages have a ready-made solution to this problem—objects
    can encapsulate the data:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now when we want to send email, we need access to an `EmailSender` (rather
    than the static function). Once we have an `EmailSender`, instead of calling a
    function, we invoke a method, and we don’t need to tell the method all the petty
    details because it already knows them; they are the fields of its class:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In general, the place where we know the configuration and the place where we
    want to send an email will be separated in our code, often by many layers. Usually
    in OO, the `sender` will be captured as a property of a class and used by its
    methods:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Often we will extract an interface:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If our client code depends on the `ISendEmail` interface rather than the `EmailSender`
    class, we can configure our tests to use a fake implementation of `ISendEmail`,
    which doesn’t actually send emails but instead allows us to check what would be
    sent if it did. Not only can we provide fakes that don’t send emails at all, but
    also different genuine implementations like `SmtpEmailSender` and `X400EmailSender`,
    each of which hides both its configuration and implementation from its clients.
    We came for the information hiding but stayed for the implementation hiding.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: When we say *hiding*, it sounds a bit pejorative, but the concealment is useful
    to both client and implementor. The former doesn’t have the problem of having
    to supply the configuration details at the point of use; the latter is able to
    evolve separately from its users (provided it doesn’t change API, expressed in
    the interface).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说 *隐藏* 时，听起来有点贬义，但这种隐藏对客户端和实现者都很有用。前者不必在使用点提供配置详细信息；后者可以与其用户分离演化（只要它不改变 API，在接口中表达）。
- en: 'Before we leave the object-oriented realm, note that we don’t have to create
    a named class to implement `ISendEmail`; we can do it anonymously:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们离开面向对象的领域之前，请注意我们不必创建一个命名类来实现`ISendEmail`；我们可以匿名地完成它：
- en: '[PRE8]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Why might we want to do this? Well, when we don’t control all the clients of
    our code (we are publishing a library external to our organization, for example),
    this gives us flexibility to change our implementation, safe in the knowledge
    that clients cannot depend on a specific implementation class by downcasting to
    it and calling other methods. We call the object that we return here a *closure*,
    because it closes over values that it requires from its enclosing context (the
    function call), capturing them for later reference.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们要这样做呢？嗯，当我们无法控制我们代码的所有客户端时（例如，我们发布一个组织外的库），这样做使我们可以灵活地更改我们的实现，而不必担心客户端依赖于特定的实现类并通过向下转型调用其他方法。我们称之为
    *闭包* 的对象，在此处关闭它需要的值（函数调用的上下文），以便以后引用。
- en: 'In Kotlin 1.4, we can declare our `ISendEmail` interface as a `fun interface`
    (one with only one abstract method). This way, we can define the implementation
    of the single operation with a lambda rather than with an object with a single
    method:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 1.4 中，我们可以将我们的 `ISendEmail` 接口声明为 `fun interface`（只有一个抽象方法）。这样，我们可以用
    lambda 定义单个操作的实现，而不是使用一个只有一个方法的对象：
- en: '[PRE9]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Again, the lambda here is a closure, capturing the values of the parameters
    of its enclosing function.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这里的 lambda 是一个闭包，捕获其封闭函数参数的值。
- en: Functional Encapsulation
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数封装
- en: Having seen how an OO programmer solves the problem of encapsulating pesky details
    so clients don’t have to supply them at the point of use, how would a functional
    programmer approach the same problem?
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 看到面向对象程序员如何解决封装繁琐细节的问题，使得客户端无需在使用点提供它们，那么函数式程序员如何解决同样的问题呢？
- en: 'Remember that we’re trying to get to a function with this signature:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们试图实现一个具有这个签名的函数：
- en: '[PRE10]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'But we actually need all this information to send the message:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 但实际上我们需要所有这些信息来发送消息：
- en: '[PRE11]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In functional terms, this is an example of [*partial application*](https://oreil.ly/V1KOm):
    fixing some of the arguments to a function to yield a function with fewer arguments.
    Although some languages provide built-in support for this, in Kotlin the easiest
    approach is to write a function to partially apply our configuration.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 从功能的角度来看，这是 [*部分应用*](https://oreil.ly/V1KOm) 的一个例子：固定函数的一些参数以产生具有更少参数的函数。尽管有些语言提供了内置支持，但在
    Kotlin 中，最简单的方法是编写一个函数来部分应用我们的配置。
- en: 'What we want is a function that takes the configuration and returns a function
    that knows how to send an email:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要的是一个函数，它接受配置并返回一个知道如何发送电子邮件的函数：
- en: '[PRE12]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[![1](assets/1.png)](#co_introduction_CO29-1)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_introduction_CO29-1)'
- en: The return type of our function is itself a function that takes an `Email` and
    returns `Unit`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们函数的返回类型本身就是一个接受 `Email` 并返回 `Unit` 的函数。
- en: Thus, `createEmailSender` is a constructor. Not a class constructor, but a function
    taking the same role. Both `createEmailSender` and `::EmailSender` are functions
    that return an object that knows how to send a message.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`createEmailSender` 是一个构造函数。不是类的构造函数，而是扮演同样角色的函数。`createEmailSender` 和 `::EmailSender`
    都是返回一个知道如何发送消息的对象的函数。
- en: 'To see how this works in functions, we can write this in longhand first by
    defining an inner function that captures the arguments it requires from the parent:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解这在函数中如何运作，我们可以先用长写法来定义一个内部函数，它捕获其父级所需的参数：
- en: '[PRE13]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can then make the result a lambda expression:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以将结果转化为一个 lambda 表达式：
- en: '[PRE14]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If we inline `result` and convert the whole function to a single expression,
    we are left with this functional definition:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们内联 `result` 并将整个函数转换为单一表达式，我们得到以下函数定义：
- en: '[PRE15]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: So `createEmailSender` is a function that returns a lambda that calls `sendEmail`,
    combining the lambda’s single `Email` argument with the configuration from its
    own parameters. This is a closure in functional land, and it’s not a coincidence
    that it is very similar to the OO versions with a `fun interface` or `object`
    definition.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`createEmailSender` 是一个返回 lambda 的函数，该 lambda 调用 `sendEmail`，将 lambda 的单个
    `Email` 参数与自己参数的配置结合起来。这在函数式编程中是一个闭包，这与带有 `fun interface` 或 `object` 定义的 OO 版本非常相似，这并非巧合。
- en: 'To use this function, we can create it in one place and invoke it in another,
    very much as we did with the object solution:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此函数，我们可以在一个地方创建它，在另一个地方调用它，非常类似于对象解决方案：
- en: '[PRE16]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[![1](assets/1.png)](#co_introduction_CO30-1)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_introduction_CO30-1)'
- en: An implicit `invoke` call is hidden here.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这里隐藏了一个隐式的 `invoke` 调用。
- en: 'This is the same shape as the OO case (if we replace the hidden `invoke` with
    `send`):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 OO 案例相同（如果我们将隐藏的`invoke`替换为`send`）：
- en: '[PRE17]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the unlikely event that you’re joining us from JavaScript or Clojure, the
    functional form will be familiar, but if you came to Kotlin from Java, this solution
    probably feels quite alien.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是从 JavaScript 或 Clojure 转来，函数形式可能很熟悉，但如果您从 Java 来到 Kotlin，这种解决方案可能会感觉非常陌生。
- en: Function Types in Java
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 中的函数类型
- en: Both the object and functional forms have allowed us to encapsulate things (in
    this case configuration, but it could equally well have been collaborators) to
    transport them from the place where they are known to the place where they are
    used. Any data structure could have done that, but because the object and the
    function both have an operation that can be run (`send` and `invoke`, respectively),
    the client can remain oblivious to the details of the configuration and just pass
    the information that is specific to each invocation (the `Email`).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对象形式和函数形式都允许我们封装事物（在本例中是配置，但同样可以是协作者），将它们从已知位置传输到使用位置。任何数据结构都可以做到这一点，但因为对象和函数都有可以运行的操作（分别是`send`和`invoke`），客户端可以对配置的细节毫不知情，只需传递每次调用特定的信息（`Email`）。
- en: 'One way of unifying the functional and OO solutions is to view a function as
    an object with a single `invoke` method. This is exactly what Java 8 did when
    it introduced lambdas. To refer to a function type, Java uses interfaces with
    a *Single Abstract Method* (SAM) that has the desired signature. Lambdas in Java
    are a special syntax to implement a SAM interface. The Java runtime defines SAM
    interfaces named by role: `Consumer`, `Supplier`, `Function`, `BiFunction`, `Predicate`,
    and so on for us. It also provides primitive specializations, like `DoublePredicate`,
    to avoid boxing issues.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 统一函数式和 OO 解决方案的一种方法是将函数视为具有单个 `invoke` 方法的对象。这正是 Java 8 引入 lambda 时所做的。为了引用函数类型，Java
    使用具有所需签名的单抽象方法（SAM）的接口。Java 中的 lambda 是一种特殊的语法，用于实现 SAM 接口。Java 运行时定义了按角色命名的 SAM
    接口：`Consumer`、`Supplier`、`Function`、`BiFunction`、`Predicate` 等等。它还提供了原始特化，如 `DoublePredicate`，以避免装箱问题。
- en: 'Expressed in Java, our functional solution is:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 用 Java 表达的函数式解决方案是：
- en: '[PRE18]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[![1](assets/1.png)](#co_introduction_CO31-1)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_introduction_CO31-1)'
- en: '`accept` is the name of the single abstract method on the `Consumer` interface.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`accept` 是 `Consumer` 接口上的单抽象方法的名称。'
- en: '`createEmailSender` can be implemented with a lambda:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`createEmailSender` 可以用 lambda 实现：'
- en: '[PRE19]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This is equivalent to creating an anonymous implementation of the interface,
    a technique that will be very familiar to those of us who programmed in Java before
    Java 8:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于创建接口的匿名实现，这种技术对于之前在 Java 中编程的人来说非常熟悉：
- en: '[PRE20]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We say “equivalent to creating an anonymous implementation of the interface,”
    but under the hood, the implementation is more complex to avoid unnecessarily
    defining classes and instantiating objects.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说“相当于创建接口的匿名实现”，但在幕后，该实现更复杂，以避免不必要地定义类和实例化对象。
- en: Note that we can’t assign the `(Email) -> Unit` result of the Kotlin `createEmailSender`
    to a variable of type `Consumer<Email>`. This is because the Kotlin runtime uses
    its own function types, and the compiler compiles `(Email) -> Unit` into `Function1<Email,
    Unit>`. There are a whole series of Kotlin `FunctionN` interfaces for the different
    numbers of parameters.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不能将 Kotlin `createEmailSender` 的 `(Email) -> Unit` 结果分配给类型为 `Consumer<Email>`
    的变量。这是因为 Kotlin 运行时使用其自己的函数类型，并且编译器将 `(Email) -> Unit` 编译为 `Function1<Email, Unit>`。对于不同数量参数，Kotlin
    还有一系列的 `FunctionN` 接口。
- en: 'Because the interfaces are not compatible, to mix Java and Kotlin at this functional
    level, we will have to thunk sometimes. Given a Kotlin function type `(Email)
    -> Unit`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 由于接口不兼容，在这个功能级别上混合使用Java和Kotlin时，有时我们需要 thunk。给定一个Kotlin函数类型`(Email) -> Unit`：
- en: '[PRE21]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can’t just assign `sender` to `Consumer<Email`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能简单地将`sender`赋给`Consumer<Email>`：
- en: '[PRE22]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[![1](assets/1.png)](#co_introduction_CO32-1)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_introduction_CO32-1)'
- en: '`Type mismatch. Required: Consumer<Email> Found:(Email) -> Unit`'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`类型不匹配。需要：Consumer<Email> 找到：(Email) -> Unit`'
- en: 'We can, though, convert with a lambda:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，我们可以通过lambda表达式进行转换：
- en: '[PRE23]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'There is a situation where we don’t have to convert, which is calling a Java
    method that takes a SAM parameter, for example, this constructor:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种情况无需转换，即调用接受SAM参数的Java方法，例如这个构造函数：
- en: '[PRE24]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here, the compiler *is* able to convert `(Email) -> Unit` to `Consumer<Email>`,
    because Kotlin will convert parameters automatically, so that we can say:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，编译器确实能够将`(Email) -> Unit`转换为`Consumer<Email>`，因为Kotlin会自动转换参数，这样我们可以说：
- en: '[PRE25]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Mix and Match
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合和匹配
- en: There are two sides to an abstraction, the client code and the implementation
    code. So far, both client and implementor have either been object-oriented or
    functional. In the OO case, fields carry configuration, and the client invokes
    a method. In the functional scheme, a function closes over the configuration,
    and the client invokes the function.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象有两个方面，客户端代码和实现代码。到目前为止，客户端和实现者都是面向对象或函数式的。在面向对象的情况下，字段携带配置，并且客户端调用方法。在函数式方案中，函数闭合配置，并且客户端调用函数。
- en: Can we unify these approaches, passing an OO implementation to a function-expecting
    client or vice versa? Or, in Kotlin terms, can we convert `ISendEmail` to `(Email)
    -> Unit` and the inverse? Why yes we can!
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否统一这些方法，将面向对象实现传递给期望函数的客户端，反之亦然？或者用Kotlin术语来说，我们能否将`ISendEmail`转换为`(Email)
    -> Unit`，反之亦然？答案是肯定的！
- en: Remember that in Java and Kotlin, function types are just interfaces. Because
    of this, `EmailSender` can implement the type `Consumer<Email>` or `(Email) ->
    Unit`, respectively, by defining a method with the signature of the function type.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在Java和Kotlin中，函数类型只是接口。因此，`EmailSender`可以分别通过定义具有函数类型签名的方法来实现类型`Consumer<Email>`或`(Email)
    -> Unit`。
- en: 'So in Java, we can write:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，我们可以写成：
- en: '[PRE26]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[![1](assets/1.png)](#co_introduction_CO33-1)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_introduction_CO33-1)'
- en: Declare
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 声明
- en: '[![2](assets/2.png)](#co_introduction_CO33-2)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_introduction_CO33-2)'
- en: Implement
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 实现
- en: 'This is the Kotlin equivalent:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin的等价代码如下：
- en: '[PRE27]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[![1](assets/1.png)](#co_introduction_CO34-1)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_introduction_CO34-1)'
- en: Declare
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 声明
- en: '[![2](assets/2.png)](#co_introduction_CO34-2)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_introduction_CO34-2)'
- en: Implement
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 实现
- en: 'If we do this, we can use our class-based sender in place of our functional
    one. We’ll stick with Kotlin now:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们这样做，我们可以在功能上使用基于类的发送器替代我们的函数式发送器。现在我们继续使用Kotlin：
- en: '[PRE28]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[![1](assets/1.png)](#co_introduction_CO35-1)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_introduction_CO35-1)'
- en: There is an implicit `invoke` here.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个隐式的`invoke`。
- en: Now our object-oriented implementation has gained an `invoke` method to fit
    in with the functional approach. This calls into question the usefulness of our
    `ISendEmail` interface. We can see that it is equivalent to the function type
    `(Email) -> Unit`. All it does is give the name `send` to what happens when you
    invoke it. Maybe we could just use the type `(Email) -> Unit` everywhere in place
    of `ISendEmail`?
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的面向对象实现增加了一个`invoke`方法以适应函数式方法。这引发了我们的`ISendEmail`接口的实用性问题。我们可以看到它等同于函数类型`(Email)
    -> Unit`。它所做的只是给`send`一个名称，表明调用它时会发生什么。也许我们可以在所有地方都使用类型`(Email) -> Unit`来代替`ISendEmail`？
- en: 'If you think that isn’t expressive enough, then maybe you aren’t a functional
    programmer. Luckily, there is a middle ground: we can use a type alias to give
    a name to the functional type, thus communicating our intent:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你觉得这不够表达性，那么也许你不是一个函数式程序员。幸运的是，我们可以采用类型别名来为函数类型命名，从而传达我们的意图：
- en: '[PRE29]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In reality, we would probably call `EmailSenderFunction`, `EmailSender`. Here
    we’ve given it a different name to avoid confusion with the OO version, but the
    fact that we want to call them the same thing shows that they serve the same purpose
    from the client’s perspective.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们可能会称之为`EmailSenderFunction`、`EmailSender`。这里我们给它起了一个不同的名字，以避免与面向对象版本混淆，但我们想要称它们为同一个东西表明它们从客户端的角度来看是具有相同目的的。
- en: 'There is another way of bridging the OO–FP gap that doesn’t involve making
    our classes implement function types: create a function reference at the point
    of translation. Here is our old class-based solution:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种方法可以弥合面向对象和函数式编程之间的差距，而不涉及使我们的类实现函数类型：在翻译点创建一个函数引用。这是我们旧的基于类的解决方案：
- en: '[PRE30]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can convert an instance of `EmailSender` to a function type with a lambda:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 lambda 将 `EmailSender` 的实例转换为函数类型：
- en: '[PRE31]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'or just use a method reference:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 或者只是使用方法引用：
- en: '[PRE32]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Although we’ve shown these conversions in Kotlin, they also work in Java (with
    a slightly different syntax). They work with the `send` method on the `ISendEmail`
    interface too, although it’s not clear that the interface is doing much for us
    if we are using the function type.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们展示了这些在 Kotlin 中的转换，它们在 Java 中也适用（语法略有不同）。它们也适用于 `ISendEmail` 接口上的 `send`
    方法，尽管如果我们使用函数类型，接口对我们来说并没有多大用处，这一点并不清楚。
- en: 'Can we do the opposite and pass our functional sender into something that expects
    an `ISendEmail`? This requires more ceremony, because we have to create an anonymous
    object implementing `ISendEmail` to perform the thunk:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以反过来将我们的函数式发送器传递给期望 `ISendEmail` 的某些东西吗？这需要更多的仪式感，因为我们必须创建一个实现 `ISendEmail`
    的匿名对象来执行这个 thunk：
- en: '[PRE33]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If we had used a Kotlin 1.4 `fun interface`, we could again remove some boilerplate:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用了 Kotlin 1.4 的 `fun interface`，我们可以再次减少一些样板代码：
- en: '[PRE34]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Comparing the Approaches
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较方法
- en: Let’s remind ourselves of the OO approach.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下面向对象的方法。
- en: 'First we define a type:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们定义一个类型：
- en: '[PRE35]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then we create instances and call methods:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建实例并调用方法：
- en: '[PRE36]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In functional land, we don’t have to define a type, because `(Email) -> Unit`
    just exists (which is to say, is provided by the runtime), so we can just say:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式领域中，我们不必定义一个类型，因为 `(Email) -> Unit` 就已经存在（也就是说，由运行时提供），所以我们可以直接说：
- en: '[PRE37]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[![1](assets/1.png)](#co_introduction_CO36-1)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_introduction_CO36-1)'
- en: With or without the `invoke`
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 有或没有 `invoke`
- en: Clients using the *object* have to know to call the `send` method to send email;
    in contrast, clients using the *function* just have to invoke it, but they only
    know that the function sends email because it has been assigned the name `sender`.
    If that name got lost in the call hierarchy, we are left to guess what happens
    from the function signature.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *object* 的客户端必须知道调用 `send` 方法来发送电子邮件；相比之下，使用 *function* 的客户端只需调用它，但他们只知道这个函数发送电子邮件，因为它被分配了名字
    `sender`。如果这个名字在调用层次结构中丢失了，我们只能从函数签名猜测发生了什么。
- en: 'The quid pro quo of the OO clients having to know to call the `send` method
    is that we could package up a number of email-related operations into an `EmailSystem`,
    with methods like `send`, `list`, and `delete`, and pass all this functionality
    to clients in one go. Clients can then choose which they need in which context:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象客户端必须知道调用 `send` 方法的回报是，我们可以将一些与电子邮件相关的操作打包成一个 `EmailSystem`，例如 `send`、`list`
    和 `delete` 等方法，并将所有这些功能一次性传递给客户端。客户端然后可以选择在哪个上下文中需要哪个：
- en: '[PRE38]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To achieve this functionally would require either passing individual functions
    around or some sort of map of name to function, maybe an instance of a class itself:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要在功能上实现这一点，要么传递单个函数，要么传递某种名称到函数的映射，也许是类本身的一个实例：
- en: '[PRE39]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Given such an object, clients could treat it very much like an implementation
    of the interface:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于这样的对象，客户端可以非常像使用接口的实现一样对待它：
- en: '[PRE40]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'But this is not the same as the OO code. Instead of invoking a `send` *method*,
    what is actually happening here is that we are calling `getSender` to access a
    property of function type, and then calling `invoke` on that function:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 但这与面向对象的代码不同。这里并不是调用 `send` *方法*，实际上发生的是我们调用 `getSender` 来访问函数类型的属性，然后在该函数上调用
    `invoke`：
- en: '[PRE41]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The code may read the same, but it generates very different, and fundamentally
    incompatible, bytecode.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可能看起来相同，但生成了非常不同且基本不兼容的字节码。
- en: Coupling
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 耦合
- en: A subtle difference between expressing a dependency as either an implementation
    of `ISendEmail`, or as an implementation of the function type `(Email) -> Unit`,
    is the coupling between the client and the implementation, in particular when
    they are in different code modules.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 表达依赖性为 `ISendEmail` 的实现或函数类型 `(Email) -> Unit` 之间微妙的差别是客户端和实现之间的耦合，特别是当它们位于不同的代码模块中时。
- en: '`ISendEmail` has to be defined somewhere. The client can’t define it, because
    the implementor will depend on the interface, and the client on the implementation,
    leading to a circular dependency. So the interface has to be defined either with
    the implementation, or in a separate place (package or JAR file) depended on by
    both implementation and its clients. The latter (an application of the [dependency
    inversion principle](https://oreil.ly/AcrWj)) is in theory preferable but in practice
    more work and thus often neglected.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`ISendEmail`必须在某处定义。客户端不能定义它，因为实现者将依赖于接口，而客户端将依赖于实现，导致循环依赖。因此，接口必须在实现中定义，或者在一个独立的地方（包或JAR文件）定义，被实现及其客户端依赖。（这是[依赖反转原则](https://oreil.ly/AcrWj)的应用）理论上更可取，但在实践中往往被忽视，因为需要更多工作。'
- en: With or without dependency inversion, the result is the client and implementation
    being coupled by the interface in ways that can make systems hard to reason with
    and refactor. Any change to methods on `EmailSystem` might affect all code that
    depends on the interface.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是否有依赖反转，结果都是客户端和实现通过接口耦合，这可能使系统难以理解和重构。对`EmailSystem`上方法的任何更改都可能影响依赖接口的所有代码。
- en: In contrast, in the functional world, the runtime defines all the function types,
    so they don’t introduce a compile-time dependency between the client and an implementation.
    Unlike `ISendEmail`, which we have to define somewhere, `(Email) -> Unit` (or
    in Java, `Consumer<Email>`) is part of the language. Of course, there will be
    a runtime dependency—the constructor code needs to be visible where the dependency
    is created, and the client has to be able to invoke the implementation code—but
    these cause less coupling. For example, when a dependency is expressed as a function
    type, we can rename `EmailSystem.send`, and the only change in our client code
    will be to use a different method reference; the internals of `sendThanks` are
    unaffected.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，在函数式世界中，运行时定义了所有的函数类型，因此它们不会在客户端和实现之间引入编译时依赖。与我们必须在某处定义的`ISendEmail`不同，`(Email)
    -> Unit`（或在Java中，`Consumer<Email>`）是语言的一部分。当然，会存在运行时依赖——构造函数的代码需要在依赖创建的地方可见，并且客户端必须能够调用实现代码——但这些会导致较少的耦合。例如，当依赖表达为函数类型时，我们可以重命名`EmailSystem.send`，而客户端代码唯一需要修改的是使用不同的方法引用；`sendThanks`的内部不受影响。
- en: Only Pass Types That You Own or That the Runtime Defines
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 只传递你拥有的类型或运行时定义的类型
- en: An early rule of thumb for OO systems was that, on the inside of our systems,
    we should program in terms of types that we own rather than those supplied by
    libraries. That way we are insulated from changes that we don’t control and are
    more likely to write code that can be reused with different implementations.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 早期面向对象系统的一个经验法则是，我们在系统内部时，应该按照我们拥有的类型来编程，而不是依赖于库提供的类型。这样我们就能够隔离我们无法控制的变化，并且更有可能编写可通过不同实现重复使用的代码。
- en: An exception to this rule is taking a dependency on types provided by the runtime;
    these are very unlikely to change. Function types allow us to easily convert from
    unstable to stable interfaces, allowing parts of our systems to evolve at different
    rates.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规则的一个例外是依赖于运行时提供的类型；这些类型变化的可能性非常小。函数类型允许我们轻松地从不稳定的接口转换为稳定的接口，使系统的各部分可以以不同的速度发展。
- en: Object-Oriented or Functional?
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象还是函数式？
- en: Both the object-oriented and functional approaches can achieve the same goals,
    and with similar levels of expressiveness. Which should we choose?
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象和函数式方法都可以实现相同的目标，并具有类似的表达能力。我们应该选择哪一种呢？
- en: 'Let’s consider this from the context of the client code. If our client only
    needs to list email, it should have a dependency on a single `(Folder) -> List<Email>`
    function. This way it is not coupled to an implementation, and the dependency
    can be satisfied by anything implementing the function type, including:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从客户端代码的角度来考虑这个问题。如果我们的客户端只需要列出电子邮件，它应该依赖于一个单一的`(Folder) -> List<Email>`函数。这样就不会与实现耦合，依赖可以由任何实现函数类型的东西满足，包括：
- en: A plain function
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个普通函数
- en: An object implementing the function type
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现函数类型的对象
- en: Method reference selecting a method with the desired signature
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择具有所需签名的方法引用
- en: A lambda with the desired signature
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有所需签名的lambda
- en: 'Even if we already happen to have an interface, let’s say `EmailSystem`, which
    defines the desired method along with `send`, `move`, and `delete`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们已经有了一个接口，比如`EmailSystem`，它定义了所需的方法，比如`send`、`move`和`delete`：
- en: '[PRE42]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'we shouldn’t needlessly couple our client to this interface when the function
    type will do:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数类型足够时，我们不应无端将客户端与此接口耦合：
- en: '[PRE43]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Depending on the wider interface misses the opportunity to communicate precisely
    which operations we require and forces clients to provide an implementation of
    the whole interface. This is particularly irritating in tests, where we will have
    to introduce fake objects just to get our test code to compile.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖更广泛的接口会错失精确表达我们需要的操作的机会，并迫使客户端提供整个接口的实现。这在测试中特别令人恼火，因为我们将不得不引入虚假对象才能使我们的测试代码编译通过。
- en: 'The drives of communication and reduced coupling are so strong that even if
    our client needs to send and delete email, and in practice these will be supplied
    by a single `EmailSystem`, the client should probably depend on two functions
    rather than the interface:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 通信和减少耦合的驱动力是如此强大，以至于即使我们的客户端需要发送和删除电子邮件，而实际上这些将由单个`EmailSystem`提供，客户端可能应该依赖于两个函数而不是接口：
- en: '[PRE44]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Only when the client requires three related operations does it feel like a
    multimethod interface should be the default:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当客户需要三个相关操作时，多方法接口才感觉应该是默认的：
- en: '[PRE45]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Even here, it might be better for the client to accept an object that only
    supports the desired operations. We can do that with a new interface (`Dependencies`
    here), implemented with an `object`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在这里，客户端接受仅支持所需操作的对象可能会更好。我们可以使用一个新的接口（这里称为`Dependencies`），由一个`object`实现：
- en: '[PRE46]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'That’s pretty irritating though; maybe this is a place where a class of functions
    would be better:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实相当恼人；也许这是一个函数类更好的地方：
- en: '[PRE47]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: So, until it becomes hard work, we should default to expressing our client’s
    needs as function types. Our implementation then can be just a function, or something
    implementing the function type, or a method converted to the function type through
    method references or lambdas, whichever makes most sense in context.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，直到变得困难，我们应默认将客户端的需求表达为函数类型。然后我们的实现可以仅仅是一个函数，或者是实现函数类型的东西，或者是通过方法引用或Lambda转换为函数类型的方法，以在上下文中最合理的方式进行。
- en: The Legacy of Java
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java的遗产
- en: Although we said earlier that “our runtime defines all the functions types,”
    that wasn’t true of Java until Java 8 introduced `Supplier`, `Consumer`, `Predicate`,
    and so on, and the ability to implement them with method references or lambdas.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们之前说过“我们的运行时定义了所有的函数类型”，但直到Java 8引入了`Supplier`、`Consumer`、`Predicate`等功能以及使用方法引用或Lambda实现它们的能力之前，Java并不是这样的。
- en: Because of this, legacy Java code usually expresses dependencies with the same
    multimethod interfaces that we would use to group them by subsystem (like `EmailSystem`),
    even when only one of those methods is required to implement the functionality.
    This leads to the coupling problems described earlier. It also leads to a need
    for mocking (or, more pedantically, faking) frameworks to create test implementations
    of broad interfaces where in practice only one method will be called. These fakes
    then sprout the functionality to fail early if you call a method that you didn’t
    mean to call, a problem that would be solved at compile time if a single function
    expressed the dependency.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，遗留的Java代码通常使用相同的多方法接口来表达依赖关系，就像我们将它们按子系统（如`EmailSystem`）分组一样，即使只有一个方法需要实现功能。这导致了前面描述的耦合问题。它还导致了需要模拟（或更加严谨地说是伪造）框架来创建广泛接口的测试实现，尽管实际上只有一个方法会被调用。这些伪造物然后会在你调用不打算调用的方法时提前失败的功能。
- en: Once we have introduced a mocking framework into our codebase (or, more usually,
    two or three mocking frameworks to cater to different tastes), they allow us to
    solve problems, like generating implementations for unused methods and stubbing
    out interactions with external systems. Usually, though, our code would be improved
    by restructuring to avoid the need for mocks. Expressing dependencies as function
    types is one example; another is moving the interaction with external systems
    to the outer layers of our code, as we will see in [Chapter 20](ch20.html#performing-io-to-passing-data).
    [Chapter 17](ch17.html#mocks-to-maps) looks at how to reduce mock use by refactoring
    our tests to a more functional form.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在代码库中引入了一个模拟框架（或者更通常的是两到三个模拟框架以迎合不同的喜好），它们允许我们解决问题，比如生成未使用方法的实现并且创建外部系统交互的存根。通常情况下，我们的代码通过重构来避免对模拟的需求会更好。表达依赖关系作为函数类型是一个例子；另一个例子是将与外部系统的交互移动到代码的外层，正如我们将在[第
    20 章](ch20.html#performing-io-to-passing-data)中看到的那样。[第 17 章](ch17.html#mocks-to-maps)讨论了如何通过重构测试来减少模拟的使用，使其更具功能性形式。
- en: Traceability
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可追溯性
- en: There is a downside to expressing dependencies with function types, and it is
    a common issue with adding a layer of indirection. If we use IntelliJ to find
    the callers of `EmailSystem.send`, the trail goes cold at the point where `EmailSystem::send`
    is converted to `(Email) -> Unit`. The IDE doesn’t know that invocations of the
    function are actually calling the method. It’s like our hero enters a river, and
    the posse tracking them has to scour both banks upstream and downstream to find
    where they get out.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数类型表达依赖关系有一个缺点，并且添加间接层次是一个常见问题。如果我们使用 IntelliJ 查找`EmailSystem.send`的调用者，踪迹在将`EmailSystem::send`转换为`(Email)
    -> Unit`时中断。IDE 不知道函数调用实际上是在调用方法。就像我们的英雄进入河流，追踪者必须在上游和下游的两岸搜索，才能找到他们出去的地方。
- en: This is a price we pay for indirection with method calls too, but our tooling
    is wise to these and can at least find all places where a particular method is
    implemented, and where an implementation is called through an interface. As with
    using unencapsulated collections ([Chapter 15](ch15.html#encapsulated-collections-to-typealiases)),
    the price that we pay for decoupling and generality is that tooling, and developers,
    have less context to hang analysis on. We trust that IDE support will improve
    its functional analysis, and in the meantime, we can help by not passing function
    types too far from where they are initialized to where they are used.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是我们通过方法调用引入间接性所付出的代价，但是我们的工具对此了如指掌，至少可以找到特定方法的所有实现位置，以及通过接口调用实现的位置。就像使用未封装集合（[第
    15 章](ch15.html#encapsulated-collections-to-typealiases)）一样，我们为解耦和通用性付出的代价是工具和开发人员在分析时的上下文更少。我们相信
    IDE 支持将改进其功能分析，同时，我们可以通过不将函数类型传递得太远来提供帮助，直到它们被初始化和使用的地方。
- en: Refactoring from Interfaces to Functions
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从接口到函数的重构
- en: 'Travelator is quite well-designed in the Java fashion, with interfaces expressing
    the relations between components. For example, the `Recommendations` engine depends
    on `FeaturedDestinations` and a `DistanceCalculator`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Travelator 在 Java 风格中设计得相当好，接口表达了组件之间的关系。例如，`Recommendations` 引擎依赖于`FeaturedDestinations`和`DistanceCalculator`：
- en: '[PRE48]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[Example 16.1 [interfaces-to-funs.0:src/main/java/travelator/recommendations/Recommendations.java]](https://java-to-kotlin.dev/code.html?ref=16.1&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=16.1&show=diff)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 16.1 [interfaces-to-funs.0:src/main/java/travelator/recommendations/Recommendations.java]](https://java-to-kotlin.dev/code.html?ref=16.1&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=16.1&show=diff)'
- en: 'The `FeaturedDestinations` interface has a few methods, grouping functionality
    that accesses a remote service:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`FeaturedDestinations` 接口有几个方法，分组功能以访问远程服务：'
- en: '[PRE49]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[Example 16.2 [interfaces-to-funs.0:src/main/java/travelator/destinations/FeaturedDestinations.java]](https://java-to-kotlin.dev/code.html?ref=16.2&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=16.2&show=diff)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 16.2 [interfaces-to-funs.0:src/main/java/travelator/destinations/FeaturedDestinations.java]](https://java-to-kotlin.dev/code.html?ref=16.2&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=16.2&show=diff)'
- en: 'It looks like we’ve already converted the `DistanceCalculator` interface to
    Kotlin. It too has more than one method, and hides another external service:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们已经将`DistanceCalculator`接口转换为 Kotlin。它也有多个方法，并且隐藏了另一个外部服务：
- en: '[PRE50]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[Example 16.3 [interfaces-to-funs.0:src/main/java/travelator/domain/DistanceCalculator.kt]](https://java-to-kotlin.dev/code.html?ref=16.3&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=16.3&show=diff)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'Despite taking a dependency on a total of seven methods, `Recommendations`
    only actually uses two of them in its implementation:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[Example 16.4 [interfaces-to-funs.0:src/main/java/travelator/recommendations/Recommendations.java]](https://java-to-kotlin.dev/code.html?ref=16.4&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=16.4&show=diff)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[![1](assets/1.png)](#co_introduction_CO37-1)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Method on `FeaturedDestinations`
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_introduction_CO37-2)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Method on `DistanceCalculator`
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '`RecommendationsTests` uses mocks to provide implementations of its `Distance​Cal⁠cula⁠tor`
    and `FeaturedDestinations`, which are passed to the instance of `Recommendations`
    under test:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[Example 16.5 [interfaces-to-funs.0:src/test/java/travelator/recommendations/RecommendationsTests.java]](https://java-to-kotlin.dev/code.html?ref=16.5&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=16.5&show=diff)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'The tests specify that the expected interactions with the mocks are using two
    methods: `givenFeaturedDestinationsFor` and `givenADistanceBetween`, which we
    won’t bore you with:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[Example 16.6 [interfaces-to-funs.0:src/test/java/travelator/recommendations/RecommendationsTests.java]](https://java-to-kotlin.dev/code.html?ref=16.6&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=16.6&show=diff)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Introduce Functions
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we start moving from interfaces to functions, we’ll convert `Recommendations`
    to Kotlin. This is the class that currently expresses its dependencies with interfaces,
    and Kotlin function types are less clunky than Java’s.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'Converting to Kotlin and applying the refactorings introduced in Chapters [10](ch10.html#functions-to-extension-functions)
    and [13](ch13.html#streams-to-sequences) gives:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[Example 16.7 [interfaces-to-funs.3:src/main/java/travelator/recommendations/Recommendations.kt]](https://java-to-kotlin.dev/code.html?ref=16.7&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=16.7&show=diff)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how the internals of `Recommendations` would use a function rather than
    the interface, without having to change its interface yet, we can add a property
    initialized from an interface method. Let’s add a property for `featuredDestinations::find​Clo⁠seTo`,
    calling it `destinationFinder`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[Example 16.8 [interfaces-to-funs.4:src/main/java/travelator/recommendations/Recommendations.kt]](https://java-to-kotlin.dev/code.html?ref=16.8&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=16.8&show=diff)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[![1](assets/1.png)](#co_introduction_CO38-1)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Extract a function from the interface.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_introduction_CO38-2)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Use it in place of the method.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'This passes the tests, so we are on to something. It feels like there should
    be a refactoring to move `destinationFinder` into the constructor, but we haven’t
    found anything better than cutting the definition and pasting where we want it:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过了测试，所以我们正在做正确的事情。感觉应该有一个重构来将`destinationFinder`移到构造函数中，但我们还没有找到比将定义剪切并粘贴到所需位置更好的方法：
- en: '[PRE56]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[Example 16.9 [interfaces-to-funs.5:src/main/java/travelator/recommendations/Recommendations.kt]](https://java-to-kotlin.dev/code.html?ref=16.9&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=16.9&show=diff)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 16.9 [interfaces-to-funs.5:src/main/java/travelator/recommendations/Recommendations.kt]](https://java-to-kotlin.dev/code.html?ref=16.9&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=16.9&show=diff)'
- en: 'This is, once again, the *expand* in [“Expand-and-Contract Refactoring”](ch04.html#expand-contract).
    Unfortunately, Java doesn’t understand the defaulted parameter, so we have to
    fix up the call sites to add the function argument. It doesn’t really matter,
    because this is what we want really anyway:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这又一次是[“扩展和收缩重构”](ch04.html#expand-contract)中的*扩展*。不幸的是，Java无法理解默认参数，所以我们必须修复调用站点以添加函数参数。这并不重要，因为这才是我们真正想要的：
- en: '[PRE57]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[Example 16.10 [interfaces-to-funs.5:src/test/java/travelator/recommendations/RecommendationsTests.java]](https://java-to-kotlin.dev/code.html?ref=16.10&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=16.10&show=diff)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 16.10 [interfaces-to-funs.5:src/test/java/travelator/recommendations/RecommendationsTests.java]](https://java-to-kotlin.dev/code.html?ref=16.10&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=16.10&show=diff)'
- en: 'Now nothing in `Recommendations` uses the `featuredDestinations` property,
    so we can remove it (contract):'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`Recommendations`中没有使用`featuredDestinations`属性，因此我们可以将其删除（contract）：
- en: '[PRE58]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[Example 16.11 [interfaces-to-funs.6:src/main/java/travelator/recommendations/Recommendations.kt]](https://java-to-kotlin.dev/code.html?ref=16.11&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=16.11&show=diff)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 16.11 [interfaces-to-funs.6:src/main/java/travelator/recommendations/Recommendations.kt]](https://java-to-kotlin.dev/code.html?ref=16.11&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=16.11&show=diff)'
- en: 'The places in our code that create `Recommendations` now look like this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们代码中创建`Recommendations`的地方现在看起来是这样的：
- en: '[PRE59]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[Example 16.12 [interfaces-to-funs.6:src/test/java/travelator/recommendations/RecommendationsTests.java]](https://java-to-kotlin.dev/code.html?ref=16.12&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=16.12&show=diff)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 16.12 [interfaces-to-funs.6:src/test/java/travelator/recommendations/RecommendationsTests.java]](https://java-to-kotlin.dev/code.html?ref=16.12&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=16.12&show=diff)'
- en: If you’re used to refactoring tests with mocks, it may surprise you that the
    tests have continued to pass through this refactoring. We can reason that they
    *should* pass—the effect of calling the function bound to `featuredDestinations::findCloseTo`
    is still to invoke the method on the mocked interface—but our reasoning is so
    often proved wrong by running the tests that we don’t count our chickens.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯使用模拟进行测试重构，那么测试继续通过这种重构可能会让你感到惊讶。我们可以推断它们*应该*通过——调用绑定到`featuredDestinations::findCloseTo`的函数的效果仍然是在模拟接口上调用方法——但我们的推理经常被运行测试证明是错误的，所以我们不要数我们的鸡蛋。
- en: 'We do like a single basket though, so let’s do the same thing with the `distance​Cal⁠cula⁠tor`,
    this time in a fell swoop, whatever that is:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，我们确实喜欢单一的篮子，所以让我们用同样的方法处理`distance​Cal⁠cul⁠ator`，这次一举两得，不管那是什么：
- en: '[PRE60]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[Example 16.13 [interfaces-to-funs.7:src/main/java/travelator/recommendations/Recommendations.kt]](https://java-to-kotlin.dev/code.html?ref=16.13&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=16.13&show=diff)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 16.13 [interfaces-to-funs.7:src/main/java/travelator/recommendations/Recommendations.kt]](https://java-to-kotlin.dev/code.html?ref=16.13&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=16.13&show=diff)'
- en: '[![1](assets/1.png)](#co_introduction_CO39-1)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_introduction_CO39-1)'
- en: Calling the new function
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 调用新函数
- en: 'The constructor invocations are now:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数调用现在是：
- en: '[PRE61]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[Example 16.14 [interfaces-to-funs.7:src/test/java/travelator/recommendations/RecommendationsTests.java]](https://java-to-kotlin.dev/code.html?ref=16.14&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=16.14&show=diff)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 16.14 [interfaces-to-funs.7:src/test/java/travelator/recommendations/RecommendationsTests.java]](https://java-to-kotlin.dev/code.html?ref=16.14&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=16.14&show=diff)'
- en: Note that a little thought around what to call functional variables can go a
    long way to making them seem natural in use, although that does sometimes make
    them a little cryptic where they are defined.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在函数变量命名上稍加思考可以使它们在使用时显得自然，尽管这有时会使它们在定义时显得有些神秘。
- en: Again the tests still pass, giving us confidence that our production code will
    see the transformation the same way. It’s particularly nice that we have shown
    that we can simultaneously cross a method/function boundary and a Java/Kotlin
    boundary. Maybe this interop will work out OK after all!
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 测试仍然通过，这让我们对我们的生产代码能够以相同方式进行转换感到自信。特别是我们已经展示了我们可以同时跨越方法/函数边界和Java/Kotlin边界。也许这种互操作性最终会顺利进行！
- en: Moving On
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Moving On
- en: We want our code to be simple and flexible. To this end, libraries need to hide
    implementation details from client code, and we want to be able to substitute
    one implementation of some functionality with another.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们的代码简单且灵活。为此，库需要将实现细节隐藏在客户端代码之外，并且我们希望能够用另一个功能的实现替换一个功能的实现。
- en: In OO, we hide configuration and implementation inside classes and express substitutable
    functionality with interfaces. In functional programming, functions take both
    roles. We might see the function as more fundamental, but we can view an object
    as a collection of functions, and a function as an object with a single method.
    Both Kotlin and Java allow us to move between realms at the boundaries between
    implementations and clients, but Kotlin’s native function type syntax encourages
    the use of function types rather than interfaces. This allows even more decoupling
    than defining our own interfaces and should be our default approach.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程中，我们将配置和实现隐藏在类中，并通过接口表达可替代的功能。在函数式编程中，函数承担了这两个角色。我们可能认为函数更为基础，但我们可以将对象视为函数的集合，将函数视为仅有一个方法的对象。Kotlin
    和 Java 都允许我们在实现和客户端之间的边界之间移动，但 Kotlin 的本地函数类型语法鼓励使用函数类型而不是接口。这比定义自己的接口更能实现解耦，并应成为我们的默认方法。
- en: We continue refactoring this example, and examining this relationship, in [Chapter 17,
    *Mocks to Maps*](ch17.html#mocks-to-maps).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续重构这个示例，并在[第17章，*Mocks to Maps*](ch17.html#mocks-to-maps)中检查这种关系。
