<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 5. Working With Records" data-type="chapter" epub:type="chapter"><div class="chapter" id="_02-records">
<h1><span class="label">Chapter 5. </span>Working With Records</h1>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45115246959280">
<h1>A Note for Early Release Readers</h1>
<p>With Early Release ebooks, you get books in their earliest form—the author’s raw and unedited content as they write—so you can take advantage of these technologies long before the official release of these titles.</p>
<p>This will be the 5th chapter of the final book. Please note that the GitHub repo will be made active later on.</p>
<p>If you have comments about how we might improve the content and/or examples in this book, or if you notice missing material within this chapter, please reach out to the editor at <em>rfernando@oreilly.com</em>.</p>
</div></aside>
<p>Java 14 introduced a new type of data structure as a preview<sup><a data-type="noteref" href="ch05.xhtml#idm45115246956000" id="idm45115246956000-marker">1</a></sup> feature, which was finalized two releases later: <em>Records</em>.
They are not just another typical Java type or technique you can use.
Instead, Records are a completely new language feature providing you with a simple but feature-rich data aggregator with minimal boilerplate.</p>
<section data-pdf-bookmark="Data Aggregation Types" data-type="sect1"><div class="sect1" id="_02-records_data-aggregation-types">
<h1>Data Aggregation Types</h1>
<p>From a general point-of-view, <em>data aggregation</em> is the process of gathering data from multiple sources and assembling it in a format that better serves the intended purpose and more preferable usage.
Maybe the most well-known kind of data aggregation type is <em>tuples</em>.</p>
<section data-pdf-bookmark="Tuples" data-type="sect2"><div class="sect2" id="idm45115246952096">
<h2>Tuples</h2>
<p>Mathematically speaking, a tuple is a “finite ordered sequence of elements.”
In terms of programming languages, a tuple is a data structure aggregating multiple values or objects.</p>
<p>There are two kinds of tuples.
<em>Structural</em> tuples rely only on the order of the contained elements and are therefore only accessible by their indices, as seen in the following Python code:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">apple</code> <code class="o">=</code> <code class="p">(</code><code class="s2">"apple"</code><code class="p">,</code> <code class="s2">"green"</code><code class="p">)</code>
<code class="n">banana</code> <code class="o">=</code> <code class="p">(</code><code class="s2">"banana"</code><code class="p">,</code> <code class="s2">"yellow"</code><code class="p">)</code>
<code class="n">cherry</code> <code class="o">=</code> <code class="p">(</code><code class="s2">"cherry"</code><code class="p">,</code> <code class="s2">"red"</code><code class="p">)</code>

<code class="n">fruits</code> <code class="o">=</code> <code class="p">[</code><code class="n">apple</code><code class="p">,</code> <code class="n">banana</code><code class="p">,</code> <code class="n">cherry</code><code class="p">]</code>

<code class="k">for</code> <code class="n">fruit</code> <code class="ow">in</code> <code class="n">fruits</code><code class="p">:</code>
  <code class="nb">print</code> <code class="s2">"The"</code><code class="p">,</code> <code class="n">fruit</code><code class="p">[</code><code class="mi">0</code><code class="p">],</code> <code class="s2">"is"</code><code class="p">,</code> <code class="n">fruit</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code></pre>
<p><em>Nominal</em> tuples don’t use an index to access their data, but they use component names instead, as seen in the following Swift code:</p>
<pre data-code-language="swift" data-type="programlisting"><code class="kd">typealias</code> <code class="n">Fruit</code> <code class="p">=</code> <code class="p">(</code><code class="n">name</code><code class="p">:</code> <code class="nb">String</code><code class="p">,</code> <code class="n">color</code><code class="p">:</code> <code class="nb">String</code><code class="p">)</code>

<code class="kd">let</code> <code class="nv">fruits</code><code class="p">:</code> <code class="p">[</code><code class="n">Fruit</code><code class="p">]</code> <code class="p">=</code> <code class="p">[</code>
  <code class="p">(</code><code class="n">name</code><code class="p">:</code> <code class="s">"apple"</code><code class="p">,</code> <code class="n">color</code><code class="p">:</code> <code class="s">"green"</code><code class="p">),</code>
  <code class="p">(</code><code class="n">name</code><code class="p">:</code> <code class="s">"banana"</code><code class="p">,</code> <code class="n">color</code><code class="p">:</code> <code class="s">"yellow"</code><code class="p">),</code>
  <code class="p">(</code><code class="n">name</code><code class="p">:</code> <code class="s">"cherry"</code><code class="p">,</code> <code class="n">color</code><code class="p">:</code> <code class="s">"red"</code><code class="p">)]</code>

<code class="k">for</code> <code class="n">fruit</code> <code class="k">in</code> <code class="n">fruits</code> <code class="p">{</code>
  <code class="bp">println</code><code class="p">(</code><code class="s">"The </code><code class="si">\(</code><code class="n">fruit</code><code class="p">.</code><code class="n">name</code><code class="si">)</code><code class="s"> is </code><code class="si">\(</code><code class="n">fruit</code><code class="p">.</code><code class="n">color</code><code class="si">)</code><code class="s">"</code><code class="p">)</code>
<code class="p">}</code></pre>
<p>In order to demonstrate what Records have to offer, you’ll first have a look at how to go from a classical POJO to an immutable one, and then I’ll show you how to replicate the same functionality with a Record instead.</p>
</div></section>
<section data-pdf-bookmark="A Simple POJO" data-type="sect2"><div class="sect2" id="idm45115246690736">
<h2>A Simple POJO</h2>
<p>First, let’s take a look at the “pre-Record” state of data aggregation in Java to better grasp what Records have to offer.
As an example, we create a simple “user” type as a “classic” POJO, evolve it to an “immutable” POJO, and finally, a Record.
It will be a simple type, with a username, an activity state, a last-login timestamp, and the “usual” boilerplate that comes along in typical Java code, as seen in <a data-type="xref" href="#_02-data-structures_records_user-pojo-like">Example 5-1</a>.</p>
<div data-type="example" id="_02-data-structures_records_user-pojo-like">
<h5><span class="label">Example 5-1. </span>Simple User POJO</h5>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">final</code> <code class="kd">class</code> <code class="nc">User</code> <code class="p">{</code>

  <code class="kd">private</code> <code class="n">String</code>        <code class="n">username</code><code class="p">;</code>
  <code class="kd">private</code> <code class="kt">boolean</code>       <code class="n">active</code><code class="p">;</code>
  <code class="kd">private</code> <code class="n">LocalDateTime</code> <code class="n">lastLogin</code><code class="p">;</code>

  <code class="kd">public</code> <code class="nf">User</code><code class="p">(</code><code class="p">)</code> <code class="p">{</code> <code class="p">}</code> <a class="co" href="#callout_working_with_records_CO1-1" id="co_working_with_records_CO1-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>

  <code class="kd">public</code> <code class="nf">User</code><code class="p">(</code><code class="n">String</code> <code class="n">username</code><code class="p">,</code>
              <code class="kt">boolean</code> <code class="n">active</code><code class="p">,</code>
              <code class="n">LocalDateTime</code> <code class="n">lastLogin</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_working_with_records_CO1-1" id="co_working_with_records_CO1-2"><img alt="1" height="12" src="assets/1.png" width="12"/></a>
    <code class="k">this</code><code class="p">.</code><code class="na">username</code> <code class="o">=</code> <code class="n">username</code><code class="p">;</code>
    <code class="k">this</code><code class="p">.</code><code class="na">active</code> <code class="o">=</code> <code class="n">active</code><code class="p">;</code>
    <code class="k">this</code><code class="p">.</code><code class="na">lastLogin</code> <code class="o">=</code> <code class="n">lastLogin</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="kd">public</code> <code class="n">String</code> <code class="nf">getUsername</code><code class="p">(</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_working_with_records_CO1-2" id="co_working_with_records_CO1-3"><img alt="2" height="12" src="assets/2.png" width="12"/></a>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="na">username</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="kd">public</code> <code class="kt">void</code> <code class="nf">setUsername</code><code class="p">(</code><code class="n">String</code> <code class="n">username</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_working_with_records_CO1-3" id="co_working_with_records_CO1-4"><img alt="3" height="12" src="assets/3.png" width="12"/></a>
    <code class="k">this</code><code class="p">.</code><code class="na">username</code> <code class="o">=</code> <code class="n">username</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="kd">public</code> <code class="kt">boolean</code> <code class="nf">isActive</code><code class="p">(</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_working_with_records_CO1-2" id="co_working_with_records_CO1-5"><img alt="2" height="12" src="assets/2.png" width="12"/></a>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="na">active</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="kd">public</code> <code class="kt">void</code> <code class="nf">setActive</code><code class="p">(</code><code class="kt">boolean</code> <code class="n">active</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_working_with_records_CO1-3" id="co_working_with_records_CO1-6"><img alt="3" height="12" src="assets/3.png" width="12"/></a>
    <code class="k">this</code><code class="p">.</code><code class="na">active</code> <code class="o">=</code> <code class="n">active</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="kd">public</code> <code class="n">LocalDateTime</code> <code class="nf">getLastLogin</code><code class="p">(</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_working_with_records_CO1-2" id="co_working_with_records_CO1-7"><img alt="2" height="12" src="assets/2.png" width="12"/></a>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="na">lastLogin</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="kd">public</code> <code class="kt">void</code> <code class="nf">setLastLogin</code><code class="p">(</code><code class="n">LocalDateTime</code> <code class="n">lastLogin</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_working_with_records_CO1-3" id="co_working_with_records_CO1-8"><img alt="3" height="12" src="assets/3.png" width="12"/></a>
    <code class="k">this</code><code class="p">.</code><code class="na">lastLogin</code> <code class="o">=</code> <code class="n">lastLogin</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="nd">@Override</code>
  <code class="kd">public</code> <code class="kt">int</code> <code class="nf">hashCode</code><code class="p">(</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_working_with_records_CO1-4" id="co_working_with_records_CO1-9"><img alt="4" height="12" src="assets/4.png" width="12"/></a>
    <code class="k">return</code> <code class="n">Objects</code><code class="p">.</code><code class="na">hash</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="na">username</code><code class="p">,</code>
                        <code class="k">this</code><code class="p">.</code><code class="na">active</code><code class="p">,</code>
                        <code class="k">this</code><code class="p">.</code><code class="na">lastLogin</code><code class="p">)</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="nd">@Override</code>
  <code class="kd">public</code> <code class="kt">boolean</code> <code class="nf">equals</code><code class="p">(</code><code class="n">Object</code> <code class="n">obj</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_working_with_records_CO1-5" id="co_working_with_records_CO1-10"><img alt="5" height="12" src="assets/5.png" width="12"/></a>
    <code class="k">if</code> <code class="p">(</code><code class="k">this</code> <code class="o">=</code><code class="o">=</code> <code class="n">obj</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">return</code> <code class="kc">true</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="k">if</code> <code class="p">(</code><code class="n">obj</code> <code class="o">=</code><code class="o">=</code> <code class="kc">null</code> <code class="o">|</code><code class="o">|</code> <code class="n">getClass</code><code class="p">(</code><code class="p">)</code> <code class="o">!</code><code class="o">=</code> <code class="n">obj</code><code class="p">.</code><code class="na">getClass</code><code class="p">(</code><code class="p">)</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">return</code> <code class="kc">false</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="n">User</code> <code class="n">other</code> <code class="o">=</code> <code class="p">(</code><code class="n">User</code><code class="p">)</code> <code class="n">obj</code><code class="p">;</code>
    <code class="k">return</code> <code class="n">Objects</code><code class="p">.</code><code class="na">equals</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="na">username</code><code class="p">,</code> <code class="n">other</code><code class="p">.</code><code class="na">username</code><code class="p">)</code>
           <code class="o">&amp;</code><code class="o">&amp;</code> <code class="k">this</code><code class="p">.</code><code class="na">active</code> <code class="o">=</code><code class="o">=</code> <code class="n">other</code><code class="p">.</code><code class="na">active</code>
           <code class="o">&amp;</code><code class="o">&amp;</code> <code class="n">Objects</code><code class="p">.</code><code class="na">equals</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="na">lastLogin</code><code class="p">,</code> <code class="n">other</code><code class="p">.</code><code class="na">lastLogin</code><code class="p">)</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="nd">@Override</code>
  <code class="kd">public</code> <code class="n">String</code> <code class="nf">toString</code><code class="p">(</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_working_with_records_CO1-5" id="co_working_with_records_CO1-11"><img alt="5" height="12" src="assets/5.png" width="12"/></a>
    <code class="k">return</code> <code class="k">new</code> <code class="n">StringBuilder</code><code class="p">(</code><code class="p">)</code><code class="p">.</code><code class="na">append</code><code class="p">(</code><code class="s">"</code><code class="s">User [username=</code><code class="s">"</code><code class="p">)</code>
                              <code class="p">.</code><code class="na">append</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="na">username</code><code class="p">)</code>
                              <code class="p">.</code><code class="na">append</code><code class="p">(</code><code class="s">"</code><code class="s">, active=</code><code class="s">"</code><code class="p">)</code>
                              <code class="p">.</code><code class="na">append</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="na">active</code><code class="p">)</code>
                              <code class="p">.</code><code class="na">append</code><code class="p">(</code><code class="s">"</code><code class="s">, lastLogin=</code><code class="s">"</code><code class="p">)</code>
                              <code class="p">.</code><code class="na">append</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="na">lastLogin</code><code class="p">)</code>
                              <code class="p">.</code><code class="na">append</code><code class="p">(</code><code class="s">"</code><code class="s">]</code><code class="s">"</code><code class="p">)</code>
                              <code class="p">.</code><code class="na">toString</code><code class="p">(</code><code class="p">)</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code></pre></div>
<dl class="calloutlist">
<dt><a class="co" href="#co_working_with_records_CO1-1" id="callout_working_with_records_CO1-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>Constructors aren’t strictly necessary but are added for convenience.
If any constructor with arguments exists, an explicit “empty” constructor should be added, too.</p></dd>
<dt><a class="co" href="#co_working_with_records_CO1-3" id="callout_working_with_records_CO1-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>POJOs usually have getters instead of public fields.</p></dd>
<dt><a class="co" href="#co_working_with_records_CO1-4" id="callout_working_with_records_CO1-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a></dt>
<dd><p>The first variant of the <code>User</code> type is still mutable due to its setter methods.</p></dd>
<dt><a class="co" href="#co_working_with_records_CO1-9" id="callout_working_with_records_CO1-4"><img alt="4" height="12" src="assets/4.png" width="12"/></a></dt>
<dd><p>Both <code>hashCode</code> and <code>equals</code> require dedicated implementations that depend on the actual structure of the type.
Any changes to the type require both methods to adapt.</p></dd>
<dt><a class="co" href="#co_working_with_records_CO1-10" id="callout_working_with_records_CO1-5"><img alt="5" height="12" src="assets/5.png" width="12"/></a></dt>
<dd><p>The <code>toString</code> method is another convenience addition that isn’t explicitly needed.
Just like the previous methods, it has to be updated every time the type changes.</p></dd>
</dl>
<p>Including the empty lines and curly braces, that’s ~75 lines for just holding three data fields.
No wonder one of the most common complaints about Java is its verbosity, and “too much ceremony” to do <em>standard</em> things!</p>
<p>Now, let’s convert it into an immutable POJO.</p>
</div></section>
<section data-pdf-bookmark="From POJO to Immutability" data-type="sect2"><div class="sect2" id="idm45115245800976">
<h2>From POJO to Immutability</h2>
<p>Making the <code>User</code> POJO immutable reduces the required boilerplate slightly because you no longer need any setter methods, as shown in <a data-type="xref" href="#_02-data-structures_records_user-pojo-like_immutable">Example 5-2</a>.</p>
<div data-type="example" id="_02-data-structures_records_user-pojo-like_immutable">
<h5><span class="label">Example 5-2. </span>Simple immutable User type</h5>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">final</code> <code class="kd">class</code> <code class="nc">User</code> <code class="p">{</code>

  <code class="kd">private</code> <code class="kd">final</code> <code class="n">String</code> <code class="n">username</code><code class="p">;</code> <a class="co" href="#callout_working_with_records_CO2-1" id="co_working_with_records_CO2-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>
  <code class="kd">private</code> <code class="kd">final</code> <code class="kt">boolean</code> <code class="n">active</code><code class="p">;</code>
  <code class="kd">private</code> <code class="kd">final</code> <code class="n">LocalDateTime</code> <code class="n">lastLogin</code><code class="p">;</code>

  <code class="kd">public</code> <code class="nf">User</code><code class="p">(</code><code class="n">String</code> <code class="n">username</code><code class="p">,</code>
              <code class="kt">boolean</code> <code class="n">active</code><code class="p">,</code>
              <code class="n">LocalDateTime</code> <code class="n">lastLogin</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_working_with_records_CO2-2" id="co_working_with_records_CO2-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>
    <code class="k">this</code><code class="p">.</code><code class="na">username</code> <code class="o">=</code> <code class="n">username</code><code class="p">;</code>
    <code class="k">this</code><code class="p">.</code><code class="na">active</code> <code class="o">=</code> <code class="n">active</code><code class="p">;</code>
    <code class="k">this</code><code class="p">.</code><code class="na">lastLogin</code> <code class="o">=</code> <code class="n">lastLogin</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="kd">public</code> <code class="n">String</code> <code class="nf">getUsername</code><code class="p">(</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_working_with_records_CO2-3" id="co_working_with_records_CO2-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="na">username</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="kd">public</code> <code class="kt">boolean</code> <code class="nf">isActive</code><code class="p">(</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_working_with_records_CO2-3" id="co_working_with_records_CO2-4"><img alt="3" height="12" src="assets/3.png" width="12"/></a>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="na">active</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="kd">public</code> <code class="n">LocalDateTime</code> <code class="nf">getLastLogin</code><code class="p">(</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_working_with_records_CO2-3" id="co_working_with_records_CO2-5"><img alt="3" height="12" src="assets/3.png" width="12"/></a>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="na">lastLogin</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="nd">@Override</code>
  <code class="kd">public</code> <code class="kt">int</code> <code class="nf">hashCode</code><code class="p">(</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_working_with_records_CO2-4" id="co_working_with_records_CO2-6"><img alt="4" height="12" src="assets/4.png" width="12"/></a>
    <code class="c1">// UNCHANGED</code>
  <code class="p">}</code>

  <code class="nd">@Override</code>
  <code class="kd">public</code> <code class="kt">boolean</code> <code class="nf">equals</code><code class="p">(</code><code class="n">Object</code> <code class="n">obj</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_working_with_records_CO2-4" id="co_working_with_records_CO2-7"><img alt="4" height="12" src="assets/4.png" width="12"/></a>
    <code class="c1">// UNCHANGED</code>
  <code class="p">}</code>

  <code class="nd">@Override</code>
  <code class="kd">public</code> <code class="n">String</code> <code class="nf">toString</code><code class="p">(</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_working_with_records_CO2-4" id="co_working_with_records_CO2-8"><img alt="4" height="12" src="assets/4.png" width="12"/></a>
    <code class="c1">// UNCHANGED</code>
  <code class="p">}</code>
<code class="p">}</code></pre></div>
<dl class="calloutlist">
<dt><a class="co" href="#co_working_with_records_CO2-1" id="callout_working_with_records_CO2-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>Without “setters”, the fields can be declared <code>final</code>.</p></dd>
<dt><a class="co" href="#co_working_with_records_CO2-2" id="callout_working_with_records_CO2-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>Only a full “pass-through” constructor is possible because the fields must be set on object creation.</p></dd>
<dt><a class="co" href="#co_working_with_records_CO2-3" id="callout_working_with_records_CO2-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a></dt>
<dd><p>The “getters” remain unchanged from the mutable variant.</p></dd>
<dt><a class="co" href="#co_working_with_records_CO2-6" id="callout_working_with_records_CO2-4"><img alt="4" height="12" src="assets/4.png" width="12"/></a></dt>
<dd><p>The supporting methods are also unchanged compared to the previous implementation.</p></dd>
</dl>
<p>By making the type immutable yourself, only the code of the setters and the empty constructor could be removed; everything else is still there.
That’s still quite a lot of code for holding three fields with not much additional functionality.
Of course, we could remove more of the “ceremony” and use a simple class with three <code>public final</code> fields and a constructor.
Depending on your requirements, that might be “just enough.”
The additional functionality, however, like equality comparison, and a correct <code>hashCode</code> so it can be used in a <code>Set</code> or <code>HashMap</code>, or a sensible <code>toString</code> output, are all desirable features.</p>
</div></section>
<section data-pdf-bookmark="From POJO to Record" data-type="sect2"><div class="sect2" id="idm45115245528160">
<h2>From POJO to Record</h2>
<p>Finally, let’s take a look at a more general, less ceremonial, but still feature-rich solution using a Record instead:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">record</code> <code class="nc">User</code><code class="p">(</code><code class="n">String</code> <code class="n">username</code><code class="p">,</code>
                   <code class="kt">boolean</code> <code class="n">active</code><code class="p">,</code>
                   <code class="n">LocalDateTime</code> <code class="n">lastLogin</code><code class="p">)</code> <code class="p">{</code>
  <code class="c1">// NO BODY</code>
<code class="p">}</code></pre>
<p>That’s it.</p>
<p>The <code>User</code> Record has the same features as the immutable POJO.
How it does so much with so little code will be explained in detail in the upcoming sections.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Records to the Rescue" data-type="sect1"><div class="sect1" id="idm45115245371904">
<h1>Records to the Rescue</h1>
<p>Records are a way to define plain <em>data aggregator types</em> that access their data components by name in the vein of <em>nominal tuples</em>.
Like nominal tuples, Records aggregate an ordered sequence of values and provide access via names instead of indices.
Their data is shallowly immutable and transparently accessible.
The typical boilerplate of other data classes is significantly reduced by generating accessors and data-driven methods like <code>equals</code> and <code>hashCode</code>.
Even though the final version of <a href="https://openjdk.java.net/jeps/395">JEP 395</a> explicitly states that “war on boilerplate” is a non-goal, it’s still a happy coincidence many developers will appreciate.</p>
<p>Being “plain” data aggregator types, there are some missing features compared to other options.
This chapter will cover each missing feature and how to mitigate them, transforming Records into a more flexible solution for your data aggregation needs.</p>
<p>As seen in the previous section, Records use a new keyword — <code>record</code> — to delimit them from other classes and enums.
The data components are declared like a constructor or method arguments directly after the Record’s name:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">record</code> <code class="nc">User</code><code class="p">(</code><code class="n">String</code> <code class="n">username</code><code class="p">,</code>
                   <code class="kt">boolean</code> <code class="n">active</code><code class="p">,</code>
                   <code class="n">LocalDateTime</code> <code class="n">lastLogin</code><code class="p">)</code> <code class="p">{</code>
  <code class="c1">// NO BODY</code>
<code class="p">}</code></pre>
<p>The general syntax for Records breaks down into two parts:
a <em>header</em> defining the same properties as other types, plus its components and an optional <em>body</em> to support additional constructors and methods.</p>
<pre data-type="programlisting">// HEADER
[visibility] record [Name][&lt;optional generic types&gt;]([data components]) {
  // BODY
}</pre>
<p>The header is similar to a <code>class</code> or <code>interface</code> header and consists of multiple parts:</p>
<dl>
<dt>Visibility</dt>
<dd>
<p>Like a <code>class</code>, <code>enum</code>, or <code>interface</code> definition, a Record supports Java’s visibility keywords (<code>public</code>, <code>private</code>, <code>protected</code>).</p>
</dd>
<dt>The record keyword</dt>
<dd>
<p>The keyword <code>record</code> distinguishes the header from the other type declarations <code>class</code>, <code>enum</code>, and <code>interface</code>.</p>
</dd>
<dt>Name</dt>
<dd>
<p>Naming rules are identical to any other identifier, as defined in the <em>Java Language Specification</em>⁠<sup><a data-type="noteref" href="ch05.xhtml#idm45115245303760" id="idm45115245303760-marker">2</a></sup>.</p>
</dd>
<dt>Generic types</dt>
<dd>
<p>Generic types are supported as with other type declarations in Java.</p>
</dd>
<dt>Data components</dt>
<dd>
<p>The name is followed by a pair of parentheses containing the components of the Record.
Each one translates into a <code>private final</code> field and a <code>public</code> accessor method behind the scenes.
The components list also represents the constructor of the Record.</p>
</dd>
<dt>Body</dt>
<dd>
<p>A typical Java body, like any other <code>class</code> or <code>interface</code>.</p>
</dd>
</dl>
<p>An effectively single line of code will be translated by the compiler to a class similar to <a data-type="xref" href="#_02-data-structures_records_user-pojo-like_immutable">Example 5-2</a> from the previous section.
It extends <code>java.lang.Record</code> explicitly rather than <code>java.lang.Object</code> implicitly, just like enums do with <code>java.lang.Enum</code>.</p>
<section data-pdf-bookmark="Behind The Scenes" data-type="sect2"><div class="sect2" id="idm45115245294768">
<h2>Behind The Scenes</h2>
<p>The generated class behind any Record gives you quite a lot of functionality without writing any additional code.
It’s time to take a deeper look at what’s actually happening behind-the-scenes.</p>
<p>The JDK includes the command <code>javap</code>, which disassembles <code>.class</code> files and allows you to see the Java corresponding Java code for the bytecode.
This way, it’s easy to compare the actual difference between the POJO and Record version of the <code>User</code> type from <a data-type="xref" href="#_02-records_data-aggregation-types">“Data Aggregation Types”</a>.
The combined and cleaned-up output for both variants is shown in <a data-type="xref" href="#_02-data-structures_records_user-javap">Example 5-3</a>.</p>
<div data-type="example" id="_02-data-structures_records_user-javap">
<h5><span class="label">Example 5-3. </span>Disassembled User.class POJO versus Record</h5>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// IMMUTABLE POJO</code>

<code class="kd">public</code> <code class="kd">final</code> <code class="kd">class</code> <code class="nc">User</code> <code class="p">{</code>
  <code class="kd">public</code> <code class="nf">User</code><code class="p">(</code><code class="n">java</code><code class="p">.</code><code class="na">lang</code><code class="p">.</code><code class="na">String</code><code class="p">,</code> <code class="kt">boolean</code><code class="p">,</code> <code class="n">java</code><code class="p">.</code><code class="na">time</code><code class="p">.</code><code class="na">LocalDateTime</code><code class="p">);</code>
  <code class="kd">public</code> <code class="n">java</code><code class="p">.</code><code class="na">lang</code><code class="p">.</code><code class="na">String</code> <code class="nf">getUsername</code><code class="p">();</code>
  <code class="kd">public</code> <code class="kt">boolean</code> <code class="nf">isActive</code><code class="p">();</code>
  <code class="kd">public</code> <code class="n">java</code><code class="p">.</code><code class="na">time</code><code class="p">.</code><code class="na">LocalDateTime</code> <code class="nf">getLastLogin</code><code class="p">();</code>

  <code class="kd">public</code> <code class="kt">int</code> <code class="nf">hashCode</code><code class="p">();</code>
  <code class="kd">public</code> <code class="kt">boolean</code> <code class="nf">equals</code><code class="p">(</code><code class="n">java</code><code class="p">.</code><code class="na">lang</code><code class="p">.</code><code class="na">Object</code><code class="p">);</code>
  <code class="kd">public</code> <code class="n">java</code><code class="p">.</code><code class="na">lang</code><code class="p">.</code><code class="na">String</code> <code class="nf">toString</code><code class="p">();</code>
<code class="p">}</code>


<code class="c1">// RECORD</code>

<code class="kd">public</code> <code class="kd">final</code> <code class="kd">class</code> <code class="nc">User</code> <code class="kd">extends</code> <code class="n">java</code><code class="p">.</code><code class="na">lang</code><code class="p">.</code><code class="na">Record</code> <code class="p">{</code>
  <code class="kd">public</code> <code class="nf">User</code><code class="p">(</code><code class="n">java</code><code class="p">.</code><code class="na">lang</code><code class="p">.</code><code class="na">String</code><code class="p">,</code> <code class="kt">boolean</code><code class="p">,</code> <code class="n">java</code><code class="p">.</code><code class="na">time</code><code class="p">.</code><code class="na">LocalDateTime</code><code class="p">);</code>
  <code class="kd">public</code> <code class="n">java</code><code class="p">.</code><code class="na">lang</code><code class="p">.</code><code class="na">String</code> <code class="nf">username</code><code class="p">();</code>
  <code class="kd">public</code> <code class="kt">boolean</code> <code class="nf">active</code><code class="p">();</code>
  <code class="kd">public</code> <code class="n">java</code><code class="p">.</code><code class="na">time</code><code class="p">.</code><code class="na">LocalDateTime</code> <code class="nf">lastLogin</code><code class="p">();</code>

  <code class="kd">public</code> <code class="kd">final</code> <code class="kt">int</code> <code class="nf">hashCode</code><code class="p">();</code>
  <code class="kd">public</code> <code class="kd">final</code> <code class="kt">boolean</code> <code class="nf">equals</code><code class="p">(</code><code class="n">java</code><code class="p">.</code><code class="na">lang</code><code class="p">.</code><code class="na">Object</code><code class="p">);</code>
  <code class="kd">public</code> <code class="kd">final</code> <code class="n">java</code><code class="p">.</code><code class="na">lang</code><code class="p">.</code><code class="na">String</code> <code class="nf">toString</code><code class="p">();</code>
<code class="p">}</code></pre></div>
<p>As you can see, the resulting classes are identical functionality-wise, only the naming of the accessor methods differ.
But where did all those methods come from?
Well, that’s the “magic” of Records, giving you a full-fledged data aggregation type without writing more code as absolutely needed.</p>
</div></section>
<section data-pdf-bookmark="Record Features" data-type="sect2"><div class="sect2" id="idm45115245007440">
<h2>Record Features</h2>
<p>Records are transparent data aggregators with specific guaranteed properties and well-defined behavior by automagically<sup><a data-type="noteref" href="ch05.xhtml#idm45115245005648" id="idm45115245005648-marker">3</a></sup> providing functionality without needing to repeatedly write the following trivial boilerplate implementations:</p>
<ul>
<li>
<p>Component accessors</p>
</li>
<li>
<p>Three types of constructors</p>
</li>
<li>
<p>Object identity and description methods</p>
</li>
</ul>
<p>That’s a lot of functionality without requiring any additional code besides the Record declaration.
Any missing pieces can be done by augmenting or overriding these features as necessary.</p>
<p>Let’s check out Record’s automatic features and how other typical Java features, like generics, annotations, and reflection, fit in.</p>
<section data-pdf-bookmark="Component Accessors" data-type="sect3"><div class="sect3" id="idm45115245062752">
<h3>Component Accessors</h3>
<p>All Record components are stored in <code>private</code> fields.
Inside a Record, its fields are directly accessible.
“From the outside,” you need to access them through the generated <code>public</code> accessor methods.
The accessor method names correspond to their component name without the typical “getter” prefix <code>get</code>, as shown in the following code example:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">record</code> <code class="nc">User</code><code class="p">(</code><code class="n">String</code> <code class="n">username</code><code class="p">,</code>
                   <code class="kt">boolean</code> <code class="n">active</code><code class="p">,</code>
                   <code class="n">LocalDateTime</code> <code class="n">lastLogin</code><code class="p">)</code> <code class="p">{</code>
  <code class="c1">// NO BODY</code>
<code class="p">}</code>

<code class="kd">var</code> <code class="n">user</code> <code class="o">=</code> <code class="k">new</code> <code class="n">User</code><code class="p">(</code><code class="s">"ben"</code><code class="p">,</code> <code class="kc">true</code><code class="p">,</code> <code class="n">LocalDateTime</code><code class="p">.</code><code class="na">now</code><code class="p">());</code>

<code class="kd">var</code> <code class="n">username</code> <code class="o">=</code> <code class="n">user</code><code class="p">.</code><code class="na">username</code><code class="p">();</code></pre>
<p>The accessor methods return the corresponding field’s value as-is.
Though you can override them, as shown in the following code, I wouldn’t recommend it.</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">record</code> <code class="nc">User</code><code class="p">(</code><code class="n">String</code> <code class="n">username</code><code class="p">,</code>
                   <code class="kt">boolean</code> <code class="n">active</code><code class="p">,</code>
                   <code class="n">LocalDateTime</code> <code class="n">lastLogin</code><code class="p">)</code> <code class="p">{</code>

  <code class="nd">@Override</code>
  <code class="kd">public</code> <code class="n">String</code> <code class="nf">username</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="na">username</code> <code class="o">==</code> <code class="kc">null</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">return</code> <code class="s">"n/a"</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="na">username</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kd">var</code> <code class="n">user</code> <code class="o">=</code> <code class="k">new</code> <code class="n">User</code><code class="p">(</code><code class="kc">null</code><code class="p">,</code> <code class="kc">true</code><code class="p">,</code> <code class="n">LocalDateTime</code><code class="p">.</code><code class="na">now</code><code class="p">());</code>

<code class="kd">var</code> <code class="n">username</code> <code class="o">=</code> <code class="n">user</code><code class="p">.</code><code class="na">username</code><code class="p">();</code>
<code class="c1">// =&gt; n/a</code></pre>
<p>Records are supposed to be <em>immutable</em> data holders, so making decisions while accessing its data could be considered a code smell.
The creation of a Record defines its data, and that’s where any validation or other logic should affect the data, as you will learn in the next section.</p>
</div></section>
<section data-pdf-bookmark="Canonical, Compact, and Custom Constructors" data-type="sect3"><div class="sect3" id="_01-immutables_records_custom-compact-constructor">
<h3>Canonical, Compact, and Custom Constructors</h3>
<p>A constructor identical to the Record’s components definition is automatically available, called the <em>canonical</em> constructor.
The Record’s components are assigned to the corresponding fields “as-is.”
Like component accessors, the canonical constructor is overridable to validate input, like <code>null</code>-checks, or even manipulate data if necessary:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">record</code> <code class="nc">User</code><code class="p">(</code><code class="n">String</code> <code class="n">username</code><code class="p">,</code>
                   <code class="kt">boolean</code> <code class="n">active</code><code class="p">,</code>
                   <code class="n">LocalDateTime</code> <code class="n">lastLogin</code><code class="p">)</code> <code class="p">{</code>

  <code class="kd">public</code> <code class="nf">User</code><code class="p">(</code><code class="n">String</code> <code class="n">username</code><code class="p">,</code>
              <code class="kt">boolean</code> <code class="n">active</code><code class="p">,</code>
              <code class="n">LocalDateTime</code> <code class="n">lastLogin</code><code class="p">)</code> <code class="p">{</code>

    <code class="n">Objects</code><code class="p">.</code><code class="na">requireNonNull</code><code class="p">(</code><code class="n">username</code><code class="p">);</code>
    <code class="n">Objects</code><code class="p">.</code><code class="na">requireNonNull</code><code class="p">(</code><code class="n">lastLogin</code><code class="p">);</code>

    <code class="k">this</code><code class="p">.</code><code class="na">username</code> <code class="o">=</code> <code class="n">username</code><code class="p">;</code>
    <code class="k">this</code><code class="p">.</code><code class="na">active</code> <code class="o">=</code> <code class="n">active</code><code class="p">;</code>
    <code class="k">this</code><code class="p">.</code><code class="na">lastLogin</code> <code class="o">=</code> <code class="n">lastLogin</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code></pre>
<p>That’s a lot of additional lines for two actual <code>null</code>-checks, including redeclaration of the constructor signature and assigning the components to the invisible fields.</p>
<p>Thankfully, a specialized <em>compact</em> form, shown in the following code example, is available, and it doesn’t force you to repeat any boilerplate if you don’t need it.</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">record</code> <code class="nc">User</code><code class="p">(</code><code class="n">String</code> <code class="n">username</code><code class="p">,</code>
                   <code class="kt">boolean</code> <code class="n">active</code><code class="p">,</code>
                   <code class="n">LocalDateTime</code> <code class="n">lastLogin</code><code class="p">)</code> <code class="p">{</code>

  <code class="kd">public</code> <code class="n">User</code> <code class="p">{</code> <a class="co" href="#callout_working_with_records_CO3-1" id="co_working_with_records_CO3-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>

    <code class="n">Objects</code><code class="p">.</code><code class="na">requireNonNull</code><code class="p">(</code><code class="n">username</code><code class="p">)</code><code class="p">;</code>
    <code class="n">Objects</code><code class="p">.</code><code class="na">requireNonNull</code><code class="p">(</code><code class="n">lastLogin</code><code class="p">)</code><code class="p">;</code>

    <code class="n">username</code> <code class="o">=</code> <code class="n">username</code><code class="p">.</code><code class="na">toLowerCase</code><code class="p">(</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_working_with_records_CO3-2" id="co_working_with_records_CO3-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>

    <a class="co" href="#callout_working_with_records_CO3-3" id="co_working_with_records_CO3-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a>
  <code class="p">}</code>
<code class="p">}</code></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_working_with_records_CO3-1" id="callout_working_with_records_CO3-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>The constructor omits all arguments, including the parentheses.</p></dd>
<dt><a class="co" href="#co_working_with_records_CO3-2" id="callout_working_with_records_CO3-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>Field assignments aren’t allowed in the compact canonical constructor, but you can customize or normalize data before it’s assigned.</p></dd>
<dt><a class="co" href="#co_working_with_records_CO3-3" id="callout_working_with_records_CO3-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a></dt>
<dd><p>The components will be assigned to their respective fields automatically.</p></dd>
</dl>
<p>At first, the syntax might look unusual because it omits all arguments, including the parentheses.
This way, though, it’s clearly distinguishable from an argument-less constructor.</p>
<p>The compact constructor is the perfect place to put any validation, as I will show you in <a data-type="xref" href="#_02-records_validation">“Record Validation and Data Scrubbing”</a>.</p>
<p>Like with classes, you can declare additional constructors, but any custom constructor must start with an explicit invocation of the canonical constructor as its first statement.
That’s quite a restrictive requirement compared to classes, which it is.
Still, this requirement serves an essential feature I’m going to discuss in <a data-type="xref" href="#_02-records_default-values">“Component Default Values and Convenience Constructors”</a>.</p>
</div></section>
<section data-pdf-bookmark="Object Identity and Description" data-type="sect3"><div class="sect3" id="idm45115244856512">
<h3>Object Identity and Description</h3>
<p>Records provide a “standard” implementation for the object identity methods <code>int hashCode()</code> and <code>boolean equals(Object)</code> based on data equality.
Without an explicit implementation of the two object identity methods, you don’t have to worry about updating your code if the Record’s component change.
Two instances of a Record type are considered equal if the data of their components are equal.</p>
<p>The object description method <code>String toString()</code> is auto-generated from the components, too, giving you a sensible default output, for example:</p>
<pre data-type="programlisting">User[username=ben, active=true, lastLogin=2023-01-11T13:32:16.727249646]</pre>
<p>The object identity and description methods are overridable, too, like component accessors and constructors.</p>
</div></section>
<section data-pdf-bookmark="Generics" data-type="sect3"><div class="sect3" id="idm45115244507088">
<h3>Generics</h3>
<p>Records also support generics, which follow the “usual” rules:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">record</code> <code class="nc">Container</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="p">(</code><code class="n">T</code> <code class="n">content</code><code class="p">,</code>
                           <code class="n">String</code> <code class="n">identifier</code><code class="p">)</code> <code class="p">{</code>
  <code class="c1">// NO BODY</code>
<code class="p">}</code>

<code class="n">Container</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">stringContainer</code> <code class="o">=</code> <code class="k">new</code> <code class="n">Container</code><code class="o">&lt;&gt;</code><code class="p">(</code><code class="s">"hello, String!"</code><code class="p">,</code>
                                                    <code class="s">"a String container"</code><code class="p">);</code>

<code class="n">String</code> <code class="n">content</code> <code class="o">=</code> <code class="n">stringContainer</code><code class="p">.</code><code class="na">content</code><code class="p">();</code></pre>
<p>Personally, I would advise against overusing generic Records.
Using more specific Records that more closely match the domain model they represent gives you more expressiveness and reduces accidental misuse.</p>
</div></section>
<section data-pdf-bookmark="Annotations" data-type="sect3"><div class="sect3" id="idm45115244438080">
<h3>Annotations</h3>
<p>Annotations behave a little differently than you might expect if used on a Record’s components:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">record</code> <code class="nc">User</code><code class="p">(</code><code class="nd">@NonNull</code> <code class="n">String</code> <code class="n">username</code><code class="p">,</code>
                   <code class="kt">boolean</code> <code class="n">active</code><code class="p">,</code>
                   <code class="n">LocalDateTime</code> <code class="n">lastLogin</code><code class="p">)</code> <code class="p">{</code>
  <code class="c1">// NO BODY</code>
<code class="p">}</code></pre>
<p>At first glance, <code>username</code> looks like a parameter, so a sensible conclusion would be that only annotations with <code>ElementType.PARAMETER</code> should be possible<sup><a data-type="noteref" href="ch05.xhtml#idm45115244379264" id="idm45115244379264-marker">4</a></sup>.
But with Records and their automagically generated fields and component accessors, some special considerations must be made.
To support annotating these features, any annotations with the targets <code>FIELD</code>, <code>PARAMETER</code>, or <code>METHOD</code>, are propagated to the corresponding locations if applied to a component.</p>
<p>In addition to the existing targets, the new target <code>ElementType.RECORD_COMPONENT</code> was introduced for more fine-grained annotation control in Records.</p>
</div></section>
<section data-pdf-bookmark="Reflection" data-type="sect3"><div class="sect3" id="idm45115244348800">
<h3>Reflection</h3>
<p>To complement Java’s reflection capabilities, Java 16 added the <code>getRecordComponents</code> method to <code>java.lang.Class</code>..
In the case of a Record-based type, the call gives you an array of <code>java.lang.reflect.RecordComponent</code> objects, or <code>null</code> for any other type of <code>Class</code>.
The components are returned in the same order that they are declared in the record header, allowing you to look up the canonical constructor via <code>getDeclaredConstructor()</code> on a Record’s class.</p>
<p>You will find some reflection-based examples in the book’s <a href="https://github.com/benweidig/a-functional-approach-to-java">code repository</a>.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Missing Features" data-type="sect2"><div class="sect2" id="idm45115245006848">
<h2>Missing Features</h2>
<p>Records are precisely what they are supposed to be: <em>plain, transparent, shallowly immutable data-aggregators</em>.
They provide a plethora of features without writing any line of code except their definition.
Compared to other available data aggregators, they lack some features you might be used to, such as:</p>
<ul>
<li>
<p>Additional State</p>
</li>
<li>
<p>Inheritance</p>
</li>
<li>
<p>(Simple) default values</p>
</li>
<li>
<p>Step-by-step creation</p>
</li>
</ul>
<p>This section shows you what features are “missing in action” and how to mitigate them if possible.</p>
<section data-pdf-bookmark="Additional State" data-type="sect3"><div class="sect3" id="idm45115244337184">
<h3>Additional State</h3>
<p>Allowing any additional opaque state is an obvious omission from records.
They are supposed to be <em>data-aggregators</em> representing a transparent state.
That’s why any additional field added to its body results in a compiler error.</p>
<div data-type="tip"><h6>Tip</h6>
<p>If you require more fields than what’s possible with a Record’s components alone, Records might not be the data structure your looking for.</p>
</div>
<p>For some scenarios at least, you could add <em>derived</em> state that’s based on the existing components, by adding methods to the Records:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">record</code> <code class="nc">User</code><code class="p">(</code><code class="n">String</code> <code class="n">username</code><code class="p">,</code>
                   <code class="kt">boolean</code> <code class="n">active</code><code class="p">,</code>
                   <code class="n">LocalDateTime</code> <code class="n">lastLogin</code><code class="p">)</code> <code class="p">{</code>

  <code class="kd">public</code> <code class="kt">boolean</code> <code class="nf">hasLoggedInAtLeastOnce</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="na">lastLogin</code> <code class="o">!=</code> <code class="kc">null</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code></pre>
<p>Methods can be added because they don’t introduce additional state like a field.
They have access to <code>private</code> fields, guaranteeing verbatim data access even if the component accessor is overridden.
Which to choose — field or accessor — depends on how you design your Record and your personal preference.</p>
</div></section>
<section data-pdf-bookmark="Inheritance" data-type="sect3"><div class="sect3" id="idm45115244306880">
<h3>Inheritance</h3>
<p>Records are <code>final</code> types that already extend <code>java.lang.Record</code> behind-the-scenes, as previously seen in <a data-type="xref" href="#_02-data-structures_records_user-javap">Example 5-3</a>.
Because Java doesn’t allow inheriting more than one type, Records can’t use inheritance.
That doesn’t mean they can’t implement any interfaces, though.
With interfaces, you can define Record templates and share common functionality with <code>default</code> methods.</p>
<p><a data-type="xref" href="#_02-data-structures_records_inheritance">Example 5-4</a> shows how to create Records for multiple shapes with the common concept of an origin and a surface area.</p>
<div data-type="example" id="_02-data-structures_records_inheritance">
<h5><span class="label">Example 5-4. </span>Using interfaces with Records as templates</h5>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">interface</code> <code class="nc">Origin</code> <code class="p">{</code>

  <code class="kt">int</code> <code class="nf">x</code><code class="p">(</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_working_with_records_CO4-1" id="co_working_with_records_CO4-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>
  <code class="kt">int</code> <code class="nf">y</code><code class="p">(</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_working_with_records_CO4-1" id="co_working_with_records_CO4-2"><img alt="1" height="12" src="assets/1.png" width="12"/></a>

  <code class="k">default</code> <code class="n">String</code> <code class="nf">origin</code><code class="p">(</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_working_with_records_CO4-2" id="co_working_with_records_CO4-3"><img alt="2" height="12" src="assets/2.png" width="12"/></a>
    <code class="k">return</code> <code class="n">String</code><code class="p">.</code><code class="na">format</code><code class="p">(</code><code class="s">"</code><code class="s">(%d/%d)</code><code class="s">"</code><code class="p">,</code> <code class="n">x</code><code class="p">(</code><code class="p">)</code><code class="p">,</code> <code class="n">y</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kd">public</code> <code class="kd">interface</code> <code class="nc">Area</code> <code class="p">{</code>

  <code class="kt">float</code> <code class="nf">area</code><code class="p">(</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_working_with_records_CO4-3" id="co_working_with_records_CO4-4"><img alt="3" height="12" src="assets/3.png" width="12"/></a>
<code class="p">}</code>


<code class="c1">// DIFFERENT RECORDS IMPLEMENTING INTERFACES</code>

<code class="kd">public</code> <code class="kd">record</code> <code class="nc">Point</code><code class="p">(</code><code class="kt">int</code> <code class="n">x</code><code class="p">,</code> <code class="kt">int</code> <code class="n">y</code><code class="p">)</code> <code class="kd">implements</code> <code class="n">Origin</code> <code class="p">{</code>
  <code class="c1">// NO BODY</code>
<code class="p">}</code>

<code class="kd">public</code> <code class="kd">record</code> <code class="nc">Rectangle</code><code class="p">(</code><code class="kt">int</code> <code class="n">x</code><code class="p">,</code> <code class="kt">int</code> <code class="n">y</code><code class="p">,</code> <code class="kt">int</code> <code class="n">width</code><code class="p">,</code> <code class="kt">int</code> <code class="n">height</code><code class="p">)</code>
  <code class="kd">implements</code> <code class="n">Origin</code><code class="p">,</code> <code class="n">Area</code> <code class="p">{</code>

  <code class="kd">public</code> <code class="kt">float</code> <code class="nf">area</code><code class="p">(</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_working_with_records_CO4-3" id="co_working_with_records_CO4-5"><img alt="3" height="12" src="assets/3.png" width="12"/></a>
    <code class="k">return</code> <code class="p">(</code><code class="kt">float</code><code class="p">)</code> <code class="p">(</code><code class="n">width</code><code class="p">(</code><code class="p">)</code> <code class="o">*</code> <code class="n">height</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kd">public</code> <code class="kd">record</code> <code class="nc">Circle</code><code class="p">(</code><code class="kt">int</code> <code class="n">x</code><code class="p">,</code> <code class="kt">int</code> <code class="n">y</code><code class="p">,</code> <code class="kt">int</code> <code class="n">radius</code><code class="p">)</code>
  <code class="kd">implements</code> <code class="n">Origin</code><code class="p">,</code> <code class="n">Area</code> <code class="p">{</code>

  <code class="kd">public</code> <code class="kt">float</code> <code class="nf">area</code><code class="p">(</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_working_with_records_CO4-3" id="co_working_with_records_CO4-6"><img alt="3" height="12" src="assets/3.png" width="12"/></a>
    <code class="k">return</code> <code class="p">(</code><code class="kt">float</code><code class="p">)</code> <code class="n">Math</code><code class="p">.</code><code class="na">PI</code> <code class="o">*</code> <code class="n">radius</code><code class="p">(</code><code class="p">)</code> <code class="o">*</code> <code class="n">radius</code><code class="p">(</code><code class="p">)</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code></pre></div>
<dl class="calloutlist">
<dt><a class="co" href="#co_working_with_records_CO4-1" id="callout_working_with_records_CO4-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>The interface defines the components of an implementing record as simple methods with the correct names</p></dd>
<dt><a class="co" href="#co_working_with_records_CO4-3" id="callout_working_with_records_CO4-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>Shared functionality is added with <code>default</code> methods.</p></dd>
<dt><a class="co" href="#co_working_with_records_CO4-4" id="callout_working_with_records_CO4-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a></dt>
<dd><p>Method signatures in interfaces must not interfere with any implementing record type.</p></dd>
</dl>
<p>Sharing behavior with interfaces and <code>default</code> methods is a straightforward approach, as long as all implementees share the interface contract.
Interfaces can provide a few left-out pieces of the missing inheritance, and it might be tempting to create intricate hierarchies and interdependencies between records.
But structuring your record types this way will create cohesion between them that’s not in the original spirit of Records to be simple data aggregators defined by their state.
The example is over-engineered to illustrate the possibilities of multiple interfaces better.
In the real world, you would most likely make <code>Origin</code> a Record, too, and use composition and additional constructors to achieve the same functionality.</p>
</div></section>
<section data-pdf-bookmark="Component Default Values and Convenience Constructors" data-type="sect3"><div class="sect3" id="_02-records_default-values">
<h3>Component Default Values and Convenience Constructors</h3>
<p>Unlike many other languages, Java doesn’t support default values for any constructor or method arguments.
Records only provide their canonical constructor with all components automatically, which can become unwieldy, especially in the case of composed data structures:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">record</code> <code class="nc">Origin</code><code class="p">(</code><code class="kt">int</code> <code class="n">x</code><code class="p">,</code> <code class="kt">int</code> <code class="n">y</code><code class="p">)</code> <code class="p">{</code>
  <code class="c1">// NO BODY</code>
<code class="p">}</code>


<code class="kd">public</code> <code class="kd">record</code> <code class="nc">Rectangle</code><code class="p">(</code><code class="n">Origin</code> <code class="n">origin</code><code class="p">,</code> <code class="kt">int</code> <code class="n">width</code><code class="p">,</code> <code class="kt">int</code> <code class="n">height</code><code class="p">)</code> <code class="p">{</code>
  <code class="c1">// NO BODY</code>
<code class="p">}</code>

<code class="kd">var</code> <code class="n">rectangle</code> <code class="o">=</code> <code class="k">new</code> <code class="n">Rectangle</code><code class="p">(</code><code class="k">new</code> <code class="n">Origin</code><code class="p">(</code><code class="mi">23</code><code class="p">,</code> <code class="mi">42</code><code class="p">),</code> <code class="mi">300</code><code class="p">,</code> <code class="mi">400</code><code class="p">);</code></pre>
<p>Additional constructors give you an easy way to have sensible default values:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">record</code> <code class="nc">Origin</code><code class="p">(</code><code class="kt">int</code> <code class="n">x</code><code class="p">,</code> <code class="kt">int</code> <code class="n">y</code><code class="p">)</code> <code class="p">{</code>

  <code class="kd">public</code> <code class="nf">Origin</code><code class="p">(</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">)</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kd">public</code> <code class="kd">record</code> <code class="nc">Rectangle</code><code class="p">(</code><code class="n">Origin</code> <code class="n">origin</code><code class="p">,</code> <code class="kt">int</code> <code class="n">width</code><code class="p">,</code> <code class="kt">int</code> <code class="n">height</code><code class="p">)</code> <code class="p">{</code>

  <code class="kd">public</code> <code class="nf">Rectangle</code><code class="p">(</code><code class="kt">int</code> <code class="n">x</code><code class="p">,</code> <code class="kt">int</code> <code class="n">y</code><code class="p">,</code> <code class="kt">int</code> <code class="n">width</code><code class="p">,</code> <code class="kt">int</code> <code class="n">height</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_working_with_records_CO5-1" id="co_working_with_records_CO5-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>
    <code class="k">this</code><code class="p">(</code><code class="k">new</code> <code class="n">Origin</code><code class="p">(</code><code class="n">x</code><code class="p">,</code> <code class="n">y</code><code class="p">)</code><code class="p">,</code> <code class="n">width</code><code class="p">,</code> <code class="n">height</code><code class="p">)</code><code class="p">;</code>

  <code class="p">}</code>

  <code class="kd">public</code> <code class="nf">Rectangle</code><code class="p">(</code><code class="kt">int</code> <code class="n">width</code><code class="p">,</code> <code class="kt">int</code> <code class="n">height</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_working_with_records_CO5-2" id="co_working_with_records_CO5-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>
    <code class="k">this</code><code class="p">(</code><code class="k">new</code> <code class="n">Origin</code><code class="p">(</code><code class="p">)</code><code class="p">,</code> <code class="n">width</code><code class="p">,</code> <code class="n">height</code><code class="p">)</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="c1">// ...</code>
<code class="p">}</code>

<code class="kd">var</code> <code class="n">rectangle</code> <code class="o">=</code> <code class="k">new</code> <code class="n">Rectangle</code><code class="p">(</code><code class="mi">23</code><code class="p">,</code> <code class="mi">42</code><code class="p">,</code> <code class="mi">300</code><code class="p">,</code> <code class="mi">400</code><code class="p">)</code><code class="p">;</code>
<code class="c1">// =&gt; Rectangle[origin=Origin[x=23, y=42], width=300, height=400]</code></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_working_with_records_CO5-1" id="callout_working_with_records_CO5-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>The first additional constructor mimics the components of <code>Origin</code> to provide a more convenient way to create a <code>Rectangle</code>.</p></dd>
<dt><a class="co" href="#co_working_with_records_CO5-2" id="callout_working_with_records_CO5-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>The second one is a convenience constructor by removing the necessity of providing an <code>Origin</code>.</p></dd>
</dl>
<p>Due to Java’s naming semantics, not all combinations for default values might be possible, like <code>Rectangle(int x, float width, float height)</code> has an identical signature to <code>Rectangle(int y, float width, float height)</code>.
In this case, using <code>static</code> factory methods allows you to create any combination you require:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">record</code> <code class="nc">Rectangle</code><code class="p">(</code><code class="n">Origin</code> <code class="n">origin</code><code class="p">,</code> <code class="kt">int</code> <code class="n">width</code><code class="p">,</code> <code class="kt">int</code> <code class="n">height</code><code class="p">)</code> <code class="p">{</code>

  <code class="kd">public</code> <code class="kd">static</code> <code class="n">Rectangle</code> <code class="nf">atX</code><code class="p">(</code><code class="kt">int</code> <code class="n">x</code><code class="p">,</code> <code class="kt">int</code> <code class="n">width</code><code class="p">,</code> <code class="kt">int</code> <code class="n">height</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">new</code> <code class="n">Rectangle</code><code class="p">(</code><code class="n">x</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="n">width</code><code class="p">,</code> <code class="n">height</code><code class="p">);</code>
  <code class="p">}</code>

  <code class="kd">public</code> <code class="kd">static</code> <code class="n">Rectangle</code> <code class="nf">atY</code><code class="p">(</code><code class="kt">int</code> <code class="n">y</code><code class="p">,</code> <code class="kt">int</code> <code class="n">width</code><code class="p">,</code> <code class="kt">int</code> <code class="n">height</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">new</code> <code class="n">Rectangle</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="n">y</code><code class="p">,</code> <code class="n">width</code><code class="p">,</code> <code class="n">height</code><code class="p">);</code>
  <code class="p">}</code>

  <code class="c1">// ...</code>
<code class="p">}</code>

<code class="kd">var</code> <code class="n">xOnlyRectangle</code> <code class="o">=</code> <code class="n">Rectangle</code><code class="p">.</code><code class="na">atX</code><code class="p">(</code><code class="mi">23</code><code class="p">,</code> <code class="mi">300</code><code class="p">,</code> <code class="mi">400</code><code class="p">);</code>
<code class="c1">// =&gt; Rectangle[origin=Origin[x=23, y=0], width=300, height=400]</code></pre>
<p>Using <code>static</code> Factory methods is a more expressive alternative to custom constructors and the only resort with overlapping signatures.</p>
<p>In the case of argument-less constructors, a constant makes more sense:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">record</code> <code class="nc">Origin</code><code class="p">(</code><code class="kt">int</code> <code class="n">x</code><code class="p">,</code> <code class="kt">int</code> <code class="n">y</code><code class="p">)</code> <code class="p">{</code>

    <code class="kd">public</code> <code class="kd">static</code> <code class="n">Origin</code> <code class="n">ZERO</code> <code class="o">=</code> <code class="k">new</code> <code class="n">Origin</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">);</code>
<code class="p">}</code></pre>
<p>First, your code is more expressive with meaningful names for constants.
Second, only a single instance is created, which is constant anywhere because the underlying data structure is immutable.</p>
</div></section>
<section data-pdf-bookmark="Step-by-Step Creation" data-type="sect3"><div class="sect3" id="_01-immutables_step-by-step">
<h3>Step-by-Step Creation</h3>
<p>One of the advantages of immutable data structures is the lack of “half-initialized” objects.
Still, not every data structure is initializable all at once.
Instead of using a mutable data structure in such a case, you can use the <em>builder pattern</em> to get a mutable intermediate variable that’s used to create an eventually immutable final result.
Even though the builder pattern was incepted as a solution to recurring object creation problems in object-oriented programming, it’s also highly beneficial for creating immutable data structures in a more functional Java environment.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45115243335488">
<h1>The Builder Design Pattern</h1>
<p>The <em>builder design pattern</em> was introduced in the book <em>Design Patterns: Elements of Reusable Object-Oriented Software</em>⁠<sup><a data-type="noteref" href="ch05.xhtml#idm45115243333328" id="idm45115243333328-marker">5</a></sup> by the “Gang of Four,” referring to Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides.</p>
<p>This creational design pattern aims to provide a flexible solution for constructing complex data structures by separating the build process from the final representation of the data structure.</p>
<p>The main advantage of this pattern is the ability to create complex data structures step-by-step, allowing you to defer steps until the required data is available.
It also fits into the <em>single responsibility principle</em>⁠<sup><a data-type="noteref" href="ch05.xhtml#idm45115243331312" id="idm45115243331312-marker">6</a></sup> of object-oriented design, defined as every class, module, or function in a program should have one responsibility/purpose in a program.
In this case, the builder class is solely responsible for constructing a complex data structure, while the structure itself is only responsible for representing its data.</p>
</div></aside>
<p>By separating the construction of the data structure from its representation, the data structure itself can be as simple as possible, making the pattern an excellent match for Records.
Any required logic, or validation, is encapsulated into a (multistep-)builder.</p>
<p>The previously used <code>User</code> Record can be complemented by a simple builder, as shown in <a data-type="xref" href="#_02-data-structures_records_builder">Example 5-5</a>.</p>
<div data-type="example" id="_02-data-structures_records_builder">
<h5><span class="label">Example 5-5. </span>User Builder</h5>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">final</code> <code class="kd">class</code> <code class="nc">UserBuilder</code> <code class="p">{</code>

  <code class="kd">private</code> <code class="kd">final</code> <code class="n">String</code> <code class="n">username</code><code class="p">;</code>

  <code class="kd">private</code> <code class="kt">boolean</code>       <code class="n">active</code><code class="p">;</code>
  <code class="kd">private</code> <code class="n">LocalDateTime</code> <code class="n">lastLogin</code><code class="p">;</code>

  <code class="kd">public</code> <code class="nf">UserBuilder</code><code class="p">(</code><code class="n">String</code> <code class="n">username</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="na">username</code> <code class="o">=</code> <code class="n">username</code><code class="p">;</code>
    <code class="k">this</code><code class="p">.</code><code class="na">active</code> <code class="o">=</code> <code class="kc">true</code><code class="p">;</code> <a class="co" href="#callout_working_with_records_CO6-1" id="co_working_with_records_CO6-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>
  <code class="p">}</code>

  <code class="kd">public</code> <code class="n">UserBuilder</code> <code class="nf">active</code><code class="p">(</code><code class="kt">boolean</code> <code class="n">isActive</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_working_with_records_CO6-2" id="co_working_with_records_CO6-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>
    <code class="k">if</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="na">active</code> <code class="o">=</code><code class="o">=</code> <code class="kc">false</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_working_with_records_CO6-3" id="co_working_with_records_CO6-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a>
      <code class="k">throw</code> <code class="k">new</code> <code class="n">IllegalArgumentException</code><code class="p">(</code><code class="s">"</code><code class="s">...</code><code class="s">"</code><code class="p">)</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="k">this</code><code class="p">.</code><code class="na">active</code> <code class="o">=</code> <code class="n">isActive</code><code class="p">;</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code> <a class="co" href="#callout_working_with_records_CO6-4" id="co_working_with_records_CO6-4"><img alt="4" height="12" src="assets/4.png" width="12"/></a>
  <code class="p">}</code>

  <code class="kd">public</code> <code class="n">UserBuilder</code> <code class="nf">lastLogin</code><code class="p">(</code><code class="n">LocalDateTime</code> <code class="n">lastLogin</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_working_with_records_CO6-5" id="co_working_with_records_CO6-5"><img alt="5" height="12" src="assets/5.png" width="12"/></a>
    <code class="k">this</code><code class="p">.</code><code class="na">lastLogin</code> <code class="o">=</code> <code class="n">lastLogin</code><code class="p">;</code>
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="kd">public</code> <code class="n">User</code> <code class="nf">build</code><code class="p">(</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_working_with_records_CO6-6" id="co_working_with_records_CO6-6"><img alt="6" height="12" src="assets/6.png" width="12"/></a>
    <code class="k">return</code> <code class="k">new</code> <code class="n">User</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="na">username</code><code class="p">,</code> <code class="k">this</code><code class="p">.</code><code class="na">active</code><code class="p">,</code> <code class="k">this</code><code class="p">.</code><code class="na">lastLogin</code><code class="p">)</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kd">var</code> <code class="n">builder</code> <code class="o">=</code> <code class="k">new</code> <code class="n">UserBuilder</code><code class="p">(</code><code class="s">"</code><code class="s">ben</code><code class="s">"</code><code class="p">)</code><code class="p">.</code><code class="na">active</code><code class="p">(</code><code class="kc">false</code><code class="p">)</code> <a class="co" href="#callout_working_with_records_CO6-7" id="co_working_with_records_CO6-7"><img alt="7" height="12" src="assets/7.png" width="12"/></a>
                                    <code class="p">.</code><code class="na">lastLogin</code><code class="p">(</code><code class="n">LocalDateTime</code><code class="p">.</code><code class="na">now</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code class="p">;</code>

<code class="c1">// ...</code>

<code class="kd">var</code> <code class="n">user</code> <code class="o">=</code> <code class="n">builder</code><code class="p">.</code><code class="na">build</code><code class="p">(</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_working_with_records_CO6-8" id="co_working_with_records_CO6-8"><img alt="8" height="12" src="assets/8.png" width="12"/></a></pre></div>
<dl class="calloutlist">
<dt><a class="co" href="#co_working_with_records_CO6-1" id="callout_working_with_records_CO6-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>Explicit default values are possible, reducing the required code for creation.</p></dd>
<dt><a class="co" href="#co_working_with_records_CO6-2" id="callout_working_with_records_CO6-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>Field that can be changed during building need setter-like methods.</p></dd>
<dt><a class="co" href="#co_working_with_records_CO6-3" id="callout_working_with_records_CO6-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a></dt>
<dd><p>Validation logic is bound to the specific setter-like method and not accumulated in any constructor.</p></dd>
<dt><a class="co" href="#co_working_with_records_CO6-4" id="callout_working_with_records_CO6-4"><img alt="4" height="12" src="assets/4.png" width="12"/></a></dt>
<dd><p>Returning <code>this</code> creates a fluent API for the builder.</p></dd>
<dt><a class="co" href="#co_working_with_records_CO6-5" id="callout_working_with_records_CO6-5"><img alt="5" height="12" src="assets/5.png" width="12"/></a></dt>
<dd><p><code>Optional</code> fields can use their explicit types, and only change into an <code>Optional</code> during <code>build()</code>.</p></dd>
<dt><a class="co" href="#co_working_with_records_CO6-6" id="callout_working_with_records_CO6-6"><img alt="6" height="12" src="assets/6.png" width="12"/></a></dt>
<dd><p>If you’re done building, calling <code>build()</code> will create the actual immutable <code>User</code> record.
Usually, the builder should validate its state if necessary.</p></dd>
<dt><a class="co" href="#co_working_with_records_CO6-7" id="callout_working_with_records_CO6-7"><img alt="7" height="12" src="assets/7.png" width="12"/></a></dt>
<dd><p>The build process is fluent, and you can pass the builder around like any other variable.</p></dd>
<dt><a class="co" href="#co_working_with_records_CO6-8" id="callout_working_with_records_CO6-8"><img alt="8" height="12" src="assets/8.png" width="12"/></a></dt>
<dd><p>Finally, create the immutable object by calling <code>build()</code>.</p></dd>
</dl>
<p>It’s sensible to increase the adhesion between the type and its builder by placing the builder class directly in the corresponding type as a <code>static</code> nested class, as seen in <a data-type="xref" href="#_02-data-structures_records_builder-nested">Example 5-6</a>.</p>
<div data-type="example" id="_02-data-structures_records_builder-nested">
<h5><span class="label">Example 5-6. </span>Nested Builder</h5>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">record</code> <code class="nc">User</code><code class="p">(</code><code class="kt">long</code> <code class="n">id</code><code class="p">,</code>
                   <code class="n">String</code> <code class="n">username</code><code class="p">,</code>
                   <code class="kt">boolean</code> <code class="n">active</code><code class="p">,</code>
                   <code class="n">Optional</code><code class="o">&lt;</code><code class="n">LocalDateTime</code><code class="o">&gt;</code> <code class="n">lastLogin</code><code class="p">)</code> <code class="p">{</code>

  <code class="kd">public</code> <code class="kd">static</code> <code class="kd">final</code> <code class="kd">class</code> <code class="nc">Builder</code> <code class="p">{</code>
    <code class="c1">// ...</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kd">var</code> <code class="n">builder</code> <code class="o">=</code> <code class="k">new</code> <code class="n">User</code><code class="p">.</code><code class="na">Builder</code><code class="p">(</code><code class="s">"ben"</code><code class="p">);</code></pre></div>
<p>It might seem non-sensical to use a Record to achieve simplicity and immutability but still introduce the complexity of a builder.
Why not use a full-fledged bean instead?
Because even with the complexity of the builder, the concerns of creating and using the data are separate.
The Record is still usable without the builder, but the builder provides an additional and flexible way to create a Record instance.</p>
</div></section>
</div></section>
</div></section>
<section data-pdf-bookmark="Use-Cases and Common Practices" data-type="sect1"><div class="sect1" id="idm45115243337408">
<h1>Use-Cases and Common Practices</h1>
<p>Records save you a lot of boilerplate code, and with a few additions, you can supercharge them into an even more flexible and versatile tool.</p>
<section data-pdf-bookmark="Record Validation and Data Scrubbing" data-type="sect2"><div class="sect2" id="_02-records_validation">
<h2>Record Validation and Data Scrubbing</h2>
<p>As shown in <a data-type="xref" href="#_01-immutables_records_custom-compact-constructor">“Canonical, Compact, and Custom Constructors”</a>, Records support a <em>compact constructor</em> that behaves differently from a <em>normal</em> constructor.
You have access to all components of the canonical constructor, but it doesn’t have any arguments.
It gives you a location to put any <em>additional</em> code required for the initialization process without needing to assign the components yourself.
That makes it the perfect place to put any validation and data-scrubbing logic:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">record</code> <code class="nc">NeedsValidation</code><code class="p">(</code><code class="kt">int</code> <code class="n">x</code><code class="p">,</code> <code class="kt">int</code> <code class="n">y</code><code class="p">)</code> <code class="p">{</code>

  <code class="kd">public</code> <code class="n">NeedsValidation</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="n">x</code> <code class="o">&lt;</code> <code class="n">y</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">throw</code> <code class="k">new</code> <code class="n">IllegalArgumentException</code><code class="p">(</code><code class="s">"x must be equal or greater than y"</code><code class="p">);</code>
    <code class="p">}</code>
  <code class="p">}</code>
<code class="p">}</code></pre>
<p>Throwing exceptions is one way to go.
Another option is to <em>scrub</em> the data and adjust component values with sensible alternatives to form a valid Record:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">record</code> <code class="nc">Time</code><code class="p">(</code><code class="kt">int</code> <code class="n">minutes</code><code class="p">,</code> <code class="kt">int</code> <code class="n">seconds</code><code class="p">)</code> <code class="p">{</code>

  <code class="kd">public</code> <code class="n">Time</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="n">seconds</code> <code class="o">&gt;=</code> <code class="mi">60</code><code class="p">)</code> <code class="p">{</code>
      <code class="kt">int</code> <code class="n">additionalMinutes</code> <code class="o">=</code> <code class="n">seconds</code> <code class="o">/</code> <code class="mi">60</code><code class="p">;</code>
      <code class="n">minutes</code> <code class="o">+=</code> <code class="n">additionalMinutes</code><code class="p">;</code>
      <code class="n">seconds</code> <code class="o">-=</code> <code class="n">additionalMinutes</code> <code class="o">*</code> <code class="mi">60</code><code class="p">;</code>
    <code class="p">}</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kd">var</code> <code class="n">time</code> <code class="o">=</code> <code class="k">new</code> <code class="n">Time</code><code class="p">(</code><code class="mi">12</code><code class="p">,</code> <code class="mi">67</code><code class="p">);</code>
<code class="c1">// =&gt; Time[minutes=13, seconds=7]</code></pre>
<p>Moving a certain degree of logic, like the normalization of out-of-range values, directly into a Record gives you more consistent data representations, regardless of the initial data.
Another approach is requiring such data scrubbing beforehand and restricting a Record to do only <em>hard</em> validation by throwing a proper exception.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45115242732864">
<h1>Record validation with the Bean Validation API</h1>
<p>Another validation option for Records is the <em>Bean Validation API</em> (<a href="https://beanvalidation.org/2.0-jsr380/spec/">JSR-380</a>).
Records aren’t JavaBeans <em>technically</em>, but they can still profit from the existing validation concept.
The Bean Validation API gives you the tools to express and validate constraints with a multitude of annotations like <code>@NonNull</code>, <code>@Positive</code>, etc.
Implementing JSR-380 compatible constraints requires adding additional dependencies to your project.
Even then, the validation isn’t run automatically.
ByteCode manipulation is often used to mitigate this issue.
The details of how to use the Bean Validation API are out of the scope of this book, but the official <a href="https://blogs.oracle.com/javamagazine/post/diving-into-java-records-serialization-marshaling-and-bean-state-validation">Java Magazine has an excellent article</a> that provides an overview of how to implement rudimentary Record validation with JSR-380.</p>
</div></aside>
</div></section>
<section data-pdf-bookmark="Increasing Immutability" data-type="sect2"><div class="sect2" id="idm45115242693472">
<h2>Increasing Immutability</h2>
<p>In <a data-type="xref" href="ch04.xhtml#_02-data-structures_immutable-collections">“Immutable Collections”</a> you learned about the problem with shallow immutability in collections.
A shallowly immutable data structure has an immutable reference, but the data it refers to is still mutable.
The same underlying problems of unexpected changes must also be considered with non-inherently immutable Record components.
An easy way to minimize any changes in Record components is by trying to increase the level of immutability by copying or rewrapping them.</p>
<p>You can use the canonical constructor to create immutable copies of a component:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">record</code> <code class="nc">IncreaseImmutability</code><code class="p">(</code><code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">values</code><code class="p">)</code> <code class="p">{</code>

  <code class="kd">public</code> <code class="n">IncreaseImmutability</code> <code class="p">{</code>
    <code class="n">values</code> <code class="o">=</code> <code class="n">Collections</code><code class="p">.</code><code class="na">unmodifiableList</code><code class="p">(</code><code class="n">values</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code></pre>
<p>The call to <code>Collections.unmodifiableList</code> creates a memory-wise lean but unmodifiable view of the original <code>List</code>.
This prevents changes to the Record’s component but can’t control changes to the underlying <code>List</code> via the original reference.
A greater level of immutability can be achieved by using the Java 10+ method <code>List.copy(Collection&lt;? extends E&gt; coll)</code> to create a deep copy independent from the original reference.</p>
</div></section>
<section data-pdf-bookmark="Creating Modified Copies" data-type="sect2"><div class="sect2" id="idm45115242548480">
<h2>Creating Modified Copies</h2>
<p>Even though the declaration of Records is as minimal as it gets, creating a slightly modified copy is a DIY job without any help from the JDK.</p>
<p>There are multiple approaches to creating modified copies if you don’t want to do it completely manually:</p>
<ul>
<li>
<p>Wither methods</p>
</li>
<li>
<p>Builder pattern</p>
</li>
<li>
<p>Tool-assisted</p>
</li>
<li>
<p>Reflection</p>
</li>
</ul>
<section data-pdf-bookmark="Wither Methods" data-type="sect3"><div class="sect3" id="idm45115242538272">
<h3>Wither Methods</h3>
<p><em>Wither methods</em> follow the name scheme <code>with[componentName]([Type] value)</code>.
They’re similar to setters, but return a new instance instead of modifying the current one:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">record</code> <code class="nc">Point</code><code class="p">(</code><code class="kt">int</code> <code class="n">x</code><code class="p">,</code> <code class="kt">int</code> <code class="n">y</code><code class="p">)</code> <code class="p">{</code>

  <code class="kd">public</code> <code class="n">Point</code> <code class="nf">withX</code><code class="p">(</code><code class="kt">int</code> <code class="n">newX</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">new</code> <code class="n">Point</code><code class="p">(</code><code class="n">newX</code><code class="p">,</code> <code class="n">y</code><code class="p">());</code>
  <code class="p">}</code>

  <code class="kd">public</code> <code class="n">Point</code> <code class="nf">withY</code><code class="p">(</code><code class="kt">int</code> <code class="n">newY</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">new</code> <code class="n">Point</code><code class="p">(</code><code class="n">x</code><code class="p">(),</code> <code class="n">newY</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kd">var</code> <code class="n">point</code> <code class="o">=</code> <code class="k">new</code> <code class="n">Point</code><code class="p">(</code><code class="mi">23</code><code class="p">,</code> <code class="mi">42</code><code class="p">);</code>
<code class="c1">// =&gt; Point[x=23, y=42]</code>

<code class="kd">var</code> <code class="n">newPoint</code> <code class="o">=</code> <code class="n">point</code><code class="p">.</code><code class="na">withX</code><code class="p">(</code><code class="mi">5</code><code class="p">);</code>
<code class="c1">// =&gt; Point[x=5, y=42]</code></pre>
<p>A nested Record is a handy way to separate the modification logic from the actual Record:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">record</code> <code class="nc">Point</code><code class="p">(</code><code class="kt">int</code> <code class="n">x</code><code class="p">,</code> <code class="kt">int</code> <code class="n">y</code><code class="p">)</code> <code class="p">{</code>

  <code class="kd">public</code> <code class="n">With</code> <code class="nf">with</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="k">new</code> <code class="n">With</code><code class="p">(</code><code class="k">this</code><code class="p">);</code>
  <code class="p">}</code>

  <code class="kd">public</code> <code class="kd">record</code> <code class="nc">With</code><code class="p">(</code><code class="n">Point</code> <code class="n">source</code><code class="p">)</code> <code class="p">{</code>

    <code class="kd">public</code> <code class="n">Point</code> <code class="nf">x</code><code class="p">(</code><code class="kt">int</code> <code class="n">x</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">return</code> <code class="k">new</code> <code class="n">Point</code><code class="p">(</code><code class="n">x</code><code class="p">,</code> <code class="n">source</code><code class="p">.</code><code class="na">y</code><code class="p">());</code>
    <code class="p">}</code>

    <code class="kd">public</code> <code class="n">Point</code> <code class="nf">y</code><code class="p">(</code><code class="kt">int</code> <code class="n">y</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">return</code> <code class="k">new</code> <code class="n">Point</code><code class="p">(</code><code class="n">source</code><code class="p">.</code><code class="na">x</code><code class="p">(),</code> <code class="n">y</code><code class="p">);</code>
    <code class="p">}</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kd">var</code> <code class="n">sourcePoint</code> <code class="o">=</code> <code class="k">new</code> <code class="n">Point</code><code class="p">(</code><code class="mi">23</code><code class="p">,</code> <code class="mi">42</code><code class="p">);</code>

<code class="kd">var</code> <code class="n">modifiedPoint</code> <code class="o">=</code> <code class="n">sourcePoint</code><code class="p">.</code><code class="na">with</code><code class="p">().</code><code class="na">x</code><code class="p">(</code><code class="mi">5</code><code class="p">);</code></pre>
<p>The original Record only has one additional method, and all mutator/copy methods are encapsulated in the <code>With</code> type.</p>
<p>The most obvious downside of wither-methods, like default values in <a data-type="xref" href="#_02-records_default-values">“Component Default Values and Convenience Constructors”</a>, is the requirement to write a method for each component.
Restricting your code to the most common scenarios is sensible, and only add new methods as required.</p>
</div></section>
<section data-pdf-bookmark="Builder Pattern" data-type="sect3"><div class="sect3" id="idm45115242400208">
<h3>Builder Pattern</h3>
<p>The builder pattern, as introduced in <a data-type="xref" href="#_01-immutables_step-by-step">“Step-by-Step Creation”</a>, also allows for easier change management if you add a copy-constructor.
Such a constructor allows you to initialize the builder with an existing record, make the appropriate changes, and create a new record, shown as follows:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">record</code> <code class="nc">Point</code><code class="p">(</code><code class="kt">int</code> <code class="n">x</code><code class="p">,</code> <code class="kt">int</code> <code class="n">y</code><code class="p">)</code> <code class="p">{</code>

  <code class="kd">public</code> <code class="kd">static</code> <code class="kd">final</code> <code class="kd">class</code> <code class="nc">Builder</code> <code class="p">{</code>

    <code class="kd">private</code> <code class="kt">int</code> <code class="n">x</code><code class="p">;</code>
    <code class="kd">private</code> <code class="kt">int</code> <code class="n">y</code><code class="p">;</code>

    <code class="kd">public</code> <code class="nf">Builder</code><code class="p">(</code><code class="n">Point</code> <code class="n">point</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">this</code><code class="p">.</code><code class="na">x</code> <code class="o">=</code> <code class="n">point</code><code class="p">.</code><code class="na">x</code><code class="p">();</code>
      <code class="k">this</code><code class="p">.</code><code class="na">y</code> <code class="o">=</code> <code class="n">point</code><code class="p">.</code><code class="na">y</code><code class="p">();</code>
    <code class="p">}</code>

    <code class="kd">public</code> <code class="n">Builder</code> <code class="nf">x</code><code class="p">(</code><code class="kt">int</code> <code class="n">x</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">this</code><code class="p">.</code><code class="na">x</code> <code class="o">=</code> <code class="n">x</code><code class="p">;</code>
      <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="kd">public</code> <code class="n">Builder</code> <code class="nf">y</code><code class="p">(</code><code class="kt">int</code> <code class="n">y</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">this</code><code class="p">.</code><code class="na">y</code> <code class="o">=</code> <code class="n">y</code><code class="p">;</code>
      <code class="k">return</code> <code class="k">this</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="kd">public</code> <code class="n">Point</code> <code class="nf">build</code><code class="p">()</code> <code class="p">{</code>
      <code class="k">return</code> <code class="k">new</code> <code class="n">Point</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="na">x</code><code class="p">,</code> <code class="k">this</code><code class="p">.</code><code class="na">y</code><code class="p">);</code>
    <code class="p">}</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kd">var</code> <code class="n">original</code> <code class="o">=</code> <code class="k">new</code> <code class="n">Point</code><code class="p">(</code><code class="mi">23</code><code class="p">,</code> <code class="mi">42</code><code class="p">);</code>

<code class="kd">var</code> <code class="n">updated</code> <code class="o">=</code> <code class="k">new</code> <code class="n">Point</code><code class="p">.</code><code class="na">Builder</code><code class="p">(</code><code class="n">original</code><code class="p">)</code>
                       <code class="p">.</code><code class="na">x</code><code class="p">(</code><code class="mi">5</code><code class="p">)</code>
                       <code class="p">.</code><code class="na">build</code><code class="p">();</code></pre>
<p>This approach shares the same problem as “wither” methods: strong cohesion between the components and code needed to create Record copies, making refactoring harder.
To mitigate, you can use a tool-assisted approach.</p>
</div></section>
<section data-pdf-bookmark="Tool-Assisted Builder" data-type="sect3"><div class="sect3" id="idm45115242202528">
<h3>Tool-Assisted Builder</h3>
<p>Instead of updating your Record builder classes each time a Record changes, you could use an annotation processor to do the work for you.
A tool like <a href="https://github.com/randgalt/record-builder">RecordBuilder</a> generates a flexible builder for any Record and all you have to do is add a single annotation:</p>
<pre data-code-language="java" data-type="programlisting"><code class="nd">@RecordBuilder</code>
<code class="kd">public</code> <code class="kd">record</code> <code class="nc">Point</code><code class="p">(</code><code class="kt">int</code> <code class="n">x</code><code class="p">,</code> <code class="kt">int</code> <code class="n">y</code><code class="p">)</code> <code class="p">{</code>
  <code class="c1">// NO BODY</code>
<code class="p">}</code>


<code class="c1">// GENERAL BUILDER</code>
<code class="kd">var</code> <code class="n">original</code> <code class="o">=</code> <code class="n">PointBuilder</code><code class="p">.</code><code class="na">builder</code><code class="p">()</code>
                           <code class="p">.</code><code class="na">x</code><code class="p">(</code><code class="mi">5</code><code class="p">)</code>
                           <code class="p">.</code><code class="na">y</code><code class="p">(</code><code class="mi">23</code><code class="p">)</code>
                           <code class="p">.</code><code class="na">build</code><code class="p">();</code>


<code class="c1">// COPY BUILDER</code>
<code class="kd">var</code> <code class="n">modified</code> <code class="o">=</code> <code class="n">PointBuilder</code><code class="p">.</code><code class="na">builder</code><code class="p">(</code><code class="n">original</code><code class="p">)</code>
                           <code class="p">.</code><code class="na">x</code><code class="p">(</code><code class="mi">12</code><code class="p">)</code>
                           <code class="p">.</code><code class="na">build</code><code class="p">();</code></pre>
<p>Any change to the Record’s components will automatically be available in the generated builder.
A “wither"-based approach is also possible but requires your Record to implement an additionally generated interface:</p>
<pre data-code-language="java" data-type="programlisting"><code class="nd">@RecordBuilder</code>
<code class="kd">public</code> <code class="kd">record</code> <code class="nc">Point</code><code class="p">(</code><code class="kt">int</code> <code class="n">x</code><code class="p">,</code> <code class="kt">int</code> <code class="n">y</code><code class="p">)</code> <code class="kd">implements</code> <code class="n">PointBuilder</code><code class="p">.</code><code class="na">With</code> <code class="p">{</code>
  <code class="c1">// NO BODY</code>
<code class="p">}</code>

<code class="kd">var</code> <code class="n">original</code> <code class="o">=</code> <code class="k">new</code> <code class="n">Point</code><code class="p">(</code><code class="mi">5</code><code class="p">,</code> <code class="mi">23</code><code class="p">);</code>

<code class="c1">// SINGLE CHANGE</code>
<code class="kd">var</code> <code class="n">modified1</code> <code class="o">=</code> <code class="n">original</code><code class="p">.</code><code class="na">withX</code><code class="p">(</code><code class="mi">12</code><code class="p">);</code>


<code class="c1">// MULTI-CHANGE VIA BUILDER</code>
<code class="kd">var</code> <code class="n">modified2</code> <code class="o">=</code> <code class="n">original</code><code class="p">.</code><code class="na">with</code><code class="p">()</code>
                        <code class="p">.</code><code class="na">x</code><code class="p">(</code><code class="mi">12</code><code class="p">)</code>
                        <code class="p">.</code><code class="na">y</code><code class="p">(</code><code class="mi">21</code><code class="p">)</code>
                        <code class="p">.</code><code class="na">build</code><code class="p">()</code>

<code class="c1">// MULTI-CHANGE VIA CONSUMER (doesn't require calling build())</code>
<code class="kd">var</code> <code class="n">modified3</code> <code class="o">=</code> <code class="n">original</code><code class="p">.</code><code class="na">with</code><code class="p">(</code><code class="n">builder</code> <code class="o">-&gt;</code> <code class="n">builder</code><code class="p">.</code><code class="na">x</code><code class="p">(</code><code class="mi">12</code><code class="p">)</code>
                                                <code class="p">.</code><code class="na">y</code><code class="p">(</code><code class="mi">21</code><code class="p">));</code></pre>
<p>Even though using an external tool to complement your Records, or any code, can save you a lot of typing, it also comes with some downsides.
Depending on a tool for an essential part of your project that won’t work without it, creates a hard-to-break cohesion between them.
Any bugs, security problems, or breaking changes may affect your code in unforeseen ways, often without the possibility of fixing it yourself.
Annotation processors integrate themselves into your build tools, making them now interrelated, too.
So make sure you evaluate such dependencies thoroughly<sup><a data-type="noteref" href="ch05.xhtml#idm45115241795328" id="idm45115241795328-marker">7</a></sup> before adding them to your projects.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Records as Local Nominal Tuples" data-type="sect2"><div class="sect2" id="_02-records_local">
<h2>Records as Local Nominal Tuples</h2>
<p>One type of construct prevalent in many functional programming languages is missing in Java: <em>dynamic tuples</em>.
Programming languages usually use those as dynamic data aggregators without requiring an explicitly defined type.
Java Records are simple data aggregators and can be considered <em>nominal tuples</em> in a sense.
The most significant difference to most tuple implementations is that their contained data is held together by an umbrella type due to the Java type system.
Records aren’t as flexible or interchangeable as other languages’ tuple implementations.
Still, you can use them as localized <em>on-the-fly</em> data aggregators, thanks to an addition to Records in Java 15: <em>local Records</em>.</p>
<p>Contextually localized Records simplify and formalize data processing and bundle up functionality.
Imagine you have a list of music album titles of the 90s, grouped by year as a <code>Map&lt;Integer, List&lt;String&gt;&gt;</code>, shown as follows:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">Map</code><code class="o">&lt;</code><code class="n">Integer</code><code class="p">,</code> <code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;&gt;</code> <code class="n">albumns</code> <code class="o">=</code>
  <code class="n">Map</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="mi">1990</code><code class="p">,</code> <code class="n">List</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="s">"Bossanova"</code><code class="p">,</code> <code class="s">" Listen Without Prejudice"</code><code class="p">),</code>
         <code class="mi">1991</code><code class="p">,</code> <code class="n">List</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="s">"Nevermind"</code><code class="p">,</code> <code class="s">"Ten"</code><code class="p">,</code> <code class="s">"Blue lines"</code><code class="p">),</code>
         <code class="mi">1992</code><code class="p">,</code> <code class="n">List</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="s">"The Chronic"</code><code class="p">,</code> <code class="s">"Rage Against the Machine"</code><code class="p">),</code>
         <code class="mi">1993</code><code class="p">,</code> <code class="n">List</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="s">"Enter the Wu-Tang (36 Chambers)"</code><code class="p">),</code>
         <code class="p">...</code>
         <code class="mi">1999</code><code class="p">,</code> <code class="n">List</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="s">"The Slim Shady LP"</code><code class="p">,</code> <code class="s">"Californication"</code><code class="p">,</code> <code class="s">"Play"</code><code class="p">));</code></pre>
<p>Working with such a nested and unspecific data structure is quite a hassle.
Iterating Maps requires using the <code>entrySet()</code> method, which returns <code>Map.Entry&lt;Integer, List&lt;String&gt;&gt;</code> instances in this case.
Working with the entries might give you access to all the data, but not in an expressive way.</p>
<p>The following code uses a Stream pipeline to create a filter method for the music album titles.
Even without reading <a data-type="xref" href="ch06.xhtml#_02-data-processing">Chapter 6</a>, which will explain Streams in detail, most of the code should be straightforward, but I’ll guide you through it.</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="nf">filterAlbums</code><code class="p">(</code><code class="n">Map</code><code class="o">&lt;</code><code class="n">Integer</code><code class="p">,</code> <code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code><code class="o">&gt;</code> <code class="n">albums</code><code class="p">,</code>
                                 <code class="kt">int</code> <code class="n">minimumYear</code><code class="p">)</code> <code class="p">{</code>

  <code class="k">return</code> <code class="n">albums</code><code class="p">.</code><code class="na">entrySet</code><code class="p">(</code><code class="p">)</code>
               <code class="p">.</code><code class="na">stream</code><code class="p">(</code><code class="p">)</code>
               <code class="p">.</code><code class="na">filter</code><code class="p">(</code><code class="n">entry</code> <code class="o">-</code><code class="o">&gt;</code> <code class="n">entry</code><code class="p">.</code><code class="na">getKey</code><code class="p">(</code><code class="p">)</code> <code class="o">&gt;</code><code class="o">=</code> <code class="n">minimumYear</code><code class="p">)</code> <a class="co" href="#callout_working_with_records_CO7-1" id="co_working_with_records_CO7-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>
               <code class="p">.</code><code class="na">sorted</code><code class="p">(</code><code class="n">Comparator</code><code class="p">.</code><code class="na">comparing</code><code class="p">(</code><code class="n">Map</code><code class="p">.</code><code class="na">Entry</code><code class="p">:</code><code class="p">:</code><code class="n">getKey</code><code class="p">)</code><code class="p">)</code> <a class="co" href="#callout_working_with_records_CO7-2" id="co_working_with_records_CO7-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>
               <code class="p">.</code><code class="na">map</code><code class="p">(</code><code class="n">Map</code><code class="p">.</code><code class="na">Entry</code><code class="p">:</code><code class="p">:</code><code class="n">getValue</code><code class="p">)</code> <a class="co" href="#callout_working_with_records_CO7-3" id="co_working_with_records_CO7-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a>
               <code class="p">.</code><code class="na">flatMap</code><code class="p">(</code><code class="n">List</code><code class="p">:</code><code class="p">:</code><code class="n">stream</code><code class="p">)</code> <a class="co" href="#callout_working_with_records_CO7-4" id="co_working_with_records_CO7-4"><img alt="4" height="12" src="assets/4.png" width="12"/></a>
               <code class="p">.</code><code class="na">toList</code><code class="p">(</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_working_with_records_CO7-5" id="co_working_with_records_CO7-5"><img alt="5" height="12" src="assets/5.png" width="12"/></a>
<code class="p">}</code></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_working_with_records_CO7-1" id="callout_working_with_records_CO7-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>Filter the entries for albums that are at least the minimum year.</p></dd>
<dt><a class="co" href="#co_working_with_records_CO7-2" id="callout_working_with_records_CO7-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>Sort the title lists by their respective years.</p></dd>
<dt><a class="co" href="#co_working_with_records_CO7-3" id="callout_working_with_records_CO7-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a></dt>
<dd><p>Transform the entry to its actual value.</p></dd>
<dt><a class="co" href="#co_working_with_records_CO7-4" id="callout_working_with_records_CO7-4"><img alt="4" height="12" src="assets/4.png" width="12"/></a></dt>
<dd><p>The <code>flatMap</code> call helps to “flatten” the <code>List&lt;String&gt;</code> elements containing a year’S titles to singular elements in the pipeline.</p></dd>
<dt><a class="co" href="#co_working_with_records_CO7-5" id="callout_working_with_records_CO7-5"><img alt="5" height="12" src="assets/5.png" width="12"/></a></dt>
<dd><p>Collect the elements to a <code>List&lt;String&gt;</code></p></dd>
</dl>
<p>Each Stream operation has to deal with <code>getKey()</code> or <code>getValue()</code> instead of expressive names representing the actual data in its context.
That’s why introducing a local Record as an intermediate type allows you to regain expressiveness in complex data processing tasks, like Stream pipelines, but any data processing can benefit from more expressiveness.
You can even move parts of the logic into the Record to use method references or single calls for each operation.</p>
<p>Think about the form of the data you <em>have</em>, and how it <em>should</em> be represented, and design your Record accordingly.
Next, you should refactor complex data processing tasks into Record methods.
Possible candidates are:</p>
<ul>
<li>
<p>Creating the Record from a <code>Map.Entry</code> instance.</p>
</li>
<li>
<p>Filtering by year</p>
</li>
<li>
<p>Sorting by year.</p>
</li>
</ul>
<p>The following Record code shows implementations of these tasks:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">record</code> <code class="nc">AlbumsPerYear</code><code class="p">(</code><code class="kt">int</code> <code class="n">year</code><code class="p">,</code> <code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">titles</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_working_with_records_CO8-1" id="co_working_with_records_CO8-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>

  <code class="kd">public</code> <code class="nf">AlbumsPerYear</code><code class="p">(</code><code class="n">Map</code><code class="p">.</code><code class="na">Entry</code><code class="o">&lt;</code><code class="n">Integer</code><code class="p">,</code> <code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code><code class="o">&gt;</code> <code class="n">entry</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_working_with_records_CO8-2" id="co_working_with_records_CO8-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>
    <code class="k">this</code><code class="p">(</code><code class="n">entry</code><code class="p">.</code><code class="na">getKey</code><code class="p">(</code><code class="p">)</code><code class="p">,</code> <code class="n">entry</code><code class="p">.</code><code class="na">getValue</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="kd">public</code> <code class="kd">static</code> <code class="n">Predicate</code><code class="o">&lt;</code><code class="n">AlbumsPerYear</code><code class="o">&gt;</code> <code class="nf">minimumYear</code><code class="p">(</code><code class="kt">int</code> <code class="n">year</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_working_with_records_CO8-3" id="co_working_with_records_CO8-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a>
    <code class="k">return</code> <code class="n">albumsPerYear</code> <code class="o">-</code><code class="o">&gt;</code> <code class="n">albumsPerYear</code><code class="p">.</code><code class="na">year</code><code class="p">(</code><code class="p">)</code> <code class="o">&gt;</code><code class="o">=</code> <code class="n">year</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="kd">public</code> <code class="kd">static</code> <code class="n">Comparator</code><code class="o">&lt;</code><code class="n">AlbumsPerYear</code><code class="o">&gt;</code> <code class="nf">sortByYear</code><code class="p">(</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_working_with_records_CO8-4" id="co_working_with_records_CO8-4"><img alt="4" height="12" src="assets/4.png" width="12"/></a>
    <code class="k">return</code> <code class="n">Comparator</code><code class="p">.</code><code class="na">comparing</code><code class="p">(</code><code class="n">AlbumsPerYear</code><code class="p">:</code><code class="p">:</code><code class="n">year</code><code class="p">)</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_working_with_records_CO8-1" id="callout_working_with_records_CO8-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>The Record components reflect how you want to access the data with more expressive names.</p></dd>
<dt><a class="co" href="#co_working_with_records_CO8-2" id="callout_working_with_records_CO8-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>An additional constructor allows using a method reference to create new instances.</p></dd>
<dt><a class="co" href="#co_working_with_records_CO8-3" id="callout_working_with_records_CO8-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a></dt>
<dd><p>If a task depends on an out-of-scope variable, it should be defined as <code>static</code> helpers.</p></dd>
<dt><a class="co" href="#co_working_with_records_CO8-4" id="callout_working_with_records_CO8-4"><img alt="4" height="12" src="assets/4.png" width="12"/></a></dt>
<dd><p>Sorting should be done either by creating a <code>static</code> helper method returning a <code>Comparator</code>, or your Record could implement the <code>Comparable</code> interface instead if only a single sort needs to be supported.</p></dd>
</dl>
<p>The Record <code>AlbumsPerYear</code> is specifically designed for the Stream pipeline of the <code>filterAlbums</code> method and should only be available in its scope.
The local context confines the record, denying it access to surrounding variables.
All nested records are implicitly <code>static</code> to prevent state leaking into it through the surrounding class.
<a data-type="xref" href="#_02-records_localized-records-final-example">Example 5-7</a> shows how the Record lives in the method and how the Record improves the overall code.</p>
<div data-type="example" id="_02-records_localized-records-final-example">
<h5><span class="label">Example 5-7. </span>Stream pipeline with localized Record</h5>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="nf">filterAlbums</code><code class="p">(</code><code class="n">Map</code><code class="o">&lt;</code><code class="n">Integer</code><code class="p">,</code> <code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code><code class="o">&gt;</code> <code class="n">albums</code><code class="p">,</code>
                                 <code class="kt">int</code> <code class="n">minimumYear</code><code class="p">)</code> <code class="p">{</code>

  <code class="kd">record</code> <code class="nc">AlbumsPerYear</code><code class="p">(</code><code class="kt">int</code> <code class="n">year</code><code class="p">,</code> <code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">titles</code><code class="p">)</code> <code class="p">{</code> <a class="co" href="#callout_working_with_records_CO9-1" id="co_working_with_records_CO9-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>
    <code class="c1">// ...</code>
  <code class="p">}</code>

  <code class="k">return</code> <code class="n">albums</code><code class="p">.</code><code class="na">entrySet</code><code class="p">(</code><code class="p">)</code>
               <code class="p">.</code><code class="na">stream</code><code class="p">(</code><code class="p">)</code>
               <code class="p">.</code><code class="na">map</code><code class="p">(</code><code class="n">AlbumsPerYear</code><code class="p">:</code><code class="p">:</code><code class="k">new</code><code class="p">)</code> <a class="co" href="#callout_working_with_records_CO9-2" id="co_working_with_records_CO9-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>
               <code class="p">.</code><code class="na">filter</code><code class="p">(</code><code class="n">AlbumsPerYear</code><code class="p">.</code><code class="na">minimumYear</code><code class="p">(</code><code class="n">minimumYear</code><code class="p">)</code><code class="p">)</code> <a class="co" href="#callout_working_with_records_CO9-3" id="co_working_with_records_CO9-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a>
               <code class="p">.</code><code class="na">sorted</code><code class="p">(</code><code class="n">AlbumsPerYear</code><code class="p">.</code><code class="na">sortByYear</code><code class="p">(</code><code class="p">)</code><code class="p">)</code> <a class="co" href="#callout_working_with_records_CO9-3" id="co_working_with_records_CO9-4"><img alt="3" height="12" src="assets/3.png" width="12"/></a>
               <code class="p">.</code><code class="na">map</code><code class="p">(</code><code class="n">AlbumsPerYear</code><code class="p">:</code><code class="p">:</code><code class="n">titles</code><code class="p">)</code> <a class="co" href="#callout_working_with_records_CO9-3" id="co_working_with_records_CO9-5"><img alt="3" height="12" src="assets/3.png" width="12"/></a>
               <code class="p">.</code><code class="na">flatMap</code><code class="p">(</code><code class="n">List</code><code class="p">:</code><code class="p">:</code><code class="n">stream</code><code class="p">)</code> <a class="co" href="#callout_working_with_records_CO9-4" id="co_working_with_records_CO9-6"><img alt="4" height="12" src="assets/4.png" width="12"/></a>
               <code class="p">.</code><code class="na">toList</code><code class="p">(</code><code class="p">)</code><code class="p">;</code>
<code class="p">}</code></pre></div>
<dl class="calloutlist">
<dt><a class="co" href="#co_working_with_records_CO9-1" id="callout_working_with_records_CO9-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>The localized Record is directly declared in the method, restricting its scope.
I didn’t repeat the actual implementation for readability reasons.</p></dd>
<dt><a class="co" href="#co_working_with_records_CO9-2" id="callout_working_with_records_CO9-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>The first operation of the Stream pipeline is to transform the <code>Map.Entry</code> instance into the local Record type.</p></dd>
<dt><a class="co" href="#co_working_with_records_CO9-3" id="callout_working_with_records_CO9-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a></dt>
<dd><p>Each subsequent operation uses an expressive method of the localized Record, either directly or as a method reference, instead of an explicit lambda expression.</p></dd>
<dt><a class="co" href="#co_working_with_records_CO9-6" id="callout_working_with_records_CO9-4"><img alt="4" height="12" src="assets/4.png" width="12"/></a></dt>
<dd><p>Some operations are harder to refactor, like <code>flatMap</code>, because the overall processing logic of the Stream dictates their use.</p></dd>
</dl>
<p>As you can see, using a local Record is an excellent way to improve the ergonomics and expressiveness of a declarative Stream pipeline without exposing the type outside of its apparent scope.</p>
</div></section>
<section data-pdf-bookmark="Better Optional Data Handling" data-type="sect2"><div class="sect2" id="idm45115241668208">
<h2>Better Optional Data Handling</h2>
<p>Dealing with optional data and possible <code>null</code> values is the bane of every Java developer.
One option is using the Bean Validation API, as shown in <a data-type="xref" href="#_02-records_validation">“Record Validation and Data Scrubbing”</a>, and annotating each component with <code>@NonNull</code> and <code>@Nullable</code>, although this approach requires a dependency.
If you want to stay within the JDK, Java 8 eased the pain of <code>null</code>-handling by introducing the <code>Optional&lt;T&gt;</code> type, which you will learn more about in <a data-type="xref" href="ch09.xhtml#_02-optionals">Chapter 9</a>.
For now, all you need to know is that it’s a container type for possible <code>null</code>-values, so even if the value is <code>null</code>, you can still interact with the container without causing a <code>NullPointerException</code>.</p>
<p>The <code>Optional</code> type clearly signifies that a component is optional, but it requires a little more code than just changing the type to be an effective tool.
Let’s add an optional group to our <code>User</code> type example from earlier in this chapter:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">record</code> <code class="nc">User</code><code class="p">(</code><code class="n">String</code> <code class="n">username</code><code class="p">,</code>
                   <code class="kt">boolean</code> <code class="n">active</code><code class="p">,</code>
                   <code class="n">Optional</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">group</code><code class="p">,</code>
                   <code class="n">LocalDateTime</code> <code class="n">lastLogin</code><code class="p">)</code> <code class="p">{</code>
  <code class="c1">// NO BODY</code>
<code class="p">}</code></pre>
<p>Even though an <code>Optional&lt;String&gt;</code> is used to store the user’s group, you still have to deal with the possibility of receiving <code>null</code> for the container itself.
A better option would be accepting <code>null</code> for the value itself but still having an <code>Optional&lt;String&gt;</code> component.
With Records reflecting their definition with their accessors 1:1, two additional steps are necessary to make Records safe and more convenient to use with optional components.</p>
<section data-pdf-bookmark="Ensure non-null Container" data-type="sect3"><div class="sect3" id="idm45115240841840">
<h3>Ensure non-null Container</h3>
<p>The first step to making Records safer and more convenient to use with optional components is to ensure that the <code>Optional&lt;String&gt;</code> won’t be <code>null</code> and, therefore, ruin the idea behind having it.
The easiest way is to validate it with a compact constructor:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">record</code> <code class="nc">User</code><code class="p">(</code><code class="n">String</code> <code class="n">username</code><code class="p">,</code>
                   <code class="kt">boolean</code> <code class="n">active</code><code class="p">,</code>
                   <code class="n">Optional</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">group</code><code class="p">,</code>
                   <code class="n">LocalDateTime</code> <code class="n">lastLogin</code><code class="p">)</code> <code class="p">{</code>

  <code class="kd">public</code> <code class="n">User</code> <code class="p">{</code>
    <code class="n">Objects</code><code class="p">.</code><code class="na">requireNonNull</code><code class="p">(</code><code class="n">group</code><code class="p">,</code> <code class="s">"Optional&lt;String&gt; group must not be null"</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code></pre>
<p>The most apparent problem is averted by moving a possible <code>NullPointerException</code> from using the component accessor to the moment of creating the Record itself, making it safer to use.</p>
</div></section>
<section data-pdf-bookmark="Add Convenience Constructors" data-type="sect3"><div class="sect3" id="idm45115240749136">
<h3>Add Convenience Constructors</h3>
<p>The second thing to make Records safer and more convenient to use is providing additional constructors with non-optional arguments and creating the container type yourself:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">record</code> <code class="nc">User</code><code class="p">(</code><code class="n">String</code> <code class="n">username</code><code class="p">,</code>
                   <code class="kt">boolean</code> <code class="n">active</code><code class="p">,</code>
                   <code class="n">Optional</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">group</code><code class="p">,</code>
                   <code class="n">LocalDateTime</code> <code class="n">lastLogin</code><code class="p">)</code> <code class="p">{</code>

  <code class="kd">public</code> <code class="nf">User</code><code class="p">(</code><code class="n">String</code> <code class="n">username</code><code class="p">,</code>
              <code class="kt">boolean</code> <code class="n">active</code><code class="p">,</code>
              <code class="n">String</code> <code class="n">group</code><code class="p">,</code>
              <code class="n">LocalDateTime</code> <code class="n">lastLogin</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">(</code><code class="n">username</code><code class="p">,</code>
         <code class="n">active</code><code class="p">,</code>
         <code class="n">Optional</code><code class="p">.</code><code class="na">ofNullable</code><code class="p">(</code><code class="n">group</code><code class="p">),</code>
         <code class="n">lastLogin</code><code class="p">);</code>
  <code class="p">}</code>

  <code class="c1">// ...</code>
<code class="p">}</code></pre>
<p>Code completion will show both constructors, indicating the optionality of the <code>group</code> component.</p>
<p>The combination of validation at Record creations and a convenience constructor gives flexibility to the creator of a Record and safer use to anyone consuming it.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Serializing Evolving Records" data-type="sect2"><div class="sect2" id="_02-data-structures_records_evolution">
<h2>Serializing Evolving Records</h2>
<p>Records, like classes, are automatically serializable if they implement the empty marker interface <code>java.io.Serializable</code>.
The serialization process of Records follows a more flexible and safer serialization strategy compared to classes, though, without requiring any additional code.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The full serialization process consists of <em>serialization</em> (converting an object to a byte stream) and <em>deserialization</em> (reading an object from a byte stream).
If not explicitly mentioned, serialization describes the whole process, not only the first aspect.</p>
</div>
<p>Serialization of ordinary, non-Record objects relies heavily on costly<sup><a data-type="noteref" href="ch05.xhtml#idm45115240641328" id="idm45115240641328-marker">8</a></sup> reflection to access their private state.
This process is customizable by implementing the <code>private</code> methods <code>readObject</code> and <code>writeObject</code> in a type.
These two methods aren’t provided by any interface but are still part of the <a href="https://docs.oracle.com/en/java/javase/17/docs/specs/serialization/serial-arch.xhtml">Java Object Serialization Specification</a>.
They’re hard to get right and have led to many exploits in the past<sup><a data-type="noteref" href="ch05.xhtml#idm45115240638480" id="idm45115240638480-marker">9</a></sup>.</p>
<p>Records are only defined by their immutable state, represented by their components.
Without any code being able to affect the state after creation, the serialization process is quite simple:</p>
<ul>
<li>
<p>Serialization is based solely on the Record’s components.</p>
</li>
<li>
<p>Deserialization only requires the canonical constructor, not reflection.</p>
</li>
</ul>
<p>Once the JVM derives the serialized form of a Record, a matching instantiator can be cached.
Customizing that process isn’t possible, which actually leads to a safer serialization process by giving the JVM back control of the Record’s serialized representation.
This allows any Record type to evolve further by adding new components and still successfully deserializing from previously serialized data.
Any unknown component encountered during deserialization without a value present will automatically use its <em>default value</em> (e.g., <code>null</code> for object-based types, <code>false</code> for <code>boolean</code>, etc.).</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Be aware that the code examples for serialization won’t work as expected when using JShell.
The internal class names won’t be identical after replacing the Record definition, so the types won’t match.</p>
</div>
<p>Let’s say you have a two-dimensional <code>record Point(float x, float y)</code> that you want to serialize.
The following code doesn’t hold any surprises:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">record</code> <code class="nc">Point</code><code class="p">(</code><code class="kt">int</code> <code class="n">x</code><code class="p">,</code> <code class="kt">int</code> <code class="n">y</code><code class="p">)</code> <code class="kd">implements</code> <code class="n">Serializable</code> <code class="p">{</code>
  <code class="c1">// NO BODY</code>
<code class="p">}</code>

<code class="kd">var</code> <code class="n">point</code> <code class="o">=</code> <code class="k">new</code> <code class="n">Point</code><code class="p">(</code><code class="mi">23</code><code class="p">,</code> <code class="mi">42</code><code class="p">);</code>
<code class="c1">// =&gt; Point[x=23, y=42]</code>

<code class="k">try</code> <code class="p">(</code><code class="kd">var</code> <code class="n">out</code> <code class="o">=</code> <code class="k">new</code> <code class="n">ObjectOutputStream</code><code class="p">(</code><code class="k">new</code> <code class="n">FileOutputStream</code><code class="p">(</code><code class="s">"point.data"</code><code class="p">)))</code> <code class="p">{</code>
  <code class="n">out</code><code class="p">.</code><code class="na">writeObject</code><code class="p">(</code><code class="n">point</code><code class="p">);</code>
<code class="p">}</code></pre>
<p>As requirements change, you need to include the third dimension to the Record, <code>z</code>, as shown in the following code.</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">record</code> <code class="nc">Point</code><code class="p">(</code><code class="kt">int</code> <code class="n">x</code><code class="p">,</code> <code class="kt">int</code> <code class="n">y</code><code class="p">,</code> <code class="kt">int</code> <code class="n">z</code><code class="p">)</code> <code class="kd">implements</code> <code class="n">Serializable</code> <code class="p">{</code>
  <code class="c1">// NO BODY</code>
<code class="p">}</code></pre>
<p>What will happen if you try to deserialize the <code>point.data</code> file into the changed Record?
Let’s find out!</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">var</code> <code class="n">in</code> <code class="o">=</code> <code class="k">new</code> <code class="n">ObjectInputStream</code><code class="p">(</code><code class="k">new</code> <code class="n">FileInputStream</code><code class="p">(</code><code class="s">"point.data"</code><code class="p">));</code>

<code class="kd">var</code> <code class="n">point</code> <code class="o">=</code> <code class="n">in</code><code class="p">.</code><code class="na">readObject</code><code class="p">();</code>
<code class="c1">// =&gt; Point[x=23, y=42, z=0]</code></pre>
<p>It just works.</p>
<p>The new component, that’s missing from the serialized representation in <code>points.data</code> and therefore can’t provide a value for the Record’s canonical constructor, is initialized with the corresponding default value for its type, in this case, <code>0</code> (zero) for an <code>int</code>.</p>
<p>As mentioned in <a data-type="xref" href="ch04.xhtml#_02-data-structures_records">“Records”</a>, Records are effectively nominal tuples, making them solely based on their components’ names and types, not their exact order.
That’s why even changing the components’ order won’t break its deserialization capabilities.</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">record</code> <code class="nc">Point</code><code class="p">(</code><code class="kt">int</code> <code class="n">z</code><code class="p">,</code> <code class="kt">int</code> <code class="n">y</code><code class="p">,</code> <code class="kt">int</code> <code class="n">x</code><code class="p">)</code> <code class="kd">implements</code> <code class="n">Serializable</code> <code class="p">{</code>
  <code class="c1">// NO BODY</code>
<code class="p">}</code>

<code class="kd">var</code> <code class="n">in</code> <code class="o">=</code> <code class="k">new</code> <code class="n">ObjectInputStream</code><code class="p">(</code><code class="k">new</code> <code class="n">FileInputStream</code><code class="p">(</code><code class="s">"point.data"</code><code class="p">));</code>

<code class="kd">var</code> <code class="n">point</code> <code class="o">=</code> <code class="n">in</code><code class="p">.</code><code class="na">readObject</code><code class="p">();</code>
<code class="c1">// =&gt; Point[z=0, y=42, x=23]</code></pre>
<p>Removing components is also possible, as any missing component is ignored during deserialization.</p>
<p>One general caveat exists, though.</p>
<p>From the viewpoint of a single Record, they’re solely defined by their components.
For the Java serialization process, though, the type of what’s serialized is relevant, too.
That’s why even if two Records have identical components, they’re not interchangeable.
You will encounter a <code>ClassCastException</code> if you try to deserialize into another type with identical components:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">record</code> <code class="nc">Point</code><code class="p">(</code><code class="kt">int</code> <code class="n">x</code><code class="p">,</code> <code class="kt">int</code> <code class="n">y</code><code class="p">)</code> <code class="kd">implements</code> <code class="n">Serializable</code> <code class="p">{</code>
  <code class="c1">// NO BODY</code>
<code class="p">}</code>

<code class="k">try</code> <code class="p">(</code><code class="kd">var</code> <code class="n">out</code> <code class="o">=</code> <code class="k">new</code> <code class="n">ObjectOutputStream</code><code class="p">(</code><code class="k">new</code> <code class="n">FileOutputStream</code><code class="p">(</code><code class="s">"point.data"</code><code class="p">)))</code> <code class="p">{</code>
  <code class="n">out</code><code class="p">.</code><code class="na">writeObject</code><code class="p">(</code><code class="k">new</code> <code class="n">Point</code><code class="p">(</code><code class="mi">23</code><code class="p">,</code> <code class="mi">42</code><code class="p">));</code>
<code class="p">}</code>

<code class="kd">public</code> <code class="kd">record</code> <code class="nc">IdenticalPoint</code><code class="p">(</code><code class="kt">int</code> <code class="n">x</code><code class="p">,</code> <code class="kt">int</code> <code class="n">y</code><code class="p">)</code> <code class="kd">implements</code> <code class="n">Serializable</code> <code class="p">{</code>
  <code class="c1">// NO BODY</code>
<code class="p">}</code>

<code class="kd">var</code> <code class="n">in</code> <code class="o">=</code> <code class="k">new</code> <code class="n">ObjectInputStream</code><code class="p">(</code><code class="k">new</code> <code class="n">FileInputStream</code><code class="p">(</code><code class="s">"point.data"</code><code class="p">));</code>
<code class="n">IdenticalPoint</code> <code class="n">point</code> <code class="o">=</code> <code class="n">in</code><code class="p">.</code><code class="na">readObject</code><code class="p">();</code>
<code class="c1">// Error:</code>
<code class="c1">// incompatible types: java.lang.Object cannot be converted to IdenticalPoint</code></pre>
<p>The incompatibility of serializing different types with identical components is a side-effect of the “simpler but safer” serialization process used by Records.
Without the possibility of manually affecting the serialization process like in traditional Java objects, you might need to migrate already serialized data.
The most straightforward approach would be deserializing the old data into the old type, converting it to the new type, and serializing it as the new type.</p>
</div></section>
<section data-pdf-bookmark="Record Pattern Matching (Java 19+)" data-type="sect2"><div class="sect2" id="idm45115240645856">
<h2>Record Pattern Matching (Java 19+)</h2>
<p>Even though this book is targeted at Java 11 while trying to be helpful with a few newer additions, I want to tell you about an upcoming feature still in development at the time of writing: <em>Record-based pattern matching</em> (<a href="https://openjdk.java.net/jeps/405">JEP 405</a>).</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>JDK preview features are new features of the Java language, JVM, or the Java API that are fully specified, implemented, and yet impermanent.
The general idea is to gather feedback on real-world use so that the feature might become permanent in a future release.</p>
</div>
<p>Java 16 introduced pattern matching for the <code>instanceof</code> operator<sup><a data-type="noteref" href="ch05.xhtml#idm45115240119152" id="idm45115240119152-marker">10</a></sup>, removing the necessity of a cast after using the operator:</p>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// PREVIOUSLY</code>

<code class="k">if</code> <code class="p">(</code><code class="n">obj</code> <code class="k">instanceof</code> <code class="n">String</code><code class="p">)</code> <code class="p">{</code>
  <code class="n">String</code> <code class="n">str</code> <code class="o">=</code> <code class="p">(</code><code class="n">String</code><code class="p">)</code> <code class="n">obj</code><code class="p">;</code>
  <code class="c1">// ...</code>
<code class="p">}</code>

<code class="c1">// JAVA 16+</code>

<code class="k">if</code> <code class="p">(</code><code class="n">obj</code> <code class="k">instanceof</code> <code class="n">String</code> <code class="n">str</code><code class="p">)</code> <code class="p">{</code>
    <code class="c1">// ...</code>
<code class="p">}</code></pre>
<p>Java 17 and 18 expanded on the idea by enabling pattern matching for the <code>switch</code> expressions<sup><a data-type="noteref" href="ch05.xhtml#idm45115240034992" id="idm45115240034992-marker">11</a></sup> as a preview feature:</p>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// WITHOUT SWITCH PATTERN MACTHING</code>

<code class="n">String</code> <code class="n">formatted</code> <code class="o">=</code> <code class="s">"unknown"</code><code class="p">;</code>
<code class="k">if</code> <code class="p">(</code><code class="n">obj</code> <code class="k">instanceof</code> <code class="n">Integer</code> <code class="n">i</code><code class="p">)</code> <code class="p">{</code>
  <code class="n">formatted</code> <code class="o">=</code> <code class="n">String</code><code class="p">.</code><code class="na">format</code><code class="p">(</code><code class="s">"int %d"</code><code class="p">,</code> <code class="n">i</code><code class="p">);</code>
<code class="p">}</code> <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="n">obj</code> <code class="k">instanceof</code> <code class="n">Long</code> <code class="n">l</code><code class="p">)</code> <code class="p">{</code>
  <code class="n">formatted</code> <code class="o">=</code> <code class="n">String</code><code class="p">.</code><code class="na">format</code><code class="p">(</code><code class="s">"long %d"</code><code class="p">,</code> <code class="n">l</code><code class="p">);</code>
<code class="p">}</code> <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="n">obj</code> <code class="k">instanceof</code> <code class="n">String</code> <code class="n">str</code><code class="p">)</code> <code class="p">{</code>
  <code class="n">formatted</code> <code class="o">=</code> <code class="n">String</code><code class="p">.</code><code class="na">format</code><code class="p">(</code><code class="s">"String %s"</code><code class="p">,</code> <code class="n">str</code><code class="p">);</code>
<code class="p">}</code>

<code class="c1">// WITH SWITCH PATTERN MATCHING</code>

<code class="n">String</code> <code class="n">formatted</code> <code class="o">=</code> <code class="k">switch</code> <code class="p">(</code><code class="n">obj</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">case</code> <code class="n">Integer</code> <code class="n">i</code> <code class="o">-&gt;</code> <code class="n">String</code><code class="p">.</code><code class="na">format</code><code class="p">(</code><code class="s">"int %d"</code><code class="p">,</code> <code class="n">i</code><code class="p">);</code>
  <code class="k">case</code> <code class="n">Long</code> <code class="n">l</code>    <code class="o">-&gt;</code> <code class="n">String</code><code class="p">.</code><code class="na">format</code><code class="p">(</code><code class="s">"long %d"</code><code class="p">,</code> <code class="n">l</code><code class="p">);</code>
  <code class="k">case</code> <code class="n">String</code> <code class="n">s</code>  <code class="o">-&gt;</code> <code class="n">String</code><code class="p">.</code><code class="na">format</code><code class="p">(</code><code class="s">"String %s"</code><code class="p">,</code> <code class="n">s</code><code class="p">);</code>
  <code class="k">default</code>        <code class="o">-&gt;</code> <code class="s">"unknown"</code><code class="p">;</code>
<code class="p">};</code></pre>
<p>Java 19+ includes both these features for Records, too, including destructuring<sup><a data-type="noteref" href="ch05.xhtml#idm45115239984864" id="idm45115239984864-marker">12</a></sup>, which means a Record’s components are directly available as variables in the scope:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">record</code> <code class="nc">Point</code><code class="p">(</code><code class="kt">int</code> <code class="n">x</code><code class="p">,</code> <code class="kt">int</code> <code class="n">y</code><code class="p">)</code> <code class="p">{</code>
  <code class="c1">// NO BODY</code>
<code class="p">};</code>

<code class="kd">var</code> <code class="n">point</code> <code class="o">=</code> <code class="k">new</code> <code class="n">Point</code><code class="p">(</code><code class="mi">23</code><code class="p">,</code> <code class="mi">42</code><code class="p">);</code>

<code class="k">if</code> <code class="p">(</code><code class="n">point</code> <code class="k">instanceof</code> <code class="nf">Point</code><code class="p">(</code><code class="kt">int</code> <code class="n">x</code><code class="p">,</code> <code class="kt">int</code> <code class="n">y</code><code class="p">))</code> <code class="p">{</code>
  <code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">x</code> <code class="o">+</code> <code class="n">y</code><code class="p">);</code>
  <code class="c1">// =&gt; 65</code>
<code class="p">}</code>

<code class="kt">int</code> <code class="n">result</code> <code class="o">=</code> <code class="k">switch</code> <code class="p">(</code><code class="n">anyObject</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">case</code> <code class="n">Point</code><code class="p">(</code><code class="kd">var</code> <code class="n">x</code><code class="p">,</code> <code class="kd">var</code> <code class="n">y</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="n">x</code> <code class="o">+</code> <code class="n">y</code><code class="p">;</code>
  <code class="k">case</code> <code class="n">Point3D</code><code class="p">(</code><code class="kd">var</code> <code class="n">x</code><code class="p">,</code> <code class="kd">var</code> <code class="n">y</code><code class="p">,</code> <code class="kd">var</code> <code class="n">z</code><code class="p">)</code> <code class="o">-&gt;</code> <code class="n">x</code> <code class="o">+</code> <code class="n">y</code> <code class="o">+</code> <code class="n">z</code><code class="p">;</code>
  <code class="k">default</code> <code class="o">-&gt;</code> <code class="mf">0.0</code><code class="p">;</code>
<code class="p">};</code></pre>
<p>As you can see, Records are still evolving with exciting new features like pattern matching improving their feature set, making it a more versatile and flexible data aggregator type that simplifies your code.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Final Thoughts on Records" data-type="sect1"><div class="sect1" id="idm45115240209280">
<h1>Final Thoughts on Records</h1>
<p>Java’s new data aggregator type, Records, provides a great deal of simplicity with as little code as possible.
It’s achieved by adhering to specific rules and restrictions, which might seem arbitrary and confining initially, but it gives you safer and more consistent use.
Records aren’t supposed to be a “one-size-fits-all” solution for data storage and state to completely replace all POJOs or other pre-existing data-aggregator types.
They’re merely providing a new option fitting for a more functional and immutable approach.</p>
<p>The available feature set was chosen deliberately to create a new type of state representation, and <em>only</em> state.
The simplicity of defining a new Record discourages the reuse of an abstraction type just because it might be more convenient than creating a new and more fitting one.</p>
<p>Records might not be as flexible as POJOs or custom types.
But flexibility usually means more complexity, which often increases bug surface.
The best way to deal with complexity is to reduce its surface as much as possible, and Records give you a lot of safe functionality “for free” and won’t break as easily if their components evolve.</p>
</div></section>
<section data-pdf-bookmark="Takeaways" data-type="sect1"><div class="sect1" id="idm45115239584016">
<h1>Takeaways</h1>
<ul>
<li>
<p>Records are transparent data aggregator types solely defined by their components.</p>
</li>
<li>
<p>Most features you’re used to from classes, like implementing interfaces, generics, or annotations, are usable with Records, too.</p>
</li>
<li>
<p>The typical boilerplate for a canonical constructor, component accessors, object identity, and object description is available in any Record type without additional code.
If necessary, you can override each one of them.</p>
</li>
<li>
<p>Records have certain restrictions to ensure their safe and simplistic use.
Many of the missing features — at least compared to more flexible solutions like POJOs or JavaBeans — can be retrofitted with either JDK-only code or tools like annotation processing.</p>
</li>
<li>
<p>Adhering to common practices like validation and a systematic approach to modified copies creates a consistent user experience.</p>
</li>
<li>
<p>Records provide a safer and more flexible serialization solution than their class-based brethren.</p>
</li>
</ul>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="idm45115246956000"><sup><a href="ch05.xhtml#idm45115246956000-marker">1</a></sup> A JDK preview feature is a feature whose design, specification, and implementation are complete, but is not permanent. It’s supposed to gather feedback from the community to evolve further. Such a feature may exist in a different form or not at all in future releases.</p><p data-type="footnote" id="idm45115245303760"><sup><a href="ch05.xhtml#idm45115245303760-marker">2</a></sup> See the Java Language Specification <a href="https://docs.oracle.com/javase/specs/jls/se16/html/jls-3.xhtml#jls-3.8">chapter 3.8</a> for the definition of valid Java identifier.</p><p data-type="footnote" id="idm45115245005648"><sup><a href="ch05.xhtml#idm45115245005648-marker">3</a></sup> The word “automagically” describes an automatic process that’s hidden from the user and therefore magic-like. Records provide their automatic features without additional tools like annotation processors or extra compiler plugins.</p><p data-type="footnote" id="idm45115244379264"><sup><a href="ch05.xhtml#idm45115244379264-marker">4</a></sup> To learn more about annotations in general and how to use them, you should check out my article <a href="https://belief-driven-design.com/4f54e6e6c3f/">Java Annotations Explained</a>.</p><p data-type="footnote" id="idm45115243333328"><sup><a href="ch05.xhtml#idm45115243333328-marker">5</a></sup> Gamma, E., Helm, R., Johnson, R., &amp; Vlissides, J. (1994). Design patterns: Elements of reusable object-oriented software. Addison Wesley.</p><p data-type="footnote" id="idm45115243331312"><sup><a href="ch05.xhtml#idm45115243331312-marker">6</a></sup> The <em>single responsibility principle</em> is the first of the <em>SOLID</em> principles for object-oriented programming. Its five principles intend to make OO designs more flexible, maintainable, and straightforward.</p><p data-type="footnote" id="idm45115241795328"><sup><a href="ch05.xhtml#idm45115241795328-marker">7</a></sup> I’ve written an article about how to evaluate dependenices on my <a href="https://belief-driven-design.com/e3e769e891b/">personal blog</a>.</p><p data-type="footnote" id="idm45115240641328"><sup><a href="ch05.xhtml#idm45115240641328-marker">8</a></sup> The word “cost” regarding reflection is associated with the incurred performance overhead and exposure to security problems. Reflection uses dynamically resolved type information, which prevents the JVM to utilize all its possible optimizations. Consequently, reflection has slower performance than their non-reflective counterparts.</p><p data-type="footnote" id="idm45115240638480"><sup><a href="ch05.xhtml#idm45115240638480-marker">9</a></sup> The method <code>readObject</code> can execute arbitrary code instead of simply reading the object. Some related CVEs: <a href="https://nvd.nist.gov/vuln/detail/CVE-2019-6503">CVE-2019-6503</a>, <a href="https://nvd.nist.gov/vuln/detail/CVE-2019-12630">CVE-2019-12630</a>, <a href="https://nvd.nist.gov/vuln/detail/CVE-2018-1851">CVE-2018-1851</a>.</p><p data-type="footnote" id="idm45115240119152"><sup><a href="ch05.xhtml#idm45115240119152-marker">10</a></sup> The extension of the <code>instanceof</code> operator to support <em>pattern matching</em> is summarized in <a href="https://openjdk.java.net/jeps/394">JEP 394</a>.</p><p data-type="footnote" id="idm45115240034992"><sup><a href="ch05.xhtml#idm45115240034992-marker">11</a></sup> Pattern Matching for <code>switch</code> is summarized in <a href="https://openjdk.java.net/jeps/406">JEP 406</a> and <a href="https://openjdk.java.net/jeps/420">JEP 430</a>.</p><p data-type="footnote" id="idm45115239984864"><sup><a href="ch05.xhtml#idm45115239984864-marker">12</a></sup> Pattern Matching for Records is summarized in <a href="https://openjdk.java.net/jeps/405">JEP 405</a></p></div></div></section></div></body></html>