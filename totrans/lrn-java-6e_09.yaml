- en: Chapter 9\. Threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We take for granted that modern computer systems can manage many applications
    and operating system (OS) tasks running concurrently and make it appear that all
    the software is running simultaneously. Most systems today have multiple processors
    or multiple cores or both, and they can achieve an impressive degree of concurrency.
    The OS still juggles applications at a higher level but turns its attention from
    one to the next so quickly that they also appear to run at once.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In programming, *concurrent* operation denotes multiple, typically unrelated
    tasks running at the same time. Think of a fast-food cook preparing multiple orders
    on a grill. *Parallel* operation usually involves breaking up a large task into
    related subtasks that can be run alongside each other to produce the final result
    more quickly. Our cook could prepare a bacon double cheeseburger “in parallel”
    by tossing two patties and some bacon on the grill at the same time. In either
    case, programmers talk more generally about these tasks and subtasks occurring
    *simultaneously*. That’s not to say everything starts and stops at the same exact
    instant, but it does mean that the execution times for those tasks overlap.
  prefs: []
  type: TYPE_NORMAL
- en: In the old days, the unit of concurrency for an operating system was the application
    or *process*. To the OS, a process was more or less a black box that decided what
    to do on its own. If an application required greater concurrency, it could get
    it only by running multiple processes and communicating between them, but this
    was a heavyweight approach and not very elegant.
  prefs: []
  type: TYPE_NORMAL
- en: Later, operating systems added the concept of threads. Conceptually, a *thread*
    is a flow of control within a program. (You may have heard of a “thread of execution,”
    for example.) Threads provide fine-grained concurrency within a process under
    the application’s own control. Threads have existed for a long time but have historically
    been tricky to use. The Java concurrency utilities address common patterns and
    practices in multithreaded applications and raise them to the level of tangible
    methods and classes. Collectively, this means that Java supports threading at
    both higher and lower levels.
  prefs: []
  type: TYPE_NORMAL
- en: This broad support makes it easier for programmers to write multithreaded code,
    and for compilers and runtimes to optimize that code. It also means that Java’s
    APIs take full advantage of threading, so it’s important that you gain some degree
    of familiarity with these concepts early in your exploration of Java. Not all
    developers will need to write applications that explicitly use threads or concurrency,
    but most will use some feature that involves them.
  prefs: []
  type: TYPE_NORMAL
- en: Threads are integral to the design of many Java APIs, especially those involved
    in client-side applications, graphics, and sound. For example, when we look at
    GUI programming in [Chapter 12](ch12.html#learnjava6-CHP-12), you’ll see that
    a component’s `paint()` method isn’t called directly by the application but rather
    by a separate drawing thread within the Java runtime system. At any given time,
    many such background threads may be performing activities alongside your application—yet
    you still get timely updates to your screen. On the server side, Java threads
    are there as well, servicing every request and running your application. It’s
    important to understand how your code fits into that environment.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll talk about writing applications that create and use their
    own threads explicitly. We’ll talk about the low-level thread support built into
    the Java language first and then discuss the `java.util.concurrent` thread utilities
    package. We’ll also tackle the new virtual threads previewed in Java 19 under
    the moniker of Project Loom.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A thread is similar to the notion of a *process*, or running program, except
    that different threads within the same application are much more closely related
    and share much of the same state than different programs running on the same machine.
    It’s kind of like a golf course that many golfers use at the same time. The threads
    cooperate to share a working area. They take turns and wait for other threads.
    They have access to the same objects, including static and instance variables,
    within their application. However, threads have their own copies of local variables,
    just as players share the golf course or a golf cart but do not share clubs or
    balls.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple threads in an application have the same problems as golfers on a course—in
    a word, *synchronization*. Just as you can’t have two sets of players playing
    the same green at the same time, you can’t have several threads trying to access
    the same variables without some kind of coordination. Otherwise, someone is bound
    to get hurt. A thread can reserve the right to use an object until it’s finished
    with its task, just as a golf party gets exclusive rights to the green until each
    of that party’s players finishes. And a thread that is more important can raise
    its priority, asserting its right to “play through.”
  prefs: []
  type: TYPE_NORMAL
- en: The devil is in the details, of course, and those details have long made threads
    difficult to use. Fortunately, Java makes creating, controlling, and coordinating
    threads simpler by integrating some of these concepts directly into the language.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common to stumble over threads when you first work with them. Creating
    a thread will exercise many of your new Java skills all at once. Just remember
    that two players are always involved in running a thread: a Java `Thread` object
    that represents the thread itself, and an arbitrary target object that contains
    the method the thread will execute. Later, we will see ways to combine these two
    roles, but those approaches just change the packaging, not the relationship.'
  prefs: []
  type: TYPE_NORMAL
- en: The Thread Class and the Runnable Interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All execution in Java is associated with a `Thread` object, beginning with a
    “main” thread that the JVM starts to launch your application. A new thread is
    born when you create an instance of the `java.lang.Thread` class. The `Thread`
    object represents a real thread in the Java interpreter and serves as a handle
    for controlling and coordinating its execution. With it, you can start the thread,
    wait for it to complete, cause it to sleep for a time, or interrupt its activity.
  prefs: []
  type: TYPE_NORMAL
- en: The constructor for the `Thread` class accepts information about where the thread
    should begin its execution. We would like to tell it what method to run. There
    are a number of ways to do this. The classic approach uses the `java.lang.Runnable`
    interface to mark an object that contains a “runnable” method.
  prefs: []
  type: TYPE_NORMAL
- en: '`Runnable` defines a single, general-purpose `run()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Every thread begins its life by executing the `run()` method in a `Runnable`
    object, which is the “target object” passed to the thread’s constructor. The `run()`
    method can contain any code, but it must be public, take no arguments, have no
    return value, and throw no checked exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Any class that contains an appropriate `run()` method can declare that it implements
    the `Runnable` interface. An instance of this class becomes a runnable object
    that can serve as the target of a new thread. If you don’t want to put the `run()`
    method directly in your object (and very often you don’t), you can always make
    an adapter class that serves as the `Runnable` for you. The adapter’s `run()`
    method can then call any method it wants after the thread is started. We’ll show
    examples of these options later.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and starting threads
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A newly born thread remains idle until we give it a figurative slap on the bottom
    by calling its `start()` method. The thread then wakes up and proceeds to execute
    the `run()` method of its target object. `start()` can be called only once in
    the lifetime of a thread. Once a thread starts, it continues running until the
    target object’s `run()` method either returns or throws an unchecked exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following class, `Animator`, implements a `run()` method to drive a drawing
    loop. We could use something similar in our game to update the playing `Field`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To use it, create a `Thread` object, pass it an instance of `Animator` as its
    target object, and invoke its `start()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We created an instance of our `Animator` class and passed it as the argument
    to the constructor for `myThread`. As shown in [Figure 9-1](#learnjava6-CHP-9-FIG-1),
    when we call the `start()` method, `myThread` begins to execute `Animator`’s `run()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 0901](assets/ljv6_0901.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-1\. Animator as an implementation of `Runnable`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Let the show begin!
  prefs: []
  type: TYPE_NORMAL
- en: A natural-born thread
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Runnable` interface lets you make an arbitrary object the target of a thread,
    as in the previous example. This is the most important general usage of the `Thread`
    class. In most situations where you need to use threads, you’ll create a class
    (possibly a simple adapter class) that implements the `Runnable` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another design option for creating a thread makes our target class a subclass
    of a type that is already runnable. As it turns out, the `Thread` class itself
    conveniently implements the `Runnable` interface; it has its own `run()` method,
    which we can override directly to do our bidding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The skeleton of our `Animator` class looks much the same as before, except that
    our class is now a subclass of `Thread`. To go along with this scheme, the default
    constructor of the `Thread` class makes itself the default target—that is, by
    default, the `Thread` executes its own `run()` method when we call the `start()`
    method, as shown in [Figure 9-2](#learnjava6-CHP-9-FIG-2). Now our subclass can
    just override the `run()` method in the `Thread` class. (`Thread` itself defines
    an empty `run()` method.)
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 0902](assets/ljv6_0902.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-2\. Animator as a subclass of `Thread`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Next, we create an instance of `Animator` and call its `start()` method (which
    it also inherited from `Thread`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Extending `Thread` may seem like a convenient way to bundle a thread and its
    target `run()` method. However, this approach often isn’t the best design. If
    you extend `Thread` to implement a thread, you are saying you need a new type
    of object that is a kind of `Thread`, which exposes all of the public methods
    of the `Thread` class. While there is something satisfying about taking an object
    that’s primarily concerned with performing a task and making it a `Thread`, the
    actual situations where you’ll want to create a subclass of `Thread` should not
    be very common. In most cases, it is more natural to let the requirements of your
    program dictate the class structure and use `Runnable`s to connect the execution
    and logic of your program.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling Threads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that you have seen the `start()` method used to begin executing a new thread,
    let’s look at instance methods that let you explicitly control a thread’s behavior
    at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Thread.sleep()` method'
  prefs: []
  type: TYPE_NORMAL
- en: Causes the currently executing thread to wait for a designated period of time
    (give or take), without consuming much (or possibly any) CPU time.
  prefs: []
  type: TYPE_NORMAL
- en: '`wait()` and `join()` methods'
  prefs: []
  type: TYPE_NORMAL
- en: Coordinate the execution of two or more threads. We’ll discuss them in detail
    when we talk about thread synchronization later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '`interrupt()` method'
  prefs: []
  type: TYPE_NORMAL
- en: Wakes up a thread that is sleeping in a `sleep()` or `wait()` operation or is
    otherwise blocked on a long I/O operation.^([1](ch09.html#id1771))
  prefs: []
  type: TYPE_NORMAL
- en: Deprecated methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We should also mention three deprecated thread-control methods: `stop()`, `suspend()`,
    and `resume()`. The `stop()` method complements `start()`; it destroys the thread.
    `start()` and the deprecated `stop()` method can be called only once in the thread’s
    life cycle. By contrast, the deprecated `suspend()` and `resume()` methods arbitrarily
    pause and then restart the execution of a thread.'
  prefs: []
  type: TYPE_NORMAL
- en: Although these deprecated methods still exist in the latest version of Java
    (and will probably be there forever), they shouldn’t be used in new code development.
    The problem with both `stop()` and `suspend()` is that they seize control of a
    thread’s execution in an uncoordinated, harsh way.
  prefs: []
  type: TYPE_NORMAL
- en: You can create and monitor a few variables as a better way to affect the execution
    of a thread (if these variables are `boolean`, you might see them referred to
    as “flags”). The early thread examples in this book use this technique in one
    way or another. Later examples will introduce some of the other control features
    available through the concurrency classes.
  prefs: []
  type: TYPE_NORMAL
- en: The sleep() method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Programmers often need to tell a thread to sit idle, or “sleep,” for some period
    of time. You may need to wait for some external resource to become available,
    for example. Even our simple animation threads takes small pauses between frames.
    While a thread is asleep, or otherwise blocked from input of some kind, it doesn’t
    consume CPU time or compete with other threads for processing. For such pauses,
    we can call the static method `Thread.sleep()`, which affects the currently executing
    thread. The call causes the thread to go idle for a specified number of milliseconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `sleep()` method may throw an `InterruptedException` if it is interrupted
    by another thread via the `interrupt()` method (more below). As you saw in the
    previous code, the thread can catch this exception and take the opportunity to
    perform some action—such as checking a variable to determine whether or not the
    thread should exit—and then go back to sleep.
  prefs: []
  type: TYPE_NORMAL
- en: The join(), wait(), and notify() methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you need to coordinate a thread’s activities by waiting for another thread
    to complete its task, you can use the `join()` method. Calling a thread’s `join()`
    method causes that thread to block until the target thread completes. Alternatively,
    you can call `join()` with a number of milliseconds to wait as an argument. In
    this form, the calling thread waits until either the target thread completes or
    the specified period elapses. This is a very coarse form of thread synchronization.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to coordinate a thread’s activities with some other resource, such
    as checking the state of a file or network connection, you can use the `wait()`
    and `notify()` methods. Calling `wait()` on a thread will pause it, similar to
    using `join()`, but it will remain paused either until it gets `interrupt()`-ed
    by some other thread, or until you call `notify()` on the thread yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Java supports more general and powerful mechanisms for coordinating thread activity
    in the `java.util.concurrent` package. We’ll show you more of this package later
    in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The interrupt() method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `interrupt()` method does more or less what it says on the tin. It interrupts
    the normal flow of execution for a thread. If that thread was idle in a `sleep()`,
    `wait()`, or lengthy I/O operation, it will wake up. When you interrupt a thread,
    its *interrupt status* flag is set. You can test this flag with the `isInterrupted()`
    method. You can also use an alternate form, `isInterrupted(boolean)`, to indicate
    whether or not you want the thread to clear its interrupt status after retrieving
    the current value.
  prefs: []
  type: TYPE_NORMAL
- en: While you probably won’t use `interrupt()` that often, it can definitely come
    in handy. If you have ever grown impatient while a desktop application tries—and
    fails—to connect to a server or database, you have experienced one of those moments
    where an interruption might be the right thing.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s simulate this scenario with a small graphical application. We’ll show
    a label on the screen and move it to a new, random location every five seconds.
    During that five-second pause, a click anywhere on the screen will interrupt the
    pause. We’ll change the message and then start the random move cycle again. You
    can run the full example from *ch09/examples/Interruption.java*, but [Figure 9-3](#learnjava6-CHP-9-FIG-interruption)
    highlights the flow and effect of calling `interrupt()`.
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 0903](assets/ljv6_0903.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-3\. Interrupting a thread
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Revisiting Animation with Threads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Managing animations is a common task in graphical interfaces. Sometimes the
    animations are subtle transitions; other times they are the focus of the application,
    as with our apple tossing game. We’ll look at two ways to handle the animation:
    using simple threads alongside the `sleep()` functions, and using a timer. Pairing
    one of those options with some type of stepping or “next frame” function is a
    popular approach that is also easy to understand.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use a thread similar to [“Creating and starting threads”](#learnjava6-CHP-9-SECT-1.1.1)
    to produce real animation. The basic idea is to paint or position all of your
    animated objects, pause, move them to their next spots, and then repeat. Let’s
    take a look at how we draw some pieces of our game field without animation first.
    We’ll include a new `List` for any active apples in addition to the existing lists
    for trees and hedges. You can pull up this code in your editor from the *ch09/examples/game*
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We start by painting the background field, then the trees and hedges, then our
    physicist, and finally any apples. Painting the apples last guarantees that they
    will show “on top” of the other elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'What changes on the screen as you play? There are really only two “moveable”
    items: the apple our physicist is aiming, and any apples actively flying after
    being tossed. The physicist aims in response to user input (by moving the mouse
    or clicking a button). That doesn’t require separate animation, so we’ll add this
    functionality in [Chapter 12](ch12.html#learnjava6-CHP-12). For now, we can concentrate
    on handling flying apples.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our game’s animation step should move every apple that is active, according
    to the rules of gravity. First, we add a `toss()` method to our `Apple` class
    where we can set up the initial conditions for our apple using information from
    our physicist. (Since the physicist is not yet interactive, we’ll fake some data.)
    Then we make one move for a given apple in the `step()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We start by calculating how fast the apple will move (the `velocityX` and `velocityY`
    variables) in the `toss()` method. In our `step()` method, we update the apple’s
    position based on those two velocities, then adjust the vertical velocity based
    on how strong our gravity is. It’s not very fancy, but it will produce a nice
    arc for the apples. We then put that code in a loop that will do the update calculations,
    repaint the field and apples, pause, and repeat:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this implementation of `Runnable` in a simple thread. Our `Field`
    class will keep an instance of the thread around and contains the following simple
    `start` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We’ll discuss events in [“Events”](ch12.html#learnjava6-CHP-12-SECT-3); you’ll
    use those events to launch an apple on command. For now, we’ll just launch one
    apple automatically, as shown in [Figure 9-4](#learnjava6-CHP-9-FIG-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 0904](assets/ljv6_0904.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-4\. Tossable apples in action
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It doesn’t look like much as a still screenshot, but it is amazing in person.
    ;^)
  prefs: []
  type: TYPE_NORMAL
- en: Death of a Thread
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All good things come to an end. A thread continues to execute until one of
    the following three things happens:'
  prefs: []
  type: TYPE_NORMAL
- en: It explicitly returns from its target `run()` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It encounters an uncaught runtime exception.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The nasty, deprecated `stop()` method is called.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What happens if none of these things occurs, and the `run()` method for a thread
    never terminates? The thread can live on, even after the code that created it
    has finished. You have to be aware of how threads eventually terminate, or your
    application can end up leaving orphaned threads running that consume resources
    unnecessarily, or even keep the application alive when it would otherwise quit.
  prefs: []
  type: TYPE_NORMAL
- en: In many cases, you want background threads that do simple, periodic tasks in
    an application. You can create one of these background workers using the `setDaemon()`
    method to mark a thread as a *daemon* thread. Daemon threads can terminate like
    other threads, but if the application that started them is quitting, they should
    be killed and discarded when no other nondaemon application threads remain.^([2](ch09.html#id1793))
    Normally, the Java interpreter continues to run until all threads have completed.
    But when daemon threads are the only threads still alive, the interpreter will
    exit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a “devilish” outline using daemon threads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `Devil` thread sets its daemon status when it is created.
    If any `Devil` threads remain when our application is otherwise complete, the
    runtime system terminates them for us. We don’t have to worry about cleaning them
    up.
  prefs: []
  type: TYPE_NORMAL
- en: 'One final note about killing threads gracefully. New developers often encounter
    a common problem the first time they create an application using a graphical Swing
    component: their application never exits. The Java VM seems to hang indefinitely
    after everything is finished and the application window is closed. Java creates
    a UI thread to process input and painting events. This UI thread is not a daemon
    thread, so it doesn’t exit automatically when other application threads have completed.
    The developer must call `System.exit()` explicitly. If you think about it, this
    makes sense. Because most GUI applications are event-driven and wait for user
    input, they would otherwise exit after their startup code completes.'
  prefs: []
  type: TYPE_NORMAL
- en: Virtual Threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previewed in Java 19 and finalized in Java 21, Project Loom^([3](ch09.html#id1797))
    brings lightweight, virtual threads to Java. One of the main goals of Project
    Loom is to improve the thread ecosystem in Java so that developers can put less
    energy into keeping multithreaded applications stable and more energy into solving
    higher-level problems.
  prefs: []
  type: TYPE_NORMAL
- en: Preview Feature Tangent
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What do we mean by “previewed in Java 19”? Starting with Java 12, Oracle began
    introducing some language features as *previews*. These preview features are well-specified
    and fully implemented but not wholly baked. Oracle may still make substantial
    modifications in future releases. Eventually, these features will either become
    permanent parts of the JDK or they will be removed. Oracle produces a language
    update page for each new release of Java that contains a nice history of recent
    changes to the language as well as an [overview of preview features](https://oreil.ly/5MuMw)
    in general.
  prefs: []
  type: TYPE_NORMAL
- en: Because any given preview feature may end up being dropped from Java, Oracle
    requires you to include special flags when you compile or run an application that
    uses it. This requirement is a small guardrail to make sure you don’t accidentally
    use code that may not work with a future release of Java.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring IDEs for preview features
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you use an IDE for the demos and exercises, you may need to configure it
    to support preview features. IntelliJ IDEA, for example, does not support preview
    features by default. You need to change a setting in the File → Project Structure
    dialog, as shown in [Figure 9-5](#learnjava6-CHP-9-FIG-idea-preview).
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 0905](assets/ljv6_0905.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-5\. Enabling Java’s preview features in IntelliJ IDEA
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: After choosing the version of Java you want in the SDK drop-down, you can enable
    preview feature support by choosing the appropriate option under the Language
    level drop-down. (The features that IDEA lists next to the version numbers is
    not an exhaustive list.) Click OK after setting the language level, and IDEA should
    be ready to compile and run any code with preview features.
  prefs: []
  type: TYPE_NORMAL
- en: Renaming preview source files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `VirtualDemo` class (*ch09/examples/VirtualDemo.java.preview*) uses a virtual
    thread to pause briefly before issuing our favorite “Hello Java” greeting. Before
    you can compile or run it, you’ll need to rename it. We added the *.preview* suffix
    to any file that includes a preview feature in the code. The suffix stops IDEs
    like IntelliJ IDEA from proactively compiling them until you’ve had a chance to
    configure preview support, as we mentioned in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the context (right-click) menu in IntelliJ IDEA to rename the file
    under the Refactor menu item. You can also rename a file quickly from a terminal
    in Linux or macOS using the *mv* command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In a Windows terminal or command prompt, you can use the *rename* command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Compiling classes with preview features
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Oracle added a pair of command-line options for compiling code with preview
    features. If you try to compile our `VirtualDemo` source file with Java 19, for
    example, you’ll likely see an error similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The error gives us a hint as to how we should proceed. Let’s try adding the
    suggested flag and compiling again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Rats! Another, different error. At least it also includes some hints. To compile,
    you need to provide *two* flags: `--enable-preview` and then either `-source`
    or `--release`.^([4](ch09.html#id1810)) The compiler uses `-source` to specify
    which language rules apply to the source code being compiled. (The compiled bytecode
    is still targeted at the same version of Java as your JDK.) You can use the `--release`
    option to specify both the source version and the bytecode version.'
  prefs: []
  type: TYPE_NORMAL
- en: 'While there are many scenarios where you might need to compile for older systems,
    preview features are meant for use with the current version of the JDK. As such,
    when we use any preview features in the book, we’ll be pairing `--enable-preview`
    with `--release` and simply give the same release version as our version of Java.
    Returning to our virtual thread preview feature, for example, we can use Java
    19 to try it out. Our final, correct *javac* call looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The “notes” that appear after your compilation completes are purely informational.
    They remind you that your code relies on an unstable feature that may not be available
    in the future. The note is not meant to dissuade you from using these features,
    but if you are planning to share your code with other users or developers, you
    will have some extra compatibility contraints to remember.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re curious, you can use the `-Xlint:preview` option mentioned in the
    notes to see exactly what preview code caused the warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: No surprises there, but then again, this is just a tiny demo program. With larger
    programs or code developed in teams, that extra `-Xlint:preview` flag can be very
    handy.
  prefs: []
  type: TYPE_NORMAL
- en: Running preview class files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Running Java classes that include preview features also requires the `--enable-preview`
    flag. If you try to run `VirtualDemo` with Java 19 as you would any other class,
    you’ll get an error like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, you can use the flag mentioned in the error, `--enable-preview`, and
    you’re good to go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to play with a preview feature in *jshell*, you can also provide
    the same `--enable-preview` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Including that flag would allow a Java 19 *jshell* session to use virtual threads,
    just as it allowed us to run our demo program above.
  prefs: []
  type: TYPE_NORMAL
- en: A Quick Comparison
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Loom team designed its virtual threads to be easy to use if you already
    have some skill with Java threads. Let’s rework the trivial thread example that
    we used to test the `--enable-preview` flag to show both types of thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In this reworking, we expanded our anonymous `Runnable` inner class to do a
    little sleuthing on the current thread. We print out the thread’s identification
    number and whether or not it’s a virtual thread. But look how similar (and simple)
    the lines are that launch the two threads: they both accept our `runnable` object
    and “fit” in the `Thread` class. For developers with established code, switching
    to use these virtual threads should be straightforward. Here’s the output after
    compiling and running (with the appropriate preview flags, of course):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Both threads run as expected. One thread does indeed report itself as a virtual
    thread. We use the word *platform* to describe the other thread, since that’s
    what the Oracle documentation calls them. Platform threads represent a direct,
    one-to-one relationship with the *native* threads your operating system (the platform)
    provides. Virtual threads, on the other hand, have an indirect, many-to-one relationship
    with native threads from the operating system, as shown in [Figure 9-6](#learnjava6-CHP-9-FIG-loom-threads).
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 0906](assets/ljv6_0906.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-6\. Platform and virtual threads map differently to native threads
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This separation is one of the key design features of virtual threads. It allows
    Java to have many (many!) threads going at once without the performance costs
    of creating and managing corresponding native threads. Virtual threads are designed
    to be inexpensive to create and highly performant once they are up and running.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every thread has a mind of its own. Normally, a thread goes about its business
    without any regard for what other threads in the application are doing. Threads
    may be *time-sliced*, which means they can run in arbitrary spurts and bursts
    as directed by the OS. On a multiprocessor or multicore system, it is even possible
    for many different threads to be running simultaneously on different CPUs. This
    section is about coordinating the activities of two or more threads so that they
    can work together and use the same variables and methods (without colliding, like
    players on the golf course).
  prefs: []
  type: TYPE_NORMAL
- en: Java provides a few simple structures for synchronizing the activities of threads.
    They are all based on the concept of monitors, a widely used synchronization scheme.
    You don’t have to know the details about how monitors work to be able to use them,
    but it may help you to have [Figure 9-7](#learnjava6-CHP-9-FIG-thread-monitor)
    in mind.
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 0907](assets/ljv6_0907.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-7\. Synchronizing access with a monitor
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A *monitor* is essentially a lock. The lock is attached to a resource that many
    threads may need to access but that should be accessed by only one thread at a
    time. It’s very much like a restroom with a lock on the door; if it’s unlocked,
    you can enter, and you lock the door while you are using it. If the resource is
    not being used, a thread can acquire the lock and access the resource. When the
    thread is done, it relinquishes the lock, just as you unlock the restroom door
    and leave it open for the next person (or thread).
  prefs: []
  type: TYPE_NORMAL
- en: 'If another thread already has the lock for the resource, however, all other
    threads must wait until the current thread is done and releases the lock. This
    is just like when the restroom is occupied when you arrive: you have to wait until
    the current user is done and unlocks the door.'
  prefs: []
  type: TYPE_NORMAL
- en: Java makes it fairly easy to synchronize access to resources. The language handles
    setting up and acquiring locks; all you need to do is specify the resources to
    synchronize.
  prefs: []
  type: TYPE_NORMAL
- en: Serializing Access to Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most common reason to synchronize threads in Java is to serialize their
    access to a resource (like an object or variable)—in other words, to make sure
    that only one thread at a time can manipulate that object.^([5](ch09.html#id1818))
    In Java, every class and every instance of a class has its own lock. The `synchronized`
    keyword marks places where a thread must acquire the lock before proceeding.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose we implement a `SpeechSynthesizer` class that contains
    a `say()` method. We don’t want multiple threads calling `say()` at the same time
    because we wouldn’t be able to understand anything the synthesizer says. So we
    mark the `say()` method as `synchronized`, which means that a thread must acquire
    the lock on the `SpeechSynthesizer` object before it can speak:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: When `say()` has completed, the calling thread gives up the lock, which allows
    the next waiting thread to acquire the lock and run the method. It doesn’t matter
    whether the thread is owned by the `SpeechSynthesizer` itself or some other object;
    every thread must acquire the same lock from the `SpeechSynthesizer` instance.
    If `say()` were a class (static) method instead of an instance method, we could
    still mark it as `synchronized`. In this case, because no instance object is involved,
    the lock is on the `SpeechSynthesizer` class object itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, you want to synchronize multiple methods of the same class so that only
    one method modifies or examines the data in the class at a time. All static synchronized
    methods in a class use the same class-object lock. By the same token, all instance
    methods in a class use the same instance-object lock. This guarantees that only
    one of a set of synchronized methods is running at a time. For example, a `SpreadSheet`
    class might contain several instance variables that represent cell values, as
    well as some methods that manipulate all of the cells in a row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The methods `setRow()` and `sumRow()` both access the cell values. You can see
    that problems might arise if one thread was changing the values of the variables
    in `setRow()` at the same moment another thread was reading the values in `sumRow()`.
    To prevent this, we mark both methods as `synchronized`. When threads encounter
    synchronized resources, only one thread runs at a time. If a thread is in the
    middle of executing `setRow()` when another thread attempts to call `sumRow()`,
    the second thread must wait until the first one finishes executing `setRow()`
    before it runs `sumRow()`. This synchronization allows us to preserve the consistency
    of the `SpreadSheet`. The best part is that all this locking and waiting is handled
    by Java; it’s invisible to the programmer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to synchronizing entire methods, the `synchronized` keyword can
    be used in a special construct to guard smaller blocks of code inside a method.
    In this form, it also takes an explicit argument that specifies which object’s
    lock to acquire:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This synchronized block can appear in any method. When a thread reaches it,
    the thread must acquire the lock on `myObject` before proceeding. In this way,
    we can synchronize methods (or parts of methods) in different classes in the same
    way as methods in the same class.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that a synchronized instance method is equivalent to a method with
    its statements synchronized on the current object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We can demonstrate the basics of synchronization with a classic “producer/consumer”
    scenario. Say we have some producers creating new resources and consumers grabbing
    and using those same resources: for instance a series of web crawlers picking
    up images online. The “producer” in this could be a thread (or multiple threads)
    doing the actual work of loading and parsing web pages to look for images and
    their URLs. We can tell it to place those URLs in a common queue. The “consumer”
    thread(s) would pick up the next URL in the queue and download the image to the
    filesystem or a database. We won’t try to do all of the real I/O here (more on
    URLs and networking in [Chapter 13](ch13.html#learnjava6-CHP-13)), but let’s set
    up some producing and consuming threads to show you how the synchronization works.'
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing a queue of URLs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s look first at the queue where the URLs will be stored. It’s just a list
    where we can append URLs (as `String`s) to the end and pull them off from the
    front. We’ll use a `LinkedList` similar to the `ArrayList` we saw in [Chapter 7](ch07.html#learnjava6-CHP-7).
    We want a structure designed for efficient access and manipulation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note that not every method is synchronized! Any thread can ask if the queue
    is empty without holding up other threads that might be adding or removing items.
    This *does* mean that `isEmpty()` might report a wrong answer—if the timing of
    different threads is exactly wrong. Fortunately, our system is somewhat fault-tolerant,
    so the efficiency of not locking the queue just to check its size wins out over
    more perfect knowledge.^([6](ch09.html#id1823))
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know how we’ll be storing and retrieving the URLs, we can create
    the producer and consumer classes. The producer will run a loop to simulate a
    web crawler by making up fake URLs. It will prefix those URLs with a producer
    ID, and then store them in our queue. Here’s the `run()` method for `URLProducer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The consumer class is similar, with the obvious exception of taking URLs out
    of the queue. It will pull a URL out, prefix it with a consumer ID, and start
    over until the producers are done producing and the queue is empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We can start by running our simulation with very small numbers: two producers
    and two consumers. Each producer will create only three URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Even with these tiny numbers involved, you can still see the effects of using
    multiple threads to do the work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The threads don’t take perfect, round-robin turns, but every thread does get
    at least some work time. And the consumers are not locked to specific producers.
    The idea is to make efficient use of limited resources. Producers can keep adding
    tasks without worrying about how long each task will take or whom to assign it
    to. Consumers, in turn, can grab a task without worry about other consumers. If
    one consumer gets handed a simple task and finishes before other consumers, it
    can go back and get a new task right away.
  prefs: []
  type: TYPE_NORMAL
- en: Try running this example yourself and bump up some of those numbers. What happens
    with hundreds of URLs? What happens with hundreds of producers or consumers? At
    scale, this type of multitasking is almost required. You won’t find large programs
    out there that don’t use threads to manage at least some of their background work.
    Java’s own graphical package, Swing, needs a separate thread to keep the UI responsive
    and correct, no matter how small your application is.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing virtual threads
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'What about virtual threads? Do they have the same concurrency concerns? Mostly
    yes. Though lightweight, virtual threads still represent the standard “thread
    of execution” concept. They can still interrupt each other in messy ways and must
    still coordinate access to shared resources. But happily, the design goals of
    Project Loom come to the rescue. We can reuse all of our synchronizing tricks
    with virtual threads. In fact, to virtual thread-ify our URL producing-and-consuming
    demo, all we need to do is replace the chunk of code in the `main()` method that
    starts the threads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The virtual threads honor the `synchronized` keyword in our `URLQueue` methods
    and understand the `join()` calls just like platform threads. If you compile `URLDemo2.java`
    and run it (don’t forget you may need to enable preview features), you will see
    the same output as before, with small variations from the random pauses, of course.
  prefs: []
  type: TYPE_NORMAL
- en: We said virtual threads *mostly* have the same concurrency concerns as platform
    threads. We added that because creating and running virtual threads is a lot cheaper
    than managing a pool of platform threads so you don’t overwhelm the operating
    system. (Recall that each platform thread is mapped to one native thread.) You
    don’t pool virtual threads—you just make more.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing Class and Instance Variables from Multiple Threads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the `SpreadSheet` example, we guarded access to a set of instance variables
    with a synchronized method in order to avoid a thread changing one of the variables
    while another thread was reading the others, to keep them coordinated.
  prefs: []
  type: TYPE_NORMAL
- en: 'But what about individual variable types? Do they need to be synchronized?
    Normally, no. Almost all operations on primitives and object reference types in
    Java happen *atomically*: that is, the JVM handles them in one step, with no opportunity
    for two threads to collide. This prevents threads from looking at references while
    other threads are accessing them.'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Watch out—the JVM specification does not guarantee it will handle `double` and
    `long` primitive types atomically. Both of these types represent 64-bit values.
    The problem has to do with how the JVM’s stack works. You should synchronize access
    to your `double` and `long` instance variables through accessor methods or use
    an atomic wrapper class, which we’ll describe in [“Concurrency Utilities”](#learnjava6-CHP-9-SECT-7).
  prefs: []
  type: TYPE_NORMAL
- en: Scheduling and Priority
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java makes few guarantees about how it schedules threads. Almost all thread
    scheduling is left up to the Java implementation and, to some degree, the application.
    Java’s designers could have specified a scheduling algorithm, but a single algorithm
    isn’t suitable for all the roles that Java can play. Instead, Java’s designers
    put the burden on you to write robust code that works no matter the scheduling
    algorithm, and let the implementation tune the algorithm for the best fit.
  prefs: []
  type: TYPE_NORMAL
- en: The priority rules in the Java language specification are carefully worded to
    be a general guideline for thread scheduling. You should be able to rely on this
    behavior overall (statistically), but it is not a good idea to write code that
    relies on very specific features of the scheduler to work properly. Instead, use
    the control and synchronization tools described in this chapter to coordinate
    your threads.^([7](ch09.html#id1843))
  prefs: []
  type: TYPE_NORMAL
- en: 'Every thread has a priority. In general, any time a thread of a higher priority
    than the current thread becomes runnable (is started, stops sleeping, or is notified),
    it preempts the lower-priority thread and begins executing. On some systems, threads
    with the same priority are scheduled *round-robin*, which means once a thread
    starts to run, it continues until it does one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Sleeps, by calling `Thread.sleep()` or `wait()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Waits for a lock, in order to run a `synchronized` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blocks an I/O, for example, in a `read()` or `accept()` call
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explicitly yields control, by calling `yield()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terminates by completing its target method^([8](ch09.html#id1845))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This situation looks something like [Figure 9-8](#learnjava6-CHP-9-FIG-4).
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 0908](assets/ljv6_0908.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-8\. Priority-preemptive round-robin scheduling
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can set a priority on a platform thread with the `setPriority()` method
    and you can see a thread’s current priority using the complementary `getPriority()`
    call. The priorities must fall within a range, bounded by the `Thread` class constants
    `MIN_PRIORITY` and `MAX_PRIORITY`. The default priority is held in the constant
    `NORM_PRIORITY`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Virtual threads all run with `NORM_PRIORITY`. If you call `setPriority()` on
    a virtual thread, the new priority you pass will simply be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Thread State
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At any given time in its life cycle, a thread is in one of five general states.
    You can query them using the `getState()` method of the `Thread` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NEW`'
  prefs: []
  type: TYPE_NORMAL
- en: The thread has been created but has not yet started.
  prefs: []
  type: TYPE_NORMAL
- en: '`RUNNABLE`'
  prefs: []
  type: TYPE_NORMAL
- en: The thread is in its normal active state, even if it is blocked in an I/O operation,
    like a read or write to a file or a network connection.
  prefs: []
  type: TYPE_NORMAL
- en: '`BLOCKED`'
  prefs: []
  type: TYPE_NORMAL
- en: The thread is blocked, waiting to enter a synchronized method or code block.
    This includes times when a thread has been awakened by a `notify()` and is attempting
    to reacquire its lock after a `wait()`.
  prefs: []
  type: TYPE_NORMAL
- en: '`WAITING, TIMED_WAITING`'
  prefs: []
  type: TYPE_NORMAL
- en: The thread is waiting for another thread via a call to `wait()` or `join()`.
    In the case of `TIMED_WAITING`, the call has a timeout.
  prefs: []
  type: TYPE_NORMAL
- en: '`TERMINATED`'
  prefs: []
  type: TYPE_NORMAL
- en: The thread has completed due to a return, an exception, or being stopped.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can show the state of all platform threads in the current thread group
    with the following snippet of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `Thread.enumerate()` call will populate our `threads` array up to its length.
    You probably won’t use this method in general programming, but it is interesting
    and useful for experimenting and learning about Java threads.
  prefs: []
  type: TYPE_NORMAL
- en: Time-Slicing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to prioritization, all modern systems (with the exception of some
    embedded and “micro” Java environments) implement thread *time-slicing*. In a
    time-sliced system, thread processing is chopped up so that each thread runs for
    a short period of time before the context is switched to the next thread, as shown
    in [Figure 9-9](#learnjava6-CHP-9-FIG-5).
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 0909](assets/ljv6_0909.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-9\. Priority-preemptive time-sliced scheduling
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Higher-priority threads still preempt lower-priority threads in this scheme.
    Adding time-slicing mixes up the processing among threads of the same priority;
    on a multiprocessor machine, threads may even be run simultaneously. This can
    change the behavior of applications that don’t use threads and synchronization
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Strictly speaking, because Java doesn’t guarantee time-slicing, you shouldn’t
    write code that relies on this type of scheduling; any software you write should
    function under round-robin scheduling. If you’re wondering what your particular
    flavor of Java does, try the following experiment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: When you run this example, you will see how your Java implementation does its
    scheduling. The `Thready` class starts up two `ShowThread` objects. `ShowThread`
    is a thread that goes into an unending loop^([9](ch09.html#id1854)) (generally
    bad form, but useful for this demonstration) and prints its message. Because we
    don’t specify a priority for either thread, they both inherit the priority of
    their creator, so they have the same priority. Under a round-robin scheme, only
    `Foo` should be printed; `Bar` should never appear. In a time-slicing implementation,
    you should occasionally see the `Foo` and `Bar` messages alternate.
  prefs: []
  type: TYPE_NORMAL
- en: The *ch09/examples* folder also contains a `VirtualThready` example if you want
    to see how virtual threads behave. They run with a “work-stealing” scheduler.
    (Feel free to dive into the [official Oracle docs](https://oreil.ly/qzfe0) on
    the fork/join framework where this algorithm is laid out.) We had to add some
    `join()` calls to the virtual thread version. Unlike the platform threads, virtual
    threads will not keep the JVM “awake” without these explicit requests to wait
    for the threads to complete.
  prefs: []
  type: TYPE_NORMAL
- en: Priorities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Thread priorities are a general guideline for how the JVM should allocate time
    among competing threads. Unfortunately, Java platform threads are mapped to native
    threads in such complex ways that you can’t rely upon the exact meaning of priorities.
    Instead, consider them a hint to the JVM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s play with the priority of our threads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: You might expect that with this change to our `Thready2` class, the `Bar` thread
    will take over completely. If you run this code on an old Solaris implementation
    of Java 5.0, that’s exactly what happens. The same is not true on most modern
    versions of Java. Similarly, if you change the priorities to values other than
    min and max, you may not see any difference at all. The subtleties of priority
    and performance relate to how Java threads and priorities are mapped to real threads
    in the OS. For this reason, you should generally reserve adjusting thread priorities
    for system and framework development.
  prefs: []
  type: TYPE_NORMAL
- en: Thread Performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The use of threads has dictated the form and functionality of several Java packages.
  prefs: []
  type: TYPE_NORMAL
- en: The Cost of Synchronization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Acquiring locks to synchronize threads takes time, even when there is no contention.
    In older implementations of Java, this time could be significant. With newer JVMs,
    it is almost negligible. However, unnecessary low-level synchronization can still
    slow applications by blocking threads where concurrent access could be allowed.
    To avoid this penalty, two important APIs, the Java collections framework and
    the Swing API, were specifically crafted to put synchronization under the developer’s
    control.
  prefs: []
  type: TYPE_NORMAL
- en: The `java.util` collections framework replaces earlier, simple Java aggregate
    types—namely, `Vector` and `Hashtable`—with more fully featured and, notably,
    unsynchronized types (`List` and `Map`). The collections framework instead defers
    to application code to synchronize access to collections when necessary, and provides
    special “fail fast” functionality to help detect concurrent access and throw an
    exception. It also provides synchronization “wrappers” that can provide safe access
    in the old style. Special concurrent-access-friendly implementations of the `Map`
    and `Queue` collections are included as part of the `java.util.concurrent` package.
    These implementations go even further and allow a high degree of concurrent access
    without any user synchronization.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Java Swing API takes a different approach to providing speed and safety.
    Swing uses a single thread to modify its components, with an exception: the *event
    dispatch thread*, also called the event queue. Swing solves performance problems
    and any event ordering issues by forcing a single super-thread to control the
    GUI. The application accesses the event dispatch thread indirectly by pushing
    commands onto a queue through a simple interface. We’ll see how to do just that
    in [Chapter 12](ch12.html#learnjava6-CHP-12).'
  prefs: []
  type: TYPE_NORMAL
- en: Thread Resource Consumption
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A fundamental pattern in Java is to start many threads to handle asynchronous
    external resources, such as socket connections. For maximum efficiency, a web
    developer might be tempted to create a thread for each client connection on a
    server. When each client has its own thread, I/O operations can block and resume
    as needed. But as efficient as this may be in terms of throughput for a given
    client, it is a very inefficient use of server resources.
  prefs: []
  type: TYPE_NORMAL
- en: Threads consume memory; each thread has its own “stack” for local variables,
    and switching between running threads (known as *context switching*) adds overhead
    to the CPU. Threads are relatively lightweight. It is possible to have hundreds
    or thousands running on a large server. But after a certain point, the cost of
    managing the existing threads starts to outweigh the benefits of starting more
    threads. Creating a thread per client is not always a scalable option.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative approach is to create “thread pools” where a fixed number of
    threads pull tasks from a queue and return for more work when they are finished.
    This recycling of threads makes for solid scalability, but it has often been difficult
    to implement efficiently for servers in Java. Basic I/O (for things like sockets)
    in Java does not fully support nonblocking operations. The `java.nio` package,
    New I/O (or simply NIO), has asynchronous I/O channels. Channels can perform nonblocking
    reads and writes. They also have the ability to test the readiness of streams
    for moving data. Threads can close channels asynchronously, making for graceful
    interactions. We’ll discuss NIO in the coming chapters on working with files and
    network connections.
  prefs: []
  type: TYPE_NORMAL
- en: Java provides thread pools and job “executor” services as part of the `java.util.concurrent`
    package. This means you don’t have to write these yourself. We’ll summarize them
    when we discuss the concurrency utilities in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual Thread Performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Project Loom set out to improve thread performance—especially when thousands
    or millions of threads are involved. The code of a `run()` method isn’t any faster
    or slower when you run it on a platform thread versus a virtual thread. What is
    faster, though, is creating and managing those threads.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take another look at our `URLDemo` class. Rather than four threads total,
    let’s crank that number up to several thousand. We’ll drop our producers and prepopulate
    the queue with URLs so we can focus on our new consumers. We’ll make consumers
    whose only job is to consume one URL—no random, artificial delay before going
    back for another URL. This behavior mimics a real use case for virtual threads:
    a single server that handles millions of small requests in a short period. We’ll
    also modify our print statements to show up at milestones rather than after every
    single URL is consumed. Our new `URLDemo3` will take two optional command-line
    arguments: the number of URLs to create (default is 100,000) and whether to use
    platform or virtual threads (default is platform), so we can compare the difference
    in performance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the source code for `URLConsumer3` in the *ch09/examples* folder
    to see the tweaks we made for this new variation. Then let’s look more carefully
    at the processing loop in the `main()` method to see how it handles the new consumers.
    Here’s the relevant section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This code doesn’t try to reuse consumers. There are valid reasons not to reuse
    threads in the real world, by the way. You have to manually clean up some shared
    data between uses, for example. Forget that bit of “administrivia” and you might
    leak sensitive information. (If you were processing bank transactions, you wouldn’t
    want to accidentally use the previous account number.) You can often simplify
    your code by assuming a single thread will do all of the work and then terminate.
    This is true whether or not you’re using virtual threads.
  prefs: []
  type: TYPE_NORMAL
- en: We tried this version with 1,000,000 URLs on a middling Linux desktop system.
    The platform threads cleared the queue in just under one minute (58.661 s according
    to the coarse `time` utility). Not bad! The virtual threads, on the other hand,
    cleared the queue in just under *2 seconds* (1.867 s). The testing for a milestone
    URL to print is trivial. It’s not the task each consumer does that slows things
    down. The real bottleneck with platform threads is asking the operating system
    for a new, expensive resource thousands of times. Project Loom removes a lot of
    that expense. Using virtual threads is not a guarantee of better performance,
    but in cases like this, it certainly can be a benefit!
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency Utilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far in this chapter, we’ve demonstrated how to create and synchronize threads
    at a low level, using Java language primitives. The `java.util.concurrent` package
    and subpackages build on this functionality, adding important threading utilities
    and codifying some common design patterns by supplying standard implementations.
    Roughly in order of generality, these areas include:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Thread-aware Collections implementations*'
  prefs: []
  type: TYPE_NORMAL
- en: The `java.util.concurrent` package augments the Java Collections API in [Chapter 7](ch07.html#learnjava6-CHP-7)
    with several implementations for specific threading models. These include timed
    wait and blocking implementations of the `Queue` interface, as well as nonblocking,
    concurrent-access optimized implementations of the `Queue` and `Map` interfaces.
    The package also adds “copy on write” `List` and `Set` implementations for extremely
    efficient “almost always read” cases. These may sound complex, but they cover
    some common cases very well.
  prefs: []
  type: TYPE_NORMAL
- en: '`Executors`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Executor`s run tasks, including `Runnable`s, and abstract the concept of thread
    creation and pooling from the user (meaning you don’t have to write your own).
    `Executors` are intended to be a high-level replacement for creating new threads
    to service a series of jobs. Along with `Executor`, the `Callable` and `Future`
    interfaces allow management, value return, and exception handling.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Low-level synchronization constructs*'
  prefs: []
  type: TYPE_NORMAL
- en: The `java.util.concurrent.locks` package holds a set of classes, including `Lock`
    and `Condition`, that parallels the Java language-level synchronization primitives
    and promotes them to the level of a concrete API. For example, the `LockSupport`
    helper class includes two methods, `park()` and `unpark()`, that replace the deprecated
    `suspend()` and `resume()` methods from the `Thread` class. The locks package
    also adds the concept of nonexclusive reader/writer locks, allowing for greater
    concurrency in synchronized data access.
  prefs: []
  type: TYPE_NORMAL
- en: '*High-level synchronization constructs*'
  prefs: []
  type: TYPE_NORMAL
- en: This includes the classes `CyclicBarrier`, `CountDownLatch`, `Semaphore`, and
    `Exchanger`. These classes implement common synchronization patterns drawn from
    other languages and systems, and they can serve as the basis for new high-level
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: '*Atomic operations (sounds very James Bond, doesn’t it?)*'
  prefs: []
  type: TYPE_NORMAL
- en: The `java.util.concurrent.atomic` package provides wrappers and utilities for
    atomic, “all-or-nothing” operations on primitive types and references. This includes
    simple combination atomic operations like testing a value before setting it, and
    getting and incrementing a number in one operation.
  prefs: []
  type: TYPE_NORMAL
- en: With the possible exception of optimizations done by the Java VM for the `atomic`
    operations package, all of these utilities are implemented in pure Java, on top
    of the standard Java language synchronization constructs. This means that they
    are in a sense only convenience utilities and don’t truly add new capabilities
    to the language. Their main role is to offer standard patterns and idioms in Java
    threading, making them safer and more efficient to use. A good example of this
    is the `Executor` utility, which allows a user to manage a set of tasks in a predefined
    threading model without having to delve into creating threads at all. Higher-level
    APIs like this both simplify coding and allow for greater optimization of the
    common cases.
  prefs: []
  type: TYPE_NORMAL
- en: Upgrading Our Queue Demo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Many of the concurrency features built into Java will be more useful to you
    on larger, more complex projects. But we can still upgrade our meager URL processing
    demo by using the thread-safe `ConcurrentLinkedQueue` class from the `java.util.concurrent`
    package. We can parameterize its type and do away with our custom `URLQueue` class
    entirely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We do have to tweak the consumer and producer code a little, but only a little,
    and mostly just to use the normal queue operation names of `add` and `poll` instead
    of our custom, URL-centric method names. But we don’t have to worry about the
    `URLQueue` class at all. Sometimes you will need custom data structures because
    the real world is messy. But if you can use one of the synchronized storage options
    built in, you know you’re getting robust storage and access that you can safely
    use in your multithreaded application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another upgrade to consider is the atomic convenience classes. You might recall
    that our consumer class has a Boolean flag that can be set to false to end the
    consumer’s processing loop. Since it’s reasonable to assume that multiple threads
    might have access to our consumer, we can remake that flag as an instance of the
    `AtomicBoolean` class to make sure that warring threads can’t clobber our poor
    flag. (We could make our accessor method `synchronized`, of course, but we want
    to highlight some of the existing options already in the JDK.) Here’s a look at
    the interesting parts of `URLConsumer4`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Using `AtomicBoolean` requires a smidge more typing—calling set/get methods
    rather than simple assignments or comparisons—but you get all the safe handling
    you could wish for. When you have complex, multithreaded logic everywhere, you
    might do your own state management. In situations where you don’t have much other
    code that requires synchronization, though, these convenience classes can be very
    convenient indeed.
  prefs: []
  type: TYPE_NORMAL
- en: Structured Concurrency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Beyond the impressive improvements that virtual threads bring to highly concurrent
    applications, Project Loom also brings structured concurrency to Java. You may
    have heard about “parallel programming” in the threaded world. You have the option
    of pursuing a parallel programming solution when you can break a larger problem
    into smaller problems that can be solved separately and at the same time (in parallel,
    get it?).
  prefs: []
  type: TYPE_NORMAL
- en: This notion of a large task that can be turned into subtasks shares many similarities
    with our demo that uses producers and consumers, but the two types of problems
    are not entirely the same. One big difference lies in how to handle errors. If
    we failed to create a consumer in our `URLDemo` classes, for example, we could
    just create another one and continue on. But if a subtask fails in a parallel
    computation, it isn’t as obvious how to recover. Should all of the other subtasks
    be canceled? What if some of them have already completed? What if we want to cancel
    the larger “parent” task?
  prefs: []
  type: TYPE_NORMAL
- en: Java 19 introduced an incubator feature, the `StructuredTaskScope` class, to
    better encapsulate the work done with subtasks. (If you were to call a preview
    feature like virtual threads a “beta” enhancement, incubator features would be
    an “alpha” enhancement.) You can read about the design goals and implementation
    details in [JEP 428](https://oreil.ly/HBbfE). We won’t work with structured concurrency
    or executors in this book, but it is important to know that Java has many tools
    available to developers who are working with parallel and concurrent applications.
    Indeed, the support it provides to developers in this arena is precisely why Java
    remains such a popular workhorse in production backends.
  prefs: []
  type: TYPE_NORMAL
- en: So Many Threads to Pull
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we won’t be looking any deeper at the concurrency packages in this chapter,
    we want you to know where you might dig next if concurrency is interesting to
    you or proves useful in the type of problems you encounter at work. As we (foot)noted
    in [“Synchronizing a queue of URLs”](#learnjava6-CHP-9-SECT-4.1.1), *[Java Concurrency
    In Practice](https://jcip.net)* by Brian Goetz, is required reading for real-world,
    multithreaded projects. We also want to give a shout-out to Doug Lea, the author
    of *Concurrent Programming in Java* (Addison-Wesley), who led the group that added
    these packages to Java and is largely responsible for creating them.
  prefs: []
  type: TYPE_NORMAL
- en: Alongside threads, Java’s native support for basic file input and output (I/O)
    figures prominently in production applications. We’ll look at the main classes
    for typical I/O in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Review Questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What is a thread?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What keyword can you add to a method if you want threads to “take turns” when
    calling it? (Meaning no two threads should be executing the method at the same
    time to avoid corrupting shared data.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What flags allow you to compile a Java program that includes preview feature
    code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What flags allow you to run a Java program that includes preview feature code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many platform threads can one native thread support?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many virtual threads can one native thread support?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is the statement `x = x + 1;` an atomic action for the variable `x`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What package includes thread-safe versions of popular collection classes like
    `Queue` and `Map`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Code Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s build a clock! Using a needle and thread—er, a `JLabel` and a `Thread`—make
    a small graphical clock application. The *Clock.java* file in the *ch09/exercises*
    folder contains a skeleton app that puts up a small window with a simple `JLabel`
    object. We bumped up the size of the label’s font to make things more readable.
    Your clock should show hours, minutes, and seconds, at a minimum. Create a thread
    that will sleep for one second and then increment the clock’s display. Feel free
    to revisit the date and time formatting examples from [“Formatting Dates and Times”](ch08.html#learnjava6-CHP-8-SECT-5.5).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The apple tossing game in the *ch09/exercises/game* folder currently uses a
    platform thread for its first foray into the world of animation following the
    discussion in [“Revisiting Animation with Threads”](#learnjava6-CHP-9-SECT-1.3).
    Compile and run it to see an apple launch itself when the game starts. The apple
    won’t hit anything, but it will move in an arc as though tossed. We’ll make this
    animation more interesting and more interactive in [Chapter 12](ch12.html#learnjava6-CHP-12).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have a feel for the intended animation, convert the platform thread
    to a virtual thread. Compile your new version and verify it still works as expected.
    (Remember that, depending on your version of Java, you may need to compile and
    run with the extra preview flags.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ^([1](ch09.html#id1771-marker)) Historically, `interrupt()` has not worked consistently
    in all Java implementations.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch09.html#id1793-marker)) The term daemon (often pronounced day-mun in
    Unix circles) was inspired by [Maxwell’s demon](https://oreil.ly/YGQMt) and refers
    to the Greek term for a lesser deity, not a malevolent spirit.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch09.html#id1797-marker)) Many Java enhancements start out as works-in-progress
    with spiffy names like “Loom.”
  prefs: []
  type: TYPE_NORMAL
- en: '^([4](ch09.html#id1810-marker)) Sadly, the single- versus double-dash prefixes
    on these options are not typos. Command-line arguments have quite a storied history
    in their own right, and Java and its tools are old enough to have inherited some
    of the legacy patterns while still needing to accommodate modern approaches. Most
    options work with either prefix, but occasionally you have to obey what seems
    like an unwritten rule. When in doubt, tools like *javac* support another option:
    `-help` (or `--help`). Supplying that argument will print out a concise list of
    options and relevant details.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](ch09.html#id1818-marker)) Don’t confuse the term *serialize* in this context
    with Java *object serialization*, which is a mechanism for making objects persistent.
    The underlying meaning (to place one thing after another) is the same, however.
    In the case of object serialization, the object’s data is laid out, byte for byte,
    in a certain order. With threads, each thread gets access to the synchronized
    resource in turn.
  prefs: []
  type: TYPE_NORMAL
- en: ^([6](ch09.html#id1823-marker)) Even with the ability to tolerate minor discrepancies
    in the state of objects, modern, multicore systems can wreak havoc without perfect
    knowledge of the application. And perfection is difficult! If you expect to work
    with threads in the real world, [*Java Concurrency in Practice*](https://jcip.net)
    by Brian Goetz et al. (Addison-Wesley) is *required* reading.
  prefs: []
  type: TYPE_NORMAL
- en: ^([7](ch09.html#id1843-marker)) *Java Threads* by Scott Oaks and Henry Wong
    (O’Reilly) includes a detailed discussion of synchronization, scheduling, and
    other thread-related issues.
  prefs: []
  type: TYPE_NORMAL
- en: ^([8](ch09.html#id1845-marker)) Technically, a thread can also terminate with
    the [deprecated `stop()` call](https://oreil.ly/AbbQk), but as we noted at the
    start of the chapter, this is bad for myriad reasons.
  prefs: []
  type: TYPE_NORMAL
- en: ^([9](ch09.html#id1854-marker)) You can type Control-C to exit the demo when
    you get tired of seeing `Foos` fly by.
  prefs: []
  type: TYPE_NORMAL
