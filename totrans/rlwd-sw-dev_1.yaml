- en: Chapter 1\. Starting the Journey
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ll give you an introduction to the concepts and principles
    of this book. A good way of summarizing the overall approach is *Practices and
    Principles over Technology*. There are already many books about specific technologies,
    and we aren’t seeking to add to that enormous pile. That isn’t to say that the
    detailed knowledge that is specific to a given language, framework, or library
    isn’t useful. It’s just that it has a shorter shelf-life than general practices
    and principles that apply over longer periods of time and across different languages
    and frameworks. That’s where this book can help you.
  prefs: []
  type: TYPE_NORMAL
- en: Themes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout the book we’ve used a project-based structure to aid learning. It’s
    worth thinking about the different themes that run through the chapters, how they
    link up together, and why we chose them. Following are the four different themes
    that weave through the chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Java Features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Structuring code with classes and interfaces is discussed in [Chapter 2](ch02.xhtml#chapter_02).
    We move onto exceptions and packages in [Chapter 3](ch03.xhtml#chapter_03). You
    will also get a short overview of lambda expressions in [Chapter 3](ch03.xhtml#chapter_03).
    Then local variable type inferences and switch expressions are explained in [Chapter 5](ch05.xhtml#chapter_05),
    and finally lambda expressions and method references are covered in detail in
    [Chapter 7](ch07.xhtml#chapter_07). Java language features are important because
    so many software projects are written in Java, so it’s useful language to know
    the workings of it. Many of these language features are useful in other programming
    languages as well, such as C#, C++, Ruby, or Python. Even though those languages
    have differences, understanding the how to use a class and core OOP concepts will
    be valuable across different languages.
  prefs: []
  type: TYPE_NORMAL
- en: Software Design and Architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Throughout the book a series of design patterns are introduced that help provide
    you with common solutions to common problems that developers encounter. These
    are important to know because even though it may seem like every software project
    is different and comes with its own set of problems, in practice many of these
    have been encountered before. Understanding common problems and solutions that
    have been solved by developers keeps you from reinventing the wheel in a new software
    project and enables you to deliver software faster and more reliably.
  prefs: []
  type: TYPE_NORMAL
- en: The higher-level concepts of coupling and cohesion are introduced early on the
    book in [Chapter 2](ch02.xhtml#chapter_02). The Notification pattern is introduced
    in [Chapter 3](ch03.xhtml#chapter_03). How to design a user-friendly Fluent API
    and the Builder pattern are introduced in [Chapter 5](ch05.xhtml#chapter_05).
    We look at the big-picture concepts of event-driven and hexagonal architectures
    in [Chapter 6](ch06.xhtml#chapter_06) and the Repository pattern in [Chapter 7](ch07.xhtml#chapter_07).
    Finally, you’re also introduced to functional programming in [Chapter 7](ch07.xhtml#chapter_07).
  prefs: []
  type: TYPE_NORMAL
- en: SOLID
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We cover all the SOLID principles throughout various chapters. These are a
    set of principles designed to help make software easier to maintain. While we
    like to think of writing software as the fun part, if the software that you write
    is successful it will need to evolve, grow, and be maintained. Trying to make
    the software as easy to maintain as possible helps this evolution, maintenance,
    and long-term addition of features. The SOLID principles and the chapters where
    we will discuss them are:'
  prefs: []
  type: TYPE_NORMAL
- en: Single Responsibility Principle (SRP), discussed in [Chapter 2](ch02.xhtml#chapter_02)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open/Closed Principle (OCP), discussed in [Chapter 3](ch03.xhtml#chapter_03)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Liskov Substitution Principle (LSP), discussed in [Chapter 4](ch04.xhtml#chapter_04)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interface Segregation Principle (ISP), discussed in [Chapter 5](ch05.xhtml#chapter_05)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency Inversion Principle (DIP), discussed in [Chapter 7](ch07.xhtml#chapter_07)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Writing reliable code that can be easily evolved over time is really important.
    Automated tests are key to this. As the software that you write scales in size
    it becomes increasingly hard to manually test different possible cases. You need
    to automate your testing processes to avoid the days of human effort it would
    take to test your software without it.
  prefs: []
  type: TYPE_NORMAL
- en: You learn about the basics of writing tests in Chapters [2](ch02.xhtml#chapter_02)
    and [4](ch04.xhtml#chapter_04). This is extended to test-driven development, or
    TDD, in [Chapter 5](ch05.xhtml#chapter_05). In [Chapter 6](ch06.xhtml#chapter_06)
    we cover the use of test doubles, including mocks and stubs.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here’s the outline of the chapters.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 2, *The Bank Statements Analyzer*](ch02.xhtml#chapter_02)'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll write a program to analyze bank statements in order to help people understand
    their finances better. This will help you to learn more about core object-oriented
    design techniques such as *Single Responsibility Principle* (SRP), coupling, and
    cohesion.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 3, *Extending the Bank Statements Analyzer*](ch03.xhtml#chapter_03)'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter you learn how to extend the code from [Chapter 2](ch02.xhtml#chapter_02),
    adding more features, using the Strategy Design pattern, the Open/Closed Principle,
    and how to model failures using exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 4, *The Document Management System*](ch04.xhtml#chapter_04)'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we help a successful doctor manage her patient records better.
    This introduces concepts such as inheritance within software design, the Liskov
    Substitution Principle, and tradeoffs between composition and inheritance. You
    will also learn how to write more reliable software with automated test code.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 5, *The Business Rules Engine*](ch05.xhtml#chapter_05)'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll learn about building a core business rules engine—a way of defining business
    logic that is flexible and easy to maintain. This chapter introduces the topics
    of test-driven development, developing a Fluent API, and the Interface Segregation
    Principle.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 6, *Twootr*](ch06.xhtml#chapter_06)'
  prefs: []
  type: TYPE_NORMAL
- en: '*Twootr* is a messaging platform that enables people to broadcast short messages
    to other users who follow them. This chapter builds out the core of a simple Twootr
    system. You’ll learn how to think outside-in—to go from requirements through to
    the core of your application. You’ll also learn how to use test doubles to isolate
    and test interactions from different components within your codebase.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 7, *Extending Twootr*](ch07.xhtml#chapter_07)'
  prefs: []
  type: TYPE_NORMAL
- en: The final project-based chapter in the book extends the Twootr implementation
    from the previous chapter. It explains the Dependency Inversion Principle and
    introduces bigger picture architectural choices such as event-driven and hexagonal
    architectures. This chapter can help you extend your knowledge of automated testing
    by covering test doubles, such as stubs and mocks, and also functional programming
    techniques.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 8, *Conclusion*](ch08.xhtml#chapter_08)'
  prefs: []
  type: TYPE_NORMAL
- en: This final concluding chapter revisits the major themes and concepts of the
    book and offers additional resources as you continue in your programming career.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating on You
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a software developer you may well approach projects in an iterative fashion.
    That’s to say, slice off the highest priority week or two’s worth of work items,
    implement them, and then use the feedback in order to decide on the next set of
    items. We’ve found that it’s often worth evaluating the progress of your own skills
    in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of every chapter there is a brief “Iterating on You” section with
    a few suggestions on how you improve upon on the learning from the chapter in
    your own time.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know what you can expect from this book, let’s get to work!
  prefs: []
  type: TYPE_NORMAL
