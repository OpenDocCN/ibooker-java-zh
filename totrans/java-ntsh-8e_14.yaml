- en: Chapter 12\. Java Platform Modules
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 12 章。Java 平台模块
- en: In this chapter, we will provide a basic introduction to the *Java Platform
    Modules System* (JPMS). However, this is a large, complex subject—​interested
    readers may well require a more in-depth reference, such as [*Java 9 Modularity*](http://shop.oreilly.com/product/0636920049494.do)
    by Sander Mak and Paul Bakker (O’Reilly).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将对 *Java 平台模块系统*（JPMS）进行基本介绍。然而，这是一个大而复杂的主题——有兴趣的读者可能需要更深入的参考资料，如《Java
    9 Modularity》（O'Reilly）的 Sander Mak 和 Paul Bakker。
- en: Modules, a relatively advanced feature, are primarily about packaging and deploying
    entire applications and their dependencies. They were added to the platform roughly
    20 years after the first version of Java and so can be seen as orthogonal to the
    rest of the language syntax.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 模块，作为一个相对先进的特性，主要用于打包和部署整个应用程序及其依赖项。它们被添加到平台大约在 Java 第一个版本之后的 20 年左右，因此可以看作是与语言语法的其他部分正交的。
- en: Java’s strong promotion of backwards compatibility also plays a role here, as
    non-modular applications must continue to run. This has led the architects and
    stewards of the Java platform to adopt a pragmatic view of the necessity of teams
    to adopt modules.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Java 强烈推广向后兼容性，在这里也发挥了作用，因为非模块化应用必须继续运行。这导致 Java 平台的架构师和管理者采取了一种务实的观点，认为团队采用模块化的必要性。
- en: There is no need to switch to modules.
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 没有必要切换到模块。
- en: ''
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: There has never been a need to switch to modules.
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 从未有过必要切换到模块。
- en: ''
  id: totrans-7
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Java 9 and later releases support traditional JAR files on the traditional classpath,
    via the concept of the unnamed module, and will likely do so until the heat death
    of the universe.
  id: totrans-8
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Java 9 及以后的版本支持传统的 JAR 文件在传统的类路径上，通过未命名模块的概念，可能会一直持续到宇宙的热死亡。
- en: ''
  id: totrans-9
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Whether to start using modules is entirely up to you.
  id: totrans-10
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 是否开始使用模块完全取决于您自己。
- en: ''
  id: totrans-11
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Mark Reinhold
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Mark Reinhold
- en: https://oreil.ly/4RjDH
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: https://oreil.ly/4RjDH
- en: Due to the advanced nature of modules, this chapter assumes you are familiar
    with a modern Java build tool, such as Gradle or Maven.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于模块的先进性质，本章假定您熟悉现代 Java 构建工具，如 Gradle 或 Maven。
- en: If you are new to Java, you can safely ignore references to those tools and
    just read the chapter to get a first, high-level overview of JPMS. It is not necessary
    for a new Java programmer to fully understand this topic while still learning
    how to write Java programs.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是 Java 的新手，可以安全地忽略对这些工具的引用，只需阅读本章节，以获取对 JPMS 的首次高级概述。新的 Java 程序员在学习如何编写 Java
    程序时，不需要完全理解这个主题。
- en: Why Modules?
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么要使用模块？
- en: 'There were several major motivating reasons for wanting to add modules to the
    Java platform. These included a desire for:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 添加模块到 Java 平台的几个主要动机包括：
- en: Strong encapsulation
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强封装
- en: Well-defined interfaces
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 明确定义的接口
- en: Explicit dependencies
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 明确的依赖关系
- en: 'These are all language (and application design) level, and they were combined
    with the promise of new platform-level capabilities as well:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是语言（和应用程序设计）级别的，并且它们与新平台级别的能力承诺相结合：
- en: Scalable development
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展的开发
- en: Improved performance (especially startup time) and reduced footprint
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进的性能（特别是启动时间）和减少的占用空间
- en: Reduced attack surface and better security
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少攻击面和提高安全性
- en: Evolvable internals
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可演化的内部
- en: 'The encapsulation point was driven by the fact that the original language specification
    supports only private, public, protected, and package-private visibility levels.
    There is no way to control access in a more fine-grained way to express concepts
    such as:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 封装点是由于原始语言规范仅支持私有、公共、受保护和包私有的可见性级别。没有办法以更精细的方式控制访问，以表达诸如以下概念：
- en: Only specified packages are available as an API—others are internal and may
    not be accessed
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有指定的包可作为 API 访问——其他包是内部的，可能无法访问
- en: Certain packages can be accessed by this list of packages but no others
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 某些包可以通过此包列表访问，但不包括其他包
- en: Defining a strict exporting mechanism
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义严格的导出机制
- en: The lack of these and related capabilities has been a significant shortcoming
    when architecting larger Java systems. Not only that, but without a suitable protection
    mechanism, it would be very difficult to evolve the internals of the JDK—as nothing
    prevents user applications from directly accessing implementation classes.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当设计更大型的 Java 系统时，缺乏这些及相关能力一直是一个重大缺点。而且，没有适当的保护机制，JDK 内部的演进将非常困难——因为没有任何东西阻止用户应用程序直接访问实现类。
- en: The modules system attempts to address all of these concerns at once and to
    provide a solution that works both for the JDK and for user applications.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 模块系统试图一次性解决所有这些问题，并提供适用于 JDK 和用户应用程序的解决方案。
- en: Modularizing the JDK
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 JDK 模块化
- en: The monolithic JDK that shipped with Java 8 was the first target for the modules
    system, and the familiar `rt.jar` was broken up into modules.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 随着模块系统的推出，Java 8 随附的单片式 JDK 成为首个目标，熟悉的 `rt.jar` 被分解为模块。
- en: Note
  id: totrans-34
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: Java 8 had begun the work of modularization, by shipping a feature called *Compact
    Profiles* that tidied up the code and made it possible to ship a reduced runtime
    footprint.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8 已经开始模块化工作，通过提供称为*紧凑配置*的功能，整理代码并使其可以以减少的运行时占用空间进行部署。
- en: '`java.base` is the module that represents the minimum that’s actually needed
    for a Java application to start up. It contains core packages, such as:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.base` 是代表 Java 应用程序启动实际所需的最小模块。它包含核心包，例如：'
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'along with some subpackages and nonexported implementation packages such as
    `sun.text.resources`. Some of the differences in compilation behavior between
    Java 8 and modular Java can be seen in this simple program, which extends an internal
    public class contained in `java.base`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以及一些子包和非导出实现包，例如 `sun.text.resources`。可以通过这个简单的程序看到 Java 8 和模块化 Java 之间编译行为的一些差异，它扩展了包含在
    `java.base` 中的内部公共类：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Attempting to compile the code on Java 11 produces this error message:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 11 上尝试编译代码会产生以下错误消息：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'With a modular Java, even classes that are public cannot be accessed unless
    they are explicitly exported by the module they are defined in. We can temporarily
    force the compiler to use the internal package (basically reasserting the old
    access rules) with the `--add-exports` switch, like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块化的 Java 中，即使是公共的类也不能访问，除非它们被定义的模块明确导出。我们可以使用 `--add-exports` 开关临时强制编译器使用内部包（基本上是重新确认旧的访问规则），像这样：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We need to specify that the export is being granted to the *unnamed module*,
    as we are compiling our class standalone and not as part of a module. The compiler
    warns us that we’re using an internal API and that this might break with a future
    release of Java. When compiled and run under Java 11, this produces a list of
    Japanese eras, like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要指定导出被授予给*未命名模块*，因为我们正在编译我们的类独立地，而不是作为模块的一部分。编译器会警告我们正在使用内部 API，并且这可能会在将来的
    Java 版本中中断。在 Java 11 下编译和运行时，这将产生一个日本时代列表，如下所示：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'However, if we try to run under Java 17, then we have a different result:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们尝试在 Java 17 下运行，那么结果就会有所不同：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This is because Java 17 now enforces additional checks as part of the tightening
    up of encapsulation of the internals. To get the program to run, we need to add
    the `--add-exports` runtime flag as well:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 Java 17 现在在强化内部封装时执行了额外的检查。为了使程序运行，我们还需要添加 `--add-exports` 运行时标志：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Although `java.base` is the absolute runtime minimum that an application needs
    to start up, at compile time we want the visible platform to be as close to the
    old (Java 8) experience as possible.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `java.base` 是应用程序启动所需的绝对运行时最小值，但在编译时，我们希望可见平台尽可能接近旧版（Java 8）的体验。
- en: This means that we use a much larger set of modules, contained under an *umbrella*
    module, `java.se`. This module has a dependency graph, shown in [Figure 12-1](#javanut8-CHP-12-FIG-1).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们使用了一个更大的模块集，包含在一个*总称*模块下，即 `java.se`。该模块有一个依赖关系图，如 [图 12-1](#javanut8-CHP-12-FIG-1)
    所示。
- en: '![JN7 1201](assets/jns8_1201.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![JN7 1201](assets/jns8_1201.png)'
- en: Figure 12-1\. Module dependency graph of java.se
  id: totrans-53
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-1\. java.se 的模块依赖关系图
- en: This brings in almost all of the classes and packages that most Java developers
    expect to be available.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎包含了大多数 Java 开发人员期望可用的所有类和包。
- en: However, one important exception is that the Java 8 packages defining the CORBA
    and Java EE APIs (now know as Jakarta EE) have been removed and are not part of
    `java.se`. This means that any project that depends on those APIs will not compile
    by default on Java 11 onward and a special build config must be used, to explicitly
    depend upon external libraries that provide these APIs.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一个重要的例外是，定义 CORBA 和 Java EE API（现在称为 Jakarta EE）的 Java 8 包已被移除，并且不包含在 `java.se`
    中。这意味着任何依赖于这些 API 的项目在 Java 11 及以后版本上默认情况下将无法编译，并且必须使用特殊的构建配置，显式依赖于提供这些 API 的外部库。
- en: Along with these changes to compilation visibility, due to the modularization
    of the JDK, the modules system is also intended to allow developers to modularize
    their own code.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JDK的模块化，编译可见性也发生了变化，模块系统还旨在允许开发人员对其自己的代码进行模块化。
- en: Writing Your Own Modules
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 撰写您自己的模块
- en: In this section, we will discuss the basic concepts needed to start writing
    modular Java applications.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论启动编写模块化Java应用程序所需的基本概念。
- en: Basic Modules Syntax
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本模块语法
- en: The key to modularizing is the new file *module-info.java*, which contains a
    description of a module. This is referred to as a *module descriptor*.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化的关键在于新文件*module-info.java*，它包含了一个模块的描述。这被称为*模块描述符*。
- en: 'A module is laid out for compilation correctly on the filesystem in the following
    way:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 模块在文件系统上的正确布局方式如下：
- en: Below the source root of the project (*src*), there needs to be a directory
    named the same as the module (the *moduledir*).
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在项目的源根目录（*src*）下面，需要有一个与模块同名的目录（*moduledir*）。
- en: Inside the *moduledir* is the *module-info.java*, at the same level as where
    the packages start from.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*moduledir*目录中，*module-info.java*位于与包开始的相同级别。
- en: 'The module info is compiled to a binary format, *module-info.class*, which
    contains the metadata that will be used when a modular runtime attempts to link
    and run our application. Let’s look at a simple example of a *module-info.java*:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 模块信息编译为二进制格式，*module-info.class*，其中包含模块运行时链接和运行应用程序时使用的元数据。让我们看一个*module-info.java*的简单示例：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This introduces some new syntax: `module`, `exports`, and `requires`—but these
    are not really full keywords in the accepted sense. As stated in the Java Language
    Specification SE 11:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这引入了一些新语法：`module`、`exports`和`requires`，但实际上这些并不是完全的关键字。正如Java语言规范SE 11中所述：
- en: 'A further ten character sequences are restricted keywords: `open`, `module`,
    `requires`, `transitive`, `exports`, `opens`, `to`, `uses`, `provides`, and `with`.
    These character sequences are tokenized as keywords solely where they appear as
    terminals in the `ModuleDeclaration` and `ModuleDirective` productions.'
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 还有十个字符序列是受限关键字：`open`、`module`、`requires`、`transitive`、`exports`、`opens`、`to`、`uses`、`provides`和`with`。这些字符序列仅在它们作为`ModuleDeclaration`和`ModuleDirective`产生式中的终端出现时被标记为关键字。
- en: 'This means that these restricted keywords can appear only in the module metadata
    and are compiled into the binary format by `javac`. The meanings of the major
    restricted keywords are:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着这些受限关键字只能出现在模块元数据中，并且由`javac`编译为二进制格式。主要受限关键字的含义是：
- en: '`module`'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`module`'
- en: Starts the module’s metadata declaration
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 开始模块的元数据声明
- en: '`requires`'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`requires`'
- en: Lists a module on which this module depends
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 列出此模块依赖的模块
- en: '`exports`'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`exports`'
- en: Declares which packages are exported as an API
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 声明导出哪些包作为API
- en: The remaining (module-related) restricted keywords will be introduced throughout
    the rest of the chapter.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的（与模块相关的）受限关键字将在本章的其余部分介绍。
- en: Note
  id: totrans-76
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The concept of *restricted keyword* is considerably expanded in Java 17, and
    as a result the description is much longer and less clear. We use the older specification
    here because it refers specifically to the modules system and is more suited to
    our purposes.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 17中，*受限关键字*的概念得到了显著扩展，因此描述更长，更不清晰。在这里，我们使用旧规范，因为它特指模块系统，更适合我们的目的。
- en: In our example, this means that we’re declaring a module `httpchecker` that
    depends upon the module `java.net.http` that was standardized in Java 11 (as well
    as an implicit dependency on `java.base`). The module exports a single package,
    `httpchecker.main`, which is the only package in this module that will be accessible
    from other modules at compile time.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，这意味着我们声明了一个模块`httpchecker`，它依赖于Java 11中标准化的模块`java.net.http`（以及对`java.base`的隐式依赖）。该模块导出一个单独的包`httpchecker.main`，这是此模块中唯一可以在编译时从其他模块访问的包。
- en: Building a Simple Modular Application
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建一个简单的模块化应用程序
- en: 'As an example, let’s build a simple tool that checks whether websites are using
    HTTP/2 yet, using the API that we met in [Chapter 10](ch10.xhtml#javanut8-CHP-10):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们构建一个简单的工具，检查网站是否已经使用了HTTP/2，使用我们在[第10章](ch10.xhtml#javanut8-CHP-10)中遇到的API：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This relies on two modules—`java.net.http` and the ubiquitous `java.base`.
    The module file for the app is very simple:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这依赖于两个模块——`java.net.http`和无处不在的`java.base`。应用程序的模块文件非常简单：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Assuming a simple, standard module layout, this can be compiled like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个简单的标准模块布局，可以像这样进行编译：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This creates a compiled module in the *out/* directory. For use, it needs to
    be packaged as a JAR file:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在*out/*目录中创建一个已编译的模块。为了使用，它需要被打包为一个JAR文件：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `--create` switch tells `jar` to create a new jar, which will include the
    classes contained in the directory. The final `.` at the end of the command is
    mandatory and signifies that all of the class files (relative to the path specified
    with `-C`) should be packaged into the jar.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`--create`开关告诉`jar`创建一个新的jar，其中将包含目录中包含的类。命令末尾的最后一个`.`是强制性的，并表示应将所有类文件（相对于使用`-C`指定的路径）打包到jar中。'
- en: 'We used the `--main-class` switch to set an *entry point* for the module—​that
    is, a class to be executed when we use the module as an application. Let’s see
    it in action:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`--main-class`开关来设置模块的*入口点*—​即，在我们将模块用作应用程序时要执行的类。让我们看看它的工作原理：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This shows that, at the time of writing, Google’s website was using HTTP/2 to
    serve its main page over HTTPS but still using HTTP/1.1 for the legacy unencrypted
    HTTP service.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明，撰写时，谷歌的网站使用HTTP/2通过HTTPS提供其主页，但仍然使用HTTP/1.1提供遗留的未加密HTTP服务。
- en: Now that we have seen how to compile and run a simple modular application, let’s
    meet some more of the core features of modularity that are needed to build and
    run full-size applications.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何编译和运行一个简单的模块化应用程序，让我们了解一些构建和运行全尺寸应用程序所需的核心模块化功能。
- en: The Module Path
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块路径
- en: Many Java developers are familiar with the concept of the classpath. When working
    with modular Java applications, we instead need to work with the *module path*.
    This is a new concept for modules that replaces the classpath wherever possible.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Java开发人员熟悉类路径的概念。在使用模块化Java应用程序时，我们需要使用*模块路径*。这是一种新的模块概念，尽可能替换类路径。
- en: Modules carry metadata about their exports and dependencies—they are not just
    a long list of types. This means a graph of module dependencies can be built easily
    and module resolution can proceed efficiently.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 模块携带关于其导出和依赖项的元数据—​它们不仅仅是类型的长列表。这意味着可以轻松构建模块依赖关系图，并且模块解析可以有效进行。
- en: Code that is not yet modularized continues to be placed on the classpath. This
    code is loaded into the *unnamed module*, which is special and can read all other
    modules that can be reached from `java.se`. Using the unnamed module happens automatically
    when classes are placed on the classpath.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 尚未模块化的代码仍然放置在类路径上。此代码加载到*未命名模块*中，该模块是特殊的，并且可以读取从`java.se`可达的所有其他模块。当将类放置在类路径上时，将自动使用未命名模块。
- en: 'This provides a migration path to adopting a modular Java runtime without having
    to migrate to a fully modular application path. However, it does have two major
    drawbacks: none of the benefits of modules will be available until the app is
    fully migrated, and the self-consistency of the classpath must be maintained by
    hand until modularization is complete.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这为采用模块化Java运行时提供了迁移路径，而无需迁移到完全模块化的应用程序路径。然而，它确实有两个主要缺点：在应用程序完全迁移之前，模块的任何好处都不可用，并且必须手动维护类路径的自一致性，直到模块化完成。
- en: Automatic Modules
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动模块
- en: One of the constraints of the modules system is that we can’t reference JARs
    on the classpath from named modules. This is a safety feature—the designers of
    the module system wanted the module dependency graph to utilize full metadata
    and be able to rely on the completeness of that metadata.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 模块系统的约束之一是我们不能从命名模块引用类路径上的JAR。这是一个安全特性—​模块系统的设计者希望模块依赖关系图利用完整的元数据，并且能够依赖于该元数据的完整性。
- en: However, there may be times when modular code needs to reference packages that
    have not yet been modularized. The solution for this is to place the unmodified
    JAR onto the module path directly (and remove it from the classpath). A JAR placed
    on the module path like this becomes an *automatic module*.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，可能会有时候模块化的代码需要引用尚未模块化的包。解决此问题的方法是将未修改的JAR直接放置在模块路径上（并从类路径中删除它）。像这样放置在模块路径上的JAR成为*自动模块*。
- en: 'This has the following features:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 它具有以下功能：
- en: Module name derived from JAR name (or read from `MANIFEST.MF`)
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块名称源自JAR名称（或从`MANIFEST.MF`中读取）
- en: Exports every package
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导出每个包
- en: Requires all other modules (including the unnamed module)
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要所有其他模块（包括未命名模块）
- en: This is another feature designed to mitigate and help with migration, but some
    safety is still being given up by using automatic modules.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个旨在缓解和帮助迁移的功能，但通过使用自动模块仍然会放弃一些安全性。
- en: Open Modules
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开放模块
- en: As noted, simply marking a method `public` no longer guarantees that the element
    will be accessible everywhere. Instead, accessibility also now depends upon whether
    the package containing that element is exported by its defining module. Another
    major issue in the design of modules is the use of reflection to access classes.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，仅仅将一个方法标记为`public`不再保证该元素在任何地方都可访问。相反，现在访问性也取决于定义模块是否导出包含该元素的包。模块设计中的另一个重要问题是使用反射访问类。
- en: Reflection is such a wide-ranging, general-purpose mechanism that it is difficult
    to see, at first glance, how it can be reconciled with the strong encapsulation
    goals of JPMS. Worse yet, so many of the Java ecosystem’s most important libraries
    and frameworks rely on reflection (e.g., unit testing, dependency injection, and
    many more) that not having a solution for reflection would make modules impossible
    to adopt for any real application.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 反射是一个广泛而通用的机制，初看起来很难看出它如何与JPMS的强封装目标相 reconciled。更糟糕的是，Java 生态系统中许多重要的库和框架都依赖于反射（例如单元测试、依赖注入等），如果没有反射的解决方案，模块对于任何真实应用都将不可能采用。
- en: 'The solution provided is twofold. First, a module can declare itself an `open`
    module, like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的解决方案是双重的。首先，一个模块可以声明自己是一个`open`模块，像这样：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This declaration has the effect that:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这种声明具有以下效果：
- en: All packages in the module can be accessed via reflection
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块中的所有包都可以通过反射访问
- en: Compile-time access is *not* provided for nonexported packages
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译时访问*不*提供给非导出包。
- en: This means that the configuration behaves like a standard module at compile
    time. The overall intent is to provide simple compatibility with existing code
    and frameworks and ease migration pain. With an open module, the previous expectation
    of being able to reflectively access code is restored. In addition, the `setAccessible()`
    hack that allows access to `private` and other methods that would not normally
    permit access is preserved for open modules.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着配置在编译时的行为就像一个标准模块一样。总体意图是提供与现有代码和框架的简单兼容性，并减少迁移的痛苦。对于开放模块，先前能够通过反射访问代码的期望得到恢复。此外，允许访问`private`和其他通常不允许访问的方法的`setAccessible()`
    hack也被保留了。
- en: 'Finer-grained control over reflective access is also provided via the `opens`
    restricted keyword. This does not create an open module but instead selectively
    opens specific packages for reflective access by explicitly declaring certain
    packages to be accessible via reflection:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`opens`限制关键字还提供了对反射访问的更细粒度控制。这不会创建一个开放模块，而是通过显式声明某些包可以通过反射访问来选择性地开放特定包：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This type of usage is likely to be useful when, for example, you are providing
    a domain model to be used by a module-aware *object-relational mapping* (ORM)
    system that needs full reflective access to the core domain types of a module.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要为一个模块感知的*对象-关系映射*（ORM）系统提供完整的反射访问以获取核心域类型时，这种用法可能非常有用。
- en: It is possible to go further and restrict reflective access to specific client
    packages, using the `to` restricted keyword. Where possible, this can be a good
    design principle, but of course such a technique will not work well with a general-purpose
    framework such as an ORM.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 可以进一步限制对特定客户端包的反射访问，使用`to`关键字来实现。在可行的情况下，这可以作为一个良好的设计原则，但当然这种技术在像ORM这样的通用框架中效果不佳。
- en: Note
  id: totrans-119
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In a similar way, it is possible to restrict the export of a package to only
    specific external packages. However, this feature was added largely to help with
    the modularization of the JDK itself, and it has limited applicability to user
    modules.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，还可以限制包的导出仅针对特定外部包。然而，此功能主要是为了帮助JDK本身的模块化而添加的，对用户模块的适用性有限。
- en: Not only that, it is also possible to both export and open a package, but this
    is not recommended—during migration, access to a package should ideally be either
    compile-time or reflective but not both.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅如此，还可以同时导出和开放一个包，但这不被推荐——在迁移期间，最好将对包的访问限制在编译时或反射访问中，而不是同时两者。
- en: In the case where reflective access is required to a package now contained in
    a module, the platform provides some switches to act as band-aids for the transitional
    period.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在一个模块内包含一个需要反射访问的包，则平台提供了一些开关作为过渡期的应急措施。
- en: In particular, the `java` option `--add-opens module/package=ALL-UNNAMED` can
    be used to open a specific package of module for reflective access to all code
    from the classpath, overriding the behavior of the modules system. For code that
    is already modular, it can also be used to allow reflective access to a specific
    module.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，`java` 选项 `--add-opens module/package=ALL-UNNAMED` 可以用来打开模块的特定包，以便对类路径中所有代码进行反射访问，覆盖模块系统的行为。对于已经是模块化的代码，它也可以用来允许对特定模块进行反射访问。
- en: When you are migrating to modular Java, any code that reflectively accesses
    internal code of another module should be run with that switch at first, until
    the situation can be remediated.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当您正在迁移到模块化的 Java 时，任何反射访问另一个模块的内部代码的代码应该首先使用该开关运行，直到情况得到解决。
- en: Related to this issue of reflective access (and a special case of it) is the
    issue of widespread use of internal platform APIs by frameworks. This is usually
    characterized as the “Unsafe problem” and we will encounter it toward the end
    of the chapter.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 与反射访问的这个问题相关（也是它的特殊情况）是框架广泛使用内部平台 API 的问题。这通常被描述为 “Unsafe 问题”，我们将在本章末尾遇到它。
- en: Providing Services
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提供服务
- en: 'The modules system includes the *services* mechanism, to mitigate another problem
    with an advanced form of encapsulation. This problem is simply explained by considering
    a familiar piece of code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 模块系统包含了 *服务* 机制，以缓解封装的高级形式的另一个问题。这个问题可以通过考虑一个熟悉的代码片段来简单地解释：
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Even if `Service` lives in an exported API package, this line of code still
    will not compile unless the package containing `ServiceImpl` is also exported.
    What we need is a mechanism to allow fine-grained access to classes implementing
    service classes without needing the entire package to be imported. For example,
    we could write something like:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 即使 `Service` 存在于一个已导出的 API 包中，这行代码也不会编译通过，除非包含 `ServiceImpl` 的包也被导出。我们需要的是一种机制，允许对实现服务类的类进行细粒度的访问，而无需导入整个包。例如，我们可以这样写：
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now the `ServiceImpl` class is accessible at compile time as an implementation
    of the `Service` interface. Note that the `services` package must be contained
    in another module, which is required by the current module for this provision
    to work.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `ServiceImpl` 类在编译时作为 `Service` 接口的实现可访问。请注意，`services` 包必须包含在另一个模块中，这是当前模块所需要的，以便此提供可以工作。
- en: Multi-Release JARs
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多版本 JAR
- en: 'To explain the problem that is solved by multi-release JARs, let’s consider
    a simple example: finding the process ID (PID) of the currently executing process
    (i.e., the JVM that’s executing our code).'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释多版本 JAR 解决的问题，让我们考虑一个简单的例子：找到当前执行进程的进程 ID（PID）（即，执行我们代码的 JVM）。
- en: Note
  id: totrans-134
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: We don’t use the HTTP/2 example from earlier on, as Java 8 doesn’t have an HTTP/2
    API—so we would have had to do a huge amount of work (essentially a full backport!)
    to provide the equivalent functionality for 8.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不使用之前的 HTTP/2 示例，因为 Java 8 没有 HTTP/2 API，所以我们需要做大量的工作（基本上是完整的后向兼容！）来为 8 提供相同的功能。
- en: 'This may seem like a simple task, but on Java 8 this requires a surprising
    amount of boilerplate code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来是一个简单的任务，但在 Java 8 上，这需要大量的样板代码：
- en: '[PRE17]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As we can see, this is nowhere near as straightforward as we might like. Worse
    still, it is not supported in a standard way across all Java 8 implementations.
    Fortunately, from Java 11 onward, we can use the new `ProcessHandle` API, like
    this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这一点远非我们所希望的那么简单。更糟糕的是，它在所有 Java 8 实现中都没有标准的支持方式。幸运的是，从 Java 11 开始，我们可以使用新的
    `ProcessHandle` API，如下所示：
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This now utilizes a standard API, but it leads to an essential problem: how
    can the developer write code that is guaranteed to run on all current Java versions?'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这使用了一个标准的 API，但它引发了一个基本问题：开发人员如何编写能够在所有当前 Java 版本上运行的代码？
- en: What we want is to build and run a project correctly in multiple Java versions.
    We want to depend on library classes that are only available in later versions
    but still run on an earlier version by using some code “shims.” The end result
    must be a single JAR, and we do not require the project to switch to a multimodule
    format—​in fact, the JAR must work as an automatic module.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要的是正确构建和运行一个项目在多个 Java 版本上。我们想依赖于仅在较新版本中可用的库类，但仍然可以通过使用一些代码 “shims” 在较早版本上运行。最终结果必须是一个单独的
    JAR，并且我们不需要项目切换到多模块格式——事实上，这个 JAR 必须作为自动模块工作。
- en: Let’s look at an example project that has to run correctly in both Java 8 and
    Java 11 or higher. The main codebase is built with Java 8, and the Java 11 portion
    must be built with Java 11. This part of the build must be isolated from the main
    codebase to prevent compilation failures, although it can depend on the build
    artifacts of the Java 8 build.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子项目，它必须在 Java 8 和 Java 11 或更高版本中都能正确运行。主要代码库是用 Java 8 构建的，Java 11 的部分必须用
    Java 11 构建。为了防止编译失败，这部分构建必须与主代码库隔离，尽管它可以依赖于 Java 8 构建的构件。
- en: 'To keep the build configuration simple, this feature is controlled using an
    entry in `MANIFEST.MF` within the JAR file:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持构建配置的简单性，此功能是通过 JAR 文件中的 `MANIFEST.MF` 条目来控制的：
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The variant code (i.e., that for a later version) is then stored in a special
    directory in *META-INF*. In our case, this is *META-INF/versions/11*.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 变体代码（即后续版本的代码）然后存储在 *META-INF* 的特殊目录中。在我们的案例中，这是 *META-INF/versions/11*。
- en: For a Java runtime that implements this feature, any classes in the version-specific
    directory override the versions in the content root. On the other hand, for Java
    8 and earlier versions, both the manifest entry and the *versions/* directory
    are ignored and only the classes in the content root are found.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实现此功能的 Java 运行时，版本特定目录中的任何类都会覆盖内容根目录中的版本。另一方面，对于 Java 8 及更早版本，MANIFEST.MF
    条目和 *versions/* 目录都会被忽略，只会找到内容根目录中的类。
- en: Converting to a Multi-Release JAR
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转换为多版本 JAR
- en: 'To start deploying your software as a multi-release JAR, follow this outline:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始将您的软件部署为多版本 JAR，请按照以下概要进行操作：
- en: Isolate code that is JDK-version-specific
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 隔离依赖于 JDK 版本的特定代码。
- en: If possible, place that code into a package or group of packages
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果可能，将该代码放入一个或一组包中。
- en: Get the version 8 project building cleanly
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使版本 8 项目能够干净地构建
- en: Create a new, separate project for the supplementary classes
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为补充类创建一个新的独立项目。
- en: Set up a single dependency for the new project (the version 8 artifact)
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为新项目设置一个单一的依赖项（版本 8 构件）。
- en: 'For Gradle, you can also use the concept of a *source set* and compile the
    v11 code using a different (later) compiler. This can then be built into a JAR
    using a stanza like this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Gradle，您还可以使用 *source set* 的概念，并使用不同（较新）的编译器编译 v11 代码。然后可以使用类似以下的段落将其构建为
    JAR 文件：
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: For Maven, the current easiest route is to use the Maven Dependency Plug-in
    and add the modular classes to the overall JAR as part of the separate `generate-resources`
    phase.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Maven，当前最简单的方法是使用 Maven 依赖插件，并在单独的 `generate-resources` 阶段将模块化类添加到整体 JAR
    中。
- en: Migrating to Modules
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迁移到模块
- en: Many Java developers are facing the question of whether, and when, they should
    migrate their applications to use modules.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 Java 开发人员面临一个问题，即是否以及何时应该将他们的应用程序迁移到使用模块。
- en: Tip
  id: totrans-159
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Modules should be the default for all greenfield apps, especially those that
    are architected in a microservices style.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 模块应该成为所有新开发的应用程序的默认选项，特别是那些采用微服务架构的应用。
- en: Many applications will not need to be migrated at all. However, modularizing
    existing code bases can be worthwhile because the better encapsulation and overall
    architectural benefits do pay off over the longer term—allowing new developers
    to be brought onto the team faster and providing a clear structure that is easier
    to understand and maintain.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序根本不需要迁移。然而，将现有代码库模块化确实值得，因为更好的封装和整体架构上的好处会在长期内显现出来——可以更快地引入新开发人员，并提供更清晰的结构，易于理解和维护。
- en: 'When considering migration of an existing app (especially a monolithic design),
    you can use the following roadmap:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑迁移现有应用程序（特别是单体设计）时，可以使用以下路线图：
- en: First upgrade the application runtime to Java 17 (running from the classpath
    initially)
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先将应用程序运行时升级到 Java 17（最初从类路径运行）。
- en: Identify any application dependencies that have been modularized and migrate
    those dependencies to modules
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定已模块化的任何应用程序依赖项，并将这些依赖项迁移到模块中。
- en: Retain any nonmodularized dependencies as automatic modules
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有非模块化的依赖项保留为自动模块。
- en: Introduce a single *monolithic module* of all application code
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 引入一个单一的 *单体模块*，包含所有应用程序代码。
- en: At this point, a minimally modularized application should be ready for production
    deployment. This module will usually be an `open` module at this stage of the
    process. The next step is architectural refactoring; at this point, applications
    can be broken out into individual modules as needed.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Once the application code runs in modules, it can make sense to limit reflective
    access to your code via `opens`. This access can be restricted to specific modules
    (such as ORM or dependency injection modules) as a first step toward removing
    any unnecessary access.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'For Maven users, it’s worth remembering that Maven is not a modules system,
    but it does have dependencies—and (unlike JPMS dependencies) they are versioned.
    The Maven tooling is still evolving to fully integrate with JPMS (and many plug-ins
    have not caught up at the time of this writing). However, some general guidelines
    for modular Maven projects are emerging, specifically:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Aim to produce one module per Maven POM
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t modularize a Maven project until you are ready (or have an immediate need
    to)
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember that running on a Java 11+ runtime does not require building on a Java
    11+ toolchain
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last point indicates that one path for migration of Maven projects is to
    start by building as a Java 8 project and ensuring that those Maven artifacts
    can deploy cleanly (as automatic modules) on a Java 11 (or 17) runtime. Only once
    that first step is working properly should a full modularization be undertaken.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Some good tooling support is available to help with the modularization process.
    Java 8 and up ships with `jdeps` (see [Chapter 13](ch13.xhtml#javanut8-CHP-13)),
    a tool for determining which packages and modules your code depends upon. This
    is very helpful for migrations from Java 8 and the use of `jdeps` when rearchitecting
    is recommended.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Custom Runtime Images
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the key goals of JPMS is the possibility that applications may need
    not every class present in the traditional monolithic runtime of Java 8 and instead
    can manage with a smaller subset of modules. Such applications can have a much
    smaller footprint in terms of startup time and memory overhead. This can be taken
    further: if not all classes are needed, then why not ship an application together
    with a reduced, custom runtime image that includes only what’s necessary?'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate the idea, let’s package the HTTP/2 checker into a standalone
    tool with a custom runtime. We can use the `jlink` tool (which has been part of
    the platform since Java 9) to achieve this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note that this assumes that JAR file *httpchecker.jar* was created with a main
    class (aka entry point). The result is an output directory, *http2chk-image*,
    which is about 39M in size, much less than the full image. This also notes that
    because the tool uses the new HTTP module, it requires the libraries for security,
    crypto, and so on when connecting using HTTPS.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'From within the custom image directory, we can run the `http2chk` tool directly
    and see that it works even when the machine does not have the required version
    of `java`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在自定义镜像目录中，我们可以直接运行`http2chk`工具，并查看它在机器没有所需版本的`java`时也可以工作：
- en: '[PRE22]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The deployment of custom runtime images is still quite a new tool, but it has
    great potential to reduce your code footprint and help Java remain competitive
    in the age of microservices. In the future, `jlink` could even be combined with
    new approaches to compilation, including an ahead-of-time (AOT) compiler.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义运行时镜像的部署仍然是一种相当新的工具，但它具有减少代码占用空间并帮助Java在微服务时代保持竞争力的巨大潜力。未来，`jlink`甚至可以与新的编译方法结合使用，包括提前（AOT）编译器。
- en: Issues with Modules
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块化的问题
- en: The modules system, despite being the flagship feature of Java 9 and having
    had a large amount of engineering time devoted to it, is not without its problems.
    This was, perhaps, inevitable—the feature fundamentally changes how Java applications
    are architected and delivered. It would have been almost impossible for modules
    to avoid running up against some problems when trying to retrofit over the large,
    mature ecosystem that is Java.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管模块系统是Java 9的旗舰功能，并且已经花费了大量的工程时间来开发它，但它也不是没有问题。这或许是不可避免的——这一功能从根本上改变了Java应用程序的架构和交付方式。当试图为Java的成熟生态系统提供后向兼容时，模块几乎不可能避免遇到一些问题。
- en: Unsafe and Related Problems
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Unsafe`及其相关问题'
- en: '`sun.misc.Unsafe` is a class that is both widely used and popular with framework
    writers and other implementors within the Java world. However, it is an internal
    implementation class and is not part of the standard API of the Java platform
    (as the package name clearly indicates). The class name also provides a fairly
    strong clue that this is not really intended for use by Java applications.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`sun.misc.Unsafe`是一个在Java世界中被广泛使用和受欢迎的类，特别是在框架编写者和其他实现者中。然而，它是一个内部实现类，并不是Java平台标准API的一部分（正如包名所清楚表明的）。类名也很明显地表明这实际上不是为Java应用程序使用而设计的。'
- en: '`Unsafe` is an unsupported, internal API and so could be withdrawn or modified
    by any new Java version, without regard to the effect on user applications. Any
    code that does use it is technically directly coupled to the HotSpot JVM and is
    also potentially nonstandard and may not run on other implementations.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`Unsafe`是一个不受支持的内部API，因此可能会在任何新的Java版本中被撤回或修改，而不考虑对用户应用程序的影响。任何使用它的代码技术上都直接耦合于HotSpot
    JVM，并且可能是非标准的，并且可能无法在其他实现上运行。'
- en: 'Although not an official part of Java SE in any way, `Unsafe` has become a
    de facto standard and key part of the implementation of basically every major
    framework in one way or another. Over subsequent versions it has evolved into
    a kind of dumping ground for nonstandard but necessary features. This admixture
    of features is a real mixed bag, with varying degrees of safety provided by each
    capability. Example uses of `Unsafe` include:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`Unsafe`并非以任何方式成为Java SE的官方部分，但已成为事实上的标准，并成为几乎每个主要框架实现的关键部分之一。随着版本的不断更新，它已经演变成为一种非标准但必要功能的垃圾桶。这些功能的混合使用形成了一个真正的混合包，每种能力提供的安全程度各不相同。`Unsafe`的示例用途包括：
- en: Fast serialization/deserialization
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速序列化/反序列化
- en: Threadsafe 64-bit sized native memory access (e.g., offheap)
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程安全的64位大小的本地内存访问（例如，堆外内存）
- en: Atomic memory operations (e.g., Compare-and-Swap)
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原子内存操作（例如，比较并交换）
- en: Fast field/memory access
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速字段/内存访问
- en: Multi-operating system replacement for JNI
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多操作系统替代JNI
- en: Access to array items with volatile semantics (see [Chapter 6](ch06.xhtml#javanut8-CHP-6))
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问具有volatile语义的数组项（参见 [第6章](ch06.xhtml#javanut8-CHP-6)）
- en: The essential problem is that many frameworks and libraries were unable to move
    to a modular JDK without replacement for some `Unsafe` features. In turn, this
    impacts everyone using any libraries from a wide range of frameworks—basically
    every application in the Java ecosystem.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 核心问题在于许多框架和库在没有某些`Unsafe`功能的替代方案的情况下无法迁移到模块化的JDK。这反过来影响了使用Java生态系统中各种框架的每个应用程序。
- en: To fix this problem, Oracle created new, supported APIs for some of the needed
    functionality and segregated APIs that could not be encapsulated in time into
    a module, `jdk.unsupported`. This makes it clear this is not a supported API and
    that developers use it at their own risk. This gives `Unsafe` a temporary pass
    (which is strictly limited time) while encouraging library and framework developers
    to move to the new APIs.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为解决这个问题，Oracle为一些所需功能创建了新的受支持的API，并将无法及时封装到模块中的API分离出来，`jdk.unsupported`。这清楚地表明这不是一个受支持的API，开发人员使用它需自担风险。这使得`Unsafe`获得了临时许可证（严格限制时间），同时鼓励库和框架开发人员转移到新的API。
- en: An example of a replacement API is VarHandles. These extend the *Method Handles*
    concept (from [Chapter 11](ch11.xhtml#javanut8-CHP-11)) and add new functionality,
    such as concurrency barrier modes for Java 11. These, along with some modest updates
    to JMM, are intended to produce a standard API for accessing new low-level processor
    features without allowing developers full access to dangerous capabilities, as
    were found in `Unsafe`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 替代API的一个示例是VarHandles。这些扩展了*Method Handles*概念（来自[第11章](ch11.xhtml#javanut8-CHP-11)）并添加了新功能，例如Java
    11的并发障碍模式。这些，连同对JMM的一些适度更新，旨在生成用于访问新低级处理器功能的标准API，而不允许开发人员完全访问危险功能，就像`Unsafe`中发现的一样。
- en: More details about `Unsafe` and related low-level platform techniques can be
    found in [*Optimizing Java*](http://shop.oreilly.com/product/0636920121718.do)
    (O’Reilly).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`Unsafe`和相关低级平台技术的更多详细信息可在[*Optimizing Java*](http://shop.oreilly.com/product/0636920121718.do)（O’Reilly）中找到。
- en: Lack of Versioning
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缺乏版本控制
- en: The JPMS standard as of Java 17 does not include the versioning of dependencies.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Java 17的JPMS标准不包括依赖项的版本控制。
- en: Note
  id: totrans-201
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This was a deliberate design decision to reduce the complexity of the delivered
    system and does not preclude the possibility that modules could include versioned
    dependencies in the future.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有意的设计决定，旨在降低交付系统的复杂性，并不排除未来模块可能包含有版本的依赖项的可能性。
- en: The current situation requires external tools to handle the versioning of module
    dependencies. In the case of Maven, this will be within the Project Object Model
    (POM). An advantage to this approach is that the download and management of versions
    are also handled within the local repository of the build tool.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当前情况需要外部工具来处理模块依赖项的版本控制。在Maven的情况下，这将在项目对象模型（POM）中完成。这种方法的一个优点是下载和管理版本也在构建工具的本地存储库中处理。
- en: However it is done, though, the simple fact is that the dependency version information
    must be stored out of the module and does not form part of the JAR artifact.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，无论如何，简单的事实是，依赖版本信息必须存储在模块之外，并且不构成JAR工件的一部分。
- en: There’s no getting away from it—this is pretty ugly, but the counterpoint is
    that the situation is no worse than it was with dependencies being deduced from
    the classpath.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 无法摆脱——这相当丑陋，但与从类路径中推导出依赖项的情况相比，情况并不更糟。
- en: Slow Adoption Rates
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 采用率缓慢
- en: With the release of Java 9, the Java release model fundamentally changed. Java
    8 and 9 used the “keystone release” model—where one keystone (or landmark) feature
    such as lambdas for Java 8 or modules for Java 9—essentially defined the release
    and so the ship date was determined by when the feature was complete.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Java 9的发布，Java发布模型在根本上发生了变化。 Java 8和9使用了“关键发布”模型——其中一个关键（或标志性）功能，如Java 8的lambda或Java
    9的模块——基本上定义了发布，因此交付日期取决于功能何时完成。
- en: The problem with this model is that it can cause inefficiencies due to uncertainty
    about when versions will ship. In particular, a small feature that just misses
    a release will have to wait a long time for the next major release. As a result,
    from Java 10 onward, a new release model was adopted, which introduces *strict
    time-based versioning*.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模型的问题在于，由于不确定版本何时发布，可能会导致效率低下。特别是，只是错过发布的一个小功能将不得不等待很长时间才能等到下一个主要发布版。因此，从Java
    10开始，采用了一种新的发布模型，引入了*严格的基于时间的版本控制*。
- en: 'This means:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着：
- en: Java releases are now classified as *feature* releases, which occur at a regular
    cadence of once every six months.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java现在被分类为*功能*发布，每六个月定期发生一次。
- en: Features are not merged into the platform until they are essentially complete.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能在基本上完成之前不会合并到平台中。
- en: The mainline repo is in a releasable state at all times.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主线仓库始终处于可发布状态。
- en: These releases are good for only six months, after which time they are no longer
    supported. Certain releases are designated by Oracle as *long-term support* (LTS)
    releases. These have extended, paid-for support available from Oracle.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这些发布仅适用于六个月，过后将不再得到支持。Oracle将某些版本指定为*长期支持*（LTS）版本，用户可以从Oracle获取扩展的付费支持。
- en: The release cadence of these LTS releases was initially three years but at time
    of writing is expected to change to two years. This means that Oracle LTS releases
    are currently 8 (retrospectively added), 11, and 17; the expected next release
    will be Java 21 in September 2023.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这些LTS版本最初的发布节奏是三年，但预计在撰写本文时将改为两年。这意味着Oracle的LTS版本目前是8（事后添加的）、11和17；预计下一个版本将在2023年9月发布Java
    21。
- en: However, as well as Oracle, builds of OpenJDK are available from other providers
    including Amazon, Azul, Eclipse Adoptium, IBM, Microsoft, Red Hat, and SAP. These
    vendors offer various ways to get JDK updates (including security) at zero cost.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Oracle外，OpenJDK的版本还可以从包括Amazon、Azul、Eclipse Adoptium、IBM、Microsoft、Red Hat和SAP在内的其他供应商获取。这些供应商提供多种获取JDK更新（包括安全更新）的方式，且零成本。
- en: There are also new and existing paid support models available from several of
    the above vendors.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 还有多种付费支持模型从上述供应商提供。
- en: 'For an in-depth write-up of this topic, please see the guide: [“Java Is Still
    Free”](https://oreil.ly/Cz61R) by the [Java Champions community](https://oreil.ly/NGIpB),
    an independent body of Java leaders in the software industry.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 欲深入了解此主题，请参阅指南：[“Java Is Still Free”](https://oreil.ly/Cz61R) by the [Java Champions
    community](https://oreil.ly/NGIpB)，这是Java行业中独立的Java领袖组成的团体。
- en: Although the Java community is generally positive on the new faster release
    cycle, adoption rates of Java 9 and above have been much smaller than for previous
    releases. This may be due to the desire of teams to have longer support cycles,
    rather than upgrading to each feature release after only six months. In practice,
    only the LTS releases are seeing widespread adoption, and even that has been slow
    compared to the rapid uptake of Java 8.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Java社区普遍对新的更快发布周期持积极态度，但Java 9及以上版本的采纳率远低于以往版本。这可能是因为团队希望有更长的支持周期，而不是仅在六个月后升级到每个特性发布。实际上，只有LTS版本才看到广泛采用，甚至与Java
    8的快速普及相比也较慢。
- en: It is also the case that the upgrade from Java 8 to 11 (or 17) is not a drop-in
    replacement (unlike 7 to 8, and to a lesser extent 6 to 7). The modules subsystem
    fundamentally changes many aspects of the Java platform, even if end-user applications
    do not take advantage of modules.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 从Java 8升级到11（或17）也不是一种插拔替换（与7到8、6到7相比）。即使最终用户应用程序不利用模块，模块子系统也从根本上改变了Java平台的许多方面。
- en: Four years after the release of Java 11, it seems to have finally overtaken
    Java 8, with more workloads now running on Java 11 than 8. It remains to be seen
    how quickly Java 17 will be adopted and what the impact of Java 21 will be (assuming
    that 21 is indeed the next LTS).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 11发布四年后，它似乎终于超过了Java 8，现在更多工作负载在Java 11上运行而不是8。Java 17的采用速度以及Java 21的影响有待观察（假设21确实是下一个LTS版本）。
- en: Summary
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The modules feature, first introduced in Java 9, aims to solve several problems
    at once. The aims of shorter startup time, lower footprint, and reduced complexity
    by denying access to internals have all been met. The longer-term goals of enabling
    better architecture of applications and starting to think about new approaches
    for compilation and deployment are still in progress.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9首次引入的模块化特性旨在一次解决多个问题。通过拒绝访问内部实现，已经实现了更短的启动时间、更小的内存占用和减少的复杂性目标。长期目标是实现更好的应用架构，并开始思考编译和部署的新方法，这些目标仍在进行中。
- en: However, the plain fact is that, as of the release of Java 17, not many teams
    and projects have moved wholeheartedly to the modular world. This is to be expected,
    as modularity is a long-term project that has a slow payoff and relies on network
    effects within the ecosystem to achieve the full benefit.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，事实是，截至Java 17发布时，很少有团队和项目全面转向模块化世界。这是可以预料的，因为模块化是一个长期的项目，回报缓慢，并依赖于生态系统内部的网络效应来实现全部收益。
- en: New applications should definitely consider building in a modular way from the
    get-go, but the overall story of platform modularity within the Java ecosystem
    is still only beginning.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 新应用程序在一开始时应考虑以模块化方式构建，但Java生态系统内平台模块性的整体故事仍处于初期阶段。
