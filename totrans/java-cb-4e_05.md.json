["```java\n// numbers/RealValues.java\nSystem.out.println(\"The real value 0.3 is \" + 0.3);\n```", "```java\nThe real value 0.3 is 0.3\n```", "```java\nThe real 0.3 times 3 is 0.89999999999999991\n```", "```java\n    public static void main(String[] argv) {\n        String aNumber = argv[0];    // not argv[1]\n        double result;\n        try {\n            result = Double.parseDouble(aNumber);\n            System.out.println(\"Number is \" + result);\n        } catch(NumberFormatException exc) {\n            System.out.println(\"Invalid number \" + aNumber);\n            return;\n        }\n    }\n```", "```java\n    /*\n * Process one String, returning it as a Number subclass\n */\n    public static Number process(String s) {\n        if (s.matches(\"[+-]*\\\\d*\\\\.\\\\d+[dDeEfF]*\")) {\n            try {\n                double dValue = Double.parseDouble(s);\n                System.out.println(\"It's a double: \" + dValue);\n                return Double.valueOf(dValue);\n            } catch (NumberFormatException e) {\n                System.out.println(\"Invalid double: \" + s);\n                return Double.NaN;\n            }\n        } else // did not contain . d e or f, so try as int.\n            try {\n                int iValue = Integer.parseInt(s);\n                System.out.println(\"It's an int: \" + iValue);\n                return Integer.valueOf(iValue);\n            } catch (NumberFormatException e2) {\n                System.out.println(\"Not a number: \" + s);\n                return Double.NaN;\n            }\n    }\n```", "```java\npublic class AutoboxDemo {\n\n    /** Shows auto-boxing (in the call to foo(i), i is wrapped automatically)\n     * and auto-unboxing (the return value is automatically unwrapped).\n     */\n    public static void main(String[] args) {\n        int i = 42;\n        int result = foo(i);            ![1](assets/1.png)\n        System.out.println(result);\n    }\n\n    public static Integer foo(Integer i) {\n        System.out.println(\"Object = \" + i);\n        return Integer.valueOf(123);    ![2](assets/2.png)\n    }\n}\n```", "```java\npublic class IntObject {\n    public static void main(String[] args) {\n        // int to Integer\n        Integer i1 = Integer.valueOf(42);\n        System.out.println(i1.toString());        // or just i1\n\n        // Integer to int\n        int i2 = i1.intValue();\n        System.out.println(i2);\n    }\n}\n```", "```java\npublic class FractMult {\n    public static void main(String[] u) {\n\n        double d1 = 0.666 * 5;  // fast but obscure and inaccurate: convert\n        System.out.println(d1); // 2/3 to 0.666 in programmer's head\n\n        double d2 = 2/3 * 5;    // wrong answer - 2/3 == 0, 0*5 = 0\n        System.out.println(d2);\n\n        double d3 = 2d/3d * 5;  // \"normal\"\n        System.out.println(d3);\n\n        double d4 = (2*5)/3d;   // one step done as integers, almost same answer\n        System.out.println(d4);\n\n        int i5 = 2*5/3;         // fast, approximate integer answer\n        System.out.println(i5);\n    }\n}\n```", "```java\n$ java numbers.FractMult\n3.33\n0.0\n3.333333333333333\n3.3333333333333335\n3\n$\n```", "```java\nx == NaN\n```", "```java\n    public static void main(String[] argv) {\n        double d = 123;\n        double e = 0;\n        if (d/e == Double.POSITIVE_INFINITY)\n            System.out.println(\"Check for POSITIVE_INFINITY works\");\n        double s = Math.sqrt(-1);\n        if (s == Double.NaN)\n            System.out.println(\"Comparison with NaN incorrectly returns true\");\n        if (Double.isNaN(s))\n            System.out.println(\"Double.isNaN() correctly returns true\");\n    }\n```", "```java\npublic class Heron {\n    public static void main(String[] args) {\n        // Sides for triangle in float\n        float af, bf, cf;\n        float sf, areaf;\n\n        // Ditto in double\n        double ad, bd, cd;\n        double sd, aread;\n\n        // Area of triangle in float\n        af = 12345679.0f;\n        bf = 12345678.0f;\n        cf = 1.01233995f;\n\n        sf = (af+bf+cf)/2.0f;\n        areaf = (float)Math.sqrt(sf * (sf - af) * (sf - bf) * (sf - cf));\n        System.out.println(\"Single precision: \" + areaf);\n\n        // Area of triangle in double\n        ad = 12345679.0;\n        bd = 12345678.0;\n        cd = 1.01233995;\n\n        sd = (ad+bd+cd)/2.0d;\n        aread = Math.sqrt(sd * (sd - ad) * (sd - bd) * (sd - cd));\n        System.out.println(\"Double precision: \" + aread);\n    }\n}\n```", "```java\n$ java numbers.Heron\nSingle precision: 0.0\nDouble precision: 972730.0557076167\n\n```", "```java\njshell> Float f1 = Float.valueOf(Float.NaN)\nf1 ==> NaN\n\njshell> Float f2 = Float.valueOf(Float.NaN)\nf2 ==> NaN\n\njshell> f1 == f2 # Comparing object identities\n$4 ==> false\n\njshell> f1.equals(f1) # bitwise comparison of values\n$5 ==> true\n```", "```java\n$ java numbers.FloatCmp\nTrue within epsilon 1.0E-7\n$\n```", "```java\npublic class FloatCmp {\n\n    final static double EPSILON = 0.0000001;\n\n    public static void main(String[] argv) {\n        double da = 3 * .3333333333;\n        double db = 0.99999992857;\n\n        // Compare two numbers that are expected to be close.\n        if (da == db) {\n            System.out.println(\"Java considers \" + da + \"==\" + db);\n        // else compare with our own equals overload\n        } else if (equals(da, db, 0.0000001)) {\n            System.out.println(\"Equal within epsilon \" + EPSILON);\n        } else {\n            System.out.println(da + \" != \" + db);\n        }\n\n        System.out.println(\"NaN prints as \" + Double.NaN);\n\n        // Show that comparing two NaNs is not a good idea:\n        double nan1 = Double.NaN;\n        double nan2 = Double.NaN;\n        if (nan1 == nan2)\n            System.out.println(\"Comparing two NaNs incorrectly returns true.\");\n        else\n            System.out.println(\"Comparing two NaNs correctly reports false.\");\n\n        if (Double.valueOf(nan1).equals(Double.valueOf(nan2)))\n            System.out.println(\"Double(NaN).equals(NaN) correctly returns true.\");\n        else\n            System.out.println(\n                \"Double(NaN).equals(NaN) incorrectly returns false.\");\n    }\n\n    /** Compare two doubles within a given epsilon */\n    public static boolean equals(double a, double b, double eps) {\n        if (a==b) return true;\n        // If the difference is less than epsilon, treat as equal.\n        return Math.abs(a - b) < eps;\n    }\n\n    /** Compare two doubles, using default epsilon */\n    public static boolean equals(double a, double b) {\n        return equals(a, b, EPSILON);\n    }\n}\n```", "```java\npublic class Round {\n    /** We round a number up if its fraction exceeds this threshold. */\n    public static final double THRESHOLD = 0.54;\n\n    /*\n * Round floating values to integers.\n * @return the closest int to the argument.\n * @param d A non-negative values to be rounded.\n */\n    public static int round(double d) {\n        return (int)Math.floor(d + 1.0 - THRESHOLD);\n    }\n\n    public static void main(String[] argv) {\n        for (double d = 0.1; d<=1.0; d+=0.05) {\n            System.out.println(\"My way:  \" + d + \"-> \" + round(d));\n            System.out.println(\"Math way:\" + d + \"-> \" + Math.round(d));\n        }\n    }\n}\n```", "```java\npublic class NumFormat2 {\n    /** A number to format */\n    public static final double data[] = {\n        0, 1, 22d/7, 100.2345678\n    };\n\n    /** The main (and only) method in this class. */\n    public static void main(String[] av) {\n        // Get a format instance\n        NumberFormat form = NumberFormat.getInstance();\n\n        // Set it to look like 999.99[99]\n        form.setMinimumIntegerDigits(3);\n        form.setMinimumFractionDigits(2);\n        form.setMaximumFractionDigits(4);\n\n        // Now print using it\n        for (int i=0; i<data.length; i++)\n            System.out.println(data[i] + \"\\tformats as \" +\n                form.format(data[i]));\n    }\n}\n```", "```java\n$ java numbers.NumFormat2\n0.0     formats as 000.00\n1.0     formats as 001.00\n3.142857142857143       formats as 003.1429\n100.2345678     formats as 100.2346\n$\n```", "```java\n    /** A number to format */\n    public static final double intlNumber = 1024.25;\n    /** Another number to format */\n    public static final double ourNumber = 100.2345678;\n        NumberFormat defForm = NumberFormat.getInstance();\n        NumberFormat ourForm = new DecimalFormat(\"##0.##\");\n        // toPattern() will reveal the combination of #0., etc\n        // that this particular Locale uses to format with!\n        System.out.println(\"defForm's pattern is \" +\n            ((DecimalFormat)defForm).toPattern());\n        System.out.println(intlNumber + \" formats as \" +\n            defForm.format(intlNumber));\n        System.out.println(ourNumber + \" formats as \" +\n            ourForm.format(ourNumber));\n        System.out.println(ourNumber + \" formats as \" +\n            defForm.format(ourNumber) + \" using the default format\");\n```", "```java\n$ java numbers.NumFormatDemo\ndefForm's pattern is #,##0.###\n1024.25 formats as 1,024.25\n100.2345678 formats as 100.23\n100.2345678 formats as 100.235 using the default format\n$\n```", "```java\npublic class CompactFormatDemo {\n\n    static final Number[] nums = {\n        0, 1, 1.25, 1234, 12345, 123456.78, 123456789012L\n    };\n    static final String[] strs = {\n        \"1\", \"1.25\", \"1234\", \"12.345K\", \"1234556.78\", \"123456789012L\"\n    };\n\n    public static void main(String[] args) throws ParseException {\n        NumberFormat cnf = NumberFormat.getCompactNumberInstance();\n        System.out.println(\"Formatting:\");\n        for (Number n : nums) {\n            cnf.setParseIntegerOnly(false);\n            cnf.setMinimumFractionDigits(2);\n            System.out.println(n + \": \" + cnf.format(n));\n        }\n        System.out.println(\"Parsing:\");\n        for (String s : strs) {\n            System.out.println(s + \": \" + cnf.parse(s));\n        }\n    }\n\n}\n```", "```java\n        RomanNumberFormat nf = new RomanNumberFormat();\n        int year = LocalDate.now().getYear();\n        System.out.println(year + \" -> \" + nf.format(year));\n```", "```java\n2020->MMXX\n```", "```java\n        String input = \"101010\";\n        for (int radix : new int[] { 2, 8, 10, 16, 36 }) {\n            System.out.print(input + \" in base \" + radix + \" is \"\n                    + Integer.valueOf(input, radix) + \"; \");\n            int i = 42;\n            System.out.println(i + \" formatted in base \" + radix + \" is \"\n                    + Integer.toString(i, radix));\n        }\n```", "```java\n$ java numbers.IntegerBinOctHexEtc\n101010 in base 2 is 42; 42 formatted in base 2 is 101010\n101010 in base 8 is 33288; 42 formatted in base 8 is 52\n101010 in base 10 is 101010; 42 formatted in base 10 is 42\n101010 in base 16 is 1052688; 42 formatted in base 16 is 2a\n101010 in base 36 is 60512868; 42 formatted in base 36 is 16\n$ \n```", "```java\npublic class NumSeries {\n    public static void main(String[] args) {\n\n        // For ordinal list of numbers n to m, use rangeClosed(start, endInclusive)\n        IntStream.rangeClosed(1, 12).forEach(\n            i -> System.out.println(\"Month # \" + i));\n\n        // Or, use a for loop starting at 1.\n        for (int i = 1; i <= months.length; i++)\n            System.out.println(\"Month # \" + i);\n\n        // Or a foreach loop\n        for (String month : months) {\n            System.out.println(month);\n        }\n\n        // When you want a set of array indices, use range(start, endExclusive)\n        IntStream.range(0, months.length).forEach(\n            i -> System.out.println(\"Month \" + months[i]));\n\n        // Or, use a for loop starting at 0.\n        for (int i = 0; i < months.length; i++)\n            System.out.println(\"Month \" + months[i]);\n\n        // For e.g., counting by 3 from 11 to 27, use a for loop\n        for (int i = 11; i <= 27; i += 3) {\n            System.out.println(\"i = \" + i);\n        }\n\n        // A discontiguous set of integers, using a BitSet\n\n        // Create a BitSet and turn on a couple of bits.\n        BitSet b = new BitSet();\n        b.set(0);    // January\n        b.set(3);    // April\n        b.set(8);    // September\n\n        // Presumably this would be somewhere else in the code.\n        for (int i = 0; i<months.length; i++) {\n            if (b.get(i))\n                System.out.println(\"Month \" + months[i]);\n        }\n\n        // Same example but shorter:\n        // a discontiguous set of integers, using an array\n        int[] numbers = {0, 3, 8};\n\n        // Presumably somewhere else in the code... Also a foreach loop\n        for (int n : numbers) {\n            System.out.println(\"Month: \" + months[n]);\n        }\n    }\n    /** Names of months. See Dates/Times chapter for a better way to get these */\n    protected static String months[] = {\n        \"January\", \"February\", \"March\", \"April\",\n        \"May\", \"June\", \"July\", \"August\",\n        \"September\", \"October\", \"November\", \"December\"\n    };\n}\n```", "```java\npublic class FormatPlurals {\n    public static void main(String[] argv) {\n        report(0);\n        report(1);\n        report(2);\n    }\n\n    /** report -- using conditional operator */\n    public static void report(int n) {\n        System.out.println(\"We used \" + n + \" item\" + (n==1?\"\":\"s\"));\n    }\n}\n```", "```java\n$ java numbers.FormatPlurals\nWe used 0 items\nWe used 1 item\nWe used 2 items\n$\n```", "```java\nif (n==1)\n    System.out.println(\"We used \" + n + \" item\");\nelse\n    System.out.println(\"We used \" + n + \" items\");\n```", "```java\npublic class FormatPluralsChoice extends FormatPlurals {\n\n    // ChoiceFormat to just give pluralized word\n    static double[] limits = { 0, 1, 2 };\n    static String[] formats = { \"reviews\", \"review\", \"reviews\"};\n    static ChoiceFormat pluralizedFormat = new ChoiceFormat(limits, formats);\n\n    // ChoiceFormat to give English text version, quantified\n    static ChoiceFormat quantizedFormat = new ChoiceFormat(\n        \"0#no reviews|1#one review|1<many reviews\");\n\n    // Test data\n    static int[] data = { -1, 0, 1, 2, 3 };\n\n    public static void main(String[] argv) {\n        System.out.println(\"Pluralized Format\");\n        for (int i : data) {\n            System.out.println(\"Found \" + i + \" \" + pluralizedFormat.format(i));\n        }\n\n        System.out.println(\"Quantized Format\");\n        for (int i : data) {\n            System.out.println(\"Found \" + quantizedFormat.format(i));\n        }\n    }\n}\n```", "```java\n// numbers/Random1.java\n// java.lang.Math.random( ) is static, don't need any constructor calls\nSystem.out.println(\"A random from java.lang.Math is \" + Math.random( ));\n```", "```java\npublic class RandomInt {\n    public static void main(String[] a) {\n        Random r = new Random();\n        for (int i=0; i<1000; i++)\n            // nextInt(10) goes from 0-9; add 1 for 1-10;\n            System.out.println(1+r.nextInt(10));\n    }\n}\n```", "```java\n$ java numbers.RandomInt | sort | uniq -c | sort -k 2 -n\n  96 1\n 107 2\n 102 3\n 122 4\n  99 5\n 105 6\n  97 7\n  96 8\n  79 9\n  97 10\n$ java -cp build numbers.RandomInt | sort | uniq -c | sort -k 2 -n\n  86 1\n  88 2\n 110 3\n  97 4\n  99 5\n 109 6\n  82 7\n 116 8\n  99 9\n 114 10\n$\n\n```", "```java\n    // java.util.Random methods are non-static, so need to construct\n    Random r = new Random();\n    for (int i=0; i<10; i++)\n    System.out.println(\"A double from java.util.Random is \" + r.nextDouble());\n    for (int i=0; i<10; i++)\n    System.out.println(\"An integer from java.util.Random is \" + r.nextInt());\n```", "```java\n// numbers/Random3.java\nRandom r = new Random();\nfor (int i = 0; i < 10; i++)\n    System.out.println(\"A gaussian random double is \" + r.nextGaussian());\n```", "```java\npublic class Matrix {\n\n    /* Matrix-multiply two arrays together.\n * The arrays MUST be rectangular.\n * @author Adapted from Tom Christiansen & Nathan Torkington's\n * implementation in their Perl Cookbook.\n */\n    public static int[][] multiply(int[][] m1, int[][] m2) {\n        int m1rows = m1.length;\n        int m1cols = m1[0].length;\n        int m2rows = m2.length;\n        int m2cols = m2[0].length;\n        if (m1cols != m2rows)\n            throw new IllegalArgumentException(\n                \"matrices don't match: \" + m1cols + \" != \" + m2rows);\n        int[][] result = new int[m1rows][m2cols];\n\n        // multiply\n        for (int i=0; i<m1rows; i++) {\n            for (int j=0; j<m2cols; j++) {\n                for (int k=0; k<m1cols; k++) {\n                    result[i][j] += m1[i][k] * m2[k][j];\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /** Matrix print.\n */\n    public static void mprint(int[][] a) {\n        int rows = a.length;\n        int cols = a[0].length;\n        System.out.println(\"array[\"+rows+\"][\"+cols+\"] = {\");\n        for (int i=0; i<rows; i++) {\n            System.out.print(\"{\");\n            for (int j=0; j<cols; j++)\n                System.out.print(\" \" + a[i][j] + \",\");\n            System.out.println(\"},\");\n        }\n        System.out.println(\"};\");\n    }\n}\n```", "```java\n        int x[][] = {\n            { 3, 2, 3 },\n            { 5, 9, 8 },\n        };\n        int y[][] = {\n            { 4, 7 },\n            { 9, 3 },\n            { 8, 1 },\n        };\n        int z[][] = Matrix.multiply(x, y);\n        Matrix.mprint(x);\n        Matrix.mprint(y);\n        Matrix.mprint(z);\n```", "```java\npublic class ComplexDemoACM {\n\n    public static void main(String[] args) {\n        Complex c = new Complex(3,  5);\n        Complex d = new Complex(2, -2);\n        System.out.println(c);\n        System.out.println(c + \".getReal() = \" + c.getReal());\n        System.out.println(c + \" + \" + d + \" = \" + c.add(d));\n        System.out.println(c + \" + \" + d + \" = \" + c.add(d));\n        System.out.println(c + \" * \" + d + \" = \" + c.multiply(d));\n        System.out.println(c.divide(d));\n    }\n}\n```", "```java\n(3.0, 5.0)\n(3.0, 5.0).getReal() = 3.0\n(3.0, 5.0) + (2.0, -2.0) = (5.0, 3.0)\n(3.0, 5.0) + (2.0, -2.0) = (5.0, 3.0)\n(3.0, 5.0) * (2.0, -2.0) = (16.0, 4.0)\n(-0.5, 2.0)\n```", "```java\npublic class Complex {\n    /** The real part */\n    private double r;\n    /** The imaginary part */\n    private double i;\n\n    /** Construct a Complex */\n    Complex(double rr, double ii) {\n        r = rr;\n        i = ii;\n    }\n\n    /** Display the current Complex as a String, for use in\n * println() and elsewhere.\n */\n    public String toString() {\n        StringBuilder sb = new StringBuilder().append(r);\n        if (i>0)\n            sb.append('+');    // else append(i) appends - sign\n        return sb.append(i).append('i').toString();\n    }\n\n    /** Return just the Real part */\n    public double getReal() {\n        return r;\n    }\n    /** Return just the Real part */\n    public double getImaginary() {\n        return i;\n    }\n    /** Return the magnitude of a complex number */\n    public double magnitude() {\n        return Math.sqrt(r*r + i*i);\n    }\n\n    /** Add another Complex to this one\n */\n    public Complex add(Complex other) {\n        return add(this, other);\n    }\n\n    /** Add two Complexes\n */\n    public static Complex add(Complex c1, Complex c2) {\n        return new Complex(c1.r+c2.r, c1.i+c2.i);\n    }\n\n    /** Subtract another Complex from this one\n */\n    public Complex subtract(Complex other) {\n        return subtract(this, other);\n    }\n\n    /** Subtract two Complexes\n */\n    public static Complex subtract(Complex c1, Complex c2) {\n        return new Complex(c1.r-c2.r, c1.i-c2.i);\n    }\n\n    /** Multiply this Complex times another one\n */\n    public Complex multiply(Complex other) {\n        return multiply(this, other);\n    }\n\n    /** Multiply two Complexes\n */\n    public static Complex multiply(Complex c1, Complex c2) {\n        return new Complex(c1.r*c2.r - c1.i*c2.i, c1.r*c2.i + c1.i*c2.r);\n    }\n\n    /** Divide c1 by c2.\n * @author Gisbert Selke.\n */\n    public static Complex divide(Complex c1, Complex c2) {\n        return new Complex(\n            (c1.r*c2.r+c1.i*c2.i)/(c2.r*c2.r+c2.i*c2.i),\n            (c1.i*c2.r-c1.r*c2.i)/(c2.r*c2.r+c2.i*c2.i));\n    }\n\n    /* Compare this Complex number with another\n */\n    public boolean equals(Object o) {\n        if (o.getClass() != Complex.class) {\n            throw new IllegalArgumentException(\n                    \"Complex.equals argument must be a Complex\");\n        }\n        Complex other = (Complex)o;\n        return r == other.r && i == other.i;\n    }\n\n    /* Generate a hashCode; not sure how well distributed these are.\n */\n    public int hashCode() {\n        return (int)(r) |  (int)i;\n    }\n}\n```", "```java\n        System.out.println(\"Here's Long.MAX_VALUE: \" + Long.MAX_VALUE);\n        BigInteger bInt = new BigInteger(\"3419229223372036854775807\");\n        System.out.println(\"Here's a bigger number: \" + bInt);\n        System.out.println(\"Here it is as a double: \" + bInt.doubleValue());\n```", "```java\npublic class BigNumCalc {\n\n    /** an array of Objects, simulating user input */\n    public static Object[] testInput = {\n        new BigDecimal(\"3419229223372036854775807.23343\"),\n        new BigDecimal(\"2.0\"),\n        \"*\",\n    };\n\n    public static void main(String[] args) {\n        BigNumCalc calc = new BigNumCalc();\n        System.out.println(calc.calculate(testInput));\n    }\n\n    /**\n * Stack of numbers being used in the calculator.\n */\n    Stack<BigDecimal> stack = new Stack<>();\n\n    /**\n * Calculate a set of operands; the input is an Object array containing\n * either BigDecimal objects (which may be pushed onto the Stack) and\n * operators (which are operated on immediately).\n * @param input\n * @return\n */\n    public BigDecimal calculate(Object[] input) {\n        BigDecimal tmp;\n        for (int i = 0; i < input.length; i++) {\n            Object o = input[i];\n            if (o instanceof BigDecimal) {\n                stack.push((BigDecimal) o);\n            } else if (o instanceof String) {\n                switch (((String)o).charAt(0)) {\n                // + and * are commutative, order doesn't matter\n                case '+':\n                    stack.push((stack.pop()).add(stack.pop()));\n                    break;\n                case '*':\n                    stack.push((stack.pop()).multiply(stack.pop()));\n                    break;\n                // - and /, order *does* matter\n                case '-':\n                    tmp = (BigDecimal)stack.pop();\n                    stack.push((stack.pop()).subtract(tmp));\n                    break;\n                case '/':\n                    tmp = stack.pop();\n                    stack.push((stack.pop()).divide(tmp,\n                        BigDecimal.ROUND_HALF_UP));\n                    break;\n                default:\n                    throw new IllegalStateException(\"Unknown OPERATOR popped\");\n                }\n            } else {\n                throw new IllegalArgumentException(\"Syntax error in input\");\n            }\n        }\n        return stack.pop();\n    }\n}\n```", "```java\n> javac -d . numbers/BigNumCalc.java\n> java numbers.BigNumCalc\n6838458446744073709551614.466860\n>\n```", "```java\npublic class TempConverter {\n\n    public static void main(String[] args) {\n        TempConverter t = new TempConverter();\n        t.start();\n        t.data();\n        t.end();\n    }\n\n    protected void start() {\n    }\n\n    protected void data() {\n        for (int i=-40; i<=120; i+=10) {\n            double c = fToC(i);\n            print(i, c);\n        }\n    }\n\n    public static double cToF(double deg) {\n        return ( deg * 9 / 5) + 32;\n    }\n\n    public static double fToC(double deg) {\n        return ( deg - 32 ) * ( 5d / 9 );\n    }\n\n    protected void print(double f, double c) {\n        System.out.println(f + \" \" + c);\n    }\n\n    protected void end() {\n    }\n}\n```", "```java\npublic class TempConverter2 extends TempConverter {\n\n    public static void main(String[] args) {\n        TempConverter t = new TempConverter2();\n        t.start();\n        t.data();\n        t.end();\n    }\n\n    @Override\n    protected void print(double f, double c) {\n        System.out.printf(\"%6.2f %6.2f%n\", f, c);\n    }\n\n    @Override\n    protected void start() {\n        System.out.println(\"Fahr    Centigrade\");\n    }\n\n    @Override\n    protected void end() {\n        System.out.println(\"-------------------\");\n    }\n}\n```", "```java\nC:\\javasrc\\numbers>java numbers.TempConverter2\nFahr    Centigrade\n-40.00 -40.00\n-30.00 -34.44\n-20.00 -28.89\n-10.00 -23.33\n  0.00 -17.78\n 10.00 -12.22\n 20.00  -6.67\n 30.00  -1.11\n 40.00   4.44\n 50.00  10.00\n 60.00  15.56\n 70.00  21.11\n 80.00  26.67\n 90.00  32.22\n100.00  37.78\n110.00  43.33\n120.00  48.89\n\n```", "```java\nC:\\javasrc\\numbers>java  numbers.Palindrome 72 142 1951 17892\nTrying 72\n72->99\nTrying 142\n142->383\nTrying 1951\nTrying 3542\n1951->5995\nTrying 17892\nTrying 47763\nTrying 84537\nTrying 158085\nTrying 738936\nTrying 1378773\nTrying 5157504\nTrying 9215019\nTrying 18320148\nTrying 102422529\nTrying 1027646730\nTrying 1404113931\n17892->2797227972\n\nC:\\javasrc\\numbers>\n```", "```java\nlong findPalindrome(long num) {\n    if (isPalindrome(num))\n        return num;\n    return findPalindrome(num + reverseNumber(num));\n}\n```", "```java\npublic class Palindrome {\n\n    public static boolean verbose = true;\n\n    public static void main(String[] argv) {\n        for (String num : argv) {\n            try {\n                long l = Long.parseLong(num);\n                if (l < 0) {\n                    System.err.println(num + \" -> TOO SMALL\");\n                    continue;\n                }\n                System.out.println(num + \"->\" + findPalindrome(l));\n            } catch (NumberFormatException e) {\n                System.err.println(num + \"-> INVALID\");\n            } catch (IllegalStateException e) {\n                System.err.println(num + \"-> \" + e);\n            }\n        }\n    }\n\n    /** find a palindromic number given a starting point, by\n * recursing until we get a number that is palindromic.\n */\n    static long findPalindrome(long num) {\n        if (num < 0)\n            throw new IllegalStateException(\"negative\");\n        if (isPalindrome(num))\n            return num;\n        if (verbose)\n             System.out.println(\"Trying \" + num);\n        return findPalindrome(num + reverseNumber(num));\n    }\n\n    /** The number of digits in Long.MAX_VALUE */\n    protected static final int MAX_DIGITS = 19;\n\n    // digits array is shared by isPalindrome and reverseNumber,\n    // which cannot both be running at the same time.\n\n    /* Statically allocated array to avoid new-ing each time. */\n    static long[] digits = new long[MAX_DIGITS];\n\n    /** Check if a number is palindromic. */\n    static boolean isPalindrome(long num) {\n        // Consider any single digit to be as palindromic as can be\n        if (num >= 0 && num <= 9)\n            return true;\n\n        int nDigits = 0;\n        while (num > 0) {\n            digits[nDigits++] = num % 10;\n            num /= 10;\n        }\n        for (int i=0; i<nDigits/2; i++)\n            if (digits[i] != digits[nDigits - i - 1])\n                return false;\n        return true;\n    }\n\n    static long reverseNumber(long num) {\n        int nDigits = 0;\n        while (num > 0) {\n            digits[nDigits++] = num % 10;\n            num /= 10;\n        }\n        long ret = 0;\n        for (int i=0; i<nDigits; i++) {\n            ret *= 10;\n            ret += digits[i];\n        }\n        return ret;\n    }\n}\n```", "```java\n    static boolean isPalindrome(long num) {\n        long result = reverseNumber(num);\n        return num == result;\n    }\n\n    private static long reverseNumber(long num) {\n        StringBuilder stringBuilder = new StringBuilder();\n        stringBuilder.append(num);\n        return Long.parseLong(stringBuilder.reverse().toString());\n    }\n```"]