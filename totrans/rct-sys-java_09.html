<html><head></head><body><section data-pdf-bookmark="Chapter 6. Quarkus: Reactive Engine" data-type="chapter" epub:type="chapter"><div class="chapter" id="quarkus-reactive">&#13;
<h1><span class="label">Chapter 6. </span>Quarkus: Reactive Engine</h1>&#13;
&#13;
&#13;
<p><a data-primary="reactive engine" data-type="indexterm" id="ix_quarkus-reactive-TEMP-adoc0"/>In <a data-type="xref" href="part02.html#reactive-part">Part II</a>, you learned a lot about Reactive, in all its forms, meanings, and variations!&#13;
I know, you’re probably a bit tired of hearing the word <em>reactive</em> right now,&#13;
but it’s a key piece to accurately describing Quarkus.&#13;
At the core of Quarkus is its reactive engine,&#13;
which we cover in <a data-type="xref" href="#quarkus-reactive::reactive-engine">“A Reactive Engine”</a>.&#13;
Without its reactive engine core,&#13;
Quarkus would not allow implementing reactive applications and provide a seamless integration of reactive programming.</p>&#13;
&#13;
<p>Quarkus unifies two development models: imperative and reactive.&#13;
In this chapter, we review the main differences and show how Quarkus handles the unification.&#13;
Quarkus aims for them to be as alike as possible.&#13;
If the APIs <em>feel</em> similar, understanding a complex model such as Reactive becomes seamless.</p>&#13;
&#13;
<p>Before we can get into the reactive engine,&#13;
we need to revisit the imperative and reactive models.&#13;
Doing so allows us an opportunity to appreciate how they’re unified with Quarkus.&#13;
For anyone already familiar with imperative and reactive models,&#13;
how they work, and the benefits and disadvantages of each,&#13;
feel free to skip ahead to <a data-type="xref" href="#quarkus-reactive::unification">“Unification of Reactive and Imperative”</a>.</p>&#13;
&#13;
<p>You might worry we’re repeating previously covered information.&#13;
We might be a little, but it’s all geared toward reinforcing how the two models impact the way applications are developed—and as a result, how frameworks differ depending on the model they offer.</p>&#13;
&#13;
<p>First up is the imperative model,&#13;
which most Java developers likely started their careers using.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Imperative Model" data-type="sect1"><div class="sect1" id="quarkus-reactive::imperative-model">&#13;
<h1>The Imperative Model</h1>&#13;
&#13;
<p><a data-primary="imperative model" data-type="indexterm" id="ix_quarkus-reactive-TEMP-adoc1"/><a data-primary="reactive engine" data-secondary="imperative model and" data-type="indexterm" id="ix_quarkus-reactive-TEMP-adoc2"/>When using the <em>imperative model</em>,&#13;
you may not even be aware of its name.&#13;
So what is the imperative model?&#13;
It alters a program’s state with a defined sequence of commands.&#13;
One command is executed after another until all commands are executed.</p>&#13;
&#13;
<p><a data-type="xref" href="#image:imperative-commands-result-10">Figure 6-1</a> shows a sequence of mathematical commands,&#13;
executed in succession,&#13;
until the result (in this case 10 if we start from 0, is produced).&#13;
As you can see in the imperative model, defining the proper sequence is critical to achieving the desired result, 10.</p>&#13;
&#13;
<figure><div class="figure" id="image:imperative-commands-result-10">&#13;
<img alt="Imperative commands with result 10" src="assets/rsij_0601.png"/>&#13;
<h6><span class="label">Figure 6-1. </span>Imperative commands with result 10</h6>&#13;
</div></figure>&#13;
&#13;
<p><a data-type="xref" href="#image:imperative-commands-result-7-5">Figure 6-2</a> shows the exact same commands, but in a different sequence.</p>&#13;
&#13;
<figure><div class="figure" id="image:imperative-commands-result-7-5">&#13;
<img alt="Imperative commands with result 7.5" src="assets/rsij_0602.png"/>&#13;
<h6><span class="label">Figure 6-2. </span>Imperative commands with result 7.5</h6>&#13;
</div></figure>&#13;
&#13;
<p>As you see, the sequence of commands, in the imperative mode, is just as important as the commands themselves.&#13;
Modifying the sequence results in an entirely different program output.&#13;
An imperative program can be considered the process of getting from A to B,&#13;
when we already know what A and B need to be.&#13;
The developer needs to define only the steps between A and B in the correct sequence to achieve the desired result.</p>&#13;
&#13;
<p>In imperative programs, we have a defined input and output, and, in addition, we know the steps needed to get from A to B.&#13;
For these two reasons, imperative programs are easily reasoned about.&#13;
When we have a defined input, what we know the output should be,&#13;
and the defined steps to get there,&#13;
writing tests is a lot easier because the permutations of what can happen are limited and determinable.</p>&#13;
&#13;
<p>What are some other aspects of the imperative programming model we need to be aware of?&#13;
As imperative relies on a sequence of commands,&#13;
resource utilization will always be a primary concern.&#13;
In the example shown in <a data-type="xref" href="#image:imperative-commands-result-10">Figure 6-1</a>,&#13;
we’re not going to need a large amount of resources to perform basic mathematical calculations.&#13;
However, if we replaced all those operations with database calls retrieving a few hundred records each,&#13;
the impacts begin adding up quickly.</p>&#13;
&#13;
<p><a data-primary="threads" data-secondary="imperative programming and" data-type="indexterm" id="ix_quarkus-reactive-TEMP-adoc3"/>The impacts we’re talking about are related to the threading model for imperative programming.&#13;
If we have our sequence of database operations using a single I/O thread,&#13;
the same I/O thread handling the HTTP request&#13;
(not realistic but useful for illustrative purposes),&#13;
only one request can be processed at any point in time.&#13;
We introduced the I/O thread in <a data-type="xref" href="ch05.html#reactive-programming">Chapter 5</a>.&#13;
Moreover, as the sequence of the imperative program is fixed,&#13;
each command must complete before the next one can commence.&#13;
What does that look like?</p>&#13;
&#13;
<p>Though contrived,&#13;
<a data-type="xref" href="#image:database-retrieval-single-thread">Figure 6-3</a> illustrates how each step in the database program must complete before the next can commence.&#13;
More importantly,&#13;
any subsequent request can begin only when the one being processed is finished.&#13;
In this situation,&#13;
the number of concurrent requests we can process is limited by the number of I/O threads we&#13;
give the application.</p>&#13;
&#13;
<figure><div class="figure" id="image:database-retrieval-single-thread">&#13;
<img alt="Database program on single I/O thread" src="assets/rsij_0603.png"/>&#13;
<h6><span class="label">Figure 6-3. </span>Database program on single I/O thread</h6>&#13;
</div></figure>&#13;
&#13;
<p>Now, as depicted in <a data-type="xref" href="#image:database-retrieval-multiple-threads">Figure 6-4</a>, we will be generous and provide the same application two I/O threads!</p>&#13;
&#13;
<figure><div class="figure" id="image:database-retrieval-multiple-threads">&#13;
<img alt="Database program on multiple I/O threads" src="assets/rsij_0604.png"/>&#13;
<h6><span class="label">Figure 6-4. </span>Database program on multiple I/O threads</h6>&#13;
</div></figure>&#13;
&#13;
<p>We can process two concurrent requests, but no more than that with only two I/O threads.&#13;
Being able to handle only a single request per I/O thread is not great,&#13;
so let’s dive deeper into what’s going on inside.</p>&#13;
&#13;
<p>Both the <em>Retrieve DB records</em> and <em>Write new DB records</em> commands have periods of time&#13;
when the command itself is not performing any work,&#13;
shown as the lighter section in <a data-type="xref" href="#image:database-retrieval-thread-delays">Figure 6-5</a>.&#13;
In between sending a request to the database and receiving the response,&#13;
what is the I/O thread doing?&#13;
In this situation, absolutely nothing!&#13;
The I/O thread sits there waiting for the response from the database.</p>&#13;
&#13;
<figure><div class="figure" id="image:database-retrieval-thread-delays">&#13;
<img alt="Database program I/O thread delays" src="assets/rsij_0605.png"/>&#13;
<h6><span class="label">Figure 6-5. </span>Database program I/O thread delays</h6>&#13;
</div></figure>&#13;
&#13;
<p>Why does it do nothing?&#13;
Could an I/O thread perform other work while waiting?&#13;
As we mentioned earlier,&#13;
imperative programming requires an ordered sequence of commands.&#13;
Because <em>Retrieve DB records</em> is still running during the wait period, an I/O thread does not know there is time to perform other work.&#13;
This is why imperative programming is often tied with synchronous execution,&#13;
and by default synchronous is the execution model for imperative programming.</p>&#13;
&#13;
<p>Some might wonder whether an I/O thread waiting is a big deal.&#13;
The time an I/O thread waits for a command to complete could be several seconds or longer.&#13;
An imperative program taking about a second to complete all its steps may be OK,&#13;
but it doesn’t take many periods of I/O threads waiting to explode the total response time to many seconds.</p>&#13;
&#13;
<p>The expanded time to complete an imperative program has several effects.&#13;
Increased execution time on an I/O thread leads to a reduction in the number of requests being processed in a given period of time.&#13;
There are additional impacts on the resources required to buffer in memory any incoming requests that are waiting on I/O threads to become available to begin processing.&#13;
These resource impacts can cause significant issues with the overall performance of an application.&#13;
If an application is dealing with a few hundred, or even thousand, users, it may not be noticeable,&#13;
especially if few are concurrent users.&#13;
However, tens of thousands of users, many concurrently,&#13;
will show these problems to their users in failed connections, time-outs, errors,&#13;
and any number of possible problems.</p>&#13;
&#13;
<p>There are other ways to break the synchronous and blocking nature of an imperative program.&#13;
We can use <code>ExecutorService</code> to move work from the I/O thread onto a separate worker pool thread.&#13;
Or we can use <code>@Suspended</code> and <code>AsyncResponse</code> with JAX-RS Resources to delegate work to a worker pool of threads,&#13;
enabling the HTTP request to be suspended from the I/O thread until a response is set on <code>AsyncResponse</code>.&#13;
Suspending HTTP requests waiting for a response facilitates processing of additional HTTP requests on the I/O thread while others are waiting for a processing response.</p>&#13;
&#13;
<p>Though these approaches work,&#13;
the complexity of code increases without a significant benefit in throughput as we’re still I/O thread limited—not quite to the level of a request per thread when using <code>@Suspended</code>, but not significantly more either.&#13;
How does the reactive model differ?<a data-startref="ix_quarkus-reactive-TEMP-adoc3" data-type="indexterm" id="idm45358827704768"/><a data-startref="ix_quarkus-reactive-TEMP-adoc2" data-type="indexterm" id="idm45358827704000"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Reactive Model" data-type="sect1"><div class="sect1" id="idm45358827741264">&#13;
<h1>The Reactive Model</h1>&#13;
&#13;
<p><a data-primary="reactive engine" data-secondary="reactive model and" data-type="indexterm" id="idm45358827702352"/><a data-primary="reactive model" data-type="indexterm" id="idm45358827701376"/>The <em>reactive model</em> is built around the notion of continuations and nonblocking I/O,&#13;
as we detailed in <a data-type="xref" href="ch05.html#reactive-programming:async-code-patterns">“Asynchronous Code and Patterns”</a>.&#13;
As mentioned previously, this approach significantly increases the level of concurrency,&#13;
enabling many more requests to be processed in parallel.&#13;
However, it’s not a free ride because it requires additional thought on the part of a developer to develop&#13;
an application built around these principles.</p>&#13;
&#13;
<p><a data-primary="threads" data-secondary="Reactive model and" data-type="indexterm" id="idm45358827698560"/>Taking our previous database example,&#13;
what would it look like to remove the I/O thread wait times to improve the concurrency? Take a look at <a data-type="xref" href="#image:database-retrieval-reactive">Figure 6-6</a>.</p>&#13;
&#13;
<figure><div class="figure" id="image:database-retrieval-reactive">&#13;
<img alt="Reactive database program on I/O thread" src="assets/rsij_0606.png"/>&#13;
<h6><span class="label">Figure 6-6. </span>Reactive database program on I/O thread</h6>&#13;
</div></figure>&#13;
&#13;
<p>Here, we can see that, instead of an I/O thread waiting,&#13;
it begins processing another incoming request.&#13;
It continues to do so until it’s been notified that a database response is ready for processing.&#13;
How do we achieve this separation?&#13;
We provide a continuation to process the database response.&#13;
The continuation is added to the queue of methods to execute on the I/O thread after the database response is received.&#13;
Likewise, the single command to process the database records is split into smaller methods to help with the concurrency.</p>&#13;
&#13;
<p><a data-type="xref" href="#image:database-retrieval-reactive">Figure 6-6</a> shows how a reactive model utilizing continuations&#13;
can facilitate the removal of I/O thread wait time and increase the number of requests processed concurrently.&#13;
As you’ve seen, we developers need to adjust how programs are developed to <em>align</em> with the reactive model.&#13;
We need to break work into smaller chunks,&#13;
but most importantly, modify interactions with anything external to the application&#13;
into separate request and response handling.</p>&#13;
&#13;
<p>In <a data-type="xref" href="#image:database-retrieval-reactive">Figure 6-6</a>, we approximated how pieces of a program&#13;
could be segmented to prevent the I/O thread<a data-startref="ix_quarkus-reactive-TEMP-adoc1" data-type="indexterm" id="idm45358827689888"/> from waiting or being blocked.&#13;
<a data-primary="event loop" data-type="indexterm" id="idm45358827689088"/>Quarkus uses an <em>event loop</em>, as discussed in <a data-type="xref" href="ch04.html#reactive-system::reactor-pattern-event-loop">“Reactor Pattern and Event Loop”</a>,&#13;
to implement the reactive model.&#13;
The event loop can visually be represented as shown previously in <a data-type="xref" href="ch04.html#image:event-loop">Figure 4-7</a>.</p>&#13;
&#13;
<p>We’ve discussed some hugely beneficial aspects of the reactive model,&#13;
but nothing comes for free.&#13;
With the reactive model needing to separate code execution,&#13;
as opposed to the imperative model in which everything is sequential,&#13;
complexity is introduced in the ability to understand the entirety of a program.</p>&#13;
&#13;
<p>A program is no longer a sequenced set of steps,&#13;
but a series of handlers executing at different points in time with no predetermined order.&#13;
Though continuations can be guaranteed to occur after they were triggered,&#13;
there is no ordering among various asynchronous invocations within a single request,&#13;
or among multiple requests.&#13;
This shift requires an alteration in thinking by developers toward event passing,&#13;
with the triggering of associated event handlers.&#13;
No longer is it a sequence of commands called one after another in code.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Unification of Reactive and Imperative" data-type="sect1"><div class="sect1" id="quarkus-reactive::unification">&#13;
<h1>Unification of Reactive and Imperative</h1>&#13;
&#13;
<p><a data-primary="imperative model" data-type="indexterm" id="ix_quarkus-reactive-TEMP-adoc4"/><a data-primary="reactive engine" data-secondary="unification of reactive and imperative" data-type="indexterm" id="ix_quarkus-reactive-TEMP-adoc5"/><a data-primary="reactive model" data-type="indexterm" id="ix_quarkus-reactive-TEMP-adoc6"/>What do we mean by Quarkus unifying reactive and imperative?&#13;
We don’t mean being able to ignore the complexities of reactive&#13;
or expecting imperative to provide high levels of concurrency.&#13;
We <em>do</em> mean the following:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Quarkus’s reactive core nonblocking I/O is key to any extension built on top.</p>&#13;
</li>&#13;
<li>&#13;
<p>Quarkus offers a framework of extensions built on the performance of the Eclipse Vert.x toolkit, the reactive engine.</p>&#13;
</li>&#13;
<li>&#13;
<p>A developer’s choice of imperative or reactive is an API choice,&#13;
and not a framework one.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Often when choosing to develop an application,&#13;
an <em>up-front</em> choice needs to be made as to whether to use reactive or imperative programming.&#13;
This decision requires much forethought by developers and architects in terms of the skills&#13;
required by the team building the application,&#13;
the current business requirements for the application,&#13;
as well as the final architecture of the application.&#13;
We developers find choosing a specific technology stack one of the most difficult decisions to make.&#13;
We always want to consider the future needs of the application,&#13;
even if we don’t know what those needs are concretely.&#13;
No matter how we try,&#13;
there will always be new requirements or unforeseen problems,&#13;
requiring a change in architecture or even design.</p>&#13;
&#13;
<p>We feel more comfortable about a decision when it doesn’t box us in,&#13;
offering ways to shift and alter the way an application works as needs change.&#13;
This is a huge advantage with Quarkus.&#13;
When we choose Quarkus,&#13;
and the unification of imperative and reactive models,&#13;
we’re free to pick one or the other,&#13;
a mix of the two,&#13;
or even switch parts of an application between the models over time.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45358827672240">&#13;
<h5>Quarkus, Vert.x, and Mutiny</h5>&#13;
<p><a data-primary="Eclipse Vert.x" data-type="indexterm" id="idm45358827671072"/><a data-primary="Vert.x" data-type="indexterm" id="idm45358827670368"/>The Quarkus reactive core relies on Eclipse Vert.x.&#13;
The Vert.x toolkit is the reactive core of everything Quarkus does.&#13;
Without this reactive core, everything else Quarkus does would not be possible.&#13;
Vert.x provides the layer interacting with nonblocking I/O and a large ecosystem of clients and servers.</p>&#13;
&#13;
<p><a data-primary="Mutiny" data-type="indexterm" id="idm45358827668992"/>In Quarkus, to ease the construction of reactive applications, we use SmallRye Mutiny.&#13;
Mutiny provides the API model we use.</p>&#13;
&#13;
<p>Vert.x and Mutiny are independent, the first one dealing with the network, and the second the API model.&#13;
To ease the integration of Vert.x in Quarkus, the <a href="https://oreil.ly/geseu">SmallRye Mutiny Vert.x Bindings project</a> provides the complete Vert.x API using the Mutiny types.</p>&#13;
</div></aside>&#13;
&#13;
<p>How does Quarkus support reactive or imperative models seamlessly?&#13;
Supporting both models seamlessly is the key foundation to everything Quarkus offers.&#13;
Built on the foundation of Vert.x,&#13;
Quarkus has a routing layer enabling either model.&#13;
This is how the layers work together when we’ve deployed reactive code,&#13;
assuming an HTTP request is being processed (<a data-type="xref" href="#image:unify-model-reactive">Figure 6-7</a>).</p>&#13;
&#13;
<figure><div class="figure" id="image:unify-model-reactive">&#13;
<img alt="Quarkus reactive model" src="assets/rsij_0607.png"/>&#13;
<h6><span class="label">Figure 6-7. </span>Quarkus reactive model</h6>&#13;
</div></figure>&#13;
&#13;
<p>We see in <a data-type="xref" href="#image:unify-model-reactive">Figure 6-7</a> how a request is received by the Vert.x HTTP server,&#13;
passes through the routing layer, and our reactive code executes.&#13;
All these interactions occur on the I/O thread;&#13;
a worker thread is not needed.&#13;
<a data-primary="threads" data-secondary="imperative programming and" data-type="indexterm" id="ix_quarkus-reactive-TEMP-adoc7"/>As already mentioned,&#13;
having code execute on the I/O thread provides the highest level of concurrency.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>In <a data-type="xref" href="#image:unify-model-reactive">Figure 6-7</a>,  only  a single HTTP request is being processed.&#13;
If there were multiple requests,&#13;
those executions would be interleaved on the I/O thread.</p>&#13;
</div>&#13;
&#13;
<p>You might be wondering how executing imperative code alters the behavior—take a look at <a data-type="xref" href="#image:unify-model-imperative">Figure 6-8</a>.</p>&#13;
&#13;
<figure><div class="figure" id="image:unify-model-imperative">&#13;
<img alt="Quarkus imperative model" src="assets/rsij_0608.png"/>&#13;
<h6><span class="label">Figure 6-8. </span>Quarkus imperative model</h6>&#13;
</div></figure>&#13;
&#13;
<p>You can see that the model is not significantly different.&#13;
The biggest change is that our code,&#13;
now imperative in nature,&#13;
is executed on a worker thread and not the I/O thread.&#13;
In this way, Quarkus can execute imperative code,&#13;
a series of sequential commands,&#13;
without impacting the concurrency of the I/O thread.&#13;
Quarkus has <em>offloaded</em> the imperative execution to a worker.</p>&#13;
&#13;
<p>The process of offloading to a worker thread comes with a cost, however.&#13;
Every time we execute on a worker thread,&#13;
a context switch, before and after execution, is necessary.&#13;
In <a data-type="xref" href="#image:unify-model-imperative">Figure 6-8</a>,&#13;
we represent this switch as a circle on the boundary between the I/O and worker threads.&#13;
These context switches cost time and resources to perform the switch and store the information in a new thread.</p>&#13;
&#13;
<p>We’ve seen how the two models operate on Quarkus,&#13;
but what about when we unify them?&#13;
For example,&#13;
if we have a reactive application needing to execute a piece of blocking code, how can we do that without blocking the I/O thread? In <a data-type="xref" href="#image:unify-model-combined">Figure 6-9</a>, we see our code executing on both the I/O and worker threads!</p>&#13;
&#13;
<figure><div class="figure" id="image:unify-model-combined">&#13;
<img alt="Quarkus reactive and imperative model" src="assets/rsij_0609.png"/>&#13;
<h6><span class="label">Figure 6-9. </span>Quarkus reactive and imperative model</h6>&#13;
</div></figure>&#13;
&#13;
<p>When reactive code is executed,&#13;
it’s on the I/O thread,&#13;
but any imperative code is executed on a worker thread.&#13;
Quarkus handles all of this for developers without them needing to create <code>Executors</code> or <code>Threads</code>,&#13;
or needing to manage them.</p>&#13;
&#13;
<p><a data-primary="proactor pattern" data-type="indexterm" id="idm45358827646048"/><a data-type="xref" href="#image:unify-model-combined">Figure 6-9</a> is a visualization of the <em>proactor</em> pattern we defined&#13;
in <a data-type="xref" href="ch04.html#reactive-system::reactor-pattern-event-loop">“Reactor Pattern and Event Loop”</a>.&#13;
Nonblocking and blocking handlers can coexist,&#13;
as long as we offload blocking execution onto worker threads&#13;
and invoke continuations when a blocking handler completes.</p>&#13;
&#13;
<p>The proactor pattern unifies imperative and reactive code in Quarkus.&#13;
Anyone familiar with developing reactive applications knows that sometimes it’s necessary&#13;
to write code in a blocking, or sequential, manner.&#13;
Quarkus’s unification allows us to delegate such execution onto a worker thread,&#13;
by using <code>@Blocking</code>, which we cover for HTTP in <a data-type="xref" href="ch08.html#http">Chapter 8</a> and Reactive Messaging in <a data-type="xref" href="ch10.html#messaging">Chapter 10</a>.</p>&#13;
&#13;
<p>Utilizing the reactive model,&#13;
and thus the I/O thread,&#13;
for as much work as possible has an added benefit.&#13;
We minimize the amount of context switching performed when delegating execution to a worker thread.&#13;
Anytime execution of the same request moves between threads,&#13;
from the I/O to worker thread, or vice versa,&#13;
costs are &#13;
<span class="keep-together">associated</span> with the switch.&#13;
Any objects associated with the request need to be available from the new thread,&#13;
costing time and resources to move them,&#13;
as well as resource costs for additional threads.<a data-startref="ix_quarkus-reactive-TEMP-adoc7" data-type="indexterm" id="idm45358827638448"/></p>&#13;
&#13;
<p>We’ve talked a lot about how the models are unified in Quarkus,&#13;
but what extensions use these models?&#13;
RESTEasy Reactive, covered in <a data-type="xref" href="ch08.html#http">Chapter 8</a>,&#13;
and Reactive Messaging, in <a data-type="xref" href="ch10.html#messaging">Chapter 10</a>,&#13;
both utilize the reactive model.&#13;
The classic RESTEasy and Spring controller both use the imperative model.<a data-startref="ix_quarkus-reactive-TEMP-adoc6" data-type="indexterm" id="idm45358827635392"/><a data-startref="ix_quarkus-reactive-TEMP-adoc5" data-type="indexterm" id="idm45358827634656"/><a data-startref="ix_quarkus-reactive-TEMP-adoc4" data-type="indexterm" id="idm45358827633968"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="A Reactive Engine" data-type="sect1"><div class="sect1" id="quarkus-reactive::reactive-engine">&#13;
<h1>A Reactive Engine</h1>&#13;
&#13;
<p><a data-primary="Vert.x" data-secondary="Quarkus reactive engine and" data-type="indexterm" id="idm45358827632048"/>If you have written reactive programs&#13;
or done any research into Reactive,&#13;
you are likely aware of the Vert.x toolkit.&#13;
As mentioned before, the Quarkus reactive engine utilizes Vert.x. In addition to Vert.x,&#13;
as well as Netty,&#13;
the routing layer of Quarkus forms the outer layer of the reactive engine.&#13;
It’s the integration piece for extensions,&#13;
coordinating the offloading of blocking handlers onto worker threads,&#13;
and the execution of their continuations.</p>&#13;
&#13;
<p>In addition,&#13;
all the reactive clients are built on top of the reactive engine to utilize the nonblocking handling.&#13;
Reactive applications are no longer reactive after they use blocking clients,&#13;
a key aspect often overlooked by developers.&#13;
Quarkus endeavors to have all clients that an application might need built on the reactive engine,&#13;
for true reactive integration.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>By default, everything in Quarkus is reactive.&#13;
Developers must decide whether they want reactive or imperative.&#13;
What do we mean by <em>everything</em>?&#13;
It includes HTTP handling, event-driven applications with AMQP and Kafka,&#13;
and <em>everything</em> Quarkus offers.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="A Reactive Programming Model" data-type="sect1"><div class="sect1" id="idm45358827627344">&#13;
<h1>A Reactive Programming Model</h1>&#13;
&#13;
<p><a data-primary="Mutiny" data-secondary="basics" data-type="indexterm" id="idm45358827626000"/><a data-primary="reactive programming" data-secondary="Mutiny" data-type="indexterm" id="idm45358827625024"/>SmallRye Mutiny is the reactive programming library of Quarkus.&#13;
You already learned about it in <a data-type="xref" href="ch05.html#reactive-programming::reactive-programming">“Reactive Programming”</a>,&#13;
and we will learn even more in <a data-type="xref" href="ch07.html#mutiny">Chapter 7</a>,&#13;
so we won’t cover too much detail here.</p>&#13;
&#13;
<p>In short, Mutiny is built around three key aspects:</p>&#13;
<dl>&#13;
<dt>Event-driven</dt>&#13;
<dd>&#13;
<p>Listening to events from the stream and handling them appropriately.</p>&#13;
</dd>&#13;
<dt>Easily navigable API</dt>&#13;
<dd>&#13;
<p>Navigating the API is driven by an event type and the available options for that event.</p>&#13;
</dd>&#13;
<dt>Only two types</dt>&#13;
<dd>&#13;
<p><code>Multi</code> and <code>Uni</code> can handle any desired asynchronous actions.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>One point to note is the laziness of the Mutiny types.&#13;
Events won’t begin flowing through the data streams until a subscriber requests them.&#13;
This is a fantastic feature to prevent streams from consuming resources if nothing is listening,&#13;
but developers do need to be aware of this, so we don’t forget to subscribe!</p>&#13;
&#13;
<p>All Quarkus reactive APIs use <code>Multi</code> and <code>Uni</code>.&#13;
This approach facilitates the seamless integration of Quarkus extensions with reactive programming and Mutiny.&#13;
Let’s see examples of using Mutiny.</p>&#13;
&#13;
<p>A reactive application with Quarkus using the PostgreSQL reactive client retrieves <code>Fruit</code> objects from&#13;
the database with <code>Multi</code>, as shown in <a data-type="xref" href="#quarkus-reactive::mutiny-data">Example 6-1</a>.</p>&#13;
<div data-type="example" id="quarkus-reactive::mutiny-data">&#13;
<h5><span class="label">Example 6-1. </span>Reactive Mutiny client</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">client</code><code class="o">.</code><code class="na">query</code><code class="o">(</code><code class="s">"SELECT id, name FROM fruits ORDER BY name ASC"</code><code class="o">)</code><code class="o">.</code><code class="na">execute</code><code class="o">(</code><code class="o">)</code><code>        </code><a class="co" href="#callout_quarkus__reactive_engine_CO1-1" id="co_quarkus__reactive_engine_CO1-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code>    </code><code class="o">.</code><code class="na">onItem</code><code class="o">(</code><code class="o">)</code><code class="o">.</code><code class="na">transformToMulti</code><code class="o">(</code><code class="n">rowSet</code><code> </code><code class="o">-</code><code class="o">&gt;</code><code> </code><code class="n">Multi</code><code class="o">.</code><code class="na">createFrom</code><code class="o">(</code><code class="o">)</code><code class="o">.</code><code class="na">iterable</code><code class="o">(</code><code class="n">rowSet</code><code class="o">)</code><code class="o">)</code><code>  </code><a class="co" href="#callout_quarkus__reactive_engine_CO1-2" id="co_quarkus__reactive_engine_CO1-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
</code><code>    </code><code class="o">.</code><code class="na">onItem</code><code class="o">(</code><code class="o">)</code><code class="o">.</code><code class="na">transform</code><code class="o">(</code><code class="n">row</code><code> </code><code class="o">-</code><code class="o">&gt;</code><code> </code><code class="n">convertRowToFruit</code><code class="o">(</code><code class="n">row</code><code class="o">)</code><code class="o">)</code><code class="o">;</code><code>                        </code><a class="co" href="#callout_quarkus__reactive_engine_CO1-3" id="co_quarkus__reactive_engine_CO1-3"><img alt="3" src="assets/3.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_quarkus__reactive_engine_CO1-1" id="callout_quarkus__reactive_engine_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p><code>client</code> is an instance of <code>PgPool</code>, the PostgreSQL reactive client built with Mutiny and Vert.x.</p></dd>&#13;
<dt><a class="co" href="#co_quarkus__reactive_engine_CO1-2" id="callout_quarkus__reactive_engine_CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>When a <code>RowSet</code> item is received, transform the single <code>RowSet</code> into a <code>Multi&lt;Row&gt;</code>.</p></dd>&#13;
<dt><a class="co" href="#co_quarkus__reactive_engine_CO1-3" id="callout_quarkus__reactive_engine_CO1-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Convert each <code>Row</code> in <code>Multi</code> to a <code>Fruit</code> instance. The result of the execution is <code>Multi&lt;Fruit&gt;</code>.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>Given we’re writing about Reactive in this book,&#13;
all the remaining chapters have examples utilizing Mutiny in many situations.&#13;
We present reactive HTTP endpoints in <a data-type="xref" href="ch08.html#http">Chapter 8</a> and their consumption in <a data-type="xref" href="ch12.html#http-client">Chapter 12</a>.&#13;
We cover reactive data access with Quarkus and Mutiny in <a data-type="xref" href="ch09.html#data">Chapter 9</a>,&#13;
including many examples.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Event-Driven Architecture with Quarkus" data-type="sect1"><div class="sect1" id="idm45358827510496">&#13;
<h1>Event-Driven Architecture with Quarkus</h1>&#13;
&#13;
<p><a data-primary="event-driven architecture" data-type="indexterm" id="idm45358827509152"/><a data-primary="Quarkus" data-secondary="event-driven architecture with" data-type="indexterm" id="idm45358827508480"/>Though building reactive applications with Quarkus is great, performant, and  fun,&#13;
we want to do more than build a single application.&#13;
We need a reactive system, as covered in <a data-type="xref" href="ch04.html#reactive-systems">Chapter 4</a>,&#13;
combining smaller applications into a coordinated distributed system. To support such an architecture,&#13;
Quarkus must receive and produce events,&#13;
an event-driven architecture!&#13;
Quarkus achieves this by using Reactive Messaging, as shown in <a data-type="xref" href="#quarkus-reactive::messaging">Example 6-2</a>.&#13;
Reactive Messaging integrates with various messaging technologies,&#13;
such as Apache Kafka, AMQP, and others,&#13;
with annotations for developers to specify whether a method receives or produces events.</p>&#13;
<div data-type="example" id="quarkus-reactive::messaging">&#13;
<h5><span class="label">Example 6-2. </span>Reactive Messaging</h5>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="nd">@Incoming</code><code class="o">(</code><code class="s">"prices"</code><code class="o">)</code><code>&#13;
</code><code class="nd">@Outgoing</code><code class="o">(</code><code class="s">"quotes"</code><code class="o">)</code><code>                                         </code><a class="co" href="#callout_quarkus__reactive_engine_CO2-1" id="co_quarkus__reactive_engine_CO2-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code class="kd">public</code><code> </code><code class="n">Quote</code><code> </code><code class="nf">generatePrice</code><code class="o">(</code><code class="n">Price</code><code> </code><code class="n">p</code><code class="o">)</code><code> </code><code class="o">{</code><code>                       </code><a class="co" href="#callout_quarkus__reactive_engine_CO2-2" id="co_quarkus__reactive_engine_CO2-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
</code><code>    </code><code class="k">return</code><code> </code><code class="k">new</code><code> </code><code class="nf">Quote</code><code class="o">(</code><code class="n">p</code><code class="o">,</code><code> </code><code class="s">"USD"</code><code class="o">)</code><code class="o">;</code><code>&#13;
</code><code class="o">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_quarkus__reactive_engine_CO2-1" id="callout_quarkus__reactive_engine_CO2-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Read messages from the <code>prices</code> channel.</p></dd>&#13;
<dt><a class="co" href="#co_quarkus__reactive_engine_CO2-2" id="callout_quarkus__reactive_engine_CO2-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Transform each <code>Price</code> into a <code>Quote</code>.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>The offered development model allows consuming, transforming, and generating messages easily.&#13;
The <code>@Incoming</code> annotation denotes the consumption of a <em>channel</em>.&#13;
Reactive Messaging invokes the method for each transiting <code>Price</code> from the configured channel.&#13;
The <code>@Outgoing</code> annotation indicates in which channel the results are written.</p>&#13;
&#13;
<p>Full details of Reactive Messaging are covered in <a data-type="xref" href="ch10.html#messaging">Chapter 10</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm45358827431920">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>This chapter covered the imperative model,&#13;
a series of sequential commands,&#13;
and the reactive model,&#13;
utilizing continuations and nonblocking I/O.</p>&#13;
&#13;
<p>We have seen the following:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>How the two models work with threads (in Figures <a data-type="xref" data-xrefstyle="select:labelnumber" href="#image:unify-model-imperative">6-8</a>, <a data-type="xref" data-xrefstyle="select:labelnumber" href="#image:unify-model-reactive">6-7</a>, and <a data-type="xref" data-xrefstyle="select:labelnumber" href="#image:unify-model-combined">6-9</a>),&#13;
providing improved concurrency with the reactive model.</p>&#13;
</li>&#13;
<li>&#13;
<p>How Quarkus unifies these models to allow developers to grow their applications,&#13;
introducing reactive aspects, as it grows and expands without the need to switch frameworks.</p>&#13;
</li>&#13;
<li>&#13;
<p>How we can use reactive programming in Quarkus.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>In the coming chapters, we explore the various reactive aspects of Quarkus,&#13;
such as HTTP and RESTEasy Reactive in <a data-type="xref" href="ch08.html#http">Chapter 8</a>, and reactive data access in <a data-type="xref" href="ch09.html#data">Chapter 9</a>.&#13;
But first, let’s have a deeper look into the Mutiny reactive programming API.<a data-startref="ix_quarkus-reactive-TEMP-adoc0" data-type="indexterm" id="idm45358827420400"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>