["```java\nhttp_server_requests_seconds_max{uri=\"/persons\"}\nhistogram_quantile(\n  0.99,\n  sum(\n    rate(\n      http_server_requests_seconds_bucket{uri=\"/persons\"}[5m]\n    )\n  ) by (le)\n)\n```", "```java\nHealthMeterRegistry registry = HealthMeterRegistry\n  .builder(HealthConfig.DEFAULT)\n  .serviceLevelObjectives(JvmServiceLevelObjectives.MEMORY)\n  .serviceLevelObjectives(JvmServiceLevelObjectives.ALLOCATIONS)\n  .serviceLevelObjectives(OperatingSystemServiceLevelObjectives.DISK)\n  .build();\n```", "```java\n@Configuration\nclass UtilizationServiceLevelObjective {\n  @Bean\n  ServiceLevelObjective apiUtilization() {\n      return ServiceLevelObjective\n        .build(\"api.utilization\") ![1](../images/00112.png)\n        .baseUnit(\"requests\") ![2](../images/00059.png)\n        .failedMessage(\"Rate limit to 10,000 requests/second.\") ![3](../images/00067.png)\n        .count(s -> s.name(\"http.server.requests\") ![4](../images/00016.png)\n          .tag(\"uri\", \"/persons\")\n          .tag(\"outcome\", \"SUCCESS\")\n        )\n        .isLessThan(10_000); ![5](../images/00100.png)\n  }\n}\n```", "```java\nmetadata:\n name: instance-reported-utilization\n  annotations:\n   service.beta.kubernetes.io/do-loadbalancer-healthcheck-port:80\n   service.beta.kubernetes.io/do-loadbalancer-healthcheck-protocol:http\n   service.beta.kubernetes.io/do-loadbalancer-healthcheck-path:/actuator/health\n   service.beta.kubernetes.io/do-loadbalancer-healthcheck-check-interval-seconds:3\n   service.beta.kubernetes.io/do-loadbalancer-healthcheck-response-timeout-seconds:5\n   service.beta.kubernetes.io/do-loadbalancer-healthcheck-unhealthy-threshold:3\n   service.beta.kubernetes.io/do-loadbalancer-healthcheck-healthy-threshold:5\n```", "```java\nmanagement:\n  endpoints.web.exposure.include: health\n  endpoint.health.show-details: always\n```", "```java\n@Configuration\n@LoadBalancerClient(\n  name = \"discovery-load-balancer\",\n  configuration = DiscoveryLoadBalancerConfiguration.class\n)\nclass WebClientConfig {\n  @LoadBalanced\n  @Bean\n  WebClient.Builder webClientBuilder() {\n    return WebClient.builder();\n  }\n}\n\n@Configuration\nclass DiscoveryLoadBalancerConfiguration {\n\t@Bean\n\tpublic ServiceInstanceListSupplier discoveryClientServiceInstances(\n    ConfigurableApplicationContext context) {\n\n    return ServiceInstanceListSuppliers.builder()\n      .withDiscoveryClient()\n      .withZonePreference()\n      .withHealthChecks()\n      .withCaching()\n      .build(context);\n\t}\n}\n```", "```java\nRetryConfig config = RetryConfig.custom()\n  .intervalFunction(IntervalFunction.ofExponentialBackoff(\n    Duration.ofSeconds(10), 3))\n  .maxAttempts(3)\n  .retryExceptions(RetryableApiException.class)\n  .build();\n\nRetryRegistry retryRegistry = RetryRegistry.of(config);\n\nRetry retry = retryRegistry.retry(\"persons.api\");\n\nretry.executeCallable(() -> {\n  Response response = ...\n  switch(response.code()) {\n    case 401:\n      // Authentication flow\n    case 502:\n    case 503:\n    case 504:\n      throw new RetryableApiException();\n  }\n\n  return response;\n});\n```", "```java\nTaggedRetryMetrics\n  .ofRetryRegistry(retryRegistry)\n  .bindTo(meterRegistry);\n```", "```java\nRateLimiterConfig config = RateLimiterConfig.custom()\n  .limitRefreshPeriod(Duration.ofMillis(1))\n  .limitForPeriod(10) ![1](../images/00112.png)\n  .timeoutDuration(Duration.ofMillis(25)) ![2](../images/00059.png)\n  .build();\n\nRateLimiterRegistry rateLimiterRegistry = RateLimiterRegistry.of(config);\n\nRateLimiter billingHistoryRateLimiter = rateLimiterRegistry\n  .rateLimiter(\"billingHistory\");\nRateLimiter paymentRateLimiter = rateLimiterRegistry\n  .rateLimiter(\"payment\", config); ![3](../images/00067.png)\n\n// Components that would, as part of their implementations, // execute HTTP requests to downstream services BillingHistory billingHistory = ...\nPayments payments = ...\n\n// Spring WebFlux Functional route specification RouterFunction<ServerResponse> route = route()\n\t.GET(\"/billing/{id}\", accept(APPLICATION_JSON),\n    RateLimiter.decorateFunction(\n      billingHistoryRateLimiter,\n      BillingHistory::getHistory\n    )\n  )\n\t.POST(\"/payment\",\n    RateLimiter.decorateFunction(\n      paymentRateLimiter,\n      Payments::sendPayment\n    )\n  )\n\t.build();\n```", "```java\nTaggedRateLimiterMetrics\n  .ofRateLimiterRegistry(rateLimiterRegistry)\n  .bindTo(meterRegistry);\n```", "```java\nname,resilience4j.ratelimiter.waiting.threads,:eq,\n$THRESHOLD,\n:gt\n```", "```java\nresilience4j_ratelimiter_waiting_threads > $THRESHOLD\n```", "```java\nBulkheadConfig config = BulkheadConfig.custom()\n  \t.maxConcurrentCalls(150) ![1](../images/00112.png)\n  \t.maxWaitDuration(Duration.ofMillis(500)) ![2](../images/00059.png)\n  \t.build();\n\nBulkheadRegistry registry = BulkheadRegistry.of(config);\n\nBulkhead billingHistoryBulkhead = registry.bulkhead(\"billingHistory\");\nBulkhead paymentBulkhead = registry.bulkhead(\"payment\", custom); ![3](../images/00067.png)\n\n// Components that would, as part of their implementations, execute HTTP requests // to downstream services BillingHistory billingHistory = ...\nPayments payments = ...\n\n// Spring WebFlux Functional route specification RouterFunction<ServerResponse> route = route()\n\t.GET(\"/billing/{id}\", accept(APPLICATION_JSON),\n    Bulkhead.decorateFunction(\n      billingHistoryBulkhead,\n      BillingHistory::getHistory\n    )\n  )\n\t.POST(\"/payment\",\n    Bulkhead.decorateFunction(\n      paymentBulkhead,\n      Payments::sendPayment\n    )\n  )\n\t.build();\n```", "```java\nTaggedBulkheadMetrics\n  .ofBulkheadRegistry(bulkheadRegistry)\n  .bindTo(meterRegistry);\n```", "```java\nname,resilience4j.bulkhead.available.concurrent.calls,:eq,\n$THRESHOLD,\n:lt\n```", "```java\nresilience4j_bulkhead_available_concurrent_calls < $THRESHOLD\n```", "```java\nCircuitBreakerConfig circuitBreakerConfig = CircuitBreakerConfig.custom()\n  .failureRateThreshold(50)\n  .waitDurationInOpenState(Duration.ofMillis(1000))\n  .ringBufferSizeInHalfOpenState(2)\n  .ringBufferSizeInClosedState(2)\n  .build();\n\nCircuitBreakerRegistry circuitBreakerRegistry = CircuitBreakerRegistry\n  .of(circuitBreakerConfig);\n\nCircuitBreaker billingHistoryCircuitBreaker = circuitBreakerRegistry\n  .circuitBreaker(\"billingHistoryCircuitBreaker\");\nCircuitBreaker paymentCircuitBreaker = circuitBreakerRegistry\n  .circuitBreaker(\"payment\", circuitBreakerConfig); ![1](../images/00112.png)\n\n// Components that would, as part of their implementations, execute HTTP requests // to downstream services BillingHistory billingHistory = ...\nPayments payments = ...\n\n// Spring WebFlux Functional route specification RouterFunction<ServerResponse> route = route()\n\t.GET(\"/billing/{id}\", accept(APPLICATION_JSON),\n    CircuitBreaker.decorateFunction(\n      billingHistoryCircuitBreaker,\n      BillingHistory::getHistory\n    )\n  )\n\t.POST(\"/payment\",\n    CircuitBreaker.decorateFunction(\n      paymentCircuitBreaker,\n      Payments::sendPayment\n    )\n  )\n\t.build();\n```", "```java\nTaggedCircuitBreakerMetrics\n  .ofCircuitBreakerRegistry(circuitBreakerRegistry)\n  .bindTo(meterRegistry);\n```", "```java\nname,resilience4j.circuitbreaker.state,:eq,\nstate,open,:eq,\n:and,\n:max, ![1](../images/00112.png)\n1,\n:eq\n```", "```java\nsum(resilience4j_circuitbreaker_state{state=\"open\"}) > 0\n```", "```java\napiVersion: networking.istio.io/v1alpha3\nkind: DestinationRule\nmetadata:\n  name: billingHistory\nspec:\n  host: billingHistory\n  subsets:\n  - name: v1\n    labels:\n      version: v1\n    trafficPolicy:\n      connectionPool:\n        tcp:\n          maxConnections: 150\n```"]