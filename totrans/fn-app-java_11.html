<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 9. Handling null with Optionals" data-type="chapter" epub:type="chapter"><div class="chapter" id="_02-optionals">
<h1><span class="label">Chapter 9. </span>Handling null with Optionals</h1>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45115230047904">
<h1>A Note for Early Release Readers</h1>
<p>With Early Release ebooks, you get books in their earliest form—the author’s raw and unedited content as they write—so you can take advantage of these technologies long before the official release of these titles.</p>
<p>This will be the 9th chapter of the final book. Please note that the GitHub repo will be made active later on.</p>
<p>If you have comments about how we might improve the content and/or examples in this book, or if you notice missing material within this chapter, please reach out to the editor at <em>rfernando@oreilly.com</em>.</p>
</div></aside>
<p>As a Java developer, you’ve most likely encountered your fair share of <code>NullPointerExceptions</code>, and then some.
Many people call the <code>null</code> reference a <em>billion-dollar mistake</em>.
Actually, the inventor of <code>null</code> itself originally coined that phrase:</p>
<blockquote>
<p>I call it my billion-dollar mistake.</p>
<p>It was the invention of the <code>null</code> reference in 1965.
At that time, I was designing the first comprehensive type system for references in an object-oriented language (ALGOL W).
My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler.
But I couldn’t resist the temptation to put in a <code>null</code> reference simply because it was so easy to implement.</p>
<p>This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.</p>
<p data-type="attribution">Sir Charles Antony Richard Hoare, <cite>QCon London 2009</cite></p>
</blockquote>
<p>Although there is no absolute consensus on how to deal with this “mistake,” many programming languages have a proper and idiomatic way of handling <code>null</code> references, often directly integrated into the language itself.</p>
<p>This chapter will show you how Java handles <code>null</code> references and how to improve it in your code with the <code>Optional&lt;T&gt;</code> type and its functional API, and learn how, when, and when not to use Optionals.</p>
<section data-pdf-bookmark="The Problem with null References" data-type="sect1"><div class="sect1" id="idm45115230036816">
<h1>The Problem with null References</h1>
<p>Java’s handling of the absence of a value depends on the type.
All primitive types have default values, e.g., a zero-equivalent for numeric types and <code>false</code> for <code>boolean</code>.
Non-primitive types, like classes, interfaces, and arrays, use <code>null</code> as their default value if unassigned, meaning the variable isn’t referencing any object.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The concept of reference types may seem similar to C/C++ pointers, but Java references are a specialized type inside the JVM called <code>reference</code>.
The JVM strictly controls them to ensure type-safety and safe-guarding memory access.</p>
</div>
<p>A <code>null</code> reference isn’t just “nothing”; it’s a <em>special state</em> because <code>null</code> is a generalized type that can be used for any object reference, regardless of the actual type.
If you attempt to access such a <code>null</code> reference, the JVM will throw a <code>NullPointerException</code>, and the current thread will crash if you don’t handle it appropriately.
This is usually mitigated by a defensive programming approach, requiring <code>null</code> checks <em>everywhere</em> at runtime, as seen in <a data-type="xref" href="#_02-optionals-minefield">Example 9-1</a>.</p>
<div data-type="example" id="_02-optionals-minefield">
<h5><span class="label">Example 9-1. </span>A minefield of possible nulls</h5>
<pre data-code-language="java" data-type="programlisting"><code class="kd">record</code> <code class="nc">User</code><code class="p">(</code><code class="kt">long</code> <code class="n">id</code><code class="p">,</code> <code class="n">String</code> <code class="n">firstname</code><code class="p">,</code> <code class="n">String</code> <code class="n">lastname</code><code class="p">)</code> <code class="p">{</code>

  <code class="n">String</code> <code class="nf">fullname</code><code class="p">(</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="n">String</code><code class="p">.</code><code class="na">format</code><code class="p">(</code><code class="s">"</code><code class="s">%s %s</code><code class="s">"</code><code class="p">,</code> <a class="co" href="#callout_handling_null_with_optionals_CO1-1" id="co_handling_null_with_optionals_CO1-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>
                         <code class="n">firstname</code><code class="p">(</code><code class="p">)</code><code class="p">,</code>
                         <code class="n">lastname</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="n">String</code> <code class="nf">initials</code><code class="p">(</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="n">String</code><code class="p">.</code><code class="na">format</code><code class="p">(</code><code class="s">"</code><code class="s">%s%s</code><code class="s">"</code><code class="p">,</code>
                         <code class="n">firstname</code><code class="p">(</code><code class="p">)</code><code class="p">.</code><code class="na">substring</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">)</code><code class="p">,</code> <a class="co" href="#callout_handling_null_with_optionals_CO1-2" id="co_handling_null_with_optionals_CO1-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>
                         <code class="n">lastname</code><code class="p">(</code><code class="p">)</code><code class="p">.</code><code class="na">substring</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">)</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_handling_null_with_optionals_CO1-2" id="co_handling_null_with_optionals_CO1-3"><img alt="2" height="12" src="assets/2.png" width="12"/></a>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kd">var</code> <code class="n">user</code> <code class="o">=</code> <code class="k">new</code> <code class="n">User</code><code class="p">(</code><code class="mi">42L</code><code class="p">,</code> <code class="s">"</code><code class="s">Ben</code><code class="s">"</code><code class="p">,</code> <code class="kc">null</code><code class="p">)</code><code class="p">;</code>

<code class="kd">var</code> <code class="n">fullname</code> <code class="o">=</code> <code class="n">user</code><code class="p">.</code><code class="na">fullname</code><code class="p">(</code><code class="p">)</code><code class="p">;</code>
<code class="c1">// =&gt; Ben null </code><a class="co" href="#callout_handling_null_with_optionals_CO1-1" id="co_handling_null_with_optionals_CO1-4"><img alt="1" height="12" src="assets/1.png" width="12"/></a>

<code class="kd">var</code> <code class="n">initials</code> <code class="o">=</code> <code class="n">user</code><code class="p">.</code><code class="na">initials</code><code class="p">(</code><code class="p">)</code><code class="p">;</code>
<code class="c1">// =&gt; NullPointerException </code><a class="co" href="#callout_handling_null_with_optionals_CO1-2" id="co_handling_null_with_optionals_CO1-5"><img alt="2" height="12" src="assets/2.png" width="12"/></a></pre></div>
<dl class="calloutlist">
<dt><a class="co" href="#co_handling_null_with_optionals_CO1-1" id="callout_handling_null_with_optionals_CO1-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p><code>String.format</code> accepts <code>null</code> values as long its not the sole value for arguments<sup><a data-type="noteref" href="ch09.xhtml#idm45115229846656" id="idm45115229846656-marker">1</a></sup> after the format string.
It translates to the string “null,” regardless of the chosen format specifier, even for numeric ones.</p></dd>
<dt><a class="co" href="#co_handling_null_with_optionals_CO1-2" id="callout_handling_null_with_optionals_CO1-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>Using <code>null</code> as an argument in a method call might not crash the current thread.
however, calling a method on a <code>null</code> reference certainly does.</p></dd>
</dl>
<p>The previous example highlights two major problems in dealing with <code>null</code>.</p>
<p>First, <code>null</code> references are valid values for variables, arguments, and return values.
That doesn’t mean that <code>null</code> is the expected, correct, or even acceptable value for each of them and might not be handled correctly down the line.</p>
<p>For example, calling <code>getFullname</code> on <code>user</code> in the previous example worked fine with a <code>null</code> reference for <code>lastname</code>, but the output — “Ben null" — is most likely not what’s intended.
So even if your code and data structures can handle <code>null</code> values superficially, you still might need to check for them to ensure a correct outcome.</p>
<p>The second problem of <code>null</code> references is one of their main features: type ambiguity.
They can represent any type without actually being that particular type.
That unique property is necessary, so a single keyword can represent the generalized concept of “absence of value” throughout your code without resorting to different types or keywords for different object types.
Even though a <code>null</code> reference is usable just like the type it represents, it still <em>isn’t</em> the type itself, as seen in <a data-type="xref" href="#_02-optionals-null-type-ambiguity">Example 9-2</a>.</p>
<div data-type="example" id="_02-optionals-null-type-ambiguity">
<h5><span class="label">Example 9-2. </span>null type ambiguity</h5>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// "TYPE-LESS" NULL AS AN ARGUMENT</code>

<code class="n">methodAcceptingString</code><code class="p">(</code><code class="kc">null</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_handling_null_with_optionals_CO2-1" id="co_handling_null_with_optionals_CO2-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>


<code class="c1">// ACCESSING A "TYPED" NULL</code>

<code class="n">String</code> <code class="n">name</code> <code class="o">=</code> <code class="kc">null</code><code class="p">;</code>

<code class="kd">var</code> <code class="n">lowerCaseName</code> <code class="o">=</code> <code class="n">name</code><code class="p">.</code><code class="na">toLowerCase</code><code class="p">(</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_handling_null_with_optionals_CO2-2" id="co_handling_null_with_optionals_CO2-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>
<code class="c1">// =&gt; NullPointerException</code>


<code class="c1">// TEST TYPE OF NULL</code>

<code class="kd">var</code> <code class="n">notString</code> <code class="o">=</code> <code class="n">name</code> <code class="k">instanceof</code> <code class="n">String</code><code class="p">;</code> <a class="co" href="#callout_handling_null_with_optionals_CO2-3" id="co_handling_null_with_optionals_CO2-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a>
<code class="c1">// =&gt; false</code>

<code class="kd">var</code> <code class="n">stillNotString</code> <code class="o">=</code> <code class="p">(</code><code class="p">(</code><code class="n">String</code><code class="p">)</code> <code class="n">name</code><code class="p">)</code> <code class="k">instanceof</code> <code class="n">String</code><code class="p">;</code> <a class="co" href="#callout_handling_null_with_optionals_CO2-3" id="co_handling_null_with_optionals_CO2-4"><img alt="3" height="12" src="assets/3.png" width="12"/></a>
<code class="c1">// =&gt; false</code></pre></div>
<dl class="calloutlist">
<dt><a class="co" href="#co_handling_null_with_optionals_CO2-1" id="callout_handling_null_with_optionals_CO2-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p><code>null</code> can represent any object type and, therefore, is a valid value for any non-primitive argument.</p></dd>
<dt><a class="co" href="#co_handling_null_with_optionals_CO2-2" id="callout_handling_null_with_optionals_CO2-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>A variable referencing <code>null</code> is like any other variable of that type.
Except for any call on it will result in a <code>NullPointerException</code>.</p></dd>
<dt><a class="co" href="#co_handling_null_with_optionals_CO2-3" id="callout_handling_null_with_optionals_CO2-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a></dt>
<dd><p>Testing a variable with <code>instanceof</code> will always evaluate to <code>false</code> regardless of the type.
Even if it’s explicitly cast into the required type, the <code>instanceof</code> operator tests the underlying value itself.
Therefore, it tests against the typeless value <code>null</code>.</p></dd>
</dl>
<p>These are the most apparent sore points with <code>null</code>.
Not to worry; there are ways to ease the pain.</p>
</div></section>
<section data-pdf-bookmark="How to handle null in Java (before Optionals)" data-type="sect1"><div class="sect1" id="idm45115230036192">
<h1>How to handle null in Java (before Optionals)</h1>
<p>Dealing with <code>null</code> in Java is an essential and necessary part of every developer’s work, even if it can be cumbersome.
Encountering an unexpected and unhandled <code>NullPointerException</code> is the root cause of many problems and must be dealt with accordingly.</p>
<p>Other languages, like <a href="https://www.swift.org">Swift</a>, provide dedicated operators and idioms, in the form of a safe navigation<sup><a data-type="noteref" href="ch09.xhtml#idm45115229645008" id="idm45115229645008-marker">2</a></sup> or <code>null</code> coalesce operator<sup><a data-type="noteref" href="ch09.xhtml#idm45115229642560" id="idm45115229642560-marker">3</a></sup> to make dealing with <code>null</code> easier.
Java doesn’t provide such built-in tools to handle <code>null</code> references, though.</p>
<p>There were three different ways to deal with <code>null</code> references before Optionals:</p>
<ul>
<li>
<p>Best practices</p>
</li>
<li>
<p>Tool-assisted <code>null</code>-checks</p>
</li>
<li>
<p>Specialized types like Optional</p>
</li>
</ul>
<p>As you will see later, handling <code>null</code> references shouldn’t rely solely on Optionals.
They are a great addition to the prior techniques by providing a standardized and readily available specialized type within the JDK.
Still, they’re not the final thought on how to manage <code>null</code> throughout your code, and knowing about all available techniques is a valuable addition to your skills toolkit.</p>
<section data-pdf-bookmark="Best Practices for Handling null" data-type="sect2"><div class="sect2" id="idm45115229632128">
<h2>Best Practices for Handling null</h2>
<p>If a language doesn’t provide integrated <code>null</code> handling, you must resort to <em>best practices</em> and <em>informal rules</em> to <code>null</code>-proof your code.
That’s why many companies, teams, and projects develop their own coding style or adapt existing ones to their needs to provide guidelines to write consistent and safer code, not only regarding <code>null</code>.
By adhering to these self-imposed practices and rules, they’re able to write more predictable and less error-prone code consistently.</p>
<p>You don’t have to develop or adapt a full-blown style guide defining every aspect of your Java code.
Instead, following these four rules are a good starting point for handling <code>null</code> references:</p>
<section data-pdf-bookmark="Don’t Initialize a Variable to null" data-type="sect3"><div class="sect3" id="idm45115229627232">
<h3>Don’t Initialize a Variable to null</h3>
<p>Variables should always have a non-<code>null</code> value.
If the value depends on a decision-making block like an <code>if</code>-<code>else</code>-statement, you should consider either refactoring it into a method or, if it’s a simple decision, using the ternary operator.</p>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// DON'T</code>

<code class="n">String</code> <code class="n">value</code> <code class="o">=</code> <code class="kc">null</code><code class="p">;</code>

<code class="k">if</code> <code class="p">(</code><code class="n">condition</code><code class="p">)</code> <code class="p">{</code>
  <code class="n">value</code> <code class="o">=</code> <code class="s">"Condition is true"</code><code class="p">;</code>
<code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
  <code class="n">value</code> <code class="o">=</code> <code class="s">"Fallback if false"</code><code class="p">;</code>
<code class="p">}</code>

<code class="c1">// DO</code>

<code class="n">String</code> <code class="n">asTernary</code> <code class="o">=</code> <code class="n">condition</code> <code class="o">?</code> <code class="s">"Condition is true"</code>
                             <code class="p">:</code> <code class="s">"Fallback if false"</code><code class="p">;</code>

<code class="n">String</code> <code class="n">asRefactored</code> <code class="o">=</code> <code class="n">refactoredMethod</code><code class="p">(</code><code class="n">condition</code><code class="p">);</code></pre>
<p>The additional benefit is that it makes the variable effectively <code>final</code> if you don’t reassign it later, so you can use them as out-of-body variables in lambda expressions.</p>
</div></section>
<section data-pdf-bookmark="Don’t Pass, Accept, or Return null" data-type="sect3"><div class="sect3" id="idm45115229620096">
<h3>Don’t Pass, Accept, or Return null</h3>
<p>As variables shouldn’t be <code>null</code>, so should any arguments and return values avoid being <code>null</code>.
Non-required arguments being <code>null</code> can be avoided by overloading a method or constructor:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">record</code> <code class="nc">User</code><code class="p">(</code><code class="kt">long</code> <code class="n">id</code><code class="p">,</code> <code class="n">String</code> <code class="n">firstname</code><code class="p">,</code> <code class="n">String</code> <code class="n">lastname</code><code class="p">)</code> <code class="p">{</code>

  <code class="c1">// DO: Additional constructor with default values to avoid null values</code>
  <code class="kd">public</code> <code class="nf">User</code><code class="p">(</code><code class="kt">long</code> <code class="n">id</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">(</code><code class="n">id</code><code class="p">,</code> <code class="s">"n/a"</code><code class="p">,</code> <code class="s">"n/a"</code><code class="p">);</code>
  <code class="p">}</code>

  <code class="c1">// ...</code>
<code class="p">}</code></pre>
<p>If method signatures clash due to identical argument types, you can always resort <code>static</code> methods with more explicit names instead.</p>
<p>After providing specific methods and constructors for optional values, you shouldn’t accept <code>null</code> in the original ones if it’s appropriate.
The easiest way to do this is using the <code>static</code> <code>requireNonNull</code> method available on <code>java.util.Objects</code>:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">record</code> <code class="nc">User</code><code class="p">(</code><code class="kt">long</code> <code class="n">id</code><code class="p">,</code> <code class="n">String</code> <code class="n">firstname</code><code class="p">,</code> <code class="n">String</code> <code class="n">lastname</code><code class="p">)</code> <code class="p">{</code>

  <code class="c1">// DO: Validate arguments against null</code>
  <code class="kd">public</code> <code class="n">User</code> <code class="p">{</code>
    <code class="n">Objects</code><code class="p">.</code><code class="na">requireNonNull</code><code class="p">(</code><code class="n">firstname</code><code class="p">);</code>
    <code class="n">Objects</code><code class="p">.</code><code class="na">requireNonNull</code><code class="p">(</code><code class="n">lastname</code><code class="p">);</code>
  <code class="p">}</code>

  <code class="c1">// ...</code>
<code class="p">}</code></pre>
<p>The <code>requireNionNull</code> call does the <code>null</code>-check for you and throws a <code>NullPointerException</code> if appropriate.
Since Java 14, any <code>NullPointerException</code> includes the name of the variable that was <code>null</code>, thanks to <a href="https://openjdk.org/jeps/358">JEP 358</a>.
If you want to include a specific message or target a previous Java version, you can add a <code>String</code> as the second argument to the call.</p>
</div></section>
<section data-pdf-bookmark="Check Everything Outside Your Control" data-type="sect3"><div class="sect3" id="idm45115229362880">
<h3>Check Everything Outside Your Control</h3>
<p>Even if you adhere to your own rules, you can’t rely on others to do, too.
Using non-familiar code, especially if not stated explicitly in the documentation, should always be assumed to be possibly <code>null</code> and needs to be checked.</p>
</div></section>
<section data-pdf-bookmark="null Is Acceptable as an Implementation Detail" data-type="sect3"><div class="sect3" id="idm45115229360912">
<h3>null Is Acceptable as an Implementation Detail</h3>
<p>Avoiding <code>null</code> is essential for the <code>public</code> surface of your code but is still sensible as an implementation detail.
Internally, a method might use <code>null</code> as much as needed as long as it won’t return it to the callee.</p>
</div></section>
<section data-pdf-bookmark="When and When Not to Follow the Rules" data-type="sect3"><div class="sect3" id="idm45115229357920">
<h3>When and When Not to Follow the Rules</h3>
<p>These rules aim at reducing the general use of <code>null</code> whenever possible if code is intersecting, like API surfaces, because less exposure leads to fewer required <code>null</code>-checks and possible <code>NullPointerExceptions</code>.
But that doesn’t mean you should avoid <code>null</code> altogether.
For example, in isolated contexts, like local variables or non-<code>public</code> API, using <code>null</code> isn’t as problematic and might even simplify your code as long as used deliberately and with care.</p>
<p>You can’t expect everyone to follow the same rules as you or be as diligent, so you need to be defensive with code, especially outside of your control.
This is all the more reason to consistently stick to your best practices and also encourage others to do the same.
They will improve your overall code quality, regardless of <code>null</code>.
But it’s not a silver bullet and requires discipline among your team to gain the most benefits.
Manually handling <code>null</code> and adding a few <code>null</code>-checks is preferable to getting the unwelcome surprise in the form of a <code>NullPointerException</code> because you assumed something could “never” be <code>null</code>.
The JIT compiler<sup><a data-type="noteref" href="ch09.xhtml#idm45115229323040" id="idm45115229323040-marker">4</a></sup> will even perform "<code>null</code> check elimination” to remove many explicit <code>null</code> checks from optimized Assembly code thanks to its greater knowledge at runtime.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Tool-Assisted null-checks" data-type="sect2"><div class="sect2" id="idm45115229320608">
<h2>Tool-Assisted null-checks</h2>
<p>A logical extension of the best practices and informal rules approach is to use third-party tools to enforce them automatically.
For <code>null</code> references in Java, an established best practice is to use annotations to mark variables, arguments, and method return types as either <code>@Nullable</code> or <code>@NonNull</code>.</p>
<p>Before such annotations, the only place to document nullability was JavaDoc.
With these annotations, static code analysis tools can find possible problems with <code>null</code> at compile time.
Even better, adding these annotations to your code gives your method signatures and type definitions a more evident intent of how to use them and what to expect, as seen in <a data-type="xref" href="#_02-optionals-annotations">Example 9-3</a>.</p>
<div data-type="example" id="_02-optionals-annotations">
<h5><span class="label">Example 9-3. </span>Null handling with annotation</h5>
<pre data-code-language="java" data-type="programlisting"><code class="kd">interface</code> <code class="nc">Example</code> <code class="p">{</code>

  <code class="nd">@NonNull</code> <code class="n">List</code><code class="o">&lt;</code><code class="nd">@Nullable</code> <code class="n">String</code><code class="o">&gt;</code> <code class="nf">getListOfNullableStrings</code><code class="p">(</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_handling_null_with_optionals_CO3-1" id="co_handling_null_with_optionals_CO3-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>

  <code class="nd">@Nullable</code> <code class="n">List</code><code class="o">&lt;</code><code class="nd">@NonNull</code> <code class="n">String</code><code class="o">&gt;</code> <code class="nf">getNullableListOfNonNullStrings</code><code class="p">(</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_handling_null_with_optionals_CO3-2" id="co_handling_null_with_optionals_CO3-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>

  <code class="kt">void</code> <code class="nf">doWork</code><code class="p">(</code><code class="nd">@Nullable</code> <code class="n">String</code> <code class="n">identifier</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_handling_null_with_optionals_CO3-3" id="co_handling_null_with_optionals_CO3-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a>
<code class="p">}</code></pre></div>
<dl class="calloutlist">
<dt><a class="co" href="#co_handling_null_with_optionals_CO3-1" id="callout_handling_null_with_optionals_CO3-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>Returns a non-<code>null</code> <code>List</code> of possible <code>null</code> <code>String</code> objects.</p></dd>
<dt><a class="co" href="#co_handling_null_with_optionals_CO3-2" id="callout_handling_null_with_optionals_CO3-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>Returns a possible <code>null</code> <code>List</code> containing non-<code>null</code> <code>String</code> objects.</p></dd>
<dt><a class="co" href="#co_handling_null_with_optionals_CO3-3" id="callout_handling_null_with_optionals_CO3-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a></dt>
<dd><p>The method argument <code>identifier</code> is allowed to be <code>null</code>.</p></dd>
</dl>
<p>The JDK doesn’t include these annotations, though, and the corresponding <a href="https://jcp.org/en/jsr/detail?id=305">JSR 305</a> state has been “dormant” since 2012.
Nevertheless, it’s still the <em>de facto</em> community standard and is widely adopted by libraries, frameworks, and IDEs.
Several libraries<sup><a data-type="noteref" href="ch09.xhtml#idm45115229213376" id="idm45115229213376-marker">5</a></sup> provide the missing annotations, and most tools support multiple variants of them.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Even though the behavior of <code>@NonNull</code> and <code>@Nullable</code> seems evident on the surface, the actual implementation might differ between tools, especially in edge cases<sup><a data-type="noteref" href="ch09.xhtml#idm45115229208080" id="idm45115229208080-marker">6</a></sup>.</p>
</div>
<p>The general problem with a tool-assisted approach is the reliance on the tool itself.
If it’s too intrusive, you might end up with code that won’t run without it, especially if the tool involves code generation “behind the scenes.”
In the case of <code>null</code>-related annotations, however, you don’t have to worry much.
Your code will still run without a tool interpreting the annotations, and your variables and method signatures will still clearly communicate their requirements to anyone using them, even if unenforced.</p>
</div></section>
<section data-pdf-bookmark="Specialized Types like Optional" data-type="sect2"><div class="sect2" id="idm45115229204608">
<h2>Specialized Types like Optional</h2>
<p>A tool-assisted approach gives you compile-time <code>null</code>-checks, whereas specialized types give you safer <code>null</code>-handling at runtime.
Before Java introduced its own <code>Optional</code> type, this gap in missing functionality was bridged by different libraries, like the rudimentary <code>Optional</code> type provided by the <a href="https://github.com/google/guava/wiki/Release10">Google Guava framework</a> since 2011.</p>
<p>Even though there’s now an integrated solution available in the JDK, Guava doesn’t plan to deprecate the class in the foreseeable future<sup><a data-type="noteref" href="ch09.xhtml#idm45115229199920" id="idm45115229199920-marker">7</a></sup>.
Still, they gently recommend that you prefer the new, standard Java <code>Optional&lt;T&gt;</code> whenever possible.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Optionals to the Rescue" data-type="sect1"><div class="sect1" id="idm45115229197344">
<h1>Optionals to the Rescue</h1>
<p>Java 8’s new <code>Optional&lt;T&gt;</code> isn’t only a specialized type to deal with <code>null</code> consistently; it’s also a functional-akin pipeline benefiting from all the functional additions available in the JDK.</p>
<section data-pdf-bookmark="What’s an Optional?" data-type="sect2"><div class="sect2" id="idm45115229195024">
<h2>What’s an Optional?</h2>
<p>The simplest way to think of the <code>Optional&lt;T&gt;</code> type is to see it as a box containing an actual value that might be <code>null</code>.
Instead of passing around a possible <code>null</code> reference, you use the box, as seen in <a data-type="xref" href="#_02-optionals-variable-versus-optional">Figure 9-1</a>.</p>
<figure><div class="figure" id="_02-optionals-variable-versus-optional">
<img alt="Variable versus Optional&lt;T&gt;" height="305" src="assets/afaj_0901.png" width="466"/>
<h6><span class="label">Figure 9-1. </span>Variable versus Optional&lt;T&gt;</h6>
</div></figure>
<p>The box provides a safe wrapper around its inner value.
Optionals do not only wrap a value, though.
Starting from this box, you can build intricate call chains that depend on a value’s existence or absence.
They can manage the whole lifecycle of a possible value until the box is unwrapped, including a fallback if no value is present, in such a call chain.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45115229188528">
<h1>The purpose and design goal of <code>Optional&lt;T&gt;</code></h1>
<p>Looking more closely at Optional’s origins and original design goal, they are not the general purpose tool you might think they were.</p>
<p>The original design goal was to create a new type to support the <em>optional return idiom</em>, meaning that it represents the result of a query or collection access.
That behavior is clearly visible in the Optional-based terminal Stream operations.</p>
<p>Taking Optionals beyond that initial scope offers many advantages compared to manual <code>null</code>-handling.
However, remember that any feature, like Optionals, Streams, or a functional approach in general, should always be a deliberate decision because it benefits your code and mental model of what it’s supposed to achieve.</p>
</div></aside>
<p>The downside of using a wrapper, though, is having to actually look and reach into the box if you want to use its inner value.
Like Streams, the additional wrapper also creates an unavoidable overhead regarding method calls and their additional stack frames.
On the other hand, the box provides additional functionality for more concise and straightforward code for common workflows with possible <code>null</code> values.</p>
<p>As an example, let’s look at the workflow of loading content by an identifier.
The numbers in <a data-type="xref" href="#_02-optionals-example-intro">Figure 9-2</a> correspond to the upcoming code in <a data-type="xref" href="#_01-optional-call-chain">Example 9-5</a>.</p>
<figure><div class="figure" id="_02-optionals-example-intro">
<img alt="Loading Content" height="527" src="assets/afaj_0902.png" width="600"/>
<h6><span class="label">Figure 9-2. </span>Workflow of loading content</h6>
</div></figure>
<p>The workflow is simplified and doesn’t handle all edge cases, but it’s a straightforward example of converting a multi-step workflow into an Optional call chain.
In <a data-type="xref" href="#_01-optional-call-chain_0">Example 9-4</a>, you see the workflow implemented without the help of Optionals first.</p>
<div data-type="example" id="_01-optional-call-chain_0">
<h5><span class="label">Example 9-4. </span>Loading content without Optionals</h5>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="n">Content</code> <code class="nf">loadFromDB</code><code class="p">(</code><code class="n">String</code> <code class="n">contentId</code><code class="p">)</code> <code class="p">{</code>
  <code class="c1">// ...</code>
<code class="p">}</code>

<code class="kd">public</code> <code class="n">Content</code> <code class="nf">get</code><code class="p">(</code><code class="n">String</code> <code class="n">contentId</code><code class="p">)</code> <code class="p">{</code>

  <code class="k">if</code> <code class="p">(</code><code class="n">contentId</code> <code class="o">==</code> <code class="kc">null</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="kc">null</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="k">if</code> <code class="p">(</code><code class="n">contentId</code><code class="p">.</code><code class="na">isBlank</code><code class="p">())</code> <code class="p">{</code>
    <code class="k">return</code> <code class="kc">null</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="kd">var</code> <code class="n">cacheKey</code> <code class="o">=</code> <code class="n">contentId</code><code class="p">.</code><code class="na">toLowerCase</code><code class="p">();</code>

  <code class="kd">var</code> <code class="n">content</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="na">cache</code><code class="p">.</code><code class="na">get</code><code class="p">(</code><code class="n">cacheKey</code><code class="p">);</code>
  <code class="k">if</code> <code class="p">(</code><code class="n">content</code> <code class="o">==</code> <code class="kc">null</code><code class="p">)</code> <code class="p">{</code>
    <code class="n">content</code> <code class="o">=</code> <code class="n">loadFromDB</code><code class="p">(</code><code class="n">contentId</code><code class="p">);</code>
  <code class="p">}</code>

  <code class="k">if</code> <code class="p">(</code><code class="n">content</code> <code class="o">==</code> <code class="kc">null</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="kc">null</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="n">content</code><code class="p">.</code><code class="na">isPublished</code><code class="p">())</code> <code class="p">{</code>
    <code class="k">return</code> <code class="kc">null</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="k">return</code> <code class="n">content</code><code class="p">;</code>
<code class="p">}</code></pre></div>
<p>The example is exaggerated to make a point, but still mostly reflects a typical approach to defensive <code>null</code>-handling.</p>
<p>There are three explicit <code>null</code>-checks, plus two decisions to be made about a current value and two temporary variables.
Even though it’s not much code, the overall flow isn’t easily graspable with its many <code>if</code>-blocks and early returns.</p>
<p>Let’s convert the code to a single Optional call chain, as shown in <a data-type="xref" href="#_01-optional-call-chain">Example 9-5</a>.
Don’t worry!
The upcoming sections will explain the different kinds of operations in detail.</p>
<div data-type="example" id="_01-optional-call-chain">
<h5><span class="label">Example 9-5. </span>Loading content with an Optional call chain</h5>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="n">Optional</code><code class="o">&lt;</code><code class="n">Content</code><code class="o">&gt;</code> <code class="nf">loadFromDB</code><code class="p">(</code><code class="n">String</code> <code class="n">contentId</code><code class="p">)</code> <code class="p">{</code>
  <code class="c1">// ...</code>
<code class="p">}</code>

<code class="kd">public</code> <code class="n">Optional</code><code class="o">&lt;</code><code class="n">Content</code><code class="o">&gt;</code> <code class="nf">get</code><code class="p">(</code><code class="n">String</code> <code class="n">contentId</code><code class="p">)</code> <code class="p">{</code>

  <code class="k">return</code> <code class="n">Optional</code><code class="p">.</code><code class="na">ofNullable</code><code class="p">(</code><code class="n">contentId</code><code class="p">)</code> <a class="co" href="#callout_handling_null_with_optionals_CO4-1" id="co_handling_null_with_optionals_CO4-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>
                 <code class="p">.</code><code class="na">filter</code><code class="p">(</code><code class="n">Predicate</code><code class="p">.</code><code class="na">not</code><code class="p">(</code><code class="n">String</code><code class="p">:</code><code class="p">:</code><code class="n">isBlank</code><code class="p">)</code><code class="p">)</code> <a class="co" href="#callout_handling_null_with_optionals_CO4-2" id="co_handling_null_with_optionals_CO4-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>
                 <code class="p">.</code><code class="na">map</code><code class="p">(</code><code class="n">String</code><code class="p">:</code><code class="p">:</code><code class="n">toLowerCase</code><code class="p">)</code> <a class="co" href="#callout_handling_null_with_optionals_CO4-3" id="co_handling_null_with_optionals_CO4-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a>
                 <code class="p">.</code><code class="na">map</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="na">cache</code><code class="p">:</code><code class="p">:</code><code class="n">get</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_handling_null_with_optionals_CO4-4" id="co_handling_null_with_optionals_CO4-4"><img alt="4" height="12" src="assets/4.png" width="12"/></a>
                 <code class="p">.</code><code class="na">or</code><code class="p">(</code><code class="p">(</code><code class="p">)</code> <code class="o">-</code><code class="o">&gt;</code> <code class="n">loadFromDB</code><code class="p">(</code><code class="n">contentId</code><code class="p">)</code><code class="p">)</code> <a class="co" href="#callout_handling_null_with_optionals_CO4-5" id="co_handling_null_with_optionals_CO4-5"><img alt="5" height="12" src="assets/5.png" width="12"/></a>
                 <code class="p">.</code><code class="na">filter</code><code class="p">(</code><code class="n">Content</code><code class="p">:</code><code class="p">:</code><code class="n">isPublished</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_handling_null_with_optionals_CO4-6" id="co_handling_null_with_optionals_CO4-6"><img alt="6" height="12" src="assets/6.png" width="12"/></a>
<code class="p">}</code></pre></div>
<dl class="calloutlist">
<dt><a class="co" href="#co_handling_null_with_optionals_CO4-1" id="callout_handling_null_with_optionals_CO4-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>The first possible <code>null</code>-check is done by using the <code>ofNullable</code> creation method.</p></dd>
<dt><a class="co" href="#co_handling_null_with_optionals_CO4-2" id="callout_handling_null_with_optionals_CO4-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>The next <code>if</code>-block is replaced by a <code>filter</code> operation.</p></dd>
<dt><a class="co" href="#co_handling_null_with_optionals_CO4-3" id="callout_handling_null_with_optionals_CO4-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a></dt>
<dd><p>Instead of using temporary variables, the <code>map</code> operation transforms the value to match the next call.</p></dd>
<dt><a class="co" href="#co_handling_null_with_optionals_CO4-4" id="callout_handling_null_with_optionals_CO4-4"><img alt="4" height="12" src="assets/4.png" width="12"/></a></dt>
<dd><p>The content is also retrievable by a <code>map</code> operation.</p></dd>
<dt><a class="co" href="#co_handling_null_with_optionals_CO4-5" id="callout_handling_null_with_optionals_CO4-5"><img alt="5" height="12" src="assets/5.png" width="12"/></a></dt>
<dd><p>Load the content from the database if no value is present in the pipeline.
This call will return another Optional so that the call chain can continue.</p></dd>
<dt><a class="co" href="#co_handling_null_with_optionals_CO4-6" id="callout_handling_null_with_optionals_CO4-6"><img alt="6" height="12" src="assets/6.png" width="12"/></a></dt>
<dd><p>Ensure only published content is available.</p></dd>
</dl>
<p>The Optional call chain condenses the overall code to one operation per line, making the overall flow easily graspable.
It perfectly highlights the difference between using an Optional call chain and the “traditional” way of <code>null</code> checking everything.</p>
<p>Let’s take a look at the different steps of creating and working with Optional pipelines.</p>
</div></section>
<section data-pdf-bookmark="Building Optional Pipelines" data-type="sect2"><div class="sect2" id="idm45115229194400">
<h2>Building Optional Pipelines</h2>
<p>As of Java 17, <code>Optional&lt;T&gt;</code> provides three <code>static</code> and 15 instance methods belonging to one of four groups representing different parts of an Optional pipeline:</p>
<ul>
<li>
<p>Creating a new <code>Optional&lt;T&gt;</code> instance</p>
</li>
<li>
<p>Checking for values or reacting to the presence or absence of a value</p>
</li>
<li>
<p>Filtering and transforming a value</p>
</li>
<li>
<p>Getting the value or having a backup plan</p>
</li>
</ul>
<p>These operations can build a fluent pipeline, similar to Streams.
Contrary to Streams, though, they are <em>not</em> lazily connected until a <em>terminal</em>-like operation is added to the pipeline, as I discussed in <a data-type="xref" href="ch06.xhtml#_02-data-processing-what-is-a-stream">“Streams as Functional Data Pipelines”</a>.
Every operation resolves as soon as it’s added to the fluent call.
Optionals only appear lazy because they might return an empty Optional or a fallback value and skip transforming or filtering steps altogether.
Still, that doesn’t make the call chain itself lazy.
However, the executed work is as minimal as possible if a <code>null</code>-value is encountered, regardless of the operation count.</p>
<p>You can think of an Optional call chain as two train tracks, as illustrated in <a data-type="xref" href="#_02-optionals-fasttrack">Figure 9-3</a>.</p>
<figure><div class="figure" id="_02-optionals-fasttrack">
<img alt="Optional Train Tracks" height="228" src="assets/afaj_0903.png" width="600"/>
<h6><span class="label">Figure 9-3. </span>Optional Train Tracks</h6>
</div></figure>
<p>In this analogy, we have two train tracks: the Optional call chain track that leads to returning an <code>Optional&lt;T&gt;</code> with an inner value and the “empty express track” that leads to an empty <code>Optional&lt;T&gt;</code>.
A train always starts on the <code>Optional&lt;T&gt;</code> call train track.
When it encounters a track switch (an Optional operation), it looks for a <code>null</code> value, in which case, the train will switch to the empty express track.
Once on the express track, there is no chance of returning to the Optional call chain track, at least not until Java 9, as you’ll see in <a data-type="xref" href="#_02-optionals_getting-a-value">“Getting a (fallback) value”</a>.</p>
<p>Technically, it will still call each method on the Optional call chain after switching to the empty express track, but it’ll just validate parameters and move on.
If the train didn’t encounter a <code>null</code> value by the time it reaches the end of its route, it returns a non-empty <code>Optional&lt;T&gt;</code>.
If it encounters a <code>null</code> value at any point along the route, it will return an empty <code>Optional&lt;T&gt;</code>.</p>
<p>To get the train rolling, let’s create some Optionals.</p>
<section data-pdf-bookmark="Creating an Optional" data-type="sect3"><div class="sect3" id="idm45115228737632">
<h3>Creating an Optional</h3>
<p>There are no <code>public</code> constructors available on the <code>Optional&lt;T&gt;</code> type.
Instead, it gives you three <code>static</code> factory methods to create new instances.
Which one to use depends on your use case and prior knowledge of the inner value:</p>
<dl>
<dt><code>Optional.ofNullable(T value)</code> if the value might be <code>null</code></dt>
<dd>
<p>If you know a value might be <code>null</code> or don’t care if it might be empty, use the method <code>Optional.ofNullable(…​)</code> to create a new instance with a possible inner <code>null</code> value.
It’s the simplest and most bullet-proof form of creating an <code>Optional&lt;T&gt;</code>.</p>
</dd>
</dl>
<pre data-code-language="java" data-type="programlisting"><code class="n">String</code> <code class="n">hasValue</code> <code class="o">=</code> <code class="s">"Optionals are awesome!"</code><code class="p">;</code>
<code class="n">Optional</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">maybeValue</code> <code class="o">=</code> <code class="n">Optional</code><code class="p">.</code><code class="na">ofNullable</code><code class="p">(</code><code class="n">hasValue</code><code class="p">);</code>

<code class="n">String</code> <code class="n">nullRef</code> <code class="o">=</code> <code class="kc">null</code><code class="p">;</code>
<code class="n">Optional</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">emptyOptional</code> <code class="o">=</code> <code class="n">Optional</code><code class="p">.</code><code class="na">ofNullable</code><code class="p">(</code><code class="n">nullRef</code><code class="p">);</code></pre>
<dl>
<dt><code>Optional.of(T value)</code> if the value must be non-<code>null</code></dt>
<dd>
<p>Even though Optionals are a great way to deal with <code>null</code> and prevent a <code>NullPointerException</code>, what if you have to make sure you have a value?
For example, you already handled any edge cases in your code — which returned empty Optionals — and now you definitely have a value.
The method <code>Optional.of(…​)</code> ensures that the value is non-<code>null</code> and throws an <code>NullPointerException</code> otherwise.
This way, the exception signifies a real problem in your code.
Maybe you missed an edge case, or a particular external method call has changed and returns <code>null</code> now.
Using <code>Optional.of(…​)</code> in such a context makes your code more future-proof and resilient against unwanted changes in behavior.</p>
</dd>
</dl>
<pre data-code-language="java" data-type="programlisting"><code class="kd">var</code> <code class="n">value</code> <code class="o">=</code> <code class="s">"Optionals are awesome!"</code><code class="p">;</code>
<code class="n">Optional</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">mustHaveValue</code> <code class="o">=</code> <code class="n">Optional</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="n">value</code><code class="p">);</code>

<code class="n">value</code> <code class="o">=</code> <code class="kc">null</code><code class="p">;</code>
<code class="n">Optional</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">emptyOptional</code> <code class="o">=</code> <code class="n">Optional</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="n">value</code><code class="p">);</code>
<code class="c1">// =&gt; throws NullPointerException</code></pre>
<dl>
<dt><code>Optional.empty()</code> if there’s no value</dt>
<dd>
<p>If you already know there’s no value at all, you can use the <code>static</code> method <code>Optional.empty()</code>.
The call <code>Optional.ofNullable(null)</code> is unnecessary because there will be just an unnecessary <code>null</code> check before calling <code>empty()</code> itself.</p>
</dd>
</dl>
<pre data-code-language="java" data-type="programlisting"><code class="n">Optional</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">noValue</code> <code class="o">=</code> <code class="n">Optional</code><code class="p">.</code><code class="na">empty</code><code class="p">();</code></pre>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>The JDK documentation explicitly mentions that the value returned by the <code>static</code> <code>Optional.empty</code> method isn’t guaranteed to be a singleton object.
So you shouldn’t compare empty Optionals with <code>==</code> (double-equals), and use <code>equals(Object obj)</code> or compare the result of the <code>isEmpty</code> method instead.</p>
</div>
<p>Using <code>Optional.ofNullable(T value)</code> might be the most <code>null</code>-tolerant creation method, but you should strive to use the most fitting one to represent your use case and context knowledge.
Code might get refactored or rewritten over time, and it’s better to have your code throw a <code>NullPointerException</code> for a suddenly missing value that’s actually required as an additional safeguard, even if the API itself is using Optionals.</p>
</div></section>
<section data-pdf-bookmark="Checking for and Reacting to Values" data-type="sect3"><div class="sect3" id="_02-optionals-checking">
<h3>Checking for and Reacting to Values</h3>
<p>Optionals are meant to wrap a value and represent its existence or absence.
They are implemented as a Java type and are, therefore, a runtime-level feature and incur an unavoidable overhead associated with object creation.
To compensate for this, checking for values should be as straightforward as possible.</p>
<p>There are four methods available for checking for and reacting to values or their absence.
They are prefixed with "<code>is</code>" for checks and "<code>if</code>" for reactive higher-order functions:</p>
<ul>
<li>
<p><code>boolean isPresent()</code></p>
</li>
<li>
<p><code>boolean isEmpty()</code> (Java 11+)</p>
</li>
</ul>
<p>Solely checking for a value has its purposes, but checking, retrieving, and using a value requires three separate steps when you use "<code>is</code>" methods.</p>
<p>That’s why the higher-order "<code>if</code>" methods consume a value directly:</p>
<ul>
<li>
<p><code>void ifPresent(Consumer&lt;? super T&gt; action)</code></p>
</li>
<li>
<p><code>void ifPresentOrElse(Consumer&lt;? super T&gt; action, Runnable emptyAction)</code></p>
</li>
</ul>
<p>Both methods only perform the given <code>action</code> if a value is present.
The second method runs the <code>emptyAction</code> if no value is present.
<code>null</code> actions aren’t allowed and throw a <code>NullPointerException</code>.
There are no <code>ifEmpty…​</code> equivalents available.</p>
<p>Let’s look at how to use these methods in <a data-type="xref" href="#_02-optionals_checking">Example 9-6</a>.</p>
<div data-type="example" id="_02-optionals_checking">
<h5><span class="label">Example 9-6. </span>Checking for Optional values</h5>
<pre data-code-language="java" data-type="programlisting"><code class="n">Optional</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">maybeValue</code> <code class="o">=</code> <code class="p">...;</code>

<code class="c1">// VERBOSE VERSION</code>

<code class="k">if</code> <code class="p">(</code><code class="n">maybeValue</code><code class="p">.</code><code class="na">isPresent</code><code class="p">())</code> <code class="p">{</code>
  <code class="kd">var</code> <code class="n">value</code> <code class="o">=</code> <code class="n">maybeValue</code><code class="p">.</code><code class="na">orElseThrow</code><code class="p">();</code>
  <code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">value</code><code class="p">);</code>
<code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
  <code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="s">"No value found!"</code><code class="p">);</code>
<code class="p">}</code>


<code class="c1">// CONCISE VERSION</code>

<code class="n">maybeValue</code><code class="p">.</code><code class="na">ifPresentOrElse</code><code class="p">(</code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">::</code><code class="n">println</code><code class="p">,</code>
                           <code class="p">()</code> <code class="o">-&gt;</code> <code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="s">"No value found!"</code><code class="p">));</code></pre></div>
<p>Both "<code>ifPresent</code>" methods perform side-effects-only code due to a lack of a return type.
Even though pure functions are generally preferable in a functional approach, Optionals live somewhere between accepting functional code and fitting right into imperative code.</p>
</div></section>
<section data-pdf-bookmark="Filtering and Mapping" data-type="sect3"><div class="sect3" id="idm45115228548320">
<h3>Filtering and Mapping</h3>
<p>Safely handling possible <code>null</code> values already removes a considerable burden from any developer, but Optionals allow for more than just checking for the presence or absence of a value.</p>
<p>Similar to Streams, you build a pipeline with intermediate-like operations.
There are three operations for filtering and mapping Optionals:</p>
<ul>
<li>
<p><code>Optional&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</code></p>
</li>
<li>
<p><code>&lt;U&gt; Optional&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; mapper)</code></p>
</li>
<li>
<p><code>&lt;U&gt; Optional&lt;U&gt; flatMap(Function&lt;? super T, ? extends Optional&lt;? extends U&gt;&gt; mapper)</code></p>
</li>
</ul>
<p>The <code>filter</code> operation returns <code>this</code> if a value is present and matches the given predicate.
If no value is present or the predicate doesn’t match the value, an empty Optional is returned.</p>
<p>The <code>map</code> operation transforms a present value with the provided mapper function, returning a new nullable Optional containing the mapped value.
If no value is present, the operation returns an empty <code>Optional&lt;U&gt;</code> instead.</p>
<p>The <code>flatMap</code> is used if the mapping function returns an <code>Optional&lt;U&gt;</code> instead of a concrete value of type <code>U</code>.
If you would use the <code>map</code> in this case, the return value would be an <code>Optional&lt;Optional&lt;U&gt;&gt;</code>.
That’s why the <code>flatMap</code> returns the mapped value directly instead of wrapping it into another Optional.</p>
<p><a data-type="xref" href="#_02-optionals_intermediate-ops">Example 9-7</a> shows an Optional call chain and the non-Optional equivalent for a hypothetical permissions container and its sub-types.
The code callouts are attached to both versions to show the corresponding operations, but their descriptions are for the Optional version.</p>
<div data-type="example" id="_02-optionals_intermediate-ops">
<h5><span class="label">Example 9-7. </span>Intermediate operations to find an active admin</h5>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">record</code> <code class="nc">Permissions</code><code class="p">(</code><code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">permissions</code><code class="p">,</code> <code class="n">Group</code> <code class="n">group</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">public</code> <code class="kt">boolean</code> <code class="nf">isEmpty</code><code class="p">(</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="n">permissions</code><code class="p">.</code><code class="na">isEmpty</code><code class="p">(</code><code class="p">)</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kd">public</code> <code class="kd">record</code> <code class="nc">Group</code><code class="p">(</code><code class="n">Optional</code><code class="o">&lt;</code><code class="n">User</code><code class="o">&gt;</code> <code class="n">admin</code><code class="p">)</code> <code class="p">{</code>
  <code class="c1">// NO BODY</code>
<code class="p">}</code>

<code class="kd">public</code> <code class="kd">record</code> <code class="nc">User</code><code class="p">(</code><code class="kt">boolean</code> <code class="n">isActive</code><code class="p">)</code> <code class="p">{</code>
    <code class="c1">// NO BODY</code>
<code class="p">}</code>

<code class="n">Permissions</code> <code class="n">permissions</code> <code class="o">=</code> <code class="p">.</code><code class="p">.</code><code class="p">.</code><code class="p">;</code>

<code class="kt">boolean</code> <code class="n">isActiveAdmin</code> <code class="o">=</code>
  <code class="n">Optional</code><code class="p">.</code><code class="na">ofNullable</code><code class="p">(</code><code class="n">permissions</code><code class="p">)</code> <a class="co" href="#callout_handling_null_with_optionals_CO5-1" id="co_handling_null_with_optionals_CO5-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>
          <code class="p">.</code><code class="na">filter</code><code class="p">(</code><code class="n">Predicate</code><code class="p">.</code><code class="na">not</code><code class="p">(</code><code class="n">Permissions</code><code class="p">:</code><code class="p">:</code><code class="n">isEmpty</code><code class="p">)</code><code class="p">)</code> <a class="co" href="#callout_handling_null_with_optionals_CO5-2" id="co_handling_null_with_optionals_CO5-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>
          <code class="p">.</code><code class="na">map</code><code class="p">(</code><code class="n">Permissions</code><code class="p">:</code><code class="p">:</code><code class="n">group</code><code class="p">)</code> <a class="co" href="#callout_handling_null_with_optionals_CO5-3" id="co_handling_null_with_optionals_CO5-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a>
          <code class="p">.</code><code class="na">flatMap</code><code class="p">(</code><code class="n">Group</code><code class="p">:</code><code class="p">:</code><code class="n">admin</code><code class="p">)</code> <a class="co" href="#callout_handling_null_with_optionals_CO5-4" id="co_handling_null_with_optionals_CO5-4"><img alt="4" height="12" src="assets/4.png" width="12"/></a>
          <code class="p">.</code><code class="na">map</code><code class="p">(</code><code class="n">User</code><code class="p">:</code><code class="p">:</code><code class="n">isActive</code><code class="p">)</code> <a class="co" href="#callout_handling_null_with_optionals_CO5-5" id="co_handling_null_with_optionals_CO5-5"><img alt="5" height="12" src="assets/5.png" width="12"/></a>
          <code class="p">.</code><code class="na">orElse</code><code class="p">(</code><code class="n">Boolean</code><code class="p">.</code><code class="na">FALSE</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_handling_null_with_optionals_CO5-6" id="co_handling_null_with_optionals_CO5-6"><img alt="6" height="12" src="assets/6.png" width="12"/></a></pre></div>
<dl class="calloutlist">
<dt><a class="co" href="#co_handling_null_with_optionals_CO5-1" id="callout_handling_null_with_optionals_CO5-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>The initial <code>null</code>-check is covered by creating an <code>Optional&lt;Permissions&gt;</code>.</p></dd>
<dt><a class="co" href="#co_handling_null_with_optionals_CO5-2" id="callout_handling_null_with_optionals_CO5-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>Filter for non-empty permissions.
With the help of the <code>static</code> <code>Predicate.not</code> method, the lambda <code>permissions → !permissions.isEmpty()</code> is replaced with a more readable wrapped method reference.</p></dd>
<dt><a class="co" href="#co_handling_null_with_optionals_CO5-3" id="callout_handling_null_with_optionals_CO5-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a></dt>
<dd><p>Get the group of the permissions object.
It doesn’t matter if the <code>Permissions::group</code> returns <code>null</code> because the Optional call chain will figuratively skip to its value-retrieving operation if that’s the case.
In reality, an empty Optional is passing through the fluent calls.</p></dd>
<dt><a class="co" href="#co_handling_null_with_optionals_CO5-4" id="callout_handling_null_with_optionals_CO5-4"><img alt="4" height="12" src="assets/4.png" width="12"/></a></dt>
<dd><p>The group might not have an admin.
That’s why it returns an <code>Optional&lt;User&gt;</code>.
If you simply use <code>map(Group::admin)</code>, you will have an <code>Optional&lt;Optional&lt;User&gt;&gt;</code> in the next step.
Thanks to <code>flatMap(Group::admin)</code>, no unnecessarily nested Optional is created.</p></dd>
<dt><a class="co" href="#co_handling_null_with_optionals_CO5-5" id="callout_handling_null_with_optionals_CO5-5"><img alt="5" height="12" src="assets/5.png" width="12"/></a></dt>
<dd><p>With the <code>User</code> object, you can filter out non-active ones.</p></dd>
<dt><a class="co" href="#co_handling_null_with_optionals_CO5-6" id="callout_handling_null_with_optionals_CO5-6"><img alt="6" height="12" src="assets/6.png" width="12"/></a></dt>
<dd><p>If any method of the call chain returns an empty Optional, e.g., the group was <code>null</code>, the last operation returns the fallback value <code>Boolean.FALSE</code>.
The next section will explain the different types of value-retrieval operations.</p></dd>
</dl>
<p>Every step of the underlying problem that needs to be solved is laid out in clear, isolated, and directly connected steps.
Any validation and decision-making, like <code>null</code> or empty-checks, is wrapped up in dedicated operations built on method references.
The intent and flow of the problem to be solved are clearly visible and easy to grasp.</p>
<p>Doing the same thing without Optionals results in a nested mess of code, as seen in <a data-type="xref" href="#_02-optionals_intermediate-ops_non-optional">Example 9-8</a>.</p>
<div data-type="example" id="_02-optionals_intermediate-ops_non-optional">
<h5><span class="label">Example 9-8. </span>Finding an active admin without Optionals</h5>
<pre data-code-language="java" data-type="programlisting"><code class="kt">boolean</code> <code class="n">isActiveAdmin</code> <code class="o">=</code> <code class="kc">false</code><code class="p">;</code>

<code class="k">if</code> <code class="p">(</code><code class="n">permissions</code> <code class="o">!=</code> <code class="kc">null</code> <code class="o">&amp;&amp;</code> <code class="o">!</code><code class="n">permissions</code><code class="p">.</code><code class="na">isEmpty</code><code class="p">())</code> <code class="p">{</code>

  <code class="k">if</code> <code class="p">(</code><code class="n">permissions</code><code class="p">.</code><code class="na">group</code><code class="p">()</code> <code class="o">!=</code> <code class="kc">null</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">var</code> <code class="n">group</code> <code class="o">=</code> <code class="n">permissions</code><code class="p">.</code><code class="na">group</code><code class="p">();</code>
    <code class="kd">var</code> <code class="n">maybeAdmin</code> <code class="o">=</code> <code class="n">group</code><code class="p">.</code><code class="na">admin</code><code class="p">();</code>

    <code class="k">if</code> <code class="p">(</code><code class="n">maybeAdmin</code><code class="p">.</code><code class="na">isPresent</code><code class="p">())</code> <code class="p">{</code>
      <code class="kd">var</code> <code class="n">admin</code> <code class="o">=</code> <code class="n">maybeAdmin</code><code class="p">.</code><code class="na">orElseThrow</code><code class="p">();</code>
      <code class="n">isActiveAdmin</code> <code class="o">=</code> <code class="n">admin</code><code class="p">.</code><code class="na">isActive</code><code class="p">();</code>
    <code class="p">}</code>
  <code class="p">}</code>
<code class="p">}</code></pre></div>
<p>The difference between the two versions is quite noticeable.</p>
<p>The non-Optional version can’t delegate any conditions or checks and relies on explicit <code>if</code>-statements.
That creates deeply nested flow structures, increasing the <em>cyclomatic complexity</em> of your code.
It’s harder to understand the overall intent of the code block, and it is not as concise as with an Optional call chain.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><em>Cyclomatic Complexity<sup><a data-type="noteref" href="ch09.xhtml#idm45115228055056" id="idm45115228055056-marker">8</a></sup></em> is a metric used to determine code complexity.
It’s based on the number of branching paths — or decisions — in your code.
The general idea is that straight, non-nested statements and expressions are more accessible to follow and less error-prone than deeply nested decision branches, like nested <code>if</code>-statements.</p>
</div>
</div></section>
<section data-pdf-bookmark="Getting a (fallback) value" data-type="sect3"><div class="sect3" id="_02-optionals_getting-a-value">
<h3>Getting a (fallback) value</h3>
<p>Optionals might provide a safe wrapper for possible <code>null</code> values, but you might need an actual value at some point.
There are multiple ways to retrieve an Optional’s inner value, ranging from “brute force” to providing fallback values.</p>
<p>The first method doesn’t concern itself with any safety checks:</p>
<ul>
<li>
<p><code>T get()</code></p>
</li>
</ul>
<p>The Optional is unwrapped forcefully, and if no value is present, a <code>NoSuchElementException</code> is thrown, so make sure to check that a value exists beforehand.</p>
<p>The next two methods provide a fallback value if no value is present:</p>
<ul>
<li>
<p><code>T orElse(T other)</code></p>
</li>
<li>
<p><code>T orElseGet(Supplier&lt;? extends T&gt; supplier)</code></p>
</li>
</ul>
<p>The <code>Supplier</code>-based variant allows for lazily getting a fallback, which is immensely useful if creating it is resource intensive.</p>
<p>There are two methods available to throw Exceptions:</p>
<ul>
<li>
<p><code>&lt;X extends Throwable&gt; T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)</code></p>
</li>
<li>
<p><code>T orElseThrow()</code> (Java 10+)</p>
</li>
</ul>
<p>Even though one of the main advantages of Optionals is preventing <code>NullPointerException</code>, sometimes you still need a domain-specific exception if there’s no value present.
With the <code>orElseThrow</code> operation, you have fine-grained control about handling a missing value and what exception to throw, too.
The second method, <code>orElseThrow</code>, was added as a semantically correct and preferred alternative to the <code>get</code> operation.
Even though the call isn’t as concise, it better fits into the overall naming scheme and confers that an Exception might be thrown.</p>
<p>Java 9 added two additional methods for providing another <code>Optional&lt;T&gt;</code> as a fallback or a <code>Stream&lt;T&gt;</code>.
These allow more complex call chains than before:</p>
<p>The first one, <code>Optional&lt;T&gt; or(Supplier&lt;? extends Optional&lt;? extends T&gt;&gt; supplier)</code>, lazily returns another Optional if no value is present.
This way, you can continue an Optional call chain, even if no value was present before calling <code>or</code>.
To go back to the “train track” analogy, the <code>or</code> operation is a way to provide a track switch back from the empty express track by creating a new starting point on the Optional call chain track.</p>
<p>The other one, <code>Stream&lt;T&gt; stream()</code>, returns a Stream containing the value as its sole element or an empty Stream if no value is present.
Usually used in the intermediate Stream operation <code>flatMap</code> as a method reference.
The Optional <code>stream</code> operation plays a broader role in the interoperability with the Stream API I discussed in <a data-type="xref" href="ch07.xhtml#_02-streams">Chapter 7</a>.</p>
</div></section>
</div></section>
</div></section>
<section data-pdf-bookmark="Optionals and Streams" data-type="sect1"><div class="sect1" id="idm45115228756096">
<h1>Optionals and Streams</h1>
<p>As discussed in previous chapters, Streams are pipelines that filter and transform elements into the desired outcome.
Optionals fit right in as a functional wrapper for possible <code>null</code> references, but they must play by the rules of Stream pipelines when used as elements and confer their state to the pipeline.</p>
<section data-pdf-bookmark="Optionals as Stream Elements" data-type="sect2"><div class="sect2" id="_02-optionals_stream">
<h2>Optionals as Stream Elements</h2>
<p>With Streams, elements are excluded from further processing by using a filtering operation to discard them.
In essence, Optionals themselves represent a kind of filtering operation, although not directly compatible with how Streams expect elements to behave.</p>
<p>If a Stream element is excluded by a <code>filter</code> operation, it won’t traverse the Stream further.
This could be achieved by using <code>Optional::isPresent</code> as the <code>filter</code> operation’s argument.
However, the resulting Stream in the case of an inner value, <code>Stream&lt;Optional&lt;User&gt;&gt;</code>, isn’t what you want.</p>
<p>To restore “normal” Stream semantics, you need to map the Stream from <code>Stream&lt;Optional&lt;User&gt;&gt;</code> to <code>Stream&lt;User&gt;</code>, as seen in <a data-type="xref" href="#_02-optionals_streams_with_optionals">Example 9-9</a>.</p>
<div data-type="example" id="_02-optionals_streams_with_optionals">
<h5><span class="label">Example 9-9. </span>Optionals as Stream elements</h5>
<pre data-code-language="java" data-type="programlisting"><code class="n">List</code><code class="o">&lt;</code><code class="n">Permissions</code><code class="o">&gt;</code> <code class="n">permissions</code> <code class="o">=</code> <code class="p">.</code><code class="p">.</code><code class="p">.</code><code class="p">;</code>

<code class="n">List</code><code class="o">&lt;</code><code class="n">User</code><code class="o">&gt;</code> <code class="n">activeUsers</code> <code class="o">=</code>
  <code class="n">permissions</code><code class="p">.</code><code class="na">stream</code><code class="p">(</code><code class="p">)</code>
             <code class="p">.</code><code class="na">filter</code><code class="p">(</code><code class="n">Predicate</code><code class="p">.</code><code class="na">not</code><code class="p">(</code><code class="n">Permissions</code><code class="p">:</code><code class="p">:</code><code class="n">isEmpty</code><code class="p">)</code><code class="p">)</code>
             <code class="p">.</code><code class="na">map</code><code class="p">(</code><code class="n">Permissions</code><code class="p">:</code><code class="p">:</code><code class="n">group</code><code class="p">)</code>
             <code class="p">.</code><code class="na">map</code><code class="p">(</code><code class="n">Group</code><code class="p">:</code><code class="p">:</code><code class="n">admin</code><code class="p">)</code> <a class="co" href="#callout_handling_null_with_optionals_CO6-1" id="co_handling_null_with_optionals_CO6-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>
             <code class="p">.</code><code class="na">filter</code><code class="p">(</code><code class="n">Optional</code><code class="p">:</code><code class="p">:</code><code class="n">isPresent</code><code class="p">)</code> <a class="co" href="#callout_handling_null_with_optionals_CO6-2" id="co_handling_null_with_optionals_CO6-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>
             <code class="p">.</code><code class="na">map</code><code class="p">(</code><code class="n">Optional</code><code class="p">:</code><code class="p">:</code><code class="n">orElseThrow</code><code class="p">)</code> <a class="co" href="#callout_handling_null_with_optionals_CO6-2" id="co_handling_null_with_optionals_CO6-3"><img alt="2" height="12" src="assets/2.png" width="12"/></a>
             <code class="p">.</code><code class="na">filter</code><code class="p">(</code><code class="n">User</code><code class="p">:</code><code class="p">:</code><code class="n">isActive</code><code class="p">)</code>
             <code class="p">.</code><code class="na">toList</code><code class="p">(</code><code class="p">)</code><code class="p">;</code></pre></div>
<dl class="calloutlist">
<dt><a class="co" href="#co_handling_null_with_optionals_CO6-1" id="callout_handling_null_with_optionals_CO6-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>The <code>Group::admin</code> method reference returns an <code>Optional&lt;User&gt;</code>.
At this point, the Stream becomes a <code>Stream&lt;Optional&lt;User&gt;&gt;</code>.</p></dd>
<dt><a class="co" href="#co_handling_null_with_optionals_CO6-2" id="callout_handling_null_with_optionals_CO6-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>The Stream pipeline requires multiple operations to check for a value and safely unwrap it from its <code>Optional</code>.</p></dd>
</dl>
<p>Filtering and mapping an <code>Optional&lt;T&gt;</code> is such a standard use case for Optionals in Streams that Java 9 added the <code>stream</code> method to the <code>Optional&lt;T&gt;</code> type.
It returns a <code>Stream&lt;T&gt;</code> containing the inner value if present as its sole element, or otherwise, an empty <code>Stream&lt;T&gt;</code>.
This makes it the most concise way to combine the power of Optionals and Streams by using the Stream’s <code>flatMap</code> operation instead of a dedicated <code>filter</code> and <code>map</code> operation, as seen in <a data-type="xref" href="#_02-optionals_streams-with-optionals-flatmap">Example 9-10</a>.</p>
<div data-type="example" id="_02-optionals_streams-with-optionals-flatmap">
<h5><span class="label">Example 9-10. </span>Optionals as Stream elements with flatMap</h5>
<pre data-code-language="java" data-type="programlisting"><code class="n">List</code><code class="o">&lt;</code><code class="n">Permissions</code><code class="o">&gt;</code> <code class="n">permissions</code> <code class="o">=</code> <code class="p">...;</code>

<code class="n">List</code><code class="o">&lt;</code><code class="n">User</code><code class="o">&gt;</code> <code class="n">activeUsers</code> <code class="o">=</code>
  <code class="n">permissions</code><code class="p">.</code><code class="na">stream</code><code class="p">()</code>
             <code class="p">.</code><code class="na">filter</code><code class="p">(</code><code class="n">Predicate</code><code class="p">.</code><code class="na">not</code><code class="p">(</code><code class="n">Permissions</code><code class="p">::</code><code class="n">isEmpty</code><code class="p">))</code>
             <code class="p">.</code><code class="na">map</code><code class="p">(</code><code class="n">Permissions</code><code class="p">::</code><code class="n">group</code><code class="p">)</code>
             <code class="p">.</code><code class="na">map</code><code class="p">(</code><code class="n">Group</code><code class="p">::</code><code class="n">admin</code><code class="p">)</code>
             <code class="p">.</code><code class="na">flatMap</code><code class="p">(</code><code class="n">Optional</code><code class="p">::</code><code class="n">stream</code><code class="p">)</code>
             <code class="p">.</code><code class="na">filter</code><code class="p">(</code><code class="n">User</code><code class="p">::</code><code class="n">isActive</code><code class="p">)</code>
             <code class="p">.</code><code class="na">toList</code><code class="p">();</code></pre></div>
<p>A singular <code>flatMap</code> call replaces the previous <code>filter</code> and <code>map</code> operations.
Even if you only save a single method call — one <code>flatMap</code> instead of <code>filter</code> plus <code>map</code> operation --⁠, the resulting code is easier to reason with and better illustrates the desired workflow.
The <code>flatMap</code> operation conveys all the necessary information for understanding the Stream pipeline without adding any complexity by requiring additional steps.
Handling Optionals is a necessity, and it should be done as concisely as possible so that the overall Stream pipeline is as understandable and straightforward.</p>
<p>There’s no reason to design your APIs without Optionals just to avoid <code>flatMap</code> operations in Streams.
If <code>Group::getAdmin</code> would return <code>null</code>, you would still have to add a <code>null-check</code> in another <code>filter</code> operation anyways.
Replacing a <code>flatMap</code> operation with a <code>filter</code> operation gains you nothing, except the <code>admin</code> call now requires explicit <code>null</code>-handling afterwards, even if it’s no longer obvious from its signature.</p>
</div></section>
<section data-pdf-bookmark="Terminal Stream Operations" data-type="sect2"><div class="sect2" id="idm45115227944736">
<h2>Terminal Stream Operations</h2>
<p>Using Optionals in Streams isn’t restricted to intermediate operations.
Five of the Stream API’s terminal operations return an <code>Optional&lt;T&gt;</code> to provide an improved representation of their return value.
All of them try to either find an element or reduce the Stream.
In the case of an empty Stream, these operations need a sensible representation of an absentee value.
Optionals exemplify this concept, so it was the logical choice to use them instead of returning <code>null</code>.</p>
<section data-pdf-bookmark="Finding an Element" data-type="sect3"><div class="sect3" id="idm45115227742768">
<h3>Finding an Element</h3>
<p>In the Stream API, the prefix "<code>find</code>" represents, as you might have guessed by its name, “finding” an element based on its existence.
There are two "<code>find</code>" operations available with distinct semantics depending on the Stream being parallel or serial:</p>
<dl>
<dt><code>Optional&lt;T&gt; findFirst()</code></dt>
<dd>
<p>Returns an Optional of the first element of a Stream or an empty Optional if the Stream is empty.
There’s no difference between parallel and serial Streams.
Any element might be returned if the Stream lacks an encounter order.</p>
</dd>
<dt><code>Optional&lt;T&gt; findAny()</code></dt>
<dd>
<p>Returns an Optional of any element of a Stream or an empty Optional if the Stream is empty.
The returned element is non-deterministic to maximize performance in parallel streams.
The first element is returned in most cases, but there’s no guarantee for this behavior!
So use <code>findFirst</code> instead for a consistent return element.</p>
</dd>
</dl>
<p>The "<code>find</code>" operations work solely on the concept of existence, so you need to filter the Stream elements accordingly beforehand.
If you only want to know if a particular element exists and don’t need the element itself, you can use one of the corresponding "<code>match</code>" methods:</p>
<ul>
<li>
<p><code>boolean anyMatch(Predicate&lt;? super T&gt; predicate)</code></p>
</li>
<li>
<p><code>boolean noneMatch(Predicate&lt;? super T&gt; predicate)</code></p>
</li>
</ul>
<p>These terminal operations include the filtering operation and avoid creating an unnecessary <code>Optional&lt;T&gt;</code> instance.</p>
</div></section>
<section data-pdf-bookmark="Reducing to a Single Value" data-type="sect3"><div class="sect3" id="idm45115227647936">
<h3>Reducing to a Single Value</h3>
<p>Reducing a Stream by combining or accumulating its elements into a new data structure is one of a Stream’s primary purposes.
And just like the <code>find</code> operations, reducing operators have to deal with empty Streams.</p>
<p>That’s why there are three terminal <code>reduce</code> operations available for Streams, with one returning an Optional: <code>Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator)</code></p>
<p>It reduces the elements of the Stream using the provided <code>accumulator</code> operator.
The returned value is the result of the reduction, or an empty Optional if the Stream is empty.</p>
<p>See <a data-type="xref" href="#_02-optionals_streams-reduce">Example 9-11</a> for an equivalent pseudo-code example from the official documentation<sup><a data-type="noteref" href="ch09.xhtml#idm45115227642032" id="idm45115227642032-marker">9</a></sup>.</p>
<div data-type="example" id="_02-optionals_streams-reduce">
<h5><span class="label">Example 9-11. </span>Pseudo-code equivalent to the <code>reduce</code> operation</h5>
<pre data-code-language="java" data-type="programlisting"><code class="n">Optional</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="nf">pseudoReduce</code><code class="p">(</code><code class="n">BinaryOperator</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code> <code class="n">accumulator</code><code class="p">)</code> <code class="p">{</code>
  <code class="kt">boolean</code> <code class="n">foundAny</code> <code class="o">=</code> <code class="kc">false</code><code class="p">;</code>
  <code class="n">T</code> <code class="n">result</code> <code class="o">=</code> <code class="kc">null</code><code class="p">;</code>

  <code class="k">for</code> <code class="p">(</code><code class="n">T</code> <code class="n">element</code> <code class="p">:</code> <code class="n">elements</code><code class="o">]</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="n">foundAny</code><code class="p">)</code> <code class="p">{</code>
      <code class="n">foundAny</code> <code class="o">=</code> <code class="kc">true</code><code class="p">;</code>
      <code class="n">result</code> <code class="o">=</code> <code class="n">element</code><code class="p">;</code>
    <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
      <code class="n">result</code> <code class="o">=</code> <code class="n">accumulator</code><code class="p">.</code><code class="na">apply</code><code class="p">(</code><code class="n">result</code><code class="p">,</code> <code class="n">element</code><code class="p">);</code>
    <code class="p">}</code>
  <code class="p">}</code>

  <code class="k">return</code> <code class="n">foundAny</code> <code class="o">?</code> <code class="n">Optional</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="n">result</code><code class="p">)</code>
                  <code class="p">:</code> <code class="n">Optional</code><code class="p">.</code><code class="na">empty</code><code class="p">();</code>
<code class="p">}</code></pre></div>
<p>The two other <code>reduce</code> methods require an initial value to combine the stream elements with, so a concrete value can be returned instead of an Optional.
See <a data-type="xref" href="ch06.xhtml#_02-data-processing_reduce">“Reducing Elements”</a> for a more detailed explanation and examples of how to use them in Streams.</p>
<p>Besides the generic <code>reduce</code> methods, there are also two common use cases of reduction available as methods:</p>
<ul>
<li>
<p><code>Optional&lt;T&gt; min​(Comparator&lt;? super T&gt; comparator)</code></p>
</li>
<li>
<p><code>Optional&lt;T&gt; max(Comparator&lt;? super T&gt; comparator)</code></p>
</li>
</ul>
<p>These methods return the “minimal” or “maximal” element based on the provided comparator or an empty Optional if the Stream is empty.</p>
<p>An <code>Optional&lt;T&gt;</code> is the only suitable type to be returned by <code>min</code>/<code>max</code>.
You have to check anyway if there’s a result of the operation.
Adding additional <code>min</code>/<code>max</code> methods with a fallback value as an argument would clutter up the Stream interface.
Thanks to the returned <code>Optional</code>, you can easily check if a result exists or resort to a fallback value or exception instead.</p>
</div></section>
</div></section>
</div></section>
<section data-pdf-bookmark="Optional Primitives" data-type="sect1"><div class="sect1" id="idm45115227513248">
<h1>Optional Primitives</h1>
<p>You might ask yourself why you might even need an Optional of a primitive because a primitive variable can never be <code>null</code>.
If not initialized, any primitive has a value equivalent to zero for their respective type.</p>
<p>Even though that’s technically correct, Optionals aren’t simply about preventing values from being <code>null</code>.
They also represent an actual state of “nothingness" — an absence of a value — that primitives lack.</p>
<p>In many cases, the default values of primitive types are adequate, like representing a networking port: zero is an invalid port number, so you have to deal with it anyway.
if zero is a valid value, though, expressing its actual absence becomes more difficult.</p>
<p>Using primitives directly with the <code>Optional&lt;T&gt;</code> type is a no-go because primitives can’t be generic types.
However, just like with Streams, there are two ways to deal with optional primitives values: autoboxing or specialized types.</p>
<p><a data-type="xref" href="ch03.xhtml#_01-functional_primitives">“Primitive Types”</a> highlighted the problems of using object-wrapper classes and the overhead they introduce.
On the other hand, autoboxing isn’t free either.</p>
<p>The usual primitive types are available as dedicated Optional variants:</p>
<ul>
<li>
<p><code>java.util.OptionalInt</code></p>
</li>
<li>
<p><code>java.util.OptionalLong</code></p>
</li>
<li>
<p><code>java.util.OptionalDouble</code></p>
</li>
</ul>
<p>Their semantics are almost identical to their generic counterpart, but they do <em>not</em> inherit from <code>Optional&lt;T&gt;</code> or share a common interface.
The features aren’t identical either, as multiple operations, like <code>filter</code>, <code>map</code>, or <code>flatMap</code>, are missing.</p>
<p>The primitive Optional types may remove unnecessary autoboxing, which can improve performance but lack the full functionality that <code>Optional&lt;T&gt;</code> offers.
Also, unlike the primitive Stream variants I discussed in <a data-type="xref" href="ch07.xhtml#_02-streams-primitives-streams">“Primitive Streams”</a>, there’s no way to easily convert between a primitive Optional variant and its corresponding <code>Optional&lt;T&gt;</code> equivalent.</p>
<p>Even though it would be easy to create your own wrapper type to improve the handling of Optional values, especially for primitives, I wouldn’t recommend doing it under most circumstances.
For internal or <code>private</code> implementations, you can use any wrapper you want or need.
But the <code>public</code> seams of your code should always strive to stick to the most anticipated and available types.
Usually, that means what’s already included in the JDK.</p>
</div></section>
<section data-pdf-bookmark="Caveats" data-type="sect1"><div class="sect1" id="idm45115227512592">
<h1>Caveats</h1>
<p>Optionals can enormously improve <code>null</code> handling for the JDK by providing a versatile “box” to hold possible <code>null</code> values and a (partially) functional API to build pipelines dealing with the presence or absence of that value.
Although the upsides are certainly useful, it also comes with some noteworthy downsides you need to be aware of to use them correctly and without any unexpected surprises.</p>
<section data-pdf-bookmark="Optionals are ordinary types" data-type="sect2"><div class="sect2" id="idm45115227436496">
<h2>Optionals are ordinary types</h2>
<p>The most obvious downside of <code>Optional&lt;T&gt;</code> and its primitive variants is that they’re ordinary types.
Without deeper integration into Java’s syntax, such as the new syntax for lambda expressions, they suffer from the same <code>null</code> reference problems as any other type in the JDK.</p>
<p>That’s why you must still adhere to best practices and informal rules to not counter-act the benefits of using Optionals in the first place.
If you design an API and decide to use Optionals as a return type, you <em>must not</em> return <code>null</code> for it under any circumstances!
Returning an Optional is a clear signal that anyone using the API will receive at least a “box” that <em>might</em> contain a value instead of a possible <code>null</code> value.
If no value is possible, always use an empty Optional or the primitive equivalent instead.</p>
<p>This essential design requirement has to be enforced by convention, though.
The compiler won’t help you there without additional tools, like <a href="https://www.sonarsource.com/">SonarSource</a><sup><a data-type="noteref" href="ch09.xhtml#idm45115227431008" id="idm45115227431008-marker">10</a></sup>.</p>
</div></section>
<section data-pdf-bookmark="Identity-sensitive Methods" data-type="sect2"><div class="sect2" id="idm45115227428048">
<h2>Identity-sensitive Methods</h2>
<p>Even though Optionals <em>are</em> ordinary types, the identity-sensitive methods might work differently from what you expect.
This includes the reference equality operator <code>==</code> (double-equals), using the <code>hashCode</code> method, or using an instance for thread synchronization.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Object identity tells you whether two different objects share the same memory address and are, therefore, the same object.
This is tested by the reference equality operator <code>==</code> (double-equals).
Equality of two objects, which is tested with their <code>equals</code> method,  means they contain the same state.</p>
<p>Two identical objects are also equal, but the reverse isn’t necessarily true.
Just because two objects contain the same state doesn’t automatically mean they also share the same memory address.</p>
</div>
<p>The difference in behavior lies in Optional’s nature of being <em>value-based</em> type, meaning its inner value is its primary concern.
Methods like <code>equals</code>, <code>hashCode</code>, and <code>toString</code> are solely based on the inner value and ignore the actual object identity.
That’s why you should treat Optional instances as interchangeable and unsuited for identity-related operations like synchronizing concurrent code, as stated in the official documentation<sup><a data-type="noteref" href="ch09.xhtml#idm45115227420480" id="idm45115227420480-marker">11</a></sup>.</p>
</div></section>
<section data-pdf-bookmark="Performance-Overhead" data-type="sect2"><div class="sect2" id="idm45115227418976">
<h2>Performance-Overhead</h2>
<p>Another point to consider when using Optionals is the performance implications, especially outside their primary design goal as return types.</p>
<p>Optionals are easy to (mis-)use for simple <code>null</code>-checks and provide a fallback value if no inner value is present:</p>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// DON'T DO THIS</code>

<code class="n">String</code> <code class="n">value</code> <code class="o">=</code> <code class="n">Optional</code><code class="p">.</code><code class="na">ofNullable</code><code class="p">(</code><code class="n">maybeNull</code><code class="p">)</code>
                       <code class="p">.</code><code class="na">orElse</code><code class="p">(</code><code class="n">fallbackValue</code><code class="p">);</code>


<code class="c1">// DON'T DO THIS</code>

<code class="k">if</code> <code class="p">(</code><code class="n">Optional</code><code class="p">.</code><code class="na">ofNullable</code><code class="p">(</code><code class="n">maybeNull</code><code class="p">).</code><code class="na">isPresent</code><code class="p">())</code> <code class="p">{</code>
  <code class="c1">// ...</code>
<code class="p">}</code></pre>
<p>Such simple Optional pipelines require a new <code>Optional</code> instance, and every method call creates a new stack frame that the JVM can’t optimize your code as easily as a simple <code>null</code>-check.
Creating an Optional doesn’t make much sense without additional operations besides checking for existence or providing a fallback.</p>
<p>Using alternatives like the ternary operator or a direct <code>null</code>-check should be your preferred solution:</p>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// DO THIS INSTEAD</code>

<code class="n">String</code> <code class="n">value</code> <code class="o">=</code> <code class="n">maybeNull</code> <code class="o">!=</code> <code class="kc">null</code> <code class="o">?</code> <code class="n">maybeNull</code>
                                 <code class="p">:</code> <code class="n">fallbackValue</code><code class="p">;</code>


<code class="c1">// DO THIS INSTEAD</code>

<code class="k">if</code> <code class="p">(</code><code class="n">maybeNull</code> <code class="o">!=</code> <code class="kc">null</code><code class="p">)</code> <code class="p">{</code>
  <code class="c1">// ...</code>
<code class="p">}</code></pre>
<p>Using an Optional instead of a ternary operator might look nicer and saves you from repeating <code>maybeNull</code>.
Reducing the number of instance creations and method invocations is usually preferable.</p>
<p>If you still want a more visually pleasing alternative to the ternary operator, Java 9 introduced two <code>static</code> helper methods on <code>java.util.Objects</code> wrapping the task of checking for <code>null</code> and providing an alternative value:</p>
<ul>
<li>
<p><code>T requireNonNullElse(T obj, T defaultObj)</code></p>
</li>
<li>
<p><code>T requireNonNullElseGet(T obj, Supplier&lt;? extends T&gt; supplier)</code></p>
</li>
</ul>
<p>The fallback value, or in the case of the second method, the result of the <code>Supplier</code>, must be non-<code>null</code>, too.</p>
<p>Saving a few CPU cycles means nothing compared to a crash due to an unexpected <code>NullPointerException</code>.
Just like with Streams, there’s a trade-off to be made between performance and safer and more straightforward code.
You need to find the balance between those based on your requirements.</p>
</div></section>
<section data-pdf-bookmark="Special Considerations for Collections" data-type="sect2"><div class="sect2" id="idm45115227418384">
<h2>Special Considerations for Collections</h2>
<p><code>null</code> is the technical representation of the absence of a value.
Optionals give you a tool to represent this absence safely with an actual object that allows further transformation, filtering, and more.
Collection-based types, though, can already represent an absence of their inner values.</p>
<p>A collection type is already a “box” that handles values, so wrapping it in an <code>Optional&lt;T&gt;</code> creates yet another layer you must deal with.
An empty collection already indicates the absence of inner values, so using an empty collection as the alternative to <code>null</code> eliminates a possible <code>NullPointerException</code> <em>and</em> the need for an additional layer by using an Optional.</p>
<p>Of course, you still have to deal with the absence of the collection itself, meaning a <code>null</code> reference.
If possible, you shouldn’t use <code>null</code> for collections at all, neither as arguments nor return values.
Designing your code to always use an empty collection instead of <code>null</code> will have the same effect as an Optional.
If you still need to discern between <code>null</code> and an empty collection, or the related code isn’t under your control or can’t be changed, a <code>null</code>-check might still be preferable to introducing another layer to deal with.</p>
</div></section>
<section data-pdf-bookmark="Optionals and Serialization" data-type="sect2"><div class="sect2" id="idm45115227259600">
<h2>Optionals and Serialization</h2>
<p>The <code>Optional&lt;T&gt;</code> type and the primitive variants don’t implement <code>java.io.Serializable</code>, making them unsuited for private fields in serializable types.
This decision was made deliberately by its design group because Optionals are supposed to provide the possibility of an optional return value, not be a general-purpose solution for nullability.
Making <code>Optional&lt;T&gt;</code> serializable would encourage use cases far beyond its intended design goal.</p>
<p>To still reap the benefits of Optionals in your object and maintain serializability, you can use them for your <code>public</code> API but use non-Optional fields as an implementation detail, as shown in <a data-type="xref" href="#_02-optionals_serialization">Example 9-12</a></p>
<div data-type="example" id="_02-optionals_serialization">
<h5><span class="label">Example 9-12. </span>Using Optionals in Serializable types</h5>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">User</code> <code class="kd">implements</code> <code class="n">Serializable</code> <code class="p">{</code>

  <code class="kd">private</code> <code class="n">UUID</code> <code class="n">id</code><code class="p">;</code>
  <code class="kd">private</code> <code class="n">String</code> <code class="n">username</code><code class="p">;</code>
  <code class="kd">private</code> <code class="n">LocalDateTime</code> <code class="n">lastLogin</code><code class="p">;</code>

  <code class="c1">// ... usual getter/setter for id and username</code>

  <code class="kd">public</code> <code class="n">Optional</code><code class="o">&lt;</code><code class="n">LocalDateTime</code><code class="o">&gt;</code> <code class="nf">getLastLogin</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="n">Optional</code><code class="p">.</code><code class="na">ofNullable</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="na">lastLogin</code><code class="p">);</code>
  <code class="p">}</code>

  <code class="kd">public</code> <code class="kt">void</code> <code class="nf">setLastLogin</code><code class="p">(</code><code class="n">LocalDateTime</code> <code class="n">lastLogin</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="na">lastLogin</code> <code class="o">=</code> <code class="n">lastLogin</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code></pre></div>
<p>By relying only on an Optional in the getter for <code>lastLogin</code>, the type remains serializable but still provides an Optional API.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Final Thoughts on null References" data-type="sect1"><div class="sect1" id="idm45115227232896">
<h1>Final Thoughts on null References</h1>
<p>Although it’s called a <em>billion-dollar mistake</em>, <code>null</code> isn’t inherently evil.
Sir Charles Antony Richard Hoare, the inventor of <code>null</code>, believes that programming language designers should be responsible for errors in programs written in their language<sup><a data-type="noteref" href="ch09.xhtml#idm45115227195568" id="idm45115227195568-marker">12</a></sup>.</p>
<p>A language should provide a solid foundation with a good deal of ingenuity and control.
Allowing <code>null</code> references is one of many design choices for Java, nothing more.
Java’s <em>catch or specify requirement</em>, as explained in <a data-type="xref" href="ch10.xhtml#_02-exception-handling">Chapter 10</a>, and <code>try</code>-<code>catch</code>-blocks provide you with tools against apparent errors.
But with <code>null</code> being a valid value for any type, every reference is a possible crash waiting to happen.
Even if you think something can <em>never</em> be <code>null</code>, experience tells us that it may be possible at some point in time.</p>
<p>The existence of <code>null</code> references doesn’t qualify a language as poorly designed.
<code>null</code> has its place, but it requires you to be more attentive to your code.
This doesn’t mean you should replace every single variable and argument in your code with Optionals, either.</p>
<p>Optionals were intended to provide a limited mechanism for optional return values, so don’t over- or misuse them just because it seems convenient.
In code under your control, you can make more assumptions and guarantees about the possible nullability of references and deal with it accordingly, even without Optionals.
If you follow the other principles highlighted in this book — like small, self-contained, pure functions without side effects — it’s way easier to make sure your code won’t return a <code>null</code> reference unexpectedly.</p>
</div></section>
<section data-pdf-bookmark="Takeaways" data-type="sect1"><div class="sect1" id="idm45115227232528">
<h1>Takeaways</h1>
<ul>
<li>
<p>There’s no language-level or special syntax available for <code>null</code>-handling in Java.</p>
</li>
<li>
<p><code>null</code> is a special case that can represent both the states of “doesn’t exist” and “undefined” without you being able to distinguish them.</p>
</li>
<li>
<p>The <code>Optional&lt;T&gt;</code> type allows for dedicated <code>null</code>-handling these states with operation chains and fallbacks.</p>
</li>
<li>
<p>Specialized types for primitives are also available, although they don’t provide feature parity.</p>
</li>
<li>
<p>Other approaches for <code>null</code>-handling exist, like annotations or best practices.</p>
</li>
<li>
<p>Not everything is a good fit for Optionals.
If a data structure already has a concept of emptiness, like collections, adding another layer is contra-productive.
You shouldn’t wrap it into an Optional unless you are required to represent an “undefined” state, too.</p>
</li>
<li>
<p>Optionals and Streams are interoperable without much friction.</p>
</li>
<li>
<p>Optionals aren’t serializable, so don’t use them as private fields if you need to serialize your type.
Instead, use Optionals as return values for getters.</p>
</li>
<li>
<p>Alternative implementations exist, like in the <a href="https://github.com/google/guava">Google Guava framework</a>, even though Google itself recommends using Java’s Optional instead.</p>
</li>
<li>
<p><code>null</code> isn’t evil per se.
Don’t replace every variable with Optionals without a good reason.</p>
</li>
</ul>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="idm45115229846656"><sup><a href="ch09.xhtml#idm45115229846656-marker">1</a></sup> Varargs don’t accept <code>null</code> as a sole argument because it’s an inexact argument type, because it might represent <code>Object</code> or <code>Object[]</code>. To pass a single <code>null</code> to a vararg you need to wrap it in an array: <code>new Object[]{ null }</code>.</p><p data-type="footnote" id="idm45115229645008"><sup><a href="ch09.xhtml#idm45115229645008-marker">2</a></sup> Many programming languages have a dedicated operator to safely call fields or methods on possible <code>null</code> references. The <a href="https://en.wikipedia.org/wiki/Safe_navigation_operator">Wikipedia article on the safe-navigation operator</a> has an in-depth explanation and examples in many languages.</p><p data-type="footnote" id="idm45115229642560"><sup><a href="ch09.xhtml#idm45115229642560-marker">3</a></sup> The <code>null</code> coalescing operator is like a shortened ternary operator. The expression <code>x != null ? x : y</code> is shortened to <code>x ?: y</code>, with <code>?:</code> (question-mark colon) being the operator. Not all languages use the same operator, though. The <a href="https://en.wikipedia.org/wiki/Null_coalescing_operator">Wikipedia article</a> gives an overview of different programming languages supporting which operator form.</p><p data-type="footnote" id="idm45115229323040"><sup><a href="ch09.xhtml#idm45115229323040-marker">4</a></sup> Java’s JIT (just-in-time) compiler performs a myriad of optimizations to improve the executed code. If necessary, it recompiles code when more information about how it’s executed becomes available. An overview of possible optimization is available on the <a href="https://wiki.openjdk.org/display/HotSpot/PerformanceTechniques">Open JDK Wiki</a>.</p><p data-type="footnote" id="idm45115229213376"><sup><a href="ch09.xhtml#idm45115229213376-marker">5</a></sup> The most common libraries to provide the marker annotation are <a href="http://findbugs.sourceforge.net/">FindBugz</a> (up to Java 8), and its spiritual successor <a href="https://spotbugs.github.io/">SpotBugz</a>. JetBrains, the creator of the IntelliJ IDE and the JVM language <em>Kotlin</em>, also <a href="https://github.com/JetBrains/java-annotations">provide a package containing the annotations</a>.</p><p data-type="footnote" id="idm45115229208080"><sup><a href="ch09.xhtml#idm45115229208080-marker">6</a></sup> The <a href="https://checkerframework.org">Checker Framework</a> has <a href="https://checkerframework.org/manual/#findbugs-nullable">an example</a> of such “non-standard” behavior between different tools.</p><p data-type="footnote" id="idm45115229199920"><sup><a href="ch09.xhtml#idm45115229199920-marker">7</a></sup> The <a href="https://guava.dev/releases/snapshot-jre/api/docs/com/google/common/base/Optional.xhtml">documentation of Guava’s <code>Optional&lt;T&gt;</code></a> explicitly mentions that the JDK variant should be preferred.</p><p data-type="footnote" id="idm45115228055056"><sup><a href="ch09.xhtml#idm45115228055056-marker">8</a></sup> McCabe, TJ. 1976. “A Complexity Measure” <a href="https://doi.org/10.1109/TSE.1976.233837">IEEE Transactions on Software Engineering, December 1976, Vol. SE-2 No. 4, 308–320</a>.</p><p data-type="footnote" id="idm45115227642032"><sup><a href="ch09.xhtml#idm45115227642032-marker">9</a></sup> <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/stream/Stream.xhtml#reduce(java.util.function.BinaryOperator)">Documentation for <code>Optional&lt;T&gt; reduce​(BinaryOperator&lt;T&gt; accumulator)</code></a>.</p><p data-type="footnote" id="idm45115227431008"><sup><a href="ch09.xhtml#idm45115227431008-marker">10</a></sup> The <a href="https://www.sonarsource.com/">SonarSource</a> rule <a href="https://rules.sonarsource.com/java/RSPEC-2789">RSPEC-2789</a> checks for Optionals being <code>null</code>.</p><p data-type="footnote" id="idm45115227420480"><sup><a href="ch09.xhtml#idm45115227420480-marker">11</a></sup> The <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Optional.xhtml">official doumentation</a> explicitly mentions unpredictable identity method behavior as an “API Note.”</p><p data-type="footnote" id="idm45115227195568"><sup><a href="ch09.xhtml#idm45115227195568-marker">12</a></sup> Sir Charles Antony Richard Hoare expressed this view in his talk <a href="https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/">“Null References: The Billion Dollar Mistake”</a> at <a href="https://qconlondon.com/london-2009/qconlondon.com/london-2009/presentation/Null%2bReferences_%2bThe%2bBillion%2bDollar%2bMistake.xhtml">QCon London</a> in 2009.</p></div></div></section></div></body></html>