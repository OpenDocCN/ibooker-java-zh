<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 9. Mobile Workflows"><div class="chapter" id="mobile_workflows">
<h1><span class="label">Chapter 9. </span>Mobile Workflows</h1>


<p class="byline">Stephen Chin</p>
  <blockquote data-type="epigraph" epub:type="epigraph">
    <p>Program testing can be a very effective way to show the presence of bugs, but is hopelessly inadequate for showing their absence.</p>
    <p data-type="attribution">Edsger Dijkstra</p>
  </blockquote>

<p>Coverage of DevOps wouldn’t be complete<a data-type="indexterm" data-primary="mobile workflows" data-secondary="about" id="ch09-mobwrk"/><a data-type="indexterm" data-primary="smartphone workflows" data-secondary="about" id="ch09-mobwrk2"/><a data-type="indexterm" data-primary="workflows" data-secondary="mobile workflows" data-tertiary="about" id="ch09-mobwrk3"/> without talking about mobile development and smartphones, which is the fastest growing segment of computer ownership.
The past decade has seen a meteoric rise in smartphone usage, with billions of smartphones owned globally, as shown in <a data-type="xref" href="#smartphone_users">Figure 9-1</a>.</p>

<p>Smartphone ownership is expected to continue to rise since many large countries such as India and China have less than 70% ownership.
With over 3.6 billion smartphones in the world today and an expected 4.3 billion smartphones by the year 2023, this is a market and user base that can’t be ignored.</p>

<p>Smartphones also have another property<a data-type="indexterm" data-primary="smartphone workflows" data-secondary="about" data-tertiary="continuous updates" data-seealso="continuous deployment" id="idm45310200749952"/><a data-type="indexterm" data-primary="mobile workflows" data-secondary="about" data-tertiary="continuous updates" data-seealso="continuous deployment" id="idm45310200748432"/><a data-type="indexterm" data-primary="workflows" data-secondary="mobile workflows" data-tertiary="continuous updates" data-seealso="continuous deployment" id="idm45310200746944"/><a data-type="indexterm" data-primary="continuous deployment" data-secondary="user expectations" data-tertiary="consumers less technical" id="idm45310200745456"/><a data-type="indexterm" data-primary="updates" data-secondary="user expectations" data-tertiary="consumers less technical" id="idm45310200744224"/><a data-type="indexterm" data-primary="updates" data-secondary="need for continuous updates" id="idm45310200742992"/><a data-type="indexterm" data-primary="continuous deployment" data-secondary="need for continuous updates" id="idm45310200742032"/> that makes DevOps an essential practice: they fall into a class of internet-connected devices where continuous updates are expected by default, because they are targeted at consumers who are less technical and need to maintain their devices with minimal user involvement.
This has been propelled by the<a data-type="indexterm" data-primary="updates" data-secondary="user expectations" data-tertiary="app ecosystem" id="idm45310200740624"/><a data-type="indexterm" data-primary="continuous deployment" data-secondary="user expectations" data-tertiary="app ecosystem" id="idm45310200739408"/> app ecosystem built around smartphones, which makes downloading new software as well as receiving software updates easy and relatively low risk for end users.</p>

<figure><div id="smartphone_users" class="figure">
<img src="Images/dtjd_0901.png" alt="Chart showing growth of smartphone ownership from 2012 through 2023" width="600" height="393"/>
<h6><span class="label">Figure 9-1. </span>Number of smartphone users in the world from 2012 through 2023 according to <a href="https://oreil.ly/k8dk1">Statista</a> (prediction for 2023 marked with *)</h6>
</div></figure>

<p>You may want to update your app for several functional reasons:</p>
<dl>
<dt>Adding new features for users</dt>
<dd>
<p>Most apps are released quickly and with a minimum viable set of features to reduce time to market.
This allows for frequent small feature updates to add useful functionality for end users.</p>
</dd>
<dt>Fixing bugs and improving the stability of your application</dt>
<dd>
<p>More mature applications have lots of updates that fix small bugs, stability issues, and user experience improvements. These changes are typically minor and can be released frequently.</p>
</dd>
<dt>Patching security vulnerabilities or exploits</dt>
<dd>
<p>Mobile applications typically have a large attack surface that includes the locally installed app, the backend that supplies data, and user authentication workflows for app and cloud service logins.</p>
</dd>
</dl>

<p>In addition, a lot of app updates are driven by the need to increase market share and improve engagement with users.
Some examples of updates that help to grow market share of your app include the following:</p>
<dl>
<dt>Aligning with major platform releases</dt>
<dd>
<p>Whenever a major platform release occurs, apps that are certified against the new version and updated to take advantage of new functionality will see an increase in downloads.</p>
</dd>
<dt>Raising visibility of your app in the store</dt>
<dd>
<p>App stores reward apps that frequently update by retaining user ratings between releases and highlighting new releases.
The release notes also give you a chance to increase searchable content in the store.
In contrast, if your app stagnates with no updates, it will naturally drop in search engine optimization.</p>
</dd>
<dt>Reminding current users about your application to increase utilization</dt>
<dd>
<p>Mobile platforms prompt users about updates to their existing apps and sometimes display badges or other reminders that will increase engagement.</p>
</dd>
</dl>

<p>The top applications in the app stores know the importance of continuous updates and update frequently.
According to <a href="https://oreil.ly/CdW2A">Appbot</a>, of the 200 top free apps, the median time since the last update was 7.8 days!
With this pace of updates, if you do not use a continuous release process, you won’t be able to keep up.</p>

<p>Java developers have great options for building mobile applications.
These include mobile-focused web development with responsive web apps that adapt to constrained devices.
Other options include dedicated mobile applications written in Java for Android devices.
Finally, several cross-platform options for building applications work across Android and iOS devices, including Gluon Mobile and Electron.</p>

<p>This chapter focuses primarily on Android application development. However, all the same mobile DevOps techniques and considerations apply across these Java-based mobile platforms.<a data-type="indexterm" data-startref="ch09-mobwrk" id="idm45310200457280"/><a data-type="indexterm" data-startref="ch09-mobwrk2" id="idm45310200456576"/><a data-type="indexterm" data-startref="ch09-mobwrk3" id="idm45310200455904"/></p>






<section data-type="sect1" data-pdf-bookmark="Fast-Paced DevOps Workflows for Mobile"><div class="sect1" id="idm45310200455104">
<h1>Fast-Paced DevOps Workflows for Mobile</h1>

<p>Here are some of the business benefits<a data-type="indexterm" data-primary="mobile workflows" data-secondary="benefits to business" id="idm45310200453664"/><a data-type="indexterm" data-primary="smartphone workflows" data-secondary="benefits to business" id="idm45310200452688"/><a data-type="indexterm" data-primary="workflows" data-secondary="mobile workflows" data-tertiary="benefits to business" id="idm45310200451744"/> you will realize from investing in mobile DevOps:</p>
<dl>
<dt>Better customer experience</dt>
<dd>
<p>With the easy and accessible rating systems available in the app store, customer experience is king.
By being able to respond quickly to customer issues and test on a large variety of devices, you will ensure an optimal customer experience.</p>
</dd>
<dt>Faster innovation</dt>
<dd>
<p>By continuously releasing to production, you will be able to get new features and capabilities to your customers at a higher velocity than your competitors.</p>
</dd>
<dt>Higher software quality</dt>
<dd>
<p>With the large number and high fragmentation of Android devices, thoroughly testing your application manually is impossible.
But with an automated mobile testing strategy that hits the key device characteristics of your user base, you will reduce the number of issues reported by end users.</p>
</dd>
<dt>Reduced risk</dt>
<dd>
<p>The majority of executable code in modern applications has open source dependencies that expose you to known security vulnerabilities.
By having a mobile DevOps pipeline that allows you to test new versions of dependencies and update frequently, you will be able to quickly fix any known vulnerabilities in your application before they can be taken advantage of.</p>
</dd>
</dl>

<p>The same principles and best practices outlined in the rest of this book apply to mobile application development, but are amplified 10 times by the size and expectations of this market.
When planning out a mobile<a data-type="indexterm" data-primary="mobile workflows" data-secondary="DevOps stages" id="idm45310200443280"/><a data-type="indexterm" data-primary="smartphone workflows" data-secondary="DevOps stages" id="idm45310200442304"/><a data-type="indexterm" data-primary="workflows" data-secondary="mobile workflows" data-tertiary="DevOps stages" id="idm45310200441360"/><a data-type="indexterm" data-primary="build stage of mobile workflow" id="idm45310200440144"/> DevOps pipeline for Android devices, here are the stages you need to consider:</p>
<ol>
<li>
<p>Build.</p>

<p>Android build scripts are usually written in Gradle.<a data-type="indexterm" data-primary="Gradle" data-secondary="Android mobile build scripts" id="idm45310200437792"/><a data-type="indexterm" data-primary="continuous integration (CI)" data-secondary="build script" data-tertiary="Android mobile" id="idm45310200436800"/>
As a result, you can use any continuous integration server of your choice, including Jenkins, CircleCI, Travis CI, or JFrog Pipelines.</p>
</li>
<li>
<p>Test.</p>
<dl>
<dt>Unit tests</dt>
<dd>
<p>Android unit tests<a data-type="indexterm" data-primary="testing" data-secondary="Android mobile build scripts" id="idm45310200432704"/><a data-type="indexterm" data-primary="unit tests" data-see="testing" id="idm45310200431728"/><a data-type="indexterm" data-primary="JUnit" id="idm45310200430784"/><a data-type="indexterm" data-primary="testing" data-secondary="automated tests" data-tertiary="Android mobile unit tests" id="idm45310200430112"/> are typically written in JUnit, which can easily be automated.
Higher-level Android unit tests are often written in some sort of UI test framework like Espresso, Appium, Calabash, or Robotium.</p>
</dd>
<dt>Integration tests</dt>
<dd>
<p>Besides testing your own application, it is important to test interactions between applications with tools like UI Automator that are focused on integration testing and can test across multiple Android applications.</p>
</dd>
<dt>Functional tests</dt>
<dd>
<p>Overall application verification is important.
You can do this manually, but automated tools can simulate user input like the previously mentioned UI automation tools.
Another option is to run robotic crawler tools like Google’s App Crawler in order to inspect your application’s user interface and automatically issue user actions.</p>
</dd>
</dl>
</li>
<li>
<p>Package.</p>

<p>In the package step, you<a data-type="indexterm" data-primary="package management" data-secondary="Android mobile workflow" id="idm45310200424144"/><a data-type="indexterm" data-primary="mobile workflows" data-secondary="deployment" id="idm45310200423168"/><a data-type="indexterm" data-primary="smartphone workflows" data-secondary="deployment" id="idm45310200422224"/><a data-type="indexterm" data-primary="workflows" data-secondary="mobile workflows" data-tertiary="deployment" id="idm45310200421280"/> aggregate all of the scripts, configuration files, and binaries needed for deployment.
By using a package management tool like Artifactory, you retain all the build and test information and can easily track dependencies for traceability and debugging.</p>
</li>
<li>
<p>Release.</p>

<p>One of the best parts of mobile app<a data-type="indexterm" data-primary="deployment" data-secondary="Android mobile workflow" id="idm45310200418384"/><a data-type="indexterm" data-primary="release" data-see="deployment" id="idm45310200417408"/><a data-type="indexterm" data-primary="Google Play" id="idm45310200416464"/> development is that releasing mobile applications ends with the app store submission; the final deployment to devices is managed by the Google Play infrastructure.
The challenging parts are that you have to prepare your build to make sure the app store submission is successful, and you’ll be penalized for any mistakes in building, testing, and packaging by delays if you do not fully automate the submission process.</p>
</li>

</ol>

<p>As you can see, the biggest difference in DevOps for Android development comes with testing.
There is a lot of investment in UI test frameworks for Android apps, because automated testing is the only solution to the problem of testing across a highly fragmented device ecosystem.
We will find out exactly how severe the Android device fragmentation is in the next section and talk about ways to mitigate this later in the chapter.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Android Device Fragmentation"><div class="sect1" id="idm45310200414896">
<h1>Android Device Fragmentation</h1>

<p>The iOS ecosystem is tightly controlled by Apple,<a data-type="indexterm" data-primary="mobile workflows" data-secondary="Android device fragmentation" data-tertiary="about" id="idm45310200413360"/><a data-type="indexterm" data-primary="smartphone workflows" data-secondary="Android device fragmentation" data-tertiary="about" id="idm45310200412048"/><a data-type="indexterm" data-primary="workflows" data-secondary="mobile workflows" data-tertiary="Android device fragmentation" id="ch09-mobwork"/><a data-type="indexterm" data-primary="testing" data-secondary="Android device fragmentation" data-tertiary="about" id="idm45310200409312"/><a data-type="indexterm" data-primary="Android device fragmentation" data-secondary="about" id="idm45310200408080"/> which limits the number of hardware models available, the variations in screen size, and the set of hardware sensors and features on its phones.
Since 2007 when the first iPhone debuted, only 29 different devices have been produced, only 7 of which are currently sold.</p>

<p>In contrast, the Android ecosystem is open to a plethora of device manufacturers who customize everything from the screen size and resolution to the processor and hardware sensors, and even produce unique form factors like foldable screens.
There are over 24,000 different devices from 1,300 different manufacturers, which is 1,000 times more fragmentation than for iOS devices.
This makes testing for Android platforms much more difficult to execute.</p>

<p>When it comes to fragmentation, several key differences make it hard to uniformly test different Android devices:<a data-type="indexterm" data-primary="APIs" data-secondary="Android device fragmentation" id="idm45310200405312"/></p>
<dl>
<dt>Android version</dt>
<dd>
<p>Android device manufacturers do not always provide updates for older devices to the latest Android version, so users may be stuck on old Android OS versions until they buy a new device.
The drop-off in use of old Android versions is gradual, with active devices still running Android 4.<em>x</em> releases that are more than seven years old, including Jelly Bean and KitKat.</p>
</dd>
</dl>
<dl class="pagebreak-before">
<dt>Screen size and resolution</dt>
<dd>
<p>Android devices come in a wide array of form factors and hardware configurations, with a trend toward larger and more pixel-dense displays.
A well-designed application needs to scale in order to work well across a range of screen sizes and resolutions.</p>
</dd>
<dt>3D support</dt>
<dd>
<p>Particularly for games, it is critical to know what level of 3D support you will get on devices, in terms of APIs and performance.</p>
</dd>
<dt>Hardware features</dt>
<dd>
<p>Most Android devices come with basic hardware sensors (camera, accelerometer, GPS), but support varies for newer hardware APIs such as near-field communication (NFC), barometers, magnetometers, proximity and pressure sensors, thermometers, and so on.</p>
</dd>
</dl>








<section data-type="sect2" data-pdf-bookmark="Android OS Fragmentation"><div class="sect2" id="idm45310200396384">
<h2>Android OS Fragmentation</h2>

<p>Android version fragmentation affects device testing at two levels.<a data-type="indexterm" data-primary="mobile workflows" data-secondary="Android device fragmentation" data-tertiary="OS fragmentation" id="idm45310200394912"/><a data-type="indexterm" data-primary="smartphone workflows" data-secondary="Android device fragmentation" data-tertiary="OS fragmentation" id="idm45310200393520"/><a data-type="indexterm" data-primary="workflows" data-secondary="mobile workflows" data-tertiary="Android OS fragmentation" id="idm45310200392288"/><a data-type="indexterm" data-primary="testing" data-secondary="Android device fragmentation" data-tertiary="OS fragmentation" id="idm45310200391200"/><a data-type="indexterm" data-primary="OS" data-secondary="Android OS fragmentation" id="idm45310200390000"/><a data-type="indexterm" data-primary="APIs" data-secondary="Android device fragmentation" data-tertiary="OS fragmentation" id="idm45310200389040"/><a data-type="indexterm" data-primary="Android device fragmentation" data-secondary="OS fragmentation" id="idm45310200387808"/>
The first is the major Android version, which determines the number of Android API versions you need to build for and test against.
And the second is the OS customization done by original equipment manufacturers (OEMs) to support specific hardware configurations.</p>

<p>In the case of iOS, since Apple controls the hardware and the operating system, it is able to push out updates for all supported devices simultaneously.
This keeps the adoption level of minor updates for performance and security fixes high.
Apple also puts a lot of features and marketing into major releases to push the installed base to upgrade to the latest version quickly.
As a result, Apple was able to achieve <a href="https://oreil.ly/3GYL8">86% adoption</a> of iOS 14 only seven months after its initial release.</p>

<p>The Android market is significantly more complex since OEMs modify and test custom versions of Android OSs for their devices.
In addition, they are reliant on<a data-type="indexterm" data-primary="system-on-a-chip (SoC) manufacturers of mobile hardware" id="idm45310200384880"/> system-on-a-chip (SoC) manufacturers to provide code updates for different hardware components.
This means that devices created by major vendors are likely to receive only a couple of major OS version updates, and devices from smaller vendors may never see an OS upgrade even when they are under support.</p>

<p>To help you decide how far back you should support different Android OS versions, Google provides information in Android Studio <a data-type="indexterm" data-primary="Google Android Studio device adoption" id="idm45310200383104"/>on the device adoption by API level.
The distribution of users as of August 2021 is shown in <a data-type="xref" href="#android_version_usage">Figure 9-2</a>.
To achieve &gt; 86% adoption comparable to the latest iOS version, you need to support at least Android 5.1 Lollipop, a release that came out in 2014. Even then you are still missing out on over 5% of users who are still using Android 4–based devices.</p>

<figure><div id="android_version_usage" class="figure">
<img src="Images/dtjd_0902.png" alt="List of Android versions with information on usage and features" width="600" height="410"/>
<h6><span class="label">Figure 9-2. </span>Android Studio showing the distribution of users on different versions of the Android platform (Android 11 has &lt; 1% adoption)</h6>
</div></figure>

<p>To further complicate the situation, every OEM modifies<a data-type="indexterm" data-primary="Linux kernel in Android devices" id="idm45310200378528"/> the Android OS it ships for its devices, so it is not enough to simply test one device per major Android version.
This is a result of the way Android uses the Linux kernel to access hardware devices.</p>

<p>The Linux kernel is the heart of the operating system and provides the low-level device driver code to access cameras, accelerometers, the display, and other hardware on the device.
To the Linux kernel that Android is based on, Google adds in Android-specific features and patches, SoC vendors add in hardware-specific support, and OEMs further modify it for their specific devices.
Therefore, each device has a range of variation in performance, security, and potential bugs that could affect your application when a user runs it on a new device.</p>

<p>Google worked toward improving this situation with Android 8.0 Oreo, which includes a new hardware abstraction layer allowing device-specific code to run outside the kernel.
This allows OEMs to update to new Android kernel versions from Google without waiting for device driver updates from SoC vendors, which reduces the amount of redevelopment and testing required for OS upgrades.
However, other than Pixel devices that Google handles OS updates for, the majority of Android device upgrades are in the hands of OEMs, which are still slow to upgrade to new Android versions.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Building for Disparate Screens"><div class="sect2" id="idm45310200376400">
<h2>Building for Disparate Screens</h2>

<p>Given the diversity in hardware manufacturers and over 24,000 models, as<a data-type="indexterm" data-primary="mobile workflows" data-secondary="Android device fragmentation" data-tertiary="screen size disparity" id="ch09-screen"/><a data-type="indexterm" data-primary="smartphone workflows" data-secondary="Android device fragmentation" data-tertiary="screen size disparity" id="ch09-screen2"/><a data-type="indexterm" data-primary="workflows" data-secondary="mobile workflows" data-tertiary="Android screen size disparity" id="ch09-screen3"/><a data-type="indexterm" data-primary="testing" data-secondary="Android device fragmentation" data-tertiary="screen size disparity" id="idm45310200370176"/><a data-type="indexterm" data-primary="screen size disparity in mobile devices" id="ch09-screen4"/><a data-type="indexterm" data-primary="Android device fragmentation" data-secondary="screen size disparity" id="ch09-screen5"/> discussed in the previous section, it should be no surprise that a huge variation also exists in screen sizes and resolutions.
New screen dimensions are constantly being introduced, such as the enormous HP Slate 21, which uses a 21.5-inch touchscreen, and the Samsung Galaxy Fold with a vertical 1680 × 720 cover display that opens to reveal a double-wide inner display with a resolution of 2152 × 1536.</p>

<p>Besides the huge variation in screen sizes, <a data-type="indexterm" data-primary="pixel density in mobile devices" id="idm45310200365760"/>there is a constant battle over achieving higher pixel density as well.
Higher pixel densities allow for clearer text and sharper graphics, providing a better viewing experience.</p>

<p>The current front-runner in pixel density is the Sony Xperia XZ, which packs a 3840 × 2160 UHS-1 display in a screen that measures only 5.2 inches diagonally.
This gives a density of 806.93 pixels per inch (PPI), which is getting close to the maximum resolution the human eye can distinguish.</p>

<p>Applied Materials, one of the leading manufacturers of LCD and OLED displays, did research on human perception of pixel density on handheld displays.
It found that at a distance of 4 inches from the eye, <a href="https://oreil.ly/OecRt">a human with 20/20 vision can distinguish 876 PPI</a>.
Therefore, smartphone displays are quickly approaching the theoretical limit on pixel density; however, other form factors like virtual reality headsets may drive the density even further.</p>

<p>To handle variation in pixel densities, Android categorizes screens into the following pixel density ranges:</p>
<dl>
<dt>ldpi, ~120 dpi (.75x scale)</dt>
<dd>
<p>Used on a limited number of very low-resolution devices like the HTC Tattoo, Motorola Flipout, and Sony X10 Mini, all of which have a screen resolution of 240 × 320 pixels.</p>
</dd>
<dt>mdpi, ~160 dpi (1x scale)</dt>
<dd>
<p>This is the original screen resolution for Android devices such as the HTC Hero and Motorola Droid.</p>
</dd>
<dt>tvdpi, ~213 dpi (1.33x scale)</dt>
<dd>
<p>Resolution intended for televisions such as the Google Nexus 7, but not considered a “primary” density group.</p>
</dd>
<dt>hdpi, ~240 dpi (1.5x scale)</dt>
<dd>
<p>The second generation of phones such as the HTC Nexus One and Samsung Galaxy Ace increased resolution by 50%.</p>
</dd>
<dt>xhdpi, ~320 dpi (2x scale)</dt>
<dd>
<p>One of the first phones to use this 2<em>x</em> resolution was the Sony Xperia S, followed by phones like the Samsung Galaxy S III and HTC One.</p>
</dd>
<dt>xxhdpi, ~480 dpi (3x scale)</dt>
<dd>
<p>The first xxhdpi device was the Nexus 10 by Google, which was only 300 dpi but needed large icons since it was in tablet form.</p>
</dd>
<dt>xxxhdpi, ~640 dpi (4x scale)</dt>
<dd>
<p>This is currently the highest resolution used by devices like the Nexus 6 and Samsung Galaxy S6 Edge.</p>
</dd>
</dl>

<p>As displays continue to increase in pixel density, Google probably wishes it had chosen a better convention for high-resolution displays than just adding more <em>x</em>s!</p>

<p>To give the best user experience for your end users, it is important to have your application look and behave consistently across the full range of available resolutions.
Given the wide variety of screen resolutions, it is not enough to simply hardcode your application for each resolution.</p>

<p>Here are some best practices to make sure that your application will work across the full range of resolutions:</p>

<ul>
<li>
<p>Always use density-independent and scalable pixels:<a data-type="indexterm" data-primary="density-independent pixels (dp)" id="idm45310200347632"/><a data-type="indexterm" data-primary="scalable pixels (sp)" id="idm45310200346912"/></p>
<dl>
<dt>Density-independent pixels (dp)</dt>
<dd>
<p>Pixel unit that adjusts based on the resolution of the device.
For an mdpi screen, 1 pixel (px) = 1 dp.
For other screen resolutions, px = dp × (dpi / 160).</p>
</dd>
<dt>Scalable pixels (sp)</dt>
<dd>
<p>Scalable pixel unit used for text or other user-resizable elements.
This starts at 1 sp = 1 dp and adjusts based on the user-defined text zoom value.</p>
</dd>
</dl>
</li>
<li>
<p>Provide alternate bitmaps for all available resolutions:</p>

<ul>
<li>
<p>Android allows you to provide alternate bitmaps for different resolutions by putting them in subfolders named <em>drawable-?dpi</em>, where <em>?dpi</em> is one of the supported density ranges.</p>
</li>
<li>
<p>The same applies for your app icon, except you should use subfolders named <em>mipmap-?dpi</em> so the resources aren’t removed when you build density-specific APKs, because app icons are often upscaled beyond the device resolution.</p>
</li>
</ul>
</li>
</ul>

<ul class="pagebreak-before">
<li>
<p>Better yet, use vector graphics whenever possible:</p>

<ul>
<li>
<p>Android Studio provides a tool called Vector Asset Studio that allows you to convert an SVG or PSD into an Android Vector file that can be used as a resource in your application, as shown in <a data-type="xref" href="#convert_svg">Figure 9-3</a>.</p>
</li>
</ul>
</li>
</ul>

<figure><div id="convert_svg" class="figure">
<img src="Images/dtjd_0903.png" alt="Dialog from Android Studio for converting SVG and PSD files to vector resources" width="600" height="454"/>
<h6><span class="label">Figure 9-3. </span>Conversion of an SVG file to an Android Vector format</h6>
</div></figure>

<p>Building applications that cleanly scale to different screen sizes and resolutions is complicated to get right and needs to be tested on devices with differing resolutions.
To help focus your testing efforts, Google provides user-mined <a href="https://oreil.ly/Aqw18">data</a> on the usage of different device resolutions, as shown in <a data-type="xref" href="#sizes_and_densities">Table 9-1</a>.</p>
<table id="sizes_and_densities" style="width: 100%">
<caption><span class="label">Table 9-1. </span>Android screen size and density distribution</caption>
<thead>
<tr>
<th/>
<th>ldpi</th>
<th>mdpi</th>
<th>tvdpi</th>
<th>hdpi</th>
<th>xdpi</th>
<th>xxhdpi</th>
<th>Total</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Small</p></td>
<td><p>0.1%</p></td>
<td/>
<td/>
<td/>
<td><p>0.1%</p></td>
<td/>
<td><p>0.2%</p></td>
</tr>
<tr>
<td><p>Normal</p></td>
<td/>
<td><p>0.3%</p></td>
<td><p>0.3%</p></td>
<td><p>14.8%</p></td>
<td><p>41.3%</p></td>
<td><p>26.1%</p></td>
<td><p>82.8%</p></td>
</tr>
<tr>
<td><p>Large</p></td>
<td/>
<td><p>1.7%</p></td>
<td><p>2.2%</p></td>
<td><p>0.8%</p></td>
<td><p>3.2%</p></td>
<td><p>2.0%</p></td>
<td><p>9.9%</p></td>
</tr>
<tr>
<td><p>Xlarge</p></td>
<td/>
<td><p>4.2%</p></td>
<td><p>0.2%</p></td>
<td><p>2.3%</p></td>
<td><p>0.4%</p></td>
<td/>
<td><p>7.1%</p></td>
</tr>
<tr>
<td><p>Total</p></td>
<td><p>0.1%</p></td>
<td><p>6.2%</p></td>
<td><p>2.7%</p></td>
<td><p>17.9%</p></td>
<td><p>45.0%</p></td>
<td><p>28.1%</p></td>
<td/>
</tr>
</tbody>
</table>

<p>As you can see, some resolutions are not prevalent and, unless your application targets these users or legacy device types, you can prune them from your device-testing matrix.
The ldpi density is used on only a small segment of Android devices and with only 0.1% market share—few applications are optimized for this very small resolution screen.
Also, tvdpi is a niche screen resolution with only 2.7% usage and can be safely ignored since Android will automatically downscale hdpi assets in order to fit this screen resolution.</p>

<p>This still leaves you with five device densities to support and a potentially innumerable number of screen resolutions and aspect ratios to test.
I discuss testing strategies later, but you will likely be using a mix of emulated devices and physical devices to make sure that you provide the best user experience across the fragmented Android ecosystem.<a data-type="indexterm" data-startref="ch09-screen" id="idm45310200298720"/><a data-type="indexterm" data-startref="ch09-screen2" id="idm45310200298016"/><a data-type="indexterm" data-startref="ch09-screen3" id="idm45310200297344"/><a data-type="indexterm" data-startref="ch09-screen4" id="idm45310200296672"/><a data-type="indexterm" data-startref="ch09-screen5" id="idm45310200296000"/></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Hardware and 3D Support"><div class="sect2" id="idm45310200375776">
<h2>Hardware and 3D Support</h2>

<p>The very first Android device was the HTC Dream (a.k.a. T-Mobile G1), shown in <a data-type="xref" href="#tmobile_g1">Figure 9-4</a>.<a data-type="indexterm" data-primary="mobile workflows" data-secondary="Android device fragmentation" data-tertiary="hardware and 3D support" id="ch09-hard"/><a data-type="indexterm" data-primary="smartphone workflows" data-secondary="Android device fragmentation" data-tertiary="hardware and 3D support" id="ch09-hard2"/><a data-type="indexterm" data-primary="workflows" data-secondary="mobile workflows" data-tertiary="Android hardware and 3D support" id="ch09-hard3"/><a data-type="indexterm" data-primary="testing" data-secondary="Android device fragmentation" data-tertiary="hardware and 3D support" id="ch09-hard4"/><a data-type="indexterm" data-primary="APIs" data-secondary="Android device fragmentation" data-tertiary="hardware and 3D support" id="ch09-hard5"/><a data-type="indexterm" data-primary="Android device fragmentation" data-secondary="hardware and 3D support" id="ch09-hard6"/>
It had a medium density touchscreen of 320 × 480 px, a hardware keyboard, speaker, microphone, five buttons, a clickable trackball, and a rear-mounted camera.
While primitive by modern smartphone standards, it was a great platform to launch Android, which lacked support for software keyboards at the time.</p>

<p>Compared to modern smartphone standards, this was a modest hardware set.
The Qualcomm MSM7201A processor that drove the HTC Dream was a 528 MHz Arm11 processor with support for only OpenGL ES 1.1. In comparison, the Samsung Galaxy S21 Ultra 5G sports a 3200 × 1440 resolution screen with the following sensors:</p>

<ul>
<li>
<p>2.9 GHz 8-core processor</p>
</li>
<li>
<p>Arm Mali-G78 MP14 GPU with support for Vulkan 1.1, OpenGL ES 3.2, and OpenCL 2.0</p>
</li>
<li>
<p>Five cameras (one front, four rear)</p>
</li>
<li>
<p>Three microphones (one bottom, two top)</p>
</li>
<li>
<p>Stereo speakers</p>
</li>
<li>
<p>Ultrasonic fingerprint reader</p>
</li>
<li>
<p>Accelerometer</p>
</li>
<li>
<p>Barometer</p>
</li>
<li>
<p>Gyro sensor (gyroscope)</p>
</li>
<li>
<p>Geomagnetic sensor (magnetometer)</p>
</li>
<li>
<p>Hall sensor</p>
</li>
<li>
<p>Proximity sensor</p>
</li>
<li>
<p>Ambient light sensor</p>
</li>
<li>
<p>NFC</p>
</li>
</ul>

<figure><div id="tmobile_g1" class="figure">
<img src="Images/dtjd_0904.png" alt="Photo of a smartphone with the screen retracted to show a hardware keyboard." width="600" height="458"/>
<h6><span class="label">Figure 9-4. </span>The T-Mobile G1 (a.k.a. HTC Dream), which was the <a href="https://oreil.ly/ijUOh">first smartphone</a> to run the Android operating system (photo used under <a href="https://oreil.ly/GLSPZ">Creative Commons license</a>)</h6>
</div></figure>

<p>The flagship Samsung phones are at the high end of the spectrum when it comes to hardware support, and include almost all of the supported sensor types.
Phones meant for mass market may choose to use less powerful chipsets and leave off sensors to reduce cost.
Android uses the data from the available<a data-type="indexterm" data-primary="virtual sensors in Android devices" id="idm45310200266080"/> physical sensors to also create “virtual” sensors in software that are used by applications:</p>
<dl>
<dt>Game rotation vector</dt>
<dd>
<p>Combination of data from the accelerometer and gyroscope</p>
</dd>
<dt>Gravity</dt>
<dd>
<p>Combination of data from the accelerometer and gyroscope (or magnetometer if no gyroscope is present)</p>
</dd>
<dt>Geomagnetic rotational vector</dt>
<dd>
<p>Combination of data from the accelerometer and magnetometer</p>
</dd>
<dt>Linear acceleration</dt>
<dd>
<p>Combination of data from the accelerometer and gyroscope (or magnetometer if no gyroscope is present)</p>
</dd>
<dt>Rotation vector</dt>
<dd>
<p>Combination of data from the accelerometer, magnetometer, and gyroscope</p>
</dd>
<dt>Significant motion</dt>
<dd>
<p>Data from the accelerometer (and possibly substitutes other sensor data when in low-power mode)</p>
</dd>
<dt>Step detector/counter</dt>
<dd>
<p>Data from the accelerometer (and possibly substitutes other sensor data when in low-power mode)</p>
</dd>
</dl>

<p>These virtual sensors are available only if a sufficient set of physical sensors is present.
Most phones contain an accelerometer, but may choose to omit either a gyroscope or magnetometer or both, reducing the precision of motion detection and disabling certain virtual sensors.</p>

<p>Hardware sensors can be emulated, but it is much harder to simulate real-world conditions for testing.
Also, much more variation occurs in hardware chipset and SoC vendor-driver implementation, producing a huge test matrix required to verify your application across a range of devices.</p>

<p>The other aspect of hardware that is particularly important for game developers, but increasingly is part of the basic graphics stack and expected performance of applications, is 3D API support.
Almost all mobile processors support some basic 3D APIs, including the first Android phone, which had support for OpenGL ES 1.1, a mobile-specific version of the OpenGL 3D standard.
Modern phones support later versions of the OpenGL ES standard, including OpenGL ES 2.0, 3.0, 3.1, and now 3.2.</p>

<p>OpenGL ES 2.0 introduced a dramatic shift in the programming model, switching from a functional pipeline to a programmable pipeline, allowing for more direct control to create complex effects through the use of shaders.
OpenGL ES 3.0 further increased the performance and hardware independence of 3D graphics by supporting features like vertex array objects, instanced rendering, and device-independent compression formats (ETC2/EAC).</p>

<p>OpenGL ES adoption has been rather quick, with all modern devices supporting at least OpenGL ES 2.0. According to Google’s device data shown in <a data-type="xref" href="#opengl_es_adoption">Figure 9-5</a>, the majority of devices (67.54%) support OpenGL ES 3.2, the latest version of the standard released in August 2015.</p>

<figure><div id="opengl_es_adoption" class="figure">
<img src="Images/dtjd_0905.png" alt="Pie chart showing of OpenGL ES version adoption" width="600" height="417"/>
<h6><span class="label">Figure 9-5. </span>Percentage of Android devices adopting different versions of OpenGL ES from <a href="https://oreil.ly/18xDQ">Google’s Distribution Dashboard</a></h6>
</div></figure>

<p>Vulkan is a newer graphics API that modern graphics chipsets support.
It has the advantage of being portable between desktop and mobile devices, allowing for easier porting of desktop code as computing platforms continue to converge.
Also, it allows an even finer level of control over threads and memory management, and an asynchronous API for buffering and sequencing commands across multiple threads, making better use of multicore processors and high-end hardware.</p>

<p>Since Vulkan is a newer API, adoption has not been as quick as OpenGL ES; however, 64% of Android devices have some level of Vulkan support.
According to Google’s device statistics visualized in <a data-type="xref" href="#vulkan_adoption">Figure 9-6</a>, this is split between Vulkan 1.1, which is supported by 42% of devices, and the remaining 22% of devices that support only the Vulkan 1.0.3 API level.</p>

<p>Similar to hardware sensor testing, a large variety of 3D chipsets are implemented by different manufacturers.
Therefore, the only way to reliably test for bugs and performance issues in your application is to execute device testing on different phone models, covered in the next section.<a data-type="indexterm" data-startref="ch09-mobwork" id="idm45310200245360"/><a data-type="indexterm" data-startref="ch09-hard" id="idm45310200244656"/><a data-type="indexterm" data-startref="ch09-hard2" id="idm45310200243984"/><a data-type="indexterm" data-startref="ch09-hard3" id="idm45310200243312"/><a data-type="indexterm" data-startref="ch09-hard4" id="idm45310200242640"/><a data-type="indexterm" data-startref="ch09-hard5" id="idm45310200241968"/><a data-type="indexterm" data-startref="ch09-hard6" id="idm45310200241296"/></p>

<figure><div id="vulkan_adoption" class="figure">
<img src="Images/dtjd_0906.png" alt="Pie chart showing Vulkan version adoption" width="600" height="427"/>
<h6><span class="label">Figure 9-6. </span>Percentage of Android devices adopting different versions of Vulkan from <a href="https://oreil.ly/K9FZd">Google’s Distribution Dashboard</a></h6>
</div></figure>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Continuous Testing on Parallel Devices"><div class="sect1" id="idm45310200237872">
<h1>Continuous Testing on Parallel Devices</h1>

<p>The preceding section discussed the large amount of fragmentation in the Android device ecosystem.<a data-type="indexterm" data-primary="mobile workflows" data-secondary="continuous testing on parallel devices" data-tertiary="about" id="idm45310200236384"/><a data-type="indexterm" data-primary="smartphone workflows" data-secondary="continuous testing on parallel devices" data-tertiary="about" id="idm45310200235088"/><a data-type="indexterm" data-primary="testing" data-secondary="Android device continuous testing" data-tertiary="about" id="idm45310200233856"/><a data-type="indexterm" data-primary="workflows" data-secondary="mobile workflows" data-tertiary="continuous testing on parallel devices" id="ch09-paral"/>
This is forced by technological factors like the Android OS architecture as well as the complex ecosystem of OEMs and SoC vendors.
Also, the sheer popularity of the Android platform, with 1,300 manufacturers producing over 24,000 devices, creates a continuous testing and deployment challenge.</p>

<p>Device emulators are great for development and basic testing of applications, but cannot possibly simulate the complex interactions of unique hardware configurations, device drivers, custom kernels, and real-world sensor behavior.
Therefore, a high level of manual and automated testing on devices is required to ensure a good experience for end users.</p>

<p>Two basic approaches are used for hardware testing at scale.
The first is to build out your own device lab with shared devices.
This is a practical approach to get started with testing, since you likely have a large collection of Android devices available that could be put to better use with proper infrastructure and automation.
However, depending on the number of device configurations you want to support, this can be quite a large and expensive endeavor.
Also, the ongoing maintenance and upkeep for a large device farm can be costly in both materials and labor.</p>

<p>The second option is to outsource your device testing to a cloud service.
Given the advances in remote control of Android devices and stability of the platform, it is convenient to be able to select your matrix of devices and have your automated tests fired off in the cloud.
Most cloud services offer detailed screenshots and diagnostic logs that can be used to trace build failures as well as the ability to manually control a device for debugging purposes.</p>








<section data-type="sect2" data-pdf-bookmark="Building a Device Farm"><div class="sect2" id="idm45310200228976">
<h2>Building a Device Farm</h2>

<p>Building your own device farm, even at a small scale,<a data-type="indexterm" data-primary="mobile workflows" data-secondary="continuous testing on parallel devices" data-tertiary="device farm" id="ch09-farm"/><a data-type="indexterm" data-primary="smartphone workflows" data-secondary="continuous testing on parallel devices" data-tertiary="device farm" id="ch09-farm2"/><a data-type="indexterm" data-primary="testing" data-secondary="Android device continuous testing" data-tertiary="device farm" id="ch09-farm3"/><a data-type="indexterm" data-primary="workflows" data-secondary="mobile workflows" data-tertiary="device farm for testing" id="ch09-farm4"/><a data-type="indexterm" data-primary="device farm for mobile testing" id="ch09-farm5"/> is a great way to leverage Android devices that you already have and increase their utility for your entire organization.
At scale, device farms can significantly reduce the run rate cost of Android development once you have made the up-front investment in hardware.
Keep in mind, though, running a large device lab is a full-time job and has ongoing costs that need to be accounted for.</p>

<p>A popular open source library for managing<a data-type="indexterm" data-primary="Device Farmer Android library" id="idm45310200219744"/><a data-type="indexterm" data-primary="Open STF" data-see="Device Farmer Android library" id="idm45310200219024"/><a data-type="indexterm" data-primary="APIs" data-secondary="Device Farmer Android library" id="idm45310200218064"/> Android devices is Device Farmer (formerly Open STF).
Device Farmer allows you to remotely control an Android device from your web browser with a real-time view of the device screen, as shown in <a data-type="xref" href="#device_farmer">Figure 9-7</a>.
For manual tests, you can type from your desktop keyboard and use your mouse to input single or multitouch gestures.
For automated tests, a REST API allows you to use test automation frameworks like Appium.</p>

<figure><div id="device_farmer" class="figure">
<img src="Images/dtjd_0907.png" alt="Picture of a volunteer built device lab at a conference" width="600" height="355"/>
<h6><span class="label">Figure 9-7. </span>Device Farmer <a href="https://oreil.ly/2MQpN">user interface</a> (photo used under <a href="https://oreil.ly/bPhIL">Creative Commons</a>)</h6>
</div></figure>

<p>Device Farmer also helps you manage your inventory of devices.
It shows you which devices are connected, who is using each device, and the hardware spec for your devices, and it assists with physically locating devices in a large lab.</p>

<p class="pagebreak-before">Finally, Device Farmer also has a system for booking and partitioning groups of devices.
You can split your device inventory into distinct groups that have owners and associated properties.
These groups can then be permanently allocated to projects or organizations or they can be booked for a specific time period.</p>

<p>To set up a device lab, you also need hardware to support the devices.
The basic hardware setup includes the following:</p>
<dl>
<dt>Driver computer</dt>
<dd>
<p>Even though Device Farmer can run on any operating system, it is recommended to run it on a Linux-based host for ease of administration and the best stability.
A good option for getting started with this is a compact, but powerful, computer like the Intel NUC.</p>
</dd>
<dt>USB hub</dt>
<dd>
<p>Both for device connectivity and to supply stable power, a powered USB hub is recommended.
Getting a reliable USB hub is important since this will affect the stability of your lab.</p>
</dd>
<dt>Wireless router</dt>
<dd>
<p>The devices will get their network connectivity from a wireless router, so this is an important part of the device setup.
Having a dedicated network for your devices will increase reliability and reduce contention with other devices on your network.</p>
</dd>
<dt>Android devices</dt>
<dd>
<p>And the most important part, of course, is having plenty of Android devices to test against.
Start with devices that are the most common and popular with your target user base and add devices to hit the desired test matrix of Android OS versions, screen sizes, and hardware support as discussed in the previous section.</p>
</dd>
<dt>Plenty of cables</dt>
<dd>
<p>You will need longer cables than usual for efficient cable management of devices to the USB hub.
It is important to leave enough space between individual devices and hardware components to avoid overheating.</p>
</dd>
</dl>

<p>With a little bit of work, you will be able to create a fully automated device lab similar to <a data-type="xref" href="#open_device_lab">Figure 9-8</a>, which was the world’s first conference device lab featured at the beyond tellerrand conference in Düsseldorf, Germany.</p>

<figure><div id="open_device_lab" class="figure">
<img src="Images/dtjd_0908.png" alt="Picture of a volunteer built device lab at a conference" width="600" height="398"/>
<h6><span class="label">Figure 9-8. </span><a href="https://oreil.ly/QgEr9">Open device lab</a> at the beyond tellerrand conference in Düsseldorf, Germany (photo used under <a href="https://oreil.ly/Xv18U">Creative Commons</a>)</h6>
</div></figure>

<p>Device Farmer is split into microservices to allow for scalability of the platform to thousands of devices.
Out of the box, it easily supports 15 devices, after which you will run into port limitations with Android Debug Bridge (ADB).
This can be scaled out by running multiple instances of the Device Farmer ADB and Provider services up to the limit of the number of USB devices that your machine can support.
For Intel architectures, this is 96 endpoints (including other peripherals), and for AMD, you can get up to 254 USB endpoints.
By using multiple Device Farmer servers, you can scale into the thousands of devices, which should be enough to support mobile testing and verification of enterprise Android applications.</p>

<p>One example of a large-scale mobile device lab is Facebook’s mobile device lab at its Prineville, Oregon, data center, shown in <a data-type="xref" href="#facebook_mobile_device_lab">Figure 9-9</a>.
The company built a customer server rack enclosure for holding mobile devices that is deigned to block WiFi signals to prevent interference among devices in the data center.
Each enclosure can support 32 devices and is powered by 4 OCP Leopard servers that connect to the devices.
This provides a stable and scalable hardware setup that allowed the company to reach its target device farm size of 2,000 devices.</p>

<figure><div id="facebook_mobile_device_lab" class="figure">
<img src="Images/dtjd_0909.png" alt="Photo of a data center holding mobile devices in rack enclosures." width="600" height="360"/>
<h6><span class="label">Figure 9-9. </span>The Facebook mobile device lab in its Prineville data center (<a href="https://oreil.ly/fbj35">photo by Antoine Reversat</a>)</h6>
</div></figure>

<p>Running a large-scale device lab has challenges:</p>
<dl>
<dt>Device maintenance</dt>
<dd>
<p>Android devices are not meant to be run 24/7 for automated testing.
As a result, you are likely to experience higher than normal device failure and have to replace batteries or entire devices every year or two.
Spacing out devices and keeping them well cooled will help with this.</p>
</dd>
<dt>WiFi interference/connectivity</dt>
<dd>
<p>WiFi networks, especially consumer-targeted WiFi routers, are not highly stable, especially with a large number of devices.
Reducing the broadcast signal power of the WiFi routers and making sure they are on noncompeting network bands can reduce interference.</p>
</dd>
<dt>Cable routing</dt>
<dd>
<p>Running cables among all the devices and the USB hubs or computers can create a tangled mess.
Besides being hard to maintain, this can also cause connectivity and charging issues.
Make sure to remove all loops in the cables and use shielded cables and ferrite cores as necessary to reduce electromagnetic interference.</p>
</dd>
<dt>Device reliability</dt>
<dd>
<p>Running a device lab on consumer devices comes with the general risk that consumer devices are not reliable.
Limiting automated test runs to a finite <span class="keep-together">duration</span> will help prevent tests from becoming blocked on nonresponsive devices.
Between tests, some housekeeping to remove data and free memory will help with performance and reliability.
Finally, the Android devices as well as the servers running them will need to be rebooted periodically.</p>
</dd>
</dl>
<div data-type="tip"><h6>Tip</h6>
<p>Starting on a small scale with devices you already own is easy and can improve the ability to test across a range of devices and fire off automated tests in parallel.
At a large scale, this is an effective solution to solving testing across the fragmented Android ecosystem, but comes with high up-front costs and ongoing support and maintenance.</p>
</div>

<p>The next section talks about device labs that you can get started with today on a simple pay-as-you-go basis.<a data-type="indexterm" data-startref="ch09-farm" id="idm45310200182304"/><a data-type="indexterm" data-startref="ch09-farm2" id="idm45310200181600"/><a data-type="indexterm" data-startref="ch09-farm3" id="idm45310200180928"/><a data-type="indexterm" data-startref="ch09-farm4" id="idm45310200180256"/><a data-type="indexterm" data-startref="ch09-farm5" id="idm45310200179584"/></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Mobile Pipelines in the Cloud"><div class="sect2" id="idm45310200178656">
<h2>Mobile Pipelines in the Cloud</h2>

<p>If the prospect of building your own device lab seems daunting,<a data-type="indexterm" data-primary="mobile workflows" data-secondary="continuous testing on parallel devices" data-tertiary="mobile device clouds" id="ch09-cloud"/><a data-type="indexterm" data-primary="smartphone workflows" data-secondary="continuous testing on parallel devices" data-tertiary="mobile device clouds" id="ch09-cloud2"/><a data-type="indexterm" data-primary="testing" data-secondary="Android device continuous testing" data-tertiary="mobile device clouds" id="ch09-cloud3"/><a data-type="indexterm" data-primary="workflows" data-secondary="mobile workflows" data-tertiary="clouds for testing" id="ch09-cloud4"/><a data-type="indexterm" data-primary="cloud testing of mobile devices" id="ch09-cloud5"/><a data-type="indexterm" data-primary="mobile device clouds" id="ch09-cloud6"/> an easy and inexpensive way to get started with testing across a large range of devices is to use a device farm running on public cloud infrastructure.
Mobile device clouds have the advantage of being easy to get started with and maintenance free for the end user.
You simply select the devices you want to run tests on, and fire off either manual or automated tests of your application against a pool of devices.</p>

<p>Some mobile device clouds also support automated robot tests that will attempt to exercise all the visible UI elements of your application to identify performance or stability issues with your application.
Once tests are run, you get a full report of any failures, device logs for debugging, and screenshots for tracing issues.</p>

<p>Many mobile device clouds are available, with some dating back to the feature phone era.
However, the most popular and modern device clouds have ended up aligning with the top three cloud providers—Amazon, Google, and Microsoft.
They all have sizable investments in mobile test infrastructure that you can try for a reasonable price and have a large range of emulated and real devices to test against.</p>










<section data-type="sect3" data-pdf-bookmark="AWS device farm"><div class="sect3" id="idm45310200167248">
<h3>AWS device farm</h3>

<p>Amazon offers a mobile device cloud as part of its public cloud services.<a data-type="indexterm" data-primary="mobile device clouds" data-secondary="AWS Device Farm" id="ch09-aws"/><a data-type="indexterm" data-primary="cloud testing of mobile devices" data-secondary="AWS Device Farm" id="ch09-aws2"/><a data-type="indexterm" data-primary="AWS Device Farm" id="ch09-aws3"/><a data-type="indexterm" data-primary="Amazon Web Services (AWS)" data-secondary="AWS Device Farm" id="ch09-aws4"/>
Using AWS Device Farm, you can run automated tests on a variety of real-world devices by using your AWS account.</p>

<p>The steps to create a new AWS Device Farm test are as follows:</p>
<ol>
<li>
<p><em>Upload your APK file</em>: To start, upload your compiled APK file or choose from recently updated files.</p>
</li>
<li>
<p><em>Configure your test automation</em>: AWS Device Farm supports a variety of test frameworks, including Appium tests (written in Java, Python, Node.js, or Ruby), Calabash, Espresso, Robotium, or UI Automator.
If you don’t have automated tests, AWS provides two robot app testers called Fuzz and Explorer.</p>
</li>
<li>
<p><em>Select devices to run on</em>: Pick the devices that you want to run your test on from a user-created pool of devices or the default pool of the five most popular devices, as shown in <a data-type="xref" href="#aws_device_farm_select_device">Figure 9-10</a>.</p>
</li>
<li>
<p><em>Set up the device state</em>: To set up the device before starting the tests, you can specify data or other dependent apps to install, set the radio states (WiFi, Bluetooth, GPS, and NFC), change the GPS coordinates, change the locale, and set up a network profile.</p>
</li>
<li>
<p><em>Run your test</em>: Finally, you can run your test on the selected devices with a specified execution time-out of up to 150 minutes per device.
If your tests execute more quickly, this can finish earlier, but this also sets a maximum cap on the cost of your test run.</p>
</li>

</ol>

<figure><div id="aws_device_farm_select_device" class="figure">
<img src="Images/dtjd_0910.png" alt="Screenshot of creating a new run on the AWS Device Farm." width="600" height="426"/>
<h6><span class="label">Figure 9-10. </span>Selecting devices to run on in the AWS Device Farm wizard</h6>
</div></figure>

<p>AWS Device Farm offer a free quota for individual developers to get started with test automation, low per-minute pricing for additional device testing, and monthly plans to do parallel testing on multiple devices at once.
All of these plans operate on a shared pool of devices, which at the time of writing included 91 total devices, 54 of which were Android devices, as shown in <a data-type="xref" href="#aws_device_farm_list">Figure 9-11</a>.
However, most of these devices were highly available, indicating that they had a large number of identical devices to test against.
This means that you are less likely to get blocked in a queue or have a device you need to test against become unavailable.</p>

<figure><div id="aws_device_farm_list" class="figure">
<img src="Images/dtjd_0911.png" alt="Screenshot of a table of devices." width="600" height="450"/>
<h6><span class="label">Figure 9-11. </span>List of available devices in the AWS Device Farm</h6>
</div></figure>

<p>Finally, AWS Device Farm offers a couple of integrations to run automated tests.
From within Android Studio, you can run tests on the AWS Device Farm by using its Gradle plug-in.
If you want to launch AWS Device Farm tests from your continuous integration system, Amazon offers a Jenkins plug-in that you can use to start device tests right after your local build and test automation completes.<a data-type="indexterm" data-startref="ch09-aws" id="idm45310200145616"/><a data-type="indexterm" data-startref="ch09-aws2" id="idm45310200144912"/><a data-type="indexterm" data-startref="ch09-aws3" id="idm45310200144240"/><a data-type="indexterm" data-startref="ch09-aws4" id="idm45310200143568"/></p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Google Firebase Test Lab"><div class="sect3" id="idm45310200142768">
<h3>Google Firebase Test Lab</h3>

<p>After Google’s acquisition of Firebase,<a data-type="indexterm" data-primary="mobile device clouds" data-secondary="Google Firebase Test Lab" id="idm45310200141296"/><a data-type="indexterm" data-primary="cloud testing of mobile devices" data-secondary="Google Firebase Test Lab" id="idm45310200140256"/><a data-type="indexterm" data-primary="Google Firebase Test Lab" id="idm45310200139280"/><a data-type="indexterm" data-primary="Firebase Test Lab (Google)" id="idm45310200138592"/> it has been continually expanding and improving the offering.
Firebase Test Lab is its mobile device-testing platform that provides similar functionality to AWS Device Farm.
To get started, Google offers a free quota for developers to run a limited number of tests per day.
Beyond that, you can upgrade to a pay-as-you-go plan with a flat fee per device hour.</p>

<p>Firebase Test Lab offers several ways you can fire off tests on the service:</p>
<dl>
<dt>Android Studio</dt>
<dd>
<p>Firebase Test Lab is integrated in Android Studio and allows you to run tests in its mobile device cloud just as easily as you would on local devices.</p>
</dd>
<dt>Firebase Web UI</dt>
<dd>
<p>From the Firebase web console, you can upload your APK and will start by running your first app in an automated Robo test, as shown in <a data-type="xref" href="#firebase_test_lab_robo">Figure 9-12</a>.
In addition, you can run your own automated tests using Espresso, Robotium, or UI Automator.
Game developers have the option to run an integrated game loop that simulates user scenarios.</p>
</dd>
<dt>Automated command-line scripts</dt>
<dd>
<p>You can easily integrate Firebase Test Lab into your CI system by using its command-line API.
This allows you to integrate with Jenkins, CircleCI, JFrog Pipelines, or your favorite CI/CD system.</p>
</dd>
</dl>

<figure><div id="firebase_test_lab_robo" class="figure">
<img src="Images/dtjd_0912.png" alt="Screenshot of the Firebase web console testing an app." width="600" height="385"/>
<h6><span class="label">Figure 9-12. </span>Firebase web user interface running an automated Robo test</h6>
</div></figure>

<p>At the time of writing, Firebase Test Lab offered a larger collection of Android devices than AWS Device Farm, with 109 devices supported, as well as multiple API levels for popular devices.
Given the tight integration with Google’s Android tooling and the generous free quota for individuals, this is an easy way to get your development team started building test automation.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Microsoft Visual Studio App Center"><div class="sect3" id="idm45310200127952">
<h3>Microsoft Visual Studio App Center</h3>

<p>Microsoft Visual Studio App Center,<a data-type="indexterm" data-primary="mobile device clouds" data-secondary="Microsoft Visual Studio App Center" id="idm45310200126480"/><a data-type="indexterm" data-primary="cloud testing of mobile devices" data-secondary="Microsoft Visual Studio App Center" id="idm45310200125488"/><a data-type="indexterm" data-primary="Microsoft Visual Studio App Center" id="idm45310200124512"/><a data-type="indexterm" data-primary="Visual Studio (Microsoft)" data-secondary="App Center device farm" id="idm45310200123824"/> formerly Xamarin Test Cloud, offers the most impressive device list of any of the clouds, with 349 Android device types for you to run tests on, as shown in <a data-type="xref" href="#vs_app_center_devices">Figure 9-13</a>.
However, unlike AWS Device Farm and Firebase Test Lab, no free tier exists for developers to use the service.
Microsoft does offer a 30-day trial on its service to use a single physical device to run tests, and paid plans where you pay by the number of concurrent devices you want to use, which makes sense for large enterprises.</p>

<figure><div id="vs_app_center_devices" class="figure">
<img src="Images/dtjd_0913.png" alt="Screenshot of the device list in VS App Center." width="600" height="422"/>
<h6><span class="label">Figure 9-13. </span>Visual Studio App Center device selection screen</h6>
</div></figure>

<p>Visual Studio App Center also is missing some of the user-friendly features like a robot tester and simple test execution via the web console.
Instead, it focuses on the command-line integration with the App Center CLI.
From the App Center CLI, you can easily fire off automated tests using Appium, Calabash, Espresso, or XamarainUITest.
Also, this makes integration with CI/CD tools straightforward.</p>

<p>Overall, Visual Studio App Center wins on device coverage and has a clear focus on enterprise mobile device testing.
However, for independent developers or smaller teams, it is less approachable and has higher up-front costs, but it will work well as you scale.<a data-type="indexterm" data-startref="ch09-cloud" id="idm45310200118096"/><a data-type="indexterm" data-startref="ch09-cloud2" id="idm45310200117392"/><a data-type="indexterm" data-startref="ch09-cloud3" id="idm45310200116720"/><a data-type="indexterm" data-startref="ch09-cloud4" id="idm45310200116048"/><a data-type="indexterm" data-startref="ch09-cloud5" id="idm45310200115376"/><a data-type="indexterm" data-startref="ch09-cloud6" id="idm45310200114704"/></p>
</div></section>



</div></section>













<section data-type="sect2" data-pdf-bookmark="Planning a Device-Testing Strategy"><div class="sect2" id="idm45310200113776">
<h2>Planning a Device-Testing Strategy</h2>

<p>Now that you’ve seen the basics of setting<a data-type="indexterm" data-primary="mobile device clouds" data-secondary="strategy for device testing" id="ch09-strat"/><a data-type="indexterm" data-primary="cloud testing of mobile devices" data-secondary="strategy for device testing" id="ch09-strat2"/><a data-type="indexterm" data-primary="mobile workflows" data-secondary="continuous testing on parallel devices" data-tertiary="strategy for device testing" id="ch09-strat3"/><a data-type="indexterm" data-primary="smartphone workflows" data-secondary="continuous testing on parallel devices" data-tertiary="strategy for device testing" id="ch09-strat4"/><a data-type="indexterm" data-primary="testing" data-secondary="Android device continuous testing" data-tertiary="strategy for device testing" id="ch09-strat5"/><a data-type="indexterm" data-primary="workflows" data-secondary="mobile workflows" data-tertiary="device-testing strategy" id="ch09-strat6"/> up your own device lab and leveraging cloud infrastructure, you should have a better idea of how these map to your mobile device-testing needs.</p>

<p>These are advantages of going with a cloud service:</p>
<dl>
<dt>Low startup costs</dt>
<dd>
<p>Cloud plans often offer a limited number of free device tests for developers and utilization-based pricing for testing on devices.
When starting out with device testing, this is the easiest and least costly way to begin exploring manual and automated device testing.</p>
</dd>
<dt>Large selection of devices</dt>
<dd>
<p>Since cloud testing providers support a large installed base of customers, they have a huge inventory of current and legacy phones to test against.
This makes it possible to precisely target the device types, profiles, and configurations that your users are most likely to have.</p>
</dd>
<dt>Fast scale-out</dt>
<dd>
<p>App development is all about viral marketing and scaling quickly.
Rather than investing in costly infrastructure up front, cloud services allow you to scale up the testing as the size and popularity of your application requires a larger device test matrix.</p>
</dd>
<dt>Reduced capital expenditures</dt>
<dd>
<p>Building a large device lab is a costly up-front capital expenditure.
By paying as you go for cloud infrastructure, you can delay the costs, maximizing your capital efficiency.</p>
</dd>
<dt>Global access</dt>
<dd>
<p>With remote and distributed teams becoming the norm, clouds by design allow for easy access from your entire team, no matter where they are located.</p>
</dd>
</dl>

<p>However, even given all of these benefits, the traditional approach of building a device lab has unique advantages.
Here are some reasons you may want to build your own device lab:</p>
<dl>
<dt>Reduced cost at scale</dt>
<dd>
<p>The total cost of ownership for a device lab that you run and maintain at scale is much lower than the total monthly costs from a cloud provider over the device’s usable lifetime.
For a small team, this threshold is hard to hit, but if you are a large mobile corporation, this can be significant savings.</p>
</dd>
<dt>Fast and predictable cycle time</dt>
<dd>
<p>With control over the device farm, you can guarantee that the tests will run in parallel and complete in a predictable time frame to enable responsive builds.
Cloud providers have limited device availability and queued wait times for popular configurations that can limit your ability to iterate quickly.</p>
</dd>
<dt>No session limits</dt>
<dd>
<p>Device clouds typically put hardcoded session limits on their service to prevent tests from hanging because of test or device failure.
As the complexity of your test suite grows, a 30-minute hard limit can become an obstacle to completing testing of a complex user flow.</p>
</dd>
<dt>Regulatory requirements</dt>
<dd>
<p>In certain regulated industries such as finance and defense, security requirements can restrict or prohibit the ability to deploy applications and execute tests outside the corporate firewall.
This class of corporations would require an on-premises device lab setup.</p>
</dd>
<dt>IoT device integration</dt>
<dd>
<p>If your use case requires the integration of mobile devices with IoT devices and sensors, this is not a configuration that cloud providers would provide as a service out of the box.
You are probably better off creating a device lab with the IoT and mobile configuration that best matches your real-world scenario.</p>
</dd>
</dl>
<div data-type="tip"><h6>Tip</h6>
<p>In some scenarios, it also makes sense to do a mix of both cloud testing and local device lab testing.
Based on your specific requirements for cycle time, maintenance cost, device scale-out, and regulatory requirements, this can allow you to get the best of both approaches to testing.<a data-type="indexterm" data-startref="ch09-paral" id="idm45310200083888"/><a data-type="indexterm" data-startref="ch09-strat" id="idm45310200083184"/><a data-type="indexterm" data-startref="ch09-strat2" id="idm45310200082512"/><a data-type="indexterm" data-startref="ch09-strat3" id="idm45310200081840"/><a data-type="indexterm" data-startref="ch09-strat4" id="idm45310200081168"/><a data-type="indexterm" data-startref="ch09-strat5" id="idm45310200080496"/><a data-type="indexterm" data-startref="ch09-strat6" id="idm45310200079824"/></p>
</div>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Summary"><div class="sect1" id="idm45310200078896">
<h1>Summary</h1>

<p>Android is the most popular mobile platform on the planet, because of its huge ecosystem of manufacturers and application developers.
However, this is also the challenge with Android development: an incredibly fragmented device market with thousands of manufacturers producing tens of thousands of devices.
Given this scale of fragmentation and device inconsistency, having a fully automated DevOps pipeline for mobile development is a necessity for success.</p>

<p>The equivalent to DevOps for web application development would be if, instead of three major browsers, there were thousands of unique browser types.
You would be forced to automate to obtain any level of quality assurance, which is exactly why there is so much focus in the mobile space on UI test automation running on real devices.</p>

<p>Using the tools and techniques you learned in this chapter, paired with the overall DevOps knowledge on source control, build promotion, and security, you should be ahead of your mobile DevOps peers to face the challenge of continuous deployments to millions of devices globally.</p>
</div></section>







</div></section></div></body></html>