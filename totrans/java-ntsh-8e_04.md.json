["```java\nAccount a = new Account(\"John Smith\", 100, 1144789);\n```", "```java\n/** Represents a point in 2-dimensional space */\npublic record Point(double x, double y) {}\n```", "```java\n// Create a Point object representing (2,-3.5).\n// Declare a variable p and store a reference to the new Point object\nPoint p = new Point(2.0, -3.5);\ndouble x = p.x();                    // Read a field of the object\n```", "```java\npublic class Integer extends Number\n                     implements Serializable, Comparable {\n    // class members go here\n}\n```", "```java\npublic class Circle {\n  // A class field\n  public static final double PI= 3.14159;     // A useful constant\n\n  // A class method: just compute a value based on the arguments\n  public static double radiansToDegrees(double radians) {\n    return radians * 180 / PI;\n  }\n\n  // An instance field\n  public double r;                  // The radius of the circle\n\n  // Two instance methods: operate on an object's instance fields\n\n  // Compute the area of the circle\n  public double area() {\n    return PI * r * r;\n  }\n\n  // Compute the circumference of the circle\n  public double circumference() {\n    return 2 * PI * r;\n  }\n}\n```", "```java\nint x = 1;\nprivate String name;\npublic static final int DAYS_PER_WEEK = 7;\nString[] daynames = new String[DAYS_PER_WEEK];\nprivate int a = 17, b = 37, c = 53;\n```", "```java\npublic static final double PI = 3.14159;\n```", "```java\npublic static double radiansToDegrees(double rads) {\n  return rads * 180 / PI;\n}\n```", "```java\n// How many degrees is 2.0 radians?\ndouble d = Circle.radiansToDegrees(2.0);\n```", "```java\npublic double r;    // The radius of the circle\n```", "```java\nCircle c = new Circle(); // Create a Circle object; store a ref in c\nc.r = 2.0;               // Assign a value to its instance field r\nCircle d = new Circle(); // Create a different Circle object\nd.r = c.r * 2;           // Make this one twice as big\n```", "```java\n// Create a Circle object; store in variable c\nCircle c = new Circle();\nc.r = 2.0;                 // Set an instance field of the object\ndouble a = c.area();       // Invoke an instance method of the object\n```", "```java\npublic double area() { return Circle.PI * this.r * this.r; }\n```", "```java\npublic void setRadius(double r) {\n  this.r = r;      // Assign the argument (r) to the field (this.r)\n                   // Note that writing r = r is a bug\n}\n```", "```java\nCircle c = new Circle();\n```", "```java\npublic class Circle {\n    public static final double PI = 3.14159;  // A constant\n    // An instance field that holds the radius of the circle\n    protected double r;\n\n    // The constructor: initialize the radius field\n    public Circle(double r) { this.r = r; }\n\n    // The instance methods: compute values based on the radius\n    public double circumference() { return 2 * PI * r; }\n    public double area() { return PI * r * r; }\n    public double radius() { return r; }\n}\n```", "```java\nCircle c = new Circle();\nc.r = 0.25;\n```", "```java\nCircle c = new Circle(0.25);\n```", "```java\npublic Circle() { r = 1.0; }\npublic Circle(double r) { this.r = r; }\n```", "```java\n// This is the basic constructor: initialize the radius\npublic Circle(double r) { this.r = r; }\n// This constructor uses this() to invoke the constructor above\npublic Circle() { this(1.0); }\n```", "```java\npublic static final double PI = 3.14159;\npublic double r = 1.0;\n```", "```java\npublic class SampleClass {\n  public int len = 10;\n  public int[] table = new int[len];\n\n  public SampleClass() {\n    for(int i = 0; i < len; i = i + 1) {\n        table[i] = i;\n    }\n  }\n\n  // The rest of the class is omitted...\n}\n```", "```java\npublic SampleClass() {\n  len = 10;\n  table = new int[len];\n  for(int i = 0; i < len; i = i + 1) {\n      table[i] = i;\n  }\n}\n```", "```java\n// We can draw the outline of a circle using trigonometric functions\n// Trigonometry is slow, though, so we precompute a bunch of values\npublic class TrigCircle {\n  // Here are our static lookup tables and their own initializers\n  private static final int NUMPTS = 500;\n  private static double sines[] = new double[NUMPTS];\n  private static double cosines[] = new double[NUMPTS];\n\n  // Here's a static initializer that fills in the arrays\n  static {\n    double x = 0.0;\n    double delta_x = (Circle.PI/2)/(NUMPTS - 1);\n    for(int i = 0, x = 0.0; i < NUMPTS; i = i + 1, x += delta_x) {\n      sines[i] = Math.sin(x);\n      cosines[i] = Math.cos(x);\n    }\n  }\n  // The rest of the class is omitted...\n}\n```", "```java\npublic record Point(double x, double y) {\n    /** Constructor simulates default parameters */\n    public Point(double x) {\n        this(x, 0.0);\n    }\n}\n```", "```java\n/** Represents a point in 2-dimensional space */\npublic record Point(double x, double y) {\n    /** Compact constructor provides validation */\n    public Point {\n        if (Double.isNaN(x) || Double.isNaN(y)) {\n            throw new IllegalArgumentException(\"Illegal NaN\");\n        }\n    }\n}\n```", "```java\npublic class PlaneCircle extends Circle {\n  // We automatically inherit the fields and methods of Circle,\n  // so we only have to put the new stuff here.\n  // New instance fields that store the center point of the circle\n  private final double cx, cy;\n\n  // A new constructor to initialize the new fields\n  // It uses a special syntax to invoke the Circle() constructor\n  public PlaneCircle(double r, double x, double y) {\n    super(r);       // Invoke the constructor of the superclass, Circle()\n    this.cx = x;    // Initialize the instance field cx\n    this.cy = y;    // Initialize the instance field cy\n  }\n\n  public double getCenterX() {\n    return cx;\n  }\n\n  public double getCenterY() {\n    return cy;\n  }\n\n  // The area() and circumference() methods are inherited from Circle\n  // A new instance method checks whether a point is inside the circle\n  // Note that it uses the inherited instance field r\n  public boolean isInside(double x, double y) {\n    double dx = x - cx, dy = y - cy;             // Distance from center\n    double distance = Math.sqrt(dx*dx + dy*dy);  // Pythagorean theorem\n    return (distance < r);                       // Returns true or false\n  }\n}\n```", "```java\ndouble ratio = pc.circumference() / pc.area();\n```", "```java\n// Unit circle at the origin\nPlaneCircle pc = new PlaneCircle(1.0, 0.0, 0.0);\nCircle c = pc;     // Assigned to a Circle variable without casting\n```", "```java\n// Narrowing conversions require a cast (and a runtime check by the VM)\nPlaneCircle pc2 = (PlaneCircle) c;\nboolean inside = ((PlaneCircle) c).isInside(0.0, 0.0);\n```", "```java\npublic class PlaneCircle extends Circle { ... }\n```", "```java\npublic PlaneCircle(double r, double x, double y) {\n  super(r);       // Invoke the constructor of the superclass, Circle()\n  this.cx = x;    // Initialize the instance field cx\n  this.cy = y;    // Initialize the instance field cy\n}\n```", "```java\npublic PlaneCircle() { super(); }\n```", "```java\npublic double r;\n```", "```java\nthis.r = Math.sqrt(cx*cx + cy*cy);  // Pythagorean theorem\n```", "```java\nr        // Refers to the PlaneCircle field\nthis.r   // Refers to the PlaneCircle field\nsuper.r  // Refers to the Circle field\n```", "```java\n((Circle) this).r   // Refers to field r of the Circle class\n```", "```java\nx                // Field x in class C\nthis.x           // Field x in class C\nsuper.x          // Field x in class B\n((B)this).x      // Field x in class B\n((A)this).x      // Field x in class A\nsuper.super.x    // Illegal; does not refer to x in class A\n```", "```java\nc.x              // Field x of class C\n((B)c).x         // Field x of class B\n((A)c).x         // Field x of class A\n```", "```java\npublic static final double PI = 3.14159265358979323846;\n```", "```java\npublic class Car {\n    public static final double LITRE_PER_100KM = 8.9;\n\n    protected double topSpeed;\n\n    protected double fuelTankCapacity;\n\n    private int doors;\n\n    public Car(double topSpeed, double fuelTankCapacity, \n               int doors) {\n        this.topSpeed = topSpeed;\n        this.fuelTankCapacity = fuelTankCapacity;\n        this.doors = doors;\n    }\n\n    public double getTopSpeed() {\n        return topSpeed;\n    }\n\n    public int getDoors() {\n        return doors;\n    }\n\n    public double getFuelTankCapacity() {\n        return fuelTankCapacity;\n    }\n\n    public double range() {\n        return 100 * fuelTankCapacity / LITRE_PER_100KM;\n    }\n}\n```", "```java\npublic class SportsCar extends Car {\n\n    private double efficiency;\n\n    public SportsCar(double topSpeed) {\n        super(topSpeed, 50.0, 2);\n        if (topSpeed > 200.0) {\n            efficiency = 200.0 / topSpeed;\n        } else {\n            efficiency = 1.0;\n        }\n    }\n\n    public double getEfficiency() {\n        return efficiency;\n    }\n\n    @Override\n    public double range() {\n        return 100 * fuelTankCapacity * efficiency / LITRE_PER_100KM;\n    }\n\n}\n```", "```java\nclass A {                          // Define a class named A\n  int i = 1;                       // An instance field\n  int f() { return i; }            // An instance method\n  static char g() { return 'A'; }  // A class method\n}\n\nclass B extends A {                // Define a subclass of A\n  int i = 2;                       // Hides field i in class A\n  int f() { return -i; }           // Overrides method f in class A\n  static char g() { return 'B'; }  // Hides class method g() in class A\n}\n\npublic class OverrideTest {\n  public static void main(String args[]) {\n    B b = new B();               // Creates a new object of type B\n    System.out.println(b.i);     // Refers to B.i; prints 2\n    System.out.println(b.f());   // Refers to B.f(); prints -2\n    System.out.println(b.g());   // Refers to B.g(); prints B\n    System.out.println(B.g());   // A better way to invoke B.g()\n\n    A a = (A) b;                 // Casts b to an instance of class A\n    System.out.println(a.i);     // Now refers to A.i; prints 1\n    System.out.println(a.f());   // Still refers to B.f(); prints -2\n    System.out.println(a.g());   // Refers to A.g(); prints A\n    System.out.println(A.g());   // A better way to invoke A.g()\n  }\n}\n```", "```java\nclass A {\n  int i = 1;            // An instance field hidden by subclass B\n  int f() { return i; } // An instance method overridden by subclass B\n}\n\nclass B extends A {\n  int i;                    // This field hides i in A\n  int f() {                 // This method overrides f() in A\n    i = super.i + 1;        // It can retrieve A.i like this\n    return super.f() + i;   // It can invoke A.f() like this\n  }\n}\n```", "```java\n// In Shape.java\npublic abstract sealed class Shape permits Circle, Triangle {\n    // ...\n}\n\n// In Circle.java\npublic final class Circle extends Shape {\n    // ...\n}\n\n// In Triangle.java\npublic final class Triangle extends Shape {\n    // ...\n}\n```", "```java\npublic class Laundromat {    // People can use this class.\n  private Laundry[] dirty;   // They cannot use this internal field,\n  public void wash() { ... } // but they can use these public methods\n  public void dry() { ... }  // to manipulate the internal field.\n  // A subclass might want to tweak this field\n  protected int temperature;\n}\n```", "```java\npackage javanut8.ch03;\n\npublic class A {\n    protected final String name;\n\n    public A(String named) {\n        name = named;\n    }\n\n    public String getName() {\n        return name;\n    }\n}\n```", "```java\npackage javanut8.ch03.different;\n\nimport javanut8.ch03.A;\n\npublic class B extends A {\n\n    public B(String named) {\n        super(named);\n    }\n\n    @Override\n    public String getName() {\n        return \"B: \" + name;\n    }\n}\n```", "```java\n    public String examine(A a) {\n        return \"B sees: \" + a.name;\n    }\n```", "```java\n    public String examine(B b) {\n        return \"B sees another B: \" + b.name;\n    }\n```", "```java\npackage javanut8.ch03.shapes; // Specify a package for the class\n\npublic class Circle {     // The class is still public\n    // This is a generally useful constant, so we keep it public\n    public static final double PI = 3.14159;\n\n    protected double r;     // Radius is hidden but visible to subclasses\n\n    // A method to enforce the restriction on the radius\n    // Subclasses may be interested in this implementation detail\n    protected void checkRadius(double radius) {\n        if (radius < 0.0)\n            throw new IllegalArgumentException(\"illegal negative radius\");\n    }\n\n    // The non-default constructor\n    public Circle(double r) {\n        checkRadius(r);\n        this.r = r;\n    }\n\n    // Public data accessor methods\n    public double getRadius() { return r; }\n    public void setRadius(double r) {\n        checkRadius(r);\n        this.r = r;\n    }\n\n    // Methods to operate on the instance field\n    public double area() { return PI * r * r; }\n    public double circumference() { return 2 * PI * r; }\n}\n```", "```java\npublic abstract class Shape {\n    public abstract double area();            // Abstract methods: note\n    public abstract double circumference();   // semicolon instead of body.\n}\n\npublic class Rectangle extends Shape {\n    // Instance data\n    protected double w, h;\n\n    // Constructor \n    public Rectangle(double w, double h) {               \n        this.w = w;  this.h = h;\n    }\n\n    // Accessor methods\n    public double getWidth() { return w; }               \n    public double getHeight() { return h; }\n\n    // Implementation of abstract methods \n    public double area() { return w*h; }                 \n    public double circumference() { return 2*(w + h); }   \n}\n```", "```java\nShape[] shapes = new Shape[3];        // Create an array to hold shapes\nshapes[0] = new Circle(2.0);          // Fill in the array\nshapes[1] = new Rectangle(1.0, 3.0);\nshapes[2] = new Rectangle(4.0, 2.0);\n\ndouble totalArea = 0;\nfor(int i = 0; i < shapes.length; i++) {\n    totalArea += shapes[i].area();   // Compute the area of the shapes\n}\n```", "```java\n    Object o = \"string\";    // Widening conversion from String\n                            // to Object later in the program...\n    String s = (String) o;  // Narrowing conversion from Object\n                            // to String\n    ```", "```java\n// Widening conversion from array to Object\nObject o = new int[] {1,2,3};\n// Later in the program...\n\nint[] a = (int[]) o;      // Narrowing conversion back to array type\n```", "```java\n// Here is an array of strings.\nString[] strings = new String[] { \"hi\", \"there\" };\n// A widening conversion to CharSequence[] is allowed because String\n// can be widened to CharSequence\nCharSequence[] sequences = strings;\n// The narrowing conversion back to String[] requires a cast.\nstrings = (String[]) sequences;\n\n// This is an array of arrays of strings\nString[][] s = new String[][] { strings };\n// It cannot be converted to CharSequence[] because String[] cannot be\n// converted to CharSequence: the number of dimensions don't match\n\nsequences = s;  // This line will not compile\n// s can be converted to Object or Object[], because all array types\n// (including String[] and String[][]) can be converted to Object.\nObject[] objects = s;\n```", "```java\n// Can't convert int[] to double[] even though\n// int can be widened to double\n// This line causes a compilation error\ndouble[] data = new int[] {1,2,3};\n// This line is legal, however,\n// because int[] can be converted to Object\nObject[] objects = new int[][] {{1,2},{3,4}};\n```"]