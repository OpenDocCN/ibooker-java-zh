- en: Chapter 22\. Classes to Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 22 章。从类到函数
- en: Object-oriented programmers are adept at solving problems by creating types.
    Functional programmers tend to augment existing types with functions. How far
    can we go without defining new types?
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 面向对象的程序员擅长通过创建类型来解决问题。而函数式程序员则倾向于使用函数来增强现有类型。在不定义新类型的情况下，我们能走多远呢？
- en: In [Chapter 15, *Encapsulated Collections to Type Aliases*](ch15.html#encapsulated-collections-to-typealiases),
    we saw the advantages of working with raw collections, and in [Chapter 16, *Interfaces
    to Functions*](ch16.html#interfaces-to-functions), we looked at using built-in
    function types rather than creating new ones. In this chapter, we’ll apply the
    lessons we’ve learned to write some Kotlin from scratch.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 15 章，《封装集合到类型别名》](ch15.html#encapsulated-collections-to-typealiases) 中，我们看到使用原始集合的优势，在
    [第 16 章，《接口到函数》](ch16.html#interfaces-to-functions) 中，我们探讨了使用内置函数类型而不是创建新类型。在本章中，我们将应用我们学到的经验，从头开始编写一些
    Kotlin 代码。
- en: Even in these days of REST APIs and webhooks, much of automatic business-to-business
    communication is in the form of tabular text data exchanged by Secure File Transfer
    Protocol (SFTP). Travelator has to import data for campsite locations, points
    of interest, unsettled bills, and more, all in regular rows and columns, with
    different column separators, and with and without a header naming the columns
    for the remaining rows. In [Chapter 20](ch20.html#performing-io-to-passing-data),
    we saw that one team had created its own parser; in other places, we use the tried-and-trusted
    [Apache Commons CSV library](https://oreil.ly/jnI4h). Honestly, for most uses,
    we would still use Commons CSV, because it works out of the box, is nicely configurable
    for special cases, and plays really well with Kotlin.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在如今的 REST API 和 Webhooks 的时代，许多自动化的企业间通信仍然以通过安全文件传输协议（SFTP）交换的表格式文本数据形式存在。Travelator
    必须导入关于营地位置、景点、未解决的账单等数据，这些数据通常以常规的行和列形式存在，使用不同的列分隔符，并且有时候有表头来命名其余的行。在 [第 20 章](ch20.html#performing-io-to-passing-data)
    中，我们看到一个团队已经创建了自己的解析器；在其他地方，我们使用了备受信赖的 [Apache Commons CSV 库](https://oreil.ly/jnI4h)。老实说，对于大多数情况，我们仍然会使用
    Commons CSV，因为它可以直接使用，对特殊情况进行了很好的配置，并且与 Kotlin 非常兼容。
- en: Today though we’re going to see what a clean-room Kotlin parser would look like.
    When we’re done, we’ll compare what we come up with to the Commons CSV functionality
    so that we can see how the grains of Java and Kotlin lead to different APIs and
    implementations.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 今天我们要看看一个干净的 Kotlin 解析器会是什么样子。完成后，我们将比较我们的成果与 Commons CSV 的功能，以便看到 Java 和 Kotlin
    的差异 API 和实现。
- en: An Acceptance Test
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个验收测试
- en: 'As you might have been able to tell from the preceding chapters, the Travelator
    developers are Extreme Programmers ([*Extreme Programming Explained: Embrace Change*](bibliography01.html#B_EPEEC_1999)).
    We write code test first, starting with a high-level acceptance test. We’re working
    on a table reader, so we create a class `TableReaderAcceptanceTests` with a stub
    method and check that it runs:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能从前面的章节中看到的那样，Travelator 的开发人员是极限编程者（[*《极限编程解密：拥抱变化》*](bibliography01.html#B_EPEEC_1999)）。我们先编写测试，从高级别的验收测试开始。我们正在处理一个表格阅读器，因此我们创建了一个名为
    `TableReaderAcceptanceTests` 的类，并添加了一个存根方法，然后检查它是否运行：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[Example 22.1 [table-reader.1:src/test/java/travelator/tablereader/TableReaderAcceptanceTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.1&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.1&show=diff)'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.1 [table-reader.1:src/test/java/travelator/tablereader/TableReaderAcceptanceTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.1&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=22.1&show=diff)'
- en: It does run (it even passes!), so now we can start coding proper.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 它确实运行了（甚至通过了测试！），现在我们可以开始编写真正的代码了。
- en: 'Part of the acceptance test’s job is to help us decide what our interface should
    look like. Having parsed a few files in our time, we know that what we almost
    always want to do is read a file and return a list of values of some domain type,
    one for each (nonheader) row. Let’s sketch that as our test, with `Measurement`
    as our domain type:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 验收测试的一部分工作是帮助我们决定接口应该是什么样子。在解析了一些文件后，我们知道我们几乎总是希望做的事情是读取文件并返回某种域类型的值列表，每个（非表头）行一个。让我们将其草拟为我们的测试，以
    `Measurement` 作为我们的域类型：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[Example 22.2 [table-reader.2:src/test/java/travelator/tablereader/TableReaderAcceptanceTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.2&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.2&show=diff)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.2 [table-reader.2:src/test/java/travelator/tablereader/TableReaderAcceptanceTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.2&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=22.2&show=diff)'
- en: 'Here `Measurement` is a value type that represents the data that we want to
    extract from each row of the table. In Java, we would probably start by creating
    a `TableReader` class, but we can see from the test that reading a table is simply
    a calculation: a mapping of the input lines to a list of the data that we want
    ([“Calculations”](ch07.html#calculations)). So we’ll default to using a top-level
    `someFunction` until we are forced to do something more complicated.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`Measurement`是一个值类型，代表我们要从每行表中提取的数据。在Java中，我们可能会从创建`TableReader`类开始，但是从测试中我们可以看出，读取表只是一个计算：将输入行映射到我们想要的数据列表（[“Calculations”](ch07.html#calculations)）。因此，我们将默认使用顶层的`someFunction`，直到我们被迫做出更复杂的事情。
- en: We can imagine all sorts of magic ways that our API could implement `someFunction`,
    but unless it has some special knowledge of the `Measurement` type (and libraries
    don’t have knowledge of *our* types, that’s the wrong way around), we will have
    to tell it how to map from some representation of a row to a `Measurement`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以想象各种神奇的方式来实现我们的API如何执行`someFunction`，但是除非它对`Measurement`类型有特殊的了解（而库不了解*我们*的类型，这是反过来的错误方法），否则我们将不得不告诉它如何从行的某种表示映射到`Measurement`。
- en: That’s twice we’ve used the word *map*. Maybe *map* holds the key? (An accidental
    pun, that one.) What if `someFunction` looked like this?
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们第二次使用单词*map*了。也许*map*是关键？（一个偶然的双关语。）如果`someFunction`看起来像这样会怎么样？
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[Example 22.3 [table-reader.3:src/test/java/travelator/tablereader/TableReaderAcceptanceTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.3&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.3&show=diff)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.3 [table-reader.3:src/test/java/travelator/tablereader/TableReaderAcceptanceTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.3&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=22.3&show=diff)'
- en: '[![1](assets/1.png)](#co_introduction_CO49-1)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_introduction_CO49-1)'
- en: '`readTable` is our table reading API entry point'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`readTable`是我们的表读取API入口点'
- en: '[![2](assets/2.png)](#co_introduction_CO49-2)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_introduction_CO49-2)'
- en: It returns something that has a `map` implementation.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回一个具有`map`实现的东西。
- en: '[![3](assets/3.png)](#co_introduction_CO49-3)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_introduction_CO49-3)'
- en: '`record` is our representation of a row in the table.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`record`是我们在表中表示一行的数据。'
- en: '[![4](assets/4.png)](#co_introduction_CO49-4)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_introduction_CO49-4)'
- en: We can index into `record` by field name, yielding a `String` that we can convert
    to other types.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过字段名索引`record`，得到一个`String`，然后我们可以将其转换为其他类型。
- en: 'This doesn’t compile, because we don’t have `readTable` yet, but if we Alt-Enter
    on the error, IntelliJ will create the function for us:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码无法编译，因为我们还没有实现`readTable`，但是如果我们在错误上按Alt-Enter，IntelliJ会为我们创建这个函数：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[Example 22.4 [table-reader.3:src/test/java/travelator/tablereader/TableReaderAcceptanceTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.4&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.4&show=diff)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.4 [table-reader.3:src/test/java/travelator/tablereader/TableReaderAcceptanceTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.4&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=22.4&show=diff)'
- en: 'We haven’t given IntelliJ enough clues about the return type of `readTable`,
    so it chose `Any`, and so `someFunction` still doesn’t compile. What type could
    we return to fix that? Well, if we return a `List` from `readTable`, then `map`
    is an operation on `List`. And if that `List` contained `Map<String, String>`,
    our `record` variable would be `Map<String, String>`, so we could call `record["time"]`,
    and so on. The only issue is that `Map.get` returns a nullable value. That’s close
    enough—let’s take account of it in `someFunction` by raising errors if `get` returns
    `null`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有给 IntelliJ 足够的关于`readTable`返回类型的线索，所以它选择了`Any`，因此`someFunction`仍然无法编译通过。我们能返回什么类型来解决这个问题呢？如果我们从`readTable`返回一个`List`，那么`map`就是`List`的一个操作。如果这个`List`包含`Map<String,
    String>`，那么我们的`record`变量就会是`Map<String, String>`，这样我们就可以调用`record["time"]`等操作。唯一的问题是`Map.get`返回一个可空值。这已经足够接近了——在`someFunction`中，我们可以通过在`get`返回`null`时引发错误来处理它：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[Example 22.5 [table-reader.4:src/test/java/travelator/tablereader/TableReaderAcceptanceTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.5&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.5&show=diff)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.5 [table-reader.4:src/test/java/travelator/tablereader/TableReaderAcceptanceTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.5&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=22.5&show=diff)'
- en: 'This compiles, although obviously the `TODO` fails the test. (You might ask
    why we are taking such a cavalier attitude toward errors compared to our forensic
    [Chapter 21](ch21.html#exceptions-to-values). The answer is that this is just
    test code: the API of `Map.get` is forcing us to consider what to do in the case
    of errors, and our test is choosing to throw.)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这编译通过了，尽管显然`TODO`未通过测试。（你可能会问为什么我们对错误采取这种鲁莽的态度，与我们的法医[第21章](ch21.html#exceptions-to-values)相比。答案是这只是测试代码：`Map.get`的API正在迫使我们考虑在错误情况下该怎么做，而我们的测试选择抛出。）
- en: 'We put our client hats on to write the acceptance tests, and these tests have
    shown that we can at least use a function with the signature of `readTable` to
    convert lines to a list of `Measurement`. Now that we have a plausible API, we
    can move the definition of `readTable` into *src/main/travelator/tablereader/table-reading.kt*:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们戴上客户的帽子来编写验收测试，这些测试显示我们至少可以使用`readTable`函数的签名将行转换为`Measurement`列表。现在我们有了一个合理的API，我们可以将`readTable`的定义移到*src/main/travelator/tablereader/table-reading.kt*中：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[Example 22.6 [table-reader.5:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.6&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.6&show=diff)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.6 [table-reader.5:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.6&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.6&show=diff)'
- en: 'Finally in this first stage, we can inline `someFunction` to give our acceptance
    test:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在这个第一阶段中，我们可以内联`someFunction`以提供我们的验收测试：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[Example 22.7 [table-reader.5:src/test/java/travelator/tablereader/TableReaderAcceptanceTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.7&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.7&show=diff)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.7 [table-reader.5:src/test/java/travelator/tablereader/TableReaderAcceptanceTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.7&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.7&show=diff)'
- en: Note that we have disabled the test because it will be some time before we get
    it running. That’s OK with acceptance tests. We don’t expect to get them to pass
    quickly, more tell us when we are done. For now, it has done its job, helping
    us sketch a simple API that we can now implement.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已经禁用了这个测试，因为在让它运行之前还需要一些时间。对于验收测试来说这没问题。我们不指望很快通过它们，更多的是告诉我们何时完成。目前，它已经完成了它的工作，帮助我们勾画出一个简单的API，现在我们可以实现它了。
- en: Before we do go on, let’s reflect on the fact that we have managed to define
    the interface to our parser without defining any new types, instead using `List`
    and `Map` of `String`. By using standard types, we know that we have rich Kotlin
    APIs to supply the `List` that we are reading from, and to interpret the `List`
    of `Map`s that we are returning.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们反思一下，我们成功定义了解析器的接口，而没有定义任何新的类型，而是使用了`String`的`List`和`Map`。通过使用标准类型，我们知道我们有丰富的
    Kotlin API 来提供我们正在读取的`List`，并解释我们正在返回的`Map`的`List`。
- en: Unit Testing
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'Now that we have an interface to implement, we can park the acceptance test
    and write a minimal unit test. What is minimal? We like to start with empty: what
    should happen if we read an empty file?'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个要实现的接口，我们可以停止验收测试并编写一个最小的单元测试。什么是最小的？我们喜欢从空白开始：如果我们读取一个空文件会发生什么？
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[Example 22.8 [table-reader.6:src/test/java/travelator/tablereader/TableReaderTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.8&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.8&show=diff)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.8 [table-reader.6:src/test/java/travelator/tablereader/TableReaderTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.8&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.8&show=diff)'
- en: 'The simplest way to get this to pass is to hard-code the result in `readTable`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让`readTable`返回预设结果是通过的最简单方法：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[Example 22.9 [table-reader.7:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.9&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.9&show=diff)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.9 [table-reader.7:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.9&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.9&show=diff)'
- en: This passes. It may seem trivial, but it’s always a good idea to have a test
    for empty input. The more complicated our algorithm, the more likely it is to
    fail in this case. It’s a poor parser that always returns an empty result, though,
    so let’s crack on. Following TDD ([*Test-Driven Development By Example*](bibliography01.html#B_TDDBE_2002)),
    we need to add a failing test first to give us a reason to change the implementation.
    We choose to add the case of reading a table with no header and one line of data.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步通过了。看起来可能微不足道，但是为了空输入编写一个测试总是一个好主意。我们的算法越复杂，它在这种情况下失败的可能性就越大。然而，总是返回空结果的解析器是不好的，所以让我们继续前进。遵循
    TDD（[*通过示例驱动开发*](bibliography01.html#B_TDDBE_2002)），我们首先需要添加一个失败的测试来给我们改变实现的理由。我们选择添加读取没有标题行但有一行数据的表格的情况。
- en: 'Why this rather than a header and one line of data? To be honest, this is just
    the first thing that came to mind; maybe if we were actually pairing at this point,
    you would have suggested using a header row. Our choice leaves us having to decide
    how to name the columns, and we decide to use the `String` representation of their
    index, `"0"` for the first column, `"1"` for the second, and so on; this feels
    like the simplest way that we can generate a `String` key:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要这样做，而不是使用标题和一行数据呢？坦率地说，这只是我脑海中的第一件事；也许如果我们真的在这个时候一起工作，你会建议使用标题行。我们的选择让我们不得不决定如何命名列，并且我们决定使用它们的索引的
    `String` 表示，第一列为 `"0"`，第二列为 `"1"`，以此类推；这感觉是我们生成 `String` 键的最简单方法：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[Example 22.10 [table-reader.8:src/test/java/travelator/tablereader/TableReaderTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.10&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.10&show=diff)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.10 [table-reader.8:src/test/java/travelator/tablereader/TableReaderTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.10&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.10&show=diff)'
- en: We *could* instead have made `readTable` return `<Map<Int, String>>` when we
    don’t have a header row. If you have some spare time, that might be a path worth
    following to see where it leads.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们*可以*选择在没有标题行时使 `readTable` 返回 `<Map<Int, String>>`。如果你有空闲时间，这可能是一个值得探索的路径。
- en: 'Back in our current predicament, we have a failing test, and we can be clever
    or we can be quick. We choose quick, to get the test passing straightaway by hardcoding
    the result again:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们当前的困境，我们有一个失败的测试，我们可以聪明地处理，也可以快速解决。我们选择快速方式，通过再次硬编码结果直接使测试通过：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[Example 22.11 [table-reader.8:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.11&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.11&show=diff)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.11 [table-reader.8:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.11&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.11&show=diff)'
- en: 'Now that our tests are passing, we can simplify the implementation by noticing
    that we want a line in the output for every line in the input. `Iterable::map`
    will do this, allowing us to remove the `if` expression:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的测试通过了，我们可以通过注意到我们希望输出的每一行与输入的每一行对应来简化实现。`Iterable::map` 可以做到这一点，使我们可以移除
    `if` 表达式：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[Example 22.12 [table-reader.9:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.12&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.12&show=diff)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.12 [table-reader.9:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.12&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.12&show=diff)'
- en: 'This continues to pass the tests and would now work for more lines (of identical
    data)! It’s only a stepping-stone though, allowing us to extract the lambda as
    a function:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这样继续通过测试，并且现在可以处理更多行（相同的数据）！但这只是一个过渡阶段，允许我们将 lambda 提取为一个函数：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[Example 22.13 [table-reader.10:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.13&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.13&show=diff)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.13 [table-reader.10:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.13&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.13&show=diff)'
- en: 'Now we’ll start removing the hard-coded values by splitting the pairs into
    `keys` and `values`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将通过将键值对分为 `keys` 和 `values` 来开始移除硬编码的值：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[Example 22.14 [table-reader.11:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.14&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.14&show=diff)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.14 [table-reader.11:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.14&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.14&show=diff)'
- en: 'We’re still resolutely cheating, but we can now see the pattern in the `keys`
    and generate these from the `values`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然在坚定地作弊，但是现在我们可以看到`keys`中的模式，并从`values`中生成这些：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[Example 22.15 [table-reader.12:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.15&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.15&show=diff)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.15 [table-reader.12:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.15&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=22.15&show=diff)'
- en: 'For the `values`, we can split the line around the commas:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`values`，我们可以将行按逗号分割：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[Example 22.16 [table-reader.13:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.16&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.16&show=diff)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.16 [table-reader.13:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.16&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=22.16&show=diff)'
- en: 'Success: we have removed the hard-coded keys and values, and the tests still
    pass. Because we used `lines.map` in `readTable`, we believe the function will
    work for any numbers of lines, but it would be good to have a test to confirm
    that.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 成功：我们已经移除了硬编码的键和值，测试仍然通过。因为我们在`readTable`中使用了`lines.map`，我们相信该函数对任意数量的行都有效，但最好有一个测试来确认这一点。
- en: We make a note to add it, because something is bothering us that we’d like to
    look at first. If you are as old as your authors (or younger and gifted) you may
    have developed spidey senses for code, and they may be tingling when you look
    at that `split`. What will happen if we try to split an empty line? For that matter,
    what should `readTable` return when fed an empty line?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做个笔记，因为有些东西让我们感到不安，我们想先看一下。如果你和作者一样老（或更年轻且有天赋），你可能已经对代码产生了直觉，当你看到那个`split`时，它可能会让你感到不安。如果我们试图分割一个空行会发生什么？实际上，当`readTable`读取到一个空行时应该返回什么？
- en: 'Discussing it, we come to the conclusion that an empty line should yield an
    empty `Map`. That feels clean, so we write a test to both document our decision
    and check that it works:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论之后，我们得出结论，一个空行应该返回一个空的`Map`。这感觉很清晰，所以我们编写了一个测试来记录我们的决定并验证它是否有效：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[Example 22.17 [table-reader.14:src/test/java/travelator/tablereader/TableReaderTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.17&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.17&show=diff)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.17 [table-reader.14:src/test/java/travelator/tablereader/TableReaderTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.17&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=22.17&show=diff)'
- en: Aha!
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 啊哈！
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After a little investigation, we discover that calling `split` on an empty
    `String` returns a `List` of a single empty `String`. Maybe that makes sense in
    other circumstances. Maybe, but it messes up our algorithm, so we have to work
    around it with a special case in `parseLine`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在一番调查之后，我们发现在空`String`上调用`split`会返回一个单个空`String`的`List`。也许在其他情况下这是有道理的。也许是这样，但这混乱了我们的算法，所以我们不得不在`parseLine`中特别处理：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[Example 22.18 [table-reader.14:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.18&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.18&show=diff)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.18 [table-reader.14:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.18&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=22.18&show=diff)'
- en: 'That gets the tests passing but muddies the waters of the `parseLine` function.
    So we extract the muddy line to a function called `splitFields`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这样测试通过了，但是让`parseLine`函数变得混乱了。所以我们将混乱的部分提取到了一个名为`splitFields`的函数中：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[Example 22.19 [table-reader.15:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.19&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.19&show=diff)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.19 [table-reader.15:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.19&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=22.19&show=diff)'
- en: 'If we make `splitFields` an extension function and introduce a `separators`
    parameter, we get the function we always really wanted `split` to be:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`splitFields`作为扩展函数，并引入一个`separators`参数，我们就得到了我们真正想要`split`成为的函数：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[Example 22.20 [table-reader.16:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.20&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.20&show=diff)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.20 [table-reader.16:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.20&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=22.20&show=diff)'
- en: 'So far, we have gotten the code working with an empty input and then an input
    of a single line. If we had written an imperative solution, we might now have
    to add a loop to handle more input, but `map` has our back, because it will always
    return as many items as we give it. We believe that `readTable` should work for
    all the numbers known to programmers: 0, 1, and infinity (well, OK, 2^(31) - 1
    rather than actual infinity).'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使代码能够处理空输入和单行输入。如果我们编写了一个命令式解决方案，现在可能必须添加一个循环来处理更多输入，但 `map` 已经为我们做好了，因为它将始终返回与我们给它的一样多的项目。我们相信
    `readTable` 应该适用于程序员已知的所有数字：0、1 和无穷大（好吧，好吧，不是实际的无穷大而是 2^(31) - 1）。
- en: '“Trust but verify” they say though, so we add a test:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: “信任但验证”他们说，所以我们添加了一个测试：
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[Example 22.21 [table-reader.17:src/test/java/travelator/tablereader/TableReaderTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.21&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.21&show=diff)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.21 [table-reader.17:src/test/java/travelator/tablereader/TableReaderTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.21&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=22.21&show=diff)'
- en: It passes, and we reason that `(0, 1, 2)` is close enough to `(0, 1, 2147483647)`
    that we are done for now. This seems like a good place to check in, make a fresh
    coffee, and dispose of the last one before getting back to work.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过了，我们推断 `(0, 1, 2)` 接近于 `(0, 1, 2147483647)`，所以我们暂时完成了。这似乎是一个检查点，可以去喝杯新鲜咖啡，然后处理掉上一杯咖啡，继续工作了。
- en: Headers
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 头部
- en: Ready to go again? OK, what about a header line?
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好再次启动了吗？好的，头部行呢？
- en: First, how should our API know to expect one? We could add a flag to `readTable`
    to tell it that our data has a header, or we can add another function. Generally
    we prefer a different function for different functionality, so let’s add a function
    named `readTableWithHeader`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们的 API 应该如何知道要期望一个头部？我们可以在 `readTable` 中添加一个标志来告诉它我们的数据有一个头部，或者我们可以添加另一个函数。通常我们更喜欢为不同的功能添加不同的函数，所以让我们添加一个名为
    `readTableWithHeader` 的函数。
- en: 'As with `readTable`, we first add a test that calls the function that we wish
    we had:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `readTable` 一样，我们首先添加一个调用我们希望有的函数的测试：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[Example 22.22 [table-reader.18:src/test/java/travelator/tablereader/TableReaderTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.22&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.22&show=diff)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.22 [table-reader.18:src/test/java/travelator/tablereader/TableReaderTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.22&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=22.22&show=diff)'
- en: 'Alt-Enter on the compilation error at `readTableWithHeader` and IntelliJ will
    create it for us. Then we can name the parameters and delegate to our original
    function for now:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `readTableWithHeader` 上的编译错误上按 Alt-Enter，IntelliJ 将为我们创建它。然后我们现在可以命名参数并委托给我们的原始函数：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[Example 22.23 [table-reader.18:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.23&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.23&show=diff)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.23 [table-reader.18:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.23&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=22.23&show=diff)'
- en: 'This compiles but fails the tests, as we expect:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个编译了，但是测试失败了，正如我们所预料的：
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: To get the tests to pass, we could hard-code the result as before, but this
    time we’re going to modify the code to make room for the functionality. When we
    say *make room*, what we are aiming for is code that does the current thing (using
    `Int::toString` field names) and which we are able to *augment* rather than modify
    to support the new functionality. The new feature will then be an addition *rather*
    than a modification (the [open–closed principle](https://oreil.ly/MwO5l)).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要使测试通过，我们可以像以前一样硬编码结果，但这次我们将修改代码以为功能留出空间。当我们说 *留出空间* 时，我们的目标是编写当前代码（使用 `Int::toString`
    字段名称）并且我们能够 *扩展* 而不是修改以支持新功能。然后，新功能将是一个添加 *而不是* 修改（[开闭原则](https://oreil.ly/MwO5l)）。
- en: 'Currently, the field name information is buried in `parseLine`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，字段名信息被深埋在 `parseLine` 中：
- en: '[PRE25]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[Example 22.24 [table-reader.18:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.24&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.24&show=diff)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.24 [table-reader.18:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.24&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=22.24&show=diff)'
- en: We’re going to pull it out from here to a place where we can use the header
    line to supply it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其从这里提取到一个我们可以使用头部行来提供的地方。
- en: '`Int::toString` is our current mapping from index to key. Let’s prepare to
    make this configurable by introducing a variable named `headerProvider`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`Int::toString` 是我们从索引到键的当前映射。让我们准备通过引入一个名为 `headerProvider` 的变量来使其可配置：'
- en: '[PRE26]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[Example 22.25 [table-reader.19:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.25&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.25&show=diff)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.25 [table-reader.19:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.25&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.25&show=diff)'
- en: This still passes our tests, except for the new `takes headers from header line`,
    which is still failing. We shouldn’t really be refactoring with a failing test,
    because every time we run the tests, we will have to check that any failure is
    actually the one we expect. So we `@Disabled` it for now to only run tests for
    completed features while we are refactoring.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的测试仍然通过，但新的`takes headers from header line`仍然失败。我们真的不应该在测试失败时进行重构，因为每次运行测试时，我们都必须检查任何失败是否确实是我们期望的失败。所以我们暂时将其`@Disabled`，仅在重构完成的功能上运行测试。
- en: '“Introduce Parameter” on the `headerProvider` line and naming it `headerProvider`
    will allow us to support different behaviors:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在`headerProvider`行上“引入参数”，并将其命名为`headerProvider`，将允许我们支持不同的行为：
- en: '[PRE27]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[Example 22.26 [table-reader.20:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.26&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.26&show=diff)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.26 [table-reader.20:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.26&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.26&show=diff)'
- en: 'Unfortunately, IntelliJ currently fails to make this refactor work, breaking
    `readTable`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，IntelliJ 目前无法使此重构生效，导致`readTable`出现问题：
- en: '[PRE28]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[Example 22.27 [table-reader.20:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.27&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.27&show=diff)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.27 [table-reader.20:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.27&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.27&show=diff)'
- en: '[![1](assets/1.png)](#co_introduction_CO50-1)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_introduction_CO50-1)'
- en: We could use the function reference when `parseLine` only had one parameter.
    Now it needs two arguments, but `map` can only supply one.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前可以在`parseLine`只有一个参数时使用函数引用。现在它需要两个参数，但`map`只能提供一个。
- en: '“Replace function reference with lambda” *before* the refactor would have made
    everything work now, but we’ll fail forward by expanding the lambda now and adding
    `Int::toString` as the `headerProvider` to get things compiling again:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: “在重构之前用 lambda 替换函数引用”现在本应使一切正常，但我们将失败前进，现在扩展 lambda 并将`Int::toString`添加为`headerProvider`来使编译通过：
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[Example 22.28 [table-reader.21:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.28&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.28&show=diff)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.28 [table-reader.21:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.28&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.28&show=diff)'
- en: All our tests still pass, so we’re quietly confident that we haven’t broken
    anything.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 所有测试仍然通过，所以我们相当自信我们没有破坏任何东西。
- en: 'Where are we going with this? Our plan is to have the new `readTableWithHeader`
    read the header line to create a `headerProvider` to pass to `parseLine`. Sitting
    between `readTableWithHeader` and `parseLine` is the call to our old `readTable`,
    so it needs a `headerProvider` parameter too, so that it can relay the value.
    So it’s “Introduce Parameter” (with “Introduce Default Value”) again, this time
    on `Int::toString` in `readTable`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做的目的是让新的`readTableWithHeader`读取头行以创建`headerProvider`以传递给`parseLine`。坐在`readTableWithHeader`和`parseLine`之间的是我们旧的`readTable`调用，因此它也需要一个`headerProvider`参数，以便它可以中继该值。所以这又是“引入参数”（带“引入默认值”），这次在`Int::toString`中的`readTable`上：
- en: '[PRE30]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[Example 22.29 [table-reader.22:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.29&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.29&show=diff)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.29 [table-reader.22:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.29&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.29&show=diff)'
- en: '[![1](assets/1.png)](#co_introduction_CO51-1)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_introduction_CO51-1)'
- en: 'Doesn’t compile: `Unresolved reference: KFunction1`'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '不编译：`Unresolved reference: KFunction1`'
- en: 'It’s hard to say why IntelliJ (at the time of writing) sometimes uses function
    types and sometimes `KFunctionN` types when refactoring. It would be nice if it
    was consistent, or at least generated code that compiled. We’ll fix this one by
    translating the `KFunction1` to an `(Int) -> String` by hand and hold just a little
    grudge for this second failed refactor in a row:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 很难说为什么 IntelliJ（写作时）有时在重构时使用函数类型，有时使用`KFunctionN`类型。如果能保持一致，或者至少生成编译的代码，那就太好了。我们将手动将`KFunction1`转换为`(Int)
    -> String`，对于这第二次失败的重构，我们有点怨念：
- en: '[PRE31]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[Example 22.30 [table-reader.23:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.30&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.30&show=diff)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.30 [table-reader.23:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.30&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.30&show=diff)'
- en: On the plus side, because the `headerProvider` parameter has a default value,
    our tests are unchanged and continue to pass.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 正面的是，由于`headerProvider`参数有默认值，我们的测试保持不变，仍然通过。
- en: 'Now we’re in a position to parse the header line; `readTableWithHeader` will
    need to read the header, create a `headerProvider` (an `(Int) -> String` remember),
    and then delegate to `readTable`. It needs to split the lines into the header
    (`Iterable.first()`) and the rest (`Iterable.drop(1)`). `Iterable.first` will
    fail if there are no lines, so we make a note to add a test for this case. As
    for converting the header line into a `header​Pro⁠vider`, we’ll pretend that we
    have a function to do that called `headerProviderFrom(String)`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以解析标题行了；`readTableWithHeader`需要读取标题，创建一个`headerProvider`（一个`(Int) -> String`记住），然后委托给`readTable`。它需要将行拆分为标题（`Iterable.first()`）和其余部分（`Iterable.drop(1)`）。如果没有行，`Iterable.first`将失败，因此我们注意要添加一个针对此情况的测试。至于将标题行转换为`headerProvider`，我们假装有一个叫做`headerProviderFrom(String)`的函数可以做到：
- en: '[PRE32]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[Example 22.31 [table-reader.24:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.31&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.31&show=diff)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.31 [table-reader.24:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.31&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.31&show=diff)'
- en: 'Alt-Enter on the new function’s invocation allows us to create it, giving:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在新函数的调用上按 Alt-Enter 允许我们创建它，得到：
- en: '[PRE33]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[Example 22.32 [table-reader.24:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.32&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.32&show=diff)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.32 [table-reader.24:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.32&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.32&show=diff)'
- en: 'This is a function that needs to return a function type. We can implement the
    return value with a lambda that takes an `Int` index and returns a `String`. The
    `String` we need to return is the header field at that index. We can use our `splitFields`
    again here:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个需要返回函数类型的函数。我们可以用一个 lambda 实现返回值，该 lambda 接受一个`Int`索引并返回一个`String`。我们需要返回的`String`是该索引处的标题字段。我们可以再次使用我们的`splitFields`：
- en: '[PRE34]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[Example 22.33 [table-reader.25:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.33&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.33&show=diff)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.33 [table-reader.25:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.33&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.33&show=diff)'
- en: 'We’ve taken care to split the `header` outside the lambda; otherwise, it will
    happen for every other row of the table. Our tests still pass, and if we’re right,
    so will the test for `readTableWithHeader` that we disabled previously. Let’s
    un-`@Disabled` it:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到在 lambda 外部分割了`header`；否则，它将发生在表的每一行之后。我们的测试仍然通过，如果我们正确，之前禁用的`readTableWithHeader`的测试也会通过。让我们解禁它：
- en: '[PRE35]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[Example 22.34 [table-reader.26:src/test/java/travelator/tablereader/TableReaderTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.34&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.34&show=diff)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.34 [table-reader.26:src/test/java/travelator/tablereader/TableReaderTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.34&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.34&show=diff)'
- en: 'This passes, hooray! We are about to say that we’re done for now, until we
    look down at our to-do list and remember that we predicted `readTableWithHeader`
    should fail given an empty input. So we write a test asserting the desired behavior,
    which is to return an empty `List`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过了，万岁！我们准备宣布我们暂时完成了，直到我们看到待办事项清单，记得我们预测`readTableWithHeader`在空输入时应该失败。所以我们写了一个测试来断言所需的行为，即返回一个空的`List`：
- en: '[PRE36]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[Example 22.35 [table-reader.26:src/test/java/travelator/tablereader/TableReaderTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.35&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.35&show=diff)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.35 [table-reader.26:src/test/java/travelator/tablereader/TableReaderTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.35&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.35&show=diff)'
- en: 'As we thought, this fails with `java.util.NoSuchElementException: List is empty.`,
    because `readTableWithHeader` is trying to call `lines.first()` on an empty `List`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '正如我们所料，这会因为在空的`List`上调用`lines.first()`而失败，抛出`java.util.NoSuchElementException:
    List is empty.`：'
- en: '[PRE37]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[Example 22.36 [table-reader.25:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.36&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.36&show=diff)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.36 [table-reader.25:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.36&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.36&show=diff)'
- en: 'Our irritation at not being finished is mitigated by being right about there
    being a problem! The simplest fix is to split our function into two definitions,
    with a `when` to choose between them. This passes all the tests and empties our
    to-do list. Here, then, is our public API:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对未完成感到不满，但是我们的正确性使我们感到宽慰！最简单的修复方法是将函数拆分为两个定义，并使用`when`来选择它们之间的函数。这通过了所有的测试并清空了我们的待办事项列表。因此，这是我们的公共API：
- en: '[PRE38]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[Example 22.37 [table-reader.26:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.37&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.37&show=diff)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.37 [table-reader.26:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.37&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.37&show=diff)'
- en: 'This is nice. Our clients now can read with or without a header row. But wait!
    Looking at the code, we realize that if they want to specify their own field names
    for `read​Ta⁠ble`, they can do this by overriding the default `headerProvider`
    in `readTable`. We have a feature for free! Let’s write a test to demonstrate
    it:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好。现在我们的客户可以选择是否使用标题行进行阅读。但是等等！看着代码，我们意识到，如果他们想要为`readTable`指定自己的字段名称，可以通过重写`readTable`中的默认`headerProvider`来实现这一点。我们免费提供了一个功能！让我们编写一个测试来演示它：
- en: '[PRE39]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[Example 22.38 [table-reader.27:src/test/java/travelator/tablereader/TableReaderTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.38&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.38&show=diff)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.38 [table-reader.27:src/test/java/travelator/tablereader/TableReaderTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.38&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.38&show=diff)'
- en: 'See how easy it is to convert from a `List<String>` to our header provider
    function `(Int) -> String` with the method reference `headers::get`? This is an
    interesting way to view collections. We can view:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 看看使用方法引用`headers::get`从`List<String>`转换为我们的标题提供者函数`(Int) -> String`是多么容易？这是查看集合的一种有趣方式。我们可以查看：
- en: '| Type | as function type | by |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 作为函数类型 | 通过 |'
- en: '| --- | --- | --- |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `List<T>` | `(index: Int) -> T` | `List.get(index)` |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `List<T>` | `(index: Int) -> T` | `List.get(index)` |'
- en: '| `Set<T>` | `(item: T) -> Boolean` | `Set.contains(item)` |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `Set<T>` | `(item: T) -> Boolean` | `Set.contains(item)` |'
- en: '| `Map<K, V>` | `(key: K) -> V?` | `Map.get(key)` |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `Map<K, V>` | `(key: K) -> V?` | `Map.get(key)` |'
- en: If we are able to express a dependency as one of these function types, then
    our clients, and our tests, can use standard collections to provide an implementation.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够将依赖表达为这些函数类型之一，那么我们的客户和我们的测试可以使用标准集合来提供实现。
- en: 'Now that we have implemented reading a table with a header, we are in a position
    to try running our acceptance test. This was:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了带标题的表格读取，我们可以尝试运行我们的验收测试。这是：
- en: '[PRE40]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[Example 22.39 [table-reader.26:src/test/java/travelator/tablereader/TableReaderAcceptanceTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.39&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.39&show=diff)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.39 [table-reader.26:src/test/java/travelator/tablereader/TableReaderAcceptanceTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.39&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.39&show=diff)'
- en: 'The function that we thought we would call `readTable` when we wrote the test
    turns out to be `readTableWithHeader`, so we make the change and run the test:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写测试时，我们认为我们将调用`readTable`函数，结果发现实际上调用的是`readTableWithHeader`，所以我们进行了更改并运行了测试：
- en: '[PRE41]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[Example 22.40 [table-reader.27:src/test/java/travelator/tablereader/TableReaderAcceptanceTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.40&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.40&show=diff)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.40 [table-reader.27:src/test/java/travelator/tablereader/TableReaderAcceptanceTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.40&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.40&show=diff)'
- en: It passes, and we ride the little dopamine hit to check in the code and take
    a coffee break.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过了，我们迎来了一点多巴胺的满足感，检查了代码并休息一下喝咖啡。
- en: Different Field Separators
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同的字段分隔符
- en: Returning from coffee, we make a quick survey of the different places in Travelator
    that read tables. Interestingly, we only have one use case that reads classic
    “comma”,“separated”,“variables” (with the quotes), but several need to use a semicolon
    as the field separator. It seems that some French SQL Server export job is using
    semicolons and then saving the file with a *.CSV* extension; maybe the *C* is
    for çemicolon? We’ll address reading those next, but try to find an interface
    that will work with more complicated quoting and escaping rules. To add flexibility,
    we need to identify an abstraction, as we did with the `headerProvider` previously.
    What is the abstraction here?
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 喝完咖啡回来后，我们快速调查了 Travelator 中读取表格的不同位置。有趣的是，我们只有一个用例读取经典的“逗号”，“分隔”，“变量”（带引号），但有几个需要使用分号作为字段分隔符。看起来，一些法国
    SQL Server 导出作业正在使用分号，然后将文件保存为 *.CSV* 扩展名；也许 *C* 代表分号？我们将在接下来解决读取这些内容，但尝试找到一个可以处理更复杂引号和转义规则的接口。为了增加灵活性，我们需要识别一个抽象，就像我们之前对
    `headerProvider` 所做的那样。这里的抽象是什么？
- en: 'Looking at the code, we see that the header and body parsing both call `splitFields`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 查看代码，我们发现标题和正文解析都调用了 `splitFields`：
- en: '[PRE42]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[Example 22.41 [table-reader.28:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.41&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.41&show=diff)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.41 [table-reader.28:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.41&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.41&show=diff)'
- en: Neither the header parsing nor the body parsing really want to depend on the
    details of how the splitting should happen, so let’s abstract that behind a function
    `(String)` `-> List<String>`. Why that signature rather than just parameterizing
    the character?
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 既不是标题解析也不是正文解析真正想要依赖于分割应该如何发生的细节，因此让我们将其抽象为一个函数 `(String)` `-> List<String>`。为什么是这个签名而不只是将字符参数化？
- en: That’s an interesting question, thank you for asking it. Introducing a `separators`
    parameter to `parseLine` and `headerProviderFrom`, and eventually their callers
    `readTable` and `readTableWithHeader`, would be the simplest thing that we could
    do. We get a lot more flexibility from using a function type, though, because
    we can hide all the details of separating, quoting, and escaping behind that signature.
    In pre-lambda Java, the benefit of the flexibility wouldn’t have been worth the
    cost of introducing and implementing a SAM interface, at least not until we really
    needed all that control. With lambdas in Java, the equation feels more balanced
    but probably not natural for most Java programmers. In Kotlin, designed from the
    outset with function types as part of the language, we use them even more readily.
    As soon as we need to parameterize an aspect of our code, it is natural to ask
    whether a function would provide more value than, erm, a simple value.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有趣的问题，谢谢你问。向 `parseLine` 和 `headerProviderFrom` 引入 `separators` 参数，最终引入他们的调用者
    `readTable` 和 `readTableWithHeader`，会是我们可以做的最简单的事情。然而，使用函数类型会给我们带来更多的灵活性，因为我们可以隐藏分割、引用和转义的所有细节在这个签名后面。在
    Java 中，使用 lambda 之前，灵活性的好处并不值得引入和实现一个 SAM 接口的成本，至少在我们真正需要所有那些控制权之前是这样。在 Java 中，这种灵活性的好处并不值得引入和实现一个
    SAM 接口的成本，至少在我们真正需要所有这些控制权之前是这样。在 Kotlin 中，从一开始就设计了函数类型作为语言的一部分，我们更容易使用它们。一旦我们需要参数化代码的一个方面，自然会问是否函数会比一个简单值提供更多的价值。
- en: 'Let’s start in `parseLine`. To extract the current splitting implementation,
    we can select `line.splitFields(",")` and “Introduce Functional Parameter”, choosing
    the parameter name `splitter`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `parseLine` 开始。为了提取当前的分割实现，我们可以选择 `line.splitFields(",")` 并选择“引入函数参数”，选择参数名称
    `splitter`：
- en: '[PRE43]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[Example 22.42 [table-reader.29:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.42&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.42&show=diff)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.42 [table-reader.29:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.42&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.42&show=diff)'
- en: '[![1](assets/1.png)](#co_introduction_CO52-1)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_introduction_CO52-1)'
- en: This lambda…
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 lambda…
- en: '[![2](assets/2.png)](#co_introduction_CO52-2)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_introduction_CO52-2)'
- en: …implements the splitter.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: …实现了分割器。
- en: 'We could continue this process, extracting the splitter lambda to the top level.
    Our lives will be made a bit easier, though, if we have a global value for the
    splitter, so we select the lambda in `readTable` and “Introduce Variable” named
    `splitOnComma`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们继续这个过程，将分隔符 lambda 提取到顶层将会使我们的生活变得更轻松，因此我们选择`readTable`中的 lambda，命名为`splitOnComma`并选择“引入变量”：
- en: '[PRE44]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[Example 22.43 [table-reader.30:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.43&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.43&show=diff)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.43 [table-reader.30:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.43&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.43&show=diff)'
- en: 'Now we can cut the `val` from the function and move it to the top level. It
    feels like there should be an automated refactor for this, but nothing works at
    the time of writing:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以从函数中删除`val`并移到顶层。在撰写时，感觉应该有自动重构的工具，但目前还没有什么有效的方法：
- en: '[PRE45]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[Example 22.44 [table-reader.31:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.44&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.44&show=diff)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.44 [table-reader.31:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.44&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.44&show=diff)'
- en: 'Now that `splitOnComma` is a global property, we can conveniently use it as
    a default. We select the reference to it in `readTable` and then “Introduce Parameter”,
    with “Introduce default value”, calling the new parameter `splitter`. This yields:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`splitOnComma`是一个全局属性，我们可以方便地将其作为默认值使用。我们在`readTable`中选择对它的引用，然后选择“引入参数”，并使用“引入默认值”，命名新参数为`splitter`。结果如下：
- en: '[PRE46]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[Example 22.45 [table-reader.32:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.45&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.45&show=diff)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.45 [table-reader.32:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.45&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.45&show=diff)'
- en: 'Because of the default value, we haven’t had to change any of the clients,
    and the tests continue to pass. As it stands, `readTable` is now using the supplied
    `splitter`, but `headerProviderFrom` is not:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 由于有了默认值，我们无需更改任何客户端，并且测试继续通过。目前，`readTable`正在使用提供的`splitter`，但`headerProviderFrom`没有：
- en: '[PRE47]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[Example 22.46 [table-reader.32:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.46&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.46&show=diff)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.46 [table-reader.32:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.46&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.46&show=diff)'
- en: 'Introducing a functional parameter for `header.splitFields(...)` yields:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为`header.splitFields(...)`引入一个函数参数产生：
- en: '[PRE48]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[Example 22.47 [table-reader.33:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.47&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.47&show=diff)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.47 [table-reader.33:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.47&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.47&show=diff)'
- en: '[![1](assets/1.png)](#co_introduction_CO53-1)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_introduction_CO53-1)'
- en: This lambda…
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 lambda…
- en: '[![2](assets/2.png)](#co_introduction_CO53-2)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_introduction_CO53-2)'
- en: …implements the splitter.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: …实现了分隔符。
- en: 'Now the lambda in `readTableWithHeader` is the same code as `splitOnComma`,
    so we use that instead:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`readTableWithHeader`中的 lambda 与`splitOnComma`的代码相同，因此我们使用它：
- en: '[PRE49]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[Example 22.48 [table-reader.34:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.48&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.48&show=diff)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.48 [table-reader.34:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.48&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.48&show=diff)'
- en: 'You can see the pattern here. Now we make a parameter from the `splitOnComma`
    reference, again with a default to avoid breaking existing clients:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这里的模式。现在我们将`splitOnComma`引用提取为一个参数，再次使用默认值以避免破坏现有客户端：
- en: '[PRE50]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[Example 22.49 [table-reader.35:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.49&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.49&show=diff)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.49 [table-reader.35:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.49&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.49&show=diff)'
- en: 'Finally, in `readTableWithHeader`, we are calling `readTable` without providing
    a `splitter`, so it will use its default (`splitOnComma`). We don’t want this,
    so we pass the parameter down. The header and body should be using the same splitter,
    so we pass it from `readTableWithHeader` to the inner `readTable`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`readTableWithHeader`中调用`readTable`时没有提供`splitter`，因此它将使用默认的`splitOnComma`。我们不希望如此，因此我们将参数传递下去。标题和正文应该使用相同的分隔符，所以我们将它从`readTableWithHeader`传递到内部的`readTable`：
- en: '[PRE51]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[Example 22.50 [table-reader.36:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.50&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.50&show=diff)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '[例子22.50 [table-reader.36:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.50&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.50&show=diff)'
- en: '[![1](assets/1.png)](#co_introduction_CO54-1)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_introduction_CO54-1)'
- en: Pass on the `splitter`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 传递`splitter`。
- en: 'Some test-driven developers might insist on a failing test to show the need
    for that last step. We certainly should write a test to demonstrate the use of
    the splitter, but before we do, let’s make it more convenient to make one. Here
    is `splitOnComma`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 一些测试驱动开发者可能会坚持先写一个失败的测试来展示最后一步的必要性。我们确实应该编写一个测试来演示使用分隔符的情况，但在此之前，让我们更方便地创建一个。这是`splitOnComma`：
- en: '[PRE52]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[Example 22.51 [table-reader.36:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.51&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.51&show=diff)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '[例子22.51 [table-reader.36:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.51&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.51&show=diff)'
- en: 'It would be nice to be able to create splitters without having to define a
    lambda every time. That way, our French clients could call `readTable` with, for
    example, `splitter = splitOn(";")`. The `splitOn` function would take the separators
    and return a value of function type `(String) -> List<String>`. We could try to
    extract this function from our current `splitOnComma` lambda, but the refactoring
    is tedious, so instead let’s just define the function and call it:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果能够不必每次都定义一个lambda来创建分隔符，那就太好了。这样，我们的法国客户就可以使用`splitter = splitOn(";")`来调用`readTable`。`splitOn`函数将接收分隔符并返回一个`(String)
    -> List<String>`类型的函数值。我们可以尝试从当前的`splitOnComma` lambda中提取这个函数，但重构工作很繁琐，所以我们直接定义这个函数并调用它：
- en: '[PRE53]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[Example 22.52 [table-reader.37:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.52&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.52&show=diff)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '[例子22.52 [table-reader.37:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.52&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.52&show=diff)'
- en: 'You can see that we have taken the opportunity to define a `splitOnTab`, too,
    so that we can use it in the new test we promised ourselves that we would write:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了一个`splitOnTab`，这样我们就可以在我们承诺要写的新测试中使用它：
- en: '[PRE54]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[Example 22.53 [table-reader.38:src/test/java/travelator/tablereader/TableReaderTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.53&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.53&show=diff)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '[例子22.53 [table-reader.38:src/test/java/travelator/tablereader/TableReaderTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.53&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.53&show=diff)'
- en: This passes, giving us both reassurance and documentation. Let’s check it in
    and take a break for a few minutes before coming back to take stock.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切顺利进行，给了我们安心和文档支持。让我们将其检入并在休息几分钟后回来看看情况。
- en: Sequences
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列
- en: We now have the basics of a table parser, and we haven’t introduced any new
    types beyond those in the standard Kotlin runtime. This is often the way with
    a more functional approach. The grain of Kotlin is to leverage the rich abstractions
    provided by the standard library, where Java programs are more likely to define
    new types. As we saw in [Chapter 6](ch06.html#java-to-kotlin-collections) and
    [Chapter 15](ch15.html#encapsulated-collections-to-typealiases), one reason for
    the difference is that Kotlin allows us to treat collections as values, which
    makes them more safely composable than Java’s mutable objects. We are able to
    define an API that takes and returns collection types without worrying about aliasing.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了一个基本的表格解析器，而且除了标准Kotlin运行时中的类型之外，我们没有引入任何新类型。这在更功能化的方法中经常发生。Kotlin的特点是利用标准库提供的丰富抽象，而Java程序更有可能定义新类型。正如我们在[第6章](ch06.html#java-to-kotlin-collections)和[第15章](ch15.html#encapsulated-collections-to-typealiases)中看到的那样，这种差异的原因之一是Kotlin允许我们将集合视为值，这使它们比Java的可变对象更安全地可组合。我们能够定义一个接受和返回集合类型的API，而不必担心别名问题。
- en: 'Value types may make for APIs composed of predictable calculations, but they
    can bring their own problems. Our naïve API suffers from the same issue as we
    saw in [Chapter 20](ch20.html#performing-io-to-passing-data): it works on a `List<String>`
    loaded into memory and produces a `List<Map<String, String>>` also in memory.
    Even discounting the cost of the data structures, the memory footprint of `readTable`
    is twice the number of bytes of the input, which is (probably) twice the size
    of a UTF-8 encoded file containing the data. To process large files, it would
    be nice to work in terms of sequences rather than in terms of lists, since if-necessary
    sequences can keep only one item in each stage of a pipeline in memory at a time.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型可能导致由可预测计算组成的API，但它们可能会带来自己的问题。我们的天真API遇到了与我们在[第20章](ch20.html#performing-io-to-passing-data)中看到的相同问题：它在加载到内存中的`List<String>`上运行，并且生成一个同样在内存中的`List<Map<String,
    String>>`。即使不考虑数据结构的成本，`readTable`的内存占用量是输入字节的两倍，这可能是UTF-8编码文件包含的数据的两倍大小。为了处理大文件，最好是按照序列而不是列表的方式工作，因为如果需要，序列可以在管道的每个阶段仅保留一个项目在内存中。
- en: As we saw in [Chapter 13](ch13.html#streams-to-sequences), we can convert a
    `Sequence` to a `List` and back (with some caveats) very easily, so we could implement
    `Sequence` functions by delegating to our existing `List` API. This wouldn’t reduce
    our memory footprint though, so instead we’ll write the `Sequence` versions and
    delegate the `List` versions to them. If we’re clever, we can test through the
    convenient `List` API, thus getting two sets of tests for the price of one.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第13章](ch13.html#streams-to-sequences)中所看到的，我们可以非常容易地将`Sequence`转换为`List`，然后再转回（有些限制），因此我们可以通过委托给现有的`List`
    API 来实现`Sequence`函数。然而，这并不会减少我们的内存占用，所以我们将编写`Sequence`版本，并将`List`版本委托给它们。如果我们聪明的话，我们可以通过便捷的`List`
    API 进行测试，从而一举获得两套测试。
- en: '`readTable` currently looks like this:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`readTable`看起来像这样：
- en: '[PRE55]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[Example 22.54 [table-reader.39:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.54&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.54&show=diff)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.54 [table-reader.39:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.54&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.54&show=diff)'
- en: 'We can try out our plan by converting to and from `Sequence` in the middle
    of the pipeline:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在管道的中间转换为和从`Sequence`尝试我们的计划：
- en: '[PRE56]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[Example 22.55 [table-reader.40:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.55&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.55&show=diff)'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.55 [table-reader.40:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.55&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.55&show=diff)'
- en: 'That passes the tests, and they all funnel through this function, so that’s
    reassuring. Now we can extract the inner workings into a function taking and returning
    a `Sequence`; this is extracting part of a chain as described in [“Extracting
    Part of a Pipeline”](ch13.html#extracting-part-of-a-pipeline):'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试都通过了，它们都通过这个函数汇聚，所以这很令人放心。现在我们可以将内部工作提取出来，以一个接受并返回`Sequence`的函数；这是根据[“提取管道的一部分”](ch13.html#extracting-part-of-a-pipeline)的描述提取的一部分：
- en: '[PRE57]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[Example 22.56 [table-reader.41:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.56&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.56&show=diff)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.56 [table-reader.41:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.56&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.56&show=diff)'
- en: 'This gives us a `Sequence` version of `readTable` that the `List` version calls,
    and the `List` version is well tested. Now for the outer `readTableWithHeader`.
    It looks like this:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们提供了一个`Sequence`版本的`readTable`，`List`版本调用它，并且`List`版本已经经过良好测试。现在轮到外部的`readTableWithHeader`。它看起来像这样：
- en: '[PRE58]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[Example 22.57 [table-reader.42:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.57&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.57&show=diff)'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.57 [table-reader.42:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.57&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.57&show=diff)'
- en: 'Currently, `readTableWithHeader` is delegating to the `List` version of `readTable`.
    If we want to produce a `Sequence` version (and we do), it should call the `Sequence`
    version of `readTable`, so we inline the call here to give:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`readTableWithHeader`正在委托给`List`版本的`readTable`。如果我们想生成一个`Sequence`版本（确实是这样），它应该调用`readTable`的`Sequence`版本，因此我们在这里内联调用以得到：
- en: '[PRE59]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[Example 22.58 [table-reader.43:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.58&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.58&show=diff)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.58 [table-reader.43:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.58&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.58&show=diff)'
- en: 'Now, by hand, create a `linesAsSequence` as a variable and use it in place
    of `lines`. This nearly works:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，手动创建一个`linesAsSequence`作为变量，并将其用作`lines`的替代。这几乎可以工作：
- en: '[PRE60]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[Example 22.59 [table-reader.44:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.59&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.59&show=diff)'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.59 [table-reader.44:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.59&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.59&show=diff)'
- en: '[![1](assets/1.png)](#co_introduction_CO55-1)'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_introduction_CO55-1)'
- en: Doesn’t compile because there is no `Sequence<T>.isEmpty()`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 编译失败是因为没有`Sequence<T>.isEmpty()`。
- en: 'How do we tell if a `Sequence` is empty? `linesAsSequence.firstOrNull() ==
    null` does the trick:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何判断`Sequence`是否为空？`linesAsSequence.firstOrNull() == null`就可以：
- en: '[PRE61]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[Example 22.60 [table-reader.45:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.60&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.60&show=diff)'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.60 [table-reader.45:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.60&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.60&show=diff)'
- en: 'This passes the tests, so we can again extract the expression between the `return`
    and `.toList()` as the function we are looking for. After extracting it and tidying
    up, we have the `Sequence` version of `readTableWithHeader`:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过了测试，因此我们可以再次提取在`return`和`.toList()`之间的表达式作为我们正在寻找的函数。提取并整理后，我们有了`readTableWithHeader`的`Sequence`版本：
- en: '[PRE62]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[Example 22.61 [table-reader.46:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.61&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.61&show=diff)'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.61 [table-reader.46:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.61&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.61&show=diff)'
- en: 'At this point, we have two versions of `readTable` and `readTableWithHeader`:
    a `List` and a `Sequence` version of each. Given how easy it is to convert a `List`
    argument to a `Sequence`, and a `Sequence` result to a `List`, maybe the `List`
    variants aren’t paying their way? Let’s just move their definitions into the tests
    while we don’t have any production uses. That way, the tests can use them to stay
    simple, and the production code is kept minimal.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们有`readTable`和`readTableWithHeader`的两个版本：每个都有一个`List`版本和一个`Sequence`版本。考虑到将`List`参数转换为`Sequence`，将`Sequence`结果转换为`List`是多么容易，也许`List`变体并没有起到多大作用？让我们把它们的定义移到测试中，因为我们没有任何生产用途。这样，测试可以使用它们保持简单，而生产代码则保持最小化。
- en: 'Here, then, is the entire public interface to our table parser:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是我们表解析器的整个公共接口：
- en: '[PRE63]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[Example 22.62 [table-reader.47:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.62&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.62&show=diff)'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.62 [table-reader.47:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.62&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.62&show=diff)'
- en: 'This is supported by three utility functions:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这由三个实用函数支持：
- en: '[PRE64]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[Example 22.63 [table-reader.47:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.63&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.63&show=diff)'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.63 [table-reader.47:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.63&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.63&show=diff)'
- en: When we looked back at the code, we realized that it wasn’t clear *why* we needed
    `splitFields`, so we added a comment. It’s often easier to do this in retrospect
    when we are trying to understand code we are returning to, rather than code we
    have just written. Apart from that, we think that the code is pretty self-explanatory.
    Sometimes we’re wrong about that. If it takes us more than a glance to work out
    what is going on next time we read this code, we’ll take the opportunity then
    to add more comments or, better, refactor to be more expressive.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们回顾代码时，我们意识到不清楚*为什么*我们需要`splitFields`，因此我们添加了注释。回顾时，我们通常更容易理解我们要返回的代码，而不是我们刚刚写的代码。除此之外，我们认为代码已经相当自解释了。有时我们对此会有误解。如果我们读这段代码时需要更多时间才能理解正在发生的事情，我们将利用这个机会添加更多注释，或者更好地重构以提升表达力。
- en: Reading from a File
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从文件读取
- en: 'This seems a fine interface in the abstract, but the first time we come to
    use it in anger, we hit on a snag. Let’s illustrate the problem with a test. This
    calls the `Sequence` version of `readTableWithHeader`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这在抽象中似乎是一个很好的接口，但是当我们第一次愤怒地使用它时，我们遇到了一个障碍。让我们通过一个测试来说明问题。这调用了`readTableWithHeader`的`Sequence`版本：
- en: '[PRE65]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[Example 22.64 [table-reader.48:src/test/java/travelator/tablereader/TableReaderTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.64&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.64&show=diff)'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.64 [table-reader.48:src/test/java/travelator/tablereader/TableReaderTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.64&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=22.64&show=diff)'
- en: 'Can you see why this fails? What if we say that it fails with `java.lang.IllegalState​Ex⁠ception:
    This sequence can be consumed only once.`?'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '你能看出为什么会失败吗？如果我们说它失败了，会出现`java.lang.IllegalState​Ex⁠ception: This sequence
    can be consumed only once.`吗？'
- en: 'Yes, once again ([“Multiple Iterations”](ch13.html#sequences-multiple-operations)),
    `Sequence`s bite us because we didn’t test both types—those that can and can’t
    be consumed twice—as input:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，再次（[“多次迭代”](ch13.html#sequences-multiple-operations)），`Sequence`让我们感到困扰，因为我们没有测试两种类型——可以和不可以两次消耗的输入：
- en: '[PRE66]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[Example 22.65 [table-reader.47:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.65&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.65&show=diff)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.65 [table-reader.47:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.65&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=22.65&show=diff)'
- en: So `lines.firstOrNull()` consumes the sequence, and when reading from a `Reader`
    we can’t just go back and start again in order to evaluate `lines.drop(1)` and
    `lines.first()`. Our unit tests were all starting from a `List` of all the file
    lines; those sequences *can* be consumed again, because they are held in memory.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`lines.firstOrNull()`消耗了这个序列，当从`Reader`中读取时，我们不能简单地返回并重新开始以评估`lines.drop(1)`和`lines.first()`。我们所有的单元测试都是从所有文件行的`List`开始的；这些序列*可以*被再次消耗，因为它们保存在内存中。
- en: To use our `Sequence` interface on data in files, we will either have to load
    it all into memory or find a way to fetch the first and rest of a `Sequence` without
    trying to read it twice. Given that we introduced the `Sequence` specifically
    to avoid loading all the data into memory at once, we choose the latter. All we
    need to do then is to check whether a `Sequence` has any items without consuming
    it. Can you see how?
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 要在文件中使用我们的`Sequence`接口，我们要么必须将所有数据加载到内存中，要么找到一种方法来获取`Sequence`的第一个和其余部分，而不必尝试两次读取它。鉴于我们专门引入了`Sequence`以避免一次性加载所有数据到内存中，我们选择了后者。那么我们所需要做的就是在不消耗`Sequence`的情况下检查它是否有任何项。你能看到吗？
- en: 'Ah, that one was a trick question. To check, we *have* to call `iterator()`
    on the `Sequence`, which is the very thing that consumes it. We cannot see whether
    the `Sequence` is empty and then use it again later. Sometimes in logic though,
    when we can’t do a thing that we want in isolation, we can do it and another thing
    that we want together. In this case, we don’t just want to see whether the `Sequence`
    is empty; we want to split it into its head and tail if it isn’t. We can achieve
    that wider goal by destructuring the `Sequence` with a function like this:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 啊，那是一个诡计问题。要检查，我们*必须*在`Sequence`上调用`iterator()`，这正是消耗它的东西。我们无法看到`Sequence`是否为空，然后稍后再次使用它。但有时在逻辑上，当我们无法单独执行我们想要的事情时，我们可以一起执行我们想要的事情和另一件事情。在这种情况下，我们不仅想要查看`Sequence`是否为空；我们还想将其拆分为其头部和尾部（如果它不为空）。我们可以通过使用这样一个函数来解构`Sequence`来实现更广泛的目标：
- en: '[PRE67]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[Example 22.66 [table-reader.49:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.66&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.66&show=diff)'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.66 [table-reader.49:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.66&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=22.66&show=diff)'
- en: 'This `destruct` returns `null` if the `Sequence` is empty; otherwise, it returns
    a `Pair` of the head and the tail (where the tail may be an empty `Sequence`).
    It consumes the original (by calling `iterator()`) but provides a fresh `Sequence`
    to continue processing. We can use it to refactor `readTableWithHeader`, currently:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Sequence`为空，则此`destruct`返回`null`；否则，它返回头部和尾部的`Pair`（其中尾部可能是一个空的`Sequence`）。它消耗了原始（通过调用`iterator()`），但提供了一个新的`Sequence`来继续处理。我们可以使用它来重构当前的`readTableWithHeader`：
- en: '[PRE68]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[Example 22.67 [table-reader.48:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.67&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.67&show=diff)'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.67 [table-reader.48:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.67&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=22.67&show=diff)'
- en: 'It certainly isn’t a trivial rearrangement, but we can transform this into:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝对不是一个微不足道的重新排列，但我们可以将其转化为：
- en: '[PRE69]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[Example 22.68 [table-reader.49:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.68&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.68&show=diff)'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.68 [table-reader.49:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.68&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=22.68&show=diff)'
- en: 'The new form passes all the tests, because it doesn’t consume `lines` more
    than once. If it feels a little clunky, we can combine a `?.let`, destructuring,
    and an Elvis operator to give a single expression that you may or may not find
    acceptably terse. The result is this public API:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 新形式通过所有测试，因为它不会多次消耗`lines`。如果感觉有点笨拙，我们可以结合`?.let`、解构和Elvis运算符，给出一个你可能接受的单一表达式。结果是这个公共API：
- en: '[PRE70]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[Example 22.69 [table-reader.50:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.69&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.69&show=diff)'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.69 [table-reader.50:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.69&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=22.69&show=diff)'
- en: We are almost done, we promise.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了，我们保证。
- en: 'The last step, now that the API has crystallized around two functions, is to
    take the opportunity to make the tests more expressive:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在API已经围绕两个函数结晶化，最后一步是利用这个机会使测试更具表现力：
- en: '[PRE71]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[Example 22.70 [table-reader.52:src/test/java/travelator/tablereader/TableReaderTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.70&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.70&show=diff)'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.70 [table-reader.52:src/test/java/travelator/tablereader/TableReaderTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.70&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=22.70&show=diff)'
- en: This is an important step. As we saw in [Chapter 17](ch17.html#mocks-to-maps),
    finding the patterns in our tests and expressing them in functions (like `checkReadTable`)
    both help readers of the tests to see what the code is doing and can help us find
    gaps in our test coverage. For example, what is the behavior of our parser when
    there are more fields than headers or vice versa? The tests that we write for
    quick feedback while we are test-driving our implementation are unlikely to be
    optimally effective for communicating about the API, finding issues, or catching
    regressions if we return to the implementation and modify it. If we use TDD as
    a design technique, we mustn’t forget to make sure that the final tests are fit
    for determining correctness, adding documentation, and preventing regression.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个重要的步骤。正如我们在[第17章](ch17.html#mocks-to-maps)中所看到的，找到我们测试中的模式，并在函数中表达它们（比如`checkReadTable`），既帮助测试的读者看到代码在做什么，也可以帮助我们找到测试覆盖中的空白。例如，当字段多于标题或反之时，我们的解析器的行为是什么？我们为了在测试驱动实现时获得快速反馈而编写的测试，如果返回实现并对其进行修改，可能不太可能有效地用于API沟通、问题发现或捕捉回归。如果我们将TDD作为设计技术使用，我们不能忘记确保最终的测试适合确定正确性、添加文档和防止回归。
- en: Comparison with Commons CSV
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与Commons CSV的比较
- en: We started this chapter by saying that in most real-world situations, we would
    reach for Apache Commons CSV rather than rolling our own parser. Before we finish
    the chapter, let’s compare our API with that of the Commons equivalent.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章开始时说，在大多数实际情况下，我们会选择Apache Commons CSV而不是自己编写解析器。在我们完成本章之前，让我们将我们的API与Commons的等效API进行比较。
- en: 'The most common use case for a table parser is to read a file with known columns,
    translating each row into some data class. Here is how we do that with our parser:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 表解析器最常见的用例是读取具有已知列的文件，并将每行转换为某些数据类。以下是我们如何使用我们的解析器来实现这一点：
- en: '[PRE72]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[Example 22.71 [table-reader.53:src/test/java/travelator/tablereader/CsvExampleTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.71&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.71&show=diff)'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.71 [table-reader.53:src/test/java/travelator/tablereader/CsvExampleTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.71&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=22.71&show=diff)'
- en: Real-world code would probably need more error handling (we see how in [Chapter 21](ch21.html#exceptions-to-values)),
    but this shows the basic use case. We use the Kotlin `Reader.useLines` extension
    function to produce a `Sequence<String>`, which our parser transforms into a `Sequence<Map<String,
    String>>`. We can `map` over the `Map`s, indexing by field name to extract the
    data we need and transform it to the type (`Measurement`) that we actually want.
    This design didn’t happen by accident—it was the decisions that we made at the
    very start, albeit with `List` rather than with `Sequence` at the time.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 真实世界的代码可能需要更多的错误处理（我们可以在[第 21 章](ch21.html#exceptions-to-values)中看到如何处理），但这展示了基本的用例。我们使用
    Kotlin 的 `Reader.useLines` 扩展函数生成一个 `Sequence<String>`，然后我们的解析器将其转换为 `Sequence<Map<String,
    String>>`。我们可以对这些 `Map` 进行 `map` 操作，按字段名索引提取我们需要的数据并将其转换为我们实际想要的类型（`Measurement`）。这个设计并非偶然——这是我们在最开始做出的决策，尽管当时使用的是
    `List` 而不是 `Sequence`。
- en: 'Here is the Commons CSV version:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 Commons CSV 版本的代码：
- en: '[PRE73]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[Example 22.72 [table-reader.53:src/test/java/travelator/tablereader/CsvExampleTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.72&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.72&show=diff)'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.72 [table-reader.53:src/test/java/travelator/tablereader/CsvExampleTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.72&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.72&show=diff)'
- en: It too has a static function entry point, `CSVParser.parse`, which also takes
    configuration about the table format (in this case, `CSVFormat.DEFAULT.withFirstRecord​A⁠sHeader()`;
    in ours, `splitOnComma`). We have two functions to differentiate between files
    with or without headers; the Apache API rolls this into the `CSVFormat`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 它也有一个静态函数入口点，`CSVParser.parse`，它还接受关于表格格式的配置（在本例中为 `CSVFormat.DEFAULT.withFirstRecordAsHeader()`；在我们的例子中为
    `splitOnComma`）。我们有两个函数来区分是否有标题的文件；Apache API 将这些函数合并到 `CSVFormat` 中。
- en: The Commons `parse` takes a `Reader` though, rather than our `Sequence<String>`.
    This allows it to handle record separators other than newline, and cope with having
    new lines in the middle of fields, but leads to a proliferation of `parse` methods.
    There are variants taking `Path`, `File`, `InputStream`, `String`, and `URL`.
    The developers probably felt these were necessary because Java provides so little
    support for converting between these types of sources and disposing of them safely.
    The `CSVParser` returned by the `parse` static method has a lot of code to manage
    resources. Our API delegates these to the workings of `Sequence` and Kotlin life
    cycle functions like `use` and `useLines`.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: Commons 的 `parse` 接受一个 `Reader`，而不是我们的 `Sequence<String>`。这使得它能够处理除换行符外的记录分隔符，并处理字段中间有换行符的情况，但会导致
    `parse` 方法的泛滥。有多个变体接受 `Path`、`File`、`InputStream`、`String` 和 `URL`。开发者可能认为这些变体是必要的，因为
    Java 对于这些类型的源和安全处理它们的支持很少。由 `parse` 静态方法返回的 `CSVParser` 具有大量代码来管理资源。我们的 API 将这些委托给
    `Sequence` 的工作以及 Kotlin 生命周期函数如 `use` 和 `useLines`。
- en: On the subject of lines, you have to read between them in the code example to
    see it, but `CSVParser` implements `Iterable<CSVRecord>`. This is a clever design
    choice, because it allows Java developers to use a `for` statement to loop over
    the records, and Kotlin developers to convert to a `Sequence` with `.asSequence`.
    In fact, the Kotlin usability is due to the design of the Kotlin standard library,
    which builds on the same `Iterable` abstraction that the Apache developers also
    leverage.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理行的问题上，你必须在代码示例中读懂它们之间的联系，但 `CSVParser` 实现了 `Iterable<CSVRecord>`。这是一个巧妙的设计选择，因为它允许
    Java 开发者使用 `for` 循环遍历记录，并允许 Kotlin 开发者使用 `.asSequence` 将其转换为 `Sequence`。事实上，Kotlin
    的易用性归功于 Kotlin 标准库的设计，该标准库建立在与 Apache 开发者同样利用的 `Iterable` 抽象之上。
- en: 'Moving on, the code to create an individual `Measurement` looks identical in
    both examples:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，两个示例中创建单个 `Measurement` 的代码看起来完全相同：
- en: '[PRE74]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[Example 22.73 [table-reader.53:src/test/java/travelator/tablereader/CsvExampleTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.73&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.73&show=diff)'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.73 [table-reader.53:src/test/java/travelator/tablereader/CsvExampleTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.73&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.73&show=diff)'
- en: 'Although the type of `record` in our parser is `Map<String, String>`, in the
    Commons case it is `CSVRecord`. `CSVRecord` has a `get(String)` method, which
    is how `record["time"]` and so on are resolved. It also has methods: `get(int)`
    to retrieve a field by index, where we could use `Map.values.get(Int)`; `size()`
    rather than `Map.size()`; and `isSet(String)` to substitute for `Map.hasKey(String)`.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的解析器中 `record` 的类型是 `Map<String, String>`，但在 Commons 情况下是 `CSVRecord`。`CSVRecord`
    有一个 `get(String)` 方法，这是 `record["time"]` 等的解决方法。它还有方法：`get(int)` 通过索引检索字段，我们可以使用
    `Map.values.get(Int)`；`size()` 而不是 `Map.size()`；以及 `isSet(String)` 代替 `Map.hasKey(String)`。
- en: Basically, `CSVRecord` is having to reproduce the `Map` interface by hand rather
    than just *being* a `Map`. Why? Because, as we discussed in [Chapter 6](ch06.html#java-to-kotlin-collections),
    the Java `Map` interface is mutable, and mutation makes no sense in the context
    of reading fields from a file; mutations certainly aren’t going to be written
    back to the source. When programming in Java, we find ourselves having to create
    new types to solve problems, where in Kotlin we can express ourselves in standard
    types and then enjoy the richness of the Kotlin API on those types.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，`CSVRecord` 手工复制了 `Map` 接口，而不仅仅是*成为*一个 `Map`。为什么呢？因为正如我们在 [第6章](ch06.html#java-to-kotlin-collections)
    讨论的那样，Java `Map` 接口是可变的，在从文件中读取字段的上下文中，变异毫无意义；变异显然不会写回到源中。在 Java 编程中，我们发现自己不得不创建新类型来解决问题，而在
    Kotlin 中，我们可以用标准类型表达自己，然后享受 Kotlin API 的丰富性。
- en: 'One area in which the Commons CSV library Excels™️ is its provision of ready-made
    parser defaults. These are expressed as constants in the `CSVFormat` class. We’ve
    seen `CSVFormat.DEFAULT`, but there are many others, including `CSVFormat.EXCEL`.
    Armed with a `CSVFormat`, you can pass it to the `CSVParser.parse` method as we
    saw, or use it directly, for example, `CSVFormat.EXCEL.parse(reader)`. Can we
    provide this facility without defining new types in our API? How about using `splitOnComma`
    as if it was our configuration:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: Commons CSV 库 Excels™️ 的一个优点是它提供了现成的解析器默认值。这些值在 `CSVFormat` 类中表示为常量。我们已经见过 `CSVFormat.DEFAULT`，但还有许多其他值，比如
    `CSVFormat.EXCEL`。有了 `CSVFormat`，你可以像我们之前看到的那样将其传递给 `CSVParser.parse` 方法，或者直接使用它，例如
    `CSVFormat.EXCEL.parse(reader)`。我们能否在不在 API 中定义新类型的情况下提供此功能？比如，使用 `splitOnComma`
    就好像它是我们的配置：
- en: '[PRE75]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[Example 22.74 [table-reader.54:src/test/java/travelator/tablereader/CsvExampleTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.74&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.74&show=diff)'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.74 [table-reader.54:src/test/java/travelator/tablereader/CsvExampleTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.74&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=22.74&show=diff)'
- en: 'We can achieve this by defining `splitOnComma.readTableWithHeader(reader)`
    as an extension function on the function type:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将 `splitOnComma.readTableWithHeader(reader)` 定义为函数类型的扩展函数来实现这一点：
- en: '[PRE76]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[Example 22.75 [table-reader.54:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.75&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.75&show=diff)'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.75 [table-reader.54:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.75&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=22.75&show=diff)'
- en: In reality, `CSVFormat` represents a whole package of strategies for escaping
    rules, what to do with blank lines, and so on, not just how to split a line. When
    our parser grows these facilities, then we will probably want to create a data
    class to collect them. Until that point, we have been able to progress using just
    the built-in types and Kotlin language features.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`CSVFormat` 表示了一整套策略，用于转义规则、空白行处理等，而不仅仅是如何分割一行。当我们的解析器增加了这些功能时，可能希望创建一个数据类来收集它们。在此之前，我们一直能够使用内置类型和
    Kotlin 语言特性来取得进展。
- en: There is another useful feature that the Commons interface provides that ours
    doesn’t, and that we will finally need to create a type to implement. Commons
    CSV has `CSVParser.getHeaderNames` to provide access to the header information.
    Can we add this facility without modifying our current API, or at least requiring
    changes to our client code?
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: Commons 接口提供了另一个有用的功能，而我们的接口却没有，这最终需要我们创建一个类型来实现。Commons CSV 有 `CSVParser.getHeaderNames`
    来提供对头信息的访问。我们能否在不修改当前 API 或至少不需要更改客户端代码的情况下添加此功能？
- en: 'For many inputs, we could just call `Map.keys` on the first of the output `Sequence`,
    but this won’t work if the table has no data rows, only a header. To return header
    information *and* the parsed records, we could return a `Pair<List<String>, Sequence<Map<String,
    String>>`, but this will force our current clients to discard the first of the
    pair. Instead, we can return a type `Table` that implements `Sequence<Map<String,
    String>>` but also has a header property. This way, all our current callers remain
    unchanged, but we can access `headers` when required:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多输入，我们可以简单地在输出 `Sequence` 的第一个上调用 `Map.keys`，但如果表没有数据行，只有标题，这种方法就行不通了。要返回标题信息和解析记录，我们可以返回一个
    `Pair<List<String>, Sequence<Map<String, String>>`，但这将强制我们当前的客户端丢弃一对中的第一个。相反，我们可以返回一个实现
    `Sequence<Map<String, String>>` 且具有标题属性的 `Table` 类型。这样一来，我们所有现有的调用者都保持不变，但我们可以在需要时访问
    `headers`：
- en: '[PRE77]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[Example 22.76 [table-reader.55:src/test/java/travelator/tablereader/TableReaderTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.76&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.76&show=diff)'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.76 [table-reader.55:src/test/java/travelator/tablereader/TableReaderTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.76&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=22.76&show=diff)'
- en: 'We’ll spare you the refactoring steps, but here is the implementation:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会略过重构步骤，但这里是实现代码：
- en: '[PRE78]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[Example 22.77 [table-reader.55:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.77&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=22.77&show=diff)'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 22.77 [table-reader.55:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.77&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=22.77&show=diff)'
- en: Moving On
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动
- en: In this final leg of our journey, we allowed ourselves the luxury of writing
    Kotlin from scratch rather than refactoring our existing Java. Even then, we started
    from the tests and then just copied the test data into our implementation and
    refactored from there. We can’t write all code this way, but it does work well
    when our code is just calculations, and the more of it that is just calculations,
    the better our code works, too.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们旅程的最后阶段，我们豁免了从头开始编写 Kotlin 而不是重构我们现有的 Java 的奢侈。即便如此，我们还是从测试开始，然后将测试数据复制到我们的实现中，并从那里进行重构。我们不能以这种方式编写所有的代码，但当我们的代码只是计算时，这确实效果很好，而且代码中计算的部分越多，我们的代码工作得就越好。
- en: We saw the power of reusing built-in types in [Chapter 15, *Encapsulated Collections
    to Type Aliases*](ch15.html#encapsulated-collections-to-typealiases), and [Chapter 16,
    *Interfaces to Functions*](ch16.html#interfaces-to-functions), and defining APIs
    as extension functions in [Chapter 10, *Functions to Extension Functions*](ch10.html#functions-to-extension-functions).
    In this example, both collection and function types came together nicely, and
    we even managed to define an extension function on a function type! Where we would
    have had to define new classes to encapsulate Java’s mutable collections, and
    methods to manipulate those collections, we passed Kotlin’s immutable collections
    between our functions and wrote application-specific extensions on those collection
    types. Where we would have needed to define interfaces in Java, we used Kotlin’s
    function types.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了在 [第 15 章，*封装集合到类型别名*](ch15.html#encapsulated-collections-to-typealiases)
    和 [第 16 章，*接口到函数*](ch16.html#interfaces-to-functions) 中重复使用内置类型的强大，以及在 [第 10 章，*函数到扩展函数*](ch10.html#functions-to-extension-functions)
    中定义 API 作为扩展函数。在这个例子中，集合和函数类型很好地结合在一起，我们甚至设法在函数类型上定义了一个扩展函数！在 Java 中，如果我们需要定义新的类来封装可变集合，并且编写操作这些集合的方法，那么我们将
    Kotlin 的不可变集合传递给我们的函数，并在这些集合类型上编写应用程序特定的扩展。如果我们需要在 Java 中定义接口，我们可以使用 Kotlin 的函数类型。
- en: Again, not all problems can or should be solved this way, but your authors have
    found that while it is hard to make Java bend in this direction, Kotlin features
    combine to actively encourage this style. We shouldn’t get hung up on not defining
    new types, but neither should we leap to solve every problem with a new class.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，并非所有问题都可以或应该这样解决，但作者们发现，虽然让 Java 朝这个方向弯曲是困难的，但 Kotlin 的特性结合起来积极鼓励这种风格。我们不应该在不定义新类型上纠缠不放，但也不应该一下子用一个新类解决每一个问题。
