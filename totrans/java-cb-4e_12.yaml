- en: Chapter 12\. Network Clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 12.0 Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java can be used to write many types of networked programs. In traditional socket-based
    code, the programmer is responsible for structuring the interaction between the
    client and server; the TCP *socket code* simply ensures that whatever data you
    send gets to the other end. In higher-level types, such as HTTP, RMI, CORBA, and
    EJB, the software takes over more control. Sockets are often used for connecting
    to legacy servers; if you were writing a new application from scratch, you’d be
    better off using a higher-level service.
  prefs: []
  type: TYPE_NORMAL
- en: It may be helpful to compare sockets with the telephone system. Telephones were
    originally used for analog voice traffic, which is pretty unstructured. Then it
    began to be used for some layered applications; the first widely popular one was
    facsimile transmission, or fax. Where would fax be without the widespread availability
    of voice telephony? The second wildly popular layered application historically
    was dial-up TCP/IP. This coexisted with the web to become popular as a mass-market
    service. Where would dial-up IP be without widely deployed voice lines? And where
    would the internet be without dial-up IP? Fax and dial-up are mostly gone now,
    but they paved the way for your smartphone’s networked ability, which is what
    makes it useful (and even seductive as a time sink).
  prefs: []
  type: TYPE_NORMAL
- en: Sockets are layered like that too. The web, RMI, JDBC, CORBA, and EJB are all
    layered on top of sockets. HTTP is now the most common protocol and should generally
    be used for new applications when all you want is to get data from point b to
    point a.
  prefs: []
  type: TYPE_NORMAL
- en: Ever since the alpha release of Java (originally as a sideline to the HotJava
    browser) in May 1995, Java has been popular as a programming language for building
    network applications. It’s easy to see why, particularly if you’ve ever built
    a networked application in C. First, C programmers have to worry about the platform
    they are on. Unix uses synchronous sockets, which work rather like normal disk
    files vis-à-vis reading and writing, whereas Microsoft OSes use asynchronous sockets,
    which use callbacks to notify when a read or write has completed. Java glosses
    over this distinction. Further, the amount of code needed to set up a socket in
    C is intimidating. Just for fun, [Example 12-1](#javacook-netclient-EX-1) shows
    the typical C code for setting up a client socket. And remember, this is only
    the Unix part. And only the part that makes and closes the connection. To be portable
    to Windows, it would need some additional conditional code (using C’s `#ifdef`
    mechanism). C’s `#include` mechanism requires that exactly the right files be
    included, and some files have to be listed in particular orders (Java’s `import`
    mechanism is much more flexible).
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-1\. main/src/main/java/network/Connect.c (C client setup)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the first recipe, we’ll see how to do the connect in essentially one line
    of Java (plus a bit of error handling). We’ll then cover error handling and transferring
    data over a socket. Next, we’ll take a quick look at a `datagram` or UDP client
    that implements most of the TFTP (Trivial File Transfer Protocol) that has been
    used for two decades to boot diskless workstations. We’ll end with a program that
    connects interactively to a chat server.
  prefs: []
  type: TYPE_NORMAL
- en: A common theme through most of these client examples is to use existing servers
    so that we don’t have to generate both the client and the server at the same time.
    Most of these are services that exist on any standard Unix platform. If you can’t
    find a Unix server near you to try them on, let me suggest that you take an old
    PC, maybe one that’s underpowered for running the latest Microsoft software, and
    put up a free, open source Unix system on it. My personal favorite is [OpenBSD](https://openbsd.org),
    and the market’s overall favorite is Linux. Both are readily available and can
    be installed for free over the internet, and they offer all the standard services
    used in the client examples, including the time servers and TFTP. Both have free
    Java implementations available.
  prefs: []
  type: TYPE_NORMAL
- en: I also provide basic coverage of web services clients. The term “web services”
    has come to mean program-to-program communication using HTTP. The two general
    categories are SOAP-based and REST-based. REST services are very simple—you send
    an HTTP request and get back a response in plain text, or JSON ([Chapter 14](ch14.html#javacook-json))
    or XML. SOAP is more complicated and not covered in this book. There is more information
    on the client-side connections in [*Java Network Programming*](http://shop.oreilly.com/product/0636920028420.do)
    by Elliotte Harold (O’Reilly). I don’t cover the server-side APIs for building
    web services—JAX-RS and JAX-WS—because these are covered in [several O’Reilly
    books](http://search.oreilly.com/?q=java+enterprise).
  prefs: []
  type: TYPE_NORMAL
- en: 12.1 HTTP/REST Web Client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to read from a URL, for example, to connect to a RESTful web service
    or to download a web page or other resource over HTTP/HTTPS.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the standard Java 11 `HttpClient` or the `URLConnection` class.
  prefs: []
  type: TYPE_NORMAL
- en: This technique applies anytime you need to read from a URL, not just a RESTful
    web service.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Prior to Java 11, you had to either use the `URLConnection` class or download
    and use the older Apache HTTP Client Library. With Java 11, there is a fairly
    easy-to-use and flexible API in standard Java. It also supports HTTP/2.0; which
    the Apache `HttpClient` does not as of early 2020, and the legacy `URLConnection`,
    which is unlikely ever to support HTTP/2.0.
  prefs: []
  type: TYPE_NORMAL
- en: As our simple example, we’ll use Google’s Suggest service, that is, what you
    see when you type the first few characters of a search into the Google web search
    engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'This Google service supports various output formats. The base URL is just the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Append to it the word you want suggestions on. The `client=firefox` tells it
    we want a simple JSON format; with `client=chrome` it contains more fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the Java HTTP Client API, you need a `HttpClient` object, which you
    get using the Builder pattern, then create a `Request` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `HttpRequest` object can be sent using the client to get a `HttpResponse`
    object, from which you can get the status and/or the body. Sending can be done
    either synchronously (if you need the results right away) or asynchronously (if
    you can usefully do something else in the meantime). This example shows sending
    it both synchronously and asynchronously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output; the line has been broken at commas to make it fit on the
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Should you not wish to use the `HttpClient` library, you *could* use the legacy
    code in `java.net`, since all we usually need here is the ability to open and
    read from a URL. Here is the code using a `URLConnection`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The output should be identical to what the `HttpClient` version produced.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Don’t confuse this `HttpClient` with the [older Apache HttpClient Library](https://hc.apache.org/httpcomponents-client-ga/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information on REST services (including implementing the server-side
    components for them) in Bill Burke’s [*RESTful Java with JAX-RS 2.0, 2nd Edition*](http://shop.oreilly.com/product/0636920028925.do)
    (O’Reilly).
  prefs: []
  type: TYPE_NORMAL
- en: 12.2 Contacting a Socket Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to contact a server using TCP/IP.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just create a `java.net.Socket`, passing the hostname and port number into the
    constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There isn’t much to this in Java. When creating a socket, you pass in the hostname
    and the port number. The `java.net.Socket` constructor does the `gethostbyname()`
    and the `socket()` system call, sets up the server’s `sockaddr_in` structure,
    and executes the `connect()` call. All you have to do is catch the errors, which
    are subclassed from the familiar `IOException`. [Example 12-2](#javacook-netclient-EX-2)
    sets up a Java network client but doesn’t actually do any I/O yet. It uses try-with-resources
    to ensure that the socket is closed automatically when we are done with it.
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-2\. main/src/main/java/network/ConnectSimple.java (simple client
    connection)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This version does no real error reporting, but a version called *ConnectFriendly*
    does; we’ll see this version in [Recipe 12.4](#javacook-netclient-SECT-3).
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Java supports other ways of using network applications. You can also open a
    URL and read from it (see [Recipe 12.8](#javacook-netserver-SECT-8-ch15)). You
    can write code so that it will run from a URL, when opened in a web browser, or
    from an application.
  prefs: []
  type: TYPE_NORMAL
- en: 12.3 Finding and Reporting Network Addresses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to look up a host’s address name or number or get the address at the
    other end of a network connection.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Get an `InetAddress` object.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `InetAddress` object represents the internet address of a given computer
    or host. It has no public constructors; you obtain an `InetAddress` by calling
    the static `getByName()` method, passing in either a hostname like *darwinsys.com*
    or a network address as a string, like 1.23.45.67\. All the “lookup” methods in
    this class can throw the checked `UnknownHostException` (a subclass of `java.io.IOException`),
    which must be caught or declared on the calling method’s header. None of these
    methods actually contact the remote host, so they do not throw the other exceptions
    related to network connections.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method `getHostAddress()` gives you the numeric IP address (as a string)
    corresponding to the `InetAddress`. The inverse is `getHostName()`, which reports
    the name of the `InetAddress`. This can be used to print the address of a host
    given its name, or vice versa:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also get an `InetAddress` from a `Socket` by calling its `getInetAddress()`
    method. You can construct a `Socket` using an `InetAddress` instead of a hostname
    string. So, to connect to port number `myPortNumber` on the same host as an existing
    socket, you’d use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Finally, to look up all the addresses associated with a host—a server may be
    on more than one network—use the static method `getAllByName(host)`, which returns
    an array of `InetAddress` objects, one for each IP address associated with the
    given name.
  prefs: []
  type: TYPE_NORMAL
- en: A static method `getLocalHost()` returns an `InetAddress` equivalent to `localhost`
    or 127.0.0.1\. This can be used to connect to a server program running on the
    same machine as the client.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using IPv6, you can use `Inet6Address` instead.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See `NetworkInterface` in [Recipe 13.2](ch13.html#javacook-netserver-SECT-10),
    which lets you find out more about the networking of the machine you are running
    on. There is no way to look up services in the standard API yet—that is, to find
    out that the HTTP service is on port 80\. Full implementations of TCP/IP have
    always included an additional set of resolvers; in C, the call `getservbyname("http"`,
    "`tcp");` would look up the given service^([1](ch12.html#idm45290645651848)) and
    return a `servent` (service entry) structure whose `s_port` member would contain
    the value 80\. The numbers of established services do not change, but when services
    are new or installed in nonroutine ways, it is convenient to be able to change
    the service number for all programs on a machine or network (regardless of programming
    language) just by changing the services definitions. Java should provide this
    capability in a future release.
  prefs: []
  type: TYPE_NORMAL
- en: 12.4 Handling Network Errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want more detailed reporting than just `IOException` if something goes wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Catch a greater variety of exception classes. `SocketException` has several
    subclasses; the most notable are `ConnectException` and `NoRouteToHostException`.
    The names are self-explanatory: the first means that the connection was refused
    by the machine at the other end (the server machine), and the second completely
    explains the failure. [Example 12-3](#javacook-netclient-EX-3) is an excerpt from
    the `Connect` program, enhanced to handle these conditions.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-3\. ConnectFriendly.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 12.5 Reading and Writing Textual Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having connected, you wish to transfer textual data.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Construct a `BufferedReader` or `PrintWriter` from the socket’s `getInputStream()`
    or `getOutputStream()`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Socket` class has methods that allow you to get an `InputStream` or `OutputStream`
    to read from or write to the socket. It has no method to fetch a `Reader` or `Writer`,
    partly because some network services are limited to ASCII, but mainly because
    the `Socket` class was decided on before there were `Reader` and `Writer` classes.
    You can always create a `Reader` from an `InputStream` or a `Writer` from an `OutputStream`
    using the conversion classes. This is the paradigm for the two most common forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 12-4](#javacook-netclient-EX-4) reads a line of text from the daytime
    service, which is offered by full-fledged TCP/IP suites (such as those included
    with most Unixes). You don’t have to send anything to the `Daytime` server; you
    simply connect and read one line. The server writes one line containing the date
    and time and then closes the connection.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Running it looks like the following code. I started by getting the current
    date and time on the local host, then ran the `DaytimeText` program to see the
    date and time on the server (machine *darian* is one of my Unix servers):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The code is in class `DaytimeText`, shown in [Example 12-4](#javacook-netclient-EX-4).
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-4\. DaytimeText.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The second example, shown in [Example 12-5](#javacook-netclient-EX-5), shows
    both reading and writing on the same socket. The `Echo` server simply echoes back
    whatever lines of text you send it. It’s not a very clever server, but it is a
    useful one. It helps in network testing and also in testing clients of this type!
  prefs: []
  type: TYPE_NORMAL
- en: The `converse()` method holds a short conversation with the `Echo` server on
    the named host; if no host is named, it tries to contact `localhost`, a universal
    alias^([2](ch12.html#idm45290645253384)) for the machine the program is running
    on.
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-5\. main/src/main/java/network/EchoClientOneLine.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: It might be a good exercise to isolate the reading and writing code from this
    method into a `NetWriter` class, possibly subclassing `PrintWriter` and adding
    the `\r\n` and the flushing.
  prefs: []
  type: TYPE_NORMAL
- en: 12.6 Reading and Writing Binary or Serialized Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having connected, you wish to transfer binary data, either raw binary data or
    serialized Java objects.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For plain binary date, construct a `DataInputStream` or `DataOutputStream` from
    the socket’s `getInputStream()` or `getOutputStream()`. For serialized Java object
    data, construct an `ObjectInputStream` or `ObjectOutputStream`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The simplest paradigm for reading/writing on a socket is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If the volume of data might be large, insert a buffered stream for efficiency.
    The paradigm is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The program example in [Example 12-6](#javacook-netclient-EX-6) uses another
    standard service that gives out the time as a binary integer representing the
    number of seconds since 1900\. Because the Java `Date` class base is 1970, we
    convert the time base by subtracting the difference between 1970 and 1900\. When
    I used this exercise in a course, most of the students wanted to *add* this time
    difference, reasoning that 1970 is later. But if you think clearly, you’ll see
    that there are fewer seconds between 1999 and 1970 than there are between 1999
    and 1900, so subtraction gives the correct number of seconds. And because the
    `Date` constructor needs milliseconds, we multiply the number of seconds by 1,000.
  prefs: []
  type: TYPE_NORMAL
- en: The time difference is the number of years multiplied by 365, plus the number
    of leap days between the two dates (in the years 1904, 1908, . . . , 1968)—19
    days.
  prefs: []
  type: TYPE_NORMAL
- en: 'The integer that we read from the server is a C-language `unsigned int`. But
    Java doesn’t provide an unsigned integer type; normally when you need an unsigned
    number, you use the next-larger integer type, which would be `long`. But Java
    also doesn’t give us a method to read an unsigned integer from a data stream.
    The `DataInputStream` method `readInt()` reads Java-style signed integers. There
    are `readUnsignedByte()` methods and `readUnsignedShort()` methods, but no `readUnsignedInt()`
    method. Accordingly, we synthesize the ability to read an unsigned `int` (which
    must be stored in a `long`, or else you’d lose the signed bit and be back where
    you started from) by reading unsigned bytes and reassembling them using Java’s
    bit-shifting operators:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the code, we use the new date/time API (see [Chapter 6](ch06.html#javacook-dates))
    to construct and print a `LocalDateTime` object to show the current date and time
    on the local (client) machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The name *aragorn* is the hostname of one of my OpenBSD Unix computers. Looking
    at the output, you can see that the server agrees within a second or two. That
    confirms the date calculation code in [Example 12-6](#javacook-netclient-EX-6).
    This protocol is commonly known as `rdate`, so the client code is called `RDateClient`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-6\. main/src/main/java/network/RDateClient.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '*Object serialization* is the ability to convert in-memory objects to an external
    form that can be sent serially (a byte at a time). To read or write Java objects
    via serialization, you need only construct an `ObjectInputStream` or `ObjectOutputStream`
    from an `InputStream` or `OutputStream`; in this case, the socket’s `getInputStream()`
    or `getOutputStream()`.'
  prefs: []
  type: TYPE_NORMAL
- en: This program (and its server) provide a service that isn’t a standard part of
    the TCP/IP stack; it’s a service I made up as a demo. The server for this service
    is introduced in [Recipe 13.3](ch13.html#javacook-netserver-SECT-2). The client
    code in [Example 12-7](#javacook-netclient-EX-7) is quite similar to the `DaytimeBinary`
    program in the previous recipe, but the server sends us a `LocalDateTime` object
    already constructed. [Example 12-7](#javacook-netclient-EX-7) shows the portion
    of the client code that differs from [Example 12-6](#javacook-netclient-EX-6).
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-7\. main/src/main/java/network/DaytimeObject.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'I ask the operating system for the date and time, and then I run the program,
    which prints the date and time on a remote machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Again, the results agree within a few seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 12.7 UDP Datagrams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to use a datagram connection (UDP) instead of a stream connection (TCP).
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use `DatagramSocket` and `DatagramPacket`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Datagram network traffic is a kindred spirit to the underlying packet-based
    Ethernet and IP (Internet Protocol) layers. Unlike a stream-based connection such
    as TCP, datagram transports like UDP transmit each *packet*, or chunk of data,
    as a single entity with no necessary relation to any other.^([3](ch12.html#idm45290644551496))
    A common analogy is that TCP is like talking on the telephone, whereas UDP is
    like sending postcards or maybe fax messages.
  prefs: []
  type: TYPE_NORMAL
- en: The differences show up most in error handling. Packets can, like postcards,
    go astray. When was the last time the postman rang your bell to tell you that
    the post office had lost one of several postcards it was supposed to deliver to
    you? That’s not going to happen, because the post office doesn’t keep track of
    postcards. On the other hand, when you’re talking on the phone and there’s a noise
    burst—like somebody yelling in the room, or even a bad connection—you notice the
    failure in real time, and you can ask the person at the other end to repeat what
    they just said.
  prefs: []
  type: TYPE_NORMAL
- en: 'With a stream-based connection like a TCP socket, the network transport layer
    handles errors for you: it asks the other end to retransmit. With a datagram transport
    such as UDP, you have to handle retransmission yourself. It’s kind of like numbering
    the postcards you send so that you can go back and resend any that don’t arrive—a
    good excuse to return to your vacation spot, perhaps.'
  prefs: []
  type: TYPE_NORMAL
- en: Another difference is that datagram transmission preserves message boundaries.
    That is, if you write 20 bytes and then write 10 bytes when using TCP, the program
    reading from the other end will not know if you wrote one chunk of 30 bytes, two
    chunks of 15, or even 30 individual characters. With a `DatagramSocket`, you construct
    a `DatagramPacket` object for each buffer, and its contents are sent as a *single*
    entity over the network; its contents will not be mixed together with the contents
    of any other buffer. The `DatagramPacket` object has methods like `getLength()`
    and `setPort()`.
  prefs: []
  type: TYPE_NORMAL
- en: So why would we even use UDP? UDP has a lot less overhead than TCP, which can
    be particularly valuable when sending huge amounts of data over a reliable local
    network or a few hops on the internet. Over long-haul networks, TCP is probably
    preferred because TCP handles retransmission of lost packets for you. And obviously,
    if preserving record boundaries makes your life easier, that may be a reason for
    considering UDP. UDP is also the way to perform Multicast (broadcast to many receivers
    simultaneously), though Multicast is out of scope for this discussion.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 12-8](#javacook-netclient-EX-8) is a short program that connects via
    UDP to the `Daytime` date and time server used in [Recipe 12.5](#javacook-netclient-SECT-4).
    Because UDP has no real notion of connection, the client typically initiates the
    conversation, which sometimes means sending an empty packet; the UDP server uses
    the address information it gets from that to return its response.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-8\. main/src/main/java/network/DaytimeUDP.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'I’ll run it to my Unix box just to be sure that it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 12.8 URI, URL, or URN?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having heard these terms, you want to know the difference between a URI, URL,
    and URN.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Read on. Or see the javadoc for *java.net.uri*.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A URL is the traditional name for a network address consisting of a scheme
    (like HTTP) and an address (site name) and resource or pathname. But there are
    three distinct terms in all:'
  prefs: []
  type: TYPE_NORMAL
- en: URI (Uniform Resource Identifier)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: URL (Uniform Resource Locator)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: URN (Uniform Resource Name)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A discussion near the end of the Java documentation for the new class explains
    the relationship among URI, URL, and URN. URIs form the set of all identifiers.
    URLs and URNs are subsets.
  prefs: []
  type: TYPE_NORMAL
- en: URIs are the most general; a URI is parsed for basic syntax without regard to
    the scheme, if any, that it specifies, and it need not refer to a particular server.
    A URL includes a hostname, scheme, and other components; the string is parsed
    according to rules for its scheme. When you construct a URL, an `InputStream`
    is created automatically. URNs name resources but do not explain how to locate
    them; typical examples of URNs that you will have seen include `mailto:` and `news:`
    references.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main operations provided by the `URI` class are normalization (removing
    extraneous path segments including “..”) and relativization (this should be called
    “making relative,” but somebody wanted a single word to make a method name). A
    `URI` object does not have any methods for opening the URI; for that, you would
    normally use a string representation of the URI to construct a URL object, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The program in [Example 12-9](#javacook-netserver-EX-6) shows examples of normalizating,
    making relative, and constructing a URL from a URI.
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-9\. main/src/main/java/network/URIDemo.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '12.9 Program: TFTP UDP Client'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This program implements the client half of the TFTP application protocol, a
    once-well-known service that has been used in the Unix world for network booting
    of workstations since before Windows 3.1, now primarily used for network bootstrapping
    of computers. I chose this protocol because it’s widely implemented on the server
    side, so it’s easy to find a test server for it.
  prefs: []
  type: TYPE_NORMAL
- en: The TFTP protocol is a bit odd. The client contacts the server on the well-known
    UDP port number 69, from a generated port number,^([4](ch12.html#idm45290643937208))
    and the server responds to the client from a generated port number. Further communication
    is on the two generated port numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Getting into more detail, as shown in [Figure 12-1](#javacook-netclient-FIG-1),
    the client initially sends a read request with the filename and reads the first
    packet of data. The read request consists of two bytes (a `short`) with the read
    request code (short integer with a value of 1, defined as `OP_RRQ`), two bytes
    for the sequence number, then the ASCII filename, null terminated, and the mode
    string, also null terminated. The server reads the read request from the client,
    verifies that it can open the file and, if so, sends the first data packet (`OP_DATA`),
    and then reads again. The client reads from its end and, if the read is OK, turns
    the packet into an acknowledgement packet, and sends it. This read-acknowledge
    cycle is repeated until all the data is read. Note that each packet is 516 bytes
    (512 bytes of data, plus 2 bytes for the packet type and 2 more for the packet
    number) except the last, which can be any length from 4 (zero bytes of data) to
    515 (511 bytes of data). If a network I/O error occurs, the packet is resent.
    If a given packet goes astray, both client and server are supposed to perform
    a timeout cycle. This client does not, but the server does. You could add timeouts
    either using a thread (see [Recipe 16.4](ch16.html#javacook-threads-SECT-4)) or
    by invoking `setSoTimeout()` on the socket and, if packets do get lost, catching
    the `SocketTimeoutException`, retransmitting the ACK (or RRQ), perhaps up to some
    max number of attempts. This is left as an exercise for the reader. The current
    version of the client code is shown in [Example 12-10](#javacook-netclient-EX-9).
  prefs: []
  type: TYPE_NORMAL
- en: '![jcb4 1201](assets/jcb4_1201.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-1\. The TFTP protocol packet formats
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Example 12-10\. main/src/main/java/network/RemCat.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To test this client, you need a TFTP server. If you are on a Unix system that
    you administer, you can enable the TFTP server to test this client just by editing
    the file */etc/inetd.conf* and restarting or reloading the *inetd* server (Linux
    uses a different mechanism, which may vary depending on which distribution you
    are on). *inetd* is a program that listens for a wide range of connections and
    starts the servers only when a connection from a client comes along (a kind of
    lazy evaluation).^([5](ch12.html#idm45290643677448)) I set up the traditional
    */tftpboot* directory, put this line in my *inetd.conf*, and reloaded `inetd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Then I put a few test files, one named *foo*, into the */tftpboot* directory.
    Running
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'produced what looked like the file. But just to be safe, I tested the output
    of `RemCat` against the original file, using the Unix *diff* comparison program.
    No news is good news:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'So far so good. Let’s not slip this program on an unsuspecting network without
    exercising the error handling at least briefly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '12.10 Program: Sockets-Based Chat Client'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This program is a simple chat program. You can’t break in on ICQ or AIM with
    it, because they each use their own protocol.^([6](ch12.html#idm45290643134536))
    Rather, this program simply writes to and reads from a server. The server for
    this will be presented in [Chapter 13](ch13.html#javacook-netserver). How does
    it look when you run it? [Figure 12-2](#javacook-netclient-FIG-2) shows me chatting
    all by myself one day.
  prefs: []
  type: TYPE_NORMAL
- en: The code is reasonably self-explanatory. We read from the remote server in a
    thread to make the input and the output run without blocking each other; this
    is discussed in [Chapter 16](ch16.html#javacook-threads). The reading and writing
    are discussed in this chapter. The program is shown in [Example 12-11](#javacook-netclient-EX-11).
  prefs: []
  type: TYPE_NORMAL
- en: '![jcb4 1202](assets/jcb4_1202.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-2\. Chat client in action
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Example 12-11\. main/src/main/java/chat/ChatClient.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many better-structured ways to write a chat client, including WebSockets,
    RMI, and JMS. RMI is Java’s RPC interface and is included both in Java SE and
    Java EE; it is not described in this edition of this book, but you can find the
    RMI chapter from previous editions on the [my website](http://darwinsys.com/java/rmi).
    The other technologies are part of the Java Enterprise so, again, I refer you
    to Arun Gupta’s *[Java EE 7 Essentials](http://shop.oreilly.com/product/0636920030614.do)*.
  prefs: []
  type: TYPE_NORMAL
- en: If your communication goes over the public internet, you do need to encrypt
    your socket connection, so check out Sun’s JSSE (Java Secure Socket Extension).
    If you took my earlier advice and used the standard HTTP protocol, you can encrypt
    the conversation just by changing the URL to https.
  prefs: []
  type: TYPE_NORMAL
- en: For a good overview of network programming from the C programmer’s point of
    view, see the late W. Richard Stevens’ *Unix Network Programming* (Prentice Hall).
    Despite the book’s name, it’s really about socket and TCP/IP/UDP programming and
    covers all parts of the (Unix) networking API and protocols such as TFTP in amazing
    detail.
  prefs: []
  type: TYPE_NORMAL
- en: '12.11 Program: Simple HTTP Link Checker'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Checking links is an ongoing problem for website owners as well as those who
    write technical documentation that links to external sources (e.g., people like
    the author of the book you are now reading). *Link checkers* are the tool they
    inevitably use to validate the links in their pages, be they web pages or book
    pages. Implementing a link checker is basically a matter of (a) extracting links
    and (b) opening them. Thus, we have the program in [Example 12-12](#javacook-netclient-ex-kwiklinkchecker).
    I call it `KwikLinkChecker` as it is a bit on the quick-and-dirty side—it doesn’t
    validate the content of the link to be sure it still contains what it once did;
    so if, say, an open source project forgets to renew its domain registration, and
    it gets taken over by a porn site, well, `KwikLinkChecker` will never know. But
    that said, it does its job reasonably well, and reasonably quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-12\. darwinsys-api/src/main/java/com/darwinsys/tools/KwikLinkChecker.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Fancier link checkers are surely available, but this one works for me.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch12.html#idm45290645651848-marker)) The location where it is looked up
    varies. It might be in a file named */etc/services* on Unix; in the *services*
    file in a subdirectory of *\ or _\winnt* in Windows; in a centralized registry
    such as Sun’s Network Information Services (NIS, formerly YP); or in some other
    platform- or network-dependent location.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch12.html#idm45290645253384-marker)) It used to be universal, when most
    networked systems were administered by full-time systems people who had been trained
    or served an apprenticeship. Today many machines on the internet don’t have `localhost`
    configured properly.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch12.html#idm45290644551496-marker)) The UDP packet may need to be fragmented
    by some networks, but this is not germane to us at the UDP level, because it will
    reassemble the network packets into our single-entity UDP packet at the other
    end.
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch12.html#idm45290643937208-marker)) When the application doesn’t care,
    these port numbers are usually made up by the operating system. For example, when
    you call a company from a pay phone or cell phone, the company doesn’t usually
    care what number you are calling from, and if it does, there are ways to find
    out. Generated port numbers generally range from 1024 (the first nonprivileged
    port; see [Chapter 13](ch13.html#javacook-netserver)) to 65535 (the largest value
    that can be held in a 16-bit port number).
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](ch12.html#idm45290643677448-marker)) Beware of security holes; don’t turn
    a TFTP server loose on the internet without first reading a good security book,
    such as [*Building Internet Firewalls*](http://shop.oreilly.com/product/9781565928718.do)
    by D. Chapman et al. (O’Reilly).
  prefs: []
  type: TYPE_NORMAL
- en: ^([6](ch12.html#idm45290643134536-marker)) For an open source program that provides
    an IM service to let you talk to both from the same program, check out Jabber
    at [*http://www.jabber.org*](http://www.jabber.org).
  prefs: []
  type: TYPE_NORMAL
