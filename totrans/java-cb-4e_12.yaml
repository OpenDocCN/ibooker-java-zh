- en: Chapter 12\. Network Clients
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 12.0 Introduction
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java can be used to write many types of networked programs. In traditional socket-based
    code, the programmer is responsible for structuring the interaction between the
    client and server; the TCP *socket code* simply ensures that whatever data you
    send gets to the other end. In higher-level types, such as HTTP, RMI, CORBA, and
    EJB, the software takes over more control. Sockets are often used for connecting
    to legacy servers; if you were writing a new application from scratch, you’d be
    better off using a higher-level service.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: It may be helpful to compare sockets with the telephone system. Telephones were
    originally used for analog voice traffic, which is pretty unstructured. Then it
    began to be used for some layered applications; the first widely popular one was
    facsimile transmission, or fax. Where would fax be without the widespread availability
    of voice telephony? The second wildly popular layered application historically
    was dial-up TCP/IP. This coexisted with the web to become popular as a mass-market
    service. Where would dial-up IP be without widely deployed voice lines? And where
    would the internet be without dial-up IP? Fax and dial-up are mostly gone now,
    but they paved the way for your smartphone’s networked ability, which is what
    makes it useful (and even seductive as a time sink).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Sockets are layered like that too. The web, RMI, JDBC, CORBA, and EJB are all
    layered on top of sockets. HTTP is now the most common protocol and should generally
    be used for new applications when all you want is to get data from point b to
    point a.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Ever since the alpha release of Java (originally as a sideline to the HotJava
    browser) in May 1995, Java has been popular as a programming language for building
    network applications. It’s easy to see why, particularly if you’ve ever built
    a networked application in C. First, C programmers have to worry about the platform
    they are on. Unix uses synchronous sockets, which work rather like normal disk
    files vis-à-vis reading and writing, whereas Microsoft OSes use asynchronous sockets,
    which use callbacks to notify when a read or write has completed. Java glosses
    over this distinction. Further, the amount of code needed to set up a socket in
    C is intimidating. Just for fun, [Example 12-1](#javacook-netclient-EX-1) shows
    the typical C code for setting up a client socket. And remember, this is only
    the Unix part. And only the part that makes and closes the connection. To be portable
    to Windows, it would need some additional conditional code (using C’s `#ifdef`
    mechanism). C’s `#include` mechanism requires that exactly the right files be
    included, and some files have to be listed in particular orders (Java’s `import`
    mechanism is much more flexible).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-1\. main/src/main/java/network/Connect.c (C client setup)
  id: totrans-6
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the first recipe, we’ll see how to do the connect in essentially one line
    of Java (plus a bit of error handling). We’ll then cover error handling and transferring
    data over a socket. Next, we’ll take a quick look at a `datagram` or UDP client
    that implements most of the TFTP (Trivial File Transfer Protocol) that has been
    used for two decades to boot diskless workstations. We’ll end with a program that
    connects interactively to a chat server.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个示例中，我们将看到如何在Java中用基本上一行代码（加上一些错误处理）完成连接。然后，我们将讨论错误处理和通过套接字传输数据。接下来，我们将简要介绍一个实现了大部分已被用于20年来引导无盘工作站的`datagram`或UDP客户端的TFTP（简单文件传输协议）。最后，我们将结束于一个连接到聊天服务器的交互式程序。
- en: A common theme through most of these client examples is to use existing servers
    so that we don’t have to generate both the client and the server at the same time.
    Most of these are services that exist on any standard Unix platform. If you can’t
    find a Unix server near you to try them on, let me suggest that you take an old
    PC, maybe one that’s underpowered for running the latest Microsoft software, and
    put up a free, open source Unix system on it. My personal favorite is [OpenBSD](https://openbsd.org),
    and the market’s overall favorite is Linux. Both are readily available and can
    be installed for free over the internet, and they offer all the standard services
    used in the client examples, including the time servers and TFTP. Both have free
    Java implementations available.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数这些客户端示例的共同主题是使用现有服务器，这样我们就不必同时生成客户端和服务器。这些大多数服务存在于任何标准Unix平台上。如果您找不到附近的Unix服务器来尝试它们，请允许我建议您拿一台旧PC，也许是一台性能不足以运行最新Microsoft软件的PC，并在其上安装一个免费的开源Unix系统。我个人最喜欢的是[OpenBSD](https://openbsd.org)，市场上普遍喜欢的是Linux。这两者都可以通过互联网免费安装，并提供所有在客户端示例中使用的标准服务，包括时间服务器和TFTP。两者都有免费的Java实现可用。
- en: I also provide basic coverage of web services clients. The term “web services”
    has come to mean program-to-program communication using HTTP. The two general
    categories are SOAP-based and REST-based. REST services are very simple—you send
    an HTTP request and get back a response in plain text, or JSON ([Chapter 14](ch14.html#javacook-json))
    or XML. SOAP is more complicated and not covered in this book. There is more information
    on the client-side connections in [*Java Network Programming*](http://shop.oreilly.com/product/0636920028420.do)
    by Elliotte Harold (O’Reilly). I don’t cover the server-side APIs for building
    web services—JAX-RS and JAX-WS—because these are covered in [several O’Reilly
    books](http://search.oreilly.com/?q=java+enterprise).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我还提供了对Web服务客户端的基本覆盖。术语“Web服务”现在已经意味着使用HTTP进行程序间通信。两个一般类别是基于SOAP和基于REST。REST服务非常简单
    — 您发送一个HTTP请求，并获得纯文本或JSON（[第14章](ch14.html#javacook-json)）或XML格式的响应。SOAP更为复杂，本书不涵盖。在Elliotte
    Harold（O'Reilly）的[*Java网络编程*](http://shop.oreilly.com/product/0636920028420.do)中有关客户端连接的更多信息。我不涵盖构建Web服务的服务器端API
    — JAX-RS和JAX-WS，因为这些内容在[几本O'Reilly书籍](http://search.oreilly.com/?q=java+enterprise)中有详细介绍。
- en: 12.1 HTTP/REST Web Client
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12.1 HTTP/REST Web Client
- en: Problem
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to read from a URL, for example, to connect to a RESTful web service
    or to download a web page or other resource over HTTP/HTTPS.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要从URL读取数据，例如连接到RESTful Web服务或通过HTTP/HTTPS下载网页或其他资源。
- en: Solution
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the standard Java 11 `HttpClient` or the `URLConnection` class.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标准Java 11的`HttpClient`或`URLConnection`类。
- en: This technique applies anytime you need to read from a URL, not just a RESTful
    web service.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术适用于任何需要从URL读取数据的情况，不仅限于RESTful Web服务。
- en: Discussion
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Prior to Java 11, you had to either use the `URLConnection` class or download
    and use the older Apache HTTP Client Library. With Java 11, there is a fairly
    easy-to-use and flexible API in standard Java. It also supports HTTP/2.0; which
    the Apache `HttpClient` does not as of early 2020, and the legacy `URLConnection`,
    which is unlikely ever to support HTTP/2.0.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 11之前，您必须使用`URLConnection`类或下载并使用旧版Apache HTTP Client库。使用Java 11后，标准Java中有一个相当易于使用和灵活的API。它还支持HTTP/2.0；而Apache
    `HttpClient`截至2020年初尚不支持HTTP/2.0，而传统的`URLConnection`也不太可能支持HTTP/2.0。
- en: As our simple example, we’ll use Google’s Suggest service, that is, what you
    see when you type the first few characters of a search into the Google web search
    engine.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以我们的简单示例为例，我们将使用Google的建议服务，即当您在Google网络搜索引擎中输入搜索的前几个字符时所看到的内容。
- en: 'This Google service supports various output formats. The base URL is just the
    following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这项Google服务支持各种输出格式。基本URL如下：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Append to it the word you want suggestions on. The `client=firefox` tells it
    we want a simple JSON format; with `client=chrome` it contains more fields.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 将您希望获得建议的单词附加到它。`client=firefox`告诉它我们需要一个简单的JSON格式；使用`client=chrome`它包含更多字段。
- en: 'To use the Java HTTP Client API, you need a `HttpClient` object, which you
    get using the Builder pattern, then create a `Request` object:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Java HTTP客户端API，您需要一个`HttpClient`对象，使用构建器模式获取，然后创建一个`Request`对象：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `HttpRequest` object can be sent using the client to get a `HttpResponse`
    object, from which you can get the status and/or the body. Sending can be done
    either synchronously (if you need the results right away) or asynchronously (if
    you can usefully do something else in the meantime). This example shows sending
    it both synchronously and asynchronously:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpRequest`对象可以使用客户端发送，以获取`HttpResponse`对象，从中您可以获取状态和/或正文。发送可以同步进行（如果您需要立即获得结果）或异步进行（如果在此期间可以有用地执行其他操作）。此示例显示了同时以同步和异步方式发送：'
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here is the output; the line has been broken at commas to make it fit on the
    page:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出；该行已在逗号处换行以适应页面：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Should you not wish to use the `HttpClient` library, you *could* use the legacy
    code in `java.net`, since all we usually need here is the ability to open and
    read from a URL. Here is the code using a `URLConnection`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想使用`HttpClient`库，则*可以*使用`java.net`中的旧代码，因为我们在这里通常只需要打开并从URL读取的能力。这是使用`URLConnection`的代码：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The output should be identical to what the `HttpClient` version produced.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该与`HttpClient`版本产生的完全一致。
- en: See Also
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Don’t confuse this `HttpClient` with the [older Apache HttpClient Library](https://hc.apache.org/httpcomponents-client-ga/index.html).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将此`HttpClient`与[较旧的Apache HttpClient库](https://hc.apache.org/httpcomponents-client-ga/index.html)混淆。
- en: You can find more information on REST services (including implementing the server-side
    components for them) in Bill Burke’s [*RESTful Java with JAX-RS 2.0, 2nd Edition*](http://shop.oreilly.com/product/0636920028925.do)
    (O’Reilly).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Bill Burke的[*RESTful Java with JAX-RS 2.0, 2nd Edition*](http://shop.oreilly.com/product/0636920028925.do)（O’Reilly）中找到更多关于REST服务（包括为其实现服务器端组件）的信息。
- en: 12.2 Contacting a Socket Server
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12.2 联系套接字服务器
- en: Problem
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to contact a server using TCP/IP.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要使用TCP/IP联系服务器。
- en: Solution
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Just create a `java.net.Socket`, passing the hostname and port number into the
    constructor.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 只需创建一个`java.net.Socket`，将主机名和端口号传递给构造函数。
- en: Discussion
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: There isn’t much to this in Java. When creating a socket, you pass in the hostname
    and the port number. The `java.net.Socket` constructor does the `gethostbyname()`
    and the `socket()` system call, sets up the server’s `sockaddr_in` structure,
    and executes the `connect()` call. All you have to do is catch the errors, which
    are subclassed from the familiar `IOException`. [Example 12-2](#javacook-netclient-EX-2)
    sets up a Java network client but doesn’t actually do any I/O yet. It uses try-with-resources
    to ensure that the socket is closed automatically when we are done with it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中并不复杂。创建套接字时，传递主机名和端口号。`java.net.Socket`构造函数执行`gethostbyname()`和`socket()`系统调用，设置服务器的`sockaddr_in`结构，并执行`connect()`调用。您只需捕获错误，这些错误是从熟悉的`IOException`继承的子类。[示例
    12-2](#javacook-netclient-EX-2)设置了Java网络客户端，但实际上尚未执行任何I/O操作。它使用try-with-resources确保当我们完成时套接字会自动关闭。
- en: Example 12-2\. main/src/main/java/network/ConnectSimple.java (simple client
    connection)
  id: totrans-43
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-2\. main/src/main/java/network/ConnectSimple.java（简单客户端连接）
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This version does no real error reporting, but a version called *ConnectFriendly*
    does; we’ll see this version in [Recipe 12.4](#javacook-netclient-SECT-3).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 此版本不进行实际错误报告，但名为*ConnectFriendly*的版本进行了；我们将在[Recipe 12.4](#javacook-netclient-SECT-3)中看到此版本。
- en: See Also
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Java supports other ways of using network applications. You can also open a
    URL and read from it (see [Recipe 12.8](#javacook-netserver-SECT-8-ch15)). You
    can write code so that it will run from a URL, when opened in a web browser, or
    from an application.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Java支持其他使用网络应用程序的方式。您还可以打开URL并从中读取（请参阅[Recipe 12.8](#javacook-netserver-SECT-8-ch15)）。您可以编写代码，以便在Web浏览器中打开时从URL运行，或者从应用程序中运行。
- en: 12.3 Finding and Reporting Network Addresses
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12.3 查找和报告网络地址
- en: Problem
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to look up a host’s address name or number or get the address at the
    other end of a network connection.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望查找主机的地址名称或编号，或获取网络连接的另一端的地址。
- en: Solution
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Get an `InetAddress` object.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 获取一个`InetAddress`对象。
- en: Discussion
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The `InetAddress` object represents the internet address of a given computer
    or host. It has no public constructors; you obtain an `InetAddress` by calling
    the static `getByName()` method, passing in either a hostname like *darwinsys.com*
    or a network address as a string, like 1.23.45.67\. All the “lookup” methods in
    this class can throw the checked `UnknownHostException` (a subclass of `java.io.IOException`),
    which must be caught or declared on the calling method’s header. None of these
    methods actually contact the remote host, so they do not throw the other exceptions
    related to network connections.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`InetAddress`对象表示给定计算机或主机的互联网地址。它没有公共构造函数；您通过调用静态的`getByName()`方法获取`InetAddress`，传递主机名如*darwinsys.com*或网络地址作为字符串，如1.23.45.67。该类中的所有“查找”方法都可以抛出已检查的`UnknownHostException`（`java.io.IOException`的子类），必须在调用方法的头部捕获或声明。这些方法实际上不联系远程主机，因此它们不会抛出与网络连接相关的其他异常。'
- en: 'The method `getHostAddress()` gives you the numeric IP address (as a string)
    corresponding to the `InetAddress`. The inverse is `getHostName()`, which reports
    the name of the `InetAddress`. This can be used to print the address of a host
    given its name, or vice versa:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 方法`getHostAddress()`给出与`InetAddress`对应的数值IP地址（作为字符串）。其反向是`getHostName()`，它报告`InetAddress`的名称。这可用于根据名称打印主机的地址，或反之亦然：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can also get an `InetAddress` from a `Socket` by calling its `getInetAddress()`
    method. You can construct a `Socket` using an `InetAddress` instead of a hostname
    string. So, to connect to port number `myPortNumber` on the same host as an existing
    socket, you’d use this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过调用其`getInetAddress()`方法从`Socket`中获取`InetAddress`。你可以使用`InetAddress`而不是主机名字符串构造`Socket`。因此，要连接到与现有套接字上相同主机上的端口号`myPortNumber`，可以使用以下代码：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Finally, to look up all the addresses associated with a host—a server may be
    on more than one network—use the static method `getAllByName(host)`, which returns
    an array of `InetAddress` objects, one for each IP address associated with the
    given name.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，要查找与主机关联的所有地址（服务器可能在多个网络上），请使用静态方法`getAllByName(host)`，它返回一个`InetAddress`对象数组，每个IP地址关联一个给定名称。
- en: A static method `getLocalHost()` returns an `InetAddress` equivalent to `localhost`
    or 127.0.0.1\. This can be used to connect to a server program running on the
    same machine as the client.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法`getLocalHost()`返回等同于`localhost`或127.0.0.1的`InetAddress`。这可用于连接到作为客户端正在运行的同一计算机上运行的服务器程序。
- en: If you are using IPv6, you can use `Inet6Address` instead.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用IPv6，可以使用`Inet6Address`。
- en: See Also
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: See `NetworkInterface` in [Recipe 13.2](ch13.html#javacook-netserver-SECT-10),
    which lets you find out more about the networking of the machine you are running
    on. There is no way to look up services in the standard API yet—that is, to find
    out that the HTTP service is on port 80\. Full implementations of TCP/IP have
    always included an additional set of resolvers; in C, the call `getservbyname("http"`,
    "`tcp");` would look up the given service^([1](ch12.html#idm45290645651848)) and
    return a `servent` (service entry) structure whose `s_port` member would contain
    the value 80\. The numbers of established services do not change, but when services
    are new or installed in nonroutine ways, it is convenient to be able to change
    the service number for all programs on a machine or network (regardless of programming
    language) just by changing the services definitions. Java should provide this
    capability in a future release.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 参见[第13.2节](ch13.html#javacook-netserver-SECT-10)中的`NetworkInterface`，它允许您更多地了解正在运行的计算机的网络。目前标准API中没有查找服务的方法，也就是说，无法查找HTTP服务位于80端口的方法。TCP/IP的完整实现始终包括一组额外的解析器；在C中，调用`getservbyname("http",
    "tcp");`将查找给定服务^([1](ch12.html#idm45290645651848))，并返回一个`servent`（服务条目）结构，其`s_port`成员将包含值80。已建立服务的编号不会更改，但是当服务是新的或以非例行方式安装时，通过更改服务定义可以方便地更改机器或网络上所有程序的服务号码（无论编程语言如何）。Java应在未来的发布版本中提供此功能。
- en: 12.4 Handling Network Errors
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12.4 处理网络错误
- en: Problem
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want more detailed reporting than just `IOException` if something goes wrong.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现问题，您需要比仅有`IOException`更详细的报告。
- en: Solution
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Catch a greater variety of exception classes. `SocketException` has several
    subclasses; the most notable are `ConnectException` and `NoRouteToHostException`.
    The names are self-explanatory: the first means that the connection was refused
    by the machine at the other end (the server machine), and the second completely
    explains the failure. [Example 12-3](#javacook-netclient-EX-3) is an excerpt from
    the `Connect` program, enhanced to handle these conditions.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获更多种类的异常类。`SocketException`有几个子类；最显著的是`ConnectException`和`NoRouteToHostException`。名称是不言自明的：第一个意味着连接被另一端的机器（服务器机器）拒绝，第二个完全解释了失败。[示例 12-3](#javacook-netclient-EX-3)是`Connect`程序的摘录，增强了处理这些条件。
- en: Example 12-3\. ConnectFriendly.java
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-3\. ConnectFriendly.java
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 12.5 Reading and Writing Textual Data
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12.5 读取和写入文本数据
- en: Problem
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Having connected, you wish to transfer textual data.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 已连接，您希望传输文本数据。
- en: Solution
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Construct a `BufferedReader` or `PrintWriter` from the socket’s `getInputStream()`
    or `getOutputStream()`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 从套接字的`getInputStream()`或`getOutputStream()`构造一个`BufferedReader`或`PrintWriter`。
- en: Discussion
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'The `Socket` class has methods that allow you to get an `InputStream` or `OutputStream`
    to read from or write to the socket. It has no method to fetch a `Reader` or `Writer`,
    partly because some network services are limited to ASCII, but mainly because
    the `Socket` class was decided on before there were `Reader` and `Writer` classes.
    You can always create a `Reader` from an `InputStream` or a `Writer` from an `OutputStream`
    using the conversion classes. This is the paradigm for the two most common forms:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`Socket`类有允许您获取用于从套接字读取或写入的`InputStream`或`OutputStream`的方法。它没有获取`Reader`或`Writer`的方法，部分原因是一些网络服务仅限于ASCII，但主要原因是在有`Reader`和`Writer`类之前就决定了`Socket`类。您可以始终使用转换类从`InputStream`创建`Reader`或从`OutputStream`创建`Writer`。这是两种最常见形式的范例：'
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[Example 12-4](#javacook-netclient-EX-4) reads a line of text from the daytime
    service, which is offered by full-fledged TCP/IP suites (such as those included
    with most Unixes). You don’t have to send anything to the `Daytime` server; you
    simply connect and read one line. The server writes one line containing the date
    and time and then closes the connection.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 12-4](#javacook-netclient-EX-4)从白天服务读取一行文本，这种服务由全功能的TCP/IP套件（例如大多数Unix系统中包含的套件）提供。您不必向`Daytime`服务器发送任何内容；您只需连接并读取一行。服务器写入包含日期和时间的一行，然后关闭连接。'
- en: 'Running it looks like the following code. I started by getting the current
    date and time on the local host, then ran the `DaytimeText` program to see the
    date and time on the server (machine *darian* is one of my Unix servers):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 运行它看起来像以下代码。我首先在本地主机上获取当前日期和时间，然后运行`DaytimeText`程序以查看服务器（机器*darian*是我的Unix服务器之一）上的日期和时间：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The code is in class `DaytimeText`, shown in [Example 12-4](#javacook-netclient-EX-4).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 代码位于`DaytimeText`类中，显示在[示例 12-4](#javacook-netclient-EX-4)中。
- en: Example 12-4\. DaytimeText.java
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-4\. DaytimeText.java
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The second example, shown in [Example 12-5](#javacook-netclient-EX-5), shows
    both reading and writing on the same socket. The `Echo` server simply echoes back
    whatever lines of text you send it. It’s not a very clever server, but it is a
    useful one. It helps in network testing and also in testing clients of this type!
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个示例，显示在[示例 12-5](#javacook-netclient-EX-5)中，显示了在同一个套接字上的读取和写入。`Echo`服务器简单地回显您发送的任何文本行。它不是一个非常聪明的服务器，但它是一个有用的服务器。它有助于网络测试，也有助于测试这类客户端！
- en: The `converse()` method holds a short conversation with the `Echo` server on
    the named host; if no host is named, it tries to contact `localhost`, a universal
    alias^([2](ch12.html#idm45290645253384)) for the machine the program is running
    on.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`converse()`方法与名为主机上的`Echo`服务器进行简短对话；如果没有指定主机，则尝试联系`localhost`，这是程序正在运行的机器的通用别名^([2](ch12.html#idm45290645253384))。'
- en: Example 12-5\. main/src/main/java/network/EchoClientOneLine.java
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-5\. main/src/main/java/network/EchoClientOneLine.java
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It might be a good exercise to isolate the reading and writing code from this
    method into a `NetWriter` class, possibly subclassing `PrintWriter` and adding
    the `\r\n` and the flushing.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 将读取和写入代码从此方法中隔离出来，可能是一个好的练习，可以将其封装到一个`NetWriter`类中，可能是`PrintWriter`的子类，并添加`\r\n`和刷新操作。
- en: 12.6 Reading and Writing Binary or Serialized Data
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12.6 读取和写入二进制或序列化数据
- en: Problem
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Having connected, you wish to transfer binary data, either raw binary data or
    serialized Java objects.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 已连接，您希望传输二进制数据，无论是原始二进制数据还是序列化的Java对象。
- en: Solution
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: For plain binary date, construct a `DataInputStream` or `DataOutputStream` from
    the socket’s `getInputStream()` or `getOutputStream()`. For serialized Java object
    data, construct an `ObjectInputStream` or `ObjectOutputStream`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The simplest paradigm for reading/writing on a socket is this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If the volume of data might be large, insert a buffered stream for efficiency.
    The paradigm is this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The program example in [Example 12-6](#javacook-netclient-EX-6) uses another
    standard service that gives out the time as a binary integer representing the
    number of seconds since 1900\. Because the Java `Date` class base is 1970, we
    convert the time base by subtracting the difference between 1970 and 1900\. When
    I used this exercise in a course, most of the students wanted to *add* this time
    difference, reasoning that 1970 is later. But if you think clearly, you’ll see
    that there are fewer seconds between 1999 and 1970 than there are between 1999
    and 1900, so subtraction gives the correct number of seconds. And because the
    `Date` constructor needs milliseconds, we multiply the number of seconds by 1,000.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: The time difference is the number of years multiplied by 365, plus the number
    of leap days between the two dates (in the years 1904, 1908, . . . , 1968)—19
    days.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'The integer that we read from the server is a C-language `unsigned int`. But
    Java doesn’t provide an unsigned integer type; normally when you need an unsigned
    number, you use the next-larger integer type, which would be `long`. But Java
    also doesn’t give us a method to read an unsigned integer from a data stream.
    The `DataInputStream` method `readInt()` reads Java-style signed integers. There
    are `readUnsignedByte()` methods and `readUnsignedShort()` methods, but no `readUnsignedInt()`
    method. Accordingly, we synthesize the ability to read an unsigned `int` (which
    must be stored in a `long`, or else you’d lose the signed bit and be back where
    you started from) by reading unsigned bytes and reassembling them using Java’s
    bit-shifting operators:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the code, we use the new date/time API (see [Chapter 6](ch06.html#javacook-dates))
    to construct and print a `LocalDateTime` object to show the current date and time
    on the local (client) machine:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The name *aragorn* is the hostname of one of my OpenBSD Unix computers. Looking
    at the output, you can see that the server agrees within a second or two. That
    confirms the date calculation code in [Example 12-6](#javacook-netclient-EX-6).
    This protocol is commonly known as `rdate`, so the client code is called `RDateClient`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-6\. main/src/main/java/network/RDateClient.java
  id: totrans-106
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Object serialization* is the ability to convert in-memory objects to an external
    form that can be sent serially (a byte at a time). To read or write Java objects
    via serialization, you need only construct an `ObjectInputStream` or `ObjectOutputStream`
    from an `InputStream` or `OutputStream`; in this case, the socket’s `getInputStream()`
    or `getOutputStream()`.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: This program (and its server) provide a service that isn’t a standard part of
    the TCP/IP stack; it’s a service I made up as a demo. The server for this service
    is introduced in [Recipe 13.3](ch13.html#javacook-netserver-SECT-2). The client
    code in [Example 12-7](#javacook-netclient-EX-7) is quite similar to the `DaytimeBinary`
    program in the previous recipe, but the server sends us a `LocalDateTime` object
    already constructed. [Example 12-7](#javacook-netclient-EX-7) shows the portion
    of the client code that differs from [Example 12-6](#javacook-netclient-EX-6).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序（及其服务器）提供的服务并不是TCP/IP协议栈的标准部分；这是我制作的一个演示服务。此服务的服务器在[Recipe 13.3](ch13.html#javacook-netserver-SECT-2)中介绍。[Example
    12-7](#javacook-netclient-EX-7)中的客户端代码与前一篇中的`DaytimeBinary`程序非常相似，但服务器发送给我们一个已构造好的`LocalDateTime`对象。[Example
    12-7](#javacook-netclient-EX-7)展示了与[Example 12-6](#javacook-netclient-EX-6)不同的客户端代码部分。
- en: Example 12-7\. main/src/main/java/network/DaytimeObject.java
  id: totrans-110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-7\. main/src/main/java/network/DaytimeObject.java
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'I ask the operating system for the date and time, and then I run the program,
    which prints the date and time on a remote machine:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我向操作系统询问日期和时间，然后运行程序，在远程机器上打印日期和时间：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Again, the results agree within a few seconds.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 再次结果在几秒钟内达成一致。
- en: 12.7 UDP Datagrams
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12.7 UDP数据报
- en: Problem
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to use a datagram connection (UDP) instead of a stream connection (TCP).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要使用数据报连接（UDP）而不是流连接（TCP）。
- en: Solution
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use `DatagramSocket` and `DatagramPacket`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`DatagramSocket`和`DatagramPacket`。
- en: Discussion
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Datagram network traffic is a kindred spirit to the underlying packet-based
    Ethernet and IP (Internet Protocol) layers. Unlike a stream-based connection such
    as TCP, datagram transports like UDP transmit each *packet*, or chunk of data,
    as a single entity with no necessary relation to any other.^([3](ch12.html#idm45290644551496))
    A common analogy is that TCP is like talking on the telephone, whereas UDP is
    like sending postcards or maybe fax messages.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 数据报网络流量与底层基于数据包的以太网和IP（Internet Protocol）层是一脉相承的。与TCP等基于流的连接不同，UDP等数据报传输像发送单个*数据包*或数据块一样，作为一个单独的实体传输，与其他任何内容都没有必要的关系。^([3](ch12.html#idm45290644551496))一个常见的比喻是，TCP就像打电话，而UDP就像发送明信片或传真。
- en: The differences show up most in error handling. Packets can, like postcards,
    go astray. When was the last time the postman rang your bell to tell you that
    the post office had lost one of several postcards it was supposed to deliver to
    you? That’s not going to happen, because the post office doesn’t keep track of
    postcards. On the other hand, when you’re talking on the phone and there’s a noise
    burst—like somebody yelling in the room, or even a bad connection—you notice the
    failure in real time, and you can ask the person at the other end to repeat what
    they just said.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 差异主要体现在错误处理上。数据包就像明信片一样，可能会丢失。你上次看到邮递员敲门告诉你邮局丢失了几张要送到你手中的明信片是什么时候？这种情况不会发生，因为邮局不会追踪明信片。另一方面，当你在电话上通话时，如果出现噪声爆发——比如有人在房间里大喊大叫，或者是连接不良——你会实时注意到故障，并可以要求对方重复刚才说的话。
- en: 'With a stream-based connection like a TCP socket, the network transport layer
    handles errors for you: it asks the other end to retransmit. With a datagram transport
    such as UDP, you have to handle retransmission yourself. It’s kind of like numbering
    the postcards you send so that you can go back and resend any that don’t arrive—a
    good excuse to return to your vacation spot, perhaps.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像TCP套接字这样的基于流的连接，网络传输层会帮你处理错误：它会要求对方重新传输。但是对于UDP等数据报传输，你必须自己处理重传。这有点像编号你发送的明信片，这样你可以回头重新发送那些未到达的明信片——也许这是返回度假地的好借口。
- en: Another difference is that datagram transmission preserves message boundaries.
    That is, if you write 20 bytes and then write 10 bytes when using TCP, the program
    reading from the other end will not know if you wrote one chunk of 30 bytes, two
    chunks of 15, or even 30 individual characters. With a `DatagramSocket`, you construct
    a `DatagramPacket` object for each buffer, and its contents are sent as a *single*
    entity over the network; its contents will not be mixed together with the contents
    of any other buffer. The `DatagramPacket` object has methods like `getLength()`
    and `setPort()`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个区别在于数据报传输保留了消息边界。也就是说，如果你使用TCP写入了20字节，然后写入了10字节，那么从另一端读取的程序将不知道你是写了30字节的一个块，还是两个15字节的块，甚至是30个单独的字符。使用`DatagramSocket`时，你为每个缓冲区构造一个`DatagramPacket`对象，其内容作为一个*单独的*实体通过网络发送；它的内容不会与任何其他缓冲区的内容混合在一起。`DatagramPacket`对象具有诸如`getLength()`和`setPort()`的方法。
- en: So why would we even use UDP? UDP has a lot less overhead than TCP, which can
    be particularly valuable when sending huge amounts of data over a reliable local
    network or a few hops on the internet. Over long-haul networks, TCP is probably
    preferred because TCP handles retransmission of lost packets for you. And obviously,
    if preserving record boundaries makes your life easier, that may be a reason for
    considering UDP. UDP is also the way to perform Multicast (broadcast to many receivers
    simultaneously), though Multicast is out of scope for this discussion.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么我们会使用UDP呢？ UDP的开销比TCP少得多，在可靠的局域网或互联网上跳数较少时特别有价值。在长距离网络上，TCP可能更受欢迎，因为TCP会为您处理丢失数据包的重传。显然，如果保留记录边界能够让您的生活更轻松，这可能是考虑使用UDP的原因。UDP还是执行多播（同时向许多接收者广播）的方式，尽管多播超出了本讨论的范围。
- en: '[Example 12-8](#javacook-netclient-EX-8) is a short program that connects via
    UDP to the `Daytime` date and time server used in [Recipe 12.5](#javacook-netclient-SECT-4).
    Because UDP has no real notion of connection, the client typically initiates the
    conversation, which sometimes means sending an empty packet; the UDP server uses
    the address information it gets from that to return its response.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 12-8](#javacook-netclient-EX-8)是一个简短的程序，通过UDP连接到[配方 12.5](#javacook-netclient-SECT-4)中使用的`Daytime`日期和时间服务器。因为UDP没有真正的连接概念，客户端通常会启动对话，有时意味着发送一个空包；UDP服务器使用从中获取的地址信息来返回其响应。'
- en: Example 12-8\. main/src/main/java/network/DaytimeUDP.java
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-8\. main/src/main/java/network/DaytimeUDP.java
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'I’ll run it to my Unix box just to be sure that it works:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我会运行它到我的Unix框中，只是为了确保它工作：
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 12.8 URI, URL, or URN?
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12.8 URI、URL或URN？
- en: Problem
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Having heard these terms, you want to know the difference between a URI, URL,
    and URN.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在听到这些术语之后，您想知道URI、URL和URN之间的区别。
- en: Solution
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Read on. Or see the javadoc for *java.net.uri*.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 继续阅读。或查看*java.net.uri*的javadoc。
- en: Discussion
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'A URL is the traditional name for a network address consisting of a scheme
    (like HTTP) and an address (site name) and resource or pathname. But there are
    three distinct terms in all:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: URL是传统的网络地址名称，由协议（如HTTP）、地址（站点名称）和资源或路径名组成。但总共有三个不同的术语：
- en: URI (Uniform Resource Identifier)
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URI（统一资源标识符）
- en: URL (Uniform Resource Locator)
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URL（统一资源定位符）
- en: URN (Uniform Resource Name)
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URN（统一资源名称）
- en: A discussion near the end of the Java documentation for the new class explains
    the relationship among URI, URL, and URN. URIs form the set of all identifiers.
    URLs and URNs are subsets.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Java文档末尾的讨论解释了URI、URL和URN之间的关系。URI形成了所有标识符的集合。URL和URN是子集。
- en: URIs are the most general; a URI is parsed for basic syntax without regard to
    the scheme, if any, that it specifies, and it need not refer to a particular server.
    A URL includes a hostname, scheme, and other components; the string is parsed
    according to rules for its scheme. When you construct a URL, an `InputStream`
    is created automatically. URNs name resources but do not explain how to locate
    them; typical examples of URNs that you will have seen include `mailto:` and `news:`
    references.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: URI是最通用的；URI在不考虑其指定的方案（如果有）的情况下对基本语法进行解析，不需要引用特定的服务器。URL包括主机名、方案和其他组件；该字符串根据其方案的规则进行解析。构造URL时，会自动创建一个`InputStream`。URN命名资源但不说明如何定位它们；您可能看到的URN的典型示例包括`mailto:`和`news:`引用。
- en: 'The main operations provided by the `URI` class are normalization (removing
    extraneous path segments including “..”) and relativization (this should be called
    “making relative,” but somebody wanted a single word to make a method name). A
    `URI` object does not have any methods for opening the URI; for that, you would
    normally use a string representation of the URI to construct a URL object, like
    so:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`URI`类提供的主要操作是规范化（移除多余的路径段，包括“..”）和相对化（这应该称为“使相对化”，但某人希望用一个单词来作为方法名）。`URI`对象没有用于打开URI的任何方法；为此，通常会使用URI的字符串表示形式构造URL对象，如下所示：'
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The program in [Example 12-9](#javacook-netserver-EX-6) shows examples of normalizating,
    making relative, and constructing a URL from a URI.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 12-9](#javacook-netserver-EX-6)中的程序展示了从URI规范化、相对化以及构造URL的示例。'
- en: Example 12-9\. main/src/main/java/network/URIDemo.java
  id: totrans-146
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-9\. main/src/main/java/network/URIDemo.java
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '12.9 Program: TFTP UDP Client'
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12.9 程序：TFTP UDP客户端
- en: This program implements the client half of the TFTP application protocol, a
    once-well-known service that has been used in the Unix world for network booting
    of workstations since before Windows 3.1, now primarily used for network bootstrapping
    of computers. I chose this protocol because it’s widely implemented on the server
    side, so it’s easy to find a test server for it.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序实现了TFTP应用协议的客户端部分，这是一种曾经非常著名的服务，在Unix世界中用于工作站的网络引导，早在Windows 3.1之前就已经存在，现在主要用于计算机的网络引导。我选择这个协议是因为它在服务器端广泛实现，所以很容易找到用于测试的服务器。
- en: The TFTP protocol is a bit odd. The client contacts the server on the well-known
    UDP port number 69, from a generated port number,^([4](ch12.html#idm45290643937208))
    and the server responds to the client from a generated port number. Further communication
    is on the two generated port numbers.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: TFTP协议有些奇怪。客户端在众所周知的UDP端口号69上与服务器联系，使用生成的端口号，^([4](ch12.html#idm45290643937208))，服务器从生成的端口号响应客户端。进一步的通信使用这两个生成的端口号。
- en: Getting into more detail, as shown in [Figure 12-1](#javacook-netclient-FIG-1),
    the client initially sends a read request with the filename and reads the first
    packet of data. The read request consists of two bytes (a `short`) with the read
    request code (short integer with a value of 1, defined as `OP_RRQ`), two bytes
    for the sequence number, then the ASCII filename, null terminated, and the mode
    string, also null terminated. The server reads the read request from the client,
    verifies that it can open the file and, if so, sends the first data packet (`OP_DATA`),
    and then reads again. The client reads from its end and, if the read is OK, turns
    the packet into an acknowledgement packet, and sends it. This read-acknowledge
    cycle is repeated until all the data is read. Note that each packet is 516 bytes
    (512 bytes of data, plus 2 bytes for the packet type and 2 more for the packet
    number) except the last, which can be any length from 4 (zero bytes of data) to
    515 (511 bytes of data). If a network I/O error occurs, the packet is resent.
    If a given packet goes astray, both client and server are supposed to perform
    a timeout cycle. This client does not, but the server does. You could add timeouts
    either using a thread (see [Recipe 16.4](ch16.html#javacook-threads-SECT-4)) or
    by invoking `setSoTimeout()` on the socket and, if packets do get lost, catching
    the `SocketTimeoutException`, retransmitting the ACK (or RRQ), perhaps up to some
    max number of attempts. This is left as an exercise for the reader. The current
    version of the client code is shown in [Example 12-10](#javacook-netclient-EX-9).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 更详细地讲，如图[12-1](#javacook-netclient-FIG-1)所示，客户端首先发送包含文件名的读取请求，并读取第一个数据包。读取请求由两个字节（一个`short`）组成，带有读取请求代码（短整数，值为1，定义为`OP_RRQ`），两个字节用于序列号，然后是ASCII文件名，以空字符结尾，和模式字符串，同样以空字符结尾。服务器从客户端读取读取请求，验证是否可以打开文件，并且如果可以，发送第一个数据包（`OP_DATA`），然后再次读取。客户端从其端口读取，并且如果读取正常，将数据包转换为确认包，并发送。这种读取-确认循环重复进行，直到读取所有数据。请注意，除了最后一个包，每个包都是516字节（512字节的数据，加上2字节的包类型和另外2字节的包编号），最后一个包可以是任何长度，从4（零字节数据）到515（511字节数据）。如果发生网络I/O错误，则重新发送该包。如果某个包偏离了轨道，客户端和服务器都应执行超时循环。这个客户端没有这样做，但服务器有。您可以使用线程（参见[Recipe
    16.4](ch16.html#javacook-threads-SECT-4)）或通过在套接字上调用`setSoTimeout()`来添加超时，如果数据包丢失，则捕获`SocketTimeoutException`，重新传输确认（或读取请求），最多尝试某个最大次数。这留给读者作为练习。客户端代码的当前版本显示在[示例
    12-10](#javacook-netclient-EX-9)中。
- en: '![jcb4 1201](assets/jcb4_1201.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![jcb4 1201](assets/jcb4_1201.png)'
- en: Figure 12-1\. The TFTP protocol packet formats
  id: totrans-153
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-1\. TFTP协议包格式
- en: Example 12-10\. main/src/main/java/network/RemCat.java
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-10\. main/src/main/java/network/RemCat.java
- en: '[PRE25]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To test this client, you need a TFTP server. If you are on a Unix system that
    you administer, you can enable the TFTP server to test this client just by editing
    the file */etc/inetd.conf* and restarting or reloading the *inetd* server (Linux
    uses a different mechanism, which may vary depending on which distribution you
    are on). *inetd* is a program that listens for a wide range of connections and
    starts the servers only when a connection from a client comes along (a kind of
    lazy evaluation).^([5](ch12.html#idm45290643677448)) I set up the traditional
    */tftpboot* directory, put this line in my *inetd.conf*, and reloaded `inetd`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Then I put a few test files, one named *foo*, into the */tftpboot* directory.
    Running
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'produced what looked like the file. But just to be safe, I tested the output
    of `RemCat` against the original file, using the Unix *diff* comparison program.
    No news is good news:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'So far so good. Let’s not slip this program on an unsuspecting network without
    exercising the error handling at least briefly:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '12.10 Program: Sockets-Based Chat Client'
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This program is a simple chat program. You can’t break in on ICQ or AIM with
    it, because they each use their own protocol.^([6](ch12.html#idm45290643134536))
    Rather, this program simply writes to and reads from a server. The server for
    this will be presented in [Chapter 13](ch13.html#javacook-netserver). How does
    it look when you run it? [Figure 12-2](#javacook-netclient-FIG-2) shows me chatting
    all by myself one day.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: The code is reasonably self-explanatory. We read from the remote server in a
    thread to make the input and the output run without blocking each other; this
    is discussed in [Chapter 16](ch16.html#javacook-threads). The reading and writing
    are discussed in this chapter. The program is shown in [Example 12-11](#javacook-netclient-EX-11).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '![jcb4 1202](assets/jcb4_1202.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
- en: Figure 12-2\. Chat client in action
  id: totrans-168
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Example 12-11\. main/src/main/java/chat/ChatClient.java
  id: totrans-169
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: See Also
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many better-structured ways to write a chat client, including WebSockets,
    RMI, and JMS. RMI is Java’s RPC interface and is included both in Java SE and
    Java EE; it is not described in this edition of this book, but you can find the
    RMI chapter from previous editions on the [my website](http://darwinsys.com/java/rmi).
    The other technologies are part of the Java Enterprise so, again, I refer you
    to Arun Gupta’s *[Java EE 7 Essentials](http://shop.oreilly.com/product/0636920030614.do)*.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: If your communication goes over the public internet, you do need to encrypt
    your socket connection, so check out Sun’s JSSE (Java Secure Socket Extension).
    If you took my earlier advice and used the standard HTTP protocol, you can encrypt
    the conversation just by changing the URL to https.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: For a good overview of network programming from the C programmer’s point of
    view, see the late W. Richard Stevens’ *Unix Network Programming* (Prentice Hall).
    Despite the book’s name, it’s really about socket and TCP/IP/UDP programming and
    covers all parts of the (Unix) networking API and protocols such as TFTP in amazing
    detail.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对于从C程序员的角度对网络编程有良好概述，请参阅已故的W·理查德·史蒂文斯（W. Richard Stevens）的《Unix网络编程》（Prentice
    Hall）。尽管书名为Unix网络编程，但实际上是关于套接字、TCP/IP和UDP编程，并详细介绍了所有（Unix）网络API及协议，如TFTP。
- en: '12.11 Program: Simple HTTP Link Checker'
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12.11 程序：简单HTTP链接检查器
- en: Checking links is an ongoing problem for website owners as well as those who
    write technical documentation that links to external sources (e.g., people like
    the author of the book you are now reading). *Link checkers* are the tool they
    inevitably use to validate the links in their pages, be they web pages or book
    pages. Implementing a link checker is basically a matter of (a) extracting links
    and (b) opening them. Thus, we have the program in [Example 12-12](#javacook-netclient-ex-kwiklinkchecker).
    I call it `KwikLinkChecker` as it is a bit on the quick-and-dirty side—it doesn’t
    validate the content of the link to be sure it still contains what it once did;
    so if, say, an open source project forgets to renew its domain registration, and
    it gets taken over by a porn site, well, `KwikLinkChecker` will never know. But
    that said, it does its job reasonably well, and reasonably quickly.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 检查链接是网站所有者及撰写链接到外部来源技术文档（例如，您正在阅读的书的作者）的人员面临的持续问题。*链接检查工具*是他们验证页面链接的必备工具，无论是网页还是书页。实现链接检查器基本上是（a）提取链接和（b）打开它们的事情。因此，我们有了[示例12-12](#javacook-netclient-ex-kwiklinkchecker)中的程序。我称之为`KwikLinkChecker`，因为它有点快速且粗糙——它不验证链接内容是否仍然包含原始内容；因此，例如，如果一个开源项目忘记更新其域名注册，而其域名被一个色情网站接管，那么`KwikLinkChecker`将永远不会知道。但话虽如此，它完成了它的工作，而且相当快速。
- en: Example 12-12\. darwinsys-api/src/main/java/com/darwinsys/tools/KwikLinkChecker.java
  id: totrans-177
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-12\. darwinsys-api/src/main/java/com/darwinsys/tools/KwikLinkChecker.java
- en: '[PRE31]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Fancier link checkers are surely available, but this one works for me.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当然还有更复杂的链接检查工具可用，但这个对我来说就够用了。
- en: ^([1](ch12.html#idm45290645651848-marker)) The location where it is looked up
    varies. It might be in a file named */etc/services* on Unix; in the *services*
    file in a subdirectory of *\ or _\winnt* in Windows; in a centralized registry
    such as Sun’s Network Information Services (NIS, formerly YP); or in some other
    platform- or network-dependent location.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch12.html#idm45290645651848-marker)) 它被查找的位置各不相同。在Unix上，它可能位于名为*/etc/services*的文件中；在Windows的*\或_\winnt*子目录的*services*文件中；或在像Sun的网络信息服务（NIS，曾称为YP）这样的集中注册表中；或在某些其他平台或网络相关位置。
- en: ^([2](ch12.html#idm45290645253384-marker)) It used to be universal, when most
    networked systems were administered by full-time systems people who had been trained
    or served an apprenticeship. Today many machines on the internet don’t have `localhost`
    configured properly.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch12.html#idm45290645253384-marker)) 在大多数网络系统由全职系统人员管理并接受培训或见习时，这曾是普遍的。今天，互联网上许多机器并未正确配置`localhost`。
- en: ^([3](ch12.html#idm45290644551496-marker)) The UDP packet may need to be fragmented
    by some networks, but this is not germane to us at the UDP level, because it will
    reassemble the network packets into our single-entity UDP packet at the other
    end.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch12.html#idm45290644551496-marker)) 某些网络可能需要对UDP数据包进行分段，但这对我们在UDP层级上不重要，因为它将在另一端将网络数据包重新组装为我们的单实体UDP数据包。
- en: ^([4](ch12.html#idm45290643937208-marker)) When the application doesn’t care,
    these port numbers are usually made up by the operating system. For example, when
    you call a company from a pay phone or cell phone, the company doesn’t usually
    care what number you are calling from, and if it does, there are ways to find
    out. Generated port numbers generally range from 1024 (the first nonprivileged
    port; see [Chapter 13](ch13.html#javacook-netserver)) to 65535 (the largest value
    that can be held in a 16-bit port number).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch12.html#idm45290643937208-marker)) 当应用程序不关心时，这些端口号通常由操作系统生成。例如，当您从公用电话或手机拨打公司电话时，公司通常不在乎您从哪个号码打过来，如果在乎的话，也有办法找出来。生成的端口号通常范围从1024（第一个非特权端口；参见[Chapter 13](ch13.html#javacook-netserver)）到65535（在16位端口号中可以表示的最大值）。
- en: ^([5](ch12.html#idm45290643677448-marker)) Beware of security holes; don’t turn
    a TFTP server loose on the internet without first reading a good security book,
    such as [*Building Internet Firewalls*](http://shop.oreilly.com/product/9781565928718.do)
    by D. Chapman et al. (O’Reilly).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch12.html#idm45290643677448-marker)) 警惕安全漏洞；不要在互联网上放任一个 TFTP 服务器，而不先读一本好的安全书，比如[*构建互联网防火墙*](http://shop.oreilly.com/product/9781565928718.do)，作者为
    D. Chapman 等人（O’Reilly）。
- en: ^([6](ch12.html#idm45290643134536-marker)) For an open source program that provides
    an IM service to let you talk to both from the same program, check out Jabber
    at [*http://www.jabber.org*](http://www.jabber.org).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch12.html#idm45290643134536-marker)) 如果你想要一个开源程序，提供 IM 服务，让你从同一个程序中进行通话，请查看
    Jabber，网址为[*http://www.jabber.org*](http://www.jabber.org)。
