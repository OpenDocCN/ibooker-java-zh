["```java\npublic interface java.lang.Runnable {\n  public abstract void run();\n}\n```", "```java\npublic interface java.util.concurrent.Callable<V> {\n  public abstract V call() throws Exception;\n}\n```", "```java\n        final ExecutorService pool = Executors.newFixedThreadPool(HOWMANY);\n        List<Future<Integer>> futures = new ArrayList<>(HOWMANY);\n        for (int i = 0; i < HOWMANY; i++) {\n            Future<Integer> f = pool.submit(new DemoRunnable(i));\n            System.out.println(\"Got 'Future' of type \" + f.getClass());\n            futures.add(f);\n        }\n        Thread.sleep(3 * 1000);\n        done = true;\n        for (Future<Integer> f : futures) {\n            System.out.println(\"Result \" + f.get());\n        }\n        pool.shutdown();\n```", "```java\nRunning Thread[pool-1-thread-3,5,main]\nRunning Thread[pool-1-thread-3,5,main]\nRunning Thread[pool-1-thread-1,5,main]\nRunning Thread[pool-1-thread-1,5,main]\n```", "```java\npublic void execute(Runnable);\npublic Future<T> submit(Callable<T>);\npublic Future<T> submit(Runnable);\n```", "```java\n/** A Sprite is one Image that moves around the screen on its own */\npublic class Sprite extends Component implements Runnable {\n    private static final long serialVersionUID = 1L;\n    protected static int spriteNumber = 0;\n    protected int number;\n    protected int x, y;\n    protected Component parent;\n    protected Image image;\n    protected volatile boolean done = false;\n    /** The time in mSec to pause between each move. */\n    protected volatile int sleepTime = 250;\n    /** The direction for this particular sprite. */\n    protected Direction direction;\n    enum Direction {\n        VERTICAL, HORIZONTAL, DIAGONAL\n    }\n    /** Construct a Sprite with a Component parent, image and direction.\n * Construct and start a Thread to drive this Sprite.\n */\n    public Sprite(Component parent, Image image, Direction direction) {\n        this.parent = parent;\n        this.image = image;\n        this.direction = direction;\n        this.number = Sprite.spriteNumber++;\n        setSize(image.getWidth(this), image.getHeight(this));\n    }\n\n    /** Construct a Sprite with the default direction */\n    public Sprite(Component parent, Image image) {\n        this(parent, image, Direction.DIAGONAL);\n    }\n\n    /** Stop this Sprite. */\n    public void stop() {\n        System.out.println(\"Stopping \" + number);\n        done = true;\n    }\n\n    /** Adjust the motion rate */\n    protected void setSleepTime(int n) {\n        sleepTime = n;\n    }\n\n    /**\n * Run one Sprite around the screen.\n * This version just moves them around either across, down, or\n * at some 45-degree angle.\n */\n    public void run() {\n        int width = parent.getSize().width;\n        int height = parent.getSize().height;\n        // Set initial location\n        x = (int)(Math.random() * width);\n        y = (int)(Math.random() * height);\n        // Flip coin for x & y directions\n        int xincr = Math.random()>0.5?1:-1;\n        int yincr = Math.random()>0.5?1:-1;\n        while (!done) {\n            width = parent.getSize().width;\n            height = parent.getSize().height;\n            if ((x+=xincr) >= width)\n                x=0;\n            if ((y+=yincr) >= height)\n                y=0;\n            if (x<0)\n                x = width;\n            if (y<0)\n                y = height;\n            switch(direction) {\n                case VERTICAL:\n                    x = 0;\n                    break;\n                case HORIZONTAL:\n                    y = 0;\n                    break;\n                case DIAGONAL:\n                    // Let it wrap around\n                    break;\n            }\n            //System.out.println(\"from \" + getLocation() + \"->\" + x + \",\" + y);\n            setLocation(x, y);\n            repaint();\n            try {\n                Thread.sleep(sleepTime);\n            } catch (InterruptedException e) {\n                return;\n            }\n        }\n    }\n\n    /** paint -- just draw our image at its current location */\n    public void paint(Graphics g) {\n        g.drawImage(image, 0, 0, this);\n    }\n}\n```", "```java\npublic class Bounce extends JPanel {\n\n    private static final long serialVersionUID = -5359162621719520213L;\n    /** The main Panel */\n    protected JPanel p;\n    /** The image, shared by all the Sprite objects */\n    protected Image img;\n    /** A Thread Pool */\n    protected ExecutorService tp = Executors.newCachedThreadPool();\n    /** A Vector of Sprite objects. */\n    protected List<Sprite> v = new Vector<Sprite>(); // multithreaded, use Vector;\n\n    public static void main(String[] args) {\n        JFrame jf = new JFrame(\"Bounce Demo\");\n        jf.add(new Bounce(args.length > 0 ? args[0] : null));\n        jf.setSize(300, 300);\n        jf.setVisible(true);\n        jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    }\n\n    public Bounce(String imgName) {\n        setLayout(new BorderLayout());\n        JButton b = new JButton(\"Add a Sprite\");\n        b.addActionListener(e -> {\n            System.out.println(\"Creating another one!\");\n            Sprite s = new Sprite(this, img);\n            tp.execute(s);\n            p.add(s);\n            v.add(s);\n        });\n        add(b, BorderLayout.NORTH);\n        add(p = new JPanel(), BorderLayout.CENTER);\n        p.setLayout(null);\n        if (imgName == null) imgName = \"duke.gif\";\n        final URL resource = getClass().getResource(\"/\" + imgName);\n        if (resource == null) {\n            throw new IllegalStateException(\"Could not load image \" + imgName);\n        }\n        img = Toolkit.getDefaultToolkit().getImage(resource);\n        MediaTracker mt = new MediaTracker(this);\n        mt.addImage(img, 0);\n        try {\n            mt.waitForID(0);\n        } catch(InterruptedException e) {\n            throw new IllegalArgumentException(\n                \"InterruptedException while loading image \" + imgName);\n        }\n        if (mt.isErrorID(0)) {\n            throw new IllegalArgumentException(\n                \"Couldn't load image \" + imgName);\n        }\n        JButton stopper = new JButton(\"Shut down\");\n        stopper.addActionListener(e -> {\n            stop();\n            tp.shutdown();\n        });\n        add(stopper, BorderLayout.SOUTH);\n    }\n\n    public void stop() {\n        for (Sprite s : v) {\n            s.stop();\n        }\n        v.clear();\n        try {\n            tp.awaitTermination(5, TimeUnit.SECONDS);\n            System.out.println(\"ThreadPool is shut down, ending program\");\n            System.exit(0);\n        } catch (InterruptedException e) {\n            // Empty\n        }\n    }\n}\n```", "```java\npublic class StopBoolean {\n\n    // Must be volatile to ensure changes visible to other threads.\n    protected volatile boolean done = false;\n\n    Runnable r = () -> {\n        while (!done) {\n            System.out.println(\"StopBoolean running\");\n            try {\n                Thread.sleep(720);\n            } catch (InterruptedException ex) {\n                // nothing to do\n            }\n        }\n        System.out.println(\"StopBoolean finished.\");\n    };\n\n    public void shutDown() {\n        System.out.println(\"Shutting down...\");\n        done = true;\n    }\n\n    public void doDemo() throws InterruptedException {\n        ExecutorService pool = Executors.newSingleThreadExecutor();\n        pool.submit(r);\n        Thread.sleep(1000*5);\n        shutDown();\n        pool.shutdown();\n        pool.awaitTermination(2, TimeUnit.SECONDS);\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        new StopBoolean().doDemo();\n    }\n}\n```", "```java\nStopBoolean running\nStopBoolean running\nStopBoolean running\nStopBoolean running\nStopBoolean running\nStopBoolean running\nStopBoolean running\nStopBoolean finished.\n```", "```java\npublic class StopClose extends Thread {\n    protected Socket io;\n\n    public void run() {\n        try {\n            io = new Socket(\"java.sun.com\", 80);    // HTTP\n            BufferedReader is = new BufferedReader(\n                new InputStreamReader(io.getInputStream()));\n            System.out.println(\"StopClose reading\");\n\n            // The following line will deadlock (intentionally), since HTTP\n            // enjoins the client to send a request (like \"GET / HTTP/1.0\")\n            // and a null line, before reading the response.\n\n            String line = is.readLine();    // DEADLOCK\n\n            // Should only get out of the readLine if an interrupt\n            // is thrown, as a result of closing the socket.\n\n            // So we shouldn't get here, ever:\n            System.out.printf(\"StopClose FINISHED after reading %s!?\", line);\n        } catch (IOException ex) {\n            System.out.println(\"StopClose terminating: \" + ex);\n        }\n    }\n\n    public void shutDown() throws IOException {\n        if (io != null) {\n            // This is supposed to interrupt the waiting read.\n            synchronized(io) {\n                io.close();\n            }\n        }\n        System.out.println(\"StopClose.shutDown() completed\");\n    }\n\n    public static void main(String[] args)\n    throws InterruptedException, IOException {\n        StopClose t = new StopClose();\n        t.start();\n        Thread.sleep(1000*5);\n        t.shutDown();\n    }\n}\n```", "```java\nStopClose reading\nStopClose terminating: java.net.SocketException: Resource temporarily unavailable\n```", "```java\ndarwinsys.com$ java threads.Join\nStarting\nJoining\nReading\nhello from standard input # waits indefinitely for me to type this line\nThread Finished.\nMain Finished.\ndarwinsys.com$\n```", "```java\npublic class Join {\n    public static void main(String[] args) {\n        Thread t = new Thread() {\n            public void run() {\n                System.out.println(\"Reading\");\n                try {\n                    System.in.read();\n                } catch (java.io.IOException ex) {\n                    System.err.println(ex);\n                }\n                System.out.println(\"Thread Finished.\");\n            }\n        };\n        System.out.println(\"Starting\");\n        t.start();\n        System.out.println(\"Joining\");\n        try {\n            t.join();\n        } catch (InterruptedException ex) {\n            // should not happen:\n            System.out.println(\"Who dares interrupt my sleep?\");\n        }\n        System.out.println(\"Main Finished.\");\n    }\n}\n```", "```java\npublic void add(Object obj) {\n   data[max] = obj; ![1](assets/1.png)\n   max = max + 1;   ![2](assets/2.png)\n}\n```", "```java\ndata[max++] = obj;\n```", "```java\npublic synchronized void add(Object obj) {\n    ...\n}\n```", "```java\npublic void add(Object obj) {\n    synchronized (someObject) {\n        // this code will execute in one thread at a time\n    }\n}\n```", "```java\nsynchronized(myArrayList) {\n     if (myArrayList.indexOf(someObject) != -1) {\n         // do something with it.\n     } else {\n         create an object and add it...\n    }\n}\n```", "```java\npublic class BuzzInServlet extends HttpServlet {\n\n    /** The attribute name used throughout. */\n    protected final static String WINNER = \"buzzin.winner\";\n\n    /** doGet is called from the contestants web page.\n * Uses a synchronized code block to ensure that\n * only one contestant can change the state of \"buzzed\".\n */\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n    throws ServletException, IOException {\n        ServletContext application = getServletContext();\n\n        boolean iWon = false;\n        String user = request.getRemoteHost() + '@' + request.getRemoteAddr();\n\n        // Do the synchronized stuff first, and all in one place.\n        synchronized(application) {\n            if (application.getAttribute(WINNER) == null) {\n                application.setAttribute(WINNER, user);\n                application.log(\"BuzzInServlet: WINNER \" + user);\n                iWon = true;\n            }\n         }\n\n        response.setContentType(\"text/html\");\n        PrintWriter out = response.getWriter();\n\n        out.println(\"<html><head><title>Thanks for playing</title></head>\");\n        out.println(\"<body bgcolor=\\\"white\\\">\");\n\n        if (iWon) {\n            out.println(\"<b>YOU GOT IT</b>\");\n            // TODO - output HTML to play a sound file :-)\n        } else {\n                out.println(\"Thanks for playing, \" + request.getRemoteAddr());\n                out.println(\", but \" + application.getAttribute(WINNER) +\n                    \" buzzed in first\");\n        }\n        out.println(\"</body></html>\");\n    }\n\n    /** The Post method is used from an Administrator page (which should\n * only be installed in the instructor/host's localweb directory).\n * Post is used for administrative functions:\n * 1) to display the winner;\n * 2) to reset the buzzer for the next question.\n */\n    public void doPost(HttpServletRequest request, HttpServletResponse response)\n    throws ServletException, IOException {\n        ServletContext application = getServletContext();\n\n        response.setContentType(\"text/html\");\n        HttpSession session = request.getSession();\n\n        PrintWriter out = response.getWriter();\n\n        if (request.isUserInRole(\"host\")) {\n            out.println(\"<html><head><title>Welcome back, \" +\n                request.getUserPrincipal().getName() + \"</title><head>\");\n            out.println(\"<body bgcolor=\\\"white\\\">\");\n            String command = request.getParameter(\"command\");\n            if (command.equals(\"reset\")) {\n\n                // Synchronize what you need, no more, no less.\n                synchronized(application) {\n                    application.setAttribute(WINNER, null);\n                }\n                session.setAttribute(\"buzzin.message\", \"RESET\");\n            } else if (command.equals(\"show\")) {\n                String winner = null;\n                synchronized(application) {\n                    winner = (String)application.getAttribute(WINNER);\n                }\n                if (winner == null) {\n                    session.setAttribute(\"buzzin.message\",\n                        \"<b>No winner yet!</b>\");\n                } else {\n                    session.setAttribute(\"buzzin.message\",\n                        \"<b>Winner is: </b>\" + winner);\n                }\n            }\n            else {\n                session.setAttribute(\"buzzin.message\",\n                    \"ERROR: Command \" + command + \" invalid.\");\n            }\n            RequestDispatcher rd = application.getRequestDispatcher(\n                \"/hosts/index.jsp\");\n            rd.forward(request, response);\n        } else {\n            out.println(\"<html><head><title>Nice try, but... </title><head>\");\n            out.println(\"<body bgcolor=\\\"white\\\">\");\n            out.println(\n                \"I'm sorry, Dave, but you know I can't allow you to do that.\");\n            out.println(\"Even if you are \" + request.getUserPrincipal());\n        }\n        out.println(\"</body></html>\");\n    }\n}\n```", "```java\n<html><head><title>Buzz In!</title></head>\n<body>\n<h1>Buzz In!</h1>\n<p>\n<font size=+6>\n<a href=\"servlet/BuzzInServlet\">\nPress here to buzz in!\n</a>\n</font>\n```", "```java\n<html><head><title>Reset Buzzer</title></head>\n<body>\n<h1>Display Winner</h1>\n<p>\n<b>The winner is:</b>\n<form method=\"post\" action=\"servlet/BuzzInServlet\">\n    <input type=\"hidden\" name=\"command\" value=\"show\">\n    <input type=\"hidden\" name=\"password\" value=\"syzzy\">\n    <input type=\"submit\" name=\"Show\" value=\"Show\">\n</form>\n<h1>Reset Buzzer</h1>\n<p>\n<b>Remember to RESET before you ask the contestants each question!</b>\n<form method=\"post\" action=\"servlet/BuzzInServlet\">\n    <input type=\"hidden\" name=\"command\" value=\"reset\">\n    <input type=\"hidden\" name=\"password\" value=\"syzzy\">\n    <input type=\"submit\" name=\"Reset\" value=\"RESET!\">\n</form>\n```", "```java\nLock thelock = ....\ntry  {\n        lock.lock( );\n        // do the work that is protected by the lock\n} finally {\n        lock.unlock( );\n}\n```", "```java\nrwlock.readLock( ).lock( );\n...\nrwlock.readLock( ).unlock( );\n```", "```java\npublic class ReadersWriterDemo {\n    private static final int NUM_READER_THREADS = 3;\n\n    public static void main(String[] args) {\n        new ReadersWriterDemo().demo();\n    }\n\n    /** Set this to true to end the program */\n    private volatile boolean done = false;\n\n    /** The data being protected. */\n    private BallotBox theData;\n\n    /** The read lock / write lock combination */\n    private ReadWriteLock lock = new ReentrantReadWriteLock();\n\n    /**\n * Constructor: set up some quasi-random initial data\n */\n    public ReadersWriterDemo() {\n        List<String> questionsList = new ArrayList<>();\n        questionsList.add(\"Agree\");\n        questionsList.add(\"Disagree\");\n        questionsList.add(\"No opinion\");\n        theData = new BallotBox(questionsList);\n    }\n\n    /**\n * Run a demo with more readers than writers\n */\n    private void demo() {\n\n        // Start two reader threads\n        for (int i = 0; i < NUM_READER_THREADS; i++) {\n            new Thread() {\n                public void run() {\n                    while (!done) {\n                        lock.readLock().lock();\n                        try {\n                            theData.forEach(p ->\n                                System.out.printf(\"%s: votes %d%n\",\n                                    p.getName(),\n                                    p.getVotes()));\n                        } finally {\n                            // Unlock in \"finally\" to be sure it gets done.\n                            lock.readLock().unlock();\n                        }\n\n                        try {\n                            Thread.sleep(((long)(Math.random()* 1000)));\n                        } catch (InterruptedException ex) {\n                            // nothing to do\n                        }\n                    }\n                }\n            }.start();\n        }\n\n        // Start one writer thread to simulate occasional voting\n        new Thread() {\n            public void run() {\n                while (!done) {\n                    lock.writeLock().lock();\n                    try {\n                        theData.voteFor(\n                            // Vote for random candidate :-)\n                            // Performance: should have one PRNG per thread.\n                            (((int)(Math.random()*\n                            theData.getCandidateCount()))));\n                    } finally {\n                        lock.writeLock().unlock();\n                    }\n                    try {\n                        Thread.sleep(((long)(Math.random()*1000)));\n                    } catch (InterruptedException ex) {\n                        // nothing to do\n                    }\n                }\n            }\n        }.start();\n\n        // In the main thread, wait a while then terminate the run.\n        try {\n            Thread.sleep(10 * 1000);\n        } catch (InterruptedException ex) {\n            // nothing to do\n        } finally {\n            done = true;\n        }\n    }\n}\n```", "```java\nAgree(6), Disagree(6)\nAgree(9), Disagree(4)\n```", "```java\npublic class ProdCons15 {\n\n    protected volatile boolean done = false;\n\n    /** Inner class representing the Producer side */\n    class Producer implements Runnable {\n\n        protected BlockingQueue<Object> queue;\n\n        Producer(BlockingQueue<Object> theQueue) { this.queue = theQueue; }\n\n        public void run() {\n            try {\n                while (!done) {\n                    Object justProduced = getRequestFromNetwork();\n                    queue.put(justProduced);\n                    System.out.println(\n                        \"Produced 1 object; List size now \" + queue.size());\n                }\n            } catch (InterruptedException ex) {\n                System.out.println(\"Producer INTERRUPTED\");\n            }\n        }\n\n        Object getRequestFromNetwork() {    // Simulation of reading from client\n            try {\n                    Thread.sleep(10); // simulate time passing during read\n            } catch (InterruptedException ex) {\n                 System.out.println(\"Producer Read INTERRUPTED\");\n            }\n            return new Object();\n        }\n    }\n\n    /** Inner class representing the Consumer side */\n    class Consumer implements Runnable {\n        protected BlockingQueue<Object> queue;\n\n        Consumer(BlockingQueue<Object> theQueue) { this.queue = theQueue; }\n\n        public void run() {\n            try {\n                while (true) {\n                    Object obj = queue.take();\n                    int len = queue.size();\n                    System.out.println(\"List size now \" + len);\n                    process(obj);\n                    if (done) {\n                        return;\n                    }\n                }\n            } catch (InterruptedException ex) {\n                    System.out.println(\"CONSUMER INTERRUPTED\");\n            }\n        }\n\n        void process(Object obj) {\n            // Thread.sleep(123) // Simulate time passing\n            System.out.println(\"Consuming object \" + obj);\n        }\n    }\n\n    ProdCons15(int nP, int nC) {\n        BlockingQueue<Object> myQueue = new LinkedBlockingQueue<>();\n        for (int i=0; i<nP; i++)\n            new Thread(new Producer(myQueue)).start();\n        for (int i=0; i<nC; i++)\n            new Thread(new Consumer(myQueue)).start();\n    }\n\n    public static void main(String[] args)\n    throws IOException, InterruptedException {\n\n        // Start producers and consumers\n        int numProducers = 4;\n        int numConsumers = 3;\n        ProdCons15 pc = new ProdCons15(numProducers, numConsumers);\n\n        // Let the simulation run for, say, 10 seconds\n        Thread.sleep(10*1000);\n\n        // End of simulation - shut down gracefully\n        pc.done = true;\n    }\n}\n```", "```java\nif (assigned portion of work is “small enough”) {\n\tperform the work myself\n} else {\n\tsplit my work into two pieces\n\tinvoke the two pieces and await the results\n}\n```", "```java\n/** A trivial demonstration of the \"Fork-Join\" framework:\n * square a bunch of numbers using RecursiveAction.\n * We use RecursiveAction here b/c we don't need each\n * compute() call to return its result; the work is\n * accumulated in the \"dest\" array.\n * @see RecursiveTaskDemo when each computation has to return a value.\n * @author Ian Darwin\n */\npublic class RecursiveActionDemo extends RecursiveAction {\n\n    private static final long serialVersionUID = 3742774374013520116L;\n\n    static int[] raw = {\n        19, 3, 0, -1, 57, 24, 65, Integer.MAX_VALUE, 42, 0, 3, 5\n    };\n    static int[] sorted = null;\n\n    int[] source;\n    int[] dest;\n    int length;\n    int start;\n    final static int THRESHOLD = 4;\n\n    public static void main(String[] args) {\n        sorted = new int[raw.length];\n        RecursiveActionDemo fb =\n            new RecursiveActionDemo(raw, 0, raw.length, sorted);\n        ForkJoinPool pool = new ForkJoinPool();\n        pool.invoke(fb);\n        System.out.print('[');\n        for (int i : sorted) {\n            System.out.print(i + \",\");\n        }\n        System.out.println(']');\n    }\n\n    public RecursiveActionDemo(int[] src, int start, int length, int[] dest) {\n        this.source = src;\n        this.start = start;\n        this.length = length;\n        this.dest = dest;\n      }\n\n    @Override\n    protected void compute() {\n        System.out.println(\"RecursiveActionDemo.compute()\");\n        if (length <= THRESHOLD) { // Compute Directly\n            for (int i = start; i < start + length; i++) {\n                dest[i] = source[i] * source[i];\n            }\n        } else {                    // Divide and Conquer\n            int split = length / 2;\n            invokeAll(\n              new RecursiveActionDemo(source, start,         split,          dest),\n              new RecursiveActionDemo(source, start + split, length - split, dest));\n        }\n    }\n}\n```", "```java\n/**\n * Demonstrate the Fork-Join Framework to average a large array.\n * Running this on a multi-core machine as e.g.,\n * $ time java threads.RecursiveTaskDemo\n * shows that the CPU time is always greater than the elapsed time,\n * indicating that we are making use of multiple cores.\n * That said, it is a somewhat contrived demo.\n *\n * Use RecursiveTask<T> where, as in this example, each call returns\n * a value that represents the computation for its subset of the overall task.\n * @see RecursiveActionDemo when each computation does not return a value,\n * e.g., when each is just working on some section of a large array.\n * @author Ian Darwin\n */\npublic class RecursiveTaskDemo extends RecursiveTask<Long> {\n\n    private static final long serialVersionUID = 3742774374013520116L;\n\n    static final int N = 10000000;\n    final static int THRESHOLD = 500;\n\n    int[] data;\n    int start, length;\n\n    public static void main(String[] args) {\n        int[] source = new int[N];\n        loadData(source);\n        RecursiveTaskDemo fb = new RecursiveTaskDemo(source, 0, source.length);\n        ForkJoinPool pool = new ForkJoinPool();\n        long before = System.currentTimeMillis();\n        pool.invoke(fb);\n        long after = System.currentTimeMillis();\n        long total = fb.getRawResult();\n        long avg = total / N;\n        System.out.println(\"Average: \" + avg);\n        System.out.println(\"Time :\" + (after - before) + \" mSec\");\n    }\n\n    static void loadData(int[] data) {\n        Random r = new Random();\n        for (int i = 0; i < data.length; i++) {\n            data[i] = r.nextInt();\n        }\n    }\n\n    public RecursiveTaskDemo(int[] data, int start, int length) {\n        this.data = data;\n        this.start = start;\n        this.length = length;\n    }\n\n    @Override\n    protected Long compute() {\n        if (length <= THRESHOLD) { // Compute Directly\n            long total = 0;\n            for (int i = start; i < start + length; i++) {\n                total += data[i];\n            }\n            return total;\n        } else {                    // Divide and Conquer\n            int split = length / 2;\n            RecursiveTaskDemo t1 =\n                new RecursiveTaskDemo(data, start,         split);\n            t1.fork();\n            RecursiveTaskDemo t2 =\n                new RecursiveTaskDemo(data, start + split, length - split);\n            return t2.compute() + t1.join();\n        }\n    }\n}\n```", "```java\n2020 12 25 10 30 Get some sleep.\n2020 12 26 01 27 Finish this program\n2020 12 25 01 29 Document this program\n```", "```java\npublic class ReminderService {\n\n    /** The Timer object */\n    Timer timer = new Timer();\n\n    class Item extends TimerTask {\n        String message;\n        Item(String m) {\n            message = m;\n        }\n        public void run() {\n            message(message);\n        }\n    }\n\n    public static void main(String[] argv) throws Exception {\n        new ReminderService().loadReminders();\n    }\n\n    private String dfPattern = \"yyyy MM dd hh mm ss\";\n    private SimpleDateFormat formatter = new SimpleDateFormat(dfPattern);\n\n    protected void loadReminders() throws Exception {\n\n        Files.lines(Path.of(\"ReminderService.txt\")).forEach(aLine -> {\n\n            ParsePosition pp = new ParsePosition(0);\n            Date date = formatter.parse(aLine, pp);\n            String task = aLine.substring(pp.getIndex());\n            if (date == null) {\n                System.out.println(\"Invalid date in \" + aLine);\n                return;\n            }\n            System.out.println(\"Date = \" + date + \"; task = \" + task);\n            timer.schedule(new Item(task), date);\n        });\n    }\n```", "```java\npublic class AutoSave extends Thread {\n    /** The FileSave interface is implemented by the main class. */\n    protected FileSaver model;\n    /** How long to sleep between tries */\n    public static final int MINUTES = 5;\n    private static final int SECONDS = MINUTES * 60;\n\n    public AutoSave(FileSaver m) {\n        super(\"AutoSave Thread\");\n        setDaemon(true);        // so we don't keep the main app alive\n        model = m;\n    }\n\n    public void run() {\n        while (true) {        // entire run method runs forever.\n            try {\n                sleep(SECONDS*1000);\n            } catch (InterruptedException e) {\n                // do nothing with it\n            }\n            if (model.wantAutoSave() && model.hasUnsavedChanges())\n                model.saveFile(null);\n        }\n    }\n\n    // Not shown:\n    // 1) saveFile() must now be synchronized.\n    // 2) method that shuts down main program be synchronized on *SAME* object\n}\n\n/** Local copy of FileSaver interface, for compiling AutoSave demo. */\ninterface FileSaver {\n    /** Load new model from fn; if null, prompt for new fname */\n    public void loadFile(String fn);\n\n    /** Ask the model if it wants AutoSave done for it */\n    public boolean wantAutoSave();\n\n    /** Ask the model if it has any unsaved changes, don't save otherwise */\n    public boolean hasUnsavedChanges();\n\n    /** Save the current model's data in fn.\n * If fn == null, use current fname or prompt for a filename if null.\n */\n    public void saveFile(String fn);\n}\n```"]