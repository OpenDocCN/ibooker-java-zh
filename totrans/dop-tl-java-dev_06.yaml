- en: Chapter 6\. Package Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第六章。包管理
- en: Ixchel Ruiz
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 伊什切尔·鲁伊斯
- en: Somewhere in the world, as you read this sentence, a line of code is being written.
    This line of code will ultimately become part of an artifact that will become
    a building block used internally by an organization in one or more enterprise
    products, or shared via a public repository, most notably Maven Central for Java
    and Kotlin libraries.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当你阅读这句话时，世界的某个地方正在编写一行代码。这行代码最终将成为一个工件的一部分，该工件将成为组织内部一个或多个企业产品中使用的构建块，或者通过公共存储库（尤其是Java和Kotlin库的Maven中央库）共享。
- en: More libraries, binaries, and artifacts are available today than ever before,
    and this collection will continue to grow as developers around the world continue
    their next generation of products and services. Handling and managing these artifacts
    require more effort now than before—with an ever-increasing number of dependencies
    creating a complicated web of connectedness. Using an incorrect version of an
    artifact is an easy trap to fall into, causing confusion and broken builds, and
    ultimately thwarting carefully planned project release dates.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当今比以往任何时候都提供了更多的库、二进制文件和工件，随着全球开发人员继续推进下一代产品和服务，这一收藏还将继续增长。处理和管理这些工件现在比以往任何时候都需要更多的努力——由于依赖项数量不断增加，形成了一个复杂的连接网络。使用错误版本的工件是一个容易陷入的陷阱，导致混乱和构建失败，最终阻碍精心计划的项目发布日期。
- en: It’s more important than ever for developers to understand not only the function
    and the idiosyncrasies of the source code directly in front of them, but also
    how their projects are packaged and how the building blocks are assembled into
    the final product. Having a deep understanding of the build process itself and
    how our automated build tools function under the hood is crucial to avert delays
    and hours of unnecessary troubleshooting—not to mention prevent a large category
    of bugs escaping into production.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开发人员来说，现在比以往任何时候都更加重要的是不仅要理解他们面前的源代码的功能和特殊之处，还要了解他们的项目如何打包以及如何将构建块组装成最终产品。深入了解构建过程本身以及我们的自动构建工具在幕后如何运作，对于避免延误和几小时的不必要故障排除至关重要——更不用说防止大量的错误进入生产环境了。
- en: Access to troves of third-party resources that provide solutions to common coding
    problems can help speed the development of our projects but introduces the risk
    of errant or unexpected behavior. Understanding how these components are brought
    into projects as well as where they come from will help in troubleshooting efforts.
    Ensuring that we are responsible managers of the artifacts we produce internally
    will allow us to improve our decision-making and prioritization when it comes
    to bug fixes and feature development as well as help pave the way to release to
    production. A developer can no longer be versed in only the semantics of the code
    in front of them, but also the complexities of package management.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 访问提供常见编码问题解决方案的大量第三方资源可以帮助加速我们项目的开发，但也引入了错误或意外行为的风险。了解这些组件如何进入项目，以及它们来自何处，将有助于故障排除工作。确保我们对内部生产的工件负责任将使我们能够在决定缺陷修复和功能开发的优先级时提升我们的决策能力，并有助于铺平通向生产发布的道路。开发人员不再只精通于他们面前代码的语义，还要了解包管理的复杂性。
- en: Why Build-It-and-Ship-It Is Not Enough
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么“构建和交付”不再足够？
- en: Not so long ago, software developers viewed building an artifact as a culmination
    of hard, sometimes epic, efforts. Meeting deadlines sometimes meant using shortcuts
    and poorly documented steps. Since then, the requirements of the industry have
    changed to bring faster delivery cycles, diverse environments, tailored artifacts,
    exploding codebases and repositories, and multimodule packages. Today building
    an artifact is just one step of a bigger business cycle.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 不久以前，软件开发人员认为构建一个工件是辛苦甚至有时史诗般的努力的顶点。有时候满足截止日期意味着采用捷径和文档不全的步骤。自那时以来，行业的要求已经发生了变化，以带来更快的交付周期、多样化的环境、定制的工件、爆炸性的代码库和存储库以及多模块包。今天，构建一个工件只是更大商业周期的一个步骤之一。
- en: Successful leaders recognize that the best innovations emerge out of trial and
    error. That’s why they’ve made testing, experimentation, and failure an integral
    part of their lives and their company’s process.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的领导者认识到，最好的创新源于试错。这就是为什么他们把测试、实验和失败作为他们生活和公司流程的一个必不可少的部分的原因。
- en: One way to innovate, scale more quickly, launch more products, improve the quality
    or user experience of applications or products, and roll out new features is through
    A/B testing. What is A/B testing? According to Kaiser Fung, who founded the applied
    analytics program at Columbia University, *A/B testing* at its most basic is a
    century-old method used to compare two versions of something to figure out which
    performs better. Today several startups, well-established companies like Microsoft,
    and several other leading companies—including Amazon, Booking.com, Facebook, and
    Google—have been [conducting](https://oreil.ly/vRKPP) more than 10,000 online
    controlled experiments annually.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一种创新、快速扩展、推出更多产品、改善应用程序或产品的质量或用户体验、推出新功能的方法是通过 A/B 测试。什么是 A/B 测试？根据在哥伦比亚大学创办应用分析项目的
    Kaiser Fung 所说，*A/B 测试* 在其最基本的层面上是一种用于比较两个版本的东西以确定哪个表现更好的百年老方法。今天，几家初创公司、微软等大型公司以及其他几家领先公司—包括亚马逊、Booking.com、Facebook
    和 Google—每年都在进行[超过 10,000 次的在线控制实验](https://oreil.ly/vRKPP)。
- en: Booking.com conducts comparative testing on every new feature on its website,
    comparing details from the selection of photos and content to button color and
    placement. By testing several versions against one another and tracking customer
    response, the company is able to constantly improve the user experience.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Booking.com 对其网站上的每个新功能进行比较测试，比较从照片和内容的选择到按钮颜色和位置的细节。通过将几个版本相互比较并跟踪客户反馈，该公司能够不断改善用户体验。
- en: How do we deliver and deploy multiple versions of software composed of numerous
    artifacts? How do we find bottlenecks? How do we know we are moving in the right
    direction? How do we keep track of what is working well or what is working against
    us? How do we maintain a reproducible outcome but with enriched lineages? Answers
    to these questions can be found by capturing and analyzing relevant, contextual,
    clear, and specific information regarding the workflows and artifacts’ inputs,
    outputs, and states. All of this is possible thanks to metadata.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何交付和部署由众多工件组成的多个软件版本？我们如何找到瓶颈？我们如何知道我们正朝着正确的方向发展？我们如何跟踪工作得很好或者对我们不利的情况？我们如何保持可重现的结果，但又具有丰富的谱系？这些问题的答案可以通过捕获和分析有关工作流程和工件的输入、输出和状态的相关、上下文、清晰和具体信息来找到。所有这些都是可能的，这要归功于元数据。
- en: It’s All About Metadata
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全都是关于元数据
- en: As W. Edwards Deming said, “In God we trust; all others bring data.” *Metadata*
    is defined as a structured key/value storage of relevant information. In other
    words, it’s a collection of properties or attributes applicable to a particular
    entity, which in our case applies to artifacts and processes.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 正如 W. Edwards Deming 所说：“信仰上帝；所有其他人带来数据。” *元数据* 被定义为相关信息的结构化键/值存储。换句话说，它是适用于特定实体的属性或特性的集合，在我们的案例中适用于工件和流程。
- en: Metadata enables the discovery of correlations and causations as well as insights
    into the organization’s behavior and outcomes. As a result, metadata can show
    whether the organization is tuned in to its stakeholders’ goals.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据使得能够发现相关性和因果关系，以及对组织行为和结果的洞察。因此，元数据可以显示组织是否对其利益相关者的目标保持敏感。
- en: Additional data can be used in later stages to extract or derive more information.
    This data helps expand perspectives and create more stories, or narratives. It’s
    important to choose which attributes, cardinality, and values to add—too many,
    and we harm performance; too few, and we miss information. With too many values,
    insights can be lost.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 附加数据可以在后期用于提取或衍生更多信息。这些数据有助于扩展视角并创造更多故事或叙述。选择添加哪些属性、基数和值很重要—太多了会影响性能；太少了会错过信息。如果值太多，洞察力就会丧失。
- en: 'A good starting point is to answer the following questions concerning the main
    stages of each phase of the software development cycle: Who? What? How? Where?
    and When? Asking the right questions is only half of the effort, though. Having
    clear, relevant, specific, and clear answers that can be normalized or enumerated
    is always a good practice.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的起点是回答关于软件开发周期每个阶段的主要阶段的以下问题：谁？什么？如何？在哪里？何时？提出正确的问题只是一半的工作，然而，拥有清晰、相关、具体和清晰的答案，并能进行归一化或枚举，总是一个好的做法。
- en: Key Attributes of Insightful Metadata
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有见地的元数据的关键属性
- en: 'Insightful data should be all of the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有见地的数据应具备以下所有特点：
- en: Contextualized
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文化
- en: All data needs to be interpreted within a frame of reference. To extract and
    compare possible scenarios, it is important to have the right stage for analysis.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 所有数据都需要在参考框架内进行解释。为了提取和比较可能的场景，分析阶段非常重要。
- en: Relevant
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 相关
- en: The variability in the values has an impact on the outcome or describes a specific
    stage or time in the outcome or process.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 值的可变性对结果产生影响，或者描述结果或过程中的特定阶段或时间。
- en: Specific
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 具体
- en: The values describe a clear event (i.e., initial value, end value).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 值描述清晰的事件（即初始值、结束值）。
- en: Clear
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 清晰
- en: The possible values are well-known or defined, computable, and comparable.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的值是众所周知或定义的，可计算且可比较的。
- en: Unique
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 独特
- en: Has a single, distinctive value.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 具有单一、独特的值。
- en: Extensible
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 可扩展
- en: Because the wealth of human knowledge is ever increasing, the data needs to
    define mechanisms so that standards can be evolved and extended to accommodate
    new properties.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因为人类知识的丰富程度在不断增加，所以数据需要定义机制，以便标准可以进化和扩展，以适应新属性。
- en: Once you have defined what, when, why, and how to record the stages, inputs,
    outputs, and states of the software development cycle, you also need to keep in
    mind the consumers of subsets of the metadata. On one hand, you may have an intermediate
    private consumer who will consume and react in different ways to the set of values—from
    triggering sub pipelines, promoting builds, deploying in different environments,
    or publishing artifacts. On the other hand, you may have final external consumers
    who will be able to extract information and with skill and experience turn it
    into insights that will help fulfill the overall goals of the organization.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您已经定义了记录软件开发周期阶段、输入、输出和状态的内容的“什么”、“何时”、“为什么”和“如何”，您还需要牢记元数据子集的消费者。一方面，您可能会有一个中间的私有消费者，该消费者将以不同方式消费和响应一组值，从触发子流水线、推广构建、在不同环境中部署，或发布工件。另一方面，您可能会有最终的外部消费者，他们能够提取信息，并通过技能和经验将其转化为洞察力，以帮助实现组织的整体目标。
- en: Metadata Considerations
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元数据考虑
- en: 'The following are important considerations about metadata:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于元数据的重要考虑因素：
- en: Privacy and security
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 隐私与安全
- en: Think twice about exposing values.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑清楚暴露值的后果。
- en: Visibility
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 可见性
- en: Not all consumers are interested in all data.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有消费者都对所有数据感兴趣。
- en: Format and encoding
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 格式和编码
- en: One specific property may be exposed during different stages in different formats,
    but consistency is needed in the naming, meaning, and possibly the general value.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一种特定的属性可能在不同阶段以不同格式暴露，但在命名、含义及可能的一般值上需要保持一致。
- en: Let’s turn our attention to generating and packaging metadata with build tools.
    The Java ecosystem has no shortage of options when it comes to build tools. Arguably,
    the most popular are Apache Maven and Gradle; hence it makes sense to discuss
    them in depth. However, should your build depend on a different build tool, the
    information presented in this section will likely still prove to be useful, as
    some of the techniques to gather and package metadata may be reused.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们转向使用构建工具生成和打包元数据。在Java生态系统中，构建工具众多，其中最流行的可能是Apache Maven和Gradle；因此，深入讨论它们是有意义的。然而，如果您的构建依赖于不同的构建工具，本节提供的信息仍然可能很有用，因为一些收集和打包元数据的技术可能会被重复使用。
- en: 'Now, before we jump into practical code snippets, we have to figure out three
    action items:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们开始实际的代码片段之前，我们必须明确三个行动项：
- en: Determine the metadata that should be packaged with an artifact.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定应该与工件打包的元数据。
- en: Find out how that metadata can be obtained during the build.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 弄清楚在构建过程中如何获取元数据。
- en: Process the metadata and record it in the appropriate format or formats.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理元数据，并以适当的格式或格式记录它。
- en: The following subsections cover each of these aspects.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下子节涵盖了每个方面。
- en: Determining the Metadata
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确定元数据
- en: The build environment has no shortage of information that can be converted into
    metadata and packaged alongside an artifact. A good example is the build timestamp
    that identifies the time and date when the build produced the artifact. Many timestamp
    formats can be followed, but I recommend using [ISO 8601](https://oreil.ly/PsZkB),
    whose formatted representation using `java.text.SimpleDateformat` is `yyyy-MM-dd'T'HH:mm:ssXXX`—useful
    when the captured timestamp relies on `java.util.Date`. Alternatively, the `java.time.format.DateTimeFormatter.ISO_OFFSET_DATE_TIME`
    may be used if the captured timestamp relies on `java.time.Local​Da⁠teTime`. The
    build’s OS details may also be of interest, as well as JDK information such as
    version, ID, and vendor. Luckily for us, these bits of information are captured
    by the JVM and exposed via [`System`](https://oreil.ly/CKMsE) properties.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 构建环境中有大量信息可以转换为元数据并与构件一起打包。一个很好的例子是构建时间戳，它标识了构建生成构件的时间和日期。可以遵循许多时间戳格式，但我建议使用[ISO
    8601](https://oreil.ly/PsZkB)，其使用`java.text.SimpleDateformat`格式化表示为`yyyy-MM-dd'T'HH:mm:ssXXX`——当捕获时间戳依赖于`java.util.Date`时非常有用。或者，如果捕获时间戳依赖于`java.time.LocalDateTime`，则可以使用`java.time.format.DateTimeFormatter.ISO_OFFSET_DATE_TIME`。构建的操作系统详细信息也可能是感兴趣的，以及JDK信息，如版本、ID和供应商。幸运的是，这些信息由JVM捕获并通过[`System`](https://oreil.ly/CKMsE)属性公开。
- en: Consider including the artifact’s ID and version as well (even though these
    values are usually encoded in the artifact’s filename) as a precaution in case
    the artifact were to be renamed at some point. SCM information is also crucial.
    Useful information from source control includes the commit hash, tag, and branch
    name. Additionally, you may want to capture specific build information such as
    the user who runs the build; the build tool’s name, ID, and version; and the hostname
    and IP address of the build machine. These key/value pairs are likely the most
    significant and commonly found metadata. However, you may select additional key/value
    pairs required by other tools and systems that will consume the produced artifacts.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑包括构件的ID和版本（即使这些值通常编码在构件的文件名中），作为一种预防措施，以防构件在某些时候被重命名。版本控制信息也至关重要。从源代码控制中获取的有用信息包括提交哈希、标签和分支名称。此外，您可能希望捕获特定的构建信息，例如运行构建的用户、构建工具的名称、ID和版本，以及构建机器的主机名和IP地址。这些键/值对可能是最重要和最常见的元数据。但是，您可能还需要选择其他工具和系统所需的额外键/值对，以消费生成的构件。
- en: Caution
  id: totrans-49
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: I can’t stress enough how important it is to check your team’s and organization’s
    policies regarding access and visibility of sensitive data. Some of the key/value
    pairs mentioned before may be deemed a security risk if exposed to third parties
    or external consumers, though they may be of high importance to internal consumers.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 强调检查团队和组织关于敏感数据访问和可见性的政策有多么重要是不够的。如果敏感数据键/值对被第三方或外部消费者访问，这些键/值对可能被视为安全风险，尽管它们对内部消费者非常重要。
- en: Capturing Metadata
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取元数据
- en: We must find a way to gather the metadata with our build tool of choice after
    we have determined which metadata we need to capture. Some of the key/value pairs
    can be obtained directly from the environment, system settings, and command flags
    exposed by the JVM as environment variables or `System` properties. Additional
    properties may be exposed by the build tool itself, whether they are defined as
    additional command-line arguments or as configuration elements in the tool’s configuration
    settings.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定需要捕获哪些元数据之后，我们必须找到一种使用我们选择的构建工具来收集元数据的方法。某些键/值对可以直接从环境、系统设置和由JVM公开的命令标志（作为环境变量或`System`属性）中获取。额外的属性可能由构建工具本身公开，无论是作为额外的命令行参数还是作为工具配置设置中的配置元素。
- en: 'Let’s assume for the moment that we need to capture the following key/value
    pairs:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们需要在某一时刻捕获以下键/值对：
- en: JDK information such as version and vendor
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDK信息，例如版本和供应商
- en: OS information such as name, arch, and version
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统信息，如名称、架构和版本
- en: The build timestamp
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建时间戳
- en: The current commit hash from SCM (assuming Git)
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自版本控制系统的当前提交哈希（假设为Git）
- en: These values may be captured with Maven by using a combination of `System` properties
    for the first two items and a third-party plug-in for the last two. Both Maven
    and Gradle have no shortage of options when it comes to plug-ins that offer integration
    with Git; however, I recommend choosing [git-commit-id-maven-plugin](https://oreil.ly/EwiLP)
    for Maven and [versioning](https://oreil.ly/qjEOi) for Gradle, as these plug-ins
    are the most versatile so far.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值可以通过Maven捕获，通过使用前两个项目的`System`属性的组合和第三方插件来实现最后两个项目。当涉及到提供与Git集成的插件时，Maven和Gradle都有丰富的选择；然而，我推荐选择[Maven的git-commit-id插件](https://oreil.ly/EwiLP)和[Gradle的versioning插件](https://oreil.ly/qjEOi)，因为这些插件到目前为止是最通用的。
- en: 'Now, Maven allows defining properties in a handful of ways, most commonly as
    key/value pairs inside the `<properties>` section found in the *pom.xml* build
    file. The value for each key is free text, although you can refer to `System`
    properties by using a shorthand notation or to environment variables by using
    a naming convention. Say you want to access the value for the `java.version` key
    found in `System` properties. This can be done by using the `${}` shorthand notation
    such as `${java.version}`. Conversely, for an environment variable, you may use
    the `${env.*NAME*}` notation. For example, the value of an environment variable
    named `TOKEN` can be accessed using the expression `${env.TOKEN}` in the *pom.xml*
    build file. Putting together the `git-commit-id` plug-in and build properties
    may result in a *pom.xml* similar to the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Maven允许以多种方式定义属性，最常见的是作为*pom.xml*构建文件中`<properties>`部分内的键/值对。每个键的值都是自由文本，尽管您可以使用简化表示法引用`System`属性或使用命名约定引用环境变量。假设您想访问在`System`属性中找到的`java.version`键的值。这可以通过使用`${}`简写表示法，如`${java.version}`来完成。相反，对于环境变量，您可以使用`${env.*NAME*}`表示法。例如，可以使用`${env.TOKEN}`表达式在*pom.xml*构建文件中访问名为`TOKEN`的环境变量的值。将`git-commit-id`插件和构建属性组合在一起可能会导致类似以下的*pom.xml*文件：
- en: '[PRE0]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that the values for `build.jdk` and `build.os` already include formatting
    as they are composites of simpler values, whereas the `build.revision` and `build.timestamp`
    values come from the properties defined by the Git plug-in. We have yet to determine
    the final format and file or files that will contain the metadata, which is why
    we see it defined in the `<properties>` section. This setup allows these values
    to be reused and consumed by other plug-ins should they need it. Another reason
    to prefer this setup is that external tools (such as those found in a build pipeline)
    may read these values more easily as they are located at a specific section instead
    of at many places within the build file.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`build.jdk`和`build.os`的值已经包含格式，因为它们是更简单值的组合，而`build.revision`和`build.timestamp`的值来自Git插件定义的属性。我们还未确定最终的格式和包含元数据的文件或文件，这就是为什么我们看到它在`<properties>`部分中定义的原因。这种设置允许这些值在需要时被其他插件重用和消费。选择这种设置的另一个原因是，外部工具（比如在构建流水线中找到的工具）可以更容易地读取这些值，因为它们位于特定部分，而不是在构建文件的多个位置。
- en: Also note the chosen value of version, `1.0.0-SNAPSHOT`. You may use any character
    combination for the version as you deem necessary. However, it’s customary to
    at least use an alphanumeric sequence that defines two numbers in the `*major*`.`*minor*`
    format. A handful of versioning conventions are out there, with both advantages
    and drawbacks. This being said, the use of the `-SNAPSHOT` tag has a special meaning
    as it indicates the artifact is not yet ready for production. Some tools will
    behave differently when a snapshot version is detected; for example, they can
    prevent an artifact from ever being published to a production environment.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意所选择的版本值，`1.0.0-SNAPSHOT`。您可以根据需要使用任何字符组合作为版本。然而，习惯上至少使用定义两个数字的`*major*`.`*minor*`格式的字母数字序列。存在多种版本控制约定，各有优缺点。尽管如此，使用`-SNAPSHOT`标签具有特殊含义，因为它表示该构件尚未准备好投入生产。一些工具在检测到快照版本时会有不同的行为；例如，它们可以阻止构件发布到生产环境。
- en: 'In contrast to Maven, Gradle has no shortage of options when it comes to defining
    and writing build files. To begin with, since Gradle 4, you have two choices for
    the build file format: Apache Groovy DSL or Kotlin DSL. Regardless of which one
    you pick, you will soon find that there are more options to capture and format
    metadata. Some of them may be idiomatic, some may require additional plug-ins,
    and some may even be considered outdated or obsolete. To keep this example short
    and basic, we’ll go with Groovy and small idiomatic expressions. We’ll capture
    the same metadata similarly as we did for Maven, with the first two values coming
    from `System` properties and the commit hash provided by the `versioning` Git
    plug-in, but the build timestamp will be calculated on the spot by using custom
    code. The following snippet shows how this can be done:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Maven 相比，Gradle 在定义和编写构建文件时没有短缺的选项。首先，自 Gradle 4 以来，您可以选择两种构建文件格式：Apache Groovy
    DSL 或 Kotlin DSL。无论您选择哪种，您很快会发现有更多选项可以捕获和格式化元数据。其中一些可能是习惯用法的，有些可能需要额外的插件，甚至有些可能被视为过时或已废弃。为了简单起见，我们将采用
    Groovy 和小型习惯用法表达式。我们将类似于 Maven 一样捕获相同的元数据，前两个值来自`System`属性和由`versioning` Git 插件提供的提交哈希，但构建时间戳将通过使用自定义代码即时计算。以下代码片段显示了如何实现这一点：
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: These computed values will be available as dynamic project properties that may
    be consumed later in the build by additional configured elements such as extensions,
    tasks, closures (for Groovy), actions (for Groovy and Kotlin), and other elements
    exposed by the DSL. All that is left now is recording the metadata in a given
    format.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这些计算得出的数值将作为动态项目属性提供，稍后可以通过其他配置的元素（如扩展、任务、Groovy 的闭包、Groovy 和 Kotlin 的动作以及 DSL
    公开的其他元素）在构建过程中消耗。现在只剩下将元数据记录在指定的格式中。
- en: Writing the Metadata
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 写入元数据
- en: 'You might need to record metadata in more than one format or file. The choice
    of format depends on the intended consumers. Some consumers require a unique format
    that no other consumer can read, whereas others may understand a variety of formats.
    Be sure to consult the documentation of a given consumer on its supported formats
    and options and also check whether integration with your build tool of choice
    is provided. You might discover that a plug-in for your build is available that
    eases the recording process of the metadata that you need. For demonstration purposes,
    we’ll record the metadata by using two popular formats: a Java properties file
    and the JAR’s manifest.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能需要记录多种格式或文件中的元数据。格式的选择取决于预期的消费者。有些消费者需要一种独特的格式，其他消费者无法读取，而其他人可能理解各种格式。请务必查阅特定消费者的文档，了解其支持的格式和选项，并检查您选择的构建工具是否提供了集成。您可能会发现，您的构建工具中提供了插件，可以简化您所需的元数据记录过程。为了演示目的，我们将使用两种流行格式记录元数据：Java
    属性文件和 JAR 的清单。
- en: 'We can leverage Maven’s [resource filtering](https://oreil.ly/X1x0q), which
    is baked into the [resources plug-in](https://oreil.ly/YqOSO), part of the core
    set of plug-ins that every build has access to. For this to work, we must add
    the following snippet to the previous *pom.xml* file, inside the `<build>` section:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用 Maven 的[资源过滤](https://oreil.ly/X1x0q)，这已经集成到[资源插件](https://oreil.ly/YqOSO)中，是每个构建都可以访问的核心插件之一。为了使其工作，我们必须将以下代码片段添加到前面的*pom.xml*文件中的`<build>`部分：
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'A companion properties file located at *src/main/resources* is also required.
    I’ve chosen *META-INF/metadata.properties* as the relative path and name of the
    properties file to be found inside the artifact JAR. Of course, you may choose
    a different naming convention as needed. This file relies on variable placeholder
    substitutions, variables that will be resolved from project properties such as
    those we set in the `<properties>` section. By convention, little configuration
    information is needed in the build file. The properties file looks like the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要一个位于*src/main/resources*的配套属性文件。我选择*META-INF/metadata.properties*作为位于工件 JAR
    内部的属性文件的相对路径和名称。当然，您可以根据需要选择不同的命名约定。此文件依赖于变量占位符替换，这些变量将从项目属性中解析，例如我们在`<properties>`部分设置的那些。按照惯例，在构建文件中几乎不需要配置信息。属性文件看起来像这样：
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Recording the metadata in the JAR’s manifest requires tweaking the configuration
    of the `jar-maven-plugin` applicable to a build file. The following snippet must
    be included inside the `<plugins>` section found in the `<build>` section. In
    other words, it’s a sibling of the `git-commit-id` plug-in we saw earlier in this
    section:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JAR 的清单中记录元数据需要调整 `jar-maven-plugin` 的配置，适用于构建文件。下面的片段必须包含在 `<build>` 部分中的
    `<plugins>` 部分内。换句话说，它与本节前面看到的 `git-commit-id` 插件是同级的：
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Note that a specific plug-in version is defined even though this plug-in is
    part of the core plug-in set. The reason behind this is that it’s imperative to
    declare all plug-in versions for the sake of reproducible builds. Otherwise, you
    will find builds may differ as different plug-in versions may be resolved depending
    on the specific version of Maven used to run the build. Each entry in the manifest
    is composed of a capitalized key and the captured value. Running the build with
    `mvn package` resolves the captured properties, copies the metadata properties
    file with resolved values into the *target/classes* directory where it will be
    added to the final JAR, and injects the metadata into the JAR’s manifest. We can
    verify this by inspecting the contents of the generated artifact:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，即使此插件是核心插件集的一部分，也定义了特定的插件版本。背后的原因是必须声明所有插件版本以便实现可重复的构建。否则，你会发现构建可能会有所不同，因为根据运行构建所使用的
    Maven 版本的不同，可能会解析不同的插件版本。清单中的每个条目由大写键和捕获值组成。使用 `mvn package` 运行构建会解析捕获的属性，将解析后的值复制到
    *target/classes* 目录中的元数据属性文件中，该文件将被添加到最终 JAR 中，并且将元数据注入到 JAR 的清单中。我们可以通过检查生成的构件的内容来验证这一点：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The two files are found inside the JAR file as expected. Extracting the JAR
    and looking at the contents of the properties file and the JAR manifest yield
    the following results:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 两个文件如预期般在 JAR 文件中找到。提取 JAR 并查看属性文件和 JAR 清单的内容将得到以下结果：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You’ve seen how to collect metadata with Maven. Let’s see the same method of
    recording metadata by using a properties file and a JAR manifest with a different
    build tool: Gradle. For the first part, we’ll configure the standard `processResources`
    task that’s provided by the `java-library` plug-in we applied to the build. The
    additional configuration can be appended to the previously shown Gradle build
    file, and it looks like the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到如何使用 Maven 收集元数据。现在让我们看看通过另一个构建工具 Gradle 来记录元数据的相同方法。首先，我们将配置由我们应用于构建的
    `java-library` 插件提供的标准 `processResources` 任务。额外的配置可以追加到之前展示的 Gradle 构建文件中，如下所示：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Note that the names of the keys use `_` as a token separator, because of the
    default resource filtering mechanism appleid by Gradle. If we were to use `.`
    as we saw earlier with Maven, Gradle would expect to find a `build` object with
    matching `jdk`, `os`, `revision`, and `timestamp` properties during resource filtering.
    That object does not exist, which will cause the build to fail. Changing the token
    separator avoids that problem but also forces us to change the contents of the
    properties file to the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到键名中使用 `_` 作为令牌分隔符，这是由 Gradle 默认的资源过滤机制所决定的。如果我们像之前 Maven 中那样使用 `.`，Gradle
    将期望在资源过滤时找到具有匹配 `jdk`、`os`、`revision` 和 `timestamp` 属性的 `build` 对象。然而这个对象并不存在，会导致构建失败。改变令牌分隔符可以避免这个问题，但也迫使我们修改属性文件的内容如下：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Configuring the JAR manifest is a straightforward operation given that the
    `jar` task offers an entry point for this behavior, as shown by the following
    snippet that can also be appended to the existing Gradle build file:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 配置 JAR 清单是一个简单的操作，因为 `jar` 任务为此行为提供了一个入口点，如下片段所示，也可以追加到现有的 Gradle 构建文件中：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As seen before, each manifest entry uses a capitalized key and its corresponding
    captured value. Running the build with `gradle jar` should produce results similar
    to those provided by Maven: the properties file will be copied to a target location
    where it can be included in the final JAR, with its value placeholders substituted
    for the actual metadata values, and the JAR manifest will be enriched with metadata
    as well. Inspecting the JAR shows that it contains the expected files:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前看到的那样，每个清单条目使用大写键和相应的捕获值。使用 `gradle jar` 运行构建应该会产生类似 Maven 提供的结果：属性文件将被复制到目标位置，在最终
    JAR 中包含其值占位符的替换值，并且 JAR 清单也将被丰富为包含元数据。检查 JAR 文件显示它包含了预期的文件：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Unpacking the JAR and looking inside each file yields the following results:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 解压 JAR 并查看每个文件内部的结果如下：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Perfect! That is all that there is to it. Let me encourage you to add or remove
    key/value pairs as needed as well as configure other plug-ins (for both Maven
    and Gradle) that may expose additional metadata or provide other means to process
    and record metadata into particular formats.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！就是这样。让我鼓励你根据需要添加或删除键/值对，并配置其他插件（用于 Maven 和 Gradle）以公开附加元数据或提供其他处理和记录元数据到特定格式的方法。
- en: Dependency Management Basics for Maven and Gradle
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Maven 和 Gradle 的依赖管理基础
- en: 'Dependency management has been a staple of Java projects since Maven *1.x*
    came to light in 2002\. The gist behind this feature is to declare artifacts that
    are required for compiling, testing, and consuming a particular project, relying
    on additional metadata attached to an artifact such as its group identifier, artifact
    identifier, version, and sometimes a classifier as well. This metadata is typically
    exposed using a well-known file format: the [Apache Maven POM](https://oreil.ly/1Kzp6)
    expressed in a *pom.xml* file. Other build tools are capable of understanding
    this format, and can even produce and publish *pom.xml* files despite using a
    totally unrelated format for declaring build aspects, as is the case for Gradle
    with `build.gradle` (Groovy) or `build.gradle.kts` (Kotlin) build file.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖管理自 Maven *1.x* 于 2002 年首次亮相以来，已成为 Java 项目的重要组成部分。该功能的核心是声明编译、测试和消费特定项目所需的构件，依赖于附加到构件的附加元数据，例如其组标识符、构件标识符、版本，有时还包括分类器。这些元数据通常以广为人知的文件格式公开：在
    *pom.xml* 文件中表达的 [Apache Maven POM](https://oreil.ly/1Kzp6)。其他构建工具能够理解该格式，甚至可以生成和发布
    *pom.xml* 文件，尽管使用完全不相关的格式声明构建方面，例如 Gradle 使用的 `build.gradle`（Groovy）或 `build.gradle.kts`（Kotlin）构建文件。
- en: Despite being a core feature provided by Maven since the early days, and also
    a core feature in Gradle, dependency management and dependency resolution remain
    a stumbling block for many. Even though the rules to declare dependencies are
    not complicated, you may find yourself at the mercy of published metadata with
    invalid, misleading, or missing constraints. The following subsections are a primer
    for dependency management using both Maven and Gradle, but it is by no means an
    exhaustive explanation—that would take a whole book on just this topic.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管自 Maven 早期以来便是提供的核心功能，并且也是 Gradle 的核心功能，但依赖管理和依赖解析仍然是许多人的绊脚石。尽管声明依赖项的规则并不复杂，但您可能会发现自己受到发布的具有无效、误导或缺失约束的元数据的影响。以下各小节是使用
    Maven 和 Gradle 进行依赖管理的入门指南，但这绝不是详尽的解释——仅此话题就可以写一整本书。
- en: In other words, tread carefully, dear reader, there be dragons ahead. I’ll do
    my best to point out the safest paths. We’ll begin with Maven, as it is the build
    tool that defines the artifact metadata using the *pom.xml* file format.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，亲爱的读者，请小心，前方有龙。我将尽力指出最安全的路径。我们将从 Maven 开始，因为它是使用 *pom.xml* 文件格式定义构件元数据的构建工具。
- en: Dependency Management with Apache Maven
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Apache Maven 进行依赖管理
- en: 'You likely have encountered a POM file before—after all, it’s ubiquitous. A
    POM file with model version 4.0.0 is responsible for defining the way artifacts
    are produced and consumed. In Maven version 4, these two capabilities are split,
    although the model version remains the same for compatibility reasons. It’s expected
    that the model format will change when Maven version 5.0.0 is introduced. although
    there are no details on how this model will look at the time of writing. One thing
    is sure: the Maven developers are keen on keeping backward compatibility. Let’s
    walk through the basics.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能以前遇到过 POM 文件，毕竟它无处不在。具有模型版本 4.0.0 的 POM 文件负责定义产生和消费构件的方式。在 Maven 4 版本中，这两个功能已分开，尽管模型版本出于兼容性原因保持不变。预计当引入
    Maven 5.0.0 版本时，模型格式将会发生变化，尽管目前写作时尚无详细信息。有一点可以确定：Maven 开发人员热衷于保持向后兼容性。让我们从基础知识开始。
- en: 'Dependencies are identified by three required elements: `groupId`, `artifactId`,
    and `version`. These elements are collectively known as *Maven coordinates*, or
    *GAV coordinates*, where GAV, as you may have guessed, stands for `groupId`, `artifactId`,
    `version`. From time to time, you may find dependencies that define a fourth element
    named `classifier`.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖由三个必需元素标识：`groupId`、`artifactId` 和 `version`。这些元素统称为 *Maven 坐标* 或 *GAV 坐标*，其中
    GAV 如你所料，代表 `groupId`、`artifactId`、`version`。偶尔你会发现定义了名为 `classifier` 的第四个元素的依赖项。
- en: Let’s break them down one by one. Both `artifactId` and `version` are straightforward;
    the former defines the “name” of the artifact, and the latter defines a version
    number. Many different versions may be associated with the same `artifactId`.
    The `groupId` is used to put together a set of artifacts that have some sort of
    relationship—that is, all of them belong to the same project or provide behavior
    that’s germane to one another. The `classifier` adds another dimension to the
    artifact, albeit optional. Classifiers are often used to differentiate artifacts
    that are specific to a particular setting such as the operating system or the
    Java release. Examples of operating system classifiers are found in the JavaFX
    binaries, such as *javafx-controls-15-win.jar*, *javafx-controls-15-mac.jar*,
    and *javafx-controls-15-linux.jar*, which identify version 15 of the JavaFX control
    binaries that may be used with Windows, macOS, and Linux platforms.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一分解它们。`artifactId` 和 `version` 都很直接；前者定义了构件的“名称”，后者定义了版本号。同一个 `artifactId`
    可能关联多个不同的版本。`groupId` 用于组合一组具有某种关系的构件，即它们都属于同一个项目或提供彼此相关的行为。`classifier` 添加了构件的另一个维度，尽管它是可选的。分类器通常用于区分特定设置下的构件，例如操作系统或Java版本。操作系统分类器的示例可以在JavaFX二进制文件中找到，例如
    *javafx-controls-15-win.jar*、*javafx-controls-15-mac.jar* 和 *javafx-controls-15-linux.jar*，它们标识了可以与Windows、macOS和Linux平台一起使用的JavaFX控件二进制版本15。
- en: Another set of common classifiers are `sources` and `javadoc`, which identify
    JAR files that contain sources and generated documentation (via the Javadoc tool).
    The combination of GAV coordinates must be unique; otherwise, the dependency resolution
    mechanism will have a hard time finding out correct dependencies to use.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 另一组常见的分类器是 `sources` 和 `javadoc`，它们标识包含源代码和生成文档（通过Javadoc工具）的JAR文件。GAV 坐标的组合必须是唯一的；否则，依赖解析机制将很难找到正确的依赖项使用。
- en: 'POM files let you define dependencies inside the `<dependencies>` section,
    where you would list GAV coordinates for each dependency. In its simplest form,
    it looks something like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: POM文件允许你在 `<dependencies>` 部分内定义依赖项，其中你会列出每个依赖项的 GAV 坐标。在其最简单的形式中，看起来像这样：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Dependencies listed in this way are known as *direct dependencies*, as they
    are explicitly declared in the POM file. This classification holds true even for
    dependencies that may be declared in a POM that’s marked as a parent of the current
    POM. What’s a parent POM? It’s just like another *pom.xml* file except that your
    POM marks it with a parent/child relationship by using the `<parent>` section.
    In this way, configuration defined by the parent POM can be inherited by the child
    POM. We can inspect the dependency graph by invoking the `mvn dependency:tree`
    command, which resolves the dependency graph and prints it out:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式列出的依赖项称为 *直接依赖项*，因为它们在POM文件中是显式声明的。即使依赖项可能在标记为当前POM的父POM中声明，此分类也成立。什么是父POM？它就像另一个
    *pom.xml* 文件一样，只是你的POM通过使用 `<parent>` 部分将它标记为父/子关系。通过这种方式，父POM定义的配置可以被子POM继承。我们可以通过调用
    `mvn dependency:tree` 命令来检查依赖图，该命令解析依赖图并将其打印出来：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here we can see that the current POM (identified by its GAV coordinates as
    `com.acme:example:1.0.0-SNAPSHOT`) has a single direct dependency. Two additional
    elements are found in the output of the `commons-collections4` dependency: the
    first is `jar`, which identifies the type of the artifact, and the second is `compile`,
    which identifies the scope of the dependency. We’ll come back to scopes in a moment,
    but suffice to say that if no explicit `<scope>` element is defined for a dependency,
    its default scope becomes `compile`. Now, when a POM that contains direct dependencies
    is consumed, it brings along those dependencies as transitive from the point of
    view of the consuming POM. The next example shows that particular setup:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们可以看到当前 POM（通过其 GAV 坐标标识为 `com.acme:example:1.0.0-SNAPSHOT`）具有单个直接依赖项。在 `commons-collections4`
    依赖项的输出中找到了两个额外的元素：第一个是 `jar`，它标识了构件的类型，第二个是 `compile`，它标识了依赖的范围。稍后我们会回到范围的问题，但可以简单地说，如果对于一个依赖项没有显式定义
    `<scope>` 元素，那么它的默认范围就是 `compile`。现在，当消费包含直接依赖项的 POM 时，它会从消费 POM 的角度带来这些依赖项作为传递性。下一个示例展示了具体的设置：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Resolving and printing out the dependency graph using the same command as before
    yields this result:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与之前相同的命令解析和打印依赖图产生了以下结果：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This tells us that the `commons-beanutils` artifact has two dependencies set
    in the ​ `com⁠pile` scope, which from the point of view of the `com.acme:example:1.0.0-SNAPSHOT`
    happen to be seen as transitive. These two transitive dependencies appear to have
    no direct dependencies of their own, as there’s nothing listed for either of them.
    However, if you were to look at the `commons-logging` POM file, you’ll find the
    following dependency declarations:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们，`commons-beanutils` 组件有两个依赖关系设置在`com⁠pile`范围内，从`com.acme:example:1.0.0-SNAPSHOT`的角度来看，这两个传递依赖关系被视为传递的。这两个传递依赖关系似乎没有自己的直接依赖关系，因为它们的列表中没有任何内容。然而，如果你查看`commons-logging`的POM文件，你会发现以下依赖声明：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, there are actually five dependencies! However, four of them
    define an additional `<optional>` element, while two define a different value
    for `<scope>`. Dependencies marked as `<optional>` may be required for compiling
    and testing the producer (`commons-logging` in this case) but not necessarily
    for consumers; this is determined on a case-by-case basis.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，实际上有五个依赖关系！然而，其中四个定义了一个额外的`<optional>`元素，而另外两个定义了`<scope>`的不同值。标记为`<optional>`的依赖关系可能对编译和测试生产者（本例中的`commons-logging`）是必需的，但并不一定适用于消费者；这是根据具体情况确定的。
- en: 'It’s time to discuss scopes now that we see them once again. *Scopes* determine
    whether a dependency is to be included in the classpath, as well as limit its
    transitivity. Maven defines six scopes as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们再次看到它们时，是时候讨论范围了。*范围*确定依赖项是否包括在类路径中，并限制其传递性。Maven定义了六个范围，如下所示：
- en: '`compile`'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`compile`'
- en: The default scope, used if none is specified, as we saw earlier. Dependencies
    in this scope will be used for all classpaths in the project (compile, runtime,
    test) and will be propagated to consuming projects.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的范围，如果未指定范围，则使用之前看到的范围。这个范围中的依赖项将用于项目中的所有类路径（compile、runtime、test），并将传播到消费项目中。
- en: '`provided`'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`provided`'
- en: Like `compile`, except that it does not affect the runtime classpath nor is
    it transitive. Dependencies set in this scope are expected to be provided by the
    hosting environment, as is the case for web applications packaged as WARs and
    launched from within an application server.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于`compile`，但不影响运行时类路径，也不是传递的。在这个范围内设置的依赖项预期由托管环境提供，例如作为WAR包打包并在应用服务器中启动的Web应用程序。
- en: '`runtime`'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`runtime`'
- en: This scope indicates the dependency is not required for compilation but for
    execution. Both the runtime and test classpaths include dependencies set in this
    scope, while the compile classpath is ignored.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个范围指示依赖项不是编译所必需的，而是执行所必需的。运行时和测试类路径都包括在这个范围内设置的依赖项，而编译类路径则被忽略。
- en: '`test`'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`test`'
- en: Defines dependencies required for compiling and running tests. This scope is
    not transitive.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了编译和运行测试所需的依赖项。这个范围不是传递的。
- en: '`system`'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`system`'
- en: Similar to `provided` except that dependencies must be listed with an explicit
    path, relative or absolute. Therefore, this scope is seen as a bad practice and
    should be avoided at all costs. For a handful of use cases, it may come in handy,
    but you must bear the consequences. At best, it’s an option left to the experts—in
    other words, imagine that this scope does not exist at all.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于`provided`，但必须列出具有显式路径（相对或绝对）的依赖项。因此，这个范围被视为不良实践，应该尽量避免使用。对于少数用例，它可能会有所帮助，但你必须承担后果。最好情况下，它是留给专家的选择——换句话说，可以想象这个范围根本不存在。
- en: '`import`'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`import`'
- en: Applies only to dependencies of type `pom` (the default is `jar` if not specified)
    and can be used only for dependencies declared inside the `<dependencyManagement>`
    section. Dependencies in this scope are replaced by the list of dependencies found
    in their own `<dependencyManagement>` section.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 仅适用于`pom`类型的依赖项（如果未指定，则默认为`jar`）。只能用于在`<dependencyManagement>`部分内声明的依赖项。在这个范围内的依赖项将被其自身`<dependencyManagement>`部分中的依赖项列表所替代。
- en: 'The `<dependencyManagement>` section has three purposes: to provide version
    hints for transitive dependencies, to provide a list of dependencies that may
    be imported using the `import` scope, and to provide a set of defaults when used
    in a parent-child POM combination. Let’s look at the first purpose. Say you have
    the following dependencies defined in your POM file:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`<dependencyManagement>`部分有三个目的：为传递依赖项提供版本提示，提供一个可以使用`import`范围导入的依赖项列表，并在父子POM组合中使用一组默认值。让我们看看第一个目的。假设在你的POM文件中定义了以下依赖项：'
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Both the `guice` and `truth` artifacts define `guava` as a direct dependency.
    This means `guava` is seen as a transitive dependency from the consumer’s point
    of view. We get the following result if we resolve and print out the dependency
    graph:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`guice` 和 `truth` 的 artifact 都将 `guava` 定义为直接依赖。这意味着从消费者的角度来看，`guava` 被视为一个传递依赖。如果我们解析并打印出依赖图，我们会得到以下结果：'
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The resolved version of `guava` turns out to be `25.1-android` because that’s
    the version found first in the graph. Look what happens if we invert the order
    of the dependencies and list `truth` before `guice` and resolve the graph once
    again:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`guava` 的解析版本结果是 `25.1-android`，因为这是在图中首先找到的版本。看看如果我们颠倒依赖项的顺序，然后再次解析图形会发生什么：'
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now the resolved version of `guava` happens to be `27.0.1-android` because it’s
    the one found first in the graph. This particular behavior is a constant source
    of head-scratching moments and frustration. As developers, we are used to versioning
    conventions, most notably [semantic versioning](https://semver.org) when it applies
    to dependency versions.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`guava` 的解析版本恰好是 `27.0.1-android`，因为它是在图中首先找到的版本。这种特定行为常常让人不知所措和沮丧。作为开发者，我们习惯于版本控制规范，尤其是
    [语义化版本控制](https://semver.org)。
- en: Semantic versioning tells us that version tokens (separated by dots) have specific
    meaning based on their position. The first token identifies the major release,
    the second token identifies the minor release, and the third token identifies
    the build/patch/fix/revision release. It’s also customary that version `27.0.1`
    is seen as more recent than `25.1.0` because the major number `27` is greater
    than `25`. In our case, we have two versions for `guava` in the graph, `27.0.1-android`
    and `25.1-android`, and both are found at the same distance from the current POM—that
    is, just one level down in the transitive graph.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 语义化版本控制告诉我们，版本号标记（由点分隔）根据其位置具有特定含义。第一个标记标识主要发布版本，第二个标记标识次要发布版本，第三个标记标识构建/补丁/修订版本。通常情况下，版本
    `27.0.1` 被视为比 `25.1.0` 更近，因为主要编号 `27` 大于 `25`。在我们的情况下，图中有两个 `guava` 版本，`27.0.1-android`
    和 `25.1-android`，并且两者在当前 POM 的同一级别——即传递图中仅下降一级处找到。
- en: It’s easy to assume that because we, as developers, are aware of semantic versioning
    and can clearly determine which version is more recent, so can Maven—and that
    is where assumption clashes with reality! Maven never looks at the version, but
    looks only at the location within the graph. This is why we get different results
    if we change the order of dependencies. We can use the `<dependencyManagement>`
    section to fix this issue.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者通常会认为，因为我们知道语义化版本控制，并且可以清楚地确定哪个版本更新，所以 Maven 也能做到这一点，但现实并非如此！ Maven 从不查看版本号，而只看图中的位置。这就是为什么如果我们改变依赖项的顺序，会得到不同的结果。我们可以使用
    `<dependencyManagement>` 部分来解决这个问题。
- en: 'Dependencies defined in the `<dependencyManagement>` section usually have the
    three main GAV coordinates. When Maven resolves dependencies, it will look at
    the definitions found in this section to see whether there’s a match for `groupId`
    and `artifactId`, in which case the associated `version` will be used. It does
    not matter how deep in the graph a dependency may be, or how many times it may
    be found in the graph. If there’s a match, that explicit version will be the chosen
    one. We can verify this claim by adding a `<dependencyManagement>` section to
    the consumer POM that looks like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `<dependencyManagement>` 部分定义的依赖通常具有三个主要的 GAV 坐标。当 Maven 解析依赖关系时，它会查看此部分中的定义，以确定是否有匹配的
    `groupId` 和 `artifactId`，如果匹配，则使用关联的 `version`。不管依赖项在图中的深度如何，或者它在图中出现了多少次，只要匹配，就会选择明确指定的版本。我们可以通过向消费者
    POM 添加类似于以下内容的 `<dependencyManagement>` 部分来验证这一点：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can see that the declaration for `guava` uses the `com.google.guava:guava:29.0-jre`
    coordinates, meaning that version `29.0-jre` will be used if a transitive dependency
    happens to match the given `groupId` and `artifactId`. We know this will happen
    in our consumer POM, twice to be exact. We get the following result when resolving
    and printing out the dependency graph:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到 `guava` 的声明使用了 `com.google.guava:guava:29.0-jre` 坐标，这意味着如果一个传递依赖恰好匹配给定的
    `groupId` 和 `artifactId`，将会使用版本 `29.0-jre`。我们知道这将在我们的消费者 POM 中发生两次。当解析并打印出依赖图时，我们得到以下结果：
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note that the chosen version for `guava` is indeed `29.0-jre` and not the previous
    versions we saw earlier in this chapter, confirming that the `<dependencyManagement>`
    section is performing its job as expected.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `guava` 的选择版本确实是 `29.0-jre`，而不是本章早些时候看到的旧版本，这证实了 `<dependencyManagement>`
    部分按预期执行其工作。
- en: 'The second purpose of `<dependencyManagement>`, listing dependencies that may
    be imported, is accomplished by using the `import` scope alongside dependencies
    of type `pom`. These types of dependencies usually define `<dependencyManagement>`
    sections of their own, although nothing stops these POMs from adding more sections.
    POM dependencies that define a `<dependencyManagement>` section and no `<dependencies>`
    section are known as bill of materials (BOM). Typically, BOM dependencies define
    a set of artifacts that belong together for a particular purpose. Although not
    explicitly defined in the Maven documentation, you can find two kinds of BOM dependencies:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`<dependencyManagement>` 的第二个目的是列出可能被导入的依赖项，通过使用 `import` 范围和类型为 `pom` 的依赖项来实现。这些类型的依赖通常定义了它们自己的
    `<dependencyManagement>` 部分，虽然这些 POM 可以增加更多的部分。定义了 `<dependencyManagement>` 部分但没有
    `<dependencies>` 部分的 POM 依赖项称为材料清单（BOM）。通常，BOM 依赖项定义了一组为特定目的归属在一起的构件。尽管在 Maven
    文档中没有明确定义，但可以找到两种类型的 BOM 依赖项：'
- en: Library
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 库
- en: All declared dependencies belong to the same project even though they might
    have different group IDs, and possibly even different versions. An example can
    be seen at [helidon-bom](https://oreil.ly/bcMHI), which groups all artifacts from
    the Helidon project.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 所有声明的依赖关系都属于同一个项目，即使它们可能具有不同的组 ID，甚至可能有不同的版本。例如，可以看到 [helidon-bom](https://oreil.ly/bcMHI)，它将
    Helidon 项目的所有构件分组在一起。
- en: Stack
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈
- en: Dependencies are grouped by behavior and the synergy they bring. Dependencies
    may belong to disparate projects. See an example at [helidon-dependencies](https://oreil.ly/wgmVx),
    which groups the previous `helidon-bom` with other dependencies such as Netty,
    logging, and so on.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项按行为和它们带来的协同作用进行分组。依赖关系可能属于不同的项目。请参阅 [helidon-dependencies](https://oreil.ly/wgmVx)
    的示例，它将之前的 `helidon-bom` 与其他依赖项（如 Netty、日志记录等）分组在一起。
- en: 'Let’s take the `helidon-dependencies` as a source of dependencies. Inspecting
    this POM, we find dozens of dependencies declared inside its `<dependencyManagement>`
    section, only a few of which are seen in the following snippet:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将 `helidon-dependencies` 视为依赖项的源头。检查此 POM，我们发现在其 `<dependencyManagement>`
    部分声明了几十个依赖项，以下摘录中仅显示了其中的几个：
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Consuming this BOM dependency in our own POM requires the use of the `<dependencyManagement>`
    section once again. We’ll also define an explicit dependency for `netty-handler`
    as we have done before when defining dependencies, except that this time we’ll
    omit the `<version>` element. The POM ends up looking like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们自己的 POM 中使用这个 BOM 依赖项需要再次使用 `<dependencyManagement>` 部分。我们还将为 `netty-handler`
    定义一个显式依赖，就像我们在定义依赖时做过的那样，只是这次我们会省略 `<version>` 元素。POM 最终看起来像这样：
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Note how the `helidon-dependencies` dependency was imported. A key element
    must be defined, `<type>`, which must be set as `pom`. Remember from earlier in
    this chapter that dependencies will have type `jar` by default if no value is
    specified? Here we know that `helidon-dependencies` is a BOM; thus it does not
    have a JAR file associated with it. If we leave out the type element, Maven will
    complain with a warning and will fail to resolve the version of `netty-handler`,
    so be sure not to miss setting this element correctly. Resolving the dependency
    graph yields the following result:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `helidon-dependencies` 依赖项是如何导入的。必须定义一个关键元素 `<type>`，它必须设置为 `pom`。还记得本章前面提到的吗？如果未指定值，默认情况下依赖关系的类型为
    `jar`。在这里，我们知道 `helidon-dependencies` 是一个 BOM；因此它没有与之关联的 JAR 文件。如果我们省略类型元素，Maven
    将发出警告并且无法解析 `netty-handler` 的版本，所以务必确保正确设置这个元素。解析依赖关系图会产生以下结果：
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We can see that the correct version was chosen and that every direct dependency
    of `netty-handler` is resolved as transitive as well.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到选择了正确的版本，并且 `netty-handler` 的每个直接依赖关系也被解析为传递依赖关系。
- en: The third and final purpose of the `<dependencyManagement>` section comes into
    play when a parent-child relationship exists between POMs. The POM format defines
    a `<parent>` section that any POM can use to establish a link with another POM
    seen as a parent. Parent POMs provide configuration that can be inherited by child
    POMs, the parent `<dependencyManagement>` section being one of them. Maven follows
    the parent link upward until it can no longer find a parent definition, then processes
    down the chain resolving configuration, with the POMs located at lower levels
    overriding configuration set by those POMs in higher levels.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`<dependencyManagement>` 部分的第三个和最后一个目的在于当 POM 之间存在父子关系时发挥作用。POM 格式定义了一个 `<parent>`
    部分，任何 POM 都可以使用它来与另一个被视为父级的 POM 建立关联。父 POM 提供的配置可以被子 POM 继承，其中父 `<dependencyManagement>`
    部分就是其中之一。Maven 沿着父链接向上进行，直到无法找到父定义，然后沿着链条向下处理解析配置，位于较低级别的 POM 覆盖由较高级别 POM 设置的配置。'
- en: 'This means a child POM always has the option to override configuration declared
    by a parent POM. Thus, a `<dependencyManagement>` section found in the parent
    POM will be visible to the child POM, as if it were defined on the child. We still
    get the same benefits from the two previous purposes of this section, which means
    we can fix versions for transitive dependencies and import BOM dependencies. The
    following is an example of a parent POM that declares `helidon-dependencies` and
    `commons-lang3` in its own `<dependencyManagement>` section:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着子 POM 总是有选择权来覆盖父 POM 声明的配置。因此，父 POM 中找到的 `<dependencyManagement>` 部分将对子
    POM 可见，就像它是在子 POM 上定义的一样。我们仍然可以从此部分前两个目的中获得相同的好处，这意味着我们可以为传递依赖项固定版本并导入 BOM 依赖项。以下是一个父
    POM 的示例，它在自己的 `<dependencyManagement>` 部分中声明了 `helidon-dependencies` 和 `commons-lang3`：
- en: '[PRE27]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Given that no JAR file is associated with this POM file, we also must explicitly
    define the value for the `<packaging>` element as `pom`. The child POM requires
    the use of the `<parent>` element to refer to this POM, shown in the following
    example:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于此 POM 文件未关联任何 JAR 文件，我们还必须显式定义 `<packaging>` 元素的值为 `pom`。子 POM 需要使用 `<parent>`
    元素来引用此 POM，如下例所示：
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Perfect! With this setup ready, it’s time to once again resolve the dependency
    graph and inspect its contents:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！准备好这个设置后，现在是时候再次解析依赖图并检查其内容了：
- en: '[PRE29]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We have two direct dependencies as expected, with the correct GAV coordinates,
    as well as the transitive dependencies as seen earlier. A few additional items
    are related to dependency management and resolution, such as dependency exclusions
    (eject a transitive dependency by its GA coordinates) and failing the build on
    dependency conflicts (different versions of the same GA coordinates found in the
    graph). However, it’s best to stop here and have a look at what Gradle offers
    in terms of dependency management.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，我们有两个直接依赖项，具有正确的 GAV 坐标，以及前面看到的传递依赖项。还有一些与依赖管理和解析相关的附加项，如依赖项排除（通过其 GA
    坐标排除传递依赖项）和在依赖冲突中失败构建（在图中找到相同 GA 坐标的不同版本）。然而，最好在这里停下来，看看 Gradle 在依赖管理方面提供了什么。
- en: Dependency Management with Gradle
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Gradle 进行依赖管理
- en: As mentioned earlier, Gradle builds on top of the lessons learned from Maven
    and understands the POM format, allowing it to provide dependency resolution capabilities
    similar to Maven. Gradle also offers additional capabilities and finer-grained
    control. This section refers to topics already covered, so I recommend you read
    the preceding section first in the event you skipped it, or if you need a refresher
    on dependency management as provided by Maven. Let’s have a look at what Gradle
    offers.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，Gradle 建立在从 Maven 学到的教训之上，并理解 POM 格式，使其能够提供类似于 Maven 的依赖解析能力。Gradle
    还提供了额外的能力和更精细的控制。本节涉及已经讨论过的主题，因此建议您首先阅读前面的部分，以防您跳过了它，或者如果您需要回顾 Maven 提供的依赖管理的内容。让我们看看
    Gradle 提供了什么。
- en: 'First, you must select the DSL for writing the build file. Your options are
    the Apache Groovy DSL or the Kotlin DSL. We’ll continue with the former, as Groovy
    has more examples found in the wild. It’s also easier to move from Groovy to Kotlin
    than vice versa, meaning that snippets written with Groovy can be used verbatim
    with Kotlin (with perhaps a few changes suggested by the IDE), whereas moving
    in the other direction requires knowledge of both DSLs. The next step is picking
    the format for recording dependencies, for which there are quite a few; the most
    common formats are a single literal with GAV coordinates, such as this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，必须选择用于编写构建文件的DSL。您的选项是Apache Groovy DSL或Kotlin DSL。我们将继续使用前者，因为在实际应用中有更多的示例。从Groovy转换到Kotlin比反向转换更容易，这意味着可以直接使用Groovy编写的代码片段（可能需要IDE建议的一些更改），而反向转换需要掌握两种DSL。下一步是选择依赖项记录的格式，有多种常见格式，如单个GAV坐标文字，例如：
- en: '[PRE30]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'and the Map literal that splits each member of the GAV coordinates into its
    own element, such as this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 和将每个GAV坐标成员分割为自己元素的Map文字，例如：
- en: '[PRE31]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note that Gradle chose to go with `group` instead of `groupId`, and `name` instead
    of `artifactId`, though the semantics are the same.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Gradle选择使用`group`而不是`groupId`，以及`name`而不是`artifactId`，尽管语义相同。
- en: 'The next order of business is declaring dependencies for a particular scope
    (in Maven’s terms), though Gradle calls this *configuration*, and the behavior
    goes beyond what scopes are capable of. Assuming the `java-library` plug-in is
    applied to a Gradle build file, we gain access to the following configurations
    by default:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的任务是声明特定范围（在Maven术语中）的依赖项，虽然Gradle称其为*配置*，其行为超出了范围的能力。假设将`java-library`插件应用于Gradle构建文件，则默认情况下可以访问以下配置：
- en: '`api`'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`api`'
- en: Defines dependencies required for compiling production code and affects the
    compile classpath. It is equivalent to the `compile` scope and thus is mapped
    as such when a POM is generated.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了编译生产代码所需的依赖项，并影响编译类路径。它等同于`compile`范围，因此在生成POM时被映射为这样。
- en: '`implementation`'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`implementation`'
- en: Defines dependencies required for compilation but deemed as implementation details;
    they are more flexible than dependencies found in the `api` configuration. This
    configuration affects the compile classpath but will be mapped to the `runtime`
    scope when a POM is generated.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了编译所需但被视为实现细节的依赖项；它们比`api`配置中的依赖项更灵活。此配置影响编译类路径，但在生成POM时将映射到`runtime`范围。
- en: '`compileOnly`'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`compileOnly`'
- en: Defines dependencies required for compilation but not for execution. This configuration
    affects the compile classpath, but these dependencies are not shared with other
    classpaths. Also, they are not mapped to the generated POM.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了编译所需但不执行的依赖项。此配置影响编译类路径，但这些依赖项不与其他类路径共享。此外，在生成的POM中它们也不被映射。
- en: '`runtimeOnly`'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`runtimeOnly`'
- en: Dependencies in this configuration are needed for execution only and affect
    only the runtime classpath. They are mapped to the `runtime` scope when a POM
    is generated.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置中的依赖项仅用于执行，并仅影响运行时类路径。在生成POM时，它们映射到`runtime`范围。
- en: '`testImplementation`'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`testImplementation`'
- en: Defines dependencies required for compiling test code and affects the `testCompile`
    classpath. They are mapped to the `test` scope when a POM is generated.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了编译测试代码所需的依赖项，并影响`testCompile`类路径。在生成POM时，它们映射到`test`范围。
- en: '`testCompileOnly`'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`testCompileOnly`'
- en: Defines dependencies required for compiling test code but not for execution.
    This configuration affects the `testCompile` classpath, but these dependencies
    are not shared with the testRuntime classpath. Also, they are not mapped to the
    generated POM.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了编译测试代码但不执行的依赖项。此配置影响`testCompile`类路径，但这些依赖项不与`testRuntime`类路径共享。此外，在生成的POM中它们也不被映射。
- en: '`testRuntimeOnly`'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`testRuntimeOnly`'
- en: Dependencies with this configuration are needed for executing test code and
    affect only the `testRuntime` classpath. They are mapped to the `test` scope when
    a POM is generated.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 具有此配置的依赖项用于执行测试代码，仅影响`testRuntime`类路径。在生成POM时，它们映射到`test`范围。
- en: 'You may see additional configurations depending on the Gradle version in use,
    including the following legacy ones (which were deprecated in Gradle 6 and removed
    in Gradle 7):'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会根据使用的Gradle版本看到其他配置，包括以下已弃用的（在Gradle 6中已弃用，在Gradle 7中移除）：
- en: '`compile`'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`compile`'
- en: This configuration was split into `api` and `implementation`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置已拆分为`api`和`implementation`。
- en: '`runtime`'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`runtime`'
- en: Deprecated in favor of `runtimeOnly`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Deprecated in favor of `runtimeOnly`.
- en: '`testCompile`'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`testCompile`'
- en: Deprecated in favor of `testImplementation` to align with the `implementation`
    configuration name.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Deprecated in favor of `testImplementation` to align with the `implementation`
    configuration name.
- en: '`testRuntime`'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`testRuntime`'
- en: Deprecated in favor of `testRuntimeOnly` to be consistent with `runtimeOnly`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Deprecated in favor of `testRuntimeOnly` to be consistent with `runtimeOnly`.
- en: Similarly to Maven, the classpaths follow a hierarchy. The compile classpath
    can be consumed by the runtime classpath, thus every dependency set in either
    the `api` or `implementation` configurations is also available for execution.
    This classpath can also be consumed by the test compile classpath, enabling production
    code to be seen by test code. The runtime and test classpaths are consumed by
    the test runtime classpath, allowing test execution access to all dependencies
    defined in all the configurations so far mentioned.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Similarly to Maven, the classpaths follow a hierarchy. The compile classpath
    can be consumed by the runtime classpath, thus every dependency set in either
    the `api` or `implementation` configurations is also available for execution.
    This classpath can also be consumed by the test compile classpath, enabling production
    code to be seen by test code. The runtime and test classpaths are consumed by
    the test runtime classpath, allowing test execution access to all dependencies
    defined in all the configurations so far mentioned.
- en: 'As with Maven, dependencies can be resolved from repositories. Unlike Maven,
    in which both Maven local and Maven Central repositories are always available,
    in Gradle we must explicitly define the repositories from which dependencies may
    be consumed. Gradle lets you define repositories that follow the standard Maven
    layout, the Ivy layout, and even local directories with a flat layout. It also
    provides conventional options to configure the most commonly known repository,
    Maven Central. We’ll use `mavenCentral` for now as our only repository. Putting
    together everything we have seen so far, we can produce a build file like the
    following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 'As with Maven, dependencies can be resolved from repositories. Unlike Maven,
    in which both Maven local and Maven Central repositories are always available,
    in Gradle we must explicitly define the repositories from which dependencies may
    be consumed. Gradle lets you define repositories that follow the standard Maven
    layout, the Ivy layout, and even local directories with a flat layout. It also
    provides conventional options to configure the most commonly known repository,
    Maven Central. We’ll use `mavenCentral` for now as our only repository. Putting
    together everything we have seen so far, we can produce a build file like the
    following:'
- en: '[PRE32]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can print the resolved dependency graph by invoking the `dependencies` task.
    However, this will print the graph for every single configuration, so we’ll print
    only the resolved dependency graph for the compile classpath for the sake of keeping
    the output short, as well as to showcase an extra setting that can be defined
    for this task:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 'We can print the resolved dependency graph by invoking the `dependencies` task.
    However, this will print the graph for every single configuration, so we’ll print
    only the resolved dependency graph for the compile classpath for the sake of keeping
    the output short, as well as to showcase an extra setting that can be defined
    for this task:'
- en: '[PRE33]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As you can see, only a single dependency is printed out, because `commons-collections`
    does not have any direct dependencies of its own that are visible to consumers.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: As you can see, only a single dependency is printed out, because `commons-collections`
    does not have any direct dependencies of its own that are visible to consumers.
- en: 'Let’s see what happens when we configure another dependency that brings in
    additional transitive dependencies, but this time using the `implementation` configuration
    that will show that both `api` and `implementation` contribute to the compile
    classpath. The updated build file looks like this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 'Let’s see what happens when we configure another dependency that brings in
    additional transitive dependencies, but this time using the `implementation` configuration
    that will show that both `api` and `implementation` contribute to the compile
    classpath. The updated build file looks like this:'
- en: '[PRE34]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Running the `dependencies` task with the same configuration as before now yields
    the following result:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 'Running the `dependencies` task with the same configuration as before now yields
    the following result:'
- en: '[PRE35]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This tells us our consumer project has two direct dependencies contributing
    to the compile classpath, and that one of those dependencies brings two additional
    dependencies seen as transitive from our consumer’s point of view. If for some
    reason you’d like to skip bringing those transitive dependencies into your dependency
    graph, you can add an extra block of configuration on the direct dependency that
    declares them, like this:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 'This tells us our consumer project has two direct dependencies contributing
    to the compile classpath, and that one of those dependencies brings two additional
    dependencies seen as transitive from our consumer’s point of view. If for some
    reason you’d like to skip bringing those transitive dependencies into your dependency
    graph, you can add an extra block of configuration on the direct dependency that
    declares them, like this:'
- en: '[PRE36]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Running the `dependencies` task once more now shows only the direct dependencies
    and no transitive dependencies:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 'Running the `dependencies` task once more now shows only the direct dependencies
    and no transitive dependencies:'
- en: '[PRE37]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The final aspect I’d like to cover before moving on is that unlike Maven, Gradle
    understands semantic versioning and will act accordingly during dependency resolution,
    choosing the highest version number as a result. We can verify this by configuring
    two versions of the same dependency, no matter whether they are direct or transitive,
    as shown in the following snippet:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我想要讨论的最后一个方面是，与 Maven 不同，Gradle 理解语义化版本，并将在依赖解析过程中相应地选择最高版本号。我们可以通过配置两个版本的相同依赖来验证这一点，无论它们是直接的还是传递的，如下面的片段所示：
- en: '[PRE38]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In this case, we have declared a direct dependency for `commons-collections`
    version `3.2.1`. We know from previous runs that `commons-beanutils:1.9.4` brings
    in version `3.2.2` of `commons-collections`. Given that `3.2.2` is considered
    more recent than `3.2.1`, we expect that `3.2.2` will be resolved. Invoking the
    `dependencies` task yields the following result:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们声明了对`commons-collections`版本`3.2.1`的直接依赖。我们从之前的运行中知道，`commons-beanutils:1.9.4`引入了`commons-collections`的`3.2.2`版本。鉴于`3.2.2`被认为比`3.2.1`更新，我们期望`3.2.2`将被解析。调用`dependencies`任务将产生以下结果：
- en: '[PRE39]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As expected, version 3.2.2 was selected. The output even contains an indicator
    telling us when a dependency version was set to a different value other than the
    requested one. Versions may be also configured to be fixed regardless of their
    semantic versioning scheme, even to lower values. This is because Gradle offers
    more flexible options for dependency resolution strategies. However, that falls
    into the realm of advanced topics alongside dependency locking, strict versus
    suggested versions, dependency relocation, platforms and enforced platforms (Gradle’s
    way to interact with BOM artifacts), and more.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，选择了版本 3.2.2。输出甚至包含一个指示器，告诉我们何时将依赖版本设置为与请求的版本不同的值。版本也可以配置为固定的，而不考虑它们的语义化版本方案，甚至可以设置为较低的值。这是因为
    Gradle 提供了更灵活的依赖解析策略选项。然而，这属于高级主题的范畴，与依赖锁定、严格与建议的版本、依赖重定位、平台和强制平台（Gradle 与 BOM
    工件交互的方式）以及其他内容相关。
- en: Dependency Management Basics for Containers
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器的依赖管理基础
- en: Further along the line of the software development cycle, you may encounter
    a step where packaging your Maven and Gradle project into a container image is
    necessary. Just like other dependencies in your project, your container images
    must also be managed appropriately and in concert with other required artifacts.
    Containers are discussed in detail in [Chapter 3](ch03.xhtml#thinking_in_containers),
    but this section focuses primarily on some of the subtleties of container image
    management. As with the dependency management in the automated build tools Maven
    and Gradle, even more dragons may lie ahead.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发周期的进一步过程中，您可能会遇到一个步骤，需要将您的 Maven 和 Gradle 项目打包成容器镜像。就像项目中的其他依赖项一样，您的容器镜像也必须适当地管理，并与其他所需的工件协调一致。容器在[第三章](ch03.xhtml#thinking_in_containers)中有详细讨论，但本节主要关注容器镜像管理的一些微妙之处。与自动化构建工具
    Maven 和 Gradle 中的依赖管理一样，可能还会遇到更多问题。
- en: As you learned in [Chapter 3](ch03.xhtml#thinking_in_containers), containers
    are launched using container images that are most commonly defined using a Dockerfile.
    The Dockerfile does the work of defining each layer of the image that will be
    used to build the running container. From this definition, you will get a base
    distribution layer, code libraries and frameworks, and any other needed files
    or artifacts required to run your software. Here you will also define any necessary
    configuration (for example, open ports, database credentials, and references to
    messaging servers) as well as any required users and permissions.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在[第三章](ch03.xhtml#thinking_in_containers)中学到的那样，容器是使用容器镜像启动的，这些镜像通常使用 Dockerfile
    定义。Dockerfile 的作用是定义镜像的每一层，这些层将用于构建运行的容器。从这个定义中，您将获得基础分发层、代码库和框架，以及运行软件所需的任何其他文件或工件。在这里，您还将定义任何必要的配置（例如开放端口、数据库凭据和消息服务器的引用），以及任何需要的用户和权限。
- en: It’s line 1 of the Dockerfile that we discuss in this section first, or in the
    case of multistage build Dockerfiles, the lines that begin with the directive
    `FROM`. Similarly to the Maven POM, an image can be built from a `parent` image,
    which may be built from another parent image—a hierarchy that goes all the way
    to a `base` image, the original ancestor. Here we must pay special attention to
    the way our images are composed.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中首先讨论的是 Dockerfile 的第 1 行，或者在多阶段构建的 Dockerfile 中，以 `FROM` 指令开头的行。与 Maven
    POM 类似，一个镜像可以从一个`父`镜像构建，该父镜像可能来自另一个父镜像，一直到`基础`镜像，即最初的祖先。在这里，我们必须特别注意我们的镜像组合方式。
- en: As you may remember from [Chapter 3](ch03.xhtml#thinking_in_containers), the
    versioning of Docker images is intended to provide flexibility during the development
    stage of your software, as well as a measure of confidence that you are using
    the latest maintenance update of an image when desired. Most often this is done
    by referencing the special image version `latest` (the default version if a version
    is not specified), a request for which will retrieve what is assumed to be the
    latest version of the image in active development. Although not a perfect comparison,
    this is most like using a `snapshot` version of a Java dependency.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能还记得的来自 [第 3 章](ch03.xhtml#thinking_in_containers) 的内容，Docker 镜像的版本控制旨在在软件开发阶段提供灵活性，并在需要时使用最新的维护更新来增强信心。大多数情况下，这是通过引用特殊的镜像版本
    `latest`（如果未指定版本，则为默认版本）来实现的，请求该版本将检索到被假定为正在开发中的镜像的最新版本。虽然不是完美的比较，但这最像使用 Java
    依赖的 `快照` 版本。
- en: This is all fine and good during development, but when it comes to troubleshooting
    a new bug in production, this type of versioning in a production image artifact
    can make troubleshooting more of a challenge. Once an image has been built with
    this default `latest` version in place for a parent or a base image, reproducing
    the build may be difficult or even impossible. Just as you would want to avoid
    using a snapshot dependency in a production release, I recommend locking down
    your image versions and avoiding using the default `latest` in order to limit
    the number of moving parts.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中一切正常，但是当在生产环境中出现新 bug 需要进行故障排除时，生产镜像工件中的这种版本控制可能会增加故障排除的难度。一旦一个镜像已经使用默认的
    `latest` 版本构建完成，重现构建可能会很困难甚至不可能。就像您希望在生产发布中避免使用快照依赖一样，我建议锁定您的镜像版本并避免使用默认的 `latest`
    版本，以限制不必要的变动部分。
- en: Simply locking down your image versions isn’t sufficient from the context of
    security. Use only trusted base images when building your containers. This tip
    might seem like an obvious one, but third-party registries often don’t have any
    governance policies for the images stored in them. It’s important to know which
    images are available for use on the Docker host, understand their provenance,
    and review their content. You should also enable Docker Content Trust (DCT) for
    image verification and install only verified packages into images.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅锁定您的镜像版本并不足以确保安全。构建容器时，请只使用可信任的基础镜像。这个建议看起来可能很明显，但第三方注册表通常没有对其存储的镜像制定治理政策。了解哪些镜像可以在
    Docker 主机上使用，了解它们的来源并审查其内容非常重要。您还应该为镜像验证启用 Docker 内容信任（DCT），并且只安装经过验证的软件包到镜像中。
- en: Use minimal base images that don’t include unnecessary software packages that
    could lead to a larger attack surface. Having fewer components in your container
    reduces the number of available attack vectors, and a minimal image also yields
    better performance because there are fewer bytes on disk and less network traffic
    for images being copied. BusyBox and Alpine are two options for building minimal
    base images. Pay just as careful attention to any additional layers you build
    on top of your verified base image by explicitly specifying all versions of software
    packages or any other artifacts you pull into the image.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 使用尽可能少的基础镜像，不包含可能导致攻击面变大的不必要软件包。在您的容器中减少组件数量可以减少可用的攻击向量，而且最小化的镜像还能提升性能，因为磁盘上的字节数更少，拷贝镜像时网络流量也较少。BusyBox
    和 Alpine 是构建最小基础镜像的两个选择。在您验证的基础镜像上构建任何额外的层时，一定要特别注意明确指定所有软件包的版本或者您拉取到镜像中的任何其他工件。
- en: Artifact Publication
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布工件
- en: Up to now, I’ve discussed how artifacts and dependencies may be resolved, often
    from locations known as repositories, but what is a repository, and how do you
    publish artifacts to it? In the most basic sense, an *artifact repository* is
    file storage that keeps track of artifacts. A repository collects metadata on
    each published artifact and uses that metadata to offer additional capabilities
    such as search, archiving, access control lists (ACLs), and others. Tools can
    harness this metadata to offer other capabilities on top such as vulnerability
    scanning, metrics, categorization, and more.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我已经讨论了如何解析构件和依赖项，通常从称为仓库的位置获取，但仓库究竟是什么，以及如何向其发布构件？从最基本的角度来看，*构件仓库*是文件存储，用于跟踪构件。仓库收集每个发布构件的元数据，并利用该元数据提供额外功能，如搜索、归档、访问控制列表（ACL）等。工具可以利用这些元数据提供其他高级功能，如漏洞扫描、指标、分类等。
- en: 'We can use two types of repositories for Maven dependencies, those dependencies
    that can be resolved via GAV coordinates: local and remote. Maven uses a configurable
    directory found in the local file system to keep track of dependencies that have
    been resolved. These dependencies may have been downloaded from a remote repository
    or directly placed there by the Maven tool itself. This directory is typically
    referred to as *Maven Local*, and its default location is *.m2/repository*, found
    at the home directory of the current user. This location is configurable. On the
    other side of the spectrum are remote repositories, which are handled by repository
    software such as Sonatype Nexus Repository, JFrog Artifactory, and others. The
    most well-known remote repository is Maven Central, which is the canonical repository
    for resolving artifacts.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用两种类型的仓库来管理 Maven 依赖项，这些依赖项可以通过 GAV 坐标解析：本地和远程。Maven 使用本地文件系统中的可配置目录来跟踪已解析的依赖项。这些依赖项可以从远程仓库下载，也可以直接由
    Maven 工具放置在那里。这个目录通常被称为*Maven 本地*，其默认位置为当前用户的主目录下的*.m2/repository*。这个位置是可配置的。另一端是远程仓库，由仓库软件如
    Sonatype Nexus Repository、JFrog Artifactory 等处理。最著名的远程仓库是 Maven 中央仓库，用于解析构件的标准仓库。
- en: Let’s discuss now how we can publish artifacts to local and remote repositories.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们讨论如何将构件发布到本地和远程仓库。
- en: Publishing to Maven Local
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布到 Maven 本地
- en: Maven offers three ways to publish artifacts to the Maven Local repository.
    Two are explicit, and one is implicit. We’ve already covered the implicit one—it
    occurs whenever Maven resolves a dependency from a remote repository; as a result,
    a copy of the artifact and its metadata (the associated *pom.xml*) will be placed
    in the Maven Local repository. This behavior occurs by default since Maven uses
    Maven Local as a cache to avoid requesting artifacts over the network all over
    again.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Maven 提供了三种方式将构件发布到 Maven 本地仓库。其中两种是显式的，一种是隐式的。我们已经涵盖了隐式的方式——每当 Maven 从远程仓库解析依赖项时都会发生这种情况，结果是构件的副本及其元数据（相关的*pom.xml*）将被放置在
    Maven 本地仓库中。这种行为默认发生，因为 Maven 使用 Maven 本地作为缓存，以避免再次通过网络请求构件。
- en: 'The other two ways of publishing artifacts to Maven Local are by explicitly
    “installing” files into the repository. Maven has a set of lifecycle phases, of
    which *install* is one. This phase is well-known by Java developers, as it’s used
    (and abused) to compile, test, package, and install artifacts to Maven Local.
    The Maven lifecycle phases follow a predetermined sequence:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 发布构件到 Maven 本地的另外两种方式是显式地“安装”文件到仓库中。Maven 有一组生命周期阶段，其中*install*是其中之一。这个阶段对于
    Java 开发者来说非常熟悉，因为它用于（有时滥用于）编译、测试、打包和将构件安装到 Maven 本地。Maven 生命周期阶段遵循预定的顺序：
- en: '[PRE40]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Phases are executed in sequence until the terminal phase is found. Thus invoking
    *install* typically results in an almost full build (except for *deploy* and *site*).
    I mentioned *install* is abused, as most times it’s enough to invoke *verify*,
    the phase that’s right before *install*, as the former will force compile, test,
    package, and integration-test but does not pollute Maven Local with artifacts
    if they are not needed. This is in no way a recommendation to drop *install* in
    favor of *verify* all the time, as sometimes a test will require resolving artifacts
    from Maven Local. The bottom line is to be aware of the inputs/outputs of each
    phase and their consequences.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 阶段按顺序执行直至找到终端阶段。因此，通常调用*install*将导致几乎完整的构建（除了*deploy*和*site*）。我提到*install*被滥用了，因为大多数情况下只需调用*verify*即可，后者位于*install*之前的阶段，它会强制编译、测试、打包和集成测试，但如果不需要，则不会将构件污染到Maven本地。这绝不是建议始终放弃*install*而选择*verify*，因为有时测试需要从Maven本地解析构件。关键是要意识到每个阶段的输入/输出及其后果。
- en: 'Back to installing. The first way to install artifacts to Maven Local is simply
    invoking the *install* phase, like so:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 回到安装。将构件安装到Maven本地的第一种方法是简单地调用*install*阶段，就像这样：
- en: '[PRE41]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This will place copies of all of the *pom.xml* files renamed to follow the
    convention `*artifactId*`-`*version*.pom` as well as every attached artifact into
    Maven Local. Attached artifacts are typically the binary JARs produced by the
    build but can also include other JARs such as the `-sources` and `-javadoc` JARs.
    The second way to install artifacts is by manually invoking the `install:install-file`
    goal with a set of parameters. Let’s say you have a JAR (*artifact.jar*) and a
    matching POM file (*artifact.pom*). Installing them can be done in the following
    way:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这将会复制所有的*pom.xml*文件并按照约定重命名为`*artifactId*`-`*version*.pom`，同时将每个附加的构件放入Maven本地。附加的构件通常是构建生成的二进制JAR文件，也可以包括其他JAR文件，比如`-sources`和`-javadoc`
    JAR文件。第二种安装构件的方法是手动调用`install:install-file`目标并提供一组参数。假设你有一个JAR文件（*artifact.jar*）和一个匹配的POM文件（*artifact.pom*），安装它们可以这样做：
- en: '[PRE42]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Maven will read the metadata found in the POM file and place the files in their
    corresponding location based on the resolved GAV coordinates. It’s possible to
    override the GAV coordinates, generate the POM on the fly, and even omit the explicit
    POM if the JAR contains a copy inside. (That’s typically the case for JARs built
    with Maven; Gradle, on the other hand, does not include the POM by default.)
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Maven将读取POM文件中的元数据，并根据解析的GAV坐标将文件放置在对应的位置。可以覆盖GAV坐标，动态生成POM，甚至可以省略显式的POM文件（如果JAR文件内部包含一份副本的话，这通常是Maven构建的情况；而Gradle默认情况下不包含POM文件）。
- en: Gradle has one way to publish artifacts to Maven Local, and that is by applying
    the `maven-publish` plug-in. This plug-in adds new capabilities to the project
    such as the `publishToMavenLocal` task; as the name indicates, it will copy the
    built artifacts and a generated POM to Maven Local. Unlike Maven, Gradle does
    not use Maven Local as a cache, as it has its own caching infrastructure. Thus,
    when Gradle resolves dependencies, the files are placed at a different location,
    usually *.gradle/caches/modules-2/files-2.1*, located at the home directory of
    the current user.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle有一种方式可以将构件发布到Maven本地，那就是应用`maven-publish`插件。该插件为项目添加了新的功能，比如`publishToMavenLocal`任务；正如其名称所示，它将构建的构件和生成的POM文件复制到Maven本地。与Maven不同，Gradle不将Maven本地作为缓存，因为它有自己的缓存基础设施。因此，当Gradle解析依赖关系时，文件会被放置在另一个位置，通常位于当前用户的主目录下的`.gradle/caches/modules-2/files-2.1`。
- en: That covers publishing to Maven Local. Now let’s have a look at remote repositories.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这就涵盖了发布到Maven本地的内容。现在让我们看一下远程仓库。
- en: Publishing to Maven Central
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布到Maven中央仓库
- en: 'The *Maven Central* repository is the backbone that allows Java projects to
    be built on a daily basis. The software running Maven Central is *Sonatype Nexus
    Repository*, an artifact repository provided by Sonatype. Given its important
    role in the Java ecosystem, Maven Central has placed a set of rules that must
    be followed when publishing artifacts; Sonatype has published a [guide](https://oreil.ly/xfhNd)
    explaining the prerequisites and rules. I highly recommend reading through the
    guide in case requirements have been updated since the publication of this book.
    In short, you must ensure the following:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '*Maven Central* 仓库是支撑 Java 项目日常构建的支柱。运行 Maven Central 的软件是 *Sonatype Nexus
    Repository*，这是由 Sonatype 提供的一个存储库。由于在 Java 生态系统中的重要角色，Maven Central 已经制定了一系列在发布构件时必须遵循的规则；Sonatype
    已经发布了一份[指南](https://oreil.ly/xfhNd)，详细解释了先决条件和规则。我强烈建议在阅读本书之后阅读该指南，以确保要求是否已自出版之日起更新。简而言之，您必须确保以下几点：'
- en: You must prove ownership of the reverse domain of the target `groupId`. If your
    `groupId` is `com.acme.*`, you must own `acme.com`.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您必须证明拥有目标 `groupId` 的反向域的所有权。如果您的 `groupId` 是 `com.acme.*`，则您必须拥有 `acme.com`。
- en: When publishing a binary JAR, you must also supply `-sources` and `javadoc`
    JARs, as well as a matching POM—that is, a minimum of four separate files.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布二进制 JAR 时，您还必须提供 `-sources` 和 `javadoc` JAR 文件，以及匹配的 POM 文件，即至少四个单独的文件。
- en: When publishing an artifact of type POM, only the POM file is needed.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布 POM 类型的构件时，只需要提供 POM 文件。
- en: PGP signature files for all artifacts must be submitted as well. The PGP keys
    used for signing must be published in public-key servers to let Maven Central
    verify signatures.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有构件的 PGP 签名文件也必须提交。用于签名的 PGP 密钥必须发布在公钥服务器上，以便 Maven Central 验证签名。
- en: 'Perhaps the aspect that trips up most people at the beginning: POM files must
    comply with a minimum set of elements such as `<license>`, `<developers>`, `<scm>`,
    and others. These elements are described in the guide; omitting any of them will
    cause a failure during publication, and as result artifacts won’t be published
    at all.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能在最初会让大多数人困惑的一点是：POM 文件必须符合最少的一组元素，如 `<license>`、`<developers>`、`<scm>` 等。这些元素在指南中有详细描述；如果省略任何一个元素，将导致在发布过程中失败，结果是构件将完全不会发布。
- en: 'We can avoid the last problem or at least detect it much earlier during development
    by using the [PomChecker](https://oreil.ly/E7LP1) project. PomChecker can be invoked
    in many ways: as a standalone CLI tool, as a Maven plug-in, or as a Gradle plug-in.
    This flexibility makes it ideal for verifying a POM at your local environment
    or at a CI/CD pipeline. Verifying a *pom.xml* file using the CLI can be done like
    so:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 [PomChecker](https://oreil.ly/E7LP1) 项目来避免最后一个问题，或者至少在开发过程中更早地检测到它。PomChecker
    可以以多种方式调用：作为独立的 CLI 工具、作为 Maven 插件或作为 Gradle 插件。这种灵活性使其非常适合在本地环境或 CI/CD 流水线中验证
    POM。使用 CLI 验证 *pom.xml* 文件可以这样做：
- en: '[PRE43]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If your project is built with Maven, you may invoke the PomChecker plug-in
    without having to configure it in the POM, like this:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的项目使用 Maven 构建，可以在不需要在 POM 中配置的情况下调用 PomChecker 插件，像这样：
- en: '[PRE44]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: That command will resolve the latest version of `pomchecker-maven-plugin` and
    execute its `check-maven-central` goal right on the spot, using the current project
    as input. With Gradle, you’d have to explicitly configure the `org.kordamp.gradle​.pom⁠checker`
    plug-in as Gradle does not offer an option for invoking an inlined plug-in as
    Maven does.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 那个命令将解析 `pomchecker-maven-plugin` 的最新版本，并立即在现有项目上执行其 `check-maven-central` 目标。使用
    Gradle 时，您必须显式配置 `org.kordamp.gradle.pomchecker` 插件，因为与 Maven 不同，Gradle 不提供调用内联插件的选项。
- en: 'The last bit of configuration that must be applied to the build is the publication
    mechanism itself. Do that by adding the following to your *pom.xml* if you’re
    building with Maven:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 必须应用于构建的最后一部分配置是发布机制本身。如果您使用 Maven 构建，可以通过将以下内容添加到 *pom.xml* 中来完成：
- en: '[PRE45]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Note that this configuration generates `-sources` and `-javadoc` JARs, signs
    all attached artifacts with PGP, and uploads all artifacts to the given URL, which
    happens to be one of the URLs supported by Maven Central. The `<serverId>` element
    identifies the credentials you must have in place in your *settings.xml* file
    (otherwise, the upload will fail), or you may define credentials as command-line
    arguments.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，该配置生成 `-sources` 和 `-javadoc` JAR 文件，用 PGP 签署所有附加的构件，并将所有构件上传到给定的 URL，这恰好是
    Maven Central 支持的 URL 之一。`<serverId>` 元素标识了您必须在 *settings.xml* 文件中设置的凭据（否则上传将失败），或者您可以将凭据定义为命令行参数。
- en: You may want to put the plug-in configuration inside a `<profile>` section,
    as the behavior provided by the configured plug-ins is needed only when a release
    is posted; there’s no reason to generate additional JARs during the execution
    of the main lifecycle phase sequence. This way, your builds will execute only
    the minimum set of steps and thus be faster as a result.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能希望将插件配置放在 `<profile>` 部分中，因为配置的插件提供的行为仅在发布时需要；在执行主要生命周期阶段序列期间生成额外的 JAR 没有必要。这样，您的构建将只执行最小的步骤，从而更快地执行。
- en: On the other hand, if you’re using Gradle for publication, you’d have to configure
    a plug-in that can publish to Sonatype Nexus Repository, the latest of such plug-ins
    being [io.github.gradle-nexus.publish-plugin](https://oreil.ly/MdCNh). There’s
    more than one way to configure Gradle to do the job. Idioms change more rapidly
    than what you must configure in Maven. I recommend you consult the official Gradle
    guides to find out what needs to be done in this case.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果您使用 Gradle 进行发布，您必须配置一个能够发布到 Sonatype Nexus 仓库的插件，最新的此类插件是 [io.github.gradle-nexus.publish-plugin](https://oreil.ly/MdCNh)。有多种配置
    Gradle 完成工作的方式。惯用法变化比您必须在 Maven 中配置的更快。我建议您查阅官方 Gradle 指南，了解在这种情况下需要做什么。
- en: Publishing to Sonatype Nexus Repository
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布到 Sonatype Nexus 仓库
- en: 'You may recall that Maven Central is run using Sonatype Nexus Repository, so
    it should be no surprise that the configuration shown in the previous section
    applies here as well, such that you have to change only the publication URLs to
    match the Nexus repository. There’s one caveat though: the strict verification
    rules applied by Maven Central often do not apply to a custom Nexus installation.
    That is, Nexus has the option to configure the rules that govern artifact publication.
    These rules may be relaxed for a Nexus instance running within your organization,
    for example, or they may be stricter in other areas. It’s a good idea to consult
    the documentation available at your organization regarding artifact publication
    to their own Nexus instance.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还记得 Maven Central 是使用 Sonatype Nexus 仓库运行的，因此不应对前面部分中显示的配置感到意外，因此您只需更改发布
    URL 以匹配 Nexus 仓库。但是有一个警告：Maven Central 经常施加的严格验证规则通常不适用于自定义 Nexus 安装。也就是说，Nexus
    有选项配置管理工件发布的规则。例如，这些规则在您组织内运行的 Nexus 实例中可能会放宽，或者在其他领域可能会更严格。最好查阅您组织的文档，了解有关向其自己的
    Nexus 实例发布工件的信息。
- en: 'One thing is clear: if you are publishing artifacts to your organization’s
    Nexus repository that eventually must be published to Maven Central, it’s a good
    idea to follow the Maven Central rules from the start—as long as these rules do
    not clash with your organization’s.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 有一件事很明确：如果您将工件发布到您组织的 Nexus 仓库，而这些工件最终必须发布到 Maven Central，从一开始遵循 Maven Central
    的规则是个好主意——只要这些规则不与您组织的规则冲突。
- en: Publishing to JFrog Artifactory
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布到 JFrog Artifactory
- en: '*JFrog Artifactory* is another popular option for artifact management. It offers
    similar capabilities as Sonatype Nexus Repository while at the same time adding
    other features, including integration with other products that belong to the JFrog
    Platform, such as Xray and Pipelines. One particular feature I’m quite fond of
    is that artifacts do not need to be signed at the source before publication. Artifactory
    can perform the signing with your PGP keys or with a site-wide PGP key. This relieves
    you of the burden of setting up keys on your local and CI environments as well
    as transferring fewer bytes during publication. As before, the previous publication
    configuration we saw for Maven Central will work for Artifactory as well, by changing
    only the publication URLs to match the Artifactory instance.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '*JFrog Artifactory* 是另一个流行的工件管理选项。它提供与 Sonatype Nexus 仓库类似的功能，同时添加了其他功能，包括与
    JFrog 平台的其他产品集成，例如 Xray 和 Pipelines。我特别喜欢的一个功能是，发布之前不需要在源处对工件进行签名。Artifactory
    可以使用您的 PGP 密钥或站点范围的 PGP 密钥执行签名。这使您无需在本地和 CI 环境上设置密钥，也减少了发布过程中的字节数传输。与之前一样，我们在
    Maven Central 中看到的发布配置也适用于 Artifactory，只需更改发布 URL 以匹配 Artifactory 实例。'
- en: As with Nexus, Artifactory allows you to sync artifacts to Maven Central, and
    you have to follow the rules for publishing to Maven Central once again. Thus
    publishing well-formed POMs, sources, and Javadoc JARs from the get-go is a good
    idea.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Nexus 类似，Artifactory 允许您将工件同步到 Maven Central，并且您必须再次遵循发布到 Maven Central 的规则。因此，从一开始就发布格式良好的
    POM、源代码和 Javadoc JAR 是个好主意。
- en: Summary
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We’ve covered plenty of concepts in this chapter, but the main takeaway should
    be that artifacts on their own are not enough to get the best results when building
    software or to get ahead of the competition. Artifacts usually have metadata that
    can be associated with them such as their build time, dependency versions, and
    environment. This metadata may be used to trace the origins of a particular artifact,
    help turn it into a reproducible artifact, or enable the generation of a software
    bill of materials (SBOM), which happens to be yet another metadata format. Moreover,
    observability, monitoring, and other concerns regarding the health and stability
    of the build pipeline can be greatly enhanced by the existence of this metadata.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了许多概念，但主要的要点是，单靠工件本身是不足以在构建软件或领先竞争中取得最佳结果的。工件通常具有与之关联的元数据，例如它们的构建时间、依赖版本和环境。这些元数据可以用于追溯特定工件的起源，帮助将其转变为可重现的工件，或者启用生成软件材料清单（SBOM），这又是另一种元数据格式。此外，通过这些元数据，还可以极大地增强构建管道健康和稳定性方面的可观察性、监控以及其他关注点。
- en: Specific to dependencies, we saw the basics of dependency resolution with popular
    Java build tools such as Apache Maven and Gradle. Of course, more depth than was
    discussed in this chapter is warranted; these topics could certainly fill a book
    on their own. Be sure to be on the lookout for improvements in this area as provided
    by later versions of these build tools.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 关于依赖性，我们看到了与流行的Java构建工具（如Apache Maven和Gradle）一起进行依赖性解析的基础知识。当然，这一章节讨论的深度还远不够；这些主题确实可以单独填满一本书。请务必关注这一领域的改进，这些改进可能会由后续版本的这些构建工具提供。
- en: Finally, we covered how to publish Java artifacts to the popular Maven Central
    repository, given that it requires adhering to a particular set of guidelines
    that must be followed for successful publication. Maven Central is the canonical
    repository, but it’s not the only one. Sonatype offers Sonatype Nexus Repository,
    and JFrog offers JFrog Artifactory, also quite popular choices to manage artifacts
    at internal locations such as your own organization or company.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了如何将Java工件发布到流行的Maven中央仓库，这要求遵循一组特定的准则以确保成功发布。Maven中央仓库是官方仓库，但并非唯一选择。Sonatype提供Sonatype
    Nexus仓库，而JFrog提供JFrog Artifactory，这两者也是管理内部位置（例如您自己的组织或公司）的工件的流行选择。
