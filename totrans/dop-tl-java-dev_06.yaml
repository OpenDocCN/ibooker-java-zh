- en: Chapter 6\. Package Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ixchel Ruiz
  prefs: []
  type: TYPE_NORMAL
- en: Somewhere in the world, as you read this sentence, a line of code is being written.
    This line of code will ultimately become part of an artifact that will become
    a building block used internally by an organization in one or more enterprise
    products, or shared via a public repository, most notably Maven Central for Java
    and Kotlin libraries.
  prefs: []
  type: TYPE_NORMAL
- en: More libraries, binaries, and artifacts are available today than ever before,
    and this collection will continue to grow as developers around the world continue
    their next generation of products and services. Handling and managing these artifacts
    require more effort now than before—with an ever-increasing number of dependencies
    creating a complicated web of connectedness. Using an incorrect version of an
    artifact is an easy trap to fall into, causing confusion and broken builds, and
    ultimately thwarting carefully planned project release dates.
  prefs: []
  type: TYPE_NORMAL
- en: It’s more important than ever for developers to understand not only the function
    and the idiosyncrasies of the source code directly in front of them, but also
    how their projects are packaged and how the building blocks are assembled into
    the final product. Having a deep understanding of the build process itself and
    how our automated build tools function under the hood is crucial to avert delays
    and hours of unnecessary troubleshooting—not to mention prevent a large category
    of bugs escaping into production.
  prefs: []
  type: TYPE_NORMAL
- en: Access to troves of third-party resources that provide solutions to common coding
    problems can help speed the development of our projects but introduces the risk
    of errant or unexpected behavior. Understanding how these components are brought
    into projects as well as where they come from will help in troubleshooting efforts.
    Ensuring that we are responsible managers of the artifacts we produce internally
    will allow us to improve our decision-making and prioritization when it comes
    to bug fixes and feature development as well as help pave the way to release to
    production. A developer can no longer be versed in only the semantics of the code
    in front of them, but also the complexities of package management.
  prefs: []
  type: TYPE_NORMAL
- en: Why Build-It-and-Ship-It Is Not Enough
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Not so long ago, software developers viewed building an artifact as a culmination
    of hard, sometimes epic, efforts. Meeting deadlines sometimes meant using shortcuts
    and poorly documented steps. Since then, the requirements of the industry have
    changed to bring faster delivery cycles, diverse environments, tailored artifacts,
    exploding codebases and repositories, and multimodule packages. Today building
    an artifact is just one step of a bigger business cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Successful leaders recognize that the best innovations emerge out of trial and
    error. That’s why they’ve made testing, experimentation, and failure an integral
    part of their lives and their company’s process.
  prefs: []
  type: TYPE_NORMAL
- en: One way to innovate, scale more quickly, launch more products, improve the quality
    or user experience of applications or products, and roll out new features is through
    A/B testing. What is A/B testing? According to Kaiser Fung, who founded the applied
    analytics program at Columbia University, *A/B testing* at its most basic is a
    century-old method used to compare two versions of something to figure out which
    performs better. Today several startups, well-established companies like Microsoft,
    and several other leading companies—including Amazon, Booking.com, Facebook, and
    Google—have been [conducting](https://oreil.ly/vRKPP) more than 10,000 online
    controlled experiments annually.
  prefs: []
  type: TYPE_NORMAL
- en: Booking.com conducts comparative testing on every new feature on its website,
    comparing details from the selection of photos and content to button color and
    placement. By testing several versions against one another and tracking customer
    response, the company is able to constantly improve the user experience.
  prefs: []
  type: TYPE_NORMAL
- en: How do we deliver and deploy multiple versions of software composed of numerous
    artifacts? How do we find bottlenecks? How do we know we are moving in the right
    direction? How do we keep track of what is working well or what is working against
    us? How do we maintain a reproducible outcome but with enriched lineages? Answers
    to these questions can be found by capturing and analyzing relevant, contextual,
    clear, and specific information regarding the workflows and artifacts’ inputs,
    outputs, and states. All of this is possible thanks to metadata.
  prefs: []
  type: TYPE_NORMAL
- en: It’s All About Metadata
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As W. Edwards Deming said, “In God we trust; all others bring data.” *Metadata*
    is defined as a structured key/value storage of relevant information. In other
    words, it’s a collection of properties or attributes applicable to a particular
    entity, which in our case applies to artifacts and processes.
  prefs: []
  type: TYPE_NORMAL
- en: Metadata enables the discovery of correlations and causations as well as insights
    into the organization’s behavior and outcomes. As a result, metadata can show
    whether the organization is tuned in to its stakeholders’ goals.
  prefs: []
  type: TYPE_NORMAL
- en: Additional data can be used in later stages to extract or derive more information.
    This data helps expand perspectives and create more stories, or narratives. It’s
    important to choose which attributes, cardinality, and values to add—too many,
    and we harm performance; too few, and we miss information. With too many values,
    insights can be lost.
  prefs: []
  type: TYPE_NORMAL
- en: 'A good starting point is to answer the following questions concerning the main
    stages of each phase of the software development cycle: Who? What? How? Where?
    and When? Asking the right questions is only half of the effort, though. Having
    clear, relevant, specific, and clear answers that can be normalized or enumerated
    is always a good practice.'
  prefs: []
  type: TYPE_NORMAL
- en: Key Attributes of Insightful Metadata
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Insightful data should be all of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Contextualized
  prefs: []
  type: TYPE_NORMAL
- en: All data needs to be interpreted within a frame of reference. To extract and
    compare possible scenarios, it is important to have the right stage for analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Relevant
  prefs: []
  type: TYPE_NORMAL
- en: The variability in the values has an impact on the outcome or describes a specific
    stage or time in the outcome or process.
  prefs: []
  type: TYPE_NORMAL
- en: Specific
  prefs: []
  type: TYPE_NORMAL
- en: The values describe a clear event (i.e., initial value, end value).
  prefs: []
  type: TYPE_NORMAL
- en: Clear
  prefs: []
  type: TYPE_NORMAL
- en: The possible values are well-known or defined, computable, and comparable.
  prefs: []
  type: TYPE_NORMAL
- en: Unique
  prefs: []
  type: TYPE_NORMAL
- en: Has a single, distinctive value.
  prefs: []
  type: TYPE_NORMAL
- en: Extensible
  prefs: []
  type: TYPE_NORMAL
- en: Because the wealth of human knowledge is ever increasing, the data needs to
    define mechanisms so that standards can be evolved and extended to accommodate
    new properties.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have defined what, when, why, and how to record the stages, inputs,
    outputs, and states of the software development cycle, you also need to keep in
    mind the consumers of subsets of the metadata. On one hand, you may have an intermediate
    private consumer who will consume and react in different ways to the set of values—from
    triggering sub pipelines, promoting builds, deploying in different environments,
    or publishing artifacts. On the other hand, you may have final external consumers
    who will be able to extract information and with skill and experience turn it
    into insights that will help fulfill the overall goals of the organization.
  prefs: []
  type: TYPE_NORMAL
- en: Metadata Considerations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are important considerations about metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: Privacy and security
  prefs: []
  type: TYPE_NORMAL
- en: Think twice about exposing values.
  prefs: []
  type: TYPE_NORMAL
- en: Visibility
  prefs: []
  type: TYPE_NORMAL
- en: Not all consumers are interested in all data.
  prefs: []
  type: TYPE_NORMAL
- en: Format and encoding
  prefs: []
  type: TYPE_NORMAL
- en: One specific property may be exposed during different stages in different formats,
    but consistency is needed in the naming, meaning, and possibly the general value.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s turn our attention to generating and packaging metadata with build tools.
    The Java ecosystem has no shortage of options when it comes to build tools. Arguably,
    the most popular are Apache Maven and Gradle; hence it makes sense to discuss
    them in depth. However, should your build depend on a different build tool, the
    information presented in this section will likely still prove to be useful, as
    some of the techniques to gather and package metadata may be reused.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, before we jump into practical code snippets, we have to figure out three
    action items:'
  prefs: []
  type: TYPE_NORMAL
- en: Determine the metadata that should be packaged with an artifact.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find out how that metadata can be obtained during the build.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Process the metadata and record it in the appropriate format or formats.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The following subsections cover each of these aspects.
  prefs: []
  type: TYPE_NORMAL
- en: Determining the Metadata
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The build environment has no shortage of information that can be converted into
    metadata and packaged alongside an artifact. A good example is the build timestamp
    that identifies the time and date when the build produced the artifact. Many timestamp
    formats can be followed, but I recommend using [ISO 8601](https://oreil.ly/PsZkB),
    whose formatted representation using `java.text.SimpleDateformat` is `yyyy-MM-dd'T'HH:mm:ssXXX`—useful
    when the captured timestamp relies on `java.util.Date`. Alternatively, the `java.time.format.DateTimeFormatter.ISO_OFFSET_DATE_TIME`
    may be used if the captured timestamp relies on `java.time.Local​Da⁠teTime`. The
    build’s OS details may also be of interest, as well as JDK information such as
    version, ID, and vendor. Luckily for us, these bits of information are captured
    by the JVM and exposed via [`System`](https://oreil.ly/CKMsE) properties.
  prefs: []
  type: TYPE_NORMAL
- en: Consider including the artifact’s ID and version as well (even though these
    values are usually encoded in the artifact’s filename) as a precaution in case
    the artifact were to be renamed at some point. SCM information is also crucial.
    Useful information from source control includes the commit hash, tag, and branch
    name. Additionally, you may want to capture specific build information such as
    the user who runs the build; the build tool’s name, ID, and version; and the hostname
    and IP address of the build machine. These key/value pairs are likely the most
    significant and commonly found metadata. However, you may select additional key/value
    pairs required by other tools and systems that will consume the produced artifacts.
  prefs: []
  type: TYPE_NORMAL
- en: Caution
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: I can’t stress enough how important it is to check your team’s and organization’s
    policies regarding access and visibility of sensitive data. Some of the key/value
    pairs mentioned before may be deemed a security risk if exposed to third parties
    or external consumers, though they may be of high importance to internal consumers.
  prefs: []
  type: TYPE_NORMAL
- en: Capturing Metadata
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We must find a way to gather the metadata with our build tool of choice after
    we have determined which metadata we need to capture. Some of the key/value pairs
    can be obtained directly from the environment, system settings, and command flags
    exposed by the JVM as environment variables or `System` properties. Additional
    properties may be exposed by the build tool itself, whether they are defined as
    additional command-line arguments or as configuration elements in the tool’s configuration
    settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume for the moment that we need to capture the following key/value
    pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: JDK information such as version and vendor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OS information such as name, arch, and version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The build timestamp
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The current commit hash from SCM (assuming Git)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These values may be captured with Maven by using a combination of `System` properties
    for the first two items and a third-party plug-in for the last two. Both Maven
    and Gradle have no shortage of options when it comes to plug-ins that offer integration
    with Git; however, I recommend choosing [git-commit-id-maven-plugin](https://oreil.ly/EwiLP)
    for Maven and [versioning](https://oreil.ly/qjEOi) for Gradle, as these plug-ins
    are the most versatile so far.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, Maven allows defining properties in a handful of ways, most commonly as
    key/value pairs inside the `<properties>` section found in the *pom.xml* build
    file. The value for each key is free text, although you can refer to `System`
    properties by using a shorthand notation or to environment variables by using
    a naming convention. Say you want to access the value for the `java.version` key
    found in `System` properties. This can be done by using the `${}` shorthand notation
    such as `${java.version}`. Conversely, for an environment variable, you may use
    the `${env.*NAME*}` notation. For example, the value of an environment variable
    named `TOKEN` can be accessed using the expression `${env.TOKEN}` in the *pom.xml*
    build file. Putting together the `git-commit-id` plug-in and build properties
    may result in a *pom.xml* similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note that the values for `build.jdk` and `build.os` already include formatting
    as they are composites of simpler values, whereas the `build.revision` and `build.timestamp`
    values come from the properties defined by the Git plug-in. We have yet to determine
    the final format and file or files that will contain the metadata, which is why
    we see it defined in the `<properties>` section. This setup allows these values
    to be reused and consumed by other plug-ins should they need it. Another reason
    to prefer this setup is that external tools (such as those found in a build pipeline)
    may read these values more easily as they are located at a specific section instead
    of at many places within the build file.
  prefs: []
  type: TYPE_NORMAL
- en: Also note the chosen value of version, `1.0.0-SNAPSHOT`. You may use any character
    combination for the version as you deem necessary. However, it’s customary to
    at least use an alphanumeric sequence that defines two numbers in the `*major*`.`*minor*`
    format. A handful of versioning conventions are out there, with both advantages
    and drawbacks. This being said, the use of the `-SNAPSHOT` tag has a special meaning
    as it indicates the artifact is not yet ready for production. Some tools will
    behave differently when a snapshot version is detected; for example, they can
    prevent an artifact from ever being published to a production environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast to Maven, Gradle has no shortage of options when it comes to defining
    and writing build files. To begin with, since Gradle 4, you have two choices for
    the build file format: Apache Groovy DSL or Kotlin DSL. Regardless of which one
    you pick, you will soon find that there are more options to capture and format
    metadata. Some of them may be idiomatic, some may require additional plug-ins,
    and some may even be considered outdated or obsolete. To keep this example short
    and basic, we’ll go with Groovy and small idiomatic expressions. We’ll capture
    the same metadata similarly as we did for Maven, with the first two values coming
    from `System` properties and the commit hash provided by the `versioning` Git
    plug-in, but the build timestamp will be calculated on the spot by using custom
    code. The following snippet shows how this can be done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: These computed values will be available as dynamic project properties that may
    be consumed later in the build by additional configured elements such as extensions,
    tasks, closures (for Groovy), actions (for Groovy and Kotlin), and other elements
    exposed by the DSL. All that is left now is recording the metadata in a given
    format.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the Metadata
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You might need to record metadata in more than one format or file. The choice
    of format depends on the intended consumers. Some consumers require a unique format
    that no other consumer can read, whereas others may understand a variety of formats.
    Be sure to consult the documentation of a given consumer on its supported formats
    and options and also check whether integration with your build tool of choice
    is provided. You might discover that a plug-in for your build is available that
    eases the recording process of the metadata that you need. For demonstration purposes,
    we’ll record the metadata by using two popular formats: a Java properties file
    and the JAR’s manifest.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can leverage Maven’s [resource filtering](https://oreil.ly/X1x0q), which
    is baked into the [resources plug-in](https://oreil.ly/YqOSO), part of the core
    set of plug-ins that every build has access to. For this to work, we must add
    the following snippet to the previous *pom.xml* file, inside the `<build>` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'A companion properties file located at *src/main/resources* is also required.
    I’ve chosen *META-INF/metadata.properties* as the relative path and name of the
    properties file to be found inside the artifact JAR. Of course, you may choose
    a different naming convention as needed. This file relies on variable placeholder
    substitutions, variables that will be resolved from project properties such as
    those we set in the `<properties>` section. By convention, little configuration
    information is needed in the build file. The properties file looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Recording the metadata in the JAR’s manifest requires tweaking the configuration
    of the `jar-maven-plugin` applicable to a build file. The following snippet must
    be included inside the `<plugins>` section found in the `<build>` section. In
    other words, it’s a sibling of the `git-commit-id` plug-in we saw earlier in this
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that a specific plug-in version is defined even though this plug-in is
    part of the core plug-in set. The reason behind this is that it’s imperative to
    declare all plug-in versions for the sake of reproducible builds. Otherwise, you
    will find builds may differ as different plug-in versions may be resolved depending
    on the specific version of Maven used to run the build. Each entry in the manifest
    is composed of a capitalized key and the captured value. Running the build with
    `mvn package` resolves the captured properties, copies the metadata properties
    file with resolved values into the *target/classes* directory where it will be
    added to the final JAR, and injects the metadata into the JAR’s manifest. We can
    verify this by inspecting the contents of the generated artifact:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The two files are found inside the JAR file as expected. Extracting the JAR
    and looking at the contents of the properties file and the JAR manifest yield
    the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ve seen how to collect metadata with Maven. Let’s see the same method of
    recording metadata by using a properties file and a JAR manifest with a different
    build tool: Gradle. For the first part, we’ll configure the standard `processResources`
    task that’s provided by the `java-library` plug-in we applied to the build. The
    additional configuration can be appended to the previously shown Gradle build
    file, and it looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the names of the keys use `_` as a token separator, because of the
    default resource filtering mechanism appleid by Gradle. If we were to use `.`
    as we saw earlier with Maven, Gradle would expect to find a `build` object with
    matching `jdk`, `os`, `revision`, and `timestamp` properties during resource filtering.
    That object does not exist, which will cause the build to fail. Changing the token
    separator avoids that problem but also forces us to change the contents of the
    properties file to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Configuring the JAR manifest is a straightforward operation given that the
    `jar` task offers an entry point for this behavior, as shown by the following
    snippet that can also be appended to the existing Gradle build file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As seen before, each manifest entry uses a capitalized key and its corresponding
    captured value. Running the build with `gradle jar` should produce results similar
    to those provided by Maven: the properties file will be copied to a target location
    where it can be included in the final JAR, with its value placeholders substituted
    for the actual metadata values, and the JAR manifest will be enriched with metadata
    as well. Inspecting the JAR shows that it contains the expected files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Unpacking the JAR and looking inside each file yields the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Perfect! That is all that there is to it. Let me encourage you to add or remove
    key/value pairs as needed as well as configure other plug-ins (for both Maven
    and Gradle) that may expose additional metadata or provide other means to process
    and record metadata into particular formats.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency Management Basics for Maven and Gradle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Dependency management has been a staple of Java projects since Maven *1.x*
    came to light in 2002\. The gist behind this feature is to declare artifacts that
    are required for compiling, testing, and consuming a particular project, relying
    on additional metadata attached to an artifact such as its group identifier, artifact
    identifier, version, and sometimes a classifier as well. This metadata is typically
    exposed using a well-known file format: the [Apache Maven POM](https://oreil.ly/1Kzp6)
    expressed in a *pom.xml* file. Other build tools are capable of understanding
    this format, and can even produce and publish *pom.xml* files despite using a
    totally unrelated format for declaring build aspects, as is the case for Gradle
    with `build.gradle` (Groovy) or `build.gradle.kts` (Kotlin) build file.'
  prefs: []
  type: TYPE_NORMAL
- en: Despite being a core feature provided by Maven since the early days, and also
    a core feature in Gradle, dependency management and dependency resolution remain
    a stumbling block for many. Even though the rules to declare dependencies are
    not complicated, you may find yourself at the mercy of published metadata with
    invalid, misleading, or missing constraints. The following subsections are a primer
    for dependency management using both Maven and Gradle, but it is by no means an
    exhaustive explanation—that would take a whole book on just this topic.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, tread carefully, dear reader, there be dragons ahead. I’ll do
    my best to point out the safest paths. We’ll begin with Maven, as it is the build
    tool that defines the artifact metadata using the *pom.xml* file format.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency Management with Apache Maven
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You likely have encountered a POM file before—after all, it’s ubiquitous. A
    POM file with model version 4.0.0 is responsible for defining the way artifacts
    are produced and consumed. In Maven version 4, these two capabilities are split,
    although the model version remains the same for compatibility reasons. It’s expected
    that the model format will change when Maven version 5.0.0 is introduced. although
    there are no details on how this model will look at the time of writing. One thing
    is sure: the Maven developers are keen on keeping backward compatibility. Let’s
    walk through the basics.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dependencies are identified by three required elements: `groupId`, `artifactId`,
    and `version`. These elements are collectively known as *Maven coordinates*, or
    *GAV coordinates*, where GAV, as you may have guessed, stands for `groupId`, `artifactId`,
    `version`. From time to time, you may find dependencies that define a fourth element
    named `classifier`.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s break them down one by one. Both `artifactId` and `version` are straightforward;
    the former defines the “name” of the artifact, and the latter defines a version
    number. Many different versions may be associated with the same `artifactId`.
    The `groupId` is used to put together a set of artifacts that have some sort of
    relationship—that is, all of them belong to the same project or provide behavior
    that’s germane to one another. The `classifier` adds another dimension to the
    artifact, albeit optional. Classifiers are often used to differentiate artifacts
    that are specific to a particular setting such as the operating system or the
    Java release. Examples of operating system classifiers are found in the JavaFX
    binaries, such as *javafx-controls-15-win.jar*, *javafx-controls-15-mac.jar*,
    and *javafx-controls-15-linux.jar*, which identify version 15 of the JavaFX control
    binaries that may be used with Windows, macOS, and Linux platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Another set of common classifiers are `sources` and `javadoc`, which identify
    JAR files that contain sources and generated documentation (via the Javadoc tool).
    The combination of GAV coordinates must be unique; otherwise, the dependency resolution
    mechanism will have a hard time finding out correct dependencies to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'POM files let you define dependencies inside the `<dependencies>` section,
    where you would list GAV coordinates for each dependency. In its simplest form,
    it looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Dependencies listed in this way are known as *direct dependencies*, as they
    are explicitly declared in the POM file. This classification holds true even for
    dependencies that may be declared in a POM that’s marked as a parent of the current
    POM. What’s a parent POM? It’s just like another *pom.xml* file except that your
    POM marks it with a parent/child relationship by using the `<parent>` section.
    In this way, configuration defined by the parent POM can be inherited by the child
    POM. We can inspect the dependency graph by invoking the `mvn dependency:tree`
    command, which resolves the dependency graph and prints it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we can see that the current POM (identified by its GAV coordinates as
    `com.acme:example:1.0.0-SNAPSHOT`) has a single direct dependency. Two additional
    elements are found in the output of the `commons-collections4` dependency: the
    first is `jar`, which identifies the type of the artifact, and the second is `compile`,
    which identifies the scope of the dependency. We’ll come back to scopes in a moment,
    but suffice to say that if no explicit `<scope>` element is defined for a dependency,
    its default scope becomes `compile`. Now, when a POM that contains direct dependencies
    is consumed, it brings along those dependencies as transitive from the point of
    view of the consuming POM. The next example shows that particular setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Resolving and printing out the dependency graph using the same command as before
    yields this result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This tells us that the `commons-beanutils` artifact has two dependencies set
    in the ​ `com⁠pile` scope, which from the point of view of the `com.acme:example:1.0.0-SNAPSHOT`
    happen to be seen as transitive. These two transitive dependencies appear to have
    no direct dependencies of their own, as there’s nothing listed for either of them.
    However, if you were to look at the `commons-logging` POM file, you’ll find the
    following dependency declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there are actually five dependencies! However, four of them
    define an additional `<optional>` element, while two define a different value
    for `<scope>`. Dependencies marked as `<optional>` may be required for compiling
    and testing the producer (`commons-logging` in this case) but not necessarily
    for consumers; this is determined on a case-by-case basis.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s time to discuss scopes now that we see them once again. *Scopes* determine
    whether a dependency is to be included in the classpath, as well as limit its
    transitivity. Maven defines six scopes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`compile`'
  prefs: []
  type: TYPE_NORMAL
- en: The default scope, used if none is specified, as we saw earlier. Dependencies
    in this scope will be used for all classpaths in the project (compile, runtime,
    test) and will be propagated to consuming projects.
  prefs: []
  type: TYPE_NORMAL
- en: '`provided`'
  prefs: []
  type: TYPE_NORMAL
- en: Like `compile`, except that it does not affect the runtime classpath nor is
    it transitive. Dependencies set in this scope are expected to be provided by the
    hosting environment, as is the case for web applications packaged as WARs and
    launched from within an application server.
  prefs: []
  type: TYPE_NORMAL
- en: '`runtime`'
  prefs: []
  type: TYPE_NORMAL
- en: This scope indicates the dependency is not required for compilation but for
    execution. Both the runtime and test classpaths include dependencies set in this
    scope, while the compile classpath is ignored.
  prefs: []
  type: TYPE_NORMAL
- en: '`test`'
  prefs: []
  type: TYPE_NORMAL
- en: Defines dependencies required for compiling and running tests. This scope is
    not transitive.
  prefs: []
  type: TYPE_NORMAL
- en: '`system`'
  prefs: []
  type: TYPE_NORMAL
- en: Similar to `provided` except that dependencies must be listed with an explicit
    path, relative or absolute. Therefore, this scope is seen as a bad practice and
    should be avoided at all costs. For a handful of use cases, it may come in handy,
    but you must bear the consequences. At best, it’s an option left to the experts—in
    other words, imagine that this scope does not exist at all.
  prefs: []
  type: TYPE_NORMAL
- en: '`import`'
  prefs: []
  type: TYPE_NORMAL
- en: Applies only to dependencies of type `pom` (the default is `jar` if not specified)
    and can be used only for dependencies declared inside the `<dependencyManagement>`
    section. Dependencies in this scope are replaced by the list of dependencies found
    in their own `<dependencyManagement>` section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `<dependencyManagement>` section has three purposes: to provide version
    hints for transitive dependencies, to provide a list of dependencies that may
    be imported using the `import` scope, and to provide a set of defaults when used
    in a parent-child POM combination. Let’s look at the first purpose. Say you have
    the following dependencies defined in your POM file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Both the `guice` and `truth` artifacts define `guava` as a direct dependency.
    This means `guava` is seen as a transitive dependency from the consumer’s point
    of view. We get the following result if we resolve and print out the dependency
    graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The resolved version of `guava` turns out to be `25.1-android` because that’s
    the version found first in the graph. Look what happens if we invert the order
    of the dependencies and list `truth` before `guice` and resolve the graph once
    again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now the resolved version of `guava` happens to be `27.0.1-android` because it’s
    the one found first in the graph. This particular behavior is a constant source
    of head-scratching moments and frustration. As developers, we are used to versioning
    conventions, most notably [semantic versioning](https://semver.org) when it applies
    to dependency versions.
  prefs: []
  type: TYPE_NORMAL
- en: Semantic versioning tells us that version tokens (separated by dots) have specific
    meaning based on their position. The first token identifies the major release,
    the second token identifies the minor release, and the third token identifies
    the build/patch/fix/revision release. It’s also customary that version `27.0.1`
    is seen as more recent than `25.1.0` because the major number `27` is greater
    than `25`. In our case, we have two versions for `guava` in the graph, `27.0.1-android`
    and `25.1-android`, and both are found at the same distance from the current POM—that
    is, just one level down in the transitive graph.
  prefs: []
  type: TYPE_NORMAL
- en: It’s easy to assume that because we, as developers, are aware of semantic versioning
    and can clearly determine which version is more recent, so can Maven—and that
    is where assumption clashes with reality! Maven never looks at the version, but
    looks only at the location within the graph. This is why we get different results
    if we change the order of dependencies. We can use the `<dependencyManagement>`
    section to fix this issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dependencies defined in the `<dependencyManagement>` section usually have the
    three main GAV coordinates. When Maven resolves dependencies, it will look at
    the definitions found in this section to see whether there’s a match for `groupId`
    and `artifactId`, in which case the associated `version` will be used. It does
    not matter how deep in the graph a dependency may be, or how many times it may
    be found in the graph. If there’s a match, that explicit version will be the chosen
    one. We can verify this claim by adding a `<dependencyManagement>` section to
    the consumer POM that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the declaration for `guava` uses the `com.google.guava:guava:29.0-jre`
    coordinates, meaning that version `29.0-jre` will be used if a transitive dependency
    happens to match the given `groupId` and `artifactId`. We know this will happen
    in our consumer POM, twice to be exact. We get the following result when resolving
    and printing out the dependency graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note that the chosen version for `guava` is indeed `29.0-jre` and not the previous
    versions we saw earlier in this chapter, confirming that the `<dependencyManagement>`
    section is performing its job as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second purpose of `<dependencyManagement>`, listing dependencies that may
    be imported, is accomplished by using the `import` scope alongside dependencies
    of type `pom`. These types of dependencies usually define `<dependencyManagement>`
    sections of their own, although nothing stops these POMs from adding more sections.
    POM dependencies that define a `<dependencyManagement>` section and no `<dependencies>`
    section are known as bill of materials (BOM). Typically, BOM dependencies define
    a set of artifacts that belong together for a particular purpose. Although not
    explicitly defined in the Maven documentation, you can find two kinds of BOM dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: Library
  prefs: []
  type: TYPE_NORMAL
- en: All declared dependencies belong to the same project even though they might
    have different group IDs, and possibly even different versions. An example can
    be seen at [helidon-bom](https://oreil.ly/bcMHI), which groups all artifacts from
    the Helidon project.
  prefs: []
  type: TYPE_NORMAL
- en: Stack
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies are grouped by behavior and the synergy they bring. Dependencies
    may belong to disparate projects. See an example at [helidon-dependencies](https://oreil.ly/wgmVx),
    which groups the previous `helidon-bom` with other dependencies such as Netty,
    logging, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take the `helidon-dependencies` as a source of dependencies. Inspecting
    this POM, we find dozens of dependencies declared inside its `<dependencyManagement>`
    section, only a few of which are seen in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Consuming this BOM dependency in our own POM requires the use of the `<dependencyManagement>`
    section once again. We’ll also define an explicit dependency for `netty-handler`
    as we have done before when defining dependencies, except that this time we’ll
    omit the `<version>` element. The POM ends up looking like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how the `helidon-dependencies` dependency was imported. A key element
    must be defined, `<type>`, which must be set as `pom`. Remember from earlier in
    this chapter that dependencies will have type `jar` by default if no value is
    specified? Here we know that `helidon-dependencies` is a BOM; thus it does not
    have a JAR file associated with it. If we leave out the type element, Maven will
    complain with a warning and will fail to resolve the version of `netty-handler`,
    so be sure not to miss setting this element correctly. Resolving the dependency
    graph yields the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the correct version was chosen and that every direct dependency
    of `netty-handler` is resolved as transitive as well.
  prefs: []
  type: TYPE_NORMAL
- en: The third and final purpose of the `<dependencyManagement>` section comes into
    play when a parent-child relationship exists between POMs. The POM format defines
    a `<parent>` section that any POM can use to establish a link with another POM
    seen as a parent. Parent POMs provide configuration that can be inherited by child
    POMs, the parent `<dependencyManagement>` section being one of them. Maven follows
    the parent link upward until it can no longer find a parent definition, then processes
    down the chain resolving configuration, with the POMs located at lower levels
    overriding configuration set by those POMs in higher levels.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means a child POM always has the option to override configuration declared
    by a parent POM. Thus, a `<dependencyManagement>` section found in the parent
    POM will be visible to the child POM, as if it were defined on the child. We still
    get the same benefits from the two previous purposes of this section, which means
    we can fix versions for transitive dependencies and import BOM dependencies. The
    following is an example of a parent POM that declares `helidon-dependencies` and
    `commons-lang3` in its own `<dependencyManagement>` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Given that no JAR file is associated with this POM file, we also must explicitly
    define the value for the `<packaging>` element as `pom`. The child POM requires
    the use of the `<parent>` element to refer to this POM, shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Perfect! With this setup ready, it’s time to once again resolve the dependency
    graph and inspect its contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We have two direct dependencies as expected, with the correct GAV coordinates,
    as well as the transitive dependencies as seen earlier. A few additional items
    are related to dependency management and resolution, such as dependency exclusions
    (eject a transitive dependency by its GA coordinates) and failing the build on
    dependency conflicts (different versions of the same GA coordinates found in the
    graph). However, it’s best to stop here and have a look at what Gradle offers
    in terms of dependency management.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency Management with Gradle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned earlier, Gradle builds on top of the lessons learned from Maven
    and understands the POM format, allowing it to provide dependency resolution capabilities
    similar to Maven. Gradle also offers additional capabilities and finer-grained
    control. This section refers to topics already covered, so I recommend you read
    the preceding section first in the event you skipped it, or if you need a refresher
    on dependency management as provided by Maven. Let’s have a look at what Gradle
    offers.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you must select the DSL for writing the build file. Your options are
    the Apache Groovy DSL or the Kotlin DSL. We’ll continue with the former, as Groovy
    has more examples found in the wild. It’s also easier to move from Groovy to Kotlin
    than vice versa, meaning that snippets written with Groovy can be used verbatim
    with Kotlin (with perhaps a few changes suggested by the IDE), whereas moving
    in the other direction requires knowledge of both DSLs. The next step is picking
    the format for recording dependencies, for which there are quite a few; the most
    common formats are a single literal with GAV coordinates, such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'and the Map literal that splits each member of the GAV coordinates into its
    own element, such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Note that Gradle chose to go with `group` instead of `groupId`, and `name` instead
    of `artifactId`, though the semantics are the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next order of business is declaring dependencies for a particular scope
    (in Maven’s terms), though Gradle calls this *configuration*, and the behavior
    goes beyond what scopes are capable of. Assuming the `java-library` plug-in is
    applied to a Gradle build file, we gain access to the following configurations
    by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '`api`'
  prefs: []
  type: TYPE_NORMAL
- en: Defines dependencies required for compiling production code and affects the
    compile classpath. It is equivalent to the `compile` scope and thus is mapped
    as such when a POM is generated.
  prefs: []
  type: TYPE_NORMAL
- en: '`implementation`'
  prefs: []
  type: TYPE_NORMAL
- en: Defines dependencies required for compilation but deemed as implementation details;
    they are more flexible than dependencies found in the `api` configuration. This
    configuration affects the compile classpath but will be mapped to the `runtime`
    scope when a POM is generated.
  prefs: []
  type: TYPE_NORMAL
- en: '`compileOnly`'
  prefs: []
  type: TYPE_NORMAL
- en: Defines dependencies required for compilation but not for execution. This configuration
    affects the compile classpath, but these dependencies are not shared with other
    classpaths. Also, they are not mapped to the generated POM.
  prefs: []
  type: TYPE_NORMAL
- en: '`runtimeOnly`'
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies in this configuration are needed for execution only and affect
    only the runtime classpath. They are mapped to the `runtime` scope when a POM
    is generated.
  prefs: []
  type: TYPE_NORMAL
- en: '`testImplementation`'
  prefs: []
  type: TYPE_NORMAL
- en: Defines dependencies required for compiling test code and affects the `testCompile`
    classpath. They are mapped to the `test` scope when a POM is generated.
  prefs: []
  type: TYPE_NORMAL
- en: '`testCompileOnly`'
  prefs: []
  type: TYPE_NORMAL
- en: Defines dependencies required for compiling test code but not for execution.
    This configuration affects the `testCompile` classpath, but these dependencies
    are not shared with the testRuntime classpath. Also, they are not mapped to the
    generated POM.
  prefs: []
  type: TYPE_NORMAL
- en: '`testRuntimeOnly`'
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies with this configuration are needed for executing test code and
    affect only the `testRuntime` classpath. They are mapped to the `test` scope when
    a POM is generated.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may see additional configurations depending on the Gradle version in use,
    including the following legacy ones (which were deprecated in Gradle 6 and removed
    in Gradle 7):'
  prefs: []
  type: TYPE_NORMAL
- en: '`compile`'
  prefs: []
  type: TYPE_NORMAL
- en: This configuration was split into `api` and `implementation`.
  prefs: []
  type: TYPE_NORMAL
- en: '`runtime`'
  prefs: []
  type: TYPE_NORMAL
- en: Deprecated in favor of `runtimeOnly`.
  prefs: []
  type: TYPE_NORMAL
- en: '`testCompile`'
  prefs: []
  type: TYPE_NORMAL
- en: Deprecated in favor of `testImplementation` to align with the `implementation`
    configuration name.
  prefs: []
  type: TYPE_NORMAL
- en: '`testRuntime`'
  prefs: []
  type: TYPE_NORMAL
- en: Deprecated in favor of `testRuntimeOnly` to be consistent with `runtimeOnly`.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly to Maven, the classpaths follow a hierarchy. The compile classpath
    can be consumed by the runtime classpath, thus every dependency set in either
    the `api` or `implementation` configurations is also available for execution.
    This classpath can also be consumed by the test compile classpath, enabling production
    code to be seen by test code. The runtime and test classpaths are consumed by
    the test runtime classpath, allowing test execution access to all dependencies
    defined in all the configurations so far mentioned.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with Maven, dependencies can be resolved from repositories. Unlike Maven,
    in which both Maven local and Maven Central repositories are always available,
    in Gradle we must explicitly define the repositories from which dependencies may
    be consumed. Gradle lets you define repositories that follow the standard Maven
    layout, the Ivy layout, and even local directories with a flat layout. It also
    provides conventional options to configure the most commonly known repository,
    Maven Central. We’ll use `mavenCentral` for now as our only repository. Putting
    together everything we have seen so far, we can produce a build file like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We can print the resolved dependency graph by invoking the `dependencies` task.
    However, this will print the graph for every single configuration, so we’ll print
    only the resolved dependency graph for the compile classpath for the sake of keeping
    the output short, as well as to showcase an extra setting that can be defined
    for this task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, only a single dependency is printed out, because `commons-collections`
    does not have any direct dependencies of its own that are visible to consumers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see what happens when we configure another dependency that brings in
    additional transitive dependencies, but this time using the `implementation` configuration
    that will show that both `api` and `implementation` contribute to the compile
    classpath. The updated build file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the `dependencies` task with the same configuration as before now yields
    the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This tells us our consumer project has two direct dependencies contributing
    to the compile classpath, and that one of those dependencies brings two additional
    dependencies seen as transitive from our consumer’s point of view. If for some
    reason you’d like to skip bringing those transitive dependencies into your dependency
    graph, you can add an extra block of configuration on the direct dependency that
    declares them, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the `dependencies` task once more now shows only the direct dependencies
    and no transitive dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The final aspect I’d like to cover before moving on is that unlike Maven, Gradle
    understands semantic versioning and will act accordingly during dependency resolution,
    choosing the highest version number as a result. We can verify this by configuring
    two versions of the same dependency, no matter whether they are direct or transitive,
    as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we have declared a direct dependency for `commons-collections`
    version `3.2.1`. We know from previous runs that `commons-beanutils:1.9.4` brings
    in version `3.2.2` of `commons-collections`. Given that `3.2.2` is considered
    more recent than `3.2.1`, we expect that `3.2.2` will be resolved. Invoking the
    `dependencies` task yields the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As expected, version 3.2.2 was selected. The output even contains an indicator
    telling us when a dependency version was set to a different value other than the
    requested one. Versions may be also configured to be fixed regardless of their
    semantic versioning scheme, even to lower values. This is because Gradle offers
    more flexible options for dependency resolution strategies. However, that falls
    into the realm of advanced topics alongside dependency locking, strict versus
    suggested versions, dependency relocation, platforms and enforced platforms (Gradle’s
    way to interact with BOM artifacts), and more.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency Management Basics for Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Further along the line of the software development cycle, you may encounter
    a step where packaging your Maven and Gradle project into a container image is
    necessary. Just like other dependencies in your project, your container images
    must also be managed appropriately and in concert with other required artifacts.
    Containers are discussed in detail in [Chapter 3](ch03.xhtml#thinking_in_containers),
    but this section focuses primarily on some of the subtleties of container image
    management. As with the dependency management in the automated build tools Maven
    and Gradle, even more dragons may lie ahead.
  prefs: []
  type: TYPE_NORMAL
- en: As you learned in [Chapter 3](ch03.xhtml#thinking_in_containers), containers
    are launched using container images that are most commonly defined using a Dockerfile.
    The Dockerfile does the work of defining each layer of the image that will be
    used to build the running container. From this definition, you will get a base
    distribution layer, code libraries and frameworks, and any other needed files
    or artifacts required to run your software. Here you will also define any necessary
    configuration (for example, open ports, database credentials, and references to
    messaging servers) as well as any required users and permissions.
  prefs: []
  type: TYPE_NORMAL
- en: It’s line 1 of the Dockerfile that we discuss in this section first, or in the
    case of multistage build Dockerfiles, the lines that begin with the directive
    `FROM`. Similarly to the Maven POM, an image can be built from a `parent` image,
    which may be built from another parent image—a hierarchy that goes all the way
    to a `base` image, the original ancestor. Here we must pay special attention to
    the way our images are composed.
  prefs: []
  type: TYPE_NORMAL
- en: As you may remember from [Chapter 3](ch03.xhtml#thinking_in_containers), the
    versioning of Docker images is intended to provide flexibility during the development
    stage of your software, as well as a measure of confidence that you are using
    the latest maintenance update of an image when desired. Most often this is done
    by referencing the special image version `latest` (the default version if a version
    is not specified), a request for which will retrieve what is assumed to be the
    latest version of the image in active development. Although not a perfect comparison,
    this is most like using a `snapshot` version of a Java dependency.
  prefs: []
  type: TYPE_NORMAL
- en: This is all fine and good during development, but when it comes to troubleshooting
    a new bug in production, this type of versioning in a production image artifact
    can make troubleshooting more of a challenge. Once an image has been built with
    this default `latest` version in place for a parent or a base image, reproducing
    the build may be difficult or even impossible. Just as you would want to avoid
    using a snapshot dependency in a production release, I recommend locking down
    your image versions and avoiding using the default `latest` in order to limit
    the number of moving parts.
  prefs: []
  type: TYPE_NORMAL
- en: Simply locking down your image versions isn’t sufficient from the context of
    security. Use only trusted base images when building your containers. This tip
    might seem like an obvious one, but third-party registries often don’t have any
    governance policies for the images stored in them. It’s important to know which
    images are available for use on the Docker host, understand their provenance,
    and review their content. You should also enable Docker Content Trust (DCT) for
    image verification and install only verified packages into images.
  prefs: []
  type: TYPE_NORMAL
- en: Use minimal base images that don’t include unnecessary software packages that
    could lead to a larger attack surface. Having fewer components in your container
    reduces the number of available attack vectors, and a minimal image also yields
    better performance because there are fewer bytes on disk and less network traffic
    for images being copied. BusyBox and Alpine are two options for building minimal
    base images. Pay just as careful attention to any additional layers you build
    on top of your verified base image by explicitly specifying all versions of software
    packages or any other artifacts you pull into the image.
  prefs: []
  type: TYPE_NORMAL
- en: Artifact Publication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to now, I’ve discussed how artifacts and dependencies may be resolved, often
    from locations known as repositories, but what is a repository, and how do you
    publish artifacts to it? In the most basic sense, an *artifact repository* is
    file storage that keeps track of artifacts. A repository collects metadata on
    each published artifact and uses that metadata to offer additional capabilities
    such as search, archiving, access control lists (ACLs), and others. Tools can
    harness this metadata to offer other capabilities on top such as vulnerability
    scanning, metrics, categorization, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use two types of repositories for Maven dependencies, those dependencies
    that can be resolved via GAV coordinates: local and remote. Maven uses a configurable
    directory found in the local file system to keep track of dependencies that have
    been resolved. These dependencies may have been downloaded from a remote repository
    or directly placed there by the Maven tool itself. This directory is typically
    referred to as *Maven Local*, and its default location is *.m2/repository*, found
    at the home directory of the current user. This location is configurable. On the
    other side of the spectrum are remote repositories, which are handled by repository
    software such as Sonatype Nexus Repository, JFrog Artifactory, and others. The
    most well-known remote repository is Maven Central, which is the canonical repository
    for resolving artifacts.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s discuss now how we can publish artifacts to local and remote repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing to Maven Local
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Maven offers three ways to publish artifacts to the Maven Local repository.
    Two are explicit, and one is implicit. We’ve already covered the implicit one—it
    occurs whenever Maven resolves a dependency from a remote repository; as a result,
    a copy of the artifact and its metadata (the associated *pom.xml*) will be placed
    in the Maven Local repository. This behavior occurs by default since Maven uses
    Maven Local as a cache to avoid requesting artifacts over the network all over
    again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other two ways of publishing artifacts to Maven Local are by explicitly
    “installing” files into the repository. Maven has a set of lifecycle phases, of
    which *install* is one. This phase is well-known by Java developers, as it’s used
    (and abused) to compile, test, package, and install artifacts to Maven Local.
    The Maven lifecycle phases follow a predetermined sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Phases are executed in sequence until the terminal phase is found. Thus invoking
    *install* typically results in an almost full build (except for *deploy* and *site*).
    I mentioned *install* is abused, as most times it’s enough to invoke *verify*,
    the phase that’s right before *install*, as the former will force compile, test,
    package, and integration-test but does not pollute Maven Local with artifacts
    if they are not needed. This is in no way a recommendation to drop *install* in
    favor of *verify* all the time, as sometimes a test will require resolving artifacts
    from Maven Local. The bottom line is to be aware of the inputs/outputs of each
    phase and their consequences.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back to installing. The first way to install artifacts to Maven Local is simply
    invoking the *install* phase, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This will place copies of all of the *pom.xml* files renamed to follow the
    convention `*artifactId*`-`*version*.pom` as well as every attached artifact into
    Maven Local. Attached artifacts are typically the binary JARs produced by the
    build but can also include other JARs such as the `-sources` and `-javadoc` JARs.
    The second way to install artifacts is by manually invoking the `install:install-file`
    goal with a set of parameters. Let’s say you have a JAR (*artifact.jar*) and a
    matching POM file (*artifact.pom*). Installing them can be done in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Maven will read the metadata found in the POM file and place the files in their
    corresponding location based on the resolved GAV coordinates. It’s possible to
    override the GAV coordinates, generate the POM on the fly, and even omit the explicit
    POM if the JAR contains a copy inside. (That’s typically the case for JARs built
    with Maven; Gradle, on the other hand, does not include the POM by default.)
  prefs: []
  type: TYPE_NORMAL
- en: Gradle has one way to publish artifacts to Maven Local, and that is by applying
    the `maven-publish` plug-in. This plug-in adds new capabilities to the project
    such as the `publishToMavenLocal` task; as the name indicates, it will copy the
    built artifacts and a generated POM to Maven Local. Unlike Maven, Gradle does
    not use Maven Local as a cache, as it has its own caching infrastructure. Thus,
    when Gradle resolves dependencies, the files are placed at a different location,
    usually *.gradle/caches/modules-2/files-2.1*, located at the home directory of
    the current user.
  prefs: []
  type: TYPE_NORMAL
- en: That covers publishing to Maven Local. Now let’s have a look at remote repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing to Maven Central
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The *Maven Central* repository is the backbone that allows Java projects to
    be built on a daily basis. The software running Maven Central is *Sonatype Nexus
    Repository*, an artifact repository provided by Sonatype. Given its important
    role in the Java ecosystem, Maven Central has placed a set of rules that must
    be followed when publishing artifacts; Sonatype has published a [guide](https://oreil.ly/xfhNd)
    explaining the prerequisites and rules. I highly recommend reading through the
    guide in case requirements have been updated since the publication of this book.
    In short, you must ensure the following:'
  prefs: []
  type: TYPE_NORMAL
- en: You must prove ownership of the reverse domain of the target `groupId`. If your
    `groupId` is `com.acme.*`, you must own `acme.com`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When publishing a binary JAR, you must also supply `-sources` and `javadoc`
    JARs, as well as a matching POM—that is, a minimum of four separate files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When publishing an artifact of type POM, only the POM file is needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PGP signature files for all artifacts must be submitted as well. The PGP keys
    used for signing must be published in public-key servers to let Maven Central
    verify signatures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Perhaps the aspect that trips up most people at the beginning: POM files must
    comply with a minimum set of elements such as `<license>`, `<developers>`, `<scm>`,
    and others. These elements are described in the guide; omitting any of them will
    cause a failure during publication, and as result artifacts won’t be published
    at all.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can avoid the last problem or at least detect it much earlier during development
    by using the [PomChecker](https://oreil.ly/E7LP1) project. PomChecker can be invoked
    in many ways: as a standalone CLI tool, as a Maven plug-in, or as a Gradle plug-in.
    This flexibility makes it ideal for verifying a POM at your local environment
    or at a CI/CD pipeline. Verifying a *pom.xml* file using the CLI can be done like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'If your project is built with Maven, you may invoke the PomChecker plug-in
    without having to configure it in the POM, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: That command will resolve the latest version of `pomchecker-maven-plugin` and
    execute its `check-maven-central` goal right on the spot, using the current project
    as input. With Gradle, you’d have to explicitly configure the `org.kordamp.gradle​.pom⁠checker`
    plug-in as Gradle does not offer an option for invoking an inlined plug-in as
    Maven does.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last bit of configuration that must be applied to the build is the publication
    mechanism itself. Do that by adding the following to your *pom.xml* if you’re
    building with Maven:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Note that this configuration generates `-sources` and `-javadoc` JARs, signs
    all attached artifacts with PGP, and uploads all artifacts to the given URL, which
    happens to be one of the URLs supported by Maven Central. The `<serverId>` element
    identifies the credentials you must have in place in your *settings.xml* file
    (otherwise, the upload will fail), or you may define credentials as command-line
    arguments.
  prefs: []
  type: TYPE_NORMAL
- en: You may want to put the plug-in configuration inside a `<profile>` section,
    as the behavior provided by the configured plug-ins is needed only when a release
    is posted; there’s no reason to generate additional JARs during the execution
    of the main lifecycle phase sequence. This way, your builds will execute only
    the minimum set of steps and thus be faster as a result.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if you’re using Gradle for publication, you’d have to configure
    a plug-in that can publish to Sonatype Nexus Repository, the latest of such plug-ins
    being [io.github.gradle-nexus.publish-plugin](https://oreil.ly/MdCNh). There’s
    more than one way to configure Gradle to do the job. Idioms change more rapidly
    than what you must configure in Maven. I recommend you consult the official Gradle
    guides to find out what needs to be done in this case.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing to Sonatype Nexus Repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may recall that Maven Central is run using Sonatype Nexus Repository, so
    it should be no surprise that the configuration shown in the previous section
    applies here as well, such that you have to change only the publication URLs to
    match the Nexus repository. There’s one caveat though: the strict verification
    rules applied by Maven Central often do not apply to a custom Nexus installation.
    That is, Nexus has the option to configure the rules that govern artifact publication.
    These rules may be relaxed for a Nexus instance running within your organization,
    for example, or they may be stricter in other areas. It’s a good idea to consult
    the documentation available at your organization regarding artifact publication
    to their own Nexus instance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing is clear: if you are publishing artifacts to your organization’s
    Nexus repository that eventually must be published to Maven Central, it’s a good
    idea to follow the Maven Central rules from the start—as long as these rules do
    not clash with your organization’s.'
  prefs: []
  type: TYPE_NORMAL
- en: Publishing to JFrog Artifactory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*JFrog Artifactory* is another popular option for artifact management. It offers
    similar capabilities as Sonatype Nexus Repository while at the same time adding
    other features, including integration with other products that belong to the JFrog
    Platform, such as Xray and Pipelines. One particular feature I’m quite fond of
    is that artifacts do not need to be signed at the source before publication. Artifactory
    can perform the signing with your PGP keys or with a site-wide PGP key. This relieves
    you of the burden of setting up keys on your local and CI environments as well
    as transferring fewer bytes during publication. As before, the previous publication
    configuration we saw for Maven Central will work for Artifactory as well, by changing
    only the publication URLs to match the Artifactory instance.'
  prefs: []
  type: TYPE_NORMAL
- en: As with Nexus, Artifactory allows you to sync artifacts to Maven Central, and
    you have to follow the rules for publishing to Maven Central once again. Thus
    publishing well-formed POMs, sources, and Javadoc JARs from the get-go is a good
    idea.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve covered plenty of concepts in this chapter, but the main takeaway should
    be that artifacts on their own are not enough to get the best results when building
    software or to get ahead of the competition. Artifacts usually have metadata that
    can be associated with them such as their build time, dependency versions, and
    environment. This metadata may be used to trace the origins of a particular artifact,
    help turn it into a reproducible artifact, or enable the generation of a software
    bill of materials (SBOM), which happens to be yet another metadata format. Moreover,
    observability, monitoring, and other concerns regarding the health and stability
    of the build pipeline can be greatly enhanced by the existence of this metadata.
  prefs: []
  type: TYPE_NORMAL
- en: Specific to dependencies, we saw the basics of dependency resolution with popular
    Java build tools such as Apache Maven and Gradle. Of course, more depth than was
    discussed in this chapter is warranted; these topics could certainly fill a book
    on their own. Be sure to be on the lookout for improvements in this area as provided
    by later versions of these build tools.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we covered how to publish Java artifacts to the popular Maven Central
    repository, given that it requires adhering to a particular set of guidelines
    that must be followed for successful publication. Maven Central is the canonical
    repository, but it’s not the only one. Sonatype offers Sonatype Nexus Repository,
    and JFrog offers JFrog Artifactory, also quite popular choices to manage artifacts
    at internal locations such as your own organization or company.
  prefs: []
  type: TYPE_NORMAL
