# 附录。超越 Java 17

本附录讨论 Java 17 之后的版本。在之前的《Java 速查表》版本中，我们一直抵制添加前瞻性材料，但 Java 发布模型的最近变化（我们在第一章中讨论过），以及正在进行和即将进行的 Java 发展，促使我们在这个新版本中改变了策略。

在当前模型中，每六个月发布一个新版本的 Java，但只有特定版本是 LTS。目前，Java 11 和 17 被视为 LTS（回顾性添加了 8）。请注意，LTS 具有双重含义：对于 Oracle 客户来说，它意味着可以获得多年的付费支持，而其他 JDK 提供者（包括 Red Hat、Microsoft、Amazon 等）实际上采用了与那些将会公开提供后向兼容安全性和其他修复的版本相同的版本——作为经过认证的 OpenJDK 二进制文件，免费提供。

由于各种原因，整个行业并没有选择采用每六个月升级一次 Java 的周期，因此在实践中，只有 LTS 版本可能会被部署到生产环境中。然而，大多数 OpenJDK 提供者确实会认真发布所有 Java 版本的二进制文件，即使在六个月窗口之后，这些版本也不会得到支持。

这造成了一个两难局面：新功能每六个月就会推出，但直到下一个 LTS 版本发布后，团队才会广泛使用，这使得撰写特定 Java 版本的文章变得更加复杂。这一情况进一步复杂化了*孵化*和*预览*功能的概念，它们分别用于在最终确定并成为语言标准的新 API 和新语言功能之前进行实验。

我们选择的解决方案是针对 LTS 版本编写本书的新版本，并包括一篇附录，介绍自上一个 LTS 版本以来（或预期将要到来的）的任何新功能。我们还选择只在主要部分中涵盖最终功能；所有关于孵化和预览功能的讨论将被限制在附录中。

让我们首先讨论 OpenJDK 中主要开发工作是如何安排的，然后再讨论 Java 18 和 19，最后再展望那个版本之后的未来。

# 长期 JDK 项目

OpenJDK 按照涵盖正在进行的工作的特定主要领域进行组织，这包括专注于开发未来语言或 JVM 功能的项目，这些项目可能需要多年的努力才能完成。

目前有四个项目专注于交付 Java 的重要未来方面。它们通常以项目代号来命名：

+   Panama

+   Loom

+   Valhalla

+   Amber

其中，Panama 项目提供了两个主要改进：Java 的现代外部函数接口以及对矢量 CPU 指令的支持。

它已经孵化了一段时间，但 Java 18 包含了功能的有趣的里程碑迭代，因此我们将在 Java 18 部分介绍该项目。

Project Loom 是 Java 的新并发模型。Loom 的一些功能首次在 Java 19 中提供预览，因此我们将在该部分讨论 Loom。

Valhalla 项目是所有项目中最雄心勃勃、影响最广泛且影响最大的。它也是最复杂且最远离成品交付的。我们将在附录的最后讨论它。

Project Amber 的任务是增量语言改进。它可能是四个项目中最为熟悉和最容易理解的，因此我们将在这里作为下一个主题进行讨论。

## Amber

Amber 自 Java 9 发布以来一直在运行。它旨在提供有用的语言功能的小块，这种方法非常适合 Java 版本的新交付计划。迄今为止作为 Amber 的一部分并已交付的功能包括：

+   局部变量类型推断 (`var`)

+   `switch`表达式

+   增强的`instanceof`

+   文本块

+   记录

+   密封类型

+   模式匹配

这些特性中大多数已经完成，但作为 Java 17 的最后一个，模式匹配还没有完全交付。迄今为止，只有最简单的情况，即`instanceof`模式，已经作为最终特性到达。Java 17 确实有一个更高级形式的预览版本（正如我们在第五章中提到的），可以作为`switch`表达式的一部分使用：

```java
sealed interface Pet permits Cat, Dog {}
record Cat(String name) implements Pet {}
record Dog(String name) implements Pet {}

boolean isDog(Pet p) {
    return switch (p) {
        case Cat c -> false;
        case Dog d -> true;
    };
}
```

注意不需要`default`情况。所有的`Pet`对象要么是`Cat`要么是`Dog`，因为`Pet`接口声明为密封的。

当未来进一步的情况到来并标准化为最终特性时，模式匹配将真正展现其全部能力。特别是模式匹配与*代数数据类型*（记录和密封类型组合的其中一种名称）的结合尤为强大。

我们可以看到 Amber 的方法如何与 Java 半年度发布模式的模型相适应；`switch`表达式和增强的`instanceof`被扩展并结合成模式匹配的基础，然后通过代数数据类型和与之相配的进一步模式进一步增强。

# Java 18

新的 Java 版本由 Java Enhancement Proposals (JEPs)组成：当前、过去和未来的所有 JEPs 的完整列表可以在[*https://oreil.ly/BE1r1*](https://oreil.ly/BE1r1)找到。

Java 18 发布于 2022 年 3 月，包括以下 JEPs：

+   400: 默认使用 UTF-8

+   408: 简单 Web 服务器

+   413: Java API 文档中的代码片段

+   416: 使用方法句柄重新实现核心反射

+   417: 向量 API（第三孵化器）

+   418: Internet 地址解析 SPI

+   419: 外部函数和内存 API（第二孵化器）

+   420: `switch`的模式匹配（第二预览）

其中大多数是非常小的或者是内部实现的变化。与 Panama 相关的两个 JEPs（417 和 419）是该项目的重要进展，我们将在这里详细讨论。

## Panama

Panama 项目旨在为连接到本地代码的现代外部（即非 Java）接口提供支持。该代号源自巴拿马地峡，这是连接两个较大“陆地块”的狭长地带，被理解为 JVM 和本地内存（即“堆外”）。

总体目标是取代 Java 本机接口（JNI），这是众所周知存在主要问题，例如过多的仪式感、额外的构件和与除 C / C++之外的库的互操作性不足。事实上，即使对于 C 的情况，JNI 也不会自动映射类型系统，Java 和 C 代码的部分必须被半手动映射。

Panama 为帮助 Java 和本地代码互操作提供了两个主要组件：

+   外部内存和函数 API

+   向量 API

外部内存 API 涉及结构化外部内存的分配、操作和释放，以及外部资源的生命周期管理。这超出了`ByteBuffer`类的现有能力，例如可以作为单个段管理超过 2GB 的内存。管理外部内存的问题很复杂，因为它超出了 JVM 的垃圾收集器范围，而现有的机制如最终化已被证明存在严重缺陷。

使用 Panama 也可以调用外部函数。一个名为`jextract`的新命令行工具，从 C 头文件创建一个 Java 桥接。该桥接使用方法和变量句柄构建，以提供一组（静态）Java 方法，尽可能接近原始的 C API。

运行时支持包含在`jdk.incubator.foreign`模块中，这显然是一个孵化 API，在最终版本发布之前可能会发生更改。目前，最初支持的外部语言是 C 和 C++，但随着项目发展，预计会添加其他可能性（尤其是 Rust）。

除外部 API 外，Panama 还通过提供以下主要目标的 API 支持向量计算：

+   清晰简洁的 API

+   平台无关

+   可靠的 JIT 编译和性能

+   向量模式退化为线性指令的优雅降级

初始情况下，Panama 为 x64 和 AArch64 CPU 架构提供实现。然而，正如目标所表达的，该 API 不得排除其他 CPU 的可能实现。

# Java 19

Java 19 发布于 2022 年 9 月，包含一个新主要特性（Loom）的预览版本，以及以下几个 JEP 选择：

+   405: 记录模式（预览版）

+   422: Linux/RISC-V 端口

+   424: 外部函数和内存 API（预览版）

+   426: 向量 API（第四孵化器）

+   427: switch 模式匹配（第三预览版）

这些 JEP 主要是现有预览和孵化功能的延续，因此我们不再花时间讨论它们，而是专注于：

+   425: 虚拟线程（预览版）

+   428: 结构化并发（孵化器）

这两个 JEP 为 Project Loom 的首个预览版交付提供了基础。

## Loom

在 Java 17 中，每个执行的 Java 语言线程都是一个操作系统线程，因为调用 `Thread.start()` 会触发一个系统调用来创建操作系统线程。因此，这在可用的 Java 执行上下文数量与操作系统限制之间创建了一个约束。随着编程语言的发展，这种约束变得更加棘手。操作系统为每个线程创建了数据结构（例如堆栈），并独立调度每个线程的执行。

这自然引出了一个问题：一个应用程序能启动多少个操作系统线程？1,000 个？也许是 10,000 个？无论确切数量如何，这种方法肯定存在硬性限制。Project Loom 是 Java 并发模型的重新构想，旨在超越这种限制。

关键在于 *虚拟线程*，这是一种新的构造，不是一对一对应的操作系统线程。从 Java 编程的角度看，虚拟线程看起来像 `Thread` 的实例，但由 JVM 管理，而不是操作系统。这意味着不会创建操作系统级的数据结构（例如线程的堆栈帧），所有管理元数据由 JVM 处理。这包括调度行为；与操作系统调度程序不同，使用的是 Java 执行调度程序（线程池）。

当虚拟线程希望执行时，它会在一个操作系统的 *载体线程* 上执行，并运行直到发出阻塞调用（例如 I/O）。载体线程会 *让步* 给另一个虚拟线程，因此一个虚拟线程可能在其生命周期内在多个不同的载体上执行。与阻塞调用的关联意味着虚拟线程不适合纯 CPU 绑定的任务，总体上，使用 Loom 的方式与开发者可能在其他语言中使用的 `async` / `await` 等方法非常不同。

尚不清楚 Loom 将对最终用户开发者产生多大影响，尽管从框架和库作者那里表现出了很高的兴趣。首个预览版本将在 JDK 19 中作为预览版推出，但仍不清楚它何时作为标准功能推出。总体来看，社区的期待是它将在下一个 LTS 版本中最终确定，预计这将是 Java 21。

# 未来的 Java

除了已提到的项目完成之外，还在进行着更长期的努力来发展 Java：Valhalla 项目和云原生 Java 的兴起。

让我们依次看一看。

## Valhalla

Valhalla 项目是一个自 2014 年以来一直在运行的非常雄心勃勃的 OpenJDK 项目。其目标是“将 JVM 内存布局行为与现代硬件的成本模型对齐”，看起来非常简单和无害。

但是，这是极其具有欺骗性的。

首先，这将现有的 Java 对象分为两种情况：我们习惯使用的身份对象和一种新的值对象，其主要区别在于它没有唯一的身份。从这些值对象中，进一步采取的一步是允许移除引用性或间接性，并且直接用其位模式来表示值。

这些新数据值的预期使用案例是小型、不可变、最终的、无身份的类型。这使得这些新的无身份值可以与现有的对象引用和原始类型完美结合，并且也暗示了一个可能的用例，即“用户定义的原始类型”。

用户应将值视为没有身份的对象，这样他们将从 JIT（例如增强的*逃逸分析*）中获得性能保证的好处。

###### 注意

Valhalla 还为低级库（如复数、半浮点数用于机器学习等复杂数据类型）提供了直接使用原始值类型的机制，但大多数开发者不应该需要使用这个方面。

这些新数据值缺乏对象身份的事实意味着它们破坏了传统的继承层次结构——没有身份就没有对象监视器，因此这些类型不支持`wait()`、`notify()`和`synchronized`。

这反过来与 Java 泛型产生了一个潜在的惊人联系，因为只有引用类型可以作为类型参数的值。因此，Valhalla 提议扩展泛型，允许抽象覆盖所有类型，包括这些新的数据值甚至现有的原始类型。

除了通过 JVM 针对这些新形式的数据进行广泛工作外，还必须在 Java 语言中创建一个使用模型，这对 Java 程序员来说似乎很自然。Valhalla 还必须使现有的库（包括但不限于 JDK）能够在这些变化被推出时兼容地演进。

由于 Valhalla 的新类型是不可变的，因此将需要一些新的字节码指令，因此`putfield`指令（修改对象字段的指令）将无法工作。

在项目历史中，Valhalla 的新类型已经以几种名称为人所知，包括*值类型*、*内联类型*和*原始类*。涵盖 Valhalla 实现的 JEP 在撰写本文时并未针对特定的 Java 版本，大多数 Java 程序员可能在日常工作中很少遇到它们。

## 云原生 Java

软件行业的一个持续的巨大趋势是向在“云”中运行的工作负载过渡，这意味着由亚马逊、微软和谷歌等基础设施提供商拥有的按时间租赁的服务器上运行。

现代编程环境越来越需要确保它们在云部署中经济实用，Java 也不例外。然而，Java 的设计确实有一些方面可能对云应用不太友好。这些主要源于运行时的类加载和 JIT 编译方面，这些都是为了单个 JVM 进程的灵活性和高性能而设计的。

在云中，这可能会产生诸如：

+   应用启动时间慢

+   较长的达到峰值性能时间

+   可能会有较高的内存开销

特别是对于云处理进程的生命周期（特别是“无服务器”和*函数即服务*部署），可能过短，以至于 Java 的性能优势无法得到回报。这可以看作是为了获得收益而需付出的成本在进程退出时尚未完全摊销。

目前正在尝试解决这些长期的痛点，并确保 Java 在云优先成为主流服务器端应用交付模式时仍具有竞争力和吸引力的编程环境。

其中一个主要方法是*本地编译*：将 Java 程序从字节码转换为编译后的机器码。由于这种编译发生在程序执行开始之前（就像 Rust 和 C++等语言一样），因此被称为*预编译*编译（AOT），或简称 AOT。这种技术在 Java 领域并不常见，但它旨在提供更快的启动时间，因为程序不需要进行类加载或 JIT 编译。然而，通常情况下它不会比在动态虚拟机模式下运行的同一应用程序提供更好的峰值性能。这是因为这里重点不在于峰值性能。AOT 和 JIT 代表了不同的策略和不同的权衡。

当前支持本地编译的主要工作是[Oracle’s GraalVM](https://oreil.ly/o9jNp)。这是在 Oracle Labs 作为一个独立的研究项目开发的，但截至 2022 年底，Oracle 宣布计划向 OpenJDK 贡献部分内容。它有两个版本，一个是开源版，另一个是专有的企业版，后者有许可和支持成本。

GraalVM 包含一个名为 Graal 的编译器，它可以在 JIT 或 AOT 模式下运行。Graal 的 AOT 模式是 GraalVM 的 Native Image 技术的基础，可以从 Java 应用程序生成一个独立的编译后的机器码二进制文件。Graal 编译器的一个有趣之处在于它是用 Java 编写的，而不像 OpenJDK 中的 JIT 编译器那样是用本地代码实现的。

GraalVM 还包括 Truffle，一个用于 JVM 上语言的解释器生成框架。在 Truffle 之上编写的支持语言的解释器本身就是运行在 JVM 上的 Java 程序。已经支持多种非 Java 语言，如 JavaScript、Python、Ruby 和 R。

另一个致力于改进云原生支持的项目是[Quarkus](https://quarkus.io)，一个专为 Kubernetes 云编排和部署堆栈设计的 Java 微服务框架。Quarkus 尝试通过广泛使用构建时处理来减少云原生的痛点影响。通常在启动过程中通过反射处理的昂贵计算和启动过程将尽可能提前执行。

Quarkus 还强调开发者体验，并提供响应式和命令式两种编程微服务的风格。

这个框架是开源且已经投入生产使用，并且有来自红帽的支持，红帽是该项目的主要维护者。它还包括对 GraalVM 开源版本的本地编译支持。不过，Quarkus 也可以在 OpenJDK 运行时的动态虚拟机模式上运行。

最后，我们还应该提到项目 Leyden。这是一个新的（2022 年 5 月）OpenJDK 项目，旨在为 Java 平台引入*静态运行时镜像*。该项目的名称来源于 18 世纪用于存储静电的“莱顿瓶”。其中一个关键点是*封闭世界*假设，即移除反射等动态运行时行为。

该项目仍处于早期阶段，但采用的方法与 GraalVM 有所不同（并更为谨慎）；Leyden 的一个关键目标是能够有选择性地和灵活地限制和转移动态性。其意图是朝着 GraalVM 创建的 AOT 编译的本地镜像二进制文件类似的目标发展，但目前尚无迹象表明这些技术何时可能出现在 Java 的生产形式中。
