- en: Chapter 2\. Preparing for Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter aims to implement your first end-to-end test using Selenium WebDriver
    and the Java language. To do that, we first review the technical requirements
    in terms of previous knowledge, hardware, and software. Second, this chapter provides
    an overview for setting up a Java project that includes Selenium WebDriver tests.
    You can use a build tool like Maven or Gradle to ease the project setup. Finally,
    you will learn to implement a basic end-to-end test with Selenium WebDriver, i.e.,
    a *hello world* test. We will implement this test in several flavors, using different
    web browsers (such as Chrome, Edge, or Firefox) and unit testing frameworks (JUnit
    and TestNG). Remember that every code example in this book is available in an
    [open source GitHub repository](https://github.com/bonigarcia/selenium-webdriver-java).
    Thus, you can reuse the content and configuration of this repository as the foundation
    for your own tests.
  prefs: []
  type: TYPE_NORMAL
- en: Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first requirement to start using Selenium WebDriver with Java is comprehending
    the Java language and object-oriented programming. It is not necessary to be an
    expert, but basic knowledge about it is required. Then, you can use Selenium WebDriver
    in any mainstream operating system: Windows, Linux, or macOS. Therefore, you can
    select the computer type you prefer. In principle, there are no specific requirements
    about its hardware in terms of memory, CPU, hard disk, etc., so any mid-tier computer
    will do.'
  prefs: []
  type: TYPE_NORMAL
- en: Java Virtual Machine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, you need a Java Virtual Machine (JVM) installed on your computer. There
    are two types of distributions for the JVM. The first option is the Java Runtime
    Environment (JRE), which includes the JVM and the Java standard API. The second
    option is the Java Development Kit (JDK), which is the JRE plus a Software Development
    Kit (SDK) for Java (such as the `javac` compiler and other tools). Since we are
    developing in Java, I recommend using JDK (although some IDEs also incorporate
    an SDK for Java). For the Java version, I recommend using at least JDK 8 since
    it is the long-term support version commonly supported in many Java projects at
    the time of this writing.
  prefs: []
  type: TYPE_NORMAL
- en: Text Editor or IDE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To code our Java tests, we need a text editor or IDE. IDEs provide an excellent
    experience for development because they have a full-fledged environment (for coding,
    running, debugging, autocompletion, etc.). Nevertheless, you can get similar practice
    using any text editor you like, used in conjunction with command-line tools (for
    running, debugging, etc.). Overall, it depends on your personal preferences to
    choose one or another. Some popular alternatives for text editors are [Sublime
    Text](https://www.sublimetext.com), [Atom](https://atom.io), [Notepad++](https://notepad-plus-plus.org),
    or [Vim](https://www.vim.org), among others. IDEs include [Eclipse](https://www.eclipse.org),
    [IntelliJ IDEA](https://www.jetbrains.com/idea), [NetBeans](https://netbeans.apache.org),
    or [Visual Studio Code](https://code.visualstudio.com).
  prefs: []
  type: TYPE_NORMAL
- en: Browsers and Drivers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An initial way to carry out automation with Selenium WebDriver is to use local
    browsers. I consider the following browsers for this book: Chrome, Edge, and Firefox.
    I refer to them as *main browsers* for several reasons. First, they are very popular
    worldwide, and because we are testing web applications with Selenium WebDriver,
    we want to use the same browser as our potential users. Second, these browsers
    are *evergreen* (i.e., they upgrade themselves automatically). Third, these browsers
    are available for the major operating systems: Windows, Linux, and macOS (unlike
    Safari, which is also a popular browser but is only available on macOS). Lastly,
    these browsers are available in the Continuous Integration (CI) environment used
    in the GitHub repository (i.e., GitHub Actions).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last requirement for controlling web browsers with Selenium WebDriver is
    the driver binaries: chromedriver (for Chrome), msedgedriver (for Edge), and geckodriver
    (for Firefox). As discussed in [Chapter 1](ch01.html#ch01), driver management
    involves three steps: download, setup, and maintenance. To avoid the potential
    problems explained in that chapter, I strongly recommend automating this process
    with [WebDriverManager](https://bonigarcia.dev/webdrivermanager).'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[Appendix B](app02.html#appendix02) provides fine-grained details about the
    automated driver management process performed by WebDriverManager. In addition,
    and just in case you need it for some reason, this appendix explains how to carry
    out the driver management manually.'
  prefs: []
  type: TYPE_NORMAL
- en: Build Tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another important component is the *build tool*. Build tools are software utilities
    used to automate the creation of executable applications from source code. These
    tools ease project management in terms of dependencies management, compilation,
    packaging, test execution, and deployment. Overall, build tools are a convenient
    way to automate the development of software projects, both in build servers (e.g.,
    GitHub Actions) and developer machines. Therefore, I highly recommend using a
    build tool to set up your project. The alternatives we cover in this book are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Maven](https://maven.apache.org)'
  prefs: []
  type: TYPE_NORMAL
- en: An open source build automation tool maintained by the Apache Software Foundation.
    It is used primarily for Java projects, although it also supports other languages
    such as C#, Ruby, or Scala.
  prefs: []
  type: TYPE_NORMAL
- en: '[Gradle](https://gradle.org)'
  prefs: []
  type: TYPE_NORMAL
- en: Another open source build automation tool for software development. It supports
    Java and other languages such as Kotlin, Groovy, Scala, C/C++, or JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: The recommended versions are Maven 3+ and Gradle 6+. For completeness, I use
    both build tools in the example repository. Again, the final choice to use one
    or another depends on your preferences.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you plan to use an IDE for developing and running your tests, a build tool
    is not strictly necessary. Nevertheless, I recommend installing at least one of
    these tools in your computer to replicate the environment typically used in build
    servers (e.g., Jenkins, GitHub Actions, etc.).
  prefs: []
  type: TYPE_NORMAL
- en: Optional Software
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to the software already explained, some other programs are convenient
    to make the most of this book. First, you can use [Git](https://git-scm.com) for
    source code management. Since the test examples presented in this book are available
    on GitHub, you can use Git to fork (or clone) and update this repository.
  prefs: []
  type: TYPE_NORMAL
- en: The second optional tool is [Docker](https://www.docker.com). In this book,
    I show you how to use Docker to execute containerized browsers (see [Chapter 6](ch06.html#ch06)).
    For this reason, I strongly recommend you install a *Docker Engine* on your computer
    (it is available for Linux, macOS, and Windows 10).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you can use different web browsers if you need them. In addition to
    the main browsers (Chrome, Edge, and Firefox), it is possible to use other browsers
    with Selenium WebDiver, such as [Safari](https://www.apple.com/safari) in macOS,
    or [Opera](https://www.opera.com), [Chromium](https://www.chromium.org), and [HtmlUnit](https://htmlunit.sourceforge.io)
    (a headless browser, i.e., GUI-less browser) in any operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Project Setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find all the code examples of this book in [a GitHub repository](https://github.com/bonigarcia/selenium-webdriver-java).
    This repository is open source, released under the terms of the Apache 2.0 license.
    The repository has multiple aims. First, it is convenient to group all the examples
    in a single site. Second, you can use its setup (Maven or Gradle) as a skeleton
    for your projects.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The following subsections describe the general requirements to create a Java
    project containing Selenium WebDriver tests. [Appendix C](app03.html#appendix03)
    provides low-level details about the configuration of the examples repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Project Layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *project layout* is the directory structure used to store the different
    assets of a software project (e.g., source code, binary files, static resources,
    and so on). Maven and Gradle use an equivalent layout for Java projects. We can
    execute the examples repository with both build tools, thanks to this.
  prefs: []
  type: TYPE_NORMAL
- en: 'As illustrated in [Figure 2-1](#project-layout), the following set of folders
    (labeled as *scaffolding folders*) are identical in both build tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/java`'
  prefs: []
  type: TYPE_NORMAL
- en: Application source code (i.e., Java files)
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/resources`'
  prefs: []
  type: TYPE_NORMAL
- en: Application resources files (i.e., properties, configuration files, etc.)
  prefs: []
  type: TYPE_NORMAL
- en: '`src/test/java`'
  prefs: []
  type: TYPE_NORMAL
- en: Test source code (i.e., Java files used for testing)
  prefs: []
  type: TYPE_NORMAL
- en: '`src/test/resources`'
  prefs: []
  type: TYPE_NORMAL
- en: Test resources files (i.e., additional assets used for testing)
  prefs: []
  type: TYPE_NORMAL
- en: '![hosw 0201](assets/hosw_0201.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-1\. Project layout in Maven and Gradle
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The rest of the project layout is different in both build tools. The first
    difference is the configuration file. On the one hand, this file is unique and
    called `pom.xml` (Project Object Model) in Maven. On the other hand, there are
    two files in Gradle for configuration, called `settings.gradle` and `build.gradle`.
    The second difference between Maven and Gradle is the output folder. In both cases,
    the build tools created this folder to save the resulting build (i.e., compiled
    classes, resulting packaged files, etc.). The name of this folder is `target`
    in Maven and `build` in Gradle. Finally, Gradle contains a set of folders and
    files for the so-called Gradle *wrapper*. This wrapper is a script file (called
    `gradlew` for Unix-like systems and `gradlew.bat` for Windows) that provides the
    following benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: Build a project without installing Gradle on the local machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Require use of a given version (which can be different from the locally installed
    instance of Gradle)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upgrade to a new version easily by changing the wrapper artifacts (in folder
    `gradle/wrapper`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As of version 4, Maven has adopted the wrapper concept using the `mvnw` script.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It is beyond the scope of this book to explain all the features provided by
    Maven and Gradle. Nevertheless, you can find more information about their build
    lifecycle and typical commands in [Appendix C](app03.html#appendix03). For further
    information, consider reading the official [Maven](https://maven.apache.org/guides)
    and [Gradle](https://docs.gradle.org) documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The dependencies of a software project are the required libraries or plug-ins.
    Among other features, build tools enable the automated management of the project
    dependencies. To that aim, we need to specify the *coordinates* of such dependencies
    in the project configuration file (see the following subsections for specifics
    on Maven and Gradle). The coordinates of a Java project are a group of three labels
    that univocally identify this project (e.g., a library, plug-in, etc.), namely:'
  prefs: []
  type: TYPE_NORMAL
- en: '`groupId`'
  prefs: []
  type: TYPE_NORMAL
- en: Organization, company, person, etc., that created the project.
  prefs: []
  type: TYPE_NORMAL
- en: '`artifactId`'
  prefs: []
  type: TYPE_NORMAL
- en: Unique name that identifies the project.
  prefs: []
  type: TYPE_NORMAL
- en: '`version`'
  prefs: []
  type: TYPE_NORMAL
- en: Particular release of the project. By default, I recommend you use the latest
    version of every release.
  prefs: []
  type: TYPE_NORMAL
- en: This section explains the Java dependencies I use in the examples repository.
    First, of course, we need Selenium WebDriver to carry out browser automation.
    This dependency is the only one strictly mandatory. Then, I recommend using additional
    dependencies for automated driver management utility, unit testing framework,
    fluent assertions, and logging. The remainder of this section explains the motivation
    and basic use of each of these utilities.
  prefs: []
  type: TYPE_NORMAL
- en: Selenium WebDriver
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the most relevant concepts of Selenium WebDriver is the `WebDriver` hierarchy,
    which is a collection of classes aimed at controlling different web browsers.
    As you can see in [Figure 2-2](#webdriver-hierarchy), this hierarchy follows the
    object-oriented programming paradigm. On the top, we find the `WebDriver` interface,
    the parent of the whole structure. The lower part of the hierarchy corresponds
    to Java classes that drive single browsers. For instance, we need to use an instance
    of the class `ChromeDriver` to control a local Chrome browser. [Table 2-1](#webdriver-hierarchy-description)
    shows a comprehensive summary of the main classes of the `WebDriver` hierarchy
    and their corresponding target browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Table 2-1\. Description of the `WebDriver` hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: '| Package | Class | Browser |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '| Chrome |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '| Edge |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '| Firefox |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '| Safari |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '| Opera |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '| Internet Explorer |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '| Remote browsers (see [Chapter 6](ch06.html#ch06)) |'
  prefs: []
  type: TYPE_TB
- en: '![hosw 0202](assets/hosw_0202.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-2\. Hierarchy of the `WebDriver` object
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Automated driver management
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is mandatory to resolve the corresponding driver before instantiating an
    object of the `WebDriver` hierarchy. For example, to control Chrome with `ChromeDriver`,
    we first need to have installed this browser on the local machine. Second, we
    need to manage chromedriver. To avoid the potential problems related to manual
    driver management (see [Chapter 1](ch01.html#ch01)), I recommend carrying out
    the whole driver management process (download, setup, and maintenance) in an automated
    manner. Concerning Java, the reference implementation is [WebDriverManager](https://bonigarcia.dev/webdrivermanager),
    a Selenium WebDriver helper library that allows automated driver management. This
    section explains how to use WebDriverManager as a Java dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the WebDriverManager dependency is resolved in our project (see [Appendix C](app03.html#appendix03)
    for the configuration details), we can use the WebDriverManager API to manage
    drivers. This API provides a set of singletons (called *managers*) to download,
    set up, and maintain drivers. These singletons are accessible through the `WebDriverManager`
    class. For instance, we need to invoke the method `chromedriver()` to manage the
    driver required by Chrome, i.e., chromedriver, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[Table 2-2](#wdm-calls) summarizes the basic WebDriverManager calls for all
    the supported browsers. In addition to these basic calls (i.e., the method `setup()`),
    WebDriverManager exposes a fluent API for advanced configuration. See [Appendix B](app02.html#appendix02)
    for more details about the WebDriverManager methodology, configuration capabilities,
    and other uses, such as a command-line interface tool (from the shell), as a server
    (using a RESTlike [REpresentational State Transfer] API), as an agent (using Java
    instrumentation), or as a Docker container.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 2-2\. WebDriverManager basic calls
  prefs: []
  type: TYPE_NORMAL
- en: '| WebDriverManager basic call | Browser | Driver |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '| Chrome | chromedriver |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '| Edge | msedgedriver |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '| Firefox | geckodriver |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '| Opera | operadriver |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '| Chromium | chromedriver |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '| Internet Explorer | IEDriverServer |'
  prefs: []
  type: TYPE_TB
- en: Unit testing frameworks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As explained in [Chapter 1](ch01.html#ch01), unit testing frameworks are the
    basis for creating different types of tests. This book will teach you how to implement
    end-to-end tests for web applications using Selenium WebDriver. Hence, I suggest
    embedding the Selenium WebDriver calls within tests created with a particular
    unit testing framework. The alternative I recommend is one of these options: JUnit
    4, JUnit 5 (alone or in conjunction with Selenium-Jupiter, which is an extension
    for Selenium WebDriver), or TestNG. The following subsections provide more details
    about these alternatives. My advice is to focus on the unit testing framework
    and the build tool you prefer to continue practicing with the examples presented
    in the rest of the book.'
  prefs: []
  type: TYPE_NORMAL
- en: JUnit 4
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: JUnit is a unit testing framework for Java created by Erich Gamma and Kent Beck
    in 1999\. It is considered the de facto standard framework for developing tests
    in Java. In JUnit, a *test* is a method within a Java class used for testing.
    As of JUnit 4, Java annotations are the building blocks for developing JUnit tests.
    The fundamental annotation of JUnit 4 is `@Test` since it allows identifying the
    method(s) that contain the test logic (i.e., the code used to exercise and verify
    a piece of software). In addition, there are other annotations to identify the
    methods used for the setup (i.e., what happens before the tests) and the teardown
    (i.e., what happens after the tests).
  prefs: []
  type: TYPE_NORMAL
- en: '`@BeforeClass` is executed once before all tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Before` is executed before each test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@After` is executed after each test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@BeforeClass` is executed once after all tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Figure 2-3](#junit4-test-lifecycle) shows a graphical representation of the
    basic test lifecycle in JUnit 4.'
  prefs: []
  type: TYPE_NORMAL
- en: '![hosw 0203](assets/hosw_0203.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-3\. JUnit 4 test lifecycle
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: JUnit 5
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Due to several limitations in JUnit 4 (such as monolithic architecture or impossible-to-compose
    JUnit runners), the JUnit team released a new major version (i.e., JUnit 5) in
    2017\. JUnit has been redesigned entirely in version 5, following a modular architecture
    consisting of three components (see [Figure 2-4](#junit5-arch)). The first component
    is the JUnit *Platform*, the foundation of the whole framework. The goal of the
    JUnit Platform is twofold:'
  prefs: []
  type: TYPE_NORMAL
- en: It allows the discovery and execution (sequential or parallel) of tests in the
    JVM through the *test launcher* API. This API is typically used by programmatic
    clients such as build tools and IDEs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It defines the *test engine* API for running tests on the JUnit Platform. This
    API is typically used by frameworks that provide programming models for testing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![hosw 0204](assets/hosw_0204.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-4\. JUnit 5 architecture
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Thanks to the test engine API, third-party test frameworks can execute tests
    on top of the JUnit Platform. Some examples of existing testing frameworks that
    have implemented test engines for JUnit 5 are [TestNG](https://github.com/junit-team/testng-engine),
    [Cucumber](https://github.com/cucumber/cucumber-jvm), or [Spock](https://github.com/spockframework/spock).
    In addition, JUnit 5 provides two out-of-the-box implementations of the test engine
    API. These engines are the remaining components of the JUnit 5 architecture, namely:'
  prefs: []
  type: TYPE_NORMAL
- en: Vintage
  prefs: []
  type: TYPE_NORMAL
- en: Test engine that provides backward compatibility with legacy JUnit tests (i.e.,
    versions 3 and 4).
  prefs: []
  type: TYPE_NORMAL
- en: Jupiter
  prefs: []
  type: TYPE_NORMAL
- en: Test engine that provides a new programming and extension model
  prefs: []
  type: TYPE_NORMAL
- en: Jupiter is a relevant component of JUnit 5 since it provides a brand-new API
    to develop tests using a robust programming model. Some of the features of this
    programming model are parameterized tests, parallel execution, tagging and filtering,
    ordered tests, repeated and nested tests, and rich capabilities to disable (ignore)
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like JUnit 4, Jupiter also uses Java annotations to declare test cases. For
    instance, the annotation to identify methods with testing logic is also `@Test`.
    The name of the rest of the annotations for the basic test lifecycle is a bit
    different in Jupiter: `@BeforeAll`, `@BeforeEach`, `@AfterEach`, and `@AfterAll`.
    As you can see in [Figure 2-5](#junit5-test-lifecycle), each of these annotations
    follows the same workflow of JUnit 4.'
  prefs: []
  type: TYPE_NORMAL
- en: '![hosw 0205](assets/hosw_0205.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-5\. JUnit 5 test lifecycle
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Thus, the structure of a Jupiter test using Selenium WebDriver and WebDriverManager
    is quite similar in JUnit 4 and JUnit 5\. In addition to the change in the setup
    and teardown annotation names, the test methods (and their lifecycle) are not
    required to be `public` in the Jupiter programming model.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This book will teach you the basics of Jupiter applied to end-to-end testing
    with Selenium WebDriver. See the *hello world* example in the next section for
    a complete test based on JUnit 5\. Please check the [JUnit 5 documentation](https://junit.org/junit5/docs/current/user-guide)
    for further details.
  prefs: []
  type: TYPE_NORMAL
- en: JUnit 5 with Selenium-Jupiter
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The extension model of Jupiter allows adding custom features to the default
    programming model. To that aim, Jupiter provides an API that developers can extend
    (using interfaces called *extension points*) to provide custom functionality.
    The categories of these extension points are:'
  prefs: []
  type: TYPE_NORMAL
- en: Test lifecycle callbacks
  prefs: []
  type: TYPE_NORMAL
- en: To include custom logic in different moments of the test lifecycle
  prefs: []
  type: TYPE_NORMAL
- en: Parameter resolution
  prefs: []
  type: TYPE_NORMAL
- en: To implement dependency injection (i.e., parameters injected in test methods
    or constructors)
  prefs: []
  type: TYPE_NORMAL
- en: Test templates
  prefs: []
  type: TYPE_NORMAL
- en: To repeat the tests based on a given context
  prefs: []
  type: TYPE_NORMAL
- en: Conditional test execution
  prefs: []
  type: TYPE_NORMAL
- en: To enable or disable tests depending on custom conditions
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling
  prefs: []
  type: TYPE_NORMAL
- en: To manage Java exceptions during the test and its lifecycle
  prefs: []
  type: TYPE_NORMAL
- en: Test instance
  prefs: []
  type: TYPE_NORMAL
- en: To create and process test class instances
  prefs: []
  type: TYPE_NORMAL
- en: Intercepting invocations
  prefs: []
  type: TYPE_NORMAL
- en: To intercept calls to test code (and decide whether or not these calls proceed)
  prefs: []
  type: TYPE_NORMAL
- en: As a Jupiter developer, you can implement your custom extension or use the existing
    ones. [Table 2-3](#jupiter_extensions) shows some examples of Jupiter extensions.
  prefs: []
  type: TYPE_NORMAL
- en: Table 2-3\. Jupiter extensions
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description | License | Maintainer | Website |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| JUnit Pioneer | Extension pack for Jupiter | EPL 2.0 | JUnit Pioneer team
    | [*https://junit-pioneer.org*](https://junit-pioneer.org) |'
  prefs: []
  type: TYPE_TB
- en: '| rerunner-jupiter | Extension for rerunning failed Jupiter tests | Apache
    2.0 | Artem Sokovets | [*https://github.com/artsok/rerunner-jupiter*](https://github.com/artsok/rerunner-jupiter)
    |'
  prefs: []
  type: TYPE_TB
- en: '| MockitoExtension | Jupiter extension for initializing mocks and handling
    stubbings | MIT | Mockito team | [*https://github.com/mockito/mockito*](https://github.com/mockito/mockito)
    |'
  prefs: []
  type: TYPE_TB
- en: '| QuickPerf | Library for evaluating some performance-related properties |
    Apache 2.0 | QuickPerf team | [*https://github.com/quick-perf/quickperf*](https://github.com/quick-perf/quickperf)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Selenium-Jupiter | Jupiter extension for Selenium WebDriver | Apache 2.0
    | Boni García | [*https://bonigarcia.dev/selenium-jupiter*](https://bonigarcia.dev/selenium-jupiter)
    |'
  prefs: []
  type: TYPE_TB
- en: '| SpringExtension | Jupiter extension for the Spring Framework | Apache 2.0
    | Pivotal Software | [*https://spring.io/projects/spring-framework*](https://spring.io/projects/spring-framework)
    |'
  prefs: []
  type: TYPE_TB
- en: 'Selenium-Jupiter is an attractive option in the context of this book since
    it enables using Selenium WebDriver in Jupiter tests seamlessly. The bases of
    Selenium-Jupiter are as follows (see the next section for a *hello world* test
    based on Selenium-Jupiter):'
  prefs: []
  type: TYPE_NORMAL
- en: Reduced boilerplate code in test cases
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to the parameter resolution feature provided by the Jupiter programming
    model, Selenium-Jupiter allows declaring an object of the `WebDriver` hierarchy
    (e.g., `ChromeDriver`, `FirefoxDriver`, etc.) to control web browsers from tests
    as a constructor or test parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Automated driver management through WebDriverManager
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to the test lifecycle callbacks provided by the extension model, the
    use of WebDriverManager is entirely transparent for Selenium-Jupiter users.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced capabilities for end-to-end testing
  prefs: []
  type: TYPE_NORMAL
- en: This includes, for instance, seamless integration with Docker, test templates
    (for cross-browser testing), or troubleshooting and monitoring capabilities (e.g.,
    session recordings or configurable screenshots).
  prefs: []
  type: TYPE_NORMAL
- en: TestNG
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The last unit testing framework I use in this book is TestNG. Some of the more
    significant features that TestNG provides are parallel test execution, test prioritization,
    data-driven testing using custom annotations, and the creation of detailed HTML
    reports.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same way as JUnit 4 and Jupiter, TestNG also uses Java annotations to
    declare tests and their lifecycle (i.e., what happens before and after each test).
    Again, the annotation `@Test` is used to designate test methods. Then, it provides
    the annotations `@BeforeClass` and `@BeforeMethod` to specify the test setup,
    and `@AfterMethod` and `@AfterClass` for the teardown (see [Figure 2-6](#testng-test-lifecycle)).
    In addition, TestNG allows grouping the tests contained in Java classes using
    the following terminology:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Suite* consists of one or more *tests*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Test* consists of one or more *classes*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Class* is a Java class with testing method(s), e.g., annotated with `@Test`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Following this notation, and as represented in [Figure 2-6](#testng-test-lifecycle),
    TestNG provides additional annotations to execute custom logic before and after
    the suite and the test(s).
  prefs: []
  type: TYPE_NORMAL
- en: '![hosw 0206](assets/hosw_0206.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-6\. TestNG test lifecycle
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Fluent assertions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As introduced in [Chapter 1](ch01.html#ch01), there are different libraries
    for assertions. These libraries typically provide a rich set of fluent assertions
    and comprehensive error messages. Among these alternatives, I use the library
    [AssertJ](https://joel-costigliola.github.io/assertj) in the examples repository.
    The reason is twofold. First, we can select the available methods for quickly
    asserting data using the autocompletion feature in IDEs (typically available using
    Ctrl + space after the static method `assertThat`). [Figure 2-7](#assertj-autocomplete-eclipse)
    shows an example of the inspection of this method using an IDE (Eclipse in this
    example).
  prefs: []
  type: TYPE_NORMAL
- en: '![hosw 0207](assets/hosw_0207.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-7\. Manual inspection of the available assertion methods in AssertJ
    using Eclipse
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The second advantage of AssertJ compared to other options is that it allows
    an assertions chain using dot notation. Thanks to this, we can concatenate several
    conditions to create more readable assertions, for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Logging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, I recommend using a logging library to trace your Java code. As you
    may know, logging is a simple way programmers track events when software executes.
    Logging is typically carried out by writing text messages into a file or the standard
    output, and it allows you to trace programs and diagnose problems. Today, it is
    common to use specific libraries to do logging effectively. These libraries provide
    different benefits, such as the level of granularity for messages (e.g., debug,
    warning, or error), timestamping, or configuration capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Hello World
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are ready to put all the pieces explained in this chapter together and implement
    our first end-to-end test. As you may know, a *hello world* program is a simple
    piece of code that many programming languages use to illustrate basic syntax.
    [Example 2-1](#helloworld_jupiter) shows the Selenium WebDriver’s version of this
    classic *hello world*.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The following example uses JUnit 5 as the unit testing framework to embed the
    call to Selenium WebDriver. Remember that you can find the other flavors (i.e.,
    JUnit 4, JUnit 5 with Selenium-Jupiter, and TestNG) in the [examples repository](https://github.com/bonigarcia/selenium-webdriver-java).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-1\. Hello world using Chrome and JUnit 5
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_preparing_for_testing_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We declare a Java attribute using the interface `WebDriver`. We use this variable
    in tests to control web browsers with Selenium WebDriver.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_preparing_for_testing_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: In the setup for all tests within this class (i.e., executed once), we call
    WebDriverManager to manage the required driver. In this example, since we use
    Chrome as a browser, we need to resolve chromedriver.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_preparing_for_testing_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: In the test setup (executed once per test method), we instantiate the `WebDriver`
    object to control Chrome. In other words, we create an object of the type `ChromeDriver`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_preparing_for_testing_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The test logic uses the Selenium WebDriver API through the `driver` variable.
    First, the test exercises the System Under Test (SUT). To that aim, we open the
    [practice site](https://bonigarcia.dev/selenium-webdriver-java) using the `get()`
    method of our `webdriver` variable (which represents a Chrome browser, in this
    case).
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_preparing_for_testing_CO1-5)'
  prefs: []
  type: TYPE_NORMAL
- en: We get the web page title using the method `getTitle()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_preparing_for_testing_CO1-6)'
  prefs: []
  type: TYPE_NORMAL
- en: For debugging purposes, we log that title using the `DEBUG` level.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_preparing_for_testing_CO1-7)'
  prefs: []
  type: TYPE_NORMAL
- en: The last part of the test contains an AssertJ assertion. In this case, we verify
    the web page title is as expected.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_preparing_for_testing_CO1-8)'
  prefs: []
  type: TYPE_NORMAL
- en: At the end of each test, we need to close the browser. To that aim, we can invoke
    the method `quit()` of the `driver` object (see more info about how to close `WebDriver`
    objects in [Chapter 3](ch03.html#ch03)).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can execute this test in different ways. I recommend getting a local copy
    of the examples repository. You can use the GitHub website to download a complete
    copy of the source code. Alternatively, you can use Git to clone the repo using
    the shell, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Then, you can use Maven or Gradle (as explained in [Appendix C](app03.html#appendix03))
    to run the tests from the shell. In addition, you can import the cloned Maven/Gradle
    projects into an IDE. IDEs provide built-in capabilities to execute the test from
    their GUI. For instance, [Figure 2-8](#hello-world-eclipse) shows a screenshot
    of the execution of the previous *hello world* test in Eclipse (in this case,
    using the command Run → Run As → JUnit Test). Notice that in the integrated console
    (at the bottom of the picture), the first traces correspond to the driver resolution
    by WebDriverManager. Then, the browser starts through chromedriver, and finally,
    we can see the test traces (concretely, the web page title).
  prefs: []
  type: TYPE_NORMAL
- en: '![hosw 0208](assets/hosw_0208.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-8\. Screenshot of the execution of the Selenium WebDriver’s *hello
    world* in Eclipse
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The *hello world* versions using JUnit 4 and TestNG are almost identical to
    JUnit 5 but use different annotations for the test lifecycle (e.g., JUnit 4’s
    `@Before` instead of JUnit 5’s `@BeforeEach`, etc.). Regarding JUnit 5 plus Selenium-Jupiter,
    the code is a bit more compact. [Example 2-2](#helloworld_seljup) shows this *hello
    world* version. As you can see, there is no need to declare the setup and teardown.
    We simply need to declare the `WebDriver` object we want as a test parameter (`FirefoxDriver`
    in this case), and Selenium-Jupiter takes care of the driver management (also
    with WebDriverManager), object instantiation, and browser disposal.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-2\. Hello world using Firefox and Selenium-Jupiter
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Using Additional Browsers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to what I am calling *main* browsers in this book (i.e., Chrome,
    Edge, and Firefox), the example repository contains the *hello world* test using
    other browsers: Opera, Chromium, Safari, and HtmlUnitDriver (a Selenium WebDriver–compatible
    driver for the HtmlUnit headless browser). These tests, contained in the package
    `helloworld_otherbrowsers` of this repository, are slightly different from the
    raw *hello world* versions. For instance, [Example 2-3](#helloworld_opera_junit5)
    shows the JUnit 5 class setup of the *hello world* test using Opera. Since this
    browser might not be available in the machine running the test (e.g., Opera is
    not available in GitHub Actions), I use *assumptions* to disable the test in runtime
    conditionally.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-3\. Class setup using Opera and JUnit 5
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_preparing_for_testing_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We use WebDriverManager to locate the browser path.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_preparing_for_testing_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: If this path does not exist, we assume the browser is not installed in the system,
    so the test is skipped (using an AssertJ assumption).
  prefs: []
  type: TYPE_NORMAL
- en: As usual, you can find this test using other unit testing frameworks in the
    examples repository. The JUnit 5 and TestNG versions use the equivalent test setup
    to the previous snippet. Nevertheless, there is a difference when using JUnit
    5 plus Selenium-Jupiter. As you can see in [Example 2-4](#helloworld_safari_seljup),
    Selenium-Jupiter simplifies the assumption logic by using a custom annotation
    (called `EnabledIfBrowserAvailable`) to disable tests depending on the browser
    availability (Safari in this example).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-4\. Hello world using Safari and JUnit 5 plus Selenium-Jupiter
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: To control Safari with Selenium WebDriver, we need to configure Safari manually
    to authorize remote automation. To that aim, first, we show the develop menu by
    clicking on the menu option Safari → Preferences → Advanced tab. Then, we enable
    the “Show Develop Menu” checkbox. After that, the “Develop” menu should appear.
    Finally, we click on the option “Allow Remote Automation” (see [Figure 2-9](#safari-macos)).
  prefs: []
  type: TYPE_NORMAL
- en: '![hosw 0209](assets/hosw_0209.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-9\. Enable Safari remote automation on macOS
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Summary and Outlook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter provides the foundations for developing end-to-end tests for web
    applications using Selenium WebDriver and Java. The first important decision you
    need to make is to decide in which unit testing framework to embed the Selenium
    WebDriver calls to implement these tests. For the sake of diversity and completeness,
    I propose four options in this book: JUnit 4, JUnit 5, JUnit 5 plus Selenium-Jupiter,
    and TestNG. They are all equivalent for basic Selenium WebDriver tests. For more
    advanced uses, [Chapter 8](ch08.html#ch08) will cover the specific features of
    each testing framework that could be relevant to WebDriver tests (e.g., parameterized
    tests for cross-browser testing). Another decision you should make is to choose
    a build tool. In this book, I propose two options: Maven and Gradle. Once again,
    both are similar for standard development practices.'
  prefs: []
  type: TYPE_NORMAL
- en: The second part of this book is focused on the Selenium WebDriver API and begins
    next. To get started, [Chapter 3](ch03.html#ch03) covers the fundamental notions
    of the Selenium WebDriver API in terms of WebDriver objects, web elements location,
    user impersonation (keyboard and mouse actions), and waiting strategies. As usual,
    this chapter is guided by code examples available on the repository hosted in
    GitHub.
  prefs: []
  type: TYPE_NORMAL
