- en: Chapter 2\. Preparing for Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。测试准备
- en: This chapter aims to implement your first end-to-end test using Selenium WebDriver
    and the Java language. To do that, we first review the technical requirements
    in terms of previous knowledge, hardware, and software. Second, this chapter provides
    an overview for setting up a Java project that includes Selenium WebDriver tests.
    You can use a build tool like Maven or Gradle to ease the project setup. Finally,
    you will learn to implement a basic end-to-end test with Selenium WebDriver, i.e.,
    a *hello world* test. We will implement this test in several flavors, using different
    web browsers (such as Chrome, Edge, or Firefox) and unit testing frameworks (JUnit
    and TestNG). Remember that every code example in this book is available in an
    [open source GitHub repository](https://github.com/bonigarcia/selenium-webdriver-java).
    Thus, you can reuse the content and configuration of this repository as the foundation
    for your own tests.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章旨在使用Selenium WebDriver和Java语言实现你的第一个端到端测试。为此，我们首先回顾了技术要求，包括先前的知识、硬件和软件。其次，本章概述了设置包含Selenium
    WebDriver测试的Java项目的概述。您可以使用类似Maven或Gradle的构建工具来简化项目设置。最后，您将学习使用Selenium WebDriver实现基本的端到端测试，即*hello
    world*测试。我们将使用不同的Web浏览器（如Chrome、Edge或Firefox）和单元测试框架（JUnit和TestNG）以多种风格实现此测试。请记住，本书中的每个代码示例都可以在[开源GitHub存储库](https://github.com/bonigarcia/selenium-webdriver-java)中找到。因此，您可以重用此存储库的内容和配置作为自己测试的基础。
- en: Requirements
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要求
- en: 'The first requirement to start using Selenium WebDriver with Java is comprehending
    the Java language and object-oriented programming. It is not necessary to be an
    expert, but basic knowledge about it is required. Then, you can use Selenium WebDriver
    in any mainstream operating system: Windows, Linux, or macOS. Therefore, you can
    select the computer type you prefer. In principle, there are no specific requirements
    about its hardware in terms of memory, CPU, hard disk, etc., so any mid-tier computer
    will do.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Java启动Selenium WebDriver的第一个要求是理解Java语言和面向对象编程。不必成为专家，但需要基本的知识。然后，您可以在任何主流操作系统上使用Selenium
    WebDriver：Windows、Linux或macOS。因此，您可以选择您喜欢的计算机类型。原则上，在内存、CPU、硬盘等方面对硬件没有特定要求，因此任何中档计算机都可以胜任。
- en: Java Virtual Machine
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java虚拟机
- en: Next, you need a Java Virtual Machine (JVM) installed on your computer. There
    are two types of distributions for the JVM. The first option is the Java Runtime
    Environment (JRE), which includes the JVM and the Java standard API. The second
    option is the Java Development Kit (JDK), which is the JRE plus a Software Development
    Kit (SDK) for Java (such as the `javac` compiler and other tools). Since we are
    developing in Java, I recommend using JDK (although some IDEs also incorporate
    an SDK for Java). For the Java version, I recommend using at least JDK 8 since
    it is the long-term support version commonly supported in many Java projects at
    the time of this writing.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要在计算机上安装Java虚拟机（JVM）。有两种类型的JVM分发版。第一种选择是Java运行时环境（JRE），其中包括JVM和Java标准API。第二种选择是Java开发工具包（JDK），它是JRE加上Java的软件开发工具包（例如`javac`编译器和其他工具）。由于我们是在Java中开发，我建议使用JDK（尽管一些集成开发环境也包含了Java的SDK）。对于Java版本，我建议至少使用JDK
    8，因为它是在我写作时期通常受到许多Java项目支持的长期支持版本。
- en: Text Editor or IDE
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文本编辑器或集成开发环境（IDE）
- en: To code our Java tests, we need a text editor or IDE. IDEs provide an excellent
    experience for development because they have a full-fledged environment (for coding,
    running, debugging, autocompletion, etc.). Nevertheless, you can get similar practice
    using any text editor you like, used in conjunction with command-line tools (for
    running, debugging, etc.). Overall, it depends on your personal preferences to
    choose one or another. Some popular alternatives for text editors are [Sublime
    Text](https://www.sublimetext.com), [Atom](https://atom.io), [Notepad++](https://notepad-plus-plus.org),
    or [Vim](https://www.vim.org), among others. IDEs include [Eclipse](https://www.eclipse.org),
    [IntelliJ IDEA](https://www.jetbrains.com/idea), [NetBeans](https://netbeans.apache.org),
    or [Visual Studio Code](https://code.visualstudio.com).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写我们的 Java 测试，我们需要一个文本编辑器或 IDE。IDE 提供了优秀的开发体验，因为它们具有完整的环境（用于编码、运行、调试、自动完成等）。尽管如此，你可以使用任何你喜欢的文本编辑器，结合命令行工具（用于运行、调试等）来获得类似的实践。总体而言，选择使用哪种工具取决于个人偏好。一些流行的文本编辑器的替代方案包括
    [Sublime Text](https://www.sublimetext.com)、[Atom](https://atom.io)、[Notepad++](https://notepad-plus-plus.org)
    或 [Vim](https://www.vim.org) 等。IDE 包括 [Eclipse](https://www.eclipse.org)、[IntelliJ
    IDEA](https://www.jetbrains.com/idea)、[NetBeans](https://netbeans.apache.org)
    或 [Visual Studio Code](https://code.visualstudio.com)。
- en: Browsers and Drivers
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浏览器和驱动程序
- en: 'An initial way to carry out automation with Selenium WebDriver is to use local
    browsers. I consider the following browsers for this book: Chrome, Edge, and Firefox.
    I refer to them as *main browsers* for several reasons. First, they are very popular
    worldwide, and because we are testing web applications with Selenium WebDriver,
    we want to use the same browser as our potential users. Second, these browsers
    are *evergreen* (i.e., they upgrade themselves automatically). Third, these browsers
    are available for the major operating systems: Windows, Linux, and macOS (unlike
    Safari, which is also a popular browser but is only available on macOS). Lastly,
    these browsers are available in the Continuous Integration (CI) environment used
    in the GitHub repository (i.e., GitHub Actions).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Selenium WebDriver 进行自动化的一个最初的方法是使用本地浏览器。我考虑在本书中使用以下浏览器：Chrome、Edge 和 Firefox。我称它们为
    *主要浏览器*，原因有几点。首先，它们在全球范围内非常流行，因为我们使用 Selenium WebDriver 测试 Web 应用程序时，希望使用与潜在用户相同的浏览器。其次，这些浏览器是
    *常绿* 的（即它们自动升级）。第三，这些浏览器适用于主要操作系统：Windows、Linux 和 macOS（不像 Safari，它也是一款流行的浏览器，但仅在
    macOS 上可用）。最后，这些浏览器在 GitHub 仓库使用的持续集成（CI）环境中可用（即 GitHub Actions）。
- en: 'The last requirement for controlling web browsers with Selenium WebDriver is
    the driver binaries: chromedriver (for Chrome), msedgedriver (for Edge), and geckodriver
    (for Firefox). As discussed in [Chapter 1](ch01.html#ch01), driver management
    involves three steps: download, setup, and maintenance. To avoid the potential
    problems explained in that chapter, I strongly recommend automating this process
    with [WebDriverManager](https://bonigarcia.dev/webdrivermanager).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 控制 web 浏览器使用 Selenium WebDriver 的最后要求是驱动程序二进制文件：chromedriver（用于 Chrome）、msedgedriver（用于
    Edge）和 geckodriver（用于 Firefox）。如 [第 1 章](ch01.html#ch01) 所述，驱动程序管理涉及三个步骤：下载、设置和维护。为了避免该章节中解释的潜在问题，我强烈建议使用
    [WebDriverManager](https://bonigarcia.dev/webdrivermanager) 自动化此过程。
- en: Tip
  id: totrans-11
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: '[Appendix B](app02.html#appendix02) provides fine-grained details about the
    automated driver management process performed by WebDriverManager. In addition,
    and just in case you need it for some reason, this appendix explains how to carry
    out the driver management manually.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[附录 B](app02.html#appendix02) 提供了由 WebDriverManager 执行的自动驱动程序管理过程的详细信息。此外，以防出于某些原因你需要手动执行驱动程序管理，本附录也解释了如何进行。'
- en: Build Tools
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建工具
- en: 'Another important component is the *build tool*. Build tools are software utilities
    used to automate the creation of executable applications from source code. These
    tools ease project management in terms of dependencies management, compilation,
    packaging, test execution, and deployment. Overall, build tools are a convenient
    way to automate the development of software projects, both in build servers (e.g.,
    GitHub Actions) and developer machines. Therefore, I highly recommend using a
    build tool to set up your project. The alternatives we cover in this book are:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要组成部分是 *构建工具*。构建工具是用于从源代码自动创建可执行应用程序的软件实用程序。这些工具在依赖管理、编译、打包、测试执行和部署方面简化了项目管理。总体而言，构建工具是自动化软件项目开发的便捷方式，无论是在构建服务器（如
    GitHub Actions）还是开发者机器上。因此，我强烈建议使用构建工具来设置项目。本书中涵盖的替代方案包括：
- en: '[Maven](https://maven.apache.org)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[Maven](https://maven.apache.org)'
- en: An open source build automation tool maintained by the Apache Software Foundation.
    It is used primarily for Java projects, although it also supports other languages
    such as C#, Ruby, or Scala.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一个由 Apache 软件基金会维护的开源构建自动化工具。它主要用于 Java 项目，尽管也支持其他语言，如 C#、Ruby 或 Scala。
- en: '[Gradle](https://gradle.org)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[Gradle](https://gradle.org)'
- en: Another open source build automation tool for software development. It supports
    Java and other languages such as Kotlin, Groovy, Scala, C/C++, or JavaScript.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个用于软件开发的开源构建自动化工具。它支持 Java 和其他语言，如 Kotlin、Groovy、Scala、C/C++ 或 JavaScript。
- en: The recommended versions are Maven 3+ and Gradle 6+. For completeness, I use
    both build tools in the example repository. Again, the final choice to use one
    or another depends on your preferences.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐的版本是 Maven 3+ 和 Gradle 6+。为了完整起见，在示例仓库中我同时使用了两种构建工具。再次强调，最终选择使用哪一种取决于你的偏好。
- en: Note
  id: totrans-20
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you plan to use an IDE for developing and running your tests, a build tool
    is not strictly necessary. Nevertheless, I recommend installing at least one of
    these tools in your computer to replicate the environment typically used in build
    servers (e.g., Jenkins, GitHub Actions, etc.).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果打算使用 IDE 进行开发和运行测试，那么构建工具并非必需。不过，我建议你至少在计算机上安装其中一种工具，以复制通常在构建服务器上使用的环境（例如
    Jenkins、GitHub Actions 等）。
- en: Optional Software
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可选软件
- en: In addition to the software already explained, some other programs are convenient
    to make the most of this book. First, you can use [Git](https://git-scm.com) for
    source code management. Since the test examples presented in this book are available
    on GitHub, you can use Git to fork (or clone) and update this repository.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 除了已经解释的软件外，还有一些其他程序可以帮助你更好地利用本书。首先，你可以使用 [Git](https://git-scm.com) 进行源代码管理。由于本书中的测试示例可在
    GitHub 上获得，你可以使用 Git 进行分支（或克隆）和更新此仓库。
- en: The second optional tool is [Docker](https://www.docker.com). In this book,
    I show you how to use Docker to execute containerized browsers (see [Chapter 6](ch06.html#ch06)).
    For this reason, I strongly recommend you install a *Docker Engine* on your computer
    (it is available for Linux, macOS, and Windows 10).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个可选工具是 [Docker](https://www.docker.com)。在本书中，我展示了如何使用 Docker 来执行容器化的浏览器（见
    [第 6 章](ch06.html#ch06)）。因此，我强烈建议你在计算机上安装 *Docker Engine*（适用于 Linux、macOS 和 Windows
    10）。
- en: Finally, you can use different web browsers if you need them. In addition to
    the main browsers (Chrome, Edge, and Firefox), it is possible to use other browsers
    with Selenium WebDiver, such as [Safari](https://www.apple.com/safari) in macOS,
    or [Opera](https://www.opera.com), [Chromium](https://www.chromium.org), and [HtmlUnit](https://htmlunit.sourceforge.io)
    (a headless browser, i.e., GUI-less browser) in any operating system.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果需要，你可以使用不同的网页浏览器。除了主流浏览器（Chrome、Edge 和 Firefox）外，还可以使用其他浏览器与 Selenium WebDriver
    结合使用，如 macOS 中的 [Safari](https://www.apple.com/safari)，或任何操作系统中的 [Opera](https://www.opera.com)，[Chromium](https://www.chromium.org)，以及
    [HtmlUnit](https://htmlunit.sourceforge.io)（一个无界面浏览器，即无 GUI 浏览器）。
- en: Project Setup
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目设置
- en: You can find all the code examples of this book in [a GitHub repository](https://github.com/bonigarcia/selenium-webdriver-java).
    This repository is open source, released under the terms of the Apache 2.0 license.
    The repository has multiple aims. First, it is convenient to group all the examples
    in a single site. Second, you can use its setup (Maven or Gradle) as a skeleton
    for your projects.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [GitHub 仓库](https://github.com/bonigarcia/selenium-webdriver-java) 中找到本书的所有代码示例。该仓库是开源的，使用
    Apache 2.0 许可发布。该仓库有多个目的。首先，将所有示例集中在一个站点中非常方便。其次，你可以使用它的设置（Maven 或 Gradle）作为你项目的骨架。
- en: Tip
  id: totrans-28
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: The following subsections describe the general requirements to create a Java
    project containing Selenium WebDriver tests. [Appendix C](app03.html#appendix03)
    provides low-level details about the configuration of the examples repositories.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的子节描述了创建包含 Selenium WebDriver 测试的 Java 项目的一般要求。[附录 C](app03.html#appendix03)
    提供了关于示例仓库配置的低级细节。
- en: Project Layout
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目布局
- en: The *project layout* is the directory structure used to store the different
    assets of a software project (e.g., source code, binary files, static resources,
    and so on). Maven and Gradle use an equivalent layout for Java projects. We can
    execute the examples repository with both build tools, thanks to this.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*项目布局*是用于存储软件项目的不同资产（例如源代码、二进制文件、静态资源等）的目录结构。Maven 和 Gradle 在 Java 项目中使用等效的布局。我们可以使用这一布局在两种构建工具中执行示例仓库，多亏了这一点。'
- en: 'As illustrated in [Figure 2-1](#project-layout), the following set of folders
    (labeled as *scaffolding folders*) are identical in both build tools:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如图[Figure 2-1](#project-layout)所示，以下一组文件夹（称为*脚手架文件夹*）在两个构建工具中完全相同：
- en: '`src/main/java`'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/java`'
- en: Application source code (i.e., Java files)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序源代码（即Java文件）
- en: '`src/main/resources`'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/resources`'
- en: Application resources files (i.e., properties, configuration files, etc.)
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序资源文件（即属性、配置文件等）
- en: '`src/test/java`'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/test/java`'
- en: Test source code (i.e., Java files used for testing)
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 测试源代码（即用于测试的Java文件）
- en: '`src/test/resources`'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/test/resources`'
- en: Test resources files (i.e., additional assets used for testing)
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 测试资源文件（即用于测试的附加资产）
- en: '![hosw 0201](assets/hosw_0201.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![hosw 0201](assets/hosw_0201.png)'
- en: Figure 2-1\. Project layout in Maven and Gradle
  id: totrans-42
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-1\. Maven和Gradle中的项目布局
- en: 'The rest of the project layout is different in both build tools. The first
    difference is the configuration file. On the one hand, this file is unique and
    called `pom.xml` (Project Object Model) in Maven. On the other hand, there are
    two files in Gradle for configuration, called `settings.gradle` and `build.gradle`.
    The second difference between Maven and Gradle is the output folder. In both cases,
    the build tools created this folder to save the resulting build (i.e., compiled
    classes, resulting packaged files, etc.). The name of this folder is `target`
    in Maven and `build` in Gradle. Finally, Gradle contains a set of folders and
    files for the so-called Gradle *wrapper*. This wrapper is a script file (called
    `gradlew` for Unix-like systems and `gradlew.bat` for Windows) that provides the
    following benefits:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 项目布局的其余部分在两个构建工具中不同。第一个区别是配置文件。一方面，该文件在Maven中是唯一的，称为`pom.xml`（项目对象模型）。另一方面，在Gradle中有两个文件用于配置，称为`settings.gradle`和`build.gradle`。Maven和Gradle之间的第二个区别是输出文件夹。在两种情况下，构建工具都创建了此文件夹以保存生成的构建（即编译后的类、生成的打包文件等）。该文件夹在Maven中称为`target`，在Gradle中称为`build`。最后，Gradle包含一组文件夹和文件，用于所谓的Gradle
    *包装器*。这个包装器是一个脚本文件（对Unix-like系统称为`gradlew`，对Windows系统称为`gradlew.bat`），提供以下好处：
- en: Build a project without installing Gradle on the local machine
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本地机器上构建项目而无需安装Gradle
- en: Require use of a given version (which can be different from the locally installed
    instance of Gradle)
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要使用给定版本（可以与本地安装的Gradle实例不同）
- en: Upgrade to a new version easily by changing the wrapper artifacts (in folder
    `gradle/wrapper`)
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过更改包装器工件（在`gradle/wrapper`文件夹中）轻松升级到新版本
- en: As of version 4, Maven has adopted the wrapper concept using the `mvnw` script.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本4开始，Maven采用了使用`mvnw`脚本的包装概念。
- en: Note
  id: totrans-48
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: It is beyond the scope of this book to explain all the features provided by
    Maven and Gradle. Nevertheless, you can find more information about their build
    lifecycle and typical commands in [Appendix C](app03.html#appendix03). For further
    information, consider reading the official [Maven](https://maven.apache.org/guides)
    and [Gradle](https://docs.gradle.org) documentation.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 本书范围不包括解释Maven和Gradle提供的所有功能。然而，您可以在附录 [C](app03.html#appendix03) 中找到有关它们的构建生命周期和典型命令的更多信息。如需进一步了解，请阅读官方的[Maven](https://maven.apache.org/guides)和[Gradle](https://docs.gradle.org)文档。
- en: Dependencies
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖项
- en: 'The dependencies of a software project are the required libraries or plug-ins.
    Among other features, build tools enable the automated management of the project
    dependencies. To that aim, we need to specify the *coordinates* of such dependencies
    in the project configuration file (see the following subsections for specifics
    on Maven and Gradle). The coordinates of a Java project are a group of three labels
    that univocally identify this project (e.g., a library, plug-in, etc.), namely:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 软件项目的依赖项是所需的库或插件。构建工具除了其他功能外，还能够自动管理项目依赖关系。为此，我们需要在项目配置文件中指定这些依赖关系的*坐标*（请参阅Maven和Gradle的具体子部分以获取详细信息）。Java项目的坐标是一组三个标签，唯一标识该项目（例如，库、插件等），即：
- en: '`groupId`'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`groupId`'
- en: Organization, company, person, etc., that created the project.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 创建项目的组织、公司、个人等。
- en: '`artifactId`'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`artifactId`'
- en: Unique name that identifies the project.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 用于标识项目的唯一名称。
- en: '`version`'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`version`'
- en: Particular release of the project. By default, I recommend you use the latest
    version of every release.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 项目的特定版本。默认情况下，建议您使用每个发布的最新版本。
- en: This section explains the Java dependencies I use in the examples repository.
    First, of course, we need Selenium WebDriver to carry out browser automation.
    This dependency is the only one strictly mandatory. Then, I recommend using additional
    dependencies for automated driver management utility, unit testing framework,
    fluent assertions, and logging. The remainder of this section explains the motivation
    and basic use of each of these utilities.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 本节解释了我在示例库中使用的 Java 依赖项。首先，当然，我们需要 Selenium WebDriver 来进行浏览器自动化。这个依赖项是唯一强制性的。然后，我建议使用额外的依赖项用于自动化驱动程序管理实用程序、单元测试框架、流畅断言和日志记录。本节的其余部分解释了每个实用程序的动机和基本使用方法。
- en: Selenium WebDriver
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Selenium WebDriver
- en: One of the most relevant concepts of Selenium WebDriver is the `WebDriver` hierarchy,
    which is a collection of classes aimed at controlling different web browsers.
    As you can see in [Figure 2-2](#webdriver-hierarchy), this hierarchy follows the
    object-oriented programming paradigm. On the top, we find the `WebDriver` interface,
    the parent of the whole structure. The lower part of the hierarchy corresponds
    to Java classes that drive single browsers. For instance, we need to use an instance
    of the class `ChromeDriver` to control a local Chrome browser. [Table 2-1](#webdriver-hierarchy-description)
    shows a comprehensive summary of the main classes of the `WebDriver` hierarchy
    and their corresponding target browsers.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium WebDriver 最相关的概念之一是 `WebDriver` 层次结构，它是一组用于控制不同网页浏览器的类集合。正如您在[图 2-2](#webdriver-hierarchy)中所见，该层次结构遵循面向对象的编程范式。在顶部，我们找到
    `WebDriver` 接口，它是整个结构的父接口。层次结构的下部对应于驱动单个浏览器的 Java 类。例如，我们需要使用 `ChromeDriver` 类的实例来控制本地的
    Chrome 浏览器。[表 2-1](#webdriver-hierarchy-description)展示了 `WebDriver` 层次结构主要类及其对应的目标浏览器的全面摘要。
- en: Table 2-1\. Description of the `WebDriver` hierarchy
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-1\. `WebDriver` 层次结构描述
- en: '| Package | Class | Browser |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 包 | 类 | 浏览器 |'
- en: '| --- | --- | --- |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '|'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE0]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '|'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE1]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '| Chrome |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| Chrome |'
- en: '|'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '|'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '| Edge |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| Edge |'
- en: '|'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '|'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '| Firefox |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| Firefox |'
- en: '|'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '|'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '| Safari |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| Safari |'
- en: '|'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '|'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '| Opera |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| Opera |'
- en: '|'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '|'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '| Internet Explorer |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| Internet Explorer |'
- en: '|'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '|'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '| Remote browsers (see [Chapter 6](ch06.html#ch06)) |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 远程浏览器（参见[第 6 章](ch06.html#ch06)） |'
- en: '![hosw 0202](assets/hosw_0202.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![hosw 0202](assets/hosw_0202.png)'
- en: Figure 2-2\. Hierarchy of the `WebDriver` object
  id: totrans-100
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-2\. `WebDriver` 对象的层次结构
- en: Automated driver management
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动化驱动程序管理
- en: It is mandatory to resolve the corresponding driver before instantiating an
    object of the `WebDriver` hierarchy. For example, to control Chrome with `ChromeDriver`,
    we first need to have installed this browser on the local machine. Second, we
    need to manage chromedriver. To avoid the potential problems related to manual
    driver management (see [Chapter 1](ch01.html#ch01)), I recommend carrying out
    the whole driver management process (download, setup, and maintenance) in an automated
    manner. Concerning Java, the reference implementation is [WebDriverManager](https://bonigarcia.dev/webdrivermanager),
    a Selenium WebDriver helper library that allows automated driver management. This
    section explains how to use WebDriverManager as a Java dependency.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在实例化 `WebDriver` 层次结构对象之前，解析相应的驱动程序是强制性的。例如，要使用 `ChromeDriver` 控制 Chrome，我们首先需要在本地机器上安装这个浏览器。其次，我们需要管理
    chromedriver。为了避免手动驱动程序管理可能出现的问题（参见[第 1 章](ch01.html#ch01)），建议完全自动化驱动程序管理过程（下载、设置和维护）。关于
    Java，推荐实现是 [WebDriverManager](https://bonigarcia.dev/webdrivermanager)，这是一个 Selenium
    WebDriver 辅助库，允许自动化驱动程序管理。本节解释了如何将 WebDriverManager 作为 Java 依赖项使用。
- en: 'Once the WebDriverManager dependency is resolved in our project (see [Appendix C](app03.html#appendix03)
    for the configuration details), we can use the WebDriverManager API to manage
    drivers. This API provides a set of singletons (called *managers*) to download,
    set up, and maintain drivers. These singletons are accessible through the `WebDriverManager`
    class. For instance, we need to invoke the method `chromedriver()` to manage the
    driver required by Chrome, i.e., chromedriver, as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的项目解析了 WebDriverManager 的依赖项（请参见[附录 C](app03.html#appendix03)获取配置详细信息），我们就可以使用
    WebDriverManager API 来管理驱动程序。该 API 提供了一组单例（称为*管理器*），用于下载、设置和维护驱动程序。这些单例可通过 `WebDriverManager`
    类访问。例如，我们需要调用 `chromedriver()` 方法来管理 Chrome 所需的驱动程序，即 chromedriver，如下所示：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[Table 2-2](#wdm-calls) summarizes the basic WebDriverManager calls for all
    the supported browsers. In addition to these basic calls (i.e., the method `setup()`),
    WebDriverManager exposes a fluent API for advanced configuration. See [Appendix B](app02.html#appendix02)
    for more details about the WebDriverManager methodology, configuration capabilities,
    and other uses, such as a command-line interface tool (from the shell), as a server
    (using a RESTlike [REpresentational State Transfer] API), as an agent (using Java
    instrumentation), or as a Docker container.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[表格 2-2](#wdm-calls) 总结了所有支持的浏览器的基本 WebDriverManager 调用。除了这些基本调用（即方法 `setup()`）外，WebDriverManager
    还公开了一个流畅的 API 用于高级配置。有关 WebDriverManager 方法论、配置能力及其他用途的更多详细信息，请参阅 [附录 B](app02.html#appendix02)，例如作为一个命令行接口工具（从
    shell 中）、作为服务器（使用类似 REST 的 API）、作为代理（使用 Java 仪器化）或作为 Docker 容器。'
- en: Table 2-2\. WebDriverManager basic calls
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 2-2\. WebDriverManager 基本调用
- en: '| WebDriverManager basic call | Browser | Driver |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| WebDriverManager 基本调用 | 浏览器 | 驱动程序 |'
- en: '| --- | --- | --- |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '|'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '| Chrome | chromedriver |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| Chrome | chromedriver |'
- en: '|'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '| Edge | msedgedriver |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| Edge | msedgedriver |'
- en: '|'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '| Firefox | geckodriver |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| Firefox | geckodriver |'
- en: '|'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '| Opera | operadriver |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| Opera | operadriver |'
- en: '|'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '| Chromium | chromedriver |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| Chromium | chromedriver |'
- en: '|'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '| Internet Explorer | IEDriverServer |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| Internet Explorer | IEDriverServer |'
- en: Unit testing frameworks
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单元测试框架
- en: 'As explained in [Chapter 1](ch01.html#ch01), unit testing frameworks are the
    basis for creating different types of tests. This book will teach you how to implement
    end-to-end tests for web applications using Selenium WebDriver. Hence, I suggest
    embedding the Selenium WebDriver calls within tests created with a particular
    unit testing framework. The alternative I recommend is one of these options: JUnit
    4, JUnit 5 (alone or in conjunction with Selenium-Jupiter, which is an extension
    for Selenium WebDriver), or TestNG. The following subsections provide more details
    about these alternatives. My advice is to focus on the unit testing framework
    and the build tool you prefer to continue practicing with the examples presented
    in the rest of the book.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [第 1 章](ch01.html#ch01) 中所解释的，单元测试框架是创建不同类型测试的基础。本书将教您如何使用 Selenium WebDriver
    为 Web 应用程序实现端到端测试。因此，我建议将 Selenium WebDriver 调用嵌入到使用特定单元测试框架创建的测试中。我推荐的备选方案之一是：JUnit
    4、JUnit 5（单独或与 Selenium-Jupiter 结合，后者是 Selenium WebDriver 的扩展）或 TestNG。以下子章节提供了有关这些替代方案的更多详细信息。我的建议是专注于您喜欢的单元测试框架和构建工具，以继续练习本书其余部分中呈现的示例。
- en: JUnit 4
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: JUnit 4
- en: JUnit is a unit testing framework for Java created by Erich Gamma and Kent Beck
    in 1999\. It is considered the de facto standard framework for developing tests
    in Java. In JUnit, a *test* is a method within a Java class used for testing.
    As of JUnit 4, Java annotations are the building blocks for developing JUnit tests.
    The fundamental annotation of JUnit 4 is `@Test` since it allows identifying the
    method(s) that contain the test logic (i.e., the code used to exercise and verify
    a piece of software). In addition, there are other annotations to identify the
    methods used for the setup (i.e., what happens before the tests) and the teardown
    (i.e., what happens after the tests).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 是由 Erich Gamma 和 Kent Beck 于 1999 年创建的 Java 单元测试框架。它被认为是在 Java 中开发测试的事实标准框架。在
    JUnit 中，*测试* 是一个用于测试的 Java 类中的方法。在 JUnit 4 中，Java 注解是开发 JUnit 测试的构建块。JUnit 4 的基本注解是
    `@Test`，因为它允许标识包含测试逻辑的方法（即用于执行和验证软件的代码）。此外，还有其他注解用于标识用于设置（即测试前发生的事情）和拆卸（即测试后发生的事情）的方法。
- en: '`@BeforeClass` is executed once before all tests.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@BeforeClass` 在所有测试之前执行一次。'
- en: '`@Before` is executed before each test.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Before` 在每个测试之前执行。'
- en: '`@After` is executed after each test.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@After` 在每个测试之后执行。'
- en: '`@BeforeClass` is executed once after all tests.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@BeforeClass` 在所有测试之前执行一次。'
- en: '[Figure 2-3](#junit4-test-lifecycle) shows a graphical representation of the
    basic test lifecycle in JUnit 4.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-3](#junit4-test-lifecycle) 展示了 JUnit 4 的基本测试生命周期的图形表示。'
- en: '![hosw 0203](assets/hosw_0203.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![hosw 0203](assets/hosw_0203.png)'
- en: Figure 2-3\. JUnit 4 test lifecycle
  id: totrans-137
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-3\. JUnit 4 测试生命周期
- en: JUnit 5
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: JUnit 5
- en: 'Due to several limitations in JUnit 4 (such as monolithic architecture or impossible-to-compose
    JUnit runners), the JUnit team released a new major version (i.e., JUnit 5) in
    2017\. JUnit has been redesigned entirely in version 5, following a modular architecture
    consisting of three components (see [Figure 2-4](#junit5-arch)). The first component
    is the JUnit *Platform*, the foundation of the whole framework. The goal of the
    JUnit Platform is twofold:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 JUnit 4 存在一些限制（如单体架构或不可能组合 JUnit 运行器），JUnit 团队在 2017 年发布了一个新的主要版本（即 JUnit
    5）。JUnit 在版本 5 中进行了完全重新设计，采用了由三个组件组成的模块化架构（见 [Figure 2-4](#junit5-arch)）。第一个组件是
    JUnit *Platform*，是整个框架的基础。JUnit Platform 的目标是双重的：
- en: It allows the discovery and execution (sequential or parallel) of tests in the
    JVM through the *test launcher* API. This API is typically used by programmatic
    clients such as build tools and IDEs.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过 *test launcher* API 允许在 JVM 中发现和执行测试（顺序或并行）。这个 API 通常被构建工具和 IDE 等程序化客户端使用。
- en: It defines the *test engine* API for running tests on the JUnit Platform. This
    API is typically used by frameworks that provide programming models for testing.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它定义了在 JUnit 平台上运行测试的 *test engine* API。这个 API 通常被提供测试模型的框架所使用。
- en: '![hosw 0204](assets/hosw_0204.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![hosw 0204](assets/hosw_0204.png)'
- en: Figure 2-4\. JUnit 5 architecture
  id: totrans-143
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figure 2-4\. JUnit 5 架构
- en: 'Thanks to the test engine API, third-party test frameworks can execute tests
    on top of the JUnit Platform. Some examples of existing testing frameworks that
    have implemented test engines for JUnit 5 are [TestNG](https://github.com/junit-team/testng-engine),
    [Cucumber](https://github.com/cucumber/cucumber-jvm), or [Spock](https://github.com/spockframework/spock).
    In addition, JUnit 5 provides two out-of-the-box implementations of the test engine
    API. These engines are the remaining components of the JUnit 5 architecture, namely:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了测试引擎 API，第三方测试框架可以在 JUnit 5 之上执行测试。一些已实现用于 JUnit 5 的测试引擎的现有测试框架的示例包括 [TestNG](https://github.com/junit-team/testng-engine)、[Cucumber](https://github.com/cucumber/cucumber-jvm)
    或 [Spock](https://github.com/spockframework/spock)。此外，JUnit 5 还提供了测试引擎 API 的两个开箱即用的实现。这些引擎是
    JUnit 5 架构的其余两个组件，即
- en: Vintage
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Vintage
- en: Test engine that provides backward compatibility with legacy JUnit tests (i.e.,
    versions 3 and 4).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 提供与传统 JUnit 测试（即版本 3 和 4）的向后兼容的测试引擎。
- en: Jupiter
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Jupiter
- en: Test engine that provides a new programming and extension model
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 提供一个新的编程和扩展模型的测试引擎
- en: Jupiter is a relevant component of JUnit 5 since it provides a brand-new API
    to develop tests using a robust programming model. Some of the features of this
    programming model are parameterized tests, parallel execution, tagging and filtering,
    ordered tests, repeated and nested tests, and rich capabilities to disable (ignore)
    tests.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Jupiter 是 JUnit 5 的一个重要组成部分，它提供了全新的 API，使用强大的编程模型来开发测试。这个编程模型的一些特性包括参数化测试、并行执行、标记和过滤、有序测试、重复和嵌套测试，以及丰富的禁用（忽略）测试的能力。
- en: 'Like JUnit 4, Jupiter also uses Java annotations to declare test cases. For
    instance, the annotation to identify methods with testing logic is also `@Test`.
    The name of the rest of the annotations for the basic test lifecycle is a bit
    different in Jupiter: `@BeforeAll`, `@BeforeEach`, `@AfterEach`, and `@AfterAll`.
    As you can see in [Figure 2-5](#junit5-test-lifecycle), each of these annotations
    follows the same workflow of JUnit 4.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 与 JUnit 4 类似，Jupiter 也使用 Java 注解来声明测试用例。例如，用于标识带有测试逻辑方法的注解仍然是 `@Test`。在 Jupiter
    中，其他基本测试生命周期注解的名称与 JUnit 4 有些不同：`@BeforeAll`、`@BeforeEach`、`@AfterEach` 和 `@AfterAll`。如你所见在
    [Figure 2-5](#junit5-test-lifecycle) 中，这些注解每一个都遵循了 JUnit 4 相同的工作流程。
- en: '![hosw 0205](assets/hosw_0205.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![hosw 0205](assets/hosw_0205.png)'
- en: Figure 2-5\. JUnit 5 test lifecycle
  id: totrans-152
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figure 2-5\. JUnit 5 测试生命周期
- en: Thus, the structure of a Jupiter test using Selenium WebDriver and WebDriverManager
    is quite similar in JUnit 4 and JUnit 5\. In addition to the change in the setup
    and teardown annotation names, the test methods (and their lifecycle) are not
    required to be `public` in the Jupiter programming model.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用 Selenium WebDriver 和 WebDriverManager 的 Jupiter 测试结构在 JUnit 4 和 JUnit
    5 中非常相似。除了设置和拆卸注解名称的变化外，在 Jupiter 编程模型中，测试方法（及其生命周期）不需要在 JUnit 4 中是 `public` 的。
- en: Tip
  id: totrans-154
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Tip
- en: This book will teach you the basics of Jupiter applied to end-to-end testing
    with Selenium WebDriver. See the *hello world* example in the next section for
    a complete test based on JUnit 5\. Please check the [JUnit 5 documentation](https://junit.org/junit5/docs/current/user-guide)
    for further details.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将教会你如何使用 Selenium WebDriver 进行端到端测试的 Jupiter 基础知识。请查看下一节中关于基于 JUnit 5 的完整测试的*hello
    world*示例。详细信息请查看 [JUnit 5 文档](https://junit.org/junit5/docs/current/user-guide)。
- en: JUnit 5 with Selenium-Jupiter
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: JUnit 5 与 Selenium-Jupiter
- en: 'The extension model of Jupiter allows adding custom features to the default
    programming model. To that aim, Jupiter provides an API that developers can extend
    (using interfaces called *extension points*) to provide custom functionality.
    The categories of these extension points are:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Jupiter 的扩展模型允许向默认编程模型添加自定义功能。为此，Jupiter 提供了一个 API，开发人员可以扩展（使用称为*扩展点*的接口）以提供自定义功能。这些扩展点的类别包括：
- en: Test lifecycle callbacks
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 测试生命周期回调
- en: To include custom logic in different moments of the test lifecycle
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试生命周期的不同时刻包含自定义逻辑
- en: Parameter resolution
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 参数解析
- en: To implement dependency injection (i.e., parameters injected in test methods
    or constructors)
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 实现依赖注入（例如，在测试方法或构造函数中注入参数）
- en: Test templates
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 测试模板
- en: To repeat the tests based on a given context
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 根据给定的上下文重复测试
- en: Conditional test execution
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 条件测试执行
- en: To enable or disable tests depending on custom conditions
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 根据自定义条件启用或禁用测试
- en: Exception handling
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理
- en: To manage Java exceptions during the test and its lifecycle
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试及其生命周期中管理Java异常
- en: Test instance
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 测试实例
- en: To create and process test class instances
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 创建和处理测试类实例
- en: Intercepting invocations
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 拦截调用
- en: To intercept calls to test code (and decide whether or not these calls proceed)
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 拦截调用测试代码（并决定这些调用是否继续）
- en: As a Jupiter developer, you can implement your custom extension or use the existing
    ones. [Table 2-3](#jupiter_extensions) shows some examples of Jupiter extensions.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 Jupiter 开发者，你可以实现自定义扩展或使用现有的扩展。[表 2-3](#jupiter_extensions) 展示了一些 Jupiter
    扩展的示例。
- en: Table 2-3\. Jupiter extensions
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-3\. Jupiter 扩展
- en: '| Name | Description | License | Maintainer | Website |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 | 许可证 | 维护者 | 网站 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| JUnit Pioneer | Extension pack for Jupiter | EPL 2.0 | JUnit Pioneer team
    | [*https://junit-pioneer.org*](https://junit-pioneer.org) |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| JUnit Pioneer | Jupiter 的扩展包 | EPL 2.0 | JUnit Pioneer 团队 | [*https://junit-pioneer.org*](https://junit-pioneer.org)
    |'
- en: '| rerunner-jupiter | Extension for rerunning failed Jupiter tests | Apache
    2.0 | Artem Sokovets | [*https://github.com/artsok/rerunner-jupiter*](https://github.com/artsok/rerunner-jupiter)
    |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| rerunner-jupiter | 用于重新运行失败的 Jupiter 测试的扩展 | Apache 2.0 | Artem Sokovets
    | [*https://github.com/artsok/rerunner-jupiter*](https://github.com/artsok/rerunner-jupiter)
    |'
- en: '| MockitoExtension | Jupiter extension for initializing mocks and handling
    stubbings | MIT | Mockito team | [*https://github.com/mockito/mockito*](https://github.com/mockito/mockito)
    |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| MockitoExtension | Jupiter 扩展，用于初始化模拟对象和处理存根 | MIT | Mockito 团队 | [*https://github.com/mockito/mockito*](https://github.com/mockito/mockito)
    |'
- en: '| QuickPerf | Library for evaluating some performance-related properties |
    Apache 2.0 | QuickPerf team | [*https://github.com/quick-perf/quickperf*](https://github.com/quick-perf/quickperf)
    |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| QuickPerf | 用于评估一些性能相关属性的库 | Apache 2.0 | QuickPerf 团队 | [*https://github.com/quick-perf/quickperf*](https://github.com/quick-perf/quickperf)
    |'
- en: '| Selenium-Jupiter | Jupiter extension for Selenium WebDriver | Apache 2.0
    | Boni García | [*https://bonigarcia.dev/selenium-jupiter*](https://bonigarcia.dev/selenium-jupiter)
    |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| Selenium-Jupiter | Selenium WebDriver 的 Jupiter 扩展 | Apache 2.0 | Boni García
    | [*https://bonigarcia.dev/selenium-jupiter*](https://bonigarcia.dev/selenium-jupiter)
    |'
- en: '| SpringExtension | Jupiter extension for the Spring Framework | Apache 2.0
    | Pivotal Software | [*https://spring.io/projects/spring-framework*](https://spring.io/projects/spring-framework)
    |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| SpringExtension | Spring 框架的 Jupiter 扩展 | Apache 2.0 | Pivotal Software |
    [*https://spring.io/projects/spring-framework*](https://spring.io/projects/spring-framework)
    |'
- en: 'Selenium-Jupiter is an attractive option in the context of this book since
    it enables using Selenium WebDriver in Jupiter tests seamlessly. The bases of
    Selenium-Jupiter are as follows (see the next section for a *hello world* test
    based on Selenium-Jupiter):'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的背景下，Selenium-Jupiter 是一个非常有吸引力的选择，因为它可以无缝地在 Jupiter 测试中使用 Selenium WebDriver。Selenium-Jupiter
    的基础如下（请参见下一节关于基于 Selenium-Jupiter 的*hello world*测试）：
- en: Reduced boilerplate code in test cases
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 减少测试用例中的样板代码
- en: Thanks to the parameter resolution feature provided by the Jupiter programming
    model, Selenium-Jupiter allows declaring an object of the `WebDriver` hierarchy
    (e.g., `ChromeDriver`, `FirefoxDriver`, etc.) to control web browsers from tests
    as a constructor or test parameter.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Jupiter 编程模型提供的参数解析功能，Selenium-Jupiter 允许声明 `WebDriver` 层次结构的对象（例如，`ChromeDriver`、`FirefoxDriver`
    等）以控制来自测试的 Web 浏览器作为构造函数或测试参数。
- en: Automated driver management through WebDriverManager
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 WebDriverManager 自动化驱动程序管理
- en: Thanks to the test lifecycle callbacks provided by the extension model, the
    use of WebDriverManager is entirely transparent for Selenium-Jupiter users.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 由于扩展模型提供的测试生命周期回调，对于 Selenium-Jupiter 用户来说，使用 WebDriverManager 是完全透明的。
- en: Advanced capabilities for end-to-end testing
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 高级端到端测试功能
- en: This includes, for instance, seamless integration with Docker, test templates
    (for cross-browser testing), or troubleshooting and monitoring capabilities (e.g.,
    session recordings or configurable screenshots).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这包括与 Docker 的无缝集成、测试模板（用于跨浏览器测试）或故障排除和监控功能（例如，会话录制或可配置截图）。
- en: TestNG
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: TestNG
- en: The last unit testing framework I use in this book is TestNG. Some of the more
    significant features that TestNG provides are parallel test execution, test prioritization,
    data-driven testing using custom annotations, and the creation of detailed HTML
    reports.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中我使用的最后一个单元测试框架是 TestNG。 TestNG 提供的一些更显著的特性包括并行测试执行、测试优先级、使用自定义注解进行数据驱动测试以及创建详细的
    HTML 报告。
- en: 'In the same way as JUnit 4 and Jupiter, TestNG also uses Java annotations to
    declare tests and their lifecycle (i.e., what happens before and after each test).
    Again, the annotation `@Test` is used to designate test methods. Then, it provides
    the annotations `@BeforeClass` and `@BeforeMethod` to specify the test setup,
    and `@AfterMethod` and `@AfterClass` for the teardown (see [Figure 2-6](#testng-test-lifecycle)).
    In addition, TestNG allows grouping the tests contained in Java classes using
    the following terminology:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 与 JUnit 4 和 Jupiter 一样，TestNG 也使用 Java 注解声明测试及其生命周期（即每个测试之前和之后发生的事情）。 再次，注解
    `@Test` 用于指定测试方法。 然后，它提供了注解 `@BeforeClass` 和 `@BeforeMethod` 来指定测试设置，并使用 `@AfterMethod`
    和 `@AfterClass` 进行拆卸（参见 [图 2-6](#testng-test-lifecycle)）。 另外，TestNG 允许使用以下术语对包含在
    Java 类中的测试进行分组：
- en: '*Suite* consists of one or more *tests*.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Suite* 包含一个或多个 *tests*。'
- en: '*Test* consists of one or more *classes*.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Test* 包含一个或多个 *classes*。'
- en: '*Class* is a Java class with testing method(s), e.g., annotated with `@Test`.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Class* 是一个带有测试方法的 Java 类，例如，用 `@Test` 注解。'
- en: Following this notation, and as represented in [Figure 2-6](#testng-test-lifecycle),
    TestNG provides additional annotations to execute custom logic before and after
    the suite and the test(s).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这种表示法，并如 [图 2-6](#testng-test-lifecycle) 所示，TestNG 提供了额外的注解来在套件和测试之前和之后执行自定义逻辑。
- en: '![hosw 0206](assets/hosw_0206.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![hosw 0206](assets/hosw_0206.png)'
- en: Figure 2-6\. TestNG test lifecycle
  id: totrans-197
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-6\. TestNG 测试生命周期
- en: Fluent assertions
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 流畅断言
- en: As introduced in [Chapter 1](ch01.html#ch01), there are different libraries
    for assertions. These libraries typically provide a rich set of fluent assertions
    and comprehensive error messages. Among these alternatives, I use the library
    [AssertJ](https://joel-costigliola.github.io/assertj) in the examples repository.
    The reason is twofold. First, we can select the available methods for quickly
    asserting data using the autocompletion feature in IDEs (typically available using
    Ctrl + space after the static method `assertThat`). [Figure 2-7](#assertj-autocomplete-eclipse)
    shows an example of the inspection of this method using an IDE (Eclipse in this
    example).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [第 1 章](ch01.html#ch01) 中介绍的，有不同的断言库。 这些库通常提供丰富的流畅断言和全面的错误消息。 在这些备选方案中，我在示例库中使用
    [AssertJ](https://joel-costigliola.github.io/assertj) 库。 原因有两个。 首先，我们可以选择在 IDE
    中使用静态方法 `assertThat` 后（通常在静态方法后按 Ctrl + 空格可用）快速断言数据的可用方法。 [图 2-7](#assertj-autocomplete-eclipse)
    显示了使用 IDE（本例中为 Eclipse）检查此方法的示例。
- en: '![hosw 0207](assets/hosw_0207.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![hosw 0207](assets/hosw_0207.png)'
- en: Figure 2-7\. Manual inspection of the available assertion methods in AssertJ
    using Eclipse
  id: totrans-201
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-7\. 使用 Eclipse 手动检查 AssertJ 中可用的断言方法
- en: 'The second advantage of AssertJ compared to other options is that it allows
    an assertions chain using dot notation. Thanks to this, we can concatenate several
    conditions to create more readable assertions, for instance:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他选项相比，AssertJ 的第二个优势是它允许使用点符号进行断言链。 由此，我们可以连接几个条件以创建更可读的断言，例如：
- en: '[PRE21]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Logging
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 记录
- en: Finally, I recommend using a logging library to trace your Java code. As you
    may know, logging is a simple way programmers track events when software executes.
    Logging is typically carried out by writing text messages into a file or the standard
    output, and it allows you to trace programs and diagnose problems. Today, it is
    common to use specific libraries to do logging effectively. These libraries provide
    different benefits, such as the level of granularity for messages (e.g., debug,
    warning, or error), timestamping, or configuration capabilities.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我建议使用日志记录库来跟踪您的Java代码。如您所知，日志记录是程序员在软件执行时跟踪事件的一种简单方式。通常通过将文本消息写入文件或标准输出来执行日志记录，并且它允许您跟踪程序并诊断问题。今天，使用特定库来有效进行日志记录是很普遍的。这些库提供不同的好处，例如消息的粒度级别（例如调试，警告或错误），时间戳或配置能力。
- en: Hello World
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hello World
- en: We are ready to put all the pieces explained in this chapter together and implement
    our first end-to-end test. As you may know, a *hello world* program is a simple
    piece of code that many programming languages use to illustrate basic syntax.
    [Example 2-1](#helloworld_jupiter) shows the Selenium WebDriver’s version of this
    classic *hello world*.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好将本章中解释的所有部分结合起来，实现我们的第一个端到端测试。正如您可能知道的那样，一个*hello world*程序是许多编程语言用来说明基本语法的简单代码片段。[示例2-1](#helloworld_jupiter)展示了Selenium
    WebDriver版本的这个经典*hello world*。
- en: Tip
  id: totrans-208
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: The following example uses JUnit 5 as the unit testing framework to embed the
    call to Selenium WebDriver. Remember that you can find the other flavors (i.e.,
    JUnit 4, JUnit 5 with Selenium-Jupiter, and TestNG) in the [examples repository](https://github.com/bonigarcia/selenium-webdriver-java).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用JUnit 5作为单元测试框架来嵌入调用Selenium WebDriver的代码。请记住，您可以在[示例存储库](https://github.com/bonigarcia/selenium-webdriver-java)中找到其他版本（即JUnit
    4，带有Selenium-Jupiter的JUnit 5和TestNG）。
- en: Example 2-1\. Hello world using Chrome and JUnit 5
  id: totrans-210
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例2-1。使用Chrome和JUnit 5的Hello World
- en: '[PRE22]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[![1](assets/1.png)](#co_preparing_for_testing_CO1-1)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_preparing_for_testing_CO1-1)'
- en: We declare a Java attribute using the interface `WebDriver`. We use this variable
    in tests to control web browsers with Selenium WebDriver.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`WebDriver`接口声明Java属性。我们在测试中使用这个变量来控制Selenium WebDriver的Web浏览器。
- en: '[![2](assets/2.png)](#co_preparing_for_testing_CO1-2)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_preparing_for_testing_CO1-2)'
- en: In the setup for all tests within this class (i.e., executed once), we call
    WebDriverManager to manage the required driver. In this example, since we use
    Chrome as a browser, we need to resolve chromedriver.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类的所有测试的设置中（即仅执行一次），我们调用WebDriverManager来管理所需的驱动程序。在这个例子中，因为我们使用Chrome作为浏览器，所以我们需要解决chromedriver。
- en: '[![3](assets/3.png)](#co_preparing_for_testing_CO1-3)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_preparing_for_testing_CO1-3)'
- en: In the test setup (executed once per test method), we instantiate the `WebDriver`
    object to control Chrome. In other words, we create an object of the type `ChromeDriver`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试设置中（每个测试方法执行一次），我们实例化`WebDriver`对象来控制Chrome。换句话说，我们创建了一个`ChromeDriver`类型的对象。
- en: '[![4](assets/4.png)](#co_preparing_for_testing_CO1-4)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_preparing_for_testing_CO1-4)'
- en: The test logic uses the Selenium WebDriver API through the `driver` variable.
    First, the test exercises the System Under Test (SUT). To that aim, we open the
    [practice site](https://bonigarcia.dev/selenium-webdriver-java) using the `get()`
    method of our `webdriver` variable (which represents a Chrome browser, in this
    case).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 测试逻辑通过`driver`变量使用Selenium WebDriver API。首先，测试执行System Under Test（SUT）。为此，我们使用我们的`webdriver`变量的`get()`方法打开[练习站点](https://bonigarcia.dev/selenium-webdriver-java)（在本例中代表Chrome浏览器）。
- en: '[![5](assets/5.png)](#co_preparing_for_testing_CO1-5)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_preparing_for_testing_CO1-5)'
- en: We get the web page title using the method `getTitle()`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`getTitle()`方法获取网页标题。
- en: '[![6](assets/6.png)](#co_preparing_for_testing_CO1-6)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_preparing_for_testing_CO1-6)'
- en: For debugging purposes, we log that title using the `DEBUG` level.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 出于调试目的，我们使用`DEBUG`级别记录该标题。
- en: '[![7](assets/7.png)](#co_preparing_for_testing_CO1-7)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_preparing_for_testing_CO1-7)'
- en: The last part of the test contains an AssertJ assertion. In this case, we verify
    the web page title is as expected.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的最后部分包含一个AssertJ断言。在这种情况下，我们验证网页标题是否符合预期。
- en: '[![8](assets/8.png)](#co_preparing_for_testing_CO1-8)'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_preparing_for_testing_CO1-8)'
- en: At the end of each test, we need to close the browser. To that aim, we can invoke
    the method `quit()` of the `driver` object (see more info about how to close `WebDriver`
    objects in [Chapter 3](ch03.html#ch03)).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个测试结束时，我们需要关闭浏览器。为此，我们可以调用`driver`对象的`quit()`方法（有关如何关闭`WebDriver`对象的更多信息，请参见[第3章](ch03.html#ch03)）。
- en: 'You can execute this test in different ways. I recommend getting a local copy
    of the examples repository. You can use the GitHub website to download a complete
    copy of the source code. Alternatively, you can use Git to clone the repo using
    the shell, as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以以不同的方式执行此测试。我建议获取示例仓库的本地副本。你可以使用GitHub网站下载源代码的完整副本。或者，你可以使用Git在shell中克隆存储库，如下所示：
- en: '[PRE23]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Then, you can use Maven or Gradle (as explained in [Appendix C](app03.html#appendix03))
    to run the tests from the shell. In addition, you can import the cloned Maven/Gradle
    projects into an IDE. IDEs provide built-in capabilities to execute the test from
    their GUI. For instance, [Figure 2-8](#hello-world-eclipse) shows a screenshot
    of the execution of the previous *hello world* test in Eclipse (in this case,
    using the command Run → Run As → JUnit Test). Notice that in the integrated console
    (at the bottom of the picture), the first traces correspond to the driver resolution
    by WebDriverManager. Then, the browser starts through chromedriver, and finally,
    we can see the test traces (concretely, the web page title).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以使用Maven或Gradle（如[附录C](app03.html#appendix03)中所述）在shell中运行测试。此外，你还可以将克隆的Maven/Gradle项目导入到IDE中。IDE提供了内置功能，可以从其GUI中执行测试。例如，[图2-8](#hello-world-eclipse)展示了在Eclipse中执行前一个*hello
    world*测试的屏幕截图（在此情况下，使用命令Run → Run As → JUnit Test）。请注意，在集成控制台（图片底部）中，第一行跟踪是由WebDriverManager解析的驱动器分辨率。然后，浏览器通过chromedriver启动，最后，我们可以看到测试跟踪（具体来说，是网页标题）。
- en: '![hosw 0208](assets/hosw_0208.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![hosw 0208](assets/hosw_0208.png)'
- en: Figure 2-8\. Screenshot of the execution of the Selenium WebDriver’s *hello
    world* in Eclipse
  id: totrans-232
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-8\. 在Eclipse中执行Selenium WebDriver的*hello world*的屏幕截图
- en: The *hello world* versions using JUnit 4 and TestNG are almost identical to
    JUnit 5 but use different annotations for the test lifecycle (e.g., JUnit 4’s
    `@Before` instead of JUnit 5’s `@BeforeEach`, etc.). Regarding JUnit 5 plus Selenium-Jupiter,
    the code is a bit more compact. [Example 2-2](#helloworld_seljup) shows this *hello
    world* version. As you can see, there is no need to declare the setup and teardown.
    We simply need to declare the `WebDriver` object we want as a test parameter (`FirefoxDriver`
    in this case), and Selenium-Jupiter takes care of the driver management (also
    with WebDriverManager), object instantiation, and browser disposal.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JUnit 4和TestNG的*hello world*版本几乎与JUnit 5相同，但使用不同的测试生命周期注解（例如，JUnit 4的`@Before`代替JUnit
    5的`@BeforeEach`等）。关于JUnit 5加Selenium-Jupiter，代码更加紧凑。[示例2-2](#helloworld_seljup)展示了这个*hello
    world*版本。正如你所看到的，无需声明设置和拆卸。我们只需要将想要的`WebDriver`对象声明为测试参数（在本例中为FirefoxDriver），Selenium-Jupiter会处理驱动程序管理（也包括WebDriverManager）、对象实例化和浏览器处理。
- en: Example 2-2\. Hello world using Firefox and Selenium-Jupiter
  id: totrans-234
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例2-2\. 使用Firefox和Selenium-Jupiter的Hello world
- en: '[PRE24]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Using Additional Browsers
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用其他浏览器
- en: 'In addition to what I am calling *main* browsers in this book (i.e., Chrome,
    Edge, and Firefox), the example repository contains the *hello world* test using
    other browsers: Opera, Chromium, Safari, and HtmlUnitDriver (a Selenium WebDriver–compatible
    driver for the HtmlUnit headless browser). These tests, contained in the package
    `helloworld_otherbrowsers` of this repository, are slightly different from the
    raw *hello world* versions. For instance, [Example 2-3](#helloworld_opera_junit5)
    shows the JUnit 5 class setup of the *hello world* test using Opera. Since this
    browser might not be available in the machine running the test (e.g., Opera is
    not available in GitHub Actions), I use *assumptions* to disable the test in runtime
    conditionally.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 除了本书中称为*主要*浏览器（即Chrome、Edge和Firefox）之外，示例仓库还包含使用其他浏览器的*hello world*测试：Opera、Chromium、Safari和HtmlUnitDriver（用于HtmlUnit无头浏览器的Selenium
    WebDriver兼容驱动程序）。这些测试包含在此存储库的`helloworld_otherbrowsers`包中，与原始的*hello world*版本略有不同。例如，[示例2-3](#helloworld_opera_junit5)展示了使用Opera的JUnit
    5类设置的*hello world*测试。由于这个浏览器可能在运行测试的机器上不可用（例如，在GitHub Actions中不可用Opera），我使用*假设*在运行时有条件地禁用测试。
- en: Example 2-3\. Class setup using Opera and JUnit 5
  id: totrans-238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例2-3\. 使用Opera和JUnit 5的类设置
- en: '[PRE25]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[![1](assets/1.png)](#co_preparing_for_testing_CO2-1)'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_preparing_for_testing_CO2-1)'
- en: We use WebDriverManager to locate the browser path.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用WebDriverManager来定位浏览器路径。
- en: '[![2](assets/2.png)](#co_preparing_for_testing_CO2-2)'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_preparing_for_testing_CO2-2)'
- en: If this path does not exist, we assume the browser is not installed in the system,
    so the test is skipped (using an AssertJ assumption).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此路径不存在，则假设系统中未安装浏览器，因此测试被跳过（使用AssertJ假设）。
- en: As usual, you can find this test using other unit testing frameworks in the
    examples repository. The JUnit 5 and TestNG versions use the equivalent test setup
    to the previous snippet. Nevertheless, there is a difference when using JUnit
    5 plus Selenium-Jupiter. As you can see in [Example 2-4](#helloworld_safari_seljup),
    Selenium-Jupiter simplifies the assumption logic by using a custom annotation
    (called `EnabledIfBrowserAvailable`) to disable tests depending on the browser
    availability (Safari in this example).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，您可以在示例存储库中使用其他单元测试框架找到此测试。JUnit 5 和 TestNG 版本使用与前面代码片段相同的等效测试设置。然而，使用
    JUnit 5 和 Selenium-Jupiter 时有所不同。正如您在 [示例 2-4](#helloworld_safari_seljup) 中所见，Selenium-Jupiter
    通过使用自定义注解（称为 `EnabledIfBrowserAvailable`）简化了依赖于浏览器可用性（本例中为 Safari）的测试假设逻辑。
- en: Example 2-4\. Hello world using Safari and JUnit 5 plus Selenium-Jupiter
  id: totrans-245
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-4\. 使用 Safari 和 JUnit 5 加上 Selenium-Jupiter 的 Hello World
- en: '[PRE26]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: To control Safari with Selenium WebDriver, we need to configure Safari manually
    to authorize remote automation. To that aim, first, we show the develop menu by
    clicking on the menu option Safari → Preferences → Advanced tab. Then, we enable
    the “Show Develop Menu” checkbox. After that, the “Develop” menu should appear.
    Finally, we click on the option “Allow Remote Automation” (see [Figure 2-9](#safari-macos)).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Selenium WebDriver 控制 Safari，我们需要手动配置 Safari 以授权远程自动化。为此，首先通过单击 Safari 菜单选项
    Safari → 首选项 → 高级选项卡来显示开发菜单。然后，启用“显示开发菜单”复选框。之后，“开发”菜单应该会显示出来。最后，单击“允许远程自动化”选项（参见
    [图 2-9](#safari-macos)）。
- en: '![hosw 0209](assets/hosw_0209.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![hosw 0209](assets/hosw_0209.png)'
- en: Figure 2-9\. Enable Safari remote automation on macOS
  id: totrans-249
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-9\. 在 macOS 上启用 Safari 远程自动化
- en: Summary and Outlook
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结与展望
- en: 'This chapter provides the foundations for developing end-to-end tests for web
    applications using Selenium WebDriver and Java. The first important decision you
    need to make is to decide in which unit testing framework to embed the Selenium
    WebDriver calls to implement these tests. For the sake of diversity and completeness,
    I propose four options in this book: JUnit 4, JUnit 5, JUnit 5 plus Selenium-Jupiter,
    and TestNG. They are all equivalent for basic Selenium WebDriver tests. For more
    advanced uses, [Chapter 8](ch08.html#ch08) will cover the specific features of
    each testing framework that could be relevant to WebDriver tests (e.g., parameterized
    tests for cross-browser testing). Another decision you should make is to choose
    a build tool. In this book, I propose two options: Maven and Gradle. Once again,
    both are similar for standard development practices.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了使用 Selenium WebDriver 和 Java 开发 Web 应用端到端测试的基础知识。您需要做出的第一个重要决定是决定在哪个单元测试框架中嵌入
    Selenium WebDriver 调用以实现这些测试。为了多样性和完整性，本书提出了四个选项：JUnit 4、JUnit 5、JUnit 5 加上 Selenium-Jupiter
    和 TestNG。它们在基本的 Selenium WebDriver 测试方面都是等效的。对于更高级的用法，[第 8 章](ch08.html#ch08)
    将涵盖每个测试框架的特定功能，这些功能可能对 WebDriver 测试（例如，用于跨浏览器测试的参数化测试）很重要。另一个您应该考虑的决定是选择构建工具。在本书中，我提出了两个选项：Maven
    和 Gradle。再次强调，对于标准的开发实践，这两者都是类似的。
- en: The second part of this book is focused on the Selenium WebDriver API and begins
    next. To get started, [Chapter 3](ch03.html#ch03) covers the fundamental notions
    of the Selenium WebDriver API in terms of WebDriver objects, web elements location,
    user impersonation (keyboard and mouse actions), and waiting strategies. As usual,
    this chapter is guided by code examples available on the repository hosted in
    GitHub.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的第二部分专注于 Selenium WebDriver API，并将在下一部分开始介绍。要开始学习，请参阅 [第 3 章](ch03.html#ch03)，该章节涵盖了
    Selenium WebDriver API 的基本概念，包括 WebDriver 对象、Web 元素定位、用户模拟操作（键盘和鼠标动作）以及等待策略。和往常一样，本章将通过
    GitHub 托管的代码示例进行指导。
