<html><head></head><body><section data-pdf-bookmark="Chapter 11. Database Performance Best Practices" data-type="chapter" epub:type="chapter"><div class="chapter" id="Database">&#13;
<h1><span class="label">Chapter 11. </span>Database Performance Best Practices</h1>&#13;
&#13;
&#13;
<p><a data-primary="databases" data-type="indexterm" id="ix_ch11-asciidoc0"/>This chapter investigates the performance of Java-driven&#13;
database applications.&#13;
Applications that access a database are subject to non-Java performance&#13;
issues: if a database&#13;
is I/O-bound or if it is executing SQL queries that require full table scans&#13;
because an index is missing,&#13;
no amount of Java tuning or application coding is going to solve the&#13;
performance issues. When dealing with database technologies, be prepared to&#13;
learn (from another source) about how to tune and program the database.</p>&#13;
&#13;
<p>This is not to say that the performance of an application that uses a&#13;
database is insensitive to things under the control of the JVM and the&#13;
Java technologies that are used. Rather, for good performance, it is&#13;
necessary to&#13;
ensure that both the database and the application are correctly tuned&#13;
and executing the best possible code.</p>&#13;
&#13;
<p>This chapter starts by looking at JDBC drivers, since those influence&#13;
the data frameworks that talk to relational databases. Many frameworks&#13;
 abstract the JDBC details, including the JPA and the&#13;
Spring data modules.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45775546075976">&#13;
<h5>SQL and NoSQL</h5>&#13;
<p><a data-primary="databases" data-secondary="SQL/NoSQL" data-type="indexterm" id="idm45775546074776"/><a data-primary="NoSQL databases" data-type="indexterm" id="idm45775546073800"/><a data-primary="SQL database standards" data-type="indexterm" id="idm45775546073128"/>The focus of this chapter is on relational databases and the Java technologies&#13;
that access them.&#13;
There are ways to access nonrelational databases via Java, but they are&#13;
not standard. Relational databases&#13;
adhere to various SQL standards, including the ANSI/ISO SQL standard&#13;
(aka SLQ:2003). Adhering to that standard means that the Java platform itself&#13;
can provide a standard interface to those databases; that interface is&#13;
JDBC (and JPA is built on top of that).</p>&#13;
&#13;
<p>There is no corresponding standard for NoSQL databases, and hence there is&#13;
no standard platform support for accessing them. The forthcoming Jakarta&#13;
Enterprise Edition 9 is expected to include a specification for standard&#13;
access to NoSQL databases, though the details are in flux.</p>&#13;
&#13;
<p>Still, while the examples in this chapter don’t address NoSQL databases,&#13;
the concepts definitely do apply to them: things like batching and transaction&#13;
boundaries have just as important an effect on NoSQL databases as on relational&#13;
databases.</p>&#13;
</div></aside>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Sample Database" data-type="sect1"><div class="sect1" id="idm45775546070248">&#13;
<h1>Sample Database</h1>&#13;
&#13;
<p>The examples in this chapter use a sample database set up to store the&#13;
data for 256 stock entities for the period of one year. The year has 261 business days.</p>&#13;
&#13;
<p>Prices for the individual stocks are held in a table called STOCKPRICE, which&#13;
has a primary key of the stock symbol and the date. There are 66,816&#13;
rows in that table (256 × 261).</p>&#13;
&#13;
<p>Each stock has a set of five associated options, which are also priced daily.&#13;
The STOCKOPTIONPRICE table holds that data with a primary key of the symbol, the&#13;
date, and an integer representing the option number. There are 334,080 rows&#13;
in that table (256 × 261 × 5).</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="JDBC" data-type="sect1"><div class="sect1" id="idm45775546067176">&#13;
<h1>JDBC</h1>&#13;
&#13;
<p><a data-primary="databases" data-secondary="JDBC" data-type="indexterm" id="ix_ch11-asciidoc1"/><a data-primary="JDBC (Java Database Connectivity)" data-type="indexterm" id="ix_ch11-asciidoc2"/>This chapter covers database performance from the perspective&#13;
of JPA version 2.<em>x</em>. However, JPA uses JDBC under&#13;
the covers, and many developers still write applications directly to the&#13;
JDBC APIs—so it is important to look at the most&#13;
important&#13;
performance aspects of JDBC also. Even for applications that use JPA&#13;
(or another&#13;
database framework from something like Spring Data), understanding&#13;
JDBC performance will help&#13;
get better performance out of the framework.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="JDBC Drivers" data-type="sect2"><div class="sect2" id="idm45775546062440">&#13;
<h2>JDBC Drivers</h2>&#13;
&#13;
<p><a data-primary="drivers, JDBC" data-type="indexterm" id="ix_ch11-asciidoc3"/><a data-primary="JDBC (Java Database Connectivity)" data-secondary="drivers" data-type="indexterm" id="ix_ch11-asciidoc4"/>The JDBC driver is the most important factor in the performance of&#13;
database applications.&#13;
Databases come with their own set of JDBC drivers, and alternate&#13;
JDBC drivers are available for most popular databases. Frequently,&#13;
the justification for these alternate drivers is that they offer&#13;
better performance.</p>&#13;
&#13;
<p>It’s impossible to adjudicate the performance claims of all database drivers,&#13;
but here are some things to consider when evaluating drivers.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Where work is performed" data-type="sect3"><div class="sect3" id="idm45775546057672">&#13;
<h3>Where work is performed</h3>&#13;
&#13;
<p>JDBC drivers can be written to perform more work within the Java application&#13;
(the database client) or to perform more work on the database server. The&#13;
best example of this is the thin and thick drivers for Oracle databases.&#13;
<a data-primary="thin drivers (JDBC)" data-type="indexterm" id="idm45775546056104"/>The <em>thin driver</em> is written to have a fairly small footprint within the Java&#13;
application: it relies on the database server to do more processing. <a data-primary="thick drivers (JDBC)" data-type="indexterm" id="idm45775546054712"/>The <em>thick&#13;
driver</em> is just the opposite: it offloads work from the database at the&#13;
expense of requiring more processing and more memory on the Java client.&#13;
That kind of&#13;
trade-off is possible in most databases.</p>&#13;
&#13;
<p>Competing claims disagree on which model gives the better performance.&#13;
The truth is that neither model offers an inherent advantage—the driver&#13;
that will offer the best performance depends on the specifics of the&#13;
environment in which it is run. Say an application&#13;
host is a small,&#13;
two-core machine connecting to a huge, well-tuned database. The CPU of the&#13;
application host is likely to become saturated well before any significant&#13;
load is placed on the database. A thin-style driver will give the better&#13;
performance in that case. Conversely, an enterprise that has 100 departments&#13;
accessing a single HR database will see the best performance if database&#13;
resources are preserved and the clients deploy a thick-style&#13;
driver.<sup><a data-type="noteref" href="ch11.html#idm45775546052104" id="idm45775546052104-marker">1</a></sup></p>&#13;
&#13;
<p>This is a reason to be suspicious of any performance claims when it comes to&#13;
JDBC drivers: it is easy to pick a driver that is well suited to a&#13;
particular environment and show that it is superior to another vendor’s&#13;
driver that&#13;
performs badly on the exact same setup. As always, test in your own&#13;
environment, and make sure that environment mirrors what you will deploy&#13;
on.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The JDBC driver type" data-type="sect3"><div class="sect3" id="idm45775546050408">&#13;
<h3>The JDBC driver type</h3>&#13;
&#13;
<p>JDBC drivers come in four types (1–4). The driver types&#13;
in wide use today are type 2 (which uses native code) and type 4 (which is&#13;
pure Java).</p>&#13;
&#13;
<p>Type 1 drivers provide a bridge between Open Database Connectivity (ODBC) and JBDC. If an application must talk to a database using ODBC, it must use this driver. Type&#13;
1 drivers generally have quite bad performance; you would choose that only&#13;
if you had to talk via the ODBC protocol to a legacy database.</p>&#13;
&#13;
<p>Type 3 drivers are, like type 4 drivers, written purely in Java, but they&#13;
are designed for a specific architecture in which a piece of middleware&#13;
(sometimes, though usually not, an application server) provides an&#13;
intermediary translation.&#13;
In this architecture, a JDBC client (usually a standalone program, though&#13;
conceivably an application server) sends the JDBC protocol to the middleware,&#13;
which translates the requests into a database-specific protocol and forwards&#13;
the request to the database (and performs the reverse translation for the&#13;
response).</p>&#13;
&#13;
<p>In some situations, this architecture is required: the middleware&#13;
can sit in the network demilitarized zone (DMZ) and provide additional security for&#13;
connections to the database. From a performance standpoint,&#13;
potential advantages and disadvantages exist. The middleware is free to cache&#13;
database information, which offloads the database (making it faster) and&#13;
returns data to the client sooner (decreasing the latency of the request).&#13;
Without that caching, however, performance will suffer, as two&#13;
round-trip network requests are now required to perform a&#13;
database operation. In the ideal&#13;
case, those will balance out (or the caching will be even faster).</p>&#13;
&#13;
<p>As a practical situation, though, this architecture has not really been&#13;
widely adopted.  It is generally easier to put the server itself in the&#13;
middle tier (including in the DMZ if needed). The server can&#13;
then perform the database operations, but it needn’t provide a JDBC interface&#13;
to clients: it is better off providing servlet interfaces, web service&#13;
interfaces, and so on—isolating the client from any knowledge of the&#13;
database.</p>&#13;
&#13;
<p>That leaves type 2 and 4 drivers, both of which are quite popular, and&#13;
neither of which has an inherent&#13;
performance advantage over the other.</p>&#13;
&#13;
<p>Type 2 drivers use a native library to access the database. These drivers&#13;
are popular with some database vendors because they allow the Java driver&#13;
to leverage the years of work that has been put into writing the C&#13;
library that other programs use to access the database. Because they rely&#13;
on a native library, they are harder to deploy: the database vendor must&#13;
provide a platform-specific native library for the driver, and the Java&#13;
application must set up environmental variables to use that library.&#13;
Still, given the work that the vendor has already put into the C&#13;
library, type 2 drivers tend to perform very well.</p>&#13;
&#13;
<p>Type 4 drivers are pure Java drivers that implement the wire protocol that&#13;
the database vendor has defined for accessing their database. Because they&#13;
are written completely in Java, they are easy to deploy: the application&#13;
simply needs to add a JAR file to their classpath. Type 4 drivers typically&#13;
perform as well as type 2 drivers because both use the same wire protocol.&#13;
From the vendor’s perspective, the type 4 driver may be additional code to&#13;
write, but from a user’s perspective, they are generally the easiest to use.</p>&#13;
&#13;
<p>Don’t conflate the driver type (2 or 4) with whether the driver is considered thick or&#13;
thin, as discussed in the previous section. It is true that type 2 drivers&#13;
tend to be thick and type 4 drivers tend to be thin, but that is not&#13;
a requirement. In the end, whether a type 2 or type 4 driver is better&#13;
depends on the environment and the specific drivers in question.&#13;
There is really no a priori way to know which will perform better.</p>&#13;
<div data-type="tip"><h1>Quick Summary</h1>&#13;
<ul>&#13;
<li>&#13;
<p>Spend time evaluating the best JDBC driver for the application.</p>&#13;
</li>&#13;
<li>&#13;
<p>The best driver will often vary depending on the specific deployment. The same application may be better with one JDBC driver in one deployment and a different JDBC driver in a different deployment.</p>&#13;
</li>&#13;
<li>&#13;
<p>If you have a choice, avoid ODBC and type 1 JDBC drivers.<a data-startref="ix_ch11-asciidoc4" data-type="indexterm" id="idm45775546037512"/><a data-startref="ix_ch11-asciidoc3" data-type="indexterm" id="idm45775546036808"/></p>&#13;
</li>&#13;
</ul>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="JDBC Connection Pools" data-type="sect2"><div class="sect2" id="idm45775546049848">&#13;
<h2>JDBC Connection Pools</h2>&#13;
&#13;
<p><a data-primary="connection pools, JDBC" data-type="indexterm" id="idm45775546034664"/><a data-primary="JDBC (Java Database Connectivity)" data-secondary="connection pools" data-type="indexterm" id="idm45775546033960"/>Connections to a database are time-consuming to create, so JDBC&#13;
connections are another prototypical object that you should reuse in Java.</p>&#13;
&#13;
<p>In most server environments, all JDBC connections come from the&#13;
server’s connection pool. In a Java SE environment with JPA, most&#13;
JPA providers will&#13;
use a connection pool transparently, and you can configure the connection&#13;
pool within the <em>persistence.xml</em> file. In a standalone Java SE environment,&#13;
the connections must be managed by the application. To deal with that&#13;
last case, you can use one of&#13;
several connection pool libraries that are available from many sources. Often,&#13;
though, it&#13;
is easier to create a connection and store it in a thread-local&#13;
variable for each thread in a standalone application.</p>&#13;
&#13;
<p>As usual, it is important to strike the right balance between the memory occupied by the pooled&#13;
objects and the amount of extra GC the pooling will trigger.&#13;
This is particularly true because of the prepared&#13;
statement caches that we’ll examine in the next section.&#13;
The actual connection objects may not be very big, but&#13;
statement caches (which exist on a per connection basis) can grow to&#13;
be quite big.</p>&#13;
&#13;
<p>In this case, striking the correct balance applies to the database as well.&#13;
Each connection to the database requires resources on the database (in&#13;
addition to the memory held in the application). As connections are added to the database, the database needs more resources: it will allocate additional memory for each prepared statement used by the JDBC driver.&#13;
Database performance can be adversely affected if the application&#13;
server has too many open connections.</p>&#13;
&#13;
<p>The general rule of thumb for connection pools is to have one connection for&#13;
every thread in the application. In a server,&#13;
start by applying the same sizing to the thread pool and the connection pool.&#13;
In a standalone application, size the connection pool based on the number of&#13;
threads the application creates. In a typical case, this will offer the&#13;
best performance: no thread in the program will have to wait for a database&#13;
connection to be available, and typically there are enough resources on&#13;
the database to handle the load imposed by the application.</p>&#13;
&#13;
<p>If the database becomes a bottleneck, however, this rule can become&#13;
counterproductive.&#13;
Having too many connections to an undersized database is another&#13;
illustration of the principle that injecting load into a busy system will&#13;
decrease its performance. Using a connection pool to throttle the&#13;
amount of work that is sent to an undersized database is the way to improve&#13;
performance in that situation. Application threads may have to wait&#13;
for a free connection, but the total throughput of the system will be&#13;
maximized if the database is not overburdened.</p>&#13;
<div data-type="tip"><h1>Quick Summary</h1>&#13;
<ul>&#13;
<li>&#13;
<p>Connections are expensive objects to initialize; they are routinely pooled in Java—either in the JDBC driver itself or within JPA and other frameworks.</p>&#13;
</li>&#13;
<li>&#13;
<p>As with other object pools, it is important to tune the connection pool so it doesn’t adversely affect the garbage collector. In this case, it is also necessary to tune the connection pool so it doesn’t adversely affect the performance of the database itself.</p>&#13;
</li>&#13;
</ul>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Prepared Statements and Statement Pooling" data-type="sect2"><div class="sect2" id="idm45775545998632">&#13;
<h2>Prepared Statements and Statement Pooling</h2>&#13;
&#13;
<p><a data-primary="JDBC (Java Database Connectivity)" data-secondary="prepared statements and statement pooling" data-type="indexterm" id="ix_ch11-asciidoc5"/><a data-primary="PreparedStatement" data-type="indexterm" id="ix_ch11-asciidoc6"/><a data-primary="statement pools" data-type="indexterm" id="ix_ch11-asciidoc7"/>In most circumstances, code should use a&#13;
<code class="keep-together">PreparedStatement</code>&#13;
rather than&#13;
a&#13;
<code class="keep-together">Statement</code>&#13;
for its JDBC calls. This aids performance: prepared&#13;
statements allow the database to reuse information about the SQL that is&#13;
being executed. That saves work for the database on subsequent executions&#13;
of the prepared statement. Prepared statements also have security and&#13;
programming advantages, particularly in specifying parameters to the&#13;
call.</p>&#13;
&#13;
<p><em>Reuse</em> is the operative word here: the first use of a prepared statement&#13;
takes more time for the database to execute, since it must&#13;
set up and save information.&#13;
If the statement is used only once, that work&#13;
will be wasted; it’s better to use a regular&#13;
statement in that case.</p>&#13;
&#13;
<p>When there are only a few database&#13;
calls, the&#13;
<code class="keep-together">Statement</code>&#13;
interface will let the application finish faster.&#13;
But even batch-oriented programs may make hundreds or&#13;
thousands of JDBC calls to the same few SQL statements;&#13;
later examples in this chapter will use a&#13;
batch program to load the database with its 400,896 records. Batch&#13;
programs that have many JDBC calls—and servers that will&#13;
service many requests over their lifetime—are better off using a&#13;
<code class="keep-together">PreparedStatement</code>&#13;
interface (and database frameworks will do&#13;
that automatically).</p>&#13;
&#13;
<p>Prepared statements provide their performance benefit&#13;
when they are pooled—that is, when the actual&#13;
<code class="keep-together">PreparedStatement</code>&#13;
object&#13;
is reused. For proper pooling, two things must be considered: the JDBC&#13;
connection pool and the JDBC driver configuration.<sup><a data-type="noteref" href="ch11.html#idm45775545987720" id="idm45775545987720-marker">2</a></sup> These&#13;
configuration options apply to any program that uses JDBC, whether&#13;
directly or via a framework.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Setting up the statement pool" data-type="sect3"><div class="sect3" id="idm45775545986376">&#13;
<h3>Setting up the statement pool</h3>&#13;
&#13;
<p><a data-primary="statement pools" data-secondary="setup" data-type="indexterm" id="idm45775545985160"/>Prepared statement pools operate on a per connection basis. If one thread&#13;
in a program pulls a JDBC connection out of the pool and uses a prepared&#13;
statement on that connection, the information associated with the&#13;
statement will be valid only for that connection. A second thread that uses&#13;
a second connection will end up establishing a second pooled instance of the&#13;
prepared statement. In the end, each connection object will have its own&#13;
pool of all the prepared statements used in the application (assuming that&#13;
they are all used over the lifetime of the application).</p>&#13;
&#13;
<p>This is one reason a standalone JDBC application should use a&#13;
connection pool.&#13;
It also means&#13;
that the size of the connection pool matters (to both JDBC and JPA&#13;
programs). That is particularly true early in the&#13;
program’s execution: when a connection that has not yet used a&#13;
particular prepared statement is used, that first request will be a&#13;
little slower.</p>&#13;
&#13;
<p>The size of the connection pool also matters because it is caching those&#13;
prepared statements, which take up heap space (and often a lot of heap&#13;
space). Object&#13;
reuse is certainly a good thing in this case, but you must&#13;
be aware of how much space those reusable objects take up and&#13;
make sure it isn’t negatively affecting the GC time.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Managing statement pools" data-type="sect3"><div class="sect3" id="idm45775545981688">&#13;
<h3>Managing statement pools</h3>&#13;
&#13;
<p><a data-primary="statement pools" data-secondary="managing" data-type="indexterm" id="idm45775545980232"/>The second thing to consider about the prepared statement pool is what&#13;
piece of code will actually create and manage the pool.&#13;
This is done by using the&#13;
<code class="keep-together">setMaxStatements()</code>&#13;
method of the&#13;
<code class="keep-together">ConnectionPoolDataSource</code>&#13;
class&#13;
to enable or disable statement pooling. Statement pooling is disabled if the value passed&#13;
to the&#13;
<code>setMaxStatements()</code> method is 0. That interface specifically&#13;
does not define where the statement pooling should occur—whether in&#13;
the JDBC driver or another layer, such as the application server. And&#13;
that single interface is insufficient for some JDBC drivers, which require&#13;
additional configuration.</p>&#13;
&#13;
<p>So, when writing a Java SE application that uses JDBC calls directly,&#13;
we have two choices: either the JDBC driver must be configured to create&#13;
and manage the statement pool or the pool must be created and managed&#13;
within the application&#13;
code. When using a framework, the statement pool is often managed by&#13;
the framework.</p>&#13;
&#13;
<p>The tricky thing is that no standards exist in this area.&#13;
Some JDBC drivers do not provide a mechanism to pool statements at all;&#13;
they expect to be used only within an application server that is doing the&#13;
statement pooling and want to provide a simpler driver. Some application&#13;
servers do not provide and manage a pool; they expect the JDBC driver to&#13;
handle that task and don’t want to complicate their code. Both arguments&#13;
have merit (though a JDBC driver that does not provide a statement pool&#13;
puts a burden on you if you are the developer of a standalone application).&#13;
In the end, you’ll have to sift through this landscape and make sure that&#13;
the statement pool is created somewhere.</p>&#13;
&#13;
<p>Since there are no standards, you may encounter a situation&#13;
where both the JDBC driver and the data layer framework are capable of&#13;
managing the&#13;
prepared statement pool. In that case, it is important that only one of&#13;
them be configured to do so. From a performance perspective, the better choice&#13;
will again depend on the exact combination of driver and server.&#13;
As a general rule, you can expect the JDBC driver to perform better&#13;
statement pooling. Since the driver is (usually) specific to a particular&#13;
database, it can be expected to make better optimizations for that database&#13;
than the more generic application server code.</p>&#13;
&#13;
<p>To enable statement pooling (or caching) for a particular JDBC driver,&#13;
consult that driver’s documentation. In many cases, you need only set up&#13;
the driver so that the&#13;
<code class="keep-together">maxStatements</code>&#13;
property is set to the desired value&#13;
(i.e., the size of the statement pool). Other drivers may require&#13;
additional settings: for example, the Oracle JDBC drivers require that specific&#13;
properties be set to tell it whether to use implicit or explicit statement&#13;
caching, and MySQL drivers require that you set a property to enable statement&#13;
caching.</p>&#13;
<div data-type="tip"><h1>Quick Summary</h1>&#13;
<ul>&#13;
<li>&#13;
<p>Java applications will typically execute the same SQL statement repeatedly. In those cases, reusing prepared statements will offer a significant performance boost.</p>&#13;
</li>&#13;
<li>&#13;
<p>Prepared statements must be pooled on a per connection basis. Most JDBC drivers and data frameworks can do this automatically.</p>&#13;
</li>&#13;
<li>&#13;
<p>Prepared statements can consume a significant amount of heap. The size of the statement pool must be carefully tuned to prevent GC issues from pooling too many very large objects.<a data-startref="ix_ch11-asciidoc7" data-type="indexterm" id="idm45775545967944"/><a data-startref="ix_ch11-asciidoc6" data-type="indexterm" id="idm45775545967240"/><a data-startref="ix_ch11-asciidoc5" data-type="indexterm" id="idm45775545966568"/></p>&#13;
</li>&#13;
</ul>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Transactions" data-type="sect2"><div class="sect2" id="idm45775545965384">&#13;
<h2>Transactions</h2>&#13;
&#13;
<p><a data-primary="JDBC (Java Database Connectivity)" data-secondary="transactions" data-type="indexterm" id="ix_ch11-asciidoc8"/><a data-primary="transactions, JDBC" data-type="indexterm" id="ix_ch11-asciidoc9"/>Applications have correctness requirements that ultimately dictate&#13;
how transactions are handled. A transaction that requires repeatable-read semantics will be slower than a transaction that requires only&#13;
read-committed semantics, but knowing that is of little practical benefit&#13;
for an application that cannot tolerate nonrepeatable reads. So while this&#13;
section discusses how to use the least intrusive isolation semantics&#13;
for an application, don’t let the desire for speed overcome the correctness&#13;
of the application.</p>&#13;
&#13;
<p>Database transactions have two performance penalties. First, it takes time&#13;
for the database to set up and then commit the transaction. This involves&#13;
making sure that changes to the database are fully stored on disk, that the&#13;
database transaction logs are consistent, and so on. Second, during a&#13;
database transaction, it is common for the transaction to obtain a&#13;
lock for a particular set of data (not always a row, but I’ll use that as&#13;
the example here). If two transactions are contending for a&#13;
lock on the same database row, the scalability of the application will&#13;
suffer.  From a Java perspective, this is exactly&#13;
analogous to the discussion in <a data-type="xref" href="ch09.html#ThreadPerformance">Chapter 9</a> about contended and&#13;
uncontended locks.</p>&#13;
&#13;
<p>For optimal performance, consider both of these issues: how to&#13;
program the transactions so that the transaction itself is efficient and how&#13;
to hold locks on the database during a transaction so that the application&#13;
as a whole can scale.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="JDBC transaction control" data-type="sect3"><div class="sect3" id="idm45775545958616">&#13;
<h3>JDBC transaction control</h3>&#13;
&#13;
<p><a data-primary="transactions, JDBC" data-secondary="transaction control" data-type="indexterm" id="ix_ch11-asciidoc10"/>Transactions are present within both JDBC and JPA applications, but JPA&#13;
manages transactions differently (those details are discussed later in&#13;
this chapter).&#13;
For JDBC, transactions&#13;
begin and end based on the way the&#13;
<code class="keep-together">Connection</code>&#13;
object is used.</p>&#13;
&#13;
<p>In basic JDBC usage, connections have an autocommit mode&#13;
(set via the&#13;
<code class="keep-together">setAutoCommit()</code>&#13;
method). If autocommit is turned&#13;
on (and for most JDBC drivers, that is the default), each statement&#13;
in a JDBC program is its own transaction. In that case, a program need&#13;
take no action to commit a transaction (in fact, if&#13;
the&#13;
<code class="keep-together">commit()</code>&#13;
method is called, performance will often suffer).</p>&#13;
&#13;
<p>If autocommit is turned off, a transaction implicitly begins when the&#13;
first call is made on the connection object (e.g., by calling the&#13;
<code class="keep-together">executeQuery()</code>&#13;
method). The transaction continues until the&#13;
<code class="keep-together">commit()</code>&#13;
method (or the&#13;
<code class="keep-together">rollback()</code>&#13;
method) is called. A new transaction will begin&#13;
when the connection is used for the next database call.</p>&#13;
&#13;
<p>Transactions are expensive to commit, so one goal is to perform as much work&#13;
in a transaction as is possible. Unfortunately, that principle is completely&#13;
at odds with another goal: because transactions can hold locks,&#13;
they should be as short as possible.&#13;
There is definitely a balance here, and striking the balance will&#13;
depend on the application and its locking requirements.&#13;
The next section, on transaction isolation and locking, covers that in&#13;
more detail; first let’s&#13;
look into the options for optimizing the transaction handling itself.</p>&#13;
&#13;
<p>Consider some sample code that inserts data into a database for use by the&#13;
stock application. For each day of valid data, one row must be inserted into&#13;
the STOCKPRICE table, and five rows into the STOCKOPTIONPRICE table. A basic&#13;
loop to accomplish that looks like this:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="k">try</code> <code class="o">(</code><code class="n">Connection</code> <code class="n">c</code> <code class="o">=</code> <code class="n">DriverManager</code><code class="o">.</code><code class="na">getConnection</code><code class="o">(</code><code class="n">URL</code><code class="o">,</code> <code class="n">p</code><code class="o">))</code> <code class="o">{</code>&#13;
    <code class="k">try</code> <code class="o">(</code><code class="n">PreparedStatement</code> <code class="n">ps</code> <code class="o">=</code> <code class="n">c</code><code class="o">.</code><code class="na">prepareStatement</code><code class="o">(</code><code class="n">insertStockSQL</code><code class="o">);</code>&#13;
         <code class="n">PreparedStatement</code> <code class="n">ps2</code> <code class="o">=</code> <code class="n">c</code><code class="o">.</code><code class="na">prepareStatement</code><code class="o">(</code><code class="n">insertOptionSQL</code><code class="o">))</code> <code class="o">{</code>&#13;
        <code class="k">for</code> <code class="o">(</code><code class="n">StockPrice</code> <code class="n">sp</code> <code class="o">:</code> <code class="n">stockPrices</code><code class="o">)</code> <code class="o">{</code>&#13;
            <code class="n">String</code> <code class="n">symbol</code> <code class="o">=</code> <code class="n">sp</code><code class="o">.</code><code class="na">getSymbol</code><code class="o">();</code>&#13;
            <code class="n">ps</code><code class="o">.</code><code class="na">clearParameters</code><code class="o">();</code>&#13;
            <code class="n">ps</code><code class="o">.</code><code class="na">setBigDecimal</code><code class="o">(</code><code class="mi">1</code><code class="o">,</code> <code class="n">sp</code><code class="o">.</code><code class="na">getClosingPrice</code><code class="o">());</code>&#13;
	    <code class="o">...</code> <code class="n">set</code> <code class="n">other</code> <code class="n">parameters</code> <code class="o">...</code>&#13;
            <code class="n">ps</code><code class="o">.</code><code class="na">executeUpdate</code><code class="o">();</code>&#13;
            <code class="k">for</code> <code class="o">(</code><code class="kt">int</code> <code class="n">j</code> <code class="o">=</code> <code class="mi">0</code><code class="o">;</code> <code class="n">j</code> <code class="o">&lt;</code> <code class="mi">5</code><code class="o">;</code> <code class="n">j</code><code class="o">++)</code> <code class="o">{</code>&#13;
                <code class="n">ps2</code><code class="o">.</code><code class="na">clearParameters</code><code class="o">();</code>&#13;
                <code class="n">ps2</code><code class="o">.</code><code class="na">setBigDecimal</code><code class="o">(</code><code class="mi">1</code><code class="o">,</code>&#13;
                    <code class="n">sp</code><code class="o">.</code><code class="na">getClosingPrice</code><code class="o">().</code><code class="na">multiply</code><code class="o">(</code>&#13;
                        <code class="k">new</code> <code class="nf">BigDecimal</code><code class="o">(</code><code class="mi">1</code> <code class="o">+</code> <code class="n">j</code> <code class="o">/</code> <code class="mi">100</code><code class="o">.)));</code>&#13;
                <code class="o">...</code> <code class="n">set</code> <code class="n">other</code> <code class="n">parameters</code> <code class="o">...</code>&#13;
                <code class="n">ps2</code><code class="o">.</code><code class="na">executeUpdate</code><code class="o">();</code>&#13;
            <code class="o">}</code>&#13;
        <code class="o">}</code>&#13;
    <code class="o">}</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>In the full code, the prices are precalculated into the <code>stockPrices</code> array.&#13;
If that array represents data for the year 2019, this loop will insert&#13;
261 rows into the STOCKPRICE table (via the first call to the&#13;
<code class="keep-together">executeUpdate()</code>&#13;
method) and 1,305 rows into the STOCKOPTIONPRICE table (via the&#13;
<code>for</code> loop). In the default autocommit mode, that means 1,566 separate&#13;
transactions, which will be quite expensive.</p>&#13;
&#13;
<p>Better performance will be achieved if autocommit mode is disabled and&#13;
an explicit commit is performed at the end of the loop:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="k">try</code> <code class="o">(</code><code class="n">Connection</code> <code class="n">c</code> <code class="o">=</code> <code class="n">DriverManager</code><code class="o">.</code><code class="na">getConnection</code><code class="o">(</code><code class="n">URL</code><code class="o">,</code> <code class="n">p</code><code class="o">))</code> <code class="o">{</code>&#13;
    <code class="n">c</code><code class="o">.</code><code class="na">setAutoCommit</code><code class="o">(</code><code class="kc">false</code><code class="o">);</code>&#13;
    <code class="k">try</code> <code class="o">(</code><code class="n">PreparedStatement</code> <code class="n">ps</code> <code class="o">=</code> <code class="n">c</code><code class="o">.</code><code class="na">prepareStatement</code><code class="o">(</code><code class="n">insertStockSQL</code><code class="o">);</code>&#13;
         <code class="n">PreparedStatement</code> <code class="n">ps2</code> <code class="o">=</code> <code class="n">c</code><code class="o">.</code><code class="na">prepareStatement</code><code class="o">(</code><code class="n">insertOptionSQL</code><code class="o">))</code> <code class="o">{</code>&#13;
        <code class="o">...</code> <code class="n">same</code> <code class="n">code</code> <code class="n">as</code> <code class="n">before</code> <code class="o">....</code>&#13;
    <code class="o">}</code>&#13;
    <code class="n">c</code><code class="o">.</code><code class="na">commit</code><code class="o">();</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>From a logical point of view, that probably makes sense as well: the database&#13;
will end up with either an entire year’s worth of data or no data.</p>&#13;
&#13;
<p>If this loop is repeated for multiple stocks, we have a choice of committing&#13;
all the data at once or committing all the data for a symbol at once:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="k">try</code> <code class="o">(</code><code class="n">Connection</code> <code class="n">c</code> <code class="o">=</code> <code class="n">DriverManager</code><code class="o">.</code><code class="na">getConnection</code><code class="o">(</code><code class="n">URL</code><code class="o">,</code> <code class="n">p</code><code class="o">))</code> <code class="o">{</code>&#13;
    <code class="n">c</code><code class="o">.</code><code class="na">setAutoCommit</code><code class="o">(</code><code class="kc">false</code><code class="o">);</code>&#13;
    <code class="n">String</code> <code class="n">lastSymbol</code> <code class="o">=</code> <code class="kc">null</code><code class="o">;</code>&#13;
    <code class="k">try</code> <code class="o">(</code><code class="n">PreparedStatement</code> <code class="n">ps</code> <code class="o">=</code> <code class="n">c</code><code class="o">.</code><code class="na">prepareStatement</code><code class="o">(</code><code class="n">insertStockSQL</code><code class="o">);</code>&#13;
         <code class="n">PreparedStatement</code> <code class="n">ps2</code> <code class="o">=</code> <code class="n">c</code><code class="o">.</code><code class="na">prepareStatement</code><code class="o">(</code><code class="n">insertOptionSQL</code><code class="o">))</code> <code class="o">{</code>&#13;
        <code class="k">for</code> <code class="o">(</code><code class="n">StockPrice</code> <code class="n">sp</code> <code class="o">:</code> <code class="n">stockPrices</code><code class="o">)</code> <code class="o">{</code>&#13;
	    <code class="n">String</code> <code class="n">symbol</code> <code class="o">=</code> <code class="n">sp</code><code class="o">.</code><code class="na">getSymbol</code><code class="o">();</code>&#13;
	    <code class="k">if</code> <code class="o">(</code><code class="n">lastSymbol</code> <code class="o">!=</code> <code class="kc">null</code> <code class="o">&amp;&amp;</code> <code class="o">!</code><code class="n">symbol</code><code class="o">.</code><code class="na">equals</code><code class="o">(</code><code class="n">lastSymbol</code><code class="o">))</code> <code class="o">{</code>&#13;
		<code class="c1">// We are processing a new symbol; commit the previous symbol</code>&#13;
	        <code class="n">c</code><code class="o">.</code><code class="na">commit</code><code class="o">();</code>&#13;
	    <code class="o">}</code>&#13;
	<code class="o">}</code>&#13;
    <code class="o">}</code>&#13;
    <code class="n">c</code><code class="o">.</code><code class="na">commit</code><code class="o">();</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>Committing all the data at once offers the fastest&#13;
performance.&#13;
In this example,&#13;
though, the application semantics might&#13;
dictate that each year of data be committed individually.&#13;
Sometimes, other requirements intrude on attempts to get the best&#13;
performance.</p>&#13;
&#13;
<p>Each time the&#13;
<code class="keep-together">executeUpdate()</code>&#13;
method is executed in the preceding code,&#13;
a remote call is made to the database and work must be performed. In&#13;
addition, locking will occur when the updates are made (to ensure,&#13;
at least, that another transaction cannot insert a record for the same&#13;
symbol and date). The transaction handling can be further optimized in this&#13;
case by batching the inserts. When inserts are batched, the JDBC driver&#13;
holds them until the batch is completed; then all statements are transmitted&#13;
in one remote JDBC call.</p>&#13;
&#13;
<p>Here is how batching is achieved:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="k">try</code> <code class="o">(</code><code class="n">Connection</code> <code class="n">c</code> <code class="o">=</code> <code class="n">DriverManager</code><code class="o">.</code><code class="na">getConnection</code><code class="o">(</code><code class="n">URL</code><code class="o">,</code> <code class="n">p</code><code class="o">))</code> <code class="o">{</code>&#13;
    <code class="k">try</code> <code class="o">(</code><code class="n">PreparedStatement</code> <code class="n">ps</code> <code class="o">=</code> <code class="n">c</code><code class="o">.</code><code class="na">prepareStatement</code><code class="o">(</code><code class="n">insertStockSQL</code><code class="o">);</code>&#13;
         <code class="n">PreparedStatement</code> <code class="n">ps2</code> <code class="o">=</code> <code class="n">c</code><code class="o">.</code><code class="na">prepareStatement</code><code class="o">(</code><code class="n">insertOptionSQL</code><code class="o">))</code> <code class="o">{</code>&#13;
        <code class="k">for</code> <code class="o">(</code><code class="n">StockPrice</code> <code class="n">sp</code> <code class="o">:</code> <code class="n">stockPrices</code><code class="o">)</code> <code class="o">{</code>&#13;
            <code class="n">String</code> <code class="n">symbol</code> <code class="o">=</code> <code class="n">sp</code><code class="o">.</code><code class="na">getSymbol</code><code class="o">();</code>&#13;
            <code class="n">ps</code><code class="o">.</code><code class="na">clearParameters</code><code class="o">();</code>&#13;
            <code class="n">ps</code><code class="o">.</code><code class="na">setBigDecimal</code><code class="o">(</code><code class="mi">1</code><code class="o">,</code> <code class="n">sp</code><code class="o">.</code><code class="na">getClosingPrice</code><code class="o">());</code>&#13;
	    <code class="o">...</code> <code class="n">set</code> <code class="n">other</code> <code class="n">parameters</code> <code class="o">...</code>&#13;
            <code class="n">ps</code><code class="o">.</code><code class="na">addBatch</code><code class="o">();</code>&#13;
            <code class="k">for</code> <code class="o">(</code><code class="kt">int</code> <code class="n">j</code> <code class="o">=</code> <code class="mi">0</code><code class="o">;</code> <code class="n">j</code> <code class="o">&lt;</code> <code class="mi">5</code><code class="o">;</code> <code class="n">j</code><code class="o">++)</code> <code class="o">{</code>&#13;
                <code class="n">ps2</code><code class="o">.</code><code class="na">clearParameters</code><code class="o">();</code>&#13;
                <code class="n">ps2</code><code class="o">.</code><code class="na">setBigDecimal</code><code class="o">(</code><code class="mi">1</code><code class="o">,</code>&#13;
                    <code class="n">sp</code><code class="o">.</code><code class="na">getClosingPrice</code><code class="o">().</code><code class="na">multiply</code><code class="o">(</code>&#13;
                        <code class="k">new</code> <code class="nf">BigDecimal</code><code class="o">(</code><code class="mi">1</code> <code class="o">+</code> <code class="n">j</code> <code class="o">/</code> <code class="mi">100</code><code class="o">.)));</code>&#13;
                <code class="o">...</code> <code class="n">set</code> <code class="n">other</code> <code class="n">parameters</code> <code class="o">...</code>&#13;
                <code class="n">ps2</code><code class="o">.</code><code class="na">addBatch</code><code class="o">();</code>&#13;
            <code class="o">}</code>&#13;
        <code class="o">}</code>&#13;
	<code class="n">ps</code><code class="o">.</code><code class="na">executeBatch</code><code class="o">();</code>&#13;
	<code class="n">ps2</code><code class="o">.</code><code class="na">executeBatch</code><code class="o">();</code>&#13;
    <code class="o">}</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>The code could equally well&#13;
choose to execute each batch on a per stock basis (similar to the way we&#13;
committed after each stock symbol change).&#13;
Some JDBC drivers have a limitation on the number of statements they can&#13;
batch (and the batch does consume memory in the application), so even if&#13;
the data is committed at the end of the entire operation, the batches may&#13;
need to be executed more frequently.</p>&#13;
&#13;
<p>These optimizations can yield very large performance increases.&#13;
<a data-type="xref" href="#TableJDBCCommit">Table 11-1</a> shows the time required to insert one&#13;
year of data for 256 stocks (a total of 400,896 insertions).</p>&#13;
<table id="TableJDBCCommit">&#13;
<caption><span class="label">Table 11-1. </span>Seconds required to insert data for 256 stocks</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Programming mode</th>&#13;
<th>Time required</th>&#13;
<th>DB calls</th>&#13;
<th>DB commits</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>Autocommit enabled, no batching</p></td>&#13;
<td><p>537 ± 2 seconds</p></td>&#13;
<td><p>400,896</p></td>&#13;
<td><p>400,896</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>1 commit for each stock</p></td>&#13;
<td><p>57 ± 4 seconds</p></td>&#13;
<td><p>400,896</p></td>&#13;
<td><p>256</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>1 commit for all data</p></td>&#13;
<td><p>56 ± 14 seconds</p></td>&#13;
<td><p>400,448</p></td>&#13;
<td><p>1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>1 batch per commit for each stock</p></td>&#13;
<td><p>4.6 ± 2 seconds</p></td>&#13;
<td><p>256</p></td>&#13;
<td><p>256</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>1 batch per stock; 1 commit</p></td>&#13;
<td><p>3.9 ± 0.7 seconds</p></td>&#13;
<td><p>256</p></td>&#13;
<td><p>1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>1 batch/commit for all data</p></td>&#13;
<td><p>3.8 ± 1 seconds</p></td>&#13;
<td><p>1</p></td>&#13;
<td><p>1</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>Note one interesting fact about this table that is not immediately obvious:&#13;
the difference between rows 1 and 2 is that autocommit has been turned off&#13;
and the code is explicitly calling the&#13;
<code class="keep-together">commit()</code>&#13;
method at the end of&#13;
each&#13;
<code class="keep-together">while</code>&#13;
loop. The difference between rows 1 and 4 is that statements are being&#13;
batched—but autocommit is still enabled. A batch is considered one&#13;
transaction, which is why there is&#13;
a one-to-one correspondence between database calls and commits (and&#13;
eliminating more than 400,000 calls yields that impressive speedup).</p>&#13;
&#13;
<p>It’s also interesting to note that the difference between 400,896 and 256&#13;
calls to commit data (rows 1 and 2) is an order of magnitude, yet&#13;
the difference between having 1 and 256&#13;
commits is not really significant (i.e., the difference between rows 2 and 3,&#13;
or the differences between rows 5 and 6). Committing the data is fast enough that when there are 256 calls, the overhead is just noise; when there are 400,896 of them, it adds up.<sup><a data-type="noteref" href="ch11.html#idm45775545357736" id="idm45775545357736-marker">3</a></sup><a data-startref="ix_ch11-asciidoc10" data-type="indexterm" id="idm45775545356920"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Transaction isolation and locking" data-type="sect3"><div class="sect3" id="idm45775545957672">&#13;
<h3>Transaction isolation and locking</h3>&#13;
&#13;
<p><a data-primary="locks" data-secondary="transactions" data-type="indexterm" id="ix_ch11-asciidoc11"/><a data-primary="transactions, JDBC" data-secondary="isolation and locking" data-type="indexterm" id="ix_ch11-asciidoc12"/>The second factor affecting transaction performance concerns the&#13;
scalability of the database as data within transactions is locked. Locking&#13;
protects data integrity; in database terms, it allows one transaction&#13;
to be isolated from other transactions.&#13;
JDBC and JPA support the four major transaction isolation modes of databases,&#13;
though they differ in the way they accomplish that.</p>&#13;
&#13;
<p>Isolation modes are briefly covered here, though since programming to&#13;
a correct isolation mode isn’t really a Java-specific issue, you are urged&#13;
to consult a database programming book for more information.</p>&#13;
&#13;
<p>Here are the basic transaction isolation modes (in order&#13;
from most to least <span class="keep-together">expensive):</span></p>&#13;
<dl>&#13;
<dt>TRANSACTION_SERIALIZABLE</dt>&#13;
<dd>&#13;
<p>This is the most expensive transaction mode; it requires that all data accessed within the transaction be locked for the duration of the transaction. This applies both to data accessed via a primary key and to data accessed via a <code>WHERE</code> clause—and when there is a <code>WHERE</code> clause, the table is locked such that no new records satisfying the clause can be added for the duration of the transaction. A serialized transaction will always see the same data each time it issues a query.</p>&#13;
</dd>&#13;
<dt>TRANSACTION_REPEATABLE_READ</dt>&#13;
<dd>&#13;
<p>This requires that all accessed data is locked for the duration of the transaction. However, other transactions can insert new rows into the table at any time. This mode can lead to <em>phantom reads</em>: a transaction that reissues a query with a <code>WHERE</code> clause may get back different data the second time the query is executed.</p>&#13;
</dd>&#13;
<dt>TRANSACTION_READ_COMMITTED</dt>&#13;
<dd>&#13;
<p>This mode locks only rows that are written during a transaction. This leads to <em>nonrepeatable reads</em>: data that is read at one point in the transaction may be different from data that is read at another point in the transaction.</p>&#13;
</dd>&#13;
<dt>TRANSACTION_READ_UNCOMMITTED</dt>&#13;
<dd>&#13;
<p>This is the least expensive transaction mode. No locks are involved, so one transaction may read the written (but uncommitted) data in another transaction. This is known as a <em>dirty read</em>; the problem here arises because the first transaction may roll back (meaning the write never actually happens), and hence the second transaction is operating on incorrect data.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Databases operate in a default mode of transaction isolation: MySQL starts&#13;
with a default of <code>TRANSACTION_REPEATABLE_READ</code>; Oracle and IBM Db2 start with&#13;
a default of <code>TRANSACTION_READ_COMMITTED</code>; and so on. There are lots of&#13;
database-specific permutations here. Db2 calls its default transaction&#13;
mode <code>CS</code> (for <em>cursor stability</em>) and has different names for the other three&#13;
JDBC modes. Oracle doesn’t support either <code>TRANSACTION_READ_UNCOMMITTED</code>&#13;
or <code>TRANSACTION_REPEATABLE_READ</code>.</p>&#13;
&#13;
<p>When a JDBC statement is executed, it&#13;
uses the database’s default isolation mode. Alternately,&#13;
the&#13;
<code class="keep-together">setTransaction()</code>&#13;
method on the JDBC connection can be called&#13;
to have the database&#13;
supply the necessary transaction isolation level (and if the database doesn’t&#13;
support the given level, the JDBC driver will either throw an exception or&#13;
silently upgrade the isolation level to the next strictest level it supports).</p>&#13;
<aside class="less_space pagebreak-before" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45775545335448">&#13;
<h5>TRANSACTION_NONE and Autocommit</h5>&#13;
<p>The JDBC specification defines a fifth transaction mode, which is&#13;
<span class="keep-together"><code>TRANSACTION_NONE</code></span>. In theory, this transaction mode cannot be specified via&#13;
the&#13;
<code>setTransaction​Isola⁠tion()</code>&#13;
mode, since if a transaction&#13;
already exists, its isolation level cannot be set to none. Some JDBC drivers&#13;
(notably for Db2) do allow that call to be made (and even default&#13;
to that&#13;
mode). Other JDBC drivers will allow an isolation level of none to be specified&#13;
in the properties used to initialize the driver.</p>&#13;
&#13;
<p>In a strict sense, a statement executing from a connection with&#13;
<code>TRANSACTION_NONE</code> semantics cannot commit data to the database: it must be a&#13;
read-only query. If data is written, there must be some locking; otherwise, if one user is writing a long&#13;
string to a table using <code>TRANSACTION_NONE</code> semantics, a second user could&#13;
see a partial string written in the&#13;
table. Databases could operate in that mode, though&#13;
that would be uncommon; at the very least, data written to a single table&#13;
is expected to be written atomically. Hence, an operation that writes&#13;
will in reality have&#13;
(at least) <code>TRANSACTION_READ_UNCOMMITTED</code> semantics.</p>&#13;
&#13;
<p>A <code>TRANSACTION_NONE</code> query cannot be committed, but&#13;
JDBC drivers that use <code>TRANSACTION_NONE</code> may allow queries to be written&#13;
if autocommit is enabled.&#13;
This means that the database is treating each query as a&#13;
separate transaction. Even so, since the database is (likely) not allowing&#13;
other transactions to see partial writes,&#13;
<code>TRANSACTION_READ_UNCOMMITTED</code> semantics are really being used.</p>&#13;
</div></aside>&#13;
&#13;
<p>For simple JDBC programs, this is sufficient. More commonly—and particularly&#13;
when used with JPA—programs may want to mix isolation levels on data within&#13;
a transaction. In an application that queries my employee information so&#13;
as to ultimately give me a large raise, access to my employee record must&#13;
be protected: that data needs to be treated as <code>TRANSACTION_REPEATABLE_READ</code>.&#13;
But that transaction is also likely to access data in other tables, such&#13;
as the table that holds my office ID. There is no real&#13;
reason to lock that data during the transaction, so access&#13;
to that row could certainly operate&#13;
as <code>TRANSACTION_READ_COMMITTED</code> (or possibly even lower).</p>&#13;
&#13;
<p>JPA allows you to specify locking levels on a per entity basis (and, of&#13;
course, an entity is, at least usually, simply a row in the database). Because&#13;
getting these locking levels correct can be difficult, it is&#13;
easier to use JPA than to perform the locking in JDBC statements.&#13;
Still, it is possible to use different locking levels in JDBC applications,&#13;
employing the same pessimistic and optimistic locking semantics that JPA&#13;
uses (and if you’re not familiar with those semantics, this example should&#13;
serve as a good <span class="keep-together">introduction).</span></p>&#13;
&#13;
<p>At a JDBC level, the basic approach is to set the isolation level&#13;
of the connection to <code>TRANSACTION_READ_UNCOMMITTED</code> and then to lock explicitly&#13;
only that data that needs to be locked during the transaction:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="k">try</code> <code class="o">(</code><code class="n">Connection</code> <code class="n">c</code> <code class="o">=</code> <code class="n">DriverManager</code><code class="o">.</code><code class="na">getConnection</code><code class="o">(</code><code class="n">URL</code><code class="o">,</code> <code class="n">p</code><code class="o">))</code> <code class="o">{</code>&#13;
    <code class="n">c</code><code class="o">.</code><code class="na">setAutoCommit</code><code class="o">(</code><code class="kc">false</code><code class="o">);</code>&#13;
    <code class="n">c</code><code class="o">.</code><code class="na">setTransactionIsolation</code><code class="o">(</code><code class="n">TRANSACTION_READ_UNCOMMITTED</code><code class="o">);</code>&#13;
    <code class="k">try</code> <code class="o">(</code><code class="n">PreparedStatement</code> <code class="n">ps1</code> <code class="o">=</code> <code class="n">c</code><code class="o">.</code><code class="na">prepareStatement</code><code class="o">(</code>&#13;
        <code class="s">"SELECT * FROM employee WHERE e_id = ? FOR UPDATE"</code><code class="o">))</code> <code class="o">{</code>&#13;
        <code class="o">...</code> <code class="n">process</code> <code class="n">info</code> <code class="n">from</code> <code class="n">ps1</code> <code class="o">...</code>&#13;
    <code class="o">}</code>&#13;
    <code class="k">try</code> <code class="o">(</code><code class="n">PreparedStatement</code> <code class="n">ps2</code> <code class="o">=</code> <code class="n">c</code><code class="o">.</code><code class="na">prepareStatement</code><code class="o">(</code>&#13;
           <code class="s">"SELECT * FROM office WHERE office_id = ?"</code><code class="o">))</code> <code class="o">{</code>&#13;
        <code class="o">...</code> <code class="n">process</code> <code class="n">info</code> <code class="n">from</code> <code class="n">ps2</code> <code class="o">...</code>&#13;
    <code class="o">}</code>&#13;
    <code class="n">c</code><code class="o">.</code><code class="na">commit</code><code class="o">();</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>The <code>ps1</code> statement establishes an explicit lock on the employee&#13;
data table: no other transaction will be able to access that row for the&#13;
duration of this transaction. The SQL syntax to accomplish that is&#13;
nonstandard. You must consult your database vendor’s documentation to&#13;
see how to achieve the desired level of locking, but the common syntax&#13;
is to include the <code>FOR UPDATE</code> clause. <a data-primary="pessimistic locking" data-type="indexterm" id="idm45775545192696"/>This kind of locking&#13;
is called <em>pessimistic locking</em>. It actively prevents other transactions&#13;
from accessing the data in question.</p>&#13;
&#13;
<p><a data-primary="optimistic locking" data-type="indexterm" id="idm45775545191256"/>Locking performance can often be improved&#13;
by using optimistic locking.&#13;
If the data access is uncontended, this will be a significant&#13;
performance boost. If the data is even slightly contended, however, the&#13;
programming becomes more <span class="keep-together">difficult</span>.</p>&#13;
&#13;
<p>In a database, optimistic concurrency is implemented with a version column.&#13;
When data is selected from a row, the selection must include the desired&#13;
data plus a version&#13;
column. To select information about me, I could issue the following SQL:</p>&#13;
&#13;
<pre data-type="programlisting">SELECT first_name, last_name, version FROM employee WHERE e_id = 5058;</pre>&#13;
&#13;
<p>This query will return my names (Scott and Oaks) plus whatever the current&#13;
version number is (say, 1012).  When it comes time to complete the&#13;
transaction, the transaction updates the version column:</p>&#13;
&#13;
<pre data-type="programlisting">UPDATE employee SET version = 1013 WHERE e_id = 5058 AND version = 1012;</pre>&#13;
&#13;
<p>If the row in question requires repeatable-read or serialization semantics,&#13;
this update must be performed even if the data was only read during&#13;
the transaction—those isolation levels require locking read-only data&#13;
used in a transaction. For read-committed semantics, the version column&#13;
 needs to be updated only when other data in the row is also updated.</p>&#13;
&#13;
<p>Under this scheme, if two transactions use my&#13;
employee record at the same time, each will read a version number of 1012.&#13;
The first transaction to complete will successfully update the version number&#13;
to 1013 and continue. The second transaction will not be able to update&#13;
the employee record—there is no longer any record where the version&#13;
number is 1012, so the SQL update statement will fail.&#13;
That transaction will get an exception and be rolled back.</p>&#13;
&#13;
<p>This highlights a major difference between optimistic locking in the&#13;
database and Java’s atomic primitives: in database programming, when the&#13;
transaction gets that exception, it is not (and cannot be) transparently&#13;
retried. If you are programming directly to JDBC, the&#13;
<code class="keep-together">commit()</code>&#13;
method will&#13;
get an&#13;
<code class="keep-together">SQLException</code>;&#13;
in JPA, your application will get an&#13;
<code class="keep-together">OptimisticLockException</code>&#13;
when the transaction is <span class="keep-together">committed.</span></p>&#13;
&#13;
<p>Depending&#13;
on your perspective, this is either a good or a bad thing.&#13;
In <a data-type="xref" href="ch09.html#ThreadPerformance">Chapter 9</a>, we looked at&#13;
the performance of the atomic utilities that use CAS-based features to&#13;
avoid explicit synchronization. Those utilities are essentially using&#13;
optimistic concurrency with an infinite, automatic retry.&#13;
Performance in highly contended cases will suffer when a lot of retries are chewing up a lot of CPU&#13;
resources, though in practice that tends not to be an issue. In a database,&#13;
the situation is far worse, since the&#13;
code executed in a transaction is far more complicated than simply&#13;
incrementing the value held in a&#13;
memory location. Retrying a failed optimistic transaction in the database&#13;
has a far greater potential to lead to a never-ending spiral of retries.&#13;
Plus, it is often infeasible to determine automatically what operation(s)&#13;
to retry.</p>&#13;
&#13;
<p>So not retrying transparently is a good thing (and often the only possible&#13;
solution), but on the other hand, that&#13;
does mean the application is now responsible for handling the&#13;
exception.&#13;
The application can choose to retry the transaction (maybe only once&#13;
or twice), it can&#13;
choose to prompt the user for different data, or it can simply inform the user&#13;
that the operation has failed. No one-size-fits-all answer exists.</p>&#13;
&#13;
<p>Optimistic locking works best, then, when there is little chance of a&#13;
collision between two sources. Think of a joint checking account: there is&#13;
a slight chance that my husband and I may be in different parts of the city&#13;
withdrawing money from our checking account at exactly the same time. That&#13;
would trigger an optimistic lock exception for one of us. Even if that&#13;
does happen, asking one of us to try again is not too onerous, and now the&#13;
chance of an optimistic lock exception is virtually nil (or so I would hope;&#13;
let’s not address how frequently we make ATM withdrawals). Contrast that&#13;
scenario to something involving the sample stock application. In the real&#13;
world, that data is updated so frequently that locking it optimistically would&#13;
be counterproductive. In truth, stock applications would&#13;
frequently use no locking when possible just because of the volume of&#13;
changes, although actual trade updates would require some locking.<a data-startref="ix_ch11-asciidoc12" data-type="indexterm" id="idm45775545177592"/><a data-startref="ix_ch11-asciidoc11" data-type="indexterm" id="idm45775545176888"/></p>&#13;
<div data-type="tip"><h1>Quick Summary</h1>&#13;
<ul>&#13;
<li>&#13;
<p>Transactions affect the speed of applications in two ways: transactions are expensive to commit, and the locking associated with transactions can prevent database scaling.</p>&#13;
</li>&#13;
<li>&#13;
<p>Those two effects are antagonistic: waiting too long to commit a transaction increases the amount of time that locks associated with the transaction are held. Especially for transactions using stricter semantics, the balance should be toward committing more frequently rather than holding the locks longer.</p>&#13;
</li>&#13;
<li>&#13;
<p>For fine-grained control of transactions in JDBC, use a default <code>TRANSACTION_READ_UNCOMMITTED</code> level and explicitly lock data as needed.<a data-startref="ix_ch11-asciidoc9" data-type="indexterm" id="idm45775545171496"/><a data-startref="ix_ch11-asciidoc8" data-type="indexterm" id="idm45775545170824"/></p>&#13;
</li>&#13;
</ul>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Result Set Processing" data-type="sect2"><div class="sect2" id="idm45775545355336">&#13;
<h2>Result Set Processing</h2>&#13;
&#13;
<p><a data-primary="JDBC (Java Database Connectivity)" data-secondary="result set processing" data-type="indexterm" id="idm45775545168536"/>Typical database applications will operate on a range of data. The stock&#13;
application, for example, deals with a history of prices for an individual&#13;
stock. That history is loaded via a single <code>SELECT</code> statement:</p>&#13;
&#13;
<pre data-type="programlisting">SELECT * FROM stockprice WHERE symbol = 'TPKS' AND&#13;
	pricedate &gt;= '2019-01-01' AND pricedate &lt;= '2019-12-31';</pre>&#13;
&#13;
<p>That statement returns 261 rows of data. If the option prices for the&#13;
stock are also required,&#13;
a similar query would be executed that would&#13;
retrieve five times that amount of data. The SQL to retrieve all&#13;
data in the sample database (256 stocks covering one year) will&#13;
retrieve 400,896 rows of data:</p>&#13;
&#13;
<pre data-type="programlisting">SELECT * FROM stockprice s, stockoptionprice o WHERE&#13;
	o.symbol = s.symbol AND s.pricedate &gt;= '2019-01-01'&#13;
	AND s.pricedate &lt;= '2019-12-31';</pre>&#13;
&#13;
<p>To use this data, code must scroll through the result set:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="k">try</code> <code class="o">(</code><code class="n">PreparedStatement</code> <code class="n">ps</code> <code class="o">=</code> <code class="n">c</code><code class="o">.</code><code class="na">prepareStatement</code><code class="o">(...))</code> <code class="o">{</code>&#13;
    <code class="k">try</code> <code class="o">(</code><code class="n">ResultSet</code> <code class="n">rs</code> <code class="o">=</code> <code class="n">ps</code><code class="o">.</code><code class="na">executeQuery</code><code class="o">())</code> <code class="o">{</code>&#13;
        <code class="k">while</code> <code class="o">(</code><code class="n">rs</code><code class="o">.</code><code class="na">next</code><code class="o">())</code> <code class="o">{</code>&#13;
            <code class="o">...</code> <code class="n">read</code> <code class="n">the</code> <code class="n">current</code> <code class="n">row</code> <code class="o">...</code>&#13;
        <code class="o">}</code>&#13;
    <code class="o">}</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>The question here is where that data for the 400,896 rows&#13;
lives. If the entire set of data is returned during the&#13;
<code class="keep-together">executeQuery()</code>&#13;
call, the application will have a very large chunk of live data in its&#13;
heap, probably causing GC and other issues. Instead, if only one row of data&#13;
is returned from the call to the&#13;
<code class="keep-together">next()</code>&#13;
method, a lot of <span class="keep-together">back-and-forth</span>&#13;
traffic will occur between the application and the database as the result set is&#13;
processed.</p>&#13;
&#13;
<p>As usual, there is no correct answer here; in some cases it will be more&#13;
efficient to keep the bulk of the data in the database and retrieve it&#13;
as needed, while in other cases it will be more efficient to load all the&#13;
data at once when the query is executed. To control this, use the&#13;
<code class="keep-together">setFetchSize()</code>&#13;
method on the&#13;
<code class="keep-together">PreparedStatement</code>&#13;
object to let the JDBC driver&#13;
know how many rows at a time it should transfer.</p>&#13;
&#13;
<p>The default value for&#13;
this varies by JDBC driver; for example, in Oracle’s JDBC drivers, the&#13;
default value is 10. When the&#13;
<code class="keep-together">executeQuery()</code>&#13;
method is called in the loop shown previously,&#13;
the database will return 10 rows of data, which will be&#13;
buffered internally by the JDBC driver. Each of the first 10 calls to&#13;
the&#13;
<code class="keep-together">next()</code>&#13;
method will process one of those buffered rows. The 11th&#13;
call will return to the database to retrieve another 10 rows, and so on.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45775545086776">&#13;
<h5>Other Ways to Set the Fetch Size</h5>&#13;
<p>I’ve recommended using the&#13;
<code class="keep-together">setFetchSize()</code>&#13;
method here on the (prepared)&#13;
statement object, but that method also exists on the&#13;
<code class="keep-together">ResultSet</code>&#13;
interface.&#13;
In either case, the size is just a hint. The JDBC driver is&#13;
free to ignore that value, round it to another value, or do anything&#13;
else it wants to do. There are no assurances either way, but setting the value&#13;
before the query is executed (i.e., on the statement object)&#13;
is more likely to result in the hint being&#13;
honored.</p>&#13;
&#13;
<p>Some JDBC drivers also allow you to set a default fetch size when the&#13;
connection is created by passing a property to the&#13;
<code class="keep-together">getConnection()</code>&#13;
method of the&#13;
<code class="keep-together">DriverManager</code>.&#13;
Consult your vendor’s documentation if&#13;
that path seems easier to manage.</p>&#13;
</div></aside>&#13;
&#13;
<p>Though the value varies, JDBC drivers will typically set the default fetch&#13;
size to a fairly small number. That approach is reasonable in most&#13;
circumstances; in&#13;
particular, it is unlikely to lead to any memory issues within the&#13;
application. If the performance of the&#13;
<code class="keep-together">next()</code>&#13;
method&#13;
(or the performance of the first getter method on the result set) is&#13;
particularly slow every now and then, consider increasing the&#13;
fetch size.</p>&#13;
<div data-type="tip"><h1>Quick Summary</h1>&#13;
<ul>&#13;
<li>&#13;
<p>Applications that process large amounts of data from a query should consider changing the fetch size of the data.</p>&#13;
</li>&#13;
<li>&#13;
<p>A trade-off exists between loading too much data in the application (putting pressure on the garbage collector) and making frequent database calls to retrieve a set of data.<a data-startref="ix_ch11-asciidoc2" data-type="indexterm" id="idm45775545076888"/><a data-startref="ix_ch11-asciidoc1" data-type="indexterm" id="idm45775545076184"/></p>&#13;
</li>&#13;
</ul>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="JPA" data-type="sect1"><div class="sect1" id="idm45775545169512">&#13;
<h1>JPA</h1>&#13;
&#13;
<p><a data-primary="databases" data-secondary="JPA" data-type="indexterm" id="ix_ch11-asciidoc13"/><a data-primary="JPA (Java Persistence API)" data-type="indexterm" id="ix_ch11-asciidoc14"/>The performance of JPA is directly affected by the performance of the&#13;
underlying JDBC driver, and most of the performance considerations regarding&#13;
the JDBC driver apply&#13;
to JPA. JPA has additional performance considerations.</p>&#13;
&#13;
<p>JPA achieves many of its performance enhancements by altering the bytecode&#13;
of the entity classes. In most server frameworks,&#13;
this happens transparently. In a Java SE environment, it is important&#13;
to make sure that the bytecode processing is set up correctly. Otherwise,&#13;
JPA application performance will be unpredictable: fields that are&#13;
expected to&#13;
be loaded lazily might be loaded eagerly, data saved to the database might&#13;
be redundant, data that should be in the JPA cache may need to be refetched&#13;
from the database, and so on.</p>&#13;
&#13;
<p>There is no JPA-defined way for the bytecode to be processed. Typically,&#13;
this is done as part of compilation—after the entity classes are compiled&#13;
(and before they are loaded into JAR files or run by the JVM), they are&#13;
passed through an implementation-specific postprocessor that “enhances”&#13;
the bytecode, producing an altered class file with the desired optimizations.&#13;
Hibernate, for example, does this via a Maven or Gradle plug-in during&#13;
compilation.</p>&#13;
&#13;
<p>Some JPA implementations also provide a way to dynamically enhance the&#13;
bytecode as the classes are loaded into the JVM. This requires running&#13;
an agent within the JVM that is notified when classes are loaded; the&#13;
agent interposes on the classloading and alters the bytes before they are&#13;
used to&#13;
define the class. The agent is specified on the command line of the&#13;
application; for example, for EclipseLink you include the&#13;
<span class="keep-together"><code>-javaagent:path_to/eclipselink.jar</code></span>&#13;
argument.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Optimizing JPA Writes" data-type="sect2"><div class="sect2" id="idm45775545067544">&#13;
<h2>Optimizing JPA Writes</h2>&#13;
&#13;
<p><a data-primary="JPA (Java Persistence API)" data-secondary="optimizing writes" data-type="indexterm" id="ix_ch11-asciidoc15"/>In JDBC, we looked at two critical performance&#13;
techniques: reusing prepared statements and performing updates in batches. It is possible to accomplish both of those optimizations with JPA, but the&#13;
way it is done depends on the JPA implementation in use; there are&#13;
no calls within the JPA API to do that. For Java SE, these optimizations&#13;
typically require setting a particular property in the application’s&#13;
<em>persistence.xml</em> file.</p>&#13;
<aside class="less_space pagebreak-before" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45775545063688">&#13;
<h5>Writing Fewer Fields</h5>&#13;
<p>One common way to optimize writes to a database is to write only those fields&#13;
that have changed. The code the HR system uses to double my salary may need&#13;
to retrieve 20 fields from my employee record, but only one (very important)&#13;
field needs to be written back to the database.</p>&#13;
&#13;
<p>JPA implementations should be expected to perform this optimization&#13;
transparently. This is one of the reasons JPA bytecode must be enhanced,&#13;
since that is the process by which the JPA provider keeps track of when values&#13;
in the code are changed. When the JPA code is properly enhanced, the SQL&#13;
to write my doubled salary back to the database will update only that single&#13;
column.</p>&#13;
</div></aside>&#13;
&#13;
<p>For example, using the JPA EclipseLink reference implementation, statement&#13;
reuse is enabled by adding the following property to the <em>persistence.xml</em>&#13;
file:</p>&#13;
&#13;
<pre data-type="programlisting">      &lt;property name="eclipselink.jdbc.cache-statements" value="true" /&gt;</pre>&#13;
&#13;
<p>Note that this enables statement reuse within the EclipseLink implementation.&#13;
If the JDBC driver is capable of providing a statement pool, it is usually&#13;
preferable to enable the statement caching in the driver and to leave this&#13;
property out of the JPA <span class="keep-together">configuration.</span></p>&#13;
&#13;
<p>Statement batching in the reference JPA implementation is achieved by&#13;
adding these properties:</p>&#13;
&#13;
<pre data-type="programlisting">      &lt;property name="eclipselink.jdbc.batch-writing" value="JDBC" /&gt;&#13;
      &lt;property name="eclipselink.jdbc.batch-writing.size" value="10000" /&gt;</pre>&#13;
&#13;
<p>JDBC drivers cannot automatically implement statement batching, so this is&#13;
a useful property to set in all cases. The batch size can be controlled in&#13;
two ways: first, the&#13;
<code class="keep-together">size</code>&#13;
property can be set, as is done in this example.&#13;
Second, the application can periodically call the&#13;
<code class="keep-together">flush()</code>&#13;
method of the&#13;
entity manager, which will cause all batched statements to be executed&#13;
immediately.</p>&#13;
&#13;
<p><a data-type="xref" href="#TableJPAWrite">Table 11-2</a> shows the effect of the statement reuse and batching&#13;
to create and write stock entities into the&#13;
database.</p>&#13;
<table id="TableJPAWrite">&#13;
<caption><span class="label">Table 11-2. </span>Seconds required to insert data for 256 stocks via JPA</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Programming mode</th>&#13;
<th>Time required</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>No batching, no statement pool</p></td>&#13;
<td><p>83 ± 3 seconds</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>No batching, statement pool</p></td>&#13;
<td><p>64 ± 5 seconds</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Batching, no statement pool</p></td>&#13;
<td><p>10 ± 0.4 seconds</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Batching, statement pooling</p></td>&#13;
<td><p>10 ± 0.3 seconds</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<div data-type="tip"><h1>Quick Summary</h1>&#13;
<ul>&#13;
<li>&#13;
<p>JPA applications, like JDBC applications, can benefit from limiting the number of write calls to the database (with the potential trade-off of holding transaction locks).</p>&#13;
</li>&#13;
<li>&#13;
<p>Statement caching can be achieved at the JPA layer or the JDBC layer. Caching at the JDBC layer should be explored first.</p>&#13;
</li>&#13;
<li>&#13;
<p>Batching JPA updates can be done declaratively (in the <em>persistence.xml</em> file) or programmatically (by calling the&#13;
<code class="keep-together">flush()</code> method).<a data-startref="ix_ch11-asciidoc15" data-type="indexterm" id="idm45775545017496"/></p>&#13;
</li>&#13;
</ul>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Optimizing JPA Reads" data-type="sect2"><div class="sect2" id="idm45775545066952">&#13;
<h2>Optimizing JPA Reads</h2>&#13;
&#13;
<p><a data-primary="JPA (Java Persistence API)" data-secondary="optimizing reads" data-type="indexterm" id="ix_ch11-asciidoc16"/>Optimizing when and how JPA reads data from the database is more&#13;
complicated than it might seem, because JPA will cache data in&#13;
the hope that it might be used to satisfy a future request. That’s&#13;
usually a good thing for performance, but it means that the JPA-generated&#13;
SQL used to read that data may seem, on the face of it, suboptimal.&#13;
The data retrieval is optimized to serve the needs of the JPA cache,&#13;
rather than being optimized for whatever particular request is in progress.</p>&#13;
&#13;
<p>The details of the cache are covered in the next section. For now, let’s&#13;
look at the basic ways to apply database read optimizations&#13;
to JPA. JPA reads data from the database in three cases: when the&#13;
<code class="keep-together">find()</code>&#13;
method of the&#13;
<code class="keep-together">EntityManager</code>&#13;
is called, when a JPA query is executed,&#13;
and when code navigates to a new&#13;
entity using the relationship of an existing entity. In the stock class,&#13;
that latter case means calling the&#13;
<code class="keep-together">getOptions()</code>&#13;
method on a&#13;
<code class="keep-together">Stock</code>&#13;
entity.</p>&#13;
&#13;
<p>Calling the&#13;
<code class="keep-together">find()</code>&#13;
method is the most straightforward case: only a single row is involved, and (at least) that single row is read&#13;
from the database.&#13;
The only thing that can be controlled is the amount of data retrieved.&#13;
JPA can retrieve only some of the fields in the row, it can retrieve the&#13;
entire row, or it can prefetch other entities related to the row being retrieved.&#13;
Those optimizations apply to queries as well.</p>&#13;
&#13;
<p>Two possible paths are available: read less data (because the&#13;
data won’t be needed) or read more data at a time (because that&#13;
data will definitely be needed in the future).</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Reading less data" data-type="sect3"><div class="sect3" id="idm45775545007096">&#13;
<h3>Reading less data</h3>&#13;
&#13;
<p>To read less data, specify that the field in question is loaded lazily.&#13;
When an entity is retrieved, the fields with a lazy annotation will be&#13;
excluded from the SQL used to load the data. If the getter of that field&#13;
is ever executed,&#13;
it will mean another trip to the database to retrieve that&#13;
piece of data.</p>&#13;
&#13;
<p>It is rare to use that annotation for simple columns of basic types, but&#13;
consider using it if the entity contains large BLOB- or CLOB-based&#13;
objects:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="nd">@Lob</code>&#13;
<code class="nd">@Column</code><code class="o">(</code><code class="n">name</code> <code class="o">=</code> <code class="s">"IMAGEDATA"</code><code class="o">)</code>&#13;
<code class="nd">@Basic</code><code class="o">(</code><code class="n">fetch</code> <code class="o">=</code> <code class="n">FetchType</code><code class="o">.</code><code class="na">LAZY</code><code class="o">)</code>&#13;
<code class="kd">private</code> <code class="kt">byte</code><code class="o">[]</code> <code class="n">imageData</code><code class="o">;</code></pre>&#13;
&#13;
<p>In this case, the entity is mapped to a table storing binary image data.&#13;
The binary data is large, and the example assumes it&#13;
shouldn’t be loaded unless it is needed. Not loading&#13;
the unneeded data&#13;
in this case serves two purposes: it makes for faster SQL when the entity is&#13;
retrieved, and it saves a lot of memory, leading to less GC pressure.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45775544980952">&#13;
<h5>Fetch Groups</h5>&#13;
<p><a data-primary="fetch groups" data-type="indexterm" id="idm45775544979912"/><a data-primary="JPA (Java Persistence API)" data-secondary="fetch groups" data-type="indexterm" id="idm45775544979208"/>If an entity has fields that are loaded lazily, they are normally loaded one&#13;
at a time as they are accessed. What if, say, three fields in an entity are subject to lazy&#13;
loading, and if one field is needed, all of them will be needed? Then it is&#13;
preferable to load all the lazy fields at once.</p>&#13;
&#13;
<p>That is not possible with standard JPA, but most JPA implementations will&#13;
allow you to specify a <em>fetch group</em> to accomplish this. Using fetch groups,&#13;
it is possible to specify that certain lazily loaded fields should be loaded&#13;
as a group whenever one of them is accessed. Typically,&#13;
multiple independent groups of fields can be defined; each group will be&#13;
loaded as needed.</p>&#13;
&#13;
<p>Because it is not a JPA standard, code using fetch groups will be tied to&#13;
one particular JPA implementation. But if it is useful, consult your JPA&#13;
implementation documentation for details.</p>&#13;
</div></aside>&#13;
&#13;
<p>Note also that the lazy annotation is, in the end, only a hint to the JPA&#13;
implementation. The JPA implementation is free to request that the&#13;
database eagerly provide that data anyway.</p>&#13;
&#13;
<p>On the other hand, perhaps other data should be preloaded—for example, when one&#13;
entity is&#13;
fetched, data for other (related) entities should also be returned.&#13;
<a data-primary="eager fetching" data-type="indexterm" id="idm45775544974712"/>That is known as <em>eager fetching</em>, and it has a similar annotation:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="nd">@OneToMany</code><code class="o">(</code><code class="n">mappedBy</code><code class="o">=</code><code class="s">"stock"</code><code class="o">,</code> <code class="n">fetch</code><code class="o">=</code><code class="n">FetchType</code><code class="o">.</code><code class="na">EAGER</code><code class="o">)</code>&#13;
<code class="kd">private</code> <code class="n">Collection</code><code class="o">&lt;</code><code class="n">StockOptionPriceImpl</code><code class="o">&gt;</code> <code class="n">optionsPrices</code><code class="o">;</code></pre>&#13;
&#13;
<p>By default, related entities are already fetched eagerly if the relationship&#13;
type is&#13;
<code class="keep-together">@OneToOne</code>&#13;
or&#13;
<code class="keep-together">@ManyToOne</code>&#13;
(and so it is possible to apply the&#13;
opposite optimization to them: mark them as&#13;
<code class="keep-together">FetchType.LAZY</code>&#13;
if they are almost never used).</p>&#13;
&#13;
<p>This also is just a hint to the JPA implementation, but it essentially says&#13;
that anytime a stock price is retrieved, make sure also to retrieve all&#13;
related option prices. Beware here:&#13;
a common expectation about eager relationship fetching is that it will&#13;
employ a <code>JOIN</code> in the generated SQL. In typical JPA providers, that is not&#13;
the case: they will issue a single SQL query to fetch the primary object,&#13;
and then one or more SQL commands to fetch any additional, related objects.&#13;
From a simple&#13;
<code class="keep-together">find()</code>&#13;
method, there is no control over this: if&#13;
a <code>JOIN</code> statement is required, you will have to use a query and&#13;
program the <code>JOIN</code> into the query.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using JOIN in queries" data-type="sect3"><div class="sect3" id="idm45775545006472">&#13;
<h3>Using JOIN in queries</h3>&#13;
&#13;
<p><a data-primary="JOIN queries" data-type="indexterm" id="idm45775544922072"/><a data-primary="JPA (Java Persistence API)" data-secondary="using JOIN in queries" data-type="indexterm" id="idm45775544921368"/>The JPA Query Language (JPQL) doesn’t allow you to specify fields of an object to be&#13;
retrieved. Take the following JPQL query:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">Query</code> <code class="n">q</code> <code class="o">=</code> <code class="n">em</code><code class="o">.</code><code class="na">createQuery</code><code class="o">(</code><code class="s">"SELECT s FROM StockPriceImpl s"</code><code class="o">);</code></pre>&#13;
&#13;
<p>That query will always yield this&#13;
SQL statement:</p>&#13;
&#13;
<pre data-type="programlisting">SELECT &lt;enumerated list of non-LAZY fields&gt; FROM StockPriceTable</pre>&#13;
&#13;
<p>If you want to retrieve fewer fields in the generated SQL, you&#13;
have no option but to mark them as lazy. Similarly, for fields that are&#13;
marked as lazy, there is no real option for fetching them in a query.</p>&#13;
&#13;
<p>If relationships exist between entities, the entities can be explicitly&#13;
joined in&#13;
a query in JPQL, which will retrieve the initial entities and their related&#13;
entities in one shot. For example, in the stock entities, this query can&#13;
be issued:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">Query</code> <code class="n">q</code> <code class="o">=</code> <code class="n">em</code><code class="o">.</code><code class="na">createQuery</code><code class="o">(</code><code class="s">"SELECT s FROM StockOptionImpl s "</code> <code class="o">+</code>&#13;
			 <code class="s">"JOIN FETCH s.optionsPrices"</code><code class="o">);</code></pre>&#13;
&#13;
<p>That results in an SQL statement similar to this:</p>&#13;
&#13;
<pre data-type="programlisting">SELECT t1.&lt;fields&gt;, t0.&lt;fields&gt; FROM StockOptionPrice t0, StockPrice t1&#13;
WHERE ((t0.SYMBOL = t1.SYMBOL) AND (t0.PRICEDATE = t1.PRICEDATE))</pre>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45775544877192">&#13;
<h5>Other Mechanisms for a Join Fetch</h5>&#13;
<p>Many JPA providers allow a join fetch to be specified by setting query&#13;
hints on a query. For example, in EclipseLink, this code will produce&#13;
a <code>JOIN</code> query:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">Query</code> <code class="n">q</code> <code class="o">=</code> <code class="n">em</code><code class="o">.</code><code class="na">createQuery</code><code class="o">(</code><code class="s">"SELECT s FROM StockOptionImpl s"</code><code class="o">);</code>&#13;
<code class="n">q</code><code class="o">.</code><code class="na">setQueryHint</code><code class="o">(</code><code class="s">"eclipselink.join-fetch"</code><code class="o">,</code> <code class="s">"s.optionsPrices"</code><code class="o">);</code></pre>&#13;
&#13;
<p>Some JPA providers also have a special <code>@JoinFetch</code> annotation that&#13;
can be used on the relationship.</p>&#13;
</div></aside>&#13;
&#13;
<p>The exact SQL will differ among JPA providers (this example is from&#13;
EclipseLink), but this is the general process.</p>&#13;
&#13;
<p>Join fetching is valid for entity relationships regardless of whether they&#13;
are annotated as eager or lazy. If the join is issued on a lazy relationship,&#13;
the lazily annotated entities that satisfy the query are still retrieved from&#13;
the database, and if those entities are later used, no additional trip to the&#13;
database is required.</p>&#13;
&#13;
<p>When all the data returned by a query using a join fetch will be used, the join fetch  often provides a big improvement in performance.&#13;
However, a join fetch&#13;
also interacts with the JPA cache in unexpected ways. An example&#13;
 is shown in <a data-type="xref" href="#JPACaching">“JPA Caching”</a>; be sure you understand those&#13;
ramifications before writing custom queries using a join fetch.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Batching and queries" data-type="sect3"><div class="sect3" id="idm45775544923048">&#13;
<h3>Batching and queries</h3>&#13;
&#13;
<p><a data-primary="JPA (Java Persistence API)" data-secondary="batching and queries" data-type="indexterm" id="idm45775544804344"/>JPA queries are handled like a JDBC query yielding a result&#13;
set: the JPA implementation has the option of getting all the results at&#13;
once, getting the results one at a time as the application iterates over&#13;
the query results, or getting a few results at a time (analogous to how&#13;
the fetch size worked for JDBC).</p>&#13;
&#13;
<p>There is no standard way to control this, but JPA vendors&#13;
have proprietary mechanisms to set the fetch size. In EclipseLink, a&#13;
hint on the query specifies the fetch size:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">q</code><code class="o">.</code><code class="na">setHint</code><code class="o">(</code><code class="s">"eclipselink.JDBC_FETCH_SIZE"</code><code class="o">,</code> <code class="s">"100000"</code><code class="o">);</code></pre>&#13;
&#13;
<p>Hibernate offers a custom&#13;
<code class="keep-together">@BatchSize</code>&#13;
annotation instead.</p>&#13;
&#13;
<p>If a very large set of data is being processed, the code may need to page&#13;
through&#13;
the list returned by the query. This has a natural relationship to how the&#13;
data might be displayed to the user on a web page: a subset of data is&#13;
displayed (say 100 rows), along with Next and Previous page links to&#13;
navigate (page) through the data.</p>&#13;
&#13;
<p>This is accomplished by setting a range on the query:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">Query</code> <code class="n">q</code> <code class="o">=</code> <code class="n">em</code><code class="o">.</code><code class="na">createNamedQuery</code><code class="o">(</code><code class="s">"selectAll"</code><code class="o">);</code>&#13;
<code class="n">query</code><code class="o">.</code><code class="na">setFirstResult</code><code class="o">(</code><code class="mi">101</code><code class="o">);</code>&#13;
<code class="n">query</code><code class="o">.</code><code class="na">setMaxResults</code><code class="o">(</code><code class="mi">100</code><code class="o">);</code>&#13;
<code class="n">List</code><code class="o">&lt;?</code> <code class="kd">implements</code> <code class="n">StockPrice</code><code class="o">&gt;</code>  <code class="o">=</code> <code class="n">q</code><code class="o">.</code><code class="na">getResultList</code><code class="o">();</code></pre>&#13;
&#13;
<p>This returns a list suitable for display on the second page of the&#13;
web application: items 101–200. Retrieving only the range of data&#13;
needed will be more efficient than retrieving 200 rows and&#13;
discarding the first 100 of them.</p>&#13;
&#13;
<p>Note that this example uses a named query&#13;
(the&#13;
<code class="keep-together">createNamedQuery()</code>&#13;
method) rather&#13;
than an ad hoc query (the&#13;
<code class="keep-together">createQuery()</code>&#13;
method). In many JPA implementations, named&#13;
queries are faster: the JPA implementation will almost always use a prepared&#13;
statement with bind parameters, utilizing the statement cache pool.&#13;
Nothing prevents JPA implementations from using similar logic for&#13;
unnamed, ad hoc queries, though implementing that is more difficult,&#13;
and the JPA&#13;
implementation may simply default to creating a new statement (i.e., a&#13;
<code class="keep-together">Statement</code>&#13;
object) each time.</p>&#13;
<div data-type="tip"><h1>Quick Summary</h1>&#13;
<ul>&#13;
<li>&#13;
<p>JPA can perform several optimizations to limit (or increase) the amount of data read in a single operation.</p>&#13;
</li>&#13;
<li>&#13;
<p>Large fields (e.g., BLOBs) that are not frequently used should be loaded lazily in a JPA entity.</p>&#13;
</li>&#13;
<li>&#13;
<p>When a relationship exists between JPA entities, the data for the related items can be loaded eagerly or lazily. The choice depends on the needs of the application.</p>&#13;
</li>&#13;
<li>&#13;
<p>When eagerly loading relationships, named queries can be used to issue a single SQL statement using a <code>JOIN</code> statement. Be aware that this affects the JPA cache; it is not always the best idea (as the next section discusses).</p>&#13;
</li>&#13;
<li>&#13;
<p>Reading data via named queries will often be faster than a regular query, since it is easier for the JPA implementation to use a&#13;
<code class="keep-together">PreparedStatement</code> for named queries.<a data-startref="ix_ch11-asciidoc16" data-type="indexterm" id="idm45775544709384"/></p>&#13;
</li>&#13;
</ul>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="JPA Caching" data-type="sect2"><div class="sect2" id="JPACaching">&#13;
<h2>JPA Caching</h2>&#13;
&#13;
<p><a data-primary="database caching" data-type="indexterm" id="ix_ch11-asciidoc17"/><a data-primary="JPA (Java Persistence API)" data-secondary="caching" data-type="indexterm" id="ix_ch11-asciidoc18"/>One of the canonical performance-related use cases for Java is to supply a&#13;
middle tier that caches data from backend database resources. The Java&#13;
tier performs architecturally useful functions (such as preventing&#13;
clients from directly accessing the database). From a performance perspective,&#13;
caching frequently used data in the Java tier can greatly speed up response&#13;
times for the clients.</p>&#13;
&#13;
<p>JPA is designed with that architecture in mind.&#13;
Two kinds of caches exist in JPA. Each entity manager instance is&#13;
its own cache: it will locally cache data that it has retrieved during a&#13;
transaction. It will also locally cache data that is written during a&#13;
transaction; the data is sent to the database only when the transaction&#13;
commits. A program may have many entity manager&#13;
instances, each executing a different transaction, and each with its&#13;
own local cache. (In particular, the entity managers injected into Java&#13;
servers are distinct instances.)</p>&#13;
&#13;
<p>When an entity manager commits a transaction, all data in the local cache&#13;
can be merged into a global cache. The global cache is shared among all entity&#13;
managers in the application. The global cache is also known as the <em>Level 2&#13;
(L2) cache</em> or the <em>second-level cache</em>; the cache in the entity manager is&#13;
known as the <em>Level 1</em>, <em>L1</em>, or <em>first-level cache</em>.</p>&#13;
&#13;
<p>There is little to tune within an entity manager transaction cache (the L1 cache),&#13;
and the L1 cache is enabled in all JPA implementations. The L2 cache&#13;
is different: most JPA implementations provide one, but not all of them&#13;
enable it by default (e.g., Hibernate does not, but EclipseLink does).&#13;
Once enabled, the way in which the L2 cache is tuned and used&#13;
can substantially affect performance.</p>&#13;
&#13;
<p>The JPA cache operates only on entities accessed by their primary keys, that is, items retrieved from a call to the&#13;
<code class="keep-together">find()</code>&#13;
method, or items&#13;
retrieved from accessing (or eagerly loading) a related entity. When the&#13;
entity manager attempts to find an object via either its primary key or&#13;
a relationship mapping, it can look in the L2 cache and return the object(s)&#13;
if they are found there, thus saving a trip to the database.</p>&#13;
&#13;
<p>Items&#13;
retrieved via a query are not held in the L2 cache.&#13;
Some&#13;
JPA implementations do have a vendor-specific mechanism to cache the results&#13;
of a query, but those results are reused only if the exact same query is&#13;
reexecuted. Even if the JPA implementation supports query caching,&#13;
the entities themselves are not stored in the L2 cache and cannot be returned&#13;
in a subsequent call to the&#13;
<code class="keep-together">find()</code>&#13;
method.</p>&#13;
&#13;
<p>The connections between the L2 cache, queries,&#13;
and the loading of objects affect performance in many ways.&#13;
To examine them, code based on&#13;
the following loop will be used:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">EntityManager</code><code> </code><code class="n">em</code><code> </code><code class="o">=</code><code> </code><code class="n">emf</code><code class="o">.</code><code class="na">createEntityManager</code><code class="o">(</code><code class="o">)</code><code class="o">;</code><code>&#13;
</code><code class="n">Query</code><code> </code><code class="n">q</code><code> </code><code class="o">=</code><code> </code><code class="n">em</code><code class="o">.</code><code class="na">createNamedQuery</code><code class="o">(</code><code class="n">queryName</code><code class="o">)</code><code class="o">;</code><code>&#13;
</code><code class="n">List</code><code class="o">&lt;</code><code class="n">StockPrice</code><code class="o">&gt;</code><code> </code><code class="n">l</code><code> </code><code class="o">=</code><code> </code><code class="n">q</code><code class="o">.</code><code class="na">getResultList</code><code class="o">(</code><code class="o">)</code><code class="o">;</code><code> </code><a class="co" href="#callout_database_performance_best_practices_CO1-1" id="co_database_performance_best_practices_CO1-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code class="k">for</code><code> </code><code class="o">(</code><code class="n">StockPrice</code><code> </code><code class="n">sp</code><code> </code><code class="o">:</code><code> </code><code class="n">l</code><code class="o">)</code><code> </code><code class="o">{</code><code>&#13;
</code><code>    </code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code> </code><code class="n">process</code><code> </code><code class="n">sp</code><code> </code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>&#13;
</code><code>    </code><code class="k">if</code><code> </code><code class="o">(</code><code class="n">processOptions</code><code class="o">)</code><code> </code><code class="o">{</code><code>&#13;
</code><code>        </code><code class="n">Collection</code><code class="o">&lt;</code><code class="o">?</code><code> </code><code class="kd">extends</code><code> </code><code class="n">StockOptionPrice</code><code class="o">&gt;</code><code> </code><code class="n">options</code><code> </code><code class="o">=</code><code> </code><code class="n">sp</code><code class="o">.</code><code class="na">getOptions</code><code class="o">(</code><code class="o">)</code><code class="o">;</code><code> </code><a class="co" href="#callout_database_performance_best_practices_CO1-2" id="co_database_performance_best_practices_CO1-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
</code><code>        </code><code class="k">for</code><code> </code><code class="o">(</code><code class="n">StockOptionPrice</code><code> </code><code class="n">sop</code><code> </code><code class="o">:</code><code> </code><code class="n">options</code><code class="o">)</code><code> </code><code class="o">{</code><code>&#13;
</code><code>	    </code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code> </code><code class="n">process</code><code> </code><code class="n">sop</code><code> </code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>&#13;
</code><code>        </code><code class="o">}</code><code>&#13;
</code><code>    </code><code class="o">}</code><code>&#13;
</code><code class="o">}</code><code>&#13;
</code><code class="n">em</code><code class="o">.</code><code class="na">close</code><code class="o">(</code><code class="o">)</code><code class="o">;</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_database_performance_best_practices_CO1-1" id="callout_database_performance_best_practices_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>SQL Call Site 1</p></dd>&#13;
<dt><a class="co" href="#co_database_performance_best_practices_CO1-2" id="callout_database_performance_best_practices_CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>SQL Call Site 2</p></dd>&#13;
</dl>&#13;
&#13;
<p>Because of the L2 cache, this loop will perform one way the first time it&#13;
is executed, and another (generally faster) way on subsequent executions.&#13;
The specific difference of that performance depends on various details of&#13;
the queries and the entity relationships. The next few subsections&#13;
explain the results in detail.</p>&#13;
&#13;
<p>The differences in this example are based in&#13;
some cases on different JPA&#13;
configurations but also occur because some tests are executed without&#13;
traversing the relationship between the&#13;
<span class="keep-together"><code>Stock</code></span>&#13;
and&#13;
<span class="keep-together"><code>StockOptions</code></span>&#13;
classes.&#13;
In those tests without traversal of the relationship, the&#13;
<span class="keep-together"><code>processOptions</code></span>&#13;
value in the loop is <code>false</code>; only the&#13;
<span class="keep-together"><code>StockPrice</code></span>&#13;
objects are actually used.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Default caching (lazy loading)" data-type="sect3"><div class="sect3" id="idm45775544507880">&#13;
<h3>Default caching (lazy loading)</h3>&#13;
&#13;
<p><a data-primary="database caching" data-secondary="default (lazy loading)" data-type="indexterm" id="idm45775544506344"/><a data-primary="lazy loading" data-type="indexterm" id="idm45775544465080"/>In the sample code, the stock prices are loaded via a named query.&#13;
In the default case, this simple query is executed to load the stock data:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="nd">@NamedQuery</code><code class="o">(</code><code class="n">name</code><code class="o">=</code><code class="s">"findAll"</code><code class="o">,</code>&#13;
    <code class="n">query</code><code class="o">=</code><code class="s">"SELECT s FROM StockPriceImpl s ORDER BY s.id.symbol"</code><code class="o">)</code></pre>&#13;
&#13;
<p>The&#13;
<code class="keep-together">StockPrice</code>&#13;
class has a&#13;
<code class="keep-together">@OneToMany</code>&#13;
relationship with the&#13;
<code class="keep-together">StockOptionPrice</code>&#13;
class using the&#13;
<code class="keep-together">optionsPrices</code>&#13;
instance variable:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="nd">@OneToMany</code><code class="o">(</code><code class="n">mappedBy</code><code class="o">=</code><code class="s">"stock"</code><code class="o">)</code>&#13;
<code class="kd">private</code> <code class="n">Collection</code><code class="o">&lt;</code><code class="n">StockOptionPrice</code><code class="o">&gt;</code> <code class="n">optionsPrices</code><code class="o">;</code></pre>&#13;
&#13;
<p><code class="keep-together">@OneToMany</code>&#13;
relationships are loaded lazily by default. <a data-type="xref" href="#TableJPACache">Table 11-3</a>&#13;
shows the time to execute this loop.</p>&#13;
<table id="TableJPACache">&#13;
<caption><span class="label">Table 11-3. </span>Seconds required to read data for 256 stocks (default configuration)</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Test case</th>&#13;
<th>First execution</th>&#13;
<th>Subsequent executions</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>Lazy relationship</p></td>&#13;
<td><p>22.7 ± 2 seconds (66,817 SQL calls)</p></td>&#13;
<td><p>1.1 ± 0.7 seconds (1 SQL call)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Lazy relationship, no traversal</p></td>&#13;
<td><p>2.0 ± 0.3 seconds (1 SQL call)</p></td>&#13;
<td><p>1.0 ± 0.02 seconds (1 SQL call)</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>The first time the sample loop is executed in this scenario (for 256&#13;
stocks with one year of data), the JPA code executes one SQL statement&#13;
in the&#13;
call to the&#13;
<code class="keep-together">executeQuery()</code>&#13;
method. That statement is executed at SQL Call Site 1 in the&#13;
code listing.</p>&#13;
&#13;
<p>As the&#13;
code loops through the stock and visits each collection of option prices,&#13;
JPA will issue SQL statements to retrieve all the options associated with the&#13;
particular entity (that is, it retrieves the entire collection for one&#13;
stock/date combination at once).&#13;
This occurs at SQL Call Site 2, and it results in&#13;
66,816 individual <code>SELECT</code> statements during execution (261 days × 256 stocks),&#13;
yielding 66,817 total calls.</p>&#13;
&#13;
<p>That example takes almost 23 seconds for the first execution of the loop.&#13;
The next time that code is executed, it takes only a little more than&#13;
1 second. That’s because the second time the loop is executed, the only&#13;
SQL executed is the named query. The entities retrieved&#13;
via the relationship are still in the L2 cache, so no database calls are&#13;
needed in that case. (Recall that the L2 cache works only for&#13;
entities loaded from a relationship or a find operation. So the stock option&#13;
entities can be found in the L2 cache, but the stock prices—since they&#13;
were loaded from a query—do not appear in the L2 cache and must be&#13;
reloaded.)</p>&#13;
&#13;
<p>The second line in <a data-type="xref" href="#TableJPACache">Table 11-3</a> represents the code that does not&#13;
visit each of the options in the relationship (i.e., the&#13;
<code class="keep-together">processOptions</code>&#13;
variable is <code>false</code>). In that case, the code is substantially faster:&#13;
it takes 2 seconds for the first iteration of the loop and 1 second&#13;
for subsequent iterations. (The difference in performance between&#13;
those two cases is&#13;
due to the warm-up period of the compiler. Although it wasn’t as noticeable,&#13;
that warm-up occurred in the first&#13;
example as well.)</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Caching and eager loading" data-type="sect3"><div class="sect3" id="idm45775544507416">&#13;
<h3>Caching and eager loading</h3>&#13;
&#13;
<p><a data-primary="database caching" data-secondary="eager loading" data-type="indexterm" id="idm45775544403336"/><a data-primary="eager loading" data-type="indexterm" id="idm45775544402360"/>In the next two experiments, the relationship between the stock prices and&#13;
option prices is redefined so that the option prices are loaded eagerly.</p>&#13;
&#13;
<p>When all the data is used (i.e., the first rows in Tables <a data-type="xref" data-xrefstyle="select: labelnumber" href="#TableJPACache">11-3</a> and <a data-type="xref" data-xrefstyle="select: labelnumber" href="#TableJPACacheEager">11-4</a>), the performance of the eager and lazy loading&#13;
cases is essentially the same. But when the relationship data isn’t actually&#13;
used (the second rows in each table), the lazy relationship case&#13;
saves some time—particularly on&#13;
the first execution of the loop. Subsequent executions of the loop don’t&#13;
save time since the eager-loading code&#13;
isn’t reloading the data in those subsequent iterations; it is loading&#13;
data from the&#13;
L2 cache.</p>&#13;
<table id="TableJPACacheEager">&#13;
<caption><span class="label">Table 11-4. </span>Seconds required to read data for 256 stocks (eager loading)</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Test case</th>&#13;
<th>First execution</th>&#13;
<th>Subsequent executions</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>Eager relationship</p></td>&#13;
<td><p>23 ± 1.0 seconds (66,817 SQL calls)</p></td>&#13;
<td><p>1.0 ± 0.8 seconds (1 SQL call)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Eager relationship, no traversal</p></td>&#13;
<td><p>23 ± 1.3 seconds (66,817 SQL calls)</p></td>&#13;
<td><p>1.0 ± 0.5 seconds  (1 SQL call)</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45775544366376">&#13;
<h5>Eager Loading of Relationships</h5>&#13;
<p><a data-primary="relationships, eager loading" data-type="indexterm" id="idm45775544364952"/>Regardless of whether the relationship is fetched lazily or eagerly,&#13;
this loop will execute 66,816 <code>SELECT</code> statements to retrieve the stock&#13;
options (as the previous section mentioned, a <code>JOIN</code> will not be used by default).</p>&#13;
&#13;
<p>The difference between eagerly and lazily loading the relationship in this&#13;
situation applies to <em>when</em> those SQL statements are executed. If the&#13;
relationship is annotated to load eagerly,&#13;
the result set is processed immediately as the query is executed (within the call to the&#13;
<code class="keep-together">getResultList()</code>&#13;
method). The JPA framework looks at every entity returned in that call&#13;
and executes an SQL statement to retrieve their related entities.&#13;
All these&#13;
SQL statements occur at SQL Call Site 1—in the eager relationship case,&#13;
no SQL statements are executed at SQL Call Site 2.</p>&#13;
&#13;
<p>If the relationship is annotated to load lazily, only the stock prices&#13;
are loaded at SQL Call Site 1 (using the named query). The option prices&#13;
for individual stocks are loaded when the relationship traversal occurs&#13;
at SQL Call Site 2. That loop is executed 66,816 times, resulting in the&#13;
66,816 SQL calls.</p>&#13;
&#13;
<p>Regardless of when the SQL is issued, though, the number of SQL statements&#13;
remains the same—assuming that all the data is actually used in the&#13;
lazy-loading example.</p>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Join fetch and caching" data-type="sect3"><div class="sect3" id="idm45775544359576">&#13;
<h3>Join fetch and caching</h3>&#13;
&#13;
<p><a data-primary="database caching" data-secondary="JOIN FETCH and" data-type="indexterm" id="idm45775544358296"/><a data-primary="JOIN FETCH" data-type="indexterm" id="idm45775544357320"/>As discussed in the previous section, the query could be written to&#13;
explicitly use a <code>JOIN</code> statement:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="nd">@NamedQuery</code><code class="o">(</code><code class="n">name</code><code class="o">=</code><code class="s">"findAll"</code><code class="o">,</code>&#13;
    <code class="n">query</code><code class="o">=</code><code class="s">"SELECT s FROM StockPriceEagerLazyImpl s "</code> <code class="o">+</code>&#13;
    <code class="s">"JOIN FETCH s.optionsPrices ORDER BY s.id.symbol"</code><code class="o">)</code></pre>&#13;
&#13;
<p>Using that named query (with full traversal) yields the data in&#13;
<a data-type="xref" href="#TableJPACacheQuery">Table 11-5</a>.</p>&#13;
<table id="TableJPACacheQuery">&#13;
<caption><span class="label">Table 11-5. </span>Seconds required to read data for 256 stocks (<code>JOIN</code> query)</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Test case</th>&#13;
<th>First execution</th>&#13;
<th>Subsequent executions</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>Default configuration</p></td>&#13;
<td><p>22.7 ± 2 seconds (66,817 SQL calls)</p></td>&#13;
<td><p>1.1 ± 0.7 seconds (1 SQL call)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Join fetch</p></td>&#13;
<td><p>9.0 ± 0.3 seconds (1 SQL call)</p></td>&#13;
<td><p>5.6 ± 0.4 seconds (1 SQL call)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Join fetch with query cache</p></td>&#13;
<td><p>5.8 ± 0.2 seconds (1 SQL call)</p></td>&#13;
<td><p>0.001 ± 0.0001 seconds (0 SQL calls)</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>The first time the loop is executed with a <code>JOIN</code> query, a&#13;
big performance win results: it takes only 9 seconds. That&#13;
is the result of issuing only one SQL request rather than 66,817 of them.</p>&#13;
&#13;
<p>Unfortunately, the next time the code&#13;
is executed, it still needs that one SQL statement, since query&#13;
results are not in the L2 cache. Subsequent executions of the example&#13;
take 5.6 seconds—because the SQL&#13;
statement that is executed has the <code>JOIN</code> statement and is retrieving more than&#13;
400,000 rows of data.</p>&#13;
&#13;
<p>If the JPA provider implements query caching, this&#13;
is clearly a good time to use it. If no SQL statements are required during&#13;
the second execution of the code, only 1 ms is required on the&#13;
subsequent executions.&#13;
Be aware that query caching works only if the parameters used in&#13;
the query are exactly&#13;
the same each time the query is executed.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Avoiding queries" data-type="sect3"><div class="sect3" id="idm45775544326952">&#13;
<h3>Avoiding queries</h3>&#13;
&#13;
<p><a data-primary="database caching" data-secondary="avoiding queries" data-type="indexterm" id="ix_ch11-asciidoc19"/><a data-primary="queries, avoiding" data-type="indexterm" id="ix_ch11-asciidoc20"/>If entities are never retrieved via a query, all&#13;
entities can be accessed through the L2 cache after an initial warm-up period. The L2 cache can be&#13;
warmed up by loading all entities, so slightly modifying the previous example&#13;
gives this code:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">EntityManager</code> <code class="n">em</code> <code class="o">=</code> <code class="n">emf</code><code class="o">.</code><code class="na">createEntityManager</code><code class="o">();</code>&#13;
<code class="n">ArrayList</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">allSymbols</code> <code class="o">=</code> <code class="o">...</code> <code class="n">all</code> <code class="n">valid</code> <code class="n">symbols</code> <code class="o">...;</code>&#13;
<code class="n">ArrayList</code><code class="o">&lt;</code><code class="n">Date</code><code class="o">&gt;</code> <code class="n">allDates</code> <code class="o">=</code> <code class="o">...</code> <code class="n">all</code> <code class="n">valid</code> <code class="n">dates</code><code class="o">...;</code>&#13;
<code class="k">for</code> <code class="o">(</code><code class="n">String</code> <code class="n">symbol</code> <code class="o">:</code> <code class="n">allSymbols</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="k">for</code> <code class="o">(</code><code class="n">Date</code> <code class="n">date</code> <code class="o">=</code> <code class="n">allDates</code><code class="o">)</code> <code class="o">{</code>&#13;
        <code class="n">StockPrice</code> <code class="n">sp</code> <code class="o">=</code>&#13;
            <code class="n">em</code><code class="o">.</code><code class="na">find</code><code class="o">(</code><code class="n">StockPriceImpl</code><code class="o">.</code><code class="na">class</code><code class="o">,</code> <code class="k">new</code> <code class="n">StockPricePK</code><code class="o">(</code><code class="n">symbol</code><code class="o">,</code> <code class="n">date</code><code class="o">);</code>&#13;
	<code class="o">...</code> <code class="n">process</code> <code class="n">sp</code> <code class="o">...</code>&#13;
        <code class="k">if</code> <code class="o">(</code><code class="n">processOptions</code><code class="o">)</code> <code class="o">{</code>&#13;
    	    <code class="n">Collection</code><code class="o">&lt;?</code> <code class="kd">extends</code> <code class="n">StockOptionPrice</code><code class="o">&gt;</code> <code class="n">options</code> <code class="o">=</code> <code class="n">sp</code><code class="o">.</code><code class="na">getOptions</code><code class="o">();</code>&#13;
	    <code class="o">...</code> <code class="n">process</code> <code class="n">options</code> <code class="o">...</code>&#13;
	<code class="o">}</code>&#13;
    <code class="o">}</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>The results of executing this code are given in <a data-type="xref" href="#TableJPACacheNoQuery">Table 11-6</a>.</p>&#13;
<table id="TableJPACacheNoQuery">&#13;
<caption><span class="label">Table 11-6. </span>Seconds required to read data for 256 stocks (L2 cache used)</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Test case</th>&#13;
<th>First execution</th>&#13;
<th>Subsequent executions</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>Default configuration</p></td>&#13;
<td><p>22.7 ± 2 seconds (66,817 SQL calls)</p></td>&#13;
<td><p>1.1 ± 0.7 seconds (1 SQL call)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>No query</p></td>&#13;
<td><p>35 ± 3 seconds (133,632 SQL calls)</p></td>&#13;
<td><p>0.28 ± 0.3 seconds (0 SQL calls)</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>The first execution of this loop requires&#13;
133,632 SQL statements: 66,816&#13;
for the call to the&#13;
<code class="keep-together">find()</code>&#13;
method, and an additional 66,816 for the call&#13;
to the&#13;
<code class="keep-together">getOptions()</code>&#13;
method. Subsequent executions of that code are very fast indeed,&#13;
since all the entities are in the L2 cache, and no SQL statements need to be&#13;
issued.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45775544196008">&#13;
<h5>Warming Up a Test</h5>&#13;
<p><a data-primary="warm-up periods" data-secondary="caching and" data-type="indexterm" id="idm45775544194808"/>Java performance tests—and particularly benchmarks—usually have a&#13;
warm-up period. As discussed in <a data-type="xref" href="ch04.html#JustInTimeCompilation">Chapter 4</a>, that allows the&#13;
compiler to compile the code <span class="keep-together">optimally.</span></p>&#13;
&#13;
<p>Here’s another example where a warm-up period is beneficial. During the&#13;
warm-up period of a JPA application, the most-frequently used entities will&#13;
be loaded into the L2 cache. The measurement period of the test will see&#13;
very different performance as those entities are first loaded.&#13;
This is particularly true if, as in the previous&#13;
example, no queries are used to load entities, but that is generally the&#13;
difference in all the tables in this section between first and second executions.</p>&#13;
</div></aside>&#13;
&#13;
<p>Recall that the sample database includes five&#13;
option prices for every date and symbol pair, or a total of 334,080 option&#13;
prices for&#13;
256 stocks over one year of data. When the five stock options for a&#13;
particular symbol and date&#13;
are accessed via a relationship, they can&#13;
all be retrieved at once. That’s why only 66,816 SQL statements are&#13;
required to load all the option price data. Even though multiple rows are&#13;
returned from those SQL statements, JPA is still able to cache the entities—it is not the same thing as executing a query. If the L2 cache is warmed up by&#13;
iterating through entities, don’t iterate through related entities&#13;
individually—do that by simply visiting the relationship.</p>&#13;
&#13;
<p>As code is optimized, you must take into&#13;
account the effects of the cache (and particularly the L2 cache). Even if&#13;
you think you could write better SQL than what JPA generates (and hence&#13;
should use&#13;
complex named queries), make sure that&#13;
code is worthwhile after the cache comes into play. Even if it&#13;
seems that using a simple named query will be faster to load data,&#13;
consider what&#13;
would happen in the long run if those entities were loaded into the L2 cache&#13;
via a call to the <code>find()</code> method.<a data-startref="ix_ch11-asciidoc20" data-type="indexterm" id="idm45775544188680"/><a data-startref="ix_ch11-asciidoc19" data-type="indexterm" id="idm45775544187944"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Sizing the JPA cache" data-type="sect3"><div class="sect3" id="idm45775544187144">&#13;
<h3>Sizing the JPA cache</h3>&#13;
&#13;
<p><a data-primary="database caching" data-secondary="sizing" data-type="indexterm" id="idm45775544185736"/><a data-primary="sizing" data-secondary="JPA cache" data-type="indexterm" id="idm45775544184760"/>As with all cases where objects are reused, the JPA cache has a potential&#13;
performance downside: if the cache consumes too much memory, it will cause&#13;
GC pressure.  This may require that the cache be tuned to adjust its size&#13;
or that you control the mode in which entities remain cached. Unfortunately,&#13;
these are not standard options, so you must perform these tunings based on which&#13;
JPA provider you are using.</p>&#13;
&#13;
<p>JPA implementations typically provide an option to set the size of the cache,&#13;
either globally or per entity. The latter case is obviously more&#13;
flexible, though it also requires more work to determine the&#13;
optimal size for each entity. An alternative approach is for the JPA&#13;
implementation to use soft and/or weak references for the L2 cache.&#13;
EclipseLink, for example,&#13;
provides five cache types (plus additional deprecated&#13;
types) based on various&#13;
combinations of soft and weak references. That approach, while potentially&#13;
easier than finding optimal sizes for each entity, still requires some&#13;
planning: in particular, recall from <a data-type="xref" href="ch07.html#Memory">Chapter 7</a> that weak references do not&#13;
really survive any GC operation and are hence a questionable choice for&#13;
a cache.</p>&#13;
&#13;
<p>If a cache based on soft or weak references is used, the performance of&#13;
the application&#13;
will also depend on what else happens in the heap. The examples of this&#13;
section all used a large heap so that caching the 400,896 entity objects&#13;
in the application would not cause issues with the garbage collector.&#13;
Tuning a heap when there are large JPA L2 caches is quite important for&#13;
good performance.</p>&#13;
<div data-type="tip"><h1>Quick Summary</h1>&#13;
<ul>&#13;
<li>&#13;
<p>The JPA L2 cache will automatically cache entities for an <span class="keep-together">application.</span></p>&#13;
</li>&#13;
<li>&#13;
<p>The L2 cache does not cache entities retrieved via queries. This means that in the long run it can be beneficial to avoid queries altogether.</p>&#13;
</li>&#13;
<li>&#13;
<p>Unless query caching is supported by the JPA implementation in use, using a <code>JOIN</code> query turns out to frequently have a negative performance effect, since it bypasses the L2 cache<a data-startref="ix_ch11-asciidoc18" data-type="indexterm" id="idm45775544175560"/><a data-startref="ix_ch11-asciidoc17" data-type="indexterm" id="idm45775544174856"/>.<a data-startref="ix_ch11-asciidoc14" data-type="indexterm" id="idm45775544174056"/><a data-startref="ix_ch11-asciidoc13" data-type="indexterm" id="idm45775544173352"/></p>&#13;
</li>&#13;
</ul>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="Spring Data" data-type="sect1"><div class="sect1" id="idm45775544707800">&#13;
<h1>Spring Data</h1>&#13;
&#13;
<p><a data-primary="databases" data-secondary="Spring Data" data-type="indexterm" id="idm45775544170824"/><a data-primary="Spring Data" data-type="indexterm" id="idm45775544169848"/>Although JDBC and JPA are standard parts of the Java platform, other&#13;
third-party Java APIs and frameworks manage database access.&#13;
NoSQL vendors all have&#13;
their own APIs to access their databases, and various frameworks provide database access via different abstractions than JPA.</p>&#13;
&#13;
<p>The most-widely used of these is Spring Data, which is a collection of database&#13;
access modules for both relational and NoSQL databases. This framework&#13;
contains several modules, including these:</p>&#13;
<dl>&#13;
<dt>Spring Data JDBC</dt>&#13;
<dd>&#13;
<p><a data-primary="JDBC (Java Database Connectivity)" data-secondary="Spring Data JDBC" data-type="indexterm" id="idm45775544166568"/>This is designed as a simple alternative to JPA. It provides a similar&#13;
entity mapping&#13;
as JPA but without caching, lazy loading, or dirty entity tracking. This&#13;
sits on top of standard JDBC drivers so it has wide support. That means you&#13;
can track the performance aspects from this chapter in the Spring code:&#13;
make sure to use prepared statements for repeated calls, implement the&#13;
necessary interfaces in your code to support Spring batched statement&#13;
models, and/or work directly with the connection objects to change&#13;
autocommit semantics.</p>&#13;
</dd>&#13;
<dt>Spring Data JPA</dt>&#13;
<dd>&#13;
<p><a data-primary="JPA (Java Persistence API)" data-secondary="Spring Data JPA" data-type="indexterm" id="idm45775544163784"/>This is designed as a wrapper around standard JPA. One large benefit&#13;
is that it reduces the amount of boilerplate code developers need to write&#13;
(which is good for developer performance but doesn’t really impact the&#13;
performance we’re discussing). Because it wraps standard JPA, the JPA&#13;
performance aspects mentioned in this chapter all apply: setting up&#13;
eager versus lazy loading, batching updates and inserts, and the L2 caches&#13;
all still apply.</p>&#13;
</dd>&#13;
<dt>Spring Data for NoSQL</dt>&#13;
<dd>&#13;
<p><a data-primary="NoSQL databases" data-type="indexterm" id="idm45775544161096"/>Spring has various connectors for NoSQL (and NoSQL-like) technologies,&#13;
including MongoDB, Cassandra, Couchbase, and Redis. This somewhat simplifies&#13;
the NoSQL access, since the techniques to access the store are then the&#13;
same, though differences in setup and initialization remain.</p>&#13;
</dd>&#13;
<dt>Spring Data R2DBC</dt>&#13;
<dd>&#13;
<p>Spring Data R2DBC, mentioned in <a data-type="xref" href="ch10.html#JavaServers">Chapter 10</a>, allows asynchronous&#13;
JDBC access to Postgres, H2, and Microsoft SQL Server databases. It follows&#13;
the typical Spring Data programming model rather than direct JDBC,&#13;
so it is similar to Spring Data JDBC: access is via simple entities in&#13;
repositories, though without the caching, lazy loading, and other features&#13;
of JPA.</p>&#13;
</dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm45775544157256">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>Properly tuning JDBC and JPA access to a database is one of the most&#13;
significant ways to affect the performance of a middle-tier application.&#13;
Keep in mind these best practices:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Batch reads and writes as much as possible by configuring the JDBC or JPA configuration appropriately.</p>&#13;
</li>&#13;
<li>&#13;
<p>Optimize the SQL the application issues. For JDBC applications, this is a question of basic, standard SQL commands. For JPA applications, be sure to consider the involvement of the L2 cache.</p>&#13;
</li>&#13;
<li>&#13;
<p>Minimize locking where possible. Use optimistic locking when data is unlikely to be contended, and use pessimistic locking when data is contended.</p>&#13;
</li>&#13;
<li>&#13;
<p>Make sure to use a prepared statement pool.</p>&#13;
</li>&#13;
<li>&#13;
<p>Make sure to use an appropriately sized connection pool.</p>&#13;
</li>&#13;
<li>&#13;
<p>Set an appropriate transaction scope: it should be as large as possible without negatively affecting the scalability of the application because of the locks held during the transaction.<a data-startref="ix_ch11-asciidoc0" data-type="indexterm" id="idm45775544149416"/></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm45775546052104"><sup><a href="ch11.html#idm45775546052104-marker">1</a></sup> You might prefer to scale the database instead, but that is often difficult in real-world deployments.</p><p data-type="footnote" id="idm45775545987720"><sup><a href="ch11.html#idm45775545987720-marker">2</a></sup> Statement pooling is often called <em>statement caching</em> by database vendors.</p><p data-type="footnote" id="idm45775545357736"><sup><a href="ch11.html#idm45775545357736-marker">3</a></sup> In the first edition of this book, when the tests were run on Oracle 11g, that also wasn’t the case; there was a clear difference between rows 2 and 3 and between rows 5 and 6. These tests were run on Oracle 18c, which has its own improvements.</p></div></div></section></body></html>