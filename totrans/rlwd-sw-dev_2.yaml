- en: Chapter 2\. The Bank Statements Analyzer
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。银行对账单分析器
- en: The Challenge
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挑战
- en: The FinTech industry is really hot right now. Mark Erbergzuck realizes that
    he spends a lot of money on different purchases and would benefit from automatically
    summarizing his expenses. He receives monthly statements from his bank, but he
    finds them a bit overwhelming. He has tasked you with developing a piece of software
    that will automate the processing of his bank statements so he can get better
    insights into his finances. Challenge accepted!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 金融科技行业现在非常热门。马克·厄伯格祖克意识到自己在不同购买上花了很多钱，会受益于自动总结自己的开支。他从银行每月收到对账单，但他觉得有点压力山大。他委托您开发一款软件，可以自动处理他的银行对账单，以便他能更好地了解自己的财务状况。接受挑战！
- en: The Goal
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 目标
- en: In this chapter, you will learn the foundations about good software development
    before learning more advanced techniques in the next few chapters.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习关于良好软件开发的基础知识，然后在接下来的几章中学习更高级的技术。
- en: You will start off by implementing the problem statement in one single class.
    You will then explore why this approach poses several challenges in terms of coping
    for changing requirements and maintenance of the project.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 您将首先在一个单一类中实现问题陈述。然后您将探讨为什么这种方法在应对不断变化的需求和项目维护方面会面临几个挑战。
- en: But do not worry! You will learn software design principles and techniques to
    adopt to ensure that the code you write meets these criteria. You will first learn
    about the *Single Responsibility Principle* (SRP), which helps develop software
    that is more maintainable, easier to comprehend, and reduces the scope for introducing
    new bugs. Along the way, you will pick up new concepts such as *cohesion* and
    *coupling*, which are useful characteristics to guide you about the quality of
    the code and software that you develop.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 但不用担心！您将学习软件设计原则和技术，以确保您编写的代码符合这些标准。您首先将了解*单一职责原则*（SRP），这有助于开发更易于维护、更容易理解并减少引入新错误范围的软件。在此过程中，您将学习到新概念，如*内聚性*和*耦合性*，这些概念对指导您开发的代码和软件的质量非常有用。
- en: Note
  id: totrans-7
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This chapter uses libraries and features from Java 8 and above, including the
    new date and time library.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用了Java 8及以上版本的库和特性，包括新的日期和时间库。
- en: If at any point you want to look at the source code for this chapter, you can
    look at the package `com.iteratrlearning.shu_book.chapter_02` in the book’s code
    repository.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在任何时候想要查看本章的源代码，您可以查看该书代码仓库中的`com.iteratrlearning.shu_book.chapter_02`包。
- en: Bank Statements Analyzer Requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 银行对账单分析器需求
- en: 'You had a delicious hipster latte (no added sugar) with Mark Erbergzuck to
    gather requirements. Because Mark is pretty tech-savvy, he tells you that the
    bank statements analyzer just needs to read a text file containing a list of bank
    transactions. He downloads the file from his online banking portal. This text
    is structured using a comma-separated values (CSV) format. Here is a sample of
    bank transactions:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您与马克·厄伯格祖克共进了一杯美味的时髦拿铁（没有加糖），以收集需求。因为马克非常精通技术，他告诉您，银行对账单分析器只需要读取一个包含银行交易列表的文本文件。他从他的网上银行门户下载了文件。这个文本是使用逗号分隔的值（CSV）格式结构化的。这是银行交易的样本：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'He would like to get an answer for the following queries:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 他想要得到以下问题的答案：
- en: What is the total profit and loss from a list of bank statements? Is it positive
    or negative?
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从一系列银行对账单中的总利润和损失是多少？是正还是负？
- en: How many bank transactions are there in a particular month?
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定月份有多少笔银行交易？
- en: What are his top-10 expenses?
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他的前10笔开销是什么？
- en: Which category does he spend most of his money on?
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他在哪个类别上花费了大部分的钱？
- en: KISS Principle
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: KISS原则
- en: 'Let’s start simple. How about the first query: “What is the total profit and
    loss from a list of bank statements?” You need to process a CSV file and calculate
    the sum of all the amounts. Since there is nothing else required, you may decide
    that there is no need to create a very complex application.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的开始。第一个查询如何：“从一系列银行对账单中的总利润和损失是多少？”您需要处理一个CSV文件，并计算所有金额的总和。由于没有其他要求，您可以决定不需要创建一个非常复杂的应用程序。
- en: You can “Keep It Short and Simple” (KISS) and have the application code in one
    single class as shown in [Example 2-1](#bank_analyzer_simple). Note that you do
    not have to worry about possible exceptions yet (e.g., what if the file does not
    exist or what if parsing a loaded file fails?). That is a topic that you will
    learn about in [Chapter 3](ch03.xhtml#chapter_03).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以“简洁明了”（KISS），并且将应用程序代码放在一个单独的类中，如[示例 2-1](#bank_analyzer_simple)所示。请注意，您现在不必担心可能的异常情况（例如，文件不存在或加载文件失败的情况）。这是您将在[第 3
    章](ch03.xhtml#chapter_03)中学习的一个主题。
- en: Note
  id: totrans-21
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: CSV is not fully standardized. It’s often referred to as values separated by
    commas. However, some people refer to it as a delimiter-separated format that
    uses different delimiters, such as semicolons or tabs. These requirements can
    add more complexity to the implementation of a parser. In this chapter, we will
    assume that values are separated by a comma (`,`).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: CSV并非完全标准化。它通常被称为由逗号分隔的值。然而，有些人称其为使用不同分隔符（如分号或制表符）的分隔符分隔格式。这些要求可能会增加解析器实现的复杂性。在本章中，我们假设值由逗号（`,`）分隔。
- en: Example 2-1\. Calculating the sum of all statements
  id: totrans-23
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-1\. 计算所有语句的总和
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'What is happening here? You are loading the CSV file passed as a command-line
    argument to the application. The `Path` class represents a path in the filesystem.
    You then use `Files.readAllLines()` to return a list of lines. Once you have all
    the lines from the file, you can parse them one at a time by:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？您正在加载作为应用程序命令行参数传递的CSV文件。`Path`类表示文件系统中的路径。然后使用`Files.readAllLines()`返回行列表。获取文件的所有行后，您可以逐行解析它们：
- en: Splitting the columns by commas
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过逗号拆分列
- en: Extracting the amount
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取金额
- en: Parsing the amount to a `double`
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将金额解析为`double`
- en: Once you have the amount for a given statement as a `double` you can then add
    it to the current total. At the end of the processing, you will have the total
    amount.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将给定语句的金额作为`double`获取，您可以将其添加到当前总金额中。在处理结束时，您将获得总金额。
- en: 'The code in [Example 2-1](#bank_analyzer_simple) will work fine, but it misses
    a few corner cases that are always good to think about when writing production-ready
    code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 2-1](#bank_analyzer_simple)中的代码将可以正常工作，但它忽略了一些边界情况，这些情况在编写生产就绪代码时总是要考虑的：'
- en: What if the file is empty?
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果文件为空怎么办？
- en: What if parsing the amount fails because the data was corrupted?
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果解析金额失败，因为数据已损坏怎么办？
- en: What if a statement line has missing data?
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果语句行数据缺失怎么办？
- en: We will come back to the topic of dealing with exceptions in [Chapter 3](ch03.xhtml#chapter_03),
    but it is a good habit to keep these types of questions in mind.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第 3 章](ch03.xhtml#chapter_03)再次讨论如何处理异常，但保持这类问题的思考习惯是一个好习惯。
- en: 'How about solving the second query: “How many bank transactions are there in
    a particular month?” What can you do? Copy and paste is a simple technique, right?
    You could just copy and paste the same code and replace the logic so it selects
    the given month, as shown in [Example 2-2](#bank_analyzer_month).'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如何解决第二个查询：“特定月份有多少银行交易？”你可以做什么？复制粘贴是一种简单的技术，对吧？您可以复制并粘贴相同的代码，并替换逻辑，以选择给定的月份，如[示例 2-2](#bank_analyzer_month)所示。
- en: Example 2-2\. Calculating the sum of January statements
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-2\. 计算一月语句的总和
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: final Variables
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: final变量
- en: As a short detour, we’ll explain the use of the `final` keyword in the code
    examples. Throughout this book we’ve used the `final` keyword fairly extensively.
    Marking a local variable or a field `final` means that it cannot be re-assigned.
    Whether you use `final` or not in your project is a collective matter for your
    team and project since its use has both benefits and drawbacks. We’ve found that
    marking as many variables `final` as possible clearly demarcates what state is
    mutated during the lifetime of an object and what state isn’t re-assigned.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个简短的旁观，我们将解释代码示例中`final`关键字的用法。在本书中，我们广泛使用了`final`关键字。标记局部变量或字段为`final`意味着它不能被重新赋值。在您的项目中是否使用`final`是您团队和项目的集体事务，因为其使用既有利也有弊。我们发现，在可能的情况下标记尽可能多的变量为`final`，可以清晰地标识对象生命周期内哪些状态是可变的，哪些状态不会被重新赋值。
- en: On the other hand, the use of the `final` keyword doesn’t guarantee immutability
    of the object in question. You can have a `final` field that refers to an object
    with mutable state. We will be discussing immutability in more detail in [Chapter 4](ch04.xhtml#chapter_04).
    Furthermore, its use also adds a lot of boilerplate to the codebase. Some teams
    pick the compromise position of having `final` fields on method parameters, in
    order to ensure that they are clearly not re-assigned and not local variables.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，使用`final`关键字并不能保证对象的不可变性。你可以有一个`final`字段，它引用具有可变状态的对象。我们将在[第四章](ch04.xhtml#chapter_04)中更详细地讨论不可变性。此外，它的使用还会向代码库中添加大量样板代码。一些团队选择妥协的方法，在方法参数上使用`final`字段，以确保它们明确不会被重新赋值，也不是局部变量。
- en: One area where there is little point in using the `final` keyword, although
    the Java language allows it, is for method parameters on abstract methods; for
    example, in interfaces. This is because the lack of body means that there is no
    real implication or meaning to the `final` keyword in this situation. Arguably
    the use of `final` has diminished since the introduction of the `var` keyword
    in Java 10, and we discuss this concept later in [Example 5-15](ch05.xhtml#local_variable_type_inference).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个领域中，使用`final`关键字几乎没有意义，尽管Java语言允许这样做，这是在抽象方法上的方法参数上；例如，在接口中。这是因为缺乏方法体意味着在这种情况下`final`关键字没有真正的含义或意义。可以说，自从Java
    10引入`var`关键字以来，`final`的使用已经减少，我们稍后在[示例5-15](ch05.xhtml#local_variable_type_inference)中讨论这个概念。
- en: Code Maintainability and Anti-Patterns
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码可维护性和反模式
- en: 'Do you think the copy-and-paste approach demonstrated in [Example 2-2](#bank_analyzer_month)
    is a good idea? Time to take a step back and reflect on what is happening. When
    you write code, you should strive for providing good *code maintainability*. What
    does this mean? It is best described by a wish list of properties about the code
    you write:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为[示例2-2](#bank_analyzer_month)中展示的复制粘贴方法是一个好主意吗？是时候退后一步，反思一下发生了什么。当你编写代码时，你应该努力提供良好的*代码可维护性*。这意味着什么？最好的描述方式是关于你所写代码的属性的愿望清单：
- en: It should be simple to locate code responsible for a particular feature.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该简单地定位负责特定功能的代码。
- en: It should be simple to understand what the code does.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该简单地了解代码的功能。
- en: It should be simple to add or remove a new feature.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加或删除新功能应该很简单。
- en: It should provide good *encapsulation*. In other words, implementation details
    should be hidden from a user of your code so it is easier to understand and make
    changes.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该提供良好的*封装性*。换句话说，实现细节应该对代码的使用者隐藏起来，这样就更容易理解和进行更改。
- en: A good way to think about the impact of the code you write is to consider what
    happens if a work colleague of yours has to look at your code in six months and
    you have moved to a different company.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到你的一位同事在六个月后查看你的代码，并且你已经去了另一家公司，思考一下你编写的代码对他们的影响是什么。
- en: 'Ultimately your goal is to manage the complexity of the application you are
    building. However, if you keep on copy pasting the same code as new requirements
    come in, you will end up with the following issues, which are called *anti-patterns*
    because they are common ineffective solutions:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，你的目标是管理你正在构建的应用程序的复杂性。然而，如果随着新需求的出现你继续复制粘贴相同的代码，你将遇到以下问题，这些问题被称为*反模式*，因为它们是常见的无效解决方案：
- en: Hard to understand code because you have one giant *“God Class”*
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码难以理解，因为你有一个庞大的*“上帝类”*
- en: Code that is brittle and easily broken by changes because of *code duplication*
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为*代码重复*而脆弱且容易受到更改破坏的代码
- en: Let’s explain these two anti-patterns in more detail.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地解释这两个反模式。
- en: God Class
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上帝类
- en: By putting all of your code in one file, you end up with one giant class making
    it harder to understand its purpose because that class is responsible for everything!
    If you need to update the logic of existing code (e.g., change how the parsing
    works) how will you easily locate that code and make changes? This problem is
    referred to as the anti-pattern “God Class.” Essentially you have one class that
    does everything. You should avoid this. In the next section, you will learn about
    the *Single Responsibility Principle*, which is a software development guideline
    to help write code that is easier to understand and maintain.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有代码放在一个文件中，你最终会得到一个巨大的类，这使得理解其目的变得更加困难，因为这个类负责所有事情！如果需要更新现有代码的逻辑（例如，更改解析方式），你如何轻松地定位到该代码并进行更改？这个问题被称为反模式“上帝类”。本质上，你有一个类负责一切。你应该避免这种情况。在下一节中，你将学习*单一责任原则*，这是一个软件开发指导原则，有助于编写更易理解和维护的代码。
- en: Code Duplication
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码重复
- en: For each query, you are duplicating the logic for reading and parsing the input.
    What if the input required is no longer CSV but a JSON file? What if multiple
    formats need to be supported? Adding such a feature will be a painful change because
    your code has hardcoded one specific solution and duplicated that behavior in
    multiple places. Consequently, all the places will all have to change and you
    will potentially introduce new bugs.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每一个查询，你都在复制读取和解析输入的逻辑。如果输入要求不再是CSV而是JSON文件怎么办？如果需要支持多种格式怎么办？添加这样一个功能将是一个痛苦的变更，因为你的代码已经硬编码了一个特定的解决方案，并在多个地方重复了这种行为。因此，所有这些地方都必须更改，你可能会引入新的错误。
- en: Note
  id: totrans-57
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You will often hear about the “Don’t Repeat Yourself” (DRY) principle. It is
    the idea that when you successfully reduce repetition, a modification of the logic
    does not require multiple modifications of your code anymore.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你经常会听到“不要重复自己”（DRY）原则。这是一个成功减少重复的想法，逻辑的修改不再需要多次修改你的代码。
- en: A related problem is what if the data format changes? The code only supports
    a specific data format pattern. If it needs to be enhanced (e.g., new columns)
    or a different data format needs to be supported (e.g., different attribute names)
    you will again have to make many changes across your code.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 相关问题是，如果数据格式发生变化怎么办？代码只支持特定的数据格式模式。如果需要增强（例如，新的列）或支持不同的数据格式（例如，不同的属性名称），你将再次不得不在整个代码中进行多次更改。
- en: The conclusion is that it is good to keep things simple when possible, but do
    not abuse the KISS principle. Instead, you need to reflect on the design of your
    whole application and have an understanding of how to break down the problem into
    separate sub-problems that are easier to manage individually. The result is that
    you will have code that is easier to understand, maintain, and adapt to new requirements.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 结论是，在可能的情况下保持事情简单是好的，但不要滥用KISS原则。相反，你需要反思整个应用程序的设计，并理解如何将问题分解为更容易单独管理的子问题。结果是，你将拥有更容易理解、维护和适应新需求的代码。
- en: Single Responsibility Principle
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单一责任原则
- en: The *Single Responsibility Principle* (SRP) is a general software development
    guideline to follow that contributes to writing code that is easier to manage
    and maintain.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*单一责任原则*（SRP）是一个通用的软件开发指导原则，有助于编写更易管理和维护的代码。'
- en: 'You can think about SRP in two complementary ways:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从两个互补的角度思考SRP：
- en: A class has responsibility over a single functionality
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类负责一个单一功能
- en: There is only one single reason for a class to change^([1](ch02.xhtml#idm45816839001464))
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类只有一个改变的原因^([1](ch02.xhtml#idm45816839001464))
- en: The SRP is usually applied to classes and methods. SRP is concerned with one
    particular behavior, concept, or category. It leads to code that is more robust
    because there is one specific reason why it should change rather than multiple
    concerns. The reason why multiple concerns is problematic is, as you saw earlier,
    it complicates code maintainability by potentially introducing bugs in several
    places. It can also make the code harder to understand and change.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: SRP通常应用于类和方法。SRP关注于一个特定的行为、概念或类别。它导致更健壮的代码，因为它只有一个特定的原因需要更改，而不是多个关注点。多个关注点的原因是问题的，正如你之前看到的那样，它通过可能在多个地方引入错误来复杂化代码的可维护性。它也可能使代码更难理解和更改。
- en: 'So how do you apply SRP in the code shown in [Example 2-2](#bank_analyzer_month)?
    It is clear that the main class has multiple responsibilities that can be broken
    down individually:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 那么在 [示例2-2](#bank_analyzer_month) 中显示的代码中如何应用 SRP 呢？很明显，主类具有多个可以单独分解的责任：
- en: Reading input
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取输入
- en: Parsing the input in a given format
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据给定格式解析输入
- en: Processing the result
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理结果
- en: Reporting a summary of the result
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 报告结果的摘要
- en: We will focus on the parsing part in this chapter. You will learn how to extend
    the Bank Statements Analyzer in the next chapter so that it is completely modularized.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节将专注于解析部分。在下一章节中，您将学习如何扩展银行对账单分析器，使其完全模块化。
- en: The first natural step is to extract the CSV parsing logic into a separate class
    so you can reuse it for different processing queries. Let’s call it `BankStatementCSVParser`
    so it is immediately clear what it does ([Example 2-3](#bank_csv_parser_extract)).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个自然的步骤是将 CSV 解析逻辑提取到一个单独的类中，以便您可以将其用于不同的处理查询。让我们称之为 `BankStatementCSVParser`，这样就立即清楚它的作用（参见
    [示例2-3](#bank_csv_parser_extract)）。
- en: Example 2-3\. Extracting the parsing logic in a separate class
  id: totrans-74
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-3 将解析逻辑提取到一个单独的类中
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can see that the class `BankStatementCSVParser` declares two methods, `parseFromCSV()`
    and `parseLinesFromCSV()`, that generate `BankTransaction` objects, which is a
    domain class that models a bank statement (see [Example 2-4](#bank_transaction_class)
    for its declaration).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到 `BankStatementCSVParser` 类声明了两个方法，`parseFromCSV()` 和 `parseLinesFromCSV()`，它们生成
    `BankTransaction` 对象，这是一个模拟银行对账单的领域类（参见 [示例2-4](#bank_transaction_class) 中的声明）。
- en: Note
  id: totrans-77
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: What does *domain* mean? It means the use of words and terminology that match
    the business problem (i.e., the domain at hand).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*domain* 是什么意思？它指的是使用与业务问题相匹配的词语和术语（即手头的领域）。'
- en: The `BankTransaction` class is useful so that different parts of our application
    share the same common understanding of what a bank statement is. You will notice
    that the class provides implementation for the methods `equals` and `hashcode`.
    The purpose of these methods and how to implement them correctly is covered in
    [Chapter 6](ch06.xhtml#chapter_06).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`BankTransaction` 类很有用，因此我们应用程序的不同部分可以共享对银行对账单的相同理解。您会注意到该类为 `equals` 和 `hashcode`
    方法提供了实现。这些方法的目的以及如何正确实现它们在 [第6章](ch06.xhtml#chapter_06) 中有所介绍。'
- en: Example 2-4\. A domain class for a bank transaction
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-4 银行交易领域类
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now you can refactor the application so that it uses your `BankStatementCSVParser`,
    in particular its `parseLinesFromCSV()` method, as shown in [Example 2-5](#bank_statement_in_action).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以重构应用程序，使其使用您的 `BankStatementCSVParser`，特别是其 `parseLinesFromCSV()` 方法，如
    [示例2-5](#bank_statement_in_action) 所示。
- en: Example 2-5\. Using the bank statement CSV parser
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-5 使用银行对账单 CSV 解析器
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The different queries you have to implement no longer need to know about internal
    parsing details, as you can now use `BankTransaction` objects directly to extract
    the information required. The code in [Example 2-6](#bank_statement_processing)
    shows how to declare the methods `calculateTotalAmount()` and `selectInMonth()`,
    which are responsible for processing the list of transactions and returning an
    appropriate result. In [Chapter 3](ch03.xhtml#chapter_03) you will get an overview
    of lambda expressions and the Streams API, which will help tidy the code further.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要实现的不同查询现在不再需要了解内部解析细节，因为您现在可以直接使用 `BankTransaction` 对象来提取所需的信息。 [示例2-6](#bank_statement_processing)
    中的代码展示了如何声明 `calculateTotalAmount()` 和 `selectInMonth()` 方法，它们负责处理交易列表并返回适当的结果。在
    [第3章](ch03.xhtml#chapter_03) 中，您将获得关于 Lambda 表达式和流 API 的概述，这将进一步简化代码。
- en: Example 2-6\. Processing lists of bank transactions
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-6 处理银行交易列表
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The key benefit with this refactoring is that your main application is no longer
    responsible for the implementation of the parsing logic. It is now delegating
    that responsibility to a separate class and methods that can be maintained and
    updated independently. As new requirements come in for different queries, you
    can reuse the functionality encapsulated by the `BankStatementCSVParser` class.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这种重构的主要好处是，您的主要应用程序不再负责实现解析逻辑。它现在将该责任委托给一个单独的类和方法，这些类和方法可以独立维护和更新。随着不同查询的新需求出现，您可以重用
    `BankStatementCSVParser` 类封装的功能。
- en: In addition, if you need to change the way the parsing algorithm works (e.g.,
    a more efficient implementation that caches results), you now have just a single
    place that needs to change. Moreover, you introduced a class called `BankTransaction`
    that other parts of your code can rely on without depending on a specific data
    format pattern.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，如果你需要改变解析算法的工作方式（例如，更高效的实现并缓存结果），现在你只需要改变一个地方。此外，你引入了一个名为`BankTransaction`的类，其他代码部分可以依赖它而不依赖于特定的数据格式模式。
- en: 'It is a good habit to follow the *principle of least surprise* when you implement
    methods. It will help ensure that it is obvious what is happening when looking
    at the code. This means:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当你实现方法时，遵循*最少惊讶原则*是一个好习惯。这将有助于确保在查看代码时清楚地了解发生了什么。这意味着：
- en: Use self-documenting method names so it is immediately obvious what they do
    (e.g., `calculateTotalAmount()`)
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自说明的方法名，这样一看就能立刻知道它们在做什么（例如，`calculateTotalAmount()`）。
- en: Do not change the state of parameters as other parts of code may depend on it
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要改变参数的状态，因为代码的其他部分可能依赖于它。
- en: The principle of least surprise can be a subjective concept, though. When in
    doubt, speak to your colleagues and team members to ensure everyone is aligned.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最少惊讶原则可能是一个主观的概念。当有疑问时，请与你的同事和团队成员沟通，以确保大家达成一致。
- en: Cohesion
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内聚性
- en: 'So far you have learned about three principles: *KISS*, *DRY*, and *SRP*. But
    you have not learned about characteristics to reason about the quality of your
    code. In software engineering you will often hear about *cohesion* as an important
    characteristic of different parts of the code you write. It sounds fancy, but
    it is a really useful concept to give you an indication about the maintainability
    of your code.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经学习了三个原则：*KISS*、*DRY*和*SRP*。但你还没有学习到关于代码质量的评估特征。在软件工程中，你经常会听到*内聚性*作为你编写的代码不同部分的重要特征。听起来很花哨，但这是一个非常有用的概念，可以帮助你评估代码的可维护性。
- en: Cohesion is concerned with *how related* things are. To be more precise, cohesion
    measures how strongly related responsibilities of a class or method are. In other
    words, how much do things belong together? It is a way to help you reason about
    the complexity of your software. What you want to achieve is *high cohesion*,
    which means that the code is easier for others to locate, understand, and use.
    In the code that you refactored earlier, the class `BankTransactionCSVParser`
    is highly cohesive. In fact, it groups together two methods that are related to
    parsing CSV data.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 内聚性关注*相关性*。更准确地说，内聚性衡量了一个类或方法责任的强相关程度。换句话说，这些事情多么相关？这是一种帮助你理解软件复杂性的方式。你想要实现的是*高内聚性*，这意味着代码更容易被他人找到、理解和使用。在你之前重构的代码中，`BankTransactionCSVParser`类具有很高的内聚性。事实上，它组合了两个与解析CSV数据相关的方法。
- en: Generally, the concept of cohesion is applied to classes (class-level cohesion),
    but it can also be applied to methods (method-level cohesion).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，内聚性的概念适用于类（类级内聚性），但也可以应用于方法（方法级内聚性）。
- en: If you take the entry point to your program, the class `BankStatementAnalyzer`,
    you will notice that its responsibility is to wire up the different parts of your
    application such as the parser and the calculations and report back on the screen.
    However, the logic responsible for doing calculations is currently declared as
    static methods within the `BankStatementAnalyzer`. This is an example of poor
    cohesion because the concerns of calculations declared in this class are not directly
    related to parsing or reporting.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看一下程序的入口点，比如`BankStatementAnalyzer`类，你会注意到它的责任是连接你应用程序的不同部分，比如解析器和计算部分，并在屏幕上报告。然而，负责进行计算的逻辑目前被声明为`BankStatementAnalyzer`类中的静态方法。这是内聚性差的一个例子，因为在这个类中声明的计算关注点与解析或报告无直接关联。
- en: Instead, you can extract the calculation operations into a separate class called
    `BankStatementProcessor`. You can also see that the list of transactions method
    argument is shared for all these operations, so you can include it as a field
    to the class. As a result, your method signatures become simpler to reason about
    and the class `BankStatementProcessor` is more cohesive. The code in [Example 2-7](#bank_statement_processor_class)
    shows the end result. The additional advantage is that the methods of `BankStatementProcessor`
    can be reused by other parts of your application without depending on the whole
    `BankStatement​Analyzer`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你可以将计算操作提取到一个名为`BankStatementProcessor`的单独类中。你还可以看到，这些操作的方法参数列表是共享的，因此你可以将其包含为该类的一个字段。结果是，你的方法签名变得更简单易懂，类`BankStatementProcessor`更加内聚。[示例 2-7](#bank_statement_processor_class)中的代码展示了最终的结果。额外的好处是，`BankStatementProcessor`的方法可以被应用程序的其他部分重复使用，而不依赖于整个`BankStatementAnalyzer`。
- en: Example 2-7\. Grouping the calculation operations in the class BankStatementProcessor
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-7\. 在BankStatementProcessor类中分组计算操作
- en: '[PRE7]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can now make use the methods of this class with the `BankStatementAnalyzer`
    as shown in [Example 2-8](#refactored_bank_statement_analyzer).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以像[示例 2-8](#refactored_bank_statement_analyzer)中所示，使用这个类的方法来处理`BankStatementAnalyzer`。
- en: Example 2-8\. Processing lists of bank transactions using the BankStatementProcessor
    class
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-8\. 使用BankStatementProcessor类处理银行交易列表的示例
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the next subsections, you will focus on learning guidelines to help you write
    code that is easier to reason and maintain.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的小节中，你将专注于学习指南，帮助你编写更容易理解和维护的代码。
- en: Class-Level Cohesion
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类级别的内聚性
- en: 'In practice, you will come across at least six common ways to group methods:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，你至少会遇到六种常见的方法来分组方法：
- en: Functional
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能性
- en: Informational
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信息性
- en: Utility
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实用性
- en: Logical
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑性
- en: Sequential
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顺序性
- en: Temporal
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间性
- en: Keep in mind that if the methods you are grouping are weakly related, you have
    low cohesion. We discuss them in order and [Table 2-1](#summary_cohesion) provides
    a summary.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '请记住，如果你分组的方法之间关系较弱，那么内聚性就较低。我们按顺序讨论它们，[表 2-1](#summary_cohesion)提供了一个摘要。 '
- en: Functional
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 功能性
- en: 'The approach you took when writing the `BankStatementCSVParser` was to group
    the methods functionally. The methods `parseFrom()` and `parseLinesFrom()` are
    solving a defined task: parse the lines in the CSV format. In fact, the method
    `parseLinesFrom()` uses the method `parseFrom()`. This is generally a good way
    to achieve high cohesion because the methods are working together, so it makes
    sense to group them so they are easier to locate and understand. The danger with
    functional cohesion is that it may be tempting to have a profusion of overly simplistic
    classes grouping only a single method. Going down the road of overly simplistic
    classes adds unnecessary verbosity and complexity because there are many more
    classes to think about.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写`BankStatementCSVParser`时所采取的方法是将方法功能分组。方法`parseFrom()`和`parseLinesFrom()`解决了一个明确定义的任务：解析CSV格式的行。事实上，方法`parseLinesFrom()`使用了方法`parseFrom()`。这通常是实现高内聚性的好方法，因为这些方法一起工作，所以将它们分组以便更容易定位和理解是有意义的。功能内聚的危险在于可能诱导出过多过于简单的类，这些类仅仅分组了一个方法。沿着过于简单的类的道路走下去会增加不必要的冗长和复杂性，因为要考虑的类会更多。
- en: Informational
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 信息性
- en: Another reason to group methods is because they work on the same data or domain
    object. Say you needed a way to create, read, update, and delete `BankTransaction`
    objects (CRUD operations); you may wish to have a class dedicated for these operations.
    The code in [Example 2-9](#bank_statement_informational) shows a class that exhibits
    informational cohesion with four different methods. Each method throws a `UnsupportedOperationException`
    to indicate the body is currently unimplemented for the purpose of the example.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 将方法分组的另一个原因是因为它们作用于相同的数据或域对象。假设你需要一种方式来创建、读取、更新和删除`BankTransaction`对象（CRUD操作）；你可能希望有一个专门用于这些操作的类。[示例 2-9](#bank_statement_informational)中的代码展示了一个具有四个不同方法的信息性内聚类。每个方法都抛出`UnsupportedOperationException`以指示当前示例中未实现该方法的体。
- en: Example 2-9\. An example of informational cohesion
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-9\. 信息性内聚的示例
- en: '[PRE9]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-121
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This is a typical pattern that you see often when interfacing with a database
    that maintains a table for a specific domain object. This pattern is usually called
    *Data Access Object* (DAO) and requires some kind of ID to identify the objects.
    DAOs essentially abstract and encapsulate access to a data source, such as a persistent
    database or an in-memory database.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当与维护特定领域对象表的数据库进行接口时，这是一个典型模式。这种模式通常称为*数据访问对象*（DAO），并需要某种 ID 来识别对象。DAO实质上是将对数据源的访问抽象和封装，如持久数据库或内存数据库。
- en: The downside of this approach is that this kind of cohesion can group multiple
    concerns together, which introduces additional dependencies for a class that only
    uses and requires some of the operations.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是这种内聚性会将多个关注点组合在一起，为仅使用和需要某些操作的类引入额外的依赖关系。
- en: Utility
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实用性
- en: You may be tempted to group different unrelated methods inside a class. This
    happens when it is not obvious where the methods belong so you end up with a utility
    class that is a bit like a jack of all trades.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会被诱惑将不同无关的方法组合到一个类中。这种情况通常发生在方法应该放置的位置不明确时，因此你最终得到一个类似于样样通的实用类。
- en: This is generally to be avoided because you end up with low cohesion. The methods
    are not related, so the class as a whole is harder to reason about. In addition,
    utility classes exhibit a poor discoverability characteristic. You want your code
    to be easy to find and easy to understand how it is supposed to be used. Utility
    classes go against this principle because they contain different methods that
    are unrelated without a clear categorization.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常应避免，因为这会导致低内聚性。方法之间没有关联，因此整个类更难推理。此外，实用类展示了发现性差的特征。你希望你的代码易于查找，并且易于理解其应该如何使用。实用类违背了这个原则，因为它们包含了不相关的不同方法，没有明确的分类。
- en: Logical
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逻辑性
- en: Say you needed to provide implementations for parsing from CSV, JSON, and XML.
    You may be tempted to group the methods responsible for parsing the different
    format inside one class, as shown in [Example 2-10](#bank_statement_logical).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要为 CSV、JSON 和 XML 提供解析的实现。你可能会被诱惑将负责解析不同格式的方法放到一个类中，如示例 [2-10](#bank_statement_logical)
    所示。
- en: Example 2-10\. An example of logical cohesion
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-10\. 逻辑内聚性示例
- en: '[PRE10]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In fact, the methods are logically categorized to do “parsing.” However, they
    are different by nature and each of the methods would be unrelated. Grouping them
    would also break the SRP, which you learned about earlier, because the class is
    responsible for multiple concerns. Consequently, this approach is not recommended.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这些方法在逻辑上被分类为“解析”。然而，它们的本质是不同的，每个方法都是不相关的。将它们分组也会违反你之前学到的单一责任原则，因为这个类负责多个关注点。因此，不推荐这种方法。
- en: You will learn in [“Coupling”](#coupling) that there exist techniques to solve
    the problem of providing different implementations for parsing while also keeping
    high cohesion.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在[“耦合”](#coupling)中了解到，存在技术来解决在保持高内聚性的同时提供不同解析实现的问题。
- en: Sequential
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 顺序性
- en: Say you need to read a file, parse it, process it, and save the information.
    You may group all of the methods in one single class. After all the output of
    reading the file becomes the input to the parsing, the output of parsing becomes
    the input to the processing step, and so on.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要读取文件、解析文件、处理信息并保存信息。你可能会将所有方法都组合到一个单一类中。毕竟，文件读取的输出成为解析的输入，解析的输出成为处理步骤的输入，依此类推。
- en: This is called sequential cohesion because you are grouping the methods so that
    they follow a sequence of input to output. It makes it easy to understand how
    the operations work together. Unfortunately, in practice this means that the class
    grouping the methods has multiple reasons to change and is therefore breaking
    the SRP. In addition, there may be many different ways of processing, summarizing,
    and saving, so this technique quickly leads to complex classes.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为顺序内聚性，因为你将方法组合在一起，使它们按照输入到输出的顺序进行。这使得理解操作如何一起工作变得容易。不幸的是，实际操作中，这意味着组合方法的类有多个变更的原因，因此违反了单一责任原则（SRP）。此外，处理、汇总和保存可能有许多不同的方法，因此这种技术很快导致复杂的类。
- en: A better approach is to break down each responsibility inside individual, cohesive
    classes.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是将每个责任分解到各个内聚力强的类中。
- en: Temporal
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 时间性
- en: A temporally cohesive class is one that performs several operations that are
    only related in time. A typical example is a class that declares some sort of
    initialization and clean-up operations (e.g., connecting and closing a database
    connection) that is called before or after other processing operations. The initialization
    and the other operations are unrelated, but they have to be called in a specific
    order in time.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一个时间上连贯的类是指执行几个仅在时间上相关的操作。一个典型的例子是一个声明某种初始化和清理操作（例如连接和关闭数据库连接）的类，在其他处理操作之前或之后被调用。这些初始化和其他操作之间没有关联，但它们必须按特定的时间顺序调用。
- en: Table 2-1\. Summary of pros and cons for different levels of cohesion
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 表2-1\. 不同内聚度水平的优缺点总结
- en: '| Level of cohesion | Pro | Con |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 内聚度水平 | 优点 | 缺点 |'
- en: '| --- | --- | --- |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Functional (high cohesion) | Easy to understand | Can lead to overly simplistic
    classes |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 功能性（高内聚度） | 易于理解 | 可能导致过于简单的类 |'
- en: '| Informational (medium cohesion) | Easy to maintain | Can lead to unnecessary
    dependencies |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 信息性（中等内聚度） | 易于维护 | 可能导致不必要的依赖关系 |'
- en: '| Sequential (medium cohesion) | Easy to locate related operations | Encourages
    violation of SRP |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 顺序性（中等内聚度） | 易于定位相关操作 | 鼓励SRP的违反 |'
- en: '| Logical (medium cohesion) | Provides some form of high-level categorization
    | Encourages violation of SRP |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 逻辑性（中等内聚度） | 提供某种高级别的分类 | 鼓励SRP的违反 |'
- en: '| Utility (low cohesion) | Simple to put in place | Harder to reason about
    the responsibility of the class |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 实用性（低内聚度） | 简单实施 | 更难理解类的责任 |'
- en: '| Temporal (low cohesion) | N/A | Harder to understand and use individual operations
    |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 时间性（低内聚度） | 不适用 | 更难理解和使用各个操作 |'
- en: Method-Level Cohesion
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法级内聚度
- en: The same principle of cohesion can be applied to methods. The more different
    functionalities a method performs, the harder it becomes to understand what that
    method actually does. In other words, your method has low cohesion if it is handling
    multiple unrelated concerns. Methods that display low cohesion are also harder
    to test because they have multiple responsibilities within one method, which makes
    it difficult to test the responsibilities individually! Typically, if you find
    yourself with a method that contains a series of if/else blocks that make modifications
    to many different fields of a class or parameters to the method, then it is a
    sign you should break down the method in more cohesive parts.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 内聚度原则同样适用于方法。方法执行的功能越多，理解方法实际作用就越困难。换句话说，如果方法处理多个不相关的关注点，则其内聚度较低。内聚度较低的方法也更难测试，因为它们在一个方法中具有多个责任，这使得单独测试这些责任变得困难！通常情况下，如果你发现自己的方法包含一系列的if/else块，这些块对类的许多不同字段或方法参数进行修改，则这是你应该将方法拆分为更内聚部分的迹象。
- en: Coupling
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 耦合
- en: Another important characteristic about the code you write is *coupling*. Where
    *cohesion* is about how related things are in a class, package, or method, *coupling*
    is about how dependent you are on other classes. Another way to think about coupling
    is how much knowledge (i.e., specific implementation) you rely on about certain
    classes. This is important because the more classes you rely on, the less flexible
    you become when introducing changes. In fact, the class affected by a change may
    affect all the classes depending on it.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你编写的代码的另一个重要特征是*耦合*。而*内聚*是关于类、包或方法中相关事物的程度，*耦合*则是关于你对其他类的依赖程度。耦合还可以理解为你对某些类的具体实现（即具体实现细节）的依赖程度。这很重要，因为你依赖的类越多，引入变更时你的灵活性就越低。实际上，受变更影响的类可能会影响到所有依赖它的类。
- en: To understand what coupling is, think about a clock. There is no need to know
    how a clock works to read the time, so you are not dependent on the clock internals.
    This means you could change the clock internals without affecting how to read
    the time. Those two concerns (interface and implementation) are decoupled from
    one another.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解什么是耦合，可以想象一个时钟。你不需要知道时钟如何工作才能读取时间，因此你并不依赖于时钟的内部机制。这意味着你可以在不影响如何读取时间的情况下更改时钟的内部。这两个关注点（接口和实现）在彼此之间是解耦的。
- en: Coupling is concerned with *how dependent* things are. For example, so far the
    class `BankStatementAnalyzer` relies on the class `BankStatementCSVParser`. What
    if you need to change the parser so it supports statements encoded as JSON entries?
    What about XML entries? This would be an annoying refactoring! But do not worry,
    you can decouple different components by using an interface, which is the tool
    of choice for providing flexibility for changing requirements.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 耦合涉及*依赖性有多强*。例如，到目前为止，`BankStatementAnalyzer`类依赖于`BankStatementCSVParser`类。如果需要更改解析器以支持以JSON条目编码的对账单或XML条目会怎样？这将是一个烦人的重构！但是不用担心，通过使用接口可以解耦不同的组件，这是提供灵活性以适应变化需求的首选工具。
- en: First, you need to introduce an interface that will tell you how you can use
    a parser for bank statements but without hardcoding a specific implementation,
    as shown in [Example 2-11](#bank_statement_parser_interface).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要引入一个接口，告诉你如何使用银行对账单的解析器，但不硬编码具体实现，正如[示例 2-11](#bank_statement_parser_interface)所示。
- en: Example 2-11\. Introducing an interface for parsing bank statements
  id: totrans-155
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-11\. 引入一个解析银行对账单的接口
- en: '[PRE11]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Your `BankStatementCSVParser` will now become an implementation of that interface:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你的`BankStatementCSVParser`将成为该接口的一个实现：
- en: '[PRE12]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: So far so good, but how do you decouple the `BankStatementAnalyzer` from the
    specific implementation of a `BankStatementCSVParser`? You need to use the interface!
    By introducing a new method called `analyze()`, which takes `BankTransactionParser`
    as an argument, you are no longer coupled to a specific implementation (see [Example 2-12](#bank_statement_analyzer_decoupling)).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 目前为止一切顺利，但如何将`BankStatementAnalyzer`从具体的`BankStatementCSVParser`实现中解耦？你需要使用接口！通过引入一个名为`analyze()`的新方法，该方法接受`BankTransactionParser`作为参数，你不再与特定实现耦合（参见[示例 2-12](#bank_statement_analyzer_decoupling)）。
- en: Example 2-12\. Decoupling the Bank Statements Analyzer from the parser
  id: totrans-160
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-12\. 解耦银行对账单分析器与解析器
- en: '[PRE13]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is great because the `BankStatementAnalyzer` class no longer requires knowledge
    of different specific implementations, which helps with coping for changing requirements.
    [Figure 2-1](#eg_coupling_img) illustrates the difference of dependencies when
    you decouple two classes.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这很棒，因为`BankStatementAnalyzer`类不再需要了解不同具体实现的细节，这有助于应对不断变化的需求。[图 2-1](#eg_coupling_img)展示了在解耦两个类时依赖关系的差异。
- en: '![Decoupling two classes](Images/rwsd_0201.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![解耦两个类](Images/rwsd_0201.png)'
- en: Figure 2-1\. Decoupling two classes
  id: totrans-164
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-1\. 解耦两个类
- en: You can now bring all the different parts together and create your main application,
    as shown in [Example 2-13](#main_application).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以把所有不同的部分组合起来，创建你的主应用程序，如[示例 2-13](#main_application)所示。
- en: Example 2-13\. The main application to run
  id: totrans-166
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-13\. 运行主应用程序
- en: '[PRE14]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Generally, when writing code you will aim for *low coupling*. This means that
    different components in your code are not relying on internal/implementation details.
    The opposite of low coupling is called *high coupling*, which is what you definitely
    want to avoid!
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在编写代码时，你会力求实现*低耦合*。这意味着代码中的不同组件不依赖于内部/实现细节。低耦合的相反称为*高耦合*，这是你绝对要避免的！
- en: Testing
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: 'You have written some software and it looks like things are working if you
    execute your application a couple of times. However, how confident are you that
    your code will always work? What guarantee can you give your client that you have
    met the requirements? In this section, you will learn about testing and how to
    write your first automated test using the most popular and widely adopted Java
    testing framework: JUnit.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经写了一些软件，看起来如果你执行你的应用程序几次，似乎一切都正常工作。然而，你对你的代码会始终工作有多有信心？你能向客户保证你已经满足了需求吗？在本节中，你将学习有关测试以及如何使用最流行和广泛采用的Java测试框架JUnit编写你的第一个自动化测试。
- en: Automated Testing
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动化测试
- en: Automated testing sounds like yet another thing that could take more time away
    from the fun part, which is writing code! Why should you care?
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试听起来又是一件可能会把你从写代码的有趣部分中带走更多时间的事情！你为什么要在意？
- en: Unfortunately in software development, things never work the first time. It
    should be pretty obvious that testing has benefits. Can you imagine integrating
    a new auto-pilot software for planes without testing if the software actually
    works?
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在软件开发中，事情从来不会一次就成功。显然，测试是有益的。你能想象在没有测试软件是否真正有效的情况下集成新的飞机自动驾驶软件吗？
- en: Testing does not have to be a manual operation, though. In automated testing
    you have a suite of tests that runs automatically without human intervention.
    This means the tests can be executed quickly when you are introducing changes
    in the code and you want to increase confidence that the behavior of your software
    is correct and has not suddenly become unexpected. On an average day, a professional
    developer will often run hundreds or thousands of automated tests.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 测试并不需要手动操作。在自动化测试中，您拥有一套可以在没有人为干预的情况下自动运行的测试。这意味着当您在代码中引入更改并希望增加对软件行为正确性的信心时，测试可以快速执行。在一个平常的工作日里，专业开发人员通常会运行数百或数千个自动化测试。
- en: In this section, we will first briefly review the benefits of automated testing
    so you have a clear understanding of why testing is a core part of good software
    development.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将首先简要回顾自动化测试的好处，以便您清楚地理解为什么测试是良好软件开发核心的一部分。
- en: Confidence
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 信心
- en: First, performing tests on the software to validate whether the behavior matches
    the specification gives you confidence that you have met the requirements of your
    client. You can present the test specifications and results to your client as
    a guarantee. In a sense, the tests become the specification from your client.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，对软件执行测试以验证行为是否符合规范，可以使您确信已满足客户的要求。您可以将测试规范和结果呈现给客户作为保证。在某种意义上，测试成为了客户的规范。
- en: Robustness to changes
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对变更的鲁棒性
- en: Second, if you introduce changes to your code, how do you know that you have
    not accidentally broken something? If the code is small you may think problems
    will be obvious. However, what if you are working on a codebase with millions
    of lines of code? How confident would you feel about making changes to a colleague’s
    code? Having a suite of automated tests is very useful to check that you have
    not introduced new bugs.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，如果您对代码进行更改，如何确保您没有意外破坏任何东西？如果代码很小，您可能认为问题会很明显。但是，如果您正在处理数百万行的代码库呢？对于更改同事的代码，您会有多大的信心？拥有一套自动化测试非常有用，可以检查您是否引入了新的错误。
- en: Program comprehension
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 程序理解
- en: Third, automated tests can be useful to help you understand how the different
    components inside the source code project works. In fact, tests make explicit
    the dependencies of different components and how they interact together. This
    can be extremely useful for quickly getting an overview of your software. Say
    you are assigned to a new project. Where would you start to get an overview of
    different components? The tests are a great place to start.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，自动化测试对于帮助您理解源代码项目内部不同组件的工作方式非常有用。事实上，测试明确了不同组件的依赖关系以及它们如何相互作用。这对于快速了解软件概览非常有用。比如说，您被分配到一个新项目。您会从哪里开始了解不同组件？测试是一个很好的起点。
- en: Using JUnit
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 JUnit
- en: Hopefully you are now convinced of the value of writing automated tests. In
    this section, you will learn how to create your first automated test using a popular
    Java framework called *JUnit*. Nothing comes for free. You will see that writing
    a test takes time. In addition, you will have to think about the longer-term maintenance
    of the test you write since it is regular code, after all. However, the benefits
    listed in the previous section far outweigh the downsides of having to write tests.
    Specifically, you will write *unit tests*, which verify a small isolated unit
    of behavior for correctness, such as a method or a small class. Throughout the
    book you will learn about guidelines for writing good tests. Here you will first
    get an initial overview for writing a simple test for the `BankTransactionCSVParser`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您现在已经认识到编写自动化测试的价值所在。在本节中，您将学习如何使用一种名为 *JUnit* 的流行Java框架创建您的第一个自动化测试。没有免费的午餐。您将看到编写测试需要时间。此外，您还需要考虑编写的测试的长期维护，因为毕竟它是常规代码。然而，前一节列出的好处远远超过了编写测试的不利因素。具体来说，您将编写
    *单元测试*，用于验证小的独立行为单元的正确性，例如方法或小类。在本书中，您将学习编写良好测试的指导方针。在这里，您将首先获得为 `BankTransactionCSVParser`
    编写简单测试的初步概述。
- en: Defining a test method
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义一个测试方法
- en: The first question is where do you write your test? The standard convention
    from the Maven and Gradle build tools is to include your code in *src/main/java*
    and the test classes inside *src/test/java*. You will also need to add a dependency
    to the JUnit library to your project. You will learn more about how to structure
    a project using Maven and Gradle in [Chapter 3](ch03.xhtml#chapter_03).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 首先的问题是你要在哪里编写你的测试？从 Maven 和 Gradle 构建工具的标准约定来看，你的代码应该放在 *src/main/java* 中，而测试类则放在
    *src/test/java* 中。你还需要将 JUnit 库作为项目的依赖添加进去。你将在 [第三章](ch03.xhtml#chapter_03) 中学习更多关于如何使用
    Maven 和 Gradle 来组织项目结构的内容。
- en: '[Example 2-14](#bank_statement_parser_empty_test) shows a simple test for `BankTransactionCSVParser`.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 2-14](#bank_statement_parser_empty_test) 展示了对 `BankTransactionCSVParser`
    的简单测试。'
- en: Note
  id: totrans-187
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Our `BankStatementCSVParserTest` test class has the `Test` suffix. It is not
    strictly necessary, but often used as a useful aide memoire.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `BankStatementCSVParserTest` 测试类有 `Test` 后缀。这并非绝对必要，但通常作为一个有用的提示。
- en: Example 2-14\. A failing unit test for the CSV parser
  id: totrans-189
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-14\. CSV 解析器的单元测试失败
- en: '[PRE15]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'There are a lot of new parts here. Let’s break it down:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多新的部分。让我们逐一分解：
- en: The unit test class is an ordinary class called `BankStatementCSVParserTest`.
    It is a common convention to use the `Test` suffix at the end of test class names.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试类是一个普通的类，名为 `BankStatementCSVParserTest`。按照惯例，在测试类名后面使用 `Test` 后缀是很常见的。
- en: 'The class declares one method: `shouldParseOneCorrectLine()`. It is recommended
    to always come up with a descriptive name so it is immediately obvious what the
    unit test does without looking at the implementation of the test method.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个类声明了一个方法：`shouldParseOneCorrectLine()`。建议总是使用描述性名称，这样一看到测试方法的实现就能立即知道它的作用。
- en: This method is annotated with the JUnit annotation `@Test`. This means that
    the method represents a unit test that should be executed. You can declare private
    helper methods with a test class, but they won’t be executed by the test runner.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个方法用 JUnit 注解 `@Test` 进行了标注。这意味着该方法代表一个应该执行的单元测试。你可以在测试类中声明私有的辅助方法，但它们不会被测试运行器执行。
- en: The implementation of this method calls `Assert.fail("Not yet implemented")`,
    which will cause the unit test to fail with the diagnostic message `"Not yet implemented"`.
    You will learn shortly how to actually implement a unit test using a set of assertion
    operations available in JUnit.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此方法的实现调用了 `Assert.fail("Not yet implemented")`，这将导致单元测试以诊断消息 “Not yet implemented”
    失败。你很快将学习如何使用 JUnit 提供的一组断言操作来实际实现一个单元测试。
- en: You can execute your test directly from your favorite build tool (e.g., Maven
    or Gradle) or by using your IDE. For example, after running the test in the IntelliJ
    IDE, you get the output in [Figure 2-2](#eg_unit_test_run_img). You can see the
    test is failing with the diagnostic “Not yet implemented”. Let’s now see how to
    actually implement a useful test to increase the confidence that the `BankStatementCSVParser`
    works correctly.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以直接从你喜欢的构建工具（如 Maven 或 Gradle）或使用你的 IDE 执行测试。例如，在 IntelliJ IDE 中运行测试后，你将在
    [图 2-2](#eg_unit_test_run_img) 中看到输出。你可以看到测试以诊断信息 “Not yet implemented” 失败。现在让我们看看如何实际实现一个有用的测试，以增加对
    `BankStatementCSVParser` 正确工作的信心。
- en: '![Running a unit test](Images/rwsd_0202.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![执行单元测试](Images/rwsd_0202.png)'
- en: Figure 2-2\. Screenshot from the IntelliJ IDE of running a failing unit test
  id: totrans-198
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-2\. 在 IntelliJ IDE 中运行失败单元测试的截图
- en: Assert statements
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Assert 语句
- en: You have just learned about `Assert.fail()`. This is a static method provided
    by JUnit called an *assert statement*. JUnit provides many assert statements to
    test for certain conditions. They let you provide an expected result and compare
    it with the result of some operation.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚学到了 `Assert.fail()`。这是由 JUnit 提供的一个静态方法，称为 *断言语句*。JUnit 提供了许多断言语句，用于测试特定的条件。它们允许你提供预期结果并将其与某些操作的结果进行比较。
- en: One of these static method is called `Assert.assertEquals()`. You can use it
    as shown in [Example 2-15](#bank_statement_parser_test_assertions) to test that
    the implementation of `parseFrom()` works correctly for a particular input.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个静态方法叫做 `Assert.assertEquals()`。你可以像 [示例 2-15](#bank_statement_parser_test_assertions)
    中展示的那样使用它，测试 `parseFrom()` 的实现对特定输入是否正常工作。
- en: Example 2-15\. Using assertion statements
  id: totrans-202
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-15\. 使用断言语句
- en: '[PRE16]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'So what is going on here? There are three parts:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这里发生了什么？有三个部分：
- en: You set up the context for your test. In this case a line to parse.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你为你的测试设置上下文。在这种情况下，是一行要解析的内容。
- en: You carry out an action. In this case, you parse the input line.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你执行一个操作。在这种情况下，你解析输入行。
- en: You specify assertions of the expected output. Here, you check that the date,
    amount, and description were parsed correctly.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您指定了预期输出的断言。在这里，您检查日期、金额和描述是否被正确解析。
- en: This three-stage pattern for setting up a unit test is often referred to as
    the *Given-When-Then* formula. It is a good idea to follow the pattern and split
    up the different parts because it helps to clearly understand what the test is
    actually doing.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 设置单元测试的这种三阶段模式通常被称为*Given-When-Then*公式。遵循这种模式并拆分不同的部分是一个好主意，因为它有助于清楚地理解测试实际在做什么。
- en: When you run the test again, with a bit luck you will see a nice green bar indicating
    that the test succeeded, as shown in [Figure 2-3](#eg_unit_test_success_img).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当您再次运行测试时，有点运气的话，您将看到一个漂亮的绿色条表示测试成功，如[图2-3](#eg_unit_test_success_img)所示。
- en: '![Test passed](Images/rwsd_0203.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![测试通过](Images/rwsd_0203.png)'
- en: Figure 2-3\. Running a passing unit test
  id: totrans-211
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-3\. 运行通过的单元测试
- en: There are other assertion statements available, which are summarized in [Table 2-2](#table_assertion).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他可用的断言语句，总结在[表2-2](#table_assertion)中。
- en: Table 2-2\. Assertion statements
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 表2-2\. 断言语句
- en: '| Assertion statement | Purpose |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| 断言语句 | 目的 |'
- en: '| --- | --- |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Assert.fail(message)` | Let the method fail. This is useful as a placeholder
    before you implement the test code. |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.fail(message)` | 让方法失败。这在您实现测试代码之前作为占位符很有用。 |'
- en: '| `Assert.assertEquals​(expected, actual)` | Test that two values are the same.
    |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.assertEquals​(expected, actual)` | 测试两个值是否相同。 |'
- en: '| `Assert.assertEquals​(expected, actual, delta)` | Assert that two floats
    or doubles are equal to within a delta. |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.assertEquals​(expected, actual, delta)` | 断言两个浮点数或双精度数在误差范围内相等。 |'
- en: '| `Assert.assertNotNull(object)` | Assert that an object is not null. |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| `Assert.assertNotNull(object)` | 断言对象不为空。 |'
- en: Code Coverage
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码覆盖率
- en: You’ve written your first test and it’s great! But how can you tell if that
    is sufficient? *Code coverage* refers to how much of the source code of your software
    (i.e., how many lines or blocks) is tested by a set of tests. It is generally
    a good idea to aim for high coverage because it reduces the chance of unexpected
    bugs. There isn’t a specific percentage that is considered sufficient, but we
    recommend aiming for 70%–90%. In practice, it is hard and less practical to actually
    reach 100% of code coverage because you may, for example, start testing getter
    and setter methods, which provides less value.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 您编写了您的第一个测试，这很棒！但是如何确定这已经足够了呢？*代码覆盖率*指的是您的软件源代码（即，多少行或块）被一组测试覆盖的程度。通常，目标是追求高覆盖率，因为它降低了意外错误的几率。没有一个具体的百分比被认为是足够的，但我们建议目标是70%–90%。在实践中，实际上很难达到100%的代码覆盖率，因为您可能会测试getter和setter方法，这提供了较少的价值。
- en: However, code coverage is not necessarily a good metric of how well you are
    testing your software. In fact, code coverage only tells you what you definitely
    have not tested. Code coverage does not say anything about the quality of your
    tests. You may cover parts of your code with a simplistic test case, but not necessarily
    for edge cases, which usually lead to problematic issues.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，代码覆盖率不一定是测试软件的好指标。事实上，代码覆盖率只告诉您您绝对没有测试的内容。代码覆盖率并不说明您测试的质量。您可能用简单的测试用例覆盖代码的一部分，但不一定覆盖边界情况，这通常会导致问题。
- en: Popular code coverage tools in Java include *JaCoCo*, *Emma*, and *Cobertura*.
    In practice, you will see people talking about line coverage, which tells you
    how many statements the code covered. This technique gives a false sense of having
    good coverage because conditionals (if, while, for) will count as one statement.
    However, conditionals have multiple possible paths. You should therefore favor
    *branch coverage*, which checks the true and false branch for each conditional.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Java中流行的代码覆盖工具包括*JaCoCo*、*Emma*和*Cobertura*。在实践中，您会看到人们谈论行覆盖率，它告诉您代码覆盖了多少语句。这种技术会给您一种错误的感觉，认为代码覆盖良好，因为条件（if、while、for）将被计算为一个语句。然而，条件具有多个可能的路径。因此，您应该优先考虑*分支覆盖*，它检查每个条件的真假分支。
- en: Takeaways
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收获
- en: God Classes and code duplication lead to code that is hard to reason about and
    maintain.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大类和代码重复导致代码难以推理和维护。
- en: The Single Responsibility Principle helps you write code that is easier to manage
    and maintain.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单一责任原则帮助您编写更易于管理和维护的代码。
- en: Cohesion is concerned with how how strongly related the responsibilities of
    a class or method are.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内聚性关注一个类或方法的职责之间有多强的相关性。
- en: Coupling is concerned with how dependent a class is on other parts of your code.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 耦合关注的是一个类在代码其他部分的依赖程度。
- en: High cohesion and low coupling are characteristics of maintainable code.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高内聚低耦合是可维护代码的特征。
- en: A suite of automated tests increases confidence that your software is correct,
    makes it more robust for changes, and helps program comprehension.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一套自动化测试增加了软件正确性的信心，使其对变更更加健壮，并帮助程序理解。
- en: JUnit is a Java testing framework that lets you specify unit tests that verify
    the behavior of your methods and classes.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JUnit是一个Java测试框架，允许你指定验证方法和类行为的单元测试。
- en: Given-When-Then is a pattern for setting up a test into three parts to help
    understand the tests you implement.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定-当-那么 是一种将测试分为三个部分的模式，以帮助理解你实现的测试。
- en: Iterating on You
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在你的迭代中
- en: 'If you want to extend and solidify the knowledge from this section, you could
    try one of these activities:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想深入和巩固本节的知识，可以尝试以下活动：
- en: Write a couple more unit test cases to test the implementation of the CSV parser.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写几个额外的单元测试用例，以测试CSV解析器的实现。
- en: Support different aggregate operations, such as finding the maximum or minimum
    transactions in specific date ranges.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持不同的聚合操作，比如在特定日期范围内查找最大或最小的交易。
- en: Return a histogram of the expenses by grouping them based on months and descriptions.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回一个按月份和描述分组的支出直方图。
- en: Completing the Challenge
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成挑战
- en: Mark Erbergzuck is very happy with your first iteration of your Bank Statements
    Analyzer. He takes your idea and renames it **THE Bank Statements Analyzer**.
    He is so happy with your application that he is asking you for a few enhancements.
    It turns out he would like to extend the reading, parsing, processing, and summarizing
    functionalities. For example, he is a fan of JSON. In addition, he found your
    tests a bit limited and found a couple of bugs.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Mark Erbergzuck对你的银行对账单分析器的第一次迭代非常满意。他采纳了你的想法，并将其重命名为**THE Bank Statements Analyzer**。他对你的应用非常满意，因此他要求你进行一些增强。事实证明，他希望扩展阅读、解析、处理和汇总功能。例如，他喜欢JSON。此外，他认为你的测试有些有限，并发现了一些错误。
- en: This is something that you will address in the next chapter, where you will
    learn about exception handling, the Open/Closed Principle, and how to build your
    Java project using a build tool.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你将在下一章中解决的问题，在那里你将学习异常处理、开闭原则，以及如何使用构建工具构建你的Java项目。
- en: ^([1](ch02.xhtml#idm45816839001464-marker)) This definition is attributed to
    Robert Martin.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch02.xhtml#idm45816839001464-marker)) 这个定义归因于Robert Martin。
