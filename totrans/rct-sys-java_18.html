<html><head></head><body><section data-pdf-bookmark="Conclusion" data-type="afterword" epub:type="afterword"><div class="appendix" id="conclusion">&#13;
<h1>Conclusion</h1>&#13;
&#13;
&#13;
<p>We have come to the end of this book.&#13;
We have covered the principles behind reactive architectures and the technical practices to implement them with Quarkus.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="A Brief Summary" data-type="sect1"><div class="sect1" id="idm45358812674576">&#13;
<h1>A Brief Summary</h1>&#13;
&#13;
<p>In <a data-type="xref" href="part02.html#reactive-part">Part II</a>, we explored reactive architectures.&#13;
Reactive systems (<a data-type="xref" href="ch04.html#reactive-systems">Chapter 4</a>) propose a different way to build distributed systems (<a data-type="xref" href="ch03.html#distributed-system">Chapter 3</a>).&#13;
The use of message passing between the various components forming the system enables elasticity and resilience, two characteristics essential for modern applications deployed in the cloud or running in containers.&#13;
But that’s not all.&#13;
Reactive applications must also handle the workload in a timely fashion and use resources efficiently.&#13;
This last point pushes reactive applications to use nonblocking I/O and avoids creating too many OS threads (<a data-type="xref" href="ch04.html#reactive-system::non-blocking">“The Role of Nonblocking Input/Output”</a>).&#13;
The resulting execution model provides better response time and improves memory consumption.&#13;
However, it does not come for free.&#13;
To write such an application, you must change the way you write code.&#13;
You must never block the I/O threads and so must write your code using a continuation-passing style.&#13;
In this book, we have looked at reactive programming and Mutiny (<a data-type="xref" href="ch05.html#reactive-programming">Chapter 5</a>, <a data-type="xref" href="ch07.html#mutiny">Chapter 7</a>).</p>&#13;
&#13;
<p>We also covered Quarkus, a stack to write applications in Java tailored for the cloud and containers (<a data-type="xref" href="ch02.html#quarkus">Chapter 2</a>).&#13;
Quarkus runs on top of a reactive engine dealing with the network and nonblocking I/O.&#13;
In addition, Quarkus offers a large set of reactive APIs.&#13;
The combination of the engine and the API creates a breeding ground to build reactive applications (<a data-type="xref" href="ch06.html#quarkus-reactive">Chapter 6</a>).&#13;
Quarkus provides reactive APIs to serve HTTP endpoints (<a data-type="xref" href="ch08.html#http">Chapter 8</a>), as well as to interact with data sources (<a data-type="xref" href="ch09.html#data">Chapter 9</a>) and consume HTTP services (<a data-type="xref" href="ch12.html#http-client">Chapter 12</a>).</p>&#13;
&#13;
<p>Quarkus also provides the connective tissue for building reactive systems (<a data-type="xref" href="ch10.html#messaging">Chapter 10</a>).&#13;
This book covered Kafka and AMQP 1.0, but many more possibilities are available (<a data-type="xref" href="ch11.html#event-bus">Chapter 11</a>).</p>&#13;
&#13;
<p>Quarkus lets you design, build, and operate reactive systems.&#13;
Observability is a key component for distributed systems and not a feature to be tacked on at the end of development (<a data-type="xref" href="ch13.html#observability">Chapter 13</a>).&#13;
Reactive systems are distributed systems, and failures are inevitable.&#13;
Being able to observe, detect issues, emit alerts, and react is essential to keep the system running and serve its purpose.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Is That All?" data-type="sect1"><div class="sect1" id="idm45358812616320">&#13;
<h1>Is That All?</h1>&#13;
&#13;
<p>This book did not offer a silver-bullet solution to build reactive systems.&#13;
We have covered the principles and the building blocks to build them.&#13;
But, as with everything in software, the ideal solutions always depend on the problem.&#13;
We’ve showed you a toolbox, but it’s up to you to select the best tool for your application, assemble your system following the reactive principles, and profit.</p>&#13;
&#13;
<p>Throughout this book, we have shown many features to implement reactive applications and systems with Quarkus, but we’ve only scratched the surface.&#13;
Quarkus offers a lot more reactive features.</p>&#13;
&#13;
<p>We explained how you can deal with HTTP in a reactive fashion.&#13;
But there are alternatives to HTTP.&#13;
gRPC, for example, is a secure, polyglot, and performant RPC protocol that can replace most HTTP interactions.&#13;
It uses a contract-first approach (written using Protobuf), and supports unidirectional and bidirectional streams.&#13;
Quarkus lets you implement gRPC services and consume them.&#13;
It relies on the reactive engine and therefore offers excellent performance and resource utilization.&#13;
In addition, it integrates with the Mutiny API.</p>&#13;
&#13;
<p>We have also covered the data space, explaining how you can interact with various databases from within your Quarkus application.&#13;
Quarkus offers reactive access to databases such as PostgreSQL, MySQL, Db2, SQL Server, and Oracle.&#13;
Quarkus also provides reactive APIs to interact with many NoSQL databases such as Neo4j, Cassandra, Redis, and MongoDB.</p>&#13;
&#13;
<p>Finally, to build reactive systems, you often need a message broker, or a way to exchange messages asynchronously.&#13;
In this book, we used Apache Kafka and Apache ActiveMQ.&#13;
Quarkus offers a lot more. You can integrate with MQTT, RabbitMQ, or JMS.&#13;
Quarkus can be combined with Apache Camel to interact with virtually any existing system without preventing <em>reactiveness</em>.</p>&#13;
&#13;
<p>In other words, Quarkus offers a complete toolbox that lets you build reactive applications for many contexts and use cases.&#13;
You have endless possibilities.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Future of Reactive Systems" data-type="sect1"><div class="sect1" id="idm45358812610144">&#13;
<h1>The Future of Reactive Systems</h1>&#13;
&#13;
<p>It’s impossible to predict the future with a high degree of certainty.&#13;
The best we can do is track meaningful trends and prepare for change.&#13;
The following are some trends that we think are important to track.</p>&#13;
&#13;
<p>HTTP is evolving.&#13;
HTTP/3 comes with a better flow-control approach and parallel request transmission, improving overall communication across the system.</p>&#13;
&#13;
<p>The use of message brokers is growing tremendously.&#13;
New brokers are emerging, such as Apache Pulsar, NATS, and KubeMQ.&#13;
The last two are built with Kubernetes in mind and integrate well in such an environment.&#13;
Several revolutionizing projects are changing how to process messages and derive knowledge from event streams. Apache Pinot, to cite one, allows querying data coming from event streams such as Apache Kafka.</p>&#13;
&#13;
<p>As in many other domains, the rise of machine learning and AI also influence the construction of reactive systems.&#13;
Machine learning algorithms can help understand the system and adapt it to handle failures or peaks of demands.&#13;
Already today, you can see Kubernetes operators collecting metrics about a system and adapting it to face the current workload.</p>&#13;
&#13;
<p>At the code level, Project Loom is promising.&#13;
It will drastically reduce the complexity of writing efficient reactive applications. Approaches to express structured concurrency such as Ballerina and Joli are still niched but may become more popular shortly.</p>&#13;
&#13;
<p>There are many more trends.&#13;
Keep an eye on the technologies that embrace the reactive principles we explained in this book.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The End of the Beginning" data-type="sect1"><div class="sect1" id="idm45358812604848">&#13;
<h1>The End of the Beginning</h1>&#13;
&#13;
<p>You now have all the tools to build <em>better</em> distributed systems that are more robust and more efficient.&#13;
Quarkus, a Java stack tailored for the cloud, will let you embrace the reactive system paradigm smoothly, one step at a time.&#13;
Go ahead!</p>&#13;
&#13;
<p>We hope you enjoyed this journey. Now it’s time for you to start a new one by using what you’ve learned.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>