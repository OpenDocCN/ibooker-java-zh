- en: Chapter 5\. Objects in Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we get to the heart of Java and explore its object-oriented
    aspects. The term *object-oriented design* refers to the art of decomposing an
    application into some number of *objects*, which are self-contained application
    components that work together. The goal is to break your problem down into smaller
    problems that are simpler and easier to handle and maintain. Object-based designs
    have proven themselves over the years, and object-oriented languages such as Java
    provide a strong foundation for writing applications—from the very small to the
    very large. Java was designed from the ground up to be an object-oriented language,
    and all of the Java APIs and libraries are built around solid object-based design
    patterns.
  prefs: []
  type: TYPE_NORMAL
- en: An object design *methodology* is a system or a set of rules created to help
    you break down your application into objects. Often this means mapping real-world
    entities and concepts (sometimes called the *problem domain*) into application
    components. Various methodologies attempt to help you factor your application
    into a good set of reusable objects. This is good in principle, but the problem
    is that good object-oriented design is still more art than science. While you
    can learn from off-the-shelf design methodologies, none of them will help you
    in all situations. The truth is that there is no substitute for experience.
  prefs: []
  type: TYPE_NORMAL
- en: We won’t try to push you into a particular methodology here; there are shelves
    full of books to do that.^([1](ch05.html#id1063)) Instead, we’ll provide some
    common-sense hints along the way as you get started.
  prefs: []
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Classes are the building blocks of a Java application. A *class* can contain
    methods (functions), variables, initialization code, and, as we’ll discuss later,
    other classes. Separate classes that describe individual parts of a more complex
    idea are often bundled in *packages*, which help you organize larger projects.
    (Every class belongs to some package, even the simple examples we’ve seen so far.)
    An *interface* can describe some specific commonalities between otherwise disparate
    classes. Classes can be related to each other by extension or to interfaces by
    implementation. [Figure 5-1](#learnjava6-CHP-5-FIG-1) illustrates the ideas in
    this very dense paragraph.
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 0501](assets/ljv6_0501.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-1\. Class, interface, and package overview
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`Object` (in the upper-left corner) is the foundational class at the heart
    of every other class in Java. It is part of the core Java package, `java.lang`.
    Java also has a package for its graphical UI elements called `javax.swing`. Inside
    that package, the `JComponent` class defines all of the low-level, common properties
    of graphical things, like frames and buttons and canvases. The `JLabel` class,
    for example, *extends* the `JComponent` class. That means `JLabel` inherits details
    from `JComponent` but adds things specific to labels. You might have noticed that
    `JComponent` itself extends from `Object`, or at least, it eventually extends
    back to `Object`. For brevity’s sake, we have left out the intermediate classes
    and packages in between.'
  prefs: []
  type: TYPE_NORMAL
- en: You can define your own classes and packages as well. For instance, the `ch05.examples.game`
    package in the lower-right corner is a custom package we built for a simple game
    that allows physicists to throw apples. (Newton will have his revenge!) In this
    package, we have some classes, like `Apple` and `Field`, that are part of our
    application. You can also see the `GamePiece` interface, which will contain some
    common, required elements for all game pieces and is implemented by the `Apple`,
    `Tree`, and `Physicist` classes. (In our game, the `Field` class is where all
    of the game pieces will be shown, but it is not a game piece itself. Notice that
    it does *not* implement the `GamePiece` interface.)
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will go into much more detail, with more examples of each concept.
    We heartily recommend that you try the examples as you go and use the *jshell*
    tool (discussed in [“Trying Java”](ch03.html#learnjava6-CHP-3-SECT-6)) to help
    cement your understanding of new topics.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring and Instantiating Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A class serves as a blueprint for making *instances*, which are runtime objects
    (individual copies) that implement the class structure. You declare a class with
    the `class` keyword and a name of your choosing. In our game, for example, the
    physicists, apples, and trees are all good targets for becoming classes. Inside
    a class, we add variables that store details or other useful information, and
    methods that describe what we can do to and with instances of this class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s get started with a class for our apples. By (strong!) convention, class
    names start with capital letters. That makes `Apple` a good name to use. We won’t
    try to get every detail about our game apples into the class right away, just
    a few elements to help illustrate how a class, variables, and methods fit together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Apple` class contains four variables: `mass`, `diameter`, `x`, and `y`.
    It also defines a method called `isTouching()`, which takes a reference to another
    `Apple` as an argument and returns a `boolean` value as a result. Variables and
    method declarations can appear in any order, but variable initializers can’t make
    “forward references” to other variables that appear later. (In our little snippet,
    the `diameter` variable could use the `mass` variable to help calculate its initial
    value, but `mass` could not use the `diameter` variable to do the same.) Once
    we’ve defined the `Apple` class, we can create an `Apple` object (an instance
    of that class) for our game, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Recall that our declaration of the variable `a1` doesn’t create an `Apple` object;
    it simply creates a variable that refers to an object of type `Apple`. We still
    have to create the object, using the `new` keyword, as shown in the second line
    of the preceding code snippet. But you can combine those steps into a single line
    just as we did for the `a2` variable. The same separate actions occur under the
    hood, of course. Sometimes the combined declaration and initialization will feel
    more readable than the multiline version.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve created an `Apple` object, we can access its variables and methods,
    as we’ve seen in several of our examples from [Chapter 4](ch04.html#learnjava6-CHP-4)
    or even our graphical “Hello” app from [“HelloJava”](ch02.html#learnjava6-CHP-2-SECT-2).
    Although this is not very exciting, we could now build another class, `PrintAppleDetails`,
    that is a complete application to create an `Apple` instance and print its details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If you compile and run this example, you should see the following output in
    your terminal or in the terminal window of your IDE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: But hmm, why doesn’t `a1` have a mass? If you look back at how we declared the
    variables for our `Apple` class, we only initialized `diameter`. All the other
    variables get the Java-assigned default value of `0` since they are numeric types.^([2](ch05.html#id1073))
    We would ideally like to have a more interesting apple. Let’s see how to provide
    those interesting bits.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing Fields and Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you have a reference to an object, you can use and manipulate its variables
    and methods using the dot notation you saw in [Chapter 4](ch04.html#learnjava6-CHP-4).
    Let’s create a new class, `PrintAppleDetails2`, provide some values for the mass
    and position of our `a1` instance, and then print the new details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the new output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Great! `a1` is looking a little better. But look at the code again. We had to
    repeat the three lines that print the object’s details. That type of exact replication
    calls out for a *method*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Methods allow us to “do stuff” inside a class. As a simple example, we could
    improve the `Apple` class by providing these print statements in a method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'With those detail statements relocated, we can create `PrintAppleDetails3`
    that does its job more succinctly than its predecessor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Take another look at the `printDetails()` method we added to the `Apple` class.
    Inside a class, we can access variables and call methods of the class directly
    by name. The print statements just use the simple names like `mass` and `diameter`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Or consider filling out the `isTouching()` method. We can use our own `x` and
    `y` coordinates without any special prefix. But to access the coordinates of some
    other apple, we need to go back to the dot notation. Here’s one way to write that
    method using some math (more of this in [“The java.lang.Math Class”](ch08.html#learnjava6-CHP-8-SECT-4.1))
    and the `if/then` statement we saw in [“if/else conditionals”](ch04.html#learnjava6-CHP-4-SECT-5.1.1):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s fill out a bit more of our game and create a `Field` class that uses
    a few `Apple` objects. It creates instances as member variables and works with
    those objects in the `setupApples()` and `detectCollision()` methods, invoking
    `Apple` methods and accessing variables of those objects through the references
    `a1` and `a2`, visualized in [Figure 5-2](#learnjava6-CHP-5-FIG-2):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![ljv6 0502](assets/ljv6_0502.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-2\. Instances of the `Apple` class
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'We can prove that `Field` has access to the apples’ variables and methods with
    another iteration of our application, `PrintAppleDetails4`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We should see the familiar apple details followed by an answer to whether or
    not the two apples are touching:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Great, just what we expected.
  prefs: []
  type: TYPE_NORMAL
- en: Before reading further, try changing the positions of the apples to make them
    touch. Do you get the expected output?
  prefs: []
  type: TYPE_NORMAL
- en: Access modifiers preview
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Several factors affect whether class members can be accessed from another class.
    You can use the visibility modifiers `public`, `private`, and `protected` to control
    access; classes can also be placed into a *package*, which affects their scope.
    The `private` modifier, for example, designates a variable or method for use only
    by other members of the class itself. In the previous example, we could change
    the declaration of our variable `diameter` to `private`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can’t access `diameter` from `Field`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If we still need to access `diameter` in some capacity, we would usually add
    public `getDiameter()` and `setDiameter()` methods to the `Apple` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Creating methods like this is a good design rule because it allows future flexibility
    in changing the type or behavior of the value. We’ll look more at packages, access
    modifiers, and how they affect the visibility of variables and methods later in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Static Members
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we’ve said, instance variables and methods are associated with and accessed
    through an instance of the class (that is, through a particular object, like `a1`
    or `f` in the previous examples). In contrast, members that are declared with
    the `static` modifier live in the class and are shared by all instances of the
    class. Variables declared with the `static` modifier are called *static variables*
    or *class variables*; similarly, these kinds of methods are called *static methods*
    or *class methods*. Static members are useful as flags and identifiers, that can
    be accessed from anywhere. We can add a static variable to our `Apple` example
    to store the value of acceleration due to gravity. This lets us calculate the
    trajectory of a tossed apple when we start animating our game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We have declared the new `float` variable `gravAccel` as `static`. That means
    it is associated with the class, not with an individual instance, and if we change
    its value (either directly or through any instance of `Apple`), the value changes
    for all `Apple` objects, as shown in [Figure 5-3](#learnjava6-CHP-5-FIG-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 0503](assets/ljv6_0503.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-3\. Static variables shared by all instances of a class
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You can access static members similarly to the way you access instance members.
    Inside our `Apple` class, we can refer to `gravAccel` like any other variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'However, since static members exist in the class itself, independent of any
    instance, we can also access them directly through the class. If we want to toss
    apples on Mars, for example, we don’t need an `Apple` object like `a1` or `a2`
    to get or set the variable `gravAccel`. Instead, we can use the class to change
    the variable to reflect conditions on Mars:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This changes the value of `gravAccel` for the class and all its instances.
    We don’t have to manually set each instance of `Apple` to fall on Mars. Static
    variables are useful for any kind of data that is shared among classes at runtime.
    For instance, you can create methods to register your object instances so that
    they can communicate, or so that you can keep track of all of them. It’s also
    common to use static variables to define constant values. In this case, we use
    the `static` modifier along with the `final` modifier. So, if we cared only about
    apples under the influence of the Earth’s gravitational pull, we might change
    `Apple` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We have followed a common convention here and named our constant with capital
    letters and underscores (if the name has more than one word). The value of `EARTH_ACCEL`
    is a constant; you can access it through the class `Apple` or its instances, but
    you can’t change its value.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s important to use the combination of `static` and `final` only for things
    that are really constant. The compiler is allowed to “inline” such values within
    classes that reference them. This means that if you change a `static final` variable,
    you may have to recompile all code that uses that class (this is really the only
    case where you have to do that in Java). Static members are also useful for values
    needed in the construction of an instance itself. In our example, we might declare
    a number of static values to represent various sizes of `Apple` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We might then use these options in a method that sets the size of an `Apple`,
    or in a special constructor, as we’ll discuss shortly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, inside the `Apple` class, we can use static members directly by name,
    as well. There’s no need for the `Apple.` prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, our example classes have been fairly simple. We keep a few bits of information
    around—apples have mass, fields have a couple of apples, etc. But we have also
    touched on the idea of making those classes do stuff. All of our various `PrintAppleDetails`
    classes have a list of steps that get executed when we run the program, for example.
    As we noted briefly before, in Java, those steps are bundled into a method. In
    the case of `PrintAppleDetails`, that is the `main()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Everywhere you have steps to take or decisions to make, you need a method. In
    addition to storing variables like the `mass` and `diameter` in our `Apple` class,
    we also added a few pieces of code that contained actions and logic. Methods are
    so fundamental to classes that we had to create a few even before getting here
    to the formal discussion of them! Think back to the `printDetails()` method in
    `Apple` or the `setupApples()` method in `Field`. Even our very first, simple
    program required a `main()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, the methods we have discussed so far have been straightforward enough
    to follow just from context. But methods can do much more than print out a few
    variables or calculate a distance. They can contain local variable declarations
    and other Java statements that are executed when the method is invoked. Methods
    may also return a value to the caller. They always specify a return type, which
    can be a primitive type, a reference type, or the special `void`, which indicates
    no returned value. Methods may take arguments, which are values supplied by the
    caller of the method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a simple example of a method that takes arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the class `Bird` defines a method, `fly()`, that takes as
    arguments two integers: `x` and `y`. It returns a `double` type value as a result,
    using the `return` keyword.'
  prefs: []
  type: TYPE_NORMAL
- en: Our method has a fixed number of arguments (two); however, methods can have
    *variable-length argument lists*, which allow the method to specify that it can
    take any number of arguments and sort them out itself at runtime.^([3](ch05.html#id1104))
  prefs: []
  type: TYPE_NORMAL
- en: Local Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our `fly()` method declares a local variable called `distance`, which it uses
    to compute the distance flown. A local variable is temporary; it exists only within
    the scope (the block) of its method. Local variables are allocated when a method
    is invoked; they are normally destroyed when the method returns. They can’t be
    referenced from outside the method itself. If the method is executing concurrently
    in different threads, each thread has its own version of the method’s local variables.
    A method’s arguments also serve as local variables within the scope of the method;
    the only difference is that they are initialized by being passed in from the caller
    of the method.
  prefs: []
  type: TYPE_NORMAL
- en: An object created within a method and assigned to a local variable may or may
    not persist after the method has returned. As we’ll see in detail in [“Object
    Destruction”](#learnjava6-CHP-5-SECT-4), it depends on whether any references
    to the object remain. If an object is created, assigned to a local variable, and
    never used anywhere else, that object is no longer referenced when the local variable
    disappears from scope, so garbage collection removes the object. If, however,
    we assign the object to an instance variable of an object, pass it as an argument
    to another method, or pass it back as a return value, it may be saved by another
    variable holding its reference.
  prefs: []
  type: TYPE_NORMAL
- en: Shadowing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If a local variable or method argument and an instance variable have the same
    name, the local variable *shadows*, or hides, the name of the instance variable
    within the scope of the method. This might sound like an odd situation, but it
    happens fairly often when the instance variable has a common or obvious name.
    For example, we could add a `move` method to our `Apple` class. Our method will
    need a new coordinate telling it where to place the apple. An easy choice for
    the coordinate arguments would be `x` and `y`. But we already have instance variables
    of the same name that hold the current position of the apple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If the apple is currently at position (20, 40) and you call `moveTo(40, 50),`
    what do you think that `println()` statement will show? Inside `moveTo()`, the
    `x` and `y` names refer only to the method arguments with those names. The output
    would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If we can’t get to the `x` and `y` instance variables, how can we move the apple?
    Turns out Java understands shadowing and provides a mechanism for working around
    these situations.
  prefs: []
  type: TYPE_NORMAL
- en: The “this” reference
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can use the special reference `this` any time you need to refer explicitly
    to the current object or a member of the current object. Often you don’t need
    to use `this`, because the reference to the current object is implicit; such is
    the case when using unambiguously named instance variables inside a class. But
    you can use `this` to refer explicitly to instance variables in an object, even
    if they are shadowed. The following example shows how to use `this` to allow argument
    names that shadow instance variable names. This is a fairly common technique because
    it saves having to make up alternative names. Here’s how we could implement our
    `moveTo()` method with shadowed variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the expression `this.x` refers to the instance variable `x`
    and assigns it the value of the local variable `x`, which would otherwise hide
    its name. We do the same for `this.y` but add a little protection to make sure
    we don’t move the apple below our ground. Notice that `diameter` is not shadowed
    in this method. Since we don’t have a `diameter` argument in `moveTo()`, we don’t
    have to say `this.diameter` when we use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only reason we need to use `this` in the previous example is because we’ve
    used argument names that hide our instance variables, and we want to refer to
    the instance variables. You can also use the `this` reference any time you want
    to pass a reference to “the current” enclosing object to some other method, like
    we did for the graphical version of our “Hello Java” application in [“HelloJava2:
    The Sequel”](ch02.html#learnjava6-CHP-2-SECT-3).'
  prefs: []
  type: TYPE_NORMAL
- en: Static Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Static methods (sometimes called class methods), like static variables, belong
    to the class and not to individual instances of the class. What does this mean?
    Well, foremost, a *static method* lives outside of any particular instance. It
    can be invoked through the class name and dot operator, without any objects around.
    Because it is not bound to a particular object, a static method can only access
    other static members (static variables and other static methods) of the class.
    It can’t directly see any instance variables or call any instance methods, because
    to do so it would have to ask, “on which instance?” Static methods can be called
    from instances using the same syntax as instance methods, but the important thing
    is that they can also be used independently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `isTouching()` method uses a static method, `Math.sqrt()`, which is defined
    by the `java.lang.Math` class; we’ll explore this class in detail in [Chapter 8](ch08.html#learnjava6-CHP-8).
    For now, the important thing to note is that `Math` is the name of a class and
    not an instance of a `Math` object.^([4](ch05.html#id1121)) Because static methods
    can be invoked wherever the class name is available, class methods are closer
    to C-style functions. Static methods are particularly useful for utility methods
    that perform work that is useful either independently of instances or in working
    on instances. For example, in our `Apple` class, we could enumerate all of the
    available sizes as human-readable strings from the constants we created in [“Accessing
    Fields and Methods”](#learnjava6-CHP-5-SECT-1.2):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we’ve defined a static method, `getAppleSizes()`, that returns an array
    of strings containing apple size names. We make the method static because the
    list of sizes is the same regardless of what size any given instance of `Apple`
    might be. We can still use `getAppleSizes()` from within an instance of `Apple`
    if we want, just like an instance method. We could change the (nonstatic) `printDetails`
    method to print a size name rather than an exact diameter, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we can also call it from other classes, using the `Apple` class name
    with the dot notation. For example, the very first `PrintAppleDetails` class could
    use similar logic to print a summary statement using our static method and static
    variables, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we have our trusty instance of the `Apple` class, `a1`, but we don’t need
    `a1` to get the list of sizes. Notice that we load the list of nice names *before*
    `a1` even exists. But everything still works, as seen in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Static methods also play an important role in various design patterns, where
    you limit the use of the `new` operator for a class to one method—a static method
    called a *factory method*. We’ll talk more about object construction in [“Constructors”](#learnjava6-CHP-5-SECT-3.1).
    There’s no naming convention for factory methods, but it is common to see usage
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We won’t be writing any factory methods, but you’re likely to find them in the
    wild, especially when looking up questions on sites like Stack Overflow.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing Local Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unlike instance variables, which receive default values if we don’t provide
    an explicit one, local variables must be initialized before they can be used.
    You’ll get a compile-time error if you try to access a local variable without
    first assigning it a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that this doesn’t imply you always have to initialize local variables
    when you declare them, just that you must assign some value to them before the
    first time you reference them. More subtle possibilities arise when making assignments
    inside conditionals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `bar` is initialized only if `someCondition` is `true`. The
    compiler doesn’t let you make this wager, so it flags the use of `bar` after our
    `if` statement as an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could correct this situation in several ways. We could initialize the variable
    to a default value in advance or move the usage inside the conditional. We could
    also make sure the flow of control doesn’t reach the uninitialized variable through
    some other means, depending on what makes sense for our particular application.
    For example, we could simply make sure that we assign `bar` a value in both an
    `else` branch if `someCondition` is false. Or we could return from the method
    abruptly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In this case, either `someCondition` is true and `bar` is set to 42, or it is
    false and control returns from `myMethod()`. There’s no chance of reaching `bar`
    in an uninitialized state, so the compiler allows this use of `bar` after the
    conditional.
  prefs: []
  type: TYPE_NORMAL
- en: Why is Java so picky about local variables? One of the most common (and insidious)
    sources of errors in other languages, like C or C++, is forgetting to initialize
    local variables. Local variables in those languages start with seemingly random
    values and cause all kinds of frustration for the programmer. Java tries to help
    out and forces you to assign good, known values.
  prefs: []
  type: TYPE_NORMAL
- en: Argument Passing and References
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the beginning of [Chapter 4](ch04.html#learnjava6-CHP-4), we described the
    distinction between primitive types, which are passed by value (by copying), and
    objects, which are passed by reference. Now that you’ve got a better handle on
    methods in Java, let’s walk through an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This chunk of code calls `myMethod()`, passing it two arguments. The first argument,
    `i`, is passed by value; when the method is called, the value of `i` is copied
    into the method’s first parameter (a local variable) named `num`. If `myMethod()`
    changes the value of `num`, it changes only its local variable. Our `i` will not
    be affected.
  prefs: []
  type: TYPE_NORMAL
- en: In the same way, Java places a copy of the reference to `obj` into the argument
    `o` of `myMethod()`. But since it is a reference, both `obj` and `o` refer to
    the same object. Any changes made through either `o` or `obj` affect the actual
    object instance. If we change the value of, say, `o.size`, the change is visible
    both as `o.size` (inside `myMethod()`) and as `obj.size` (in the caller after
    `myMethod()` completes). However, if `myMethod()` reassigns the reference `o`
    to point to a different object, that assignment only affects its local variable
    reference. Assigning `o` to something else doesn’t affect the caller’s variable
    `obj`, which still refers to the original object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Passing references to methods gives us a taste of the other use for the `this`
    keyword we mentioned earlier. You can use `this` to pass a reference for the current
    object to some other object. Let’s look at a bit of code to see how this (no pun
    intended) works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Our example is contrived, of course, but the syntax is correct. Inside the `printMyDetails()`
    method, we call our old friend, `System.out.println()`. The argument we pass to
    `println()` is `this`, meaning we want the current element object printed. We’ll
    be working with more complex object relationships in later chapters, and we will
    often need access to the current instance. The `this` keyword gives us that access.
  prefs: []
  type: TYPE_NORMAL
- en: Wrappers for Primitive Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we touched on briefly in [“Primitive Types”](ch04.html#learnjava6-CHP-4-SECT-4.1),
    there is a schism in the Java world between class types (objects) and primitive
    types (numbers, characters, and Boolean values). Java accepts this trade-off for
    efficiency reasons. When you’re crunching numbers, you want your computations
    to be lightweight; having to use objects for primitive types complicates performance
    optimizations. It’s not common, but sometimes you need to store a primitive value
    as an object. For those occasions, Java supplies a standard wrapper class for
    each of the primitive types, as shown in [Table 5-1](#learnjava6-CHP-5-TABLE-1).
  prefs: []
  type: TYPE_NORMAL
- en: Table 5-1\. Primitive type wrappers
  prefs: []
  type: TYPE_NORMAL
- en: '| Primitive | Wrapper |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `void` | `java.lang.Void` |'
  prefs: []
  type: TYPE_TB
- en: '| `boolean` | `java.lang.Boolean` |'
  prefs: []
  type: TYPE_TB
- en: '| `char` | `java.lang.Character` |'
  prefs: []
  type: TYPE_TB
- en: '| `byte` | `java.lang.Byte` |'
  prefs: []
  type: TYPE_TB
- en: '| `short` | `java.lang.Short` |'
  prefs: []
  type: TYPE_TB
- en: '| `int` | `java.lang.Integer` |'
  prefs: []
  type: TYPE_TB
- en: '| `long` | `java.lang.Long` |'
  prefs: []
  type: TYPE_TB
- en: '| `float` | `java.lang.Float` |'
  prefs: []
  type: TYPE_TB
- en: '| `double` | `java.lang.Double` |'
  prefs: []
  type: TYPE_TB
- en: 'An instance of a wrapper class encapsulates a single value of its corresponding
    type. It’s an immutable object that serves as a container to hold the value and
    lets you retrieve it later. You can construct a wrapper object from a primitive
    value or from a `String` representation of the value. The following statements
    are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The numeric wrapper constructors throw a `NumberFormatException` when they encounter
    an error parsing a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of the numeric wrappers implements the `java.lang.Number` interface, which
    provides “value” methods to access its value in all the primitive forms. You can
    retrieve scalar values with the methods `doubleValue()`, `floatValue()`, `longValue()`,
    `intValue()`, `shortValue()`, and `byteValue()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This code is equivalent to casting the primitive `double` value to the various
    types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common need for these wrappers is when you want to pass a primitive
    value to a method that requires an object. For example, in [Chapter 7](ch07.html#learnjava6-CHP-7),
    we’ll look at Java collections, a sophisticated set of classes for dealing with
    object groups, such as lists, sets, and maps. Collections work only with object
    types, so primitives must be wrapped when stored in them. As we’ll see in the
    next section, Java makes this wrapping process transparent and automatic. For
    now, however, let’s do it ourselves. As we’ll see, a `List` is an extensible collection
    of `Object`s. We can use wrappers to hold simple numbers in a `List` (along with
    other objects):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have created an `Integer` wrapper object so that we can insert the
    number into the `List`, using the `add()` method, which accepts an object. Later,
    when we are extracting elements from the `List`, we can recover the `int` value
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Happily, Java can do much of this work automatically. Java calls the automatic
    wrapping and unwrapping of primitive types *autoboxing*. As we alluded to earlier,
    allowing Java to do this for us makes the code more concise and secure. The usage
    of the wrapper class is mostly hidden from us by the compiler, but it is still
    being used internally. Here’s one more example that includes extra type information
    (*generics* in computer language parlance) and uses autoboxing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Notice we don’t create any explicit instances of the `Integer` wrapper, although
    we do include that extra type information in angle brackets (`<Integer>`) when
    we declare our variable. We’ll see more of generics in [Chapter 7](ch07.html#learnjava6-CHP-7).
  prefs: []
  type: TYPE_NORMAL
- en: Method Overloading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Method overloading* is the ability to define multiple methods with the same
    name in a class; when the method is invoked, the compiler picks the correct one
    based on the arguments passed to the method. This implies that overloaded methods
    must have different numbers or types of arguments. (In [“Overriding methods”](#learnjava6-CHP-5-SECT-6.1.2),
    we’ll look at *method overriding*, which occurs when we declare methods with identical
    signatures in subclasses.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Method overloading (also called *ad hoc polymorphism*) is a powerful and useful
    feature. The idea is to create methods that act in the same way on different types
    of arguments. This creates the illusion that a single method can operate on many
    types of arguments. The `print()` method in the standard `PrintStream` class is
    a good example of method overloading in action. As you’ve probably deduced by
    now, you can print a string representation of just about anything using this expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The variable `out` is a reference to an object (a `PrintStream`) that defines
    nine different, “overloaded” versions of the `print()` method. The versions take
    arguments of the following types: `Object`, `String`, `char[]`, `char`, `int`,
    `long`, `float`, `double`, and `boolean`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: You can invoke the `print()` method with any of these types as an argument,
    and the value will be printed in an appropriate way. In a language without method
    overloading, this requires something more cumbersome, such as a uniquely named
    method for printing each type of object. In that case, it’s your responsibility
    to figure out what method to use for each data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java, `print()` has been overloaded to support two reference types: `Object`
    and `String`. What if we try to call `print()` with some other reference type?
    Say, a `Date` object? When there’s not an exact type match, the compiler searches
    for an acceptable, *assignable* match. Since `Date`, like all classes, is a subclass
    of `Object`, a `Date` object can be assigned to a variable of type `Object`. It’s
    therefore an acceptable match, and the compiler selects the `Object` version of
    the method.'
  prefs: []
  type: TYPE_NORMAL
- en: What if there’s more than one possible match? For example, what if we want to
    print the literal `"Hi there"`? That literal is assignable to either `String`
    (since it is a `String`) or to `Object`, the parent class of `String`. Here, the
    compiler decides which match is “better” and selects that method. In this case,
    it selects the `String` version.
  prefs: []
  type: TYPE_NORMAL
- en: The intuitive explanation for selecting the `String` version is that the `String`
    class is “closer” to the type of our literal `"Hi there"` in the inheritance hierarchy.
    It is a *more specific* match. A slightly more rigorous way of specifying it would
    be to say that a given method is more specific than another method if the argument
    types of the first method are all assignable to the argument types of the second
    method. In this case, the `String` method is more specific because type `String`
    is assignable to type `Object`. The reverse is not true.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re paying close attention, you may have noticed we said that the compiler
    resolves overloaded methods. Method overloading is not something that happens
    at runtime; this is an important distinction. Making this decision during compilation
    means that once the overloaded method is selected, the choice is fixed until the
    code is recompiled, even if the class containing the called method is later revised
    and an even more specific overloaded method is added.
  prefs: []
  type: TYPE_NORMAL
- en: This compile-time selection is in contrast to *overridden* methods, which are
    located at runtime and can be found even if they didn’t exist when the calling
    class was compiled. In practice, this distinction will not usually be relevant
    to you, as you will likely recompile all of the necessary classes at the same
    time. We’ll talk about method overriding later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Object Creation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Objects in Java are allocated on a system “heap” memory space. Unlike some other
    languages, however, we needn’t manage that memory ourselves. Java takes care of
    memory allocation and deallocation for you. Java explicitly allocates storage
    for an object when you create it with the `new` operator. More importantly, objects
    are removed by garbage collection when they’re no longer referenced.
  prefs: []
  type: TYPE_NORMAL
- en: Constructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Objects are allocated with the `new` operator using a *constructor*. A constructor
    is a special method with the same name as its class and no return type. It’s called
    when a new class instance is created, which gives the class an opportunity to
    set up the object for use. Constructors, like other methods, can accept arguments
    and can be overloaded. They are not, however, inherited like other methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In this snippet, the class `Date` has two constructors. The first takes no
    arguments; it’s known as the *default constructor*. Default constructors play
    a special role: if you don’t define any constructors for a class, the compiler
    will supply an empty default constructor for you. The default constructor is what
    gets called whenever you create an object by calling its constructor with no arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we have implemented the default constructor so that it sets the instance
    variable `day` by calling a hypothetical method, `currentDay()`, which presumably
    knows how to look up the current day. The second constructor takes a `String`
    argument. In this case, the `String` contains a date string that can be parsed
    to set the `day` variable. Given these constructors, we can create a `Date` object
    in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In each case, Java chooses the appropriate constructor at compile time based
    on the rules for overloaded method selection.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we later remove all references to an allocated object, it’ll be garbage-collected,
    as we’ll discuss shortly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Setting this reference to `null` means it’s no longer pointing to the `"Dec
    25, 2022"` date object. Setting the variable `christmas` to any other value would
    have the same effect. Unless another variable also refers to the original date
    object, the date is now inaccessible and can be garbage-collected. We’re not suggesting
    that you have to set references to `null` to get the values garbage-collected.
    Often this just happens naturally when local variables fall out of scope, but
    instance variables of objects live as long as the object itself lives (through
    references to it), and static variables live effectively forever.
  prefs: []
  type: TYPE_NORMAL
- en: 'A few more notes: you can declare constructors with the same visibility modifiers
    (`public`, `private`, or `protected`) as other methods, to control their accessibility.
    You can’t, however, make constructors `abstract`, `final`, or `synchronized`.
    We’ll talk in detail about `abstract`, `final`, and visibility modifiers later
    in this chapter, and we’ll cover `synchronized` in [Chapter 9](ch09.html#learnjava6-CHP-9).'
  prefs: []
  type: TYPE_NORMAL
- en: Working with Overloaded Constructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A constructor can refer to another constructor in the same class or the immediate
    superclass using special forms of the `this` and `super` references. We’ll discuss
    the first case here and return to that of the superclass constructor after we
    have talked more about creating subclasses (often referred to simply as subclassing)
    and inheritance. A constructor can invoke another overloaded constructor in its
    class using the self-referential method call `this()` with appropriate arguments
    to select the desired constructor. If a constructor calls another constructor,
    *it must do so as its first statement*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the class `Car` has two constructors. The first, more explicit
    one accepts arguments specifying the car’s model and its number of doors. The
    second constructor takes just the model as an argument and, in turn, calls the
    first constructor with a default value of four doors. The advantage of this approach
    is that you can have a single constructor do all the complicated setup work; other,
    more convenient constructors simply feed the appropriate arguments to that primary
    constructor.
  prefs: []
  type: TYPE_NORMAL
- en: The special call to `this()` must appear as the first statement in our delegating
    constructor. The syntax is restricted in this way because there’s a need to identify
    a clear chain of command when calling constructors. At the end of the chain, Java
    invokes the constructor of the superclass (if we don’t do it explicitly in our
    code) to ensure that inherited members are initialized properly before we proceed.
  prefs: []
  type: TYPE_NORMAL
- en: There’s also a point in the chain, just after invoking the constructor of the
    superclass, where the initializers of the current class’s instance variables are
    evaluated. Before that point, we can’t even reference the instance variables of
    our class. We’ll explain this situation again in complete detail after we have
    talked about inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, all you need to know is that you can invoke a second constructor (delegate
    to it) only as the first statement of your constructor. For example, the following
    code is illegal and causes a compile-time error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The simple model name constructor can’t do any additional setup before calling
    the more explicit constructor. It can’t even refer to an instance member for a
    constant value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The instance variable `defaultDoors` is not initialized until a later point
    in the chain of constructor calls setting up the object, so the compiler doesn’t
    let us access it yet. Fortunately, we can solve this particular problem by using
    a static variable instead of an instance variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The static members of a class are initialized when the class is first loaded
    into the virtual machine. The compiler can determine the value of these static
    members so it’s safe to access them in a constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Object Destruction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we’ve seen how to create objects, it’s time to talk about how to destroy
    them. If you’re accustomed to programming in C or C++, you’ve probably spent time
    hunting down *memory leaks* in your code. Programmers accidentally allow memory
    to leak by creating objects (which consume memory) and forgetting to destroy them
    (which returns the allocated memory) once the objects are no longer needed. Java
    takes care of object destruction for you; you don’t have to worry about traditional
    memory leaks, and you can concentrate on more important programming tasks.^([5](ch05.html#id1181))
  prefs: []
  type: TYPE_NORMAL
- en: Garbage Collection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Java uses a technique known as *garbage collection* to remove objects that are
    no longer needed. The garbage collector is Java’s Grim Reaper. It lingers in the
    background, stalking objects and awaiting their demise. It finds and watches them,
    periodically counting references to them to see when their time has come. When
    all references to an object are gone and it’s no longer accessible, the garbage-collection
    mechanism declares the object *unreachable* and reclaims its space back to the
    available pool of resources. An unreachable object is one that can no longer be
    found through any combination of “live” references in the running application.
  prefs: []
  type: TYPE_NORMAL
- en: Garbage collection uses a variety of algorithms; the Java virtual machine architecture
    doesn’t require a particular scheme. It’s worth noting, however, how some implementations
    of Java have accomplished this task. In the beginning, Java used a technique called
    “mark and sweep.” In this scheme, Java first walks through the tree of all accessible
    object references and marks them as alive. It then scans the heap, looking for
    identifiable objects that are *not* marked. Using this technique, Java can find
    objects on the heap because they are stored in a characteristic way and have a
    particular signature of bits in their handles that’s unlikely to be reproduced
    naturally. This kind of algorithm doesn’t become confused by the problem of cyclic
    references, in which objects can mutually reference each other and appear alive
    even when they are dead (Java handles this problem automatically). This scheme
    wasn’t the fastest method, however, and caused pauses in programs. Since then,
    implementations have become much more sophisticated.
  prefs: []
  type: TYPE_NORMAL
- en: Modern Java garbage collectors effectively run continuously without forcing
    any lengthy delay in execution of the Java application. Because they are part
    of a runtime system, they can also accomplish some things that could not be done
    statically. For instance, Java divides the memory heap into several areas for
    objects with different estimated life spans. Short-lived objects are placed on
    a special part of the heap, which drastically reduces the time required to recycle
    them. Objects that live longer can be moved to other, less volatile parts of the
    heap. In recent implementations, the garbage collector can even “tune” itself
    by adjusting the heap partition sizes based on the actual application performance.
    The improvement in Java’s garbage collection since the early releases has been
    remarkable and is one of the reasons that Java is now roughly equivalent in speed
    to many traditional languages that place the burden of memory management on the
    shoulders of the programmer.
  prefs: []
  type: TYPE_NORMAL
- en: In general, you do not have to concern yourself with the garbage-collection
    process. But one garbage-collection method can be useful for debugging. You can
    prompt the garbage collector to make a clean sweep explicitly by invoking the
    `System.gc()` method. This method is completely implementation dependent and may
    do nothing, but you can use it if you want some guarantee that Java has at least
    tried to clean up memory before you do an activity.
  prefs: []
  type: TYPE_NORMAL
- en: Packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even when we stick to simple examples, you may have noticed that solving problems
    in Java requires creating classes. For our game classes above, we have our apples
    and our trees and our playing field, to name just a few. For more complex applications
    or libraries, you can have hundreds or even thousands of classes. You need a way
    to organize things, and Java uses the notion of a *package* to accomplish this
    task. Let’s look at some examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall our second Hello World example in [Chapter 2](ch02.html#learnjava6-CHP-2).
    The first few lines in the file show us a lot of information about where the code
    lives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: We named the Java file *HelloJava.java* according to the main class (`HelloJava`)
    in that file. When we talk about organizing things that go in files, you might
    naturally think of using folders to organize those files in turn. That is essentially
    what Java does. In this example, we use the `package` keyword and assign a package
    name of `ch02.examples`. Packages map onto folder names much the way classes map
    onto filenames. From the directory where you installed the examples for this book,
    then, this class should be found in the file *ch02/examples/HelloJava.java*. Take
    a look back at [Figure 5-1](#learnjava6-CHP-5-FIG-1) where we have some classes
    grouped into their packages. If you were looking at the Java source code for the
    Swing components we used in `HelloJava`, for example, you would find a folder
    named *javax*, and under that, one named *swing*, and under that you would find
    files like *JFrame.java* and *JLabel.java*.
  prefs: []
  type: TYPE_NORMAL
- en: Each class belongs to exactly one package. Package names follow the same general
    rules as other Java identifiers and are all lowercase by convention. If you don’t
    specify a package, Java assigns your class to the “default” package. Using the
    default package is fine for one-off demos, but you should otherwise use `package`
    for your classes. The default package has several limitations—for example, a class
    in the default package cannot be used with *jshell*—and is not meant to be used
    beyond testing.
  prefs: []
  type: TYPE_NORMAL
- en: Importing Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of Java’s biggest strengths lies in the vast collection of supporting libraries
    available under both commercial and open source licensing. Need to export a PDF?
    There’s a library for that. Need to import a spreadsheet? There’s a library for
    that. Need to turn on that smart lightbulb in the basement from a web server in
    the cloud? There’s a library for that, too. If computers are doing some task or
    other, you will almost always find a Java library to help you write code to perform
    that task as well.
  prefs: []
  type: TYPE_NORMAL
- en: To use any of these wonderful libraries, you *import* them with the cleverly
    named `import` keyword. We used `import` with our `HelloJava` example so we could
    add the frame and label components from the Swing graphical library. You can import
    individual classes or entire packages. Let’s look at some examples.
  prefs: []
  type: TYPE_NORMAL
- en: Importing individual classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In programming, you’ll often hear the maxim that “less is more.” Less code
    is more maintainable. Less overhead means more throughput, and so on. (Although
    in pursuing this way of coding, we do want to remind you to follow another famous
    quote from no less a thinker than Einstein: “Everything should be made as simple
    as possible, but no simpler.”) If you need only one or two classes from an external
    package, you can import exactly those classes. This makes your code a little more
    readable—others know exactly what classes you’ll be using.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s reexamine that earlier snippet of `HelloJava`. We used a blanket import
    (more on that in the next section), but we could tighten things up a bit by importing
    just the classes we need, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This type of import setup is certainly more verbose, but again, it means anyone
    reading or compiling your code knows its exact dependencies. Many IDEs even have
    an “Optimize Imports” function that will automatically find those dependencies
    and list them individually. Once you get in the habit of listing and seeing these
    explicit imports, it is surprising how useful they become when orienting yourself
    in a new (or perhaps long-forgotten) class.
  prefs: []
  type: TYPE_NORMAL
- en: Importing entire packages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Of course, not every package lends itself to individual imports. That same
    Swing package, `javax.swing`, is a great example. If you are writing a graphical
    desktop application, you’ll almost certainly use Swing—and lots and lots of its
    components. You can import every class in the package using the syntax we glossed
    over earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The `*` is a sort of wildcard for class imports. This version of the `import`
    statement tells the compiler to have every class in the package ready to use.
    You’ll see this type of import quite often for many of the common Java packages,
    such as AWT, Swing, utilities, and I/O. Again, it works for any package, but where
    it makes sense to be more specific, you’ll gain some compile-time performance
    boosts and improve the readability of your code.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: While it might seem natural for a wildcard `import` to include both the classes
    of the named package as well as the classes from any subpackages, Java does not
    allow recursive imports. If you need some classes from `java.awt` and some more
    classes from `java.awt.event`, you must supply separate `import` lines for each
    package.
  prefs: []
  type: TYPE_NORMAL
- en: Skipping imports
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You have another option for using external classes from other packages—you
    can use their fully qualified names right in your code. For example, our `HelloJava`
    class used the `JFrame` and `JLabel` classes from the `javax.swing` package. We
    could import only the `JLabel` class if we wanted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This might seem overly verbose for one line where we create our frame, but in
    larger classes with already lengthy lists of imports, one-off usages can actually
    make your code more readable. Such a fully qualified entry often points to the
    sole use of this class within a file. If you were using that class many times,
    you would `import` it or its package. This type of full-name usage is never a
    requirement, but you will see it in the wild from time to time.
  prefs: []
  type: TYPE_NORMAL
- en: Custom Packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you continue learning Java and write more code and solve larger problems,
    you will undoubtedly start to collect a larger and larger number of classes. You
    can use packages to help organize that collection. You use the `package` keyword
    to declare a custom package. You then place the file with your class inside a
    folder structure corresponding to the package name. As a quick reminder, packages
    use all lowercase names (by convention) separated by periods, such as in our graphical
    interface package, `javax.swing`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another convention applied widely to package names is something called “reverse
    domain name” naming. Apart from the packages associated directly with Java, third-party
    libraries and other contributed code are usually organized using the domain name
    of the company or individual’s email address. For example, the Mozilla Foundation
    has contributed a variety of Java libraries to the open source community. Most
    of those libraries and utilities will be in packages starting with Mozilla’s domain,
    *mozilla.org*, in reverse order: `org.mozilla`. This reverse naming has the handy
    (and intended) side effect of keeping the folder structure at the top fairly small.
    It is not uncommon for good-sized projects to use libraries from only the `com`
    and `org` top-level domains.'
  prefs: []
  type: TYPE_NORMAL
- en: If you are building your own packages separate from any company or contract
    work, you can use your email address and reverse it, similar to company domain
    names. Another popular option for code distributed online is to use the domain
    of your hosting provider. GitHub, for example, hosts many, *many* Java projects
    for hobbyists and enthusiasts. You might create a package named `com.github.myawesomeproject`
    (where `myawesomeproject` would obviously be replaced by your actual project name).
    Be aware that repositories at sites like GitHub often allow names that are not
    valid in package names. You might have a repo named `my-awesome-project`, but
    dashes are not allowed in any portion of a package name. Often such illegal characters
    are simply omitted to create a valid name.
  prefs: []
  type: TYPE_NORMAL
- en: You may have already noticed we placed the various examples from this book in
    packages. While organizing classes *within* packages is a woolly topic with no
    great best practices available, we’ve taken an approach designed to make the examples
    easy to locate as you’re reading the book. For any complete examples in a chapter,
    you’ll see a package like `ch05.examples`. For the ongoing game example, we use
    a `game` subpackage. We put the end-of-chapter exercises in `ch05.exercises`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When you compile a packaged class, you need to tell the compiler where the actual
    file resides within the filesystem, so you use its path, with the package elements
    separated by your filesystem separator (typically `/` or `\`). When you run a
    packaged class, on the other hand, you specify its fully qualified, dot-separated
    name.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using an IDE, it will happily manage these package issues for you.
    Simply create and organize your classes and continue to identify the main class
    that kicks off your program.
  prefs: []
  type: TYPE_NORMAL
- en: Member Visibility and Access
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve talked a bit about the access modifiers you can use when declaring variables
    and methods. Making something `public` means anyone, anywhere, can see your variable
    or call your method. Making something `protected` means any subclass can access
    the variable, call the method, or override the method to provide some alternate
    functionality more appropriate to your subclass. The `private` modifier means
    the variable or method is available only within the class itself.
  prefs: []
  type: TYPE_NORMAL
- en: Packages affect `protected` members. In addition to being accessible by any
    subclass, such members are visible and can be overridden by other classes in the
    same package. Packages also come into play if you leave off the modifier altogether.
    Consider some example text components in the custom package `mytools.text`, as
    shown in [Figure 5-4](#learnjava6-CHP-5-FIG-4).
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 0504](assets/ljv6_0504.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-4\. Packages and class visibility
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The class `TextComponent` has no modifier. It has *default* visibility or “package
    private” visibility. This means that other classes *in the same package* can access
    the class, but any classes outside the package cannot. This can be very useful
    for implementation-specific classes or internal helpers. You can use the package
    private elements freely in building your code, but other programmers can use only
    your `public` and `protected` elements. [Figure 5-5](#learnjava6-CHP-5-FIG-5)
    shows more details, with both subclasses and external classes using variables
    and methods for a sample class.
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 0505](assets/ljv6_0505.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-5\. Packages and member visibility
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Notice that extending the `TextArea` class gives you access to the public `getText()`
    and `setText()` methods as well as the `protected` method `formatText()`. But
    `MyTextDisplay` (more on subclasses and `extends` shortly in [“Subclassing and
    Inheritance”](#learnjava6-CHP-5-SECT-6.1)) does not have access to the package-private
    variable `linecount`. Within the `mytools.text` package where we create the `TextEditor`
    class, however, we can get to `linecount` as well as those methods that are `public`
    or `protected`. Our internal storage for the content, `text`, remains private
    and unavailable to anyone other than the `TextArea` class itself.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 5-2](#learnjava6-CHP-5-TABLE-2) summarizes the levels of visibility
    available in Java; it runs generally from most to least restrictive. Methods and
    variables are always visible within a declaring class itself, so the table doesn’t
    address that scope.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 5-2\. Visibility modifiers
  prefs: []
  type: TYPE_NORMAL
- en: '| Modifier | Visibility outside the class |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `private` | None |'
  prefs: []
  type: TYPE_TB
- en: '| No modifier (default) | Classes in the package |'
  prefs: []
  type: TYPE_TB
- en: '| `protected` | Classes in package and subclasses inside or outside the package
    |'
  prefs: []
  type: TYPE_TB
- en: '| `public` | All classes |'
  prefs: []
  type: TYPE_TB
- en: Compiling with Packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You’ve already seen a few examples of using a fully qualified class name to
    compile a simple example. If you’re not using an IDE, you have other options available
    to you. For example, you may wish to compile all of the classes in a given package.
    If so, you can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that for commercial applications, you often see more complex package names
    that include multiple segments. As we mentioned earlier, a common practice is
    to reverse the internet domain name of your company. For example, this book from
    O’Reilly might more appropriately use a full package prefix such as `com.oreilly.learningjava6e`.
    Each chapter would be a subpackage under that prefix. Compiling and running classes
    in such packages is fairly straightforward, if a bit wordy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The *javac* command also understands basic class dependency. If your main class
    uses a few other classes in the same source hierarchy—even if they are not all
    in the same package—compiling that main class will “pick up” the other, dependent
    classes and compile them as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Beyond simple programs with a few classes in a single package, though, you
    really are more likely to rely on your IDE or a build management tool such as
    Gradle or Maven. Those tools are outside the scope of this book, but there are
    many references for them online. Maven in particular is popular for managing large
    projects with many dependencies. See [*Maven: The Definitive Guide*](https://oreil.ly/ya4DY)
    (O’Reilly) by Maven creator Jason Van Zyl and his team at Sonatype for a true
    exploration of the features and capabilities of this powerful tool.^([6](ch05.html#id1217))'
  prefs: []
  type: TYPE_NORMAL
- en: Advanced Class Design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You may recall from [“HelloJava2: The Sequel”](ch02.html#learnjava6-CHP-2-SECT-3)
    that we had two classes in the same file. That simplified the writing and compiling
    process but didn’t grant either class any special access to the other. As you
    start thinking about more complex problems, you will encounter cases where more
    advanced class design that does grant special access is not just handy but critical
    to writing maintainable code.'
  prefs: []
  type: TYPE_NORMAL
- en: Subclassing and Inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Classes in Java exist in a hierarchy. You can declare a class in Java as a
    *subclass* of another class using the `extends` keyword. A subclass *inherits*
    variables and methods from its *superclass* and can use them as if they were declared
    within the subclass itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: In this example, an object of type `Mammal` has both the instance variable `weight`
    and the method `eat()`. They are inherited from `Animal`.
  prefs: []
  type: TYPE_NORMAL
- en: A class can *extend* only one other class. To use the proper terminology, Java
    allows *single inheritance* of a class implementation. Later in this chapter,
    we’ll talk about interfaces, which take the place of *multiple inheritance* found
    in other languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'A subclass can be further subclassed. Normally, subclassing specializes or
    refines a class by adding variables and methods (you cannot remove or hide variables
    or methods by subclassing). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The `Cat` class is a type of `Mammal` that is ultimately a type of `Animal`.
    `Cat` objects inherit all the characteristics of `Mammal` objects and, in turn,
    `Animal` objects. `Cat` also provides additional behavior in the form of the `purr()`
    method and the `longHair` variable. We can denote the class relationship in a
    diagram, as shown in [Figure 5-6](#learnjava6-CHP-5-FIG-6).
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 0506](assets/ljv6_0506.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-6\. A class hierarchy
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'A subclass inherits all members of its superclass not designated as `private`.
    As we’ll discuss shortly, other levels of visibility affect which inherited members
    of the class can be seen from outside of the class and its subclasses, but at
    a minimum, a subclass always has the same set of visible members as its parent.
    For this reason, the type of a subclass can be considered a *subtype* of its parent,
    and instances of the subtype can be used anywhere instances of the supertype are
    allowed. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The `Cat` instance `simon` in this example can be assigned to the `Animal` type
    variable `creature` because `Cat` is a subtype of `Animal`. Similarly, any method
    accepting an `Animal` object would accept an instance of a `Cat` or any `Mammal`
    type as well. This is an important aspect of polymorphism in an object-oriented
    language such as Java. We’ll see how it can be used to refine a class’s behavior,
    as well as add new capabilities to it.
  prefs: []
  type: TYPE_NORMAL
- en: Shadowed variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have seen that a local variable of the same name as an instance variable
    *shadows* (hides) the instance variable. Similarly, an instance variable in a
    subclass can shadow an instance variable of the same name in its parent class,
    as shown in [Figure 5-7](#learnjava6-CHP-5-FIG-7).
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 0507](assets/ljv6_0507.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-7\. The scope of shadowed variables
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The variable `weight` is declared in three places: as a local variable in the
    method `foodConsumption()` of the class `Mammal`, as an instance variable of the
    class `Mammal` itself, and as an instance variable of the class `Animal`. The
    actual variable you would reference in the code would depend on the scope in which
    you are working and how you qualify the reference to it.'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, all variables were of the same type. A slightly more
    plausible use of shadowed variables would involve changing their types. We could,
    for example, shadow an `int` variable with a `double` variable in a subclass that
    needs decimal values instead of integer values. We can do this without changing
    the existing code because, as its name suggests, when we shadow variables, we
    don’t replace them but rather mask them instead. Both variables still exist; methods
    of the superclass see the original variable, and methods of the subclass see the
    new version. What variables the various methods see is determined at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we shadow the instance variable `sum` to change its type from
    `int` to `double`.^([7](ch05.html#id1222)) Methods defined in the class `IntegerCalculator`
    see the integer variable `sum`, while methods defined in `DecimalCalculator` see
    the floating-point variable `sum`. However, both variables actually exist for
    a given instance of `DecimalCalculator`, and they can have independent values.
    In fact, any methods that `DecimalCalculator` inherits from `IntegerCalculator`
    actually see the integer variable `sum`. If that sounds confusing—it certainly
    can be. Shadowing is something you should avoid when possible. But it isn’t always
    possible to avoid, so we want to make sure you have seen some examples, albeit
    contrived ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because both variables exist in `DecimalCalculator`, we need a way to reference
    the variable inherited from `IntegerCalculator`. We do that using the `super`
    keyword as a qualifier on the reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Inside of `DecimalCalculator`, the `super` keyword used in this manner selects
    the `sum` variable defined in the superclass. We’ll explain the use of `super`
    more fully in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another important point about shadowed variables has to do with how they work
    when we refer to an object by way of a less derived type (a parent type). For
    example, we can refer to a `DecimalCalculator` object as an `IntegerCalculator`
    by using it via a variable of type `IntegerCalculator`. If we do so and then access
    the variable `sum`, we get the integer variable, not the decimal one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The same would be true if we accessed the object using an explicit cast to the
    `IntegerCalculator` type or when passing an instance into a method that accepts
    that parent type.
  prefs: []
  type: TYPE_NORMAL
- en: To reiterate, the usefulness of shadowed variables is limited. It’s much better
    to abstract the use of variables like this in other ways than to use tricky scoping
    rules. However, it’s important to understand the concepts here before we talk
    about doing the same thing with methods. We’ll see a different and more dynamic
    type of behavior when methods shadow other methods, or to use the correct terminology,
    *override* other methods. Overriding methods in a subclass is quite common and
    can be very powerful.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have seen that we can declare overloaded methods (methods with the same name
    but a different number or type of arguments) within a class. Overloaded method
    selection works in the way we described on all methods available to a class, including
    inherited ones. This means that a subclass can define additional overloaded methods
    that add to the overloaded methods provided by a superclass.
  prefs: []
  type: TYPE_NORMAL
- en: A subclass can do more than that; it can define a method that has exactly the
    *same* method signature (name and argument types) as a method in its superclass.
    In that case, the method in the subclass *overrides* the method in the superclass
    and effectively replaces its implementation, as shown in [Figure 5-8](#learnjava6-CHP-5-FIG-8).
    Overriding methods to change the behavior of objects is called *subtype polymorphism*.
    It’s the usage most people think of when they talk about the power of object-oriented
    languages.
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 0508](assets/ljv6_0508.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-8\. Method overriding
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In [Figure 5-8](#learnjava6-CHP-5-FIG-8), `Mammal` overrides the `reproduce()`
    method of `Animal`, perhaps to specialize the method for the behavior of mammals
    giving birth to live young.^([8](ch05.html#id1233)) The `Cat` object’s sleeping
    behavior is also overridden to be different from that of a general `Animal`, perhaps
    to accommodate catnaps. The `Cat` class also adds the more unique behaviors of
    purring and hunting mice.
  prefs: []
  type: TYPE_NORMAL
- en: From what you’ve seen so far, overridden methods probably look like they shadow
    methods in superclasses, just as variables do. But overridden methods are actually
    more powerful than that. When there are multiple implementations of a method in
    the inheritance hierarchy of an object, the one in the “most derived” class (the
    furthest down the hierarchy) always overrides the others, even if we refer to
    the object through a reference of one of the superclass types.^([9](ch05.html#id1234))
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we have a `Cat` instance assigned to a variable of the more
    general type `Animal`, and we call its `sleep()` method, we still get the `sleep()`
    method implemented in the `Cat` class, not the one in `Animal`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: In other words, for purposes of behavior (invoking methods), a `Cat` acts like
    a `Cat`, regardless of whether you refer to it as such. You might remember that
    accessing a shadowed variable through our `Animal` variable `creature` would find
    that variable in the `Animal` class, not the `Cat` class. However, because methods
    are located *dynamically*, searching subclasses first, the runtime will invoke
    the appropriate method in the `Cat` class, even though we are treating it more
    generally as an `Animal` object. This means that the *behavior* of objects is
    dynamic. We can deal with specialized objects as if they were more general types
    and still take advantage of their specialized implementations of behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract Classes and Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes you don’t have a good default behavior for a method. Think about
    how animals communicate. Dogs bark. Cats meow. Cows moo. There really is no standard
    sound. In Java, you can create an *abstract* method that defines exactly what
    a method should look like, without specifying any particular behavior. You use
    the `abstract` modifier when declaring the method. And rather than providing a
    body, you simply end the definition with a semicolon. Consider a `makeSound()`
    method for our animals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that our method to make a sound has a complete signature (recall [“Running
    Java Applications”](ch03.html#learnjava6-CHP-3-SECT-3)). It is `void` (it has
    no return value), and it takes one argument of type `int`. But it has no body.
    This type of method is explicitly designed to be overridden. You cannot call an
    abstract method; you’ll get a compile-time error. You must create a new subclass
    that provides the logic for the abstract method before you can use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: With an instance of `Cat`, we can now call the `makeSound()` method and the
    compiler knows what to do. But because `Animal` now contains an abstract method,
    we can’t create an instance of that class. To use `Animal` we have to create a
    subclass and fill out `makeSound()` like we did with our `Cat`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, if we do include an abstract method in our class, we also have to
    declare the class itself as abstract. Our snippet of `Animal` above would not
    compile. We use the same `abstract` keyword for the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: This declaration tells the compiler (and other developers) that you designed
    this class to be part of a larger program. You expect (actually, require) subclasses
    to extend your abstract class and fill in any missing details. Those subclasses,
    in turn, can be instantiated and can do real work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Abstract classes can still contain typical, complete-with-body methods, too.
    In the case of `Animal`, for example, we could add some helper methods for the
    animal’s weight:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: This is common and a good design practice. Your `Animal` class contains as much
    of the basic, shared information and behavior as possible. But for things that
    are not shared, you create a subclass with the desired traits and actions.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Java expands on the concept of abstract methods with interfaces. It’s often
    desirable to specify a group of abstract methods defining some behavior for an
    object without tying it to any implementation at all. In Java, this is called
    an *interface*. An interface defines a set of methods that a class must implement.
    A class in Java can declare that it *implements* an interface if it implements
    the required methods. Unlike extending an abstract class, a class implementing
    an interface doesn’t have to inherit from any particular part of the inheritance
    hierarchy or use a particular implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces are kind of like Scouting merit badges. A scout who has learned to
    build a birdhouse can walk around wearing a cloth patch or sash with a picture
    of one. This says to the world, “I know how to build a birdhouse.” Similarly,
    an interface is a list of methods that define some set of behavior for an object.
    Any class that implements each method listed in the interface can declare at compile
    time that it implements the interface and wear, as its merit badge, an extra type—the
    interface’s type.
  prefs: []
  type: TYPE_NORMAL
- en: '*Interface types* act like class types. You can declare variables to be of
    an interface type, you can declare arguments of methods to accept interface types,
    and you can specify that the return type of a method is an interface type. In
    each case, you’re saying that any object that implements the interface (i.e.,
    wears the right merit badge) can fill that role. In this sense, interfaces are
    orthogonal to the class hierarchy. They cut across the boundaries of what kind
    of object an item *is* and deal with it only in terms of what it can *do*. You
    can implement as many interfaces as you need for any given class. Interfaces in
    Java replace much of the need for multiple inheritance in other languages (and
    all the messy complications that come from true multiple inheritance).'
  prefs: []
  type: TYPE_NORMAL
- en: 'An interface looks, essentially, like a purely `abstract` class (a class with
    *only* `abstract` methods). You define an interface with the `interface` keyword
    and list its methods with no bodies, just prototypes (signatures):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The previous example defines an interface called `Driveable` with four methods.
    It’s acceptable, but not necessary, to declare the methods in an interface with
    the `abstract` modifier; we haven’t done that here. More importantly, the methods
    of an interface are always considered `public`, and you can optionally declare
    them as so. Why public? Well, the user of the interface wouldn’t necessarily be
    able to see them otherwise, and interfaces are generally intended to describe
    the behavior of an object, not its implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Interfaces define capabilities, so it’s common to name interfaces after their
    capabilities. `Driveable`, `Runnable`, and `Updateable` are good interface names.
    Any class that implements all the methods can then declare that it implements
    the interface by using a special `implements` clause in its class definition.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Here, the class `Automobile` implements the methods of the `Driveable` interface
    and declares itself a type of `Driveable` using the `implements` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: As shown in [Figure 5-9](#learnjava6-CHP-5-FIG-9), another class, such as `Lawnmower`,
    can also implement the `Driveable` interface. The figure illustrates the `Driveable`
    interface being implemented by two different classes. While it’s possible that
    both `Automobile` and `Lawnmower` could derive from some primitive kind of vehicle,
    they don’t have to in this scenario.
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 0509](assets/ljv6_0509.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-9\. Implementing the `Driveable` interface
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'After declaring the interface, we have a new type, `Driveable`. We can declare
    variables of type `Driveable` and assign them any instance of a `Driveable` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Both `Automobile` and `Lawnmower` implement `Driveable`, so they can be considered
    interchangeable objects of that type.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned earlier, interfaces play a critical role in Java’s power and
    popularity. We will be using them throughout the remaining chapters. If they don’t
    quite make sense, keep reading and working on the code exercises. You’ll get much
    more practice with them. Practice doesn’t always make perfect, but it definitely
    does make something less weird and opaque.
  prefs: []
  type: TYPE_NORMAL
- en: Inner Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All of the classes we’ve seen so far in this book have been *top-level*, “freestanding”
    classes declared at the file and package level. But classes in Java can actually
    be declared at any level of scope, within any set of curly braces—in other words,
    almost anywhere that you could put any other Java statement. These *inner classes*
    belong to another class or method as a variable would and may have their visibility
    limited to its scope in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: Inner classes are a useful and aesthetically pleasing facility for structuring
    code. Their cousins, *anonymous inner classes*, are an even more powerful shorthand
    that make it seem as if you can create new kinds of objects dynamically within
    Java’s statically typed environment. In Java, anonymous inner classes play part
    of the role of *closures* in other languages, giving the effect of handling state
    and behavior independently of classes. (You can also use *lambdas* in many places
    where inner or anonymous inner classes work. Lambdas encapsulate bits of logic
    and are common in many functional languages and LISPs. We’ll look at them in much
    more detail in [Chapter 11](ch11.html#learnjava6-CHP-11).)
  prefs: []
  type: TYPE_NORMAL
- en: However, as we delve into their inner workings, we’ll see that inner classes
    are not quite as aesthetically pleasing or dynamic as they seem. Inner classes
    are pure syntactic sugar; the Java runtime does not support them. Instead, the
    compiler maps the code of an inner class to a cleverly named regular class. As
    a programmer, you may never need to know this; you can simply rely on inner classes
    like any other language construct. However, you should know a little about how
    they work to better understand the compiled code and to watch for a few potential
    side effects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inner classes are essentially nested classes. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the class `Brain` is an inner class: it is a class declared inside the
    scope of the `Animal` class. Although the details of what that means require a
    bit of explanation, we’ll start by saying that Java tries to make the meaning,
    as much as possible, the same as for the other members (methods and variables)
    living at that level of scope. For example, let’s add a method to the `Animal`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The inner class `Brain`, the method `performBehavior()`, and the `weight` variable
    are within the scope of `Animal`. Therefore, anywhere within `Animal`, we can
    refer to `Brain`, `performBehavior()`, and `weight` directly, by name. Within
    `Animal`, we can call the constructor for `Brain` (`new Brain()`) to get a `Brain`
    object or invoke `performBehavior()` to carry out that method’s function. But
    none of these elements are generally accessible outside of the class `Animal`
    without some additional qualification.
  prefs: []
  type: TYPE_NORMAL
- en: Within the body of the inner `Brain` class and the body of the `performBehavior()`
    method, we have direct access to the `weight` variable as well as all the other
    methods and variables of the `Animal` class. So, just as the `performBehavior()`
    method could work with the `Brain` class and create instances of `Brain`, methods
    within the `Brain` class can invoke the `performBehavior()` method of `Animal`
    or work with the `weight` variable. The `Brain` class “sees” all of the methods
    and variables of the `Animal` class directly in its scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'A brain’s access to the variables and methods of `Animal` has important consequences.
    From within `Brain`, we can invoke the method `performBehavior()`; that is, from
    within an instance of `Brain`, we can invoke the `performBehavior()` method of
    an instance of `Animal`. Well, which instance of `Animal`? If we have several
    `Animal` objects around (say, a few `Cat`s and `Dog`s), we need to know whose
    `performBehavior()` method we are calling. What does it mean for a class definition
    to be “inside” another class definition? The answer is that a `Brain` object always
    lives within a single instance of `Animal`: the one that it was told about when
    it was created. We’ll call the object that contains any instance of `Brain` its
    *enclosing instance*.'
  prefs: []
  type: TYPE_NORMAL
- en: A `Brain` object cannot live outside of an enclosing instance of an `Animal`
    object. Anywhere you see an instance of `Brain`, it will be tethered to an instance
    of `Animal`. Although it is possible to construct a `Brain` object from elsewhere
    (perhaps another class), `Brain` always requires an enclosing instance of `Animal`
    to “hold” it. If you ever do find a `Brain` of the `Animal` class, it will still
    be explicitly associated with `Animal` as the `Animal.Brain` class. Just as with
    the `performBehavior()` method, modifiers can be applied to restrict its visibility.
    All of the usual visibility modifiers apply, and inner classes can also be declared
    `static`, as we’ll discuss in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous Inner Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we get to the best part. As a general rule, the more deeply encapsulated
    and limited in scope our classes are, the more freedom we have in naming them.
    We saw this in our earlier iterator example. This is not just a purely aesthetic
    issue. Naming is an important part of writing readable, maintainable code. Generally,
    use the most concise, meaningful names possible. As a corollary, avoid doling
    out names for temporary objects that are going to be used only once.
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous inner classes are an extension of the syntax of the `new` operation.
    When you create an anonymous inner class, you combine a class declaration with
    the allocation of an instance of that class, effectively creating a “one-time
    only” class and an instance in one operation. After the `new` keyword, you specify
    either the name of a class or an interface, followed by a class body. The class
    body becomes an inner class. It either extends the specified class or, in the
    case of an interface, is expected to implement the interface. A single instance
    of the class is created and returned as the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we could revisit the graphical application from [“HelloJava2:
    The Sequel”](ch02.html#learnjava6-CHP-2-SECT-3). As you might recall, that app
    creates a `HelloComponent2` that extends `JComponent` and implements the `MouseMotionListener`
    interface. (Does that example make a little more sense now?) We never expect `HelloComponent2`
    to respond to mouse motion events coming from other components. It might make
    more sense to create an anonymous inner class specifically to move our “Hello”
    label around.'
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, since `HelloComponent2` is really meant only for use by our demo, we
    could *refactor* (a common developer process to optimize or improve code that
    is already working) that separate class into an inner class. Now that we know
    a little more about constructors and inheritance, we could also make our class
    an extension of `JFrame` rather than building a frame inside our `main()` method.
    And to put a little icing on this newly refactored cake, we can move our mouse
    listener code into an anonymous inner class devoted to our custom component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s our `HelloJava3` with these nifty refactorings in place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Try compiling and running this example. It should behave exactly like the original
    `HelloJava2` application. The real difference is how we have organized the classes
    and who can access them (and the variables and methods inside them). `HelloJava3`
    probably looks a little cumbersome compared to `HelloJava2`, and it is verbose
    for such a small demo.
  prefs: []
  type: TYPE_NORMAL
- en: The power of inner classes and interfaces will start to shine as you develop
    more complex applications. Practicing with the structure and rules of these features
    will help you write more maintainable code in the long run.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing Content and Planning for Failure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Classes are the single most important idea in Java. They form the core of every
    executable program, portable library, or helper. We looked at the contents of
    classes and how classes relate to each other in a larger project. We know more
    about how to create and destroy objects based on the classes we write. And we’ve
    seen how inner classes (and anonymous inner classes) can help us write more maintainable
    code. We’ll be seeing more of these inner classes as we get into deeper topics
    such as threads in [Chapter 9](ch09.html#learnjava6-CHP-9) and Swing in [Chapter 12](ch12.html#learnjava6-CHP-12).
  prefs: []
  type: TYPE_NORMAL
- en: 'As you build your classes, here are a few guidelines to keep in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: Hide as much of your implementation as possible
  prefs: []
  type: TYPE_NORMAL
- en: Never expose more of the internals of an object than you need to. This is key
    to building maintainable, reusable code. Avoid using public variables in your
    objects, with the notable exception of constants. Instead, define *accessor* methods
    to set and return values. This is useful even if they are simple types—think of
    methods like `getWeight()` and `setWeight()`. You’ll be able to modify and extend
    your objects’ behavior down the road without breaking other classes that rely
    on them.
  prefs: []
  type: TYPE_NORMAL
- en: Use composition instead of inheritance
  prefs: []
  type: TYPE_NORMAL
- en: Specialize objects only when you must. When you use an object in its existing
    form, as a piece of a new object, you are *composing* objects. When you change
    or refine the behavior of an object (by subclassing), you are using *inheritance*.
    Try to reuse objects by composition rather than inheritance whenever possible.
    When you compose objects, you are taking full advantage of existing tools. Inheritance
    involves breaking down the encapsulation of an object, so do it only when there’s
    a real advantage. Ask yourself if you really need to inherit the whole class (do
    you want it to be a “kind” of that object?) or if you can just include an instance
    of that class in your own class and delegate some work to that included instance.
  prefs: []
  type: TYPE_NORMAL
- en: Minimize relationships between objects and try to organize related objects in
    packages
  prefs: []
  type: TYPE_NORMAL
- en: Java packages (recall [Figure 5-1](#learnjava6-CHP-5-FIG-1)) can also hide classes
    that are not of general interest. Expose only classes that you intend other people
    to use. The more loosely coupled your objects, the easier it will be to reuse
    them later.
  prefs: []
  type: TYPE_NORMAL
- en: We can apply these principles even on small projects. The *ch05/examples* folder
    contains simple versions of the classes and interfaces we’ll use to create our
    apple tossing game. Take a moment to see how the `Apple`, `Tree`, and `Physicist`
    classes implement the `GamePiece` interface—like the `draw()` method every class
    includes. Notice how `Field` extends `JComponent` and how the main game class,
    `AppleToss`, extends `JFrame`. You can see these simple pieces playing together
    in [Figure 5-10](#learnjava6-CHP-5-FIG-10).
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 0510](assets/ljv6_0510.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-10\. Our very first game classes in action
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The final code exercise for this chapter will help you get started. Look over
    the comments in the classes. Try tweaking a few things. Add another tree. More
    play is always good. We’ll be building on these classes throughout the remaining
    chapters, so getting comfortable with how they fit together will make it easier.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of how you organize the members in your classes, the classes in your
    packages, or the packages in your project, you’ll have to contend with errors.
    Some will be simple syntax errors you’ll fix in your editor. Other errors are
    more interesting and may crop up only while your program is actually running.
    The next chapter will cover Java’s notion of these problems and help you handle
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Review Questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What is the primary organizing unit in Java?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What operator do you use to create an object (or instance) from a class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Java does not support classic multiple inheritance. What mechanisms does Java
    provide as alternatives?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you organize multiple, related classes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you include classes from other packages for use in your own code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What do you call a class defined inside the scope of another class? What are
    some features that make such a class useful in some circumstances?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What do you call a method designed to be overridden that has a name, return
    type, and argument list, but no body?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an overloaded method?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you want to make sure no other class can use a variable you have defined,
    what access modifier should you use?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Code Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For your first coding practice, create a small zoo of communicative creatures.
    The *ch05/exercises/Zoo.java* file contains a complete outline for creating a
    few animals and having them “speak” using inner classes. Start by filling in the
    `speak()` method of the included `Gibbon` class using the completed `Lion` inner
    class as an example. When you compile and run your `Zoo`, you should see output
    like this (with your own animal noises, of course):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now add your own animal to the zoo. Create a new inner class similar to `Lion`.
    Fill in the appropriate sound for your animal, and add them to the output section
    of the `listen()` method. Your new output will look something like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let’s clean up that `listen()` method. We currently use separate `print()` and
    `println()` methods for each animal. If we add another animal (or several), that
    will require copying and pasting and tweaking the output lines—tasks that can
    introduce errors. Add another abstract method to `Animal` called `getSpecies()`.
    In the subclasses, this method should return the name of the animal as a `String`,
    such as “lion” or “seal” from the examples above.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With that method in place, refactor the output section to put your animals in
    a small array, and then use a loop to produce the output. (Feel free to edit your
    existing `Zoo` class. Our solution is in a new class, `Zoo2`, so that you can
    look over the solution to this problem as well as the solution to the previous
    exercise.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Run the apple tossing game. Compile and run the `ch05.exercises.game.AppleToss`
    class in the *ch05/exercises/game* folder using the steps discussed earlier in
    [“Custom Packages”](#learnjava6-CHP-5-SECT-5.2).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Advanced Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For a more advanced challenge, let’s expand our apple tossing game by creating
    a new type of obstacle. Use the `Tree` class as a template and create a `Hedge`
    class. You can draw your hedge as a green rectangle. To draw a rectangle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add a hedge to your field. The final game should look something like [Figure 5-11](#learnjava6-CHP-5-FIG-hedges).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![ljv6 0511](assets/ljv6_0511.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 5-11\. Our new hedge obstacle on the field
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: We will continue to expand this game throughout the book, but feel free to do
    some of your own expanding now. Play around with drawing other shapes or change
    the colors of the current elements. The [online documentation](https://oreil.ly/_dhQy)
    for the `Graphics` class will be helpful.
  prefs: []
  type: TYPE_NORMAL
- en: '^([1](ch05.html#id1063-marker)) Once you have some experience with basic object-oriented
    concepts, you might want to look at *Design Patterns: Elements of Reusable Object-Oriented
    Software* by Erich Gamma et al. (Addison-Wesley). This book catalogs useful object-oriented
    designs that have been refined over the years. Many of these patterns appear in
    the design of the Java APIs.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch05.html#id1073-marker)) The `char` also gets a 0 but usually expressed
    as the null character, `\0`. A `boolean` variable gets the default of `false`,
    and reference types get the default of `null`.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch05.html#id1104-marker)) We don’t go into the details of such argument
    lists, but if you’re curious and would like to do a little reading on your own,
    search online for the programmer-speak keyword “varargs.”
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch05.html#id1121-marker)) It turns out the `Math` class cannot be instantiated
    at all. It contains only static methods. Trying to call `new Math()` would result
    in a compiler error.
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](ch05.html#id1181-marker)) It’s still possible to write code in Java that
    holds on to objects forever (by accident, we’re sure), consuming more and more
    memory. This isn’t really a leak as much as it is hoarding. Such hoarding in Java
    is usually easier to track down than a leak in C.
  prefs: []
  type: TYPE_NORMAL
- en: ^([6](ch05.html#id1217-marker)) Maven sufficiently changed the landscape for
    dependency management in Java and even other JVM-based languages so you can now
    find tools such as [Gradle](https://gradle.org), which were based on Maven’s success.
  prefs: []
  type: TYPE_NORMAL
- en: '^([7](ch05.html#id1222-marker)) Note that a better way to design our calculators
    would be to have an abstract `Calculator` class with two separate subclasses:
    `IntegerCalculator` and `DecimalCalculator`.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([8](ch05.html#id1233-marker)) The platypus is a highly unusual egg-laying
    mammal. We could override the `reproduce()` behavior again for `Platypus` in its
    own subclass of `Mammal`.
  prefs: []
  type: TYPE_NORMAL
- en: ^([9](ch05.html#id1234-marker)) An overridden method in Java acts like a `virtual`
    method in C++.
  prefs: []
  type: TYPE_NORMAL
