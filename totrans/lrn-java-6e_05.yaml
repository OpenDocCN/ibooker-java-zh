- en: Chapter 5\. Objects in Java
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章\. Java 中的对象
- en: In this chapter, we get to the heart of Java and explore its object-oriented
    aspects. The term *object-oriented design* refers to the art of decomposing an
    application into some number of *objects*, which are self-contained application
    components that work together. The goal is to break your problem down into smaller
    problems that are simpler and easier to handle and maintain. Object-based designs
    have proven themselves over the years, and object-oriented languages such as Java
    provide a strong foundation for writing applications—from the very small to the
    very large. Java was designed from the ground up to be an object-oriented language,
    and all of the Java APIs and libraries are built around solid object-based design
    patterns.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了 Java 的面向对象的特性。术语*面向对象设计*指的是将应用程序分解为一些*对象*的艺术，这些对象是自包含的应用程序组件，彼此协作。目标是将您的问题分解为更简单、更易处理和维护的小问题。多年来，基于对象的设计已经证明其效果，而像
    Java 这样的面向对象语言为编写从非常小到非常大的应用程序提供了坚实的基础。Java 是从头开始设计为一种面向对象的语言，所有 Java API 和库都围绕着稳固的基于对象的设计模式构建。
- en: An object design *methodology* is a system or a set of rules created to help
    you break down your application into objects. Often this means mapping real-world
    entities and concepts (sometimes called the *problem domain*) into application
    components. Various methodologies attempt to help you factor your application
    into a good set of reusable objects. This is good in principle, but the problem
    is that good object-oriented design is still more art than science. While you
    can learn from off-the-shelf design methodologies, none of them will help you
    in all situations. The truth is that there is no substitute for experience.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 对象设计的*方法论*是一个系统或一组规则，旨在帮助您将应用程序分解为对象。通常这意味着将现实世界的实体和概念（有时称为*问题域*）映射到应用程序组件中。各种方法论尝试帮助您将应用程序因子化为一组良好的可重用对象。从原则上讲，这是有益的，但问题在于良好的面向对象设计仍然更多地是艺术而不是科学。虽然您可以从现成的设计方法中学习，但没有一种方法适用于所有情况。事实上，经验无可替代。
- en: We won’t try to push you into a particular methodology here; there are shelves
    full of books to do that.^([1](ch05.html#id1063)) Instead, we’ll provide some
    common-sense hints along the way as you get started.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在这里试图强行推荐某种方法论；有很多书可以做到这一点。^([1](ch05.html#id1063)) 相反，我们会在你开始的过程中提供一些常识性的提示。
- en: Classes
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类
- en: Classes are the building blocks of a Java application. A *class* can contain
    methods (functions), variables, initialization code, and, as we’ll discuss later,
    other classes. Separate classes that describe individual parts of a more complex
    idea are often bundled in *packages*, which help you organize larger projects.
    (Every class belongs to some package, even the simple examples we’ve seen so far.)
    An *interface* can describe some specific commonalities between otherwise disparate
    classes. Classes can be related to each other by extension or to interfaces by
    implementation. [Figure 5-1](#learnjava6-CHP-5-FIG-1) illustrates the ideas in
    this very dense paragraph.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 类是 Java 应用程序的构建块。*类* 可以包含方法（函数）、变量、初始化代码，以及稍后我们将讨论的其他类（这些类通常被打包在*包*中，帮助你组织更大的项目。即使是我们到目前为止看到的简单示例中，每个类也属于某个包。*接口*
    可以描述在其他不同的类之间存在的某些共同点。类可以通过扩展彼此相关联，通过实现接口与接口相关联。[图 5-1](#learnjava6-CHP-5-FIG-1)展示了这段非常密集的段落中的思想。
- en: '![ljv6 0501](assets/ljv6_0501.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0501](assets/ljv6_0501.png)'
- en: Figure 5-1\. Class, interface, and package overview
  id: totrans-7
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-1\. 类、接口和包概述
- en: '`Object` (in the upper-left corner) is the foundational class at the heart
    of every other class in Java. It is part of the core Java package, `java.lang`.
    Java also has a package for its graphical UI elements called `javax.swing`. Inside
    that package, the `JComponent` class defines all of the low-level, common properties
    of graphical things, like frames and buttons and canvases. The `JLabel` class,
    for example, *extends* the `JComponent` class. That means `JLabel` inherits details
    from `JComponent` but adds things specific to labels. You might have noticed that
    `JComponent` itself extends from `Object`, or at least, it eventually extends
    back to `Object`. For brevity’s sake, we have left out the intermediate classes
    and packages in between.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object`（在左上角）是Java中每个其他类的基础类。它是核心Java包`java.lang`的一部分。Java还有一个用于其图形用户界面元素的包`javax.swing`。在该包内，`JComponent`类定义了所有图形元素的低级通用属性，如框架、按钮和画布。例如，`JLabel`类*扩展*了`JComponent`类。这意味着`JLabel`继承了`JComponent`的细节，但添加了特定于标签的内容。您可能注意到`JComponent`本身也从`Object`继承，或者至少最终会返回到`Object`。为了简洁起见，我们省略了中间的类和包。'
- en: You can define your own classes and packages as well. For instance, the `ch05.examples.game`
    package in the lower-right corner is a custom package we built for a simple game
    that allows physicists to throw apples. (Newton will have his revenge!) In this
    package, we have some classes, like `Apple` and `Field`, that are part of our
    application. You can also see the `GamePiece` interface, which will contain some
    common, required elements for all game pieces and is implemented by the `Apple`,
    `Tree`, and `Physicist` classes. (In our game, the `Field` class is where all
    of the game pieces will be shown, but it is not a game piece itself. Notice that
    it does *not* implement the `GamePiece` interface.)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以定义自己的类和包。例如，右下角的`ch05.examples.game`包是我们为一个简单游戏构建的自定义包，允许物理学家扔苹果。（牛顿会报仇的！）在这个包中，我们有一些类，如`Apple`和`Field`，它们是我们应用程序的一部分。你还可以看到`GamePiece`接口，它包含所有游戏元素的一些共同必需元素，并由`Apple`、`Tree`和`Physicist`类实现。（在我们的游戏中，`Field`类是所有游戏元素显示的地方，但它本身不是一个游戏元素。注意它并没有实现`GamePiece`接口。）
- en: This chapter will go into much more detail, with more examples of each concept.
    We heartily recommend that you try the examples as you go and use the *jshell*
    tool (discussed in [“Trying Java”](ch03.html#learnjava6-CHP-3-SECT-6)) to help
    cement your understanding of new topics.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将详细介绍每个概念，并提供更多示例。我们强烈建议您在学习过程中尝试这些示例，并使用*jshell*工具（在[“尝试Java”](ch03.html#learnjava6-CHP-3-SECT-6)中讨论）来帮助巩固对新主题的理解。
- en: Declaring and Instantiating Classes
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明和实例化类
- en: A class serves as a blueprint for making *instances*, which are runtime objects
    (individual copies) that implement the class structure. You declare a class with
    the `class` keyword and a name of your choosing. In our game, for example, the
    physicists, apples, and trees are all good targets for becoming classes. Inside
    a class, we add variables that store details or other useful information, and
    methods that describe what we can do to and with instances of this class.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 类（class）作为制作实例（instances）的蓝图，这些实例是运行时对象（独立副本），实现了类的结构。你使用`class`关键字和自己选择的名称声明一个类。例如，在我们的游戏中，物理学家、苹果和树都是很好的类对象。在类中，我们添加存储详细信息或其他有用信息的变量，以及描述我们可以对类实例执行的方法。
- en: 'Let’s get started with a class for our apples. By (strong!) convention, class
    names start with capital letters. That makes `Apple` a good name to use. We won’t
    try to get every detail about our game apples into the class right away, just
    a few elements to help illustrate how a class, variables, and methods fit together:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从苹果类开始。按照（强烈的！）约定，类名以大写字母开头。这使得`Apple`成为一个很好的名称使用。我们不会立即将我们游戏苹果的每一个细节放入类中，只是一些元素，帮助说明类、变量和方法如何结合在一起：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `Apple` class contains four variables: `mass`, `diameter`, `x`, and `y`.
    It also defines a method called `isTouching()`, which takes a reference to another
    `Apple` as an argument and returns a `boolean` value as a result. Variables and
    method declarations can appear in any order, but variable initializers can’t make
    “forward references” to other variables that appear later. (In our little snippet,
    the `diameter` variable could use the `mass` variable to help calculate its initial
    value, but `mass` could not use the `diameter` variable to do the same.) Once
    we’ve defined the `Apple` class, we can create an `Apple` object (an instance
    of that class) for our game, like so:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`Apple`类包含四个变量：`mass`、`diameter`、`x`和`y`。它还定义了一个名为`isTouching()`的方法，该方法以另一个`Apple`的引用作为参数，并返回一个布尔值作为结果。变量和方法声明可以以任何顺序出现，但变量初始化器不能对稍后出现的其他变量进行“前向引用”。（在我们的小片段中，`diameter`变量可以使用`mass`变量来帮助计算其初始值，但`mass`不能使用`diameter`变量来执行相同的操作。）一旦我们定义了`Apple`类，我们就可以为我们的游戏创建一个`Apple`对象（该类的实例），如下所示：'
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Recall that our declaration of the variable `a1` doesn’t create an `Apple` object;
    it simply creates a variable that refers to an object of type `Apple`. We still
    have to create the object, using the `new` keyword, as shown in the second line
    of the preceding code snippet. But you can combine those steps into a single line
    just as we did for the `a2` variable. The same separate actions occur under the
    hood, of course. Sometimes the combined declaration and initialization will feel
    more readable than the multiline version.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们对变量`a1`的声明并没有创建一个`Apple`对象；它只是创建一个引用类型为`Apple`的变量。我们仍然需要使用`new`关键字创建对象，就像前面代码片段的第二行所示。但是你可以将这些步骤合并成一行，就像我们对`a2`变量所做的那样。当然，在幕后仍然是分开的动作。有时，合并声明和初始化的方式会比多行版本更易读。
- en: 'Now that we’ve created an `Apple` object, we can access its variables and methods,
    as we’ve seen in several of our examples from [Chapter 4](ch04.html#learnjava6-CHP-4)
    or even our graphical “Hello” app from [“HelloJava”](ch02.html#learnjava6-CHP-2-SECT-2).
    Although this is not very exciting, we could now build another class, `PrintAppleDetails`,
    that is a complete application to create an `Apple` instance and print its details:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们创建了一个`Apple`对象，我们可以访问它的变量和方法，就像我们在[第4章](ch04.html#learnjava6-CHP-4)的几个例子中或者甚至我们的图形“Hello”应用程序中看到的那样。尽管这并不是非常令人兴奋，但我们现在可以构建另一个类`PrintAppleDetails`，它是一个完整的应用程序，用于创建一个`Apple`实例并打印其详细信息：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you compile and run this example, you should see the following output in
    your terminal or in the terminal window of your IDE:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你编译并运行这个示例，你应该在你的终端或IDE的终端窗口中看到以下输出：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: But hmm, why doesn’t `a1` have a mass? If you look back at how we declared the
    variables for our `Apple` class, we only initialized `diameter`. All the other
    variables get the Java-assigned default value of `0` since they are numeric types.^([2](ch05.html#id1073))
    We would ideally like to have a more interesting apple. Let’s see how to provide
    those interesting bits.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，为什么`a1`没有质量呢？如果你回顾一下我们为`Apple`类声明变量的方式，我们只初始化了`diameter`。所有其他变量由于它们是数值类型，都会得到Java分配的默认值`0`。^([2](ch05.html#id1073))
    我们理想情况下希望有一个更有趣的苹果。让我们看看如何提供这些有趣的部分。
- en: Accessing Fields and Methods
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问字段和方法
- en: 'Once you have a reference to an object, you can use and manipulate its variables
    and methods using the dot notation you saw in [Chapter 4](ch04.html#learnjava6-CHP-4).
    Let’s create a new class, `PrintAppleDetails2`, provide some values for the mass
    and position of our `a1` instance, and then print the new details:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你获得了对象的引用，你就可以使用点符号来使用和操作它的变量和方法，就像你在[第4章](ch04.html#learnjava6-CHP-4)的几个例子中或者我们的图形“Hello”应用程序中看到的那样。让我们创建一个新类`PrintAppleDetails2`，为我们的`a1`实例提供一些质量和位置的值，然后打印新的详细信息：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here’s the new output:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这是新的输出：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Great! `a1` is looking a little better. But look at the code again. We had to
    repeat the three lines that print the object’s details. That type of exact replication
    calls out for a *method*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！`a1`看起来好多了。但再看看代码。我们不得不重复打印对象详细信息的三行代码。这种精确复制的情况需要一个*方法*。
- en: 'Methods allow us to “do stuff” inside a class. As a simple example, we could
    improve the `Apple` class by providing these print statements in a method:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 方法允许我们在类内部“做事情”。举个简单的例子，我们可以通过一个方法改进`Apple`类，提供这些打印语句：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With those detail statements relocated, we can create `PrintAppleDetails3`
    that does its job more succinctly than its predecessor:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些详细语句重新定位后，我们可以创建比其前身更为简洁的`PrintAppleDetails3`：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Take another look at the `printDetails()` method we added to the `Apple` class.
    Inside a class, we can access variables and call methods of the class directly
    by name. The print statements just use the simple names like `mass` and `diameter`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 再看看我们添加到`Apple`类的`printDetails()`方法。在类内部，我们可以通过名称直接访问类的变量和调用方法。打印语句只使用像`mass`和`diameter`这样的简单名称。
- en: 'Or consider filling out the `isTouching()` method. We can use our own `x` and
    `y` coordinates without any special prefix. But to access the coordinates of some
    other apple, we need to go back to the dot notation. Here’s one way to write that
    method using some math (more of this in [“The java.lang.Math Class”](ch08.html#learnjava6-CHP-8-SECT-4.1))
    and the `if/then` statement we saw in [“if/else conditionals”](ch04.html#learnjava6-CHP-4-SECT-5.1.1):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 或者考虑填写`isTouching()`方法。我们可以使用自己的`x`和`y`坐标，不需要任何特殊前缀。但要访问其他苹果的坐标，我们需要回到点表示法。这是使用一些数学（在[“java.lang.Math类”](ch08.html#learnjava6-CHP-8-SECT-4.1)中会有更多）和我们在[“if/else条件语句”](ch04.html#learnjava6-CHP-4-SECT-5.1.1)中看到的`if/then`语句来编写该方法的一种方式：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let’s fill out a bit more of our game and create a `Field` class that uses
    a few `Apple` objects. It creates instances as member variables and works with
    those objects in the `setupApples()` and `detectCollision()` methods, invoking
    `Apple` methods and accessing variables of those objects through the references
    `a1` and `a2`, visualized in [Figure 5-2](#learnjava6-CHP-5-FIG-2):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们填充我们的游戏并创建一个使用几个`Apple`对象的`Field`类。它作为成员变量创建实例，并在`setupApples()`和`detectCollision()`方法中与这些对象一起工作，调用`Apple`方法并通过引用`a1`和`a2`访问这些对象的变量，在[图 5-2](#learnjava6-CHP-5-FIG-2)中可视化：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![ljv6 0502](assets/ljv6_0502.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0502](assets/ljv6_0502.png)'
- en: Figure 5-2\. Instances of the `Apple` class
  id: totrans-39
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-2\. `Apple`类的实例
- en: 'We can prove that `Field` has access to the apples’ variables and methods with
    another iteration of our application, `PrintAppleDetails4`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过应用程序的另一个迭代`PrintAppleDetails4`证明`Field`可以访问苹果的变量和方法：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We should see the familiar apple details followed by an answer to whether or
    not the two apples are touching:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该看到熟悉的苹果细节，然后是两个苹果是否接触的答案：
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Great, just what we expected.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，正如我们所预期的那样。
- en: Before reading further, try changing the positions of the apples to make them
    touch. Do you get the expected output?
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续阅读之前，请尝试更改苹果的位置以使它们接触。您得到了预期的输出吗？
- en: Access modifiers preview
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问修饰符预览
- en: 'Several factors affect whether class members can be accessed from another class.
    You can use the visibility modifiers `public`, `private`, and `protected` to control
    access; classes can also be placed into a *package*, which affects their scope.
    The `private` modifier, for example, designates a variable or method for use only
    by other members of the class itself. In the previous example, we could change
    the declaration of our variable `diameter` to `private`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 影响类成员是否可以从另一个类访问的几个因素。您可以使用可见性修饰符`public`、`private`和`protected`来控制访问；类也可以放置在*包*中，这会影响它们的范围。例如，`private`修饰符指定变量或方法仅供类本身的其他成员使用。在前面的示例中，我们可以将变量`diameter`的声明更改为`private`：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now we can’t access `diameter` from `Field`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们无法从`Field`访问`diameter`：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If we still need to access `diameter` in some capacity, we would usually add
    public `getDiameter()` and `setDiameter()` methods to the `Apple` class:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仍然需要以某种方式访问`diameter`，通常会向`Apple`类添加公共`getDiameter()`和`setDiameter()`方法：
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Creating methods like this is a good design rule because it allows future flexibility
    in changing the type or behavior of the value. We’ll look more at packages, access
    modifiers, and how they affect the visibility of variables and methods later in
    this chapter.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这样的方法是一个良好的设计规则，因为它允许将来在更改值的类型或行为时具有灵活性。我们将在本章后面更详细地查看包、访问修饰符以及它们如何影响变量和方法的可见性。
- en: Static Members
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态成员
- en: 'As we’ve said, instance variables and methods are associated with and accessed
    through an instance of the class (that is, through a particular object, like `a1`
    or `f` in the previous examples). In contrast, members that are declared with
    the `static` modifier live in the class and are shared by all instances of the
    class. Variables declared with the `static` modifier are called *static variables*
    or *class variables*; similarly, these kinds of methods are called *static methods*
    or *class methods*. Static members are useful as flags and identifiers, that can
    be accessed from anywhere. We can add a static variable to our `Apple` example
    to store the value of acceleration due to gravity. This lets us calculate the
    trajectory of a tossed apple when we start animating our game:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说，实例变量和方法与类的实例相关联并通过其实例访问（即通过特定对象，如前面示例中的`a1`或`f`）。相反，使用`static`修饰符声明的成员位于类中并由类的所有实例共享。使用`static`修饰符声明的变量称为*静态变量*或*类变量*；同样，这些类型的方法称为*静态方法*或*类方法*。静态成员作为标志和标识符非常有用，可以从任何地方访问。我们可以向我们的`Apple`示例添加一个静态变量来存储由于重力而产生的加速度的值。这使我们可以在开始动画化我们的游戏时计算扔苹果的轨迹：
- en: '[PRE15]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We have declared the new `float` variable `gravAccel` as `static`. That means
    it is associated with the class, not with an individual instance, and if we change
    its value (either directly or through any instance of `Apple`), the value changes
    for all `Apple` objects, as shown in [Figure 5-3](#learnjava6-CHP-5-FIG-3).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将新的`float`变量`gravAccel`声明为`static`。这意味着它与类关联，而不是与单个实例关联，如果我们更改它的值（直接或通过任何`Apple`实例），则该值会对所有`Apple`对象更改，如[图5-3](#learnjava6-CHP-5-FIG-3)所示。
- en: '![ljv6 0503](assets/ljv6_0503.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0503](assets/ljv6_0503.png)'
- en: Figure 5-3\. Static variables shared by all instances of a class
  id: totrans-59
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-3\. 类的所有实例共享的静态变量
- en: 'You can access static members similarly to the way you access instance members.
    Inside our `Apple` class, we can refer to `gravAccel` like any other variable:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以类似于访问实例成员的方式访问静态成员。在我们的`Apple`类中，我们可以像访问任何其他变量一样引用`gravAccel`：
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'However, since static members exist in the class itself, independent of any
    instance, we can also access them directly through the class. If we want to toss
    apples on Mars, for example, we don’t need an `Apple` object like `a1` or `a2`
    to get or set the variable `gravAccel`. Instead, we can use the class to change
    the variable to reflect conditions on Mars:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于静态成员存在于类本身中，而不依赖于任何实例，因此我们还可以直接通过类访问它们。例如，如果我们想在火星上扔苹果，我们不需要像`a1`或`a2`这样的`Apple`对象来获取或设置变量`gravAccel`。相反，我们可以使用类来更改变量以反映火星上的条件：
- en: '[PRE17]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This changes the value of `gravAccel` for the class and all its instances.
    We don’t have to manually set each instance of `Apple` to fall on Mars. Static
    variables are useful for any kind of data that is shared among classes at runtime.
    For instance, you can create methods to register your object instances so that
    they can communicate, or so that you can keep track of all of them. It’s also
    common to use static variables to define constant values. In this case, we use
    the `static` modifier along with the `final` modifier. So, if we cared only about
    apples under the influence of the Earth’s gravitational pull, we might change
    `Apple` as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这会改变类及其所有实例的`gravAccel`值。我们不必手动设置每个`Apple`实例在火星上下落。静态变量对于在运行时共享的任何类型的数据非常有用。例如，您可以创建方法来注册您的对象实例，以便它们可以进行通信，或者以便您可以跟踪它们的所有实例。使用静态变量定义常量值也很常见。在这种情况下，我们使用`static`修饰符以及`final`修饰符。因此，如果我们只关心受地球引力影响的苹果，我们可能会如下更改`Apple`：
- en: '[PRE18]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We have followed a common convention here and named our constant with capital
    letters and underscores (if the name has more than one word). The value of `EARTH_ACCEL`
    is a constant; you can access it through the class `Apple` or its instances, but
    you can’t change its value.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们遵循了一个常见的约定，并使用大写字母和下划线（如果名称有多个单词）命名了我们的常量。`EARTH_ACCEL`的值是一个常量；您可以通过类`Apple`或其实例访问它，但不能更改其值。
- en: 'It’s important to use the combination of `static` and `final` only for things
    that are really constant. The compiler is allowed to “inline” such values within
    classes that reference them. This means that if you change a `static final` variable,
    you may have to recompile all code that uses that class (this is really the only
    case where you have to do that in Java). Static members are also useful for values
    needed in the construction of an instance itself. In our example, we might declare
    a number of static values to represent various sizes of `Apple` objects:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 只有真正常量的事物才重要使用`static`和`final`的组合。编译器允许在引用它们的类中“内联”这些值。这意味着如果你改变了一个`static final`变量，你可能需要重新编译所有使用该类的代码（这确实是在Java中唯一需要这样做的情况）。静态成员对于构造实例本身所需的值也很有用。例如，我们可以声明多个静态值来表示不同大小的`Apple`对象：
- en: '[PRE19]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We might then use these options in a method that sets the size of an `Apple`,
    or in a special constructor, as we’ll discuss shortly:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以在设置`Apple`大小的方法中使用这些选项，或者在稍后讨论的特殊构造函数中使用：
- en: '[PRE20]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Again, inside the `Apple` class, we can use static members directly by name,
    as well. There’s no need for the `Apple.` prefix:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，在`Apple`类内部，我们也可以直接通过名称使用静态成员。无需前缀`Apple.`：
- en: '[PRE21]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Methods
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法
- en: So far, our example classes have been fairly simple. We keep a few bits of information
    around—apples have mass, fields have a couple of apples, etc. But we have also
    touched on the idea of making those classes do stuff. All of our various `PrintAppleDetails`
    classes have a list of steps that get executed when we run the program, for example.
    As we noted briefly before, in Java, those steps are bundled into a method. In
    the case of `PrintAppleDetails`, that is the `main()` method.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的示例类还相当简单。我们保留一些信息，比如苹果有质量，田地有几个苹果等等。但是我们也触及了让这些类做一些事情的想法。例如，我们的各种`PrintAppleDetails`类在运行程序时有一系列步骤要执行。正如我们之前简要提到的，在Java中，这些步骤被打包成一个方法。对于`PrintAppleDetails`来说，这就是`main()`方法。
- en: Everywhere you have steps to take or decisions to make, you need a method. In
    addition to storing variables like the `mass` and `diameter` in our `Apple` class,
    we also added a few pieces of code that contained actions and logic. Methods are
    so fundamental to classes that we had to create a few even before getting here
    to the formal discussion of them! Think back to the `printDetails()` method in
    `Apple` or the `setupApples()` method in `Field`. Even our very first, simple
    program required a `main()` method.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您有步骤要执行或决策要做时，都需要一个方法。除了在我们的`Apple`类中存储诸如`mass`和`diameter`之类的变量外，我们还添加了一些包含动作和逻辑的代码片段。方法对于类来说如此基本，以至于我们甚至在正式讨论它们之前就不得不创建几个！想想`Apple`中的`printDetails()`方法或`Field`中的`setupApples()`方法。即使是我们的第一个简单程序也需要一个`main()`方法。
- en: Hopefully, the methods we have discussed so far have been straightforward enough
    to follow just from context. But methods can do much more than print out a few
    variables or calculate a distance. They can contain local variable declarations
    and other Java statements that are executed when the method is invoked. Methods
    may also return a value to the caller. They always specify a return type, which
    can be a primitive type, a reference type, or the special `void`, which indicates
    no returned value. Methods may take arguments, which are values supplied by the
    caller of the method.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 希望到目前为止我们讨论的方法都足够直接，可以从上下文中跟随。但是方法可以做的远不止打印出几个变量或计算距离。它们可以包含本地变量声明和其他在方法被调用时执行的Java语句。方法还可以向调用者返回一个值。它们总是指定一个返回类型，可以是原始类型、引用类型，或特殊的`void`，表示没有返回值。方法可以接受参数，这些参数是由方法的调用者提供的值。
- en: 'Here’s a simple example of a method that takes arguments:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个接受参数的简单方法的示例：
- en: '[PRE22]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In this example, the class `Bird` defines a method, `fly()`, that takes as
    arguments two integers: `x` and `y`. It returns a `double` type value as a result,
    using the `return` keyword.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，类`Bird`定义了一个方法`fly()`，它接受两个整数参数`x`和`y`。它使用`return`关键字返回一个`double`类型的值作为结果。
- en: Our method has a fixed number of arguments (two); however, methods can have
    *variable-length argument lists*, which allow the method to specify that it can
    take any number of arguments and sort them out itself at runtime.^([3](ch05.html#id1104))
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的方法有固定数量的参数（两个）；但是，方法可以有*可变长度的参数列表*，允许方法指定可以接受任意数量的参数，并在运行时自行排序。^([3](ch05.html#id1104))
- en: Local Variables
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地变量
- en: Our `fly()` method declares a local variable called `distance`, which it uses
    to compute the distance flown. A local variable is temporary; it exists only within
    the scope (the block) of its method. Local variables are allocated when a method
    is invoked; they are normally destroyed when the method returns. They can’t be
    referenced from outside the method itself. If the method is executing concurrently
    in different threads, each thread has its own version of the method’s local variables.
    A method’s arguments also serve as local variables within the scope of the method;
    the only difference is that they are initialized by being passed in from the caller
    of the method.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `fly()` 方法声明了一个名为 `distance` 的局部变量，用于计算飞行距离。局部变量是临时的；它们仅存在于其方法的作用域（代码块）内。局部变量在方法被调用时分配；它们通常在方法返回时被销毁。它们无法从方法外部引用。如果方法在不同线程中并发执行，每个线程都有自己版本的方法的局部变量。方法的参数在方法的作用域内也充当局部变量；唯一的区别是它们通过方法的调用者传递来初始化。
- en: An object created within a method and assigned to a local variable may or may
    not persist after the method has returned. As we’ll see in detail in [“Object
    Destruction”](#learnjava6-CHP-5-SECT-4), it depends on whether any references
    to the object remain. If an object is created, assigned to a local variable, and
    never used anywhere else, that object is no longer referenced when the local variable
    disappears from scope, so garbage collection removes the object. If, however,
    we assign the object to an instance variable of an object, pass it as an argument
    to another method, or pass it back as a return value, it may be saved by another
    variable holding its reference.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法内创建并分配给局部变量的对象在方法返回后可能会存在或不存在。正如我们将在 [“对象销毁”](#learnjava6-CHP-5-SECT-4) 中详细看到的那样，这取决于对象是否仍然有任何引用。如果创建对象并将其分配给局部变量，然后从未在其他任何地方使用该对象，则当局部变量从作用域中消失时，该对象不再被引用，因此垃圾收集器将移除该对象。但是，如果我们将对象分配给对象的实例变量，将其作为参数传递给另一个方法，或者将其作为返回值返回，则可能会由另一个变量持有其引用而保存下来。
- en: Shadowing
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遮蔽
- en: 'If a local variable or method argument and an instance variable have the same
    name, the local variable *shadows*, or hides, the name of the instance variable
    within the scope of the method. This might sound like an odd situation, but it
    happens fairly often when the instance variable has a common or obvious name.
    For example, we could add a `move` method to our `Apple` class. Our method will
    need a new coordinate telling it where to place the apple. An easy choice for
    the coordinate arguments would be `x` and `y`. But we already have instance variables
    of the same name that hold the current position of the apple:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个局部变量或方法参数与实例变量同名，则局部变量 *遮蔽* 或隐藏了方法作用域内的实例变量名称。这听起来可能有点奇怪，但当实例变量具有常见或明显的名称时，这种情况经常发生。例如，我们可以在我们的
    `Apple` 类中添加一个 `move` 方法。我们的方法将需要一个新的坐标，告诉它将苹果放在哪里。坐标参数的简单选择可能是 `x` 和 `y`。但是我们已经有了相同名称的实例变量，用于保存苹果的当前位置：
- en: '[PRE23]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If the apple is currently at position (20, 40) and you call `moveTo(40, 50),`
    what do you think that `println()` statement will show? Inside `moveTo()`, the
    `x` and `y` names refer only to the method arguments with those names. The output
    would be:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果苹果当前位于位置（20, 40），你调用了 `moveTo(40, 50),` 你觉得 `println()` 语句会显示什么？在 `moveTo()`
    中，`x` 和 `y` 仅指代那些具有这些名称的方法参数。输出将是：
- en: '[PRE24]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If we can’t get to the `x` and `y` instance variables, how can we move the apple?
    Turns out Java understands shadowing and provides a mechanism for working around
    these situations.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们无法访问 `x` 和 `y` 实例变量，我们怎么移动苹果呢？Java 理解遮蔽并提供了一种解决这些情况的机制。
- en: The “this” reference
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “this” 引用
- en: 'You can use the special reference `this` any time you need to refer explicitly
    to the current object or a member of the current object. Often you don’t need
    to use `this`, because the reference to the current object is implicit; such is
    the case when using unambiguously named instance variables inside a class. But
    you can use `this` to refer explicitly to instance variables in an object, even
    if they are shadowed. The following example shows how to use `this` to allow argument
    names that shadow instance variable names. This is a fairly common technique because
    it saves having to make up alternative names. Here’s how we could implement our
    `moveTo()` method with shadowed variables:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 每当需要显式引用当前对象或当前对象的成员时，你都可以使用特殊引用`this`。通常情况下，你不需要使用`this`，因为对当前对象的引用是隐式的；在类内部使用明确命名的实例变量时就是这种情况。但是，你可以使用`this`显式引用对象中的实例变量，即使它们被隐藏了。以下示例显示了如何使用`this`允许参数名称遮蔽实例变量名称。这是一种相当常见的技术，因为它避免了必须编造替代名称。这里是我们如何使用`this`来实现我们的`moveTo()`方法，其中包含了被遮蔽变量：
- en: '[PRE25]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this example, the expression `this.x` refers to the instance variable `x`
    and assigns it the value of the local variable `x`, which would otherwise hide
    its name. We do the same for `this.y` but add a little protection to make sure
    we don’t move the apple below our ground. Notice that `diameter` is not shadowed
    in this method. Since we don’t have a `diameter` argument in `moveTo()`, we don’t
    have to say `this.diameter` when we use it.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，表达式`this.x`引用了实例变量`x`并将其赋值给本地变量`x`的值，否则它会隐藏它的名称。对于`this.y`我们做了同样的事情，但是稍作保护，以确保我们不会将苹果移动到地面以下。请注意，在此方法中`diameter`没有被遮蔽。由于在`moveTo()`中没有`diameter`参数，因此在使用它时我们不必说`this.diameter`。
- en: 'The only reason we need to use `this` in the previous example is because we’ve
    used argument names that hide our instance variables, and we want to refer to
    the instance variables. You can also use the `this` reference any time you want
    to pass a reference to “the current” enclosing object to some other method, like
    we did for the graphical version of our “Hello Java” application in [“HelloJava2:
    The Sequel”](ch02.html#learnjava6-CHP-2-SECT-3).'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '在前面的示例中，我们唯一需要使用`this`的原因是因为我们使用了隐藏实例变量的参数名称，并且我们想要引用这些实例变量。你还可以在任何时候使用`this`引用，以便将“当前”封闭对象的引用传递给其他方法，就像我们在我们的“Hello
    Java”应用程序的图形版本中为[“HelloJava2: The Sequel”](ch02.html#learnjava6-CHP-2-SECT-3)所做的那样。'
- en: Static Methods
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态方法
- en: Static methods (sometimes called class methods), like static variables, belong
    to the class and not to individual instances of the class. What does this mean?
    Well, foremost, a *static method* lives outside of any particular instance. It
    can be invoked through the class name and dot operator, without any objects around.
    Because it is not bound to a particular object, a static method can only access
    other static members (static variables and other static methods) of the class.
    It can’t directly see any instance variables or call any instance methods, because
    to do so it would have to ask, “on which instance?” Static methods can be called
    from instances using the same syntax as instance methods, but the important thing
    is that they can also be used independently.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法（有时称为类方法），像静态变量一样，属于类而不是类的各个实例。这是什么意思呢？首先，*静态方法*存在于任何特定实例之外。它可以通过类名和点运算符调用，而无需任何对象的存在。因为它不绑定到特定对象，静态方法只能访问类的其他静态成员（静态变量和其他静态方法）。它不能直接访问任何实例变量或调用任何实例方法，因为这样做会需要问：“在哪个实例上？”静态方法可以通过与实例方法相同的语法从实例中调用，但重要的是它们也可以独立使用。
- en: 'Our `isTouching()` method uses a static method, `Math.sqrt()`, which is defined
    by the `java.lang.Math` class; we’ll explore this class in detail in [Chapter 8](ch08.html#learnjava6-CHP-8).
    For now, the important thing to note is that `Math` is the name of a class and
    not an instance of a `Math` object.^([4](ch05.html#id1121)) Because static methods
    can be invoked wherever the class name is available, class methods are closer
    to C-style functions. Static methods are particularly useful for utility methods
    that perform work that is useful either independently of instances or in working
    on instances. For example, in our `Apple` class, we could enumerate all of the
    available sizes as human-readable strings from the constants we created in [“Accessing
    Fields and Methods”](#learnjava6-CHP-5-SECT-1.2):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`isTouching()`方法使用了一个静态方法`Math.sqrt()`，它由`java.lang.Math`类定义；我们将在[第8章](ch08.html#learnjava6-CHP-8)详细探讨这个类。现在，需要注意的重要一点是，`Math`是一个类的名称，而不是`Math`对象的实例。^([4](ch05.html#id1121))因为静态方法可以在类名可用的任何地方调用，类方法更接近于C风格函数。静态方法特别适用于执行与实例无关或在实例上工作的实用方法。例如，在我们的`Apple`类中，我们可以从我们在[“访问字段和方法”](#learnjava6-CHP-5-SECT-1.2)中创建的常量中枚举所有可用大小为人类可读字符串。
- en: '[PRE26]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here, we’ve defined a static method, `getAppleSizes()`, that returns an array
    of strings containing apple size names. We make the method static because the
    list of sizes is the same regardless of what size any given instance of `Apple`
    might be. We can still use `getAppleSizes()` from within an instance of `Apple`
    if we want, just like an instance method. We could change the (nonstatic) `printDetails`
    method to print a size name rather than an exact diameter, for example:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个静态方法`getAppleSizes()`，它返回一个包含苹果尺寸名称的字符串数组。我们将该方法设置为静态，因为无论给定`Apple`实例的大小如何，大小列表始终相同。如果需要，我们仍然可以从`Apple`实例中使用`getAppleSizes()`，就像一个实例方法一样。例如，我们可以将（非静态）`printDetails`方法更改为打印大小名称而不是确切的直径：
- en: '[PRE27]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'However, we can also call it from other classes, using the `Apple` class name
    with the dot notation. For example, the very first `PrintAppleDetails` class could
    use similar logic to print a summary statement using our static method and static
    variables, like so:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们也可以从其他类中调用它，使用`Apple`类名和点符号。例如，第一个`PrintAppleDetails`类可以使用类似的逻辑来打印一个总结性语句，使用我们的静态方法和静态变量，就像这样：
- en: '[PRE28]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here we have our trusty instance of the `Apple` class, `a1`, but we don’t need
    `a1` to get the list of sizes. Notice that we load the list of nice names *before*
    `a1` even exists. But everything still works, as seen in the output:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有我们可靠的`Apple`类的实例`a1`，但我们不需要`a1`来获取大小列表。请注意，我们在`a1`甚至存在之前加载了漂亮名称列表。但一切仍然正常，如输出所示：
- en: '[PRE29]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Static methods also play an important role in various design patterns, where
    you limit the use of the `new` operator for a class to one method—a static method
    called a *factory method*. We’ll talk more about object construction in [“Constructors”](#learnjava6-CHP-5-SECT-3.1).
    There’s no naming convention for factory methods, but it is common to see usage
    like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法还在各种设计模式中发挥着重要作用，其中你将类的`new`操作符的使用限制为一个方法——一个称为*工厂方法*的静态方法。我们将在[“构造函数”](#learnjava6-CHP-5-SECT-3.1)中进一步讨论对象构造。工厂方法没有命名约定，但是在类似这样的用法中很常见：
- en: '[PRE30]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We won’t be writing any factory methods, but you’re likely to find them in the
    wild, especially when looking up questions on sites like Stack Overflow.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会编写任何工厂方法，但是在查找类似于Stack Overflow的网站上的问题时，你可能会发现它们。
- en: Initializing Local Variables
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化局部变量
- en: 'Unlike instance variables, which receive default values if we don’t provide
    an explicit one, local variables must be initialized before they can be used.
    You’ll get a compile-time error if you try to access a local variable without
    first assigning it a value:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 与实例变量不同，如果我们没有提供显式值，局部变量必须在使用之前进行初始化。如果尝试访问未分配值的局部变量，将会收到编译时错误：
- en: '[PRE31]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Notice that this doesn’t imply you always have to initialize local variables
    when you declare them, just that you must assign some value to them before the
    first time you reference them. More subtle possibilities arise when making assignments
    inside conditionals:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这并不意味着你在声明它们时总是要初始化局部变量，只是在第一次引用它们之前必须为它们赋值。当在条件语句内部进行赋值时，会出现更微妙的可能性：
- en: '[PRE32]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this example, `bar` is initialized only if `someCondition` is `true`. The
    compiler doesn’t let you make this wager, so it flags the use of `bar` after our
    `if` statement as an error.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，仅当`someCondition`为`true`时，才会初始化`bar`。编译器不会让你这么赌博，因此在`if`语句之后使用`bar`会被标记为错误。
- en: 'We could correct this situation in several ways. We could initialize the variable
    to a default value in advance or move the usage inside the conditional. We could
    also make sure the flow of control doesn’t reach the uninitialized variable through
    some other means, depending on what makes sense for our particular application.
    For example, we could simply make sure that we assign `bar` a value in both an
    `else` branch if `someCondition` is false. Or we could return from the method
    abruptly:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过几种方法来纠正这种情况。我们可以提前将变量初始化为默认值，或者将使用移动到条件内部。我们还可以确保控制流不通过其他方式到达未初始化的变量，这取决于对我们特定应用程序有意义的内容。例如，如果`someCondition`为假，我们可以简单地确保在`else`分支中为`bar`分配一个值。或者我们可以突然从方法返回：
- en: '[PRE33]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this case, either `someCondition` is true and `bar` is set to 42, or it is
    false and control returns from `myMethod()`. There’s no chance of reaching `bar`
    in an uninitialized state, so the compiler allows this use of `bar` after the
    conditional.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，要么`someCondition`为真，`bar`被设置为42，要么为假并从`myMethod()`返回。不可能在未初始化状态下访问`bar`，所以编译器允许在条件语句之后使用`bar`。
- en: Why is Java so picky about local variables? One of the most common (and insidious)
    sources of errors in other languages, like C or C++, is forgetting to initialize
    local variables. Local variables in those languages start with seemingly random
    values and cause all kinds of frustration for the programmer. Java tries to help
    out and forces you to assign good, known values.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么Java对局部变量如此挑剔？在其他语言（如C或C++）中，最常见（也是最隐秘）的错误之一就是忘记初始化局部变量。在那些语言中，局部变量以看似随机的值开始，给程序员带来各种各样的沮丧。Java试图帮助你，强制你分配好、已知的值。
- en: Argument Passing and References
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数传递和引用
- en: 'In the beginning of [Chapter 4](ch04.html#learnjava6-CHP-4), we described the
    distinction between primitive types, which are passed by value (by copying), and
    objects, which are passed by reference. Now that you’ve got a better handle on
    methods in Java, let’s walk through an example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第四章](ch04.html#learnjava6-CHP-4)的开头，我们描述了原始类型（通过复制按值传递）和对象（通过引用传递）之间的区别。既然你对Java中的方法有了更好的掌握，让我们通过一个例子来详细说明：
- en: '[PRE34]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This chunk of code calls `myMethod()`, passing it two arguments. The first argument,
    `i`, is passed by value; when the method is called, the value of `i` is copied
    into the method’s first parameter (a local variable) named `num`. If `myMethod()`
    changes the value of `num`, it changes only its local variable. Our `i` will not
    be affected.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码调用了`myMethod()`，并传递了两个参数。第一个参数`i`是按值传递的；当调用方法时，`i`的值被复制到方法的第一个参数（一个名为`num`的局部变量）中。如果`myMethod()`改变了`num`的值，它只改变了它自己的局部变量。我们的`i`不会受影响。
- en: In the same way, Java places a copy of the reference to `obj` into the argument
    `o` of `myMethod()`. But since it is a reference, both `obj` and `o` refer to
    the same object. Any changes made through either `o` or `obj` affect the actual
    object instance. If we change the value of, say, `o.size`, the change is visible
    both as `o.size` (inside `myMethod()`) and as `obj.size` (in the caller after
    `myMethod()` completes). However, if `myMethod()` reassigns the reference `o`
    to point to a different object, that assignment only affects its local variable
    reference. Assigning `o` to something else doesn’t affect the caller’s variable
    `obj`, which still refers to the original object.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，Java将`obj`的引用副本放入`myMethod()`的参数`o`中。但由于它是一个引用，`obj`和`o`都指向同一个对象。通过`o`或`obj`进行的任何更改都会影响实际的对象实例。如果我们改变了，比如说，`o.size`的值，这种更改在`myMethod()`内部的`o.size`和`myMethod()`完成后调用者的`obj.size`上都是可见的。然而，如果`myMethod()`重新分配引用`o`以指向不同的对象，那么这个分配只影响它的局部变量引用。将`o`赋给其他东西不会影响调用者的变量`obj`，它仍然指向原始对象。
- en: 'Passing references to methods gives us a taste of the other use for the `this`
    keyword we mentioned earlier. You can use `this` to pass a reference for the current
    object to some other object. Let’s look at a bit of code to see how this (no pun
    intended) works:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 将引用传递给方法让我们体验了我们之前提到的`this`关键字的另一种用法。你可以使用`this`将当前对象的引用传递给其他对象。让我们看一些代码来看看这是如何工作的：
- en: '[PRE35]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Our example is contrived, of course, but the syntax is correct. Inside the `printMyDetails()`
    method, we call our old friend, `System.out.println()`. The argument we pass to
    `println()` is `this`, meaning we want the current element object printed. We’ll
    be working with more complex object relationships in later chapters, and we will
    often need access to the current instance. The `this` keyword gives us that access.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们的例子是刻意构造的，但语法是正确的。在 `printMyDetails()` 方法内部，我们调用了我们的老朋友 `System.out.println()`。我们传递给
    `println()` 的参数是 `this`，意味着我们希望打印当前元素对象。在后面的章节中，我们将处理更复杂的对象关系，并且我们经常需要访问当前实例。`this`
    关键字提供了这种访问权限。
- en: Wrappers for Primitive Types
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原始类型的包装器
- en: As we touched on briefly in [“Primitive Types”](ch04.html#learnjava6-CHP-4-SECT-4.1),
    there is a schism in the Java world between class types (objects) and primitive
    types (numbers, characters, and Boolean values). Java accepts this trade-off for
    efficiency reasons. When you’re crunching numbers, you want your computations
    to be lightweight; having to use objects for primitive types complicates performance
    optimizations. It’s not common, but sometimes you need to store a primitive value
    as an object. For those occasions, Java supplies a standard wrapper class for
    each of the primitive types, as shown in [Table 5-1](#learnjava6-CHP-5-TABLE-1).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[“原始类型”](ch04.html#learnjava6-CHP-4-SECT-4.1)中简要提到的，Java 世界在类类型（对象）和原始类型（数字、字符和布尔值）之间存在分歧。出于效率原因，Java
    接受了这种权衡。当您在进行数字计算时，希望您的计算是轻量级的；使用对象来表示原始类型会复杂化性能优化。虽然不常见，但有时需要将原始值存储为对象。对于这些场合，Java
    为每个原始类型提供了标准的包装器类，如表 5-1 所示。
- en: Table 5-1\. Primitive type wrappers
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5-1\. 原始类型包装器
- en: '| Primitive | Wrapper |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 原始类型 | 包装器 |'
- en: '| --- | --- |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `void` | `java.lang.Void` |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `void` | `java.lang.Void` |'
- en: '| `boolean` | `java.lang.Boolean` |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `boolean` | `java.lang.Boolean` |'
- en: '| `char` | `java.lang.Character` |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `char` | `java.lang.Character` |'
- en: '| `byte` | `java.lang.Byte` |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `byte` | `java.lang.Byte` |'
- en: '| `short` | `java.lang.Short` |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `short` | `java.lang.Short` |'
- en: '| `int` | `java.lang.Integer` |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `int` | `java.lang.Integer` |'
- en: '| `long` | `java.lang.Long` |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `long` | `java.lang.Long` |'
- en: '| `float` | `java.lang.Float` |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `float` | `java.lang.Float` |'
- en: '| `double` | `java.lang.Double` |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `double` | `java.lang.Double` |'
- en: 'An instance of a wrapper class encapsulates a single value of its corresponding
    type. It’s an immutable object that serves as a container to hold the value and
    lets you retrieve it later. You can construct a wrapper object from a primitive
    value or from a `String` representation of the value. The following statements
    are equivalent:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 包装器类的实例封装了其对应类型的单个值。它是一个不可变对象，用于容纳值并允许您稍后检索它。您可以从原始值或值的 `String` 表示构造包装器对象。以下语句是等价的：
- en: '[PRE36]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The numeric wrapper constructors throw a `NumberFormatException` when they encounter
    an error parsing a string.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 数字包装器的构造函数在解析字符串时遇到错误时会抛出 `NumberFormatException`。
- en: 'Each of the numeric wrappers implements the `java.lang.Number` interface, which
    provides “value” methods to access its value in all the primitive forms. You can
    retrieve scalar values with the methods `doubleValue()`, `floatValue()`, `longValue()`,
    `intValue()`, `shortValue()`, and `byteValue()`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数字包装器都实现了 `java.lang.Number` 接口，该接口提供了访问其各种原始形式值的“value”方法。您可以使用 `doubleValue()`、`floatValue()`、`longValue()`、`intValue()`、`shortValue()`
    和 `byteValue()` 方法检索标量值：
- en: '[PRE37]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This code is equivalent to casting the primitive `double` value to the various
    types.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码等效于将原始 `double` 值转换为各种类型。
- en: 'The most common need for these wrappers is when you want to pass a primitive
    value to a method that requires an object. For example, in [Chapter 7](ch07.html#learnjava6-CHP-7),
    we’ll look at Java collections, a sophisticated set of classes for dealing with
    object groups, such as lists, sets, and maps. Collections work only with object
    types, so primitives must be wrapped when stored in them. As we’ll see in the
    next section, Java makes this wrapping process transparent and automatic. For
    now, however, let’s do it ourselves. As we’ll see, a `List` is an extensible collection
    of `Object`s. We can use wrappers to hold simple numbers in a `List` (along with
    other objects):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这些包装器最常用的情况是当您想要将原始值传递给需要对象的方法时。例如，在[第 7 章](ch07.html#learnjava6-CHP-7)中，我们将学习
    Java 集合，这是一组用于处理对象组（如列表、集合和映射）的复杂类。集合仅适用于对象类型，因此在存储原始类型时必须进行包装。正如我们将在下一节看到的，Java
    会自动透明地处理此包装过程。但现在让我们手动做一下。正如我们将看到的，`List` 是 `Object` 的可扩展集合。我们可以使用包装器在 `List`
    中存储简单的数字（以及其他对象）：
- en: '[PRE38]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Here, we have created an `Integer` wrapper object so that we can insert the
    number into the `List`, using the `add()` method, which accepts an object. Later,
    when we are extracting elements from the `List`, we can recover the `int` value
    as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个`Integer`包装器对象，以便我们可以将该数字插入`List`中，使用接受对象的`add()`方法。稍后，当我们从`List`中提取元素时，我们可以如下恢复`int`值：
- en: '[PRE39]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Happily, Java can do much of this work automatically. Java calls the automatic
    wrapping and unwrapping of primitive types *autoboxing*. As we alluded to earlier,
    allowing Java to do this for us makes the code more concise and secure. The usage
    of the wrapper class is mostly hidden from us by the compiler, but it is still
    being used internally. Here’s one more example that includes extra type information
    (*generics* in computer language parlance) and uses autoboxing:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 令人高兴的是，Java可以自动完成这些工作的大部分。Java调用原始类型的自动包装和拆包称为*自动装箱*。正如我们之前提到的，允许Java为我们完成这些工作使得代码更加简洁和安全。编译器大部分时间都会为我们隐藏包装类的使用，但它确实在内部使用。以下是包含额外类型信息（在计算机语言术语中称为*泛型*）并使用自动装箱的另一个示例：
- en: '[PRE40]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Notice we don’t create any explicit instances of the `Integer` wrapper, although
    we do include that extra type information in angle brackets (`<Integer>`) when
    we declare our variable. We’ll see more of generics in [Chapter 7](ch07.html#learnjava6-CHP-7).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们没有创建任何`Integer`包装器的显式实例，尽管在声明变量时我们在尖括号（`<Integer>`）中包含了额外的类型信息。我们将在[第7章](ch07.html#learnjava6-CHP-7)中看到更多有关泛型的内容。
- en: Method Overloading
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法重载
- en: '*Method overloading* is the ability to define multiple methods with the same
    name in a class; when the method is invoked, the compiler picks the correct one
    based on the arguments passed to the method. This implies that overloaded methods
    must have different numbers or types of arguments. (In [“Overriding methods”](#learnjava6-CHP-5-SECT-6.1.2),
    we’ll look at *method overriding*, which occurs when we declare methods with identical
    signatures in subclasses.)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*方法重载*是在类中定义多个具有相同名称的方法的能力；当调用该方法时，编译器根据传递给方法的参数选择正确的方法。这意味着重载方法必须具有不同数量或类型的参数。在[“方法重写”](#learnjava6-CHP-5-SECT-6.1.2)中，我们将查看*方法重写*，它发生在我们在子类中声明具有相同签名的方法时。'
- en: 'Method overloading (also called *ad hoc polymorphism*) is a powerful and useful
    feature. The idea is to create methods that act in the same way on different types
    of arguments. This creates the illusion that a single method can operate on many
    types of arguments. The `print()` method in the standard `PrintStream` class is
    a good example of method overloading in action. As you’ve probably deduced by
    now, you can print a string representation of just about anything using this expression:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 方法重载（也称为*特定多态性*）是一种强大而有用的特性。其理念是创建能够在不同类型参数上以相同方式操作的方法。这造成了单个方法能够在许多类型的参数上操作的假象。标准`PrintStream`类中的`print()`方法就是方法重载的一个很好的例子。正如你现在可能已经推断出的那样，你可以使用以下表达式打印几乎任何东西的字符串表示：
- en: '[PRE41]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The variable `out` is a reference to an object (a `PrintStream`) that defines
    nine different, “overloaded” versions of the `print()` method. The versions take
    arguments of the following types: `Object`, `String`, `char[]`, `char`, `int`,
    `long`, `float`, `double`, and `boolean`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`out`是一个对象引用（一个`PrintStream`），它定义了`print()`方法的九个不同的“重载”版本。这些版本接受以下类型的参数：`Object`、`String`、`char[]`、`char`、`int`、`long`、`float`、`double`和`boolean`：
- en: '[PRE42]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: You can invoke the `print()` method with any of these types as an argument,
    and the value will be printed in an appropriate way. In a language without method
    overloading, this requires something more cumbersome, such as a uniquely named
    method for printing each type of object. In that case, it’s your responsibility
    to figure out what method to use for each data type.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用任何这些类型之一作为参数调用`print()`方法，并且该值将以适当的方式打印出来。在没有方法重载的语言中，这将需要更多的繁琐操作，例如为每种对象类型命名一个唯一的打印方法。在这种情况下，您需要确定每种数据类型使用哪种方法。
- en: 'In Java, `print()` has been overloaded to support two reference types: `Object`
    and `String`. What if we try to call `print()` with some other reference type?
    Say, a `Date` object? When there’s not an exact type match, the compiler searches
    for an acceptable, *assignable* match. Since `Date`, like all classes, is a subclass
    of `Object`, a `Date` object can be assigned to a variable of type `Object`. It’s
    therefore an acceptable match, and the compiler selects the `Object` version of
    the method.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，`print()` 方法已经被重载以支持两种引用类型：`Object` 和 `String`。如果我们尝试使用其他引用类型调用 `print()`
    方法会怎样呢？比如，一个 `Date` 对象？当没有精确的类型匹配时，编译器会寻找一个可接受的、*可赋值的* 匹配。由于 `Date` 类，像所有类一样，是
    `Object` 的子类，因此可以将 `Date` 对象赋给类型为 `Object` 的变量。因此，这是一个可接受的匹配，编译器选择了 `Object` 版本的方法。
- en: What if there’s more than one possible match? For example, what if we want to
    print the literal `"Hi there"`? That literal is assignable to either `String`
    (since it is a `String`) or to `Object`, the parent class of `String`. Here, the
    compiler decides which match is “better” and selects that method. In this case,
    it selects the `String` version.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有多个可能的匹配怎么办？例如，如果我们想打印字面值 `"Hi there"`，那么这个字面值既可以分配给 `String`（因为它是一个 `String`），也可以分配给
    `Object`，即 `String` 的父类。在这种情况下，编译器决定哪个匹配“更好”并选择该方法。在这种情况下，它选择了 `String` 版本。
- en: The intuitive explanation for selecting the `String` version is that the `String`
    class is “closer” to the type of our literal `"Hi there"` in the inheritance hierarchy.
    It is a *more specific* match. A slightly more rigorous way of specifying it would
    be to say that a given method is more specific than another method if the argument
    types of the first method are all assignable to the argument types of the second
    method. In this case, the `String` method is more specific because type `String`
    is assignable to type `Object`. The reverse is not true.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 `String` 版本的直觉解释是，`String` 类在继承层次结构中与我们的字面值 `"Hi there"` 类型“更接近”。它是一个*更具体*
    的匹配。更严格地说，可以说，如果第一个方法的参数类型都可以赋值给第二个方法的参数类型，则给定方法比另一个方法更具体。在这种情况下，`String` 方法更具体，因为类型
    `String` 可以赋值给类型 `Object`。反之则不成立。
- en: If you’re paying close attention, you may have noticed we said that the compiler
    resolves overloaded methods. Method overloading is not something that happens
    at runtime; this is an important distinction. Making this decision during compilation
    means that once the overloaded method is selected, the choice is fixed until the
    code is recompiled, even if the class containing the called method is later revised
    and an even more specific overloaded method is added.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您非常注意，您可能已经注意到我们说编译器解析重载的方法。方法重载不是在运行时发生的事情；这是一个重要的区别。在编译期间做出这个决定意味着一旦选择了重载的方法，即使包含调用方法的类稍后被修订并添加了更具体的重载方法，选择也是固定的，直到代码重新编译。
- en: This compile-time selection is in contrast to *overridden* methods, which are
    located at runtime and can be found even if they didn’t exist when the calling
    class was compiled. In practice, this distinction will not usually be relevant
    to you, as you will likely recompile all of the necessary classes at the same
    time. We’ll talk about method overriding later in the chapter.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这种编译时选择与 *重写* 方法形成对比，后者在运行时定位并可以找到，即使在调用类编译时它们不存在也可以。在实践中，这种区别通常对您不会有太大影响，因为您可能会同时重新编译所有必要的类。我们将在本章后面讨论方法重写。
- en: Object Creation
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象创建
- en: Objects in Java are allocated on a system “heap” memory space. Unlike some other
    languages, however, we needn’t manage that memory ourselves. Java takes care of
    memory allocation and deallocation for you. Java explicitly allocates storage
    for an object when you create it with the `new` operator. More importantly, objects
    are removed by garbage collection when they’re no longer referenced.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Java 中的对象被分配在系统的“堆”内存空间中。然而，与其他一些语言不同的是，我们不需要自行管理该内存。Java 会为您处理内存的分配和释放。在您使用`new`操作符创建对象时，Java
    明确为其分配存储空间。更重要的是，当对象不再被引用时，通过垃圾回收机制将其移除。
- en: Constructors
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造函数
- en: 'Objects are allocated with the `new` operator using a *constructor*. A constructor
    is a special method with the same name as its class and no return type. It’s called
    when a new class instance is created, which gives the class an opportunity to
    set up the object for use. Constructors, like other methods, can accept arguments
    and can be overloaded. They are not, however, inherited like other methods:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 对象使用`new`运算符分配，使用*构造函数*。构造函数是一个与其类名相同且没有返回类型的特殊方法。当创建新的类实例时调用它，这为类设置对象使用的机会。构造函数像其他方法一样可以接受参数，并且可以重载。然而，它们不像其他方法那样被继承：
- en: '[PRE43]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In this snippet, the class `Date` has two constructors. The first takes no
    arguments; it’s known as the *default constructor*. Default constructors play
    a special role: if you don’t define any constructors for a class, the compiler
    will supply an empty default constructor for you. The default constructor is what
    gets called whenever you create an object by calling its constructor with no arguments.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码片段中，`Date`类有两个构造函数。第一个不带参数；它被称为*默认构造函数*。默认构造函数有着特殊的角色：如果您没有为类定义任何构造函数，编译器将为您提供一个空的默认构造函数。默认构造函数是在您通过不带参数调用其构造函数创建对象时调用的函数。
- en: 'Here we have implemented the default constructor so that it sets the instance
    variable `day` by calling a hypothetical method, `currentDay()`, which presumably
    knows how to look up the current day. The second constructor takes a `String`
    argument. In this case, the `String` contains a date string that can be parsed
    to set the `day` variable. Given these constructors, we can create a `Date` object
    in the following ways:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已实现了默认构造函数，以便它通过调用一个假设的方法`currentDay()`设置实例变量`day`，该方法可能知道如何查找当前日期。第二个构造函数接受一个`String`参数。在这种情况下，`String`包含一个可以解析为设置`day`变量的日期字符串。有了这些构造函数，我们可以通过以下方式创建`Date`对象：
- en: '[PRE44]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In each case, Java chooses the appropriate constructor at compile time based
    on the rules for overloaded method selection.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，Java根据重载方法选择的规则在编译时选择适当的构造函数。
- en: 'If we later remove all references to an allocated object, it’ll be garbage-collected,
    as we’ll discuss shortly:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果以后删除了分配的对象的所有引用，则它将被垃圾收集，我们将很快讨论：
- en: '[PRE45]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Setting this reference to `null` means it’s no longer pointing to the `"Dec
    25, 2022"` date object. Setting the variable `christmas` to any other value would
    have the same effect. Unless another variable also refers to the original date
    object, the date is now inaccessible and can be garbage-collected. We’re not suggesting
    that you have to set references to `null` to get the values garbage-collected.
    Often this just happens naturally when local variables fall out of scope, but
    instance variables of objects live as long as the object itself lives (through
    references to it), and static variables live effectively forever.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 将此引用设置为`null`意味着它不再指向`"Dec 25, 2022"`日期对象。将变量`christmas`设置为其他任何值将产生相同的效果。除非另一个变量也引用原始日期对象，否则日期现在是不可访问的，并且可以被垃圾收集。我们并不建议您必须将引用设置为`null`才能进行值的垃圾收集。通常情况下，当局部变量超出范围时，这种情况自然发生，但是对象的实例变量（通过引用）会随着对象本身的生存而存在，而静态变量则会永久存在。
- en: 'A few more notes: you can declare constructors with the same visibility modifiers
    (`public`, `private`, or `protected`) as other methods, to control their accessibility.
    You can’t, however, make constructors `abstract`, `final`, or `synchronized`.
    We’ll talk in detail about `abstract`, `final`, and visibility modifiers later
    in this chapter, and we’ll cover `synchronized` in [Chapter 9](ch09.html#learnjava6-CHP-9).'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以使用与其他方法相同的可见性修饰符（`public`、`private`或`protected`）声明构造函数，以控制它们的可访问性。然而，您不能将构造函数设为`abstract`、`final`或`synchronized`。我们将在本章后面详细讨论`abstract`、`final`和可见性修饰符，并将在[第9章](ch09.html#learnjava6-CHP-9)中讨论`synchronized`。
- en: Working with Overloaded Constructors
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用重载构造函数
- en: 'A constructor can refer to another constructor in the same class or the immediate
    superclass using special forms of the `this` and `super` references. We’ll discuss
    the first case here and return to that of the superclass constructor after we
    have talked more about creating subclasses (often referred to simply as subclassing)
    and inheritance. A constructor can invoke another overloaded constructor in its
    class using the self-referential method call `this()` with appropriate arguments
    to select the desired constructor. If a constructor calls another constructor,
    *it must do so as its first statement*:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数可以使用`this`和`super`引用的特殊形式引用同一类或直接超类中的另一个构造函数。我们将在这里讨论第一种情况，并在更多地讨论创建子类（通常简称为子类化）和继承之后返回超类构造函数的情况。构造函数可以使用自引用方法调用`this()`来调用其类中的另一个重载构造函数，以选择所需的构造函数。如果一个构造函数调用另一个构造函数，则*必须将其作为其第一条语句*进行：
- en: '[PRE46]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In this example, the class `Car` has two constructors. The first, more explicit
    one accepts arguments specifying the car’s model and its number of doors. The
    second constructor takes just the model as an argument and, in turn, calls the
    first constructor with a default value of four doors. The advantage of this approach
    is that you can have a single constructor do all the complicated setup work; other,
    more convenient constructors simply feed the appropriate arguments to that primary
    constructor.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，类`Car`有两个构造函数。第一个更明确的构造函数接受指定汽车型号和车门数量的参数。第二个构造函数只接受模型作为参数，并调用第一个构造函数，使用默认值四个车门。这种方法的优点在于，您可以让单个构造函数完成所有复杂的设置工作；其他更方便的构造函数只需将适当的参数传递给该主要构造函数。
- en: The special call to `this()` must appear as the first statement in our delegating
    constructor. The syntax is restricted in this way because there’s a need to identify
    a clear chain of command when calling constructors. At the end of the chain, Java
    invokes the constructor of the superclass (if we don’t do it explicitly in our
    code) to ensure that inherited members are initialized properly before we proceed.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对`this()`的特殊调用必须出现作为我们委托构造函数中的第一条语句。语法以这种方式受限是因为在调用构造函数时需要确定一个清晰的命令链。在链的末端，Java会调用超类的构造函数（如果我们在代码中没有明确调用它），以确保继承成员在继续之前被正确初始化。
- en: There’s also a point in the chain, just after invoking the constructor of the
    superclass, where the initializers of the current class’s instance variables are
    evaluated. Before that point, we can’t even reference the instance variables of
    our class. We’ll explain this situation again in complete detail after we have
    talked about inheritance.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用超类构造函数后的链中，当前类的实例变量的初始化器被评估。在这一点之前，我们甚至不能引用我们类的实例变量。在我们讨论完继承之后，我们将再次详细解释这种情况。
- en: 'For now, all you need to know is that you can invoke a second constructor (delegate
    to it) only as the first statement of your constructor. For example, the following
    code is illegal and causes a compile-time error:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，您只需知道，您只能作为构造函数的第一条语句调用第二个构造函数（委托给它）。例如，以下代码是非法的并导致编译时错误：
- en: '[PRE47]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The simple model name constructor can’t do any additional setup before calling
    the more explicit constructor. It can’t even refer to an instance member for a
    constant value:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的模型名称构造函数在调用更明确的构造函数之前不能进行任何额外的设置。它甚至不能引用实例成员来获取常量值：
- en: '[PRE48]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The instance variable `defaultDoors` is not initialized until a later point
    in the chain of constructor calls setting up the object, so the compiler doesn’t
    let us access it yet. Fortunately, we can solve this particular problem by using
    a static variable instead of an instance variable:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 实例变量`defaultDoors`在设置对象的构造函数调用链的后续过程中才被初始化，因此编译器不允许我们访问它。幸运的是，我们可以通过使用静态变量而不是实例变量来解决这个特定的问题：
- en: '[PRE49]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The static members of a class are initialized when the class is first loaded
    into the virtual machine. The compiler can determine the value of these static
    members so it’s safe to access them in a constructor.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 类的静态成员在首次加载到虚拟机时初始化。编译器可以确定这些静态成员的值，因此在构造函数中访问它们是安全的。
- en: Object Destruction
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象销毁
- en: Now that we’ve seen how to create objects, it’s time to talk about how to destroy
    them. If you’re accustomed to programming in C or C++, you’ve probably spent time
    hunting down *memory leaks* in your code. Programmers accidentally allow memory
    to leak by creating objects (which consume memory) and forgetting to destroy them
    (which returns the allocated memory) once the objects are no longer needed. Java
    takes care of object destruction for you; you don’t have to worry about traditional
    memory leaks, and you can concentrate on more important programming tasks.^([5](ch05.html#id1181))
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何创建对象，是时候谈谈如何销毁它们了。如果你习惯于使用C或C++进行编程，那么你可能已经花费了时间来追踪你的代码中的*内存泄漏*。程序员通常会因为创建对象（消耗内存）而忘记在对象不再需要时销毁它们（返回分配的内存）而导致内存泄漏。Java会为你处理对象销毁；你不必担心传统的内存泄漏问题，可以专注于更重要的编程任务。^([5](ch05.html#id1181))
- en: Garbage Collection
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 垃圾回收
- en: Java uses a technique known as *garbage collection* to remove objects that are
    no longer needed. The garbage collector is Java’s Grim Reaper. It lingers in the
    background, stalking objects and awaiting their demise. It finds and watches them,
    periodically counting references to them to see when their time has come. When
    all references to an object are gone and it’s no longer accessible, the garbage-collection
    mechanism declares the object *unreachable* and reclaims its space back to the
    available pool of resources. An unreachable object is one that can no longer be
    found through any combination of “live” references in the running application.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Java使用一种称为*垃圾回收*的技术来删除不再需要的对象。垃圾收集器是Java的收割者。它在后台徘徊，潜伏着对象并等待它们的死亡。它找到它们并观察它们，定期计算对它们的引用，以确定它们的寿命何时结束。当一个对象的所有引用都消失了，它不再可访问时，垃圾收集机制会声明该对象*不可达*，并将其空间收回到可用资源池中。一个不可达的对象是指在运行应用程序的任何“活”引用组合中都无法找到的对象。
- en: Garbage collection uses a variety of algorithms; the Java virtual machine architecture
    doesn’t require a particular scheme. It’s worth noting, however, how some implementations
    of Java have accomplished this task. In the beginning, Java used a technique called
    “mark and sweep.” In this scheme, Java first walks through the tree of all accessible
    object references and marks them as alive. It then scans the heap, looking for
    identifiable objects that are *not* marked. Using this technique, Java can find
    objects on the heap because they are stored in a characteristic way and have a
    particular signature of bits in their handles that’s unlikely to be reproduced
    naturally. This kind of algorithm doesn’t become confused by the problem of cyclic
    references, in which objects can mutually reference each other and appear alive
    even when they are dead (Java handles this problem automatically). This scheme
    wasn’t the fastest method, however, and caused pauses in programs. Since then,
    implementations have become much more sophisticated.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾收集使用各种算法；Java虚拟机架构并不需要特定的方案。然而，值得注意的是，一些Java的实现是如何完成这项任务的。最初，Java使用了一种称为“标记-清除”的技术。在这种方案中，Java首先遍历所有可访问对象引用的树，并将它们标记为存活的。然后它扫描堆，寻找未标记的可识别对象。使用这种技术，Java可以找到堆上的对象，因为它们以特定的方式存储，并且在其句柄中具有特定的位签名，这不太可能自然产生。这种算法不会因循环引用问题而混乱，即对象可以相互引用并且在它们死亡时仍然看起来存活（Java会自动处理此问题）。然而，这种方案并不是最快的方法，并且会导致程序暂停。自那时以来，实现已经变得更加复杂。
- en: Modern Java garbage collectors effectively run continuously without forcing
    any lengthy delay in execution of the Java application. Because they are part
    of a runtime system, they can also accomplish some things that could not be done
    statically. For instance, Java divides the memory heap into several areas for
    objects with different estimated life spans. Short-lived objects are placed on
    a special part of the heap, which drastically reduces the time required to recycle
    them. Objects that live longer can be moved to other, less volatile parts of the
    heap. In recent implementations, the garbage collector can even “tune” itself
    by adjusting the heap partition sizes based on the actual application performance.
    The improvement in Java’s garbage collection since the early releases has been
    remarkable and is one of the reasons that Java is now roughly equivalent in speed
    to many traditional languages that place the burden of memory management on the
    shoulders of the programmer.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现代Java垃圾收集器在不强制执行任何长时间延迟的情况下有效地持续运行Java应用程序。因为它们是运行时系统的一部分，它们还可以完成一些静态无法完成的任务。例如，Java将内存堆分为几个区域，用于存放估计生命周期不同的对象。短生命周期对象被放置在堆的特定部分，这大大减少了回收它们所需的时间。生命周期较长的对象可以被移动到堆的其他不那么易变的部分。在最近的实现中，垃圾收集器甚至可以通过根据实际应用程序性能调整堆分区大小来“调优”自己。自从早期版本以来，Java的垃圾收集改进非常显著，这也是Java现在速度大致相当于许多传统语言的原因之一，那些语言把内存管理的负担放在程序员的肩上。
- en: In general, you do not have to concern yourself with the garbage-collection
    process. But one garbage-collection method can be useful for debugging. You can
    prompt the garbage collector to make a clean sweep explicitly by invoking the
    `System.gc()` method. This method is completely implementation dependent and may
    do nothing, but you can use it if you want some guarantee that Java has at least
    tried to clean up memory before you do an activity.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，你不需要关心垃圾回收过程。但是一种垃圾回收方法在调试时可能会有用。你可以通过调用`System.gc()`方法显式地促使垃圾收集器进行一次完整的清理。这个方法完全依赖于实现，并且可能什么都不做，但是如果你希望在执行某个活动之前确保Java至少尝试清理内存，你可以使用它。
- en: Packages
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包
- en: Even when we stick to simple examples, you may have noticed that solving problems
    in Java requires creating classes. For our game classes above, we have our apples
    and our trees and our playing field, to name just a few. For more complex applications
    or libraries, you can have hundreds or even thousands of classes. You need a way
    to organize things, and Java uses the notion of a *package* to accomplish this
    task. Let’s look at some examples.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们只用简单的例子，你可能也注意到在Java中解决问题需要创建类。在上面的游戏类中，我们有苹果、树和游戏场地等等。对于更复杂的应用程序或库，你可能会有数百甚至数千个类。你需要一种方法来组织这些内容，Java使用*包*的概念来完成这项任务。让我们看几个例子。
- en: 'Recall our second Hello World example in [Chapter 2](ch02.html#learnjava6-CHP-2).
    The first few lines in the file show us a lot of information about where the code
    lives:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾我们在[第二章](ch02.html#learnjava6-CHP-2)中的第二个Hello World示例。文件的前几行向我们展示了代码的所在地的很多信息：
- en: '[PRE50]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We named the Java file *HelloJava.java* according to the main class (`HelloJava`)
    in that file. When we talk about organizing things that go in files, you might
    naturally think of using folders to organize those files in turn. That is essentially
    what Java does. In this example, we use the `package` keyword and assign a package
    name of `ch02.examples`. Packages map onto folder names much the way classes map
    onto filenames. From the directory where you installed the examples for this book,
    then, this class should be found in the file *ch02/examples/HelloJava.java*. Take
    a look back at [Figure 5-1](#learnjava6-CHP-5-FIG-1) where we have some classes
    grouped into their packages. If you were looking at the Java source code for the
    Swing components we used in `HelloJava`, for example, you would find a folder
    named *javax*, and under that, one named *swing*, and under that you would find
    files like *JFrame.java* and *JLabel.java*.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们根据该文件中的主类(`HelloJava`)将Java文件命名为*HelloJava.java*。当我们讨论如何组织文件中的内容时，你可能自然会想到使用文件夹来进一步组织这些文件。这基本上就是Java所做的。在这个例子中，我们使用`package`关键字并为其指定一个包名`ch02.examples`。包映射到文件夹名称的方式与类映射到文件名的方式类似。因此，从安装本书示例的目录开始，这个类应该可以在文件*ch02/examples/HelloJava.java*中找到。回顾一下[图 5-1](#learnjava6-CHP-5-FIG-1)，我们将一些类分组到它们的包中。例如，如果你正在查看我们在`HelloJava`中使用的Swing组件的Java源代码，你会发现一个名为*javax*的文件夹，它下面有一个名为*swing*的文件夹，而在其中你会找到像*JFrame.java*和*JLabel.java*这样的文件。
- en: Each class belongs to exactly one package. Package names follow the same general
    rules as other Java identifiers and are all lowercase by convention. If you don’t
    specify a package, Java assigns your class to the “default” package. Using the
    default package is fine for one-off demos, but you should otherwise use `package`
    for your classes. The default package has several limitations—for example, a class
    in the default package cannot be used with *jshell*—and is not meant to be used
    beyond testing.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类都属于一个包。包名遵循与其他 Java 标识符相同的一般规则，并且按约定全部小写。如果不指定包，Java 将把你的类分配给“默认”包。对于一次性演示，使用默认包是可以的，但除此之外，你应该使用
    `package` 来为你的类指定包。默认包有几个限制——例如，默认包中的类无法与 *jshell* 一起使用——并且不应该仅用于测试之外的用途。
- en: Importing Classes
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入类
- en: One of Java’s biggest strengths lies in the vast collection of supporting libraries
    available under both commercial and open source licensing. Need to export a PDF?
    There’s a library for that. Need to import a spreadsheet? There’s a library for
    that. Need to turn on that smart lightbulb in the basement from a web server in
    the cloud? There’s a library for that, too. If computers are doing some task or
    other, you will almost always find a Java library to help you write code to perform
    that task as well.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Java 的一个最大优势在于其庞大的支持库集合，涵盖商业和开源许可下的各种库。需要导出 PDF 吗？有适合的库。需要导入电子表格吗？也有适合的库。需要从云中的
    Web 服务器控制地下室的智能灯泡吗？同样有适合的库。如果计算机正在执行某项任务，几乎总能找到一个 Java 库来帮助你编写执行该任务的代码。
- en: To use any of these wonderful libraries, you *import* them with the cleverly
    named `import` keyword. We used `import` with our `HelloJava` example so we could
    add the frame and label components from the Swing graphical library. You can import
    individual classes or entire packages. Let’s look at some examples.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这些优秀的库中的任何一个，你可以使用巧妙命名的 `import` 关键字进行*导入*。我们在 `HelloJava` 的示例中使用了 `import`，这样我们就可以从
    Swing 图形库中添加框架和标签组件。你可以导入单个类或整个包。让我们看一些例子。
- en: Importing individual classes
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导入单个类
- en: 'In programming, you’ll often hear the maxim that “less is more.” Less code
    is more maintainable. Less overhead means more throughput, and so on. (Although
    in pursuing this way of coding, we do want to remind you to follow another famous
    quote from no less a thinker than Einstein: “Everything should be made as simple
    as possible, but no simpler.”) If you need only one or two classes from an external
    package, you can import exactly those classes. This makes your code a little more
    readable—others know exactly what classes you’ll be using.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，你经常会听到“少即是多”的最大。少量代码更易维护。少量开销意味着更高的吞吐量，等等。（尽管在追求这种编码方式时，我们确实要提醒您遵循爱因斯坦的另一句名言：“事物应该尽可能简单，但不应过于简单。”）如果你只需要来自外部包的一个或两个类，你可以精确导入这些类。这可以使你的代码更易读——其他人可以确切知道你将使用哪些类。
- en: 'Let’s reexamine that earlier snippet of `HelloJava`. We used a blanket import
    (more on that in the next section), but we could tighten things up a bit by importing
    just the classes we need, like so:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新审视之前 `HelloJava` 的片段。我们使用了全局导入（下一节会详细介绍），但我们可以通过仅导入我们需要的类来稍微优化一下，如下所示：
- en: '[PRE51]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This type of import setup is certainly more verbose, but again, it means anyone
    reading or compiling your code knows its exact dependencies. Many IDEs even have
    an “Optimize Imports” function that will automatically find those dependencies
    and list them individually. Once you get in the habit of listing and seeing these
    explicit imports, it is surprising how useful they become when orienting yourself
    in a new (or perhaps long-forgotten) class.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的导入设置显然更加冗长，但同样，它意味着任何阅读或编译你代码的人都知道它的确切依赖关系。许多集成开发环境甚至有一个“优化导入”功能，可以自动查找这些依赖关系并逐个列出。一旦你习惯了列出和看到这些明确的导入，你会惊讶地发现它们在定位自己在一个新的（或者说是长期遗忘的）类时是多么有用。
- en: Importing entire packages
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导入整个包
- en: 'Of course, not every package lends itself to individual imports. That same
    Swing package, `javax.swing`, is a great example. If you are writing a graphical
    desktop application, you’ll almost certainly use Swing—and lots and lots of its
    components. You can import every class in the package using the syntax we glossed
    over earlier:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，并非每个包都适合单独导入。同样是 Swing 包，`javax.swing` 就是一个很好的例子。如果你正在编写图形桌面应用程序，几乎肯定会使用
    Swing，以及大量的组件。你可以使用我们之前忽略的语法来导入包中的每个类：
- en: '[PRE52]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `*` is a sort of wildcard for class imports. This version of the `import`
    statement tells the compiler to have every class in the package ready to use.
    You’ll see this type of import quite often for many of the common Java packages,
    such as AWT, Swing, utilities, and I/O. Again, it works for any package, but where
    it makes sense to be more specific, you’ll gain some compile-time performance
    boosts and improve the readability of your code.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`*`是类导入的通配符。这种导入语句的版本告诉编译器准备好使用包中的每个类。你会经常看到这种类型的导入语句，例如AWT、Swing、utilities和I/O等常见Java包。再次强调，它适用于任何包，但在可以更具体的情况下，你将获得一些编译时性能提升，并提高代码的可读性。'
- en: Warning
  id: totrans-216
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: While it might seem natural for a wildcard `import` to include both the classes
    of the named package as well as the classes from any subpackages, Java does not
    allow recursive imports. If you need some classes from `java.awt` and some more
    classes from `java.awt.event`, you must supply separate `import` lines for each
    package.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管使用通配符`import`自然而然地包括命名包的类以及任何子包中的类，Java不允许递归导入。如果你需要一些来自`java.awt`的类和更多来自`java.awt.event`的类，你必须为每个包提供单独的`import`语句。
- en: Skipping imports
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跳过导入
- en: 'You have another option for using external classes from other packages—you
    can use their fully qualified names right in your code. For example, our `HelloJava`
    class used the `JFrame` and `JLabel` classes from the `javax.swing` package. We
    could import only the `JLabel` class if we wanted:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 你有另一种选择可以在你的代码中直接使用其他包的完全限定名称来使用外部类。例如，我们的`HelloJava`类使用了`javax.swing`包中的`JFrame`和`JLabel`类。如果需要，我们可以只导入`JLabel`类：
- en: '[PRE53]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This might seem overly verbose for one line where we create our frame, but in
    larger classes with already lengthy lists of imports, one-off usages can actually
    make your code more readable. Such a fully qualified entry often points to the
    sole use of this class within a file. If you were using that class many times,
    you would `import` it or its package. This type of full-name usage is never a
    requirement, but you will see it in the wild from time to time.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在我们创建框架的一行中显得过于冗长的情况，但在具有已经很长的导入列表的大类中，一次性的用法实际上可以使你的代码更易读。这种完全限定名称的使用通常指向文件中仅使用此类的情况。如果你多次使用该类，你将`import`它或其包。这种全名使用方式从不是必需的，但你偶尔会在现实中看到它。
- en: Custom Packages
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义包
- en: As you continue learning Java and write more code and solve larger problems,
    you will undoubtedly start to collect a larger and larger number of classes. You
    can use packages to help organize that collection. You use the `package` keyword
    to declare a custom package. You then place the file with your class inside a
    folder structure corresponding to the package name. As a quick reminder, packages
    use all lowercase names (by convention) separated by periods, such as in our graphical
    interface package, `javax.swing`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你继续学习Java并编写更多代码并解决更大的问题，无疑会开始积累越来越多的类。你可以使用包来帮助组织这些类。使用`package`关键字声明自定义包，然后将带有你的类的文件放置在与包名对应的文件夹结构中。作为一个快速提醒，包使用全小写名称（按约定）以句点分隔，例如我们的图形界面包`javax.swing`。
- en: 'Another convention applied widely to package names is something called “reverse
    domain name” naming. Apart from the packages associated directly with Java, third-party
    libraries and other contributed code are usually organized using the domain name
    of the company or individual’s email address. For example, the Mozilla Foundation
    has contributed a variety of Java libraries to the open source community. Most
    of those libraries and utilities will be in packages starting with Mozilla’s domain,
    *mozilla.org*, in reverse order: `org.mozilla`. This reverse naming has the handy
    (and intended) side effect of keeping the folder structure at the top fairly small.
    It is not uncommon for good-sized projects to use libraries from only the `com`
    and `org` top-level domains.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 包名的另一个广泛应用的约定是称为“反向域名”命名。除了与Java直接关联的包外，第三方库和其他贡献的代码通常使用公司或个人电子邮件地址的域名进行组织。例如，Mozilla基金会向开源社区贡献了各种Java库。大多数这些库和工具将位于以Mozilla的域名*mozilla.org*反向命名的包中：`org.mozilla`。这种反向命名有一个方便的（也是预期的）副作用，即保持顶层文件夹结构相对较小。对于使用来自`com`和`org`顶级域的库的好规模的项目来说，这并不少见。
- en: If you are building your own packages separate from any company or contract
    work, you can use your email address and reverse it, similar to company domain
    names. Another popular option for code distributed online is to use the domain
    of your hosting provider. GitHub, for example, hosts many, *many* Java projects
    for hobbyists and enthusiasts. You might create a package named `com.github.myawesomeproject`
    (where `myawesomeproject` would obviously be replaced by your actual project name).
    Be aware that repositories at sites like GitHub often allow names that are not
    valid in package names. You might have a repo named `my-awesome-project`, but
    dashes are not allowed in any portion of a package name. Often such illegal characters
    are simply omitted to create a valid name.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在自己的项目中构建包，与任何公司或合同工作无关，你可以使用你的电子邮件地址，并进行反向，类似于公司域名。另一个在线分发代码的流行选项是使用你的托管提供商的域名。例如，GitHub
    托管了许多，*许多* Java 爱好者和爱好者的项目。你可能会创建一个名为`com.github.myawesomeproject`的包（其中`myawesomeproject`显然应替换为你的实际项目名称）。请注意，像
    GitHub 这样的网站上的存储库通常允许在包名称中不合法的名称。你可能有一个名为`my-awesome-project`的存储库，但在包名称的任何部分中都不允许使用破折号。通常这些非法字符会被简单地省略以创建一个有效的名称。
- en: You may have already noticed we placed the various examples from this book in
    packages. While organizing classes *within* packages is a woolly topic with no
    great best practices available, we’ve taken an approach designed to make the examples
    easy to locate as you’re reading the book. For any complete examples in a chapter,
    you’ll see a package like `ch05.examples`. For the ongoing game example, we use
    a `game` subpackage. We put the end-of-chapter exercises in `ch05.exercises`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们将这本书中的各种示例放在了包中。虽然在包内组织类 *内部* 是一个毫无明确最佳实践的难题，但我们采取了一种方法，旨在使读者在阅读书籍时能轻松找到示例。对于每一章的完整示例，你会看到一个像`ch05.examples`这样的包。对于正在进行的游戏示例，我们使用了一个`game`子包。我们将章节末尾的练习放在了`ch05.exercises`中。
- en: Note
  id: totrans-227
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: When you compile a packaged class, you need to tell the compiler where the actual
    file resides within the filesystem, so you use its path, with the package elements
    separated by your filesystem separator (typically `/` or `\`). When you run a
    packaged class, on the other hand, you specify its fully qualified, dot-separated
    name.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编译一个打包的类时，你需要告诉编译器实际文件在文件系统中的位置，因此你使用它的路径，路径元素之间用你的文件系统分隔符（通常是`/`或`\`）分隔开。另一方面，当你运行一个打包的类时，你指定它的完全限定的，点分隔的名称。
- en: If you are using an IDE, it will happily manage these package issues for you.
    Simply create and organize your classes and continue to identify the main class
    that kicks off your program.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是一个集成开发环境（IDE），它将很高兴为你管理这些包问题。只需创建和组织你的类，并继续识别启动你程序的主类。
- en: Member Visibility and Access
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 成员可见性和访问
- en: We’ve talked a bit about the access modifiers you can use when declaring variables
    and methods. Making something `public` means anyone, anywhere, can see your variable
    or call your method. Making something `protected` means any subclass can access
    the variable, call the method, or override the method to provide some alternate
    functionality more appropriate to your subclass. The `private` modifier means
    the variable or method is available only within the class itself.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经谈到了在声明变量和方法时可以使用的访问修饰符。将某些内容设置为`public`意味着任何地方都可以看到你的变量或调用你的方法。将某些内容设置为`protected`意味着任何子类都可以访问变量，调用方法，或者重写方法，以提供适合你子类的替代功能。`private`修饰符表示该变量或方法仅在类本身内部可用。
- en: Packages affect `protected` members. In addition to being accessible by any
    subclass, such members are visible and can be overridden by other classes in the
    same package. Packages also come into play if you leave off the modifier altogether.
    Consider some example text components in the custom package `mytools.text`, as
    shown in [Figure 5-4](#learnjava6-CHP-5-FIG-4).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 包影响`protected`成员。除了可以被任何子类访问外，这些成员还可被同一包中的其他类看到和重写。如果你完全省略修饰符，包也会起作用。考虑一些自定义包`mytools.text`中的示例文本组件，如[图 5-4](#learnjava6-CHP-5-FIG-4)所示。
- en: '![ljv6 0504](assets/ljv6_0504.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0504](assets/ljv6_0504.png)'
- en: Figure 5-4\. Packages and class visibility
  id: totrans-234
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-4\. 包和类的可见性
- en: The class `TextComponent` has no modifier. It has *default* visibility or “package
    private” visibility. This means that other classes *in the same package* can access
    the class, but any classes outside the package cannot. This can be very useful
    for implementation-specific classes or internal helpers. You can use the package
    private elements freely in building your code, but other programmers can use only
    your `public` and `protected` elements. [Figure 5-5](#learnjava6-CHP-5-FIG-5)
    shows more details, with both subclasses and external classes using variables
    and methods for a sample class.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 类`TextComponent`没有修饰符。它具有*默认*可见性或“包私有”可见性。这意味着同一包中的其他类可以访问该类，但是包外的任何类都不能访问。这对于特定于实现的类或内部辅助类非常有用。您可以在构建代码时自由使用包私有元素，但其他程序员只能使用您的`public`和`protected`元素。[图5-5](#learnjava6-CHP-5-FIG-5)显示了更多细节，包括子类和外部类使用示例类的变量和方法。
- en: '![ljv6 0505](assets/ljv6_0505.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0505](assets/ljv6_0505.png)'
- en: Figure 5-5\. Packages and member visibility
  id: totrans-237
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-5\. 包和成员可见性
- en: Notice that extending the `TextArea` class gives you access to the public `getText()`
    and `setText()` methods as well as the `protected` method `formatText()`. But
    `MyTextDisplay` (more on subclasses and `extends` shortly in [“Subclassing and
    Inheritance”](#learnjava6-CHP-5-SECT-6.1)) does not have access to the package-private
    variable `linecount`. Within the `mytools.text` package where we create the `TextEditor`
    class, however, we can get to `linecount` as well as those methods that are `public`
    or `protected`. Our internal storage for the content, `text`, remains private
    and unavailable to anyone other than the `TextArea` class itself.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，扩展`TextArea`类可以让您访问公共的`getText()`和`setText()`方法，以及`protected`方法`formatText()`。但是`MyTextDisplay`（稍后在[“子类化和继承”](#learnjava6-CHP-5-SECT-6.1)中详细介绍）无法访问包私有变量`linecount`。然而，在我们创建`TextEditor`类的`mytools.text`包中，我们可以访问`linecount`以及那些是`public`或`protected`的方法。我们用于存储内容的内部变量`text`保持私有，除了`TextArea`类本身之外，其他任何人都无法访问它。
- en: '[Table 5-2](#learnjava6-CHP-5-TABLE-2) summarizes the levels of visibility
    available in Java; it runs generally from most to least restrictive. Methods and
    variables are always visible within a declaring class itself, so the table doesn’t
    address that scope.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '[表格5-2](#learnjava6-CHP-5-TABLE-2)总结了Java中可用的可见性级别；一般情况下从最严格到最不严格的顺序排列。方法和变量始终在声明类内部可见，因此该表不涉及该范围。'
- en: Table 5-2\. Visibility modifiers
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 表5-2\. 可见性修饰符
- en: '| Modifier | Visibility outside the class |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| 修饰符 | 类外可见性 |'
- en: '| --- | --- |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `private` | None |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| `private` | 无 |'
- en: '| No modifier (default) | Classes in the package |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| 无修饰符（默认） | 包内的类 |'
- en: '| `protected` | Classes in package and subclasses inside or outside the package
    |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| `protected` | 包内和包外子类 |'
- en: '| `public` | All classes |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| `public` | 所有类 |'
- en: Compiling with Packages
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用包编译
- en: 'You’ve already seen a few examples of using a fully qualified class name to
    compile a simple example. If you’re not using an IDE, you have other options available
    to you. For example, you may wish to compile all of the classes in a given package.
    If so, you can do this:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到了使用完全限定的类名编译简单示例的几个示例。如果您不使用IDE，还有其他选项可供选择。例如，您可能希望编译给定包中的所有类。如果是这样，您可以这样做：
- en: '[PRE54]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Note that for commercial applications, you often see more complex package names
    that include multiple segments. As we mentioned earlier, a common practice is
    to reverse the internet domain name of your company. For example, this book from
    O’Reilly might more appropriately use a full package prefix such as `com.oreilly.learningjava6e`.
    Each chapter would be a subpackage under that prefix. Compiling and running classes
    in such packages is fairly straightforward, if a bit wordy:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于商业应用程序，您经常会看到包含多个段的更复杂的包名称。正如我们之前提到的，一个常见做法是反转公司的互联网域名。例如，O’Reilly的这本书可能更适合使用类似于`com.oreilly.learningjava6e`的完整包前缀。每个章节将是该前缀下的一个子包。在这些包中编译和运行类非常简单，只是有点啰嗦：
- en: '[PRE55]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The *javac* command also understands basic class dependency. If your main class
    uses a few other classes in the same source hierarchy—even if they are not all
    in the same package—compiling that main class will “pick up” the other, dependent
    classes and compile them as well.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '*javac*命令还了解基本的类依赖关系。如果您的主类使用同一源代码层次结构中的几个其他类，即使它们不都在同一个包中，编译该主类也会“捎带”其他依赖类并将它们一起编译。'
- en: 'Beyond simple programs with a few classes in a single package, though, you
    really are more likely to rely on your IDE or a build management tool such as
    Gradle or Maven. Those tools are outside the scope of this book, but there are
    many references for them online. Maven in particular is popular for managing large
    projects with many dependencies. See [*Maven: The Definitive Guide*](https://oreil.ly/ya4DY)
    (O’Reilly) by Maven creator Jason Van Zyl and his team at Sonatype for a true
    exploration of the features and capabilities of this powerful tool.^([6](ch05.html#id1217))'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '虽然简单程序中可能只有一个包中的几个类，但实际上更可能依赖于你的 IDE 或诸如 Gradle 或 Maven 等构建管理工具。这些工具超出了本书的范围，但在线上有很多关于它们的参考资料。特别是
    Maven，它在管理具有许多依赖的大型项目方面非常流行。请参阅[*Maven: The Definitive Guide*](https://oreil.ly/ya4DY)（O’Reilly），由
    Maven 的创始人 Jason Van Zyl 及其 Sonatype 团队撰写，详细探讨这一强大工具的功能和能力。^([6](ch05.html#id1217))'
- en: Advanced Class Design
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级类设计
- en: 'You may recall from [“HelloJava2: The Sequel”](ch02.html#learnjava6-CHP-2-SECT-3)
    that we had two classes in the same file. That simplified the writing and compiling
    process but didn’t grant either class any special access to the other. As you
    start thinking about more complex problems, you will encounter cases where more
    advanced class design that does grant special access is not just handy but critical
    to writing maintainable code.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '你可能还记得在 [“HelloJava2: The Sequel”](ch02.html#learnjava6-CHP-2-SECT-3) 中，我们在同一个文件中有两个类。这简化了编写和编译过程，但并没有赋予任何一个类对另一个类的特殊访问权限。当你开始思考更复杂的问题时，你会遇到更高级的类设计，它不仅仅是方便，而且是编写可维护代码的关键。'
- en: Subclassing and Inheritance
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子类化与继承
- en: 'Classes in Java exist in a hierarchy. You can declare a class in Java as a
    *subclass* of another class using the `extends` keyword. A subclass *inherits*
    variables and methods from its *superclass* and can use them as if they were declared
    within the subclass itself:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: Java 中的类存在层次结构。你可以使用 `extends` 关键字在 Java 中声明一个类作为另一个类的*子类*。子类从其*超类*那里*继承*变量和方法，并且可以像在子类内部声明的一样使用它们：
- en: '[PRE56]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In this example, an object of type `Mammal` has both the instance variable `weight`
    and the method `eat()`. They are inherited from `Animal`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，类型为 `Mammal` 的对象同时具有实例变量 `weight` 和方法 `eat()`，它们是从 `Animal` 继承而来的。
- en: A class can *extend* only one other class. To use the proper terminology, Java
    allows *single inheritance* of a class implementation. Later in this chapter,
    we’ll talk about interfaces, which take the place of *multiple inheritance* found
    in other languages.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类只能*扩展*另一个类。使用正确的术语，Java 允许对类实现*单继承*。本章后面我们将讨论接口，它们取代了其他语言中的*多继承*。
- en: 'A subclass can be further subclassed. Normally, subclassing specializes or
    refines a class by adding variables and methods (you cannot remove or hide variables
    or methods by subclassing). For example:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 子类可以进一步被子类化。通常情况下，通过子类化可以通过添加变量和方法来专门化或改进类（不可以通过子类化移除或隐藏变量或方法）。例如：
- en: '[PRE57]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The `Cat` class is a type of `Mammal` that is ultimately a type of `Animal`.
    `Cat` objects inherit all the characteristics of `Mammal` objects and, in turn,
    `Animal` objects. `Cat` also provides additional behavior in the form of the `purr()`
    method and the `longHair` variable. We can denote the class relationship in a
    diagram, as shown in [Figure 5-6](#learnjava6-CHP-5-FIG-6).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cat` 类是 `Mammal` 的一种类型，最终是 `Animal` 的一种类型。`Cat` 对象继承了 `Mammal` 对象的所有特征，并且进而继承了
    `Animal` 对象的特征。此外，`Cat` 还通过 `purr()` 方法和 `longHair` 变量提供了额外的行为。我们可以在图示中表示类之间的关系，如
    [Figure 5-6](#learnjava6-CHP-5-FIG-6) 所示。'
- en: '![ljv6 0506](assets/ljv6_0506.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0506](assets/ljv6_0506.png)'
- en: Figure 5-6\. A class hierarchy
  id: totrans-265
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-6\. 类层次结构
- en: 'A subclass inherits all members of its superclass not designated as `private`.
    As we’ll discuss shortly, other levels of visibility affect which inherited members
    of the class can be seen from outside of the class and its subclasses, but at
    a minimum, a subclass always has the same set of visible members as its parent.
    For this reason, the type of a subclass can be considered a *subtype* of its parent,
    and instances of the subtype can be used anywhere instances of the supertype are
    allowed. Consider the following example:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 子类继承其超类中未标记为 `private` 的所有成员。正如我们即将讨论的那样，其他可见性级别影响了类的继承成员能否从类外部及其子类中看到，但至少，子类始终具有与其父类相同的可见成员集合。因此，子类的类型可以被视为其父类的*子类型*，子类型的实例可以在任何允许使用父类型实例的地方使用。考虑以下示例：
- en: '[PRE58]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `Cat` instance `simon` in this example can be assigned to the `Animal` type
    variable `creature` because `Cat` is a subtype of `Animal`. Similarly, any method
    accepting an `Animal` object would accept an instance of a `Cat` or any `Mammal`
    type as well. This is an important aspect of polymorphism in an object-oriented
    language such as Java. We’ll see how it can be used to refine a class’s behavior,
    as well as add new capabilities to it.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`Cat` 实例 `simon` 可以赋值给 `Animal` 类型变量 `creature`，因为 `Cat` 是 `Animal` 的子类型。同样地，接受
    `Animal` 对象的任何方法也将接受 `Cat` 实例或任何 `Mammal` 类型的实例。这是面向对象语言如 Java 中多态性的重要方面。我们将看到它如何用于细化类的行为，以及为其添加新的能力。
- en: Shadowed variables
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 阴影变量
- en: We have seen that a local variable of the same name as an instance variable
    *shadows* (hides) the instance variable. Similarly, an instance variable in a
    subclass can shadow an instance variable of the same name in its parent class,
    as shown in [Figure 5-7](#learnjava6-CHP-5-FIG-7).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，与实例变量同名的局部变量会*遮蔽*（隐藏）实例变量。类似地，子类中的实例变量可以遮蔽其父类中同名的实例变量，如 [图 5-7](#learnjava6-CHP-5-FIG-7)
    所示。
- en: '![ljv6 0507](assets/ljv6_0507.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0507](assets/ljv6_0507.png)'
- en: Figure 5-7\. The scope of shadowed variables
  id: totrans-272
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-7\. 阴影变量的作用域
- en: 'The variable `weight` is declared in three places: as a local variable in the
    method `foodConsumption()` of the class `Mammal`, as an instance variable of the
    class `Mammal` itself, and as an instance variable of the class `Animal`. The
    actual variable you would reference in the code would depend on the scope in which
    you are working and how you qualify the reference to it.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `weight` 在三个地方声明：作为 `Mammal` 类的 `foodConsumption()` 方法中的局部变量，作为 `Mammal`
    类本身的实例变量，以及作为 `Animal` 类的实例变量。您在代码中引用的实际变量将取决于您正在工作的作用域以及您如何限定对它的引用。
- en: In the previous example, all variables were of the same type. A slightly more
    plausible use of shadowed variables would involve changing their types. We could,
    for example, shadow an `int` variable with a `double` variable in a subclass that
    needs decimal values instead of integer values. We can do this without changing
    the existing code because, as its name suggests, when we shadow variables, we
    don’t replace them but rather mask them instead. Both variables still exist; methods
    of the superclass see the original variable, and methods of the subclass see the
    new version. What variables the various methods see is determined at compile time.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，所有变量都是相同类型的。稍微更有可能的使用阴影变量的情况是改变它们的类型。例如，我们可以在需要十进制值而不是整数值的子类中用 `double`
    变量来阴影 `int` 变量。我们可以在不改变现有代码的情况下做到这一点，因为顾名思义，当我们阴影变量时，我们并不是替换它们，而是遮蔽它们。两个变量仍然存在；超类的方法看到原始变量，子类的方法看到新版本。各种方法看到的变量是在编译时确定的。
- en: 'Here’s a simple example:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的例子：
- en: '[PRE59]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In this example, we shadow the instance variable `sum` to change its type from
    `int` to `double`.^([7](ch05.html#id1222)) Methods defined in the class `IntegerCalculator`
    see the integer variable `sum`, while methods defined in `DecimalCalculator` see
    the floating-point variable `sum`. However, both variables actually exist for
    a given instance of `DecimalCalculator`, and they can have independent values.
    In fact, any methods that `DecimalCalculator` inherits from `IntegerCalculator`
    actually see the integer variable `sum`. If that sounds confusing—it certainly
    can be. Shadowing is something you should avoid when possible. But it isn’t always
    possible to avoid, so we want to make sure you have seen some examples, albeit
    contrived ones.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们阴影实例变量 `sum`，将其类型从 `int` 改变为 `double`。类 `IntegerCalculator` 中定义的方法看到整数变量
    `sum`，而类 `DecimalCalculator` 中定义的方法看到浮点数变量 `sum`。然而，对于给定的 `DecimalCalculator`
    实例，这两个变量都是实际存在的，并且它们可以具有独立的值。事实上，`DecimalCalculator` 继承自 `IntegerCalculator` 的任何方法实际上看到整数变量
    `sum`。如果这听起来令人困惑——确实如此。在可能的情况下，应避免使用阴影。但是并非总是能够避免，所以我们希望确保您已经看到了一些例子，尽管有些有点牵强。
- en: 'Because both variables exist in `DecimalCalculator`, we need a way to reference
    the variable inherited from `IntegerCalculator`. We do that using the `super`
    keyword as a qualifier on the reference:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `DecimalCalculator` 中存在这两个变量，我们需要一种方法来引用从 `IntegerCalculator` 继承的变量。我们可以使用
    `super` 关键字作为引用的限定符：
- en: '[PRE60]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Inside of `DecimalCalculator`, the `super` keyword used in this manner selects
    the `sum` variable defined in the superclass. We’ll explain the use of `super`
    more fully in a bit.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `DecimalCalculator` 中，以这种方式使用的 `super` 关键字选择了在超类中定义的 `sum` 变量。我们稍后将更详细地解释
    `super` 的用法。
- en: 'Another important point about shadowed variables has to do with how they work
    when we refer to an object by way of a less derived type (a parent type). For
    example, we can refer to a `DecimalCalculator` object as an `IntegerCalculator`
    by using it via a variable of type `IntegerCalculator`. If we do so and then access
    the variable `sum`, we get the integer variable, not the decimal one:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 关于遮蔽变量的另一个重要观点是，当我们通过一个不太派生的类型（父类型）的变量引用对象时，它们的工作方式是如何的。例如，我们可以通过一个`IntegerCalculator`类型的变量来引用一个`DecimalCalculator`对象。如果我们这样做，然后访问变量`sum`，我们得到的是整数变量，而不是小数变量：
- en: '[PRE61]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The same would be true if we accessed the object using an explicit cast to the
    `IntegerCalculator` type or when passing an instance into a method that accepts
    that parent type.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用显式转换到`IntegerCalculator`类型来访问对象，或者将实例传递给接受该父类型的方法时，情况也是如此。
- en: To reiterate, the usefulness of shadowed variables is limited. It’s much better
    to abstract the use of variables like this in other ways than to use tricky scoping
    rules. However, it’s important to understand the concepts here before we talk
    about doing the same thing with methods. We’ll see a different and more dynamic
    type of behavior when methods shadow other methods, or to use the correct terminology,
    *override* other methods. Overriding methods in a subclass is quite common and
    can be very powerful.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 重申一下，变量的遮蔽使用是有限的。在其他方面，抽象化变量的使用比使用复杂的作用域规则要好得多。然而，在我们讨论如何使用方法做同样的事情之前，理解这里的概念是很重要的。当方法遮蔽其他方法或者用正确的术语说，*重写*其他方法时，我们会看到一种不同而且更动态的行为。在子类中重写方法非常常见且非常强大。
- en: Overriding methods
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法重写
- en: We have seen that we can declare overloaded methods (methods with the same name
    but a different number or type of arguments) within a class. Overloaded method
    selection works in the way we described on all methods available to a class, including
    inherited ones. This means that a subclass can define additional overloaded methods
    that add to the overloaded methods provided by a superclass.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到我们可以在一个类中声明重载的方法（具有相同名称但不同数量或类型的参数的方法）。重载方法的选择方式与我们在类中描述的方式一样，包括继承的方法。这意味着子类可以定义额外的重载方法，以补充超类提供的重载方法。
- en: A subclass can do more than that; it can define a method that has exactly the
    *same* method signature (name and argument types) as a method in its superclass.
    In that case, the method in the subclass *overrides* the method in the superclass
    and effectively replaces its implementation, as shown in [Figure 5-8](#learnjava6-CHP-5-FIG-8).
    Overriding methods to change the behavior of objects is called *subtype polymorphism*.
    It’s the usage most people think of when they talk about the power of object-oriented
    languages.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 子类不仅可以这样做；它还可以定义一个与其超类中方法签名（名称和参数类型）完全相同的方法。在这种情况下，子类中的方法会覆盖超类中的方法，并有效地替换其实现，如图[5-8](#learnjava6-CHP-5-FIG-8)所示。通过重写方法来改变对象行为被称为*子类型多态性*。这是大多数人在谈论面向对象语言的强大功能时所考虑的用法。
- en: '![ljv6 0508](assets/ljv6_0508.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0508](assets/ljv6_0508.png)'
- en: Figure 5-8\. Method overriding
  id: totrans-289
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-8\. 方法重写
- en: In [Figure 5-8](#learnjava6-CHP-5-FIG-8), `Mammal` overrides the `reproduce()`
    method of `Animal`, perhaps to specialize the method for the behavior of mammals
    giving birth to live young.^([8](ch05.html#id1233)) The `Cat` object’s sleeping
    behavior is also overridden to be different from that of a general `Animal`, perhaps
    to accommodate catnaps. The `Cat` class also adds the more unique behaviors of
    purring and hunting mice.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在图[5-8](#learnjava6-CHP-5-FIG-8)中，`Mammal`重写了`Animal`的`reproduce()`方法，可能是为了将方法专门化为哺乳动物生产活仔的行为。`Cat`对象的睡眠行为也被重写，以与一般`Animal`的不同，可能是为了适应猫的小睡。`Cat`类还增加了更独特的行为，如咕噜声和捕猎老鼠。
- en: From what you’ve seen so far, overridden methods probably look like they shadow
    methods in superclasses, just as variables do. But overridden methods are actually
    more powerful than that. When there are multiple implementations of a method in
    the inheritance hierarchy of an object, the one in the “most derived” class (the
    furthest down the hierarchy) always overrides the others, even if we refer to
    the object through a reference of one of the superclass types.^([9](ch05.html#id1234))
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 从你目前看到的内容来看，重写方法可能看起来像是在超类中遮蔽方法，就像变量一样。但是重写的方法实际上比这更强大。当对象在其继承层次结构中具有多个方法实现时，位于“最派生”类中（层次结构最低端）的方法始终会重写其他方法，即使我们通过一个超类类型的引用来引用对象。^([9](ch05.html#id1234))
- en: 'For example, if we have a `Cat` instance assigned to a variable of the more
    general type `Animal`, and we call its `sleep()` method, we still get the `sleep()`
    method implemented in the `Cat` class, not the one in `Animal`:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们有一个`Cat`实例分配给一个更一般类型`Animal`的变量，并且我们调用它的`sleep()`方法，我们仍然得到`Cat`类中实现的`sleep()`方法，而不是`Animal`类中的方法：
- en: '[PRE62]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In other words, for purposes of behavior (invoking methods), a `Cat` acts like
    a `Cat`, regardless of whether you refer to it as such. You might remember that
    accessing a shadowed variable through our `Animal` variable `creature` would find
    that variable in the `Animal` class, not the `Cat` class. However, because methods
    are located *dynamically*, searching subclasses first, the runtime will invoke
    the appropriate method in the `Cat` class, even though we are treating it more
    generally as an `Animal` object. This means that the *behavior* of objects is
    dynamic. We can deal with specialized objects as if they were more general types
    and still take advantage of their specialized implementations of behavior.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，对于行为（调用方法）来说，一个`Cat`表现得像一个`Cat`，无论你是否将其称为这样。你可能记得，通过我们的`Animal`变量`creature`访问一个被屏蔽的变量将在`Animal`类中找到该变量，而不是`Cat`类中。然而，因为方法是*动态定位*的，首先搜索子类，运行时会调用`Cat`类中适当的方法，即使我们将其更一般地视为`Animal`对象。这意味着对象的*行为*是动态的。我们可以将专门的对象处理为更一般的类型，并且仍然利用它们的行为专用实现。
- en: Abstract Classes and Methods
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象类和方法
- en: 'Sometimes you don’t have a good default behavior for a method. Think about
    how animals communicate. Dogs bark. Cats meow. Cows moo. There really is no standard
    sound. In Java, you can create an *abstract* method that defines exactly what
    a method should look like, without specifying any particular behavior. You use
    the `abstract` modifier when declaring the method. And rather than providing a
    body, you simply end the definition with a semicolon. Consider a `makeSound()`
    method for our animals:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你没有一个好的默认行为来实现一个方法。想想动物如何交流。狗会叫。猫会喵。牛会哞。实际上没有标准的声音。在Java中，你可以创建一个*抽象*方法来精确定义一个方法应该如何看起来，而不指定任何特定的行为。在声明方法时使用`abstract`修饰符。而不是提供方法体，你只需在定义末尾加上一个分号。考虑我们动物的`makeSound()`方法：
- en: '[PRE63]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Notice that our method to make a sound has a complete signature (recall [“Running
    Java Applications”](ch03.html#learnjava6-CHP-3-SECT-3)). It is `void` (it has
    no return value), and it takes one argument of type `int`. But it has no body.
    This type of method is explicitly designed to be overridden. You cannot call an
    abstract method; you’ll get a compile-time error. You must create a new subclass
    that provides the logic for the abstract method before you can use it:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们制作声音的方法有一个完整的签名（回顾[“运行Java应用程序”](ch03.html#learnjava6-CHP-3-SECT-3)）。它是`void`（没有返回值），并且接受一个`int`类型的参数。但是它没有方法体。这种类型的方法明确设计为被覆盖。你不能调用一个抽象方法；你会得到一个编译时错误。在你可以使用它之前，你必须创建一个提供抽象方法逻辑的新子类：
- en: '[PRE64]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: With an instance of `Cat`, we can now call the `makeSound()` method and the
    compiler knows what to do. But because `Animal` now contains an abstract method,
    we can’t create an instance of that class. To use `Animal` we have to create a
    subclass and fill out `makeSound()` like we did with our `Cat`.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个`Cat`的实例，我们可以调用`makeSound()`方法，编译器知道该怎么做了。但是因为`Animal`现在包含一个抽象方法，我们不能创建该类的实例。要使用`Animal`，我们必须创建一个子类并像我们的`Cat`一样填写`makeSound()`。
- en: 'In fact, if we do include an abstract method in our class, we also have to
    declare the class itself as abstract. Our snippet of `Animal` above would not
    compile. We use the same `abstract` keyword for the class:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，如果我们在我们的类中包含一个抽象方法，我们还必须将该类本身声明为抽象。我们上面的`Animal`片段将不能编译。我们在类声明时使用相同的`abstract`关键字：
- en: '[PRE65]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This declaration tells the compiler (and other developers) that you designed
    this class to be part of a larger program. You expect (actually, require) subclasses
    to extend your abstract class and fill in any missing details. Those subclasses,
    in turn, can be instantiated and can do real work.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 此声明告诉编译器（和其他开发人员），你设计这个类来作为一个更大程序的一部分。你期望（事实上，要求）子类扩展你的抽象类并填补任何缺失的细节。这些子类反过来可以被实例化并且可以执行真正的工作。
- en: 'Abstract classes can still contain typical, complete-with-body methods, too.
    In the case of `Animal`, for example, we could add some helper methods for the
    animal’s weight:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类仍然可以包含典型的、带有方法体的方法。例如，对于`Animal`，我们可以添加一些动物体重的帮助方法：
- en: '[PRE66]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This is common and a good design practice. Your `Animal` class contains as much
    of the basic, shared information and behavior as possible. But for things that
    are not shared, you create a subclass with the desired traits and actions.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种常见且良好的设计实践。你的`Animal`类包含尽可能多的基本共享信息和行为。但是对于不共享的事物，你可以创建一个具有所需特性和操作的子类。
- en: Interfaces
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口
- en: Java expands on the concept of abstract methods with interfaces. It’s often
    desirable to specify a group of abstract methods defining some behavior for an
    object without tying it to any implementation at all. In Java, this is called
    an *interface*. An interface defines a set of methods that a class must implement.
    A class in Java can declare that it *implements* an interface if it implements
    the required methods. Unlike extending an abstract class, a class implementing
    an interface doesn’t have to inherit from any particular part of the inheritance
    hierarchy or use a particular implementation.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: Java通过接口扩展了抽象方法的概念。通常希望指定一组抽象方法来定义对象的某种行为，而不将其与任何具体实现绑定。在Java中，这称为*接口*。接口定义了一个类必须实现的一组方法。在Java中，如果一个类实现了所需的方法，它可以声明它*implements*一个接口。与扩展抽象类不同，实现接口的类不必继承自继承层次结构的任何特定部分或使用特定实现。
- en: Interfaces are kind of like Scouting merit badges. A scout who has learned to
    build a birdhouse can walk around wearing a cloth patch or sash with a picture
    of one. This says to the world, “I know how to build a birdhouse.” Similarly,
    an interface is a list of methods that define some set of behavior for an object.
    Any class that implements each method listed in the interface can declare at compile
    time that it implements the interface and wear, as its merit badge, an extra type—the
    interface’s type.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 接口有点像童子军的徽章。一个学会如何建造鸟屋的童子军可以穿着一个带有鸟屋图案的布贴或肩带四处走动。这向世界宣告：“我知道如何建造鸟屋。”同样，接口是为对象定义一组行为的方法列表。实现接口中列出的每个方法的任何类都可以在编译时声明它实现了该接口，并且佩戴一种额外的类型——接口的类型，作为它的徽章。
- en: '*Interface types* act like class types. You can declare variables to be of
    an interface type, you can declare arguments of methods to accept interface types,
    and you can specify that the return type of a method is an interface type. In
    each case, you’re saying that any object that implements the interface (i.e.,
    wears the right merit badge) can fill that role. In this sense, interfaces are
    orthogonal to the class hierarchy. They cut across the boundaries of what kind
    of object an item *is* and deal with it only in terms of what it can *do*. You
    can implement as many interfaces as you need for any given class. Interfaces in
    Java replace much of the need for multiple inheritance in other languages (and
    all the messy complications that come from true multiple inheritance).'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '*接口类型*就像类类型。你可以声明变量为接口类型，可以声明方法的参数接受接口类型，也可以指定方法的返回类型为接口类型。在每种情况下，你都在说任何实现接口的对象（即佩戴了正确徽章的对象）都可以担任这个角色。在这个意义上，接口与类层次结构是正交的。它们跨越了一个物品属于什么类型的界限，而是仅通过它可以做什么来处理它。你可以为任何给定的类实现尽可能多的接口。Java中的接口在其他语言中大部分需要多重继承的需求（以及真正的多重继承所带来的混乱复杂性）都得到了解决。'
- en: 'An interface looks, essentially, like a purely `abstract` class (a class with
    *only* `abstract` methods). You define an interface with the `interface` keyword
    and list its methods with no bodies, just prototypes (signatures):'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 接口在本质上看起来像一个纯`abstract`类（只有`abstract`方法的类）。你使用`interface`关键字定义一个接口，并列出它的方法，但不带有任何具体内容，只有原型（签名）：
- en: '[PRE67]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The previous example defines an interface called `Driveable` with four methods.
    It’s acceptable, but not necessary, to declare the methods in an interface with
    the `abstract` modifier; we haven’t done that here. More importantly, the methods
    of an interface are always considered `public`, and you can optionally declare
    them as so. Why public? Well, the user of the interface wouldn’t necessarily be
    able to see them otherwise, and interfaces are generally intended to describe
    the behavior of an object, not its implementation.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子定义了一个名为`Driveable`的接口，其中包含四个方法。这是可以接受的，但不是必须的，将接口中的方法声明为`abstract`修饰符；我们在这里没有这样做。更重要的是，接口的方法始终被视为`public`，你可以选择将它们声明为`public`。为什么是`public`？因为接口的使用者否则可能看不到它们，并且接口通常旨在描述对象的行为，而不是其实现方式。
- en: 'Interfaces define capabilities, so it’s common to name interfaces after their
    capabilities. `Driveable`, `Runnable`, and `Updateable` are good interface names.
    Any class that implements all the methods can then declare that it implements
    the interface by using a special `implements` clause in its class definition.
    For example:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 接口定义了能力，因此通常根据它们的能力命名接口是很常见的。`Driveable`、`Runnable`和`Updateable`是很好的接口名称。任何实现了所有方法的类都可以通过在其类定义中使用特殊的`implements`子句声明它实现了该接口。例如：
- en: '[PRE68]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Here, the class `Automobile` implements the methods of the `Driveable` interface
    and declares itself a type of `Driveable` using the `implements` keyword.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，类`Automobile`实现了`Driveable`接口的方法，并使用`implements`关键字声明自己是`Driveable`类型。
- en: As shown in [Figure 5-9](#learnjava6-CHP-5-FIG-9), another class, such as `Lawnmower`,
    can also implement the `Driveable` interface. The figure illustrates the `Driveable`
    interface being implemented by two different classes. While it’s possible that
    both `Automobile` and `Lawnmower` could derive from some primitive kind of vehicle,
    they don’t have to in this scenario.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如图[5-9](#learnjava6-CHP-5-FIG-9)所示，另一个类，如`Lawnmower`，也可以实现`Driveable`接口。该图示例了`Driveable`接口被两个不同类实现的情况。虽然`Automobile`和`Lawnmower`可能都来源于某种原始类型的车辆，但在这种情况下并非如此。
- en: '![ljv6 0509](assets/ljv6_0509.png)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0509](assets/ljv6_0509.png)'
- en: Figure 5-9\. Implementing the `Driveable` interface
  id: totrans-319
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-9\. 实现`Driveable`接口
- en: 'After declaring the interface, we have a new type, `Driveable`. We can declare
    variables of type `Driveable` and assign them any instance of a `Driveable` object:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明接口之后，我们有了一个新的类型，`Driveable`。我们可以声明`Driveable`类型的变量，并分配任何`Driveable`对象的实例：
- en: '[PRE69]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Both `Automobile` and `Lawnmower` implement `Driveable`, so they can be considered
    interchangeable objects of that type.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`Automobile`和`Lawnmower`都实现了`Driveable`，因此它们可以被视为该类型的可互换对象。'
- en: As we mentioned earlier, interfaces play a critical role in Java’s power and
    popularity. We will be using them throughout the remaining chapters. If they don’t
    quite make sense, keep reading and working on the code exercises. You’ll get much
    more practice with them. Practice doesn’t always make perfect, but it definitely
    does make something less weird and opaque.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，接口在Java的功能和流行性中起着至关重要的作用。我们将在剩余的章节中一直使用它们。如果它们还不太明白，请继续阅读并继续进行代码练习。你将会更多地通过实践来掌握它们。练习并不总是能够达到完美，但它确实会使某些东西变得不那么奇怪和晦涩。
- en: Inner Classes
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内部类
- en: All of the classes we’ve seen so far in this book have been *top-level*, “freestanding”
    classes declared at the file and package level. But classes in Java can actually
    be declared at any level of scope, within any set of curly braces—in other words,
    almost anywhere that you could put any other Java statement. These *inner classes*
    belong to another class or method as a variable would and may have their visibility
    limited to its scope in the same way.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 所有我们在本书中到目前为止看到的类都是*顶级*的，“独立的”类，它们在文件和包级别声明。但是在Java中，类实际上可以在任何作用域级别声明，在任何花括号中——换句话说，几乎可以放置任何其他Java语句的地方。这些*内部类*作为变量一样属于另一个类或方法，并且其可见性可能被限制在其范围内。
- en: Inner classes are a useful and aesthetically pleasing facility for structuring
    code. Their cousins, *anonymous inner classes*, are an even more powerful shorthand
    that make it seem as if you can create new kinds of objects dynamically within
    Java’s statically typed environment. In Java, anonymous inner classes play part
    of the role of *closures* in other languages, giving the effect of handling state
    and behavior independently of classes. (You can also use *lambdas* in many places
    where inner or anonymous inner classes work. Lambdas encapsulate bits of logic
    and are common in many functional languages and LISPs. We’ll look at them in much
    more detail in [Chapter 11](ch11.html#learnjava6-CHP-11).)
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 内部类是用于结构化代码的一个有用且美观的功能。它们的姊妹类，*匿名内部类*，是一种更强大的简写方式，使得在Java的静态类型环境中似乎可以动态创建新类型的对象。在Java中，匿名内部类扮演其他语言中*闭包*的角色的一部分，产生处理状态和行为独立于类的效果。（你还可以在许多内部或匿名内部类适用的地方使用*lambda*。Lambda封装了逻辑的片段，在许多函数式语言和LISP中都很常见。我们将在[第11章](ch11.html#learnjava6-CHP-11)中更详细地介绍它们。）
- en: However, as we delve into their inner workings, we’ll see that inner classes
    are not quite as aesthetically pleasing or dynamic as they seem. Inner classes
    are pure syntactic sugar; the Java runtime does not support them. Instead, the
    compiler maps the code of an inner class to a cleverly named regular class. As
    a programmer, you may never need to know this; you can simply rely on inner classes
    like any other language construct. However, you should know a little about how
    they work to better understand the compiled code and to watch for a few potential
    side effects.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们深入其内部工作时，我们会发现内部类并不像它们看起来那样美观或动态。内部类只是一种语法糖；Java运行时不支持它们。相反，编译器将内部类的代码映射到一个巧妙命名的常规类。作为程序员，您可能永远不需要知道这一点；您可以像任何其他语言构造一样依赖内部类。但是，您应该了解它们的工作原理，以更好地理解编译后的代码，并注意一些潜在的副作用。
- en: 'Inner classes are essentially nested classes. For example:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 内部类本质上是嵌套类。例如：
- en: '[PRE70]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Here, the class `Brain` is an inner class: it is a class declared inside the
    scope of the `Animal` class. Although the details of what that means require a
    bit of explanation, we’ll start by saying that Java tries to make the meaning,
    as much as possible, the same as for the other members (methods and variables)
    living at that level of scope. For example, let’s add a method to the `Animal`
    class:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，类`Brain`是一个内部类：它是在`Animal`类的范围内声明的类。虽然具体的含义需要稍作解释，但我们先从Java尝试尽可能使其与其他成员（方法和变量）在同一级别的作用域中的含义相同开始。例如，让我们向`Animal`类添加一个方法：
- en: '[PRE71]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The inner class `Brain`, the method `performBehavior()`, and the `weight` variable
    are within the scope of `Animal`. Therefore, anywhere within `Animal`, we can
    refer to `Brain`, `performBehavior()`, and `weight` directly, by name. Within
    `Animal`, we can call the constructor for `Brain` (`new Brain()`) to get a `Brain`
    object or invoke `performBehavior()` to carry out that method’s function. But
    none of these elements are generally accessible outside of the class `Animal`
    without some additional qualification.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 内部类`Brain`，方法`performBehavior()`和变量`weight`都在`Animal`的范围内。因此，在`Animal`的任何地方，我们都可以直接通过名称引用`Brain`，`performBehavior()`和`weight`。在`Animal`内部，我们可以调用`Brain`的构造函数（`new
    Brain()`）获取一个`Brain`对象或者调用`performBehavior()`执行该方法的功能。但这些元素在没有额外限定的情况下通常无法在`Animal`类外部访问。
- en: Within the body of the inner `Brain` class and the body of the `performBehavior()`
    method, we have direct access to the `weight` variable as well as all the other
    methods and variables of the `Animal` class. So, just as the `performBehavior()`
    method could work with the `Brain` class and create instances of `Brain`, methods
    within the `Brain` class can invoke the `performBehavior()` method of `Animal`
    or work with the `weight` variable. The `Brain` class “sees” all of the methods
    and variables of the `Animal` class directly in its scope.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部`Brain`类和`performBehavior()`方法的主体内，我们可以直接访问`weight`变量以及`Animal`类的所有其他方法和变量。因此，正如`performBehavior()`方法可以使用`Brain`类并创建`Brain`实例一样，`Brain`类内的方法可以调用`Animal`的`performBehavior()`方法或处理`weight`变量。`Brain`类在其范围内“看到”`Animal`类的所有方法和变量。
- en: 'A brain’s access to the variables and methods of `Animal` has important consequences.
    From within `Brain`, we can invoke the method `performBehavior()`; that is, from
    within an instance of `Brain`, we can invoke the `performBehavior()` method of
    an instance of `Animal`. Well, which instance of `Animal`? If we have several
    `Animal` objects around (say, a few `Cat`s and `Dog`s), we need to know whose
    `performBehavior()` method we are calling. What does it mean for a class definition
    to be “inside” another class definition? The answer is that a `Brain` object always
    lives within a single instance of `Animal`: the one that it was told about when
    it was created. We’ll call the object that contains any instance of `Brain` its
    *enclosing instance*.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 一个大脑对`Animal`的变量和方法的访问具有重要的后果。从`Brain`内部，我们可以调用`performBehavior()`方法；也就是说，在`Brain`的实例内部，我们可以调用`Animal`的实例的`performBehavior()`方法。那么，是哪个`Animal`的实例呢？如果我们周围有几个`Animal`对象（比如几只`Cat`和`Dog`），我们需要知道我们调用的是谁的`performBehavior()`方法。类定义“内部”另一个类定义是什么意思？答案是`Brain`对象总是存在于单个`Animal`实例内：即在创建时告知它的那个实例。我们将包含任何`Brain`实例的对象称为*封闭实例*。
- en: A `Brain` object cannot live outside of an enclosing instance of an `Animal`
    object. Anywhere you see an instance of `Brain`, it will be tethered to an instance
    of `Animal`. Although it is possible to construct a `Brain` object from elsewhere
    (perhaps another class), `Brain` always requires an enclosing instance of `Animal`
    to “hold” it. If you ever do find a `Brain` of the `Animal` class, it will still
    be explicitly associated with `Animal` as the `Animal.Brain` class. Just as with
    the `performBehavior()` method, modifiers can be applied to restrict its visibility.
    All of the usual visibility modifiers apply, and inner classes can also be declared
    `static`, as we’ll discuss in later chapters.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`Brain`对象不能存在于`Animal`对象的封闭实例之外。无论何处看到`Brain`的实例，它都将与`Animal`的实例相连。虽然可能从其他地方（可能是另一个类）构造`Brain`对象，但`Brain`始终需要一个`Animal`的封闭实例来“容纳”它。如果你确实找到了`Animal`类的`Brain`，它仍将明确与`Animal`关联为`Animal.Brain`类。与`performBehavior()`方法一样，可以应用修饰符来限制其可见性。所有通常的可见性修饰符都适用，内部类也可以声明为`static`，我们将在后面的章节中讨论。'
- en: Anonymous Inner Classes
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匿名内部类
- en: Now we get to the best part. As a general rule, the more deeply encapsulated
    and limited in scope our classes are, the more freedom we have in naming them.
    We saw this in our earlier iterator example. This is not just a purely aesthetic
    issue. Naming is an important part of writing readable, maintainable code. Generally,
    use the most concise, meaningful names possible. As a corollary, avoid doling
    out names for temporary objects that are going to be used only once.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来到了最精彩的部分。作为一个一般规则，我们的类封装得越深、作用域越有限，我们在命名它们时就越自由。我们在早期迭代器示例中看到了这一点。这不仅仅是一个纯粹的审美问题。命名是写可读性强、可维护的代码的重要组成部分。一般来说，使用最简洁、最有意义的名称。作为一个推论，避免为只会被使用一次的临时对象赋予名称。
- en: Anonymous inner classes are an extension of the syntax of the `new` operation.
    When you create an anonymous inner class, you combine a class declaration with
    the allocation of an instance of that class, effectively creating a “one-time
    only” class and an instance in one operation. After the `new` keyword, you specify
    either the name of a class or an interface, followed by a class body. The class
    body becomes an inner class. It either extends the specified class or, in the
    case of an interface, is expected to implement the interface. A single instance
    of the class is created and returned as the value.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名内部类是`new`操作语法的扩展。当你创建一个匿名内部类时，你将类声明与分配该类的实例结合在一起，有效地创建一个“一次性”类和一个实例。在`new`关键字之后，你指定一个类的名称或一个接口，然后是一个类体。类体成为一个内部类。它要么扩展指定的类，要么在接口的情况下，被期望实现该接口。创建并返回该类的单个实例作为值。
- en: 'For example, we could revisit the graphical application from [“HelloJava2:
    The Sequel”](ch02.html#learnjava6-CHP-2-SECT-3). As you might recall, that app
    creates a `HelloComponent2` that extends `JComponent` and implements the `MouseMotionListener`
    interface. (Does that example make a little more sense now?) We never expect `HelloComponent2`
    to respond to mouse motion events coming from other components. It might make
    more sense to create an anonymous inner class specifically to move our “Hello”
    label around.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，我们可以重新审视来自[“HelloJava2: The Sequel”](ch02.html#learnjava6-CHP-2-SECT-3)的图形应用程序。您可能还记得，该应用程序创建了一个扩展`JComponent`并实现`MouseMotionListener`接口的`HelloComponent2`。现在这个例子是否更有意义了呢？我们从不指望`HelloComponent2`会响应来自其他组件的鼠标移动事件。创建一个匿名内部类来特别移动我们的“Hello”标签可能更合理。'
- en: Indeed, since `HelloComponent2` is really meant only for use by our demo, we
    could *refactor* (a common developer process to optimize or improve code that
    is already working) that separate class into an inner class. Now that we know
    a little more about constructors and inheritance, we could also make our class
    an extension of `JFrame` rather than building a frame inside our `main()` method.
    And to put a little icing on this newly refactored cake, we can move our mouse
    listener code into an anonymous inner class devoted to our custom component.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，由于`HelloComponent2`真正只用于我们的演示，我们可以*重构*（这是优化或改进已经工作的代码的常见开发者过程），将那个单独的类重构为内部类。现在我们对构造函数和继承了解更多后，我们也可以将我们的类扩展为`JFrame`，而不是在我们的`main()`方法内构建一个窗体。为了给这个新重构的部分增添点亮色，我们可以将我们的鼠标监听器代码移动到专门为我们的自定义组件设计的匿名内部类中。
- en: 'Here’s our `HelloJava3` with these nifty refactorings in place:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们的`HelloJava3`，已经进行了这些巧妙的重构：
- en: '[PRE72]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Try compiling and running this example. It should behave exactly like the original
    `HelloJava2` application. The real difference is how we have organized the classes
    and who can access them (and the variables and methods inside them). `HelloJava3`
    probably looks a little cumbersome compared to `HelloJava2`, and it is verbose
    for such a small demo.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试编译和运行此示例。它应该与原始的`HelloJava2`应用程序行为完全相同。真正的区别在于我们如何组织类以及谁能访问它们（以及其中的变量和方法）。与`HelloJava2`相比，`HelloJava3`可能看起来有点累赘，并且对于这样一个小的演示而言，它很冗长。
- en: The power of inner classes and interfaces will start to shine as you develop
    more complex applications. Practicing with the structure and rules of these features
    will help you write more maintainable code in the long run.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您开发更复杂的应用程序，内部类和接口的功能将开始发挥作用。通过使用这些功能的结构和规则进行练习，将有助于您长期编写更易于维护的代码。
- en: Organizing Content and Planning for Failure
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织内容并为失败做计划
- en: Classes are the single most important idea in Java. They form the core of every
    executable program, portable library, or helper. We looked at the contents of
    classes and how classes relate to each other in a larger project. We know more
    about how to create and destroy objects based on the classes we write. And we’ve
    seen how inner classes (and anonymous inner classes) can help us write more maintainable
    code. We’ll be seeing more of these inner classes as we get into deeper topics
    such as threads in [Chapter 9](ch09.html#learnjava6-CHP-9) and Swing in [Chapter 12](ch12.html#learnjava6-CHP-12).
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 类是 Java 中最重要的概念。它们构成了每个可执行程序、可移植库或助手的核心。我们已经查看了类的内容以及类在较大项目中如何相互关联。我们了解了如何根据我们编写的类来创建和销毁对象。我们还看到了内部类（和匿名内部类）如何帮助我们编写更易于维护的代码。当我们深入研究诸如[第 9 章](ch09.html#learnjava6-CHP-9)中的线程和[第 12 章](ch12.html#learnjava6-CHP-12)中的
    Swing 等更深入的主题时，我们将会看到更多这些内部类。
- en: 'As you build your classes, here are a few guidelines to keep in mind:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建类时，请牢记以下几点指导方针：
- en: Hide as much of your implementation as possible
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能隐藏实现细节
- en: Never expose more of the internals of an object than you need to. This is key
    to building maintainable, reusable code. Avoid using public variables in your
    objects, with the notable exception of constants. Instead, define *accessor* methods
    to set and return values. This is useful even if they are simple types—think of
    methods like `getWeight()` and `setWeight()`. You’ll be able to modify and extend
    your objects’ behavior down the road without breaking other classes that rely
    on them.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要公开比您需要的更多的对象内部信息。这是构建可维护、可重用代码的关键。避免在对象中使用公共变量，其中一个值得注意的例外是常量。相反，定义*访问器*方法来设置和返回值。即使它们是简单的类型也很有用——考虑一下像`getWeight()`和`setWeight()`这样的方法。在不破坏依赖于它们的其他类的情况下，您将能够修改和扩展对象的行为。
- en: Use composition instead of inheritance
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 使用组合而不是继承
- en: Specialize objects only when you must. When you use an object in its existing
    form, as a piece of a new object, you are *composing* objects. When you change
    or refine the behavior of an object (by subclassing), you are using *inheritance*.
    Try to reuse objects by composition rather than inheritance whenever possible.
    When you compose objects, you are taking full advantage of existing tools. Inheritance
    involves breaking down the encapsulation of an object, so do it only when there’s
    a real advantage. Ask yourself if you really need to inherit the whole class (do
    you want it to be a “kind” of that object?) or if you can just include an instance
    of that class in your own class and delegate some work to that included instance.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在必要时才对对象进行特化。当您使用现有形式的对象作为新对象的一部分时，您正在*组合*对象。当您改变或完善对象的行为（通过子类化）时，您正在使用*继承*。尽量通过组合而不是继承来重用对象。当您组合对象时，您正在充分利用现有的工具。继承涉及到打破对象的封装，因此只有在确实有优势时才这样做。问问自己，您是否真的需要继承整个类（您希望它成为该对象的“一种”吗？）还是您只需在自己的类中包含该类的一个实例并将一些工作委托给该包含的实例。
- en: Minimize relationships between objects and try to organize related objects in
    packages
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 将对象之间的关系最小化，并尝试将相关对象组织在包中。
- en: Java packages (recall [Figure 5-1](#learnjava6-CHP-5-FIG-1)) can also hide classes
    that are not of general interest. Expose only classes that you intend other people
    to use. The more loosely coupled your objects, the easier it will be to reuse
    them later.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: Java 包（回顾[图 5-1](#learnjava6-CHP-5-FIG-1)）还可以隐藏对不是普遍兴趣的类的访问。只公开您打算其他人使用的类。您的对象之间的耦合度越低，以后重用它们就越容易。
- en: We can apply these principles even on small projects. The *ch05/examples* folder
    contains simple versions of the classes and interfaces we’ll use to create our
    apple tossing game. Take a moment to see how the `Apple`, `Tree`, and `Physicist`
    classes implement the `GamePiece` interface—like the `draw()` method every class
    includes. Notice how `Field` extends `JComponent` and how the main game class,
    `AppleToss`, extends `JFrame`. You can see these simple pieces playing together
    in [Figure 5-10](#learnjava6-CHP-5-FIG-10).
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在小项目中，我们也可以应用这些原则。*ch05/examples* 文件夹包含我们将用来创建苹果投掷游戏的类和接口的简单版本。花一点时间看看`Apple`、`Tree`
    和`Physicist` 类如何实现`GamePiece` 接口，就像每个类都包括的`draw()` 方法一样。注意`Field` 扩展了`JComponent`，以及主游戏类`AppleToss`
    扩展了`JFrame`。您可以看到这些简单的组件如何一起运行在[图 5-10](#learnjava6-CHP-5-FIG-10) 中。
- en: '![ljv6 0510](assets/ljv6_0510.png)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0510](assets/ljv6_0510.png)'
- en: Figure 5-10\. Our very first game classes in action
  id: totrans-356
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-10. 我们的第一个游戏类在操作中
- en: The final code exercise for this chapter will help you get started. Look over
    the comments in the classes. Try tweaking a few things. Add another tree. More
    play is always good. We’ll be building on these classes throughout the remaining
    chapters, so getting comfortable with how they fit together will make it easier.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后一个编码练习将帮助您入门。查看类中的注释。尝试调整一些东西。再添加一个树。更多的实践总是有好处的。在接下来的章节中，我们将继续构建这些类，因此熟悉它们如何配合将会更容易。
- en: Regardless of how you organize the members in your classes, the classes in your
    packages, or the packages in your project, you’ll have to contend with errors.
    Some will be simple syntax errors you’ll fix in your editor. Other errors are
    more interesting and may crop up only while your program is actually running.
    The next chapter will cover Java’s notion of these problems and help you handle
    them.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您如何组织类中的成员、包中的类或项目中的包，都将不得不处理错误。有些错误是您在编辑器中修复的简单语法错误。其他错误更有趣，可能只在程序实际运行时出现。下一章将涵盖
    Java 对这些问题的概念，并帮助您处理它们。
- en: Review Questions
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复习问题
- en: What is the primary organizing unit in Java?
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java 中的主要组织单位是什么？
- en: What operator do you use to create an object (or instance) from a class?
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您使用什么运算符来从类创建对象（或实例）？
- en: Java does not support classic multiple inheritance. What mechanisms does Java
    provide as alternatives?
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java 不支持经典的多重继承。Java 提供了哪些替代机制？
- en: How can you organize multiple, related classes?
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何组织多个相关类？
- en: How do you include classes from other packages for use in your own code?
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在您自己的代码中包含来自其他包的类以供使用？
- en: What do you call a class defined inside the scope of another class? What are
    some features that make such a class useful in some circumstances?
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何称呼在另一个类的作用域内定义的类？这样的类在某些情况下有哪些有用的特征？
- en: What do you call a method designed to be overridden that has a name, return
    type, and argument list, but no body?
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何称呼一个设计为被重写的方法，它有一个名称、返回类型和参数列表，但没有方法体？
- en: What is an overloaded method?
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是重载方法？
- en: If you want to make sure no other class can use a variable you have defined,
    what access modifier should you use?
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您希望确保没有其他类可以使用您定义的变量，应该使用哪种访问修饰符？
- en: Code Exercises
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码练习
- en: 'For your first coding practice, create a small zoo of communicative creatures.
    The *ch05/exercises/Zoo.java* file contains a complete outline for creating a
    few animals and having them “speak” using inner classes. Start by filling in the
    `speak()` method of the included `Gibbon` class using the completed `Lion` inner
    class as an example. When you compile and run your `Zoo`, you should see output
    like this (with your own animal noises, of course):'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于您的第一个编码实践，创建一个能够交流的小动物园。*ch05/exercises/Zoo.java* 文件包含了创建几种动物并让它们通过内部类“说话”的完整概述。首先，通过完成的`Lion`内部类的例子填写`Gibbon`类的`speak()`方法。当您编译并运行您的`Zoo`时，您应该看到类似这样的输出（当然，您自己的动物叫声）：
- en: '[PRE73]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Now add your own animal to the zoo. Create a new inner class similar to `Lion`.
    Fill in the appropriate sound for your animal, and add them to the output section
    of the `listen()` method. Your new output will look something like:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在向动物园添加您自己的动物。创建一个类似于`Lion` 的新内部类。为您的动物填写适当的声音，并将它们添加到`listen()` 方法的输出部分。您的新输出将类似于：
- en: '[PRE74]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Let’s clean up that `listen()` method. We currently use separate `print()` and
    `println()` methods for each animal. If we add another animal (or several), that
    will require copying and pasting and tweaking the output lines—tasks that can
    introduce errors. Add another abstract method to `Animal` called `getSpecies()`.
    In the subclasses, this method should return the name of the animal as a `String`,
    such as “lion” or “seal” from the examples above.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们来清理一下`listen()`方法。我们目前为每个动物使用单独的`print()`和`println()`方法。如果我们添加另一个（或几个）动物，那将需要复制、粘贴和调整输出行——这些任务可能会引入错误。在`Animal`中添加另一个抽象方法称为`getSpecies()`。在子类中，此方法应返回动物的名称作为`String`，例如上面的“狮子”或“海豹”。
- en: With that method in place, refactor the output section to put your animals in
    a small array, and then use a loop to produce the output. (Feel free to edit your
    existing `Zoo` class. Our solution is in a new class, `Zoo2`, so that you can
    look over the solution to this problem as well as the solution to the previous
    exercise.)
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有了这个方法，重构输出部分以将你的动物放入一个小数组中，然后使用循环生成输出。（可以编辑现有的`Zoo`类。我们的解决方案在一个新类`Zoo2`中，这样你可以查看这个问题的解决方案以及上一个练习的解决方案。）
- en: Run the apple tossing game. Compile and run the `ch05.exercises.game.AppleToss`
    class in the *ch05/exercises/game* folder using the steps discussed earlier in
    [“Custom Packages”](#learnjava6-CHP-5-SECT-5.2).
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行苹果投掷游戏。使用[“自定义包”](#learnjava6-CHP-5-SECT-5.2)中讨论的步骤编译和运行*ch05/exercises/game*文件夹中的`ch05.exercises.game.AppleToss`类。
- en: Advanced Exercises
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级练习
- en: 'For a more advanced challenge, let’s expand our apple tossing game by creating
    a new type of obstacle. Use the `Tree` class as a template and create a `Hedge`
    class. You can draw your hedge as a green rectangle. To draw a rectangle:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于更高级的挑战，让我们通过创建一种新类型的障碍物来扩展我们的苹果投掷游戏。使用`Tree`类作为模板创建`Hedge`类。你可以将你的篱笆绘制为绿色的矩形。要绘制一个矩形：
- en: '[PRE75]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Add a hedge to your field. The final game should look something like [Figure 5-11](#learnjava6-CHP-5-FIG-hedges).
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在你的田野上添加一道篱笆。最终游戏应该看起来像[图5-11](#learnjava6-CHP-5-FIG-hedges)那样。
- en: '![ljv6 0511](assets/ljv6_0511.png)'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![ljv6 0511](assets/ljv6_0511.png)'
- en: Figure 5-11\. Our new hedge obstacle on the field
  id: totrans-382
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-11。我们田野上的新篱笆障碍物
- en: We will continue to expand this game throughout the book, but feel free to do
    some of your own expanding now. Play around with drawing other shapes or change
    the colors of the current elements. The [online documentation](https://oreil.ly/_dhQy)
    for the `Graphics` class will be helpful.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在整本书中继续扩展这个游戏，但现在请随意进行一些扩展。尝试绘制其他形状或更改当前元素的颜色。[在线文档](https://oreil.ly/_dhQy)`Graphics`类对你有所帮助。
- en: '^([1](ch05.html#id1063-marker)) Once you have some experience with basic object-oriented
    concepts, you might want to look at *Design Patterns: Elements of Reusable Object-Oriented
    Software* by Erich Gamma et al. (Addison-Wesley). This book catalogs useful object-oriented
    designs that have been refined over the years. Many of these patterns appear in
    the design of the Java APIs.'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch05.html#id1063-marker)) 一旦你对基本面向对象的概念有了一些经验，你可能想看看《*设计模式：可复用面向对象软件的基础*》（Addison-Wesley）由Erich
    Gamma等人编写。这本书总结了多年来得到改进的有用面向对象设计。许多这些模式出现在Java API的设计中。
- en: ^([2](ch05.html#id1073-marker)) The `char` also gets a 0 but usually expressed
    as the null character, `\0`. A `boolean` variable gets the default of `false`,
    and reference types get the default of `null`.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch05.html#id1073-marker)) `char`也得到一个0，但通常表示为空字符`\0`。`boolean`变量默认为`false`，引用类型默认为`null`。
- en: ^([3](ch05.html#id1104-marker)) We don’t go into the details of such argument
    lists, but if you’re curious and would like to do a little reading on your own,
    search online for the programmer-speak keyword “varargs.”
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch05.html#id1104-marker)) 我们不深入讨论这些参数列表的细节，但如果你感兴趣并想自己阅读一些内容，请在网上搜索程序员术语“varargs”。
- en: ^([4](ch05.html#id1121-marker)) It turns out the `Math` class cannot be instantiated
    at all. It contains only static methods. Trying to call `new Math()` would result
    in a compiler error.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch05.html#id1121-marker)) 原来`Math`类根本无法实例化。它仅包含静态方法。尝试调用`new Math()`将导致编译器错误。
- en: ^([5](ch05.html#id1181-marker)) It’s still possible to write code in Java that
    holds on to objects forever (by accident, we’re sure), consuming more and more
    memory. This isn’t really a leak as much as it is hoarding. Such hoarding in Java
    is usually easier to track down than a leak in C.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: ^([6](ch05.html#id1217-marker)) Maven sufficiently changed the landscape for
    dependency management in Java and even other JVM-based languages so you can now
    find tools such as [Gradle](https://gradle.org), which were based on Maven’s success.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '^([7](ch05.html#id1222-marker)) Note that a better way to design our calculators
    would be to have an abstract `Calculator` class with two separate subclasses:
    `IntegerCalculator` and `DecimalCalculator`.'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: ^([8](ch05.html#id1233-marker)) The platypus is a highly unusual egg-laying
    mammal. We could override the `reproduce()` behavior again for `Platypus` in its
    own subclass of `Mammal`.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: ^([9](ch05.html#id1234-marker)) An overridden method in Java acts like a `virtual`
    method in C++.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
