<html><head></head><body><section data-pdf-bookmark="Chapter 4. Operating AWS Lambda Functions" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch04">&#13;
<h1><span class="label">Chapter 4. </span>Operating AWS Lambda Functions</h1>&#13;
&#13;
&#13;
<p>This chapter will introduce a more advanced method of building and packaging Java-based AWS Lambda functions.&#13;
We’ll also go into more detail on the serverless-oriented version of AWS’s infrastructure-as-code tool, SAM, which you first used in <a data-type="xref" href="ch02.html#ch02">Chapter 2</a>.&#13;
Finally, we’ll go over how Lambda functions and serverless applications are affected by AWS’s security model and how to use SAM to automatically enforce a least-privilege security model for our serverless application.</p>&#13;
&#13;
<p>Before proceeding, we recommend that if you haven’t done so already that you download this book’s <a href="https://oreil.ly/t0Bgg">code examples</a>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Build and Package" data-type="sect1"><div class="sect1" id="build-and-package">&#13;
<h1>Build and Package</h1>&#13;
&#13;
<p>The<a data-primary="building and packaging Lambda functions" data-secondary="overview of" data-type="indexterm" id="idm46222421783368"/><a data-primary="Lambda functions" data-secondary="building and packaging" data-type="indexterm" id="LFbuild04"/><a data-primary="ZIP archive files" data-type="indexterm" id="idm46222421781128"/> Lambda platform expects all user-provided code to be in the form of a <a href="https://oreil.ly/aECWk">ZIP</a> archive file.&#13;
Depending on which runtime you’re using and your actual business logic, that ZIP file may consist of source code, or code and libraries, or, in the case of Java, compiled byte code (class files) and libraries.</p>&#13;
&#13;
<p>In<a data-primary="Java" data-secondary="JAR (Java ARchive) files" data-type="indexterm" id="idm46222421779016"/> the Java ecosystem, we often package our code into JAR (Java ARchive) files, to be run via the <code>java -jar</code> command, or to be used as libraries by other applications.&#13;
It turns out that a JAR file is simply a ZIP file with some additional metadata.&#13;
The Lambda platform doesn’t perform any special handling of JAR files—it treats them as ZIP files, just as it does for the other Lambda language runtimes.</p>&#13;
&#13;
<p>Using<a data-primary="Maven" data-secondary="purpose of" data-type="indexterm" id="idm46222421776632"/> a tool like Maven, we can specify the other libraries that our code depends on and have Maven download the right versions of those libraries (and any transitive dependencies that they might have), compile our code into Java class files, and package everything up into a single JAR file (often called an <em>uberjar</em>).</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Uberjars" data-type="sect1"><div class="sect1" id="idm46222421774664">&#13;
<h1>Uberjars</h1>&#13;
&#13;
<p>Despite<a data-primary="building and packaging Lambda functions" data-secondary="uberjars" data-type="indexterm" id="idm46222421772904"/><a data-primary="uberjars" data-type="indexterm" id="idm46222421771928"/> using the uberjar approach in Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch02.html#ch02">2</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch03.html#ch03">3</a>, there are a few problems with it that are worth calling out before we go any further.</p>&#13;
&#13;
<p>First, the uberjar approach unpacks and then overlays libraries on top of each other in the target uberjar file.&#13;
In the following example, Library A contains a class file and a properties file.&#13;
Library B contains a different class file and a properties file with the same name as the properties file from Library A.</p>&#13;
&#13;
<pre data-type="programlisting" id="jar-layouts">$ jar tf LibraryA.jar&#13;
book/&#13;
book/important.properties&#13;
book/A.class&#13;
&#13;
$ jar tf LibraryB.jar&#13;
book/&#13;
book/important.properties&#13;
book/B.class</pre>&#13;
&#13;
<p>If these JAR files were used to create an uberjar (as we did in prior chapters), the result would contain two class files and one properties file—but the properties file from which source JAR?</p>&#13;
&#13;
<pre data-type="programlisting" id="uberjar-layout">$ jar tf uberjar.jar&#13;
book/&#13;
book/important.properties # Which properties file is this?&#13;
book/A.class&#13;
book/B.class</pre>&#13;
&#13;
<p>Because the JAR files are unpacked and overlaid, only one of those properties files will make it into the final uberjar, and it can be difficult to know which one will win without delving into the dark arts of Maven resource transformers.</p>&#13;
&#13;
<p>The second major issue with the uberjar approach is oriented around creating a JAR file—the fact that JAR files are also ZIP files that can be used by the Lambda runtime is incidental from the perspective of the Maven build process.&#13;
Two specific issues arise from this JAR versus ZIP situation.&#13;
One is that any JAR-specific metadata is unused (and in fact, ignored) by the Lambda runtime.&#13;
Things like a <code>Main-Class</code> attribute in a <em>MANIFEST.MF</em> file—a piece of metadata common to JAR files—are meaningless in the context of a Lambda function.</p>&#13;
&#13;
<p>Furthermore, the JAR creation process itself introduces a certain amount of non-determinism into the build process.&#13;
For example, tool versions and build timestamps are recorded in <em>MANIFEST.MF</em> and <em>pom.properties</em> files—and that makes it impossible to reproducibly build the same JAR file from the same source code every time.&#13;
This nonreproducibility wreaks havoc on downstream caching, deployment, and security processes, so we want to avoid it when possible.</p>&#13;
&#13;
<p>Since we’re not actually interested in the JAR-ness of an uberjar file, it makes sense for us to consider not using the uberjar process at all.&#13;
Of course, the uberjar process itself isn’t necessarily the only source of nondeterminism in our build process, but we’ll deal with the rest of it later.</p>&#13;
&#13;
<p>Despite these drawbacks, the uberjar process is simpler to configure and use for simple cases, especially when a Lambda function has few (or no) third-party dependencies.&#13;
This was the case in the examples in Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch02.html#ch02">2</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch03.html#ch03">3</a>, which is why we used the uberjar technique up until this point, but for any real-world use of Java and Lambda of any significant scale, we recommend the ZIP file approach that we describe next.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Assembling a ZIP File" data-type="sect1"><div class="sect1" id="assembling-a-zip-file">&#13;
<h1>Assembling a ZIP File</h1>&#13;
&#13;
<p>So, in<a data-primary="building and packaging Lambda functions" data-secondary="ZIP archive files" data-type="indexterm" id="BPzip04"/><a data-primary="ZIP archive files" data-type="indexterm" id="zip04"/> the Java world, our alternative to using an uberjar file is to fall back to a trusty old ZIP file.&#13;
In this scenario, the archive layout is going to be a little different, but we’ll see how a careful approach can avoid the issues with the uberjar and give us an artifact that the Lambda platform can use.&#13;
We’ll discuss how to achieve this using<a data-primary="Maven" data-secondary="assembling ZIP files" data-type="indexterm" id="idm46222421733480"/> Maven, but of course you should feel free to translate this method to your preferred build tool—the outcome is more important than the process itself.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46222421732104">&#13;
<h5>Starting Fresh with sam init</h5>&#13;
<p>If<a data-primary="sam init command" data-type="indexterm" id="idm46222421730584"/> you want to create a new project using the ideas we discuss in this chapter—packaging and deploying reproducible ZIP artifacts—then you can use a different version of the <code>sam init</code> template we introduced in <a data-type="xref" href="ch02.html#ch02">Chapter 2</a>.&#13;
Run the following, and it will generate a version with the updated <em>pom.xml</em> and <em>template.yaml</em> files, along with the <em>lambda-zip.xml</em> assembly descriptor file that we’ll be using later in the chapter:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nv">$ </code>sam init <code class="se">\</code>&#13;
  --location <code class="se">\</code>&#13;
  gh:symphoniacloud/sam-init-HelloWorldLambdaJava-zip</pre>&#13;
</div></aside>&#13;
&#13;
<p>To make a more interesting example, first we’ll add a dependency on the AWS SDK for DynamoDB to our Maven build for the Lambda function from <a data-type="xref" href="ch02.html#java-hello-world">“Lambda Hello World (the Proper Way)”</a>.</p>&#13;
&#13;
<p>Add a <code>dependencies</code> section to the <em>pom.xml</em> file:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting">    <code class="nt">&lt;dependencies&gt;</code>&#13;
      <code class="nt">&lt;dependency&gt;</code>&#13;
        <code class="nt">&lt;groupId&gt;</code>com.amazonaws<code class="nt">&lt;/groupId&gt;</code>&#13;
        <code class="nt">&lt;artifactId&gt;</code>aws-java-sdk-dynamodb<code class="nt">&lt;/artifactId&gt;</code>&#13;
        <code class="nt">&lt;version&gt;</code>1.11.319<code class="nt">&lt;/version&gt;</code>&#13;
      <code class="nt">&lt;/dependency&gt;</code>&#13;
    <code class="nt">&lt;/dependencies&gt;</code></pre>&#13;
&#13;
<p>With that dependency added, here’s what the desired ZIP file layout looks like for our simple Lambda function and dependencies:</p>&#13;
&#13;
<pre data-type="programlisting">$ zipinfo -1 target/lambda.zip&#13;
META-INF/&#13;
book/&#13;
book/HelloWorld.class&#13;
lib/&#13;
lib/aws-java-sdk-core-1.11.319.jar&#13;
lib/aws-java-sdk-dynamodb-1.11.319.jar&#13;
lib/aws-java-sdk-kms-1.11.319.jar&#13;
lib/aws-java-sdk-s3-1.11.319.jar&#13;
lib/commons-codec-1.10.jar&#13;
lib/commons-logging-1.1.3.jar&#13;
lib/httpclient-4.5.5.jar&#13;
lib/httpcore-4.4.9.jar&#13;
lib/ion-java-1.0.2.jar&#13;
lib/jackson-annotations-2.6.0.jar&#13;
lib/jackson-core-2.6.7.jar&#13;
lib/jackson-databind-2.6.7.1.jar&#13;
lib/jackson-dataformat-cbor-2.6.7.jar&#13;
lib/jmespath-java-1.11.319.jar&#13;
lib/joda-time-2.8.1.jar</pre>&#13;
&#13;
<p>In addition to our application code (<em>book/HelloWorld.class</em>), we see a <em>lib</em> directory full of JAR files, one for the AWS DynamoDB SDK, and one for each of its transitive dependencies.</p>&#13;
&#13;
<p>We can build that ZIP output using the<a data-primary="Maven" data-secondary="Assembly plugin" data-type="indexterm" id="idm46222421698456"/> Maven Assembly plug-in.&#13;
This plug-in allows us to add some special behavior to a specific part of the Maven build (in this case, the <code>package</code> phase where the results of the Java compilation process are packaged up alongside other resources into a set of output files).</p>&#13;
&#13;
<p>First, we’ve configured the Maven Assembly plug-in in the <em>pom.xml</em> file for the project, in the <code>build</code> section:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;build&gt;</code>&#13;
  <code class="nt">&lt;plugins&gt;</code>&#13;
    <code class="nt">&lt;plugin&gt;</code>&#13;
      <code class="nt">&lt;artifactId&gt;</code>maven-assembly-plugin<code class="nt">&lt;/artifactId&gt;</code>&#13;
      <code class="nt">&lt;version&gt;</code>3.1.1<code class="nt">&lt;/version&gt;</code>&#13;
      <code class="nt">&lt;executions&gt;</code>&#13;
        <code class="nt">&lt;execution&gt;</code>&#13;
          <code class="nt">&lt;phase&gt;</code>package<code class="nt">&lt;/phase&gt;</code>&#13;
          <code class="nt">&lt;goals&gt;</code>&#13;
            <code class="nt">&lt;goal&gt;</code>single<code class="nt">&lt;/goal&gt;</code>&#13;
          <code class="nt">&lt;/goals&gt;</code>&#13;
        <code class="nt">&lt;/execution&gt;</code>&#13;
      <code class="nt">&lt;/executions&gt;</code>&#13;
      <code class="nt">&lt;configuration&gt;</code>&#13;
        <code class="nt">&lt;appendAssemblyId&gt;</code>false<code class="nt">&lt;/appendAssemblyId&gt;</code>&#13;
        <code class="nt">&lt;descriptors&gt;</code>&#13;
          <code class="nt">&lt;descriptor&gt;</code>src/assembly/lambda-zip.xml<code class="nt">&lt;/descriptor&gt;</code>&#13;
        <code class="nt">&lt;/descriptors&gt;</code>&#13;
        <code class="nt">&lt;finalName&gt;</code>lambda<code class="nt">&lt;/finalName&gt;</code>&#13;
      <code class="nt">&lt;/configuration&gt;</code>&#13;
    <code class="nt">&lt;/plugin&gt;</code>&#13;
  <code class="nt">&lt;/plugins&gt;</code>&#13;
<code class="nt">&lt;/build&gt;</code></pre>&#13;
&#13;
<p>The two most important parts of this configuration are the assembly <code>descriptor</code>, which is a path to another XML file in our project, and the <code>finalName</code>, which instructs the plug-in to name our output file <em>lambda.zip</em> instead of something else.&#13;
We’ll see later how picking a simple <code>finalName</code> will aid in rapid iteration of our project, especially after we start using Maven submodules.</p>&#13;
&#13;
<p>Most of the configuration for our ZIP file is actually located in the assembly <code>descriptor</code> file, which was referenced in the <em>pom.xml</em> file earlier.&#13;
This <code>assembly</code> configuration is a description of exactly which contents to include in our output file:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;assembly</code><code class="nt">&gt;</code><code>&#13;
  </code><code class="nt">&lt;id</code><code class="nt">&gt;</code><code>lambda-zip</code><code class="nt">&lt;/id&gt;</code><code> </code><a class="co" href="#callout_operating_aws_lambda_functions_CO1-1" id="co_operating_aws_lambda_functions_CO1-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
  </code><code class="nt">&lt;formats</code><code class="nt">&gt;</code><code>&#13;
    </code><code class="nt">&lt;format</code><code class="nt">&gt;</code><code>zip</code><code class="nt">&lt;/format&gt;</code><code> </code><a class="co" href="#callout_operating_aws_lambda_functions_CO1-2" id="co_operating_aws_lambda_functions_CO1-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
  </code><code class="nt">&lt;/formats&gt;</code><code>&#13;
  </code><code class="nt">&lt;includeBaseDirectory</code><code class="nt">&gt;</code><code>false</code><code class="nt">&lt;/includeBaseDirectory&gt;</code><code> </code><a class="co" href="#callout_operating_aws_lambda_functions_CO1-3" id="co_operating_aws_lambda_functions_CO1-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
  </code><code class="nt">&lt;dependencySets</code><code class="nt">&gt;</code><code>&#13;
    </code><code class="nt">&lt;dependencySet</code><code class="nt">&gt;</code><code> </code><a class="co" href="#callout_operating_aws_lambda_functions_CO1-4" id="co_operating_aws_lambda_functions_CO1-4"><img alt="4" src="assets/4.png"/></a><code>&#13;
      </code><code class="nt">&lt;includes</code><code class="nt">&gt;</code><code>&#13;
        </code><code class="nt">&lt;include</code><code class="nt">&gt;</code><code>${project.groupId}:${project.artifactId}</code><code class="nt">&lt;/include&gt;</code><code>&#13;
      </code><code class="nt">&lt;/includes&gt;</code><code>&#13;
      </code><code class="nt">&lt;unpack</code><code class="nt">&gt;</code><code>true</code><code class="nt">&lt;/unpack&gt;</code><code>&#13;
      </code><code class="nt">&lt;unpackOptions</code><code class="nt">&gt;</code><code>&#13;
        </code><code class="nt">&lt;excludes</code><code class="nt">&gt;</code><code>&#13;
          </code><code class="nt">&lt;exclude</code><code class="nt">&gt;</code><code>META-INF/MANIFEST.MF</code><code class="nt">&lt;/exclude&gt;</code><code>&#13;
          </code><code class="nt">&lt;exclude</code><code class="nt">&gt;</code><code>META-INF/maven/**</code><code class="nt">&lt;/exclude&gt;</code><code>&#13;
        </code><code class="nt">&lt;/excludes&gt;</code><code>&#13;
      </code><code class="nt">&lt;/unpackOptions&gt;</code><code>&#13;
    </code><code class="nt">&lt;/dependencySet&gt;</code><code>&#13;
    </code><code class="nt">&lt;dependencySet</code><code class="nt">&gt;</code><code> </code><a class="co" href="#callout_operating_aws_lambda_functions_CO1-5" id="co_operating_aws_lambda_functions_CO1-5"><img alt="5" src="assets/5.png"/></a><code>&#13;
      </code><code class="nt">&lt;useProjectArtifact</code><code class="nt">&gt;</code><code>false</code><code class="nt">&lt;/useProjectArtifact&gt;</code><code>&#13;
      </code><code class="nt">&lt;unpack</code><code class="nt">&gt;</code><code>false</code><code class="nt">&lt;/unpack&gt;</code><code>&#13;
      </code><code class="nt">&lt;scope</code><code class="nt">&gt;</code><code>runtime</code><code class="nt">&lt;/scope&gt;</code><code>&#13;
      </code><code class="nt">&lt;outputDirectory</code><code class="nt">&gt;</code><code>lib</code><code class="nt">&lt;/outputDirectory&gt;</code><code> </code><a class="co" href="#callout_operating_aws_lambda_functions_CO1-6" id="co_operating_aws_lambda_functions_CO1-6"><img alt="6" src="assets/6.png"/></a><code>&#13;
    </code><code class="nt">&lt;/dependencySet&gt;</code><code>&#13;
  </code><code class="nt">&lt;/dependencySets&gt;</code><code>&#13;
</code><code class="nt">&lt;/assembly&gt;</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_operating_aws_lambda_functions_CO1-1" id="callout_operating_aws_lambda_functions_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>We’ve given the assembly a unique name, <code>lambda-zip</code>.</p></dd>&#13;
<dt><a class="co" href="#co_operating_aws_lambda_functions_CO1-2" id="callout_operating_aws_lambda_functions_CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>The output format itself will be of type <code>zip</code>.</p></dd>&#13;
<dt><a class="co" href="#co_operating_aws_lambda_functions_CO1-3" id="callout_operating_aws_lambda_functions_CO1-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>The output file will not have a base directory—this means that when extracted, our ZIP file’s contents will be unpacked into the current directory rather than into a new subdirectory.</p></dd>&#13;
<dt><a class="co" href="#co_operating_aws_lambda_functions_CO1-4" id="callout_operating_aws_lambda_functions_CO1-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>The first <code>dependencySet</code> section explicitly includes our application code, by referencing the project’s <code>groupId</code> and <code>artifactId</code> properties.&#13;
When we start using Maven submodules, this will need to be altered.&#13;
Our application code will be “unpacked.” That is, it won’t be contained in a JAR file; rather, it will just be a normal directory structure and Java <em>.class</em> files.&#13;
We’ve also explicitly excluded the unnecessary <em>META-INF</em> directory.</p></dd>&#13;
<dt><a class="co" href="#co_operating_aws_lambda_functions_CO1-5" id="callout_operating_aws_lambda_functions_CO1-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>The second <code>dependencySet</code> section handles our application’s dependencies.&#13;
We exclude the project’s artifact (as it was handled in the first <code>dependencySet</code> section).&#13;
We only include dependencies that are in the <code>runtime</code> scope.&#13;
We don’t unpack the dependencies; rather, we just leave them packaged as JAR files.</p></dd>&#13;
<dt><a class="co" href="#co_operating_aws_lambda_functions_CO1-6" id="callout_operating_aws_lambda_functions_CO1-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>Finally, instead of including all of the JAR files in the root of our output file, we’ll put them all into a <em>lib</em> directory.</p></dd>&#13;
</dl>&#13;
&#13;
<p>So<a data-primary="uberjars" data-type="indexterm" id="idm46222421410632"/> how does this complicated new Maven configuration help us avoid the issues with uberjars?</p>&#13;
&#13;
<p>First, we’ve stripped out some of the unnecessary META-INF information.&#13;
You’ll notice we’ve been a bit selective—there are some cases where having META-INF information (like “services”) is still valuable, so we don’t want to get rid of it <span class="keep-together">completely</span>.</p>&#13;
&#13;
<p>Second, we’ve included all of our dependencies, but as individual JAR files in a <em>lib</em> directory.&#13;
This avoids the file and path overwriting issue completely.&#13;
Each dependency JAR remains self-contained.&#13;
According<a data-primary="AWS Lambda" data-secondary="best practices documentation" data-type="indexterm" id="idm46222421407592"/><a data-primary="best practices documentation" data-type="indexterm" id="idm46222421406744"/> to the AWS Lambda <a href="https://oreil.ly/euF1U">best practices documentation</a>, this approach also pays some performance dividends in that it’s faster for the Lambda platform to unpack a ZIP file and faster for the JVM to load classes from JAR files.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46222421405064">&#13;
<h5>io.symphonia/lambda-packaging</h5>&#13;
<p>Rather<a data-primary="building and packaging Lambda functions" data-secondary="io.symphonia/lambda-packaging" data-type="indexterm" id="idm46222421403704"/><a data-primary="io.symphonia/lambda-packaging" data-type="indexterm" id="idm46222421402856"/><a data-primary="Maven" data-secondary="Maven Central" data-type="indexterm" id="idm46222421402248"/> than copy and paste the <code>lambda-zip</code> assembly descriptor into all of your projects, we have built a prepackaged descriptor that is available on Maven Central.&#13;
Just use the following configuration in the <code>build</code> section of your <em>pom.xml</em> file:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;plugin&gt;</code>&#13;
  <code class="nt">&lt;artifactId&gt;</code>maven-assembly-plugin<code class="nt">&lt;/artifactId&gt;</code>&#13;
  <code class="nt">&lt;version&gt;</code>3.1.1<code class="nt">&lt;/version&gt;</code>&#13;
  <code class="nt">&lt;dependencies&gt;</code>&#13;
    <code class="nt">&lt;dependency&gt;</code>&#13;
      <code class="nt">&lt;groupId&gt;</code>io.symphonia<code class="nt">&lt;/groupId&gt;</code>&#13;
      <code class="nt">&lt;artifactId&gt;</code>lambda-packaging<code class="nt">&lt;/artifactId&gt;</code>&#13;
      <code class="nt">&lt;version&gt;</code>1.0.0<code class="nt">&lt;/version&gt;</code>&#13;
    <code class="nt">&lt;/dependency&gt;</code>&#13;
  <code class="nt">&lt;/dependencies&gt;</code>&#13;
  <code class="nt">&lt;executions&gt;</code>&#13;
    <code class="nt">&lt;execution&gt;</code>&#13;
      <code class="nt">&lt;id&gt;</code>make-assembly<code class="nt">&lt;/id&gt;</code>&#13;
      <code class="nt">&lt;phase&gt;</code>package<code class="nt">&lt;/phase&gt;</code>&#13;
      <code class="nt">&lt;goals&gt;</code>&#13;
        <code class="nt">&lt;goal&gt;</code>single<code class="nt">&lt;/goal&gt;</code>&#13;
      <code class="nt">&lt;/goals&gt;</code>&#13;
    <code class="nt">&lt;/execution&gt;</code>&#13;
  <code class="nt">&lt;/executions&gt;</code>&#13;
  <code class="nt">&lt;configuration&gt;</code>&#13;
    <code class="nt">&lt;appendAssemblyId&gt;</code>false<code class="nt">&lt;/appendAssemblyId&gt;</code>&#13;
    <code class="nt">&lt;descriptorRefs&gt;</code>&#13;
      <code class="nt">&lt;descriptorRef&gt;</code>lambda-zip<code class="nt">&lt;/descriptorRef&gt;</code>&#13;
    <code class="nt">&lt;/descriptorRefs&gt;</code>&#13;
    <code class="nt">&lt;finalName&gt;</code>lambda<code class="nt">&lt;/finalName&gt;</code>&#13;
  <code class="nt">&lt;/configuration&gt;</code>&#13;
<code class="nt">&lt;/plugin&gt;</code></pre>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Reproducible Builds" data-type="sect1"><div class="sect1" id="reproducible-builds">&#13;
<h1>Reproducible Builds</h1>&#13;
&#13;
<p>When<a data-primary="building and packaging Lambda functions" data-secondary="reproducible builds" data-type="indexterm" id="idm46222421343528"/><a data-primary="" data-startref="BPzip04" data-type="indexterm" id="idm46222421342664"/><a data-primary="" data-startref="zip04" data-type="indexterm" id="idm46222421341720"/> our source code or dependencies change, we expect the contents of the deployment package (the uberjar or ZIP file) to change too (after running our build and packaging process).&#13;
However, when our source code and dependencies don’t change, the contents of the deployment package should remain the same even if the build and packaging process is executed again.&#13;
The output of the build should be reproducible (e.g., deterministic).&#13;
This is important because downstream processes (like deployment pipelines) are often triggered based on whether a deployment package has changed as indicated by the MD5 hash of the contents, and we want to avoid triggering those processes unnecessarily.</p>&#13;
&#13;
<p>Even though we’ve eliminated the autogenerated <em>MANIFEST.MF</em> and <em>pom.properties</em> files using the <code>lambda-zip</code> assembly descriptor, we still haven’t removed all of the potential sources of nondeterminism in the build process.&#13;
For example, when we build our application code (e.g., <code>HelloWorld</code>), the timestamp on the compiled Java class files may change.&#13;
These altered timestamps are propagated into the ZIP file, and then the hash of the ZIP file’s contents changes even though the source code didn’t.</p>&#13;
&#13;
<p>Fortunately, a simple Maven<a data-primary="Maven" data-secondary="reproducible-build-maven-plugin" data-type="indexterm" id="idm46222421336712"/> plug-in exists to strip these sources of nondeterminism from our build process.&#13;
The <code>reproducible-build-maven-plugin</code> can be executed during the build process and will render our output ZIP file completely deterministic.&#13;
It can be configured as a <code>plugin</code> in the <code>build</code> section of our <em>pom.xml</em> file:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;plugin&gt;</code>&#13;
  <code class="nt">&lt;groupId&gt;</code>io.github.zlika<code class="nt">&lt;/groupId&gt;</code>&#13;
  <code class="nt">&lt;artifactId&gt;</code>reproducible-build-maven-plugin<code class="nt">&lt;/artifactId&gt;</code>&#13;
  <code class="nt">&lt;version&gt;</code>0.10<code class="nt">&lt;/version&gt;</code>&#13;
  <code class="nt">&lt;executions&gt;</code>&#13;
    <code class="nt">&lt;execution&gt;</code>&#13;
      <code class="nt">&lt;phase&gt;</code>package<code class="nt">&lt;/phase&gt;</code>&#13;
      <code class="nt">&lt;goals&gt;</code>&#13;
        <code class="nt">&lt;goal&gt;</code>strip-jar<code class="nt">&lt;/goal&gt;</code>&#13;
      <code class="nt">&lt;/goals&gt;</code>&#13;
    <code class="nt">&lt;/execution&gt;</code>&#13;
  <code class="nt">&lt;/executions&gt;</code>&#13;
<code class="nt">&lt;/plugin&gt;</code></pre>&#13;
&#13;
<p>Now, when we rebuild our deployment packages multiple times using the same unchanged source code, the hash is always the same.&#13;
You’ll see how this affects the deployment process in the next section.<a data-primary="" data-startref="LFbuild04" data-type="indexterm" id="idm46222421323768"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Deploy" data-type="sect1"><div class="sect1" id="lambda-deployment-tools">&#13;
<h1>Deploy</h1>&#13;
&#13;
<p>There<a data-primary="deployment" data-secondary="methods of" data-type="indexterm" id="idm46222421315800"/><a data-primary="Lambda functions" data-secondary="deploying" data-type="indexterm" id="LFdeploy04"/> are many options for deploying Lambda code.&#13;
Before we dive in, however, it’s worth clarifying what we mean by <em>deploy</em>.&#13;
In this case, we’re simply talking about updating the code or configuration for a particular Lambda function, or a group of Lambda functions and related AWS resources, through the use of APIs or other services.&#13;
We’re not extending the definition to include deployment orchestration (like AWS CodeDeploy).</p>&#13;
&#13;
<p>In no particular order, the methods of deploying Lambda code are as follows:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>AWS Lambda web console</p>&#13;
</li>&#13;
<li>&#13;
<p>AWS CloudFormation/Serverless Application Model (SAM)</p>&#13;
</li>&#13;
<li>&#13;
<p>AWS CLI (which uses the AWS API)</p>&#13;
</li>&#13;
<li>&#13;
<p>AWS Cloud Development Kit (CDK)</p>&#13;
</li>&#13;
<li>&#13;
<p>Other AWS-developed frameworks, like Amplify and Chalice</p>&#13;
</li>&#13;
<li>&#13;
<p>Third-party frameworks targeting serverless components that build primarily on top of CloudFormation, like the Serverless Framework</p>&#13;
</li>&#13;
<li>&#13;
<p>Third-party tools and frameworks targeting serverless components that build primarily on top of the AWS API, like Claudia.js and <code>lambda-maven-plugin</code> from Maven</p>&#13;
</li>&#13;
<li>&#13;
<p>General-purpose third-party infrastructure tools, like Ansible or Terraform</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>In this book, we’ll address the first two (and indeed have already touched upon the AWS Lambda web console and SAM in Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch02.html#ch02">2</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch03.html#ch03">3</a>).&#13;
We also use the AWS CLI, although not as a deployment tool.&#13;
With a solid understanding of those methods, you should be able to evaluate the other options and decide whether one of them is a better fit for your environment and use case.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Infrastructure as Code" data-type="sect1"><div class="sect1" id="idm46222421266584">&#13;
<h1>Infrastructure as Code</h1>&#13;
&#13;
<p>When<a data-primary="deployment" data-secondary="infrastructure as code" data-type="indexterm" id="idm46222421265176"/><a data-primary="infrastructure as code" data-type="indexterm" id="idm46222421264168"/> we interact with AWS via the web console or the CLI, we’re creating, updating, and destroying infrastructure manually.&#13;
For example, if we create a Lambda function using the AWS Web Console, the next time we want to create a Lambda function with the same parameters, we still have to perform the same manual actions via the web console.&#13;
This same characteristic applies to the CLI as well.</p>&#13;
&#13;
<p>For initial development and experimentation, this is a reasonable approach.&#13;
However, when our projects begin building momentum, this manual approach to infrastructure management will turn into a roadblock.&#13;
A well-proven way to address this issue is called <em>infrastructure as code</em>.</p>&#13;
&#13;
<p>Rather<a data-primary="CloudFormation" data-secondary="deploying code using" data-type="indexterm" id="idm46222421261448"/> than manually interacting with AWS via the web console or CLI, we can declaratively specify our desired infrastructure in a JSON or YAML file and submit that file to AWS’s infrastructure-as-code service:&#13;
CloudFormation.&#13;
The CloudFormation service takes our input file and makes the necessary changes to AWS infrastructure on our behalf, taking into account resource dependencies, the current state of previously deployed versions of our app, and the idiosyncrasies and specific requirements of the various AWS services.&#13;
A set of AWS resources created from a CloudFormation template file is called a <em>stack</em>.</p>&#13;
&#13;
<p>CloudFormation is AWS’s proprietary infrastructure-as-code service, but it’s not the only option in this area.&#13;
Other popular choices that work with AWS are Terraform, Ansible, and Chef.&#13;
Each service has its own configuration languages and patterns, but all achieve essentially the same outcome—cloud infrastructure provisioned from configuration files.</p>&#13;
&#13;
<p>A key benefit of using configuration files (rather than pointing and clicking in the console) is that those files, which represent our application infrastructure, can be version-controlled alongside our application source code.&#13;
We can see a complete timeline of changes to our infrastructure, using the same version-control tools we use for the other pieces of our application.&#13;
Furthermore, we can incorporate those configuration files into our continuous deployment pipelines, so when we make changes to our application infrastructure, those changes can be rolled out safely using industry-standard tools, alongside our application code.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="pagebreak-before less_space" data-pdf-bookmark="CloudFormation and the Serverless Application Model" data-type="sect1"><div class="sect1" id="cloudformation-and-sam">&#13;
<h1>CloudFormation and the Serverless Application Model</h1>&#13;
&#13;
<p>While<a data-primary="Serverless Application Model (SAM)" data-startref="sam04" data-type="indexterm" id="idm46222421239944"/><a data-primary="deployment" data-secondary="Serverless Application Model (SAM)" data-type="indexterm" id="Dsam04f"/> there are obvious benefits to an infrastructure-as-code approach, CloudFormation<a data-primary="CloudFormation" data-secondary="drawbacks of" data-type="indexterm" id="idm46222421237848"/><a data-primary="AWS SAM" data-secondary="versus CloudFormation" data-secondary-sortas="CloudFormation" data-type="indexterm" id="idm46222421236904"/> itself has a reputation for being verbose, unwieldy, and inflexible.&#13;
Configuration files for even the simplest application architectures can easily run into the hundreds or thousands of lines of JSON or YAML.&#13;
When dealing with an existing CloudFormation stack of that size, there’s an understandable temptation to fall back to using the AWS Web Console or CLI.</p>&#13;
&#13;
<p>Fortunately, as AWS serverless developers, we have the good fortune to be able to use a different “flavor” of CloudFormation called the<a data-primary="CloudFormation" data-secondary="versus Serverless Application Model (SAM)" data-secondary-sortas="Serverless Application Model (SAM)" data-type="indexterm" id="idm46222421234600"/> Serverless Application Model (SAM), which we used in Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch02.html#ch02">2</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch03.html#ch03">3</a>.&#13;
This is essentially a superset of CloudFormation, which allows us to use some special resource types and shortcuts to represent common serverless components and application architectures.&#13;
It also includes some special CLI commands to ease development, testing, and deployment.</p>&#13;
&#13;
<p>Here’s the SAM template we first used in <a data-type="xref" href="ch02.html#creating_the_lambda_function">“Creating the Lambda Function”</a>, updated to use our new ZIP deployment package (note that the <code>CodeUri</code> suffix has changed from <code>.jar</code> to <code>.zip</code>):</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">AWSTemplateFormatVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">2010-09-09</code>&#13;
<code class="nt">Transform</code><code class="p">:</code> <code class="l-Scalar-Plain">AWS::Serverless-2016-10-31</code>&#13;
<code class="nt">Description</code><code class="p">:</code> <code class="l-Scalar-Plain">Chapter 4</code>&#13;
&#13;
<code class="nt">Resources</code><code class="p">:</code>&#13;
  <code class="nt">HelloWorldLambda</code><code class="p">:</code>&#13;
    <code class="nt">Type</code><code class="p">:</code> <code class="l-Scalar-Plain">AWS::Serverless::Function</code>&#13;
    <code class="nt">Properties</code><code class="p">:</code>&#13;
      <code class="nt">Runtime</code><code class="p">:</code> <code class="l-Scalar-Plain">java8</code>&#13;
      <code class="nt">MemorySize</code><code class="p">:</code> <code class="l-Scalar-Plain">512</code>&#13;
      <code class="nt">Handler</code><code class="p">:</code> <code class="l-Scalar-Plain">book.HelloWorld::handler</code>&#13;
      <code class="nt">CodeUri</code><code class="p">:</code> <code class="l-Scalar-Plain">target/lambda.zip</code></pre>&#13;
&#13;
<p>We can deploy the new ZIP-based Lambda function using the same SAM command you learned in <a data-type="xref" href="ch02.html#ch02">Chapter 2</a>:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nv">$ </code>sam deploy <code class="se">\</code>&#13;
  --s3-bucket <code class="nv">$CF_BUCKET</code> <code class="se">\</code>&#13;
  --stack-name chapter4-sam <code class="se">\</code>&#13;
  --capabilities CAPABILITY_IAM</pre>&#13;
&#13;
<p><code>sam deploy</code> starts<a data-primary="sam deploy command" data-type="indexterm" id="idm46222421163000"/> by uploading our deployment package to S3, but only if the contents of that package have changed.&#13;
Earlier in the chapter, we spent some time setting up a reproducible build so that operations like this upload process don’t have to execute if nothing has actually changed.</p>&#13;
&#13;
<p>Behind the scenes <code>sam deploy</code> also creates a modified version of our template (also stored in S3) to reference the newly uploaded S3 locations of our artifact(s), rather than the local ones.&#13;
This step is necessary because CloudFormation requires any referenced artifacts within a template to be available in S3 at deployment time.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>The<a data-primary="Simple Storage Service (S3)" data-secondary="Lifecyle Policy" data-type="indexterm" id="idm46222421189112"/> files that <code>s3 deploy</code> stores in S3 should be considered merely staging versions as part of a deployment process, rather than application artifacts to be kept. Because<a data-primary="Lifecycle Policy" data-type="indexterm" id="idm46222421157512"/> of this, we recommend that you set a “Lifecycle Policy” on your SAM S3 bucket, if it isn’t being used for anything else, that will automatically delete the deployment artifacts after a period of time—we usually set it to a week.</p>&#13;
</div>&#13;
&#13;
<p>After the upload step, the <code>sam deploy</code> command creates a new CloudFormation stack if one doesn’t already exist with the provided name in this AWS account and region.&#13;
If<a data-primary="CloudFormation" data-secondary="change sets" data-type="indexterm" id="idm46222421155128"/> the stack already exists, the <code>sam deploy</code> command will create a CloudFormation <em>change set</em>, which lists which resources will be created, updated, or deleted <em>before</em> taking action.&#13;
The <code>sam deploy</code> command will then apply the change set to update the CloudFormation stack.</p>&#13;
&#13;
<p>Listing the stack resources, we can see that not only did CloudFormation create our Lambda function, but it also created the supporting IAM roles and policies (which we’ll explore later) without our having to specify them explicitly:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nv">$ </code>aws cloudformation list-stack-resources --stack-name chapter4-sam&#13;
<code class="o">{</code>&#13;
  <code class="s2">"StackResourceSummaries"</code>: <code class="o">[</code>&#13;
    <code class="o">{</code>&#13;
      <code class="s2">"LogicalResourceId"</code>: <code class="s2">"HelloWorldLambda"</code>,&#13;
      <code class="s2">"PhysicalResourceId"</code>: <code class="s2">"chapter4-sam-HelloWorldLambda-1HP15K6524D2E"</code>,&#13;
      <code class="s2">"ResourceType"</code>: <code class="s2">"AWS::Lambda::Function"</code>,&#13;
      <code class="s2">"LastUpdatedTimestamp"</code>: <code class="s2">"2019-07-26T19:16:34.424Z"</code>,&#13;
      <code class="s2">"ResourceStatus"</code>: <code class="s2">"CREATE_COMPLETE"</code>,&#13;
      <code class="s2">"DriftInformation"</code>: <code class="o">{</code>&#13;
        <code class="s2">"StackResourceDriftStatus"</code>: <code class="s2">"NOT_CHECKED"</code>&#13;
      <code class="o">}</code>&#13;
    <code class="o">}</code>,&#13;
    <code class="o">{</code>&#13;
      <code class="s2">"LogicalResourceId"</code>: <code class="s2">"HelloWorldLambdaRole"</code>,&#13;
      <code class="s2">"PhysicalResourceId"</code>:&#13;
        <code class="s2">"chapter4-sam-HelloWorldLambdaRole-1KV86CI9RCXY0"</code>,&#13;
      <code class="s2">"ResourceType"</code>: <code class="s2">"AWS::IAM::Role"</code>,&#13;
      <code class="s2">"LastUpdatedTimestamp"</code>: <code class="s2">"2019-07-26T19:16:30.287Z"</code>,&#13;
      <code class="s2">"ResourceStatus"</code>: <code class="s2">"CREATE_COMPLETE"</code>,&#13;
      <code class="s2">"DriftInformation"</code>: <code class="o">{</code>&#13;
        <code class="s2">"StackResourceDriftStatus"</code>: <code class="s2">"NOT_CHECKED"</code>&#13;
      <code class="o">}</code>&#13;
    <code class="o">}</code>&#13;
  <code class="o">]</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>In addition to Lambda functions, SAM includes resource types for<a data-primary="DynamoDB" data-secondary="support for" data-type="indexterm" id="idm46222421184872"/><a data-primary="API Gateway" data-secondary="SAM resources" data-type="indexterm" id="idm46222421079624"/> DynamoDB tables (<code>AWS::Serverless::SimpleTable</code>) and API Gateways (<code>AWS::Serverless::Api</code>).&#13;
These resource types are focused on popular use cases and may not be usable for all application architectures.&#13;
However, because SAM is a superset of CloudFormation, we can use plain old CloudFormation resource types in our SAM templates.&#13;
That means we can mix and match serverless and “normal” AWS components in our architectures, gaining the benefits of both approaches, and the idempotent CLI semantics of SAM’s <code>sam deploy</code> command.&#13;
You’ll see examples of combining SAM and CloudFormation resources in one template in <a data-type="xref" href="ch05.html#ch05">Chapter 5</a>.<a data-primary="" data-startref="LFdeploy04" data-type="indexterm" id="idm46222421075960"/><a data-primary="" data-startref="sam04" data-type="indexterm" id="idm46222421074984"/><a data-primary="" data-startref="Dsam04f" data-type="indexterm" id="idm46222421074040"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Security" data-type="sect1"><div class="sect1" id="idm46222421256664">&#13;
<h1>Security</h1>&#13;
&#13;
<p>Security permeates<a data-primary="security" data-secondary="necessary complexity and" data-type="indexterm" id="idm46222421071688"/><a data-primary="Lambda functions" data-secondary="effect of AWS security model" data-type="indexterm" id="LFsecurity04"/> every aspect of AWS.&#13;
As you learned in <a data-type="xref" href="ch02.html#ch02">Chapter 2</a>, we must deal with AWS’s security layer, called Identity and Access Management (IAM), from the very beginning.&#13;
However, rather than gloss over the details by simply running everything with the broadest, least-secure set of IAM permissions possible, we’re going to dive a little deeper in this section and explain how access to the Lambda platform is controlled by IAM, how that affects our functions’ interactions with other AWS resources, and how SAM makes it a bit easier to build secure applications.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="necessary-complexity">&#13;
<h5>Necessary Complexity</h5>&#13;
<p>It would be undeniably easier for us to build applications in AWS if we didn’t have to worry about IAM at all.&#13;
Why do we need it, and why does AWS require it?&#13;
To answer those questions, let’s imagine how the AWS ecosystem might work without IAM.</p>&#13;
&#13;
<p>Without IAM, our Lambda functions could access any other AWS resource, like a DynamoDB table or S3 bucket.&#13;
This is simple to reason about—if a resource exists, we can use it.&#13;
Of course, with no restrictions in place, we could even access resources in other AWS accounts, and those other accounts could access our <span class="keep-together">resources</span>!</p>&#13;
&#13;
<p>This world of “open access” might be convenient for developers, but unfortunately it’s a nightmare for security and privacy.&#13;
If we want to limit access to our applications and data, we need a system to enforce those limitations.&#13;
In AWS, IAM is that <span class="keep-together">system</span>.</p>&#13;
&#13;
<p>IAM controls access to AWS services by limiting who can perform certain actions against a set of resources.&#13;
The <em>who</em> in this case is an IAM principal, which is a user or role.&#13;
The actions and resources are defined in an IAM policy.&#13;
As you might imagine, IAM introduces a tremendous amount of complexity into our AWS applications, especially when we’re using many different serverless components and resources that each has its own action and resource specifications.</p>&#13;
&#13;
<p>But understanding IAM and using it correctly are critical to building serverless applications, as we’ll see in this chapter.</p>&#13;
</div></aside>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Principle of Least Privilege" data-type="sect2"><div class="sect2" id="idm46222421060824">&#13;
<h2>The Principle of Least Privilege</h2>&#13;
&#13;
<p>Unlike<a data-primary="security" data-secondary="principle of least privilege" data-type="indexterm" id="idm46222421059448"/><a data-primary="principle of least privilege" data-type="indexterm" id="idm46222421058376"/> in a traditional monolithic application, a serverless application could potentially have hundreds of individual AWS components, each with different behavior and access to different pieces of information.&#13;
If we simply applied the broadest security permissions possible, then every component would have access to every other component and piece of information in our AWS account.&#13;
Every gap we leave in a security policy is an opportunity for information to leak or be lost or be altered or for our application’s behavior to be changed.&#13;
And, if a single component is compromised, the entire AWS account (and any other applications deployed in it) is at risk as well.</p>&#13;
&#13;
<p>We can address this risk by applying the principle of “least privilege” to our security model.&#13;
In a nutshell, this principle states that every application and indeed every component of an application should have the least possible access it needs to perform its function.&#13;
For example, let’s consider a Lambda function that reads from a DynamoDB table.&#13;
The broadest possible permissions would allow that Lambda function to read, write, or otherwise interact with every other component and piece of information in the AWS account.&#13;
It could read from S3 buckets, create new Lambda functions, or even launch EC2 instances.&#13;
If the Lambda code had a bug or vulnerability (in parsing user input, for example), its behavior could be altered to do those things, and it wouldn’t be constrained by its IAM role.</p>&#13;
&#13;
<p>The principle of least privilege, applied to this particular Lambda function, would lead to an IAM role that allows the function to only access the DynamoDB service.&#13;
Going a step further, we might only allow the function to read data from DynamoDB and remove its ability to write data or to create or delete tables.&#13;
We can go even further in this case and restrict the function’s read-only access to the single DynamoDB table it requires.&#13;
Taken to the logical extreme, we can even restrict which items in the table the function can read, based on the user who has executed the function in the first place.</p>&#13;
&#13;
<p>Having applied the principle of least privilege to our Lambda function, we’ve now limited its access to only the specific resources that it needs to perform its job.&#13;
If the Lambda function was compromised or hacked in some way, its security policy would still constrain it to reading specific items from a single DynamoDB table.&#13;
That said, the principle of least privilege is not only applicable to preventing compromises.&#13;
It’s also an effective means of limiting the “blast radius” of bugs in your application code.</p>&#13;
&#13;
<p>Let’s consider a situation in which our Lambda function has a bug that, for example, uses the wrong value to delete data.&#13;
In a wide-open security model, that bug could result in the Lambda function deleting data for the wrong user!&#13;
However, because we’ve limited the “blast radius” of bugs by applying the principle of least privilege for our Lambda function, this particular issue will result in it simply doing nothing or throwing an error.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="control-plane-and-data-plane">&#13;
<h5>The Control Plane and the Data Plane</h5>&#13;
<p>As<a data-primary="security" data-secondary="control plane and data plane" data-type="indexterm" id="idm46222421050840"/><a data-primary="control plane" data-type="indexterm" id="idm46222421049816"/><a data-primary="data plane" data-type="indexterm" id="idm46222421049144"/> we briefly mentioned in <a data-type="xref" href="ch03.html#ch03">Chapter 3</a> (<a data-type="xref" href="ch03.html#lambda-execution-environment">Figure 3-1</a>), the Lambda service is split into the control plane and the data plane.&#13;
The control plane manages Lambda functions and provides APIs like CreateFunction, DeleteFunction, and UpdateFunctionCode.&#13;
The control plane also manages integrations with other AWS services.&#13;
Invocation of a Lambda function is handled by the data plane, which provides the Invoke and <span class="keep-together">InvokeAsync</span> APIs.</p>&#13;
&#13;
<p>When considering how IAM is integrated with Lambda, it’s important to understand which plane is involved.</p>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Identity and Access Management" data-type="sect2"><div class="sect2" id="IAM">&#13;
<h2>Identity and Access Management</h2>&#13;
&#13;
<p>A<a data-primary="security" data-secondary="Identity and Access Management (IAM)" data-type="indexterm" id="Siam04"/><a data-primary="IAM" data-see="Identity and Access Management (IAM)" data-type="indexterm" id="idm46222421041864"/> working knowledge of IAM is critical to successfully building any kind of application on AWS, and as we discussed in the previous section, effectively applying the principle of least privilege is even more important when building a serverless application.&#13;
IAM is a complex, multifaceted service, and we’re not going to come close to covering all of it here.&#13;
Rather, in this section, we’re just going to dive into IAM from the perspective of building serverless applications.&#13;
Where IAM most commonly and frequently comes into play for serverless applications is in execution roles, in the policies attached to those roles, and in policies attached to specific AWS resources.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Roles and policies" data-type="sect3"><div class="sect3" id="idm46222421039960">&#13;
<h3>Roles and policies</h3>&#13;
&#13;
<p>An<a data-primary="roles" data-type="indexterm" id="idm46222421038264"/><a data-primary="Identity and Access Management (IAM)" data-secondary="roles and policies" data-type="indexterm" id="idm46222421037528"/> IAM role is an identity that can be assumed by an AWS component (like a Lambda function).&#13;
A role differs from an IAM user in that a role is assumable by anyone (or anything) who needs it, and a role doesn’t have long-term access credentials.&#13;
With that in mind, we can define an IAM role as an assumable identity, with an attached set of permissions.</p>&#13;
&#13;
<p>The<a data-primary="assumable identity" data-type="indexterm" id="idm46222421035688"/><a data-primary="trust relationships" data-type="indexterm" id="idm46222421034952"/> phrase <em>assumable identity</em> might make it sound like anyone or anything can assume an IAM role.&#13;
If that were the case, then using roles wouldn’t really provide any benefit because there would be no restrictions on assuming a role and therefore no restrictions on what actions any given user or component could undertake.&#13;
Fortunately, IAM roles are not assumable by just anyone.&#13;
When building a role, we must specify who (or what) can assume that role.&#13;
For example, if we’re building a role for use by a Lambda function, we must explicitly grant the Lambda service (in this case the data plane) permission to assume that role, by specifying the following “trust <span class="keep-together">relationship”:</span></p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="p">{</code>&#13;
  <code class="nt">"Version"</code><code class="p">:</code> <code class="s2">"2012-10-17"</code><code class="p">,</code>&#13;
  <code class="nt">"Statement"</code><code class="p">:</code> <code class="p">[</code>&#13;
    <code class="p">{</code>&#13;
      <code class="nt">"Effect"</code><code class="p">:</code> <code class="s2">"Allow"</code><code class="p">,</code>&#13;
      <code class="nt">"Principal"</code><code class="p">:</code> <code class="p">{</code>&#13;
        <code class="nt">"Service"</code><code class="p">:</code> <code class="s2">"lambda.amazonaws.com"</code>&#13;
      <code class="p">},</code>&#13;
      <code class="nt">"Action"</code><code class="p">:</code> <code class="s2">"sts:AssumeRole"</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">]</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This statement specifies an effect (<code>Allow</code>), which applies to an action (<code>sts:Assume​Role</code>).&#13;
Most important, however, it specifies a principal, which is the identity that is allowed to assume the role.&#13;
In this case, we’re allowing the Lambda service’s data plane (<code>lambda.amazonaws.com</code>) to assume this role.&#13;
If we tried to use this role with a different service, like EC2 or ECS, it wouldn’t work unless we changed the principal.</p>&#13;
&#13;
<p>Now<a data-primary="permissions" data-type="indexterm" id="idm46222420979864"/> that we’ve established who can assume the role, we need to add permissions.&#13;
IAM roles don’t inherently have any permissions to access resources or perform actions.&#13;
Also, IAM’s default behavior is to deny permission, unless that permission is explicitly allowed in a policy.&#13;
Those permissions are contained in policies, which state permissions using the following constructs:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>An <em>effect</em> (like <code>Allow</code> or <code>Deny</code>)</p>&#13;
</li>&#13;
<li>&#13;
<p>A set of <em>actions</em>, which are generally namespaced to a specific AWS service (like <code>logs:PutLogEvents</code>)</p>&#13;
</li>&#13;
<li>&#13;
<p>A set of <em>resources</em>, which are generally<a data-primary="Amazon Resource Names (ARNs)" data-type="indexterm" id="idm46222420973160"/> Amazon Resource Names (ARNs) that define specific AWS components.&#13;
Different services support varying levels of specificity for resources.&#13;
For example, DynamoDB policies can apply down to the level of a table.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Here’s an<a data-primary="execution environment" data-secondary="logging" data-type="indexterm" id="idm46222420971464"/><a data-primary="logging" data-secondary="example policy" data-type="indexterm" id="idm46222420970456"/><a data-primary="CloudWatch Logs" data-secondary="example policy" data-type="indexterm" id="idm46222420969512"/> example policy that allows a set of actions against the “logs” service (aka CloudWatch Logs) and doesn’t restrict those actions to any particular “logs” resource:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="p">{</code>&#13;
  <code class="nt">"Version"</code><code class="p">:</code> <code class="s2">"2012-10-17"</code><code class="p">,</code>&#13;
  <code class="nt">"Statement"</code><code class="p">:</code> <code class="p">[</code>&#13;
    <code class="p">{</code>&#13;
      <code class="nt">"Effect"</code><code class="p">:</code> <code class="s2">"Allow"</code><code class="p">,</code>&#13;
      <code class="nt">"Action"</code><code class="p">:</code> <code class="p">[</code>&#13;
        <code class="s2">"logs:CreateLogGroup"</code><code class="p">,</code>&#13;
        <code class="s2">"logs:CreateLogStream"</code><code class="p">,</code>&#13;
        <code class="s2">"logs:PutLogEvents"</code>&#13;
      <code class="p">],</code>&#13;
      <code class="nt">"Resource"</code><code class="p">:</code> <code class="s2">"*"</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">]</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>We established earlier who can assume the role (the Lambda service’s data plane, as specified by the principal identifier <code>lambda.amazonaws.com</code>) and what permissions the role has.&#13;
By itself, however, this role isn’t used until it’s attached to a Lambda function, which we would need to explicitly configure.&#13;
That is, we need to tell the Lambda service to use this role when executing a particular Lambda function.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Lambda resource policies" data-type="sect3"><div class="sect3" id="idm46222421039368">&#13;
<h3>Lambda resource policies</h3>&#13;
&#13;
<p>As<a data-primary="resource policies" data-type="indexterm" id="idm46222420893624"/><a data-primary="Identity and Access Management (IAM)" data-secondary="Lambda resource policies" data-type="indexterm" id="idm46222420892888"/> if the world of security and IAM weren’t complex enough, AWS also occasionally uses IAM policies applied to resources (rather than identities) to control actions and access.&#13;
Resource policies invert control compared to an identity-based IAM policy: a resource policy states what other principals can do to the resource in question.&#13;
In particular, this is useful for allowing principals in different accounts access to certain resources (like Lambda functions or S3 buckets).</p>&#13;
&#13;
<p>A<a data-primary="invocation models" data-type="indexterm" id="idm46222420891000"/> Lambda function invocation resource policy consists of a series of statements, each of which specifies a principal, a list of actions, and a list of resources.&#13;
These policies are used by the Lambda data plane to determine whether to allow a caller (e.g., a principal) to successfully invoke a function.&#13;
Here’s an example Lambda resource policy (also called a <em>function policy</em>) that allows the API Gateway service to invoke a particular function:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting" id="policy-with-condition"><code class="p">{</code>&#13;
  <code class="nt">"Version"</code><code class="p">:</code> <code class="s2">"2012-10-17"</code><code class="p">,</code>&#13;
  <code class="nt">"Id"</code><code class="p">:</code> <code class="s2">"default"</code><code class="p">,</code>&#13;
  <code class="nt">"Statement"</code><code class="p">:</code> <code class="p">[</code>&#13;
    <code class="p">{</code>&#13;
      <code class="nt">"Sid"</code><code class="p">:</code> <code class="s2">"Stmt001"</code><code class="p">,</code>&#13;
      <code class="nt">"Effect"</code><code class="p">:</code> <code class="s2">"Allow"</code><code class="p">,</code>&#13;
      <code class="nt">"Principal"</code><code class="p">:</code> <code class="p">{</code>&#13;
        <code class="nt">"Service"</code><code class="p">:</code> <code class="s2">"apigateway.amazonaws.com"</code>&#13;
      <code class="p">},</code>&#13;
      <code class="nt">"Action"</code><code class="p">:</code> <code class="s2">"lambda:invokeFunction"</code><code class="p">,</code>&#13;
      <code class="nt">"Resource"</code><code class="p">:</code>&#13;
        <code class="s2">"arn:aws:lambda:us-east-1:555555555555:function:MyLambda"</code><code class="p">,</code>&#13;
      <code class="nt">"Condition"</code><code class="p">:</code> <code class="p">{</code>&#13;
        <code class="nt">"ArnLike"</code><code class="p">:</code> <code class="p">{</code>&#13;
          <code class="nt">"AWS:SourceArn"</code><code class="p">:</code> <code class="s2">"arn:aws:execute-api:us-east-1:</code>&#13;
<code class="s2">            555555555555:xxx/*/GET/locations"</code>&#13;
        <code class="p">}</code>&#13;
      <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">]</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In this policy, we’ve also added a condition, which more specifically limits the allowed source of the action to only API Gateway deployments with an ID of “xxx” that include the “/GET/locations” path.&#13;
Conditions are service-specific and depend on what information the caller makes available.</p>&#13;
&#13;
<p>Let’s work through the scenario in which API Gateway invokes a Lambda function, using <a data-type="xref" href="#lambda-and-iam-security">Figure 4-1</a>.</p>&#13;
&#13;
<figure><div class="figure" id="lambda-and-iam-security">&#13;
<img alt="images/ch04_image01.png" src="assets/awsl_0401.png"/>&#13;
<h6><span class="label">Figure 4-1. </span>Overview of Lambda and IAM security</h6>&#13;
</div></figure>&#13;
<ol>&#13;
<li>&#13;
<p>Did the caller have permission to call the API?&#13;
For this scenario, we’ll assume the answer is yes.&#13;
Please see the <a href="https://oreil.ly/Sb6N2">API Gateway documentation</a> for more information.</p>&#13;
</li>&#13;
<li>&#13;
<p>The API Gateway API is attempting to invoke the Lambda function.&#13;
Does the Lambda service allow this?&#13;
This is controlled by a Lambda function invocation resource policy.</p>&#13;
</li>&#13;
<li>&#13;
<p>What permissions should the Lambda function code have when it executes?&#13;
This is controlled by the Lambda execution role, and that role is assumed through a trust relationship with the Lambda service.</p>&#13;
</li>&#13;
<li>&#13;
<p>The Lambda code is trying to put an item into a DynamoDB table.&#13;
Can it do that?&#13;
This is controlled by a permission, which comes from an IAM policy attached to the Lambda execution role.</p>&#13;
</li>&#13;
<li>&#13;
<p>DynamoDB doesn’t use resource policies, so calls from anyone (including Lambda functions) are permitted, as long as their role (e.g., the Lambda execution role) permits it.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="SAM IAM" data-type="sect3"><div class="sect3" id="idm46222420804040">&#13;
<h3>SAM IAM</h3>&#13;
&#13;
<p>Unfortunately, the<a data-primary="SAM IAM" data-type="indexterm" id="idm46222420802712"/><a data-primary="Identity and Access Management (IAM)" data-secondary="SAM IAM" data-type="indexterm" id="idm46222420801976"/> complexity of IAM puts its effective use somewhat at odds with a rapid prototyping workflow.&#13;
Throw a serverless application architecture into the mix, and it’s no wonder so many Lambda execution roles have completely open policies, allowing all forms of access to every resource in the AWS account.&#13;
Even though it’s easy to agree that the principle of least privilege provides valuable benefits, when faced with the somewhat daunting task of implementing it using IAM for dozens or hundreds of AWS resources, many otherwise conscientious engineers choose to forgo security for simplicity.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Autogenerated execution roles and resource policies" data-type="sect4"><div class="sect4" id="idm46222420800152">&#13;
<h4>Autogenerated execution roles and resource policies</h4>&#13;
&#13;
<p>Fortunately, the<a data-primary="resource policies" data-type="indexterm" id="idm46222420798824"/><a data-primary="execution environment" data-secondary="autogenerated execution roles" data-type="indexterm" id="idm46222420798088"/> Serverless Application Model addresses this issue in a few different ways.&#13;
In the simplest of cases, it will automatically create the appropriate Lambda execution roles and function policies, based on the various functions and event sources configured in the SAM infrastructure template.&#13;
This neatly handles permissions for executing Lambda functions and allowing them to be invoked by other AWS services.</p>&#13;
&#13;
<p>For example, if you configured a single Lambda function with no triggers, SAM will automatically generate a Lambda execution role for that function, which would allow it to write to CloudWatch Logs.&#13;
If you then added an API Gateway trigger to that Lambda function, SAM will generate a Lambda function invocation resource policy, which allows the Lambda function to be invoked by the API Gateway platform.&#13;
This will make our lives a little easier in the next chapter!</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Common policy templates" data-type="sect4"><div class="sect4" id="idm46222420795464">&#13;
<h4>Common policy templates</h4>&#13;
&#13;
<p>Of course, if your Lambda function needs to interact with other AWS services in code (for example, to write to a DynamoDB table), it will likely require additional permissions.&#13;
For these situations, SAM provides a selection of common IAM policy templates that allow us to concisely specify permissions and resources.&#13;
Those templates are then expanded during the SAM deployment process and become fully specified IAM policy statements.&#13;
Here we’ve added a DynamoDB table to our SAM template.&#13;
We’ve used a SAM policy template to allow our Lambda function to perform create, read, update, and delete actions (aka CRUD) against that DynamoDB table.</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">AWSTemplateFormatVersion</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">2010-09-09</code><code>&#13;
</code><code class="nt">Transform</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">AWS::Serverless-2016-10-31</code><code>&#13;
</code><code class="nt">Description</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">Chapter</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">4</code><code>&#13;
&#13;
</code><code class="nt">Resources</code><code class="p">:</code><code>&#13;
&#13;
</code><code>  </code><code class="nt">HelloWorldLambda</code><code class="p">:</code><code>&#13;
</code><code>    </code><code class="nt">Type</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">AWS::Serverless::Function</code><code>&#13;
</code><code>    </code><code class="nt">Properties</code><code class="p">:</code><code>&#13;
</code><code>      </code><code class="nt">Runtime</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">java8</code><code>&#13;
</code><code>      </code><code class="nt">MemorySize</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">512</code><code>&#13;
</code><code>      </code><code class="nt">Handler</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">book.HelloWorld::handler</code><code>&#13;
</code><code>      </code><code class="nt">CodeUri</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">target/lambda.zip</code><code>&#13;
</code><code>      </code><code class="nt">Policies</code><code class="p">:</code><code>&#13;
</code><code>        </code><code class="nt">— DynamoDBCrudPolicy</code><code class="p">:</code><code>&#13;
</code><code>          </code><code class="nt">TableName</code><code class="p">:</code><code> </code><code class="kt">!Ref</code><code> </code><code class="l-Scalar-Plain">HelloWorldTable</code><code> </code><a class="co" href="#callout_operating_aws_lambda_functions_CO2-1" id="co_operating_aws_lambda_functions_CO2-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
&#13;
</code><code>  </code><code class="nt">HelloWorldTable</code><code class="p">:</code><code>&#13;
</code><code>    </code><code class="nt">Type</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">AWS::Serverless::SimpleTable</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_operating_aws_lambda_functions_CO2-1" id="callout_operating_aws_lambda_functions_CO2-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Here we’ve used the CloudFormation Intrinsic Function <a href="https://oreil.ly/ScQ9Q"><code>Ref</code></a>, which allows us to use the logical ID of a resource (in this case <code>HelloWorldTable</code>) as a placeholder for the physical ID of the resource (which would be something like <code>stack-name-HelloWorldTable-ABC123DEF</code>). The CloudFormation service will resolve logical IDs to physical IDs when a stack is created or updated.<a data-primary="" data-startref="LFsecurity04" data-type="indexterm" id="idm46222420689336"/><a data-primary="" data-startref="Siam04" data-type="indexterm" id="idm46222420694856"/></p></dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm46222420697208">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>In this chapter, we covered building and packaging Lambda code and dependencies in a reproducible, deterministic way.&#13;
We started to use AWS’s SAM to specify our infrastructure (e.g., our Lambda function and later a DynamoDB table) as YAML code—we’ll explore this much further in <a data-type="xref" href="ch05.html#ch05">Chapter 5</a>.&#13;
We then explored the two different kinds of IAM constructs that affect Lambda functions: execution roles and resource policies.&#13;
Finally, using SAM instead of raw CloudFormation meant that we didn’t have to add very much additional YAML code to apply the principle of least privilege to the IAM roles and policies for our Lambda function.</p>&#13;
&#13;
<p>We now have nearly all the basic building blocks in place to create complete applications using Lambda and associated tools.&#13;
In <a data-type="xref" href="ch05.html#ch05">Chapter 5</a> we’ll show how to tie Lambda functions to event sources and then build two example applications.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Exercises" data-type="sect1"><div class="sect1" id="idm46222420700648">&#13;
<h1>Exercises</h1>&#13;
<ol>&#13;
<li>&#13;
<p>Deliberately<a data-primary="exercises" data-secondary="operating AWS Lambda functions" data-type="indexterm" id="idm46222420705128"/> misconfigure the Lambda function in this chapter by setting the <code>Handler</code> property to <code>book.HelloWorld::foo</code>.&#13;
What happens when the function is deployed? What happens when you invoke the function?</p>&#13;
</li>&#13;
<li>&#13;
<p>Read the <a href="https://oreil.ly/nBdd9">IAM reference guide</a> to learn which AWS services (and actions) can have granular IAM permissions.</p>&#13;
</li>&#13;
<li>&#13;
<p>If you’d like an extra challenge, replace <code>AWS::Serverless::Function</code> with <code>AWS::Lambda::Function</code> in the <em>template.yaml</em> file.&#13;
What other changes do you have to make for CloudFormation to deploy your function?&#13;
If you get stuck, you can look at the post-transform template (for the original stack) via the CloudFormation web console.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>