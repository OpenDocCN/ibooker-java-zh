- en: 'Chapter 5\. Beyond Lift and Shift: Working with Legacy'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。超越简单迁移：与遗留系统合作
- en: Legacy is not what I did for myself. It’s what I’m doing for the next generation.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 遗留不是我为自己做的事。这是我为下一代正在做的事。
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Vitor Belfort
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 维托尔·贝尔福特
- en: Many organizations are faced with the challenge of keeping their existing business
    operations running while also trying to innovate. There are typically increased
    expectations to deliver new functionality faster and to reduce cost, something
    that seems challenging when looking at the existing application landscape and
    prevalence of legacy systems.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 许多组织面临着在保持现有业务运营的同时试图创新的挑战。通常期望更快地交付新功能并降低成本，看起来似乎是一项具有挑战性的任务，特别是在审视现有应用程序景观和遗留系统的普及时。
- en: 'We often use the term “legacy system” to describe an old methodology, or technology,
    or application that is not written according to the latest methods or uses an
    outdated technology stack. Admittedly, many of the systems we created early on
    in our career belong to this category. We do know that most of them are still
    in use. Some of them even paved the way for new approaches or even standards that
    followed them. We usually also imply that those systems would need a replacement,
    which ultimately contributes to the perceived negative connotation. Thankfully,
    this isn’t always true. Legacy also is a beautiful word to describe achievements
    and heritage. Calling something “legacy” doesn’t automatically make it outdated
    and unusable. There are plenty of reasons to keep the legacy systems in place,
    including:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常使用术语“遗留系统”来描述一种旧的方法、技术或应用程序，该方法、技术或应用程序不符合最新的方法或使用过时的技术堆栈。诚然，我们在职业生涯早期创建的许多系统都属于这一类别。我们知道其中大多数仍在使用。其中一些甚至为后来的新方法或标准铺平了道路。我们通常也意味着这些系统需要替换，这最终会导致负面含义的感知。幸运的是，这并不总是真的。遗留也是一个美丽的词汇，用来描述成就和遗产。称某物为“遗留”并不自动使其过时和无用。保留遗留系统的理由有很多，包括：
- en: The system works as designed, and there is no need to change.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统按设计工作，无需更改。
- en: The business processes implemented are no longer known or documented, and replacing
    them is expensive.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施的业务流程已不再为人所知或记录，而替换它们是昂贵的。
- en: The cost for replacing a system is higher than the benefit of keeping it unchanged.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替换系统的成本高于保持不变的好处。
- en: The book [*Working Effectively with Legacy Code*](https://oreil.ly/iogGC) by
    Michael Feathers (O’Reilly) provides programmers with techniques to cost-effectively
    handle common legacy code problems without having to go through the hugely expensive
    task of rewriting all existing code.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 由Michael Feathers（O’Reilly）著作的[*与遗留代码有效工作*](https://oreil.ly/iogGC)为程序员提供了技术，以成本效益地处理常见的遗留代码问题，而无需重新编写所有现有代码的巨大费用。
- en: Feathers said, “To me, legacy code is simply code without tests.” If we read
    the term “legacy” today, it primarily refers to monolithic applications. There
    are various approaches to handling legacy applications in a modern enterprise
    landscape, and picking the right one is the first and most crucial part of the
    modernization journey.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Feathers说：“对我而言，遗留代码就是没有测试的代码。”如果我们今天阅读术语“遗留”，它主要指的是单块应用程序。在现代企业景观中处理遗留应用程序有多种方法，选择正确的方法是现代化旅程的第一步，也是最关键的部分。
- en: 'We’ve only talked about individual systems so far. And developers usually only
    care about this specific system scope. Modernization plans should follow overarching
    company goals and should also take the company-wide IT strategy into account.
    A particularly exciting approach for cloud migration is presented in Gregor Hohpe’s
    book [*Cloud Strategy: A Decision-Based Approach to Successful Cloud Migration*](https://oreil.ly/EuW9J).
    It is a must-read if you want to know more about building the abstraction above
    individual migration efforts.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只谈论了个别系统。开发人员通常只关心这个特定的系统范围。现代化计划应遵循全面的公司目标，还应考虑公司整体的IT战略。云迁移的一种特别激动人心的方法在Gregor
    Hohpe的书[*云策略：成功云迁移的基于决策的方法*](https://oreil.ly/EuW9J)中提出。如果你想了解更多关于在个别迁移工作之上构建抽象的信息，这本书是必读之选。
- en: Managing Legacy
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理遗留
- en: Every successful journey begins with a first step. The first step for an application
    migration journey is the assessment of the existing applications. We assume that
    you know the company-wide goals and directives. We can map them into assessment
    categories now. Another source for assessment categories is technical requirements—for
    example, existing blueprints or recommended master solutions or framework versions.
    Building and updating this list of assessment categories should be a recurring
    task that becomes part of your governance process. Ultimately, you can derive
    migration criteria from these assessment criteria and use them as decision-making
    cornerstones for your modernization journey.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 每一次成功的旅程都始于第一步。应用程序迁移旅程的第一步是评估现有应用程序。我们假设您了解公司的整体目标和指令。现在我们可以将它们映射到评估类别中。评估类别的另一个来源是技术要求，例如现有的蓝图或推荐的主要解决方案或框架版本。构建和更新这个评估类别列表应该成为您管理流程的一部分。最终，您可以从这些评估标准中导出迁移标准，并将它们用作现代化旅程的决策基石。
- en: Assessing Applications for Migration
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 评估迁移应用程序
- en: 'When assessing a migration or modernization effort, it is essential to consider
    the specific challenges that motivate or influence your organization. Some examples
    of challenges that organizations might face include:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估迁移或现代化工作时，重要的是考虑到激励或影响您的组织的特定挑战。组织可能面临的一些挑战的例子包括：
- en: Limited budgets for development
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 开发的有限预算
- en: Development teams need to become more efficient, and their velocity has to increase.
    Instead of working with complex specifications, they aim to switch to lightweight
    frameworks and prebuilt functionalities. Modernizations should be usually scheduled
    as part of an ongoing development or maintanance project.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 开发团队需要变得更加高效，并且他们的速度必须增加。他们的目标不是使用复杂的规范，而是转向轻量级框架和预构建功能。现代化通常应该作为正在进行的开发或维护项目的一部分来安排。
- en: Lack of in-house skills
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 缺乏内部技能
- en: The team skills for existing in-house technologies are decreasing. Examples
    of this are host programming or even earlier versions of Enterprise Java specifications
    that are no longer taught or state-of-the-art. Changing existing systems that
    use older technologies might mean needing to add specific skills for the development
    project.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 内部现有技术的团队技能正在减少。这样的例子包括主机编程甚至是早期版本的企业Java规范，这些规范已经不再教授或不再是最先进的。更改使用较旧技术的现有系统可能意味着需要为开发项目添加特定技能。
- en: Perceived risks
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 感知风险
- en: Following a famous proverb popularized around 1977, “If it ain’t broken, don’t
    fix it,” we do see a lot of perceived risks to changing well-established and running
    software. The reasons for this can be numerous and range from knowledge issues
    about the system to fear of stopped production in factories. These risks need
    to be addressed individually and mitigated through suitable actions in the migration
    plan.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 按照1977年左右广为流传的一句名言，“如果它没有坏，就不要修理”，我们确实看到了许多围绕更改已经建立并运行的软件的感知风险。导致这种情况的原因有很多，从对系统的知识问题到对工厂停产的恐惧。这些风险需要单独解决，并通过迁移计划中的适当行动来缓解。
- en: No known predictable process
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 没有可预测的过程
- en: This book helps you with this particular point. Navigating the unknown can be
    a considerable challenge. Having a proven and repeatable process for modernization
    efforts in place that all parties respect and follow is critical for success.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书将帮助您解决这个特定问题。探索未知可能是一个巨大的挑战。对于现代化工作，已经有一个经过验证且可重复的流程，并且所有参与方都尊重并遵循这个流程对于成功至关重要。
- en: Real effort estimation
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的工作量估计
- en: Estimating migration efforts should not be magic. Unfortunately, many companies
    have a minimal idea about the genuine efforts to modernize Enterprise Java applications.
    Following a predictable and optimized approach will remove this challenge.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 估计迁移工作量不应该是魔术。不幸的是，许多公司对现代化企业Java应用程序的真实工作量几乎一无所知。遵循可预测和优化的方法将消除这种挑战。
- en: 'Turning these challenges into actionable items for your assessment can look
    like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些挑战转化为可操作项，供您的评估看起来可以像这样：
- en: Predicting the level of effort and cost
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预测工作量和成本水平
- en: Scheduling application migrations and handling conflicts
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安排应用程序迁移并处理冲突
- en: Identifying all potential risks at a code, infrastructure, process, or knowledge
    level
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别代码、基础架构、流程或知识层面的所有潜在风险
- en: Predicting the return on investment to make the business case
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预测投资回报以制定业务案例
- en: Identifying and mitigating risks to the business
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别和缓解对业务的风险
- en: Minimizing disruption to existing business operations
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化对现有业务运营的干扰
- en: It is sufficient to do this in a spreadsheet or document if you are only looking
    at a single application. However, every mid- to large-scale effort needs a better
    solution. Large-scale efforts need automated routines and rules to assess an install
    base and link applications to business services to plan the next steps reliably.
    An open source and straightforward way of gathering and managing all relevant
    information comes from the [Konveyor project](https://www.konveyor.io). It combines
    a set of tools that aim at helping with modernization and migration onto Kubernetes.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只是查看单个应用程序，可以在电子表格或文档中完成这项工作就足够了。然而，每一个中大型工作都需要一个更好的解决方案。大规模工作需要自动化例行程序和规则来评估安装基础，并将应用程序链接到业务服务，以可靠地规划下一步操作。一个开放源码且直接的方法是来自于[Konveyor
    项目](https://www.konveyor.io)。它结合了一系列工具，旨在帮助现代化和迁移到 Kubernetes。
- en: The Konveyor subproject Forklift provides the ability to migrate virtual machines
    to KubeVirt with minimal downtime. The subproject Crane concentrates on migrating
    applications between Kubernetes clusters. Also part of the suite is Move2Kube
    to help accelerate the replatforming of Swarm and Cloud Foundry-based applications
    to Kubernetes.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Konveyor 子项目 Forklift 提供将虚拟机迁移到 KubeVirt 的能力，且最小化停机时间。子项目 Crane 则专注于在 Kubernetes
    集群之间迁移应用程序。套件的一部分还包括 Move2Kube，以帮助加速将 Swarm 和基于 Cloud Foundry 的应用程序重新平台化到 Kubernetes。
- en: For application modernization in particular, Konveyor offers the [Tackle](https://oreil.ly/u99Gf)
    project. It assesses and analyzes applications for refactoring into containers
    and provides a standard inventory.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是对于应用现代化，Konveyor 提供了[Tackle](https://oreil.ly/u99Gf) 项目。它评估和分析应用程序，以便重构为容器，并提供标准清单。
- en: Tackle Application Inventory
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Tackle 应用程序清单
- en: This allows users to maintain their portfolio of applications, link them to
    the business services they support, and define their interdependencies. The Application
    Inventory uses an extensible tagging model to add metadata, which is a great way
    to link migration categories, as discussed earlier. The Application Inventory
    is used to select an application for an assessment by Pathfinder.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以通过这种方式维护其应用程序组合，将它们链接到它们支持的业务服务，并定义它们之间的相互依赖关系。应用程序清单使用可扩展的标记模型来添加元数据，这是一种链接迁移类别的好方法，正如前文所讨论的。应用程序清单用于通过
    Pathfinder 进行评估选择应用程序。
- en: Tackle Pathfinder
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Tackle Pathfinder
- en: 'This is an interactive, questionnaire-based tool that assesses the suitability
    of applications for modernization so they can be deployed in containers on an
    enterprise Kubernetes platform. [Pathfinder](https://oreil.ly/K4V4u) generates
    reports about an application’s suitability for Kubernetes, including the associated
    risk, and creates an adoption plan. Pathfinder does this based on the information
    present in the application inventory and additional assessment questions. If an
    application depends on a direct host system connection, it might disqualify this
    particular application for a migration to Kubernetes because it would overload
    the host parts. Some examples of assessment questions are:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基于问卷的交互式工具，评估应用程序是否适合现代化，以便在企业 Kubernetes 平台上部署容器。[Pathfinder](https://oreil.ly/K4V4u)
    生成关于应用程序适合 Kubernetes 的报告，包括相关风险，并创建采纳计划。Pathfinder 根据应用程序清单和额外的评估问题进行操作。如果应用程序依赖于直接主机系统连接，这可能会使得此特定应用程序不适合迁移到
    Kubernetes，因为它会过载主机部分。一些评估问题的例子包括：
- en: Are third-party vendor components supported in containers?
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三方供应商组件在容器中是否受支持？
- en: Is the application under active development?
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序是否处于积极开发中？
- en: Does the application have any legal requirements (e.g., PCI, HIPAA)?
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序是否有任何法律要求（例如 PCI、HIPAA）？
- en: Does the application provide metrics?
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序是否提供指标？
- en: We strongly recommend looking at Pathfinder to manage large-scale modernization
    projects across complete landscapes. It will help you categorize and prioritize
    applications in your scope today and continuously track your migration assessment
    for future changes.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强烈建议查看 Pathfinder 来管理完整景观的大规模现代化项目。它将帮助您对今天的范围内的应用程序进行分类和优先级排序，并持续跟踪您的迁移评估以适应未来的变化。
- en: Tackle Controls
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Tackle 控制
- en: Controls are a collection of entities that add different values to the Application
    Inventory and the Pathfinder assessment. They comprise business services, stakeholders,
    stakeholder groups, job functions, tag types, and tags. In addition, you can capture
    company- or project-specific attributes by implementing your own entities. This
    will filter your Application Inventory, for example, all applications used by
    a certain “job function” to identify all applications used by the human resources
    department.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 控制项是一组实体，它们为应用清单和路径评估添加不同的值。它们包括业务服务、利益相关者、利益相关者群体、工作职能、标签类型和标签。此外，您可以通过实施自己的实体来捕获公司或项目特定的属性。例如，这将过滤您的应用清单，识别所有由某个“工作职能”使用的应用程序，以识别人力资源部门使用的所有应用程序。
- en: Tackle DiVA
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决DiVA
- en: 'Finally, [DiVA](https://oreil.ly/UGzn2) is a data-centric application analysis
    tool. As a successor to the project [Windup](https://oreil.ly/sjiNq), it is the
    most exciting project to look at if you want to assess individual applications.
    It focuses on the traditional monolithic application and currently supports Servlets
    and Spring Boot applications. You can import a set of application source files
    (Java/XML), and DiVA then provides the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，[DiVA](https://oreil.ly/UGzn2)是一款以数据为中心的应用程序分析工具。作为项目[Windup](https://oreil.ly/sjiNq)的继任者，如果您想评估单个应用程序，它是最令人兴奋的项目。它专注于传统的单片应用程序，目前支持Servlets和Spring
    Boot应用程序。您可以导入一组应用程序源文件（Java/XML），然后DiVA会提供以下内容：
- en: Service entry (exported API) inventory
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务入口（导出的API）清单
- en: Database inventory
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库清单
- en: Transaction inventory
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事务清单
- en: Code-to-Database dependencies (call graphs)
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码到数据库的依赖关系（调用图）
- en: Database-to-Database dependencies
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库对数据库的依赖关系
- en: Transaction-to-Transaction dependencies
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事务对事务的依赖关系
- en: Transaction refactoring recommendations
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事务重构建议
- en: DiVA is currently under active development, and the incorporation of the original
    Windup project isn’t finished yet. However, it still gives you a solid foundation
    for your modernization efforts. Additionally, it presents an excellent opportunity
    to contribute your findings and become part of a larger community dedicated to
    automating migrations.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: DiVA目前正在积极开发中，原始Windup项目的整合尚未完成。但是，它仍然为您的现代化工作提供了坚实的基础。此外，它提供了一个绝佳的机会，让您贡献自己的发现，并成为致力于自动化迁移的更大社区的一部分。
- en: Migration Toolkit for Applications
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用程序迁移工具包
- en: While we wait for Windup to be fully integrated into DiVA, you can still use
    an automated migration assessment for Enterprise Java-based applications by using
    the [Migration Toolkit for Applications (MTA)](https://oreil.ly/SIOSR).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们等待Windup完全集成到DiVA时，您仍然可以使用[应用程序迁移工具包（MTA）](https://oreil.ly/SIOSR)对基于Enterprise
    Java的应用程序进行自动迁移评估。
- en: MTA assembles tools that support large-scale Enterprise Java application modernization
    and migration projects across many transformations and use cases. You can import
    your application binary or archives into it, and it automatically performs code
    analysis, including the application portfolio, application dependencies, migration
    challenges, and migration effort estimation in the form of story points. Initially
    it was designed to support Java EE server migrations (e.g., WebSphere or WebLogic
    to JBoss EAP). Still, it has a highly extensible rule set mechanism that allows
    developers to create their own set of rules or even adapt existing ones to their
    needs. Today it also covers Spring Boot to Quarkus migrations.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: MTA组装了支持大规模企业Java应用现代化和迁移项目的工具，涵盖了许多转换和用例。您可以将您的应用程序二进制文件或存档导入其中，它会自动执行代码分析，包括应用程序组合、应用程序依赖关系、迁移挑战和以故事点形式的迁移工作量估算。最初它是设计用于支持Java
    EE服务器迁移（例如，从WebSphere或WebLogic到JBoss EAP）。但是，它具有高度可扩展的规则集机制，允许开发人员创建自己的规则集，甚至是适应其需求的现有规则。今天它还涵盖了Spring
    Boot到Quarkus的迁移。
- en: 'An excerpt from an example rule in Java looks like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Java示例规则摘录如下：
- en: '[PRE0]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This rule scans Java classes for `@WLServlet` annotations and adds an effort
    (story points) to this finding. You can learn more about rules and how to develop
    them in the [Windup documentation](https://oreil.ly/FbQKL).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此规则扫描Java类以查找`@WLServlet`注释，并为此结果添加一项工作量（故事点）。您可以在[Windup文档](https://oreil.ly/FbQKL)中了解更多关于规则以及如何开发它们的信息。
- en: Beyond that, it can also support nonmigration use cases as part of a build process
    (via a [Maven plug-in](https://oreil.ly/T8mom) or a [Command Line Interface](https://oreil.ly/U7Dsk)),
    either validating code regularly against organizational standards or ensuring
    application portability.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它还可以作为构建过程的一部分支持非迁移用例（通过 [Maven 插件](https://oreil.ly/T8mom) 或 [命令行界面](https://oreil.ly/U7Dsk)），定期验证代码是否符合组织标准或确保应用程序的可移植性。
- en: 'Some of the patterns MTA can detect include the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: MTA 可以检测到的一些模式包括以下内容：
- en: Proprietary libraries
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专有库
- en: Proprietary configurations
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专有配置
- en: Service locators
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务定位器
- en: Web services
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web 服务
- en: EJB descriptors
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EJB 描述符
- en: Deprecated Java code
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 废弃的 Java 代码
- en: Transaction managers
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事务管理器
- en: Injection frameworks
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注入框架
- en: Thread pooling mechanisms
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程池机制
- en: Timer services
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定时器服务
- en: WAR/EAR descriptors
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WAR/EAR 描述符
- en: Static IP addresses
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态 IP 地址
- en: MTA and DiVA are two potent tools that help us identify overall technical debt,
    resulting in a classification of migration needs and risks. However, they do not
    allow us to identify the functionality that should be migrated or modernized first.
    For this, we need to take a deeper look into the application design and functionality.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: MTA 和 DiVA 是两个强大的工具，帮助我们识别总体技术债务，导致迁移需求和风险的分类。然而，它们不能帮助我们识别应首先迁移或现代化的功能。为此，我们需要深入研究应用程序设计和功能。
- en: Assessing Functionality for Migration
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 评估迁移功能
- en: Traditional monoliths come in various shapes, forms, and sizes. When someone
    uses the term “monolith,” they are usually referring to the deployment artifact
    itself. In Enterprise Java, this has traditionally been Enterprise Archives (EAR)
    or Web Archives (WAR). You can also look at them as single-process applications.
    They can be designed following modularity recommendations like OSGi (Open Services
    Gateway Initiative) or following more technical approaches like the three-tier
    design without significant business modules. The overall direction of your modernization
    efforts heavily depends on the type of monolith you are dealing with. As a rule
    of thumb, the more modular an existing application already is, the easier it is
    to modernize it. In a perfect world, modules directly translate into service boundaries.
    But this rarely happens.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的单体应用有各种形状、形式和大小。当有人使用术语“单体”时，他们通常指的是部署工件本身。在企业 Java 中，这传统上是企业归档（EAR）或 Web
    归档（WAR）。你也可以将它们视为单一进程应用程序。它们可以按照像 OSGi（开放服务网关倡议）这样的模块化建议进行设计，或者按照更技术化的方法，如三层设计，没有显著的业务模块。您的现代化努力的整体方向在很大程度上取决于您正在处理的单体类型。作为一个经验法则，现有应用程序越模块化，现代化的难度就越小。在理想的情况下，模块直接转化为服务边界。但这种情况很少发生。
- en: If the monolith seems like a giant box, we have to apply a logical model to
    it. And we realize that inside this box are organized business and technical components,
    for example, order management, PDF rendering, client notifications, etc. While
    the code is probably not organized around these concepts, they exist in the codebase
    from a business-domain-model perspective. These business domain boundaries, often
    called “bounded contexts” in Domain-Driven-Design (DDD), become the new services.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果单体看起来像一个巨大的盒子，我们必须对其应用逻辑模型。我们意识到在这个盒子内部有组织良好的业务和技术组件，例如订单管理、PDF 渲染、客户通知等。虽然代码可能并未围绕这些概念组织，但从业务领域模型的角度来看，它们存在于代码库中。这些业务领域边界，在领域驱动设计（DDD）中通常称为“有界上下文”，成为新的服务。
- en: Note
  id: totrans-81
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you are interested in learning more, many consider Eric Evans’s book [*Domain-Driven
    Design: Tackling Complexity in the Heart of Software* (O’Reilly)](https://oreil.ly/kgLPl)
    the de facto standard introduction to DDD.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有兴趣了解更多信息，许多人认为 Eric Evans 的书 [*《领域驱动设计：软件核心复杂性应对之道》（O’Reilly）*](https://oreil.ly/kgLPl)
    是DDD的事实标准介绍。
- en: Once you have identified the modules and functionality, you can start to think
    about your modernizing order. But first, make sure to look at the cost versus
    benefit tradeoffs for each module and start with the best candidate. [Figure 5-1](#fig5-1)
    gives a very high-level overview of how this could look for a sample application
    with six modules. Let’s assume we are talking about a fictitious online shop in
    this case. For modules that are heavily interdependent, for example, Order and
    Customer, it will be complex to extract them individually. If you also consider
    the necessity for scalability and with that the benefit of removing them from
    a monolith, it might not be very high. Those two modules reside on the lower left
    side of the graph. On the opposite side, we might find the Catalog service. It
    lists the available products and is a read-only service with very little interdependencies.
    During high demand on the website, this is the number-one requested module, and
    it benefits heavily from being extracted, as shown in Figure 5-1, indicated by
    the green module in the upper right of the graph. Do a similar exercise for all
    the modules in your application to assess cost versus benefit.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确定了模块和功能，您可以开始考虑现代化的顺序。但首先，请确保查看每个模块的成本与收益权衡，并从最佳候选模块开始。[图5-1](#fig5-1)为一个包含六个模块的样本应用程序提供了一个非常高层次的概述。在本例中，我们假设讨论的是一个虚构的在线商店。例如，对于强烈相互依赖的模块，例如订单和客户，单独提取它们将会很复杂。如果还考虑到可扩展性的必要性以及从单体架构中移除它们的好处，其效益可能并不高。这两个模块位于图表的左下角。在相反的一侧，我们可能会找到目录服务。它列出可用的产品，并且是一个只读服务，几乎没有任何相互依赖。在网站需求高峰期间，这是最受欢迎的模块，并且从图5-1中显示的绿色模块位于图表的右上方，受益匪浅。对于应用程序中的所有模块进行类似的练习，以评估成本与收益。
- en: '![Cost vs. Benefit](Images/moej_0501.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![成本与收益](Images/moej_0501.png)'
- en: Figure 5-1\. Cost versus benefit
  id: totrans-85
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-1\. 成本与收益
- en: You’ve now reached the last checkpoint to validate your earlier strategic application
    assessment. Does the estimated modernization benefit outweigh the estimated modernization
    cost? Unfortunately, there is no generally applicable recommendation, as it heavily
    depends on the application itself, the business requirements, and the overarching
    company goals and challenges. Document your decisions and conclusions because
    now is the time to decide about the future direction of your modernization effort.
    Remember the 6 Rs from [Chapter 3](ch03.xhtml#travel_light_on_your_pathway)? Retain
    (change nothing), Retire (turn off), Repurchase (a new version), Rehost (put into
    containers), Replatform (some slight adjustments), or Refactor (build something
    new).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经达到验证先前战略应用评估的最后检查点。估计的现代化收益是否超过了估计的现代化成本？不幸的是，没有普适的建议，因为这严重依赖于应用本身、业务需求以及公司的总体目标和挑战。记录您的决策和结论，因为现在是决定您现代化努力未来方向的时候。还记得[第三章](ch03.xhtml#travel_light_on_your_pathway)中的6R吗？保留（无需更改）、退出（停用）、重新购买（新版本）、重新托管（放入容器）、重新平台化（进行轻微调整）或重构（构建新内容）。
- en: We’ve now assessed the application for migration, and we’ve evaluated the functionality
    for migration. We know which aspects of the application we’re ready to modernize.
    You’ve concluded that you do not want to build a new application but rather gently
    modernize the existing legacy. In the next section, we are going to take a deeper
    look at some approaches to migration.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经评估了迁移的应用，并且评估了迁移的功能。我们知道应用的哪些方面我们准备现代化。您已经得出结论，不希望构建新应用，而是轻度现代化现有的遗留系统。在下一节中，我们将深入探讨一些迁移方法。
- en: Migration Approaches
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迁移方法
- en: The aforementioned tools and assessments will help you on your journey to identify
    the most suitable applications and services. Now it’s time to dig deeper into
    the strategies and challenges of a single application.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 上述工具和评估将帮助您确定最适合的应用程序和服务。现在是深入了解单个应用程序的策略和挑战的时候了。
- en: Protecting Legacy (Replatform)
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保护遗留系统（重新平台化）
- en: With only one or two modules needing a business refresh or added functionality,
    the most straightforward way is to focus on the two modules and keep as much as
    possible of the existing application, making it runnable on modern infrastructure.
    Besides changes of the relevant modules, this also involves a reevaluation of
    the runtime, libraries, or even target infrastructure while touching as little
    code as possible.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一个或两个模块需要业务刷新或增加功能时，最简单的方法是专注于这两个模块，并尽可能保留现有应用程序，在现代基础设施上运行。除了相关模块的更改，还包括对运行时、库或目标基础设施的重新评估，同时尽量少触及代码。
- en: This can be achieved by simply containerizing the application and databases
    and modifying relevant modules of a well-architected monolith or extracting certain
    functionality completely and reintegrating it to a partly distributed system,
    as [Figure 5-2](#fig5-2) shows.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过简单地将应用程序和数据库容器化，并修改良构单体的相关模块，或完全提取某些功能并重新集成到部分分布式系统中来实现，正如[图 5-2](#fig5-2)所示。
- en: '![Putting the pieces back together](Images/moej_0502.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![Putting the pieces back together](Images/moej_0502.png)'
- en: Figure 5-2\. Putting the pieces back together
  id: totrans-94
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-2\. 把碎片重新组合起来
- en: What is easily said isn’t quickly done. There are plenty of nonfunctional requirements
    that need to be reallocated from the application server platform to the [outer
    architecture](https://oreil.ly/rrcZG). We will focus on the more critical pieces
    in the next chapter. In this chapter, we want to focus on the migration of the
    application and database itself.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 言之易，行之难。有许多非功能性需求需要从应用服务器平台重新分配到[外部架构](https://oreil.ly/rrcZG)。我们将在下一章节重点讨论更关键的部分。在本章中，我们希望专注于应用程序和数据库本身的迁移。
- en: Service to application
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务对应用的服务
- en: Once you’ve extracted certain functionality, the most pressing question is how
    to integrate the remaining monolith with the newly extracted service. Assuming
    that you switch to a container runtime, you should use an API Gateway to load
    balance and switch traffic on a URL basis. We’ll cover this in more detail in
    [Chapter 6](ch06.xhtml#microservices_architecture).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您提取了特定功能，最紧迫的问题是如何将剩余的单体与新提取的服务集成起来。假设您切换到容器运行时，应使用 API 网关基于 URL 进行负载均衡和流量切换。我们将在[第
    6 章](ch06.xhtml#microservices_architecture)中更详细地讨论此问题。
- en: Another approach is to use an HTTP proxy. It is essential to have the proxy
    up in production before you even try to extract parts of the monolith. Ensure
    it does not break the existing monolith and take some time to push the new service
    into production regularly, even without it being used by end users. Gradually
    switch over by redirecting traffic if everything looks good.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用 HTTP 代理。在尝试从单体应用程序中提取部分之前，必须确保代理已经在生产环境中运行。确保它不会破坏现有的单体，并且花一些时间定期将新服务推送到生产环境中，即使尚未被最终用户使用。如果一切看起来良好，逐渐通过重定向流量进行切换。
- en: For more simple service to monolith interactions, you can even think about implementing
    a simple JAX-RS direct communication. This approach is only suitable when you
    work with very few services, though. Make sure to treat the extracted service
    as an integration system from the perspective of the monolith.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更简单的服务与单体交互，甚至可以考虑实现简单的 JAX-RS 直接通信。然而，此方法仅适用于处理极少数量服务的情况。确保从单体的视角处理提取出的服务作为一个集成系统。
- en: All three approaches (API, gateway, HTTP proxy, and JAX-RS interface) are a
    pathway to your first successful microservice. They all implement the strangler
    pattern (refer to [Chapter 3](ch03.xhtml#travel_light_on_your_pathway)) and help
    to refactor the monolith into separate systems as a first step.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这三种方法（API、网关、HTTP 代理和 JAX-RS 接口）都是迈向首个成功微服务的途径。它们都实施了窒息模式（参见[第 3 章](ch03.xhtml#travel_light_on_your_pathway)），并帮助将单体应用程序重构为独立系统作为第一步。
- en: 'Interception is a potentially dangerous path: if you start building a custom
    protocol translation layer that is shared by multiple services, you risk adding
    too much intelligence to the shared proxy. This design approach leads away from
    independent microservices and becomes a more service-oriented architecture with
    too much intelligence in the routing layer. A better alternative is the so-called
    Sidecar pattern, which basically describes an additional container in the Pod.
    Rather than placing custom proxy logic in a shared layer, it becomes part of the
    new service. As a Kubernetes sidecar, it becomes a runtime binding and can serve
    legacy clients and new clients.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 拦截是一条潜在危险的路径：如果您开始构建一个自定义协议转换层，该层由多个服务共享，则可能会向共享代理添加过多的智能。这种设计方法使得独立微服务变得困难，并且变成了一个具有过多智能的路由层的面向服务的体系结构。一个更好的替代方案是所谓的边车模式，它基本上描述了
    Pod 中的另一个附加容器。与将自定义代理逻辑放在共享层中不同，它成为新服务的一部分。作为 Kubernetes 边车，它成为运行时绑定，并可以为传统客户端和新客户端提供服务。
- en: Note
  id: totrans-102
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A *sidecar* is just a container that runs on the same Pod as the application
    container. It shares the same volume and network as the application container
    and can “help” or enhance application behavior with this. Typical examples are
    logging, or more generally agent functionality.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*边车*只是在与应用程序容器相同的 Pod 上运行的容器。它与应用程序容器共享相同的卷和网络，并且可以通过这种方式“帮助”或增强应用程序行为。典型的例子是日志记录，或更一般的代理功能。'
- en: Database to databases
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据库到数据库
- en: Once we have identified the functional boundary and the integration method,
    we need to decide how to approach database separation. While monolith applications
    typically rely on a single large database, each extracted service should operate
    on its own data. The correct way to solve this puzzle again depends on the existing
    data layout and transactions.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定了功能边界和集成方法，我们就需要决定如何处理数据库分离问题。虽然单体应用通常依赖于单个大型数据库，但每个提取的服务应该操作自己的数据。再次解决这个难题的正确方式取决于现有数据布局和事务。
- en: A relatively easy first step is to separate the tables necessary for the service
    into a read-only view and a write table and adjust the flow of the monolith to
    use an interface for both read and write operations. These interfaces can more
    easily be abstracted in a later step into a service access. This option requires
    changes to the monolith application only and should have minimal impact on the
    existing codebase. We can move the table into a separate database and adjust the
    dependent queries in the next step.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 相对容易的第一步是将服务所需的表分离为只读视图和写入表，并调整单体应用程序的流程，以便同时使用读写操作的接口。这些接口可以更容易地在后续步骤中抽象为服务访问。此选项仅需要更改单体应用程序，并且对现有代码库的影响应该最小。我们可以将表移到一个单独的数据库中，并在下一步中调整相关查询。
- en: All this solely happens in the old monolith as preparation. Evolving existing
    code into a more modularized structure as preparation can be risky. In particular,
    the risk increases as the data model complexity does. In the last step, we can
    separate the extracted tables into a new database and adjust the monolith to use
    the newly created service for interactions with the business object. This is relatively
    easy with pen and paper and quickly reaches the end of practicality if the data
    access requires many joins across tables. Simple candidates are master data objects,
    like “User.” More complex ones could be combined objects, like an “Order.” What
    was said about the modularization of the application code is even more true for
    the database. The better the design and modularization already are, the easier
    it will be to extract functionality and data into a separate service. There will
    be cases where you won’t find an excellent solution to extract objects from the
    data model. Or you may see different approaches not delivering suitable performance
    anymore. This is the time to revisit your chosen modernization path.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都仅在旧的单体应用中作为准备工作而发生。将现有代码演变为更模块化的结构可能存在风险。特别是，随着数据模型复杂性的增加，风险也会增加。在最后一步中，我们可以将提取的表分离到一个新数据库，并调整单体应用程序以使用新创建的服务与业务对象进行交互。这在纸上和纸笔上相对容易，并且如果数据访问需要在表之间执行许多连接，则很快就会达到实用性的尽头。简单的候选对象是主数据对象，例如“用户”。更复杂的可能是组合对象，如“订单”。对于应用程序代码的模块化所说的事情，对于数据库而言更为真实。设计和模块化程度越好，将功能和数据提取到单独服务中就越容易。会有一些情况下，你找不到一个很好的解决方案来从数据模型中提取对象。或者您可能会看到不同的方法不再提供合适的性能。这是重新审视您选择的现代化路径的时候了。
- en: Continuing on the happy path, you now have two separate databases and two very
    unequal “services” composing a system. Now it’s time to think about data synchronization
    strategies between your services. Most databases implement some functionality
    to execute behavior on data changes. Simple cases support trigger functionality
    on changed rows to add copies to other tables or even call higher-level features
    (e.g., WebServices) on change. It is often proprietary functionality and heavily
    depends on the database being used. This could be an option if you have a company-wide
    directive to use certain features or you’re confident enough in further altering
    the original legacy database.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续“快乐路径”的过程中，你现在有两个独立的数据库和两个非常不平等的“服务”组成的系统。现在是时候考虑你的服务之间的数据同步策略了。大多数数据库实现了某些功能来在数据变更时执行行为。简单情况下，支持在更改的行上触发功能以将副本添加到其他表中，甚至在更改时调用更高级别的功能（例如WebServices）。这通常是专有功能，并且在很大程度上依赖于正在使用的数据库。如果你有全公司使用某些功能的指令或者对进一步改变原始遗留数据库有足够的信心，这可能是一个选择。
- en: If this isn’t possible, there’s the batch job-based synchronization. Changed
    timestamps, versions, or status columns indicate a needed replication. You can
    rely on this as a very mature and well-known version of data synchronization,
    which you can find in many legacy systems. The major drawback is that you’ll always
    end up with a discrepancy in data accuracy in the target system no matter the
    implementation. Higher replication intervals might also lead to additional costs
    for transactions or additional load on the source system. This approach is only
    suitable for infrequent updates that ideally have a non-time-sensitive process
    step in between. It is unsuitable for real- or near-time update requirements.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这不可能，那么有基于批处理作业的同步选项。更改的时间戳、版本或状态列表明需要复制。你可以依赖这种非常成熟和众所周知的数据同步版本，它存在于许多遗留系统中。主要缺点是无论实现方式如何，你最终都会在目标系统的数据准确性上出现差异。较高的复制间隔也可能导致交易成本增加或源系统负载增加。这种方法只适用于不频繁更新，理想情况下在两者之间有非时间敏感的过程步骤。它不适用于实时或接近实时的更新要求。
- en: The modern approach to solving data synchronization challenges relies on log
    readers. As third-party libraries, they identify changes by scanning the database
    transaction log files. These log files exist for backup and recovery operations
    and provide a reliable way to capture all changes, including deletes. This concept
    is also known as change-data-capture. One of the most notable projects here is
    [Debezium](https://debezium.io). Using log readers is the least disruptive option
    for synchronizing changes between databases because they require no modification
    to the source database, and they don’t have a query load on the source systems.
    Change data events generate notifications for other systems with the help of the
    Outbox pattern.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 解决数据同步挑战的现代方法依赖于日志读取器。作为第三方库，它们通过扫描数据库事务日志文件来识别变更。这些日志文件用于备份和恢复操作，并提供一种可靠的捕获所有变更（包括删除）的方法。这个概念也称为变更数据捕获。这里最显著的项目之一是[Debezium](https://debezium.io)。使用日志读取器是在数据库之间同步更改的最不具破坏性的选项，因为它们不需要修改源数据库，也不会对源系统产生查询负载。变更数据事件通过Outbox模式为其他系统生成通知。
- en: Build Something New (Refactor)
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建新东西（重构）
- en: If, for whatever reasons, you’ve reached a fork in the road where you decide
    to re-implement and refactor your complete system into a new distributed architecture,
    you are most likely thinking about synergies and ways to keep effort small and
    predictable. Given the complexity of a full microservices stack, this isn’t an
    easy task. One critical factor with this approach is team knowledge. After many
    years of development on an Enterprise Java application server, a team should profit
    from continuous API and standards knowledge. There are various ways to implement
    services on the JVM that all help teams with reusing the most critical functionalities
    we all already know from Enterprise Java/Jakarta EE standards. Let’s discuss some
    of these methods for implementing services on the JVM.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果因为任何原因，你发现自己面临一个岔路口，决定重新实现和重构你的完整系统为一个新的分布式架构，那么你很可能在思考如何协同工作以保持工作量小而可预测。考虑到完整微服务堆栈的复杂性，这并不是一件容易的任务。这种方法的一个关键因素是团队知识。在企业Java应用服务器上经过多年的开发后，团队应该能从持续的API和标准知识中获益。有多种方式可以在JVM上实现服务，所有这些方式都有助于团队重用我们从企业Java/Jakarta
    EE标准中已知的最关键的功能。让我们讨论一些在JVM上实现服务的方法。
- en: Note
  id: totrans-113
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '[Jakarta EE](https://jakarta.ee/about) is a set of specifications that enables
    Java developers to work on Java Enterprise applications. The specifications are
    developed by well-known industry leaders that instill confidence in technology
    developers and consumers. It is the open source version of the Java Enterprise
    Edition.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[Jakarta EE](https://jakarta.ee/about) 是一套规范，使 Java 开发人员能够开发 Java 企业应用程序。这些规范由知名行业领袖开发，为技术开发者和消费者带来信心。它是
    Java 企业版的开源版本。'
- en: MicroProfile
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MicroProfile
- en: '[MicroProfile](https://microprofile.io) was created in 2016 and quickly joined
    the Eclipse foundation. The primary purpose of MicroProfile is to create a Java
    Enterprise framework for implementing portable microservices in a vendor-neutral
    way. MicroProfile is composed of a vendor-agnostic programming model and configuration
    and services such as tracing, fault tolerance, health, and metrics. MicroProfile
    API components are built upon the model of Jakarta EE, making a transition to
    microservices more natural for Java developers. You can reuse the existing knowledge
    of Jakarta EE you’ve already accumulated in your career. MicroProfile defines
    12 specifications as shown in [Figure 5-3](#fig5-3), and the component model underneath
    uses a subset of the existing Jakarta EE standards. Compared to the full Jakarta
    EE specification, the more heavyweight specifications are missing. Most relevant
    for larger monolithic applications are Enterprise JavaBeans (EJB) and Jakarta
    XML Web Services.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[MicroProfile](https://microprofile.io) 成立于2016年，并迅速加入 Eclipse 基金会。MicroProfile
    的主要目的是以厂商中立的方式创建 Java 企业框架，用于实现可移植的微服务。MicroProfile 包括厂商中立的编程模型、配置以及追踪、容错、健康和指标等服务。MicroProfile
    API 组件建立在 Jakarta EE 模型之上，使 Java 开发人员更自然地过渡到微服务。您可以重复使用在职业生涯中已积累的 Jakarta EE 知识。MicroProfile
    定义了12个规范，如 [图5-3](#fig5-3) 所示，并且组件模型在底层使用 Jakarta EE 标准的一个子集。与完整的 Jakarta EE 规范相比，更重的规范如企业
    JavaBeans (EJB) 和 Jakarta XML Web Services 是缺失的。'
- en: '![MicroProfile technologies overview](Images/moej_0503.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![MicroProfile 技术概览](Images/moej_0503.png)'
- en: Figure 5-3\. MicroProfile technologies overview
  id: totrans-118
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-3\. MicroProfile 技术概览
- en: 'There are various implementations of the MicroProfile specifications available:
    Open Liberty, Thorntail, Paraya Server, TomEE, SmallRye, etc. As the MicroProfile
    relies on principles and components close to the Jakarta EE Web Profile, it is
    comparably easy to migrate existing applications.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种 MicroProfile 规范的实现可供选择：Open Liberty、Thorntail、Paraya Server、TomEE、SmallRye
    等。由于 MicroProfile 基于与 Jakarta EE Web Profile 接近的原则和组件，因此现有应用程序的迁移相对容易。
- en: Quarkus
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Quarkus
- en: '[Quarkus](http://quarkus.io) is a relatively new member of the so-called microservices
    frameworks. It is a full stack, Kubernetes-native Java framework for JVMs and
    native compilation. It is optimized specifically for containers and constrained
    runtime environments. Its primary purpose is to be an ideal runtime for serverless,
    cloud, and Kubernetes environments.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[Quarkus](http://quarkus.io) 是所谓的微服务框架中的一个相对较新的成员。它是一个为 JVM 和原生编译优化的 Kubernetes
    本地 Java 框架。它专为容器和受限运行时环境进行了优化。其主要目的是成为无服务器、云和 Kubernetes 环境的理想运行时。'
- en: It works with popular Java standards, frameworks, and libraries like Eclipse
    MicroProfile, Spring Boot, Apache Kafka, RESTEasy (JAX-RS), Hibernate ORM (JPA),
    Infinispan, Camel, and many more.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 它与流行的 Java 标准、框架和库兼容，如 Eclipse MicroProfile、Spring Boot、Apache Kafka、RESTEasy
    (JAX-RS)、Hibernate ORM (JPA)、Infinispan、Camel 等等。
- en: The dependency injection solution is based on CDI (Contexts and Dependency Injection)
    coming from Jakarta EE, making it compatible with established component models.
    An interesting part is the extension framework, which helps expand functionality
    to configure, boot, and integrate company-specific libraries into your application.
    It runs on JVMs and supports GraalVM (a general-purpose virtual machine for many
    languages).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入解决方案基于来自 Jakarta EE 的 CDI（上下文和依赖注入），使其与已建立的组件模型兼容。一个有趣的部分是扩展框架，它帮助扩展功能以配置、引导和集成公司特定的库到您的应用程序中。它运行在
    JVM 上，并支持 GraalVM（多语言通用虚拟机）。
- en: Component models to services
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组件模型到服务
- en: One of the most common questions among developers is how to migrate existing
    component models of Enterprise Java applications into microservices. Commonly,
    this question refers to Enterprise Java Beans or CDI Beans, especially the container-managed
    persistence beans (before EJB3), which need to be re-created on a Java Persistence
    API (JPA) basis. We strongly recommend checking if the underlying data/object
    mapping is still accurate and suitable for the new requirements and re-creating
    it entirely. This is not the most time- and cost-consuming part of modernization.
    Typically, the more challenging parts are the coded business requirements. While
    CDI Beans are technically part of MicroProfile-compatible implementations, the
    decision of whether a simple code migration is appropriate depends on the new
    business requirements. It is essential to look for existing code transaction boundaries
    to ensure no downstream resource needs to be involved. A general recommendation
    is to reuse as little source code as possible. The reason here is mainly the different
    approaches in system design between the two technologies. While we got away with
    a halfway modularized monolith, this isn’t possible with microservices anymore.
    Taking extra care to define the bounded contexts will pay off for the performance
    and design of the final solution.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员中最常见的问题之一是如何将企业 Java 应用程序的现有组件模型迁移到微服务中。通常，此问题指的是企业 Java Beans 或 CDI Beans，特别是容器管理的持久性
    Beans（在 EJB3 之前），需要基于 Java 持久性 API（JPA）重新创建。我们强烈建议检查底层的数据/对象映射是否仍然准确并适合新的要求，并完全重新创建它。这不是现代化过程中最耗时和费用的部分。通常，更具挑战性的部分是编码的业务需求。虽然
    CDI Beans 在技术上是 MicroProfile 兼容实现的一部分，但是否适合进行简单的代码迁移的决定取决于新的业务需求。必须注意查找现有代码事务边界，以确保不需要涉及下游资源。一个普遍的建议是尽可能少地重用源代码。这里的原因主要是两种技术之间系统设计方法的不同。虽然我们在部分模块化的单体架构中得以脱身，但在微服务中却不可能。特别关注定义有界上下文将为最终解决方案的性能和设计付出回报。
- en: Spring applications to services
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Spring 应用到服务
- en: We can take a similar approach with applications following a different programming
    framework like Spring. While it will technically be easy to update and copy existing
    implementations, the drawbacks stay the same. In particular, it might be helpful
    for Spring-based development teams to use compatibility APIs in different frameworks
    like Quarkus.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以采用类似的方法来处理采用不同编程框架（如 Spring）的应用程序。虽然从技术上讲，更新和复制现有实现是容易的，但缺点依然存在。特别是，对于基于
    Spring 的开发团队，可能会发现在不同框架（如 Quarkus）中使用兼容性 API 有所帮助。
- en: Quarkus’s Spring API compatibility includes Spring DI, Spring Web, and Spring
    Data JPA. Additional Spring APIs are partially supported like Spring Security,
    Spring Cache, Spring Scheduled, and Spring Cloud Config. The Spring API compatibility
    in Quarkus is not intended to be a complete Spring platform to rehost existing
    Spring applications. The intent is to offer enough Spring API compatibility to
    develop new applications with Quarkus.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus 的 Spring API 兼容性包括 Spring DI、Spring Web 和 Spring Data JPA。额外的 Spring
    API 部分支持，如 Spring Security、Spring Cache、Spring Scheduled 和 Spring Cloud Config。Quarkus
    中的 Spring API 兼容性并不意味着要成为一个完整的 Spring 平台来重新托管现有的 Spring 应用程序。目的是提供足够的 Spring API
    兼容性，以便使用 Quarkus 开发新的应用程序。
- en: Challenges
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挑战
- en: With assessment, planning, and care, you can decompose and modernize existing
    monolithic applications. It is not an automated process most of the time and will
    require a decent amount of work. There are some specific challenges to watch out
    for.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 通过评估、规划和关怀，您可以分解和现代化现有的单体应用程序。这在大多数情况下都不是自动化过程，而需要大量的工作。需要注意一些特定的挑战。
- en: Avoiding Dual-Writes
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免双写
- en: Once you build a few microservices, you quickly realize that the most challenging
    part about them is data. As part of their business logic, microservices often
    have to update their local data store. At the same time, they also need to notify
    other services about the changes that happened. This challenge is not so evident
    in the world of monolithic applications, nor on legacy-distributed transactions
    operating on one data model. This situation isn’t easy to resolve. With a switch
    to distributed applications, you most likely lose consistency. This is described
    in the CAP theorem.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您建立了几个微服务，您很快会意识到它们最具挑战性的部分是数据。作为它们业务逻辑的一部分，微服务经常需要更新它们的本地数据存储。同时，它们还需要通知其他服务发生的更改。这个挑战在单体应用程序的世界中并不那么明显，也不在操作单一数据模型的遗留分布式事务中。这种情况并不容易解决。随着分布式应用程序的转变，您很可能会失去一致性。这在
    CAP 定理中有描述。
- en: Note
  id: totrans-133
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'The [CAP theorem](https://oreil.ly/TVwYw), or the “two out of three” concept,
    states that we can only simultaneously provide two of the following three guarantees:
    consistency, availability, and partitition tolerance.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[CAP 定理](https://oreil.ly/TVwYw)，或“三选二”概念，说明我们只能同时提供以下三种保证中的两种：一致性、可用性和分区容错性。'
- en: Modern distributed applications use an event bus, like Apache Kafka, to transport
    data between services. Migrating your transactions from two-phase commit (2PC)
    in your monolith to a distributed world will significantly change the way your
    application behaves and reacts to failures. You need a way to control long-running
    and distributed transactions.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现代分布式应用使用事件总线，比如 Apache Kafka，用于在服务之间传输数据。将你的事务从单体架构中的两阶段提交（2PC）迁移到分布式世界将显著改变你的应用行为并对故障做出反应。你需要一种控制长时间运行和分布式事务的方法。
- en: Long-Running Transactions
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 长时间运行事务
- en: The Saga pattern offers a solution to dual writes and long-running transactions.
    While the Outbox pattern solves the more straightforward interservice communication
    problem, it is insufficient to solve the more complex, long-running, distributed
    business transactions use case. The latter requires executing multiple operations
    across multiple services with a consistent all-or-nothing semantic. Every multistep
    business process can be an example of this when split out across multiple services.
    The shopping cart application needs to generate confirmation emails and print
    a shipping label in the inventory. All actions must be carried out together or
    not at all. In the legacy world, or with a monolithic architecture, you might
    not be aware of this problem as the coordination between the modules is done in
    a single process and a single transactional context. The distributed world requires
    a different approach.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Saga 模式提供了对双写和长时间运行事务的解决方案。虽然 Outbox 模式解决了更简单的服务间通信问题，但不足以解决更复杂的长时间运行的分布式业务事务用例。后者需要在多个服务之间执行多个操作，并具有一致的全部或无操作语义。每个多步骤业务流程都可能是一个例子，分布在多个服务之间。购物车应用需要生成确认电子邮件并在库存中打印运输标签。所有操作必须一起执行，否则就不执行。在传统世界或单片体系结构中，您可能不会意识到这个问题，因为模块之间的协调是在单个进程和单个事务上下文中完成的。分布式世界需要不同的方法。
- en: 'The Saga pattern offers a solution to this problem by splitting up an overarching
    business transaction into multiple local database transactions, which are executed
    by the participating services. Generally, there are two ways to implement distributed
    sagas:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Saga 模式通过将一个总体业务事务拆分为由参与服务执行的多个本地数据库事务，为这个问题提供了解决方案。一般来说，有两种实现分布式 saga 的方式：
- en: 'Choreography: In this approach, one participating service sends a message to
    the next one after it has executed its local transaction.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协同作业：在这种方法中，参与的一个服务在执行完其本地事务后向下一个服务发送消息。
- en: 'Orchestration: In this approach, one central coordinating service coordinates
    and invokes the participating services. Communication between the participating
    services might be either synchronous, via HTTP or gRPC, or asynchronous, via messaging
    such as Apache Kafka.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编排：在这种方法中，一个中心协调服务协调和调用参与的服务。参与服务之间的通信可以是同步的，通过 HTTP 或 gRPC，也可以是异步的，通过像 Apache
    Kafka 这样的消息传递。
- en: Removing Old Code Too Quickly
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移除旧代码太快
- en: As soon as we extract a service, we want to get rid of the old source code,
    maintenance costs, and duplicate development. But be careful. You can look at
    the old code as a reference and test changes in behavior against both code bases.
    It might also be helpful from time to time to check the timing of the newly created
    service. A recommendation is to run them side by side for a defined period and
    compare the results. After this, you can remove the old implementation. That is
    early enough.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们提取一个服务，我们就希望摆脱旧的源代码、维护成本和重复的开发。但是要小心。你可以把旧代码视为参考，并针对两个代码库测试行为变化。偶尔检查新创建的服务的时间也可能会有帮助。建议在一个定义的时间段内并行运行它们并比较结果。之后，你可以删除旧的实现。这样做早了些会更好。
- en: Integration Aspects
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成方面
- en: Traditional monoliths have a solid relationship with complex integration logic.
    This is mainly proxied behind session facades or integrated with data synchronization
    logic. Every single system integrated into the overarching business process needs
    to be treated as a separate service. You can apply the same principles when extracting
    parts of the data from the existing data model and do this step by step. Another
    approach is to treat your integration logic as a service from the very beginning.
    A method that was primarily designed to support microservices is [Camel K](https://oreil.ly/JiOwc).
    It builds on the foundation of the well-known Apache Camel integration library
    and wraps integration routes into containers or better individual services. This
    way, you can separate the complete integration logic of your monolithic application
    and your services.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的单体应用与复杂的集成逻辑有着紧密的关系。这主要是通过会话外观或与数据同步逻辑集成来进行代理。每个整合到全局业务流程中的单一系统都需要被视为一个独立的服务。你可以在从现有数据模型中提取数据部分并逐步进行此操作时应用相同的原则。另一种方法是从一开始就将你的集成逻辑视为一个服务。这种方法最初是为支持微服务而设计的，[Camel
    K](https://oreil.ly/JiOwc)是一种方法。它基于著名的Apache Camel集成库，并将集成路由包装成容器或更好的单独服务。通过这种方式，你可以将单体应用的完整集成逻辑与你的服务分离开来。
- en: Summary
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'Modern enterprise Java systems are like generations of families: they evolve
    on top of legacy systems. Using proven patterns, standardized tools, and open
    source resources will help you create long-lasting systems that can grow and change
    with your needs. Fundamentally, your migration approach is directly related to
    what problems you’re trying to solve today and tomorrow. What are you trying to
    achieve that your current architecture doesn’t scale up to? Maybe microservices
    are the answer, or perhaps something else is. You must understand what you’re
    trying to achieve because it will be challenging to establish how to migrate the
    existing systems without that comprehension. Understanding your end goal will
    change how you decompose a system and how you prioritize that work.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现代企业Java系统就像家族的世代传承：它们在旧系统的基础上不断发展。使用成熟的模式、标准化工具和开源资源将有助于你创建能够随着需求增长和变化的持久系统。从根本上讲，你的迁移方法直接关系到你今天和明天试图解决的问题。你试图解决什么问题，你的当前架构无法扩展到？也许微服务是答案，或者也许有其他答案。你必须理解你试图实现的目标，因为如果没有这种理解，将很难确定如何迁移现有系统。理解你的最终目标将改变你如何分解一个系统以及如何优先处理这项工作。
