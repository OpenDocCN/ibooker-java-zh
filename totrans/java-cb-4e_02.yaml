- en: Chapter 2\. Interacting with the Environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 2.0 Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter describes how your Java program can deal with its immediate surroundings
    with what we call the runtime environment. In one sense, everything you do in
    a Java program using almost any Java API involves the environment. Here we focus
    more narrowly on things that directly surround your program. Along the way we’ll
    be introduced to the `System` class, which knows a lot about your particular system.
  prefs: []
  type: TYPE_NORMAL
- en: Two other runtime classes deserve brief mention. The first, `java.lang.Runtime`,
    lies behind many of the methods in the `System` class. `System.exit()`, for example,
    just calls `Runtime.exit()`. `Runtime` is technically part of the environment,
    but the only time we use it directly is to run other programs, which is covered
    in [Recipe 18.1](ch18.html#javacook-otherlang-SECT-1).
  prefs: []
  type: TYPE_NORMAL
- en: 2.1 Getting Environment Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to get the value of environment variables from within your Java program.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use `System.getenv()`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The seventh edition of Unix, released in 1979, had a new feature known as environment
    variables. Environment variables are in all modern Unix systems (including macOS)
    and in most later command-line systems, such as the DOS or Command Prompt in Windows,
    but they are not in some older platforms or other Java runtimes. Environment variables
    are commonly used for customizing an individual computer user’s runtime environment,
    hence the name. To take one familiar example, on Unix or DOS the environment variable
    `PATH` determines where the system looks for executable programs. So, of course
    people want to know how they access environment variables from their Java program.
  prefs: []
  type: TYPE_NORMAL
- en: The answer is that you can do this in all modern versions of Java, but you should
    exercise caution in depending on being able to specify environment variables because
    some rare operating systems may not provide them. That said, it’s unlikely you’ll
    run into such a system because all “standard” desktop systems provide them at
    present.
  prefs: []
  type: TYPE_NORMAL
- en: In some ancient versions of Java, `System.getenv()` was deprecated and/or just
    didn’t work. Nowadays the `getenv()` method is no longer deprecated, though it
    still carries the warning that system properties (see [Recipe 2.2](#javacook-environ-SECT-2))
    should be used instead. Even among systems that support environment variables,
    their names are case sensitive on some platforms and case insensitive on others.
    The code in [Example 2-1](#javacook-environ-EX-1) is a short program that uses
    the `getenv()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-1\. main/src/main/java/environ/GetEnv.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this code will produce output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The no-argument form of the method `System.getenv()` returns *all* the environment
    variables in the form of an immutable `String Map`. You can iterate through this
    map and access all the user’s settings or retrieve multiple environment settings.
  prefs: []
  type: TYPE_NORMAL
- en: Both forms of `getenv()` require you to have permissions to access the environment,
    so they typically do not work in restricted environments such as applets.
  prefs: []
  type: TYPE_NORMAL
- en: 2.2 Getting Information from System Properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to get information from the system properties.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use `System.getProperty()` or `System.getProperties()`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What is a *property* anyway? A property is just a name and value pair stored
    in a `java.util.Properties` object, which we discuss more fully in [Recipe 7.10](ch07.html#javacook-structure-SECT-7).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `System.Properties` object controls and describes the Java runtime. The
    `System` class has a static `Properties` member whose content is the merger of
    operating system specifics (`os.name`, for example), system and user tailoring
    (`java.class.path`), and properties defined on the command line (as we’ll see
    in a moment). Note that the use of periods in these names (like `os.arch`, `os.version`,
    `java.class.path`, and `java.lang.version`) makes it look as though there is a
    hierarchical relationship similar to that for package/class names. The `Properties`
    class, however, imposes no such relationships: each key is just a string, and
    dots are not special.'
  prefs: []
  type: TYPE_NORMAL
- en: To view all the defined system properties, you can iterate through the output
    of calling `System.getProperties()` as in [Example 2-2](#javacook-getstarted-EX-42).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-2\. jshell System.getProperties()
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Remember that properties whose names begin with “sun” are unsupported and subject
    to change.
  prefs: []
  type: TYPE_NORMAL
- en: 'To retrieve one system-provided property, use `System.getProperty(propName)`.
    If I just wanted to find out if the `System Properties` had a property named `"pencil_color"`,
    I could say:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: But what does that return? Surely Java isn’t clever enough to know about everybody’s
    favorite pencil color? Right you are! But we can easily tell Java about our pencil
    color (or anything else we want to tell it) using the `-D` argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'When starting a Java runtime, you can define a value in the system properties
    object using a `-D` option. Its argument must have a name, an equals sign, and
    a value, which are parsed the same way as in a properties file (see [Recipe 7.10](ch07.html#javacook-structure-SECT-7)).
    You can have more than one `-D` definition between the `java` command and your
    class name on the command line. At the Unix or Windows command line, type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: When running this under an IDE, put the variable’s name and value in the appropriate
    dialog box, for example, in Eclipse’s Run Configuration dialog under Program Arguments.
    You can also set environment variables and system properties using the build tools
    (Maven, Gradle, etc.).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SysPropDemo` program has code to extract just one or a few properties,
    so you can run it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If you invoke the `SysPropDemo` program with no arguments, it outputs the same
    information as the `jshell` fragment in [Example 2-2](#javacook-getstarted-EX-42).
  prefs: []
  type: TYPE_NORMAL
- en: Which reminds me—this is a good time to mention system-dependent code. [Recipe
    2.3](#javacook-environ-SECT-4) talks about OS-dependent code and release-dependent
    code.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Recipe 7.10](ch07.html#javacook-structure-SECT-7) lists more details on using
    and naming your own `Properties` files. The javadoc page for `java.util.Properties`
    lists the exact rules used in the `load()` method, as well as other details.'
  prefs: []
  type: TYPE_NORMAL
- en: 2.3 Dealing with Code That Depends on the Java Version or the Operating System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to write code that adapts to the underlying operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use `System.Properties` to find out the Java version and the operating
    system, various features in the `File` class to find out some platform-dependent
    features, and `java.awt.TaskBar` to see if you can use the system-dependent Taskbar
    or Dock.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some things depend on the version of Java you are running. Use `System.getProperty()`
    with an argument of `java.specification.version`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, and with greater generality, you may want to test for the presence
    or absence of particular classes. One way to do this is with `Class.forName("class")`
    (see [Chapter 17](ch17.html#javacook-reflection)), which throws an exception if
    the class cannot be loaded—a good indication that it’s not present in the runtime’s
    library. [Example 2-3](#example02checkswing) shows code for this, from an application
    wanting to find out whether the common Swing UI components are available. The
    javadoc for the standard classes reports the version of the JDK in which this
    class first appeared, under the heading “Since.” If there is no such heading,
    it normally means that the class has been present since the beginnings of Java:'
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-3\. *main/src/main/java/starting/CheckForSwing.java*
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s important to distinguish between testing this code at compile time and
    at runtime. In both cases, it must be compiled on a system that includes the classes
    you are testing for: JDK >= 1.1 and Swing, respectively. These tests are only
    attempts to help the poor backwater Java runtime user trying to run your up-to-date
    application. The goal is to provide this user with a message more meaningful than
    the simple “class not found” error that the runtime gives. It’s also important
    to note that this test becomes unreachable if you write it inside any code that
    depends on the code you are testing. Put the test early in the main flow of your
    application, before any GUI objects are constructed. Otherwise the code just sits
    there wasting space on newer runtimes and never gets run on Java systems that
    don’t include Swing. Obviously this is a very early example, but you can use the
    same technique to test for any runtime feature added at any stage of Java’s evolution
    (see [Appendix A](app01.html#javacook-then_now) for an outline of the features
    added in each release of Java). You can also use this technique to determine whether
    a needed third-party library has been successfully added to your CLASSPATH.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, although Java is designed to be portable, some things aren’t. These include
    such variables as the filename separator. Everybody on Unix knows that the filename
    separator is a slash character (/) and that a backward slash, or backslash (\),
    is an escape character. Back in the late 1970s, a group at Microsoft was actually
    working on Unix—their version was called Xenix, later taken over by SCO—and the
    people working on DOS saw and liked the Unix filesystem model. The earliest versions
    of MS-DOS didn’t have directories; it just had user numbers like the system it
    was a clone of, Digital Research CP/M (itself a clone of various other systems).
    So the Microsoft developers set out to clone the Unix filesystem organization.
    Unfortunately, MS-DOS had already committed the slash character for use as an
    option delimiter, for which Unix had used a dash (`-`); and the `PATH` separator
    (:) was also used as a drive letter delimiter, as in `C`: or `A`:. So we now have
    commands like those shown in [Table 2-1](#javacook-environ-dirPaths).'
  prefs: []
  type: TYPE_NORMAL
- en: Table 2-1\. Directory listing commands
  prefs: []
  type: TYPE_NORMAL
- en: '| System | Directory list command | Meaning | Example PATH setting |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Unix | *ls -R /* | Recursive listing of /, the top-level directory | *PATH=/bin:/usr/bin*
    |'
  prefs: []
  type: TYPE_TB
- en: '| DOS | *dir/s \* | Directory with subdirectories option (i.e., recursive)
    of \, the top-level directory (but only of the current drive) | *PATH=C:\windows;D:\mybin*
    |'
  prefs: []
  type: TYPE_TB
- en: 'Where does this get us? If we are going to generate filenames in Java, we may
    need to know whether to put a / or a \ or some other character. Java has two solutions
    to this. First, when moving between Unix and Microsoft systems, at least, it is
    *permissive*: either / or \ can be used,^([1](ch02.html#idm45290706287432)) and
    the code that deals with the operating system sorts it out. Second, and more generally,
    Java makes the platform-specific information available in a platform-independent
    way. For the file separator (and also the `PATH` separator), the `java.io.File`
    class makes available some static variables containing this information. Because
    the `File` class manages platform-dependent information, it makes sense to anchor
    this information here. The variables are shown in [Table 2-2](#javacook-environ-filesepstuff).'
  prefs: []
  type: TYPE_NORMAL
- en: Table 2-2\. Table 2-2\. File properties
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Type | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `separator` | `static String` | The system-dependent filename separator character
    (e.g., / or \) |'
  prefs: []
  type: TYPE_TB
- en: '| `separatorChar` | `static char` | The system-dependent filename separator
    character (e.g., / or \) |'
  prefs: []
  type: TYPE_TB
- en: '| `pathSeparator` | `static String` | The system-dependent path separator character,
    represented as a string for convenience |'
  prefs: []
  type: TYPE_TB
- en: '| `pathSeparatorChar` | `static char` | The system-dependent path separator
    character |'
  prefs: []
  type: TYPE_TB
- en: Both filename and path separators are normally characters, but they are also
    available in `String` form for convenience.
  prefs: []
  type: TYPE_NORMAL
- en: 'A second, more general, mechanism is the `System` `Properties` object mentioned
    in [Recipe 2.2](#javacook-environ-SECT-2). You can use this to determine the operating
    system you are running on. Here is code that simply lists the system properties;
    it can be informative to run this on several different implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Some OSes, for example, provide a mechanism called the null device that can
    be used to discard output (typically used for timing purposes). Here is code that
    asks the system properties for the `os.name` and uses it to make up a name that
    can be used for discarding data (if no null device is known for the given platform,
    we return the name `jnk`, which means that on such platforms, we’ll occasionally
    create, well, junk files; I just remove these files when I stumble across them):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_interacting_with_the_environment_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: If `/dev/null` exists, use it.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_interacting_with_the_environment_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: If not, ask `System properties` if it knows the OS name.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_interacting_with_the_environment_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Nope, so give up, return `jnk`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_interacting_with_the_environment_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: We know it’s Microsoft Windows, so use `NUL:`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_interacting_with_the_environment_CO1-5)'
  prefs: []
  type: TYPE_NORMAL
- en: All else fails, go with `jnk`.
  prefs: []
  type: TYPE_NORMAL
- en: Although Java’s Swing GUI aims to be portable, Apple’s implementation for macOS
    does not automatically do the right thing for everyone. For example, a `JMenuBar`
    menu container appears by default at the top of the application window. This is
    the norm on Windows and on most Unix platforms, but Mac users expect the menu
    bar for the active application to appear at the top of the screen. To enable normal
    behavior, you have to set the `System` property `apple.laf.useScreenMenuBar` to
    the value `true` before the Swing GUI starts up. You might want to set some other
    properties too, such as a short name for your application to appear in the menu
    bar (the default is the full class name of your main application class).
  prefs: []
  type: TYPE_NORMAL
- en: There is an example of this in the book’s source code, at *src/main/java/gui/MacOsUiHints.java*.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is probably no point in setting these properties unless you are, in fact,
    being run under macOS. How do you tell? Apple’s recommended way is to check for
    the system property `mrj.runtime` and, if so, assume you are on macOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: On the other hand, these properties are likely harmless on non-Mac systems,
    so you could just skip the test and set the two properties unconditionally.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the Mac’s Dock or the Taskbar on most other systems can be accessed
    using the `java.awt.Taskbar` class that was added in Java 9. This is not discussed
    here, but there is an example `TaskbarDemo` in the `main/gui` subdirectory.
  prefs: []
  type: TYPE_NORMAL
- en: 2.4 Using Extensions or Other Packaged APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have a JAR file of classes you want to use.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Simply add the JAR file to your `CLASSPATH`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you build more sophisticated applications, you will need to use more and
    more third-party libraries. You can add these to your `CLASSPATH`.
  prefs: []
  type: TYPE_NORMAL
- en: It used to be recommended that you drop these JAR files into the Java Extensions
    mechanism directory, typically something like *\jdk1.x\jre\lib\ext*., instead
    of listing each JAR file in your `CLASSPATH` variable. However, this is no longer
    generally recommended and is no longer available in the latest JDKs. Instead,
    you may wish to use build tools like Maven (see [Recipe 1.7](ch01.html#javacook-getstarted-maven))
    or Gradle, as well as IDEs, to automate the addition of JAR files to your `CLASSPATH`.
  prefs: []
  type: TYPE_NORMAL
- en: One reason I’ve never been fond of using the extensions directory is that it
    requires modifying the installed JDK or JRE, which can lead to maintenance issues
    and problems when a new JDK or JRE is installed.
  prefs: []
  type: TYPE_NORMAL
- en: Java 9 introduced a major change to Java, the Java 9 Modules system for program
    modularization, which we discuss in [Recipe 2.5](#javacook-environ-modules).
  prefs: []
  type: TYPE_NORMAL
- en: 2.5 Using the Java Modules System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You are using Java 9 or later, and need to deal with the Modules mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Read on.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Java’s Modules system, formerly known as Project Jigsaw, was designed to handle
    the need to build large applications out of many small pieces. To an extent this
    problem had been solved by tools like Maven and Gradle, but the Modules system
    solves a slightly different problem than those tools. Maven or Gradle will find
    dependencies, download them, install them on your development and test runtimes,
    and package them into runnable JAR files. The Modules system is more concerned
    with the visbility of classes from one chunk of application code to another, typically
    provided by different developers who may not know or trust each other. As such,
    it is an admission that Java’s original set of access modifiers—such as `public`,
    `private`, `protected`, and default visibility—was not sufficient for building
    large-scale applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'What follows is a brief discussion of using JPMS, the Java Platform Module
    System, to import modules into your application. There is an introduction to creating
    your own modules in [Chapter 15](ch15.html#javacook-packages). For a more detailed
    presentation, you should refer to a book-length treatment such as [*Java 9 Modularity:
    Patterns and Practices for Developing Maintainable Applications*](http://shop.oreilly.com/product/0636920049494.do)
    by Sander Mak and Paul Bakker (O’Reilly).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Java has always been a language for large-scale development. Object orientation
    is one of the keys: classes and objects group methods, and access modifiers can
    be applied so that public and private methods are clearly separated. When developing
    large applications, having just a single flat namespace of classes is still not
    enough. Enter packages: they gather classes into logical groups within their own
    namespace. Access control can be applied at the package level as well so that
    some classes are only accessible inside a package. Modules are the next logical
    step up. A module groups some number of related packages, has a distinct name,
    and can restrict access to some packages while exposing other packages to different
    modules as public API.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing to understand at the outset: JPMS is not a replacement for your existing
    build tool. Whether you use Maven, Gradle, Ant, or just dump all needed JAR files
    into a lib directory, you still need to do that. Also, don’t confuse Maven’s modules
    with JPMS modules; the former is the physical structuring of a project into subprojects,
    and the latter is something the Java platform (compiler, runtime) understands.
    Usually when working with Java modules, each Java module will equate to a single
    Maven module.'
  prefs: []
  type: TYPE_NORMAL
- en: When you’re dealing with a tiny, self-contained program, you don’t need to be
    concerned with modules. Just put all the necessary JAR files on your `CLASSPATH`
    at compile time and runtime, and all will be well. Probably.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may see warning messages like this along the way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The warning message comes about as a result of JPMS doing its job, checking
    that no types are accessed in encapsulated packages within a module. Such messages
    will go away over time as all public Java libraries and all apps being developed
    get modularized.
  prefs: []
  type: TYPE_NORMAL
- en: Why will all be well only “probably”? If you are using certain classes that
    were deprecated over the last few releases, things won’t compile. For that, you
    must make the requisite modules available. In the *unsafe* subdirectory (also
    a Maven module) under `javasrc`, there is a class called `LoadAverage`. The load
    average is a feature of Unix/Linux systems that gives a rough measure of system
    load or busyness, by reporting the number of processes that are waiting to be
    run. There are almost always more processes running than CPU cores to run them
    on, so some always have to wait. Higher numbers mean a busier system with slower
    response.
  prefs: []
  type: TYPE_NORMAL
- en: Sun’s unsupported `Unsafe` class has a method for obtaining the load average,
    on systems that support it. The code has to use the Reflection API (see [Chapter 17](ch17.html#javacook-reflection))
    to obtain the `Unsafe` object; if you try to instantiate `Unsafe` directly you
    will get a `SecurityException` (this was the case before the Modules system).
    Once the instance is obtained and casted to `Unsafe`, you can invoke methods such
    as `loadAverage()` ([Example 2-4](#javacook-environ-modules-1)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-4\. unsafe/src/main/java/unsafe/LoadAverage.java (use of Unsafe.java)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This code, which used to compile, gives warnings. If we are using Java Modules,
    we must modify our *module-info.java* file to tell the compiler and VM that we
    require use of the module with the semi-obvious name `jdk.unsupported`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We’ll say more about the module file format in [Recipe 15.9](ch15.html#javacook-packages-creating-JPMS-modules).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the code in place and the module file in the top level of
    the source folder, we can build the project, run the program, and compare its
    output against the system-level tool for displaying the load average, `uptime`.
    We’ll still get the “internal proprietary API” warnings, but it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Thankfully, it works and gives the same numbers as the standard Unix *uptime*
    command. At least, it works on Java 11\. As the warnings imply, it *may* (i.e.,
    probably will) be removed in a later release.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are building a more complex app, you will probably need to put together
    a more complete *module-info.java* file. But at this stage it’s primarily a matter
    of requiring the modules you need. The standard Java API is divided into several
    modules, which you can list using the *java* command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Of these, `java.base` is always available and doesn’t need to be listed in
    your module file, `java.desktop` adds AWT and Swing for graphics, and `java.se`
    includes basically all of what used to be public API in the Java SDK. If our load
    average program wanted to display the result in a Swing window, for example, it
    would need to add this into its module file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: When your application is big enough to be divided into tiers or layers, you
    will probably want to describe these modules using JPMS. Since that topic comes
    under the heading of packaging, it is described in [Recipe 15.9](ch15.html#javacook-packages-creating-JPMS-modules).
  prefs: []
  type: TYPE_NORMAL
- en: '^([1](ch02.html#idm45290706287432-marker)) When compiling strings for use on
    Windows, remember to double them because \ is an escape character in most places
    other than the MS-DOS command line: `String rootDir = "C:\\";`.'
  prefs: []
  type: TYPE_NORMAL
