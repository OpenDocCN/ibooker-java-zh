<html><head></head><body>
<div id="sbo-rt-content"><section data-nutshell-tab="Type System" data-pdf-bookmark="Chapter 4. The Java Type System" data-type="chapter" epub:type="chapter"><div class="chapter" id="javanut8-CHP-4">
<h1><span class="label">Chapter 4. </span>The Java Type System</h1>
<p><a data-primary="type system" data-type="indexterm" id="ix_ch04-asciidoc0"/>In this chapter, we move beyond basic object-oriented programming with classes and into the additional concepts required to work effectively with Java’s type system.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a data-primary="statically typed language" data-type="indexterm" id="idm45927743150176"/>A <em>statically typed</em> language is one in which variables have definite types, and where it is a compile-time error to assign a value of an incompatible type to a variable.
<a data-primary="dynamically typed language" data-type="indexterm" id="idm45927743148800"/>Languages that only check type compatibility at runtime are called <em>dynamically typed</em>.</p>
</div>
<p>Java is a fairly classic example of a statically typed language. JavaScript is an example of a dynamically typed language that allows any variable to store any type of value.</p>
<p>The Java type system involves not only classes and primitive types but also other kinds of reference type that are related to the basic concept of a class, but which differ in some way and are usually treated in a special way by <code>javac</code> or the JVM.</p>
<p>We have already met arrays and classes, two of Java’s most widely used kinds of reference type. This chapter starts by discussing another very important kind of reference type—<em>interfaces</em>.
We then move on to discuss Java’s <em>generics</em>, which have a major role to play in Java’s type system. With these topics under our belts, we can discuss the differences between compile-time and runtime types in Java.</p>
<p>To complete the full picture of Java’s reference types, we look at specialized kinds of classes and interfaces—known as <em>enums</em> and <em>annotations</em>.
We conclude the chapter by looking at <em>lambda expressions</em> and <em>nested types</em> and then reviewing how enhanced type inference has allowed Java’s <em>nondenotable types</em> to become usable by <span class="keep-together">programmers</span>.</p>
<p>Let’s get started by taking a look at interfaces—probably the most important of Java’s reference types after classes and a key building block for the rest of Java’s type <span class="keep-together">system</span>.</p>
<section data-pdf-bookmark="Interfaces" data-type="sect1"><div class="sect1" id="idm45927743139376">
<h1>Interfaces</h1>
<p><a data-primary="interfaces" data-type="indexterm" id="ix_ch04-asciidoc1"/><a data-primary="type system" data-secondary="interfaces" data-type="indexterm" id="ix_ch04-asciidoc2"/>In <a data-type="xref" href="ch03.xhtml#javanut8-CHP-3">Chapter 3</a>, we met the idea of inheritance. We also saw that a Java class can inherit only from a single class.
This is quite a big restriction on the kinds of object-oriented programs that we want to build.
The designers of Java knew this, but they also wanted to ensure that Java’s approach to object-oriented programming was less complex and error-prone than, for example, that of C++.</p>
<p>The solution that they chose was to introduce the concept of an interface to Java.
Like a class, an <em>interface</em> defines a new reference type.
As its name implies, an interface is intended to represent only an API—so it
provides a description of a type and the methods (and signatures) that
classes that <em>implement</em> that API must provide.</p>
<p>In general, a Java interface does not provide any implementation code for the methods that it describes. These methods are considered <em>mandatory</em>—any class that wishes to implement the interface must provide an implementation of these <span class="keep-together">methods</span>.</p>
<p>However, an interface may wish to mark that some API methods are optional and that implementing classes do not need to implement them if they choose not to.
This is done with the <code>default</code> keyword—and the interface must provide an implementation of these optional methods, which will be used by any implementing class that elects not to implement them.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a data-primary="Java 8" data-primary-sortas="Java 08" data-secondary="interfaces in" data-type="indexterm" id="idm45927743129728"/>The ability to have optional methods in interfaces was new in Java 8.
It is not available in any earlier version. See <a data-type="xref" href="#javanut8-CHP-4-SECT-1.5">“Records and Interfaces”</a> for a full description of how optional (also called default) methods work.</p>
</div>
<p>It is not possible to directly instantiate an interface and create a member of the interface type. Instead, a class must <em>implement</em> the interface to provide the necessary method bodies.</p>
<p>Any instances of the implementing class are <em>compatible with</em> both the type defined by the class and the type defined by the interface.
This means that the instances may be substituted at any point in the code that requires an instance of either the class type or the interface type.
This extends the Liskov principle as seen in <a data-type="xref" href="ch03.xhtml#javanut8-CHP-3-SECT-6.1">“Reference Type Conversions”</a>.</p>
<p>Another way of saying this is that two objects that do not share the same class or superclass may still both be compatible with the same interface type if both objects are instances of classes that implement the interface.</p>
<section data-pdf-bookmark="Defining an Interface" data-type="sect2"><div class="sect2" id="idm45927743124080">
<h2>Defining an Interface</h2>
<p><a data-primary="interfaces" data-secondary="defining" data-type="indexterm" id="idm45927743122176"/>An interface definition is somewhat like a class definition in which all the (mandatory) methods are abstract and the keyword <code>class</code> has been replaced with 
<span class="keep-together"><code>interface</code></span>.
For example, this code shows the definition of an interface named <span class="keep-together"><code>Centered</code></span> (a <code>Shape</code> class, such as those defined in <a data-type="xref" href="ch03.xhtml#javanut8-CHP-3">Chapter 3</a>, might implement this interface if it wants to allow the coordinates of its center to be set and queried):</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">interface</code> <code class="nc">Centered</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="kt">void</code><code class="w"> </code><code class="nf">setCenter</code><code class="p">(</code><code class="kt">double</code><code class="w"> </code><code class="n">x</code><code class="p">,</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">y</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="kt">double</code><code class="w"> </code><code class="nf">getCenterX</code><code class="p">();</code><code class="w"/>
<code class="w">  </code><code class="kt">double</code><code class="w"> </code><code class="nf">getCenterY</code><code class="p">();</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p><a data-primary="interfaces" data-secondary="restrictions on" data-type="indexterm" id="idm45927743095152"/>A number of restrictions apply to the members of an interface:</p>
<ul>
<li>
<p>All mandatory methods of an interface are implicitly <code>abstract</code> and must have a semicolon in place of a method body. The <code>abstract</code> modifier is allowed but by convention is usually omitted.</p>
</li>
<li>
<p>An interface defines a public API. By convention, members of an interface are implicitly <code>public</code>, and it is conventional to omit the unnecessary <code>public</code> <span class="keep-together">modifier</span>.</p>
</li>
<li>
<p>An interface may not define any instance fields. Fields are an implementation detail, and an interface is a specification, not an implementation.
The only fields allowed in an interface definition are constants that are declared both <code>static</code> and <code>final</code>.</p>
</li>
<li>
<p>An interface cannot be instantiated, so it does not define a constructor.</p>
</li>
<li>
<p>Interfaces may contain nested types.
Any such types are implicitly <code>public</code> and <code>static</code>. See <a data-type="xref" href="#javanut8-CHP-4-SECT-5">“Nested Types”</a> for a full description of nested types.</p>
</li>
<li>
<p><a data-primary="Java 8" data-primary-sortas="Java 08" data-secondary="static methods" data-type="indexterm" id="idm45927743076432"/>As of Java 8, an interface may contain static methods. Previous
versions of Java did not allow this, which is widely believed to have
been a flaw in the design of the Java language.</p>
</li>
<li>
<p>As of Java 9, an interface may contain <code>private</code> methods.
These have limited use cases, but with the other changes to the interface construct, it seems arbitrary to disallow them.</p>
</li>
<li>
<p>It is a compile-time error to try to define a <code>protected</code> method in an interface.</p>
</li>
</ul>
</div></section>
<section data-pdf-bookmark="Extending Interfaces" data-type="sect2"><div class="sect2" id="idm45927743072080">
<h2>Extending Interfaces</h2>
<p><a data-primary="extending interfaces" data-type="indexterm" id="idm45927743070880"/><a data-primary="extends clause" data-type="indexterm" id="idm45927743070176"/><a data-primary="interfaces" data-secondary="extending" data-type="indexterm" id="idm45927743069504"/>Interfaces may extend other interfaces, and, like a class definition,
an interface definition indicates this by including an <code>extends</code> clause. When one interface extends another, it inherits all the methods and constants of its superinterface and can define new methods and constants.
Unlike classes, however, the <code>extends</code> clause of an interface definition may include more than one superinterface.
For example, here are some interfaces that extend other interfaces:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">interface</code> <code class="nc">Positionable</code><code class="w"> </code><code class="kd">extends</code><code class="w"> </code><code class="n">Centered</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="kt">void</code><code class="w"> </code><code class="nf">setUpperRightCorner</code><code class="p">(</code><code class="kt">double</code><code class="w"> </code><code class="n">x</code><code class="p">,</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">y</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="kt">double</code><code class="w"> </code><code class="nf">getUpperRightX</code><code class="p">();</code><code class="w"/>
<code class="w">  </code><code class="kt">double</code><code class="w"> </code><code class="nf">getUpperRightY</code><code class="p">();</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="kd">interface</code> <code class="nc">Transformable</code><code class="w"> </code><code class="kd">extends</code><code class="w"> </code><code class="n">Scalable</code><code class="p">,</code><code class="w"> </code><code class="n">Translatable</code><code class="p">,</code><code class="w"> </code><code class="n">Rotatable</code><code class="w"> </code><code class="p">{}</code><code class="w"/>
<code class="kd">interface</code> <code class="nc">SuperShape</code><code class="w"> </code><code class="kd">extends</code><code class="w"> </code><code class="n">Positionable</code><code class="p">,</code><code class="w"> </code><code class="n">Transformable</code><code class="w"> </code><code class="p">{}</code><code class="w"/></pre>
<p>An interface that extends more than one interface inherits all the methods and constants from each of those interfaces and can define its own additional methods and constants. A class that implements such an interface must implement the abstract methods defined directly by the interface, as well as all the abstract methods inherited from all the superinterfaces.</p>
</div></section>
<section data-pdf-bookmark="Implementing an Interface" data-type="sect2"><div class="sect2" id="idm45927742965904">
<h2>Implementing an Interface</h2>
<p><a data-primary="interfaces" data-secondary="implementing" data-type="indexterm" id="ix_ch04-asciidoc3"/>Just as a class uses <code>extends</code> to specify its superclass, it can use <code>implements</code> to name one or more interfaces it supports.
<a data-primary="implements keyword" data-type="indexterm" id="idm45927742987648"/>The <code>implements</code> keyword can appear in a class declaration following the <code>extends</code> clause.
It should be followed by a comma-separated list of interfaces that the class implements.</p>
<p>When a class declares an interface in its <code>implements</code> clause, it is
saying that it provides an implementation (i.e., a body) for each
mandatory method of that interface. If a class implements an interface
but does not provide an implementation for every mandatory interface
method, it inherits those unimplemented <code>abstract</code> methods from the
interface and must itself be declared <code>abstract</code>. If a class implements
more than one interface, it must implement every mandatory method of
each interface it implements (or be declared <code>abstract</code>).</p>
<p>The following code shows how to define a <code>CenteredRectangle</code> class
that extends the <code>Rectangle</code> class from
<a data-type="xref" href="ch03.xhtml#javanut8-CHP-3">Chapter 3</a> and implements our <code>Centered</code>
<span class="keep-together">interface</span>:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="kd">class</code> <code class="nc">CenteredRectangle</code><code class="w"> </code><code class="kd">extends</code><code class="w"> </code><code class="n">Rectangle</code><code class="w"> </code><code class="kd">implements</code><code class="w"> </code><code class="n">Centered</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="c1">// New instance fields</code><code class="w"/>
<code class="w">  </code><code class="kd">private</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">cx</code><code class="p">,</code><code class="w"> </code><code class="n">cy</code><code class="p">;</code><code class="w"/>

<code class="w">  </code><code class="c1">// A constructor</code><code class="w"/>
<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="nf">CenteredRectangle</code><code class="p">(</code><code class="kt">double</code><code class="w"> </code><code class="n">cx</code><code class="p">,</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">cy</code><code class="p">,</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">w</code><code class="p">,</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">h</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">super</code><code class="p">(</code><code class="n">w</code><code class="p">,</code><code class="w"> </code><code class="n">h</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="k">this</code><code class="p">.</code><code class="na">cx</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">cx</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="k">this</code><code class="p">.</code><code class="na">cy</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">cy</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>

<code class="w">  </code><code class="c1">// We inherit all the methods of Rectangle but must</code><code class="w"/>
<code class="w">  </code><code class="c1">// provide implementations of all the Centered methods.</code><code class="w"/>
<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">setCenter</code><code class="p">(</code><code class="kt">double</code><code class="w"> </code><code class="n">x</code><code class="p">,</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">y</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">cx</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">x</code><code class="p">;</code><code class="w"> </code><code class="n">cy</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">y</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="nf">getCenterX</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">cx</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="nf">getCenterY</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">cy</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Suppose we implement <code>CenteredCircle</code> and <code>CenteredSquare</code> just as we
have implemented this <code>CenteredRectangle</code> class. Each class extends
<code>Shape</code>, so instances of the classes can be treated as instances of the
<code>Shape</code> class, as we saw earlier. Because each class implements the
<code>Centered</code> interface, instances can also be treated as instances of that
type. The following code demonstrates how objects can be members of
both a class type and an interface type:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">Shape</code><code class="o">[]</code><code class="w"> </code><code class="n">shapes</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">Shape</code><code class="o">[</code><code class="mi">3</code><code class="o">]</code><code class="p">;</code><code class="w">      </code><code class="c1">// Create an array to hold shapes</code><code class="w"/>

<code class="c1">// Create some centered shapes, and store them in the Shape[]</code><code class="w"/>
<code class="c1">// No cast necessary: these are all compatible assignments</code><code class="w"/>
<code class="n">shapes</code><code class="o">[</code><code class="mi">0</code><code class="o">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">CenteredCircle</code><code class="p">(</code><code class="mf">1.0</code><code class="p">,</code><code class="w"> </code><code class="mf">1.0</code><code class="p">,</code><code class="w"> </code><code class="mf">1.0</code><code class="p">);</code><code class="w"/>
<code class="n">shapes</code><code class="o">[</code><code class="mi">1</code><code class="o">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">CenteredSquare</code><code class="p">(</code><code class="mf">2.5</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">);</code><code class="w"/>
<code class="n">shapes</code><code class="o">[</code><code class="mi">2</code><code class="o">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">CenteredRectangle</code><code class="p">(</code><code class="mf">2.3</code><code class="p">,</code><code class="w"> </code><code class="mf">4.5</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">);</code><code class="w"/>

<code class="c1">// Compute average area of the shapes and</code><code class="w"/>
<code class="c1">// average distance from the origin</code><code class="w"/>
<code class="kt">double</code><code class="w"> </code><code class="n">totalArea</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>
<code class="kt">double</code><code class="w"> </code><code class="n">totalDistance</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>
<code class="k">for</code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="n">shapes</code><code class="p">.</code><code class="na">length</code><code class="p">;</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mi">1</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="n">totalArea</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="n">shapes</code><code class="o">[</code><code class="n">i</code><code class="o">]</code><code class="p">.</code><code class="na">area</code><code class="p">();</code><code class="w">   </code><code class="c1">// Compute the area of the shapes</code><code class="w"/>

<code class="w">  </code><code class="c1">// Be careful, in general, the use of instanceof to determine the</code><code class="w"/>
<code class="w">  </code><code class="c1">// runtime type of an object is quite often an indication of a</code><code class="w"/>
<code class="w">  </code><code class="c1">// problem with the design</code><code class="w"/>
<code class="w">  </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">shapes</code><code class="o">[</code><code class="n">i</code><code class="o">]</code><code class="w"> </code><code class="k">instanceof</code><code class="w"> </code><code class="n">Centered</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="c1">// The shape is a Centered shape</code><code class="w"/>
<code class="w">    </code><code class="c1">// Note the required cast from Shape to Centered (no cast would</code><code class="w"/>
<code class="w">    </code><code class="c1">// be required to go from CenteredSquare to Centered, however).</code><code class="w"/>
<code class="w">    </code><code class="n">Centered</code><code class="w"> </code><code class="n">c</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="n">Centered</code><code class="p">)</code><code class="w"> </code><code class="n">shapes</code><code class="o">[</code><code class="n">i</code><code class="o">]</code><code class="p">;</code><code class="w"/>

<code class="w">    </code><code class="kt">double</code><code class="w"> </code><code class="n">cx</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">c</code><code class="p">.</code><code class="na">getCenterX</code><code class="p">();</code><code class="w">    </code><code class="c1">// Get coordinates of the center</code><code class="w"/>
<code class="w">    </code><code class="kt">double</code><code class="w"> </code><code class="n">cy</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">c</code><code class="p">.</code><code class="na">getCenterY</code><code class="p">();</code><code class="w">    </code><code class="c1">// Compute distance from origin</code><code class="w"/>
<code class="w">    </code><code class="n">totalDistance</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="n">Math</code><code class="p">.</code><code class="na">sqrt</code><code class="p">(</code><code class="n">cx</code><code class="o">*</code><code class="n">cx</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">cy</code><code class="o">*</code><code class="n">cy</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="s">"Average area: "</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">totalArea</code><code class="o">/</code><code class="n">shapes</code><code class="p">.</code><code class="na">length</code><code class="p">);</code><code class="w"/>
<code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="s">"Average distance: "</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">totalDistance</code><code class="o">/</code><code class="n">shapes</code><code class="p">.</code><code class="na">length</code><code class="p">);</code><code class="w"/></pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Interfaces are data types in Java, just like classes. When a class
implements an interface, instances of that class can be assigned to
variables of the interface type.</p>
</div>
<p>Don’t interpret this example to imply that you must assign a <code>CenteredRectangle</code> object to a <code>Centered</code> variable before you can invoke the <code>setCenter()</code> method or to a <code>Shape</code> variable before invoking the <code>area()</code> method. Instead, because the 
<span class="keep-together"><code>CenteredRectangle</code></span> class defines <code>setCenter()</code> and inherits <code>area()</code> from its <code>Rectangle</code> superclass, you can always invoke these methods.</p>
<p>As we could see by examining the bytecode (e.g., by using the <code>javap</code> tool we will meet in <a data-type="xref" href="ch13.xhtml#javanut8-CHP-13">Chapter 13</a>), the JVM calls the <code>setCenter()</code> method slightly differently depending on whether the local variable holding the shape is of the type <code><span class="keep-together">Centered</span>Rectangle</code> or <code>Centered</code>, but this is not a distinction that matters most of the time when you’re writing Java code.<a data-startref="ix_ch04-asciidoc3" data-type="indexterm" id="idm45927742431904"/></p>
</div></section>
<section data-pdf-bookmark="Records and Interfaces" data-type="sect2"><div class="sect2" id="javanut8-CHP-4-SECT-1.5">
<h2>Records and Interfaces</h2>
<p><a data-primary="interfaces" data-secondary="records and" data-type="indexterm" id="idm45927742429648"/><a data-primary="records" data-secondary="interfaces and" data-type="indexterm" id="idm45927742428672"/>Records, being a special case of classes, can implement interfaces, just like any other class. The body of the record must contain implementation code for all of the mandatory methods of the interface, and it may contain overriding implementations for any of the default methods of the interface.</p>
<p>Let’s look at an example as applied to the <code>Point</code> record we met in the last chapter. Given an interface defined like this:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">interface</code> <code class="nc">Translatable</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">Translatable</code><code class="w"> </code><code class="nf">deltaX</code><code class="p">(</code><code class="kt">double</code><code class="w"> </code><code class="n">dx</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="n">Translatable</code><code class="w"> </code><code class="nf">deltaY</code><code class="p">(</code><code class="kt">double</code><code class="w"> </code><code class="n">dy</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="n">Translatable</code><code class="w"> </code><code class="nf">delta</code><code class="p">(</code><code class="kt">double</code><code class="w"> </code><code class="n">dx</code><code class="p">,</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">dy</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>then we can update the <code>Point</code> type like this:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="kd">record</code> <code class="nc">Point</code><code class="p">(</code><code class="kt">double</code><code class="w"> </code><code class="n">x</code><code class="p">,</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">y</code><code class="p">)</code><code class="w"> </code><code class="kd">implements</code><code class="w"> </code><code class="n">Translatable</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="n">Translatable</code><code class="w"> </code><code class="nf">deltaX</code><code class="p">(</code><code class="kt">double</code><code class="w"> </code><code class="n">dx</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="n">delta</code><code class="p">(</code><code class="n">dx</code><code class="p">,</code><code class="w"> </code><code class="mf">0.0</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="n">Translatable</code><code class="w"> </code><code class="nf">deltaY</code><code class="p">(</code><code class="kt">double</code><code class="w"> </code><code class="n">dy</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="n">delta</code><code class="p">(</code><code class="mf">0.0</code><code class="p">,</code><code class="w"> </code><code class="n">dy</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="n">Translatable</code><code class="w"> </code><code class="nf">delta</code><code class="p">(</code><code class="kt">double</code><code class="w"> </code><code class="n">dx</code><code class="p">,</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">dy</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">Point</code><code class="p">(</code><code class="n">x</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">dx</code><code class="p">,</code><code class="w"> </code><code class="n">y</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">dy</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Note that because records are immutable, it is not possible to mutate instances in-place and so, if we need a modified object, we have to create one and return it explicitly. This implies that not every interface will be suitable for implementation by a record type.</p>
</div></section>
<section data-pdf-bookmark="Sealed Interfaces" data-type="sect2"><div class="sect2" id="javanut8-CHP-4-SECT-1.6">
<h2>Sealed Interfaces</h2>
<p><a data-primary="interfaces" data-secondary="sealed" data-type="indexterm" id="ix_ch04-asciidoc4"/><a data-primary="sealed interfaces" data-type="indexterm" id="ix_ch04-asciidoc5"/>We met the <code>sealed</code> keyword in the last chapter, as applied to classes. It can also be applied to interfaces, like this:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">sealed</code><code class="w"> </code><code class="kd">interface</code> <code class="nc">Rotate90</code><code class="w"> </code><code class="n">permits</code><code class="w"> </code><code class="n">Circle</code><code class="p">,</code><code class="w"> </code><code class="n">Rectangle</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kt">void</code><code class="w"> </code><code class="nf">clockwise</code><code class="p">();</code><code class="w"/>
<code class="w">    </code><code class="kt">void</code><code class="w"> </code><code class="nf">antiClockwise</code><code class="p">();</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>This sealed interface represents the capability for a shape to be rotated by 90 degrees. Note that the declaration also contains a <code>permits</code> clause that specifies the only classes that are allowed to implement this interface—in this case just the <code>Circle</code> and <code>Rectangle</code> for simplicity. The <code>Circle</code> is modified like this:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="kd">final</code><code class="w"> </code><code class="kd">class</code> <code class="nc">Circle</code><code class="w"> </code><code class="kd">extends</code><code class="w"> </code><code class="n">Shape</code><code class="w"> </code><code class="kd">implements</code><code class="w"> </code><code class="n">Rotate90</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="c1">// ...</code><code class="w"/>

<code class="w">    </code><code class="nd">@Override</code><code class="w"/>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">clockwise</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="c1">// No-op, circles are rotation-invariant</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="nd">@Override</code><code class="w"/>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">antiClockwise</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="c1">// No-op, circles are rotation-invariant</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="c1">// ...</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>whereas the <code>Rectangle</code> has been modified like this:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="kd">final</code><code class="w"> </code><code class="kd">class</code> <code class="nc">Rectangle</code><code class="w"> </code><code class="kd">extends</code><code class="w"> </code><code class="n">Shape</code><code class="w"> </code><code class="kd">implements</code><code class="w"> </code><code class="n">Rotate90</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="c1">// ...</code><code class="w"/>

<code class="w">    </code><code class="nd">@Override</code><code class="w"/>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">clockwise</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="c1">// Swap width and height</code><code class="w"/>
<code class="w">        </code><code class="kt">double</code><code class="w"> </code><code class="n">tmp</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">w</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="n">w</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">h</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="n">h</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">tmp</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="nd">@Override</code><code class="w"/>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">antiClockwise</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="c1">// Swap width and height</code><code class="w"/>
<code class="w">        </code><code class="kt">double</code><code class="w"> </code><code class="n">tmp</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">w</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="n">w</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">h</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="n">h</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">tmp</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="c1">// ...</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>As it stands, we don’t want to deal with the complexity of allowing other shapes to have rotational behavior, so we restrict the interface so that it can only be implemented by the two simplest cases: circles and rectangles.</p>
<p>There is also an interesting interplay between sealed interfaces and records, which we will discuss in <a data-type="xref" href="ch05.xhtml#javanut8-CHP-5">Chapter 5</a>.<a data-startref="ix_ch04-asciidoc5" data-type="indexterm" id="idm45927741826112"/><a data-startref="ix_ch04-asciidoc4" data-type="indexterm" id="idm45927741825440"/></p>
</div></section>
<section data-pdf-bookmark="Default Methods" data-type="sect2"><div class="sect2" id="javanut8-CHP-4-SECT-1.7">
<h2>Default Methods</h2>
<p><a data-primary="default methods" data-secondary="interfaces and" data-type="indexterm" id="ix_ch04-asciidoc6"/><a data-primary="interfaces" data-secondary="default methods" data-type="indexterm" id="ix_ch04-asciidoc7"/>From <a data-primary="Java 8" data-primary-sortas="Java 08" data-secondary="interfaces in" data-type="indexterm" id="idm45927741820560"/>Java 8 onward, it is possible to declare methods in interfaces that include an implementation. In this section, we’ll discuss these methods, which should be understood as optional methods in the API the interfaces represent—they’re usually called <em>default methods</em>. Let’s start by looking at the reasons why we need the default mechanism in the first place.</p>
<section data-pdf-bookmark="Backward compatibility" data-type="sect3"><div class="sect3" id="idm45927741818560">
<h3>Backward compatibility</h3>
<p><a data-primary="backward compatibility, interfaces and" data-type="indexterm" id="idm45927741817120"/><a data-primary="default methods" data-secondary="backward compatibility and" data-type="indexterm" id="idm45927741785856"/><a data-primary="interfaces" data-secondary="backward compatibility" data-type="indexterm" id="idm45927741785008"/>The Java platform has always been very concerned with backward
compatibility. This means that code that was written (or even compiled)
for an earlier version of the platform must continue to work
with later releases of the platform. This principle allows development
groups to have a high degree of confidence that an upgrade of their JDK
or Java Runtime Environment (JRE) will not break currently working applications.</p>
<p>Backward compatibility is a great strength of the Java platform, but in
order to achieve it, some constraints are placed on the platform. One of
them is that interfaces may not have new mandatory methods added to them
in a new release of the <span class="keep-together">interface</span>.</p>
<p>For example, let’s suppose that we want to update the <code>Positionable</code>
interface with the ability to add a bottom-left bounding point as well:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="kd">interface</code> <code class="nc">Positionable</code><code class="w"> </code><code class="kd">extends</code><code class="w"> </code><code class="n">Centered</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="kt">void</code><code class="w"> </code><code class="nf">setUpperRightCorner</code><code class="p">(</code><code class="kt">double</code><code class="w"> </code><code class="n">x</code><code class="p">,</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">y</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="kt">double</code><code class="w"> </code><code class="nf">getUpperRightX</code><code class="p">();</code><code class="w"/>
<code class="w">  </code><code class="kt">double</code><code class="w"> </code><code class="nf">getUpperRightY</code><code class="p">();</code><code class="w"/>
<code class="w">  </code><code class="kt">void</code><code class="w"> </code><code class="nf">setLowerLeftCorner</code><code class="p">(</code><code class="kt">double</code><code class="w"> </code><code class="n">x</code><code class="p">,</code><code class="w"> </code><code class="kt">double</code><code class="w"> </code><code class="n">y</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="kt">double</code><code class="w"> </code><code class="nf">getLowerLeftX</code><code class="p">();</code><code class="w"/>
<code class="w">  </code><code class="kt">double</code><code class="w"> </code><code class="nf">getLowerLeftY</code><code class="p">();</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>With this new definition, if we try to use this new interface with code
developed for the old, it just won’t work, as the existing code is
missing the mandatory methods <code>setLowerLeftCorner()</code>, <code>getLowerLeftX()</code>,
and <code>getLowerLeftY()</code>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>You can see this effect quite easily in your own code. Compile a class
file that depends on an interface. Then add a new mandatory method to
the interface and try to run the program with the new version of the
interface, together with your old class file. You should see the program
crash with a <code>NoClassDefError</code>.</p>
</div>
<p>This limitation was a concern for the designers of Java 8—as one of their goals was to be able to upgrade the core Java Collections libraries and introduce methods that used lambda expressions.</p>
<p>To solve this problem, a new mechanism was needed, essentially to allow interfaces to evolve by allowing new methods to be added without breaking backward <span class="keep-together">compatibility</span>.</p>
</div></section>
<section data-pdf-bookmark="Implementation of default methods" data-type="sect3"><div class="sect3" id="idm45927741730752">
<h3>Implementation of default methods</h3>
<p><a data-primary="default methods" data-secondary="implementation of" data-type="indexterm" id="ix_ch04-asciidoc8"/><a data-primary="interfaces" data-secondary="default implementation" data-type="indexterm" id="ix_ch04-asciidoc9"/>Adding new methods to an interface without breaking backward
compatibility requires providing some implementation for the
older implementations of the interface so that they can continue to
work. This mechanism is a <code>default</code> method, and it was first added to
the platform in JDK 8.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>A default method (sometimes called an optional method) can be added to
any interface. <a data-primary="default implementation" data-type="indexterm" id="idm45927741673040"/>This must include an implementation, called the <em>default
implementation</em>, which is written inline in the interface definition.</p>
</div>
<p>The basic behavior of a default method is:</p>
<ul>
<li>
<p>An implementing class may (but is not required to) implement the default method.</p>
</li>
<li>
<p>If an implementing class implements the default method, then the implementation in the class is used.</p>
</li>
<li>
<p>If no other implementation can be found, then the default implementation is used.</p>
</li>
</ul>
<p><a data-primary="Java 8" data-primary-sortas="Java 08" data-secondary="sort()" data-type="indexterm" id="idm45927741667968"/><a data-primary="sort()" data-secondary="as default method" data-secondary-sortas="default method" data-type="indexterm" id="idm45927741666720"/>An example default method is the <code>sort()</code> method. It’s been added to
the interface <code>java.util.List</code> in JDK 8, and is defined as:</p>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// The &lt;E&gt; syntax is Java's way of writing a generic type - see</code><code class="w"/>
<code class="c1">// the next section for full details. If you aren't familiar with</code><code class="w"/>
<code class="c1">// generics, just ignore that syntax for now.</code><code class="w"/>
<code class="kd">interface</code> <code class="nc">List</code><code class="o">&lt;</code><code class="n">E</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="c1">// Other members omitted</code><code class="w"/>

<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="k">default</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">sort</code><code class="p">(</code><code class="n">Comparator</code><code class="o">&lt;?</code><code class="w"> </code><code class="kd">super</code><code class="w"> </code><code class="n">E</code><code class="o">&gt;</code><code class="w"> </code><code class="n">c</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">Collections</code><code class="p">.</code><code class="o">&lt;</code><code class="n">E</code><code class="o">&gt;</code><code class="n">sort</code><code class="p">(</code><code class="k">this</code><code class="p">,</code><code class="w"> </code><code class="n">c</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Thus, from Java 8 upward, any object that implements <code>List</code> has an instance method <code>sort()</code> that can be used to sort the list using a suitable <code>Comparator</code>.
As the return type is <code>void</code>, we might expect that this is an in-place sort, and this is indeed the case.</p>
<p>One consequence of default methods is that when implementing multiple interfaces, it’s possible that two or more interfaces may contain a default method with a completely identical name and signature.</p>
<p>For example:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">interface</code> <code class="nc">Vocal</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="k">default</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">call</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="s">"Hello!"</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">interface</code> <code class="nc">Caller</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="k">default</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">call</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">Switchboard</code><code class="p">.</code><code class="na">placeCall</code><code class="p">(</code><code class="k">this</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">public</code><code class="w"> </code><code class="kd">class</code> <code class="nc">Person</code><code class="w"> </code><code class="kd">implements</code><code class="w"> </code><code class="n">Vocal</code><code class="p">,</code><code class="w"> </code><code class="n">Caller</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="c1">// ... which default is used?</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p><a data-primary="colliding default method" data-type="indexterm" id="idm45927741458432"/>These two interfaces have very different default semantics for <code>call()</code> and could cause a potential implementation clash—a <em>colliding default method</em>.
In versions of Java prior to 8, this could not occur, as the language permitted only single inheritance of implementation.
<a data-primary="multiple inheritance" data-type="indexterm" id="idm45927741523904"/>The introduction of default methods means that Java now permits a limited form of <em>multiple inheritance</em> (but only of method implementations).
Java still does not permit (and has no plans to add) multiple inheritance of object state.</p>
<div data-type="tip"><h6>Tip</h6>
<p><a data-primary="diamond inheritance" data-type="indexterm" id="idm45927741521904"/>In some other languages, notably C++, this problem is known as <em>diamond inheritance</em>.</p>
</div>
<p>Default methods have a simple set of rules to help resolve any potential ambiguities:</p>
<ul>
<li>
<p>If a class implements multiple interfaces in such a way as to cause a potential clash of default method implementations, the implementing class must override the clashing method and provide a definition of what is to be done.</p>
</li>
<li>
<p>Syntax is provided to allow the implementing class to simply call one of the interface default methods if that is what is required:</p>
</li>
</ul>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="kd">class</code> <code class="nc">Person</code><code class="w"> </code><code class="kd">implements</code><code class="w"> </code><code class="n">Vocal</code><code class="p">,</code><code class="w"> </code><code class="n">Caller</code><code class="w"> </code><code class="p">{</code><code class="w"/>

<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">call</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="c1">// Can do our own thing</code><code class="w"/>
<code class="w">        </code><code class="c1">// or delegate to either interface</code><code class="w"/>
<code class="w">        </code><code class="c1">// e.g.,</code><code class="w"/>
<code class="w">        </code><code class="c1">// Vocal.super.call();</code><code class="w"/>
<code class="w">        </code><code class="c1">// or</code><code class="w"/>
<code class="w">        </code><code class="c1">// Caller.super.call();</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>As a side effect of the design of default methods, there is a slight, unavoidable usage issue that may arise in the case of evolving interfaces with colliding methods.
Consider the case where a bytecode version 51.0 (Java 7) class implements two interfaces <code>A</code> and <code>B</code> with version numbers <code>a.0</code> and <code>b.0</code>, respectively.
As defaults are not available in Java 7, this class will work correctly.
However, if at a later time either or both interfaces adopt a default implementation of a colliding method, then compile-time breakage can occur.</p>
<p>For example, if version <code>a.1</code> introduces a default method in <code>A</code>, then the implementing class will pick up the implementation when run with the new version of the dependency.
If version <code>b.1</code> now introduces the same method, it causes a collision:</p>
<ul>
<li>
<p>If <code>B</code> introduces the method as a mandatory (i.e., abstract) method, then the implementing class continues to work—both at compile time and at runtime.</p>
</li>
<li>
<p>If <code>B</code> introduces the method as a default method, then this is not safe and the implementing class will fail both at compile and at runtime.</p>
</li>
</ul>
<p>This minor issue is very much a corner case and in practice is a very small price to pay in order to have usable default methods in the language.</p>
<p>When working with default methods, we should be aware that there is a slightly restricted set of operations we can perform from within a default method:</p>
<ul>
<li>
<p>Call another method present in the interface’s public API (whether mandatory or optional); some implementation for such methods is guaranteed to be <span class="keep-together">available</span>.</p>
</li>
<li>
<p>Call a private method on the interface (Java 9 and up).</p>
</li>
<li>
<p>Call a static method, whether on the interface or defined elsewhere.</p>
</li>
<li>
<p>Use the <code>this</code> reference (e.g., as an argument to method calls).</p>
</li>
</ul>
<p>The biggest takeaway from these restrictions is that even with default methods, Java interfaces still lack meaningful state; we cannot alter or store state within the <span class="keep-together">interface</span>.</p>
<p>Default methods have had a profound impact on the way that Java practitioners approach object-oriented programming.
When combined with the rise of lambda expressions, they have upended many previous conventions of Java coding; we will discuss this in detail in the next chapter<a data-startref="ix_ch04-asciidoc9" data-type="indexterm" id="idm45927741366992"/><a data-startref="ix_ch04-asciidoc8" data-type="indexterm" id="idm45927741366288"/>.<a data-startref="ix_ch04-asciidoc7" data-type="indexterm" id="idm45927741365488"/><a data-startref="ix_ch04-asciidoc6" data-type="indexterm" id="idm45927741364784"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Marker Interfaces" data-type="sect2"><div class="sect2" id="javanut8-CHP-4-SECT-1.8">
<h2>Marker Interfaces</h2>
<p><a data-primary="interfaces" data-secondary="marker" data-type="indexterm" id="idm45927741362592"/><a data-primary="marker interfaces" data-type="indexterm" id="idm45927741361616"/>Occasionally it is useful to define an interface that is entirely empty.
A class can implement this interface simply by naming it in its <code>implements</code> clause without <span class="keep-together">having</span> to implement any methods.
In this case, any instances of the class become valid instances of the interface as well and can be cast to the type. Java code can check whether an object is an instance of the interface using the <code>instanceof</code> operator, so this technique is a useful way to provide additional information about an object. It can be thought of as providing additional, auxiliary type information about a class.</p>
<div data-type="tip"><h6>Tip</h6>
<p>Marker interfaces are much less widely used than they once were.
Java’s <em>annotations</em> (which we shall meet presently) have largely replaced them due to their much greater flexibility at conveying extended type information.</p>
</div>
<p><a data-primary="java.util.RandomAccess" data-type="indexterm" id="idm45927741356944"/>The interface <code>java.util.RandomAccess</code> is an example of a marker interface: <code>java.util.List</code> implementations use this interface to advertise that they provide fast random access to the elements of the list.
For example, <code>ArrayList</code> implements <code>RandomAccess</code>, while <code>LinkedList</code> does not.
Algorithms that care about the performance of random-access operations can test for <code>RandomAccess</code> like this:</p>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// Before sorting the elements of a long arbitrary list, we may want</code><code class="w"/>
<code class="c1">// to make sure that the list allows fast random access.  If not,</code><code class="w"/>
<code class="c1">// it may be quicker to make a random-access copy of the list before</code><code class="w"/>
<code class="c1">// sorting it. Note that this is not necessary when using</code><code class="w"/>
<code class="c1">// java.util.Collections.sort().</code><code class="w"/>
<code class="n">List</code><code class="w"> </code><code class="n">l</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">...;</code><code class="w">  </code><code class="c1">// Some arbitrary list we're given</code><code class="w"/>
<code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">l</code><code class="p">.</code><code class="na">size</code><code class="p">()</code><code class="w"> </code><code class="o">&gt;</code><code class="w"> </code><code class="mi">2</code><code class="w"> </code><code class="o">&amp;&amp;</code><code class="w"> </code><code class="o">!</code><code class="p">(</code><code class="n">l</code><code class="w"> </code><code class="k">instanceof</code><code class="w"> </code><code class="n">RandomAccess</code><code class="p">))</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">l</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">ArrayList</code><code class="p">(</code><code class="n">l</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="n">sortListInPlace</code><code class="p">(</code><code class="n">l</code><code class="p">);</code><code class="w"/></pre>
<p><a data-primary="nominal typing" data-type="indexterm" id="idm45927741246992"/>As we will see later, Java’s type system is very tightly coupled to the names that types have—an approach called <em>nominal typing</em>.
A marker interface is a great example of this: it has nothing at all <em>except</em> a name.<a data-startref="ix_ch04-asciidoc2" data-type="indexterm" id="idm45927741258432"/><a data-startref="ix_ch04-asciidoc1" data-type="indexterm" id="idm45927741257728"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Java Generics" data-type="sect1"><div class="sect1" id="javanut8-CHP-4-SECT-2">
<h1>Java Generics</h1>
<p><a data-primary="generics" data-type="indexterm" id="ix_ch04-asciidoc10"/><a data-primary="type system" data-secondary="generics" data-type="indexterm" id="ix_ch04-asciidoc11"/>One of the great strengths of the Java platform is the standard library it ships.
It provides a great deal of useful functionality—and in particular robust implementations of common data structures.
These implementations are relatively simple to develop with and are well
documented.
The libraries are known as the Java Collections, and we will spend a big chunk of <a data-type="xref" href="ch08.xhtml#javanut8-CHP-8">Chapter 8</a> discussing them.
For a far more complete treatment, see the book <a class="orm:hideurl" href="http://shop.oreilly.com/product/9780596527754.do"><em>Java Generics and Collections</em></a> by Maurice Naftalin and Philip Wadler (O’Reilly).</p>
<p>Although they were still very useful, the earliest versions of the collections had a fairly major limitation: the data structure (sometimes called the <em>container</em>) essentially obscured the type of the data being stored in it.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Data hiding and encapsulation is a great principle of object-oriented
programming, but in this case, the opaque nature of the container caused
a lot of problems for the developer.</p>
</div>
<p>Let’s kick off the section by demonstrating the problem and showing how the introduction of <em>generic types</em> solved it and made life much easier for Java developers.</p>
<section data-pdf-bookmark="Introduction to Generics" data-type="sect2"><div class="sect2" id="javanut8-CHP-4-SECT-2.1">
<h2>Introduction to Generics</h2>
<p><a data-primary="generics" data-secondary="basics" data-type="indexterm" id="idm45927741243200"/><a data-primary="List interface" data-secondary="generics and" data-type="indexterm" id="idm45927741242224"/>If we want to build a collection of <code>Shape</code> instances, we can use a
<code>List</code> to hold them, like this:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">List</code><code class="w"> </code><code class="n">shapes</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">ArrayList</code><code class="p">();</code><code class="w">   </code><code class="c1">// Create a List to hold shapes</code><code class="w"/>

<code class="c1">// Create some centered shapes, and store them in the list</code><code class="w"/>
<code class="n">shapes</code><code class="p">.</code><code class="na">add</code><code class="p">(</code><code class="k">new</code><code class="w"> </code><code class="n">CenteredCircle</code><code class="p">(</code><code class="mf">1.0</code><code class="p">,</code><code class="w"> </code><code class="mf">1.0</code><code class="p">,</code><code class="w"> </code><code class="mf">1.0</code><code class="p">));</code><code class="w"/>
<code class="c1">// This is legal Java-but is a very bad design choice</code><code class="w"/>
<code class="n">shapes</code><code class="p">.</code><code class="na">add</code><code class="p">(</code><code class="k">new</code><code class="w"> </code><code class="n">CenteredSquare</code><code class="p">(</code><code class="mf">2.5</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">));</code><code class="w"/>

<code class="c1">// List::get() returns Object, so to get back a</code><code class="w"/>
<code class="c1">// CenteredCircle we must cast</code><code class="w"/>
<code class="n">CenteredCircle</code><code class="w"> </code><code class="n">c</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="n">CenteredCircle</code><code class="p">)</code><code class="n">shapes</code><code class="p">.</code><code class="na">get</code><code class="p">(</code><code class="mi">0</code><code class="p">);</code><code class="w"/>

<code class="c1">// Next line causes a runtime failure</code><code class="w"/>
<code class="n">CenteredCircle</code><code class="w"> </code><code class="n">c</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="n">CenteredCircle</code><code class="p">)</code><code class="n">shapes</code><code class="p">.</code><code class="na">get</code><code class="p">(</code><code class="mi">1</code><code class="p">);</code><code class="w"/></pre>
<p>A problem with this code stems from the requirement to perform a cast to get the shape objects back out in a usable form—the <code>List</code> doesn’t know what type of objects it contains.
Not only that, but it’s actually possible to put different types of objects into the same container, and everything will work fine until an illegal cast is used and the program crashes.</p>
<p>What we really want is a form of <code>List</code> that understands what type it contains.
Then, <code>javac</code> could detect when an illegal argument was passed to the methods of <code>List</code> and cause a compilation error, rather than deferring the issue to runtime.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a data-primary="heterogeneous collections" data-type="indexterm" id="idm45927741185168"/><a data-primary="homogeneous collections" data-type="indexterm" id="idm45927741184496"/>Collections that have all elements of the same type are called <em>homogeneous</em>, while the collections that can have elements of potentially different types are called <em>heterogeneous</em> (sometimes called “mystery meat collections”).</p>
</div>
<p><a data-primary="&lt; &gt; (angle brackets)" data-secondary="homogeneous collections and" data-type="indexterm" id="idm45927741182368"/>Java provides a simple syntax to cater to homogeneous collections. To indicate that a type is a container that holds instances of another reference type, we enclose the <em>payload</em> type that the container holds within angle brackets:</p>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// Create a List-of-CenteredCircle</code><code class="w"/>
<code class="n">List</code><code class="o">&lt;</code><code class="n">CenteredCircle</code><code class="o">&gt;</code><code class="w"> </code><code class="n">shapes</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">ArrayList</code><code class="o">&lt;</code><code class="n">CenteredCircle</code><code class="o">&gt;</code><code class="p">();</code><code class="w"/>

<code class="c1">// Create some centered shapes, and store them in the list</code><code class="w"/>
<code class="n">shapes</code><code class="p">.</code><code class="na">add</code><code class="p">(</code><code class="k">new</code><code class="w"> </code><code class="n">CenteredCircle</code><code class="p">(</code><code class="mf">1.0</code><code class="p">,</code><code class="w"> </code><code class="mf">1.0</code><code class="p">,</code><code class="w"> </code><code class="mf">1.0</code><code class="p">));</code><code class="w"/>

<code class="c1">// Next line will cause a compilation error</code><code class="w"/>
<code class="n">shapes</code><code class="p">.</code><code class="na">add</code><code class="p">(</code><code class="k">new</code><code class="w"> </code><code class="n">CenteredSquare</code><code class="p">(</code><code class="mf">2.5</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">));</code><code class="w"/>

<code class="c1">// List&lt;CenteredCircle&gt;::get() returns a CenteredCircle, no cast needed</code><code class="w"/>
<code class="n">CenteredCircle</code><code class="w"> </code><code class="n">c</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">shapes</code><code class="p">.</code><code class="na">get</code><code class="p">(</code><code class="mi">0</code><code class="p">);</code><code class="w"/></pre>
<p>This syntax ensures that a large class of unsafe code is caught by the compiler, before it gets anywhere near runtime.
This is, of course, the whole point of static type systems—to use compile-time knowledge to help eliminate runtime problems wherever possible.</p>
<p><a data-primary="payload type" data-type="indexterm" id="idm45927740995696"/>The resulting types, which combine an enclosing container type and a payload type, are usually called <em>generic types</em>, and they are declared like this:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">interface</code> <code class="nc">Box</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="kt">void</code><code class="w"> </code><code class="nf">box</code><code class="p">(</code><code class="n">T</code><code class="w"> </code><code class="n">t</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="n">T</code><code class="w"> </code><code class="nf">unbox</code><code class="p">();</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>This indicates that the <code>Box</code> interface is a general construct, which can hold any type of payload.
It isn’t really a complete interface by itself—it’s more like a general description of a whole family of interfaces, one for each type that can be used in place of <code>T</code>.</p>
</div></section>
<section data-pdf-bookmark="Generic Types and Type Parameters" data-type="sect2"><div class="sect2" id="javanut8-CHP-4-SECT-2.2">
<h2>Generic Types and Type Parameters</h2>
<p><a data-primary="generics" data-secondary="types/type parameters" data-type="indexterm" id="idm45927740952400"/><a data-primary="type parameter" data-type="indexterm" id="idm45927740951424"/><a data-primary="types" data-seealso="generics" data-type="indexterm" id="idm45927740950752"/>We’ve seen how to use a generic type to provide enhanced program
safety by using compile-time knowledge to prevent simple type errors.
In this section, let’s dig deeper into the properties of generic types.</p>
<p><a data-primary="parameterized type" data-type="indexterm" id="idm45927740949424"/>The syntax <code>&lt;T&gt;</code> has a special name, <em>type parameter</em>,
and another name for a generic type is a <em>parameterized type</em>. This
should convey the sense that the container type (e.g., <code>List</code>) is
parameterized by another type (the payload type). When we write a type
like <code>Map&lt;String, Integer&gt;</code>, we are assigning concrete values to the
type parameters.</p>
<p>When we define a type that has parameters, we need to do so in a way
that does not make assumptions about the type parameters. So the <code>List</code>
type is declared in a generic way as <code>List&lt;E&gt;</code>, and the type parameter
<code>E</code> is used all the way through to stand as a placeholder for the actual
type that programmers will use for the payload when they use the <code>List</code> data structure.</p>
<div data-type="tip"><h6>Tip</h6>
<p>Type parameters always stand in for reference types. It is not possible
to use a primitive type as a value for a type parameter.</p>
</div>
<p>The type parameter can be used in the signatures and bodies of methods
as though it is a real type, for example:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">interface</code> <code class="nc">List</code><code class="o">&lt;</code><code class="n">E</code><code class="o">&gt;</code><code class="w"> </code><code class="kd">extends</code><code class="w"> </code><code class="n">Collection</code><code class="o">&lt;</code><code class="n">E</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="kt">boolean</code><code class="w"> </code><code class="nf">add</code><code class="p">(</code><code class="n">E</code><code class="w"> </code><code class="n">e</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="n">E</code><code class="w"> </code><code class="nf">get</code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">index</code><code class="p">);</code><code class="w"/>
<code class="w">  </code><code class="c1">// other methods omitted</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Note how the type parameter <code>E</code> can be used as a parameter for both return types and method arguments.
We don’t assume that the payload type has any specific properties and only make the basic assumption of consistency—that the type we put in is the same type that we will later get back out.</p>
<p>This enhancement has effectively introduced a new kind of type to Java’s type system. By combining the container type with the value of the type parameter, we are making new types.</p>
</div></section>
<section data-pdf-bookmark="Diamond Syntax" data-type="sect2"><div class="sect2" id="javanut8-CHP-4-SECT-2.3">
<h2>Diamond Syntax</h2>
<p><a data-primary="diamond syntax" data-type="indexterm" id="idm45927740867424"/><a data-primary="generics" data-secondary="diamond syntax" data-type="indexterm" id="idm45927740866720"/>When we create an instance of a generic type, the righthand side of the
assignment statement repeats the value of the type parameter. This is
usually unnecessary, as the compiler can infer the values of the type
parameters. In modern versions of Java, we can leave out the repeated
type values in what is called <em>diamond syntax</em>.</p>
<p>Let’s look at an example of how to use diamond syntax, by rewriting one
of our earlier examples:</p>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// Create a List-of-CenteredCircle using diamond syntax</code><code class="w"/>
<code class="n">List</code><code class="o">&lt;</code><code class="n">CenteredCircle</code><code class="o">&gt;</code><code class="w"> </code><code class="n">shapes</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">ArrayList</code><code class="o">&lt;&gt;</code><code class="p">();</code><code class="w"/></pre>
<p>This is a small improvement in the verbosity of the assignment
statement—we’ve managed to save a few characters of typing. We’ll return
to the topic of type inference when we discuss lambda expressions
later in this chapter.</p>
</div></section>
<section data-pdf-bookmark="Type Erasure" data-type="sect2"><div class="sect2" id="javanut8-CHP-4-SECT-2.4">
<h2>Type Erasure</h2>
<p><a data-primary="generics" data-secondary="type erasure" data-type="indexterm" id="idm45927740859104"/><a data-primary="type erasure" data-type="indexterm" id="idm45927740843264"/>In <a data-type="xref" href="#javanut8-CHP-4-SECT-1.7">“Default Methods”</a>, we discussed the Java platform’s strong preference for backward compatibility.
The addition of generics in Java 5 was another example of where backward compatibility was an issue for a new language feature.</p>
<p>The central question was how to make a type system that allowed older, nongeneric collection classes to be used alongside with newer, generic collections.
The design decision was to achieve this by the use of casts:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">List</code><code class="w"> </code><code class="n">someThings</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">getSomeThings</code><code class="p">();</code><code class="w"/>
<code class="c1">// Unsafe cast, but we know that the</code><code class="w"/>
<code class="c1">// contents of someThings are really strings</code><code class="w"/>
<code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code><code class="w"> </code><code class="n">myStrings</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code><code class="p">)</code><code class="n">someThings</code><code class="p">;</code><code class="w"/></pre>
<p>This means that <code>List</code> and <code>List&lt;String&gt;</code> are compatible as types, at least at some level.
Java achieves this compatibility by <em>type erasure</em>. This means that generic type parameters are only visible at compile time—they are stripped out by <code>javac</code> and are not reflected in the bytecode.<sup><a data-type="noteref" href="ch04.xhtml#idm45927740773536" id="idm45927740773536-marker">1</a></sup></p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p><a data-primary="raw type" data-type="indexterm" id="idm45927740772128"/>The nongeneric type <code>List</code> is usually called a <em>raw type</em>. It is still
perfectly legal Java to work with the raw form of types, even for types that are now generic.
This is almost always a sign of poor-quality code, however.</p>
</div>
<p>The mechanism of type erasure gives rise to a difference in the type
system seen by <code>javac</code> and that seen by the JVM—we will discuss this
fully in <a data-type="xref" href="#javanut8-CHP-4-SECT-2.10">“Compile and Runtime Typing”</a>.</p>
<p>Type erasure also prohibits some other definitions, which would
otherwise seem legal. In this code, we want to count the orders as
represented in two slightly different data structures:</p>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// Won't compile</code><code class="w"/>
<code class="kd">interface</code> <code class="nc">OrderCounter</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="c1">// Name maps to list of order numbers</code><code class="w"/>
<code class="w">  </code><code class="kt">int</code><code class="w"> </code><code class="nf">totalOrders</code><code class="p">(</code><code class="n">Map</code><code class="o">&lt;</code><code class="n">String</code><code class="p">,</code><code class="w"> </code><code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;&gt;</code><code class="w"> </code><code class="n">orders</code><code class="p">);</code><code class="w"/>

<code class="w">  </code><code class="c1">// Name maps to total orders made so far</code><code class="w"/>
<code class="w">  </code><code class="kt">int</code><code class="w"> </code><code class="nf">totalOrders</code><code class="p">(</code><code class="n">Map</code><code class="o">&lt;</code><code class="n">String</code><code class="p">,</code><code class="w"> </code><code class="n">Integer</code><code class="o">&gt;</code><code class="w"> </code><code class="n">orders</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>This seems like perfectly legal Java code, but it will not compile. The
issue is that although the two methods seem like normal overloads, after
type erasure, the signature of both methods becomes:</p>
<pre data-code-language="java" data-type="programlisting"><code class="w">  </code><code class="kt">int</code><code class="w"> </code><code class="nf">totalOrders</code><code class="p">(</code><code class="n">Map</code><code class="p">);</code><code class="w"/></pre>
<p>All that is left after type erasure is the raw type of the container—in
this case, <code>Map</code>. The runtime would be unable to distinguish between the
methods by signature, and so the language specification makes this
syntax illegal.</p>
</div></section>
<section class="pagebreak-before" data-pdf-bookmark="Bounded Type Parameters" data-type="sect2"><div class="sect2" id="javanut8-CHP-4-SECT-2.5">
<h2>Bounded Type Parameters</h2>
<p><a data-primary="bounded type parameters" data-type="indexterm" id="ix_ch04-asciidoc12"/><a data-primary="generics" data-secondary="bounded type parameters" data-type="indexterm" id="ix_ch04-asciidoc13"/><a data-primary="type parameter" data-type="indexterm" id="ix_ch04-asciidoc14"/>Consider a simple generic box:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="kd">class</code> <code class="nc">Box</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">protected</code><code class="w"> </code><code class="n">T</code><code class="w"> </code><code class="n">value</code><code class="p">;</code><code class="w"/>

<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">box</code><code class="p">(</code><code class="n">T</code><code class="w"> </code><code class="n">t</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">value</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">t</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="n">T</code><code class="w"> </code><code class="nf">unbox</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">T</code><code class="w"> </code><code class="n">t</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">value</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="n">value</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="kc">null</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="n">t</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>This is a useful abstraction, but suppose we want to have a restricted form of box that holds only numbers.
Java allows us to achieve this by using a <em>bound</em> on the type parameter.
This is the ability to restrict the types that can be used as the value of a type parameter, for example:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="kd">class</code> <code class="nc">NumberBox</code><code class="o">&lt;</code><code class="n">T</code><code class="w"> </code><code class="kd">extends</code><code class="w"> </code><code class="n">Number</code><code class="o">&gt;</code><code class="w"> </code><code class="kd">extends</code><code class="w"> </code><code class="n">Box</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="nf">intValue</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="n">value</code><code class="p">.</code><code class="na">intValue</code><code class="p">();</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>The type bound <code>T extends Number</code> ensures that <code>T</code> can only be substituted with a type that is compatible with the type <code>Number</code>.
As a result of this, the compiler knows that <code>value</code> will definitely have a method <code>intValue()</code> available on it.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Notice that because the <code>value</code> field has protected access, it can be accessed directly in the subclass.</p>
</div>
<p>If we attempt to instantiate <code>NumberBox</code> with an invalid value for the type parameter, the result will be a compilation error:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">NumberBox</code><code class="o">&lt;</code><code class="n">Integer</code><code class="o">&gt;</code><code class="w"> </code><code class="n">ni</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">NumberBox</code><code class="o">&lt;&gt;</code><code class="p">();</code><code class="w"> </code><code class="c1">// This compiles fine</code><code class="w"/>

<code class="n">NumberBox</code><code class="o">&lt;</code><code class="n">Object</code><code class="o">&gt;</code><code class="w"> </code><code class="n">no</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">NumberBox</code><code class="o">&lt;&gt;</code><code class="p">();</code><code class="w"> </code><code class="c1">// Won't compile</code><code class="w"/></pre>
<p>Beginning Java programmers should avoid using raw types altogether.
Even experienced Java programmers can run into problems when using them.
For example, when using raw types when working with a type bound, then the type bound can be evaded, but in doing so, the code is left vulnerable to a runtime exception:</p>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// Compiles</code><code class="w"/>
<code class="n">NumberBox</code><code class="w"> </code><code class="n">n</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">NumberBox</code><code class="p">();</code><code class="w"/>
<code class="c1">// This is very dangerous</code><code class="w"/>
<code class="n">n</code><code class="p">.</code><code class="na">box</code><code class="p">(</code><code class="k">new</code><code class="w"> </code><code class="n">Object</code><code class="p">());</code><code class="w"/>
<code class="c1">// Runtime error</code><code class="w"/>
<code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">n</code><code class="p">.</code><code class="na">intValue</code><code class="p">());</code><code class="w"/></pre>
<p>The call to <code>intValue()</code> fails with a <code>java.lang.ClassCastException</code>—as <code>javac</code> has inserted an unconditional cast of <code>value</code> to <code>Number</code> before calling the method.</p>
<p>In general, type bounds can be used to write better generic code and libraries.
With practice, some fairly complex constructions can be built, for example:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="kd">class</code> <code class="nc">ComparingBox</code><code class="o">&lt;</code><code class="n">T</code><code class="w"> </code><code class="kd">extends</code><code class="w"> </code><code class="n">Comparable</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;&gt;</code><code class="w"> </code><code class="kd">extends</code><code class="w"> </code><code class="n">Box</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"/>
<code class="w">                            </code><code class="kd">implements</code><code class="w"> </code><code class="n">Comparable</code><code class="o">&lt;</code><code class="n">ComparingBox</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nd">@Override</code><code class="w"/>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="nf">compareTo</code><code class="p">(</code><code class="n">ComparingBox</code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="n">o</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">value</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="kc">null</code><code class="p">)</code><code class="w"/>
<code class="w">            </code><code class="k">return</code><code class="w"> </code><code class="n">o</code><code class="p">.</code><code class="na">value</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="kc">null</code><code class="w"> </code><code class="o">?</code><code class="w"> </code><code class="mi">0</code><code class="w"> </code><code class="p">:</code><code class="w"> </code><code class="o">-</code><code class="mi">1</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="n">value</code><code class="p">.</code><code class="na">compareTo</code><code class="p">(</code><code class="n">o</code><code class="p">.</code><code class="na">value</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>The definition might seem daunting, but the <code>ComparingBox</code> is really just a <code>Box</code> that contains a <code>Comparable</code> value. The type also extends the comparison operation to the <code>ComparingBox</code> type itself, just by comparing the contents of the two boxes.<a data-startref="ix_ch04-asciidoc14" data-type="indexterm" id="idm45927740276896"/><a data-startref="ix_ch04-asciidoc13" data-type="indexterm" id="idm45927740276192"/><a data-startref="ix_ch04-asciidoc12" data-type="indexterm" id="idm45927740275520"/></p>
</div></section>
<section data-pdf-bookmark="Introducing Covariance" data-type="sect2"><div class="sect2" id="javanut8-CHP-4-SECT-2.6">
<h2>Introducing Covariance</h2>
<p><a data-primary="covariance, generics and" data-type="indexterm" id="ix_ch04-asciidoc15"/><a data-primary="generics" data-secondary="covariance" data-type="indexterm" id="ix_ch04-asciidoc16"/>The design of Java’s generics contains the solution to an old problem.
In the earliest versions of Java, before the collections libraries were
even introduced, the language had been forced to confront a deep-seated type system design issue.</p>
<p>Put simply, the question is this:</p>
<blockquote>
<p>Should an array of strings be compatible with a variable of type array-of-object?</p></blockquote>
<p>In other words, should this code be legal?</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">String</code><code class="o">[]</code><code class="w"> </code><code class="n">words</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">{</code><code class="s">"Hello World!"</code><code class="p">};</code><code class="w"/>
<code class="n">Object</code><code class="o">[]</code><code class="w"> </code><code class="n">objects</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">words</code><code class="p">;</code><code class="w"/></pre>
<p>Without this, then even simple methods like <code>Arrays::sort</code> would have been very difficult to write in a useful way, as this would not work as expected:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">Arrays</code><code class="p">.</code><code class="na">sort</code><code class="p">(</code><code class="n">Object</code><code class="o">[]</code><code class="w"> </code><code class="n">a</code><code class="p">);</code><code class="w"/></pre>
<p>The method declaration would work only for the type <code>Object[]</code> and not for any other array type. As a result of these complications, the very first version of the Java Language Standard determined that:</p>
<blockquote>
<p>If a value of type <code>C</code> can be assigned to a variable of type <code>P</code>, then a value of type <code>C[]</code> can be assigned to a variable of type <code>P[]</code>.</p></blockquote>
<p>That is, arrays’ assignment syntax <em>varies with</em> the base type that they hold, or arrays are <em>covariant</em>.</p>
<p>This design decision is rather unfortunate, as it leads to immediate negative <span class="keep-together">consequences</span>:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">String</code><code class="o">[]</code><code class="w"> </code><code class="n">words</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">{</code><code class="s">"Hello"</code><code class="p">,</code><code class="w"> </code><code class="s">"World!"</code><code class="p">};</code><code class="w"/>
<code class="n">Object</code><code class="o">[]</code><code class="w"> </code><code class="n">objects</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">words</code><code class="p">;</code><code class="w"/>

<code class="c1">// Oh, dear, runtime error</code><code class="w"/>
<code class="n">objects</code><code class="o">[</code><code class="mi">0</code><code class="o">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">Integer</code><code class="p">(</code><code class="mi">42</code><code class="p">);</code><code class="w"/></pre>
<p>The assignment to <code>objects[0]</code> attempts to store an <code>Integer</code> into a piece of storage that is expecting to hold a <code>String</code>.
This obviously will not work and will throw an <code>ArrayStoreException</code>.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>The usefulness of covariant arrays led to them being seen as a necessary evil in the very early days of the platform, despite the hole in the static type system that the feature exposes.</p>
</div>
<p>However, more recent research on modern open-source codebases indicates that array covariance is extremely rarely used and is a language misfeature.<sup><a data-type="noteref" href="ch04.xhtml#idm45927740053936" id="idm45927740053936-marker">2</a></sup> You should avoid it when writing new code.</p>
<p>When considering the behavior of generics in the Java platform, a very similar question can be asked: “Is <code>List&lt;String&gt;</code> a subtype of <code>List&lt;Object&gt;</code>?” That is, can we write this:</p>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// Is this legal?</code><code class="w"/>
<code class="n">List</code><code class="o">&lt;</code><code class="n">Object</code><code class="o">&gt;</code><code class="w"> </code><code class="n">objects</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">ArrayList</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code><code class="p">();</code><code class="w"/></pre>
<p>At first glance, this seems entirely reasonable—<code>String</code> is a subclass of <code>Object</code>, so we know that any <code>String</code> element in our collection is also a valid <code>Object</code>.</p>
<p>However, consider the following code (which is just the array covariance code translated to use <code>List</code>):</p>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// Is this legal?</code><code class="w"/>
<code class="n">List</code><code class="o">&lt;</code><code class="n">Object</code><code class="o">&gt;</code><code class="w"> </code><code class="n">objects</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">ArrayList</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code><code class="p">();</code><code class="w"/>

<code class="c1">// What do we do about this?</code><code class="w"/>
<code class="n">objects</code><code class="p">.</code><code class="na">add</code><code class="p">(</code><code class="k">new</code><code class="w"> </code><code class="n">Object</code><code class="p">());</code><code class="w"/></pre>
<p>As the type of <code>objects</code> was declared to be <code>List&lt;Object&gt;</code>, then it should be legal to add an <code>Object</code> instance to it.
However, as the actual instance holds strings, then trying to add an <code>Object</code> would not be compatible, and so this would fail at runtime.</p>
<p>This would have changed nothing from the case of arrays, and so the resolution is to realize that although this is legal:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">Object</code><code class="w"> </code><code class="n">o</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">String</code><code class="p">(</code><code class="s">"X"</code><code class="p">);</code><code class="w"/></pre>
<p>that does not mean that the corresponding statement for generic container types is also true, and as a result:</p>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// Won't compile</code><code class="w"/>
<code class="n">List</code><code class="o">&lt;</code><code class="n">Object</code><code class="o">&gt;</code><code class="w"> </code><code class="n">objects</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">ArrayList</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code><code class="p">();</code><code class="w"/></pre>
<p>Another way of saying this is that <code>List&lt;String&gt;</code> is <em>not</em> a subtype of
<code>List&lt;Object&gt;</code> or that generic types are <em>invariant</em>, not <em>covariant</em>.
We will have more to say about this when we discuss bounded wildcards.<a data-startref="ix_ch04-asciidoc16" data-type="indexterm" id="idm45927739879904"/><a data-startref="ix_ch04-asciidoc15" data-type="indexterm" id="idm45927739879200"/></p>
</div></section>
<section data-pdf-bookmark="Wildcards" data-type="sect2"><div class="sect2" id="javanut8-CHP-4-SECT-2.7">
<h2>Wildcards</h2>
<p><a data-primary="generics" data-secondary="wildcards" data-type="indexterm" id="ix_ch04-asciidoc17"/><a data-primary="types" data-secondary="wildcards" data-type="indexterm" id="ix_ch04-asciidoc18"/>A parameterized type, such as <code>ArrayList&lt;T&gt;</code>, is not <em>instantiable</em>; we
cannot create instances of them. This is because <code>&lt;T&gt;</code> is just a type
parameter, merely a placeholder for a genuine type. It is only when we
provide a concrete value for the type parameter (e.g.,
<code>ArrayList&lt;String&gt;</code>) that the type becomes fully formed and we can
create objects of that type.</p>
<p><a data-primary="unknown type" data-seealso="wildcard types" data-type="indexterm" id="idm45927739872512"/>This poses a problem if the type that we want to work with is unknown at compile time.
Fortunately, the Java type system is able to accommodate this concept.
<a data-primary="wildcard types" data-type="indexterm" id="idm45927739871408"/>It does so by having an explicit concept of the <em>unknown type</em>, which is represented as <code>&lt;?&gt;</code>. This is the simplest example of Java’s <em>wildcard types</em>.</p>
<p>We can write expressions that involve the unknown type:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">ArrayList</code><code class="o">&lt;?&gt;</code><code class="w"> </code><code class="n">mysteryList</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">unknownList</code><code class="p">();</code><code class="w"/>
<code class="n">Object</code><code class="w"> </code><code class="n">o</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">mysteryList</code><code class="p">.</code><code class="na">get</code><code class="p">(</code><code class="mi">0</code><code class="p">);</code><code class="w"/></pre>
<p>This is perfectly valid Java: <code>ArrayList&lt;?&gt;</code> is a complete type that a variable can have, unlike <code>ArrayList&lt;T&gt;</code>.
We don’t know anything about <code>mysteryList</code>’s payload type, but that may not be a problem for our code.</p>
<p>For example, when we get an item out of <code>mysteryList</code>, it has a completely unknown type.
However, we can be sure that the object is assignable to <code>Object</code>—because all valid values of a generic type parameter are reference types and all reference values can be assigned to a variable of type <code>Object</code>.</p>
<p>On the other hand, when we’re working with the unknown type, there are some limitations on its use in user code.
For example, this code will not compile:</p>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// Won't compile</code><code class="w"/>
<code class="n">mysteryList</code><code class="p">.</code><code class="na">add</code><code class="p">(</code><code class="k">new</code><code class="w"> </code><code class="n">Object</code><code class="p">());</code><code class="w"/></pre>
<p>The reason for this is simple: we don’t know what the payload type of
<code>mysteryList</code> is! For example, if <code>mysteryList</code> was really a instance of
<code>ArrayList&lt;String&gt;</code>, then we wouldn’t expect to be able to put an
<code>Object</code> into it.</p>
<p>The only value that we know we can always insert into a container is
<code>null</code>, as we know that <code>null</code> is a possible value for any reference type.
This isn’t that useful, and for this reason, the Java language spec also
rules out instantiating a container object with the unknown type as
payload, for example:</p>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// Won't compile</code><code class="w"/>
<code class="n">List</code><code class="o">&lt;?&gt;</code><code class="w"> </code><code class="n">unknowns</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">ArrayList</code><code class="o">&lt;?&gt;</code><code class="p">();</code><code class="w"/></pre>
<p>The unknown type may seem to be of limited utility, but one very important use for it is as a starting point for resolving the covariance question.
We can use the unknown type if we want to have a subtyping relationship for
containers, like this:</p>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// Perfectly legal</code><code class="w"/>
<code class="n">List</code><code class="o">&lt;?&gt;</code><code class="w"> </code><code class="n">objects</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">ArrayList</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code><code class="p">();</code><code class="w"/></pre>
<p>This means that <code>List&lt;String&gt;</code> <em>is</em> a subtype of <code>List&lt;?&gt;</code>—although when we use an assignment like the preceding one, we have lost some type information.
For example, the return type of <code>objects.get()</code> is now effectively <code>Object</code>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>For any value of the type parameter <code>T</code>, <code>List&lt;?&gt;</code> is not a subtype of the type <code>List&lt;T&gt;</code>.</p>
</div>
<p>The unknown type sometimes confuses developers—provoking questions like,
“Why wouldn’t you just use <code>Object</code> instead of the unknown type?”
However, as we’ve seen, the need to have subtyping relationships between
generic types essentially requires us to have a notion of the unknown
type.</p>
<section data-pdf-bookmark="Bounded wildcards" data-type="sect3"><div class="sect3" id="javanut8-CHP-4-SECT-2.8">
<h3>Bounded wildcards</h3>
<p><a data-primary="bounded wildcards" data-type="indexterm" id="idm45927739700032"/><a data-primary="generics" data-secondary="bounded wildcards" data-type="indexterm" id="idm45927739699328"/>In fact, Java’s wildcard types extend beyond just the unknown type,
with the concept of <em>bounded wildcards</em>.</p>
<p>These are used to describe the inheritance hierarchy of a mostly unknown
type—effectively making statements like, for example, “I don’t know
anything about this type, except that it must implement <code>List</code>.”</p>
<p>This would be written as <code>? extends List</code> in the type parameter. This
provides a useful lifeline to programmers. Instead of being restricted
to the totally unknown type, they know that at least the capabilities of
the type bound are <span class="keep-together">available</span>.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>The <code>extends</code> keyword is always used, regardless of whether the constraining type is a class or interface type.</p>
</div>
<p><a data-primary="type variance" data-type="indexterm" id="idm45927739693328"/>This is an example of a concept called <em>type variance</em>, which is the
general theory of how inheritance between container types relates to the
inheritance of their payload types.</p>
<dl>
<dt>Type covariance</dt>
<dd>
<p>This means that the container types have the same relationship to
each other as the payload types do. This is expressed using the
<code>extends</code> keyword.</p>
</dd>
<dt>Type contravariance</dt>
<dd>
<p>This means that the container types have the inverse relationship to
each other as the payload types. This is expressed using the <code>super</code>
keyword.</p>
</dd>
</dl>
<p>These ideas tend to appear when discussing container types.
For example, if <code>Cat</code> extends <code>Pet</code>, then <code>List&lt;Cat&gt;</code> is a subtype of <code>List&lt;? extends Pet&gt;</code>, and so:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">List</code><code class="o">&lt;</code><code class="n">Cat</code><code class="o">&gt;</code><code class="w"> </code><code class="n">cats</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">ArrayList</code><code class="o">&lt;</code><code class="n">Cat</code><code class="o">&gt;</code><code class="p">();</code><code class="w"/>
<code class="n">List</code><code class="o">&lt;?</code><code class="w"> </code><code class="kd">extends</code><code class="w"> </code><code class="n">Pet</code><code class="o">&gt;</code><code class="w"> </code><code class="n">pets</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">cats</code><code class="p">;</code><code class="w"/></pre>
<p>However, this differs from the array case, because type safety is maintained in the following way:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">pets</code><code class="p">.</code><code class="na">add</code><code class="p">(</code><code class="k">new</code><code class="w"> </code><code class="n">Cat</code><code class="p">());</code><code class="w"> </code><code class="c1">// won't compile</code><code class="w"/>
<code class="n">pets</code><code class="p">.</code><code class="na">add</code><code class="p">(</code><code class="k">new</code><code class="w"> </code><code class="n">Pet</code><code class="p">());</code><code class="w"> </code><code class="c1">// won't compile</code><code class="w"/>
<code class="n">cats</code><code class="p">.</code><code class="na">add</code><code class="p">(</code><code class="k">new</code><code class="w"> </code><code class="n">Cat</code><code class="p">());</code><code class="w"/></pre>
<p>The compiler cannot prove that the storage pointed at by <code>pets</code> is capable of storing a <code>Cat</code> and so it rejects the call to <code>add()</code>.
However, as <code>cats</code> definitely points at a list of <code>Cat</code> objects, then it must be acceptable to add a new one to the list.</p>
<p>As a result, it is very commonplace to see these types of generic constructions with types that act as producers or consumers of payload types.</p>
<p>For example, when the <code>List</code> is acting as a <em>producer</em> of <code>Pet</code> objects, then the appropriate keyword is <code>extends</code>.</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">Pet</code><code class="w"> </code><code class="n">p</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">pets</code><code class="p">.</code><code class="na">get</code><code class="p">(</code><code class="mi">0</code><code class="p">);</code><code class="w"/></pre>
<p>Note that for the producer case, the payload type appears as the return type of the producer method.</p>
<p>For a container type that is acting purely as a <em>consumer</em> of instances
of a type, we would use the <code>super</code> keyword, and we would expect to see the payload type as the type of a method argument.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a data-primary="PECS (Producer Extends, Consumer Super) principle" data-type="indexterm" id="idm45927739541840"/><a data-primary="Producer Extends, Consumer Super (PECS) principle" data-type="indexterm" id="idm45927739541168"/>This is codified in the <em>Producer Extends, Consumer Super</em> (PECS)
principle coined by Joshua Bloch.</p>
</div>
<p>As we will discuss in <a data-type="xref" href="ch08.xhtml#javanut8-CHP-8">Chapter 8</a>, both covariance and contravariance appear throughout the Java Collections.
They largely exist to ensure that the generics just “do the right thing” and behave in a manner that should not surprise the developer.<a data-startref="ix_ch04-asciidoc18" data-type="indexterm" id="idm45927739538576"/><a data-startref="ix_ch04-asciidoc17" data-type="indexterm" id="idm45927739537904"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Generic Methods" data-type="sect2"><div class="sect2" id="javanut8-CHP-4-SECT-2.9">
<h2>Generic Methods</h2>
<p><a data-primary="generic methods" data-type="indexterm" id="idm45927739535728"/><a data-primary="generics" data-secondary="generic methods" data-type="indexterm" id="idm45927739535024"/>A <em>generic method</em> is a method that is able to take instances of any reference type.</p>
<p>Let’s look at an example.
<a data-primary="compound declaration" data-type="indexterm" id="idm45927739511824"/>In Java, the comma is used to allow multiple declarations in a single line (usually referred to as a <em>compound declaration</em>).
<a data-primary=", (comma) operator" data-type="indexterm" id="idm45927739510592"/>Other languages, such as Javascript or C, have a comma operator that is much more general.
The JS comma operator <code>(,)</code> evaluates both expressions provided to it (from left to right) and returns the value of the last expression.
The aim is to create a compound expression in which multiple expressions are evaluated, with the compound expression’s value being the value of the rightmost of its member expressions.
Note that any side effects from evaluating the expressions to the comma are always triggered, unlike in a short-circuiting logic operator.</p>
<p>Java’s comma is much more restrictive than this, by design.
This is because the comma in other languages can lead to some very hard-to-understand code and can be a fantastic source of bugs.
However, if we did want to emulate the behavior of the comma operator from other language, we could do so by creating a generic method:</p>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// Note that this class is not generic</code><code class="w"/>
<code class="kd">public</code><code class="w"> </code><code class="kd">class</code> <code class="nc">Utils</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="kd">static</code><code class="w"> </code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="n">T</code><code class="w"> </code><code class="nf">comma</code><code class="p">(</code><code class="n">T</code><code class="w"> </code><code class="n">a</code><code class="p">,</code><code class="w"> </code><code class="n">T</code><code class="w"> </code><code class="n">b</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="n">b</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Calling the method <code>Utils.comma()</code> will cause the values of the expressions <code>a</code> and <code>b</code> to be computed, and any side effects to be triggered, before the method call, which is the behavior we want.</p>
<p>However, notice that even though a type parameter is used in the definition of the method, the class it is defined in (<code>Utils</code>) is not generic.
Instead, we see that a new syntax is used to indicate that the method can be used freely, and that the return type is the same as the argument.</p>
<p>Let’s look at another example, from the Java Collections library.
In the <code>ArrayList</code> class we can find a method to create a new array object from an arraylist instance:</p>
<pre data-code-language="java" data-type="programlisting"><code class="nd">@SuppressWarnings</code><code class="p">(</code><code class="s">"unchecked"</code><code class="p">)</code><code class="w"/>
<code class="kd">public</code><code class="w"> </code><code class="o">&lt;</code><code class="n">T</code><code class="o">&gt;</code><code class="w"> </code><code class="n">T</code><code class="o">[]</code><code class="w"> </code><code class="nf">toArray</code><code class="p">(</code><code class="n">T</code><code class="o">[]</code><code class="w"> </code><code class="n">a</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">a</code><code class="p">.</code><code class="na">length</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="n">size</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="c1">// Make a new array of a's runtime type, but my contents:</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="n">T</code><code class="o">[]</code><code class="p">)</code><code class="w"> </code><code class="n">Arrays</code><code class="p">.</code><code class="na">copyOf</code><code class="p">(</code><code class="n">elementData</code><code class="p">,</code><code class="w"> </code><code class="n">size</code><code class="p">,</code><code class="w"> </code><code class="n">a</code><code class="p">.</code><code class="na">getClass</code><code class="p">());</code><code class="w"/>
<code class="w">    </code><code class="n">System</code><code class="p">.</code><code class="na">arraycopy</code><code class="p">(</code><code class="n">elementData</code><code class="p">,</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="n">a</code><code class="p">,</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="n">size</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">a</code><code class="p">.</code><code class="na">length</code><code class="w"> </code><code class="o">&gt;</code><code class="w"> </code><code class="n">size</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="n">a</code><code class="o">[</code><code class="n">size</code><code class="o">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="kc">null</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="n">a</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>This method uses the low-level <code>arraycopy()</code> method to do the actual work.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>If we look at the class definition for <code>ArrayList</code> we can see that it is a generic class—but the type parameter is <code>&lt;E&gt;</code>, not <code>&lt;T&gt;</code>, and the type parameter <code>&lt;E&gt;</code> does not appear at all in the definition of <code>toArray()</code>.</p>
</div>
<p>The <code>toArray()</code> method provides one half of a bridge API between the collections and Java’s original arrays.
The other half of the API—moving from arrays to collections—involves a few additional subtleties, as we will discuss in <a data-type="xref" href="ch08.xhtml#javanut8-CHP-8">Chapter 8</a>.</p>
</div></section>
<section data-pdf-bookmark="Compile and Runtime Typing" data-type="sect2"><div class="sect2" id="javanut8-CHP-4-SECT-2.10">
<h2>Compile and Runtime Typing</h2>
<p><a data-primary="compile-time typing" data-type="indexterm" id="idm45927739330320"/><a data-primary="generics" data-secondary="compile-time/runtime typing" data-type="indexterm" id="idm45927739329616"/><a data-primary="runtime typing" data-type="indexterm" id="idm45927739328656"/>Consider an example piece of code:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code><code class="w"> </code><code class="n">l</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">ArrayList</code><code class="o">&lt;&gt;</code><code class="p">();</code><code class="w"/>
<code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">l</code><code class="p">);</code><code class="w"/></pre>
<p>We can ask the following question: what is the type of <code>l</code>? The answer to that question depends on whether we consider <code>l</code> at compile time (i.e., the type seen by <code>javac</code>) or at runtime (as seen by the JVM).</p>
<p><code>javac</code> will see the type of <code>l</code> as <code>List-of-String</code> and will use that type information to carefully check for syntax errors, such as an attempted <code>add()</code> of an illegal type.</p>
<p>Conversely, the JVM will see <code>l</code> as an object of type <code>ArrayList</code>, as we
can see from the <code>println()</code> statement. The runtime type of <code>l</code> is a
raw type due to type erasure.</p>
<p>The compile-time and runtime types are therefore slightly different from
each other. The slightly strange thing is that in some ways, the runtime
type is both more <em>and</em> less specific than the compile-time type.</p>
<p>The runtime type is less specific than the compile-time type, because
the type information about the payload type is gone—it has been erased,
and the resulting runtime type is just a raw type.</p>
<p>The compile-time type is less specific than the runtime type, because we
don’t know exactly what concrete type <code>l</code> will be; all we know is that it
will be of a type compatible with <code>List</code>.</p>
<p>The differences between compile-time and runtime typing sometimes confuse new Java programmers, but the distinction quickly comes to be seen as a normal part of working in the language.</p>
</div></section>
<section data-pdf-bookmark="Using and Designing Generic Types" data-type="sect2"><div class="sect2" id="javanut8-CHP-4-SECT-2.11">
<h2>Using and Designing Generic Types</h2>
<p><a data-primary="generics" data-secondary="using and designing" data-type="indexterm" id="idm45927739241856"/>When working with Java’s generics, it can be helpful to think
in terms of two different levels of understanding:</p>
<dl>
<dt>Practitioner</dt>
<dd>
<p>A practitioner needs to use existing generic libraries and to build
some fairly simple generic classes. At this level, the developer
should also understand the basics of type erasure, as several Java
syntax features are confusing without at least an awareness of the
runtime handling of generics.</p>
</dd>
<dt>Designer</dt>
<dd>
<p>The designer of new libraries that use generics needs to understand
much more of the capabilities of generics. There are some nastier
parts of the spec, including a full understanding of wildcards, and
advanced topics such as “capture-of” error messages.</p>
</dd>
</dl>
<p>Java generics are one of the most complex parts of the language specification with a lot of potential corner cases.
Not every developer needs to fully understand this part of the language, at least not on their first encounter with
this part of Java’s type system.<a data-startref="ix_ch04-asciidoc11" data-type="indexterm" id="idm45927739237280"/><a data-startref="ix_ch04-asciidoc10" data-type="indexterm" id="idm45927739236576"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Enums and Annotations" data-type="sect1"><div class="sect1" id="javanut8-CHP-4-SECT-3">
<h1>Enums and Annotations</h1>
<p>We have already met records, but Java has additional specialized forms of classes and interfaces used to fulfill specific roles in the type system. They are known as <em>enumerated types</em> and <em>annotation types</em>, or normally just <em>enums</em> and <em>annotations</em>.</p>
<section data-pdf-bookmark="Enums" data-type="sect2"><div class="sect2" id="javanut8-CHP-4-SECT-3.1">
<h2>Enums</h2>
<p><a data-primary="class(es)" data-secondary="enums" data-type="indexterm" id="ix_ch04-asciidoc19"/><a data-primary="enums (enumerated types)" data-type="indexterm" id="ix_ch04-asciidoc20"/><a data-primary="type system" data-secondary="enums" data-type="indexterm" id="ix_ch04-asciidoc21"/>Enums are a variation of classes that have limited functionality and the specific semantic meaning that the type has only a small number of possible permitted values.</p>
<p>For example, suppose we want to define a type to represent the primary colors of red, green, and blue, and we want these to be the only possible values of the type.
We can do this by using the <code>enum</code> keyword:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="kd">enum</code><code class="w"> </code><code class="n">PrimaryColor</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="c1">// The ; is not required at the end of the list of instances</code><code class="w"/>
<code class="w">  </code><code class="n">RED</code><code class="p">,</code><code class="w"> </code><code class="n">GREEN</code><code class="p">,</code><code class="w"> </code><code class="n">BLUE</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>The only available instances of the type <code>PrimaryColor</code> can then be referenced as static fields: <code>PrimaryColor.RED</code>, <code>PrimaryColor.GREEN</code>, and <code>PrimaryColor.BLUE</code>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a data-primary="C/C++" data-secondary="enum types in" data-type="indexterm" id="idm45927739173680"/>In other languages, such as C++, the role of enum types is fulfilled by using constant integers, but Java’s approach provides better type safety and more flexiblity.</p>
</div>
<p>As enums are specialized classes, enums can have member fields and methods.
If they do have a body (consisting of fields or methods), then the semicolon at the end of the list of instances is required, and the list of enum constants must precede the methods and fields.</p>
<p>For example, suppose that we want to have an enum that encompasses the suits of standard playing cards.
We can achieve this by using an enum that takes a value as a parameter, like this:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="kd">enum</code><code class="w"> </code><code class="n">Suit</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="c1">// ; at the end of list required for enums with parameters</code><code class="w"/>
<code class="w">    </code><code class="n">HEART</code><code class="p">(</code><code class="sc">'♥'</code><code class="p">),</code><code class="w"/>
<code class="w">    </code><code class="n">CLUB</code><code class="p">(</code><code class="sc">'♣'</code><code class="p">),</code><code class="w"/>
<code class="w">    </code><code class="n">DIAMOND</code><code class="p">(</code><code class="sc">'♦'</code><code class="p">),</code><code class="w"/>
<code class="w">    </code><code class="n">SPADE</code><code class="p">(</code><code class="sc">'♠'</code><code class="p">);</code><code class="w"/>

<code class="w">    </code><code class="kd">private</code><code class="w"> </code><code class="kt">char</code><code class="w"> </code><code class="n">symbol</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="kd">private</code><code class="w"> </code><code class="kt">char</code><code class="w"> </code><code class="n">letter</code><code class="p">;</code><code class="w"/>

<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kt">char</code><code class="w"> </code><code class="nf">getSymbol</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="n">symbol</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kt">char</code><code class="w"> </code><code class="nf">getLetter</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="n">letter</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="kd">private</code><code class="w"> </code><code class="nf">Suit</code><code class="p">(</code><code class="kt">char</code><code class="w"> </code><code class="n">symbol</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">this</code><code class="p">.</code><code class="na">symbol</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">symbol</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="k">this</code><code class="p">.</code><code class="na">letter</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">switch</code><code class="w"> </code><code class="p">(</code><code class="n">symbol</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="k">case</code><code class="w"> </code><code class="sc">'♥'</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="sc">'H'</code><code class="p">;</code><code class="w"/>
<code class="w">            </code><code class="k">case</code><code class="w"> </code><code class="sc">'♣'</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="sc">'C'</code><code class="p">;</code><code class="w"/>
<code class="w">            </code><code class="k">case</code><code class="w"> </code><code class="sc">'♦'</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="sc">'D'</code><code class="p">;</code><code class="w"/>
<code class="w">            </code><code class="k">case</code><code class="w"> </code><code class="sc">'♠'</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="sc">'S'</code><code class="p">;</code><code class="w"/>
<code class="w">            </code><code class="k">default</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="k">throw</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">RuntimeException</code><code class="p">(</code><code class="s">"Illegal:"</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">symbol</code><code class="p">);</code><code class="w"/>
<code class="w">        </code><code class="p">};</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>The parameters (only one of them in this example) are passed to the
constructor to create the individual enum instances. As the enum
instances are created by the Java runtime, and can’t be instantiated
from outside, the constructor is declared as private.</p>
<p>Enums have some special properties:</p>
<ul>
<li>
<p>All (implicitly) extend <code>java.lang.Enum</code></p>
</li>
<li>
<p>May not be generic</p>
</li>
<li>
<p>May implement interfaces</p>
</li>
<li>
<p>Cannot be extended</p>
</li>
<li>
<p>May have only abstract methods if all enum values provide an
implementation body</p>
</li>
<li>
<p>May not be directly instantiated by <code>new</code><a data-startref="ix_ch04-asciidoc21" data-type="indexterm" id="idm45927738841568"/><a data-startref="ix_ch04-asciidoc20" data-type="indexterm" id="idm45927738840864"/><a data-startref="ix_ch04-asciidoc19" data-type="indexterm" id="idm45927738840192"/></p>
</li>
</ul>
</div></section>
<section data-pdf-bookmark="Annotations" data-type="sect2"><div class="sect2" id="javanut8-CHP-4-SECT-3.2">
<h2>Annotations</h2>
<p><a data-primary="annotations (annotated types)" data-type="indexterm" id="idm45927739007136"/><a data-primary="interfaces" data-secondary="annotations" data-type="indexterm" id="idm45927739006464"/><a data-primary="type system" data-secondary="annotations" data-type="indexterm" id="idm45927739005520"/>Annotations are a specialized kind of interface that, as the name
suggests, annotate some part of a Java program.</p>
<p><a data-primary="@Override annotation" data-primary-sortas="Override annotation" data-type="indexterm" id="idm45927739004064"/>For example, consider the <code>@Override</code> annotation. You may have seen it
on some methods in some of the earlier examples and may have asked the
following question: what does it do?</p>
<p>The short, and perhaps surprising, answer is that it does nothing at all.</p>
<p>The less short (and flippant) answer is that, like all annotations, it
has no direct effect but instead acts as additional information about
the method that it annotates; in this case, it denotes that a method
overrides a superclass method.</p>
<p>This acts as a useful hint to compilers and integrated development
environments (IDEs)—if a developer has misspelled the name of a method intended to be an override of a superclass method, then the
presence of the <code>@Override</code> annotation on the misspelled method (which
does not override anything) alerts the compiler to the fact that
something is not right.</p>
<p>Annotations, as originally conceived, were not supposed to alter program semantics; instead, they were to provide optional metadata.
In its strictest sense, this means that they should not affect program execution and instead should only provide information for compilers and other pre-execution phases.</p>
<p>In practice, modern Java applications make heavy use of annotations, and this now includes many use cases that essentially render the annotated classes useless without additional runtime support.</p>
<p>For example, classes bearing annotations such as <code>@Inject</code>, <code>@Test</code>, or <code>@Autowired</code> cannot realistically be used outside of a suitable container.
As a result, it is difficult to argue that such annotations do not violate the “no semantic meaning” rule.</p>
<p><a data-primary="java.lang" data-type="indexterm" id="idm45927738997904"/>The platform defines a small number of basic annotations in
<code>java.lang</code>. The original set were <code>@Override</code>, <code>@Deprecated</code>, and
<code>@SuppressWarnings</code>, which were used to indicate that a method was
overriden, deprecated, or that it generated some compiler warnings that
should be suppressed.</p>
<p><a data-primary="@FunctionalInterface annotation" data-primary-sortas="FunctionalInterface annotation" data-type="indexterm" id="idm45927738994928"/>These were augmented by <code>@SafeVarargs</code> in Java 7 (which provides extended warning suppression for varargs methods) and <code>@FunctionalInterface</code> in Java 8.</p>
<p>This last annotation indicates an interface can be used as a target for a lambda expression—it is a useful marker annotation although not mandatory, as we will see.</p>
<p>Annotations have some special properties, compared to regular interfaces:</p>
<ul>
<li>
<p>All (implicitly) extend <code>java.lang.annotation.Annotation</code></p>
</li>
<li>
<p>May not be generic</p>
</li>
<li>
<p>May not extend any other interface</p>
</li>
<li>
<p>May only define zero-arg methods</p>
</li>
<li>
<p>May not define methods that throw exceptions</p>
</li>
<li>
<p>Have restrictions on the return types of methods</p>
</li>
<li>
<p>Can have a default return value for methods</p>
</li>
</ul>
<p>In practice, annotations do not typically have a great deal of functionality and instead are a fairly simple language concept.</p>
</div></section>
<section data-pdf-bookmark="Defining Custom Annotations" data-type="sect2"><div class="sect2" id="javanut8-CHP-4-SECT-3.3">
<h2>Defining Custom Annotations</h2>
<p><a data-primary="annotations (annotated types)" data-secondary="defining custom types" data-type="indexterm" id="idm45927738982768"/><a data-primary="custom annotations, defining" data-type="indexterm" id="idm45927738981728"/>Defining custom annotation types for use in your own code is not that hard.
The <code>@interface</code> keyword allows the developer to define a new annotation type, in much the same way that <code>class</code> or <code>interface</code> is used.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a data-primary="meta-annotations" data-type="indexterm" id="idm45927738978640"/>The key to writing custom annotations is the use of “meta-annotations.”
These are special annotations that appear on the definition of new (custom) annotation types.</p>
</div>
<p><a data-primary="java.lang.annotation" data-type="indexterm" id="idm45927738977424"/>The meta-annotations are defined in <code>java.lang.annotation</code> and allow
the developer to specify policy for where the new annotation type is to
be used and how it will be treated by the compiler and runtime.</p>
<p>There are two primary meta-annotations that are both required when creating a new annotation type—<code>@Target</code> and
<code>@Retention</code>. These both take values that are represented as enums.</p>
<p>The <code>@Target</code> meta-annotation indicates where the new custom annotation
can be legally placed within Java source code. The enum <code>ElementType</code>
has the possible values <code>TYPE</code>, <code>FIELD</code>, <code>METHOD</code>,
<code>PARAMETER</code>, <code>CONSTRUCTOR</code>, <code>LOCAL_VARIABLE</code>, <code>ANNOTATION_TYPE</code>,
<code>PACKAGE</code>, <code>TYPE_PARAMETER</code>, and <code>TYPE_USE</code>, and annotations can indicate that they intend to be used at one or more of these locations.</p>
<p>The other meta-annotation is <code>@Retention</code>, which indicates how <code>javac</code>
and the Java runtime should process the custom annotation type. It can
have one of three values, which are represented by the enum
<code>RetentionPolicy</code>:</p>
<dl>
<dt><code>SOURCE</code></dt>
<dd>
<p>Annotations with this retention policy are discarded by <code>javac</code> during <span class="keep-together">compilation</span>.</p>
</dd>
<dt><code>CLASS</code></dt>
<dd>
<p>This means that the annotation will be present in the class file but
will not necessarily be accessible at runtime by the JVM. This is
rarely used but is sometimes seen in tools that do offline analysis
of JVM bytecode.</p>
</dd>
<dt><code>RUNTIME</code></dt>
<dd>
<p>This indicates that the annotation will be available for user code to
access at runtime (by using reflection).</p>
</dd>
</dl>
<p>Let’s take a look at an example, a simple annotation called <code>@Nickname</code>,
which allows the developer to define a nickname for a method, which can
then be used to find the method reflectively at runtime:</p>
<pre data-code-language="java" data-type="programlisting"><code class="nd">@Target</code><code class="p">(</code><code class="n">ElementType</code><code class="p">.</code><code class="na">METHOD</code><code class="p">)</code><code class="w"/>
<code class="nd">@Retention</code><code class="p">(</code><code class="n">RetentionPolicy</code><code class="p">.</code><code class="na">RUNTIME</code><code class="p">)</code><code class="w"/>
<code class="kd">public</code><code class="w"> </code><code class="nd">@interface</code><code class="w"> </code><code class="n">Nickname</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">String</code><code class="o">[]</code><code class="w"> </code><code class="nf">value</code><code class="p">()</code><code class="w"> </code><code class="k">default</code><code class="w"> </code><code class="p">{};</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>This is all that’s required to define the annotation—a syntax element
where the annotation can appear, a retention policy, and the name of the
element. As we need to be able to supply the nickname we’re assigning to
the method, we also need to define a method on the annotation. Despite
this, defining new custom annotations is a remarkably compact
undertaking.</p>
<p>In addition to the two primary meta-annotations, there are also the
<code>@Inherited</code> and <code>@Documented</code> meta-annotations. These are much less
frequently encountered in practice, and details on them can be found in
the platform documentation.</p>
</div></section>
<section data-pdf-bookmark="Type Annotations" data-type="sect2"><div class="sect2" id="javanut8-CHP-4-SECT-3.4">
<h2>Type Annotations</h2>
<p><a data-primary="annotations (annotated types)" data-secondary="type annotations" data-type="indexterm" id="idm45927738783456"/><a data-primary="Java 8" data-primary-sortas="Java 08" data-secondary="ElementType values" data-type="indexterm" id="idm45927738782512"/>With the release of Java 8, two new values for <code>ElementType</code> were
added: <code>TYPE_PARAMETER</code> and <code>TYPE_USE</code>. These new values allow the use of
annotations in places where they were previously not legal, such as at
any site where a type is used. This enables the developer to write code
such as:</p>
<pre data-code-language="java" data-type="programlisting"><code class="nd">@NotNull</code><code class="w"> </code><code class="n">String</code><code class="w"> </code><code class="n">safeString</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">getMyString</code><code class="p">();</code><code class="w"/></pre>
<p>The extra type information conveyed by the <code>@NotNull</code> can then be used by a special type checker to detect problems (a possible <code>NullPointerException</code>, in this example) and to perform additional static analysis.
The basic Java 8 distribution ships with some basic pluggable type checkers, but it also provides a framework for allowing developers and library authors to create their own.</p>
<p>In this section, we’ve met Java’s enum and annotation types.
Let’s move on to consider the next important part of Java’s type system: lambda expressions.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Lambda Expressions" data-type="sect1"><div class="sect1" id="javanut8-CHP-4-SECT-4">
<h1>Lambda Expressions</h1>
<p><a data-primary="lambda expressions" data-type="indexterm" id="ix_ch04-asciidoc22"/><a data-primary="type system" data-secondary="lambda expressions" data-type="indexterm" id="ix_ch04-asciidoc23"/>One <a data-primary="lambda expressions" data-secondary="basics" data-type="indexterm" id="ix_ch04-asciidoc24"/>of the most eagerly anticipated features of Java 8 was the introduction of lambda expressions (frequently referred to as just lambdas).</p>
<p>This major upgrade to the Java platform was driven by five goals, in roughly descending order of priority:</p>
<ul>
<li>
<p>More expressive programming</p>
</li>
<li>
<p>Better libraries</p>
</li>
<li>
<p>Concise code</p>
</li>
<li>
<p>Improved programming safety</p>
</li>
<li>
<p>Potentially increased data parallelism</p>
</li>
</ul>
<p>Lambdas have three key aspects that help define the essential nature of the feature:</p>
<ul>
<li>
<p>They allow small bits of code to be written inline as literals in a program.</p>
</li>
<li>
<p>They relax the strict grammar of Java code by using type inference.</p>
</li>
<li>
<p>They facilitate a more functional style of programming Java.</p>
</li>
</ul>
<p>As we saw in <a data-type="xref" href="ch02.xhtml#javanut8-CHP-2">Chapter 2</a>, the syntax for a lambda
expression is to take a list of parameters (the types of which are
typically inferred), and to attach that to a method body, like this:</p>
<pre data-code-language="java" data-type="programlisting"><code class="p">(</code><code class="n">p</code><code class="p">,</code><code class="w"> </code><code class="n">q</code><code class="p">)</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="cm">/* method body */</code><code class="w"> </code><code class="p">}</code><code class="w"/></pre>
<p>This can provide a very compact way to represent what is effectively a single method.
It is also a major departure from earlier versions of Java—until now, we always required a class declaration and then a complete method declaration, all of which add to the verboseness of the code.</p>
<p><a data-primary="anonymous classes" data-type="indexterm" id="idm45927738717136"/>In fact, before the arrival of lambdas, the only way to approximate this coding style was to use <em>anonymous classes</em>, which we will discuss later in this chapter.
However, since Java 8, lambdas have proved to be very popular with Java programmers and now have mostly taken over the role of anonymous classes.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Despite the similarities between lambda expressions and anonymous classes, lambdas are <em>not</em> simply syntactic sugar over anonymous classes.
In fact, lambdas are implemented using method handles (which we will meet in <a data-type="xref" href="ch11.xhtml#javanut8-CHP-11">Chapter 11</a>) and a special JVM bytecode called <code>invokedynamic</code>.</p>
</div>
<p>Lambda expressions represent the creation of an object of a specific type.
The type of the instance that is created is known as the <em>target type</em> of the lambda.</p>
<p>Only certain types are eligible to be the target of a lambda.</p>
<p><a data-primary="functional interfaces" data-type="indexterm" id="idm45927738707664"/>Target types are also called <em>functional interfaces</em> and they must:</p>
<ul>
<li>
<p>Be interfaces</p>
</li>
<li>
<p>Have only one nondefault method (but may have other methods that are default)</p>
</li>
</ul>
<p><a data-primary="SAM (single abstract method) type" data-type="indexterm" id="idm45927738677200"/><a data-primary="single abstract method (SAM) type" data-type="indexterm" id="idm45927738676592"/>Some developers also like to use the <em>single abstract method</em> (or SAM) type to refer to the interface type that the lambda is converted into.
This draws attention to the fact that to be usable by the lambda expression mechanism, an interface must have only a single nondefault method.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>A lambda expression has almost all of the component parts of a method, with the obvious exception that a lambda doesn’t have a name.
In fact, many developers like to think of lambdas as “anonymous methods.”</p>
</div>
<p>As a result, this means that the single line of code:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">Runnable</code><code class="w"> </code><code class="n">r</code><code class="w">  </code><code class="o">=</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="s">"Hello"</code><code class="p">);</code><code class="w"/></pre>
<p>does not result in the execution of the <code>println()</code> but instead creates an object, which is assigned to a variable <code>r</code>, of type <code>Runnable</code>.
This object, <code>r</code>, will execute the <code>println()</code> statement, but only when <code>r.run()</code> is called, and not until then.<a data-startref="ix_ch04-asciidoc24" data-type="indexterm" id="idm45927738626544"/></p>
<section data-pdf-bookmark="Lambda Expression Conversion" data-type="sect2"><div class="sect2" id="javanut8-CHP-4-SECT-4.1">
<h2>Lambda Expression Conversion</h2>
<p><a data-primary="javac" data-secondary="lambda expression conversion" data-type="indexterm" id="idm45927738648048"/><a data-primary="lambda expressions" data-secondary="conversion" data-type="indexterm" id="idm45927738647104"/>When <code>javac</code> encounters a lambda expression, it interprets it as the
body of a method with a specific signature—but which method?</p>
<p>To resolve this question, <code>javac</code> looks at the surrounding code. To be
legal Java code, the lambda expression must satisfy the following properties:</p>
<ul>
<li>
<p>The lambda must appear where an instance of an interface type is
expected.</p>
</li>
<li>
<p>The expected interface type should have exactly one mandatory method.</p>
</li>
<li>
<p>The expected interface method should have a signature that exactly matches that of the lambda expression.</p>
</li>
</ul>
<p>If this is the case, then an instance is created of a type that implements the expected interface and uses the lambda body as the implementation for the mandatory method.</p>
<p>This slightly complex conversion approach comes from the desire to keep Java’s
type system as purely <em>nominative</em> (based on names). The lambda expression
is said to be <em>converted</em> to an instance of the correct interface type.</p>
<p>From this discussion, we can see that although Java 8 has added lambda
expressions, they have been specifically designed to fit into Java’s
existing type system—which has a very strong emphasis on nominal types (rather than the other possible sorts of types that exist in some other programming languages).</p>
<p>Let’s consider an example of lambda conversion—the <code>list()</code> method of the <code>java.io.File</code> class.
This method lists the files in a directory. Before it returns the list, though, it passes the name of each file to a <code>FilenameFilter</code> object that the programmer must supply.
This <code>FilenameFilter</code> object accepts or rejects each file and is a SAM type defined in the <code>java.io</code> package:</p>
<pre data-code-language="java" data-type="programlisting"><code class="nd">@FunctionalInterface</code><code class="w"/>
<code class="kd">public</code><code class="w"> </code><code class="kd">interface</code> <code class="nc">FilenameFilter</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kt">boolean</code><code class="w"> </code><code class="nf">accept</code><code class="p">(</code><code class="n">File</code><code class="w"> </code><code class="n">dir</code><code class="p">,</code><code class="w"> </code><code class="n">String</code><code class="w"> </code><code class="n">name</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p><a data-primary="@FunctionalInterface annotation" data-primary-sortas="FunctionalInterface annotation" data-type="indexterm" id="idm45927738595664"/>The type <code>FilenameFilter</code> carries the <code>@FunctionalInterface</code> to indicate that it is a suitable type to be used as the target type for a lambda.
However, this annotation is not required, and any type that meets the requirements (by being an interface and a SAM type) can be used as a target type.</p>
<p>This is because the JDK and the existing corpus of Java code already had a huge number of SAM types available before Java 8 was released.
To require potential target types to carry the annotation would have prevented lambdas from being retrofitted to existing code for no real benefit.</p>
<div data-type="tip"><h6>Tip</h6>
<p>In code that you write, you should always try to indicate when your types are usable as target types, which you can do by adding the <code>@FunctionalInterface</code> to them.
This aids readability and can help some automated tools as well.</p>
</div>
<p>Here’s how we can define a <code>FilenameFilter</code> class to list only those
files whose names end with <em>.java</em>, using a lambda:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">File</code><code class="w"> </code><code class="n">dir</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">File</code><code class="p">(</code><code class="s">"/src"</code><code class="p">);</code><code class="w">      </code><code class="c1">// The directory to list</code><code class="w"/>

<code class="n">String</code><code class="o">[]</code><code class="w"> </code><code class="n">filelist</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">dir</code><code class="p">.</code><code class="na">list</code><code class="p">((</code><code class="n">d</code><code class="p">,</code><code class="w"> </code><code class="n">fName</code><code class="p">)</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="n">fName</code><code class="p">.</code><code class="na">endsWith</code><code class="p">(</code><code class="s">".java"</code><code class="p">));</code><code class="w"/></pre>
<p>For each file in the list, the block of code in the lambda expression is
evaluated. If the method returns <code>true</code> (which happens if the filename
ends in <em>.java</em>), then the file is included in the output—which ends up
in the array <code>filelist</code>.</p>
<p>This pattern, where a block of code is used to test if an element of a
container matches a condition, and to return only the elements that pass
the condition, is called a <em>filter idiom</em>. It is one of the standard
techniques of functional programming, which we will discuss in more
depth presently.</p>
</div></section>
<section data-pdf-bookmark="Method References" data-type="sect2"><div class="sect2" id="javanut8-CHP-4-SECT-4.2">
<h2>Method References</h2>
<p>Recall that we can think of lambda expressions as objects representing methods that don’t have names.
Now, consider this lambda expression:</p>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// In real code this would probably be</code><code class="w"/>
<code class="c1">// shorter because of type inference</code><code class="w"/>
<code class="p">(</code><code class="n">MyObject</code><code class="w"> </code><code class="n">myObj</code><code class="p">)</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="n">myObj</code><code class="p">.</code><code class="na">toString</code><code class="p">()</code><code class="w"/></pre>
<p>This will be autoconverted to an implementation of a <code>@FunctionalInterface</code> type that has a single nondefault method that takes a single <code>MyObject</code> and returns a <code>String</code>—specifically, the string obtained by calling <code>toString()</code> on the instance of <code>MyObject</code>.
<a data-primary="Java 8" data-primary-sortas="Java 08" data-secondary="method references" data-type="indexterm" id="idm45927738444976"/><a data-primary="lambda expressions" data-secondary="method references and" data-type="indexterm" id="idm45927738443696"/><a data-primary="method references" data-secondary="lambda expressions and" data-type="indexterm" id="idm45927738442752"/>However, this seems like excessive boilerplate, and so Java 8 provides a syntax for making this easier to read and write:</p>
<pre data-code-language="java" data-type="programlisting"><code class="nl">MyObject</code><code class="p">::</code><code class="n">toString</code><code class="w"/></pre>
<p>This shorthand, known as a <em>method reference</em>, uses an existing method as a lambda expression. The method reference syntax is completely equivalent to the previous form expressed as a lambda. It can be thought of as using an existing method but ignoring the name of the method, so it can be used as a lambda and then autoconverted in the usual way. Java defines four types of method reference, which are equivalent to four slightly different lambda expression forms (see <a data-type="xref" href="#javanut8-CHP-4-TABLE-1">Table 4-1</a>).</p>
<table id="javanut8-CHP-4-TABLE-1">
<caption><span class="label">Table 4-1. </span>Method references</caption>
<thead>
<tr>
<th>Name</th>
<th>Method reference</th>
<th>Equivalent lambda</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Unbound</p></td>
<td><p><code>Trade::getPrice</code></p></td>
<td><p><code>trade -&gt; trade.getPrice()</code></p></td>
</tr>
<tr>
<td><p>Bound</p></td>
<td><p><code>System.out::println</code></p></td>
<td><p><code>s -&gt; System.out.println(s)</code></p></td>
</tr>
<tr>
<td><p>Static</p></td>
<td><p><code>System::getProperty</code></p></td>
<td><p><code>key -&gt; System.getProperty(key)</code></p></td>
</tr>
<tr>
<td><p>Constructor</p></td>
<td><p><code>Trade::new</code></p></td>
<td><p><code>price -&gt; new Trade(price)</code></p></td>
</tr>
</tbody>
</table>
<p><a data-primary="unbound method reference" data-type="indexterm" id="idm45927738380496"/>The form we originally introduced can be seen to be an <em>unbound method reference</em>.
When we use an unbound method reference, it is equivalent to a lambda that is expecting an instance of the type that contains the method reference—​in <a data-type="xref" href="#javanut8-CHP-4-TABLE-1">Table 4-1</a> that is a <code>Trade</code> object.</p>
<p>It is called an unbound method reference because the receiver object needs to be supplied (as the first argument to the lambda) when the method reference is used.
That is, we are going to call <code>getPrice()</code> on some <code>Trade</code> object, but the supplier of the method reference has not defined which one. That is left up to the user of the reference.</p>
<p><a data-primary="bound method reference" data-type="indexterm" id="idm45927738376496"/>By contrast, a <em>bound method reference</em> always includes the receiver as part of the instantiation of the method reference.
In <a data-type="xref" href="#javanut8-CHP-4-TABLE-1">Table 4-1</a>, the receiver is <code>System.out</code> so, when the reference is used, the <code>println()</code> method will always be called on 
<span class="keep-together"><code>System.out</code></span>, and all the parameters of the lambda will be used as method parameters to <code>println()</code>.</p>
<p>We will discuss use cases for method references versus lambda expressions in more detail in the next chapter.</p>
</div></section>
<section data-pdf-bookmark="Functional Programming" data-type="sect2"><div class="sect2" id="javanut8-CHP-4-SECT-4.3">
<h2>Functional Programming</h2>
<p><a data-primary="functional programming" data-secondary="lambda expressions and" data-type="indexterm" id="ix_ch04-asciidoc25"/><a data-primary="lambda expressions" data-secondary="functional programming and" data-type="indexterm" id="ix_ch04-asciidoc26"/><a data-primary="lambda expressions" data-secondary="lexical scoping and local variables" data-type="indexterm" id="ix_ch04-asciidoc27"/><a data-primary="local variables" data-secondary="lambda expressions and" data-type="indexterm" id="ix_ch04-asciidoc28"/>Java is fundamentally an object-oriented language. However, with the
arrival of lambda expressions, it becomes much easier to write code that
is closer to the functional approach.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>There’s no single definition of exactly what constitutes a <em>functional
language</em>—but there is at least consensus that it should at a minimum
contain the ability to represent a function as a value that can be put
into a variable.</p>
</div>
<p>Java has always (since version 1.1) been able to represent functions via
inner classes (see next section), but the syntax was complex and lacking in clarity.
Lambda expressions greatly simplify that syntax, and so it is only
natural that more developers will be seeking to use aspects of
functional programming in their Java code.</p>
<p>The first taste of functional programming that Java developers are
likely to encounter are three basic idioms that are remarkably useful:</p>
<dl>
<dt><code>map()</code></dt>
<dd>
<p><a data-primary="map()" data-type="indexterm" id="idm45927738361232"/>The map idiom is used with lists and list-like containers. The idea
is that a function is passed in that is applied to each element in the
collection, and a new collection is created that consists of the results
of applying the function to each element in turn. This means that a
map idiom converts a collection of one type to a collection of
potentially a different type.</p>
</dd>
<dt><code>filter()</code></dt>
<dd>
<p><a data-primary="filter()" data-type="indexterm" id="idm45927738359120"/>We have already met an example of the filter idiom, when we discussed
how to replace an anonymous implementation of <code>FilenameFilter</code> with a
lambda. The filter idiom is used for producing a new subset of a
collection, based on some selection criteria.
Note that in functional programming, it is normal to produce a new collection rather than modifying an existing one in place.</p>
</dd>
<dt><code>reduce()</code></dt>
<dd>
<p><a data-primary="reduce()" data-type="indexterm" id="idm45927738356464"/>The reduce idiom has several different guises. It is an aggregation
operation, which can be called <em>fold</em>, <em>accumulate</em>, or <em>aggregate</em>
as well as reduce. The basic idea is to take an initial value and an
aggregation (or reduction) function, and apply the reduction function
to each element in turn, building up a final result for the whole
collection by making a series of intermediate results—similar to a
“running total”—as the reduce operation traverses the collection.</p>
</dd>
</dl>
<p>Java has full support for these key functional idioms (and several
others). The implementation is explained in some depth in
<a data-type="xref" href="ch08.xhtml#javanut8-CHP-8">Chapter 8</a>, where we discuss Java’s data structures
and collections, and in particular the <em>stream</em> abstraction, which makes
all of this possible.</p>
<p>Let’s conclude this introduction with some words of caution. It’s worth
noting that Java is best regarded as having support for “slightly
functional programming.” It is not an especially functional language,
nor does it try to be. Some particular aspects of Java that militate
against any claims to being a functional language include:</p>
<ul>
<li>
<p>Java has no structural types, which means no “true” function types.
Every lambda is automatically converted to the appropriate target type.</p>
</li>
<li>
<p>Type erasure causes problems for functional programming—type safety
can be lost for higher-order functions.</p>
</li>
<li>
<p>Java is inherently mutable (as we’ll discuss in
<a data-type="xref" href="ch06.xhtml#javanut8-CHP-6">Chapter 6</a>)—mutability is often regarded as highly
undesirable for functional languages.</p>
</li>
<li>
<p>The Java collections are imperative, not functional. Collections must be converted to streams to use functional style.</p>
</li>
</ul>
<p>Despite this, easy access to the basics of functional programing—and
especially idioms such as map, filter, and reduce—is a huge step forward
for the Java community. These idioms are so useful that a large majority
of Java developers will never need or miss the more advanced
capabilities provided by languages with a more thoroughbred functional
pedigree.</p>
<p>In truth, many of these techniques were possible using nested
types (see next section for details), via patterns like callbacks and handlers, but the syntax was
always quite cumbersome, especially given that you had to explicitly define
a completely new type even when you needed to express only a single line of
code in the callback.<a data-startref="ix_ch04-asciidoc28" data-type="indexterm" id="idm45927738346016"/><a data-startref="ix_ch04-asciidoc27" data-type="indexterm" id="idm45927738345312"/><a data-startref="ix_ch04-asciidoc26" data-type="indexterm" id="idm45927738344640"/><a data-startref="ix_ch04-asciidoc25" data-type="indexterm" id="idm45927738343968"/></p>
</div></section>
<section data-pdf-bookmark="Lexical Scoping and Local Variables" data-type="sect2"><div class="sect2" id="javanut8-CHP-4-SECT-4.4">
<h2>Lexical Scoping and Local Variables</h2>
<p><a data-primary="lexical scoping" data-type="indexterm" id="ix_ch04-asciidoc29"/>A local variable is defined within a block of code that defines its <em>scope</em> and, outside of that scope, a local variable cannot be accessed and ceases to exist.
Only code within the curly braces that define the boundaries of a block can use local variables defined in that block.
This type of scoping is known as <em>lexical scoping</em>, and it just defines a section of source code within which a variable can be used.</p>
<p>It is common for programmers to think of such a scope as <em>temporal</em> instead—that is, to think of a local variable as existing from the time the JVM begins executing the block until the time control exits the block.
This is usually a reasonable way to think about local variables and their scope.
However, lambda expressions (and anonymous and local classes, which we will meet later) have the ability to bend or break this intuition.</p>
<p>This can cause effects that some developers initially find surprising.
Because lambdas can use local variables, they can contain copies of values from lexical scopes that no longer exist.
This can been seen in the following code:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="kd">interface</code> <code class="nc">IntHolder</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="nf">getValue</code><code class="p">();</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">public</code><code class="w"> </code><code class="kd">class</code> <code class="nc">Weird</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kd">static</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">main</code><code class="p">(</code><code class="n">String</code><code class="o">[]</code><code class="w"> </code><code class="n">args</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">IntHolder</code><code class="o">[]</code><code class="w"> </code><code class="n">holders</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">IntHolder</code><code class="o">[</code><code class="mi">10</code><code class="o">]</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="k">for</code><code class="w"> </code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="mi">10</code><code class="p">;</code><code class="w"> </code><code class="n">i</code><code class="o">++</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="kd">final</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">fi</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">i</code><code class="p">;</code><code class="w"/>

<code class="w">            </code><code class="n">holders</code><code class="o">[</code><code class="n">i</code><code class="o">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">                </code><code class="k">return</code><code class="w"> </code><code class="n">fi</code><code class="p">;</code><code class="w"/>
<code class="w">            </code><code class="p">};</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">  </code><code class="c1">// The lambda is now out of scope, but we have 10 valid instances</code><code class="w"/>
<code class="w">  </code><code class="c1">// of the class the lambda has been converted to in our array.</code><code class="w"/>
<code class="w">  </code><code class="c1">// The local variable fi is not in our scope here, but is still</code><code class="w"/>
<code class="w">  </code><code class="c1">// in scope for the getValue() method of each of those 10 objects.</code><code class="w"/>
<code class="w">  </code><code class="c1">// So call getValue() for each object and print it out.</code><code class="w"/>
<code class="w">  </code><code class="c1">// This prints the digits 0 to 9.</code><code class="w"/>
<code class="w">        </code><code class="k">for</code><code class="w"> </code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="mi">10</code><code class="p">;</code><code class="w"> </code><code class="n">i</code><code class="o">++</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">holders</code><code class="o">[</code><code class="n">i</code><code class="o">]</code><code class="p">.</code><code class="na">getValue</code><code class="p">());</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Each instance of a lambda has an automatically created private copy of each of the final local variables it uses, so, in effect, it has its own private copy of the scope that existed when it was created.
This is sometimes referred to as a <em>captured</em> variable.</p>
<p><a data-primary="closures" data-type="indexterm" id="idm45927738334336"/>Lambdas that capture variables like this are referred to as <em>closures</em>, and the variables are said to have been <em>closed over</em>.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Other programming languages may have a slightly different definition of a closure.
In fact, some theorists would dispute that Java’s mechanism counts as a closure because, technically, it is the contents of the variable (a value) and not the variable itself that is captured.</p>
</div>
<p>In practice, the preceding closure example is more verbose than it needs to be in two separate ways:</p>
<ul>
<li>
<p>The lambda has an explicit scope <code>{}</code> and <code>return</code> statement.</p>
</li>
<li>
<p>The variable <code>fi</code> is explicitly declared <code>final</code>.</p>
</li>
</ul>
<p><a data-primary="javac" data-secondary="lambda expression conversion" data-type="indexterm" id="idm45927738139344"/>The compiler <code>javac</code> helps with both of these.</p>
<p>Lambdas that return the value of only a single expression need not include a scope or <code>return</code>; instead, the body of the lambda is just the expression without the need for curly braces.
In our example, we have explicitly included the braces and <code>return</code> statement to spell out that the lambda is defining its own scope.</p>
<p>In early versions of Java, there were two hard requirements when closing over a <span class="keep-together">variable</span>:</p>
<ul>
<li>
<p>The captures must not be modified after they have been captured (e.g., after the lambda)</p>
</li>
<li>
<p><a data-primary="captured variable" data-type="indexterm" id="idm45927738133408"/>The captured variables must be declared <code>final</code></p>
</li>
</ul>
<p>However, in recent Java versions, <code>javac</code> can analyze the code and detect whether the programmer attempts to modify the captured variable after the scope of the lambda.
<a data-primary="effectively final variable" data-type="indexterm" id="idm45927738131008"/>If not, then the <code>final</code> qualifier on the captured variable can be omitted (such a variable is said to be <em>effectively final</em>).
If the <code>final</code> qualifier is omitted, then it is a compile-time error to attempt to modify a captured variable after the lambda’s scope.</p>
<p>The reason for this is that Java implements closures by copying the bit pattern of the contents of the variable into the scope created by the closure.
Further changes to the contents of the closed-over variable would not be reflected in the copy contained in closure scope, so the design decision was made to make such changes illegal and a compile-time error.</p>
<p>These assists from <code>javac</code> mean that we can rewrite the inner loop of the preceding example to the very compact form:</p>
<pre data-code-language="java" data-type="programlisting"><code class="k">for</code><code class="w"> </code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="mi">10</code><code class="p">;</code><code class="w"> </code><code class="n">i</code><code class="o">++</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kt">int</code><code class="w"> </code><code class="n">fi</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">i</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="n">holders</code><code class="o">[</code><code class="n">i</code><code class="o">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="n">fi</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Closures are very useful in some styles of programming, and different programming languages define and implement closures in different ways.
Java implements closures as lambda expressions, but local classes and anonymous classes can also capture state—and in fact this is how Java implemented closures before lambdas were available<a data-startref="ix_ch04-asciidoc29" data-type="indexterm" id="idm45927738020320"/>.<a data-startref="ix_ch04-asciidoc23" data-type="indexterm" id="idm45927738036096"/><a data-startref="ix_ch04-asciidoc22" data-type="indexterm" id="idm45927738035488"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Nested Types" data-type="sect1"><div class="sect1" id="javanut8-CHP-4-SECT-5">
<h1>Nested Types</h1>
<p><a data-primary="nested types" data-type="indexterm" id="ix_ch04-asciidoc30"/><a data-primary="type system" data-secondary="nested types" data-type="indexterm" id="ix_ch04-asciidoc31"/>The <a data-primary="top-level types" data-type="indexterm" id="idm45927738031584"/>classes, interfaces, and enum types we have seen so far in this book have all been defined as <em>top-level types</em>.
This means that they are direct members of packages, defined independently of other types.
However, type definitions can also be nested within other type definitions. These <em>nested types</em>, commonly known as “inner classes,” are a powerful feature of the Java language.</p>
<p>In general, nested types are used for two separate purposes, both related to encapsulation.
First, a type may be nested because it needs especially intimate access to the internals of another type.
By being a nested type, it has access in the same way that member variables and methods do.
This means that nested types have privileged access and can be thought of as “slightly bending the rules of encapsulation.”</p>
<p>Another way of thinking about this use case of nested types is that they are types that are somehow tied together with another type.
This means that they don’t really have a completely independent existence as an entity and only coexist.</p>
<p>Alternatively, a type may be only required for a very specific reason and in a very small section of code.
This means that it should be tightly localized, as it is really part of the implementation detail.</p>
<p>In older versions of Java, the only way to do this was with a nested type, such as an anonymous implementation of an interface.
In practice, with the advent of Java 8, this use case has substantially been taken over by lambda expressions. The use of anonymous types as closely localized types has dramatically declined as a result, although it still persists for some cases.</p>
<p>Types can be nested within another type in four different ways:</p>
<dl>
<dt>Static member types</dt>
<dd>
<p>A static member type is any type defined as a <code>static</code> member of
another type. Nested interfaces, enums, and annotations are always
static (even if you don’t use the keyword).</p>
</dd>
<dt>Nonstatic member classes</dt>
<dd>
<p>A “nonstatic member type” is simply a member type that is not declared
<code>static</code>. Only classes can be nonstatic member types.</p>
</dd>
<dt>Local classes</dt>
<dd>
<p>A local class is a class that is defined and only visible within a
block of Java code. Interfaces, enums, and annotations may not be
defined locally.</p>
</dd>
<dt>Anonymous classes</dt>
<dd>
<p>An anonymous class is a kind of local class that has no meaningful name that is useful to humans; it is merely an arbitrary name assigned by the compiler, which programmers should not use directly. Interfaces, enums, and annotations cannot be defined <span class="keep-together">anonymously</span>.</p>
</dd>
</dl>
<p>The term “nested types,” while correct and precise, is not widely used by developers. Instead, most Java programmers use the much vaguer term “inner class.” Depending on the situation, this can refer to a nonstatic member class, local class, or anonymous class, but not a static member type, with no real way to distinguish between them.</p>
<p>Fortunately, although the terminology for describing nested types is not always clear, the syntax for working with them is, and it is usually apparent from context which kind of nested type is being discussed.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a data-primary="Java 11" data-secondary="nested types" data-type="indexterm" id="idm45927737975072"/>Until Java 11, nested types were implemented using a compiler trick and were mostly syntactic sugar. Experienced Java programmers should note that this detail changed in Java 11, and it is no longer done in quite the same way as it used to be.</p>
</div>
<p>Let’s move on to describe each of the four kinds of nested types in greater detail.
Each section describes the features of the nested type, the restrictions on its use, and any special Java syntax used with the type.</p>
<section data-pdf-bookmark="Static Member Types" data-type="sect2"><div class="sect2" id="javanut8-CHP-4-SECT-5.1">
<h2>Static Member Types</h2>
<p><a data-primary="member classes" data-secondary="static" data-type="indexterm" id="ix_ch04-asciidoc32"/><a data-primary="nested types" data-secondary="static member types" data-type="indexterm" id="ix_ch04-asciidoc33"/><a data-primary="static member types" data-type="indexterm" id="ix_ch04-asciidoc34"/>A <em>static member type</em> is much like a regular top-level type. For
convenience, however, it is nested within the namespace of another
type. Static member types have the following basic properties:</p>
<ul>
<li>
<p>A static member type is like the other static members of a class:
static fields and static methods.</p>
</li>
<li>
<p>A static member type is not associated with any instance of the
containing class (i.e., there is no <code>this</code> object).</p>
</li>
<li>
<p>A static member type can access (only) the <code>static</code> members of the
class that contains it.</p>
</li>
<li>
<p>A static member type has access to all the <code>static</code> members (including
any other static member types) of its containing type.</p>
</li>
<li>
<p>Nested interfaces, enums, and annotations are implicitly static,
whether or not the <code>static</code> keyword appears.</p>
</li>
<li>
<p>Any type nested within an interface or annotation is also implicitly
<code>static</code>.</p>
</li>
<li>
<p>Static member types may be defined within top-level types or nested to
any depth within other static member types.</p>
</li>
<li>
<p>A static member type may not be defined within any other kind of
nested type.</p>
</li>
</ul>
<p>Let’s look at a quick example of the syntax for static member types.
<a data-type="xref" href="#javanut8-CHP-4-EX-1">Example 4-1</a> shows a helper interface defined
as a static member of a containing interface, in this case Java’s <code>Map</code>.</p>
<div data-type="example" id="javanut8-CHP-4-EX-1">
<h5><span class="label">Example 4-1. </span>Defining and using a static member interface</h5>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="kd">interface</code> <code class="nc">Map</code><code class="o">&lt;</code><code class="n">K</code><code class="p">,</code><code class="w"> </code><code class="n">V</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="c1">// ...</code><code class="w"/>

<code class="w">    </code><code class="n">Set</code><code class="o">&lt;</code><code class="n">Map</code><code class="p">.</code><code class="na">Entry</code><code class="o">&lt;</code><code class="n">K</code><code class="p">,</code><code class="w"> </code><code class="n">V</code><code class="o">&gt;&gt;</code><code class="w"> </code><code class="nf">entrySet</code><code class="p">();</code><code class="w"/>

<code class="w">    </code><code class="c1">// All nested interfaces are automatically static</code><code class="w"/>
<code class="w">    </code><code class="kd">interface</code> <code class="nc">Entry</code><code class="o">&lt;</code><code class="n">K</code><code class="p">,</code><code class="w"> </code><code class="n">V</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">K</code><code class="w"> </code><code class="nf">getKey</code><code class="p">();</code><code class="w"/>
<code class="w">        </code><code class="n">V</code><code class="w"> </code><code class="nf">getValue</code><code class="p">();</code><code class="w"/>
<code class="w">        </code><code class="n">V</code><code class="w"> </code><code class="nf">setValue</code><code class="p">(</code><code class="n">V</code><code class="w"> </code><code class="n">value</code><code class="p">);</code><code class="w"/>

<code class="w">        </code><code class="c1">// other members elided</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="c1">// other members elided</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre></div>
<p>When used by an external class, <code>Entry</code> will be referred to by its hierarchical name <code>Map.Entry</code>.</p>
<section data-pdf-bookmark="Features of static member types" data-type="sect3"><div class="sect3" id="javanut8-CHP-4-SECT-5.1.1">
<h3>Features of static member types</h3>
<p>A static member type has access to all static members of its containing
type, including <code>private</code> members. The reverse is true as well: the
methods of the containing type have access to all members of a static
member type, including the <code>private</code> members. A static member type even
has access to all the members of any other static member types,
including the <code>private</code> members of those types. A static member type can
use any other static member without qualifying its name with the name of
the containing type.</p>
<p>Top-level types can be declared as either <code>public</code> or package-private
(if they’re declared without the <code>public</code> keyword). But declaring
top-level types as <code>private</code> and <code>protected</code> wouldn’t make a great deal
of sense—<code>protected</code> would just mean the same as package-private, and a
<code>private</code> top-level class would be unable to be accessed by any other
type.</p>
<p>Static member types, on the other hand, are members and so can use any
access control modifiers that other members of the containing type can.
These modifiers have the same meanings for static member types as they
do for other members of a type.</p>
<p>Under most circumstances, the <code>Outer.Inner</code> syntax for class names provides a helpful reminder that the inner class is interconnected with its containing type.
However, the Java language does permit you to use the <code>import</code> directive to directly import a static member type:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kn">import</code><code class="w"> </code><code class="nn">java.util.Map.Entry</code><code class="p">;</code><code class="w"/></pre>
<p>You can then reference the nested type without including the name of its
enclosing type (e.g., just as <code>Entry</code>).</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>You can also use the <code>import static</code> directive to import a static member type.
See <a data-type="xref" href="ch02.xhtml#javanut8-CHP-2-SECT-10">“Packages and the Java Namespace”</a> in <a data-type="xref" href="ch02.xhtml#javanut8-CHP-2">Chapter 2</a> for details on <code>import</code> and <code>import static</code>.</p>
</div>
<p>However, importing a nested type obscures the fact that that type is
closely associated with its containing type—which is usually important
information—and as a result it is not commonly done.<a data-startref="ix_ch04-asciidoc34" data-type="indexterm" id="idm45927737814688"/><a data-startref="ix_ch04-asciidoc33" data-type="indexterm" id="idm45927737813984"/><a data-startref="ix_ch04-asciidoc32" data-type="indexterm" id="idm45927737813312"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Nonstatic Member Classes" data-type="sect2"><div class="sect2" id="javanut8-CHP-4-SECT-5.2">
<h2>Nonstatic Member Classes</h2>
<p><a data-primary="member classes" data-secondary="nonstatic" data-type="indexterm" id="ix_ch04-asciidoc35"/><a data-primary="nested types" data-secondary="nonstatic member class" data-type="indexterm" id="ix_ch04-asciidoc36"/><a data-primary="nonstatic members" data-type="indexterm" id="ix_ch04-asciidoc37"/>A <em>nonstatic member class</em> is a class that is declared as a member
of a containing class or enumerated type without the <code>static</code> keyword:</p>
<ul>
<li>
<p>If a static member type is analogous to a class field or class method,
a nonstatic member class is analogous to an instance field or instance method.</p>
</li>
<li>
<p>Only classes can be nonstatic member types.</p>
</li>
<li>
<p>An instance of a nonstatic member class is always associated with an instance of the enclosing type.</p>
</li>
<li>
<p>The code of a nonstatic member class has access to all the fields and methods (both <code>static</code> and non-<code>static</code>) of its enclosing type.</p>
</li>
<li>
<p>Several Java syntax features exist specifically to work with the enclosing instance of a nonstatic member class.</p>
</li>
</ul>
<p><a data-type="xref" href="#javanut8-CHP-4-EX-2">Example 4-2</a> shows how a member class can be defined and used.
This example shows a <code>LinkedStack</code> example: it defines a nested interface that describes the nodes of the linked list underlying the stack and a nested class to allow enumeration of the elements on the stack.
<a data-primary="java.util.Iterator" data-type="indexterm" id="idm45927737780992"/>The member class defines an implementation of the <code>java.util.Iterator</code> interface.</p>
<div data-type="example" id="javanut8-CHP-4-EX-2">
<h5><span class="label">Example 4-2. </span>An iterator implemented as a member class</h5>
<pre data-code-language="java" data-type="programlisting"><code class="kn">import</code><code class="w"> </code><code class="nn">java.util.Iterator</code><code class="p">;</code><code class="w"/>

<code class="kd">public</code><code class="w"> </code><code class="kd">class</code> <code class="nc">LinkedStack</code><code class="w"> </code><code class="p">{</code><code class="w"/>

<code class="w">    </code><code class="c1">// Our static member interface</code><code class="w"/>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kd">interface</code> <code class="nc">Linkable</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="kd">public</code><code class="w"> </code><code class="n">Linkable</code><code class="w"> </code><code class="nf">getNext</code><code class="p">();</code><code class="w"/>
<code class="w">        </code><code class="kd">public</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">setNext</code><code class="p">(</code><code class="n">Linkable</code><code class="w"> </code><code class="n">node</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="c1">// The head of the list</code><code class="w"/>
<code class="w">    </code><code class="kd">private</code><code class="w"> </code><code class="n">Linkable</code><code class="w"> </code><code class="n">head</code><code class="p">;</code><code class="w"/>

<code class="w">    </code><code class="c1">// Method bodies omitted here</code><code class="w"/>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">push</code><code class="p">(</code><code class="n">Linkable</code><code class="w"> </code><code class="n">node</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="p">...</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="n">Linkable</code><code class="w"> </code><code class="nf">pop</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="p">...</code><code class="w"> </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="c1">// This method returns an Iterator object for this LinkedStack</code><code class="w"/>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="n">Iterator</code><code class="o">&lt;</code><code class="n">Linkable</code><code class="o">&gt;</code><code class="w"> </code><code class="nf">iterator</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">LinkedIterator</code><code class="p">();</code><code class="w"> </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="c1">// Here is the implementation of the Iterator interface,</code><code class="w"/>
<code class="w">    </code><code class="c1">// defined as a nonstatic member class.</code><code class="w"/>
<code class="w">    </code><code class="kd">protected</code><code class="w"> </code><code class="kd">class</code> <code class="nc">LinkedIterator</code><code class="w"> </code><code class="kd">implements</code><code class="w"> </code><code class="n">Iterator</code><code class="o">&lt;</code><code class="n">Linkable</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">Linkable</code><code class="w"> </code><code class="n">current</code><code class="p">;</code><code class="w"/>

<code class="w">        </code><code class="c1">// The constructor uses a private field of the containing class</code><code class="w"/>
<code class="w">        </code><code class="kd">public</code><code class="w"> </code><code class="nf">LinkedIterator</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">current</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">head</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w"/>

<code class="w">        </code><code class="c1">// The following three methods are defined</code><code class="w"/>
<code class="w">        </code><code class="c1">// by the Iterator interface</code><code class="w"/>
<code class="w">        </code><code class="kd">public</code><code class="w"> </code><code class="kt">boolean</code><code class="w"> </code><code class="nf">hasNext</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="n">current</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">null</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w"/>

<code class="w">        </code><code class="kd">public</code><code class="w"> </code><code class="n">Linkable</code><code class="w"> </code><code class="nf">next</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">current</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="kc">null</code><code class="p">)</code><code class="w"/>
<code class="w">              </code><code class="k">throw</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">java</code><code class="p">.</code><code class="na">util</code><code class="p">.</code><code class="na">NoSuchElementException</code><code class="p">();</code><code class="w"/>
<code class="w">            </code><code class="n">Linkable</code><code class="w"> </code><code class="n">value</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">current</code><code class="p">;</code><code class="w"/>
<code class="w">            </code><code class="n">current</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">current</code><code class="p">.</code><code class="na">getNext</code><code class="p">();</code><code class="w"/>
<code class="w">            </code><code class="k">return</code><code class="w"> </code><code class="n">value</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>

<code class="w">        </code><code class="kd">public</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">remove</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">throw</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">UnsupportedOperationException</code><code class="p">();</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre></div>
<p>Notice how the <code>LinkedIterator</code> class is nested within the <code>LinkedStack</code> class. <code><span class="keep-together">Linked</span>Iterator</code> is a helper class used only within <code>LinkedStack</code>, so having it defined close to where it is used by the
containing class makes for a clean design.</p>
<section data-pdf-bookmark="Features of member classes" data-type="sect3"><div class="sect3" id="javanut8-CHP-4-SECT-5.2.1">
<h3>Features of member classes</h3>
<p><a data-primary="member classes" data-secondary="features" data-type="indexterm" id="idm45927737554896"/>Like instance fields and instance methods, every instance of a
nonstatic member class is associated with an instance of the class in
which it is defined. This means that the code of a member class has
access to all the instance fields and instance methods (as well as the
<code>static</code> members) of the containing instance, including any that are
declared <code>private</code>.</p>
<p>This crucial feature was already illustrated in <a data-type="xref" href="#javanut8-CHP-4-EX-2">Example 4-2</a>.
Here is the <code>LinkedStack.LinkedIterator()</code> constructor again:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="nf">LinkedIterator</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">current</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">head</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w"/></pre>
<p>This single line of code sets the <code>current</code> field of the inner class to
the value of the <code>head</code> field of the containing class. The code works as
shown, even though <code>head</code> is declared as a <code>private</code> field in the
containing class.</p>
<p>A nonstatic member class, like any member of a class, can be assigned
one of the standard access control modifiers. In
<a data-type="xref" href="#javanut8-CHP-4-EX-2">Example 4-2</a>, the <code>LinkedIterator</code> class is
declared <code>protected</code>, so it is inaccessible to code (in a different
package) that uses the <code>LinkedStack</code> class but is accessible to any
class that subclasses <code>LinkedStack</code>.</p>
<p class="pagebreak-before">Member classes have two important restrictions:</p>
<ul>
<li>
<p>A nonstatic member class cannot have the same name as any containing
class or package. This is an important rule, one that is <em>not</em> shared by
fields and <span class="keep-together">methods</span>.</p>
</li>
<li>
<p>Nonstatic member classes cannot contain any <code>static</code> fields, methods,
or types, except for constant fields declared both <code>static</code> and <code>final</code>.</p>
</li>
</ul>
</div></section>
<section data-pdf-bookmark="Syntax for member classes" data-type="sect3"><div class="sect3" id="javanut8-CHP-4-SECT-5.2.2">
<h3>Syntax for member classes</h3>
<p><a data-primary="member classes" data-secondary="syntax for" data-type="indexterm" id="idm45927737376832"/>The most important feature of a member class is that it can access the
instance fields and methods in its containing object.</p>
<p>If we want to use explicit references, and make use of <code>this</code>, then we
have to use a special syntax for explicitly referring to the containing
instance of the <code>this</code> object. For example, if we want to be explicit in
our constructor, we can use the following syntax:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="nf">LinkedIterator</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">this</code><code class="p">.</code><code class="na">current</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">LinkedStack</code><code class="p">.</code><code class="na">this</code><code class="p">.</code><code class="na">head</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w"/></pre>
<p>The general syntax is <em><code>classname.this</code></em>, where <em><code>classname</code></em> is the
name of a containing class. Note that member classes can themselves
contain member classes, nested to any depth.</p>
<p>However, no member class can have the same name as any containing class, so the use of the enclosing class name prepended to <code>this</code> is a perfectly general way to
refer to any containing instance.
Another way of saying this is that the syntax construction <code>EnclosingClass.this</code> is an unambiguous way of referring to the containing instance as an <em>uplevel reference</em>. <a data-startref="ix_ch04-asciidoc37" data-type="indexterm" id="idm45927737324128"/><a data-startref="ix_ch04-asciidoc36" data-type="indexterm" id="idm45927737323392"/><a data-startref="ix_ch04-asciidoc35" data-type="indexterm" id="idm45927737349232"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Local Classes" data-type="sect2"><div class="sect2" id="javanut8-CHP-4-SECT-5.3">
<h2>Local Classes</h2>
<p><a data-primary="local classes" data-type="indexterm" id="ix_ch04-asciidoc38"/><a data-primary="nested types" data-secondary="local classes" data-type="indexterm" id="ix_ch04-asciidoc39"/>A <em>local class</em> is declared locally within a block of Java code
rather than as a member of a class. Only classes may be defined locally:
interfaces, enumerated types, and annotation types must be top-level or
static member types. Typically, a local class is defined within a
method, but it can also be defined within a static initializer or
instance initializer of a class.</p>
<p>Just as all blocks of Java code appear within class definitions, all local classes are nested within containing blocks.
For this reason, although local classes share many of the features of member classes, it is usually more appropriate to think of them as an entirely separate kind of nested type.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>See <a data-type="xref" href="ch05.xhtml#javanut8-CHP-5">Chapter 5</a> for details as to when it’s appropriate to choose a local class versus a lambda expression.</p>
</div>
<p>The defining characteristic of a local class is that it is local to a
block of code. Like a local variable, a local class is valid only within
the scope defined by its enclosing block.
<a data-type="xref" href="#javanut8-CHP-4-EX-3">Example 4-3</a> illustrates how we can modify the
<code>iterator()</code> method of the <span class="keep-togther"><code>LinkedStack</code></span> class so it defines
<code>LinkedIterator</code> as a local class instead of a member class.</p>
<p>By doing this, we move the definition of the class even closer to where
it is used and hopefully improve the clarity of the code even further.
For brevity, <a data-type="xref" href="#javanut8-CHP-4-EX-3">Example 4-3</a> shows only the
<code>iterator()</code> method, not the entire <code>LinkedStack</code> class that contains
it.</p>
<div data-type="example" id="javanut8-CHP-4-EX-3">
<h5><span class="label">Example 4-3. </span>Defining and using a local class</h5>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// This method returns an Iterator object for this LinkedStack</code><code class="w"/>
<code class="kd">public</code><code class="w"> </code><code class="n">Iterator</code><code class="o">&lt;</code><code class="n">Linkable</code><code class="o">&gt;</code><code class="w"> </code><code class="nf">iterator</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="c1">// Here's the definition of LinkedIterator as a local class</code><code class="w"/>
<code class="w">    </code><code class="kd">class</code> <code class="nc">LinkedIterator</code><code class="w"> </code><code class="kd">implements</code><code class="w"> </code><code class="n">Iterator</code><code class="o">&lt;</code><code class="n">Linkable</code><code class="o">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">Linkable</code><code class="w"> </code><code class="n">current</code><code class="p">;</code><code class="w"/>

<code class="w">        </code><code class="c1">// The constructor uses a private field of the containing class</code><code class="w"/>
<code class="w">        </code><code class="kd">public</code><code class="w"> </code><code class="nf">LinkedIterator</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">current</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">head</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w"/>

<code class="w">        </code><code class="c1">// The following three methods are defined</code><code class="w"/>
<code class="w">        </code><code class="c1">// by the Iterator interface</code><code class="w"/>
<code class="w">        </code><code class="kd">public</code><code class="w"> </code><code class="kt">boolean</code><code class="w"> </code><code class="nf">hasNext</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="n">current</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">null</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w"/>

<code class="w">        </code><code class="kd">public</code><code class="w"> </code><code class="n">Linkable</code><code class="w"> </code><code class="nf">next</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">current</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="kc">null</code><code class="p">)</code><code class="w"/>
<code class="w">              </code><code class="k">throw</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">java</code><code class="p">.</code><code class="na">util</code><code class="p">.</code><code class="na">NoSuchElementException</code><code class="p">();</code><code class="w"/>
<code class="w">            </code><code class="n">Linkable</code><code class="w"> </code><code class="n">value</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">current</code><code class="p">;</code><code class="w"/>
<code class="w">            </code><code class="n">current</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">current</code><code class="p">.</code><code class="na">getNext</code><code class="p">();</code><code class="w"/>
<code class="w">            </code><code class="k">return</code><code class="w"> </code><code class="n">value</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>

<code class="w">        </code><code class="kd">public</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">remove</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">throw</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">UnsupportedOperationException</code><code class="p">();</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="c1">// Create and return an instance of the class we just defined</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">LinkedIterator</code><code class="p">();</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre></div>
<section data-pdf-bookmark="Features of local classes" data-type="sect3"><div class="sect3" id="javanut8-CHP-4-SECT-5.3.1">
<h3>Features of local classes</h3>
<p><a data-primary="local classes" data-secondary="features of" data-type="indexterm" id="idm45927737155040"/>Local classes have the following interesting features:</p>
<ul>
<li>
<p>Like member classes, local classes are associated with a containing
instance and can access any members, including <code>private</code> members, of the
containing class.</p>
</li>
<li>
<p>In addition to accessing fields defined by the containing class, local
classes can access any local variables, method parameters, or exception
parameters that are in the scope of the local method definition and are
declared <code>final</code>.</p>
</li>
</ul>
<p>Local classes are subject to the following restrictions:</p>
<ul>
<li>
<p>The name of a local class is defined only within the block that
defines it; it can never be used outside that block. (Note, however,
that instances of a local class created within the scope of the class
can continue to exist outside of that scope. This situation is described
in more detail later in this section.)</p>
</li>
<li>
<p>Local classes cannot be declared <code>public</code>, <code>protected</code>, <code>private</code>, or
<code>static</code>.</p>
</li>
<li>
<p>Like member classes, and for the same reasons, local classes cannot
contain <code>static</code> fields, methods, or classes. The only exception is for
constants that are declared both <code>static</code> and <code>final</code>.</p>
</li>
<li>
<p>Interfaces, enumerated types, and annotation types cannot be defined
locally.</p>
</li>
<li>
<p>A local class, like a member class, cannot have the same name as any
of its enclosing classes.</p>
</li>
<li>
<p>As noted earlier, a local class can close over the local variables, method parameters, and even exception parameters that are in its scope but only if those variables or parameters are effectively <code>final</code>.</p>
</li>
</ul>
</div></section>
<section data-pdf-bookmark="Scope of a local class" data-type="sect3"><div class="sect3" id="javanut8-CHP-4-SECT-5.3.2">
<h3>Scope of a local class</h3>
<p><a data-primary="local classes" data-secondary="scope of" data-type="indexterm" id="idm45927737091024"/>In discussing nonstatic member classes, we saw that a member class can access any members inherited from superclasses and any members defined by their containing classes.</p>
<p>The same is true for local classes, but local classes can also behave like lambdas and access effectively <code>final</code> local variables and parameters.
<a data-type="xref" href="#javanut8-CHP-4-EX-4">Example 4-4</a> illustrates the different kinds of fields and variables that may be accessible to a local class (or a lambda, for that matter).</p>
<div data-type="example" id="javanut8-CHP-4-EX-4">
<h5><span class="label">Example 4-4. </span>Fields and variables available to a local class</h5>
<pre data-code-language="java" data-type="programlisting"><code class="kd">class</code> <code class="nc">A</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="kd">protected</code><code class="w"> </code><code class="kt">char</code><code class="w"> </code><code class="n">a</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="sc">'a'</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="kd">class</code> <code class="nc">B</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="kd">protected</code><code class="w"> </code><code class="kt">char</code><code class="w"> </code><code class="n">b</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="sc">'b'</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w"/>

<code class="kd">public</code><code class="w"> </code><code class="kd">class</code> <code class="nc">C</code><code class="w"> </code><code class="kd">extends</code><code class="w"> </code><code class="n">A</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="kd">private</code><code class="w"> </code><code class="kt">char</code><code class="w"> </code><code class="n">c</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="sc">'c'</code><code class="p">;</code><code class="w">         </code><code class="c1">// Private fields visible to local class</code><code class="w"/>
<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="kd">static</code><code class="w"> </code><code class="kt">char</code><code class="w"> </code><code class="n">d</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="sc">'d'</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">createLocalObject</code><code class="p">(</code><code class="kd">final</code><code class="w"> </code><code class="kt">char</code><code class="w"> </code><code class="n">e</code><code class="p">)</code><code class="w"/>
<code class="w">  </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">final</code><code class="w"> </code><code class="kt">char</code><code class="w"> </code><code class="n">f</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="sc">'f'</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="kt">int</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w">                  </code><code class="c1">// i not final; not usable by local class</code><code class="w"/>
<code class="w">    </code><code class="kd">class</code> <code class="nc">Local</code><code class="w"> </code><code class="kd">extends</code><code class="w"> </code><code class="n">B</code><code class="w"/>
<code class="w">    </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="kt">char</code><code class="w"> </code><code class="n">g</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="sc">'g'</code><code class="p">;</code><code class="w"/>
<code class="w">      </code><code class="kd">public</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">printVars</code><code class="p">()</code><code class="w"/>
<code class="w">      </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="c1">// All of these fields and variables are accessible to this class</code><code class="w"/>
<code class="w">        </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">g</code><code class="p">);</code><code class="w">  </code><code class="c1">// (this.g) g is a field of this class</code><code class="w"/>
<code class="w">        </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">f</code><code class="p">);</code><code class="w">  </code><code class="c1">// f is a final local variable</code><code class="w"/>
<code class="w">        </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">e</code><code class="p">);</code><code class="w">  </code><code class="c1">// e is a final local parameter</code><code class="w"/>
<code class="w">        </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">d</code><code class="p">);</code><code class="w">  </code><code class="c1">// (C.this.d) d field of containing class</code><code class="w"/>
<code class="w">        </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">c</code><code class="p">);</code><code class="w">  </code><code class="c1">// (C.this.c) c field of containing class</code><code class="w"/>
<code class="w">        </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">b</code><code class="p">);</code><code class="w">  </code><code class="c1">// b is inherited by this class</code><code class="w"/>
<code class="w">        </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">a</code><code class="p">);</code><code class="w">  </code><code class="c1">// a is inherited by the containing class</code><code class="w"/>
<code class="w">      </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="n">Local</code><code class="w"> </code><code class="n">l</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">Local</code><code class="p">();</code><code class="w">      </code><code class="c1">// Create an instance of the local class</code><code class="w"/>
<code class="w">    </code><code class="n">l</code><code class="p">.</code><code class="na">printVars</code><code class="p">();</code><code class="w">              </code><code class="c1">// and call its printVars() method.</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre></div>
<p>Local classes have quite a complex scoping structure, therefore. To see why, notice that instances of a local class can have a lifetime that extends past the time that the JVM exits the block where the local class is defined.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>In other words, if you create an instance of a local class, that
instance does not automatically go away when the JVM finishes executing
the block that defines the class. So, even though the definition of the
class was local, instances of that class can escape the place
they were defined.</p>
</div>
<p>Local classes, therefore, behave like lambdas in many regards, although the use case of local classes is more general than that of lambdas.
However, in practice, the extra generality is rarely required, and lambdas are preferred wherever possible.<a data-startref="ix_ch04-asciidoc39" data-type="indexterm" id="idm45927737051648"/><a data-startref="ix_ch04-asciidoc38" data-type="indexterm" id="idm45927737050976"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Anonymous Classes" data-type="sect2"><div class="sect2" id="javanut8-CHP-4-SECT-5.4">
<h2>Anonymous Classes</h2>
<p><a data-primary="anonymous classes" data-type="indexterm" id="ix_ch04-asciidoc40"/><a data-primary="nested types" data-secondary="anonymous classes" data-type="indexterm" id="ix_ch04-asciidoc41"/>An <em>anonymous class</em> is a local class without a name. It is defined and instantiated in a single expression using the <code>new</code> operator.
While a local class definition is a statement in a block of Java code, an anonymous class definition is an expression, which means that it can be included as part of a larger expression, such as a method call.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a data-primary="lambda expressions" data-secondary="anonymous classes and" data-type="indexterm" id="idm45927736850384"/>For the sake of completeness, we cover anonymous classes here, but for most use cases, lambda expressions (see <a data-type="xref" href="#javanut8-CHP-4-SECT-4">“Lambda Expressions”</a>) have replaced anonymous classes.</p>
</div>
<p>Consider <a data-type="xref" href="#javanut8-CHP-4-EX-5">Example 4-5</a>, which shows the <code>LinkedIterator</code> class implemented as an anonymous class within the
<code>iterator()</code> method of the <span class="keep-together"><code>LinkedStack</code></span> class.
Compare it with <a data-type="xref" href="#javanut8-CHP-4-EX-4">Example 4-4</a>, which shows the same class implemented as a local class.</p>
<div data-type="example" id="javanut8-CHP-4-EX-5">
<h5><span class="label">Example 4-5. </span>An enumeration implemented with an anonymous class</h5>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="n">Iterator</code><code class="o">&lt;</code><code class="n">Linkable</code><code class="o">&gt;</code><code class="w"> </code><code class="nf">iterator</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="c1">// The anonymous class is defined as part of the return statement</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">Iterator</code><code class="o">&lt;</code><code class="n">Linkable</code><code class="o">&gt;</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">Linkable</code><code class="w"> </code><code class="n">current</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="c1">// Replace constructor with an instance initializer</code><code class="w"/>
<code class="w">        </code><code class="p">{</code><code class="w"> </code><code class="n">current</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">head</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w"/>

<code class="w">        </code><code class="c1">// The following three methods are defined</code><code class="w"/>
<code class="w">        </code><code class="c1">// by the Iterator interface</code><code class="w"/>
<code class="w">        </code><code class="kd">public</code><code class="w"> </code><code class="kt">boolean</code><code class="w"> </code><code class="nf">hasNext</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="n">current</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">null</code><code class="p">;</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">        </code><code class="kd">public</code><code class="w"> </code><code class="n">Linkable</code><code class="w"> </code><code class="nf">next</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">current</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="kc">null</code><code class="p">)</code><code class="w"/>
<code class="w">              </code><code class="k">throw</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">java</code><code class="p">.</code><code class="na">util</code><code class="p">.</code><code class="na">NoSuchElementException</code><code class="p">();</code><code class="w"/>
<code class="w">            </code><code class="n">Linkable</code><code class="w"> </code><code class="n">value</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">current</code><code class="p">;</code><code class="w"/>
<code class="w">            </code><code class="n">current</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">current</code><code class="p">.</code><code class="na">getNext</code><code class="p">();</code><code class="w"/>
<code class="w">            </code><code class="k">return</code><code class="w"> </code><code class="n">value</code><code class="p">;</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">        </code><code class="kd">public</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">remove</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">throw</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">UnsupportedOperationException</code><code class="p">();</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">};</code><code class="w">  </code><code class="c1">// Note the required semicolon. It terminates the return statement</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre></div>
<p>As you can see, the syntax for defining an anonymous class and creating
an instance of that class uses the <code>new</code> keyword, followed by the name
of a type and a class body definition in curly braces.
If the name following the <code>new</code> keyword is the name of a class, the anonymous class is a subclass of the named class.
If the name following <code>new</code> specifies an interface, as in the two previous examples, the anonymous class implements that interface and extends <code>Object</code>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The syntax for anonymous classes deliberately does not include any way to specify an <code>extends</code> clause, an <code>implements</code> clause, or a name for the class.</p>
</div>
<p>Because an anonymous class has no name, it is not possible to define a
constructor for it within the class body. This is one of the basic
restrictions on anonymous classes. Any arguments you specify between the
parentheses following the superclass name in an anonymous class
definition are implicitly passed to the superclass constructor.
Anonymous classes are commonly used to subclass simple classes that do
not take any constructor arguments, so the parentheses in the anonymous
class definition syntax are often empty.</p>
<p>Because an anonymous class is just a type of local class, anonymous
classes and local classes share the same restrictions. An anonymous
class cannot define any <code>static</code> fields, methods, or classes, except for
<code>static</code> <code>final</code> constants. Interfaces, enumerated types, and annotation
types cannot be defined anonymously. Also, like local classes,
anonymous classes cannot be <code>public</code>, <code>private</code>, <code>protected</code>, or
<code>static</code>.</p>
<p>The syntax for defining an anonymous class combines definition with instantiation, similar to a lambda expression.
Using an anonymous class instead of a local class is not appropriate if you need to create more than a single instance of the class each time the containing block is executed<a data-startref="ix_ch04-asciidoc41" data-type="indexterm" id="idm45927736513280"/><a data-startref="ix_ch04-asciidoc40" data-type="indexterm" id="idm45927736512576"/>.<a data-startref="ix_ch04-asciidoc31" data-type="indexterm" id="idm45927736511776"/><a data-startref="ix_ch04-asciidoc30" data-type="indexterm" id="idm45927736511072"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Describing the Java Type System" data-type="sect1"><div class="sect1" id="javanut8-CHP-4-SECT-6">
<h1>Describing the Java Type System</h1>
<p><a data-primary="type system" data-secondary="describing" data-type="indexterm" id="ix_ch04-asciidoc42"/>At this point, we have met all of the major aspects of the Java type system, and so it is possible for us to describe and characterize it.</p>
<p>The most important and obvious characteristics of Java’s type system are that it is:</p>
<ul>
<li>
<p>Static</p>
</li>
<li>
<p>Not single-rooted</p>
</li>
<li>
<p>Nominal</p>
</li>
</ul>
<p><a data-primary="statically typed language" data-type="indexterm" id="idm45927736503360"/>Static typing, which is the most widely recognized of the three aspects, means that in Java, every piece of data storage (such as variables, fields, etc.) has a type, and that type is declared when the storage is first introduced.
It is a compile-time error to try to put an incompatible value into storage that does not support it.</p>
<p>That Java’s type system is not single-rooted is also immediately apparent. Java has both primitive types and reference types.
Every object in Java belongs to a class, and every class, except <code>Object</code>, has a single parent.
This means that the set of classes in any Java program forms a tree structure with <code>Object</code> at the root.</p>
<p>However, there is no inheritance relationship between any of the primitive types and <code>Object</code>.
As a result, the overall graph of Java classes consists of a large tree of reference types and eight disjoint, isolated points that correspond to the primitives.
This leads to the need to use wrapper types, such as <code>Integer</code>, to represent primitive values as objects where necessary (such as in the Java Collections).</p>
<p>The final aspect, though, requires a bit more of a detailed discussion.</p>
<section data-pdf-bookmark="Nominal Typing" data-type="sect2"><div class="sect2" id="idm45927736499280">
<h2>Nominal Typing</h2>
<p><a data-primary="nominal typing" data-type="indexterm" id="ix_ch04-asciidoc43"/><a data-primary="type system" data-secondary="nominal typing" data-type="indexterm" id="ix_ch04-asciidoc44"/>In Java, each type has a name. In the normal course of Java programming, this will be a simple string of letters (and sometimes numbers) that has some semantic meaning that reflects the purpose of the type. This approach is known as <em>nominal typing</em>.</p>
<p>Not all languages have purely nominal typing; for example, some languages can express the idea that “this type has a method with a certain signature” without needing to explicitly refer to the name of the type, sometimes known as a <em>structural type</em>.</p>
<p>For example, in Python, you can call <code>len()</code> on any object that defines a <code>__len__()</code> method.
Of course, Python is a dynamically typed language and so will throw a runtime exception if the call to <code>len()</code> cannot be made.
However, it is also possible to express a similar idea in statically typed languages, such as Scala.</p>
<p>Java, on the other hand, has no way to express this idea without using an interface, which, of course, has a name.
Java also maintains type compatibility based strictly on inheritance and implementation.
Let’s look at an example:</p>
<pre data-code-language="java" data-type="programlisting"><code class="nd">@FunctionalInterface</code><code class="w"/>
<code class="kd">public</code><code class="w"> </code><code class="kd">interface</code> <code class="nc">MyRunnable</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kt">void</code><code class="w"> </code><code class="nf">run</code><code class="p">();</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>The interface <code>MyRunnable</code> has a single method that exactly matches that of 
<span class="keep-together"><code>Runnable</code></span>.
However, the two interfaces have no inheritance or other relationship to each other and so code like this:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">MyRunnable</code><code class="w"> </code><code class="n">myR</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="s">"Hello"</code><code class="p">);</code><code class="w"/>
<code class="n">Runnable</code><code class="w"> </code><code class="n">r</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="n">Runnable</code><code class="p">)</code><code class="n">myR</code><code class="p">;</code><code class="w"/>
<code class="n">r</code><code class="p">.</code><code class="na">run</code><code class="p">();</code><code class="w"/></pre>
<p>will compile cleanly but will fail with a <code>ClassCastException</code> at runtime.
The fact that a <code>run()</code> method with an identical signature exists on both interfaces is not considered, and in fact the program never even makes it to the point where <code>run()</code> would be called: it fails on the previous line where the cast is attempted.</p>
<p><a data-primary="lambda expressions" data-secondary="nominal typing and" data-type="indexterm" id="idm45927736384896"/>Another important point is that the entire construction of Java’s lambda expressions, and especially the use of target typing to a functional interface, is to ensure that lambdas fit into the nominal typing approach.
For example, consider an interface such as:</p>
<pre data-code-language="java" data-type="programlisting"><code class="nd">@FunctionalInterface</code><code class="w"/>
<code class="kd">public</code><code class="w"> </code><code class="kd">interface</code> <code class="nc">MyIntProvider</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kt">int</code><code class="w"> </code><code class="nf">run</code><code class="p">()</code><code class="w"> </code><code class="kd">throws</code><code class="w"> </code><code class="n">InterruptedException</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>then a lambda expression that yields a constant, e.g., <code>() -&gt; 42</code>, can be used in a number of different ways:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">MyIntProvider</code><code class="w"> </code><code class="n">prov</code><code class="w">       </code><code class="o">=</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="mi">42</code><code class="p">;</code><code class="w"/>
<code class="n">Supplier</code><code class="o">&lt;</code><code class="n">Integer</code><code class="o">&gt;</code><code class="w"> </code><code class="n">sup</code><code class="w">    </code><code class="o">=</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="mi">42</code><code class="p">;</code><code class="w"/>
<code class="n">Callable</code><code class="o">&lt;</code><code class="n">Integer</code><code class="o">&gt;</code><code class="w"> </code><code class="n">callMe</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="mi">42</code><code class="p">;</code><code class="w"/></pre>
<p>From this, we can see that the expression <code>() -&gt; 42</code> is, by itself, incomplete.
Java lambdas rely upon type inference, and so we need to see the expression in context with its target type for it to be meaningful.
When combined with a target type, the lambda’s class type is “an unknown-at-compile-time implementation of the target interface,” and the programmer must use the interface type as the type of the lambda.</p>
<p>Beyond lambdas, there are some corner cases of nominal typing in Java.
One example is anonymous classes, but even here the types still have names.
However, the type names of anonymous types are automatically generated by the compiler and are specially chosen so as to be usable by the JVM but not accepted by the Java source code compiler.</p>
<p>There is one other corner case that we should consider, and it relates to the enhanced type inference introduced in recent Java versions.<a data-startref="ix_ch04-asciidoc44" data-type="indexterm" id="idm45927736272304"/><a data-startref="ix_ch04-asciidoc43" data-type="indexterm" id="idm45927736271664"/></p>
</div></section>
<section data-pdf-bookmark="Nondenotable Types and var" data-type="sect2"><div class="sect2" id="idm45927736498656">
<h2>Nondenotable Types and var</h2>
<p><a data-primary="local variable type inference (LVTI)" data-type="indexterm" id="ix_ch04-asciidoc45"/><a data-primary="LVTI (local variable type inference)" data-type="indexterm" id="ix_ch04-asciidoc46"/><a data-primary="non-denotable types" data-type="indexterm" id="ix_ch04-asciidoc47"/><a data-primary="type system" data-secondary="non-denotable types and var" data-type="indexterm" id="ix_ch04-asciidoc48"/><a data-primary="var (local variable type inference)" data-type="indexterm" id="ix_ch04-asciidoc49"/>From Java 11 onwards (actually introduced in the Java 10 non-LTS release), Java developers can make use of a new language feature <em>Local Variable Type Inference</em> (LVTI), otherwise known as <code>var</code>.
This is an enhancement to Java’s type inference capabilities that may prove to be more significant than it first appears.
In the simplest case, it allows code such as:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">var</code><code class="w"> </code><code class="n">ls</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">ArrayList</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code><code class="p">();</code><code class="w"/></pre>
<p>which moves the inference from the type of values to the type of variables.</p>
<p>The implementation achieves this by making <code>var</code> a reserved type name rather than a keyword.
This means that code can still use <code>var</code> as a variable, method, or package name without being affected by the new syntax.
However, code that has previously used <code>var</code> as the name of a type will have to be recompiled.</p>
<p>This simple case is designed to reduce verbosity and to make programmers coming to Java from other languages (especially Scala, .NET, and JavaScript) feel more comfortable. However, it does carry the risk that overuse will potentially obscure the intent of the code being written, so it should be used sparingly.</p>
<p>As well as the simple cases, <code>var</code> actually permits programming constructs that were not possible before.
To see the differences, let’s consider that <code>javac</code> has always permitted a very limited form of type inference:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="kd">class</code> <code class="nc">Test</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kd">static</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">main</code><code class="p">(</code><code class="n">String</code><code class="o">[]</code><code class="w"> </code><code class="n">args</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="p">(</code><code class="k">new</code><code class="w"> </code><code class="n">Object</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="kd">public</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">bar</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">                </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="s">"bar!"</code><code class="p">);</code><code class="w"/>
<code class="w">            </code><code class="p">}</code><code class="w"/>
<code class="w">        </code><code class="p">}).</code><code class="na">bar</code><code class="p">();</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>The code will compile and run, printing out <code>bar!</code>.
This slightly counterintuitive result occurs because <code>javac</code> preserves enough type information about the anonymous class (i.e., that it has a <code>bar()</code> method) for just long enough that the compiler can conclude that the call to <code>bar()</code> is valid.</p>
<p>In fact, this edge case has been <a href="https://oreil.ly/RVqng">known in the Java community</a> since at least 2009, long before the arrival of Java 7.</p>
<p>The problem with this form of type inference is that it has no real practical applications: the type of “Object-with-a-bar-method” exists within the compiler, but the type is impossible to express as the type of a variable—it is not a <em>denotable type</em>.
This means that before Java 10, the existence of this type is restricted to a single expression and cannot be used in a larger scope.</p>
<p>With the arrival of LVTI, however, the type of variables does not always need to be made explicit.
Instead, we can use <code>var</code> to allow us to preserve the static type information by avoiding denoting the type.</p>
<p>This means we can now modify our example and write:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">var</code><code class="w"> </code><code class="n">o</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">Object</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">bar</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="s">"bar!"</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">};</code><code class="w"/>

<code class="n">o</code><code class="p">.</code><code class="na">bar</code><code class="p">();</code><code class="w"/></pre>
<p>This has allowed us to preserve the true type of <code>o</code> beyond a single expression.
The type of <code>o</code> cannot be denoted, and so it cannot appear as the type of either a method parameter or return type.
This means the type is still limited to only a single method, but it is still useful to express some constructions that would be awkward or impossible otherwise.</p>
<p>This use of <code>var</code> as a “magic type” allows the programmer to preserve type information for each distinct usage of <code>var</code>, in a way that is somewhat reminiscent of bounded wildcards from Java’s generics.</p>
<p>More advanced usages of <code>var</code> with nondenotable types <a href="https://oreil.ly/p0w-a">are possible</a>.
While the feature is not able to satisfy every criticism of Java’s type system, it does represent a definite (if cautious) step forward<a data-startref="ix_ch04-asciidoc49" data-type="indexterm" id="idm45927736043152"/><a data-startref="ix_ch04-asciidoc48" data-type="indexterm" id="idm45927736042448"/><a data-startref="ix_ch04-asciidoc47" data-type="indexterm" id="idm45927736041776"/><a data-startref="ix_ch04-asciidoc46" data-type="indexterm" id="idm45927736041104"/><a data-startref="ix_ch04-asciidoc45" data-type="indexterm" id="idm45927736040432"/>.<a data-startref="ix_ch04-asciidoc42" data-type="indexterm" id="idm45927736039632"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="javanut8-CHP-4-SECT-7">
<h1>Summary</h1>
<p>By examining Java’s type system, we have been able to build up a clear
picture of the worldview that the Java platform has about data types.
<a data-primary="type system" data-secondary="characteristics of" data-type="indexterm" id="idm45927736036800"/>Java’s type system can be characterized as:</p>
<dl>
<dt>Static</dt>
<dd>
<p>All Java variables have types that are known at compile time.</p>
</dd>
<dt>Nominal</dt>
<dd>
<p>The name of a Java type is of paramount importance. Java does not
permit structural types and has only limited support for nondenotable
types.</p>
</dd>
<dt>Object/imperative</dt>
<dd>
<p>Java code is object-oriented, and all code must live inside methods,
which must live inside classes. However, Java’s primitive types
prevent full adoption of the “everything is an object” worldview.</p>
</dd>
<dt>Slightly functional</dt>
<dd>
<p>Java provides support for some of the more common functional idioms
but more as a convenience to programmers than anything else.</p>
</dd>
<dt>Type-inferred</dt>
<dd>
<p>Java is optimized for readability (even by novice progammers) and
prefers to be explicit but uses type inference to reduce boilerplate
where it does not impact the legibility of the code.</p>
</dd>
<dt>Strongly backward compatible</dt>
<dd>
<p>Java is primarily a business-focused language, and backward
compatibility and protection of existing codebases are very high
priorities.</p>
</dd>
<dt>Type erased</dt>
<dd>
<p>Java permits parameterized types, but this information is not
available at <span class="keep-together">runtime</span>.</p>
</dd>
</dl>
<p>Java’s type system has evolved (albeit slowly and cautiously) over the years—and is now on par with the type systems of other mainstream programming languages.
Lambda expressions, along with default methods, represent the greatest transformation since the advent of Java 5 and the introduction of generics, annotations, and related innovations.</p>
<p>Default methods represent a major shift in Java’s approach to object-oriented programming—perhaps the biggest since the language’s inception.
From Java 8 onward, interfaces can contain implementation code.
This fundamentally changes Java’s nature. Previously a single-inherited language, Java is now multiply inherited (but only for behavior—there is still no multiple inheritance of state).</p>
<p>Despite all of these innovations, Java’s type system is not (and is not intended to be) equipped with the power of the type systems of languages such as Scala or Haskell.<a data-startref="ix_ch04-asciidoc0" data-type="indexterm" id="idm45927735997120"/>
Instead, Java’s type system is strongly biased in favor of simplicity, readability, and a simple learning curve for newcomers.</p>
<p>Java has also benefited enormously from the approaches to types developed in other languages over the last 10 years.
Scala’s example of a statically typed language that nevertheless achieves much of the feel of a dynamically typed language through the use of type inference has been a good source of ideas for features to add to Java, even though the languages have quite different design philosophies.</p>
<p>One remaining question is whether the modest support for functional idioms that lambda expressions provide in Java is sufficient for the majority of Java <span class="keep-together">programmers</span>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The long-term direction of Java’s type system is being explored in research projects such as Valhalla, where concepts such as data classes, pattern matching, and sealed classes are being explored.</p>
</div>
<p>It remains to be seen whether the majority of ordinary Java programmers require the added power—and attendant complexity—that comes from an advanced (and much less nominal) type system such as Scala’s, or whether the “slightly functional programming” introduced in Java 8 (e.g., <em>map</em>, <em>filter</em>, <em>reduce</em>, and their peers) will suffice for most developers’ needs.</p>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="idm45927740773536"><sup><a href="ch04.xhtml#idm45927740773536-marker">1</a></sup> Some small traces of generics remain, which can be seen at runtime via reflection.</p><p data-type="footnote" id="idm45927740053936"><sup><a href="ch04.xhtml#idm45927740053936-marker">2</a></sup> Raoul-Gabriel Urma and Janina Voigt, “Using the OpenJDK to Investigate Covariance in Java,” <em>Java Magazine</em> (May/June 2012): 44–47.</p></div></div></section></div></body></html>