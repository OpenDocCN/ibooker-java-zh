- en: Chapter 5\. Continuous Integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Melissa McKay
  prefs: []
  type: TYPE_NORMAL
- en: Always make new mistakes.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Esther Dyson
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Back in [Chapter 2](ch02.xhtml#the_system_of_truth), you learned the value of
    source control and a common code repository. After you have organized and settled
    on your source control solution, you need to take a few more steps to reach an
    end result where your users can bask in the perfect user experience of your delivered
    software.
  prefs: []
  type: TYPE_NORMAL
- en: Think about the process that you would take as an individual developer to progress
    your software through the entire software development lifecycle. After determining
    the acceptance criteria for a particular feature or bug fix for your software,
    you would proceed with adding the actual lines of code along with the related
    unit tests to the codebase. Then, you would compile and run all of the unit tests
    to ensure that your new code works as you expect (or at least as defined by your
    unit tests) and doesn’t break known existing functionality. After you find that
    all tests pass, you would build and package your application and verify functionality
    in the form of integration tests in a quality assurance (QA) environment. Finally,
    happy with the green light from your well-oiled and maintained test suites, you
    would deliver and/or deploy your software to a production environment.
  prefs: []
  type: TYPE_NORMAL
- en: If you have any development experience at all, you know as well as I do that
    software rarely falls into place so neatly. Strict implementation of the ideal
    workflow described is too simplistic when you begin working on a larger project
    with a team of developers. Multiple complications are introduced that can gum
    up the gears of the software delivery lifecycle and throw your schedule into a
    lurch. This chapter discusses how continuous integration and the related best
    practices and toolsets will help you steer clear of or mitigate the most common
    hurdles and headaches that software development projects often encounter on the
    path to delivery.
  prefs: []
  type: TYPE_NORMAL
- en: Adopt Continuous Integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Continuous integration* (CI) is most commonly described as frequently integrating
    code changes from multiple contributors into the main source code repository of
    a project. In practice, this definition by itself is a little vague. Exactly how
    often is *frequently*? What does integrating actually mean in this context? Is
    it enough just to coordinate pushing code changes to the source code repository?
    And most important, what problem does this process solve—for what benefit(s) should
    you adopt this practice?'
  prefs: []
  type: TYPE_NORMAL
- en: The concept of CI has been around now for quite some time. [According to Martin
    Fowler](https://oreil.ly/3sYHE), the term *continuous integration* originated
    with Kent Beck’s Extreme Programming development process, as one of its original
    12 practices. In the DevOps community, the term itself is now as common as butter
    on toast. But the way it is implemented may vary from team to team and project
    to project. The benefits are hit-or-miss if there isn’t a thorough understanding
    of the original intent or if best practices are abandoned.
  prefs: []
  type: TYPE_NORMAL
- en: It’s interesting to see how our understanding of CI has changed over time. The
    way we talk about it now is much different from when it was initially introduced
    by Beck to address the issues of concurrent development. The problems we have
    today are more about keeping regular and frequent builds efficient while minimizing
    bugs, whereas initially, CI and the proliferation of build tools that spun out
    from it was more about getting a project to build *at all* after development was
    complete. Instead of trying to assemble a project only *after* all the coding
    has been completed by the team, CI required a change in mindset—to regularly build
    *during* development.
  prefs: []
  type: TYPE_NORMAL
- en: Today, CI is meant to identify bugs and compatibility issues as quickly as possible
    in the development cycle through regular and frequent builds. The basic premise
    of CI is that if developers integrate changes often, bugs can be found sooner
    in the process, and less time is spent hunting down when and where a problem was
    introduced. The longer a bug goes undiscovered, the greater the potential for
    it to become entrenched in the surrounding codebase.
  prefs: []
  type: TYPE_NORMAL
- en: It is much easier from a development perspective to find, catch, and fix bugs
    closer to when they are introduced rather than extract them from layers of code
    that have already moved to later stages of the delivery pipeline. Bugs that evade
    discovery until the latest acceptance phases, and especially those that escape
    all the way to release, directly translate to more money spent to fix and less
    time spent on new features. In the case of fixing a bug in production, in many
    instances, there is now a requirement to patch existing deployments in addition
    to including and documenting the fix in a new version. This inherently reduces
    the time the team has available to spend on the development of new features.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s important to understand that implementing a CI solution does *not* equate
    to software that never has any bugs. It would be foolish to use such a definitive
    measure to determine whether the implementation of CI is worthy. A more valuable
    metric might be the number of bugs or compatibility issues that were caught by
    CI. In much the same way that a vaccine is never 100% effective in a large population,
    CI is simply another level of protection to filter the most obvious bugs from
    a release. By itself, CI will never replace the well-known benefits of software
    development best practices that are in the purview of the initial design and development
    steps. It will, however, provide a better safety net for software as it is repeatedly
    handled and massaged by multiple developers over time. Martin Fowler puts it this
    way: “Continuous integration doesn’t get rid of bugs, but it does make them dramatically
    easier to find and remove.”'
  prefs: []
  type: TYPE_NORMAL
- en: My first experience with CI was during an internship at a small company that
    adopted the software development methodology of Extreme Programming (XP), of which
    CI is an important aspect. We did not have an incredibly fancy system using all
    of the latest and greatest DevOps tools. What we did have was a common code repository,
    and a single build server located in a small closet in the office.
  prefs: []
  type: TYPE_NORMAL
- en: Unbeknownst to me when I first joined the development team, a speaker was set
    up on the build server that would erupt in the sound of emergency sirens if a
    fresh checkout from source control resulted in the failure of a build or any automated
    tests. We were a relatively young team, so this part of our CI was mostly in jest,
    but guess who learned *remarkably* quickly not to push code to the main repository
    without first verifying that the project built successfully and passed unit tests?
  prefs: []
  type: TYPE_NORMAL
- en: 'To this day, I feel exceptionally fortunate to have been exposed to this practice
    in this way. The simplicity of it underscored the most important aspects of CI.
    I want to call out three by-products of this simple setup:'
  prefs: []
  type: TYPE_NORMAL
- en: Code integration was regular and rarely complicated
  prefs: []
  type: TYPE_NORMAL
- en: My team had agreed to follow XP practices, which encourage integration as often
    as [every few hours](https://oreil.ly/0A7P9). More important than a specific time
    interval was the amount of code requiring integration at any given point. When
    planning and breaking down actual development work, we focused our efforts on
    creating small, completable tasks, always beginning with the [simplest thing that
    can possibly work](https://oreil.ly/Scb94). By *completable*, I mean after the
    development task was complete, it could be integrated into the main code repository
    and the result would be expected to build successfully and pass all unit tests.
    This practice of organizing code updates in as small a package as possible made
    regular and frequent integration to the main source code repository a normal and
    unremarkable activity. Rarely was significant time spent on large integration
    efforts.
  prefs: []
  type: TYPE_NORMAL
- en: Build and test failures were relatively easy to troubleshoot
  prefs: []
  type: TYPE_NORMAL
- en: Because the project was built and automated tests were run at regular intervals,
    it was readily apparent where to start troubleshooting any failures. A relatively
    small amount of code would have been touched since the latest successful build,
    and if the problem couldn’t immediately be identified and resolved, we would start
    with reverting the latest merge and work backward as needed to restore a clean
    build.
  prefs: []
  type: TYPE_NORMAL
- en: Bugs and compatibility issues introduced by integration and caught by the CI
    system were fixed immediately
  prefs: []
  type: TYPE_NORMAL
- en: The loud sound of the siren let *everyone* on the team know that a problem needed
    to be addressed, a problem that could not be ignored. Because our CI system halted
    progress whenever a build or test failure occurred, everyone was on board to figure
    out what was wrong and what to do to fix the problem. Team communication, coordination,
    and cooperation were all in top shape because no one would be able to move forward
    until the issue was resolved. A majority of the time, the offending code could
    be identified simply by analyzing the most recent merge, and the responsibility
    to fix was assigned to that developer or pair of developers. At times, a discussion
    with the entire team was necessary because of a compatibility issue around multiple
    recent merges, as changes in one part of the system negatively affected another
    seemingly unrelated part. These instances required our team to reevaluate the
    code changes being made holistically and then decide together the best plan of
    action.
  prefs: []
  type: TYPE_NORMAL
- en: These three factors were key to the success of our CI solution. You might have
    discerned that all three imply the prerequisites of a healthy codebase and a healthy
    development team. Without these, the initial implementation of a CI solution will
    undoubtedly be more difficult. However, implementing a CI solution will in turn
    have a positive impact on the codebase, and taking the first steps will provide
    a measure of benefit that will be well worth the effort.
  prefs: []
  type: TYPE_NORMAL
- en: It is true there is much more to an effective CI solution than simple coordination
    of code contribution to a shared repository and following a mandate to integrate
    at an agreed-upon frequency. The following sections will walk you through the
    essentials of a complete, practicable CI solution that will help unburden and
    accelerate the software development process.
  prefs: []
  type: TYPE_NORMAL
- en: Declaratively Script Your Build
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Regardless of the state of your project—whether it’s greenfield, legacy, a small
    individual library, or a large multimodule project—your first task in implementing
    a CI solution should be to *script your build*. Having a consistent and repeatable
    process that you can automate will help avoid the frustration of buggy build permutations
    due to the mismanagement of dependencies, forgetting to include needed resources
    when creating the distributable package, or unintentionally neglecting build steps,
    among other pitfalls.
  prefs: []
  type: TYPE_NORMAL
- en: You will reap a tremendous amount of time savings from scripting your build.
    Your project *build lifecycle* (all of the discrete steps required to build your
    project) can easily grow more complicated over time, especially as you consume
    more and more dependencies, include various resources, add modules, and add tests.
    You may also need to build your project differently depending on the intended
    deployment environment. For example, you might need to enable debugging capabilities
    in a development or QA environment, but disable debugging in a build intended
    for release to production as well as prevent test classes from being included
    in the distributable package. Manually performing all of the required steps involved
    in building a Java project, including consideration for configuration differences
    per environment, is a hotbed for human error. The first time you neglect a step
    like building an updated dependency and consequently must repeat a build of a
    huge multimodule project to correct your mistake, you will appreciate the value
    of a build script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whatever tool or framework you choose for scripting your build, take care to
    use a *declarative* approach rather than *imperative*. Here’s a quick reminder
    of the meaning of these terms:'
  prefs: []
  type: TYPE_NORMAL
- en: Imperative
  prefs: []
  type: TYPE_NORMAL
- en: Defining an exact procedure with implementation details
  prefs: []
  type: TYPE_NORMAL
- en: Declarative
  prefs: []
  type: TYPE_NORMAL
- en: Defining an action without implementation details
  prefs: []
  type: TYPE_NORMAL
- en: In other words, keep your build script focused on *what* you need to do rather
    than *how* to do it. This will help keep your script understandable, maintainable,
    testable, and scalable by encouraging reuse on other projects or modules. To accomplish
    this, you may need to establish or conform to a known convention, or write plug-ins
    or other external code referenced from your build script that provides the implementation
    details. Some build tools are more apt to foster a declarative approach than others.
    This usually comes with the cost of conforming to a convention versus flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: The Java ecosystem has several well-established build tools available, so I
    would be surprised if you are currently manually compiling your project with `javac`
    and packaging your class files into a JAR or other package type. You likely already
    have some sort of build process and script established, but in the unlikely scenario
    that you do not, you are starting a brand-new Java project, or you are looking
    to improve an existing script to utilize best practices, this section summarizes
    a few of the most common build tools/frameworks available in the Java ecosystem
    and what they provide you out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, it is important to map out your build process, to determine what you
    need from your build script in order to gain the most benefit. To build a Java
    project, at the bare minimum you need to specify the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Java version
  prefs: []
  type: TYPE_NORMAL
- en: The version of Java required to compile the project
  prefs: []
  type: TYPE_NORMAL
- en: Source directory path
  prefs: []
  type: TYPE_NORMAL
- en: The directory that includes all of the source code for the project
  prefs: []
  type: TYPE_NORMAL
- en: Destination directory path
  prefs: []
  type: TYPE_NORMAL
- en: The directory where compiled class files are expected to be placed
  prefs: []
  type: TYPE_NORMAL
- en: Names, locations, and versions of needed dependencies
  prefs: []
  type: TYPE_NORMAL
- en: The metadata necessary to locate and gather any dependencies required by your
    project
  prefs: []
  type: TYPE_NORMAL
- en: 'With this information, you should be able to execute a minimal build process
    with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Collect any needed dependencies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Package your application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The best way to show how to massage your build process into a build script is
    by example. The following examples demonstrate the use of three of the most common
    build tools to script the minimal build process described for a simple Hello World
    Java application. In no way do these examples explore all of the functionality
    available in these tools. They are simply meant as a crash course to help you
    either begin to understand your existing build script or write your first build
    script to benefit from a full CI solution.
  prefs: []
  type: TYPE_NORMAL
- en: In evaluating a build tool, bear in mind the actual process your project requires
    to complete a build. Your project may require scripting additional steps that
    are not shown here, and one build tool may be more suited than another to accomplish
    this. It is important that the tool you choose helps you programmatically define
    and accelerate the build process your project requires rather than arbitrarily
    force you to modify your process to fit the requirements of the tool. That said,
    when you learn the capabilities of a tool, reflect on your process and be mindful
    of changes that would benefit your team. This is most important with established
    projects. Changes to the process, however well-intentioned, can be painful for
    a development team. They should be made only intentionally, with a clear understanding
    of the reason for the change and, of course, a clear benefit.
  prefs: []
  type: TYPE_NORMAL
- en: Build with Apache Ant
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Apache Ant* is an open source project released under an Apache License by
    the Apache Software Foundation. According to the [Apache Ant documentation](https://ant.apache.org),
    the name is an acronym for Another Neat Tool and was initially part of the Tomcat
    codebase, written by James Duncan Davidson for the purpose of building Tomcat.
    Its first initial release was in 2000.'
  prefs: []
  type: TYPE_NORMAL
- en: Apache Ant is a build tool written in Java that provides a way to describe a
    build process as declarative steps within an XML file. This is the first build
    tool that I was exposed to in my Java career, and although Ant has heavy competition
    today, it is still an active project and widely used often in combination with
    other tools.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 5-1](#ant_build_script_example) is a simple Ant build file I created
    and executed with Ant 1.10.8.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-1\. Ant build script (build.xml)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_continuous_integration_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The value of the `default` attribute of the project can be set to the name of
    a default target to run when Ant is invoked without a target. For this project,
    the command `ant` without any arguments will run the *package* target.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_continuous_integration_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Property elements are hardcoded, immutable values that may be used more than
    once in the rest of the build script. Using them helps with both readability and
    maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_continuous_integration_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: This path element is how I chose to manage the location of needed dependencies
    for this project. In this case, both the *junit* and *hamcrest-core* JARs are
    manually placed in the directory configured here. This technique implies that
    dependencies would be checked into source control along with the project. Although
    it was simple to do for this example, this is not a recommended practice. [Chapter 6](ch06.xhtml#package_management)
    discusses package management in detail.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_continuous_integration_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The `compile` target is responsible for the compilation of the source code (this
    project specifies Java 11) and placement of the resulting class files in the configured
    location. This target depends on the *clean* target, meaning the clean target
    will be run first, to ensure that compiled class files are fresh and not left
    over from an old build.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_continuous_integration_CO1-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The `test` target configures the JUnit Ant task that will run all of the available
    unit tests and print the results to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](Images/6.png)](#co_continuous_integration_CO1-6)'
  prefs: []
  type: TYPE_NORMAL
- en: The `package` target will assemble and place a final JAR file in the configured
    location.
  prefs: []
  type: TYPE_NORMAL
- en: Executing the one-line command `ant package` will take our Java project, compile
    it, run unit tests, and then assemble a JAR file for us. Ant is flexible, rich
    in functionality, and satisfies our goal of scripting a minimal build. The XML
    configuration file is a clean, straightforward way of documenting the project’s
    build lifecycle. By itself, Ant is lacking in the way of dependency management.
    However, tools like [Apache Ivy](https://oreil.ly/7t5v5) have been developed to
    extend this functionality to Ant.
  prefs: []
  type: TYPE_NORMAL
- en: Build with Apache Maven
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: According to the [Apache Maven Project documentation](https://oreil.ly/CziRT),
    *maven* is a Yiddish word meaning *accumulator of knowledge*. Like Apache Ant,
    Maven is also an open source project of the Apache Software Foundation. It began
    as an improvement to the Jakarta turbine project build that was utilizing varied
    configurations of Ant for each subproject. Its first official release was in 2004.
  prefs: []
  type: TYPE_NORMAL
- en: Like Apache Ant, Maven uses an XML document, (a POM file) to describe and manage
    Java projects. This document records information about the project, including
    a unique identifier for the project, the required compiler version, configuration
    property values, and metadata on all required dependencies and their versions.
    One of the most powerful features of Maven is its dependency management and the
    ability to use repositories to share dependencies with other projects.
  prefs: []
  type: TYPE_NORMAL
- en: Maven relies heavily on convention in order to provide a uniform method of managing
    and documenting a project that can easily scale across all projects using Maven.
    A project is expected to be laid out on the filesystem in a specific way. To keep
    the script declarative, customized implementations require building custom plug-ins.
    Although it can be extensively customized to override expected defaults, Maven
    works out of the box with little configuration if you conform to the expected
    project structure.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 5-2](#maven_pom_file_example) is a simple POM file I configured for
    my Java 11 environment using Maven 3.6.3.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-2\. Maven POM file (pom.xml)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_continuous_integration_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Every project is uniquely identified by its configured `groupId`, `artifactId`,
    and `version`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_continuous_integration_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Properties are hardcoded values that can potentially be used in multiple places
    in the POM file. They can be either custom properties or built-in properties used
    by plug-ins or goals.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_continuous_integration_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: In the `dependencies` block, all direct dependencies of the project are identified.
    This project relies on JUnit to run the unit tests, so the *junit* dependency
    is specified here. JUnit has a dependency itself on *hamcrest-core*, but Maven
    is smart enough to figure that out without having to include it here. By default,
    Maven will pull these dependencies from Maven Central.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_continuous_integration_CO2-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The `build` block is where plug-ins are configured. Unless there is configuration
    you want to override, this block isn’t required.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_continuous_integration_CO2-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Default plug-in bindings exist for all of the lifecycle phases, but in this
    case, I wanted to configure `maven-compiler-plugin` to use Java version 11 rather
    than the default. The property that controls this for the plug-in is `maven​.com⁠piler.release`
    in the `properties` block. This configuration could have been put in the `plugins`
    block, but it makes sense to move it to the `properties` block for better visibility
    toward the top of the file. This property replaces `maven.compiler.source` and
    `maven.compiler.target` that is usually seen when using older versions of Java.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It is a good idea to lock down all of your Maven plug-in versions to avoid using
    Maven defaults. Specifically, pay special attention to Maven instructions for
    configuring your build script when using older versions of Maven and Java versions
    9 or greater. The default plug-in versions of your Maven installation might not
    be compatible with later versions of Java.
  prefs: []
  type: TYPE_NORMAL
- en: Because of the strong reliance on convention, this Maven build script is quite
    brief. With this small POM file, I am able to execute `mvn package` to compile,
    run tests, and assemble a JAR file, all utilizing default settings. If you spend
    any time with Maven, you will quickly realize that it is much more than just a
    build tool and is chock-full of powerful features. For someone new to Maven, its
    potential complexity can be overwhelming. Also, customization through creating
    a new Maven plug-in is daunting when the customization is minor. At the time of
    this writing, the [Apache Maven Project](https://oreil.ly/CziRT) documentation
    contains excellent resources, including a [Maven in 5 Minutes](https://oreil.ly/dkxa6)
    guide. I highly recommend starting with these resources if you are unfamiliar
    with Maven.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Although the [Apache Maven Ant Plugin](https://oreil.ly/DOg5K) is no longer
    maintained, it is possible to generate an Ant build file from a Maven POM file.
    Doing this will help you appreciate everything you get out of the box with Maven’s
    convention and defaults! In the same directory as your *pom.xml* file, invoke
    the Maven plug-in with the command `mvn ant:ant`.
  prefs: []
  type: TYPE_NORMAL
- en: Build with Gradle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Gradle* is an open source build tool under the Apache 2.0 license. Hans Dockter,
    the founder of Gradle, [explained in the Gradle Forums](https://oreil.ly/1mEwy)
    that his original idea was to call the project Cradle with a *C*. He ultimately
    decided on the name Gradle with a *G* since it used Apache Groovy for the domain-specific
    language (DSL). Gradle 1.0 was released in 2012, so in comparison to Apache Ant
    and Apache Maven, Gradle is the new kid on the block.'
  prefs: []
  type: TYPE_NORMAL
- en: One of the biggest differences between Gradle and Maven and Ant is that the
    Gradle build script is not XML based. Instead, Gradle build scripts can be written
    with either a Groovy or Kotlin DSL. Like Maven, Gradle also utilizes convention,
    but is more flexible compared to Maven. The [Gradle documentation](https://oreil.ly/Vvhch)
    touts the flexibility of the tool and includes instructions on how to easily customize
    your build.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Gradle has extensive online documentation on [migrating Maven builds to Gradle](https://oreil.ly/RqR1s).
    You can generate a Gradle build file from an existing Maven POM.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 5-3](#gradle_build_script_example) is a simple Gradle build file that
    I generated from the content of [Example 5-2](#maven_pom_file_example) in the
    previous section.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-3\. Gradle build script (build.gradle)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_continuous_integration_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Gradle plug-ins are applied by adding their *plug-in ID* to the `plugins` block.
    The `java` plug-in is a Gradle Core plug-in that provides compilation, testing,
    packaging, and other functionality for Java projects.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_continuous_integration_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Repositories for dependencies are provided in the `repositories` block. Dependencies
    are resolved using these settings.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_continuous_integration_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Gradle handles dependencies similarly to Maven. The JUnit dependency is required
    for our unit tests, so it is included in the `dependencies` block.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_continuous_integration_CO3-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The `sourceCompatibility` configuration setting is provided by the `java` plug-in
    and maps to the `source` option of `javac`. There is also a `targetCompatibility`
    configuration setting. Its default value is the value of `sourceCompatibility`,
    so there was no reason to add it to the build script.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_continuous_integration_CO3-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The flexibility of Gradle allows me to add explicit encoding for the Java compiler.
    A task provided by the `java` plug-in, called `compileJava`, is of the type `Java​Com⁠piler`.
    This code block sets the encoding property on this compile task.
  prefs: []
  type: TYPE_NORMAL
- en: This Gradle build script allows me to compile, run tests, and assemble a JAR
    file for my project by executing the single command `gradle build`. Because Gradle
    builds are based on well-known conventions, build scripts contain only what is
    needed that differentiates the build, helping to keep them small and maintainable.
    This simple script shows how powerful and flexible Gradle can be, especially for
    Java projects that have a more complicated build process. In that case, the up-front
    investment required to understand the Gradle DSL for customization is well worth
    the time.
  prefs: []
  type: TYPE_NORMAL
- en: All three of these tools for building your Java project have their own strengths
    and weaknesses. Choose a tool based on the needs of your project, the experience
    of your team, and the flexibility required. Wrangling together a build script—however
    you choose to do it—and with whatever tool you choose to do it, will increase
    your efficiency by leaps and bounds. Building a Java project is a repetitive process
    consisting of numerous steps, ripe for human error, and marvelously suitable for
    automation. Reducing your project build to a single command saves ramp-up time
    for new developers, increases efficiency during development tasks in a local development
    environment, and paves the way for build automation, an integral component of
    an effective CI solution.
  prefs: []
  type: TYPE_NORMAL
- en: Continuously Build
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most telltale sign that code integration was unsuccessful is the failure
    of a build. Therefore, it stands to reason that a project should be built often
    in order to detect and resolve any issues as soon as possible. In fact, *every
    contribution to the mainline codebase should be expected to result in a build
    that compiles successfully and passes all unit tests*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When referring to building a project after code is merged into the mainline
    source code repository, I intentionally use the word *contribution* as opposed
    to *commit* or *check-in*. This is simply because your development team may have
    agreed to follow multiple development processes (all valid), and in some of these,
    a *contribution* to the mainline may be the merge of a branch or the merge of
    a pull request—both of which potentially consist of one or more commits.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a typical developer workflow using test-driven development:'
  prefs: []
  type: TYPE_NORMAL
- en: Check out the latest code from source control to a local workspace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build and run all tests for the project to ensure a clean start. (There should
    be a build script for this. Refer to [“Declaratively Script Your Build”](#declaratively_script_your_build).)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the code and related unit tests for the new feature or bug fix.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the new unit tests to ensure that they pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build and run *all* unit tests for the project to ensure that the new code doesn’t
    result in negative side effects when integrated with the existing code. (Again,
    use a build script for this.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Commit the new code along with the new tests to the codebase.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This process aims to prevent issues (including the introduction of bugs or loss
    of functionality) with integrating code before it leaves your local development
    workspace. However, problems can manifest during this workflow that will cause
    pain down the road. Some will be caused by the realities of human nature, and
    others arise because, regardless of how much effort is put into advanced planning,
    it is nearly impossible to prevent every potential incompatibility introduced
    by concurrent development. Do not misunderstand; I am *not* saying that this process
    is wrong and should be discarded altogether. Instead, this section explains how
    an automated CI implementation helps mitigate the problems that can arise during
    this workflow and bolster your efficiency and productivity as a developer.
  prefs: []
  type: TYPE_NORMAL
- en: It isn’t enough for a developer to successfully build a project in their own
    local environment. Even if every developer diligently abides by the agreed-upon
    process and commits code changes only after all tests pass, you shouldn’t rely
    on this alone. The simplest reason is that a developer might not have the latest
    changes from the mainline (an even more likely scenario when many developers are
    working in the same codebase). This could result in an incompatibility that isn’t
    discovered until after the code is merged.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes issues with tests might surface only when someone else attempts to
    do a build or run tests in their own local development environment. For example,
    more than once I’ve embarrassingly forgotten to commit a new file or resource
    that I’ve created to the codebase. This means that the next developer who collects
    these changes gets to suffer through the annoyance of having either the build
    or tests fail immediately. Another issue I’ve seen is code written in such a way
    that it works in only a specific environment or a specific OS.
  prefs: []
  type: TYPE_NORMAL
- en: We all have bad days, and these problems slip by us from time to time even in
    the most ideal circumstances. But rather than let broken builds spread through
    the team like a virus, strategies can be put in place to help to mitigate integration
    issues like this. The most common is using automatic build servers, or CI servers.
    These servers are shared by development teams responsible for performing full
    builds, including running tests, and reporting the result of the build after code
    changes have been committed.
  prefs: []
  type: TYPE_NORMAL
- en: Popular CI servers you might recognize include Jenkins, CircleCI, TeamCity,
    Bamboo, and GitLab. More options are coming on the scene like JFrog Pipelines,
    and some have more features and capabilities than others, but the primary objective
    is to establish a referee for the code changes coming in to the shared repository
    by building frequently and reporting when a problem occurs. Utilizing a CI server
    for the purpose of running builds automatically is the best way to ensure that
    builds are happening regularly, revealing any integrations issues early.
  prefs: []
  type: TYPE_NORMAL
- en: Automate Tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Outside of running individual tests during development, most often within an
    IDE, a developer should have a quick method of running the full suite of automated
    tests prior to checking in new code to the codebase.
  prefs: []
  type: TYPE_NORMAL
- en: The minimal build process outlined in [“Declaratively Script Your Build”](#declaratively_script_your_build)
    includes a step for automatically running unit tests. Each build script example
    also includes this unit test step. This is no accident. In fact, this part of
    your build is absolutely essential for a healthy CI solution and is worthy of
    a decent amount of time and attention. One of the primary purposes of CI is having
    the ability to catch integration issues as early in the development process as
    possible.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests alone will not expose every single issue—that’s an unrealistic expectation.
    But writing a strong set of unit tests is one of the best proactive approaches
    to detecting the most obvious problems early on. Because unit tests can be run
    even prior to the first stages of formal quality assurance, they are an extremely
    valuable part of the development cycle. They are the first set of safety measures
    that you can take to ensure that your software will behave correctly in production.
  prefs: []
  type: TYPE_NORMAL
- en: This section does not go into specifics on how to write unit tests in Java.
    I assume that you understand and accept their importance, that your project has
    unit tests, and that you utilize a framework that facilitates automatically running
    them like JUnit or TestNG. If you do not, immediately stop and write a simple
    unit test for your project that can be automatically run during your build for
    the sake of having this step available to expand on in your CI solution. Then,
    schedule a time to sit down with your development team and strategize how you
    will write and maintain unit tests moving forward.
  prefs: []
  type: TYPE_NORMAL
- en: Numerous test tools are available in the Java ecosystem, and this section is
    not meant to be an exhaustive comparison or an endorsement of one over another.
    Instead, I discuss how test automation should fit into your CI process, the qualities
    of your test suite to strive for, and how to avoid common pitfalls in the context
    of CI that will eat away at your efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: Monitor and Maintain Tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Checking out the latest code to your local development workspace is pretty straightforward.
    Compiling and running all of the unit tests is straightforward as well. But as
    you add more modules, and your project becomes more complicated, doing a complete
    build and running all of the tests will begin to take more time. The longer your
    development process takes, the more likely that other code changes have been introduced
    to the mainline ahead of yours.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent a potential break, you would have to check out the newest changes
    and run all of the tests again—not a very efficient process. Frustration can lead
    to developers taking shortcuts and skipping running the tests in an effort to
    commit code to the mainline before it is changed out from under them. Obviously,
    this is a slippery slope that is guaranteed to result in broken code in the mainline
    more often, slowing the entire team.
  prefs: []
  type: TYPE_NORMAL
- en: It takes time to maintain tests, and this time should be regularly built in
    to the development schedule. Just like the rest of your codebase, tests require
    improvements and adjustments over time. When they become obsolete, they should
    be removed. When they break, they should be fixed. Often when browsing through
    various codebases, I’ll come across test cases that are commented out. This happens
    for a few reasons; none of them good. Sometimes it’s simply because a team was
    short on time and felt the need to force through a build to meet a deadline, with
    the promise of revisiting the tests at a later time. Sometimes, it’s because a
    particular test case inconsistently fails, known as a *flaky* test. This could
    be due to a race condition or a dynamic value that the test erroneously expects
    to be static.
  prefs: []
  type: TYPE_NORMAL
- en: In either case, manipulating tests not to run is a dangerous business and indicates
    bigger problems afoot with the development team. A review of priorities is in
    order. Not addressing stale or brittle tests, or even worse, not writing them
    at all, removes the guardrails for your project and defeats the purpose of the
    CI process you have carefully put in place.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes tests are not run because it is determined they take too much time.
    Use your CI server to regularly record how long test runs take and determine your
    acceptable threshold. As your project grows and you see the amount of time for
    builds increase beyond your acceptable threshold, stop to review your tests. Look
    for obsolete tests, duplicates, and tests that could be run in parallel. Considering
    how often you expect your build server to run (potentially after every code change),
    every second counts.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter presented continuous integration as an essential practice for a
    development team. Tools have developed over time that have helped increase our
    efficiency in building software projects. Automatically triggering builds as well
    as automatically running tests has helped developers better concentrate on coding
    and catch errant code earlier in the development process. It is easy to take for
    granted and enjoy the effort saved by automation, but it is important to understand
    the details underneath, especially when it comes to your test suite. Don’t let
    poorly maintained tests take away the benefit of your continuous integration system.
  prefs: []
  type: TYPE_NORMAL
