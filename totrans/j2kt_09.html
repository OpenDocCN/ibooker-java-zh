<html><head></head><body><section data-pdf-bookmark="Chapter 9. Multi- to Single-Expression Functions" data-type="chapter" epub:type="chapter"><div class="chapter" id="multi-to-single-expression-functions">&#13;
<h1><span class="label">Chapter 9. </span>Multi- to Single-Expression Functions</h1>&#13;
&#13;
<blockquote data-type="epigraph" epub:type="epigraph">&#13;
<p>Nat and Duncan both love Kotlin’s single-expression function definitions.&#13;
When should we use this form, why might we prefer it, and what Kotlin features can we use to make more functions single expressions?</p>&#13;
</blockquote>&#13;
&#13;
<p>As<a data-primary="multi- to single-expression functions" data-secondary="Java and Kotlin syntax" data-type="indexterm" id="idm46393397399464"/><a data-primary="{} (block function body)" data-type="indexterm" id="idm46393397398488"/><a data-primary="block function body ({})" data-type="indexterm" id="idm46393397397800"/> with Java, the code in a Kotlin function is usually { defined inside braces } and uses&#13;
<code>return</code> to define the result of the function (unless it is <code>Unit</code>, Kotlin’s alias for <code>void</code>):</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">add</code><code class="p">(</code><code class="n">a</code><code class="p">:</code> <code class="n">Int</code><code class="p">,</code> <code class="n">b</code><code class="p">:</code> <code class="n">Int</code><code class="p">):</code> <code class="n">Int</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="n">a</code> <code class="p">+</code> <code class="n">b</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>If<a data-primary="= (equals sign) in function declarations" data-type="indexterm" id="idm46393397374600"/><a data-primary="equals sign (=) in function declarations" data-type="indexterm" id="idm46393397373864"/> the top level of the code is a single expression though, we can optionally drop the result type, and define the code with an expression after an equals sign:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">addToo</code><code class="p">(</code><code class="n">a</code><code class="p">:</code> <code class="n">Int</code><code class="p">,</code> <code class="n">b</code><code class="p">:</code> <code class="n">Int</code><code class="p">):</code> <code class="n">Int</code> <code class="p">=</code> <code class="n">a</code> <code class="p">+</code> <code class="n">b</code></pre>&#13;
&#13;
<p>We<a data-primary="subexpressions" data-type="indexterm" id="idm46393397363864"/> can read this as: the result of function <code>add</code> equals <code>a + b</code>.&#13;
Which makes sense for a single expression, and can also read nicely when that expression is itself composed of subexpressions:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">max</code><code class="p">(</code><code class="n">a</code><code class="p">:</code> <code class="n">Int</code><code class="p">,</code> <code class="n">b</code><code class="p">:</code> <code class="n">Int</code><code class="p">):</code> <code class="n">Int</code> <code class="p">=</code>&#13;
    <code class="k">when</code> <code class="p">{</code>&#13;
        <code class="n">a</code> <code class="p">&gt;</code> <code class="n">b</code> <code class="p">-&gt;</code> <code class="n">a</code>&#13;
        <code class="k">else</code> <code class="p">-&gt;</code> <code class="n">b</code>&#13;
    <code class="p">}</code></pre>&#13;
&#13;
<p>This<a data-primary="side effects" data-type="indexterm" id="idm46393397287272"/> interpretation makes less sense for functions that have side effects, especially those that perform I/O or write to mutable state.&#13;
For instance:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">printTwice</code><code class="p">(</code><code class="n">s</code><code class="p">:</code> <code class="n">String</code><code class="p">):</code> <code class="n">Unit</code> <code class="p">=</code> <code class="n">println</code><code class="p">(</code><code class="s">"$s\n$s"</code><code class="p">)</code></pre>&#13;
&#13;
<p>We can’t read this as the result of <code>printTwice</code> equals <code>println(..)</code>, because <code>println</code> doesn’t have a result, or at least it doesn’t return one.&#13;
Its function is entirely side effects, as we explored in <a data-type="xref" href="ch07.html#actions-to-calculations">Chapter 7</a>.</p>&#13;
<div data-type="tip" id="single-expresssion-functions-for-calculations"><h1>Reserve Single-Expression Functions for Calculations</h1>&#13;
<p>If<a data-primary="calculations" data-secondary="reserving single-expression functions for" data-type="indexterm" id="idm46393397256824"/><a data-primary="single-expression functions" data-seealso="multi- to single-expression functions" data-type="indexterm" id="idm46393397255848"/><a data-primary="actions" data-secondary="single-expression functions and" data-type="indexterm" id="idm46393397254968"/> we adopt a convention of reserving single-expression functions for calculations (<a data-type="xref" href="ch07.html#calculations">“Calculations”</a>), then we have a way of communicating our intent when we use them.&#13;
When we see a single-expression function, we will know that it isn’t an action (<a data-type="xref" href="ch07.html#actions">“Actions”</a>), and so is much safer to refactor.</p>&#13;
&#13;
<p>In practice this means that single-expression functions shouldn’t return <code>Unit</code>, or read or write from mutable state, including performing I/O.</p>&#13;
</div>&#13;
&#13;
<p>Your<a data-primary="multi- to single-expression functions" data-secondary="benefits of single expressions" data-type="indexterm" id="idm46393397206520"/> authors have found that attempting to make as many functions as possible into single expressions improves our software.&#13;
For one thing, if we reserve the single-expression form for calculations, then this will decrease the proportion of our code that is <a href="ch07.html#actions">actions</a>, making it easier to understand and modify.&#13;
Single expressions will also tend to be shorter than the alternative, limiting the complexity of each function.&#13;
When a function does get too large to be easily understood, single-expression style lets us more easily refactor for clarity, because there is less risk of breaking logic that depends on side effects and the order in which actions are performed.</p>&#13;
&#13;
<p>We<a data-primary="multi- to single-expression functions" data-secondary="expressions versus statements" data-type="indexterm" id="idm46393397203320"/><a data-primary="expressions, versus statements" data-seealso="multi- to single-expression functions" data-type="indexterm" id="idm46393397202328"/><a data-primary="statements" data-secondary="versus expressions" data-type="indexterm" id="idm46393397201352"/> also prefer expressions as opposed to statements.&#13;
Expressions are <em>declarative</em>: we declare <em>what</em> we want the function to calculate and let the Kotlin compiler and runtime decide <em>how</em> to compute that calculation.&#13;
We don’t have to run the code in a simulated computer in our heads to figure out what the function does.</p>&#13;
&#13;
<p>For example, at the end of <a data-type="xref" href="ch03.html#java-to-kotlin-classes">Chapter 3</a> we were left with this code for <code>EmailAddress</code>:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">data</code> <code class="k">class</code> <code class="nc">EmailAddress</code><code class="p">(</code>&#13;
    <code class="k">val</code> <code class="py">localPart</code><code class="p">:</code> <code class="n">String</code><code class="p">,</code>&#13;
    <code class="k">val</code> <code class="py">domain</code><code class="p">:</code> <code class="n">String</code>&#13;
<code class="p">)</code> <code class="p">{</code>&#13;
&#13;
    <code class="k">override</code> <code class="k">fun</code> <code class="nf">toString</code><code class="p">()</code> <code class="p">=</code> <code class="s">"$localPart@$domain"</code>&#13;
&#13;
    <code class="n">companion</code> <code class="k">object</code> <code class="err">{</code>&#13;
        <code class="n">@JvmStatic</code>&#13;
        <code class="k">fun</code> <code class="nf">parse</code><code class="p">(</code><code class="n">value</code><code class="p">:</code> <code class="n">String</code><code class="p">):</code> <code class="n">EmailAddress</code> <code class="p">{</code>&#13;
            <code class="k">val</code> <code class="py">atIndex</code> <code class="p">=</code> <code class="n">value</code><code class="p">.</code><code class="n">lastIndexOf</code><code class="p">(</code><code class="sc">'@'</code><code class="p">)</code>&#13;
            <code class="n">require</code><code class="p">(!(</code><code class="n">atIndex</code> <code class="p">&lt;</code> <code class="m">1</code> <code class="p">||</code> <code class="n">atIndex</code> <code class="p">==</code> <code class="n">value</code><code class="p">.</code><code class="n">length</code> <code class="p">-</code> <code class="m">1</code><code class="p">))</code> <code class="p">{</code>&#13;
                <code class="s">"EmailAddress must be two parts separated by @"</code>&#13;
            <code class="p">}</code>&#13;
            <code class="k">return</code> <code class="n">EmailAddress</code><code class="p">(</code>&#13;
                <code class="n">value</code><code class="p">.</code><code class="n">substring</code><code class="p">(</code><code class="m">0</code><code class="p">,</code> <code class="n">atIndex</code><code class="p">),</code>&#13;
                <code class="n">value</code><code class="p">.</code><code class="n">substring</code><code class="p">(</code><code class="n">atIndex</code> <code class="p">+</code> <code class="m">1</code><code class="p">)</code>&#13;
            <code class="p">)</code>&#13;
        <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=9.1&amp;show=file">Example 9.1 [single-expressions.0:src/main/java/travelator/EmailAddress.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=9.1&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>The<a data-primary="toString method" data-type="indexterm" id="idm46393397092632"/> <code>toString</code> method is already a nice simple single expression.&#13;
As we said at the time though, the amount of code required in the <code>parse</code> method adds insult to the injury of having to declare static methods in a companion object.&#13;
Maybe focusing on making the function into a simple single expression would help?</p>&#13;
&#13;
<p>Before<a data-primary="refactoring" data-secondary="in real-life" data-secondary-sortas="real-life" data-type="indexterm" id="idm46393397090200"/> we go on, we should say that lots of the refactoring sequences presented in this book are of the form “Here’s one I prepared earlier.”&#13;
We show you the successful take.&#13;
Real-life refactorings, like writing code from scratch, aren’t like that.&#13;
We try things that don’t work at all, or we take a much more circuitous route than we show in the final edit.&#13;
Because<a data-primary="refactoring" data-secondary="multi- to single-expression functions" data-type="indexterm" id="Rmulti09"/><a data-primary="multi- to single-expression functions" data-secondary="step-by-step example" data-type="indexterm" id="MSEstep09"/> this is an otherwise small example, we’ve taken this opportunity to show what actually happened when we tried to convert <code>parse</code> to a single expression.&#13;
We think that there are valuable lessons in the journey, but if you just want the destination, you should skip ahead to <a data-type="xref" href="#take-4">“Take 4: Stepping Back”</a>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Take 1: Inlining" data-type="sect1"><div class="sect1" id="idm46393397084264">&#13;
<h1>Take 1: Inlining</h1>&#13;
&#13;
<p>Let’s analyze the code and see what is preventing this function from being a nice single expression:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code><code> </code><code class="nf">parse</code><code class="p">(</code><code class="n">value</code><code class="p">:</code><code> </code><code class="n">String</code><code class="p">)</code><code class="p">:</code><code> </code><code class="n">EmailAddress</code><code> </code><code class="p">{</code><code>&#13;
</code><code>    </code><code class="k">val</code><code> </code><code class="py">atIndex</code><code> </code><code class="p">=</code><code> </code><code class="n">value</code><code class="p">.</code><code class="n">lastIndexOf</code><code class="p">(</code><code class="sc">'@'</code><code class="p">)</code><code> </code><a class="co" href="#callout_introduction_CO16-1" id="co_introduction_CO16-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code>    </code><code class="n">require</code><code class="p">(</code><code class="p">!</code><code class="p">(</code><code class="n">atIndex</code><code> </code><code class="p">&lt;</code><code> </code><code class="m">1</code><code> </code><code class="p">|</code><code class="p">|</code><code> </code><code class="n">atIndex</code><code> </code><code class="p">=</code><code class="p">=</code><code> </code><code class="n">value</code><code class="p">.</code><code class="n">length</code><code> </code><code class="p">-</code><code> </code><code class="m">1</code><code class="p">)</code><code class="p">)</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_introduction_CO16-2" id="co_introduction_CO16-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
</code><code>        </code><code class="s">"EmailAddress must be two parts separated by @"</code><code>&#13;
</code><code>    </code><code class="p">}</code><code>&#13;
</code><code>    </code><code class="k">return</code><code> </code><code class="n">EmailAddress</code><code class="p">(</code><code> </code><a class="co" href="#callout_introduction_CO16-3" id="co_introduction_CO16-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
</code><code>        </code><code class="n">value</code><code class="p">.</code><code class="n">substring</code><code class="p">(</code><code class="m">0</code><code class="p">,</code><code> </code><code class="n">atIndex</code><code class="p">)</code><code class="p">,</code><code>&#13;
</code><code>        </code><code class="n">value</code><code class="p">.</code><code class="n">substring</code><code class="p">(</code><code class="n">atIndex</code><code> </code><code class="p">+</code><code> </code><code class="m">1</code><code class="p">)</code><code>&#13;
</code><code>    </code><code class="p">)</code><code>&#13;
</code><code class="p">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=9.2&amp;show=file">Example 9.2 [single-expressions.1:src/main/java/travelator/EmailAddress.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=9.2&amp;show=diff">(diff)</a>&#13;
</div>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_introduction_CO16-1" id="callout_introduction_CO16-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Assigning to <code>atIndex</code> is a statement.</p></dd>&#13;
<dt><a class="co" href="#co_introduction_CO16-2" id="callout_introduction_CO16-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>The call to <code>require</code> is a statement.</p></dd>&#13;
<dt><a class="co" href="#co_introduction_CO16-3" id="callout_introduction_CO16-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Creating the <code>EmailAddress</code> is a single expression, depending on <code>value</code> and <code>atIndex</code>.</p></dd>&#13;
</dl>&#13;
&#13;
<p>The first statement is the assignment to <code>atIndex</code>.&#13;
In Kotlin, assignment is a statement, not an expression (unlike Java, where we can chain assignments).&#13;
Its position in the code also matters—it has to happen here in the code for the value of <code>atIndex</code> to be available to compile the rest of the function.&#13;
The expression bound to the variable, <code>value.lastIndexOf(Char)</code>, is a calculation though, meaning that it will always return the same result for the same arguments (<code>this</code> is considered an argument when we call methods).&#13;
As a result, we can inline the variable <code>atIndex</code> without changing the result of the function, giving:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">parse</code><code class="p">(</code><code class="n">value</code><code class="p">:</code> <code class="n">String</code><code class="p">):</code> <code class="n">EmailAddress</code> <code class="p">{</code>&#13;
    <code class="n">require</code><code class="p">(!(</code>&#13;
        <code class="n">value</code><code class="p">.</code><code class="n">lastIndexOf</code><code class="p">(</code><code class="sc">'@'</code><code class="p">)</code> <code class="p">&lt;</code> <code class="m">1</code> <code class="p">||</code>&#13;
            <code class="n">value</code><code class="p">.</code><code class="n">lastIndexOf</code><code class="p">(</code><code class="sc">'@'</code><code class="p">)</code> <code class="p">==</code> <code class="n">value</code><code class="p">.</code><code class="n">length</code> <code class="p">-</code> <code class="m">1</code><code class="p">))</code> <code class="p">{</code>&#13;
        <code class="s">"EmailAddress must be two parts separated by @"</code>&#13;
    <code class="p">}</code>&#13;
    <code class="k">return</code> <code class="n">EmailAddress</code><code class="p">(</code>&#13;
        <code class="n">value</code><code class="p">.</code><code class="n">substring</code><code class="p">(</code><code class="m">0</code><code class="p">,</code> <code class="n">value</code><code class="p">.</code><code class="n">lastIndexOf</code><code class="p">(</code><code class="sc">'@'</code><code class="p">)),</code>&#13;
        <code class="n">value</code><code class="p">.</code><code class="n">substring</code><code class="p">(</code><code class="n">value</code><code class="p">.</code><code class="n">lastIndexOf</code><code class="p">(</code><code class="sc">'@'</code><code class="p">)</code> <code class="p">+</code> <code class="m">1</code><code class="p">)</code>&#13;
    <code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=9.3&amp;show=file">Example 9.3 [single-expressions.2:src/main/java/travelator/EmailAddress.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=9.3&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>This version won’t produce the same bytecode, nor run as fast (probably, it’s notoriously difficult to second-guess HotSpot), but it will return the same result.&#13;
We still have that <code>require</code> call to deal with, though, and we seem to have made everything a bit less understandable already,  so let’s revert the change and try another tack.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Take 2: Introduce a Function" data-type="sect1"><div class="sect1" id="idm46393396826904">&#13;
<h1>Take 2: Introduce a Function</h1>&#13;
&#13;
<p>Another way to remove the assignment statement is to have a scope where <code>atIndex</code> is always defined.&#13;
We could use a function as such a scope, because a function binds a single evaluation of its arguments to its parameters.&#13;
We can see this by selecting all but the code before the assignment and extracting a function <code>emailAddress</code>:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">parse</code><code class="p">(</code><code class="n">value</code><code class="p">:</code> <code class="n">String</code><code class="p">):</code> <code class="n">EmailAddress</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="py">atIndex</code> <code class="p">=</code> <code class="n">value</code><code class="p">.</code><code class="n">lastIndexOf</code><code class="p">(</code><code class="sc">'@'</code><code class="p">)</code>&#13;
    <code class="k">return</code> <code class="n">emailAddress</code><code class="p">(</code><code class="n">value</code><code class="p">,</code> <code class="n">atIndex</code><code class="p">)</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="k">private</code> <code class="k">fun</code> <code class="nf">emailAddress</code><code class="p">(</code><code class="n">value</code><code class="p">:</code> <code class="n">String</code><code class="p">,</code> <code class="n">atIndex</code><code class="p">:</code> <code class="n">Int</code><code class="p">):</code> <code class="n">EmailAddress</code> <code class="p">{</code>&#13;
    <code class="n">require</code><code class="p">(!(</code><code class="n">atIndex</code> <code class="p">&lt;</code> <code class="m">1</code> <code class="p">||</code> <code class="n">atIndex</code> <code class="p">==</code> <code class="n">value</code><code class="p">.</code><code class="n">length</code> <code class="p">-</code> <code class="m">1</code><code class="p">))</code> <code class="p">{</code>&#13;
        <code class="s">"EmailAddress must be two parts separated by @"</code>&#13;
    <code class="p">}</code>&#13;
    <code class="k">return</code> <code class="n">EmailAddress</code><code class="p">(</code>&#13;
        <code class="n">value</code><code class="p">.</code><code class="n">substring</code><code class="p">(</code><code class="m">0</code><code class="p">,</code> <code class="n">atIndex</code><code class="p">),</code>&#13;
        <code class="n">value</code><code class="p">.</code><code class="n">substring</code><code class="p">(</code><code class="n">atIndex</code> <code class="p">+</code> <code class="m">1</code><code class="p">)</code>&#13;
    <code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=9.4&amp;show=file">Example 9.4 [single-expressions.3:src/main/java/travelator/EmailAddress.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=9.4&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>Now we can inline the <code>atIndex</code> variable in <code>parse</code>, because the <code>atIndex</code> parameter has captured its value for us:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">parse</code><code class="p">(</code><code class="n">value</code><code class="p">:</code> <code class="n">String</code><code class="p">):</code> <code class="n">EmailAddress</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="n">emailAddress</code><code class="p">(</code><code class="n">value</code><code class="p">,</code> <code class="n">value</code><code class="p">.</code><code class="n">lastIndexOf</code><code class="p">(</code><code class="sc">'@'</code><code class="p">))</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="k">private</code> <code class="k">fun</code> <code class="nf">emailAddress</code><code class="p">(</code><code class="n">value</code><code class="p">:</code> <code class="n">String</code><code class="p">,</code> <code class="n">atIndex</code><code class="p">:</code> <code class="n">Int</code><code class="p">):</code> <code class="n">EmailAddress</code> <code class="p">{</code>&#13;
    <code class="n">require</code><code class="p">(!(</code><code class="n">atIndex</code> <code class="p">&lt;</code> <code class="m">1</code> <code class="p">||</code> <code class="n">atIndex</code> <code class="p">==</code> <code class="n">value</code><code class="p">.</code><code class="n">length</code> <code class="p">-</code> <code class="m">1</code><code class="p">))</code> <code class="p">{</code>&#13;
        <code class="s">"EmailAddress must be two parts separated by @"</code>&#13;
    <code class="p">}</code>&#13;
    <code class="k">return</code> <code class="n">EmailAddress</code><code class="p">(</code>&#13;
        <code class="n">value</code><code class="p">.</code><code class="n">substring</code><code class="p">(</code><code class="m">0</code><code class="p">,</code> <code class="n">atIndex</code><code class="p">),</code>&#13;
        <code class="n">value</code><code class="p">.</code><code class="n">substring</code><code class="p">(</code><code class="n">atIndex</code> <code class="p">+</code> <code class="m">1</code><code class="p">)</code>&#13;
    <code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=9.5&amp;show=file">Example 9.5 [single-expressions.4:src/main/java/travelator/EmailAddress.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=9.5&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>Now <code>parse</code> is a single expression, but <code>emailAddress(...)</code> isn’t, so we can’t declare victory just yet.&#13;
That <code>require</code> is always going to cause us some problems, because its job is to prevent evaluation from proceeding.&#13;
This is the opposite of an expression, which needs to evaluate to a value.</p>&#13;
&#13;
<p>Often when we reach this sort of impasse when refactoring, inlining the cause of the problem will let us see the way ahead.&#13;
So let’s inline <code>require</code>.&#13;
(Suspend disbelief for now; things are going to get worse before they get better.)</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">private</code> <code class="k">fun</code> <code class="nf">emailAddress</code><code class="p">(</code><code class="n">value</code><code class="p">:</code> <code class="n">String</code><code class="p">,</code> <code class="n">atIndex</code><code class="p">:</code> <code class="n">Int</code><code class="p">):</code> <code class="n">EmailAddress</code> <code class="p">{</code>&#13;
    <code class="k">if</code> <code class="p">(</code><code class="o">!!</code><code class="p">(</code><code class="n">atIndex</code> <code class="p">&lt;</code> <code class="m">1</code> <code class="p">||</code> <code class="n">atIndex</code> <code class="p">==</code> <code class="n">value</code><code class="p">.</code><code class="n">length</code> <code class="p">-</code> <code class="m">1</code><code class="p">))</code> <code class="p">{</code>&#13;
        <code class="k">val</code> <code class="py">message</code> <code class="p">=</code> <code class="s">"EmailAddress must be two parts separated by @"</code>&#13;
        <code class="k">throw</code> <code class="n">IllegalArgumentException</code><code class="p">(</code><code class="n">message</code><code class="p">.</code><code class="n">toString</code><code class="p">())</code>&#13;
    <code class="p">}</code>&#13;
    <code class="k">return</code> <code class="n">EmailAddress</code><code class="p">(</code>&#13;
        <code class="n">value</code><code class="p">.</code><code class="n">substring</code><code class="p">(</code><code class="m">0</code><code class="p">,</code> <code class="n">atIndex</code><code class="p">),</code>&#13;
        <code class="n">value</code><code class="p">.</code><code class="n">substring</code><code class="p">(</code><code class="n">atIndex</code> <code class="p">+</code> <code class="m">1</code><code class="p">)</code>&#13;
    <code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=9.6&amp;show=file">Example 9.6 [single-expressions.5:src/main/java/travelator/EmailAddress.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=9.6&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>There’s an awful lot of redundancy that we can remove here.&#13;
Alt-Enter on the <code>if</code> condition will remove the double-negation <code>!!</code>, and then Alt-Enter on the redundant <code>toString</code> will remove it.&#13;
This allows us to inline <code>message</code>, yielding:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">private</code> <code class="k">fun</code> <code class="nf">emailAddress</code><code class="p">(</code><code class="n">value</code><code class="p">:</code> <code class="n">String</code><code class="p">,</code> <code class="n">atIndex</code><code class="p">:</code> <code class="n">Int</code><code class="p">):</code> <code class="n">EmailAddress</code> <code class="p">{</code>&#13;
    <code class="k">if</code> <code class="p">((</code><code class="n">atIndex</code> <code class="p">&lt;</code> <code class="m">1</code> <code class="p">||</code> <code class="n">atIndex</code> <code class="p">==</code> <code class="n">value</code><code class="p">.</code><code class="n">length</code> <code class="p">-</code> <code class="m">1</code><code class="p">))</code> <code class="p">{</code>&#13;
        <code class="k">throw</code> <code class="n">IllegalArgumentException</code><code class="p">(</code>&#13;
            <code class="s">"EmailAddress must be two parts separated by @"</code>&#13;
        <code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
    <code class="k">return</code> <code class="n">EmailAddress</code><code class="p">(</code>&#13;
        <code class="n">value</code><code class="p">.</code><code class="n">substring</code><code class="p">(</code><code class="m">0</code><code class="p">,</code> <code class="n">atIndex</code><code class="p">),</code>&#13;
        <code class="n">value</code><code class="p">.</code><code class="n">substring</code><code class="p">(</code><code class="n">atIndex</code> <code class="p">+</code> <code class="m">1</code><code class="p">)</code>&#13;
    <code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=9.7&amp;show=file">Example 9.7 [single-expressions.6:src/main/java/travelator/EmailAddress.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=9.7&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p class="pagebreak-before">Now we can introduce an <code>else</code> to see the structure:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">private</code> <code class="k">fun</code> <code class="nf">emailAddress</code><code class="p">(</code><code class="n">value</code><code class="p">:</code> <code class="n">String</code><code class="p">,</code> <code class="n">atIndex</code><code class="p">:</code> <code class="n">Int</code><code class="p">):</code> <code class="n">EmailAddress</code> <code class="p">{</code>&#13;
    <code class="k">if</code> <code class="p">((</code><code class="n">atIndex</code> <code class="p">&lt;</code> <code class="m">1</code> <code class="p">||</code> <code class="n">atIndex</code> <code class="p">==</code> <code class="n">value</code><code class="p">.</code><code class="n">length</code> <code class="p">-</code> <code class="m">1</code><code class="p">))</code> <code class="p">{</code>&#13;
        <code class="k">throw</code> <code class="n">IllegalArgumentException</code><code class="p">(</code>&#13;
            <code class="s">"EmailAddress must be two parts separated by @"</code>&#13;
        <code class="p">)</code>&#13;
    <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>&#13;
        <code class="k">return</code> <code class="n">EmailAddress</code><code class="p">(</code>&#13;
            <code class="n">value</code><code class="p">.</code><code class="n">substring</code><code class="p">(</code><code class="m">0</code><code class="p">,</code> <code class="n">atIndex</code><code class="p">),</code>&#13;
            <code class="n">value</code><code class="p">.</code><code class="n">substring</code><code class="p">(</code><code class="n">atIndex</code> <code class="p">+</code> <code class="m">1</code><code class="p">)</code>&#13;
        <code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=9.8&amp;show=file">Example 9.8 [single-expressions.7:src/main/java/travelator/EmailAddress.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=9.8&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>At this point we have a function with two statements chosen by an <code>if</code>.&#13;
This is so tantalizingly close to a single expression that even the IDE can feel it: Alt-Enter on the <code>if</code>, and IntelliJ offers to “Lift return out of ‘if’”:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">private</code> <code class="k">fun</code> <code class="nf">emailAddress</code><code class="p">(</code><code class="n">value</code><code class="p">:</code> <code class="n">String</code><code class="p">,</code> <code class="n">atIndex</code><code class="p">:</code> <code class="n">Int</code><code class="p">):</code> <code class="n">EmailAddress</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="k">if</code> <code class="p">((</code><code class="n">atIndex</code> <code class="p">&lt;</code> <code class="m">1</code> <code class="p">||</code> <code class="n">atIndex</code> <code class="p">==</code> <code class="n">value</code><code class="p">.</code><code class="n">length</code> <code class="p">-</code> <code class="m">1</code><code class="p">))</code> <code class="p">{</code>&#13;
        <code class="k">throw</code> <code class="n">IllegalArgumentException</code><code class="p">(</code>&#13;
            <code class="s">"EmailAddress must be two parts separated by @"</code>&#13;
        <code class="p">)</code>&#13;
    <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>&#13;
        <code class="n">EmailAddress</code><code class="p">(</code>&#13;
            <code class="n">value</code><code class="p">.</code><code class="n">substring</code><code class="p">(</code><code class="m">0</code><code class="p">,</code> <code class="n">atIndex</code><code class="p">),</code>&#13;
            <code class="n">value</code><code class="p">.</code><code class="n">substring</code><code class="p">(</code><code class="n">atIndex</code> <code class="p">+</code> <code class="m">1</code><code class="p">)</code>&#13;
        <code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=9.9&amp;show=file">Example 9.9 [single-expressions.8:src/main/java/travelator/EmailAddress.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=9.9&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>There it is—our single expression.&#13;
Alt-Enter on the <code>return</code> offers “Convert to expression body”:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">private</code> <code class="k">fun</code> <code class="nf">emailAddress</code><code class="p">(</code><code class="n">value</code><code class="p">:</code> <code class="n">String</code><code class="p">,</code> <code class="n">atIndex</code><code class="p">:</code> <code class="n">Int</code><code class="p">):</code> <code class="n">EmailAddress</code> <code class="p">=</code>&#13;
    <code class="k">if</code> <code class="p">((</code><code class="n">atIndex</code> <code class="p">&lt;</code> <code class="m">1</code> <code class="p">||</code> <code class="n">atIndex</code> <code class="p">==</code> <code class="n">value</code><code class="p">.</code><code class="n">length</code> <code class="p">-</code> <code class="m">1</code><code class="p">))</code> <code class="p">{</code>&#13;
        <code class="k">throw</code> <code class="n">IllegalArgumentException</code><code class="p">(</code>&#13;
            <code class="s">"EmailAddress must be two parts separated by @"</code>&#13;
        <code class="p">)</code>&#13;
    <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>&#13;
        <code class="n">EmailAddress</code><code class="p">(</code>&#13;
            <code class="n">value</code><code class="p">.</code><code class="n">substring</code><code class="p">(</code><code class="m">0</code><code class="p">,</code> <code class="n">atIndex</code><code class="p">),</code>&#13;
            <code class="n">value</code><code class="p">.</code><code class="n">substring</code><code class="p">(</code><code class="n">atIndex</code> <code class="p">+</code> <code class="m">1</code><code class="p">)</code>&#13;
        <code class="p">)</code>&#13;
    <code class="p">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=9.10&amp;show=file">Example 9.10 [single-expressions.9:src/main/java/travelator/EmailAddress.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=9.10&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>When we’re defining a function as a single expression, <code>when</code> is often clearer than <code>if</code>.&#13;
IntelliJ will do this for us if we Alt-Enter on the <code>if</code>.&#13;
Here we’ve also removed unnecessary braces, inlined <code>message</code>, and finally converted <code>parse</code> to a single expression too:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">parse</code><code class="p">(</code><code class="n">value</code><code class="p">:</code> <code class="n">String</code><code class="p">)</code> <code class="p">=</code>&#13;
    <code class="n">emailAddress</code><code class="p">(</code><code class="n">value</code><code class="p">,</code> <code class="n">value</code><code class="p">.</code><code class="n">lastIndexOf</code><code class="p">(</code><code class="sc">'@'</code><code class="p">))</code>&#13;
&#13;
<code class="k">private</code> <code class="k">fun</code> <code class="nf">emailAddress</code><code class="p">(</code><code class="n">value</code><code class="p">:</code> <code class="n">String</code><code class="p">,</code> <code class="n">atIndex</code><code class="p">:</code> <code class="n">Int</code><code class="p">):</code> <code class="n">EmailAddress</code> <code class="p">=</code>&#13;
    <code class="k">when</code> <code class="p">{</code>&#13;
        <code class="n">atIndex</code> <code class="p">&lt;</code> <code class="m">1</code> <code class="p">||</code> <code class="n">atIndex</code> <code class="p">==</code> <code class="n">value</code><code class="p">.</code><code class="n">length</code> <code class="p">-</code> <code class="m">1</code> <code class="p">-&gt;</code>&#13;
            <code class="k">throw</code> <code class="n">IllegalArgumentException</code><code class="p">(</code>&#13;
                <code class="s">"EmailAddress must be two parts separated by @"</code>&#13;
            <code class="p">)</code>&#13;
        <code class="k">else</code> <code class="p">-&gt;</code> <code class="n">EmailAddress</code><code class="p">(</code>&#13;
            <code class="n">value</code><code class="p">.</code><code class="n">substring</code><code class="p">(</code><code class="m">0</code><code class="p">,</code> <code class="n">atIndex</code><code class="p">),</code>&#13;
            <code class="n">value</code><code class="p">.</code><code class="n">substring</code><code class="p">(</code><code class="n">atIndex</code> <code class="p">+</code> <code class="m">1</code><code class="p">)</code>&#13;
        <code class="p">)</code>&#13;
    <code class="p">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=9.11&amp;show=file">Example 9.11 [single-expressions.10:src/main/java/travelator/EmailAddress.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=9.11&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>For comparison, here is the original:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">parse</code><code class="p">(</code><code class="n">value</code><code class="p">:</code> <code class="n">String</code><code class="p">):</code> <code class="n">EmailAddress</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="py">atIndex</code> <code class="p">=</code> <code class="n">value</code><code class="p">.</code><code class="n">lastIndexOf</code><code class="p">(</code><code class="sc">'@'</code><code class="p">)</code>&#13;
    <code class="n">require</code><code class="p">(!(</code><code class="n">atIndex</code> <code class="p">&lt;</code> <code class="m">1</code> <code class="p">||</code> <code class="n">atIndex</code> <code class="p">==</code> <code class="n">value</code><code class="p">.</code><code class="n">length</code> <code class="p">-</code> <code class="m">1</code><code class="p">))</code> <code class="p">{</code>&#13;
        <code class="s">"EmailAddress must be two parts separated by @"</code>&#13;
    <code class="p">}</code>&#13;
    <code class="k">return</code> <code class="n">EmailAddress</code><code class="p">(</code>&#13;
        <code class="n">value</code><code class="p">.</code><code class="n">substring</code><code class="p">(</code><code class="m">0</code><code class="p">,</code> <code class="n">atIndex</code><code class="p">),</code>&#13;
        <code class="n">value</code><code class="p">.</code><code class="n">substring</code><code class="p">(</code><code class="n">atIndex</code> <code class="p">+</code> <code class="m">1</code><code class="p">)</code>&#13;
    <code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=9.12&amp;show=file">Example 9.12 [single-expressions.11:src/main/java/travelator/EmailAddress.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=9.12&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>Are we happy with the result?</p>&#13;
&#13;
<p>Not really.&#13;
We now have <em>more</em> code, and that <code>emailAddress</code> function doesn’t feel like it’s adding any value except for capturing <code>atIndex</code>.</p>&#13;
&#13;
<p>Refactoring is often a process of exploration.&#13;
We have a goal in mind, but don’t always know how it will turn out.&#13;
It’s our (your authors’) experience that trying to find a single-expression form of a function often improves our code, but we can’t look you in the eye and say that has happened here.</p>&#13;
&#13;
<p>We could give up on the idea, or we could push on and try to get there from here.&#13;
Instead though, let’s revert and try a third approach, informed by the experience we’ve just gained.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Take 3: Let" data-type="sect1"><div class="sect1" id="idm46393396825960">&#13;
<h1>Take 3: Let</h1>&#13;
&#13;
<p>The reason we extracted the <code>emailAddress</code> function was to give us a scope where the <code>atIndex</code> value is defined throughout the block; rather than having to be assigned to a local variable.&#13;
Where we only have one variable we need to replace, a <code>let</code> block gives us this facility without having to define a function.&#13;
We can get there in baby steps by first surrounding the code after the assignment with a <code>let</code>:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">parse</code><code class="p">(</code><code class="n">value</code><code class="p">:</code> <code class="n">String</code><code class="p">):</code> <code class="n">EmailAddress</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="py">atIndex</code> <code class="p">=</code> <code class="n">value</code><code class="p">.</code><code class="n">lastIndexOf</code><code class="p">(</code><code class="sc">'@'</code><code class="p">)</code>&#13;
    <code class="n">atIndex</code><code class="p">.</code><code class="n">let</code> <code class="p">{</code>&#13;
        <code class="n">require</code><code class="p">(!(</code><code class="n">atIndex</code> <code class="p">&lt;</code> <code class="m">1</code> <code class="p">||</code> <code class="n">atIndex</code> <code class="p">==</code> <code class="n">value</code><code class="p">.</code><code class="n">length</code> <code class="p">-</code> <code class="m">1</code><code class="p">))</code> <code class="p">{</code>&#13;
            <code class="s">"EmailAddress must be two parts separated by @"</code>&#13;
        <code class="p">}</code>&#13;
        <code class="k">return</code> <code class="n">EmailAddress</code><code class="p">(</code>&#13;
            <code class="n">value</code><code class="p">.</code><code class="n">substring</code><code class="p">(</code><code class="m">0</code><code class="p">,</code> <code class="n">atIndex</code><code class="p">),</code>&#13;
            <code class="n">value</code><code class="p">.</code><code class="n">substring</code><code class="p">(</code><code class="n">atIndex</code> <code class="p">+</code> <code class="m">1</code><code class="p">)</code>&#13;
        <code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=9.13&amp;show=file">Example 9.13 [single-expressions.12:src/main/java/travelator/EmailAddress.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=9.13&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>Now we can lift the return out of the <code>let</code>; unfortunately IntelliJ doesn’t offer to help us this time:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">parse</code><code class="p">(</code><code class="n">value</code><code class="p">:</code> <code class="n">String</code><code class="p">):</code> <code class="n">EmailAddress</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="py">atIndex</code> <code class="p">=</code> <code class="n">value</code><code class="p">.</code><code class="n">lastIndexOf</code><code class="p">(</code><code class="sc">'@'</code><code class="p">)</code>&#13;
    <code class="k">return</code> <code class="n">atIndex</code><code class="p">.</code><code class="n">let</code> <code class="p">{</code>&#13;
        <code class="n">require</code><code class="p">(!(</code><code class="n">atIndex</code> <code class="p">&lt;</code> <code class="m">1</code> <code class="p">||</code> <code class="n">atIndex</code> <code class="p">==</code> <code class="n">value</code><code class="p">.</code><code class="n">length</code> <code class="p">-</code> <code class="m">1</code><code class="p">))</code> <code class="p">{</code>&#13;
            <code class="s">"EmailAddress must be two parts separated by @"</code>&#13;
        <code class="p">}</code>&#13;
        <code class="n">EmailAddress</code><code class="p">(</code>&#13;
            <code class="n">value</code><code class="p">.</code><code class="n">substring</code><code class="p">(</code><code class="m">0</code><code class="p">,</code> <code class="n">atIndex</code><code class="p">),</code>&#13;
            <code class="n">value</code><code class="p">.</code><code class="n">substring</code><code class="p">(</code><code class="n">atIndex</code> <code class="p">+</code> <code class="m">1</code><code class="p">)</code>&#13;
        <code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=9.14&amp;show=file">Example 9.14 [single-expressions.13:src/main/java/travelator/EmailAddress.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=9.14&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>Currently, <code>atIndex</code> in the <code>let</code> block refers to the local that we are trying to remove.&#13;
If we add a lambda parameter with the same name, it will bind to that instead:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code><code> </code><code class="nf">parse</code><code class="p">(</code><code class="n">value</code><code class="p">:</code><code> </code><code class="n">String</code><code class="p">)</code><code class="p">:</code><code> </code><code class="n">EmailAddress</code><code> </code><code class="p">{</code><code>&#13;
</code><code>    </code><code class="k">val</code><code> </code><code class="py">atIndex</code><code> </code><code class="p">=</code><code> </code><code class="n">value</code><code class="p">.</code><code class="n">lastIndexOf</code><code class="p">(</code><code class="sc">'@'</code><code class="p">)</code><code>&#13;
</code><code>    </code><code class="k">return</code><code> </code><code class="n">atIndex</code><code class="p">.</code><code class="n">let</code><code> </code><code class="p">{</code><code> </code><code class="n">atIndex</code><code> </code><code class="p">-</code><code class="p">&gt;</code><code> </code><a class="co" href="#callout_introduction_CO17-1" id="co_introduction_CO17-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code>        </code><code class="n">require</code><code class="p">(</code><code class="p">!</code><code class="p">(</code><code class="n">atIndex</code><code> </code><code class="p">&lt;</code><code> </code><code class="m">1</code><code> </code><code class="p">|</code><code class="p">|</code><code> </code><code class="n">atIndex</code><code> </code><code class="p">=</code><code class="p">=</code><code> </code><code class="n">value</code><code class="p">.</code><code class="n">length</code><code> </code><code class="p">-</code><code> </code><code class="m">1</code><code class="p">)</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
</code><code>            </code><code class="s">"EmailAddress must be two parts separated by @"</code><code>&#13;
</code><code>        </code><code class="p">}</code><code>&#13;
</code><code>        </code><code class="n">EmailAddress</code><code class="p">(</code><code>&#13;
</code><code>            </code><code class="n">value</code><code class="p">.</code><code class="n">substring</code><code class="p">(</code><code class="m">0</code><code class="p">,</code><code> </code><code class="n">atIndex</code><code class="p">)</code><code class="p">,</code><code>&#13;
</code><code>            </code><code class="n">value</code><code class="p">.</code><code class="n">substring</code><code class="p">(</code><code class="n">atIndex</code><code> </code><code class="p">+</code><code> </code><code class="m">1</code><code class="p">)</code><code>&#13;
</code><code>        </code><code class="p">)</code><code>&#13;
</code><code>    </code><code class="p">}</code><code>&#13;
</code><code class="p">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=9.15&amp;show=file">Example 9.15 [single-expressions.14:src/main/java/travelator/EmailAddress.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=9.15&amp;show=diff">(diff)</a>&#13;
</div>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_introduction_CO17-1" id="callout_introduction_CO17-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p><code>Warning Name shadowed: atIndex</code>, which is the point</p></dd>&#13;
</dl>&#13;
&#13;
<p>Inline the <code>atIndex</code> variable and we have our single expression:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">parse</code><code class="p">(</code><code class="n">value</code><code class="p">:</code> <code class="n">String</code><code class="p">):</code> <code class="n">EmailAddress</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="n">value</code><code class="p">.</code><code class="n">lastIndexOf</code><code class="p">(</code><code class="sc">'@'</code><code class="p">).</code><code class="n">let</code> <code class="p">{</code> <code class="n">atIndex</code> <code class="p">-&gt;</code>&#13;
        <code class="n">require</code><code class="p">(!(</code><code class="n">atIndex</code> <code class="p">&lt;</code> <code class="m">1</code> <code class="p">||</code> <code class="n">atIndex</code> <code class="p">==</code> <code class="n">value</code><code class="p">.</code><code class="n">length</code> <code class="p">-</code> <code class="m">1</code><code class="p">))</code> <code class="p">{</code>&#13;
            <code class="s">"EmailAddress must be two parts separated by @"</code>&#13;
        <code class="p">}</code>&#13;
        <code class="n">EmailAddress</code><code class="p">(</code>&#13;
            <code class="n">value</code><code class="p">.</code><code class="n">substring</code><code class="p">(</code><code class="m">0</code><code class="p">,</code> <code class="n">atIndex</code><code class="p">),</code>&#13;
            <code class="n">value</code><code class="p">.</code><code class="n">substring</code><code class="p">(</code><code class="n">atIndex</code> <code class="p">+</code> <code class="m">1</code><code class="p">)</code>&#13;
        <code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=9.16&amp;show=file">Example 9.16 [single-expressions.15:src/main/java/travelator/EmailAddress.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=9.16&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>Now Alt-Enter on the return lets us “Convert to expression body”:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">parse</code><code class="p">(</code><code class="n">value</code><code class="p">:</code> <code class="n">String</code><code class="p">):</code> <code class="n">EmailAddress</code> <code class="p">=</code>&#13;
    <code class="n">value</code><code class="p">.</code><code class="n">lastIndexOf</code><code class="p">(</code><code class="sc">'@'</code><code class="p">).</code><code class="n">let</code> <code class="p">{</code> <code class="n">atIndex</code> <code class="p">-&gt;</code>&#13;
        <code class="n">require</code><code class="p">(!(</code><code class="n">atIndex</code> <code class="p">&lt;</code> <code class="m">1</code> <code class="p">||</code> <code class="n">atIndex</code> <code class="p">==</code> <code class="n">value</code><code class="p">.</code><code class="n">length</code> <code class="p">-</code> <code class="m">1</code><code class="p">))</code> <code class="p">{</code>&#13;
            <code class="s">"EmailAddress must be two parts separated by @"</code>&#13;
        <code class="p">}</code>&#13;
        <code class="n">EmailAddress</code><code class="p">(</code>&#13;
            <code class="n">value</code><code class="p">.</code><code class="n">substring</code><code class="p">(</code><code class="m">0</code><code class="p">,</code> <code class="n">atIndex</code><code class="p">),</code>&#13;
            <code class="n">value</code><code class="p">.</code><code class="n">substring</code><code class="p">(</code><code class="n">atIndex</code> <code class="p">+</code> <code class="m">1</code><code class="p">)</code>&#13;
        <code class="p">)</code>&#13;
    <code class="p">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=9.17&amp;show=file">Example 9.17 [single-expressions.16:src/main/java/travelator/EmailAddress.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=9.17&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>We’ve reached the point of no return!&#13;
Are we happy with the result?</p>&#13;
&#13;
<p>Duncan is writing this, and he <em>is</em> pretty relieved to have made it here after 15 refactoring steps.&#13;
The example has certainly served its purpose of showing some tricks to allow us to get to single-expression functions.&#13;
Nevertheless, he isn’t convinced that it has demonstrated that seeking single expressions has a significant payoff.&#13;
This still seems to be a lot of code, and none of it feels like it is earning its keep.</p>&#13;
&#13;
<p>Can we make this better by raising the level of abstraction?&#13;
Let’s try a fourth tack.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="pagebreak-before less_space" data-pdf-bookmark="Take 4: Stepping Back" data-type="sect1"><div class="sect1" id="take-4">&#13;
<h1>Take 4: Stepping Back</h1>&#13;
&#13;
<p>If we step out from the mechanical refactorings, we can see that what we are doing is creating an <code>EmailAddress</code> from two nonempty strings separated by a particular character, <code>@</code> in this case.&#13;
Finding two nonempty strings separated by a character sounds like a higher-level concept that we could refactor toward.</p>&#13;
&#13;
<p>One last revert, then, back to:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">parse</code><code class="p">(</code><code class="n">value</code><code class="p">:</code> <code class="n">String</code><code class="p">):</code> <code class="n">EmailAddress</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="py">atIndex</code> <code class="p">=</code> <code class="n">value</code><code class="p">.</code><code class="n">lastIndexOf</code><code class="p">(</code><code class="sc">'@'</code><code class="p">)</code>&#13;
    <code class="n">require</code><code class="p">(!(</code><code class="n">atIndex</code> <code class="p">&lt;</code> <code class="m">1</code> <code class="p">||</code> <code class="n">atIndex</code> <code class="p">==</code> <code class="n">value</code><code class="p">.</code><code class="n">length</code> <code class="p">-</code> <code class="m">1</code><code class="p">))</code> <code class="p">{</code>&#13;
        <code class="s">"EmailAddress must be two parts separated by @"</code>&#13;
    <code class="p">}</code>&#13;
    <code class="k">return</code> <code class="n">EmailAddress</code><code class="p">(</code>&#13;
        <code class="n">value</code><code class="p">.</code><code class="n">substring</code><code class="p">(</code><code class="m">0</code><code class="p">,</code> <code class="n">atIndex</code><code class="p">),</code>&#13;
        <code class="n">value</code><code class="p">.</code><code class="n">substring</code><code class="p">(</code><code class="n">atIndex</code> <code class="p">+</code> <code class="m">1</code><code class="p">)</code>&#13;
    <code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=9.18&amp;show=file">Example 9.18 [single-expressions.17:src/main/java/travelator/EmailAddress.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=9.18&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>This time we’ll concentrate not on <code>atIndex</code>, but on those <code>substring</code> calls.&#13;
We’ll pull them out into variables:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">parse</code><code class="p">(</code><code class="n">value</code><code class="p">:</code> <code class="n">String</code><code class="p">):</code> <code class="n">EmailAddress</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="py">atIndex</code> <code class="p">=</code> <code class="n">value</code><code class="p">.</code><code class="n">lastIndexOf</code><code class="p">(</code><code class="sc">'@'</code><code class="p">)</code>&#13;
    <code class="n">require</code><code class="p">(!(</code><code class="n">atIndex</code> <code class="p">&lt;</code> <code class="m">1</code> <code class="p">||</code> <code class="n">atIndex</code> <code class="p">==</code> <code class="n">value</code><code class="p">.</code><code class="n">length</code> <code class="p">-</code> <code class="m">1</code><code class="p">))</code> <code class="p">{</code>&#13;
        <code class="s">"EmailAddress must be two parts separated by @"</code>&#13;
    <code class="p">}</code>&#13;
    <code class="k">val</code> <code class="py">leftPart</code> <code class="p">=</code> <code class="n">value</code><code class="p">.</code><code class="n">substring</code><code class="p">(</code><code class="m">0</code><code class="p">,</code> <code class="n">atIndex</code><code class="p">)</code>&#13;
    <code class="k">val</code> <code class="py">rightPart</code> <code class="p">=</code> <code class="n">value</code><code class="p">.</code><code class="n">substring</code><code class="p">(</code><code class="n">atIndex</code> <code class="p">+</code> <code class="m">1</code><code class="p">)</code>&#13;
    <code class="k">return</code> <code class="n">EmailAddress</code><code class="p">(</code>&#13;
        <code class="n">leftPart</code><code class="p">,</code>&#13;
        <code class="n">rightPart</code>&#13;
    <code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=9.19&amp;show=file">Example 9.19 [single-expressions.18:src/main/java/travelator/EmailAddress.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=9.19&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>Now, one more time with feeling. We can extract a function of all but the return &#13;
<span class="keep-together">statement</span>:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">parse</code><code class="p">(</code><code class="n">value</code><code class="p">:</code> <code class="n">String</code><code class="p">):</code> <code class="n">EmailAddress</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="err">(</code><code class="py">leftPart</code><code class="p">,</code> <code class="n">rightPart</code><code class="p">)</code> <code class="p">=</code> <code class="n">split</code><code class="p">(</code><code class="n">value</code><code class="p">)</code>&#13;
    <code class="k">return</code> <code class="n">EmailAddress</code><code class="p">(</code>&#13;
        <code class="n">leftPart</code><code class="p">,</code>&#13;
        <code class="n">rightPart</code>&#13;
    <code class="p">)</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="k">private</code> <code class="k">fun</code> <code class="nf">split</code><code class="p">(</code><code class="n">value</code><code class="p">:</code> <code class="n">String</code><code class="p">):</code> <code class="n">Pair</code><code class="p">&lt;</code><code class="n">String</code><code class="p">,</code> <code class="n">String</code><code class="p">&gt;</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="py">atIndex</code> <code class="p">=</code> <code class="n">value</code><code class="p">.</code><code class="n">lastIndexOf</code><code class="p">(</code><code class="sc">'@'</code><code class="p">)</code>&#13;
    <code class="n">require</code><code class="p">(!(</code><code class="n">atIndex</code> <code class="p">&lt;</code> <code class="m">1</code> <code class="p">||</code> <code class="n">atIndex</code> <code class="p">==</code> <code class="n">value</code><code class="p">.</code><code class="n">length</code> <code class="p">-</code> <code class="m">1</code><code class="p">))</code> <code class="p">{</code>&#13;
        <code class="s">"EmailAddress must be two parts separated by @"</code>&#13;
    <code class="p">}</code>&#13;
    <code class="k">val</code> <code class="py">leftPart</code> <code class="p">=</code> <code class="n">value</code><code class="p">.</code><code class="n">substring</code><code class="p">(</code><code class="m">0</code><code class="p">,</code> <code class="n">atIndex</code><code class="p">)</code>&#13;
    <code class="k">val</code> <code class="py">rightPart</code> <code class="p">=</code> <code class="n">value</code><code class="p">.</code><code class="n">substring</code><code class="p">(</code><code class="n">atIndex</code> <code class="p">+</code> <code class="m">1</code><code class="p">)</code>&#13;
    <code class="k">return</code> <code class="n">Pair</code><code class="p">(</code><code class="n">leftPart</code><code class="p">,</code> <code class="n">rightPart</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=9.20&amp;show=file">Example 9.20 [single-expressions.19:src/main/java/travelator/EmailAddress.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=9.20&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>IntelliJ turns out to be really quite clever here, making the result a <code>Pair</code> because it has two values to return.</p>&#13;
&#13;
<p>This <code>split</code> would be a nice generic function that we might use in other places if it was parameterized with the character.&#13;
“Introduce Parameter” on the <code>'@'</code> makes that so.&#13;
We “Convert parameter to receiver” on <code>value</code> while we’re there to get a little local extension function:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">parse</code><code class="p">(</code><code class="n">value</code><code class="p">:</code> <code class="n">String</code><code class="p">):</code> <code class="n">EmailAddress</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="err">(</code><code class="py">leftPart</code><code class="p">,</code> <code class="n">rightPart</code><code class="p">)</code> <code class="p">=</code> <code class="n">value</code><code class="p">.</code><code class="n">split</code><code class="p">(</code><code class="sc">'@'</code><code class="p">)</code>&#13;
    <code class="k">return</code> <code class="n">EmailAddress</code><code class="p">(</code>&#13;
        <code class="n">leftPart</code><code class="p">,</code>&#13;
        <code class="n">rightPart</code>&#13;
    <code class="p">)</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="k">private</code> <code class="k">fun</code> <code class="nf">String</code><code class="p">.</code><code class="n">split</code><code class="p">(</code><code class="n">divider</code><code class="p">:</code> <code class="n">Char</code><code class="p">):</code> <code class="n">Pair</code><code class="p">&lt;</code><code class="n">String</code><code class="p">,</code> <code class="n">String</code><code class="p">&gt;</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="py">atIndex</code> <code class="p">=</code> <code class="n">lastIndexOf</code><code class="p">(</code><code class="n">divider</code><code class="p">)</code>&#13;
    <code class="n">require</code><code class="p">(!(</code><code class="n">atIndex</code> <code class="p">&lt;</code> <code class="m">1</code> <code class="p">||</code> <code class="n">atIndex</code> <code class="p">==</code> <code class="n">length</code> <code class="p">-</code> <code class="m">1</code><code class="p">))</code> <code class="p">{</code>&#13;
        <code class="s">"EmailAddress must be two parts separated by @"</code>&#13;
    <code class="p">}</code>&#13;
    <code class="k">val</code> <code class="py">leftPart</code> <code class="p">=</code> <code class="n">substring</code><code class="p">(</code><code class="m">0</code><code class="p">,</code> <code class="n">atIndex</code><code class="p">)</code>&#13;
    <code class="k">val</code> <code class="py">rightPart</code> <code class="p">=</code> <code class="n">substring</code><code class="p">(</code><code class="n">atIndex</code> <code class="p">+</code> <code class="m">1</code><code class="p">)</code>&#13;
    <code class="k">return</code> <code class="n">Pair</code><code class="p">(</code><code class="n">leftPart</code><code class="p">,</code> <code class="n">rightPart</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=9.21&amp;show=file">Example 9.21 [single-expressions.20:src/main/java/travelator/EmailAddress.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=9.21&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>Now we can introduce a <code>let</code>, as we did previously, to get:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">parse</code><code class="p">(</code><code class="n">value</code><code class="p">:</code> <code class="n">String</code><code class="p">):</code> <code class="n">EmailAddress</code> <code class="p">=</code>&#13;
    <code class="n">value</code><code class="p">.</code><code class="n">split</code><code class="p">(</code><code class="sc">'@'</code><code class="p">).</code><code class="n">let</code> <code class="p">{</code> <code class="p">(</code><code class="n">leftPart</code><code class="p">,</code> <code class="n">rightPart</code><code class="p">)</code> <code class="p">-&gt;</code>&#13;
        <code class="n">EmailAddress</code><code class="p">(</code><code class="n">leftPart</code><code class="p">,</code> <code class="n">rightPart</code><code class="p">)</code>&#13;
    <code class="p">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=9.22&amp;show=file">Example 9.22 [single-expressions.21:src/main/java/travelator/EmailAddress.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=9.22&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>This, finally, is a single-expression function that feels worth the effort!</p>&#13;
&#13;
<p>To finish, we can apply the techniques from this chapter to <code>split</code> to make it a single expression, too.&#13;
Here then is the final <code>EmailAddress.kt</code>:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">data</code> <code class="k">class</code> <code class="nc">EmailAddress</code><code class="p">(</code>&#13;
    <code class="k">val</code> <code class="py">localPart</code><code class="p">:</code> <code class="n">String</code><code class="p">,</code>&#13;
    <code class="k">val</code> <code class="py">domain</code><code class="p">:</code> <code class="n">String</code>&#13;
<code class="p">)</code> <code class="p">{</code>&#13;
&#13;
    <code class="k">override</code> <code class="k">fun</code> <code class="nf">toString</code><code class="p">()</code> <code class="p">=</code> <code class="s">"$localPart@$domain"</code>&#13;
&#13;
    <code class="n">companion</code> <code class="k">object</code> <code class="err">{</code>&#13;
        <code class="n">@JvmStatic</code>&#13;
        <code class="k">fun</code> <code class="nf">parse</code><code class="p">(</code><code class="n">value</code><code class="p">:</code> <code class="n">String</code><code class="p">):</code> <code class="n">EmailAddress</code> <code class="p">=</code>&#13;
            <code class="n">value</code><code class="p">.</code><code class="n">splitAroundLast</code><code class="p">(</code><code class="sc">'@'</code><code class="p">).</code><code class="n">let</code> <code class="p">{</code> <code class="p">(</code><code class="n">leftPart</code><code class="p">,</code> <code class="n">rightPart</code><code class="p">)</code> <code class="p">-&gt;</code>&#13;
                <code class="n">EmailAddress</code><code class="p">(</code><code class="n">leftPart</code><code class="p">,</code> <code class="n">rightPart</code><code class="p">)</code>&#13;
            <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="k">private</code> <code class="k">fun</code> <code class="nf">String</code><code class="p">.</code><code class="n">splitAroundLast</code><code class="p">(</code><code class="n">divider</code><code class="p">:</code> <code class="n">Char</code><code class="p">):</code> <code class="n">Pair</code><code class="p">&lt;</code><code class="n">String</code><code class="p">,</code> <code class="n">String</code><code class="p">&gt;</code> <code class="p">=</code>&#13;
    <code class="n">lastIndexOf</code><code class="p">(</code><code class="n">divider</code><code class="p">).</code><code class="n">let</code> <code class="p">{</code> <code class="n">index</code> <code class="p">-&gt;</code>&#13;
        <code class="n">require</code><code class="p">(</code><code class="n">index</code> <code class="p">&gt;=</code> <code class="m">1</code> <code class="p">&amp;&amp;</code> <code class="n">index</code> <code class="p">!=</code> <code class="n">length</code> <code class="p">-</code> <code class="m">1</code><code class="p">)</code> <code class="p">{</code>&#13;
            <code class="s">"string must be two non-empty parts separated by $divider"</code>&#13;
        <code class="p">}</code>&#13;
        <code class="n">substring</code><code class="p">(</code><code class="m">0</code><code class="p">,</code> <code class="n">index</code><code class="p">)</code> <code class="n">to</code> <code class="n">substring</code><code class="p">(</code><code class="n">index</code> <code class="p">+</code> <code class="m">1</code><code class="p">)</code>&#13;
    <code class="p">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=9.23&amp;show=file">Example 9.23 [single-expressions.22:src/main/java/travelator/EmailAddress.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=9.23&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p><code>splitAroundLast</code> felt like a better name that doesn’t clash with the standard <code>String.split</code>, and hints that both sides of the split must be nonempty.&#13;
Words like <em>around</em>, which are unusual in identifiers, should prompt readers of the code to suspend their assumptions about what a function does and actually look it up.</p>&#13;
&#13;
<p>Although <code>splitAroundLast</code> does feel like a generally applicable utility function, if we want to promote it to be public, we should probably write some unit tests for it.&#13;
We’ve spent enough time for today though, so we’ll make a mental note that we have a <code>String.splitAroundLast</code> lying around if we ever need one, and finally commit the change.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46393394571032">&#13;
<h5>What Should Parse Return?</h5>&#13;
<p>Before we leave this example, note that this refactoring would have been easier had <code>parse</code> not thrown an exception on error.&#13;
<code>throw</code> is an expression that returns &#13;
<span class="keep-together"><code>Nothing</code>—it</span> doesn’t complete—and so doesn’t sit well when we are trying to decompose into expressions.&#13;
<a data-type="xref" href="ch19.html#throwing-to-returning">Chapter 19</a> talks about this in detail, but had we written <code>EmailAddress</code> from scratch in Kotlin, we would probably have returned <code>EmailAddress?</code> from <code>parse</code>, with <code>null</code> on failure.&#13;
That doesn’t sit well with Java clients, where the type system doesn’t warn about nullability.&#13;
So we would probably end up with two parsing methods, one for legacy code and one for Kotlin, removing the exception version when there were no Java clients left.&#13;
We explore how to support both languages’ conventions during a gradual conversion from Kotlin to Java in <a data-type="xref" href="ch12.html#functions-to-operators">Chapter 12</a>.<a data-primary="" data-startref="MSEstep09" data-type="indexterm" id="idm46393394563672"/><a data-primary="" data-startref="Rmulti09" data-type="indexterm" id="idm46393394562696"/></p>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Moving On" data-type="sect1"><div class="sect1" id="idm46393395322024">&#13;
<h1>Moving On</h1>&#13;
&#13;
<p>Defining<a data-primary="multi- to single-expression functions" data-secondary="benefits of single expressions" data-type="indexterm" id="idm46393394560856"/><a data-primary="calculations" data-secondary="reserving single-expression functions for" data-type="indexterm" id="idm46393394559912"/><a data-primary="actions" data-secondary="single-expression functions and" data-type="indexterm" id="idm46393394558936"/> our calculations as single-expression functions lets us communicate that they are different from side-effecting actions.&#13;
Trying to express functions as a simple single expression is a useful discipline that can lead to well-factored, clean code.&#13;
To achieve single-expression form, we usually have to factor out subexpressions into their own functions.</p>&#13;
&#13;
<p>Single-expression form is declarative: the expression describes the function’s result in terms of its parameters rather than the actions that the computer must perform to compute the result.&#13;
Factoring subexpressions into their own functions prompts us to think about what those subexpressions should be denoting, and so guides us to write clearer code.&#13;
For example, <code>String.splitAroundLast('@')</code> better described what we wanted to calculate than <code>emailAddress(value: String, atIndex: Int)</code>.</p>&#13;
&#13;
<p>At<a data-primary="refactoring" data-secondary="art of" data-type="indexterm" id="idm46393394555432"/> a deeper level, this chapter is about more than single expressions; it’s about how we can rearrange our code without changing its behavior.&#13;
Many different arrangements of statements and expressions will have the same behavior; refactoring is the art of finding a better one, and getting there safely.&#13;
The more arrangements we can &#13;
<span class="keep-together">visualize</span>, and the more safe routes we can plan, the more options we have to make our code better.</p>&#13;
&#13;
<p>Refactorings don’t always succeed the first, second, or even third time we try them.&#13;
As developers, we don’t always have the luxury of repeated attempts, but the more we practice improving our communication in code, the more often we’ll get there before we have to give up and move on.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>