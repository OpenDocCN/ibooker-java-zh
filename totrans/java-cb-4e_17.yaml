- en: Chapter 17\. Reflection, or “A Class Named Class”
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 17.0 Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The class `java.lang.Class` and the reflection package `java.lang.reflect` provide
    a number of mechanisms for gathering information from the Java Virtual Machine.
    Known collectively as *reflection*, these facilities allow you to load classes
    on the fly, to find methods and fields in classes, to generate listings of them,
    and to invoke methods on dynamically loaded classes. There is even a mechanism
    to let you construct a class from scratch (well, actually, from an array of bytes)
    while your program is running. This is about as close as Java lets you get to
    the magic, secret internals of the Java machine.
  prefs: []
  type: TYPE_NORMAL
- en: The JVM itself is a large program, normally written in C and/or C++, that implements
    the Java Virtual Machine abstraction. You can get the source for OpenJDK and other
    JVMs via the internet, which you could study for months. Here we concentrate on
    just a few aspects, and only from the point of view of a programmer using the
    JVM’s facilities, not how it works internally; that is an implementation detail
    that could vary from one vendor’s JVM to another.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll start with loading an existing class dynamically, move on to listing the
    fields and methods of a class and invoking methods, and end by creating a class
    on the fly using a `ClassLoader`. One of the more interesting aspects of Java,
    and one that accounts for its flexibility (applets in days of yore, servlets,
    web services, and other dynamic APIs) while also once being part of its perceived
    speed problem, is the notion of *dynamic loading*. For example, even the simplest
    “Hello, Java” program has to load the class file for your `HelloJava` class, the
    class file for its parent (usually `java.lang.Object`), the class for `PrintStream`
    (because you used `System.out`), the class for `PrintStream`’s parent, and `IOException`,
    and its parent, and so on. To see this in action, try something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To take another example, when applets were popular, a browser would download
    an applet’s bytecode file over the internet and run it on your desktop. How does
    it load the class file into the running JVM? We discuss this little bit of Java
    magic in [Recipe 17.4](#javacook-reflection-SECT-3). The chapter ends with replacement
    versions of the JDK tools *javap* and a cross-reference tool that you can use
    to become a famous Java author by publishing your very own reference to the complete
    Java API.
  prefs: []
  type: TYPE_NORMAL
- en: 17.1 Getting a Class Descriptor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to get a `Class` object from a class name or instance.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the type name is known at compile time, you can get the class instance using
    the compiler keyword `.class`, which works on any type that is known at compile
    time, even the eight primitive types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Otherwise, if you have an object (an instance of a class), you can call the
    `java.lang.Object` method `getClass()`, which returns the `Class` object for the
    object’s class (now that was a mouthful!):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run it, we see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Nothing fancy, but as you can see, you can get the `Class` object for almost
    anything known at compile time, whether it’s part of a package or not.
  prefs: []
  type: TYPE_NORMAL
- en: 17.2 Finding and Using Methods and Fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to find arbitrary method or field names in arbitrary classes.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the reflection package `java.lang.reflect`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you just wanted to find fields and methods in one particular class, you wouldn’t
    need this recipe; you could simply create an instance of the class using `new`
    and refer to its fields and methods directly. But this allows you to find methods
    and fields in any class, even classes that have not yet been written! Given a
    class object created as in [Recipe 17.1](#javacook-reflection-SECT-1), you can
    obtain a list of constructors, a list of methods, or a list of fields. The method
    `getMethods()` lists the methods available for a given class as an array of `Method`
    objects. Similarly, `getFields()` returns a list of `Field` objects. Because constructor
    methods are treated specially by Java, there is also a `getConstructors()` method,
    which returns an array of `Constructor` objects. Even though `Class` is in the
    package `java.lang`, the `Constructor`, `Method`, and `Field` objects it returns
    are in `java.lang.``reflect`, so you need an import of this package. The `ListMethods`
    class (see [Example 17-1](#javacook-reflection-EX-1)) shows how get a list of
    methods in a class whose name is known at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Example 17-1\. main/src/main/java/reflection/ListMethods.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, you could run [Example 17-1](#javacook-reflection-EX-1) on a class
    like `java.lang.String` and get a fairly lengthy list of methods; I’ll only show
    part of the output so you can see what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You can see that this could be extended (almost literally) to write a `BeanMethods`
    class that would list only the set/get methods defined in a JavaBean (see [Recipe
    15.4](ch15.html#javacook-packages-SECT-8)).
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you can find a particular method and invoke it, or find a particular
    field and refer to its value. Let’s start by finding a given field, because that’s
    the easiest. [Example 17-2](#javacook-reflection-EX-2) is code that, given an
    `Object` and the name of a field, finds the field (gets a `Field` object) and
    then retrieves and prints the value of that `Field` as an `int`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 17-2\. main/src/main/java/reflection/FindField.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'What if we need to find a method? The simplest way is to use the methods `getMethod()`
    and `invoke()`. But this is not altogether trivial. Suppose that somebody gives
    us a reference to an object. We don’t know its class but have been told that it
    should have this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We wish to invoke `work()`. To find the method, we must make an array of `Class`
    objects, one per item in the parameter list. So, in this case, we make an array
    containing only a reference to the class object for `String`. Because we know
    the name of the class at compile time, we’ll use the shorter invocation `String.class`
    instead of `Class.forName()`. This, plus the name of the method as a string, gets
    us entry into the `getMethod()` method of the `Class` object. If this succeeds,
    we have a `Method` object. But guess what? In order to invoke the method, we have
    to construct yet another array, this time an array of `Object` references actually
    containing the data to be passed to the invocation. We also, of course, need an
    instance of the class in whose context the method is to be run. For this demonstration
    class, we need to pass only a single string, because our array consists only of
    the string. [Example 17-3](#javacook-reflection-EX-3) is the code that finds the
    method and invokes it.
  prefs: []
  type: TYPE_NORMAL
- en: Example 17-3\. main/src/main/java/reflection/GetAndInvokeMethod.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Not tiny, but it’s still not bad. In most programming languages, you couldn’t
    do that in the 40 lines it took us here.
  prefs: []
  type: TYPE_NORMAL
- en: 'A word of caution: when the arguments to a method are of a primitive type,
    such as `int`, you do not pass `Integer.class` into `getMethod()`. Instead, you
    must use the class object representing the primitive type `int`. The easiest way
    to find this class is in the `Integer` class, as a public constant named `TYPE`,
    so you’d pass `Integer.TYPE`. The same is true for all the primitive types; for
    each, the corresponding wrapper `class` has the primitive `class` referred to
    as `TYPE`.'
  prefs: []
  type: TYPE_NORMAL
- en: Java also includes a mechanism called a `MethodHandle` that was intended both
    to simplify and to generalize use of Reflection to invoke methods; we do not cover
    it here because in practice it has not shown to be a significant improvement over
    using the Reflection API.
  prefs: []
  type: TYPE_NORMAL
- en: 17.3 Accessing Private Methods and Fields via Reflection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to access private fields and have heard you can do so using the Reflection
    API.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s generally a bad idea to access private fields. But if you have to, and
    the `SecurityManager` allows you to use Reflection, you can.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is occasionally a need to access private fields in other classes. For
    example, I did so recently in writing a JUnit test case that needed to see all
    the fields of a target class. The secret is to call the `Field` or `Method` descriptor’s
    `setAccessible()` method passing the value `true` before trying to get the value
    or invoke the method. It really is that easy, as shown in [Example 17-4](#javacook-reflection-defeatPrivacy).
  prefs: []
  type: TYPE_NORMAL
- en: Example 17-4\. main/src/main/java/reflection/DefeatPrivacy.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Use this with *extreme care*, because it can defeat some of the most cherished
    principles of Java programming.
  prefs: []
  type: TYPE_NORMAL
- en: 17.4 Loading and Instantiating a Class Dynamically
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to load classes dynamically, just like web servers load your servlets.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use `class.forName("ClassName");` and the class’s `newInstance( )` method.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Suppose you are writing a Java application and want other developers to be able
    to extend your application by writing Java classes that run in the context of
    your application. In other words, these developers are, in essence, using Java
    as an extension language, in the same way that applets are an extension of a web
    browser. You would probably want to define a small set of methods that these extension
    programs would have and that you could call for such purposes as initialization,
    operation, and termination. The best way to do this is, of course, to publish
    a given, possibly abstract, class that provides those methods and get the developers
    to subclass from it. Sound familiar? It should. This is just how web browsers
    such as Netscape allow the deployment of applets.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll leave the thornier issues of security and of loading a class file over
    a network socket for now and assume that the user can install the classes into
    the application directory or into a directory that appears in the `CLASSPATH`
    at the time the program is run. First, let’s define our class. We’ll call it `Cooklet`
    (see [Example 17-5](#javacook-reflection-EX-4)) to avoid infringing on the overused
    word *applet*. Pretend each subclass will represent the code to drive some elaborate
    kind of food-preparing-and-cooking appliance through the steps of one traditional
    recipe. And we’ll initially take the easiest path from ingredients to cookies
    before we complicate it.
  prefs: []
  type: TYPE_NORMAL
- en: Example 17-5\. Cooklet.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now, because we’ll be baking, er, making this available to other people, we’ll
    probably want to cook up a demonstration version too; see [Example 17-6](#javacook-reflection-EX-5).
  prefs: []
  type: TYPE_NORMAL
- en: Example 17-6\. main/src/main/java/reflection/DemoCooklet.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: But how does our application use it? Once we have the name of the user’s class,
    we need to create a `Class` object for that class. This can be done easily using
    the static method `Class.forName()`. Then we can create an instance of it using
    the `Class` object’s `newInstance()` method; this calls the class’s no-argument
    constructor. Then we simply cast the newly constructed object to our `Cooklet`
    class, and we can call its methods! It actually takes longer to describe this
    code than to look at the code, so let’s do that now; see [Example 17-7](#javacook-reflection-EX-6).
  prefs: []
  type: TYPE_NORMAL
- en: Example 17-7\. main/src/main/java/reflection/Cookies.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: And if we run it?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Of course, this version has rather limited error handling. But you already know
    how to fix that. Your `ClassLoader` can also place classes into a package by constructing
    a `Package` object; you should do this if loading any medium-sized set of application
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 17.5 Constructing a Class from Scratch with a ClassLoader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to load a class from a nonstandard location and run its methods.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Examine the existing loaders such as `java.net.URLClassLoader`. If none is suitable,
    write and use your own `ClassLoader`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `ClassLoader`, of course, is a program that loads classes. One `ClassLoader`
    is built into the Java Virtual Machine, but your application can create others
    as needed. Learning to write and run a working `ClassLoader` and using it to load
    a class and run its methods is a nontrivial exercise. In fact, you rarely need
    to write a `ClassLoader`, but knowing how is helpful in understanding how the
    JVM finds classes, creates objects, and calls methods.
  prefs: []
  type: TYPE_NORMAL
- en: '`ClassLoader` itself is abstract; you must subclass it, presumably providing
    a `loadClass()` method that loads classes as you wish. It can load the bytes from
    a network connection, a local disk, RAM, a serial port, or anywhere else. Or you
    can construct the class file in memory yourself, if you have access to a compiler.'
  prefs: []
  type: TYPE_NORMAL
- en: There is a general-purpose loader called `java.net.URLClassLoader` that can
    be used if all you need is to load classes via the web protocol (or, more generally,
    from one or more URLs).
  prefs: []
  type: TYPE_NORMAL
- en: You must call the `ClassLoader` `loadClass()` method for any classes you wish
    to explicitly load from it. Note that this method is called to load all classes
    required for classes you load (superclasses that aren’t already loaded, for example).
    However, the JVM still loads classes that you instantiate with the `new` operator
    normally via classpath.
  prefs: []
  type: TYPE_NORMAL
- en: When writing a `ClassLoader`, your `loadClass()` method needs to get the class
    file into a byte array (typically by reading it), convert the array into a `Class`
    object, and return the result.
  prefs: []
  type: TYPE_NORMAL
- en: What? That sounds a bit like “And Then a Miracle Occurs…” And it is. The miracle
    of class creation, however, happens down inside the JVM, where you don’t have
    access to it. Instead, your `ClassLoader` has to call the `protected defineClass()`
    method in your superclass (which is `java.lang.ClassLoader`). This is illustrated
    in [Figure 17-1](#javacook-reflection-FIG-1), where a stream of bytes containing
    a hypothetical `Chicken` class is converted into a ready-to-run `Chicken` class
    in the JVM by calling the `defineClass()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '![jcb4 1701](assets/jcb4_1701.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-1\. ClassLoader in action
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: What next?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To use your `ClassLoader` subclass, you need to instantiate it and call its
    `loadClass()` method with the name of the class you want to load. This gives you
    a `Class` object for the named class; the `Class` object in turn lets you construct
    instances, find and call methods, etc. Refer back to [Recipe 17.2](#javacook-reflection-SECT-2).
  prefs: []
  type: TYPE_NORMAL
- en: 17.6 Constructing a Class from Scratch with JavaCompiler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’d rather construct a class dynamically by generating source code and compiling
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `JavaCompiler` from `javax.tools`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many cases where you might need to generate code on the fly. If you’re
    writing a framework, you might want to introspect on a model class to find its
    fields, and generate accessors for them on the fly. As we’ve seen in [Recipe 17.2](#javacook-reflection-SECT-2),
    you can do this with the `Field` class. However, for a high-volume operation it
    may well be more efficient to generate direct access code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Java Compiler API has been around since Java 1.6 and is fairly easy to
    use for simple cases. Here are the basic steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Get the `JavaCompiler` object for your current Java Runtime. If it’s not available,
    either give up altogether, or fall back to using reflection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get a `CompilerTask` (which is also a `Callable`) to run the compilation, passing
    input and outputs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invoke the `Callable`, either directly or by using an `ExecutorService`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check the results. If true, invoke the class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is demonstrated in [Example 17-8](#javacook-reflection-EX-javacompilerdemo).
  prefs: []
  type: TYPE_NORMAL
- en: Example 17-8\. main/src/main/java/reflection/JavaCompilerDemo.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_reflection__or__a_class_named_class__CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The source code that we want to compile. In real life it would probably be dynamically
    generated, maybe using a `StringBuffer`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_reflection__or__a_class_named_class__CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Get a reference to the default `JavaCompiler` object.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_reflection__or__a_class_named_class__CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Ask the compiler to create a `CompilerTask` to do the compilation. `CompilerTask`
    is also `Callable` and we save it under that type. The `-d` and `.` are standard
    *javac* arguments. `MySource` extends the compiler-provided API class `SimpleJavaFileObject`
    to give access to a file by creating a *file://* URL.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_reflection__or__a_class_named_class__CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: A `Callable` can be put into a thread pool (`ExecutorService`) (see [Recipe
    16.1](ch16.html#javacook-threads-SECT-1)); we don’t need this capability but the
    Compiler API returns it. We invoke the `Callable` directly.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_reflection__or__a_class_named_class__CO1-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Assuming the `result` was `true` indicating success, we load the class with
    `Class.forName()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_reflection__or__a_class_named_class__CO1-6)'
  prefs: []
  type: TYPE_NORMAL
- en: We have to find the `main()` method in the generated class. We reuse the `String[].class`
    type from args, since all `main` methods have the same argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_reflection__or__a_class_named_class__CO1-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can invoke the `main` method, reusing the incoming `args` array
    to pass any *welcome* message along.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this program with and without an argument shows that the argument passed
    to the `JavaCompilerDemo` is being passed correctly to the generated `AnotherDemo`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: There is a lot to explore in the Compiler API, including the `JavaFileManager`
    that lets you control the placement of class files (other than by using `-d` as
    we did here), listeners to monitor compilation, and control of output and error
    streams. Consult the `javax.tools.JavaCompiler` [documentation](https://docs.oracle.com/javase/8/docs/api/javax/tools/JavaCompiler.html)
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: 17.7 Performance Timing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Slow performance?
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use a *profiler*, or time individual methods using `System.currentTimeMillis()`
    before and after invoking the target method; the difference is the time that method
    took.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Profilers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Profiling tools—profilers—have a long history as one of the important tools
    in a programmer’s toolkit. A commercial profiling tool will help find bottlenecks
    in your program by showing both the number of times each method was called and
    the amount of time in each.
  prefs: []
  type: TYPE_NORMAL
- en: Quite a bit of useful information can be obtained from a Java application by
    use of the `VisualVM` tool, which was part of the Oracle JDK up until Java 8.
    With Java 9 this tool was open-sourced, and it’s now available from the [VisualVM
    project](https://visualvm.github.io/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: Another tool that is part of the JDK is [Java Flight Recorder](https://en.wikipedia.org/wiki/JDK_Flight_Recorder),
    which is now open-sourced and built into the JDK. Its data is meant to be analyzed
    by [Java Mission Control](https://en.wikipedia.org/wiki/JDK_Mission_Control).
    There are also third-party profilers that will give more detailed information;
    a web search will find current commercial offerings.
  prefs: []
  type: TYPE_NORMAL
- en: Measuring a single method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The simplest technique is to save the JVM’s accumulated time before and after
    dynamically loading a main program and then calculate the difference between those
    times. Code to do just this is presented in [Example 17-11](#javacook-reflection-EX-7);
    for now, just remember that we have a way of timing a given Java class.
  prefs: []
  type: TYPE_NORMAL
- en: One way of measuring the efficiency of a particular operation is to run it many
    times in isolation. The overall time the program takes to run thus approximates
    the total time of many invocations of the same operation. Gross numbers like this
    can be compared if you want to know which of two ways of doing something is more
    efficient. Consider the case of string concatenation versus `println()`. The code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'will probably work by creating a `StringBuilder`; appending the string `"Time
    is"`, the value of `n` as a string, and `"seconds"`; and finally converting the
    finished `StringBuilder` to a `String` and passing that to `println()`. Suppose
    you have a program that does a lot of this, such as a Java servlet that creates
    a lot of HTML this way, and you expect (or at least hope) your website to be sufficiently
    busy so that doing this efficiently will make a difference. There are two ways
    of thinking about this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Theory A: this string concatenation is inefficient.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Theory B: string concatenation doesn’t matter; `println()` is inefficient,
    too.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A proponent of Theory A might say that because `println()` just puts stuff into
    a buffer, it is very fast and that string concatenation is the expensive part.
  prefs: []
  type: TYPE_NORMAL
- en: How to decide between Theory A and Theory B? Assume you are willing to write
    a simple test program that tests both theories. Let’s just write a simple program
    both ways and time it. [Example 17-9](#stringprintA) is the timing program for
    Theory A.
  prefs: []
  type: TYPE_NORMAL
- en: Example 17-9\. main/src/main/java/performance/StringPrintA.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`StringPrintAA` (in the *javasrc* repo but not printed here) is the same but
    explicitly uses a `StringBuilder` for the string concatenation. [Example 17-10](#stringprintb)
    is the tester for Theory B.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 17-10\. main/src/main/java/performance/StringPrintB.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Timing results
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'I ran `StringPrintA`, `StringPrintAA`, and `StringPrintB` twice each on the
    same computer. To eliminate JVM startup times, I ran them from a program called
    `TimeNoArgs`, which takes a class name and invokes its `main()` method, using
    the Reflection API. `TimeNoArgs` and a shell script to run it, *stringprinttimer.sh*,
    are in the *performance* folder of the *javasrc* source repository. Here are the
    results:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 2004 program | Seconds |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `StringPrintA` | 17.23, 17.20 seconds |'
  prefs: []
  type: TYPE_TB
- en: '| `StringPrintAA` | 17.23, 17.23 seconds |'
  prefs: []
  type: TYPE_TB
- en: '| `StringPrintB` | 27.59, 27.60 seconds |'
  prefs: []
  type: TYPE_TB
- en: '| 2014 program | Seconds |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `StringPrintA` | 0.714, 0.525 seconds |'
  prefs: []
  type: TYPE_TB
- en: '| `StringPrintAA` | 0.616, 0.561 seconds |'
  prefs: []
  type: TYPE_TB
- en: '| `StringPrintB` | 1.091, 1.039 seconds |'
  prefs: []
  type: TYPE_TB
- en: 'Although the times went down by a factor of roughly 20 over a decade due to
    both JVM improvements and faster hardware, the ratios remain remarkably consistent:
    `StringPrintB`, which calls `print()` and `println()` multiple times, takes roughly
    twice as long.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Moral: don’t guess. If it matters, time it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another moral: multiple calls to `System.out.print()` cost more than the same
    number of calls to a `StringBuilder`’s `append()` method, by a factor of roughly
    1.5 (or 150%). Theory B wins; the extra `println` calls appear to save a string
    concatenation but make the program take substantially longer.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Other aspects of performance: GC'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are many other aspects of software performance. One that is fundamental
    to Java is garbage collection behavior. Sun/Oracle usually discusses this at JavaOne.
    For example, see the 2003 JavaOne presentation [“Garbage Collection in the Java
    HotSpot Virtual Machine”](http://www.oracle.com/technetwork/java/javase/tech/ts-3153-coomes-19899-dsf-150093.pdf).
    See also the 2007 JavaOne talk by the same GC development team, [“Garbage Collection-Friendly
    Programming,” TS-2906](https://docs.huihoo.com/javaone/2007/java-se/TS-2906.pdf).
    JavaOne 2010 featured an updated presentation entitled [“The Garbage Collection
    MythBusters”](https://oreil.ly/java-world-the-garbage-collection-mythbusters).
  prefs: []
  type: TYPE_NORMAL
- en: A timing program
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s pretty easy to build a simplified `time` command in Java, given that you
    have `System.currentTimeMillis()` to start with. Run my `Time` program, and, on
    the command line, specify the name of the class to be timed, followed by the arguments
    (if any) that class needs for running. The program is shown in [Example 17-11](#javacook-reflection-EX-7).
    The time that the class took is displayed. But remember that `System.currentTimeMillis()`
    returns clock time, not necessarily CPU time. So you must run it on a machine
    that isn’t running a lot of background processes. And note also that I use dynamic
    loading (see [Recipe 17.4](#javacook-reflection-SECT-3)) to let you put the Java
    class name on the command line.
  prefs: []
  type: TYPE_NORMAL
- en: Example 17-11\. main/src/main/java/performance/Time.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Of course, you can’t directly compare the results from the operating system
    `time` command with results from running this program. There is a rather large,
    but fairly constant, initialization overhead—the JVM startup and the initialization
    of `Object` and `System.out`, for example—that is included in the former and excluded
    from the latter. One could even argue that my `Time` program is more accurate
    because it excludes this constant overhead. But, as noted, it must be run on a
    single-user machine to yield repeatable results. And no fair running an editor
    in another window while waiting for your timed program to complete!
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*[Java Performance](http://shop.oreilly.com/product/0636920272250.do)* by Scott
    Oaks (O’Reilly) provides information on tuning Java performance.'
  prefs: []
  type: TYPE_NORMAL
- en: 17.8 Printing Class Information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to print all the information about a class, similar to the way *javap*
    does.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Get a `Class` object, call its `getFields()` and `getMethods()`, and print the
    results.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The JDK includes a program called *javap*, the Java Printer. Sun’s JDK version
    normally prints the outline of a class file—a list of its methods and fields—but
    can also print out the Java bytecodes or machine instructions. The Kaffe package
    did not include a version of *javap*, so I wrote one and contributed it (see [Example 17-12](#javacook-reflection-EX-8)).
    The Kaffe folks have expanded it somewhat, but it still works basically the same.
    My version doesn’t print the bytecodes; it behaves rather like Sun’s behaves when
    you don’t give its version any command-line options.
  prefs: []
  type: TYPE_NORMAL
- en: The `getFields()` and `getMethods()` methods return arrays of `Field` and `Method`,
    respectively; these are both in package `java.lang.reflect`. I use a `Modifiers`
    object to get details on the permissions and storage attributes of the fields
    and methods. In many Java implementations, you can bypass this and simply call
    `toString()` in each `Field` and `Method` object (as I do here for `Constructors`).
    Doing it this way gives me a bit more control over the formatting.
  prefs: []
  type: TYPE_NORMAL
- en: Example 17-12\. main/src/main/java/reflection/MyJavaP.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 17.9 Listing Classes in a Package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to get a list of all the classes in a package.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can’t, in the general case. There are some limited approaches, most involving
    `CLASSPATH` scanning.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is no way to find out all the classes in a package, in part because, as
    we just saw in [Recipe 17.5](#javacook-reflection-SECT-4), you can add classes
    to a package at any time! And, for better or for worse, the JVM and standard classes
    such as `java.lang.Package` do not even allow you to enumerate the classes currently
    in a given package.
  prefs: []
  type: TYPE_NORMAL
- en: The nearest you can come is to look through the `CLASSPATH`. And this will surely
    work only for local directories and JAR files; if you have locally defined or
    network-loaded classes, this is not going to help. In other words, it will find
    compiled classes, but not dynamically loaded ones. There are several libraries
    that can automate this for you, and you’re welcome to use them. The code to scan
    the `CLASSPATH` is fairly simple at heart, though, so classy developers with heart
    will want to examine it. [Example 17-13](#javacook-reflection-EX-8X) shows my
    `ClassesInPackage` class with its one static method. The code works but is rather
    short on error handling, and it will crash on nonexistent packages and other failures.
  prefs: []
  type: TYPE_NORMAL
- en: The code goes through a few gyrations to get the `CLASSPATH` as an enumeration
    of URLs, then looks at each element.
  prefs: []
  type: TYPE_NORMAL
- en: file
  prefs: []
  type: TYPE_NORMAL
- en: URLs will contain the pathname of the file containing the *.class* file, so
    we can just list it.
  prefs: []
  type: TYPE_NORMAL
- en: jar
  prefs: []
  type: TYPE_NORMAL
- en: URLs contain the filename as “file:/path_to_jar_file!package/name,” so we have
    to pull this apart; the “package name” suffix is slightly redundant in this case
    because it’s the package we asked the `ClassLoader` to give us.
  prefs: []
  type: TYPE_NORMAL
- en: Example 17-13\. main/src/main/java/reflection/ClassesInPackage.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note that if you run this application in the *javasrc* project, it will list
    the members of the demonstration package (`com.darwinsys.io`) twice, because it
    will find them both in the build directory and in the JAR file. If this is an
    issue, change the `List` to a `Set` (see [Recipe 7.3](ch07.html#javacook-structure-collections)).
  prefs: []
  type: TYPE_NORMAL
- en: 17.10 Using and Defining Annotations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to know how to use annotations in code or to define your own annotations.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Apply annotations in your code using `@``AnnotationName` before a class, method,
    field, etc. Define annotations with `@interface` at the same level as `class`,
    `interface`, etc.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Annotations are a way of adding additional information beyond what the source
    code conveys. Annotations may be directed at the compiler or at runtime examination.
    Their syntax was somewhat patterned after javadoc annotations (such as `@author`,
    `@version` inside doc comments). Annotations are what I call *class-like things*
    (so they have initial-cap names) but are prefixed by `@` sign where used (e.g.,
    `@Override`). You can place them on classes, methods, fields, and a few other
    places; they must appear immediately before what they annotate (ignoring space
    and comments). A given annotation may only appear once in a given position (this
    is relaxed in Java 8 or 9).
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example of the benefits of a compile-time annotation, consider the common
    error made when overriding: as shown in [Example 17-14](#myclassjavaanno), a small
    error in the method signature can result it an overload when an override was intended.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 17-14\. MyClass.java (an example of why we need annotations)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The code will compile just fine on any release of Java, but it is incorrect.
    The standard contract of the `equals()` method (see [Recipe 8.1](ch08.html#javacook-oo-SECT-1))
    requires a method whose solitary argument is of type `java.lang.Object`. The preceding
    version creates an accidental overload. Because the main use of `equals()` (and
    its buddy method `hashCode()`; see [Recipe 8.1](ch08.html#javacook-oo-SECT-1))
    is in the Collections classes (see [Chapter 7](ch07.html#javacook-structure)),
    this overloaded method will never get called, resulting both in dead code and
    in incorrect operation of your class within `Set`s and `Map`s.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution is very simple: using the annotation `java.lang.Override`, as
    in [Example 17-15](#myclassjavaoverride), informs the compiler that the annotated
    method is required to override a method inherited from a supertype (such as a
    superclass or an interface). If not, the code will not compile.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 17-15\. MyClass.java with @Override annotation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This version of `equals()`, while still incorrect, will be flagged as erroneous
    at compile time, potentially avoiding a lot of debugging time. This annotation,
    on your own classes, will help both at the time you write new code and as you
    maintain your codebase; if a method is removed from a superclass, all the subclasses
    that still attempt to override it *and* have the `@Override` annotation will cause
    an error message, allowing you to remove a bunch of dead code.
  prefs: []
  type: TYPE_NORMAL
- en: The second major use of annotations is to provide metadata at runtime. For example,
    the Java Persistence API (JPA, see [*https://darwinsys.com/db_in_java*](https://darwinsys.com/db_in_java))
    uses its own set of annotations from the package `javax.persistence` to mark up
    entity classes to be loaded and/or persisted. A JPA entity class might look like
    [Example 17-16](#personjavajpa).
  prefs: []
  type: TYPE_NORMAL
- en: Example 17-16\. main/src/main/java/domain/Person.java (JPA annotations)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `@Entity` annotation at class level directs JPA to treat this as a data
    object to be mapped into the database. The `@Id` informs JPA that this `id` is
    the primary key property, and the `@GeneratedValue` tells it how to assign the
    primary key values for newly created objects. The `@Column` annotation is only
    needed when the column name in the relational database differs from the expected
    name based on the property; in this case, the SQL database designer has used `surname`,
    whereas the Java developer wants to use `lastName`.
  prefs: []
  type: TYPE_NORMAL
- en: I said that annotations are class-like things, and therefore, you can define
    your own. The syntax here is a bit funky; you use `@interface`. It is rumored
    that the team developing this feature was either told not to, or was afraid to,
    introduce a new keyword into the language, due to the trouble that doing so had
    caused when the `enum` keyword was introduced in Java SE 1.4. Or, maybe they just
    wanted to use a syntax that was more reminiscent of the annotation’s usage. At
    any rate, [Example 17-17](#trivialannot) is a trivial example of a custom annotation.
  prefs: []
  type: TYPE_NORMAL
- en: Example 17-17\. Trivial annotation defined
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Annotations are class-like things, so they should be named the same way—that
    is, names that begin with a capital letter and, if public, are stored in a source
    file of the same name (e.g, *MyToyAnnotation.java*).
  prefs: []
  type: TYPE_NORMAL
- en: Compile the [Example 17-17](#trivialannot) with *javac* and you’ll see there’s
    a new *MyToyAnnotation.class* file. In [Example 17-18](#runningjavap), we examine
    this with *javap*, the standard JDK class inspection tool.
  prefs: []
  type: TYPE_NORMAL
- en: Example 17-18\. Running javap on trivial annotation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As it says, an `Annotation` is represented in the class file format as just
    an interface that `extends Annotation` (to answer the obvious question, you could
    write simple interfaces this way, but it would be a truly terrible idea). In [Example 17-19](#annotation),
    we take a quick look at `Annotation` itself.
  prefs: []
  type: TYPE_NORMAL
- en: Example 17-19\. The Annotation Interface in Detail
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Annotations can be made such that the compiler will only allow them in certain
    points in your code. [Example 17-20](#annotation-classes) is one that can only
    go on classes or interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Example 17-20\. Sample Annotation for Classes, Interfaces, etc.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `@Target` specifies where the annotation can be used: `ElementType.TYPE`
    makes it usable on classes, interfaces, class-like things such as enums, even
    annotations! To restrict it to use just on annotations, there is `ElementType.ANNOTATION_TYPE`.
    Other types include `METHOD`, `FIELD`, `CONSTRUCTOR`, `LOCAL_VARIABLE`, `PACKAGE`,
    and `PARAMETER`. So, this annotation is itself annotated with two `@ANNOTATION_TYPE`-targeted
    annotations.'
  prefs: []
  type: TYPE_NORMAL
- en: Usage of annotations with an existing framework requires consulting their documentation.
    Using annotations for your own purpose at runtime requires use of the Reflection
    API, as shown in [Example 17-21](#javacook-reflection-Ex-AnnotationDemo).
  prefs: []
  type: TYPE_NORMAL
- en: One more thing to note about annotations is that they may have attributes. These
    are defined as methods in the annotation source code but used as attributes where
    the annotation is used. [Example 17-21](#javacook-reflection-Ex-AnnotationDemo)
    is an annotated annotation with one such attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Example 17-21\. main/src/main/java/lang/AnnotationDemo.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '`AnnotationDemo` has the meta-annotation `@Target(ElementType.TYPE)` to indicate
    that it can annotate user-defined types (such as classes). Other `ElementType`
    choices include `METHOD`, `FIELD`, and `PARAMETER`. If more than one is needed,
    use array initializer syntax.'
  prefs: []
  type: TYPE_NORMAL
- en: '`AnnotationDemo` also has the `@Retention(RetentionPolicy.RUNTIME)` annotation
    to request that it be preserved until runtime. This is obviously required for
    any annotation that will be examined by a framework at runtime.'
  prefs: []
  type: TYPE_NORMAL
- en: These two meta-annotations are common on user-defined annotations that will
    be examined at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: The class `FancyClassJustToShowAnnotation` shows using the `AnnotationDemo`
    annotation, along with a standard Java one (the `@Resource` annotation).
  prefs: []
  type: TYPE_NORMAL
- en: Refer to [Recipe 17.11](#javacook-reflection-pluginViaAnnotations) for a full
    example of using this mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: 17.11 Finding Plug-In-Like Classes via Annotations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to do plug-in-like things without using an explicit plug-in API.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Define an annotation for the purpose, and use it to mark the plug-in classes.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suppose we want to model how the Java EE standard `javax.annotations.Named`
    or `javax.faces.ManagedBean` annotations work; for each class that is so annotated,
    convert the class name to an instance-like name (e.g, lowercase the first letter),
    and do something special with it. You’d want to do something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Get the list of classes in the given package(s) (see [Recipe 17.9](#javacook-reflection-classesInPackage)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check if the class is annotated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If so, save the name and `Class` descriptor for later use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is implemented in [Example 17-22](#javacook-reflection-EX-8Y).
  prefs: []
  type: TYPE_NORMAL
- en: Example 17-22\. main/src/main/java/reflection/PluginsViaAnnotations
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We can take this one step further and support particular method annotations,
    similar to `javax.annotations.PostCreate`, which is meant to decorate a method
    that is to be called after an instance of the bean has been instantiated by the
    framework. Our flow is now something like this, and the code is shown in [Example 17-23](#javacook-reflection-EX-8Z):'
  prefs: []
  type: TYPE_NORMAL
- en: Get the list of classes in the given package(s) (again, see [Recipe 17.9](#javacook-reflection-classesInPackage)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are using a class-level annotation, check if the class is annotated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If this class is still of interest, get a list of its methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each method, see if it contains a given method-specific annotation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If so, add the class and method to a list of invocable methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Example 17-23\. main/src/main/java/reflection/PluginsViaAnnotations (find annotated
    methods)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Recipe 17.10](#javacook-reflection-annotations) and the rest of this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: '17.12 Program: CrossRef'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You’ve probably seen those other Java books that consist entirely of listings
    of the Java API for version thus-and-such of the JDK. I don’t suppose you thought
    the authors of these works sat down and typed the entire contents from scratch.
    As a programmer, you would have realized, I hope, that there must be a way to
    obtain that information from Java. But you might not have realized how easy it
    is! If you’ve read this chapter faithfully, you now know that there is one true
    way: make the computer do the walking. [Example 17-24](#javacook-reflection-EX-9)
    is a program that puts most of the techniques together. This version generates
    a cross-reference listing, but by overriding the last few methods, you could easily
    convert it to print the information in any format you like, including an API reference
    book. You’d need to deal with the details of this or that publishing software—FrameMaker,
    troff, T[E]X, or whatever—but that’s the easy part.'
  prefs: []
  type: TYPE_NORMAL
- en: This program makes fuller use of the Reflection API than did `MyJavaP` in [Recipe
    17.8](#javacook-reflection-SECT-6). It also uses the `java.util.zip` classes (see
    [Recipe 10.15](ch10.html#javacook-io-SECT-20)) to crack the JAR archive containing
    the class files of the API. Each class file found in the archive is loaded and
    listed; the listing part is similar to `MyJavaP`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 17-24\. main/src/main/java/reflection/CrossRef.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: You probably noticed the methods `startClass()` and `endClass()`, which are
    null. These methods are placeholders designed to make subclassing easy for when
    you need to write something at the start and end of each class. One example might
    be a fancy text formatting application in which you need to output a bold header
    at the beginning of each class. Another would be XML, where you’d want to write
    a tag like `<class>` at the front of each class and `</class>` at the end. [Example 17-25](#javacook-reflection-EX-10)
    is an XML-specific subclass that generates (limited) XML for each field and method.
  prefs: []
  type: TYPE_NORMAL
- en: Example 17-25\. main/src/main/java/reflection/CrossRefXML.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: By the way, if you publish a book using either of these and get rich, “Remember,
    remember me!”
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have not investigated all the ins and outs of reflection or the `ClassLoader`
    mechanism, but by now you should have a basic idea of how it works.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps the most important omissions are `SecurityManager` and `ProtectionDomain`.
    Only one `SecurityManager` can be installed in a given instance of the JVM (e.g.,
    to prevent malicious code from providing its own!). A browser running the old
    Java Applet API, for example, provides a `SecurityManager` that is far more restrictive
    than the standard one. Writing such a `SecurityManager` is left as an exercise
    for the reader—an important exercise for anyone planning to load classes over
    the internet! (For more information about security managers and the Java Security
    APIs, see *[Java Security](http://oreil.ly/java-security-2nd)* by Scott Oaks (O’Reilly).
    A `ProtectionDomain` can be provided with a `ClassLoader` to specify all the permissions
    needed for the class to run.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve also left unexplored many topics in the JVM; see the (somewhat dated) O’Reilly
    books *[Java Virtual Machine](http://shop.oreilly.com/product/9781565921948.do)*
    by Troy Downing and Jon Meyer, and *[Java Language Reference](http://shop.oreilly.com/product/9781565923263.do)*
    by Mark Grand. You can also read the Sun/Oracle *Java Language Specification*
    and *JVM Specification* documents (both updated with new releases, available [online](https://docs.oracle.com/en/java/javase/13/docs)),
    for a lifetime of reading enjoyment and edification!
  prefs: []
  type: TYPE_NORMAL
- en: The Apache Software Foundation maintains a vast array of useful software packages
    that are free to get and use. Source code is always available without charge from
    its website. Two packages you might want to investigate include the Commons BeanUtils
    and the Byte Code Engineering Library (BCEL). The [Commons BeanUtils](http://commons.apache.org/beanutils)
    claims to provide easier-to-use wrappers around some of the Reflection API. BCEL
    is a third-party toolkit for building and manipulating bytecode class files. Written
    by Markus Dahm, BCEL has become part of the [Apache Commons Project](http://commons.apache.org/bcel).
  prefs: []
  type: TYPE_NORMAL
