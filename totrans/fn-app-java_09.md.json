["```java\nStream<Long> longStream = Stream.of(5L, 23L, 42L);\n```", "```java\n@FunctionalInterface\npublic interface IntUnaryOperator {\n\n    int applyAsInt(int operand);\n\n    // ...\n}\n```", "```java\n// FOR-LOOP\nfor (int idx = 1; ![1](assets/1.png)\n     idx < 5; ![2](assets/2.png)\n     idx++) { ![3](assets/3.png)\n  System.out.println(idx);\n}\n\n// EQUIVALENT STREAM (Java 8)\nIntStream.iterate(1, ![1](assets/1.png)\n                  idx -> idx + 1) ![3](assets/3.png)\n         .limit(4) ![2](assets/2.png)\n         .forEachOrdered(System.out::println);\n\n// EQUIVALENT STREAM (Java 9+)\nIntStream.iterate(1, ![1](assets/1.png)\n                  idx -> idx < 5, ![2](assets/2.png)\n                  idx -> idx + 1) ![3](assets/3.png)\n         .forEachOrdered(System.out::println);\n```", "```java\nStream<UUID> createStream(int count) {\n  return Stream.generate(UUID::randomUUID)\n               .limit(count);\n}\n```", "```java\nStream.generate(new AtomicInteger()::incrementAndGet)\n      .parallel()\n      .limit(1_000)\n      .mapToInt(Integer::valueOf)\n      .max()\n      .ifPresent(System.out::println);\n```", "```java\nIntStream ints()\nIntStream ints(long streamSize)\n\nIntStream ints(int randomNumberOrigin,\n               int randomNumberBound)\n\nIntStream ints(long streamSize,\n               int randomNumberOrigin,\n               int randomNumberBound)\n\nLongStream longs()\n\nLongStream longs(long streamSize)\n\nLongStream longs(long randomNumberOrigin,\n                 long randomNumberBound)\n\nLongStream longs(long streamSize,\n                 long randomNumberOrigin,\n                 long randomNumberBound)\n\nDoubleStream doubles()\n\nDoubleStream doubles(long streamSize)\n\nDoubleStream doubles(double randomNumberOrigin,\n                     double randomNumberBound)\n\nDoubleStream doubles(long streamSize,\n                     double randomNumberOrigin,\n                     double randomNumberBound)\n```", "```java\nString[] fruits = new String[] {\n    \"Banana\",\n    \"Melon\",\n    \"Orange\"\n};\n\nString[] result = Arrays.stream(fruits)\n                        .filter(fruit -> fruit.contains(\"a\"))\n                        .toArray(String[]::new);\n```", "```java\nint[] fibonacci = new int[] {\n    0, 1, 1, 2, 3, 5, 8, 13, 21, 34\n};\n\nint[] evenNumbers = Arrays.stream(fibonacci)\n                          .filter(value -> value % 2 == 0)\n                          .toArray();\n```", "```java\nSpliterator<T> spliterator(Iterator<? extends T> iterator,\n                                                 long size,\n                                                 int characteristics)\n\nSpliterator<T> spliteratorUnknownSize(Iterator<? extends T> iterator,\n                                      int characteristics)\n```", "```java\n├── README.md\n├── assets\n│   └── a-functional-approach-to-java.png\n├── part-1\n│   ├── 01-an-introduction-to-functional-programming\n│   │   └── README.md\n│   ├── 02-functional-java\n│   │   ├── README.md\n│   │   ├── java\n|   |   └─ ...\n└── part-2\n    ├── 04-immutability\n    │   ├── ...\n    │   └── jshell\n    │       ├── immutable-copy.java\n    │       ├── immutable-math.java\n    │       ├── unmodifiable-list-exception.java\n    │       └── unmodifiable-list-modify-original.java\n    ├─ ...\n```", "```java\nstatic Stream<Path> list(Path dir) throws IOException\n```", "```java\nvar dir = Paths.get(\"./part-2/04-immutability/jshell\");\n\ntry (var stream = Files.list(dir)) {\n  stream.map(Path::getFileName)\n        .forEach(System.out::println);\n} catch (IOException e) {\n  // ...\n}\n```", "```java\nunmodifiable-list-exception.java\nunmodifiable-list-modify-original.java\nimmutable-copy.java\nimmutable-math.java\n```", "```java\nstatic Stream<Path> walk(Path start, ![1](assets/1.png)\n                         int maxDepth, ![2](assets/2.png)\n                         FileVisitOption... options) ![3](assets/3.png)\n                         throws IOException\n\nstatic Stream<Path> walk(Path start, ![1](assets/1.png)\n                         FileVisitOption... options) ![3](assets/3.png)\n                         throws IOException\n```", "```java\nvar start = Paths.get(\"./part-1\");\n\ntry (var stream = Files.walk(start)) {\n  stream.map(Path::toFile)\n        .filter(Predicate.not(File::isFile))\n        .sorted()\n        .forEach(System.out::println);\n} catch (IOException e) {\n  // ...\n}\n```", "```java\n./part-1\n./part-1/01-an-introduction-to-functional-programming\n./part-1/02-functional-java\n./part-1/02-functional-java/java\n./part-1/02-functional-java/jshell\n./part-1/02-functional-java/other\n./part-1/03-functional-jdk\n./part-1/03-functional-jdk/java\n./part-1/03-functional-jdk/jshell\n```", "```java\nstatic Stream<Path> find(Path start, ![1](assets/1.png)\n                         int maxDepth, ![2](assets/2.png)\n                         BiPredicate<Path, BasicFileAttributes> matcher, ![3](assets/3.png)\n                         FileVisitOption... options) ![4](assets/4.png)\n                         throws IOException\n```", "```java\nvar start = Paths.get(\"./part-1\");\n\nBiPredicate<Path, BasicFileAttributes> matcher =\n  (path, attr) -> attr.isDirectory();\n\ntry (var stream = Files.find(start,\n                             Integer.MAX_VALUE,\n                             matcher)) {\n\n    stream.sorted()\n          .forEach(System.out::println);\n} catch (IOException e) {\n  // ...\n}\n```", "```java\nstatic Stream<String> lines(Path path, ![1](assets/1.png)\n                            Charset cs) ![2](assets/2.png)\n                            throws IOException\n\nstatic Stream<String> lines(Path path) ![1](assets/1.png)\n                      throws IOException\n```", "```java\nvar location = Paths.get(\"war-and-peace.txt\"); ![1](assets/1.png)\n\n// CLEANUP PATTERNS ![2](assets/2.png)\nvar punctuation = Pattern.compile(\"\\\\p{Punct}\");\nvar whitespace  = Pattern.compile(\"\\\\s+\");\nvar words       = Pattern.compile(\"\\\\w+\");\n\ntry (Stream<String> stream = Files.lines(location)) { ![3](assets/3.png)\n\n  Map<String, Integer> wordCount =\n\n           // CLEAN CONTENT ![4](assets/4.png)\n    stream.map(punctuation::matcher)\n          .map(matcher -> matcher.replaceAll(\"\"))\n          // SPLIT TO WORDS ![5](assets/5.png)\n          .map(whitespace::split)\n          .flatMap(Arrays::stream)\n          // ADDITIONAL CLEANUP ![6](assets/6.png)\n          .filter(word -> words.matcher(word).matches())\n          // NORMALIZE ![7](assets/7.png)\n          .map(String::toLowerCase)\n          // COUNTING ![8](assets/8.png)\n          .collect(Collectors.toMap(Function.identity(),\n                                    word -> 1,\n                                    Integer::sum));\n} catch (IOException e) {\n  // ...\n}\n```", "```java\ntry (Stream<String> stream = Files.lines(location)) {\n  stream.map(...)\n        ...\n}\n```", "```java\n<R> R query(TemporalQuery<R> query);\n```", "```java\n// TemporalQuery<Boolean> == Predicate<TemporalAccessor>\n\nboolean isItTeaTime = LocalDateTime.now()\n                                   .query(temporal -> {\n                                     var time = LocalTime.from(temporal);\n                                     return time.getHour() >= 16;\n                                   });\n\n// TemporalQuery<LocalTime> == Function<TemporalAccessor,Localtime>\nLocalTime time = LocalDateTime.now().query(LocalTime::from);\n```", "```java\nrecord User(UUID id,\n            String group,\n            LocalDateTime lastLogin,\n            List<String> logEntries) { }\n\nList<User> users = ...;\n```", "```java\nMap<String, List<User>> lookup =\n  users.stream()\n       .collect(Collectors.groupingBy(User::group));\n```", "```java\nCollector<T, ?, Map<K, D>> groupingBy(Function<? super T, ? extends K> classifier,\n                                      Collector<? super T, A, D> downstream)\n```", "```java\n// COLLECT ELEMENTS TO SET\nCollector<UUID, ?, Set<UUID>> collectToSet = Collectors.toSet();\n\n// MAP FROM USER TO UUID\nCollector<User, ?, Set<UUID>> mapToId =\n  Collectors.mapping(User::id,\n                     collectToSet);\n\n// GROUPING BY GROUP\nCollector<User, ?, Map<String, Set<UUID>>> groupingBy =\n  Collectors.groupingBy(User::group, mapToId);\n```", "```java\nimport static java.util.stream.Collectors.*;\n\nMap<String, Set<UUID>> lookup =\n  users.stream()\n       .collect(groupingBy(User::group,\n                           mapping(User::id, toSet())));\n```", "```java\nvar collectIdsToSet = Collectors.mapping(User::id, ![1](assets/1.png)\n                                         Collectors.toSet());\n\n// LAMBDA ALTERNATIVE\n\nvar collectIdsToSetLambda = Collectors.mapping((User user) -> user.id(), ![2](assets/2.png)\n                                               Collectors.toSet());\n\nMap<String, Set<UUID>> lookup =\n  users.stream()\n       .collect(Collectors.groupingBy(User::group,\n                                      collectIdsToSet)); ![3](assets/3.png)\n```", "```java\nvar summingUp = Collectors.reducing(0, Integer::sum);\n\nvar downstream =\n  Collectors.mapping((User user) -> user.logEntries().size(),\n                     summingUp);\n\nMap<UUID, Integer> logCountPerUserId =\n  users.stream()\n       .collect(Collectors.groupingBy(User::id, downstream));\n```", "```java\nCollector<T, ?, U> reducing(U identity,\n                            Function<? super T, ? extends U> mapper,\n                            BinaryOperator<U> op)\n```", "```java\nvar downstream =\n  Collectors.reducing(0,                                       // identity\n                      (User user) -> user.logEntries().size(), // mapper\n                      Integer::sum);                           // op\n\nMap<UUID, Integer> logCountPerUserId =\n  users.stream()\n       .collect(Collectors.groupingBy(User::id, downstream));\n```", "```java\nvar downstream =\n  Collectors.summingInt((User user) -> user.logEntries().size());\n\nMap<UUID, Integer> logCountPerUserId =\n  users.stream()\n       .collect(Collectors.groupingBy(User::id, downstream));\n```", "```java\nstatic Collector<T, ?, R> flatMapping(Function<T, Stream<U>> mapper,\n                                      Collector<U, A, R> downstream)\n```", "```java\nvar downstream =\n  Collectors.flatMapping((User user) -> user.logEntries().stream(),\n                         Collectors.toList());\n\nMap<String, List<String>> result =\n  users.stream()\n       .collect(Collectors.groupingBy(User::group, downstream));\n```", "```java\nstatic <T, A, R> Collector<T,?,R> filtering(Predicate<T> predicate,\n                                            Collector<T, A, R> downstream)\n```", "```java\nimport static java.util.stream.Collectors.*;\n\nvar startOfDay = LocalDate.now().atStartOfDay();\n\nPredicate<User> loggedInToday =\n  Predicate.not(user -> user.lastLogin().isBefore(startOfDay));\n\n// WITH INTERMEDIATE FILTER\n\nMap<String, Set<UUID>> todaysLoginsByGroupWithFilterOp =\n  users.stream()\n       .filter(loggedInToday)\n       .collect(groupingBy(User::group,\n                           mapping(User::id, toSet())));\n\n// WITH COLLECT FILTER\n\nMap<String, Set<UUID>> todaysLoginsByGroupWithFilteringCollector =\n  users.stream()\n       .collect(groupingBy(User::group,\n                           filtering(loggedInToday,\n                                     mapping(User::id, toSet()))));\n```", "```java\nrecord UserStats(long total, long neverLoggedIn) { ![1](assets/1.png)\n  // NO BODY\n}\n\nUserStats result =\n  users.stream()\n       .collect(Collectors.teeing(Collectors.counting(), ![2](assets/2.png)\n                Collectors.filtering(user -> user.lastLogin() == null, ![3](assets/3.png)\n                                     Collectors.counting()),\n                UserStats::new)); ![4](assets/4.png)\n```", "```java\npublic class Joinector implements Collector<CharSequence, // T\n                                            StringJoiner, // A\n                                            String> {     // R\n\n  private final CharSequence delimiter;\n\n  public Joinector(CharSequence delimiter) {\n    this.delimiter = delimiter;\n  }\n\n  @Override\n  public Supplier<StringJoiner> supplier() {\n    return () -> new StringJoiner(this.delimiter); ![1](assets/1.png)\n  }\n\n  @Override\n  public BiConsumer<StringJoiner, CharSequence> accumulator() {\n    return StringJoiner::add; ![2](assets/2.png)\n  }\n\n  @Override\n  public BinaryOperator<StringJoiner> combiner() {\n    return StringJoiner::merge; ![3](assets/3.png)\n  }\n\n  @Override\n  public Function<StringJoiner, String> finisher() {\n    return StringJoiner::toString; ![4](assets/4.png)\n  }\n\n  @Override\n  public Set<Characteristics> characteristics() {\n    return Collections.emptySet(); ![5](assets/5.png)\n  }\n}\n```", "```java\nCollector<CharSequence, StringJoiner, String> joinector =\n  Collector.of(() -> new StringJoiner(delimiter), // supplier\n               StringJoiner::add,                 // accumulator\n               StringJoiner::merge,               // combiner\n               StringJoiner::toString);           // finisher\n```"]