<html><head></head><body>
<div id="sbo-rt-content"><section data-nutshell-tab="Platform Tools" data-pdf-bookmark="Chapter 13. Platform Tools" data-type="chapter" epub:type="chapter"><div class="chapter" id="javanut8-CHP-13">
<h1><span class="label">Chapter 13. </span>Platform Tools</h1>
<p>This chapter discusses the tools that ship with the OpenJDK version of the Java platform. The tools covered are all command-line tools.
If you are using a different version of Java, you may find different tools as part of your distribution but with similar function.</p>
<p>Later in the chapter, we devote dedicated sections to two tools: <code>jshell</code>, which
introduced interactive development to the Java platform, and Java Flight
Recorder (JFR) tooling for deep profiling of Java applications.</p>
<section data-pdf-bookmark="Command-Line Tools" data-type="sect1"><div class="sect1" id="javanut8-CHP-13-SECT-1">
<h1>Command-Line Tools</h1>
<p>The command-line tools we cover are the most commonly used tools and those of greatest utility—they are not a complete description of every available tool.
In particular, tools concerned with CORBA and the server portion of RMI are not covered, as these modules were removed from the platform with the release of Java 11.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>In some cases, we need to discuss switches that take filesystem paths.
As elsewhere in the book, we use Unix conventions for such cases.</p>
</div>
<p>Below we’ll discuss the following tools, including their basic usage, description, and common switches:</p>
<ul>
<li>
<p><code>javac</code></p>
</li>
<li>
<p><code>java</code></p>
</li>
<li>
<p><code>jar</code></p>
</li>
<li>
<p><code>javadoc</code></p>
</li>
<li>
<p><code>jdeps</code></p>
</li>
<li>
<p><code>jps</code></p>
</li>
<li>
<p><code>jstat</code></p>
</li>
<li>
<p><code>jstatd</code></p>
</li>
<li>
<p><code>jinfo</code></p>
</li>
<li>
<p><code>jstack</code></p>
</li>
<li>
<p><code>jmap</code></p>
</li>
<li>
<p><code>javap</code></p>
</li>
<li>
<p><code>jlink</code></p>
</li>
<li>
<p><code>jmod</code></p>
</li>
<li>
<p><code>jcmd</code></p>
</li>
</ul>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Options described throughout are targeted at Java 17 and may vary in older Java
versions. For example, <code>--class-path</code> was introduced when <code>--module-path</code> became
an option but won’t work on Java 8 and earlier (which require <code>-cp</code> or
<code>--classpath</code>).</p>
</div>
<div class="refentry" id="javanut8-CHP-13-SECT-1.1">
<header>
<p class="refname bottom-left">javac</p>
</header>
<div class="refsect1" id="_basic_usage">
<h6>Basic usage</h6>
<p><code><a contenteditable="false" data-primary="compilers, javac and" data-type="indexterm" id="idm45927698810032"/><a contenteditable="false" data-primary="javac" data-type="indexterm" id="idm45927698808832"/>bjavac <em>some</em>/<em>package</em>/MyClass.java</code></p>
</div>
<div class="refsect1" id="_description">
<h6>Description</h6>
<p><code>javac</code> is the Java source code  compiler—it produces bytecode (in the form of <em>.class</em> files) from <em>.java</em> source files.</p>
<p>For modern Java projects, <code>javac</code> is not often used directly, as it is rather low-level and unwieldy, especially for larger codebases. Instead, modern integrated development environments (IDEs) either drive <code>javac</code> automatically for the developer or have built-in compilers for use while code is being written. For deployment, most projects will use a separate build tool, most commonly Maven or Gradle. Discussion of these tools is outside the scope of this book.</p>
<p>Nevertheless, it is useful for developers to understand how to use <code>javac</code>, as there are cases when compiling small codebases by hand is preferable to having to install and manage a production-grade build tool such as Maven.</p>
</div>
<div class="refsect1" id="_common_switches">
<h6>Common switches</h6>
<dl>
<dt><code>-cp</code>, <code>--class-path <em>&lt;path&gt;</em></code></dt>
<dd>
<p>Supply classes we need for compilation.</p>
</dd>
<dt><code>-p</code>, <code>--module-path <em>&lt;path&gt;</em></code></dt>
<dd>
<p>Supply application modules for compilation. See <a href="ch12.xhtml#javanut8-CHP-12">Chapter 12</a> for a full discussion of Java modules.</p>
</dd>
<dt><code>-d <em>some</em>/<em>dir</em></code></dt>
<dd>
<p>Tell <code>javac</code> where to output class files.</p>
</dd>
<dt><code>@project.list</code></dt>
<dd>
<p>Load options and source files from the file <em>project.list</em>.</p>
</dd>
<dt><code>-help</code></dt>
<dd>
<p>Help on options.</p>
</dd>
<dt><code>-X</code></dt>
<dd>
<p>Help on nonstandard options.</p>
</dd>
<dt><code>-source <em>&lt;version&gt;</em></code></dt>
<dd>
<p>Control the Java version that <code>javac</code> will accept.</p>
</dd>
<dt><code>-target <em>&lt;version&gt;</em></code></dt>
<dd>
<p>Control the version of class files that <code>javac</code> will output.</p>
</dd>
<dt><code>-profile <em>&lt;profile&gt;</em></code></dt>
<dd>
<p>Control the profile that <code>javac</code> will use when compiling the application.</p>
</dd>
<dt><code>-Xlint</code></dt>
<dd>
<p>Enable detail about warnings.</p>
</dd>
<dt><code>-Xstdout <em>&lt;path&gt;</em></code></dt>
<dd>
<p>Redirect output of compilation run to a file.</p>
</dd>
<dt><code>-g</code></dt>
<dd>
<p>Add debug information to class files.</p>
</dd>
</dl>
</div>
<div class="refsect1" id="_notes">
<h6>Notes</h6>
<p><code>javac</code> has traditionally accepted switches (<code>-source</code> and <code>-target</code>) that control the version of the source language that the compiler accepts and the version of the class file format used for the outputted class files.</p>
<p>This facility introduces additional compiler complexity (as multiple language syntaxes must be supported internally) for some small developer benefit. In Java 8, this capability was slightly tidied up and placed on a more formal basis.</p>
<p>From JDK 8 onward, <code>javac</code> will only accept source and target options from three versions back. That is, only the formats from JDK 5, 6, 7, and 8 will be accepted by <code>javac</code> version 8. This does not affect the <code>java</code> interpreter—any class file from any Java version will still work on the JVM shipped with Java 8.</p>
<p>C and C++ developers may find that the <code>-g</code> switch is less helpful to them than it is in those other languages. This is largely due to the widespread use of IDEs in the Java ecosystem—integrated debugging is simply a lot more useful, and easier to use, than additional debug symbols in class files.</p>
<p>The use of the lint capability remains somewhat controversial among developers. Many Java developers produce code that triggers a large number of compilation warnings, which they then simply ignore. However, experience on larger codebases (especially on the JDK codebase itself) suggests that in a substantial percentage of cases, code that triggers warnings is code in which subtle bugs may lurk. Use of the lint feature, or static analysis tools (such as SpotBugs), is strongly recommended.</p>
</div>
</div>
<div class="refentry" id="javanut8-CHP-13-SECT-1.2">
<header>
<p class="refname bottom-left">java</p>
</header>
<div class="refsect1" id="_basic_usage_2">
<h6>Basic usage</h6>
<p><a contenteditable="false" data-primary="java command" data-type="indexterm" id="idm45927698764416"/><a contenteditable="false" data-primary="Java Virtual Machine (JVM)" data-secondary="java command" data-type="indexterm" id="idm45927698763312"/>b<code>java some.package.MyClass</code><br/>
<code>java -jar my-packaged.jar</code></p>
</div>
<div class="refsect1" id="_description_2">
<h6>Description</h6>
<p><code>java</code> is the executable that starts up a Java Virtual Machine. The initial entry point into the program is the <code>main()</code> method that exists on the named class and that has the signature:</p>
<pre data-code-language="java" data-type="programlisting">
<code class="kd">public</code><code class="w"> </code><code class="kd">static</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">main</code><code class="p">(</code><code class="n">String</code><code class="o">[]</code><code class="w"> </code><code class="n">args</code><code class="p">);</code><code class="w"/></pre>
<p>This method is run on the single application thread created by the JVM startup. The JVM process will exit once this method returns (and any additional nondaemon application threads that were started have terminated).</p>
<p>If the form takes a JAR file rather than a class (the executable JAR form), the JAR file must contain a piece of metadata that tells the JVM which class to start from.</p>
<p>This bit of metadata is the <code>Main-Class</code>: attribute, and it is contained in the <span class="keep-together"><em>MANIFEST.MF</em></span> file in the <em>META-INF/</em> directory. See the description of the <code>jar</code> tool for more details.</p>
</div>
<div class="refsect1" id="_common_switches_2">
<h6>Common switches</h6>
<dl>
<dt><code>-cp</code>, <code>--class-path <em>&lt;path&gt;</em></code></dt>
<dd>
<p>Define the classpath to read from.</p>
</dd>
<dt><code>-p</code>, <code>--module-path <em>&lt;path&gt;</em></code></dt>
<dd>
<p>Define the path to find modules.</p>
</dd>
<dt><code>--list-modules</code></dt>
<dd>
<p>List modules found with current settings and exits.</p>
</dd>
<dt><code>-X</code>, <code>-?</code>, <code>-help</code></dt>
<dd>
<p>Provide help about the <code>java</code> executable and its switches.</p>
</dd>
<dt><code>-D<em>&lt;property=value&gt;</em></code></dt>
<dd>
<p>Set a Java system property that can be retrieved by the Java program. Any number of such properties can be specified this way.</p>
</dd>
<dt><code>-jar</code></dt>
<dd>
<p>Run an executable JAR (see <a href="#refname_jar">the entry for <code>jar</code></a>).</p>
</dd>
<dt><code>-Xbootclasspath(/a or /p)</code></dt>
<dd>
<p>Run with an alternative system classpath (very rarely used).</p>
</dd>
<dt><code>-client</code>, <code>-server</code></dt>
<dd>
<p>Select a HotSpot JIT compiler (see <a href="#_notes_2">“Notes” for this entry</a>).</p>
</dd>
<dt><code>-Xint</code>, <code>-Xcomp</code>, <code>-Xmixed</code></dt>
<dd>
<p>Control JIT compilation (very rarely used).</p>
</dd>
<dt><code>-Xms<em>&lt;size&gt;</em></code></dt>
<dd>
<p>Set the minimum committed heap size for the JVM.</p>
</dd>
<dt><code>-Xmx<em>&lt;size&gt;</em></code></dt>
<dd>
<p>Set the maximum committed heap size for the JVM.</p>
</dd>
<dt><code>-agentlib:<em>&lt;agent&gt;</em></code>, <code>-agentpath:<em>&lt;path to agent&gt;</em></code></dt>
<dd>
<p>Specify a JVM Tooling Interface (JVMTI) agent to attach to the process being started. Agents are typically used for instrumentation or monitoring.</p>
</dd>
<dt><code>-verbose</code></dt>
<dd>
<p>Generate additional output, sometimes useful for debugging.</p>
</dd>
</dl>
</div>
<div class="refsect1" id="_notes_2">
<h6>Notes</h6>
<p><a contenteditable="false" data-primary="HotSpot JVM" data-type="indexterm" id="idm45927698683888"/>The HotSpot VM contains two separate JIT compilers—known as the client (or C1) compiler and the server (or C2) compiler. These were designed for different purposes, with the client compiler offering more predictable performance and quicker startup, at the expense of not performing aggressive code optimization.</p>
<p>Traditionally, the JIT compiler that a Java process used was chosen at process startup via the <code>-client</code> or <code>-server</code> switch. However, as hardware advances have made compilation ever cheaper, a new possibility has become available—to use the client compiler early on, while the Java process is warming up, and then to switch to the high-performance optimizations available in the server compiler when they are available. This scheme is called Tiered Compilation, and it is the default in Java 8. Most processes will no longer need explicit <code>-client</code> or <code>-server</code> switches.</p>
<p>On the Windows platform, a slightly different version of the <code>java</code> executable is often used—<code>javaw</code>. This version starts up a Java Virtual Machine, without forcing a Windows console window to appear.</p>
<p>In older Java versions, a number of different legacy interpreters and virtual machine modes were supported. These have now mostly been removed and any remaining should be regarded as vestigial.</p>
<p>Switches that start with <code>-X</code> were intended to be nonstandard switches. However, the trend has been to standardize a number of these switches (particularly <code>-Xms</code> and <code><span class="keep-together">-Xmx</span></code>). In parallel, Java versions have introduced an increasing number of <code>-XX</code>: switches. These were intended to be experimental and not for production use. <span class="keep-together">However</span>, as the implementations have stabilized, some of these switches are now suitable for some advanced users (even in production deployments).</p>
<p>In general, a full discussion of switches is outside the scope of this book. Configuration of the JVM for production use is a specialist subject, and developers are urged to take care, especially when modifying any switches related to the garbage collection subsystem.</p>
</div>
</div>
<div class="refentry" id="javanut8-CHP-13-SECT-1.3">
<header>
<p class="refname bottom-left" id="refname_jar">jar</p>
</header>
<div class="refsect1" id="_basic_usage_3">
<h6>Basic usage</h6>
<p><a contenteditable="false" data-primary="JAR (Java archive) files" data-secondary="jar and" data-type="indexterm" id="idm45927698670656"/><a contenteditable="false" data-primary="jar command" data-type="indexterm" id="idm45927698669264"/><code>jar cvf my.jar <em>someDir/</em> </code></p>
</div>
<div class="refsect1" id="_description_3">
<h6>Description</h6>
<p>The <code>jar</code> utility is used to create and manipulate Java Archive (<em>.jar</em>) files. These are ZIP format files that contain Java classes, additional resources, and (usually) metadata. The tool has five major modes of operation—Create, Update, Index, List, and Extract—on a JAR file.</p>
<p class="pagebreak-after">These are controlled by passing a command option character (not a switch) to <code>jar</code>. Only one command character can be specified, but optional modifier characters can also be used.</p>
</div>
<div class="refsect1" id="_command_options">
<h6>Command options</h6>
<ul>
<li>
<p><code>c</code>: Create a new archive</p>
</li>
<li>
<p><code>u</code>: Update archive</p>
</li>
<li>
<p><code>i</code>: Index an archive</p>
</li>
<li>
<p><code>t</code>: List an archive</p>
</li>
<li>
<p><code>x</code>: Extract an archive</p>
</li>
</ul>
</div>
<div class="refsect1" id="_modifiers">
<h6>Modifiers</h6>
<ul>
<li>
<p><code>v</code>: Verbose mode</p>
</li>
<li>
<p><code>f</code>: Operate on a named file, rather than standard input</p>
</li>
<li>
<p><code>0</code>: Store, but do not compress, files added to the archive</p>
</li>
<li>
<p><code>m</code>: Add the contents of the specified file to the <code>jar</code> metadata manifest</p>
</li>
<li>
<p><code>e</code>: Make this <code>jar</code> executable, with the specified class as the entry point</p>
</li>
</ul>
</div>
<div class="refsect1" id="_notes_3">
<h6>Notes</h6>
<p>The syntax of the <code>jar</code> command is intentionally very similar to that of the Unix <code>tar</code> command. This similarity is the reason <code>jar</code> uses command options, rather than switches (as the other Java platform commands do). More typical explicit switches (e.g. <code>--create</code>) are also available and documentation for them can be found via <code>jar --help</code>.</p>
<p>When you create a JAR file, the <code>jar</code> tool will automatically add a directory called <em>META-INF</em> that contains a file called <em>MANIFEST.MF</em>—this is metadata in the form of headers paired with values. By default, <em>MANIFEST.MF</em> contains just two headers:</p>
<pre data-type="programlisting">
Manifest-Version: 1.0
Created-By: 17.0.4 (Eclipse Adoptium)</pre>
<p>Using the <code>m</code> option allows additional metadata to be added into <em>MANIFEST.MF</em> at JAR creation time. One frequently added piece is the <code>Main-Class:</code> attribute, which indicates the entry point into the application contained in the JAR. A JAR with a specified <code>Main-Class:</code> can be directly executed by the JVM, via <code>java -jar</code>, or double-clicking the JAR in a graphical file browser.</p>
<p>The addition of the <code>Main-Class:</code> attribute is so common that <code>jar</code> has the <code>e</code> option to create it directly in <em>MANIFEST.MF</em>, rather than having to create a separate text file for this purpose. Contents of a jar, including the manifest, may be inspected easily using the <code>--extract</code> option.</p>
</div>
</div>
<div class="refentry" id="javanut8-CHP-13-SECT-1.4">
<header>
<p class="refname bottom-left">javadoc</p>
</header>
<div class="refsect1" id="_basic_usage_4">
<h6>Basic usage</h6>
<p><a contenteditable="false" data-primary="javadoc" data-secondary="basics" data-type="indexterm" id="idm45927698629872"/><code>javadoc <em>some.package</em></code></p>
</div>
<div class="refsect1" id="_description_4">
<h6>Description</h6>
<p><code>javadoc</code> produces documentation from Java source files. It does so by reading a special comment format (known as Javadoc comments) and parsing it into a standard documentation format, which can then be output into a variety of document formats (although HTML is by far the most common).</p>
<p>For a full description of Javadoc syntax, refer to <a href="ch07.xhtml#javanut8-CHP-7">Chapter 7</a>.</p>
</div>
<div class="refsect1" id="_common_switches_3">
<h6>Common switches</h6>
<dl>
<dt><code>-cp</code>, <code>--class-path <em>&lt;path&gt;</em></code></dt>
<dd>
<p>Define the classpath to use.</p>
</dd>
<dt><code>-p</code>, <code>--module-path <em>&lt;path&gt;</em></code></dt>
<dd>
<p>Define the path to find modules.</p>
</dd>
<dt><code>-D <em>&lt;directory&gt;</em></code></dt>
<dd>
<p>Tell <code>javadoc</code> where to output the generated docs.</p>
</dd>
<dt><code>-quiet</code></dt>
<dd>
<p>Suppress output except for errors and warnings.</p>
</dd>
</dl>
</div>
<div class="refsect1" id="_notes_4">
<h6>Notes</h6>
<p>The platform API docs are all written in Javadoc.</p>
<p><code>javadoc</code> is built on top of the same classes as <code>javac</code> and uses some of the source compiler infrastructure to implement Javadoc features.</p>
<p>The typical way to use <code>javadoc</code> is to run it against a whole package, rather than just a class.</p>
<p class="pagebreak-after"><code>javadoc</code> has a very large number of switches and options that can control many aspects of its behavior. Detailed discussion of all the options is outside the scope of this book.</p>
</div>
</div>
<div class="refentry" id="javanut8-CHP-13-SECT-1.5">
<header>
<p class="refname bottom-left">jdeps</p>
</header>
<p><a contenteditable="false" data-primary="jdeps tool" data-type="indexterm" id="idm45927698606800"/>bThe <code>jdeps</code> tool is a static analysis tool for analyzing the dependencies of packages or classes. The tool has a number of usages, from identifying developer code that makes calls into the internal, undocumented JDK APIs (such as the <code>sun.misc</code> classes) to helping trace transitive dependencies.</p>
<p><code>jdeps</code> can also be used to confirm whether a JAR file can run under a Compact Profile (see later in the chapter for more details on Compact Profiles).</p>
<div class="refsect1" id="_basic_usage_5">
<h6>Basic usage</h6>
<p><code>jdeps com.me.MyClass</code></p>
</div>
<div class="refsect1" id="_description_5">
<h6>Description</h6>
<p><code>jdeps</code> reports dependency information for the classes it is asked to analyze. The classes can be specified as any class on the classpath, a file path, a directory, or a JAR file.</p>
</div>
<div class="refsect1" id="_common_switches_4">
<h6>Common switches</h6>
<dl>
<dt><code>-cp</code>, <code>--class-path <em>&lt;path&gt;</em></code></dt>
<dd>
<p>Define the classpath to use.</p>
</dd>
<dt><code>-p</code>, <code>--module-path <em>&lt;path&gt;</em></code></dt>
<dd>
<p>Define the path to find modules.</p>
</dd>
<dt><code>-s</code>, <code>-summary</code></dt>
<dd>
<p>Print dependency summary only.</p>
</dd>
<dt><code>-m <em>&lt;module-name&gt;</em></code></dt>
<dd>
<p>Target a module for analysis</p>
</dd>
<dt><code>-v</code>, <code>-verbose</code></dt>
<dd>
<p>Print all class-level dependencies.</p>
</dd>
<dt><code>-verbose:package</code></dt>
<dd>
<p>Print package-level dependencies, excluding dependencies within the same archive.</p>
</dd>
<dt><code>-verbose:class</code></dt>
<dd>
<p>Print class-level dependencies, excluding dependencies within the same archive.</p>
</dd>
<dt><code>-p <em>&lt;pkg name&gt;</em>, -package <em>&lt;pkg name&gt;</em></code></dt>
<dd>
<p>Find dependencies in the specified package. You can specify this option multiple times for different packages. The <code>-p</code> and <code>-e</code> options are mutually exclusive.</p>
</dd>
<dt><code>-e <em>&lt;regex&gt;</em>, -regex <em>&lt;regex&gt;</em></code></dt>
<dd>
<p>Find dependencies in packages matching the specified regular expression pattern. The <code>-p</code> and <code>-e</code> options are mutually exclusive.</p>
</dd>
<dt><code>-include <em>&lt;regex&gt;</em></code></dt>
<dd>
<p>Restrict analysis to classes matching pattern. This option filters the list of classes to be analyzed. It can be used together with <code>-p</code> and <code>-e</code>.</p>
</dd>
<dt><code>-jdkinternals</code></dt>
<dd>
<p>Find class-level dependencies in JDK internal APIs (which may change or disappear in even minor platform releases).</p>
</dd>
<dt><code>-apionly</code></dt>
<dd>
<p>Restrict analysis to APIs—for example, dependencies from the signature of public and protected members of public classes including field type, method parameter types, returned type, and checked exception types.</p>
</dd>
<dt><code>-R</code>, <code>-recursive</code></dt>
<dd>
<p>Recursively traverse all dependencies.</p>
</dd>
<dt><code>-h</code>, <code>-?</code>, <code>--help</code></dt>
<dd>
<p>Print help message for <code>jdeps</code>.</p>
</dd>
</dl>
</div>
<div class="refsect1" id="_notes_5">
<h6>Notes</h6>
<p><code>jdeps</code> is a useful tool for making developers aware of their dependencies on the JRE not as a monolithic environment but as something more modular.</p>
</div>
</div>
<div class="refentry" id="javanut8-CHP-13-SECT-1.6">
<header>
<p class="refname bottom-left">jps</p>
</header>
<div class="refsect1" id="_basic_usage_6">
<h6>Basic usage</h6>
<p><a contenteditable="false" data-primary="jps command" data-type="indexterm" id="idm45927698561408"/><code>jps</code><br/>
<code>jps <em>&lt;remote URL&gt;</em></code></p>
</div>
<div class="refsect1" id="_description_6">
<h6>Description</h6>
<p><code>jps</code> provides a list of all active JVM processes on the local machine (or a remote machine, if a suitable instance of <code>jstatd</code> is running on the remote side). Remote URL support requires RMI; this configuration is explained in more detail in the <code>jstatd</code> section.</p>
</div>
<div class="refsect1" id="_common_switches_5">
<h6>Common switches</h6>
<dl>
<dt><code>-m</code></dt>
<dd>
<p>Output the arguments passed to the main method.</p>
</dd>
<dt><code>-l</code></dt>
<dd>
<p>Output the full package name for the application’s main class (or the full path name to the application’s JAR file).</p>
</dd>
<dt><code>-v</code></dt>
<dd>
<p>Output the arguments passed to the JVM.</p>
</dd>
</dl>
</div>
<div class="refsect1" id="_notes_6">
<h6>Notes</h6>
<p>This command is not strictly necessary, as the standard Unix <code>ps</code> command could suffice. However, it does not use the standard Unix mechanism for interrogating the process, so there are circumstances in which a Java process stops responding (and looks dead to <code>jps</code>) but is still listed as alive by the operating system.</p>
</div>
</div>
<div class="refentry" id="javanut8-CHP-13-SECT-1.7">
<header>
<p class="refname bottom-left">jstat</p>
</header>
<div class="refsect1" id="_basic_usage_65">
<h6>Basic usage</h6>
<p><a contenteditable="false" data-primary="jstat command" data-type="indexterm" id="idm45927698542624"/><code>jstat -options</code><br/>
<code>jstat <em>&lt;report type such as -class&gt;</em> <em>&lt;PID&gt;</em></code></p>
</div>
<div class="refsect1" id="_description_7">
<h6>Description</h6>
<p>This command displays some basic statistics about a given Java process. This is usually a local process but can be located on a remote machine, provided the remote side is running a suitable <code>jstatd</code> process.</p>
</div>
<div class="refsect1" id="_common_switches_6">
<h6>Common switches</h6>
<dl>
<dt><code>-options</code></dt>
<dd>
<p>List report types that <code>jstat</code> can produce. Most common options are:</p>
<dl>
<dt><code>-class</code></dt>
<dd>
<p>Report on classloading activity to date.</p>
</dd>
<dt><code>-compiler</code></dt>
<dd>
<p>JIT compilation of the process so far.</p>
</dd>
<dt><code>-gcutil</code></dt>
<dd>
<p>Detailed garbage collection report.</p>
</dd>
<dt><code>-printcompilation</code></dt>
<dd>
<p>More detail on compilation.</p>
</dd>
</dl>
</dd>
</dl>
</div>
<div class="refsect1" id="_notes_7">
<h6>Notes</h6>
<p>The general syntax <code>jstat</code> uses to identify a process (which may be remote) is:</p>
<pre data-code-language="java" data-type="programlisting">
<code class="o">[</code><em><code class="o">&lt;</code><code class="n">protocol</code><code class="o">&gt;</code></em><code class="p">:</code><code class="c1">//]&lt;vmid&gt;[@hostname][:port][/servername]</code></pre>
<p>This syntax is used to specify a remote process (which is usually connected to via JMX over RMI), but in practice, the more common local syntax simply uses the VM ID, which is the operating system process ID (PID) on mainstream platforms (Linux, Windows, Unix, macOS, etc.).</p>
</div>
</div>
<div class="refentry" id="javanut8-CHP-13-SECT-1.8">
<header>
<p class="refname bottom-left">jstatd</p>
</header>
<div class="refsect1" id="_basic_usage_7">
<h6>Basic usage</h6>
<p><a contenteditable="false" data-primary="jstad tool" data-type="indexterm" id="idm45927698511376"/><code>jstatd <em>&lt;options&gt;</em></code></p>
</div>
<div class="refsect1" id="_description_8">
<h6>Description</h6>
<p><code>jstatd</code> makes information about local JVMs available over the network. It achieves this using RMI and can make these otherwise-local capabilities accessible to JMX clients. This requires special security settings, which differ from the JVM defaults. To start <code>jstatd</code>, first we need to create the following file and name it <em>jstatd.policy</em>:</p>
<pre data-code-language="java" data-type="programlisting">
<code class="n">grant</code><code class="w"> </code><code class="n">codebase</code><code class="w"> </code><code class="s">"jrt:/jdk.jstatd"</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="n">permission</code><code class="w"> </code><code class="n">java</code><code class="p">.</code><code class="na">security</code><code class="p">.</code><code class="na">AllPermission</code><code class="p">;</code><code class="w"/>
<code class="p">};</code><code class="w"/>

<code class="n">grant</code><code class="w"> </code><code class="n">codebase</code><code class="w"> </code><code class="s">"jrt:/jdk.internal.jvmstat"</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="n">permission</code><code class="w"> </code><code class="n">java</code><code class="p">.</code><code class="na">security</code><code class="p">.</code><code class="na">AllPermission</code><code class="p">;</code><code class="w"/>
<code class="p">};</code><code class="w"/></pre>
<p>This policy file grants all security permissions to any class loaded from the JDK modules that implement <code>jstatd</code>. The precise policy requirements changed with the introduction of modules in JDK 9 and may vary in future JDK versions.</p>
<p>To launch <code>jstatd</code> with this policy, use this command line:</p>
<pre data-code-language="java" data-type="programlisting">
<code class="n">jstatd</code><code class="w"> </code><code class="o">-</code><code class="n">J</code><code class="o">-</code><code class="n">Djava</code><code class="p">.</code><code class="na">security</code><code class="p">.</code><code class="na">policy</code><code class="o">=</code><em><code class="o">&lt;</code><code class="n">path</code><code class="w"> </code><code class="n">to</code><code class="w"> </code><code class="n">jstat</code><code class="p">.</code><code class="na">policy</code><code class="o">&gt;</code></em></pre>
</div>
<div class="refsect1" id="_common_switches_7">
<h6>Common switches</h6>
<dl>
<dt><code>-p <em>&lt;port&gt;</em></code></dt>
<dd>
<p>Look for an existing RMI registry on that port and create one if not found.</p>
</dd>
</dl>
</div>
<div class="refsect1" id="_notes_8">
<h6>Notes</h6>
<p>It is recommended that <code>jstatd</code> is always switched on in production environments but not over the public internet. For most corporate and enterprise environments, this is nontrivial to achieve and will require the cooperation of Operations and Network Engineering staff. However, the benefits of having telemetry data from production JVMs, especially during outages, are difficult to overstate.</p>
<p>A full discussion of JMX and monitoring techniques is outside the scope of this book.</p>
</div>
</div>
<div class="refentry" id="javanut8-CHP-13-SECT-1.9">
<header>
<p class="refname bottom-left">jinfo</p>
</header>
<div class="refsect1" id="_basic_usage_8">
<h6>Basic usage</h6>
<p><a contenteditable="false" data-primary="jinfo tool" data-type="indexterm" id="idm45927698365312"/><code>jinfo <em>&lt;PID&gt;</em></code><br/>
<code>jinfo <em>&lt;core file&gt;</em></code></p>
</div>
<div class="refsect1" id="_description_9">
<h6>Description</h6>
<p>This tool displays the system properties and JVM options for a running Java process (or a core file).</p>
</div>
<div class="refsect1" id="_common_switches_8">
<h6>Common switches</h6>
<dl>
<dt><code>-flags</code></dt>
<dd>
<p>Display JVM flags only.</p>
</dd>
<dt><code>-sysprops</code></dt>
<dd>
<p>Display system properties only.</p>
</dd>
</dl>
</div>
<div class="refsect1" id="_notes_9">
<h6>Notes</h6>
<p>In practice, this is very rarely used—although it can occasionally be helpful as a sanity check that the expected program is actually the one that is executing.</p>
</div>
</div>
<div class="refentry" id="javanut8-CHP-13-SECT-1.10">
<header>
<p class="refname bottom-left">jstack</p>
</header>
<div class="refsect1" id="_basic_usage_85">
<h6>Basic usage</h6>
<p><a contenteditable="false" data-primary="jstack utility" data-type="indexterm" id="idm45927698350176"/><code>jstack <em>&lt;PID&gt;</em></code></p>
</div>
<div class="refsect1" id="_description_10">
<h6>Description</h6>
<p>The <code>jstack</code> utility produces a stack trace for each Java thread in the process.</p>
</div>
<div class="refsect1" id="_common_switches_9">
<h6>Common switches</h6>
<dl>
<dt><code>-e</code></dt>
<dd>
<p>Extended mode (contains additional information about threads).</p>
</dd>
<dt><code>-l</code></dt>
<dd>
<p>Long mode (contains additional information about locks).</p>
</dd>
</dl>
</div>
<div class="refsect1" id="_notes_11">
<h6>Notes</h6>
<p>Producing the stack trace does not stop or terminate the Java process. The files that <code>jstack</code> produces can be very large, and some postprocessing of the file is usually necessary.</p>
</div>
</div>
<div class="refentry" id="javanut8-CHP-13-SECT-1.11">
<header>
<p class="refname bottom-left">jmap</p>
</header>
<div class="refsect1" id="_basic_usage_86">
<h6>Basic usage</h6>
<p><a contenteditable="false" data-primary="jmap utility" data-type="indexterm" id="idm45927698335248"/><code>jmap <em>&lt;output option&gt;</em> <em>&lt;process&gt;</em></code></p>
</div>
<div class="refsect1" id="_description_11">
<h6>Description</h6>
<p><code>jmap</code> provides a view of memory allocation for a running Java process.</p>
</div>
<div class="refsect1" id="_common_switches_10">
<h6>Common switches</h6>
<dl>
<dt><em>-dump:&lt;option&gt;,file=&lt;location;&gt;</em></dt>
<dd>
<p>Produce a heap dump from the running process.</p>
</dd>
<dt><em>-histo</em></dt>
<dd>
<p>Produce a histogram of the current state of allocated memory.</p>
</dd>
<dt><em>-histo:live</em></dt>
<dd>
<p>This version of the histogram displays information only for live objects.</p>
</dd>
</dl>
</div>
<div class="refsect1" id="_notes_12">
<h6>Notes</h6>
<p>The histogram forms walk the JVMs allocation list. This includes both live and dead (but not yet collected) objects. The histogram is organized by the type of objects using memory and is ordered from greatest to least number of bytes used by a particular type. The standard form does not pause the JVM.</p>
<p>The live form ensures that it is accurate by performing a full, stop-the-world (STW) garbage collection before executing. As a result, it should not be used on a production system at a time when a full GC would appreciably impact users.</p>
<p>For the <code>-dump</code> form, note that the production of a heap dump can be a time-consuming process and is STW. The size of the resulting file is proportional to the currently allocated heap and hence may be extremely large for some processes.</p>
</div>
</div>
<div class="refsect1" id="javanut8-CHP-13-SECT-1.12">
<header>
<p class="refname bottom-left">javap</p>
</header>
<div class="refsect1" id="_basic_usage_87">
<h6>Basic usage</h6>
<p><a contenteditable="false" data-primary="javap tool" data-type="indexterm" id="idm45927698317424"/><code>javap <em>&lt;classname&gt;</em></code><br/>
<code>javap <em>&lt;path/to/ClassFile.class&gt;</em></code></p>
</div>
<div class="refsect1" id="_description_12">
<h6>Description</h6>
<p><code>javap</code> is the Java class disassembler—effectively a tool for peeking inside class files. It can show the bytecode that Java methods have been compiled into, as well as the constant pool information (which contains information similar to that of the symbol table of Unix processes).</p>
<p>By default, <code>javap</code> shows signatures of <code>public</code>, <code>protected</code>, and default methods. The <code>-p</code> switch will also show <code>private</code> methods.</p>
</div>
<div class="refsect1" id="_common_switches_11">
<h6>Common switches</h6>
<dl>
<dt><code>-c</code></dt>
<dd>
<p>Decompile bytecode</p>
</dd>
<dt><code>-v</code></dt>
<dd>
<p>Verbose mode (include constant pool information)</p>
</dd>
<dt><code>-p</code></dt>
<dd>
<p>Include <code>private</code> methods</p>
</dd>
<dt><code>-cp</code>, <code>--class-path</code></dt>
<dd>
<p>Location of classes if loading by class name</p>
</dd>
<dt><code>-p</code>, <code>--module-path</code></dt>
<dd>
<p>Location of modules if loading by class name</p>
</dd>
</dl>
</div>
<div class="refsect1" id="_notes_13">
<h6>Notes</h6>
<p>The <code>javap</code> tool will work with any class file, provided <code>javap</code> is from a JDK version the same as (or later than) the one that produced the file.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>Some Java language features may have surprising implementations in bytecode. For example, as we saw in <a href="ch09.xhtml#javanut8-CHP-9">Chapter 9</a>, Java’s <code>String</code> class has effectively immutable instances, and the JVM implements the string concatenation operator <code>+</code> in a different way in Java versions after 8. This difference is clearly visible in the disassembled bytecode shown by <code>javap</code>.</div>
</div>
</div>
<div class="refsect1" id="javanut8-CHP-13-SECT-1.13">
<header>
<p class="refname bottom-left">jlink</p>
</header>
<div class="refsect1" id="_basic_usage_89">
<h6>Basic usage</h6>
<p><a contenteditable="false" data-primary="jlink tool" data-type="indexterm" id="idm45927698289216"/><code>jlink <em>[options]</em> --module-path modulepath --add-modules module</code></p>
</div>
<div class="refsect1" id="_description_13">
<h6>Description</h6>
<p><code>jlink</code> is the custom runtime image linker for the Java platform—a tool for linking and packaging Java classes, modules, and their dependencies into a custom runtime image. The image created by the <code>jlink</code> tool will comprise a linked set of modules, along with their transitive dependences.</p>
</div>
<div class="refsect1" id="_common_switches_13">
<h6>Common switches</h6>
<dl>
<dt><code>--add-modules <em>&lt;module&gt;</em> [, <em>module1</em>]</code></dt>
<dd>
<p>Add modules to the root set of modules to be linked</p>
</dd>
<dt><code>--endian {little|big}</code></dt>
<dd>
<p>Specify the endianness of the target architecture</p>
</dd>
<dt><code>--module-path <em>&lt;path&gt;</em></code></dt>
<dd>
<p>Specify the path where the modules for linking can be found</p>
</dd>
<dt><code>--save-opts <em>&lt;file&gt;</em></code></dt>
<dd>
<p>Save the options to the linker in the specified file</p>
</dd>
<dt><code>--help</code></dt>
<dd>
<p>Print help information</p>
</dd>
<dt><code>@filename</code></dt>
<dd>
<p>Read options from filename instead of the command line</p>
</dd>
</dl>
</div>
<div class="refsect1" id="_notes_13b">
<h6>Notes</h6>
<p>The <code>jlink</code> tool will work with any class file or module and linking will require the transitive dependencies of the code to be linked.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>Custom runtime images don’t have any support for automatic updates by default. This means developers are responsible for rebuilding and updating their own applications in the field when necessary. Some Java language features may have restrictions, as the runtime image may not include the full JDK; therefore, reflection and other dynamic techniques may not be fully supported.</div>
</div>
</div>
<div class="refsect1" id="javanut8-CHP-13-SECT-1.14">
<header>
<p class="refname bottom-left">jmod</p>
</header>
<div class="refsect1" id="_basic_usage_90">
<h6>Basic usage</h6>
<p><a contenteditable="false" data-primary="jmod tool" data-type="indexterm" id="idm45927698265264"/><code>jmod create <em>[options]</em> my-new.jmod</code></p>
</div>
<div class="refsect1" id="_description_14">
<h6>Description</h6>
<p><code>jmod</code> prepares Java software components for use by the custom linker (<code>jlink</code>). The result is a <em>.jmod</em> file. This should be considered an intermediate file, not a primary artifact for distribution.</p>
</div>
<div class="refsect1" id="_common_switches_14">
<h6>Basic modes</h6>
<dl>
<dt><code>create</code></dt>
<dd>
<p>Create a new JMOD file</p>
</dd>
<dt><code>extract</code></dt>
<dd>
<p>Extract all files from a JMOD file (explode it)</p>
</dd>
<dt><code>list</code></dt>
<dd>
<p>List all files from a JMOD file</p>
</dd>
<dt><code>describe</code></dt>
<dd>
<p>Print details about a JMOD file</p>
</dd>
</dl>
<h6>Common switches</h6>
<dl>
<dt><code>--module-path path</code></dt>
<dd>
<p>Specify the module path where the core contents of the module can be found.</p>
</dd>
<dt><code>--libs path</code></dt>
<dd>
<p>Specify the path where native libraries for inclusion can be found.</p>
</dd>
<dt><code>--help</code></dt>
<dd>
<p>Print help information.</p>
</dd>
<dt><code>@filename</code></dt>
<dd>
<p>Read options from filename instead of the command line.</p>
</dd>
</dl>
</div>
<div class="refsect1" id="_notes_14">
<h6>Notes</h6>
<p><code>jmod</code> reads and writes the JMOD format, but please note that this is different from the modular JAR format and is not intended as an immediate replacement for it.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>The <code>jmod</code> tool is only currently intended for modules that are to be linked into a runtime image (using the <code>jlink</code> tool). One other possible use case is for packaging modules that have native libraries or other configuration files that must be distributed along with the module.</div>
</div>
</div>
<div class="refsect1" id="javanut8-CHP-13-SECT-1.15">
<header>
<p class="refname bottom-left">jcmd</p>
</header>
<div class="refsect1" id="_basic_usage_91">
<h6>Basic usage</h6>
<p><a contenteditable="false" data-primary="jcmd tool" data-type="indexterm" id="idm45927698237360"/><code>jcmd <em>&lt;PID&gt;</em></code><br/>
<code>jcmd <em>&lt;PID&gt;</em> <em>&lt;command&gt;</em></code></p>
</div>
<div class="refsect1" id="_description_15">
<h6>Description</h6>
<p><code>jcmd</code> issues commands to a running Java process. The precise commands may vary between Java versions and may be listed by running <code>jcmd</code> with the process ID and no command.</p>
</div>
<div class="refsect1" id="_common_switches_15">
<h6>Common switches</h6>
<dl>
<dt><code>-f <em>&lt;path&gt;</em></code></dt>
<dd>
<p>Read from commands from a file rather than command-line arguments</p>
</dd>
<dt><code>-l</code></dt>
<dd>
<p>List Java processes (similar to <code>jps</code>)</p>
</dd>
<dt><code>--help</code></dt>
<dd>
<p>Print help information</p>
</dd>
</dl>
</div>
<div class="refsect1" id="_common_commands_15">
<h6>Common commands</h6>
<dl>
<dt><code>GC.heap_dump <em>&lt;path&gt;</em></code></dt>
<dd>
<p>Generate a heap dump like <code>jmap</code>. Note the path is relative to the Java process, <em>not</em> where <code>jcmd</code> is run!</p>
</dd>
<dt><code>GC.heap_info</code></dt>
<dd>
<p>Display statistics and sizing information about the Java process heap.</p>
</dd>
<dt><code>JFR.start</code></dt>
<dd>
<p>Begin a Java Flight Recorder (JFR) session. JFR is the JVM’s built-in performance monitoring and profiling tool.</p>
</dd>
<dt><code>JFR.stop name=<em>&lt;name from start&gt;</em> filename=<em>&lt;path&gt;</em></code></dt>
<dd>
<p>Stop named JFR session and record to a file.</p>
</dd>
<dt><code>VM.system_properties</code></dt>
<dd>
<p>Output Java process system properties.</p>
</dd>
</dl>
</div>
<div class="refsect1" id="_notes_15">
<h6>Notes</h6>
<div data-type="note" epub:type="note"><h6>Note</h6>Commands to <code>jcmd</code> are grouped by the subsystem they interact with, for instance <code>GC</code> or <code>JFR</code>. There are many more commands than the examples we’ve given here. It’s worth exploring what’s available on your Java installation for help in operating the JVM in production.</div>
</div>
</div>
</div></section>
<section data-pdf-bookmark="Introduction to JShell" data-type="sect1"><div class="sect1" id="javanut8-CHP-13-SECT-2">
<h1>Introduction to JShell</h1>
<p><a data-primary="Java 9" data-primary-sortas="Java 09" data-secondary="JShell and" data-type="indexterm" id="ix_ch13-asciidoc0"/><a data-primary="JShell" data-type="indexterm" id="ix_ch13-asciidoc1"/><a data-primary="shell" data-type="indexterm" id="ix_ch13-asciidoc2"/>Java is traditionally understood as a language that is class-oriented and has a distinct compile-interpret-evaluate execution model.
However, in this section, we will discuss a new technology that extends this programming paradigm by providing a form of interactive/scripting capability.</p>
<p>With the advent of Java 9, the Java runtime and JDK bundles a new tool, JShell. This is an interactive shell for Java, similar to the REPL seen in languages like Python, Scala, or Lisp.
The shell is intended for teaching and exploratory use and, due to the nature of the Java language, is not expected to be as much use to the working programmer as similar shells  in other languages.</p>
<p>In particular, it is not expected that Java will become an REPL-driven language.
Instead, this opens up an opportunity to use JShell for a different style of programming, one that complements the traditional use case but also provides new perspectives, especially for working with a new API.</p>
<p>It is very easy to use JShell to explore simple language features, for instance:</p>
<ul>
<li>
<p>Primitive data types</p>
</li>
<li>
<p>Simple numeric operations</p>
</li>
<li>
<p>String manipulation basics</p>
</li>
<li>
<p>Object types</p>
</li>
<li>
<p>Defining new classes</p>
</li>
<li>
<p>Creating new objects</p>
</li>
<li>
<p>Calling methods</p>
</li>
</ul>
<p>To start up JShell, we just invoke it from the command line:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">$</code><code class="w"> </code><code class="n">jshell</code><code class="w"/>
<code class="o">|</code><code class="w">  </code><code class="n">Welcome</code><code class="w"> </code><code class="n">to</code><code class="w"> </code><code class="n">JShell</code><code class="w"> </code><code class="o">--</code><code class="w"> </code><code class="n">Version</code><code class="w"> </code><code class="mf">17.0.4</code><code class="w"/>
<code class="o">|</code><code class="w">  </code><code class="n">For</code><code class="w"> </code><code class="n">an</code><code class="w"> </code><code class="n">introduction</code><code class="w"> </code><code class="n">type</code><code class="p">:</code><code class="w"> </code><code class="o">/</code><code class="n">help</code><code class="w"> </code><code class="n">intro</code><code class="w"/>

<code class="n">jshell</code><code class="o">&gt;</code><code class="w"/></pre>
<p><a data-primary="snippets" data-type="indexterm" id="idm45927698139168"/>From here, we can enter small pieces of Java code, which are known as <em>snippets</em>:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">jshell</code><code class="o">&gt;</code><code class="w"> </code><code class="mi">2</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="mi">3</code><code class="w"/>
<code class="n">$1</code><code class="w"> </code><code class="o">==&gt;</code><code class="w"> </code><code class="mi">6</code><code class="w"/>

<code class="n">jshell</code><code class="o">&gt;</code><code class="w"> </code><code class="kd">var</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">2</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="mi">3</code><code class="w"/>
<code class="n">i</code><code class="w"> </code><code class="o">==&gt;</code><code class="w"> </code><code class="mi">6</code><code class="w"/></pre>
<p>The shell is designed to be a simple working environment, and so it relaxes some of the rules that working Java programmers may expect.
Some of the differences between JShell snippets and regular Java include:</p>
<ul>
<li>
<p>Semicolons are optional in JShell</p>
</li>
<li>
<p>JShell supports a verbose mode</p>
</li>
<li>
<p>JShell has a wider set of default imports than a regular Java program</p>
</li>
<li>
<p>Methods can be declared at top level (outside of a class)</p>
</li>
<li>
<p>Methods can be redefined within snippets</p>
</li>
<li>
<p>A snippet may not declare a package or a module—everything is placed in an unnamed package controlled by the shell</p>
</li>
<li>
<p>Only public classes may be accessed from JShell</p>
</li>
<li>
<p>Due to package restrictions, it’s advisable to ignore access control when defining classes and working within JShell</p>
</li>
</ul>
<p>It’s simple to create simple class hierarchies (e.g., for exploring Java’s inheritance and generics):</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">jshell</code><code class="o">&gt;</code><code class="w"> </code><code class="kd">class</code> <code class="nc">Pet</code><code class="w"> </code><code class="p">{}</code><code class="w"/>
<code class="o">|</code><code class="w">  </code><code class="n">created</code><code class="w"> </code><code class="kd">class</code> <code class="nc">Pet</code><code class="w"/>

<code class="n">jshell</code><code class="o">&gt;</code><code class="w"> </code><code class="kd">class</code> <code class="nc">Cat</code><code class="w"> </code><code class="kd">extends</code><code class="w"> </code><code class="n">Pet</code><code class="w"> </code><code class="p">{}</code><code class="w"/>
<code class="o">|</code><code class="w">  </code><code class="n">created</code><code class="w"> </code><code class="kd">class</code> <code class="nc">Cat</code><code class="w"/>

<code class="n">jshell</code><code class="o">&gt;</code><code class="w"> </code><code class="kd">var</code><code class="w"> </code><code class="n">c</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">Cat</code><code class="p">()</code><code class="w"/>
<code class="n">c</code><code class="w"> </code><code class="o">==&gt;</code><code class="w"> </code><code class="n">Cat@2ac273d3</code><code class="w"/></pre>
<p>Tab completion within the shell is also possible, such as for autocompletion of possible methods:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">jshell</code><code class="o">&gt;</code><code class="w"> </code><code class="n">c</code><code class="p">.</code><code class="o">&lt;</code><code class="n">TAB</code><code class="o">&gt;</code><code class="w"/>
<code class="nf">equals</code><code class="p">(</code><code class="w">       </code><code class="n">getClass</code><code class="p">()</code><code class="w">    </code><code class="n">hashCode</code><code class="p">()</code><code class="w">    </code><code class="n">notify</code><code class="p">()</code><code class="w">      </code><code class="n">notifyAll</code><code class="p">()</code><code class="w"/>
<code class="n">toString</code><code class="p">()</code><code class="w">    </code><code class="n">wait</code><code class="p">(</code><code class="w"/></pre>
<p>Pressing the tab key twice with certain input will display documentation for a method:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">jshell</code><code class="o">&gt;</code><code class="w"> </code><code class="n">c</code><code class="p">.</code><code class="na">hashCode</code><code class="p">(</code><code class="o">&lt;</code><code class="n">TAB</code><code class="o">&gt;</code><code class="w"/>
<code class="nl">Signatures</code><code class="p">:</code><code class="w"/>
<code class="kt">int</code><code class="w"> </code><code class="n">Object</code><code class="p">.</code><code class="na">hashCode</code><code class="p">()</code><code class="w"/>

<code class="o">&lt;</code><code class="n">press</code><code class="w"> </code><code class="n">tab</code><code class="w"> </code><code class="n">again</code><code class="w"> </code><code class="n">to</code><code class="w"> </code><code class="n">see</code><code class="w"> </code><code class="n">documentation</code><code class="o">&gt;</code><code class="w"/>
<code class="n">jshell</code><code class="o">&gt;</code><code class="w"> </code><code class="n">c</code><code class="p">.</code><code class="na">hashCode</code><code class="p">(</code><code class="o">&lt;</code><code class="n">TAB</code><code class="w"> </code><code class="n">TAB</code><code class="o">&gt;</code><code class="w"/>
<code class="kt">int</code><code class="w"> </code><code class="n">Object</code><code class="p">.</code><code class="na">hashCode</code><code class="p">()</code><code class="w"/>
<code class="n">Returns</code><code class="w"> </code><code class="n">a</code><code class="w"> </code><code class="n">hash</code><code class="w"> </code><code class="n">code</code><code class="w"> </code><code class="n">value</code><code class="w"> </code><code class="k">for</code><code class="w"> </code><code class="n">the</code><code class="w"> </code><code class="n">object</code><code class="p">.</code><code class="w"> </code><code class="p">(</code><code class="n">Full</code><code class="w"> </code><code class="n">Javadoc</code><code class="w"> </code><code class="n">follows</code><code class="p">...)</code><code class="w"/></pre>
<p>We can also create top-level methods, such as:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">jshell</code><code class="o">&gt;</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="nf">div</code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">x</code><code class="p">,</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">y</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="p">...</code><code class="o">&gt;</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="n">x</code><code class="w"> </code><code class="o">/</code><code class="w"> </code><code class="n">y</code><code class="p">;</code><code class="w"/>
<code class="w">   </code><code class="p">...</code><code class="o">&gt;</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="o">|</code><code class="w">  </code><code class="n">created</code><code class="w"> </code><code class="n">method</code><code class="w"> </code><code class="nf">div</code><code class="p">(</code><code class="kt">int</code><code class="p">,</code><code class="kt">int</code><code class="p">)</code><code class="w"/></pre>
<p>Simple exception backtraces are also supported:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">jshell</code><code class="o">&gt;</code><code class="w"> </code><code class="nf">div</code><code class="p">(</code><code class="mi">3</code><code class="p">,</code><code class="mi">0</code><code class="p">)</code><code class="w"/>
<code class="o">|</code><code class="w">  </code><code class="n">Exception</code><code class="w"> </code><code class="n">java</code><code class="p">.</code><code class="na">lang</code><code class="p">.</code><code class="na">ArithmeticException</code><code class="p">:</code><code class="w"> </code><code class="o">/</code><code class="w"> </code><code class="n">by</code><code class="w"> </code><code class="n">zero</code><code class="w"/>
<code class="o">|</code><code class="w">        </code><code class="n">at</code><code class="w"> </code><code class="nf">div</code><code class="w"> </code><code class="p">(</code><code class="err">#</code><code class="mi">2</code><code class="p">:</code><code class="mi">2</code><code class="p">)</code><code class="w"/>
<code class="o">|</code><code class="w">        </code><code class="n">at</code><code class="w"> </code><code class="p">(</code><code class="err">#</code><code class="mi">3</code><code class="p">:</code><code class="mi">1</code><code class="p">)</code><code class="w"/></pre>
<p>We can access classes from the JDK:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">jshell</code><code class="o">&gt;</code><code class="w"> </code><code class="kd">var</code><code class="w"> </code><code class="n">ls</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">List</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="s">"Alpha"</code><code class="p">,</code><code class="w"> </code><code class="s">"Beta"</code><code class="p">,</code><code class="w"> </code><code class="s">"Gamma"</code><code class="p">,</code><code class="w"> </code><code class="s">"Delta"</code><code class="p">,</code><code class="w"> </code><code class="s">"Epsilon"</code><code class="p">)</code><code class="w"/>
<code class="n">ls</code><code class="w"> </code><code class="o">==&gt;</code><code class="w"> </code><code class="o">[</code><code class="n">Alpha</code><code class="p">,</code><code class="w"> </code><code class="n">Beta</code><code class="p">,</code><code class="w"> </code><code class="n">Gamma</code><code class="p">,</code><code class="w"> </code><code class="n">Delta</code><code class="p">,</code><code class="w"> </code><code class="n">Epsilon</code><code class="o">]</code><code class="w"/>

<code class="n">jshell</code><code class="o">&gt;</code><code class="w"> </code><code class="n">ls</code><code class="p">.</code><code class="na">get</code><code class="p">(</code><code class="mi">3</code><code class="p">)</code><code class="w"/>
<code class="n">$11</code><code class="w"> </code><code class="o">==&gt;</code><code class="w"> </code><code class="s">"Delta"</code><code class="w"/>

<code class="n">jshell</code><code class="o">&gt;</code><code class="w"> </code><code class="n">ls</code><code class="p">.</code><code class="na">forEach</code><code class="p">(</code><code class="n">s</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">s</code><code class="p">.</code><code class="na">charAt</code><code class="p">(</code><code class="mi">1</code><code class="p">)))</code><code class="w"/>
<code class="n">l</code><code class="w"/>
<code class="n">e</code><code class="w"/>
<code class="n">a</code><code class="w"/>
<code class="n">e</code><code class="w"/>
<code class="n">p</code><code class="w"/></pre>
<p>Or explicitly import classes if necessary:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">jshell</code><code class="o">&gt;</code><code class="w"> </code><code class="kn">import</code><code class="w"> </code><code class="nn">java.time.LocalDateTime</code><code class="w"/>

<code class="n">jshell</code><code class="o">&gt;</code><code class="w"> </code><code class="kd">var</code><code class="w"> </code><code class="n">now</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">LocalDateTime</code><code class="p">.</code><code class="na">now</code><code class="p">()</code><code class="w"/>
<code class="n">now</code><code class="w"> </code><code class="o">==&gt;</code><code class="w"> </code><code class="mi">2018</code><code class="o">-</code><code class="mi">10</code><code class="o">-</code><code class="mo">02</code><code class="n">T14</code><code class="p">:</code><code class="mi">48</code><code class="p">:</code><code class="mf">28.139422</code><code class="w"/>

<code class="n">jshell</code><code class="o">&gt;</code><code class="w"> </code><code class="n">now</code><code class="p">.</code><code class="na">plusWeeks</code><code class="p">(</code><code class="mi">3</code><code class="p">)</code><code class="w"/>
<code class="n">$9</code><code class="w"> </code><code class="o">==&gt;</code><code class="w"> </code><code class="mi">2018</code><code class="o">-</code><code class="mi">10</code><code class="o">-</code><code class="mi">23</code><code class="n">T14</code><code class="p">:</code><code class="mi">48</code><code class="p">:</code><code class="mf">28.139422</code><code class="w"/></pre>
<p>The environment also allows JShell commands, which start with a <code>/</code>.
It is useful to be aware of some of the most common basic commands:</p>
<ul>
<li>
<p><code>/help intro</code> is the introductory help text</p>
</li>
<li>
<p><code>/help</code> is a more comprehensive entry point into the help system</p>
</li>
<li>
<p><code>/vars</code> shows which variables are in scope</p>
</li>
<li>
<p><code>/list</code> shows the shell history</p>
</li>
<li>
<p><code>/save</code> outputs accepted snippet source to a file</p>
</li>
<li>
<p><code>/open</code> reads a saved file and brings it into the environment</p>
</li>
<li>
<p><code>/exit</code> exits the jshell interface</p>
</li>
</ul>
<p>For example, the imports available within JShell include a lot more than just <code>java.lang</code>.
The whole list is loaded by JShell during startup and can be seen as the <em>special imports</em> visible through the <code>/list -all</code> command:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">jshell</code><code class="o">&gt;</code><code class="w"> </code><code class="o">/</code><code class="n">list</code><code class="w"> </code><code class="o">-</code><code class="n">all</code><code class="w"/>

<code class="w">  </code><code class="n">s1</code><code class="w"> </code><code class="p">:</code><code class="w"> </code><code class="kn">import</code><code class="w"> </code><code class="nn">java.io.*</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="n">s2</code><code class="w"> </code><code class="p">:</code><code class="w"> </code><code class="kn">import</code><code class="w"> </code><code class="nn">java.math.*</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="n">s3</code><code class="w"> </code><code class="p">:</code><code class="w"> </code><code class="kn">import</code><code class="w"> </code><code class="nn">java.net.*</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="n">s4</code><code class="w"> </code><code class="p">:</code><code class="w"> </code><code class="kn">import</code><code class="w"> </code><code class="nn">java.nio.file.*</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="n">s5</code><code class="w"> </code><code class="p">:</code><code class="w"> </code><code class="kn">import</code><code class="w"> </code><code class="nn">java.util.*</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="n">s6</code><code class="w"> </code><code class="p">:</code><code class="w"> </code><code class="kn">import</code><code class="w"> </code><code class="nn">java.util.concurrent.*</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="n">s7</code><code class="w"> </code><code class="p">:</code><code class="w"> </code><code class="kn">import</code><code class="w"> </code><code class="nn">java.util.function.*</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="n">s8</code><code class="w"> </code><code class="p">:</code><code class="w"> </code><code class="kn">import</code><code class="w"> </code><code class="nn">java.util.prefs.*</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="n">s9</code><code class="w"> </code><code class="p">:</code><code class="w"> </code><code class="kn">import</code><code class="w"> </code><code class="nn">java.util.regex.*</code><code class="p">;</code><code class="w"/>
<code class="w"> </code><code class="n">s10</code><code class="w"> </code><code class="p">:</code><code class="w"> </code><code class="kn">import</code><code class="w"> </code><code class="nn">java.util.stream.*</code><code class="p">;</code><code class="w"/></pre>
<p>The JShell environment is tab-completed, which greatly adds to the tool’s usability.
The verbose mode is particularly useful when you are getting to know JShell—it can be activated by passing the <code>-v</code> switch at startup as well as via a shell command.<a data-startref="ix_ch13-asciidoc2" data-type="indexterm" id="idm45927697413104"/><a data-startref="ix_ch13-asciidoc1" data-type="indexterm" id="idm45927697357120"/><a data-startref="ix_ch13-asciidoc0" data-type="indexterm" id="idm45927697356480"/></p>
</div></section>
<section data-pdf-bookmark="Introduction to Java Flight Recorder (JFR)" data-type="sect1"><div class="sect1" id="javanut8-CHP-13-SECT-3">
<h1>Introduction to Java Flight Recorder (JFR)</h1>
<p><a data-primary="Java Flight Recorder (JFR)" data-type="indexterm" id="idm45927697354336"/><a data-primary="JFR (Java Flight Recorder)" data-type="indexterm" id="idm45927697353664"/>Java Flight Record (JFR) is a powerful, low-latency profiling system built
directly into the JVM. It has existed for years but was available only with a
commercial license prior to Java 11. Now this rich source of information is
available with OpenJDK and worth exploring.</p>
<p>The typical JFR workflow involves starting a profile against a running JVM,
downloading the results as a file, and then inspecting that file offline with
the JDK Mission Control (JMC) GUI application. While JFR is embedded directly within
OpenJDK, JMC isn’t distributed with the JDK but can be downloaded from
<a class="bare" href="https://oreil.ly/eq4cg"><em class="hyperlink">https://oreil.ly/eq4cg</em></a>.</p>
<p>JFR recording can be started either via options at JVM startup or interactively
with the <code>jcmd</code> tool shown earlier in this chapter. The following <code>java</code>
invocation starts with JFR recording for two minutes, writing the results to a
file when finished:</p>
<pre data-type="programlisting">java -XX:StartFlightRecording=duration=120s,filename=flight.jfr \
   Application</pre>
<p>Options allow for tight control over the volume of data JFR will hold in memory, either by specifying how long a recording to generate or by the size of the file that will be generated.
When combined with its low overhead, it is plausible to run JFR persistently in
production so data is always ready should you wish to capture it (sometimes referred to as “ring buffer” mode). This opens up
a world of possibilities for debugging in amazing detail with the JFR profiles,
even minutes to hours after a problem has occurred.</p>
<p>Along with sizing limits, JFR recording can also be configured to gather only
specific information of interest. Typical areas (but only a few of the things
JFR measures) include:</p>
<ul>
<li>
<p>Object allocation</p>
</li>
<li>
<p>Garbage collection</p>
</li>
<li>
<p>Threads and locks</p>
</li>
<li>
<p>Method profiling</p>
</li>
</ul>
<p><a data-primary="Java 17" data-secondary="JFR and" data-type="indexterm" id="idm45927697256416"/>With Java 17, APIs are available in-process to consume JFR events in a
streaming fashion, evolving away from the file-based profiling approaches.
This opens the door for monitoring tooling to tap into this rich source of data, without the hassle of logging onto servers to ask for a profile to be dumped.</p>
<p>In the future, we may expect JFR to act as a data source for the new generation 
<span class="keep-together">of Observability</span> tools that are being adopted by the Java ecosystem, such as 
<span class="keep-together">OpenTelemetry</span>.</p>
</div></section>
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm45927697253488">
<h1>Summary</h1>
<p>Java has changed a huge amount over the last 15+ years, and yet the
platform and community remain vibrant. To have achieved this, while
retaining a recognizable language and platform, is no small
accomplishment.</p>
<p>Ultimately, Java’s continued existence and viability depend upon
the individual developer. On that basis, the future looks bright, and we
look forward to the next wave and beyond.</p>
</div></section>
</div></section></div></body></html>