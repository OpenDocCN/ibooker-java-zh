<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 6. Package Management"><div class="chapter" id="package_management">
<h1><span class="label">Chapter 6. </span>Package Management</h1>


<p class="byline">Ixchel Ruiz</p>

<p>Somewhere in the world, as you read this sentence, a line of code is being written.<a data-type="indexterm" data-primary="package management" data-secondary="about" id="idm45310208101824"/>
This line of code will ultimately become part of an artifact that will become a building block used internally by an organization in one or more enterprise products, or <a data-type="indexterm" data-primary="Maven Central" id="idm45310208100720"/><a data-type="indexterm" data-primary="Maven (Apache)" data-secondary="artifact publication" data-tertiary="Maven Central" id="idm45310208100048"/><a data-type="indexterm" data-primary="Apache Maven" data-secondary="artifact publication" data-tertiary="Maven Central" id="idm45310208098832"/>shared via a public repository, most notably Maven Central for Java and Kotlin libraries.</p>

<p>More libraries, binaries, and artifacts are available today than ever before, and this collection will continue to grow as developers around the world continue their next generation of products and services.
Handling and managing these artifacts<a data-type="indexterm" data-primary="dependencies" data-secondary="management basics" data-tertiary="libraries, binaries, and artifacts" id="idm45310208096736"/> require more effort now than before—with an ever-increasing number of dependencies creating a complicated web of connectedness.
Using an incorrect version of an artifact is an easy trap to fall into, causing confusion and broken builds, and ultimately thwarting carefully planned project release dates.</p>

<p>It’s more important than ever for developers to understand not only the function and the idiosyncrasies of the source code directly in front of them, but also how their projects are packaged and how the building blocks are assembled into the final product.
Having a deep understanding of the build process itself and how our automated build tools function under the hood is crucial to avert delays and hours of unnecessary troubleshooting—not to mention prevent a large category of bugs escaping into production.</p>

<p>Access to troves of third-party resources that provide solutions to common coding problems can help speed the development of our projects but introduces the risk of errant or unexpected behavior.
Understanding how these components are brought into projects as well as where they come from will help in troubleshooting efforts.
Ensuring that we are responsible managers of the artifacts we produce internally will allow us to improve our decision-making and prioritization when it comes to bug fixes and feature development as well as help pave the way to release to production.
A developer can no longer be versed in only the semantics of the code in front of them, but also the complexities of package management.</p>






<section data-type="sect1" data-pdf-bookmark="Why Build-It-and-Ship-It Is Not Enough"><div class="sect1" id="idm45310208094464">
<h1>Why Build-It-and-Ship-It Is Not Enough</h1>

<p>Not so long ago, software developers viewed building an artifact as a culmination of hard, sometimes epic, efforts.
Meeting deadlines sometimes meant using shortcuts and poorly documented steps.
Since then, the requirements of the industry have changed to bring faster delivery cycles, diverse environments, tailored artifacts, exploding codebases and repositories, and multimodule packages.
Today building an artifact is just one step of a bigger business cycle.</p>

<p>Successful leaders recognize that the best innovations emerge out of trial and error.<a data-type="indexterm" data-primary="package management" data-secondary="A/B testing" id="idm45310208092576"/><a data-type="indexterm" data-primary="A/B testing" id="idm45310208091600"/>
That’s why they’ve made testing, experimentation, and failure an integral part of their lives and their company’s process.</p>

<p>One way to innovate, scale more quickly, launch more products, improve the quality or user experience of applications or products, and roll out new features is through A/B testing. What is A/B testing? <a data-type="indexterm" data-primary="Fung, Kaiser" id="idm45310208090272"/>According to Kaiser Fung, who founded the applied analytics program at Columbia University, <em>A/B testing</em> at its most basic is a century-old method used to compare two versions of something to figure out which performs better.
Today several startups, well-established companies like Microsoft, and several other leading companies—including Amazon, Booking.com, Facebook, and <span class="keep-together">Google—</span>have been <a href="https://oreil.ly/vRKPP">conducting</a> more than 10,000 online controlled experiments annually.</p>

<p>Booking.com conducts comparative testing on every new feature on its website, comparing details from the selection of photos and content to button color and placement.
By testing several versions against one another and tracking customer response, the company is able to constantly improve the user experience.</p>

<p>How do we deliver and deploy multiple versions of software composed of numerous artifacts? How do we find bottlenecks? How do we know we are moving in the right direction? How do we keep track of what is working well or what is working against us? How do we maintain a reproducible outcome but with enriched lineages? <a data-type="indexterm" data-primary="package management" data-secondary="metadata" id="idm45310208086336"/><a data-type="indexterm" data-primary="metadata" data-secondary="about" id="idm45310208085360"/><a data-type="indexterm" data-primary="data" data-secondary="metadata" data-tertiary="about" id="idm45310208084416"/>Answers to these questions can be found by capturing and analyzing relevant, contextual, clear, and specific information regarding the workflows and artifacts’ inputs, outputs, and states. All of this is possible thanks to metadata.</p>
</div></section>













<section data-type="sect1" class="less_space pagebreak-before" data-pdf-bookmark="It’s All About Metadata"><div class="sect1" id="idm45310208082688">
<h1>It’s All About Metadata</h1>

<p>As W. Edwards Deming said, “In God we trust; all others bring data.” <em>Metadata</em> is defined as a structured key/value storage of relevant information. In other words, it’s a collection of properties or attributes applicable to a particular entity, which in our case applies to artifacts and processes.</p>

<p>Metadata enables the discovery of correlations and causations as well as insights into the organization’s behavior and outcomes.
As a result, metadata can show whether the organization is tuned in to its stakeholders’ goals.</p>

<p>Additional data can be used in later stages to extract or derive more information. This data helps expand perspectives and create more stories, or narratives. It’s important to choose which attributes, cardinality, and values to add—too many, and we harm performance; too few, and we miss information. With too many values, insights can be lost.</p>

<p>A good starting point is to answer the following questions concerning the main stages of each phase of the software development cycle: Who? What? How? Where? and When? Asking the right questions is only half of the effort, though. Having clear, relevant, specific, and clear answers that can be normalized or enumerated is always a good practice.</p>








<section data-type="sect2" data-pdf-bookmark="Key Attributes of Insightful Metadata"><div class="sect2" id="idm45310208078656">
<h2>Key Attributes of Insightful Metadata</h2>

<p>Insightful data should be all of the following:<a data-type="indexterm" data-primary="metadata" data-secondary="insightful metadata" id="idm45310208077248"/><a data-type="indexterm" data-primary="data" data-secondary="metadata" data-tertiary="insightful metadata" id="idm45310208076272"/><a data-type="indexterm" data-primary="package management" data-secondary="metadata" data-tertiary="insightful metadata" id="idm45310208075056"/></p>
<dl>
<dt>Contextualized</dt>
<dd>
<p>All data needs to be interpreted within a frame of reference.
To extract and compare possible scenarios, it is important to have the right stage for analysis.</p>
</dd>
<dt>Relevant</dt>
<dd>
<p>The variability in the values has an impact on the outcome or describes a specific stage or time in the outcome or process.</p>
</dd>
<dt>Specific</dt>
<dd>
<p>The values describe a clear event (i.e., initial value, end value).</p>
</dd>
<dt>Clear</dt>
<dd>
<p>The possible values are well-known or defined, computable, and comparable.</p>
</dd>
<dt>Unique</dt>
<dd>
<p>Has a single, distinctive value.</p>
</dd>
<dt>Extensible</dt>
<dd>
<p>Because the wealth of human knowledge is ever increasing, the data needs to define mechanisms so that standards can be evolved and extended to accommodate new properties.</p>
</dd>
</dl>

<p>Once you have defined what, when, why, and how to record the stages, inputs, outputs, and states of the software development cycle, you also need to keep in mind the consumers of subsets of the metadata.
On one hand, you may have an intermediate private consumer who will consume and react in different ways to the set of values—from triggering sub pipelines, promoting builds, deploying in different environments, or publishing artifacts.
On the other hand, you may have final external consumers who will be able to extract information and with skill and experience turn it into insights that will help fulfill the overall goals of the organization.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Metadata Considerations"><div class="sect2" id="idm45310208064368">
<h2>Metadata Considerations</h2>

<p>The following are important considerations about metadata:<a data-type="indexterm" data-primary="metadata" data-secondary="issues to consider" id="idm45310208062688"/><a data-type="indexterm" data-primary="data" data-secondary="metadata" data-tertiary="issues to consider" id="idm45310208061632"/><a data-type="indexterm" data-primary="package management" data-secondary="metadata" data-tertiary="issues to consider" id="idm45310208060416"/><a data-type="indexterm" data-primary="privacy and metadata" id="idm45310208059200"/><a data-type="indexterm" data-primary="security" data-secondary="metadata considerations" id="idm45310208058528"/></p>
<dl>
<dt>Privacy and security</dt>
<dd>
<p>Think twice about exposing values.</p>
</dd>
<dt>Visibility</dt>
<dd>
<p>Not all consumers are interested in all data.</p>
</dd>
<dt>Format and encoding</dt>
<dd>
<p>One specific property may be exposed during different stages in different formats, but consistency is needed in the naming, meaning, and possibly the general value.</p>
</dd>
</dl>

<p>Let’s turn our attention to generating<a data-type="indexterm" data-primary="build tools" data-secondary="metadata packaging" id="idm45310208052464"/> and packaging metadata with build tools.
The Java ecosystem has no shortage of options when it comes to build tools.
Arguably, the most popular are Apache Maven and Gradle; hence it makes sense to discuss them in depth.
However, should your build depend on a different build tool, the information presented in this section will likely still prove to be useful, as some of the techniques to gather and package metadata may be reused.</p>

<p>Now, before we jump into practical code snippets, we have to figure out three action items:</p>
<ol>
<li>
<p>Determine the metadata that should be packaged with an artifact.</p>
</li>
<li>
<p>Find out how that metadata can be obtained during the build.</p>
</li>
<li>
<p>Process the metadata and record it in the appropriate format or formats.</p>
</li>

</ol>

<p>The following subsections cover each of these aspects.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Determining the Metadata"><div class="sect2" id="idm45310208047056">
<h2>Determining the Metadata</h2>

<p>The build environment has no shortage<a data-type="indexterm" data-primary="package management" data-secondary="metadata" data-tertiary="determining" id="ch06-deter"/><a data-type="indexterm" data-primary="metadata" data-secondary="determining" id="ch06-deter2"/><a data-type="indexterm" data-primary="data" data-secondary="metadata" data-tertiary="determining" id="ch06-deter3"/> of information that can be converted into metadata and packaged alongside an artifact.
A good example is the <a data-type="indexterm" data-primary="timestamps as metadata" id="idm45310208040928"/>build timestamp that identifies the time and date when the build produced the artifact.
Many timestamp formats can be followed,<a data-type="indexterm" data-primary="timestamps as metadata" data-secondary="ISO 8601 format" id="idm45310208039984"/><a data-type="indexterm" data-primary="ISO 8601 timestamp format" id="idm45310208039040"/><a data-type="indexterm" data-primary="resources for learning" data-secondary="timestamp ISO 8601 format" id="idm45310208038304"/><a data-type="indexterm" data-primary="date format" id="idm45310208037344"/> but I recommend using <a href="https://oreil.ly/PsZkB">ISO 8601</a>, whose formatted representation using <code>java.text.SimpleDateformat</code> is <code>yyyy-MM-dd'T'HH:mm:ssXXX</code>—useful when the captured timestamp relies on <code>java.util.Date</code>.
Alternatively, the <code>java.time.format.DateTimeFormatter.ISO_OFFSET_DATE_TIME</code> may be used if the captured timestamp relies on <code>java.time.Local​Da⁠teTime</code>.
The build’s OS details<a data-type="indexterm" data-primary="OS" data-secondary="metadata about" id="idm45310208033424"/><a data-type="indexterm" data-primary="system properties link" id="idm45310208032480"/><a data-type="indexterm" data-primary="resources for learning" data-secondary="system properties link" id="idm45310208031808"/> may also be of interest, as well as JDK information such as version, ID, and vendor. Luckily for us, these bits of information are captured by the JVM and exposed via <a href="https://oreil.ly/CKMsE"><code>System</code></a> properties.</p>

<p>Consider including the artifact’s ID and version as well (even though these values are usually encoded in the artifact’s filename) as a precaution in case the artifact were to be renamed at some point.
SCM information is also crucial.<a data-type="indexterm" data-primary="source code management (SCM)" data-secondary="metadata about" id="idm45310208029440"/> Useful information from source control includes the commit hash, tag, and branch name. Additionally, you may want to capture specific build information such as the user who runs the build; the build tool’s name, ID, and version; and the hostname and IP address of the build machine. These key/value pairs are likely the most significant and commonly found metadata. However, you may select additional key/value pairs required by other tools and systems that will consume the produced artifacts.</p>
<div data-type="caution"><h6>Caution</h6>
<p>I can’t stress enough how important<a data-type="indexterm" data-primary="privacy and metadata" id="idm45310208026832"/><a data-type="indexterm" data-primary="security" data-secondary="metadata considerations" id="idm45310208026128"/> it is to check your team’s and organization’s policies regarding access and visibility of sensitive data.
Some of the key/value pairs mentioned before may be deemed a security risk if exposed to third parties or external consumers, though they may be of high importance to internal consumers.</p>
</div>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Capturing Metadata"><div class="sect2" id="idm45310208024352">
<h2>Capturing Metadata</h2>

<p>We must find a way to gather<a data-type="indexterm" data-primary="metadata" data-secondary="capturing" id="ch06-capt"/><a data-type="indexterm" data-primary="data" data-secondary="metadata" data-tertiary="capturing" id="ch06-capt2"/><a data-type="indexterm" data-primary="package management" data-secondary="metadata" data-tertiary="capturing" id="ch06-capt3"/> the metadata with our build tool of choice after we have determined which metadata we need to capture.
Some of the key/value pairs can be obtained directly from the environment, system settings, and command flags exposed by the JVM as environment variables or <code>System</code> properties. Additional properties may be exposed by the build tool itself, whether they are defined as additional command-line arguments or as configuration elements in the tool’s configuration settings.</p>

<p>Let’s assume for the moment that we need to capture the following key/value pairs:</p>

<ul>
<li>
<p>JDK information such as version and vendor</p>
</li>
<li>
<p>OS information such as name, arch, and version</p>
</li>
<li>
<p>The build timestamp</p>
</li>
<li>
<p>The current commit hash from SCM (assuming Git)</p>
</li>
</ul>

<p>These values may be captured<a data-type="indexterm" data-primary="Maven (Apache)" data-secondary="metadata" data-tertiary="capturing" id="ch06-mavcapt"/><a data-type="indexterm" data-primary="Apache Maven" data-secondary="metadata" data-tertiary="capturing" id="ch06-mavcapt2"/> with Maven by using a combination of <code>System</code> properties for the first two items and a third-party plug-in for the last two. <a data-type="indexterm" data-primary="Maven (Apache)" data-secondary="Git plug-ins" id="idm45310208008592"/><a data-type="indexterm" data-primary="Apache Maven" data-secondary="Git plug-ins" id="idm45310208007616"/><a data-type="indexterm" data-primary="Gradle" data-secondary="Git plug-ins" id="idm45310208006672"/><a data-type="indexterm" data-primary="resources for learning" data-secondary="Gradle" data-tertiary="Git plug-ins" id="idm45310208005728"/><a data-type="indexterm" data-primary="resources for learning" data-secondary="Apache Maven" data-tertiary="Git plug-ins" id="idm45310208004512"/>Both Maven and Gradle have no shortage of options when it comes to plug-ins that offer integration with Git; however, I recommend choosing <a href="https://oreil.ly/EwiLP">git-commit-id-maven-plugin</a> for Maven and <a href="https://oreil.ly/qjEOi">versioning</a> for Gradle, as these plug-ins are the most versatile so far.</p>

<p>Now, Maven allows defining properties in a handful of ways, most commonly as key/value pairs inside the <code>&lt;properties&gt;</code> section found in the <em>pom.xml</em> build file. The value for each key is free text, although you can refer to <code>System</code> properties by using a shorthand notation or to environment variables by using a naming convention. Say you want to access the value for the <code>java.version</code> key found in <code>System</code> properties. This can be done by using the <code>${}</code> shorthand notation such as <code>${java.version}</code>. Conversely, for an environment variable, you may use the <code>${env.<em>NAME</em>}</code> notation. For example, the value of an environment variable named <code>TOKEN</code> can be accessed using the expression <code>${env.TOKEN}</code> in the <em>pom.xml</em> build file. Putting together the <code>git-commit-id</code> plug-in and build properties may result in a <em>pom.xml</em> similar to the following:</p>

<pre data-type="programlisting" data-code-language="xml"><code class="nt">&lt;project</code> <code class="na">xmlns=</code><code class="s">"http://maven.apache.org/POM/4.0.0"</code>
  <code class="na">xmlns:xsi=</code><code class="s">"http://www.w3.org/2001/XMLSchema-instance"</code>
  <code class="na">xsi:schemaLocation=</code><code class="s">"http://maven.apache.org/POM/4.0.0</code>
<code class="s">  http://maven.apache.org/xsd/maven-4.0.0.xsd"</code><code class="nt">&gt;</code>
  <code class="nt">&lt;modelVersion&gt;</code>4.0.0<code class="nt">&lt;/modelVersion&gt;</code>

  <code class="nt">&lt;groupId&gt;</code>com.acme<code class="nt">&lt;/groupId&gt;</code>
  <code class="nt">&lt;artifactId&gt;</code>example<code class="nt">&lt;/artifactId&gt;</code>
  <code class="nt">&lt;version&gt;</code>1.0.0-SNAPSHOT<code class="nt">&lt;/version&gt;</code>

  <code class="nt">&lt;properties&gt;</code>
    <code class="nt">&lt;project.build.sourceEncoding&gt;</code>UTF-8<code class="nt">&lt;/project.build.sourceEncoding&gt;</code>
    <code class="nt">&lt;build.jdk&gt;</code>${java.version} (${java.vendor} ${java.vm.version})<code class="nt">&lt;/build.jdk&gt;</code>
    <code class="nt">&lt;build.os&gt;</code>${os.name} ${os.arch} ${os.version}<code class="nt">&lt;/build.os&gt;</code>
    <code class="nt">&lt;build.revision&gt;</code>${git.commit.id}<code class="nt">&lt;/build.revision&gt;</code>
    <code class="nt">&lt;build.timestamp&gt;</code>${git.build.time}<code class="nt">&lt;/build.timestamp&gt;</code>
  <code class="nt">&lt;/properties&gt;</code>

  <code class="nt">&lt;build&gt;</code>
    <code class="nt">&lt;plugins&gt;</code>
      <code class="nt">&lt;plugin&gt;</code>
        <code class="nt">&lt;groupId&gt;</code>pl.project13.maven<code class="nt">&lt;/groupId&gt;</code>
        <code class="nt">&lt;artifactId&gt;</code>git-commit-id-plugin<code class="nt">&lt;/artifactId&gt;</code>
        <code class="nt">&lt;version&gt;</code>4.0.3<code class="nt">&lt;/version&gt;</code>
        <code class="nt">&lt;executions&gt;</code>
          <code class="nt">&lt;execution&gt;</code>
            <code class="nt">&lt;id&gt;</code>resolve-git-properties<code class="nt">&lt;/id&gt;</code>
            <code class="nt">&lt;goals&gt;</code>
              <code class="nt">&lt;goal&gt;</code>revision<code class="nt">&lt;/goal&gt;</code>
            <code class="nt">&lt;/goals&gt;</code>
          <code class="nt">&lt;/execution&gt;</code>
        <code class="nt">&lt;/executions&gt;</code>
        <code class="nt">&lt;configuration&gt;</code>
          <code class="nt">&lt;verbose&gt;</code>false<code class="nt">&lt;/verbose&gt;</code>
          <code class="nt">&lt;failOnNoGitDirectory&gt;</code>false<code class="nt">&lt;/failOnNoGitDirectory&gt;</code>
          <code class="nt">&lt;generateGitPropertiesFile&gt;</code>true<code class="nt">&lt;/generateGitPropertiesFile&gt;</code>
          <code class="nt">&lt;generateGitPropertiesFilename&gt;</code>
            ${project.build.directory}/git.properties
          <code class="nt">&lt;/generateGitPropertiesFilename&gt;</code>
          <code class="nt">&lt;dateFormat&gt;</code>yyyy-MM-dd'T'HH:mm:ssXXX<code class="nt">&lt;/dateFormat&gt;</code>
        <code class="nt">&lt;/configuration&gt;</code>
      <code class="nt">&lt;/plugin&gt;</code>
    <code class="nt">&lt;/plugins&gt;</code>
  <code class="nt">&lt;/build&gt;</code>
<code class="nt">&lt;/project&gt;</code></pre>

<p>Note that the values for <code>build.jdk</code> and <code>build.os</code> already include formatting as they are composites of simpler values, whereas the <code>build.revision</code> and <code>build.timestamp</code> values come from the properties defined by the Git plug-in. We have yet to determine the final format and file or files that will contain the metadata, which is why we see it defined in the <code>&lt;properties&gt;</code> section. This setup allows these values to be reused and consumed by other plug-ins should they need it. Another reason to prefer this setup is that external tools (such as those found in a build pipeline) may read these values more easily as they are located at a specific section instead of at many places within the build file.</p>

<p>Also note the chosen value of<a data-type="indexterm" data-primary="version value format" id="idm45310207982960"/><a data-type="indexterm" data-primary="package management" data-secondary="version value format" id="idm45310207982256"/> version, <code>1.0.0-SNAPSHOT</code>. You may use any character combination for the version as you deem necessary. However, it’s customary to at least use an alphanumeric sequence that defines two numbers in the <code><em>major</em></code>.<code><em>minor</em></code> format. A handful of versioning conventions are out there, with both advantages and drawbacks. <a data-type="indexterm" data-primary="SNAPSHOT tag" id="idm45310207979504"/><a data-type="indexterm" data-primary="tag with container image version" data-secondary="SNAPSHOT tag" id="idm45310207864112"/><a data-type="indexterm" data-primary="version value format" data-secondary="tagging with SNAPSHOT" id="idm45310207863264"/><a data-type="indexterm" data-primary="package management" data-secondary="version value format" data-tertiary="tagging with SNAPSHOT" id="idm45310207862416"/>This being said, the use of the <code>-SNAPSHOT</code> tag has a special meaning as it indicates the artifact is not yet ready for production. Some tools will behave differently when a snapshot version is detected; for example, they can prevent an artifact from ever being published to a production environment.<a data-type="indexterm" data-startref="ch06-mavcapt" id="idm45310207860416"/><a data-type="indexterm" data-startref="ch06-mavcapt2" id="idm45310207859712"/></p>

<p>In contrast to Maven, Gradle has no shortage<a data-type="indexterm" data-primary="Gradle" data-secondary="metadata" data-tertiary="capturing" id="idm45310207858720"/> of options when it comes to defining and writing build files. <a data-type="indexterm" data-primary="Apache Groovy" data-secondary="Gradle build file" id="idm45310207857344"/><a data-type="indexterm" data-primary="Kotlin for Gradle build file" id="idm45310207856400"/>To begin with, since Gradle 4, you have two choices for the build file format: Apache Groovy DSL or Kotlin DSL. Regardless of which one you pick, you will soon find that there are more options to capture and format metadata. Some of them may be idiomatic, some may require additional plug-ins, and some may even be considered outdated or obsolete. To keep this example short and basic, we’ll go with Groovy and small idiomatic expressions. We’ll capture the same metadata similarly as we did for Maven, with the first two values coming from <code>System</code> properties and the commit hash provided by the <code>versioning</code> Git plug-in, but the build timestamp will be calculated on the spot by using custom code. The following snippet shows how this can be done:</p>

<pre data-type="programlisting" data-code-language="groovy"><code class="n">plugins</code> <code class="o">{</code>
  <code class="n">id</code> <code class="s1">'java-library'</code>
  <code class="n">id</code> <code class="s1">'net.nemerosa.versioning'</code> <code class="n">version</code> <code class="s1">'2.14.0'</code>
<code class="o">}</code>

<code class="n">version</code> <code class="o">=</code> <code class="s1">'1.0.0-SNAPSHOT'</code>

<code class="n">ext</code> <code class="o">{</code>
  <code class="n">buildJdk</code> <code class="o">=</code> <code class="o">[</code>
    <code class="n">System</code><code class="o">.</code><code class="na">properties</code><code class="o">[</code><code class="s1">'java.version'</code><code class="o">],</code>
    <code class="s1">'('</code> <code class="o">+</code> <code class="n">System</code><code class="o">.</code><code class="na">properties</code><code class="o">[</code><code class="s1">'java.vendor'</code><code class="o">],</code>
    <code class="n">System</code><code class="o">.</code><code class="na">properties</code><code class="o">[</code><code class="s1">'java.vm.version'</code><code class="o">]</code> <code class="o">+</code> <code class="s1">')'</code>
  <code class="o">].</code><code class="na">join</code><code class="o">(</code><code class="s1">' '</code><code class="o">)</code>
  <code class="n">buildOs</code> <code class="o">=</code> <code class="o">[</code>
    <code class="n">System</code><code class="o">.</code><code class="na">properties</code><code class="o">[</code><code class="s1">'os.name'</code><code class="o">],</code>
    <code class="n">System</code><code class="o">.</code><code class="na">properties</code><code class="o">[</code><code class="s1">'os.arch'</code><code class="o">],</code>
    <code class="n">System</code><code class="o">.</code><code class="na">properties</code><code class="o">[</code><code class="s1">'os.version'</code><code class="o">]</code>
  <code class="o">].</code><code class="na">join</code><code class="o">(</code><code class="s1">' '</code><code class="o">)</code>
  <code class="n">buildRevision</code> <code class="o">=</code> <code class="n">project</code><code class="o">.</code><code class="na">extensions</code><code class="o">.</code><code class="na">versioning</code><code class="o">.</code><code class="na">info</code><code class="o">.</code><code class="na">commit</code>
  <code class="n">buildTimestamp</code> <code class="o">=</code> <code class="k">new</code> <code class="n">Date</code><code class="o">().</code><code class="na">format</code><code class="o">(</code><code class="s2">"yyyy-MM-dd'T'HH:mm:ssXXX"</code><code class="o">)</code>
<code class="o">}</code></pre>

<p>These computed values will be available as dynamic project properties that may be consumed later in the build by additional configured elements such as extensions, tasks, closures (for Groovy), actions (for Groovy and Kotlin), and other elements exposed by the DSL. All that is left now is recording the metadata in a given format.<a data-type="indexterm" data-startref="ch06-capt" id="idm45310207777504"/><a data-type="indexterm" data-startref="ch06-capt2" id="idm45310207776896"/><a data-type="indexterm" data-startref="ch06-capt3" id="idm45310207812112"/></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Writing the Metadata"><div class="sect2" id="idm45310208023760">
<h2>Writing the Metadata</h2>

<p>You might need to record metadata<a data-type="indexterm" data-primary="metadata" data-secondary="writing" id="ch06-writ"/><a data-type="indexterm" data-primary="data" data-secondary="metadata" data-tertiary="writing" id="ch06-writ2"/><a data-type="indexterm" data-primary="package management" data-secondary="metadata" data-tertiary="writing" id="ch06-writ3"/> in more than one format or file. The choice of format depends on the intended consumers. Some consumers require a unique format that no other consumer can read, whereas others may understand a variety of formats. Be sure to consult the documentation of a given consumer on its supported formats and options and also check whether integration with your build tool of choice is provided. You might discover that a plug-in for your build is available that eases the recording process of the metadata that you need. For demonstration purposes, we’ll record the metadata by using two popular formats: a Java properties file and the JAR’s manifest.<a data-type="indexterm" data-primary="Apache Maven" data-secondary="metadata" data-tertiary="writing" id="ch06-mavwrit"/><a data-type="indexterm" data-primary="Maven (Apache)" data-secondary="metadata" data-tertiary="writing" id="ch06-mavwrit2"/></p>

<p>We can leverage Maven’s <a href="https://oreil.ly/X1x0q">resource filtering</a>, which is baked into the <a href="https://oreil.ly/YqOSO">resources plug-in</a>, part of the core set of plug-ins that every build has access to. For this to work, we must add the following snippet to the previous <em>pom.xml</em> file, inside the <code>&lt;build&gt;</code> section:</p>

<pre data-type="programlisting" data-code-language="xml" class="pagebreak-before"><code class="nt">&lt;resources&gt;</code>
  <code class="nt">&lt;resource&gt;</code>
    <code class="nt">&lt;directory&gt;</code>src/main/resources<code class="nt">&lt;/directory&gt;</code>
    <code class="nt">&lt;filtering&gt;</code>true<code class="nt">&lt;/filtering&gt;</code>
  <code class="nt">&lt;/resource&gt;</code>
<code class="nt">&lt;/resources&gt;</code></pre>

<p>A companion properties file located at <em>src/main/resources</em> is also required. I’ve chosen <em>META-INF/metadata.properties</em> as the relative path and name of the properties file to be found inside the artifact JAR. Of course, you may choose a different naming convention as needed. This file relies on variable placeholder substitutions, variables that will be resolved from project properties such as those we set in the <code>&lt;properties&gt;</code> section. By convention, little configuration information is needed in the build file. The properties file looks like the following:</p>

<pre data-type="programlisting" data-code-language="java"><code class="n">build</code><code class="o">.</code><code class="na">jdk</code>       <code class="o">=</code> <code class="n">$</code><code class="o">{</code><code class="n">build</code><code class="o">.</code><code class="na">jdk</code><code class="o">}</code>
<code class="n">build</code><code class="o">.</code><code class="na">os</code>        <code class="o">=</code> <code class="n">$</code><code class="o">{</code><code class="n">build</code><code class="o">.</code><code class="na">os</code><code class="o">}</code>
<code class="n">build</code><code class="o">.</code><code class="na">revision</code>  <code class="o">=</code> <code class="n">$</code><code class="o">{</code><code class="n">build</code><code class="o">.</code><code class="na">revision</code><code class="o">}</code>
<code class="n">build</code><code class="o">.</code><code class="na">timestamp</code> <code class="o">=</code> <code class="n">$</code><code class="o">{</code><code class="n">build</code><code class="o">.</code><code class="na">timestamp</code><code class="o">}</code></pre>

<p>Recording the metadata in the JAR’s manifest requires tweaking the configuration of the <code>jar-maven-plugin</code> applicable to a build file.
The following snippet must be included inside the <code>&lt;plugins&gt;</code> section found in the <code>&lt;build&gt;</code> section.
In other words, it’s a sibling of the <code>git-commit-id</code> plug-in we saw earlier in this section:</p>

<pre data-type="programlisting" data-code-language="xml"><code class="nt">&lt;plugin&gt;</code>
  <code class="nt">&lt;groupId&gt;</code>org.apache.maven.plugins<code class="nt">&lt;/groupId&gt;</code>
  <code class="nt">&lt;artifactId&gt;</code>maven-jar-plugin<code class="nt">&lt;/artifactId&gt;</code>
  <code class="nt">&lt;version&gt;</code>3.2.0<code class="nt">&lt;/version&gt;</code>
  <code class="nt">&lt;configuration&gt;</code>
    <code class="nt">&lt;archive&gt;</code>
      <code class="nt">&lt;manifestEntries&gt;</code>
        <code class="nt">&lt;Build-Jdk&gt;</code>${build.jdk}<code class="nt">&lt;/Build-Jdk&gt;</code>
        <code class="nt">&lt;Build-OS&gt;</code>${build.os}<code class="nt">&lt;/Build-OS&gt;</code>
        <code class="nt">&lt;Build-Revision&gt;</code>${build.revision}<code class="nt">&lt;/Build-Revision&gt;</code>
        <code class="nt">&lt;Build-Timestamp&gt;</code>${build.timestamp}<code class="nt">&lt;/Build-Timestamp&gt;</code>
      <code class="nt">&lt;/manifestEntries&gt;</code>
    <code class="nt">&lt;/archive&gt;</code>
  <code class="nt">&lt;/configuration&gt;</code>
<code class="nt">&lt;/plugin&gt;</code></pre>

<p>Note that a specific plug-in version is defined even though this plug-in is part of the core plug-in set. The reason behind this is that it’s imperative to declare all plug-in versions for the sake of reproducible builds. Otherwise, you will find builds may differ as different plug-in versions may be resolved depending on the specific version of Maven used to run the build. Each entry in the manifest is composed of a capitalized key and the captured value. Running the build with <code>mvn package</code> resolves the captured properties, copies the metadata properties file with resolved values into the <em>target/classes</em> directory where it will be added to the final JAR, and injects the metadata into the JAR’s manifest. We can verify this by inspecting the contents of the generated artifact:</p>

<pre data-type="programlisting">$ mvn verify
$ jar tvf target/example-1.0.0-SNAPSHOT.jar
    0 Sun Jan 10 20:41 CET 2021 META-INF/
  131 Sun Jan 10 20:41 CET 2021 META-INF/MANIFEST.MF
  205 Sun Jan 10 20:41 CET 2021 META-INF/metadata.properties
    0 Sun Jan 10 20:41 CET 2021 META-INF/maven/
    0 Sun Jan 10 20:41 CET 2021 META-INF/maven/com.acme/
    0 Sun Jan 10 20:41 CET 2021 META-INF/maven/com.acme/example/
 1693 Sun Jan 10 19:13 CET 2021 META-INF/maven/com.acme/example/pom.xml
  109 Sun Jan 10 20:41 CET 2021 META-INF/maven/com.acme/example/pom.properties</pre>

<p>The two files are found inside the JAR file as expected.
Extracting the JAR and looking at the contents of the properties file and the JAR manifest yield the following results:</p>

<pre data-type="programlisting">build.jdk       = 11.0.9 (Azul Systems, Inc. 11.0.9+11-LTS)
build.os        = Mac OS X x86_64 10.15.7
build.revision  = 0ab9d51a3aaa17fca374d28be1e3f144801daa3b
build.timestamp = 2021-01-10T20:41:11+01:00</pre>

<pre data-type="programlisting">Manifest-Version: 1.0
Created-By: Maven Jar Plugin 3.2.0
Build-Jdk-Spec: 11
Build-Jdk: 11.0.9 (Azul Systems, Inc. 11.0.9+11-LTS)
Build-OS: Mac OS X x86_64 10.15.7
Build-Revision: 0ab9d51a3aaa17fca374d28be1e3f144801daa3b
Build-Timestamp: 2021-01-10T20:41:11+01:00</pre>

<p>You’ve seen how to collect metadata with Maven.<a data-type="indexterm" data-startref="ch06-mavwrit" id="idm45310207560400"/><a data-type="indexterm" data-startref="ch06-mavwrit2" id="idm45310207559696"/><a data-type="indexterm" data-primary="Gradle" data-secondary="metadata" data-tertiary="writing" id="idm45310207559024"/><a data-type="indexterm" data-primary="Apache Groovy" data-secondary="Gradle build file" id="idm45310207557808"/> Let’s see the same method of recording metadata by using a properties file and a JAR manifest with a different build tool: Gradle. For the first part, we’ll configure the standard <code>processResources</code> task that’s provided by the <code>java-library</code> plug-in we applied to the build. The additional configuration can be appended to the previously shown Gradle build file, and it looks like the following:</p>

<pre data-type="programlisting" data-code-language="groovy"><code class="n">processResources</code> <code class="o">{</code>
  <code class="n">expand</code><code class="o">(</code>
    <code class="s1">'build_jdk'</code>      <code class="o">:</code> <code class="n">project</code><code class="o">.</code><code class="na">buildJdk</code><code class="o">,</code>
    <code class="s1">'build_os'</code>       <code class="o">:</code> <code class="n">project</code><code class="o">.</code><code class="na">buildOs</code><code class="o">,</code>
    <code class="s1">'build_revision'</code> <code class="o">:</code> <code class="n">project</code><code class="o">.</code><code class="na">buildRevision</code><code class="o">,</code>
    <code class="s1">'build_timestamp'</code><code class="o">:</code> <code class="n">project</code><code class="o">.</code><code class="na">buildTimestamp</code>
  <code class="o">)</code>
<code class="o">}</code></pre>

<p>Note that the names of the keys use <code>_</code> as a token separator, because of the default resource filtering mechanism appleid by Gradle. If we were to use <code>.</code> as we saw earlier with Maven, Gradle would expect to find a <code>build</code> object with matching <code>jdk</code>, <code>os</code>, <code>revision</code>, and <code>timestamp</code> properties during resource filtering. That object does not exist, which will cause the build to fail. Changing the token separator avoids that problem but also forces us to change the contents of the properties file to the following:</p>

<pre data-type="programlisting" data-code-language="java"><code class="n">build</code><code class="o">.</code><code class="na">jdk</code>       <code class="o">=</code> <code class="n">$</code><code class="o">{</code><code class="n">build_jdk</code><code class="o">}</code>
<code class="n">build</code><code class="o">.</code><code class="na">os</code>        <code class="o">=</code> <code class="n">$</code><code class="o">{</code><code class="n">build_os</code><code class="o">}</code>
<code class="n">build</code><code class="o">.</code><code class="na">revision</code>  <code class="o">=</code> <code class="n">$</code><code class="o">{</code><code class="n">build_revision</code><code class="o">}</code>
<code class="n">build</code><code class="o">.</code><code class="na">timestamp</code> <code class="o">=</code> <code class="n">$</code><code class="o">{</code><code class="n">build_timestamp</code><code class="o">}</code></pre>

<p>Configuring the JAR manifest is a straightforward operation given that the <code>jar</code> task offers an entry point for this behavior, as shown by the following snippet that can also be appended to the existing Gradle build file:</p>

<pre data-type="programlisting" data-code-language="groovy"><code class="n">jar</code> <code class="o">{</code>
  <code class="n">manifest</code> <code class="o">{</code>
    <code class="n">attributes</code><code class="o">(</code>
      <code class="s1">'Build-Jdk'</code>      <code class="o">:</code> <code class="n">project</code><code class="o">.</code><code class="na">buildJdk</code><code class="o">,</code>
      <code class="s1">'Build-OS'</code>       <code class="o">:</code> <code class="n">project</code><code class="o">.</code><code class="na">buildOs</code><code class="o">,</code>
      <code class="s1">'Build-Revision'</code> <code class="o">:</code> <code class="n">project</code><code class="o">.</code><code class="na">buildRevision</code><code class="o">,</code>
      <code class="s1">'Build-Timestamp'</code><code class="o">:</code> <code class="n">project</code><code class="o">.</code><code class="na">buildTimestamp</code>
    <code class="o">)</code>
  <code class="o">}</code>
<code class="o">}</code></pre>

<p>As seen before, each manifest entry uses a capitalized key and its corresponding captured value.
Running the build with <code>gradle jar</code> should produce results similar to those provided by Maven: the properties file will be copied to a target location where it can be included in the final JAR, with its value placeholders substituted for the actual metadata values, and the JAR manifest will be enriched with metadata as well.
Inspecting the JAR shows that it contains the expected files:</p>

<pre data-type="programlisting">$ gradle jar
$ jar tvf build/libs/example-1.0.0-SNAPSHOT.jar
     0 Sun Jan 10 21:08:22 CET 2021 META-INF/
    25 Sun Jan 10 21:08:22 CET 2021 META-INF/MANIFEST.MF
   165 Sun Jan 10 21:08:22 CET 2021 META-INF/metadata.properties</pre>

<p>Unpacking the JAR and looking inside each file yields the following results:</p>

<pre data-type="programlisting">build.jdk       = 11.0.9 (Azul Systems, Inc. 11.0.9+11-LTS)
build.os        = Mac OS X x86_64 10.15.7
build.revision  = 0ab9d51a3aaa17fca374d28be1e3f144801daa3b
build.timestamp = 2021-01-10T21:08:22+01:00</pre>

<pre data-type="programlisting">Manifest-Version: 1.0
Build-Jdk: 11.0.9 (Azul Systems, Inc. 11.0.9+11-LTS)
Build-OS: Mac OS X x86_64 10.15.7
Build-Revision: 0ab9d51a3aaa17fca374d28be1e3f144801daa3b
Build-Timestamp: 2021-01-10T21:08:22+01:00</pre>

<p>Perfect!
That is all that there is to it.
Let me encourage you to add or remove key/value pairs as needed as well as configure other plug-ins (for both Maven and Gradle) that may expose additional metadata or provide other means to process and record metadata into particular formats.<a data-type="indexterm" data-startref="ch06-writ" id="idm45310207378720"/><a data-type="indexterm" data-startref="ch06-writ2" id="idm45310207378016"/><a data-type="indexterm" data-startref="ch06-writ3" id="idm45310207377344"/></p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Dependency Management Basics for Maven and Gradle"><div class="sect1" id="idm45310208082096">
<h1>Dependency Management Basics for Maven and Gradle</h1>

<p>Dependency management has been a staple<a data-type="indexterm" data-primary="dependencies" data-secondary="management basics" data-tertiary="about" id="idm45310207375680"/><a data-type="indexterm" data-primary="package management" data-secondary="dependency management" data-tertiary="about" id="idm45310207374048"/><a data-type="indexterm" data-primary="Gradle" data-secondary="dependency management" data-tertiary="about" id="idm45310207372832"/><a data-type="indexterm" data-primary="data" data-secondary="metadata" data-tertiary="dependency management" id="ch06-depend"/><a data-type="indexterm" data-primary="package management" data-secondary="metadata" data-tertiary="dependency management" id="ch06-depend2"/><a data-type="indexterm" data-primary="metadata" data-secondary="dependency management" id="ch06-depend3"/><a data-type="indexterm" data-primary="Maven (Apache)" data-secondary="dependency management" data-tertiary="about the dragons" id="idm45310207367424"/><a data-type="indexterm" data-primary="Apache Maven" data-secondary="dependency management" data-tertiary="about the dragons" id="idm45310207366208"/> of Java projects since Maven <em>1.x</em> came to light in 2002. The gist behind this feature is to declare artifacts that are required for compiling, testing, and consuming a particular project, relying on additional metadata attached to an artifact such as its group identifier, artifact identifier, version, and sometimes a classifier as well.
This metadata is typically exposed using a well-known<a data-type="indexterm" data-primary="dependencies" data-secondary="management basics" data-tertiary="POM file metadata" id="ch06-deppom"/><a data-type="indexterm" data-primary="Apache Maven" data-secondary="POM file" data-tertiary="dependency metadata" id="ch06-deppom2"/><a data-type="indexterm" data-primary="Maven (Apache)" data-secondary="POM file" data-tertiary="dependency metadata" id="ch06-deppom3"/><a data-type="indexterm" data-primary="Gradle" data-secondary="metadata" data-tertiary="POM file dependency metadata" id="ch06-deppom4"/><a data-type="indexterm" data-primary="POM file (Apache Maven)" data-secondary="dependency metadata" id="ch06-deppom5"/><a data-type="indexterm" data-primary="package management" data-secondary="dependency management" data-tertiary="POM file metadata" id="ch06-deppom6"/> file format: the <a href="https://oreil.ly/1Kzp6">Apache Maven POM</a> expressed in a <em>pom.xml</em> file.
Other build tools are capable of understanding this format, and can even produce and publish <em>pom.xml</em> files despite using a totally unrelated format for declaring build aspects, as is the case for Gradle with <code>build.gradle</code> (Groovy) or <code>build.gradle.kts</code> (Kotlin) build file.</p>

<p>Despite being a core feature provided by Maven since the early days, and also a core feature in Gradle, dependency management and dependency resolution remain a stumbling block for many. Even though the rules to declare dependencies are not complicated, you may find yourself at the mercy of published metadata with invalid, misleading, or missing constraints.
The following subsections are a primer for dependency management using both Maven and Gradle, but it is by no means an exhaustive explanation—that would take a whole book on just this topic.</p>

<p>In other words, tread carefully, dear reader, there be dragons ahead. I’ll do my best to point out the safest paths. We’ll begin with Maven, as it is the build tool that defines the artifact metadata using the <em>pom.xml</em> file format.</p>








<section data-type="sect2" data-pdf-bookmark="Dependency Management with Apache Maven"><div class="sect2" id="idm45310207312240">
<h2>Dependency Management with Apache Maven</h2>

<p>You likely have encountered a POM file<a data-type="indexterm" data-primary="dependencies" data-secondary="management basics" data-tertiary="Apache Maven" id="ch06-depapm"/><a data-type="indexterm" data-primary="Apache Maven" data-secondary="dependency management" id="ch06-depapm2"/><a data-type="indexterm" data-primary="Maven (Apache)" data-secondary="dependency management" id="ch06-depapm3"/><a data-type="indexterm" data-primary="package management" data-secondary="dependency management" data-tertiary="Apache Maven" id="ch06-depapm4"/> before—after all, it’s ubiquitous.
A POM file with model version 4.0.0 is responsible for defining the way artifacts are produced and consumed.
In Maven version 4, these two capabilities are split, although the model version remains the same for compatibility reasons.
It’s expected that the model format will change when Maven version 5.0.0 is introduced. although there are no details on how this model will look at the time of writing.
One thing is sure: the Maven developers are keen on keeping backward compatibility.
Let’s walk through the basics.</p>

<p>Dependencies are identified by three required elements: <code>groupId</code>, <code>artifactId</code>, and <code>version</code>.
These elements are collectively known as <em>Maven coordinates</em>, or <em>GAV coordinates</em>, where GAV, as you may have guessed, stands for <code>groupId</code>, <code>artifactId</code>, <code>version</code>.
From time to time, you may find dependencies that define a fourth element named <code>classifier</code>.</p>

<p>Let’s break them down one by one.
Both <code>artifactId</code> and <code>version</code> are straightforward; the former defines the “name” of the artifact, and the latter defines a version number.
Many different versions may be associated with the same <code>artifactId</code>.
The <code>groupId</code> is used to put together a set of artifacts that have some sort of relationship—that is, all of them belong to the same project or provide behavior that’s germane to one another.
The <code>classifier</code> adds another dimension to the artifact, albeit optional.
Classifiers are often used to differentiate artifacts that are specific to a particular setting such as the operating system or the Java release.
Examples of operating system classifiers are found in the JavaFX binaries, such as <em>javafx-controls-15-win.jar</em>, <em>javafx-controls-15-mac.jar</em>, and <em>javafx-controls-15-linux.jar</em>, which identify version 15 of the JavaFX control binaries that may be used with Windows, macOS, and Linux platforms.</p>

<p>Another set of common classifiers are <code>sources</code> and <code>javadoc</code>, which identify JAR files that contain sources and generated documentation (via the Javadoc tool). The combination of GAV coordinates must be unique; otherwise, the dependency resolution mechanism will have a hard time finding out correct dependencies to use.</p>

<p>POM files let you define dependencies inside the <code>&lt;dependencies&gt;</code> section, where you would list GAV coordinates for each dependency.
In its simplest form, it looks something like this:</p>

<pre data-type="programlisting" data-code-language="xml"><code class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</code>
<code class="nt">&lt;project</code>
  <code class="na">xsi:schemaLocation=</code><code class="s">"http://maven.apache.org/POM/4.0.0</code>
<code class="s">  http://maven.apache.org/xsd/maven-4.0.0.xsd"</code>
  <code class="na">xmlns=</code><code class="s">"http://maven.apache.org/POM/4.0.0"</code>
  <code class="na">xmlns:xsi=</code><code class="s">"http://www.w3.org/2001/XMLSchema-instance"</code><code class="nt">&gt;</code>
  <code class="nt">&lt;modelVersion&gt;</code>4.0.0<code class="nt">&lt;/modelVersion&gt;</code>
  <code class="nt">&lt;groupId&gt;</code>com.acme<code class="nt">&lt;/groupId&gt;</code>
  <code class="nt">&lt;artifactId&gt;</code>example<code class="nt">&lt;/artifactId&gt;</code>
  <code class="nt">&lt;version&gt;</code>1.0.0-SNAPSHOT<code class="nt">&lt;/version&gt;</code>

  <code class="nt">&lt;dependencies&gt;</code>
    <code class="nt">&lt;dependency&gt;</code>
      <code class="nt">&lt;groupId&gt;</code>org.apache.commons<code class="nt">&lt;/groupId&gt;</code>
      <code class="nt">&lt;artifactId&gt;</code>commons-collections4<code class="nt">&lt;/artifactId&gt;</code>
      <code class="nt">&lt;version&gt;</code>4.4<code class="nt">&lt;/version&gt;</code>
    <code class="nt">&lt;/dependency&gt;</code>
  <code class="nt">&lt;/dependencies&gt;</code>
<code class="nt">&lt;/project&gt;</code></pre>

<p>Dependencies listed in this way are<a data-type="indexterm" data-primary="dependencies" data-secondary="direct dependencies" id="idm45310207271984"/><a data-type="indexterm" data-primary="direct dependencies" id="idm45310207282384"/><a data-type="indexterm" data-primary="POM file (Apache Maven)" data-secondary="dependency metadata" data-tertiary="direct dependencies" id="idm45310207268048"/> known as <em>direct dependencies</em>, as they are explicitly declared in the POM file.
This classification holds true even for dependencies that may be declared in a POM that’s marked as a parent of the current POM.
What’s a parent POM?<a data-type="indexterm" data-primary="POM file (Apache Maven)" data-secondary="dependency metadata" data-tertiary="parent POM" id="idm45310207266288"/>
It’s just like another <em>pom.xml</em> file except that your POM marks it with a parent/child relationship by using the <code>&lt;parent&gt;</code> section.
In this way, configuration defined by the parent POM can be inherited by the child POM.
We can inspect the dependency graph by invoking the <code>mvn dependency:tree</code> command, which resolves the dependency graph and prints it out:</p>

<pre data-type="programlisting">$ mvn dependency:tree
[INFO] Scanning for projects...
[INFO]
[INFO] --------------------------&lt; com.acme:example &gt;--------------------------
[INFO] Building example 1.0.0-SNAPSHOT
[INFO] --------------------------------[ jar ]---------------------------------
[INFO]
[INFO] --- maven-dependency-plugin:2.8:tree (default-cli) @ example ---
[INFO] com.acme:example:jar:1.0.0-SNAPSHOT
[INFO] \- org.apache.commons:commons-collections4:jar:4.4:compile
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------</pre>

<p>Here we can see that the current POM (identified by its GAV coordinates as <code>com.acme:example:1.0.0-SNAPSHOT</code>) has a single direct dependency.
Two additional elements are found in the output of the <code>commons-collections4</code> dependency: the first is <code>jar</code>, which identifies the type of the artifact, and the <a data-type="indexterm" data-primary="dependencies" data-secondary="scopes (Maven)" id="idm45310207261168"/><a data-type="indexterm" data-primary="scopes of dependencies (Maven)" id="idm45310207260192"/><a data-type="indexterm" data-primary="configuration of dependencies (Gradle)" data-secondary="scopes of dependencies in Maven" id="idm45310207218064"/>second is <code>compile</code>, which identifies the scope of the dependency.
We’ll come back to scopes in a moment, but suffice to say that if no explicit <code>&lt;scope&gt;</code> element is defined for a dependency, its default scope becomes <code>compile</code>.
Now, when a POM that contains direct dependencies is consumed, it brings along those dependencies as transitive from the point of view of the consuming POM.
The next example shows that particular setup:</p>

<pre data-type="programlisting" data-code-language="xml"><code class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</code>
<code class="nt">&lt;project</code>
  <code class="na">xsi:schemaLocation=</code><code class="s">"http://maven.apache.org/POM/4.0.0</code>
<code class="s">  http://maven.apache.org/xsd/maven-4.0.0.xsd"</code>
  <code class="na">xmlns=</code><code class="s">"http://maven.apache.org/POM/4.0.0"</code>
  <code class="na">xmlns:xsi=</code><code class="s">"http://www.w3.org/2001/XMLSchema-instance"</code><code class="nt">&gt;</code>
  <code class="nt">&lt;modelVersion&gt;</code>4.0.0<code class="nt">&lt;/modelVersion&gt;</code>
  <code class="nt">&lt;groupId&gt;</code>com.acme<code class="nt">&lt;/groupId&gt;</code>
  <code class="nt">&lt;artifactId&gt;</code>example<code class="nt">&lt;/artifactId&gt;</code>
  <code class="nt">&lt;version&gt;</code>1.0.0-SNAPSHOT<code class="nt">&lt;/version&gt;</code>

  <code class="nt">&lt;dependencies&gt;</code>
    <code class="nt">&lt;dependency&gt;</code>
      <code class="nt">&lt;groupId&gt;</code>commons-beanutils<code class="nt">&lt;/groupId&gt;</code>
      <code class="nt">&lt;artifactId&gt;</code>commons-beanutils<code class="nt">&lt;/artifactId&gt;</code>
      <code class="nt">&lt;version&gt;</code>1.9.4<code class="nt">&lt;/version&gt;</code>
    <code class="nt">&lt;/dependency&gt;</code>
  <code class="nt">&lt;/dependencies&gt;</code>
<code class="nt">&lt;/project&gt;</code></pre>

<p>Resolving and printing out the dependency graph using the same command as before yields this result:</p>

<pre data-type="programlisting">$ mvn dependency:tree
[INFO] Scanning for projects...
[INFO]
[INFO] --------------------------&lt; com.acme:example &gt;--------------------------
[INFO] Building example 1.0.0-SNAPSHOT
[INFO] --------------------------------[ jar ]---------------------------------
[INFO]
[INFO] --- maven-dependency-plugin:2.8:tree (default-cli) @ example ---
[INFO] com.acme:example:jar:1.0.0-SNAPSHOT
[INFO] \- commons-beanutils:commons-beanutils:jar:1.9.4:compile
[INFO]    +- commons-logging:commons-logging:jar:1.2:compile
[INFO]    \- commons-collections:commons-collections:jar:3.2.2:compile
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------</pre>

<p>This tells us that the <code>commons-beanutils</code> artifact has two dependencies set in the ​ <code>com⁠pile</code> scope, which from the point of view of the <code>com.acme:example:1.0.0-SNAPSHOT</code> happen to be seen as transitive.
These two transitive dependencies appear to have no direct dependencies of their own, as there’s nothing listed for either of them. However, if you were to look at the <code>commons-logging</code> POM file, you’ll find the following dependency declarations:</p>

<pre data-type="programlisting" data-code-language="xml"><code class="nt">&lt;dependencies&gt;</code>
  <code class="nt">&lt;dependency&gt;</code>
    <code class="nt">&lt;groupId&gt;</code>log4j<code class="nt">&lt;/groupId&gt;</code>
    <code class="nt">&lt;artifactId&gt;</code>log4j<code class="nt">&lt;/artifactId&gt;</code>
    <code class="nt">&lt;version&gt;</code>1.2.17<code class="nt">&lt;/version&gt;</code>
    <code class="nt">&lt;optional&gt;</code>true<code class="nt">&lt;/optional&gt;</code>
  <code class="nt">&lt;/dependency&gt;</code>
  <code class="nt">&lt;dependency&gt;</code>
    <code class="nt">&lt;groupId&gt;</code>logkit<code class="nt">&lt;/groupId&gt;</code>
    <code class="nt">&lt;artifactId&gt;</code>logkit<code class="nt">&lt;/artifactId&gt;</code>
    <code class="nt">&lt;version&gt;</code>1.0.1<code class="nt">&lt;/version&gt;</code>
    <code class="nt">&lt;optional&gt;</code>true<code class="nt">&lt;/optional&gt;</code>
  <code class="nt">&lt;/dependency&gt;</code>
  <code class="nt">&lt;dependency&gt;</code>
    <code class="nt">&lt;groupId&gt;</code>avalon-framework<code class="nt">&lt;/groupId&gt;</code>
    <code class="nt">&lt;artifactId&gt;</code>avalon-framework<code class="nt">&lt;/artifactId&gt;</code>
    <code class="nt">&lt;version&gt;</code>4.1.5<code class="nt">&lt;/version&gt;</code>
    <code class="nt">&lt;optional&gt;</code>true<code class="nt">&lt;/optional&gt;</code>
  <code class="nt">&lt;/dependency&gt;</code>
  <code class="nt">&lt;dependency&gt;</code>
    <code class="nt">&lt;groupId&gt;</code>javax.servlet<code class="nt">&lt;/groupId&gt;</code>
    <code class="nt">&lt;artifactId&gt;</code>servlet-api<code class="nt">&lt;/artifactId&gt;</code>
    <code class="nt">&lt;version&gt;</code>2.3<code class="nt">&lt;/version&gt;</code>
    <code class="nt">&lt;scope&gt;</code>provided<code class="nt">&lt;/scope&gt;</code>
    <code class="nt">&lt;optional&gt;</code>true<code class="nt">&lt;/optional&gt;</code>
  <code class="nt">&lt;/dependency&gt;</code>
  <code class="nt">&lt;dependency&gt;</code>
    <code class="nt">&lt;groupId&gt;</code>junit<code class="nt">&lt;/groupId&gt;</code>
    <code class="nt">&lt;artifactId&gt;</code>junit<code class="nt">&lt;/artifactId&gt;</code>
    <code class="nt">&lt;version&gt;</code>3.8.1<code class="nt">&lt;/version&gt;</code>
    <code class="nt">&lt;scope&gt;</code>test<code class="nt">&lt;/scope&gt;</code>
  <code class="nt">&lt;/dependency&gt;</code>
<code class="nt">&lt;/dependencies&gt;</code></pre>

<p>As you can see, there are actually five dependencies!
However, four of them define an additional <code>&lt;optional&gt;</code> element, while two define a different value for <code>&lt;scope&gt;</code>.
Dependencies marked as <code>&lt;optional&gt;</code> may be required for compiling and testing the producer (<code>commons-logging</code> in this case) but not necessarily for consumers; this is determined on a case-by-case basis.</p>

<p>It’s time to discuss scopes now that we see them once again.<a data-type="indexterm" data-primary="dependencies" data-secondary="scopes (Maven)" id="idm45310207108400"/><a data-type="indexterm" data-primary="scopes of dependencies (Maven)" id="idm45310207107456"/><a data-type="indexterm" data-primary="configuration of dependencies (Gradle)" data-secondary="scopes of dependencies in Maven" id="idm45310207106816"/>
<em>Scopes</em> determine whether a dependency is to be included in the classpath, as well as limit its transitivity. Maven defines six scopes as follows:</p>
<dl>
<dt><code>compile</code></dt>
<dd>
<p>The default scope, used if none is specified, as we saw earlier. Dependencies in this scope will be used for all classpaths in the project (compile, runtime, test) and will be propagated to consuming projects.<a data-type="indexterm" data-primary="compile dependency scope" id="idm45310207041568"/></p>
</dd>
<dt><code>provided</code></dt>
<dd>
<p>Like <code>compile</code>, except that it does not affect the runtime classpath nor is it transitive.<a data-type="indexterm" data-primary="provided dependency scope" id="idm45310207039008"/>
Dependencies set in this scope are expected to be provided by the hosting environment, as is the case for web applications packaged as WARs and launched from within an application server.</p>
</dd>
<dt><code>runtime</code></dt>
<dd>
<p>This scope indicates the dependency is not required for compilation but for execution.<a data-type="indexterm" data-primary="runtime dependency scope" id="idm45310207036800"/>
Both the runtime and test classpaths include dependencies set in this scope, while the compile classpath is ignored.</p>
</dd>
<dt><code>test</code></dt>
<dd>
<p>Defines dependencies required for compiling and running tests.
This scope is not transitive.<a data-type="indexterm" data-primary="test dependency scope" id="idm45310207034352"/><a data-type="indexterm" data-primary="testing" data-secondary="test dependency scope" id="idm45310207033648"/></p>
</dd>
<dt><code>system</code></dt>
<dd>
<p>Similar to <code>provided</code> except that dependencies must be listed with an explicit path, relative or absolute.<a data-type="indexterm" data-primary="system dependency scope" id="idm45310207030848"/>
Therefore, this scope is seen as a bad practice and should be avoided at all costs.
For a handful of use cases, it may come in handy, but you must bear the consequences.
At best, it’s an option left to the experts—in other words, imagine that this scope does not exist at all.</p>
</dd>
<dt><code>import</code></dt>
<dd>
<p>Applies only to dependencies of type <code>pom</code> (the default is <code>jar</code> if not specified) and can be used only for dependencies declared inside the <code>&lt;dependencyManagement&gt;</code> section.<a data-type="indexterm" data-primary="import dependency scope" id="idm45310207027104"/>
Dependencies in this scope are replaced by the list of dependencies found in their own <code>&lt;dependencyManagement&gt;</code> section.</p>
</dd>
</dl>

<p>The <code>&lt;dependencyManagement&gt;</code> section has three purposes: to provide version hints for transitive dependencies, to provide a list of dependencies that may be imported using the <code>import</code> scope, and to provide a set of defaults when used in a parent-child POM combination.
Let’s look at the first purpose.
Say you have the following dependencies defined in your POM file:</p>

<pre data-type="programlisting" data-code-language="xml"><code class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</code>
<code class="nt">&lt;project</code>
  <code class="na">xsi:schemaLocation=</code><code class="s">"http://maven.apache.org/POM/4.0.0</code>
<code class="s">  http://maven.apache.org/xsd/maven-4.0.0.xsd"</code>
  <code class="na">xmlns=</code><code class="s">"http://maven.apache.org/POM/4.0.0"</code>
  <code class="na">xmlns:xsi=</code><code class="s">"http://www.w3.org/2001/XMLSchema-instance"</code><code class="nt">&gt;</code>
  <code class="nt">&lt;modelVersion&gt;</code>4.0.0<code class="nt">&lt;/modelVersion&gt;</code>
  <code class="nt">&lt;groupId&gt;</code>com.acme<code class="nt">&lt;/groupId&gt;</code>
  <code class="nt">&lt;artifactId&gt;</code>example<code class="nt">&lt;/artifactId&gt;</code>
  <code class="nt">&lt;version&gt;</code>1.0.0-SNAPSHOT<code class="nt">&lt;/version&gt;</code>

  <code class="nt">&lt;dependencies&gt;</code>
    <code class="nt">&lt;dependency&gt;</code>
      <code class="nt">&lt;groupId&gt;</code>com.google.inject<code class="nt">&lt;/groupId&gt;</code>
      <code class="nt">&lt;artifactId&gt;</code>guice<code class="nt">&lt;/artifactId&gt;</code>
      <code class="nt">&lt;version&gt;</code>4.2.2<code class="nt">&lt;/version&gt;</code>
    <code class="nt">&lt;/dependency&gt;</code>
    <code class="nt">&lt;dependency&gt;</code>
      <code class="nt">&lt;groupId&gt;</code>com.google.truth<code class="nt">&lt;/groupId&gt;</code>
      <code class="nt">&lt;artifactId&gt;</code>truth<code class="nt">&lt;/artifactId&gt;</code>
      <code class="nt">&lt;version&gt;</code>1.0<code class="nt">&lt;/version&gt;</code>
    <code class="nt">&lt;/dependency&gt;</code>
  <code class="nt">&lt;/dependencies&gt;</code>
<code class="nt">&lt;/project&gt;</code></pre>

<p>Both the <code>guice</code> and <code>truth</code> artifacts define <code>guava</code> as a direct dependency.
This means <code>guava</code> is seen as a transitive dependency from the consumer’s point of view.
We get the following result if we resolve and print out the dependency graph:</p>

<pre data-type="programlisting">$ mvn dependency:tree
[INFO] Scanning for projects...
[INFO]
[INFO] --------------------------&lt; com.acme:example &gt;--------------------------
[INFO] Building example 1.0.0-SNAPSHOT
[INFO] --------------------------------[ jar ]---------------------------------
[INFO]
[INFO] --- maven-dependency-plugin:2.8:tree (default-cli) @ example ---
[INFO] com.acme:example:jar:1.0.0-SNAPSHOT
[INFO] +- com.google.inject:guice:jar:4.2.2:compile
[INFO] |  +- javax.inject:javax.inject:jar:1:compile
[INFO] |  +- aopalliance:aopalliance:jar:1.0:compile
[INFO] |  \- com.google.guava:guava:jar:25.1-android:compile
[INFO] |     +- com.google.code.findbugs:jsr305:jar:3.0.2:compile
[INFO] |     +- com.google.j2objc:j2objc-annotations:jar:1.1:compile
[INFO] |     \- org.codehaus.mojo:animal-sniffer-annotations:jar:1.14:compile
[INFO] \- com.google.truth:truth:jar:1.0:compile
[INFO]    +- org.checkerframework:checker-compat-qual:jar:2.5.5:compile
[INFO]    +- junit:junit:jar:4.12:compile
[INFO]    |  \- org.hamcrest:hamcrest-core:jar:1.3:compile
[INFO]    +- com.googlecode.java-diff-utils:diffutils:jar:1.3.0:compile
[INFO]    +- com.google.auto.value:auto-value-annotations:jar:1.6.3:compile
[INFO]    \- com.google.errorprone:error_prone_annotations:jar:2.3.1:compile
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------</pre>

<p>The resolved version of <code>guava</code> turns out to be <code>25.1-android</code> because that’s the version found first in the graph.
Look what happens if we invert the order of the dependencies and list <code>truth</code> before <code>guice</code> and resolve the graph once again:</p>

<pre data-type="programlisting">$ mvn dependency:tree
[INFO] Scanning for projects...
[INFO]
[INFO] --------------------------&lt; com.acme:example &gt;--------------------------
[INFO] Building example 1.0.0-SNAPSHOT
[INFO] --------------------------------[ jar ]---------------------------------
[INFO]
[INFO] --- maven-dependency-plugin:2.8:tree (default-cli) @ example ---
[INFO] com.acme:example:jar:1.0.0-SNAPSHOT
[INFO] +- com.google.truth:truth:jar:1.0:compile
[INFO] |  +- com.google.guava:guava:jar:27.0.1-android:compile
[INFO] |  |  +- com.google.guava:failureaccess:jar:1.0.1:compile
[INFO] |  |  +- com.google.guava:listenablefuture:jar:
                        9999.0-empty-to-avoid-conflict
[INFO] |  |  +- com.google.code.findbugs:jsr305:jar:3.0.2:compile
[INFO] |  |  +- com.google.j2objc:j2objc-annotations:jar:1.1:compile
[INFO] |  |  \- org.codehaus.mojo:animal-sniffer-annotations:jar:1.17:compile
[INFO] |  +- org.checkerframework:checker-compat-qual:jar:2.5.5:compile
[INFO] |  +- junit:junit:jar:4.12:compile
[INFO] |  |  \- org.hamcrest:hamcrest-core:jar:1.3:compile
[INFO] |  +- com.googlecode.java-diff-utils:diffutils:jar:1.3.0:compile
[INFO] |  +- com.google.auto.value:auto-value-annotations:jar:1.6.3:compile
[INFO] |  \- com.google.errorprone:error_prone_annotations:jar:2.3.1:compile
[INFO] \- com.google.inject:guice:jar:4.2.2:compile
[INFO]    +- javax.inject:javax.inject:jar:1:compile
[INFO]    \- aopalliance:aopalliance:jar:1.0:compile
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------</pre>

<p>Now the resolved version of <code>guava</code> happens to be <code>27.0.1-android</code> because it’s the one found first in the graph.
This particular behavior is a constant source of head-scratching moments and frustration.
As developers, we are used to versioning conventions, most notably <a href="https://semver.org">semantic versioning</a> when it applies to dependency versions.</p>

<p>Semantic versioning tells us that version tokens (separated by dots) have specific meaning based on their position.
The first token identifies the major release, the second token identifies the minor release, and the third token identifies the build/patch/fix/revision release.
It’s also customary that version <code>27.0.1</code> is seen as more recent than <code>25.1.0</code> because the major number <code>27</code> is greater than <code>25</code>.
In our case, we have two versions for <code>guava</code> in the graph, <code>27.0.1-android</code> and <code>25.1-android</code>, and both are found at the same distance from the current POM—that is, just one level down in the transitive graph.</p>

<p>It’s easy to assume that because we, as developers, are aware of semantic versioning and can clearly determine which version is more recent, so can Maven—and that is where assumption clashes with reality! Maven never looks at the version, but looks only at the location within the graph. This is why we get different results if we change the order of dependencies.
We can use the <code>&lt;dependencyManagement&gt;</code> section to fix this issue.</p>

<p>Dependencies defined in the <code>&lt;dependencyManagement&gt;</code> section usually have the three main GAV coordinates.
When Maven resolves dependencies, it will look at the definitions found in this section to see whether there’s a match for <code>groupId</code> and <code>artifactId</code>, in which case the associated <code>version</code> will be used.
It does not matter how deep in the graph a dependency may be, or how many times it may be found in the graph. If there’s a match, that explicit version will be the chosen one.
We can verify this claim by adding a <code>&lt;dependencyManagement&gt;</code> section to the consumer POM that looks like this:</p>

<pre data-type="programlisting" data-code-language="xml"><code class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</code>
<code class="nt">&lt;project</code>
  <code class="na">xsi:schemaLocation=</code><code class="s">"http://maven.apache.org/POM/4.0.0</code>
<code class="s">  http://maven.apache.org/xsd/maven-4.0.0.xsd"</code>
  <code class="na">xmlns=</code><code class="s">"http://maven.apache.org/POM/4.0.0"</code>
  <code class="na">xmlns:xsi=</code><code class="s">"http://www.w3.org/2001/XMLSchema-instance"</code><code class="nt">&gt;</code>
  <code class="nt">&lt;modelVersion&gt;</code>4.0.0<code class="nt">&lt;/modelVersion&gt;</code>
  <code class="nt">&lt;groupId&gt;</code>com.acme<code class="nt">&lt;/groupId&gt;</code>
  <code class="nt">&lt;artifactId&gt;</code>example<code class="nt">&lt;/artifactId&gt;</code>
  <code class="nt">&lt;version&gt;</code>1.0.0-SNAPSHOT<code class="nt">&lt;/version&gt;</code>

  <code class="nt">&lt;dependencyManagement&gt;</code>
    <code class="nt">&lt;dependencies&gt;</code>
      <code class="nt">&lt;dependency&gt;</code>
        <code class="nt">&lt;groupId&gt;</code>com.google.guava<code class="nt">&lt;/groupId&gt;</code>
        <code class="nt">&lt;artifactId&gt;</code>guava<code class="nt">&lt;/artifactId&gt;</code>
        <code class="nt">&lt;version&gt;</code>29.0-jre<code class="nt">&lt;/version&gt;</code>
      <code class="nt">&lt;/dependency&gt;</code>
    <code class="nt">&lt;/dependencies&gt;</code>
  <code class="nt">&lt;/dependencyManagement&gt;</code>

  <code class="nt">&lt;dependencies&gt;</code>
    <code class="nt">&lt;dependency&gt;</code>
      <code class="nt">&lt;groupId&gt;</code>com.google.truth<code class="nt">&lt;/groupId&gt;</code>
      <code class="nt">&lt;artifactId&gt;</code>truth<code class="nt">&lt;/artifactId&gt;</code>
      <code class="nt">&lt;version&gt;</code>1.0<code class="nt">&lt;/version&gt;</code>
    <code class="nt">&lt;/dependency&gt;</code>
    <code class="nt">&lt;dependency&gt;</code>
      <code class="nt">&lt;groupId&gt;</code>com.google.inject<code class="nt">&lt;/groupId&gt;</code>
      <code class="nt">&lt;artifactId&gt;</code>guice<code class="nt">&lt;/artifactId&gt;</code>
      <code class="nt">&lt;version&gt;</code>4.2.2<code class="nt">&lt;/version&gt;</code>
    <code class="nt">&lt;/dependency&gt;</code>
  <code class="nt">&lt;/dependencies&gt;</code>
<code class="nt">&lt;/project&gt;</code></pre>

<p>We can see that the declaration for <code>guava</code> uses the <code>com.google.guava:guava:29.0-jre</code> coordinates, meaning that version <code>29.0-jre</code> will be used if a transitive dependency happens to match the given <code>groupId</code> and <code>artifactId</code>. We know this will happen in our consumer POM, twice to be exact.
We get the following result when resolving and printing out the dependency graph:</p>

<pre data-type="programlisting">$ mvn dependency:tree
[INFO] Scanning for projects...
[INFO]
[INFO] --------------------------&lt; com.acme:example &gt;--------------------------
[INFO] Building example 1.0.0-SNAPSHOT
[INFO] --------------------------------[ jar ]---------------------------------
[INFO]
[INFO] --- maven-dependency-plugin:2.8:tree (default-cli) @ example ---
[INFO] com.acme:example:jar:1.0.0-SNAPSHOT
[INFO] +- com.google.truth:truth:jar:1.0:compile
[INFO] |  +- com.google.guava:guava:jar:29.0-jre:compile
[INFO] |  |  +- com.google.guava:failureaccess:jar:1.0.1:compile
[INFO] |  |  +- com.google.guava:listenablefuture:jar:
                        9999.0-empty-to-avoid-conflict
[INFO] |  |  +- com.google.code.findbugs:jsr305:jar:3.0.2:compile
[INFO] |  |  +- org.checkerframework:checker-qual:jar:2.11.1:compile
[INFO] |  |  \- com.google.j2objc:j2objc-annotations:jar:1.3:compile
[INFO] |  +- org.checkerframework:checker-compat-qual:jar:2.5.5:compile
[INFO] |  +- junit:junit:jar:4.12:compile
[INFO] |  |  \- org.hamcrest:hamcrest-core:jar:1.3:compile
[INFO] |  +- com.googlecode.java-diff-utils:diffutils:jar:1.3.0:compile
[INFO] |  +- com.google.auto.value:auto-value-annotations:jar:1.6.3:compile
[INFO] |  \- com.google.errorprone:error_prone_annotations:jar:2.3.1:compile
[INFO] \- com.google.inject:guice:jar:4.2.2:compile
[INFO]    +- javax.inject:javax.inject:jar:1:compile
[INFO]    \- aopalliance:aopalliance:jar:1.0:compile
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------</pre>

<p>Note that the chosen version for <code>guava</code> is indeed <code>29.0-jre</code> and not the previous versions we saw earlier in this chapter, confirming that the <code>&lt;dependencyManagement&gt;</code> section is performing its job as expected.</p>

<p>The second purpose of <code>&lt;dependencyManagement&gt;</code>, listing dependencies that may be imported, is accomplished by using the <code>import</code> scope alongside dependencies of type <code>pom</code>.
These types of dependencies usually define <code>&lt;dependencyManagement&gt;</code> sections of their own, although nothing stops these POMs from adding more sections.
POM dependencies that define<a data-type="indexterm" data-primary="dependencies" data-secondary="bill of materials" id="idm45310206920016"/><a data-type="indexterm" data-primary="bill of materials (BOM) dependencies" id="idm45310206830112"/> a <code>&lt;dependencyManagement&gt;</code> section and no <code>&lt;dependencies&gt;</code> section are known as bill of materials (BOM).
Typically, BOM dependencies define a set of artifacts that belong together for a particular purpose.
Although not explicitly defined in the Maven documentation, you can find two kinds of BOM dependencies:</p>
<dl>
<dt>Library</dt>
<dd>
<p>All declared dependencies belong to the same project even though they might have different group IDs, and possibly even different versions.
An example can be seen at <a href="https://oreil.ly/bcMHI">helidon-bom</a>, which groups all artifacts from the Helidon project.<a data-type="indexterm" data-primary="bill of materials (BOM) dependencies" data-secondary="library" id="idm45310206826432"/><a data-type="indexterm" data-primary="dependencies" data-secondary="bill of materials" data-tertiary="library" id="idm45310206825488"/></p>
</dd>
<dt>Stack</dt>
<dd>
<p>Dependencies are grouped by behavior and the synergy they bring.<a data-type="indexterm" data-primary="bill of materials (BOM) dependencies" data-secondary="stack" id="idm45310206822992"/><a data-type="indexterm" data-primary="dependencies" data-secondary="bill of materials" data-tertiary="stack" id="idm45310206822048"/>
Dependencies may belong to disparate projects.
See an example at <a href="https://oreil.ly/wgmVx">helidon-dependencies</a>, which groups the previous <code>helidon-bom</code> with other dependencies such as Netty, logging, and so on.</p>
</dd>
</dl>

<p>Let’s take the <code>helidon-dependencies</code> as a source of dependencies.
Inspecting this POM, we find dozens of dependencies declared inside its <code>&lt;dependencyManagement&gt;</code> section, only a few of which are seen in the following snippet:</p>

<pre data-type="programlisting" data-code-language="xml"><code class="nt">&lt;artifactId&gt;</code>helidon-dependencies<code class="nt">&lt;/artifactId&gt;</code>
<code class="nt">&lt;packaging&gt;</code>pom<code class="nt">&lt;/packaging&gt;</code>
<code class="cm">&lt;!-- additional elements elided --&gt;</code>
<code class="nt">&lt;dependencyManagement&gt;</code>
  <code class="nt">&lt;dependencies&gt;</code>
    <code class="cm">&lt;!-- more dependencies elided --&gt;</code>
    <code class="nt">&lt;dependency&gt;</code>
      <code class="nt">&lt;groupId&gt;</code>io.netty<code class="nt">&lt;/groupId&gt;</code>
      <code class="nt">&lt;artifactId&gt;</code>netty-handler<code class="nt">&lt;/artifactId&gt;</code>
      <code class="nt">&lt;version&gt;</code>4.1.51.Final<code class="nt">&lt;/version&gt;</code>
    <code class="nt">&lt;/dependency&gt;</code>
    <code class="nt">&lt;dependency&gt;</code>
      <code class="nt">&lt;groupId&gt;</code>io.netty<code class="nt">&lt;/groupId&gt;</code>
      <code class="nt">&lt;artifactId&gt;</code>netty-handler-proxy<code class="nt">&lt;/artifactId&gt;</code>
      <code class="nt">&lt;version&gt;</code>4.1.51.Final<code class="nt">&lt;/version&gt;</code>
    <code class="nt">&lt;/dependency&gt;</code>
    <code class="nt">&lt;dependency&gt;</code>
      <code class="nt">&lt;groupId&gt;</code>io.netty<code class="nt">&lt;/groupId&gt;</code>
      <code class="nt">&lt;artifactId&gt;</code>netty-codec-http<code class="nt">&lt;/artifactId&gt;</code>
      <code class="nt">&lt;version&gt;</code>4.1.51.Final<code class="nt">&lt;/version&gt;</code>
    <code class="nt">&lt;/dependency&gt;</code>
    <code class="cm">&lt;!-- more dependencies elided --&gt;</code>
  <code class="nt">&lt;/dependencies&gt;</code>
<code class="nt">&lt;/dependencyManagement&gt;</code></pre>

<p>Consuming this BOM dependency in our own POM requires the use of the <code>&lt;dependencyManagement&gt;</code> section once again.
We’ll also define an explicit dependency for <code>netty-handler</code> as we have done before when defining dependencies, except that this time we’ll omit the <code>&lt;version&gt;</code> element.
The POM ends up looking like this:</p>

<pre data-type="programlisting" data-code-language="xml"><code class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</code>
<code class="nt">&lt;project</code>
  <code class="na">xsi:schemaLocation=</code><code class="s">"http://maven.apache.org/POM/4.0.0</code>
<code class="s">  http://maven.apache.org/xsd/maven-4.0.0.xsd"</code>
  <code class="na">xmlns=</code><code class="s">"http://maven.apache.org/POM/4.0.0"</code>
  <code class="na">xmlns:xsi=</code><code class="s">"http://www.w3.org/2001/XMLSchema-instance"</code><code class="nt">&gt;</code>
  <code class="nt">&lt;modelVersion&gt;</code>4.0.0<code class="nt">&lt;/modelVersion&gt;</code>
  <code class="nt">&lt;groupId&gt;</code>com.acme<code class="nt">&lt;/groupId&gt;</code>
  <code class="nt">&lt;artifactId&gt;</code>example<code class="nt">&lt;/artifactId&gt;</code>
  <code class="nt">&lt;version&gt;</code>1.0.0-SNAPSHOT<code class="nt">&lt;/version&gt;</code>

  <code class="nt">&lt;dependencyManagement&gt;</code>
    <code class="nt">&lt;dependencies&gt;</code>
      <code class="nt">&lt;dependency&gt;</code>
        <code class="nt">&lt;groupId&gt;</code>io.helidon<code class="nt">&lt;/groupId&gt;</code>
        <code class="nt">&lt;artifactId&gt;</code>helidon-dependencies<code class="nt">&lt;/artifactId&gt;</code>
        <code class="nt">&lt;version&gt;</code>2.2.0<code class="nt">&lt;/version&gt;</code>
        <code class="nt">&lt;type&gt;</code>pom<code class="nt">&lt;/type&gt;</code>
        <code class="nt">&lt;scope&gt;</code>import<code class="nt">&lt;/scope&gt;</code>
      <code class="nt">&lt;/dependency&gt;</code>
    <code class="nt">&lt;/dependencies&gt;</code>
  <code class="nt">&lt;/dependencyManagement&gt;</code>

  <code class="nt">&lt;dependencies&gt;</code>
    <code class="nt">&lt;dependency&gt;</code>
      <code class="nt">&lt;groupId&gt;</code>io.netty<code class="nt">&lt;/groupId&gt;</code>
      <code class="nt">&lt;artifactId&gt;</code>netty-handler<code class="nt">&lt;/artifactId&gt;</code>
    <code class="nt">&lt;/dependency&gt;</code>
  <code class="nt">&lt;/dependencies&gt;</code>
<code class="nt">&lt;/project&gt;</code></pre>

<p>Note how the <code>helidon-dependencies</code> dependency was imported.
A key element must be defined, <code>&lt;type&gt;</code>, which must be set as <code>pom</code>.
Remember from earlier in this chapter that dependencies will have type <code>jar</code> by default if no value is specified?
Here we know that <code>helidon-dependencies</code> is a BOM; thus it does not have a JAR file associated with it.
If we leave out the type element, Maven will complain with a warning and will fail to resolve the version of <code>netty-handler</code>, so be sure not to miss setting this element correctly.
Resolving the dependency graph yields the following result:</p>

<pre data-type="programlisting">$ mvn dependency:tree
[INFO] Scanning for projects...
[INFO]
[INFO] --------------------------&lt; com.acme:example &gt;--------------------------
[INFO] Building example 1.0.0-SNAPSHOT
[INFO] --------------------------------[ jar ]---------------------------------
[INFO]
[INFO] --- maven-dependency-plugin:2.8:tree (default-cli) @ example ---
[INFO] com.acme:example:jar:1.0.0-SNAPSHOT
[INFO] \- io.netty:netty-handler:jar:4.1.51.Final:compile
[INFO]    +- io.netty:netty-common:jar:4.1.51.Final:compile
[INFO]    +- io.netty:netty-resolver:jar:4.1.51.Final:compile
[INFO]    +- io.netty:netty-buffer:jar:4.1.51.Final:compile
[INFO]    +- io.netty:netty-transport:jar:4.1.51.Final:compile
[INFO]    \- io.netty:netty-codec:jar:4.1.51.Final:compile
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------</pre>

<p>We can see that the correct version was chosen and that every direct dependency of <code>netty-handler</code> is resolved as transitive as well.</p>

<p>The third and final purpose of the <code>&lt;dependencyManagement&gt;</code> section comes into play when a parent-child relationship exists between POMs.
The POM format defines a <code>&lt;parent&gt;</code> section that any POM can use to establish a link with another POM seen as a parent.
Parent POMs provide configuration that can be inherited by child POMs, the parent <code>&lt;dependencyManagement&gt;</code> section being one of them. Maven follows the parent link upward until it can no longer find a parent definition, then processes down the chain resolving configuration, with the POMs located at lower levels overriding configuration set by those POMs in higher levels.</p>

<p>This means a child POM always has the option to override configuration declared by a parent POM.
Thus, a <code>&lt;dependencyManagement&gt;</code> section found in the parent POM will be visible to the child POM, as if it were defined on the child.
We still get the same benefits from the two previous purposes of this section, which means we can fix versions for transitive dependencies and import BOM dependencies.
The following is an example of a parent POM that declares <code>helidon-dependencies</code> and <code>commons-lang3</code> in its own <code>&lt;dependencyManagement&gt;</code> section:</p>

<pre data-type="programlisting" data-code-language="xml"><code class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</code>
<code class="nt">&lt;project</code>
   <code class="na">xsi:schemaLocation=</code><code class="s">"http://maven.apache.org/POM/4.0.0</code>
<code class="s">   http://maven.apache.org/xsd/maven-4.0.0.xsd"</code>
   <code class="na">xmlns=</code><code class="s">"http://maven.apache.org/POM/4.0.0"</code>
   <code class="na">xmlns:xsi=</code><code class="s">"http://www.w3.org/2001/XMLSchema-instance"</code><code class="nt">&gt;</code>
  <code class="nt">&lt;modelVersion&gt;</code>4.0.0<code class="nt">&lt;/modelVersion&gt;</code>
  <code class="nt">&lt;groupId&gt;</code>com.acme<code class="nt">&lt;/groupId&gt;</code>
  <code class="nt">&lt;artifactId&gt;</code>parent<code class="nt">&lt;/artifactId&gt;</code>
  <code class="nt">&lt;version&gt;</code>1.0.0-SNAPSHOT<code class="nt">&lt;/version&gt;</code>
  <code class="nt">&lt;packaging&gt;</code>pom<code class="nt">&lt;/packaging&gt;</code>

  <code class="nt">&lt;dependencyManagement&gt;</code>
    <code class="nt">&lt;dependencies&gt;</code>
      <code class="nt">&lt;dependency&gt;</code>
        <code class="nt">&lt;groupId&gt;</code>io.helidon<code class="nt">&lt;/groupId&gt;</code>
        <code class="nt">&lt;artifactId&gt;</code>helidon-dependencies<code class="nt">&lt;/artifactId&gt;</code>
        <code class="nt">&lt;version&gt;</code>2.2.0<code class="nt">&lt;/version&gt;</code>
        <code class="nt">&lt;type&gt;</code>pom<code class="nt">&lt;/type&gt;</code>
        <code class="nt">&lt;scope&gt;</code>import<code class="nt">&lt;/scope&gt;</code>
      <code class="nt">&lt;/dependency&gt;</code>
      <code class="nt">&lt;dependency&gt;</code>
        <code class="nt">&lt;groupId&gt;</code>org.apache.commons<code class="nt">&lt;/groupId&gt;</code>
        <code class="nt">&lt;artifactId&gt;</code>commons-lang3<code class="nt">&lt;/artifactId&gt;</code>
        <code class="nt">&lt;version&gt;</code>3.11<code class="nt">&lt;/version&gt;</code>
      <code class="nt">&lt;/dependency&gt;</code>
    <code class="nt">&lt;/dependencies&gt;</code>
  <code class="nt">&lt;/dependencyManagement&gt;</code>
<code class="nt">&lt;/project&gt;</code></pre>

<p>Given that no JAR file is associated with this POM file, we also must explicitly define the value for the <code>&lt;packaging&gt;</code> element as <code>pom</code>.
The child POM requires the use of the <code>&lt;parent&gt;</code> element to refer to this POM, shown in the following example:</p>

<pre data-type="programlisting" data-code-language="xml"><code class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</code>
<code class="nt">&lt;project</code>
  <code class="na">xsi:schemaLocation=</code><code class="s">"http://maven.apache.org/POM/4.0.0</code>
<code class="s">  http://maven.apache.org/xsd/maven-4.0.0.xsd"</code>
  <code class="na">xmlns=</code><code class="s">"http://maven.apache.org/POM/4.0.0"</code>
  <code class="na">xmlns:xsi=</code><code class="s">"http://www.w3.org/2001/XMLSchema-instance"</code><code class="nt">&gt;</code>
  <code class="nt">&lt;modelVersion&gt;</code>4.0.0<code class="nt">&lt;/modelVersion&gt;</code>
  <code class="nt">&lt;parent&gt;</code>
    <code class="nt">&lt;groupId&gt;</code>com.acme<code class="nt">&lt;/groupId&gt;</code>
    <code class="nt">&lt;artifactId&gt;</code>parent<code class="nt">&lt;/artifactId&gt;</code>
    <code class="nt">&lt;version&gt;</code>1.0.0-SNAPSHOT<code class="nt">&lt;/version&gt;</code>
  <code class="nt">&lt;/parent&gt;</code>
  <code class="nt">&lt;artifactId&gt;</code>example<code class="nt">&lt;/artifactId&gt;</code>

  <code class="nt">&lt;dependencies&gt;</code>
    <code class="nt">&lt;dependency&gt;</code>
      <code class="nt">&lt;groupId&gt;</code>io.netty<code class="nt">&lt;/groupId&gt;</code>
      <code class="nt">&lt;artifactId&gt;</code>netty-handler<code class="nt">&lt;/artifactId&gt;</code>
    <code class="nt">&lt;/dependency&gt;</code>
    <code class="nt">&lt;dependency&gt;</code>
      <code class="nt">&lt;groupId&gt;</code>org.apache.commons<code class="nt">&lt;/groupId&gt;</code>
      <code class="nt">&lt;artifactId&gt;</code>commons-lang3<code class="nt">&lt;/artifactId&gt;</code>
    <code class="nt">&lt;/dependency&gt;</code>
  <code class="nt">&lt;/dependencies&gt;</code>
<code class="nt">&lt;/project&gt;</code></pre>

<p>Perfect!
With this setup ready, it’s time to once again resolve the dependency graph and inspect its contents:</p>

<pre data-type="programlisting">$ mvn dependency:tree
[INFO] Scanning for projects...
[INFO]
[INFO] --------------------------&lt; com.acme:example &gt;--------------------------
[INFO] Building example 1.0.0-SNAPSHOT
[INFO] --------------------------------[ jar ]---------------------------------
[INFO]
[INFO] --- maven-dependency-plugin:2.8:tree (default-cli) @ example ---
[INFO] com.acme:example:jar:1.0.0-SNAPSHOT
[INFO] +- io.netty:netty-handler:jar:4.1.51.Final:compile
[INFO] |  +- io.netty:netty-common:jar:4.1.51.Final:compile
[INFO] |  +- io.netty:netty-resolver:jar:4.1.51.Final:compile
[INFO] |  +- io.netty:netty-buffer:jar:4.1.51.Final:compile
[INFO] |  +- io.netty:netty-transport:jar:4.1.51.Final:compile
[INFO] |  \- io.netty:netty-codec:jar:4.1.51.Final:compile
[INFO] \- org.apache.commons:commons-lang3:jar:3.11:compile
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------</pre>

<p>We have two direct dependencies as expected, with the correct GAV coordinates, as well as the transitive dependencies as seen earlier.
A few additional items are related to dependency management and resolution, such as dependency exclusions (eject a transitive dependency by its GA coordinates) and failing the build on dependency conflicts (different versions of the same GA coordinates found in the graph). However, it’s best to stop here and have a look at what Gradle offers in terms of dependency management.<a data-type="indexterm" data-startref="ch06-deppom" id="idm45310206528576"/><a data-type="indexterm" data-startref="ch06-deppom2" id="idm45310206527936"/><a data-type="indexterm" data-startref="ch06-deppom3" id="idm45310206527264"/><a data-type="indexterm" data-startref="ch06-deppom4" id="idm45310206526592"/><a data-type="indexterm" data-startref="ch06-deppom5" id="idm45310206525920"/><a data-type="indexterm" data-startref="ch06-deppom6" id="idm45310206525248"/><a data-type="indexterm" data-startref="ch06-depapm" id="idm45310206480256"/><a data-type="indexterm" data-startref="ch06-depapm2" id="idm45310206479648"/><a data-type="indexterm" data-startref="ch06-depapm3" id="idm45310206479040"/><a data-type="indexterm" data-startref="ch06-depapm4" id="idm45310206478432"/></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Dependency Management with Gradle"><div class="sect2" id="idm45310207310624">
<h2>Dependency Management with Gradle</h2>

<p>As mentioned earlier, Gradle builds<a data-type="indexterm" data-primary="dependencies" data-secondary="management basics" data-tertiary="Gradle" id="ch06-depgrad"/><a data-type="indexterm" data-primary="Gradle" data-secondary="dependency management" id="ch06-depgrad2"/><a data-type="indexterm" data-primary="package management" data-secondary="dependency management" data-tertiary="Gradle" id="ch06-depgrad3"/> on top of the lessons learned from Maven and understands the POM format, allowing it to provide dependency resolution capabilities similar to Maven.
Gradle also offers additional capabilities and finer-grained control.
This section refers to topics already covered, so I recommend you read the preceding section first in the event you skipped it, or if you need a refresher on dependency management as provided by Maven.
Let’s have a look at what Gradle offers.</p>

<p>First, you must select the DSL for writing the build file.<a data-type="indexterm" data-primary="Apache Groovy" data-secondary="Gradle build file" id="idm45310206472400"/><a data-type="indexterm" data-primary="Kotlin for Gradle build file" id="idm45310206471456"/>
Your options are the Apache Groovy DSL or the Kotlin DSL.
We’ll continue with the former, as Groovy has more examples found in the wild.
It’s also easier to move from Groovy to Kotlin than vice versa, meaning that snippets written with Groovy can be used verbatim with Kotlin (with perhaps a few changes suggested by the IDE), whereas moving in the other direction requires knowledge of both DSLs.
The next step is picking the format for recording dependencies, for which there are quite a few; the most common formats are a single literal with GAV coordinates, such as this:</p>

<pre data-type="programlisting" data-code-language="groovy"><code class="s1">'org.apache.commons:commons-collections4:4.4'</code></pre>

<p>and the Map literal that splits each member of the GAV coordinates into its own element, such as this:</p>

<pre data-type="programlisting" data-code-language="groovy"><code class="nl">group:</code> <code class="s1">'org.apache.commons'</code><code class="o">,</code> <code class="nl">name:</code> <code class="s1">'commons-collections4'</code><code class="o">,</code> <code class="nl">version:</code> <code class="s1">'4.4'</code></pre>

<p>Note that Gradle chose to go with <code>group</code> instead of <code>groupId</code>, and <code>name</code> instead of <code>artifactId</code>, though the semantics are the same.</p>

<p>The next order of business is declaring<a data-type="indexterm" data-primary="scopes of dependencies (Maven)" data-secondary="configuration in Gradle" id="idm45310206463184"/><a data-type="indexterm" data-primary="dependencies" data-secondary="configuration (Gradle)" id="idm45310206462240"/><a data-type="indexterm" data-primary="configuration of dependencies (Gradle)" id="idm45310206461296"/> dependencies for a particular scope (in Maven’s terms), though Gradle calls this <em>configuration</em>, and the behavior goes beyond what scopes are capable of.
Assuming the <code>java-library</code> plug-in is applied to a Gradle build file, we gain access to the following configurations by default:</p>
<dl>
<dt><code>api</code></dt>
<dd>
<p>Defines dependencies required for compiling production code and affects the compile classpath.
It is equivalent to the <code>compile</code> scope and thus is mapped as such when a POM is generated.</p>
</dd>
<dt><code>implementation</code></dt>
<dd>
<p>Defines dependencies required for compilation but deemed as implementation details; they are more flexible than dependencies found in the <code>api</code> configuration.
This configuration affects the compile classpath but will be mapped to the <code>runtime</code> scope when a POM is generated.</p>
</dd>
<dt><code>compileOnly</code></dt>
<dd>
<p>Defines dependencies required for compilation but not for execution.
This configuration affects the compile classpath, but these dependencies are not shared with other classpaths.
Also, they are not mapped to the generated POM.</p>
</dd>
<dt><code>runtimeOnly</code></dt>
<dd>
<p>Dependencies in this configuration are needed for execution only and affect only the runtime classpath.
They are mapped to the <code>runtime</code> scope when a POM is generated.</p>
</dd>
<dt><code>testImplementation</code></dt>
<dd>
<p>Defines dependencies required for compiling test code and affects the <span class="keep-together"><code>testCompile</code></span> classpath.
They are mapped to the <code>test</code> scope when a POM is generated.</p>
</dd>
<dt><code>testCompileOnly</code></dt>
<dd>
<p>Defines dependencies required for compiling test code but not for execution.
This configuration affects the <code>testCompile</code> classpath, but these dependencies are not shared with the testRuntime classpath.
Also, they are not mapped to the generated POM.</p>
</dd>
<dt><code>testRuntimeOnly</code></dt>
<dd>
<p>Dependencies with this configuration are needed for executing test code and affect only the <code>testRuntime</code> classpath.
They are mapped to the <code>test</code> scope when a POM is generated.</p>
</dd>
</dl>

<p>You may see additional configurations depending on the Gradle version in use, including the following legacy ones (which were deprecated in Gradle 6 and removed in Gradle 7):</p>
<dl>
<dt><code>compile</code></dt>
<dd>
<p>This configuration was split into <code>api</code> and <code>implementation</code>.</p>
</dd>
<dt><code>runtime</code></dt>
<dd>
<p>Deprecated in favor of <code>runtimeOnly</code>.</p>
</dd>
<dt><code>testCompile</code></dt>
<dd>
<p>Deprecated in favor of <code>testImplementation</code> to align with the <code>implementation</code> configuration name.</p>
</dd>
<dt><code>testRuntime</code></dt>
<dd>
<p>Deprecated in favor of <code>testRuntimeOnly</code> to be consistent with <code>runtimeOnly</code>.</p>
</dd>
</dl>

<p>Similarly to Maven, the classpaths follow a hierarchy.
The compile classpath can be consumed by the runtime classpath, thus every dependency set in either the <code>api</code> or <code>implementation</code> configurations is also available for execution.
This classpath can also be consumed by the test compile classpath, enabling production code to be seen by test code.
The runtime and test classpaths are consumed by the test runtime classpath, allowing test execution access to all dependencies defined in all the configurations so far mentioned.</p>

<p>As with Maven, dependencies can be resolved from repositories.
Unlike Maven, in which both Maven local and Maven Central repositories are always available, in Gradle we must explicitly define the repositories from which dependencies may be consumed.
Gradle lets you define repositories that follow the standard Maven layout, the Ivy layout, and even local directories with a flat layout.
It also provides conventional options to configure the most commonly known repository, Maven Central.
We’ll use <code>mavenCentral</code> for now as our only repository.
Putting together everything we have seen so far, we can produce a build file like the following:</p>

<pre data-type="programlisting" data-code-language="groovy"><code class="n">plugins</code> <code class="o">{</code>
  <code class="n">id</code> <code class="s1">'java-library'</code>
<code class="o">}</code>

<code class="n">repositories</code> <code class="o">{</code>
  <code class="n">mavenCentral</code><code class="o">()</code>
<code class="o">}</code>

<code class="n">dependencies</code> <code class="o">{</code>
  <code class="n">api</code> <code class="s1">'org.apache.commons:commons-collections4:4.4'</code>
<code class="o">}</code></pre>

<p>We can print the resolved dependency graph by invoking the <code>dependencies</code> task.
However, this will print the graph for every single configuration, so we’ll print only the resolved dependency graph for the compile classpath for the sake of keeping the output short, as well as to showcase an extra setting that can be defined for this task:</p>

<pre data-type="programlisting">$ gradle dependencies --configuration compileClasspath

&gt; Task :dependencies

------------------------------------------------------------
Root project
------------------------------------------------------------

compileClasspath - Compile classpath for source set 'main'.
\--- org.apache.commons:commons-collections4:4.4</pre>

<p>As you can see, only a single dependency is printed out, because <code>commons-collections</code> does not have any direct dependencies of its own that are visible to consumers.</p>

<p>Let’s see what happens when we configure another dependency that brings in additional transitive dependencies, but this time using the <code>implementation</code> configuration that will show that both <code>api</code> and <code>implementation</code> contribute to the compile classpath.
The updated build file looks like this:</p>

<pre data-type="programlisting" data-code-language="groovy"><code class="n">plugins</code> <code class="o">{</code>
  <code class="n">id</code> <code class="s1">'java-library'</code>
<code class="o">}</code>

<code class="n">repositories</code> <code class="o">{</code>
  <code class="n">mavenCentral</code><code class="o">()</code>
<code class="o">}</code>

<code class="n">dependencies</code> <code class="o">{</code>
  <code class="n">api</code> <code class="s1">'org.apache.commons:commons-collections4:4.4'</code>
  <code class="n">implementation</code> <code class="s1">'commons-beanutils:commons-beanutils:1.9.4'</code>
<code class="o">}</code></pre>

<p>Running the <code>dependencies</code> task with the same configuration as before now yields the following result:</p>

<pre data-type="programlisting">$ gradle dependencies --configuration compileClasspath

&gt; Task :dependencies

------------------------------------------------------------
Root project
------------------------------------------------------------

compileClasspath - Compile classpath for source set 'main'.
+--- org.apache.commons:commons-collections4:4.4
\--- commons-beanutils:commons-beanutils:1.9.4
     +--- commons-logging:commons-logging:1.2
     \--- commons-collections:commons-collections:3.2.2</pre>

<p>This tells us our consumer project has two direct dependencies contributing to the compile classpath, and that one of those dependencies brings two additional dependencies seen as transitive from our consumer’s point of view.
If for some reason you’d like to skip bringing those transitive dependencies into your dependency graph, you can add an extra block of configuration on the direct dependency that declares them, like this:</p>

<pre data-type="programlisting" data-code-language="groovy"><code class="n">plugins</code> <code class="o">{</code>
  <code class="n">id</code> <code class="s1">'java-library'</code>
<code class="o">}</code>

<code class="n">repositories</code> <code class="o">{</code>
  <code class="n">mavenCentral</code><code class="o">()</code>
<code class="o">}</code>

<code class="n">dependencies</code> <code class="o">{</code>
  <code class="n">api</code> <code class="s1">'org.apache.commons:commons-collections4:4.4'</code>
  <code class="n">implementation</code><code class="o">(</code><code class="s1">'commons-beanutils:commons-beanutils:1.9.4'</code><code class="o">)</code> <code class="o">{</code>
    <code class="n">transitive</code> <code class="o">=</code> <code class="kc">false</code>
  <code class="o">}</code>
<code class="o">}</code></pre>

<p>Running the <code>dependencies</code> task once more now shows only the direct dependencies and no transitive dependencies:</p>

<pre data-type="programlisting">$ gradle dependencies --configuration compileClasspath

&gt; Task :dependencies

------------------------------------------------------------
Root project
------------------------------------------------------------

compileClasspath - Compile classpath for source set 'main'.
+--- org.apache.commons:commons-collections4:4.4
\--- commons-beanutils:commons-beanutils:1.9.4</pre>

<p>The final aspect I’d like to cover before moving on is that unlike Maven, Gradle understands semantic versioning and will act accordingly during dependency resolution, choosing the highest version number as a result.
We can verify this by configuring two versions of the same dependency, no matter whether they are direct or transitive, as shown in the following snippet:</p>

<pre data-type="programlisting" data-code-language="groovy"><code class="n">plugins</code> <code class="o">{</code>
  <code class="n">id</code> <code class="s1">'java-library'</code>
<code class="o">}</code>

<code class="n">repositories</code> <code class="o">{</code>
  <code class="n">mavenCentral</code><code class="o">()</code>
<code class="o">}</code>

<code class="n">dependencies</code> <code class="o">{</code>
  <code class="n">api</code> <code class="s1">'org.apache.commons:commons-collections4:4.4'</code>
  <code class="n">implementation</code> <code class="s1">'commons-collections:commons-collections:3.2.1'</code>
  <code class="n">implementation</code> <code class="s1">'commons-beanutils:commons-beanutils:1.9.4'</code>
<code class="o">}</code></pre>

<p>In this case, we have declared a direct dependency for <code>commons-collections</code> version <code>3.2.1</code>.
We know from previous runs that <code>commons-beanutils:1.9.4</code> brings in version <code>3.2.2</code> of <code>commons-collections</code>. Given that <code>3.2.2</code> is considered more recent than <code>3.2.1</code>, we expect that <code>3.2.2</code> will be resolved.
Invoking the <code>dependencies</code> task yields the following result:</p>

<pre data-type="programlisting">$ gradle dependencies --configuration compileClasspath

&gt; Task :dependencies

------------------------------------------------------------
Root project
------------------------------------------------------------

compileClasspath - Compile classpath for source set 'main'.
+--- org.apache.commons:commons-collections4:4.4
+--- commons-collections:commons-collections:3.2.1 -&gt; 3.2.2
\--- commons-beanutils:commons-beanutils:1.9.4
     +--- commons-logging:commons-logging:1.2
     \--- commons-collections:commons-collections:3.2.2

(*) - dependencies omitted (listed previously)</pre>

<p>As expected, version 3.2.2 was selected.
The output even contains an indicator telling us when a dependency version was set to a different value other than the requested one.
Versions may be also configured to be fixed regardless of their semantic versioning scheme, even to lower values.
This is because Gradle offers more flexible options for dependency resolution strategies. However, that falls into the realm of advanced topics alongside dependency locking, strict versus suggested versions, dependency relocation, platforms and enforced platforms (Gradle’s way to interact with BOM artifacts), and more.<a data-type="indexterm" data-startref="ch06-depgrad" id="idm45310206210720"/><a data-type="indexterm" data-startref="ch06-depgrad2" id="idm45310206210016"/><a data-type="indexterm" data-startref="ch06-depgrad3" id="idm45310206209344"/></p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Dependency Management Basics for Containers"><div class="sect1" id="idm45310206477696">
<h1>Dependency Management Basics for Containers</h1>

<p>Further along the line of the software<a data-type="indexterm" data-primary="dependencies" data-secondary="management basics" data-tertiary="containers" id="idm45310206207520"/><a data-type="indexterm" data-primary="containers" data-secondary="dependency management" id="idm45310206206272"/><a data-type="indexterm" data-primary="package management" data-secondary="dependency management" data-tertiary="containers" id="idm45310206205328"/><a data-type="indexterm" data-primary="Dockerfile" data-secondary="dependency management for containers" id="idm45310206204112"/><a data-type="indexterm" data-primary="container images" data-secondary="dependency management" id="idm45310206203200"/> development cycle, you may encounter a step where packaging your Maven and Gradle project into a container image is necessary.
Just like other dependencies in your project, your container images must also be managed appropriately and in concert with other required artifacts.
Containers are discussed in detail in <a data-type="xref" href="ch03.xhtml#thinking_in_containers">Chapter 3</a>, but this section focuses primarily on some of the subtleties of container image management.
As with the dependency management in the automated build tools Maven and Gradle, even more dragons may lie ahead.</p>

<p>As you learned in <a data-type="xref" href="ch03.xhtml#thinking_in_containers">Chapter 3</a>, containers are launched using container images that are most commonly defined using a Dockerfile.
The Dockerfile does the work of defining each layer of the image that will be used to build the running container.
From this definition, you will get a base distribution layer, code libraries and frameworks, and any other needed files or artifacts required to run your software.
Here you will also define any necessary configuration (for example, open ports, database credentials, and references to messaging servers) as well as any required users and permissions.</p>

<p>It’s line 1 of the Dockerfile that we discuss in this section first, or in the case of multistage build Dockerfiles, the lines that begin with the directive <code>FROM</code>.
Similarly to the Maven POM, an image can be built from a <code>parent</code> image, which may be built from another parent image—a hierarchy that goes all the way to a <code>base</code> image, the original ancestor.
Here we must pay special attention to the way our images are composed.</p>

<p>As you may remember from <a data-type="xref" href="ch03.xhtml#thinking_in_containers">Chapter 3</a>, the versioning of Docker images is intended to provide flexibility during the development stage of your software, as well as a measure of confidence that you are using the latest maintenance update of an image when desired.
Most often this is done by referencing the special image version <code>latest</code> (the default version if a version is not specified), a request for which will retrieve what is assumed to be the latest version of the image in active development.
Although not a perfect comparison, this is most like using a <code>snapshot</code> version of a Java dependency.</p>

<p>This is all fine and good during development, but when it comes to troubleshooting a new bug in production, this type of versioning in a production image artifact can make troubleshooting more of a challenge.
Once an image has been built with this default <code>latest</code> version in place for a parent or a base image, reproducing the build may be difficult or even impossible.
Just as you would want to avoid using a snapshot dependency in a production release, I recommend locking down your image versions and avoiding using the default <code>latest</code> in order to limit the number of moving parts.</p>

<p>Simply locking down your image versions isn’t sufficient from the context of security.
Use only trusted base images when building your containers.
This tip might seem like an obvious one, but third-party registries often don’t have any governance policies for the images stored in them.
It’s important to know which images are available for use on the Docker host, understand their provenance, and review their content.
You should also enable Docker Content Trust (DCT) for image verification and install only verified packages into images.</p>

<p>Use minimal base images <a data-type="indexterm" data-primary="attack surface" data-secondary="minimal base images" id="idm45310206166336"/><a data-type="indexterm" data-primary="container images" data-secondary="minimal image size" id="idm45310206165488"/>that don’t include unnecessary software packages that could lead to a larger attack surface.
Having fewer components in your container reduces the number of available attack vectors, and a minimal image also yields better performance because there are fewer bytes on disk and less network traffic for images being copied.
BusyBox and Alpine are two options for building minimal base images.
Pay just as careful attention to any additional layers you build on top of your verified base image by explicitly specifying all versions of software packages or any other artifacts you pull into the image.<a data-type="indexterm" data-startref="ch06-depend" id="idm45310206164512"/><a data-type="indexterm" data-startref="ch06-depend2" id="idm45310206163904"/><a data-type="indexterm" data-startref="ch06-depend3" id="idm45310206163296"/></p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Artifact Publication"><div class="sect1" id="idm45310206162432">
<h1>Artifact Publication</h1>

<p>Up to now, I’ve discussed how artifacts<a data-type="indexterm" data-primary="package management" data-secondary="artifact publication" data-tertiary="about" id="idm45310206160672"/><a data-type="indexterm" data-primary="repositories" data-secondary="publication to" id="idm45310206159424"/><a data-type="indexterm" data-primary="dependencies" data-secondary="repositories explained" id="idm45310206158480"/><a data-type="indexterm" data-primary="Apache Maven" data-secondary="artifact publication" data-tertiary="about" id="idm45310206157536"/><a data-type="indexterm" data-primary="Maven (Apache)" data-secondary="artifact publication" data-tertiary="about" id="idm45310206156320"/><a data-type="indexterm" data-primary="Apache Maven" data-secondary="dependency management" data-tertiary="artifact publication" id="ch06-artpub"/><a data-type="indexterm" data-primary="Maven (Apache)" data-secondary="dependency management" data-tertiary="artifact publication" id="ch06-artpub2"/> and dependencies may be resolved, often from locations known as repositories, but what is a repository, and how do you publish artifacts to it?
In the most basic sense, an <em>artifact repository</em> is file storage that keeps track of artifacts.
A repository collects metadata<a data-type="indexterm" data-primary="metadata" data-secondary="published artifacts in repositories" id="idm45310206151616"/><a data-type="indexterm" data-primary="data" data-secondary="metadata" data-tertiary="published artifacts in repositories" id="idm45310206150672"/> on each published artifact and uses that metadata to offer additional capabilities such as search, archiving, access control lists (ACLs), and others.
Tools can harness this metadata to offer other capabilities on top such as vulnerability scanning, metrics, categorization, and more.</p>

<p>We can use two types of repositories for Maven<a data-type="indexterm" data-primary="Maven (Apache)" data-secondary="artifact publication" data-tertiary="Maven Local" id="ch06-local"/><a data-type="indexterm" data-primary="Apache Maven" data-secondary="artifact publication" data-tertiary="Maven Local" id="ch06-local2"/><a data-type="indexterm" data-primary="Maven Local" id="ch06-local3"/><a data-type="indexterm" data-primary="package management" data-secondary="artifact publication" data-tertiary="Maven Local" id="ch06-local4"/><a data-type="indexterm" data-primary="Apache Maven" data-secondary="artifact publication" data-tertiary="Maven Central" id="idm45310206143328"/><a data-type="indexterm" data-primary="Maven Central" id="idm45310206142112"/><a data-type="indexterm" data-primary="Maven (Apache)" data-secondary="artifact publication" data-tertiary="Maven Central" id="idm45310206141440"/> dependencies, those dependencies that can be resolved via GAV coordinates: local and remote. Maven uses a configurable directory found in the local file system to keep track of dependencies that have been resolved.
These dependencies may have been downloaded from a remote repository or directly placed there by the Maven tool itself.
This directory is typically referred to as <em>Maven Local</em>, and its default location is <em>.m2/repository</em>, found at the home directory of the current user.
This location is configurable.
On the other side of the spectrum are remote repositories, which are handled by repository software such as Sonatype Nexus Repository, JFrog Artifactory, and others.
The most well-known remote repository is Maven Central, which is the canonical repository for resolving artifacts.</p>

<p>Let’s discuss now how we can publish artifacts to local and remote repositories.</p>








<section data-type="sect2" data-pdf-bookmark="Publishing to Maven Local"><div class="sect2" id="idm45310206138512">
<h2>Publishing to Maven Local</h2>

<p>Maven offers three ways to publish artifacts to the Maven Local repository.
Two are explicit, and one is implicit.
We’ve already covered the implicit one—it occurs whenever Maven resolves a dependency from a remote repository; as a result, a copy of the artifact and its metadata (the associated <em>pom.xml</em>) will be placed in the Maven Local repository.
This behavior occurs by default since Maven uses Maven Local as a cache to avoid requesting artifacts over the network all over again.</p>

<p>The other two ways of publishing artifacts to Maven Local are by explicitly “installing” files into the repository. Maven has a set of lifecycle phases, of which <em>install</em> is one.
This phase is well-known by Java developers, as it’s used (and abused) to compile, test, package, and install artifacts to Maven Local.
The Maven lifecycle phases follow a predetermined sequence:</p>

<pre data-type="programlisting">Available lifecycle phases are: validate, initialize, generate-sources,
process-sources, generate-resources, process-resources, compile,
process-classes, generate-test-sources, process-test-sources,
generate-test-resources, process-test-resources, test-compile,
process-test-classes, test, prepare-package, package, pre-integration-test,
integration-test, post-integration-test, verify, install, deploy,
pre-clean, clean, post-clean, pre-site, site, post-site, site-deploy.</pre>

<p>Phases are executed in sequence until the terminal phase is found.
Thus invoking <em>install</em> typically results in an almost full build (except for <em>deploy</em> and <em>site</em>).
I mentioned <em>install</em> is abused, as most times it’s enough to invoke <em>verify</em>, the phase that’s right before <em>install</em>, as the former will force compile, test, package, and integration-test but does not pollute Maven Local with artifacts if they are not needed.
This is in no way a recommendation to drop <em>install</em> in favor of <em>verify</em> all the time, as sometimes a test will require resolving artifacts from Maven Local. The bottom line is to be aware of the inputs/outputs of each phase and their consequences.</p>

<p>Back to installing.
The first way to install artifacts to Maven Local is simply invoking the <em>install</em> phase, like so:</p>

<pre data-type="programlisting">$ mvn install</pre>

<p>This will place copies of all of the <em>pom.xml</em> files renamed to follow the convention <code><em>artifactId</em></code>-<code><em>version</em>.pom</code> as well as every attached artifact into Maven Local.
Attached artifacts are typically the binary JARs produced by the build but can also include other JARs such as the <code>-sources</code> and <code>-javadoc</code> JARs.
The second way to install artifacts is by manually invoking the <code>install:install-file</code> goal with a set of parameters.
Let’s say you have a JAR (<em>artifact.jar</em>) and a matching POM file (<em>artifact.pom</em>).
Installing them can be done in the following way:</p>

<pre data-type="programlisting">$ mvn install:install-file -Dfile=artifact.jar -DpomFile=artifact.pom</pre>

<p>Maven will read the metadata found in the POM file and place the files in their corresponding location based on the resolved GAV coordinates.
It’s possible to override the GAV coordinates, generate the POM on the fly, and even omit the explicit POM if the JAR contains a copy inside. (That’s typically the case for JARs built with Maven; Gradle, on the other hand, does not include the POM by default.)</p>

<p>Gradle has one way to publish artifacts to Maven Local, and that is by applying the <code>maven-publish</code> plug-in.
This plug-in adds new capabilities to the project such as the <code>publishToMavenLocal</code> task; as the name indicates, it will copy the built artifacts and a generated POM to Maven Local.
Unlike Maven, Gradle does not use Maven Local as a cache, as it has its own caching infrastructure.
Thus, when Gradle resolves <span class="keep-together">dependencies</span>, the files are placed at a different location, usually <em>.gradle/caches/modules-2/files-2.1</em>, located at the home directory of the current user.</p>

<p>That covers publishing to Maven Local.<a data-type="indexterm" data-startref="ch06-local" id="idm45310206119280"/><a data-type="indexterm" data-startref="ch06-local2" id="idm45310206118576"/><a data-type="indexterm" data-startref="ch06-local3" id="idm45310206117904"/><a data-type="indexterm" data-startref="ch06-local4" id="idm45310206117232"/>
Now let’s have a look at remote repositories.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Publishing to Maven Central"><div class="sect2" id="idm45310206137856">
<h2>Publishing to Maven Central</h2>

<p>The <em>Maven Central</em> repository is the<a data-type="indexterm" data-primary="Maven (Apache)" data-secondary="artifact publication" data-tertiary="Maven Central" id="ch06-central"/><a data-type="indexterm" data-primary="Apache Maven" data-secondary="artifact publication" data-tertiary="Maven Central" id="ch06-central2"/><a data-type="indexterm" data-primary="Maven Central" id="ch06-central3"/><a data-type="indexterm" data-primary="package management" data-secondary="artifact publication" data-tertiary="Maven Central" id="ch06-central4"/> backbone that allows Java projects to be built on a daily basis.
The software running Maven Central<a data-type="indexterm" data-primary="Sonatype Nexus Repository" id="idm45310206108288"/><a data-type="indexterm" data-primary="repositories" data-secondary="Sonatype Nexus Repository" id="idm45310206107600"/> is <em>Sonatype Nexus Repository</em>, an artifact repository provided by Sonatype.
Given its important role in the Java ecosystem, <a data-type="indexterm" data-primary="Maven Central" data-secondary="rules guide" id="idm45310206105984"/><a data-type="indexterm" data-primary="Maven (Apache)" data-secondary="artifact publication" data-tertiary="Maven Central rules guide" id="idm45310206105040"/><a data-type="indexterm" data-primary="Apache Maven" data-secondary="artifact publication" data-tertiary="Maven Central rules guide" id="idm45310206103760"/><a data-type="indexterm" data-primary="resources for learning" data-secondary="Maven Central rules guide" id="idm45310206102528"/><a data-type="indexterm" data-primary="resources for learning" data-secondary="Apache Maven" data-tertiary="Maven Central rules guide" id="idm45310206101568"/>Maven Central has placed a set of rules that must be followed when publishing artifacts; Sonatype has published a <a href="https://oreil.ly/xfhNd">guide</a> explaining the prerequisites and rules.
I highly recommend reading through the guide in case requirements have been updated since the publication of this book.
In short, you must ensure the following:</p>

<ul>
<li>
<p>You must prove ownership of the reverse domain of the target <code>groupId</code>.
If your <code>groupId</code> is <code>com.acme.*</code>, you must own <code>acme.com</code>.</p>
</li>
<li>
<p>When publishing a binary JAR, you must also supply <code>-sources</code> and <code>javadoc</code> JARs, as well as a matching POM—that is, a minimum of four separate files.</p>
</li>
<li>
<p>When publishing an artifact of type POM, only the POM file is needed.</p>
</li>
<li>
<p>PGP signature files for all artifacts must be submitted as well.
The PGP keys used for signing must be published in public-key servers to let Maven Central verify signatures.</p>
</li>
<li>
<p>Perhaps the aspect that trips up most people at the beginning: POM files must comply with a minimum set of elements such as <code>&lt;license&gt;</code>, <code>&lt;developers&gt;</code>, <code>&lt;scm&gt;</code>, and others.
These elements are described in the guide; omitting any of them will cause a failure during publication, and as result artifacts won’t be published at all.</p>
</li>
</ul>

<p>We can avoid the last problem or at least detect it much earlier during development by using the <a href="https://oreil.ly/E7LP1">PomChecker</a> project.
PomChecker can be invoked in many ways: as a standalone CLI tool, as a Maven plug-in, or as a Gradle plug-in.
This flexibility makes it ideal for verifying a POM at your local environment or at a CI/CD pipeline.
Verifying a <em>pom.xml</em> file using the CLI can be done like so:</p>

<pre data-type="programlisting">$ pomchecker check-maven-central --pom-file=pom.xml</pre>

<p>If your project is built with Maven, you may invoke the PomChecker plug-in without having to configure it in the POM, like this:</p>

<pre data-type="programlisting">$ mvn org.kordamp.maven:pomchecker-maven-plugin:check-maven-central</pre>

<p>That command will resolve the latest version of <code>pomchecker-maven-plugin</code> and execute its <code>check-maven-central</code> goal right on the spot, using the current project as input.
With Gradle, you’d have to explicitly configure the <code>org.kordamp.gradle​.pom⁠checker</code> plug-in as Gradle does not offer an option for invoking an inlined plug-in as Maven does.</p>

<p>The last bit of configuration that must be applied to the build is the publication mechanism itself.
Do that by adding the following to your <em>pom.xml</em> if you’re building with Maven:</p>

<pre data-type="programlisting" data-code-language="xml"><code class="nt">&lt;distributionManagement&gt;</code>
  <code class="nt">&lt;repository&gt;</code>
    <code class="nt">&lt;id&gt;</code>ossrh<code class="nt">&lt;/id&gt;</code>
    <code class="nt">&lt;url&gt;</code>https://s01.oss.sonatype.org/service/local/staging/deploy/maven2/<code class="nt">&lt;/url&gt;</code>
  <code class="nt">&lt;/repository&gt;</code>
  <code class="nt">&lt;snapshotRepository&gt;</code>
    <code class="nt">&lt;id&gt;</code>ossrh<code class="nt">&lt;/id&gt;</code>
    <code class="nt">&lt;url&gt;</code>https://s01.oss.sonatype.org/content/repositories/snapshots<code class="nt">&lt;/url&gt;</code>
  <code class="nt">&lt;/snapshotRepository&gt;</code>
<code class="nt">&lt;/distributionManagement&gt;</code>

<code class="nt">&lt;build&gt;</code>
  <code class="nt">&lt;plugins&gt;</code>
    <code class="nt">&lt;plugin&gt;</code>
     <code class="nt">&lt;groupId&gt;</code>org.apache.maven.plugins<code class="nt">&lt;/groupId&gt;</code>
     <code class="nt">&lt;artifactId&gt;</code>maven-javadoc-plugin<code class="nt">&lt;/artifactId&gt;</code>
     <code class="nt">&lt;version&gt;</code>3.2.0<code class="nt">&lt;/version&gt;</code>
      cutions&gt;
       cution&gt;
       <code class="nt">&lt;id&gt;</code>attach-javadocs<code class="nt">&lt;/id&gt;</code>
       <code class="nt">&lt;goals&gt;</code>
         <code class="nt">&lt;goal&gt;</code>jar<code class="nt">&lt;/goal&gt;</code>
       <code class="nt">&lt;/goals&gt;</code>
       <code class="nt">&lt;configuration&gt;</code>
         <code class="nt">&lt;attach&gt;</code>true<code class="nt">&lt;/attach&gt;</code>
       <code class="nt">&lt;/configuration&gt;</code>
      <code class="nt">&lt;/execution&gt;</code>
     <code class="nt">&lt;/executions&gt;</code>
    <code class="nt">&lt;/plugin&gt;</code>
    <code class="nt">&lt;plugin&gt;</code>
      <code class="nt">&lt;groupId&gt;</code>org.apache.maven.plugins<code class="nt">&lt;/groupId&gt;</code>
      <code class="nt">&lt;artifactId&gt;</code>maven-source-plugin<code class="nt">&lt;/artifactId&gt;</code>
      <code class="nt">&lt;version&gt;</code>3.2.1<code class="nt">&lt;/version&gt;</code>
      <code class="nt">&lt;executions&gt;</code>
        <code class="nt">&lt;execution&gt;</code>
          <code class="nt">&lt;id&gt;</code>attach-sources<code class="nt">&lt;/id&gt;</code>
          <code class="nt">&lt;goals&gt;</code>
            <code class="nt">&lt;goal&gt;</code>jar<code class="nt">&lt;/goal&gt;</code>
          <code class="nt">&lt;/goals&gt;</code>
          <code class="nt">&lt;configuration&gt;</code>
            <code class="nt">&lt;attach&gt;</code>true<code class="nt">&lt;/attach&gt;</code>
          <code class="nt">&lt;/configuration&gt;</code>
        <code class="nt">&lt;/execution&gt;</code>
      <code class="nt">&lt;/executions&gt;</code>
    <code class="nt">&lt;/plugin&gt;</code>
    <code class="nt">&lt;plugin&gt;</code>
      <code class="nt">&lt;groupId&gt;</code>org.apache.maven.plugins<code class="nt">&lt;/groupId&gt;</code>
      <code class="nt">&lt;artifactId&gt;</code>maven-gpg-plugin<code class="nt">&lt;/artifactId&gt;</code>
      <code class="nt">&lt;version&gt;</code>1.6<code class="nt">&lt;/version&gt;</code>
      <code class="nt">&lt;executions&gt;</code>
        <code class="nt">&lt;execution&gt;</code>
          <code class="nt">&lt;goals&gt;</code>
            <code class="nt">&lt;goal&gt;</code>sign<code class="nt">&lt;/goal&gt;</code>
          <code class="nt">&lt;/goals&gt;</code>
          <code class="nt">&lt;phase&gt;</code>verify<code class="nt">&lt;/phase&gt;</code>
          <code class="nt">&lt;configuration&gt;</code>
            <code class="nt">&lt;gpgArguments&gt;</code>
              <code class="nt">&lt;arg&gt;</code>--pinentry-mode<code class="nt">&lt;/arg&gt;</code>
              <code class="nt">&lt;arg&gt;</code>loopback<code class="nt">&lt;/arg&gt;</code>
            <code class="nt">&lt;/gpgArguments&gt;</code>
          <code class="nt">&lt;/configuration&gt;</code>
        <code class="nt">&lt;/execution&gt;</code>
      <code class="nt">&lt;/executions&gt;</code>
    <code class="nt">&lt;/plugin&gt;</code>
    <code class="nt">&lt;plugin&gt;</code>
      <code class="nt">&lt;groupId&gt;</code>org.sonatype.plugins<code class="nt">&lt;/groupId&gt;</code>
      <code class="nt">&lt;artifactId&gt;</code>nexus-staging-maven-plugin<code class="nt">&lt;/artifactId&gt;</code>
      <code class="nt">&lt;version&gt;</code>1.6.8<code class="nt">&lt;/version&gt;</code>
      <code class="nt">&lt;extensions&gt;</code>true<code class="nt">&lt;/extensions&gt;</code>
      <code class="nt">&lt;configuration&gt;</code>
        <code class="nt">&lt;serverId&gt;</code>central<code class="nt">&lt;/serverId&gt;</code>
        <code class="nt">&lt;nexusUrl&gt;</code>https://s01.oss.sonatype.org<code class="nt">&lt;/nexusUrl&gt;</code>
        <code class="nt">&lt;autoReleaseAfterClose&gt;</code>true<code class="nt">&lt;/autoReleaseAfterClose&gt;</code>
      <code class="nt">&lt;/configuration&gt;</code>
    <code class="nt">&lt;/plugin&gt;</code>
  <code class="nt">&lt;/plugins&gt;</code>
<code class="nt">&lt;/build&gt;</code></pre>

<p>Note that this configuration generates <code>-sources</code> and <code>-javadoc</code> JARs, signs all attached artifacts with PGP, and uploads all artifacts to the given URL, which happens to be one of the URLs supported by Maven Central.
The <code>&lt;serverId&gt;</code> element identifies the credentials you must have in place in your <em>settings.xml</em> file (otherwise, the upload will fail), or you may define credentials as command-line arguments.</p>

<p>You may want to put the plug-in configuration inside a <code>&lt;profile&gt;</code> section, as the behavior provided by the configured plug-ins is needed only when a release is posted; there’s no reason to generate additional JARs during the execution of the main lifecycle phase sequence.
This way, your builds will execute only the minimum set of steps and thus be faster as a result.<a data-type="indexterm" data-startref="ch06-artpub" id="idm45310206006672"/><a data-type="indexterm" data-startref="ch06-artpub2" id="idm45310206005968"/></p>

<p>On the other hand, if you’re using Gradle for publication, you’d have to configure a plug-in that can publish to Sonatype Nexus Repository, the latest of such plug-ins being <a href="https://oreil.ly/MdCNh">io.github.gradle-nexus.publish-plugin</a>.
There’s more than one way to configure Gradle to do the job.
Idioms change more rapidly than what you must configure in Maven.
I recommend you consult the official Gradle guides to find out what needs to be done in this case.<a data-type="indexterm" data-startref="ch06-central" id="idm45310206004032"/><a data-type="indexterm" data-startref="ch06-central2" id="idm45310206003360"/><a data-type="indexterm" data-startref="ch06-central3" id="idm45310206002688"/><a data-type="indexterm" data-startref="ch06-central4" id="idm45310206002016"/></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Publishing to Sonatype Nexus Repository"><div class="sect2" id="idm45310206115776">
<h2>Publishing to Sonatype Nexus Repository</h2>

<p>You may recall that Maven Central is run<a data-type="indexterm" data-primary="package management" data-secondary="artifact publication" data-tertiary="Sonatype Nexus Repository" id="idm45310206000032"/><a data-type="indexterm" data-primary="Sonatype Nexus Repository" data-secondary="publishing to" id="idm45310205998720"/><a data-type="indexterm" data-primary="repositories" data-secondary="Sonatype Nexus Repository" data-tertiary="publishing to" id="idm45310205997760"/> using Sonatype Nexus Repository, so it should be no surprise that the configuration shown in the previous section applies here as well, such that you have to change only the publication URLs to match the Nexus repository.
There’s one caveat though: the strict verification rules applied by Maven Central often do not apply to a custom Nexus installation.
That is, Nexus has the option to configure the rules that govern artifact publication.
These rules may be relaxed for a Nexus instance running within your organization, for example, or they may be stricter in other areas.
It’s a good idea to consult the documentation available at your organization regarding artifact publication to their own Nexus instance.</p>

<p>One thing is clear: if you are publishing artifacts to your organization’s Nexus repository that eventually must be published to Maven Central, it’s a good idea to follow the Maven Central rules from the start—as long as these rules do not clash with your organization’s.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Publishing to JFrog Artifactory"><div class="sect2" id="idm45310205889360">
<h2>Publishing to JFrog Artifactory</h2>

<p><em>JFrog Artifactory</em> is another popular option<a data-type="indexterm" data-primary="package management" data-secondary="artifact publication" data-tertiary="JFrog Artifactory" id="idm45310205887872"/><a data-type="indexterm" data-primary="JFrog Artifactory" id="idm45310205886624"/> for artifact management.
It offers similar capabilities as Sonatype Nexus Repository while at the same time adding other features, including integration with other products that belong to the JFrog Platform, such as Xray and Pipelines.
One particular feature I’m quite fond of is that artifacts do not need to be signed at the source before publication.
Artifactory can perform the signing with your PGP keys or with a site-wide PGP key.
This relieves you of the burden of setting up keys on your local and CI environments as well as transferring fewer bytes during publication.
As before, the previous publication configuration we saw for Maven Central will work for Artifactory as well, by changing only the publication URLs to match the Artifactory instance.</p>

<p>As with Nexus, Artifactory allows you to sync artifacts to Maven Central, and you have to follow the rules for publishing to Maven Central once again.
Thus publishing well-formed POMs, sources, and Javadoc JARs from the get-go is a good idea.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Summary"><div class="sect1" id="idm45310205885056">
<h1>Summary</h1>

<p>We’ve covered plenty of concepts in this chapter, but the main takeaway should be that artifacts on their own are not enough to get the best results when building software or to get ahead of the competition. Artifacts usually have metadata that can be associated with them such as their build time, dependency versions, and environment. This metadata may be used to trace the origins of a particular artifact, help turn it into a reproducible artifact, or enable the generation of a software bill of materials (SBOM), which happens to be yet another metadata format. Moreover, observability, monitoring, and other concerns regarding the health and stability of the build pipeline can be greatly enhanced by the existence of this metadata.</p>

<p>Specific to dependencies, we saw the basics of dependency resolution with popular Java build tools such as Apache Maven and Gradle. Of course, more depth than was discussed in this chapter is warranted; these topics could certainly fill a book on their own. Be sure to be on the lookout for improvements in this area as provided by later versions of these build tools.</p>

<p>Finally, we covered how to publish Java artifacts to the popular Maven Central repository, given that it requires adhering to a particular set of guidelines that must be followed for successful publication. Maven Central is the canonical repository, but it’s not the only one. Sonatype offers Sonatype Nexus Repository, and JFrog offers JFrog Artifactory, also quite popular choices to manage artifacts at internal locations such as your own organization or company.</p>
</div></section>







</div></section></div></body></html>