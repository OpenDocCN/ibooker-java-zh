<html><head></head><body><section data-pdf-bookmark="Chapter 13. Streams to Iterables to Sequences" data-type="chapter" epub:type="chapter"><div class="chapter" id="streams-to-sequences">&#13;
<h1><span class="label">Chapter 13. </span>Streams to Iterables to Sequences</h1>&#13;
&#13;
<blockquote data-type="epigraph" epub:type="epigraph">&#13;
<p>Java and Kotlin both allow us to transform and reduce collections.&#13;
They have different design goals and implementations, though.&#13;
What does Kotlin use instead of Java streams, when should we convert, and how?</p>&#13;
</blockquote>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Java Streams" data-type="sect1"><div class="sect1" id="idm46393385020200">&#13;
<h1>Java Streams</h1>&#13;
&#13;
<p>Java 8<a data-primary="Java streams" data-type="indexterm" id="idm46393385018472"/><a data-primary="streams to iterables to sequences" data-secondary="Java streams" data-type="indexterm" id="idm46393385017736"/> introduced streams in 2014, making good use of the new lambdas.&#13;
Say we want to work out the average length of some strings, except that blank strings (those with only whitespace characters) should be treated as if they are empty.&#13;
Previously we might have written:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">static</code> <code class="kt">double</code> <code class="nf">averageNonBlankLength</code><code class="o">(</code><code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">strings</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="n">var</code> <code class="n">sum</code> <code class="o">=</code> <code class="mi">0</code><code class="o">;</code>&#13;
    <code class="k">for</code> <code class="o">(</code><code class="n">var</code> <code class="n">s</code> <code class="o">:</code> <code class="n">strings</code><code class="o">)</code> <code class="o">{</code>&#13;
        <code class="k">if</code> <code class="o">(!</code><code class="n">s</code><code class="o">.</code><code class="na">isBlank</code><code class="o">())</code>&#13;
            <code class="n">sum</code> <code class="o">+=</code> <code class="n">s</code><code class="o">.</code><code class="na">length</code><code class="o">();</code>&#13;
    <code class="o">}</code>&#13;
    <code class="k">return</code> <code class="n">sum</code> <code class="o">/</code> <code class="o">(</code><code class="kt">double</code><code class="o">)</code> <code class="n">strings</code><code class="o">.</code><code class="na">size</code><code class="o">();</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>With<a data-primary="filter" data-type="indexterm" id="idm46393385015048"/><a data-primary="map" data-type="indexterm" id="idm46393384971432"/><a data-primary="reduce" data-type="indexterm" id="idm46393384970792"/><a data-primary="transformations" data-secondary="of collections of data" data-secondary-sortas="collections of data" data-type="indexterm" id="idm46393384970120"/> Java streams, we can express this algorithm as <code>filter</code>, <code>map</code>, and <code>reduce</code> by first converting the <code>List</code> to a <code>Stream</code> and applying transformations:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">static</code> <code class="kt">double</code> <code class="nf">averageNonBlankLength</code><code class="o">(</code><code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">strings</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="k">return</code> <code class="n">strings</code>&#13;
        <code class="o">.</code><code class="na">stream</code><code class="o">()</code>&#13;
        <code class="o">.</code><code class="na">filter</code><code class="o">(</code><code class="n">s</code> <code class="o">-&gt;</code> <code class="o">!</code><code class="n">s</code><code class="o">.</code><code class="na">isBlank</code><code class="o">())</code>&#13;
        <code class="o">.</code><code class="na">mapToInt</code><code class="o">(</code><code class="nl">String:</code><code class="o">:</code><code class="n">length</code><code class="o">)</code>&#13;
        <code class="o">.</code><code class="na">sum</code><code class="o">()</code>&#13;
        <code class="o">/</code> <code class="o">(</code><code class="kt">double</code><code class="o">)</code> <code class="n">strings</code><code class="o">.</code><code class="na">size</code><code class="o">();</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>Rather than having to run the for-loop in our heads to see what this code is doing, we can see the steps of the algorithm declared line by line and rely on the runtime to implement those steps for us.</p>&#13;
&#13;
<p>If we are really in a hurry for those results, we can even write:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code> </code><code class="kd">static</code><code> </code><code class="kt">double</code><code> </code><code class="nf">averageNonBlankLength</code><code class="o">(</code><code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code><code> </code><code class="n">strings</code><code class="o">)</code><code> </code><code class="o">{</code><code>&#13;
</code><code>    </code><code class="k">return</code><code> </code><code class="n">strings</code><code>&#13;
</code><code>        </code><code class="o">.</code><code class="na">parallelStream</code><code class="o">(</code><code class="o">)</code><code> </code><a class="co" href="#callout_introduction_CO21-1" id="co_introduction_CO21-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code>        </code><code class="o">.</code><code class="na">filter</code><code class="o">(</code><code class="n">s</code><code> </code><code class="o">-</code><code class="o">&gt;</code><code> </code><code class="o">!</code><code class="n">s</code><code class="o">.</code><code class="na">isBlank</code><code class="o">(</code><code class="o">)</code><code class="o">)</code><code>&#13;
</code><code>        </code><code class="o">.</code><code class="na">mapToInt</code><code class="o">(</code><code class="nl">String:</code><code class="o">:</code><code class="n">length</code><code class="o">)</code><code>&#13;
</code><code>        </code><code class="o">.</code><code class="na">sum</code><code class="o">(</code><code class="o">)</code><code>&#13;
</code><code>        </code><code class="o">/</code><code> </code><code class="o">(</code><code class="kt">double</code><code class="o">)</code><code> </code><code class="n">strings</code><code class="o">.</code><code class="na">size</code><code class="o">(</code><code class="o">)</code><code class="o">;</code><code>&#13;
</code><code class="o">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_introduction_CO21-1" id="callout_introduction_CO21-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p><code>parallelStream</code> will divide the work across multiple threads.</p></dd>&#13;
</dl>&#13;
&#13;
<p>There are different types of fundamental operations going on here:&#13;
<code>map</code> changes the type of items, not their number;&#13;
<code>filter</code> keeps or rejects items depending on some property, but keeps their type the same; and&#13;
<code>sum</code> is a reduction of the collection to a single property.&#13;
Not shown in this example are the operations <code>skip(n)</code> and <code>limit(n)</code>.&#13;
These return streams without the first and last <code>n</code> elements, respectively.</p>&#13;
&#13;
<p>Java streams are lazy: <code>strings.filter(...).mapToInt(...)</code> does nothing but set up a pipeline for some terminal operation, <code>sum</code> in this case, to suck values through.&#13;
Laziness means that later pipeline stages can limit the amount of work earlier stages have to perform.&#13;
Consider translating a list of words until we see the word <code>STOP</code>.&#13;
The loop version might look like this:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">static</code> <code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="nf">translatedWordsUntilSTOP</code><code class="o">(</code><code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">strings</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="n">var</code> <code class="n">result</code> <code class="o">=</code> <code class="k">new</code> <code class="n">ArrayList</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;();</code>&#13;
    <code class="k">for</code> <code class="o">(</code><code class="n">var</code> <code class="nl">word:</code> <code class="n">strings</code><code class="o">)</code> <code class="o">{</code>&#13;
        <code class="n">String</code> <code class="n">translation</code> <code class="o">=</code> <code class="n">translate</code><code class="o">(</code><code class="n">word</code><code class="o">);</code>&#13;
        <code class="k">if</code> <code class="o">(</code><code class="n">translation</code><code class="o">.</code><code class="na">equalsIgnoreCase</code><code class="o">(</code><code class="s">"STOP"</code><code class="o">))</code>&#13;
            <code class="k">break</code><code class="o">;</code>&#13;
        <code class="k">else</code>&#13;
            <code class="n">result</code><code class="o">.</code><code class="na">add</code><code class="o">(</code><code class="n">translation</code><code class="o">);</code>&#13;
    <code class="o">}</code>&#13;
    <code class="k">return</code> <code class="n">result</code><code class="o">;</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>By breaking out of the loop, we don’t translate all the words, only the minimum we need.&#13;
Java 9 introduced <code>dropWhile</code> and <code>takeWhile</code>, which allow us to express this as:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">static</code> <code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="nf">translatedWordsUntilSTOP</code><code class="o">(</code><code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">strings</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="k">return</code> <code class="n">strings</code>&#13;
        <code class="o">.</code><code class="na">stream</code><code class="o">()</code>&#13;
        <code class="o">.</code><code class="na">map</code><code class="o">(</code><code class="n">word</code> <code class="o">-&gt;</code> <code class="n">translate</code><code class="o">(</code><code class="n">word</code><code class="o">))</code>&#13;
        <code class="o">.</code><code class="na">takeWhile</code><code class="o">(</code><code class="n">translation</code> <code class="o">-&gt;</code> <code class="o">!</code><code class="n">translation</code><code class="o">.</code><code class="na">equalsIgnoreCase</code><code class="o">(</code><code class="s">"STOP"</code><code class="o">))</code>&#13;
        <code class="o">.</code><code class="na">collect</code><code class="o">(</code><code class="n">toList</code><code class="o">());</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>This works because the <code>collect</code> causes values to be sucked through the pipeline, and <code>takeWhile</code> stops sucking from its predecessor when its predicate returns <code>false</code>.</p>&#13;
&#13;
<p>On the subject of sucking, streams can be surprisingly slow for small collections.&#13;
They are great for large-scale data crunching where we want to throw all available cores at a problem—not so great for summing the cost of five items in a shopping cart.&#13;
The problem is that Java streams were designed to provide general collection transformations, lazy evaluation, <em>and</em> parallel processing, and these have different demands.&#13;
Kotlin doesn’t try to implement parallel operations, leaving two abstractions; iterables are good for transforming and reducing collections, whereas sequences give lazy evaluation.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Kotlin Iterables" data-type="sect1"><div class="sect1" id="idm46393385019576">&#13;
<h1>Kotlin Iterables</h1>&#13;
&#13;
<p>Instead<a data-primary="streams to iterables to sequences" data-secondary="Kotlin iterables" data-type="indexterm" id="idm46393384641656"/><a data-primary="Kotlin" data-secondary="Kotlin iterables" data-type="indexterm" id="idm46393384640680"/> of creating a new interface to define collections operations, Kotlin provides extension functions on <code>Iterable</code>.&#13;
The simplest Kotlin expression of the same algorithm is:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">averageNonBlankLength</code><code class="p">(</code><code class="n">strings</code><code class="p">:</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">String</code><code class="p">&gt;):</code> <code class="n">Double</code> <code class="p">=</code>&#13;
    <code class="p">(</code><code class="n">strings</code>&#13;
        <code class="p">.</code><code class="n">filter</code> <code class="p">{</code> <code class="n">it</code><code class="p">.</code><code class="n">isNotBlank</code><code class="p">()</code> <code class="p">}</code>&#13;
        <code class="p">.</code><code class="n">map</code><code class="p">(</code><code class="n">String</code><code class="o">::</code><code class="n">length</code><code class="p">)</code>&#13;
        <code class="p">.</code><code class="n">sum</code><code class="p">()</code>&#13;
        <code class="p">/</code> <code class="n">strings</code><code class="p">.</code><code class="n">size</code><code class="p">.</code><code class="n">toDouble</code><code class="p">())</code></pre>&#13;
&#13;
<p>Here <code>filter</code> is an extension function on <code>Iterable</code>.&#13;
Unlike the <code>Stream.filter</code>, though, which returns another <code>Stream</code>, the Kotlin <code>filter</code> returns a <code>List</code> (which is <code>Iterable</code>, so we can continue the chain);&#13;
<code>map</code> returns a <code>List</code>, too, so this single expression creates two additional lists in memory.</p>&#13;
&#13;
<p>The first is a <code>List</code> of the nonblank strings, the second is a <code>List</code> of the lengths of those strings.&#13;
When (if) we care about performance, this can be a problem, because both of those lists will take time to populate and memory to support.</p>&#13;
&#13;
<p>The <code>List</code> of lengths is a particular issue, because the integers will have been <em>boxed</em> (wrapped in an <code>Integer</code> object) to fit in the list.&#13;
The Java streams example used <code>mapToInt(String::length)</code> to avoid this problem.&#13;
<code>IntStream</code> (and <code>LongStream</code> and <code>DoubleStream</code>, but curiously not <code>BooleanStream</code> or <code>CharStream</code>) were created to prevent streams having to box and unbox, but you have to remember to use them, and <code>IntStream</code> is not a <code>Stream&lt;Integer&gt;</code>.</p>&#13;
&#13;
<p>Should we care about performance?&#13;
Mostly no—this Kotlin will be fast <em>unless</em> we have large collections, the opposite of streams, which are only fast <em>if</em> we have large collections.&#13;
When we do have large collections, we can switch over to sequences.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Kotlin Sequences" data-type="sect1"><div class="sect1" id="idm46393384487352">&#13;
<h1>Kotlin Sequences</h1>&#13;
&#13;
<p>The<a data-primary="streams to iterables to sequences" data-secondary="Kotlin sequences" data-type="indexterm" id="idm46393384485560"/><a data-primary="Kotlin" data-secondary="Kotlin sequences" data-type="indexterm" id="idm46393384484584"/> Kotlin <code>Sequence</code> abstraction offers the same lazy evaluation as Java streams.&#13;
The <code>map</code> operation on a <code>Sequence</code> returns another <code>Sequence</code>: the operations in the chain are only performed when some terminal operation requires their evaluation.&#13;
If we have a <code>Collection</code>, <code>Iterable</code>, or even an <code>Iterator</code>, there are <code>asSequence()</code> extension functions to convert.&#13;
After that the API is suspiciously familiar:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">averageNonBlankLength</code><code class="p">(</code><code class="n">strings</code><code class="p">:</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">String</code><code class="p">&gt;):</code> <code class="n">Double</code> <code class="p">=</code>&#13;
    <code class="p">(</code><code class="n">strings</code>&#13;
        <code class="p">.</code><code class="n">asSequence</code><code class="p">()</code>&#13;
        <code class="p">.</code><code class="n">filter</code> <code class="p">{</code> <code class="n">it</code><code class="p">.</code><code class="n">isNotBlank</code><code class="p">()</code> <code class="p">}</code>&#13;
        <code class="p">.</code><code class="n">map</code><code class="p">(</code><code class="n">String</code><code class="o">::</code><code class="n">length</code><code class="p">)</code>&#13;
        <code class="p">.</code><code class="n">sum</code><code class="p">()</code>&#13;
        <code class="p">/</code> <code class="n">strings</code><code class="p">.</code><code class="n">size</code><code class="p">.</code><code class="n">toDouble</code><code class="p">())</code></pre>&#13;
&#13;
<p>The familiarity is suspicious because all those operations (<code>filter</code>, <code>map</code>, <code>sum</code>) are now extensions not on <code>Iterable</code> but <code>Sequence</code>, and they don’t return a <code>List</code>; they return another <code>Sequence</code>.&#13;
Except, that is, for <code>sum</code>, which can’t even pretend to do its job without reading all the data, so it is a terminal operation.&#13;
This code reads the same as the iterable version, but each of the functions is actually different.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46393384395912">&#13;
<h5>Swapping Iterables and Sequences</h5>&#13;
<p><code>Iterable&lt;T&gt;</code> and <code>Sequence&lt;T&gt;</code> have the same single method signature: <code>public &#13;
<span class="keep-together">operator</span> fun iterator(): Iterator&lt;T&gt;</code>.&#13;
They both also have extension functions for <code>map</code>, <code>filter</code>, <code>reduce</code>, and so on, which take the same parameters.&#13;
But they are not the same type, because their semantics are very different.&#13;
The operations on <code>Iterable</code> are eager, whereas those on <code>Sequence</code> are lazy, so we cannot swap one for the other with impunity (as we will see later in this chapter).</p>&#13;
&#13;
<p>Nevertheless, the fact that they have such similar APIs means that in situations like this, we can often change very little (source) code when we do want to swap between them.</p>&#13;
</div></aside>&#13;
&#13;
<p>The sequence version of <code>averageNonBlankLength</code> won’t pay the price of creating the intermediate lists to hold the results of each stage, but for small numbers of items, the cost of setting up and executing the pipeline may be higher than creating the lists.&#13;
In this case the <code>Int</code> lengths will still be boxed as <code>Integer</code>, albeit one at a time rather than creating a whole list of them.&#13;
In many cases, the API designers will have provided a clever solution to remove boxing.&#13;
In this case, it is <code>sumBy</code>:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">averageNonBlankLength</code><code class="p">(</code><code class="n">strings</code><code class="p">:</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">String</code><code class="p">&gt;):</code> <code class="n">Double</code> <code class="p">=</code>&#13;
    <code class="p">(</code><code class="n">strings</code>&#13;
        <code class="p">.</code><code class="n">asSequence</code><code class="p">()</code>&#13;
        <code class="p">.</code><code class="n">filter</code> <code class="p">{</code> <code class="n">it</code><code class="p">.</code><code class="n">isNotBlank</code><code class="p">()</code> <code class="p">}</code>&#13;
        <code class="p">.</code><code class="n">sumBy</code><code class="p">(</code><code class="n">String</code><code class="o">::</code><code class="n">length</code><code class="p">)</code>&#13;
        <code class="p">/</code> <code class="n">strings</code><code class="p">.</code><code class="n">size</code><code class="p">.</code><code class="n">toDouble</code><code class="p">())</code></pre>&#13;
&#13;
<p><code>sumBy</code> (also available as an extension on <code>Iterable</code>) avoids boxing by taking a function that returns an <code>Int</code>.&#13;
It can do this because it is a terminal operation, so it doesn’t return another sequence or collection.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Multiple Iterations" data-type="sect1"><div class="sect1" id="sequences-multiple-operations">&#13;
<h1>Multiple Iterations</h1>&#13;
&#13;
<p>If<a data-primary="streams to iterables to sequences" data-secondary="multiple iterations" data-type="indexterm" id="SISmult13"/> you use Java streams, you have probably tried to do something like this:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">static</code> <code class="kt">double</code> <code class="nf">averageNonBlankLength</code><code class="o">(</code><code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">strings</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="k">return</code> <code class="nf">averageNonBlankLength</code><code class="o">(</code><code class="n">strings</code><code class="o">.</code><code class="na">stream</code><code class="o">());</code>&#13;
<code class="o">}</code>&#13;
&#13;
<code class="kd">public</code> <code class="kd">static</code> <code class="kt">double</code> <code class="nf">averageNonBlankLength</code><code class="o">(</code><code class="n">Stream</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">strings</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="k">return</code> <code class="n">strings</code>&#13;
        <code class="o">.</code><code class="na">filter</code><code class="o">(</code><code class="n">s</code> <code class="o">-&gt;</code> <code class="o">!</code><code class="n">s</code><code class="o">.</code><code class="na">isBlank</code><code class="o">())</code>&#13;
        <code class="o">.</code><code class="na">mapToInt</code><code class="o">(</code><code class="nl">String:</code><code class="o">:</code><code class="n">length</code><code class="o">)</code>&#13;
        <code class="o">.</code><code class="na">sum</code><code class="o">()</code>&#13;
        <code class="o">/</code> <code class="o">(</code><code class="kt">double</code><code class="o">)</code> <code class="n">strings</code><code class="o">.</code><code class="na">count</code><code class="o">();</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>This looks very plausible: we’ve just extracted a function, taking a <code>Stream</code> parameter rather than the <code>List</code>.&#13;
There is no <code>size</code> property on <code>Stream</code>, but <code>count()</code> gives the same result, so we use that.&#13;
When we run it, though, we get <code>java.lang.IllegalState​Excep⁠tion: stream has already been operated upon or closed</code>.</p>&#13;
&#13;
<p>The problem is that a <code>Stream</code> has hidden state.&#13;
Once we have consumed all its items (and <code>sum</code> does just that), we can’t go around again to <code>count</code> them.&#13;
Even though <code>sum</code> is actually a method on <code>IntStream</code>, each stream in the pipeline consumes its predecessor, so the input <code>strings</code> is consumed by the <code>sum</code>.</p>&#13;
&#13;
<p>In Java this is enough to put you off extracting <code>Stream</code> operations into functions.&#13;
Let’s try the same thing with a Kotlin <code>Sequence</code>:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">averageNonBlankLength</code><code class="p">(</code><code class="n">strings</code><code class="p">:</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">String</code><code class="p">&gt;):</code> <code class="n">Double</code> <code class="p">=</code>&#13;
    <code class="n">averageNonBlankLength</code><code class="p">(</code><code class="n">strings</code><code class="p">.</code><code class="n">asSequence</code><code class="p">())</code>&#13;
&#13;
<code class="k">fun</code> <code class="nf">averageNonBlankLength</code><code class="p">(</code><code class="n">strings</code><code class="p">:</code> <code class="n">Sequence</code><code class="p">&lt;</code><code class="n">String</code><code class="p">&gt;):</code> <code class="n">Double</code> <code class="p">=</code>&#13;
    <code class="p">(</code><code class="n">strings</code>&#13;
        <code class="p">.</code><code class="n">filter</code> <code class="p">{</code> <code class="n">it</code><code class="p">.</code><code class="n">isNotBlank</code><code class="p">()</code> <code class="p">}</code>&#13;
        <code class="p">.</code><code class="n">sumBy</code><code class="p">(</code><code class="n">String</code><code class="o">::</code><code class="n">length</code><code class="p">)</code>&#13;
        <code class="p">/</code> <code class="n">strings</code><code class="p">.</code><code class="n">count</code><code class="p">().</code><code class="n">toDouble</code><code class="p">())</code></pre>&#13;
&#13;
<p>In Kotlin, we can call the <code>Sequence</code> version from the <code>List</code> version and all is fine…for now.</p>&#13;
&#13;
<p>We are storing up trouble though.&#13;
To see why, let’s step out another layer and add a function that takes an <code>Iterator</code>:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">averageNonBlankLength</code><code class="p">(</code><code class="n">strings</code><code class="p">:</code> <code class="n">Iterator</code><code class="p">&lt;</code><code class="n">String</code><code class="p">&gt;):</code> <code class="n">Double</code> <code class="p">=</code>&#13;
    <code class="n">averageNonBlankLength</code><code class="p">(</code><code class="n">strings</code><code class="p">.</code><code class="n">asSequence</code><code class="p">())</code></pre>&#13;
&#13;
<p>If we call this function, we now get <code>java.lang.IllegalStateException: This sequence can be consumed only once.</code> (Comparing this to the streams error, we see that the Kotlin developers seem to be more grammatically pedantic than the JVM developers.)&#13;
Now the <code>Sequence</code> is acting like a Java <code>Stream</code>, but previously it wasn’t.&#13;
What changed?</p>&#13;
&#13;
<p>It turns out that some sequences can safely be iterated over multiple times: those backed by a collection that is held in memory, for example.&#13;
Others cannot.&#13;
Now that our <code>Sequence</code> is provided by an <code>Iterator</code>, the first run through (to calculate the <code>sum</code>) continued until <code>Iterator.hasNext()</code> returned <code>false</code>.&#13;
If we were to try to run through the <code>Sequence</code> again (to <code>count</code>), the <code>Iterator</code> state would not have changed, so <code>hasNext()</code> would immediately return <code>false</code>.&#13;
This would lead <code>strings.count()</code> to return <code>0</code>, resulting in <code>averageNonBlankLength</code> always returning <code>Infinity</code> (if there was any input).</p>&#13;
&#13;
<p>This sort of behavior is, erm, <em>undesirable</em>, so sequences wrapping iterators are deliberately hobbled with <code>Sequence.constrainOnce()</code> to prevent this.&#13;
It is <code>constrainOnce()</code> that throws the <code>IllegalStateException</code> if we try to consume twice.</p>&#13;
&#13;
<p>The other canonical example of a <code>Sequence</code> that cannot be consumed more than once is one backed by reading from an external resource, such as a file or network socket.&#13;
In such cases we can’t in general just go back and replay input to iterate again.</p>&#13;
&#13;
<p>Unfortunately, the difference between the two types of <code>Sequence</code> is not reflected in the type system, so we will only discover any incompatibility between our algorithm and our input at runtime.&#13;
As we will see in <a data-type="xref" href="ch20.html#performing-io-to-passing-data">Chapter 20</a>, this is exacerbated by the common technique of using <code>sequenceOf(...)</code> or <code>List.asSequence()</code> as our test data; these sequences <em>do</em> support multiple iterations and won’t warn us of the problem.</p>&#13;
&#13;
<p>In practice, this problem is usually only an irritation, causing some wasted time and reworking.&#13;
It will tend not to happen if you are converting from streams code, because that will not have had the issue in the first place, but rather when applying a <code>Sequence</code> from scratch or converting from an <code>Iterable</code>.</p>&#13;
&#13;
<p>In this particular case, we can make things work by keeping count of items as they whiz past in the first iteration, rather than counting again at the end:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">averageNonBlankLength</code><code class="p">(</code><code class="n">strings</code><code class="p">:</code> <code class="n">Sequence</code><code class="p">&lt;</code><code class="n">String</code><code class="p">&gt;):</code> <code class="n">Double</code> <code class="p">{</code>&#13;
    <code class="k">var</code> <code class="py">count</code> <code class="p">=</code> <code class="m">0</code>&#13;
    <code class="k">return</code> <code class="p">(</code><code class="n">strings</code>&#13;
        <code class="p">.</code><code class="n">onEach</code> <code class="p">{</code> <code class="n">count</code><code class="p">++</code> <code class="p">}</code>&#13;
        <code class="p">.</code><code class="n">filter</code> <code class="p">{</code> <code class="n">it</code><code class="p">.</code><code class="n">isNotBlank</code><code class="p">()</code> <code class="p">}</code>&#13;
        <code class="p">.</code><code class="n">sumBy</code><code class="p">(</code><code class="n">String</code><code class="o">::</code><code class="n">length</code><code class="p">)</code>&#13;
        <code class="p">/</code> <code class="n">count</code><code class="p">.</code><code class="n">toDouble</code><code class="p">())</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This is the first problem that we have solved in this book with a mutable local variable!&#13;
We can hide our shame inside a more generally useful utility class: &#13;
<span class="keep-together"><code>CountingSequence</code></span>:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">CountingSequence</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;(</code>&#13;
    <code class="k">private</code> <code class="k">val</code> <code class="py">wrapped</code><code class="p">:</code> <code class="n">Sequence</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code>&#13;
<code class="p">)</code> <code class="p">:</code> <code class="n">Sequence</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code> <code class="p">{</code>&#13;
    <code class="k">var</code> <code class="py">count</code> <code class="p">=</code> <code class="m">0</code>&#13;
    <code class="k">override</code> <code class="k">fun</code> <code class="nf">iterator</code><code class="p">()</code> <code class="p">=</code>&#13;
        <code class="n">wrapped</code><code class="p">.</code><code class="n">onEach</code> <code class="p">{</code> <code class="n">count</code><code class="p">++</code> <code class="p">}.</code><code class="n">iterator</code><code class="p">()</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="k">fun</code> <code class="nf">averageNonBlankLength</code><code class="p">(</code><code class="n">strings</code><code class="p">:</code> <code class="n">Sequence</code><code class="p">&lt;</code><code class="n">String</code><code class="p">&gt;):</code> <code class="n">Double</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="py">countingSequence</code> <code class="p">=</code> <code class="n">CountingSequence</code><code class="p">(</code><code class="n">strings</code><code class="p">)</code>&#13;
    <code class="k">return</code> <code class="p">(</code><code class="n">countingSequence</code>&#13;
            <code class="p">.</code><code class="n">filter</code> <code class="p">{</code> <code class="n">it</code><code class="p">.</code><code class="n">isNotBlank</code><code class="p">()</code> <code class="p">}</code>&#13;
            <code class="p">.</code><code class="n">sumBy</code><code class="p">(</code><code class="n">String</code><code class="o">::</code><code class="n">length</code><code class="p">)</code>&#13;
            <code class="p">/</code> <code class="n">countingSequence</code><code class="p">.</code><code class="n">count</code><code class="p">.</code><code class="n">toDouble</code><code class="p">())</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This a recurrent theme in Kotlin algorithms: we might occasionally need to stoop to mutation to implement something in a sensible or efficient way, but we can usually hide the mutation in a way that both reduces its visibility and makes for a useful abstraction.&#13;
In this case, this is aided by the fact that <code>Sequence</code> is an interface with just one method, making it very easy to implement it ourselves.&#13;
Java’s <code>Stream</code> is also an interface, but with 42 methods and no <code>AbstractStream</code> class to provide default &#13;
<span class="keep-together">implementations</span>!</p>&#13;
&#13;
<p>Before we leave this section, you may have been silently fuming ever since we introduced <code>Stream.count()</code>.&#13;
If not, can you see what the issue is?</p>&#13;
&#13;
<p>One of the points of <code>Stream</code> and <code>Sequence</code> is that they allow us to work on arbitrarily large datasets, and finding the size of these datasets by counting them individually is not very efficient, even if it can sometimes be done.&#13;
In general, even if we can, in practice, iterate over a <code>Sequence</code> more than once, it is likely to be inefficient in the use cases that caused us to use <code>Sequence</code> in the first place.</p>&#13;
<div data-type="tip"><h1>Only Iterate Over a Sequence Once</h1>&#13;
<p>As a rule of thumb, if they operate on a <code>Sequence</code>, our algorithms should complete in a single pass.&#13;
This way, they will be able to work with sequences that do not support multiple iteration and can be efficient with large numbers of items.</p>&#13;
&#13;
<p>We can use <code>Sequence.constrainOnce()</code> in our tests to make sure that we don’t accidentally go around again.<a data-primary="" data-startref="SISmult13" data-type="indexterm" id="idm46393383874536"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Choosing Between Streams, Iterables, and Sequences" data-type="sect1"><div class="sect1" id="choosing-sequences">&#13;
<h1>Choosing Between Streams, Iterables, and Sequences</h1>&#13;
&#13;
<p>If<a data-primary="streams to iterables to sequences" data-secondary="choosing between" data-type="indexterm" id="idm46393383872136"/> we already have code using Java streams, it will continue to run just fine on the JVM, even when converted to Kotlin.&#13;
It will even look a little nicer, since Kotlin can move the lambda outside the method and allow the use of the implicit <code>it</code> lambda parameter:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">averageNonBlankLength</code><code class="p">(</code><code class="n">strings</code><code class="p">:</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">String</code><code class="p">&gt;):</code> <code class="n">Double</code> <code class="p">=</code>&#13;
    <code class="p">(</code><code class="n">strings</code>&#13;
        <code class="p">.</code><code class="n">stream</code><code class="p">()</code>&#13;
        <code class="p">.</code><code class="n">filter</code> <code class="p">{</code> <code class="n">it</code><code class="p">.</code><code class="n">isNotBlank</code><code class="p">()</code> <code class="p">}</code>&#13;
        <code class="p">.</code><code class="n">mapToInt</code><code class="p">(</code><code class="n">String</code><code class="o">::</code><code class="n">length</code><code class="p">)</code>&#13;
        <code class="p">.</code><code class="n">sum</code><code class="p">()</code>&#13;
        <code class="p">/</code> <code class="n">strings</code><code class="p">.</code><code class="n">size</code><code class="p">.</code><code class="n">toDouble</code><code class="p">())</code></pre>&#13;
&#13;
<p>In addition, we can use extension functions to <em>add</em> operations to streams, in the same way as Kotlin defines its <code>Sequence</code> operations.</p>&#13;
&#13;
<p>If our code is working on large collections, and in particular using <code>parallelStream()</code>, then the default should be to leave the streams alone, because in these cases they are well optimized by the JVM.&#13;
The Kotlin standard library even provides extensions <code>Stream&lt;T&gt;.asSequence()</code> and <code>Sequence&lt;T&gt;.asStream()</code> that allow us to swap horses mid, erm, <code>Stream</code>.</p>&#13;
&#13;
<p>If we decide to convert to a Kotlin abstraction, then we can choose <code>Iterable</code> or <code>Sequence</code>, depending on whether the streams code takes advantage of lazy evaluation.</p>&#13;
&#13;
<p>Lazy evaluation is required if:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>We need to produce results before we have finished reading the input.</p>&#13;
</li>&#13;
<li>&#13;
<p>We need to process more data than we can fit into memory (including intermediate results).</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Lazy evaluation may give better performance for:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Large collections with many pipeline stages, where building intermediate collections may be slow.</p>&#13;
</li>&#13;
<li>&#13;
<p>Pipelines where early stages could be skipped, depending on information only available in later stages.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>We can illustrate the last point with the same translation example we saw with streams:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">static</code> <code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="nf">translatedWordsUntilSTOP</code><code class="o">(</code><code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">strings</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="k">return</code> <code class="n">strings</code>&#13;
        <code class="o">.</code><code class="na">stream</code><code class="o">()</code>&#13;
        <code class="o">.</code><code class="na">map</code><code class="o">(</code><code class="n">word</code> <code class="o">-&gt;</code> <code class="n">translate</code><code class="o">(</code><code class="n">word</code><code class="o">))</code>&#13;
        <code class="o">.</code><code class="na">takeWhile</code><code class="o">(</code><code class="n">translation</code> <code class="o">-&gt;</code> <code class="o">!</code><code class="n">translation</code><code class="o">.</code><code class="na">equalsIgnoreCase</code><code class="o">(</code><code class="s">"STOP"</code><code class="o">))</code>&#13;
        <code class="o">.</code><code class="na">collect</code><code class="o">(</code><code class="n">toList</code><code class="o">());</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>We can convert this to the equivalent iterable expression:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">translatedWordsUntilSTOP</code><code class="p">(</code><code class="n">strings</code><code class="p">:</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">String</code><code class="p">&gt;):</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">String</code><code class="p">&gt;</code> <code class="p">=</code>&#13;
    <code class="n">strings</code>&#13;
        <code class="p">.</code><code class="n">map</code> <code class="p">{</code> <code class="n">translate</code><code class="p">(</code><code class="n">it</code><code class="p">)</code> <code class="p">}</code>&#13;
        <code class="p">.</code><code class="n">takeWhile</code> <code class="p">{</code> <code class="p">!</code><code class="n">it</code><code class="p">.</code><code class="n">equals</code><code class="p">(</code><code class="s">"STOP"</code><code class="p">,</code> <code class="n">ignoreCase</code> <code class="p">=</code> <code class="k">true</code><code class="p">)</code> <code class="p">}</code></pre>&#13;
&#13;
<p>But then <em>all</em> words in the input <code>List</code> will be translated to another <code>List</code> by <code>map</code>, even those after <code>STOP</code>.&#13;
Using a <code>Sequence</code> avoids translating words we aren’t going to return:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">translatedWordsUntilSTOP</code><code class="p">(</code><code class="n">strings</code><code class="p">:</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">String</code><code class="p">&gt;):</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">String</code><code class="p">&gt;</code> <code class="p">=</code>&#13;
    <code class="n">strings</code>&#13;
        <code class="p">.</code><code class="n">asSequence</code><code class="p">()</code>&#13;
        <code class="p">.</code><code class="n">map</code> <code class="p">{</code> <code class="n">translate</code><code class="p">(</code><code class="n">it</code><code class="p">)</code> <code class="p">}</code>&#13;
        <code class="p">.</code><code class="n">takeWhile</code> <code class="p">{</code> <code class="p">!</code><code class="n">it</code><code class="p">.</code><code class="n">equals</code><code class="p">(</code><code class="s">"STOP"</code><code class="p">,</code> <code class="n">ignoreCase</code> <code class="p">=</code> <code class="k">true</code><code class="p">)</code> <code class="p">}</code>&#13;
        <code class="p">.</code><code class="n">toList</code><code class="p">()</code></pre>&#13;
&#13;
<p>If we don’t need lazy evaluation, and for smaller collections, or when writing from scratch in Kotlin, <code>Iterable</code> pipelines are simple, generally quick, and easy to reason with.&#13;
Your authors will often convert streams to iterables to take advantage of the far richer API that Kotlin provides.&#13;
If iterables prove too slow (or sometimes too greedy for memory) with large collections, then we can convert to sequences.&#13;
If that still isn’t enough, we can move (hopefully not back) to streams, and maybe even take advantage of parallelism.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Algebraic Transformation" data-type="sect1"><div class="sect1" id="idm46393383873208">&#13;
<h1>Algebraic Transformation</h1>&#13;
&#13;
<p>Laziness and parallelism<a data-primary="transformations" data-secondary="algebraic" data-type="indexterm" id="tranal13"/><a data-primary="laziness" data-type="indexterm" id="idm46393383548568"/><a data-primary="parallelism" data-type="indexterm" id="idm46393383547896"/><a data-primary="streams to iterables to sequences" data-secondary="algebraic transformation" data-type="indexterm" id="SISalgebra13"/><a data-primary="algebraic transformation" data-type="indexterm" id="algtrans13"/> will of course affect <em>when</em> the stages of our pipeline are invoked.&#13;
If any of our algorithm depends on the order of operations, it may be broken if we swap between streams, iterables, and sequences.&#13;
What we want is code with a predictable <em>algebra</em>: a set of rules for manipulating operations while preserving behavior.</p>&#13;
&#13;
<p>We<a data-primary="actions" data-secondary="algebraic transformation" data-type="indexterm" id="idm46393383543416"/> saw in <a data-type="xref" href="ch07.html#actions-to-calculations">Chapter 7</a> that we can categorize functions (actually any code, including lambdas) according to whether they depend on when they are run.&#13;
Calculations<a data-primary="calculations" data-secondary="refactoring" data-type="indexterm" id="idm46393383541352"/> (<a data-type="xref" href="ch07.html#calculations">“Calculations”</a>) are safe to refactor because we can move their invocations around without affecting their result or the result of any other code.&#13;
In contrast, moving an action (<a data-type="xref" href="ch07.html#actions">“Actions”</a>) from an iterable to a sequence, or vice versa, may change when it is invoked, and hence the outcome of our program.&#13;
The more of our code that is expressed as calculations, the more we can treat its representation as something that we can transform according to rules.</p>&#13;
&#13;
<p>We can also apply another algebra—arithmetic—to simplify our definition of <code>averageNonBlankLength</code>.&#13;
This is currently:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">CountingSequence</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;(</code>&#13;
    <code class="k">private</code> <code class="k">val</code> <code class="py">wrapped</code><code class="p">:</code> <code class="n">Sequence</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code>&#13;
<code class="p">)</code> <code class="p">:</code> <code class="n">Sequence</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code> <code class="p">{</code>&#13;
    <code class="k">var</code> <code class="py">count</code> <code class="p">=</code> <code class="m">0</code>&#13;
    <code class="k">override</code> <code class="k">fun</code> <code class="nf">iterator</code><code class="p">()</code> <code class="p">=</code>&#13;
        <code class="n">wrapped</code><code class="p">.</code><code class="n">onEach</code> <code class="p">{</code> <code class="n">count</code><code class="p">++</code> <code class="p">}.</code><code class="n">iterator</code><code class="p">()</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="k">fun</code> <code class="nf">averageNonBlankLength</code><code class="p">(</code><code class="n">strings</code><code class="p">:</code> <code class="n">Sequence</code><code class="p">&lt;</code><code class="n">String</code><code class="p">&gt;):</code> <code class="n">Double</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="py">countingSequence</code> <code class="p">=</code> <code class="n">CountingSequence</code><code class="p">(</code><code class="n">strings</code><code class="p">)</code>&#13;
    <code class="k">return</code> <code class="p">(</code><code class="n">countingSequence</code>&#13;
            <code class="p">.</code><code class="n">filter</code> <code class="p">{</code> <code class="n">it</code><code class="p">.</code><code class="n">isNotBlank</code><code class="p">()</code> <code class="p">}</code>&#13;
            <code class="p">.</code><code class="n">sumBy</code><code class="p">(</code><code class="n">String</code><code class="o">::</code><code class="n">length</code><code class="p">)</code>&#13;
            <code class="p">/</code> <code class="n">countingSequence</code><code class="p">.</code><code class="n">count</code><code class="p">.</code><code class="n">toDouble</code><code class="p">())</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>All that complication arises because we don’t want the simple average, but the average where blank strings are counted as if empty.&#13;
Filtering the blanks from the sum, but not the count, is one way to do this.&#13;
Mathematically, though, it is equivalent to the following:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">averageNonBlankLength</code><code class="p">(</code><code class="n">strings</code><code class="p">:</code> <code class="n">Sequence</code><code class="p">&lt;</code><code class="n">String</code><code class="p">&gt;):</code> <code class="n">Double</code> <code class="p">=</code>&#13;
    <code class="n">strings</code>&#13;
        <code class="p">.</code><code class="n">map</code> <code class="p">{</code> <code class="k">if</code> <code class="p">(</code><code class="n">it</code><code class="p">.</code><code class="n">isBlank</code><code class="p">())</code> <code class="m">0</code> <code class="k">else</code> <code class="n">it</code><code class="p">.</code><code class="n">length</code> <code class="p">}</code>&#13;
        <code class="p">.</code><code class="n">average</code><code class="p">()</code></pre>&#13;
&#13;
<p>This is a mathematical rearrangement, and, as with our code refactoring, works only if all the operations are calculations.&#13;
It is also dangerously seductive, because we have slipped back to boxing our integers to pass them to <code>average</code>.</p>&#13;
&#13;
<p>What we need is an <code>averageBy</code> analog of <code>sumBy</code>.&#13;
We can do that by mating the Kotlin runtime definitions of <code>Sequence.sumBy</code> with <code>Sequence.average</code> to give:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">inline</code> <code class="k">fun</code> <code class="err">&lt;</code><code class="nf">T</code><code class="p">&gt;</code> <code class="n">Sequence</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;.</code><code class="n">averageBy</code><code class="p">(</code><code class="n">selector</code><code class="p">:</code> <code class="p">(</code><code class="n">T</code><code class="p">)</code> <code class="p">-&gt;</code> <code class="n">Int</code><code class="p">):</code> <code class="n">Double</code> <code class="p">{</code>&#13;
    <code class="k">var</code> <code class="py">sum</code><code class="p">:</code> <code class="n">Double</code> <code class="p">=</code> <code class="m">0.0</code>&#13;
    <code class="k">var</code> <code class="py">count</code><code class="p">:</code> <code class="n">Int</code> <code class="p">=</code> <code class="m">0</code>&#13;
    <code class="k">for</code> <code class="p">(</code><code class="n">element</code> <code class="k">in</code> <code class="k">this</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="n">sum</code> <code class="p">+=</code> <code class="n">selector</code><code class="p">(</code><code class="n">element</code><code class="p">)</code>&#13;
        <code class="n">checkCountOverflow</code><code class="p">(++</code><code class="n">count</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
    <code class="k">return</code> <code class="k">if</code> <code class="p">(</code><code class="n">count</code> <code class="p">==</code> <code class="m">0</code><code class="p">)</code> <code class="n">Double</code><code class="p">.</code><code class="n">NaN</code> <code class="k">else</code> <code class="n">sum</code> <code class="p">/</code> <code class="n">count</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This again stoops to mutation in the name of efficiency, and finally allows us to write:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">averageNonBlankLength</code><code class="p">(</code><code class="n">strings</code><code class="p">:</code> <code class="n">Sequence</code><code class="p">&lt;</code><code class="n">String</code><code class="p">&gt;):</code> <code class="n">Double</code> <code class="p">=</code>&#13;
    <code class="n">strings</code><code class="p">.</code><code class="n">averageBy</code> <code class="p">{</code>&#13;
        <code class="k">if</code> <code class="p">(</code><code class="n">it</code><code class="p">.</code><code class="n">isBlank</code><code class="p">())</code> <code class="m">0</code> <code class="k">else</code> <code class="n">it</code><code class="p">.</code><code class="n">length</code>&#13;
    <code class="p">}</code></pre>&#13;
&#13;
<p>Why did we not just write it that way in the first place?&#13;
Well, sometimes we see these equivalences, sometimes we don’t!&#13;
Remember that we started here:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">static</code> <code class="kt">double</code> <code class="nf">averageNonBlankLength</code><code class="o">(</code><code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">strings</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="n">var</code> <code class="n">sum</code> <code class="o">=</code> <code class="mi">0</code><code class="o">;</code>&#13;
    <code class="k">for</code> <code class="o">(</code><code class="n">var</code> <code class="n">s</code> <code class="o">:</code> <code class="n">strings</code><code class="o">)</code> <code class="o">{</code>&#13;
        <code class="k">if</code> <code class="o">(!</code><code class="n">s</code><code class="o">.</code><code class="na">isBlank</code><code class="o">())</code>&#13;
            <code class="n">sum</code> <code class="o">+=</code> <code class="n">s</code><code class="o">.</code><code class="na">length</code><code class="o">();</code>&#13;
    <code class="o">}</code>&#13;
    <code class="k">return</code> <code class="n">sum</code> <code class="o">/</code> <code class="o">(</code><code class="kt">double</code><code class="o">)</code> <code class="n">strings</code><code class="o">.</code><code class="na">size</code><code class="o">();</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>Given this code, it is natural to translate the <code>if</code> statement to a <code>filter</code>:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">static</code> <code class="kt">double</code> <code class="nf">averageNonBlankLength</code><code class="o">(</code><code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">strings</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="k">return</code> <code class="n">strings</code>&#13;
        <code class="o">.</code><code class="na">stream</code><code class="o">()</code>&#13;
        <code class="o">.</code><code class="na">filter</code><code class="o">(</code><code class="n">s</code> <code class="o">-&gt;</code> <code class="o">!</code><code class="n">s</code><code class="o">.</code><code class="na">isBlank</code><code class="o">())</code>&#13;
        <code class="o">.</code><code class="na">mapToInt</code><code class="o">(</code><code class="nl">String:</code><code class="o">:</code><code class="n">length</code><code class="o">)</code>&#13;
        <code class="o">.</code><code class="na">sum</code><code class="o">()</code>&#13;
        <code class="o">/</code> <code class="o">(</code><code class="kt">double</code><code class="o">)</code> <code class="n">strings</code><code class="o">.</code><code class="na">size</code><code class="o">();</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>What if our original code had been more functional? Rather than using an <code>if</code> statement to decide <em>whether</em> to add, it might have used a ternary expression to calculate <em>the amount</em> to add:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">static</code> <code class="kt">double</code> <code class="nf">averageNonBlankLength</code><code class="o">(</code><code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">strings</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="n">var</code> <code class="n">sum</code> <code class="o">=</code> <code class="mi">0</code><code class="o">;</code>&#13;
    <code class="k">for</code> <code class="o">(</code><code class="n">var</code> <code class="n">s</code> <code class="o">:</code> <code class="n">strings</code><code class="o">)</code> <code class="o">{</code>&#13;
        <code class="n">sum</code> <code class="o">+=</code> <code class="n">s</code><code class="o">.</code><code class="na">isBlank</code><code class="o">()</code> <code class="o">?</code> <code class="mi">0</code> <code class="o">:</code> <code class="n">s</code><code class="o">.</code><code class="na">length</code><code class="o">();</code>&#13;
    <code class="o">}</code>&#13;
    <code class="k">return</code> <code class="n">sum</code> <code class="o">/</code> <code class="o">(</code><code class="kt">double</code><code class="o">)</code> <code class="n">strings</code><code class="o">.</code><code class="na">size</code><code class="o">();</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>Ah—then our initial translation would probably have been:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">static</code> <code class="kt">double</code> <code class="nf">averageNonBlankLength</code><code class="o">(</code><code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">strings</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="k">return</code> <code class="n">strings</code>&#13;
        <code class="o">.</code><code class="na">stream</code><code class="o">()</code>&#13;
        <code class="o">.</code><code class="na">mapToInt</code><code class="o">(</code><code class="n">s</code> <code class="o">-&gt;</code> <code class="n">s</code><code class="o">.</code><code class="na">isBlank</code><code class="o">()</code> <code class="o">?</code> <code class="mi">0</code> <code class="o">:</code> <code class="n">s</code><code class="o">.</code><code class="na">length</code><code class="o">())</code>&#13;
        <code class="o">.</code><code class="na">average</code><code class="o">()</code>&#13;
        <code class="o">.</code><code class="na">orElse</code><code class="o">(</code><code class="n">Double</code><code class="o">.</code><code class="na">NaN</code><code class="o">);</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>In that case, we would have had a shorter chapter but learned less.<a data-primary="" data-startref="SISalgebra13" data-type="indexterm" id="idm46393382915752"/><a data-primary="" data-startref="algtrans13" data-type="indexterm" id="idm46393382856984"/><a data-primary="" data-startref="tranal13" data-type="indexterm" id="idm46393382856104"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Refactoring from Streams to Iterables and Sequences" data-type="sect1"><div class="sect1" id="idm46393383550952">&#13;
<h1>Refactoring from Streams to Iterables and Sequences</h1>&#13;
&#13;
<p>Travelator logs<a data-primary="streams to iterables to sequences" data-secondary="refactoring" data-type="indexterm" id="SISrefact13"/><a data-primary="refactoring" data-secondary="streams to iterables and sequences" data-type="indexterm" id="Rstreams13"/> operational events as it runs, so we know that it is working as we expect.&#13;
These are sent as JSON to an indexing server, which can generate pretty graphs and alerts specified with its own query language.&#13;
Somehow, though, those nice people in marketing are always asking questions that we can’t write queries for.</p>&#13;
&#13;
<p>In these cases, we fetch events from the server and process them locally.&#13;
The querying, marshaling, and paging of the events is hidden behind a simple <code>EventStore</code> interface that returns an <code>Iterator&lt;Map&lt;String, Object&gt;&gt;</code>, where <code>Map&lt;String, Object&gt;</code> represents JSON objects:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">interface</code> <code class="nc">EventStore</code> <code class="o">{</code>&#13;
&#13;
    <code class="n">Iterator</code><code class="o">&lt;</code><code class="n">Map</code><code class="o">&lt;</code><code class="n">String</code><code class="o">,</code> <code class="n">Object</code><code class="o">&gt;&gt;</code> <code class="n">query</code><code class="o">(</code><code class="n">String</code> <code class="n">query</code><code class="o">);</code>&#13;
&#13;
    <code class="k">default</code> <code class="n">Stream</code><code class="o">&lt;</code><code class="n">Map</code><code class="o">&lt;</code><code class="n">String</code><code class="o">,</code> <code class="n">Object</code><code class="o">&gt;&gt;</code> <code class="n">queryAsStream</code><code class="o">(</code><code class="n">String</code> <code class="n">query</code><code class="o">)</code> <code class="o">{</code>&#13;
        <code class="n">Iterable</code><code class="o">&lt;</code><code class="n">Map</code><code class="o">&lt;</code><code class="n">String</code><code class="o">,</code> <code class="n">Object</code><code class="o">&gt;&gt;</code> <code class="n">iterable</code> <code class="o">=</code> <code class="o">()</code> <code class="o">-&gt;</code> <code class="n">query</code><code class="o">(</code><code class="n">query</code><code class="o">);</code>&#13;
        <code class="k">return</code> <code class="n">StreamSupport</code><code class="o">.</code><code class="na">stream</code><code class="o">(</code><code class="n">iterable</code><code class="o">.</code><code class="na">spliterator</code><code class="o">(),</code> <code class="kc">false</code><code class="o">);</code>&#13;
    <code class="o">}</code>&#13;
<code class="o">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=13.1&amp;show=file">Example 13.1 [streams-to-sequences.0:src/main/java/travelator/analytics/EventStore.java]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=13.1&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>The interface contains its own conversion of the <code>Iterator</code> to a <code>Stream</code> for our happy convenience. (Amazingly, no conversion function is built into the JDK.)</p>&#13;
&#13;
<p>Here is the sort of thing that we haven’t been able to write in the indexing server’s query language.&#13;
It calculates the average number of interactions customers make to complete a booking successfully:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kt">double</code> <code class="nf">averageNumberOfEventsPerCompletedBooking</code><code class="o">(</code>&#13;
    <code class="n">String</code> <code class="n">timeRange</code>&#13;
<code class="o">)</code> <code class="o">{</code>&#13;
    <code class="n">Stream</code><code class="o">&lt;</code><code class="n">Map</code><code class="o">&lt;</code><code class="n">String</code><code class="o">,</code> <code class="n">Object</code><code class="o">&gt;&gt;</code> <code class="n">eventsForSuccessfulBookings</code> <code class="o">=</code>&#13;
        <code class="n">eventStore</code>&#13;
            <code class="o">.</code><code class="na">queryAsStream</code><code class="o">(</code><code class="s">"type=CompletedBooking&amp;timerange="</code> <code class="o">+</code> <code class="n">timeRange</code><code class="o">)</code>&#13;
            <code class="o">.</code><code class="na">flatMap</code><code class="o">(</code><code class="n">event</code> <code class="o">-&gt;</code> <code class="o">{</code>&#13;
                <code class="n">String</code> <code class="n">interactionId</code> <code class="o">=</code> <code class="o">(</code><code class="n">String</code><code class="o">)</code> <code class="n">event</code><code class="o">.</code><code class="na">get</code><code class="o">(</code><code class="s">"interactionId"</code><code class="o">);</code>&#13;
                <code class="k">return</code> <code class="n">eventStore</code><code class="o">.</code><code class="na">queryAsStream</code><code class="o">(</code><code class="s">"interactionId="</code> <code class="o">+</code> <code class="n">interactionId</code><code class="o">);</code>&#13;
            <code class="o">});</code>&#13;
    <code class="n">Map</code><code class="o">&lt;</code><code class="n">String</code><code class="o">,</code> <code class="n">List</code><code class="o">&lt;</code><code class="n">Map</code><code class="o">&lt;</code><code class="n">String</code><code class="o">,</code> <code class="n">Object</code><code class="o">&gt;&gt;&gt;</code> <code class="n">bookingEventsByInteractionId</code> <code class="o">=</code>&#13;
        <code class="n">eventsForSuccessfulBookings</code><code class="o">.</code><code class="na">collect</code><code class="o">(</code><code class="n">groupingBy</code><code class="o">(</code>&#13;
            <code class="n">event</code> <code class="o">-&gt;</code> <code class="o">(</code><code class="n">String</code><code class="o">)</code> <code class="n">event</code><code class="o">.</code><code class="na">get</code><code class="o">(</code><code class="s">"interactionId"</code><code class="o">))</code>&#13;
        <code class="o">);</code>&#13;
    <code class="n">var</code> <code class="n">averageNumberOfEventsPerCompletedBooking</code> <code class="o">=</code>&#13;
        <code class="n">bookingEventsByInteractionId</code>&#13;
            <code class="o">.</code><code class="na">values</code><code class="o">()</code>&#13;
            <code class="o">.</code><code class="na">stream</code><code class="o">()</code>&#13;
            <code class="o">.</code><code class="na">mapToInt</code><code class="o">(</code><code class="nl">List:</code><code class="o">:</code><code class="n">size</code><code class="o">)</code>&#13;
            <code class="o">.</code><code class="na">average</code><code class="o">();</code>&#13;
    <code class="k">return</code> <code class="n">averageNumberOfEventsPerCompletedBooking</code><code class="o">.</code><code class="na">orElse</code><code class="o">(</code><code class="n">Double</code><code class="o">.</code><code class="na">NaN</code><code class="o">);</code>&#13;
<code class="o">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=13.2&amp;show=file">Example 13.2 [streams-to-sequences.0:src/main/java/travelator/analytics/MarketingAnalytics.java]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=13.2&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>We did our best when we wrote this to make it understandable.&#13;
We named intermediate variables, and specified their types when and only when it seemed to help, and formatted carefully—and it still looks like someone knocked the code onto the floor and tried to put it back together in the hope that we didn’t notice.&#13;
We sometimes end up in a losing battle like this: we could extract a function to simplify code at the call site, but if we can’t give that function a good name, we have just kicked the can down the source file.</p>&#13;
<div data-type="tip"><h1>Implicit or Explicit Types</h1>&#13;
<p>Sometimes<a data-primary="implicit types" data-type="indexterm" id="idm46393382604824"/><a data-primary="explicit types" data-type="indexterm" id="idm46393382604088"/> a variable’s type is essential to understanding how code works; other times it just clutters an already wordy block.&#13;
In this respect, explicit types are like comments, but they have the added advantage of being checked and enforced by the compiler.&#13;
As with comments, we should try to write code that doesn’t need explicit variable types.&#13;
Good naming can help, as can refactoring into functions where the return type can be shown.</p>&#13;
&#13;
<p>If these fail though, there is no shame in showing a variables type if it improves the readability of the code, and we should certainly prefer to communicate in types rather than comments.</p>&#13;
</div>&#13;
&#13;
<p>We’re going to convert this code to Kotlin in the fervent hope that our favorite language will allow us to do a better job.&#13;
Here is the result of the automated conversion:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">averageNumberOfEventsPerCompletedBooking</code><code class="p">(</code>&#13;
    <code class="n">timeRange</code><code class="p">:</code> <code class="n">String</code>&#13;
<code class="p">):</code> <code class="n">Double</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="py">eventsForSuccessfulBookings</code> <code class="p">=</code> <code class="n">eventStore</code>&#13;
        <code class="p">.</code><code class="n">queryAsStream</code><code class="p">(</code><code class="s">"type=CompletedBooking&amp;timerange=$timeRange"</code><code class="p">)</code>&#13;
        <code class="p">.</code><code class="n">flatMap</code> <code class="p">{</code> <code class="n">event</code><code class="p">:</code> <code class="n">Map</code><code class="p">&lt;</code><code class="n">String</code><code class="p">?,</code> <code class="n">Any</code><code class="p">?&gt;</code> <code class="p">-&gt;</code>&#13;
            <code class="k">val</code> <code class="py">interactionId</code> <code class="p">=</code> <code class="n">event</code><code class="p">[</code><code class="s">"interactionId"</code><code class="p">]</code> <code class="k">as</code> <code class="n">String</code><code class="p">?</code>&#13;
            <code class="n">eventStore</code><code class="p">.</code><code class="n">queryAsStream</code><code class="p">(</code><code class="s">"interactionId=$interactionId"</code><code class="p">)</code>&#13;
        <code class="p">}</code>&#13;
    <code class="k">val</code> <code class="py">bookingEventsByInteractionId</code> <code class="p">=</code> <code class="n">eventsForSuccessfulBookings</code><code class="p">.</code><code class="n">collect</code><code class="p">(</code>&#13;
        <code class="n">Collectors</code><code class="p">.</code><code class="n">groupingBy</code><code class="p">(</code>&#13;
            <code class="n">Function</code> <code class="p">{</code> <code class="n">event</code><code class="p">:</code> <code class="n">Map</code><code class="p">&lt;</code><code class="n">String</code><code class="p">,</code> <code class="n">Any</code><code class="p">&gt;</code> <code class="p">-&gt;</code>&#13;
                <code class="n">event</code><code class="p">[</code><code class="s">"interactionId"</code><code class="p">]</code> <code class="k">as</code> <code class="n">String</code><code class="p">?</code>&#13;
            <code class="p">}</code>&#13;
        <code class="p">)</code>&#13;
    <code class="p">)</code>&#13;
    <code class="k">val</code> <code class="py">averageNumberOfEventsPerCompletedBooking</code> <code class="p">=</code> <code class="n">bookingEventsByInteractionId</code>&#13;
        <code class="p">.</code><code class="n">values</code>&#13;
        <code class="p">.</code><code class="n">stream</code><code class="p">()</code>&#13;
        <code class="p">.</code><code class="n">mapToInt</code> <code class="p">{</code> <code class="n">obj</code><code class="p">:</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">Map</code><code class="p">&lt;</code><code class="n">String</code><code class="p">,</code> <code class="n">Any</code><code class="p">&gt;&gt;</code> <code class="p">-&gt;</code> <code class="n">obj</code><code class="p">.</code><code class="n">size</code> <code class="p">}</code>&#13;
        <code class="p">.</code><code class="n">average</code><code class="p">()</code>&#13;
    <code class="k">return</code> <code class="n">averageNumberOfEventsPerCompletedBooking</code><code class="p">.</code><code class="n">orElse</code><code class="p">(</code><code class="n">Double</code><code class="p">.</code><code class="n">NaN</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=13.3&amp;show=file">Example 13.3 [streams-to-sequences.1:src/main/java/travelator/analytics/MarketingAnalytics.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=13.3&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>At the time of writing, the Java to Kotlin converter is not as clever as it might be mapping between lambdas in the two languages.&#13;
This is particularly noticeable in streams code, because that is where most Java lambdas are to be found.&#13;
Most of the issues can be fixed with Alt-Enter on the odd code and accepting a quick fix.&#13;
Let’s start by tidying up nullability, removing the vestigial <code>Function</code>, and simplifying that ugly <code>mapToInt</code> lambda:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">averageNumberOfEventsPerCompletedBooking</code><code class="p">(</code>&#13;
    <code class="n">timeRange</code><code class="p">:</code> <code class="n">String</code>&#13;
<code class="p">):</code> <code class="n">Double</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="py">eventsForSuccessfulBookings</code> <code class="p">=</code> <code class="n">eventStore</code>&#13;
        <code class="p">.</code><code class="n">queryAsStream</code><code class="p">(</code><code class="s">"type=CompletedBooking&amp;timerange=$timeRange"</code><code class="p">)</code>&#13;
        <code class="p">.</code><code class="n">flatMap</code> <code class="p">{</code> <code class="n">event</code> <code class="p">-&gt;</code>&#13;
            <code class="k">val</code> <code class="py">interactionId</code> <code class="p">=</code> <code class="n">event</code><code class="p">[</code><code class="s">"interactionId"</code><code class="p">]</code> <code class="k">as</code> <code class="n">String</code>&#13;
            <code class="n">eventStore</code><code class="p">.</code><code class="n">queryAsStream</code><code class="p">(</code><code class="s">"interactionId=$interactionId"</code><code class="p">)</code>&#13;
        <code class="p">}</code>&#13;
    <code class="k">val</code> <code class="py">bookingEventsByInteractionId</code> <code class="p">=</code> <code class="n">eventsForSuccessfulBookings</code><code class="p">.</code><code class="n">collect</code><code class="p">(</code>&#13;
        <code class="n">groupingBy</code> <code class="p">{</code> <code class="n">event</code> <code class="p">-&gt;</code> <code class="n">event</code><code class="p">[</code><code class="s">"interactionId"</code><code class="p">]</code> <code class="k">as</code> <code class="n">String</code> <code class="p">}</code>&#13;
    <code class="p">)</code>&#13;
    <code class="k">val</code> <code class="py">averageNumberOfEventsPerCompletedBooking</code> <code class="p">=</code> <code class="n">bookingEventsByInteractionId</code>&#13;
        <code class="p">.</code><code class="n">values</code>&#13;
        <code class="p">.</code><code class="n">stream</code><code class="p">()</code>&#13;
        <code class="p">.</code><code class="n">mapToInt</code> <code class="p">{</code> <code class="n">it</code><code class="p">.</code><code class="n">size</code> <code class="p">}</code>&#13;
        <code class="p">.</code><code class="n">average</code><code class="p">()</code>&#13;
    <code class="k">return</code> <code class="n">averageNumberOfEventsPerCompletedBooking</code><code class="p">.</code><code class="n">orElse</code><code class="p">(</code><code class="n">Double</code><code class="p">.</code><code class="n">NaN</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=13.4&amp;show=file">Example 13.4 [streams-to-sequences.2:src/main/java/travelator/analytics/MarketingAnalytics.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=13.4&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>The Java code before conversion mixed some old-style explicitly typed variables: <code>Stream&lt;Map&lt;String, Object&gt;&gt;</code>, for example, with the implicit <code>var averageNumberOf​Event⁠sPerCompletedBooking</code>.&#13;
The conversion has dropped the explicit types.&#13;
It is certainly less intimidating this way, but also less comprehensible if we actually care how it is doing whatever it is doing.&#13;
We’ll leave it this way for now but review our decision before we finish.</p>&#13;
&#13;
<p>At this point, we have Kotlin code using Java streams that runs just fine.&#13;
We could leave it alone.&#13;
Travelator is a huge success, with many thousands of completed bookings a day, and streams are a good choice for throughput, so why convert to Kotlin?&#13;
You didn’t buy this book for that sort of attitude though, so we’ll push on under the pretense that we are measuring performance at every stage and will stop if we see it degrade significantly.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Iterables First" data-type="sect2"><div class="sect2" id="idm46393382269752">&#13;
<h2>Iterables First</h2>&#13;
&#13;
<p>Looking at the code, we see that it has two stages.&#13;
The first stage processes an input of indeterminate length, producing a collection in memory:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">eventsForSuccessfulBookings</code> <code class="p">=</code> <code class="n">eventStore</code>&#13;
    <code class="p">.</code><code class="n">queryAsStream</code><code class="p">(</code><code class="s">"type=CompletedBooking&amp;timerange=$timeRange"</code><code class="p">)</code>&#13;
    <code class="p">.</code><code class="n">flatMap</code> <code class="p">{</code> <code class="n">event</code> <code class="p">-&gt;</code>&#13;
        <code class="k">val</code> <code class="py">interactionId</code> <code class="p">=</code> <code class="n">event</code><code class="p">[</code><code class="s">"interactionId"</code><code class="p">]</code> <code class="k">as</code> <code class="n">String</code>&#13;
        <code class="n">eventStore</code><code class="p">.</code><code class="n">queryAsStream</code><code class="p">(</code><code class="s">"interactionId=$interactionId"</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="k">val</code> <code class="py">bookingEventsByInteractionId</code> <code class="p">=</code> <code class="n">eventsForSuccessfulBookings</code><code class="p">.</code><code class="n">collect</code><code class="p">(</code>&#13;
    <code class="n">groupingBy</code> <code class="p">{</code> <code class="n">event</code> <code class="p">-&gt;</code> <code class="n">event</code><code class="p">[</code><code class="s">"interactionId"</code><code class="p">]</code> <code class="k">as</code> <code class="n">String</code> <code class="p">}</code>&#13;
<code class="p">)</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=13.5&amp;show=file">Example 13.5 [streams-to-sequences.2:src/main/java/travelator/analytics/MarketingAnalytics.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=13.5&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>The second processes that collection:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">averageNumberOfEventsPerCompletedBooking</code> <code class="p">=</code> <code class="n">bookingEventsByInteractionId</code>&#13;
    <code class="p">.</code><code class="n">values</code>&#13;
    <code class="p">.</code><code class="n">stream</code><code class="p">()</code>&#13;
    <code class="p">.</code><code class="n">mapToInt</code> <code class="p">{</code> <code class="n">it</code><code class="p">.</code><code class="n">size</code> <code class="p">}</code>&#13;
    <code class="p">.</code><code class="n">average</code><code class="p">()</code>&#13;
<code class="k">return</code> <code class="n">averageNumberOfEventsPerCompletedBooking</code><code class="p">.</code><code class="n">orElse</code><code class="p">(</code><code class="n">Double</code><code class="p">.</code><code class="n">NaN</code><code class="p">)</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=13.6&amp;show=file">Example 13.6 [streams-to-sequences.2:src/main/java/travelator/analytics/MarketingAnalytics.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=13.6&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>As we saw earlier, Java uses streams for both these cases, whereas in Kotlin we would tend to use a <code>Sequence</code> to process input of unknown length and an <code>Iterable</code> to process data in memory.&#13;
Acting on in-memory data is easier to reason with, so we’ll convert <code>averageNumberOfEventsPerCompletedBooking</code> first.</p>&#13;
&#13;
<p>Until IntelliJ comes up with automated refactoring, we are left having to do this by hand.&#13;
Usually, we would have tests to make this safer, but this is fast-moving and arbitrary analytics code, so it turns out we cut corners.&#13;
Before we begin refactoring proper, we write a quick test that talks to production and shows that the result for yesterday was 7.44; now we can keep running that to check that it doesn’t change.</p>&#13;
&#13;
<p>We know that we can apply collection operations directly to <code>Map.values</code> in Kotlin (those on <code>Iterable</code>), so we can remove the <code>.stream()</code>; <code>average()</code> is an operation on <code>IntStream</code> in Java, but Kotlin conveniently declares <code>Iterable&lt;Int&gt;.average()</code>, so we don’t have to <code>mapToInt</code>, just <code>map</code>.&#13;
Finally, where <code>IntStream.average()</code> returns an empty <code>OptionalDouble</code> if the stream has no elements, Kotlin’s <code>Iterable&lt;Int&gt;.average()</code> returns <code>NaN</code> (not a number), which means we can use the result directly:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">averageNumberOfEventsPerCompletedBooking</code> <code class="p">=</code> <code class="n">bookingEventsByInteractionId</code>&#13;
    <code class="p">.</code><code class="n">values</code>&#13;
    <code class="p">.</code><code class="n">map</code> <code class="p">{</code> <code class="n">it</code><code class="p">.</code><code class="n">size</code> <code class="p">}</code>&#13;
    <code class="p">.</code><code class="n">average</code><code class="p">()</code>&#13;
<code class="k">return</code> <code class="n">averageNumberOfEventsPerCompletedBooking</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=13.7&amp;show=file">Example 13.7 [streams-to-sequences.3:src/main/java/travelator/analytics/MarketingAnalytics.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=13.7&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>Has this been a good change though?</p>&#13;
&#13;
<p>Looking at the code, we are now creating an intermediate <code>List&lt;Int&gt;</code> on which to call <code>average()</code>.&#13;
This will result in boxing each value, and this time there is no <code>averageBy()</code> (as there was <code>sumBy()</code> in the previous example) to prevent this.</p>&#13;
&#13;
<p>Whether this code performs better or worse than the stream version will depend on the number of values in the <code>Map</code>, how our particular JVM optimizes boxing, and how heavily HotSpot has optimized this path; only measuring in real conditions will tell.&#13;
If we have to choose a generic solution, we should probably write our own &#13;
<span class="keep-together"><code>Collection.averageBy</code></span>. That way we can leverage knowing the size of a <code>Collection</code>.&#13;
We could use the one we prepared earlier in the chapter (albeit for <code>Sequence</code>) or refactor from here.&#13;
We can refactor from here by extracting <code>values</code> and using <code>sumBy()</code>:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">values</code> <code class="p">=</code> <code class="n">bookingEventsByInteractionId</code><code class="p">.</code><code class="n">values</code>&#13;
<code class="k">return</code> <code class="n">values</code><code class="p">.</code><code class="n">sumBy</code> <code class="p">{</code> <code class="n">it</code><code class="p">.</code><code class="n">size</code> <code class="p">}</code> <code class="p">/</code> <code class="n">values</code><code class="p">.</code><code class="n">size</code><code class="p">.</code><code class="n">toDouble</code><code class="p">()</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=13.8&amp;show=file">Example 13.8 [streams-to-sequences.4:src/main/java/travelator/analytics/MarketingAnalytics.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=13.8&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>Now “Extract Function” <code>averageBy</code> on the returned expression:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">values</code> <code class="p">=</code> <code class="n">bookingEventsByInteractionId</code><code class="p">.</code><code class="n">values</code>&#13;
<code class="k">return</code> <code class="n">averageBy</code><code class="p">(</code><code class="n">values</code><code class="p">)</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=13.9&amp;show=file">Example 13.9 [streams-to-sequences.5:src/main/java/travelator/analytics/MarketingAnalytics.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=13.9&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">private</code> <code class="k">fun</code> <code class="nf">averageBy</code><code class="p">(</code>&#13;
    <code class="n">values</code><code class="p">:</code> <code class="n">MutableCollection</code><code class="p">&lt;</code><code class="n">MutableList</code><code class="p">&lt;</code><code class="n">MutableMap</code><code class="p">&lt;</code><code class="n">String</code><code class="p">,</code> <code class="n">Any</code><code class="p">&gt;&gt;&gt;</code>&#13;
<code class="p">):</code> <code class="n">Double</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="n">values</code><code class="p">.</code><code class="n">sumBy</code> <code class="p">{</code> <code class="n">it</code><code class="p">.</code><code class="n">size</code> <code class="p">}</code> <code class="p">/</code> <code class="n">values</code><code class="p">.</code><code class="n">size</code><code class="p">.</code><code class="n">toDouble</code><code class="p">()</code>&#13;
<code class="p">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=13.10&amp;show=file">Example 13.10 [streams-to-sequences.5:src/main/java/travelator/analytics/MarketingAnalytics.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=13.10&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>Eeek!&#13;
It turns out that the type of <code>bookingEventsByInteractionId</code> was a lot more mutable than we wanted.&#13;
It came from <code>Collectors.groupingBy</code>, a stream operation that only has Java collections to return after all.&#13;
We’ll change it to use <code>Collection</code> in place of the <code>MutableCollection</code> for now, and then “Introduce Parameter” named <code>selector</code> on the lambda:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">private</code> <code class="k">fun</code> <code class="nf">averageBy</code><code class="p">(</code>&#13;
    <code class="n">values</code><code class="p">:</code> <code class="n">Collection</code><code class="p">&lt;</code><code class="n">MutableList</code><code class="p">&lt;</code><code class="n">MutableMap</code><code class="p">&lt;</code><code class="n">String</code><code class="p">,</code> <code class="n">Any</code><code class="p">&gt;&gt;&gt;,</code>&#13;
    <code class="n">selector</code><code class="p">:</code> <code class="p">(</code><code class="n">MutableList</code><code class="p">&lt;</code><code class="n">MutableMap</code><code class="p">&lt;</code><code class="n">String</code><code class="p">,</code> <code class="n">Any</code><code class="p">&gt;&gt;)</code> <code class="p">-&gt;</code> <code class="n">Int</code>&#13;
<code class="p">):</code> <code class="n">Double</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="n">values</code><code class="p">.</code><code class="n">sumBy</code><code class="p">(</code><code class="n">selector</code><code class="p">)</code> <code class="p">/</code> <code class="n">values</code><code class="p">.</code><code class="n">size</code><code class="p">.</code><code class="n">toDouble</code><code class="p">()</code>&#13;
<code class="p">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=13.11&amp;show=file">Example 13.11 [streams-to-sequences.6:src/main/java/travelator/analytics/MarketingAnalytics.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=13.11&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>Now we don’t want to care about the actual type of items in the <code>Collection</code>.&#13;
If we select the <code>MutableList&lt;MutableMap&lt;String, Any&gt;&gt;</code>, and “Extract/Introduce Type Parameter”, we get the following:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">private</code> <code class="k">fun</code> <code class="err">&lt;</code><code class="nf">T</code> <code class="p">:</code> <code class="n">MutableList</code><code class="p">&lt;</code><code class="n">MutableMap</code><code class="p">&lt;</code><code class="n">String</code><code class="p">,</code> <code class="n">Any</code><code class="p">&gt;&gt;&gt;</code> <code class="n">averageBy</code><code class="p">(</code>&#13;
    <code class="n">values</code><code class="p">:</code> <code class="n">Collection</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;,</code>&#13;
    <code class="n">selector</code><code class="p">:</code> <code class="p">(</code><code class="n">T</code><code class="p">)</code> <code class="p">-&gt;</code> <code class="n">Int</code>&#13;
<code class="p">):</code> <code class="n">Double</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="n">values</code><code class="p">.</code><code class="n">sumBy</code><code class="p">(</code><code class="n">selector</code><code class="p">)</code> <code class="p">/</code> <code class="n">values</code><code class="p">.</code><code class="n">size</code><code class="p">.</code><code class="n">toDouble</code><code class="p">()</code>&#13;
<code class="p">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=13.12&amp;show=file">Example 13.12 [streams-to-sequences.7:src/main/java/travelator/analytics/MarketingAnalytics.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=13.12&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>That refactoring is clever enough that we don’t begrudge having to tell IntelliJ that <code>T</code> can be anything really (by removing the <code>MutableList&lt;MutableMap&lt;String, Any&gt;&gt;</code> type restriction):</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">private</code> <code class="k">fun</code> <code class="err">&lt;</code><code class="nf">T</code><code class="p">&gt;</code> <code class="n">averageBy</code><code class="p">(</code>&#13;
    <code class="n">values</code><code class="p">:</code> <code class="n">Collection</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;,</code>&#13;
    <code class="n">selector</code><code class="p">:</code> <code class="p">(</code><code class="n">T</code><code class="p">)</code> <code class="p">-&gt;</code> <code class="n">Int</code>&#13;
<code class="p">):</code> <code class="n">Double</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="n">values</code><code class="p">.</code><code class="n">sumBy</code><code class="p">(</code><code class="n">selector</code><code class="p">)</code> <code class="p">/</code> <code class="n">values</code><code class="p">.</code><code class="n">size</code><code class="p">.</code><code class="n">toDouble</code><code class="p">()</code>&#13;
<code class="p">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=13.13&amp;show=file">Example 13.13 [streams-to-sequences.8:src/main/java/travelator/analytics/MarketingAnalytics.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=13.13&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>IntelliJ also added the type to the call for some reason:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">values</code> <code class="p">=</code> <code class="n">bookingEventsByInteractionId</code><code class="p">.</code><code class="n">values</code>&#13;
<code class="k">return</code> <code class="n">averageBy</code><code class="p">&lt;</code><code class="n">MutableList</code><code class="p">&lt;</code><code class="n">MutableMap</code><code class="p">&lt;</code><code class="n">String</code><code class="p">,</code> <code class="n">Any</code><code class="p">&gt;&gt;&gt;(</code><code class="n">values</code><code class="p">)</code> <code class="p">{</code> <code class="n">it</code><code class="p">.</code><code class="n">size</code> <code class="p">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=13.14&amp;show=file">Example 13.14 [streams-to-sequences.7:src/main/java/travelator/analytics/MarketingAnalytics.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=13.14&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>So we remove the <code>MutableList&lt;MutableMap&lt;String, Any&gt;&gt;</code> from there too.</p>&#13;
&#13;
<p>Finally, we can make <code>averageBy</code> the tiny single-expression inline extension function it was born to be (see Chapters <a href="ch09.html#multi-to-single-expression-functions">9</a> and <a href="ch10.html#functions-to-extension-functions">10</a>):</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">inline</code> <code class="k">fun</code> <code class="err">&lt;</code><code class="nf">T</code><code class="p">&gt;</code> <code class="n">Collection</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;.</code><code class="n">averageBy</code><code class="p">(</code><code class="n">selector</code><code class="p">:</code> <code class="p">(</code><code class="n">T</code><code class="p">)</code> <code class="p">-&gt;</code> <code class="n">Int</code><code class="p">):</code> <code class="n">Double</code> <code class="p">=</code>&#13;
    <code class="n">sumBy</code><code class="p">(</code><code class="n">selector</code><code class="p">)</code> <code class="p">/</code> <code class="n">size</code><code class="p">.</code><code class="n">toDouble</code><code class="p">()</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=13.15&amp;show=file">Example 13.15 [streams-to-sequences.9:src/main/java/travelator/analytics/MarketingAnalytics.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=13.15&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>This version doesn’t box integers nor iterate more than once, so it is probably as efficient as we are going to get.&#13;
But again, only measuring in our specific circumstances will tell for sure.</p>&#13;
&#13;
<p>Note that when we wrote <code>Sequence.averageNonBlankLength</code> earlier, we had to count the number of items.&#13;
By defining <code>averageBy</code> as an extension on <code>Collection</code> rather than on <code>Iterable</code>, we can use the fact that we can ask the <code>size</code> of in-memory collections to avoid the tedious bookkeeping.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Then Sequences" data-type="sect2"><div class="sect2" id="idm46393382268168">&#13;
<h2>Then Sequences</h2>&#13;
&#13;
<p>So far, we have converted the in-memory pipeline.&#13;
Now we are left with the code that reads an unknown number of events from the <code>eventStore</code>. We will want to keep this code lazy.</p>&#13;
&#13;
<p>Returning to the entry point, we now have:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">averageNumberOfEventsPerCompletedBooking</code><code class="p">(</code>&#13;
    <code class="n">timeRange</code><code class="p">:</code> <code class="n">String</code>&#13;
<code class="p">):</code> <code class="n">Double</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="py">eventsForSuccessfulBookings</code> <code class="p">=</code> <code class="n">eventStore</code>&#13;
        <code class="p">.</code><code class="n">queryAsStream</code><code class="p">(</code><code class="s">"type=CompletedBooking&amp;timerange=$timeRange"</code><code class="p">)</code>&#13;
        <code class="p">.</code><code class="n">flatMap</code> <code class="p">{</code> <code class="n">event</code> <code class="p">-&gt;</code>&#13;
            <code class="k">val</code> <code class="py">interactionId</code> <code class="p">=</code> <code class="n">event</code><code class="p">[</code><code class="s">"interactionId"</code><code class="p">]</code> <code class="k">as</code> <code class="n">String</code>&#13;
            <code class="n">eventStore</code><code class="p">.</code><code class="n">queryAsStream</code><code class="p">(</code><code class="s">"interactionId=$interactionId"</code><code class="p">)</code>&#13;
        <code class="p">}</code>&#13;
    <code class="k">val</code> <code class="py">bookingEventsByInteractionId</code> <code class="p">=</code> <code class="n">eventsForSuccessfulBookings</code><code class="p">.</code><code class="n">collect</code><code class="p">(</code>&#13;
        <code class="n">groupingBy</code> <code class="p">{</code> <code class="n">event</code> <code class="p">-&gt;</code> <code class="n">event</code><code class="p">[</code><code class="s">"interactionId"</code><code class="p">]</code> <code class="k">as</code> <code class="n">String</code> <code class="p">}</code>&#13;
    <code class="p">)</code>&#13;
    <code class="k">return</code> <code class="n">bookingEventsByInteractionId</code><code class="p">.</code><code class="n">values</code><code class="p">.</code><code class="n">averageBy</code> <code class="p">{</code> <code class="n">it</code><code class="p">.</code><code class="n">size</code> <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=13.16&amp;show=file">Example 13.16 [streams-to-sequences.9:src/main/java/travelator/analytics/MarketingAnalytics.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=13.16&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>Now the variable <code>bookingEventsByInteractionId</code> is only really there to give a checkpoint in the algorithm: it names an intermediate in the hope that it aids understanding.&#13;
Moving up the function, <code>eventsForSuccessfulBookings</code> is a <code>Stream</code>, so we can convert the <code>collect(groupingBy(...))</code> to Kotlin with <code>asSequence().groupBy {...}</code>; the lambda remains unchanged:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">bookingEventsByInteractionId</code> <code class="p">=</code> <code class="n">eventsForSuccessfulBookings</code>&#13;
    <code class="p">.</code><code class="n">asSequence</code><code class="p">()</code>&#13;
    <code class="p">.</code><code class="n">groupBy</code> <code class="p">{</code> <code class="n">event</code> <code class="p">-&gt;</code>&#13;
        <code class="n">event</code><code class="p">[</code><code class="s">"interactionId"</code><code class="p">]</code> <code class="k">as</code> <code class="n">String</code>&#13;
    <code class="p">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=13.17&amp;show=file">Example 13.17 [streams-to-sequences.10:src/main/java/travelator/analytics/MarketingAnalytics.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=13.17&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>Swapping out one method for another method (or extension function) with a similar name that takes a compatible lambda is a good sign that we are on the right track.</p>&#13;
&#13;
<p>Now for that <code>flatMap</code>, used to fetch all the events for any interaction that had a completed booking:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">eventsForSuccessfulBookings</code> <code class="p">=</code> <code class="n">eventStore</code>&#13;
    <code class="p">.</code><code class="n">queryAsStream</code><code class="p">(</code><code class="s">"type=CompletedBooking&amp;timerange=$timeRange"</code><code class="p">)</code>&#13;
    <code class="p">.</code><code class="n">flatMap</code> <code class="p">{</code> <code class="n">event</code> <code class="p">-&gt;</code>&#13;
        <code class="k">val</code> <code class="py">interactionId</code> <code class="p">=</code> <code class="n">event</code><code class="p">[</code><code class="s">"interactionId"</code><code class="p">]</code> <code class="k">as</code> <code class="n">String</code>&#13;
        <code class="n">eventStore</code><code class="p">.</code><code class="n">queryAsStream</code><code class="p">(</code><code class="s">"interactionId=$interactionId"</code><code class="p">)</code>&#13;
    <code class="p">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=13.18&amp;show=file">Example 13.18 [streams-to-sequences.10:src/main/java/travelator/analytics/MarketingAnalytics.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=13.18&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>This would also <em>probably just work™</em> if we had sequences rather than streams.&#13;
Thankfully, we know how to convert from the <code>Stream</code> to a <code>Sequence</code>: it’s the <code>.asSequence()</code> extension provided by the Kotlin JDK interop.&#13;
We need to apply it to both streams:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">eventsForSuccessfulBookings</code> <code class="p">=</code> <code class="n">eventStore</code>&#13;
    <code class="p">.</code><code class="n">queryAsStream</code><code class="p">(</code><code class="s">"type=CompletedBooking&amp;timerange=$timeRange"</code><code class="p">)</code>&#13;
    <code class="p">.</code><code class="n">asSequence</code><code class="p">()</code>&#13;
    <code class="p">.</code><code class="n">flatMap</code> <code class="p">{</code> <code class="n">event</code> <code class="p">-&gt;</code>&#13;
        <code class="k">val</code> <code class="py">interactionId</code> <code class="p">=</code> <code class="n">event</code><code class="p">[</code><code class="s">"interactionId"</code><code class="p">]</code> <code class="k">as</code> <code class="n">String</code>&#13;
        <code class="n">eventStore</code>&#13;
            <code class="p">.</code><code class="n">queryAsStream</code><code class="p">(</code><code class="s">"interactionId=$interactionId"</code><code class="p">)</code>&#13;
            <code class="p">.</code><code class="n">asSequence</code><code class="p">()</code>&#13;
    <code class="p">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=13.19&amp;show=file">Example 13.19 [streams-to-sequences.11:src/main/java/travelator/analytics/MarketingAnalytics.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=13.19&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>Awesomely, this continues to compile and pass our (cursory) test!&#13;
It compiles because, although we have changed the type of <code>eventsForSuccessfulBookings</code> from <code>Stream</code> to <code>Sequence</code>, we then call <code>eventsForSuccessfulBookings.asSequence()</code>:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">bookingEventsByInteractionId</code> <code class="p">=</code> <code class="n">eventsForSuccessfulBookings</code>&#13;
    <code class="p">.</code><code class="n">asSequence</code><code class="p">()</code>&#13;
    <code class="p">.</code><code class="n">groupBy</code> <code class="p">{</code> <code class="n">event</code> <code class="p">-&gt;</code>&#13;
        <code class="n">event</code><code class="p">[</code><code class="s">"interactionId"</code><code class="p">]</code> <code class="k">as</code> <code class="n">String</code>&#13;
    <code class="p">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=13.20&amp;show=file">Example 13.20 [streams-to-sequences.11:src/main/java/travelator/analytics/MarketingAnalytics.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=13.20&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>This resolves to <code>Sequence.asSequence()</code>, which is a no-op.&#13;
We can inline <code>asSequence</code> to prove it:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">bookingEventsByInteractionId</code> <code class="p">=</code> <code class="n">eventsForSuccessfulBookings</code>&#13;
    <code class="p">.</code><code class="n">groupBy</code> <code class="p">{</code> <code class="n">event</code> <code class="p">-&gt;</code>&#13;
        <code class="n">event</code><code class="p">[</code><code class="s">"interactionId"</code><code class="p">]</code> <code class="k">as</code> <code class="n">String</code>&#13;
    <code class="p">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=13.21&amp;show=file">Example 13.21 [streams-to-sequences.12:src/main/java/travelator/analytics/MarketingAnalytics.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=13.21&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>Returning to <code>eventsForSuccessfulBookings</code>, we now have:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">eventsForSuccessfulBookings</code> <code class="p">=</code> <code class="n">eventStore</code>&#13;
    <code class="p">.</code><code class="n">queryAsStream</code><code class="p">(</code><code class="s">"type=CompletedBooking&amp;timerange=$timeRange"</code><code class="p">)</code>&#13;
    <code class="p">.</code><code class="n">asSequence</code><code class="p">()</code>&#13;
    <code class="p">.</code><code class="n">flatMap</code> <code class="p">{</code> <code class="n">event</code> <code class="p">-&gt;</code>&#13;
        <code class="k">val</code> <code class="py">interactionId</code> <code class="p">=</code> <code class="n">event</code><code class="p">[</code><code class="s">"interactionId"</code><code class="p">]</code> <code class="k">as</code> <code class="n">String</code>&#13;
        <code class="n">eventStore</code>&#13;
            <code class="p">.</code><code class="n">queryAsStream</code><code class="p">(</code><code class="s">"interactionId=$interactionId"</code><code class="p">)</code>&#13;
            <code class="p">.</code><code class="n">asSequence</code><code class="p">()</code>&#13;
    <code class="p">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=13.22&amp;show=file">Example 13.22 [streams-to-sequences.11:src/main/java/travelator/analytics/MarketingAnalytics.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=13.22&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>What we really wanted was for <code>EventStore</code> to support <code>queryAsSequence</code>. We can do this without modifying it by introducing an extension function:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">EventStore</code><code class="p">.</code><code class="n">queryAsSequence</code><code class="p">(</code><code class="n">query</code><code class="p">:</code> <code class="n">String</code><code class="p">)</code> <code class="p">=</code>&#13;
    <code class="k">this</code><code class="p">.</code><code class="n">queryAsStream</code><code class="p">(</code><code class="n">query</code><code class="p">).</code><code class="n">asSequence</code><code class="p">()</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=13.23&amp;show=file">Example 13.23 [streams-to-sequences.12:src/main/java/travelator/analytics/MarketingAnalytics.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=13.23&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>This allows us to remove the <code>asSequence</code> calls from the calling function:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">averageNumberOfEventsPerCompletedBooking</code><code class="p">(</code>&#13;
    <code class="n">timeRange</code><code class="p">:</code> <code class="n">String</code>&#13;
<code class="p">):</code> <code class="n">Double</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="py">eventsForSuccessfulBookings</code> <code class="p">=</code> <code class="n">eventStore</code>&#13;
        <code class="p">.</code><code class="n">queryAsSequence</code><code class="p">(</code><code class="s">"type=CompletedBooking&amp;timerange=$timeRange"</code><code class="p">)</code>&#13;
        <code class="p">.</code><code class="n">flatMap</code> <code class="p">{</code> <code class="n">event</code> <code class="p">-&gt;</code>&#13;
            <code class="k">val</code> <code class="py">interactionId</code> <code class="p">=</code> <code class="n">event</code><code class="p">[</code><code class="s">"interactionId"</code><code class="p">]</code> <code class="k">as</code> <code class="n">String</code>&#13;
            <code class="n">eventStore</code>&#13;
                <code class="p">.</code><code class="n">queryAsSequence</code><code class="p">(</code><code class="s">"interactionId=$interactionId"</code><code class="p">)</code>&#13;
        <code class="p">}</code>&#13;
    <code class="k">val</code> <code class="py">bookingEventsByInteractionId</code> <code class="p">=</code> <code class="n">eventsForSuccessfulBookings</code>&#13;
        <code class="p">.</code><code class="n">groupBy</code> <code class="p">{</code> <code class="n">event</code> <code class="p">-&gt;</code>&#13;
            <code class="n">event</code><code class="p">[</code><code class="s">"interactionId"</code><code class="p">]</code> <code class="k">as</code> <code class="n">String</code>&#13;
        <code class="p">}</code>&#13;
    <code class="k">return</code> <code class="n">bookingEventsByInteractionId</code><code class="p">.</code><code class="n">values</code><code class="p">.</code><code class="n">averageBy</code> <code class="p">{</code> <code class="n">it</code><code class="p">.</code><code class="n">size</code> <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=13.24&amp;show=file">Example 13.24 [streams-to-sequences.12:src/main/java/travelator/analytics/MarketingAnalytics.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=13.24&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>OK, time to review.&#13;
We’ve converted our Java to Kotlin, and are using iterables to process the in-memory operations, and sequences (backed by streams in <code>EventStore</code>) to process the unbounded operations.&#13;
We really can’t claim, though, that the structure of the algorithm has become much clearer.&#13;
A little less noisy, yes, but hardly expressive.</p>&#13;
&#13;
<p>The function is currently divided into three parts, and if we’re honest, they are pretty arbitrary.&#13;
Sometimes we can gain greater insight by inlining everything and seeing what we have, so let’s do that:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">averageNumberOfEventsPerCompletedBooking</code><code class="p">(</code>&#13;
    <code class="n">timeRange</code><code class="p">:</code> <code class="n">String</code>&#13;
<code class="p">):</code> <code class="n">Double</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="n">eventStore</code>&#13;
        <code class="p">.</code><code class="n">queryAsSequence</code><code class="p">(</code><code class="s">"type=CompletedBooking&amp;timerange=$timeRange"</code><code class="p">)</code>&#13;
        <code class="p">.</code><code class="n">flatMap</code> <code class="p">{</code> <code class="n">event</code> <code class="p">-&gt;</code>&#13;
            <code class="k">val</code> <code class="py">interactionId</code> <code class="p">=</code> <code class="n">event</code><code class="p">[</code><code class="s">"interactionId"</code><code class="p">]</code> <code class="k">as</code> <code class="n">String</code>&#13;
            <code class="n">eventStore</code>&#13;
                <code class="p">.</code><code class="n">queryAsSequence</code><code class="p">(</code><code class="s">"interactionId=$interactionId"</code><code class="p">)</code>&#13;
        <code class="p">}.</code><code class="n">groupBy</code> <code class="p">{</code> <code class="n">event</code> <code class="p">-&gt;</code>&#13;
            <code class="n">event</code><code class="p">[</code><code class="s">"interactionId"</code><code class="p">]</code> <code class="k">as</code> <code class="n">String</code>&#13;
        <code class="p">}.</code><code class="n">values</code>&#13;
        <code class="p">.</code><code class="n">averageBy</code> <code class="p">{</code> <code class="n">it</code><code class="p">.</code><code class="n">size</code> <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=13.25&amp;show=file">Example 13.25 [streams-to-sequences.13:src/main/java/travelator/analytics/MarketingAnalytics.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=13.25&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>It looks like the part starting with <code>flatMap</code> and ending before <code>groupBy</code> might standalone.&#13;
Let’s see how to extract part of a pipeline into its own function.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Extracting Part of a Pipeline" data-type="sect2"><div class="sect2" id="extracting-part-of-a-pipeline">&#13;
<h2>Extracting Part of a Pipeline</h2>&#13;
&#13;
<p>First we select from the start of the pipeline to the last stage we want to include, so from <code>eventStore</code> up to but not including <code>.groupBy</code>.&#13;
“Extract Function”, calling it (in this case) <code>allEventsInSameInteractions</code>:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">averageNumberOfEventsPerCompletedBooking</code><code class="p">(</code>&#13;
    <code class="n">timeRange</code><code class="p">:</code> <code class="n">String</code>&#13;
<code class="p">):</code> <code class="n">Double</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="n">allEventsInSameInteractions</code><code class="p">(</code><code class="n">timeRange</code><code class="p">)</code>&#13;
        <code class="p">.</code><code class="n">groupBy</code> <code class="p">{</code> <code class="n">event</code> <code class="p">-&gt;</code>&#13;
            <code class="n">event</code><code class="p">[</code><code class="s">"interactionId"</code><code class="p">]</code> <code class="k">as</code> <code class="n">String</code>&#13;
        <code class="p">}.</code><code class="n">values</code>&#13;
        <code class="p">.</code><code class="n">averageBy</code> <code class="p">{</code> <code class="n">it</code><code class="p">.</code><code class="n">size</code> <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="k">private</code> <code class="k">fun</code> <code class="nf">allEventsInSameInteractions</code><code class="p">(</code><code class="n">timeRange</code><code class="p">:</code> <code class="n">String</code><code class="p">)</code> <code class="p">=</code> <code class="n">eventStore</code>&#13;
    <code class="p">.</code><code class="n">queryAsSequence</code><code class="p">(</code><code class="s">"type=CompletedBooking&amp;timerange=$timeRange"</code><code class="p">)</code>&#13;
    <code class="p">.</code><code class="n">flatMap</code> <code class="p">{</code> <code class="n">event</code> <code class="p">-&gt;</code>&#13;
        <code class="k">val</code> <code class="py">interactionId</code> <code class="p">=</code> <code class="n">event</code><code class="p">[</code><code class="s">"interactionId"</code><code class="p">]</code> <code class="k">as</code> <code class="n">String</code>&#13;
        <code class="n">eventStore</code>&#13;
            <code class="p">.</code><code class="n">queryAsSequence</code><code class="p">(</code><code class="s">"interactionId=$interactionId"</code><code class="p">)</code>&#13;
    <code class="p">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=13.26&amp;show=file">Example 13.26 [streams-to-sequences.14:src/main/java/travelator/analytics/MarketingAnalytics.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=13.26&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>Now we select the bits of the pipeline that we don’t want in the new function, so <code>e⁠v⁠e⁠n⁠t​S⁠t⁠o⁠r⁠e</code> to before <code>.flatMap</code>, and “Introduce Parameter”.&#13;
Accept any name that IntelliJ chooses—it won’t live long:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">averageNumberOfEventsPerCompletedBooking</code><code class="p">(</code>&#13;
    <code class="n">timeRange</code><code class="p">:</code> <code class="n">String</code>&#13;
<code class="p">):</code> <code class="n">Double</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="n">allEventsInSameInteractions</code><code class="p">(</code>&#13;
        <code class="n">eventStore</code>&#13;
            <code class="p">.</code><code class="n">queryAsSequence</code><code class="p">(</code><code class="s">"type=CompletedBooking&amp;timerange=$timeRange"</code><code class="p">)</code>&#13;
    <code class="p">)</code>&#13;
        <code class="p">.</code><code class="n">groupBy</code> <code class="p">{</code> <code class="n">event</code> <code class="p">-&gt;</code>&#13;
            <code class="n">event</code><code class="p">[</code><code class="s">"interactionId"</code><code class="p">]</code> <code class="k">as</code> <code class="n">String</code>&#13;
        <code class="p">}.</code><code class="n">values</code>&#13;
        <code class="p">.</code><code class="n">averageBy</code> <code class="p">{</code> <code class="n">it</code><code class="p">.</code><code class="n">size</code> <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="k">private</code> <code class="k">fun</code> <code class="nf">allEventsInSameInteractions</code><code class="p">(</code>&#13;
    <code class="n">sequence</code><code class="p">:</code> <code class="n">Sequence</code><code class="p">&lt;</code><code class="n">MutableMap</code><code class="p">&lt;</code><code class="n">String</code><code class="p">,</code> <code class="n">Any</code><code class="p">?&gt;&gt;</code>&#13;
<code class="p">)</code> <code class="p">=</code> <code class="n">sequence</code>&#13;
    <code class="p">.</code><code class="n">flatMap</code> <code class="p">{</code> <code class="n">event</code> <code class="p">-&gt;</code>&#13;
        <code class="k">val</code> <code class="py">interactionId</code> <code class="p">=</code> <code class="n">event</code><code class="p">[</code><code class="s">"interactionId"</code><code class="p">]</code> <code class="k">as</code> <code class="n">String</code>&#13;
        <code class="n">eventStore</code>&#13;
            <code class="p">.</code><code class="n">queryAsSequence</code><code class="p">(</code><code class="s">"interactionId=$interactionId"</code><code class="p">)</code>&#13;
    <code class="p">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=13.27&amp;show=file">Example 13.27 [streams-to-sequences.15:src/main/java/travelator/analytics/MarketingAnalytics.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=13.27&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>That’s really ugly, but once we convert the <code>sequence</code> parameter of <code>allEventsInSame​In⁠teractions</code> to a receiver and reformat, we have:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">averageNumberOfEventsPerCompletedBooking</code><code class="p">(</code>&#13;
    <code class="n">timeRange</code><code class="p">:</code> <code class="n">String</code>&#13;
<code class="p">):</code> <code class="n">Double</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="n">eventStore</code>&#13;
        <code class="p">.</code><code class="n">queryAsSequence</code><code class="p">(</code><code class="s">"type=CompletedBooking&amp;timerange=$timeRange"</code><code class="p">)</code>&#13;
        <code class="p">.</code><code class="n">allEventsInSameInteractions</code><code class="p">()</code>&#13;
        <code class="p">.</code><code class="n">groupBy</code> <code class="p">{</code> <code class="n">event</code> <code class="p">-&gt;</code>&#13;
            <code class="n">event</code><code class="p">[</code><code class="s">"interactionId"</code><code class="p">]</code> <code class="k">as</code> <code class="n">String</code>&#13;
        <code class="p">}.</code><code class="n">values</code>&#13;
        <code class="p">.</code><code class="n">averageBy</code> <code class="p">{</code> <code class="n">it</code><code class="p">.</code><code class="n">size</code> <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="k">fun</code> <code class="nf">Sequence</code><code class="p">&lt;</code><code class="n">Map</code><code class="p">&lt;</code><code class="n">String</code><code class="p">,</code> <code class="n">Any</code><code class="p">?&gt;&gt;.</code><code class="n">allEventsInSameInteractions</code><code class="p">()</code> <code class="p">=</code>&#13;
    <code class="n">flatMap</code> <code class="p">{</code> <code class="n">event</code> <code class="p">-&gt;</code>&#13;
        <code class="k">val</code> <code class="py">interactionId</code> <code class="p">=</code> <code class="n">event</code><code class="p">[</code><code class="s">"interactionId"</code><code class="p">]</code> <code class="k">as</code> <code class="n">String</code>&#13;
        <code class="n">eventStore</code>&#13;
            <code class="p">.</code><code class="n">queryAsSequence</code><code class="p">(</code><code class="s">"interactionId=$interactionId"</code><code class="p">)</code>&#13;
    <code class="p">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=13.28&amp;show=file">Example 13.28 [streams-to-sequences.16:src/main/java/travelator/analytics/MarketingAnalytics.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=13.28&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>As we discussed in <a data-type="xref" href="ch10.html#functions-to-extension-functions">Chapter 10</a>, extension functions really come into their own when we are chaining operations.&#13;
In Java, we couldn’t extend the Streams API with &#13;
<span class="keep-together"><code>allEventsInSameInteractions()</code></span>, so we ended up breaking the chain, either by calling a function or by introducing an explaining variable.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Final Tidy" data-type="sect2"><div class="sect2" id="idm46393380838936">&#13;
<h2>Final Tidy</h2>&#13;
&#13;
<p>This is still a little clunky, and we could probably make it more efficient by not creating lists in the grouping, but that will do.&#13;
Oh, except for a wafer-thin type alias and extension property:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">typealias</code> <code class="n">Event</code> <code class="p">=</code> <code class="n">Map</code><code class="p">&lt;</code><code class="n">String</code><code class="p">,</code> <code class="n">Any</code><code class="p">?&gt;</code>&#13;
&#13;
<code class="k">val</code> <code class="py">Event</code><code class="p">.</code><code class="n">interactionId</code><code class="p">:</code> <code class="n">String</code><code class="p">?</code> <code class="k">get</code><code class="p">()</code> <code class="p">=</code>&#13;
    <code class="k">this</code><code class="p">[</code><code class="s">"interactionId"</code><code class="p">]</code> <code class="k">as</code><code class="p">?</code> <code class="n">String</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=13.29&amp;show=file">Example 13.29 [streams-to-sequences.17:src/main/java/travelator/analytics/MarketingAnalytics.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=13.29&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>This lets us concentrate on the hard stuff when we read the code:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">MarketingAnalytics</code><code class="p">(</code>&#13;
    <code class="k">private</code> <code class="k">val</code> <code class="py">eventStore</code><code class="p">:</code> <code class="n">EventStore</code>&#13;
<code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">fun</code> <code class="nf">averageNumberOfEventsPerCompletedBooking</code><code class="p">(</code>&#13;
        <code class="n">timeRange</code><code class="p">:</code> <code class="n">String</code>&#13;
    <code class="p">):</code> <code class="n">Double</code> <code class="p">=</code> <code class="n">eventStore</code>&#13;
        <code class="p">.</code><code class="n">queryAsSequence</code><code class="p">(</code><code class="s">"type=CompletedBooking&amp;timerange=$timeRange"</code><code class="p">)</code>&#13;
        <code class="p">.</code><code class="n">allEventsInSameInteractions</code><code class="p">()</code>&#13;
        <code class="p">.</code><code class="n">groupBy</code><code class="p">(</code><code class="n">Event</code><code class="o">::</code><code class="n">interactionId</code><code class="p">)</code>&#13;
        <code class="p">.</code><code class="n">values</code>&#13;
        <code class="p">.</code><code class="n">averageBy</code> <code class="p">{</code> <code class="n">it</code><code class="p">.</code><code class="n">size</code> <code class="p">}</code>&#13;
&#13;
    <code class="k">private</code> <code class="k">fun</code> <code class="nf">Sequence</code><code class="p">&lt;</code><code class="n">Event</code><code class="p">&gt;.</code><code class="n">allEventsInSameInteractions</code><code class="p">()</code> <code class="p">=</code>&#13;
        <code class="n">flatMap</code> <code class="p">{</code> <code class="n">event</code> <code class="p">-&gt;</code>&#13;
            <code class="n">eventStore</code><code class="p">.</code><code class="n">queryAsSequence</code><code class="p">(</code>&#13;
                <code class="s">"interactionId=${event.interactionId}"</code>&#13;
            <code class="p">)</code>&#13;
        <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="n">inline</code> <code class="k">fun</code> <code class="err">&lt;</code><code class="nf">T</code><code class="p">&gt;</code> <code class="n">Collection</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;.</code><code class="n">averageBy</code><code class="p">(</code><code class="n">selector</code><code class="p">:</code> <code class="p">(</code><code class="n">T</code><code class="p">)</code> <code class="p">-&gt;</code> <code class="n">Int</code><code class="p">):</code> <code class="n">Double</code> <code class="p">=</code>&#13;
    <code class="n">sumBy</code><code class="p">(</code><code class="n">selector</code><code class="p">)</code> <code class="p">/</code> <code class="n">size</code><code class="p">.</code><code class="n">toDouble</code><code class="p">()</code>&#13;
&#13;
<code class="k">fun</code> <code class="nf">EventStore</code><code class="p">.</code><code class="n">queryAsSequence</code><code class="p">(</code><code class="n">query</code><code class="p">:</code> <code class="n">String</code><code class="p">)</code> <code class="p">=</code>&#13;
    <code class="k">this</code><code class="p">.</code><code class="n">queryAsStream</code><code class="p">(</code><code class="n">query</code><code class="p">).</code><code class="n">asSequence</code><code class="p">()</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=13.30&amp;show=file">Example 13.30 [streams-to-sequences.17:src/main/java/travelator/analytics/MarketingAnalytics.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=13.30&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>In passing, note that <code>allEventsInSameInteractions</code> is an example of an extension function as method that we discussed in <a data-type="xref" href="ch10.html#functions-to-extension-functions">Chapter 10</a>.&#13;
It has access to both <code>this</code> from &#13;
<span class="keep-together"><code>MarketingAnalytics</code></span> (to access <code>eventStore</code>) and <code>this</code> from <code>Sequence&lt;Event&gt;</code>.<a data-primary="" data-startref="SISrefact13" data-type="indexterm" id="idm46393380207432"/><a data-primary="" data-startref="Rstreams13" data-type="indexterm" id="idm46393380206424"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Moving On" data-type="sect1"><div class="sect1" id="idm46393382854248">&#13;
<h1>Moving On</h1>&#13;
&#13;
<p>We aren’t going to claim that the refactored Kotlin code in this example is beautiful, but we do think that it is a significant improvement on the original Java.&#13;
Extension functions, Kotlin’s lambda syntax, and improved type inference combine to reduce a lot of the noise associated with Java streams.&#13;
When we have in-memory collections, using iterables rather than streams can also be more efficient as well as cleaner.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>