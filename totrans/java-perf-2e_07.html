<html><head></head><body><section data-pdf-bookmark="Chapter 7. Heap Memory Best Practices" data-type="chapter" epub:type="chapter"><div class="chapter" id="Memory">&#13;
<h1><span class="label">Chapter 7. </span>Heap Memory Best Practices</h1>&#13;
&#13;
&#13;
<p><a data-primary="heap memory" data-type="indexterm" id="ix_ch07-asciidoc0"/>Chapters <a data-type="xref" data-xrefstyle="select: labelnumber" href="ch05.html#GC">5</a> and <a data-type="xref" data-xrefstyle="select: labelnumber" href="ch06.html#Collectors">6</a> discussed the details of how to tune the garbage collector&#13;
so that it has as little effect on a program as possible. Tuning the&#13;
garbage collector is important, but often better performance&#13;
gains can be made by utilizing better programming practices. This&#13;
chapter discusses some of the best-practice approaches to using heap memory in Java.</p>&#13;
&#13;
<p>We have two conflicting goals here. The first general rule is to&#13;
create objects sparingly and to discard them as quickly as possible.&#13;
Using less memory is the best way to improve the efficiency of the garbage collector. On the other hand, frequently re-creating some kinds of objects can lead to worse overall performance (even if GC performance improves). If those objects are instead reused, programs can see substantial performance gains.&#13;
Objects can be reused in a variety of ways, including&#13;
thread-local variables, special object references, and object pools.&#13;
Reusing objects means they will be long-lived and impact the garbage&#13;
collector, but when they are reused judiciously, overall performance will&#13;
improve.</p>&#13;
&#13;
<p>This chapter discusses both approaches and the trade-offs between them.&#13;
First, though, we’ll look into tools for understanding what is happening&#13;
inside the heap.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Heap Analysis" data-type="sect1"><div class="sect1" id="heap_analysis">&#13;
<h1>Heap Analysis</h1>&#13;
&#13;
<p><a data-primary="heap analysis" data-type="indexterm" id="ix_ch07-asciidoc1"/><a data-primary="heap memory" data-secondary="heap analysis" data-type="indexterm" id="ix_ch07-asciidoc2"/>GC logs and the tools discussed in <a data-type="xref" href="ch05.html#GC">Chapter 5</a> are great at understanding the&#13;
impact GC has on an application,&#13;
but for additional visibility, we must look into&#13;
the heap itself. The tools discussed in this section provide insight into&#13;
the objects that the application is currently using.</p>&#13;
&#13;
<p>Most of the time, these tools operate only on live objects in the heap—objects that will be reclaimed during the next full GC cycle are not included&#13;
in the tools’ output. In some cases, tools accomplish that by forcing a&#13;
full GC, so the application behavior can be affected after the tool is used.&#13;
In other cases, the tools walk through the heap and report live data without&#13;
freeing objects along the way. In either case, though, the tools require&#13;
time and machine resources; they are generally not useful during&#13;
measurement of a program’s execution.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Heap Histograms" data-type="sect2"><div class="sect2" id="idm45775553552616">&#13;
<h2>Heap Histograms</h2>&#13;
&#13;
<p><a data-primary="heap analysis" data-secondary="heap histograms" data-type="indexterm" id="idm45775553551016"/><a data-primary="heap histograms" data-type="indexterm" id="idm45775553550040"/><a data-primary="histograms" data-type="indexterm" id="idm45775553549368"/>Reducing memory use is an important goal, but as with most performance topics,&#13;
it helps to target efforts to maximize the available benefits. Later in this&#13;
chapter, you’ll see an example around&#13;
lazily initializing a&#13;
<span class="keep-together"><code>Calendar</code></span>&#13;
object. That will save 640 bytes in the heap, but&#13;
if the application always initializes one such object, no measurable difference in performance will occur. Analysis must be performed to know which&#13;
kinds of objects are consuming large amounts of memory.</p>&#13;
&#13;
<p>The easiest way to do that is via a <em>heap histogram</em>.&#13;
Histograms are a quick way to look at the number of objects within an&#13;
application without doing a full heap dump (since heap dumps can take a&#13;
while to analyze, and they consume a large amount of disk space).&#13;
If a few particular object types are responsible for creating memory pressure&#13;
in an application, a heap histogram is a quick way to find that.</p>&#13;
&#13;
<p>Heap histograms can be obtained by using <code>jcmd</code> (here with process ID 8898):</p>&#13;
<pre data-type="programlisting">&#13;
% <strong>jcmd 8998 GC.class_histogram</strong>&#13;
8898:&#13;
&#13;
 num     #instances         #bytes  class name&#13;
----------------------------------------------&#13;
   1:        789087       31563480  java.math.BigDecimal&#13;
   2:        172361       14548968  [C&#13;
   3:         13224       13857704  [B&#13;
   4:        184570        5906240  java.util.HashMap$Node&#13;
   5:         14848        4188296  [I&#13;
   6:        172720        4145280  java.lang.String&#13;
   7:         34217        3127184  [Ljava.util.HashMap$Node;&#13;
   8:         38555        2131640  [Ljava.lang.Object;&#13;
   9:         41753        2004144  java.util.HashMap&#13;
  10:         16213        1816472  java.lang.Class&#13;
</pre>&#13;
&#13;
<p>In a histogram, we can usually expect to see&#13;
character arrays (<code>[C</code>) and <code>String</code> objects near&#13;
the top, as these are the most commonly created Java objects. Byte arrays (<code>[B</code>)&#13;
and object arrays&#13;
<span class="keep-together">(<code>[Ljava.lang.Object;</code>)</span>&#13;
are also common, since&#13;
classloaders store their data in those structures. If you’re unfamiliar with this syntax, it is described in the Java Native Interface (JNI) documentation.</p>&#13;
&#13;
<p>In this example, the&#13;
inclusion of the&#13;
<span class="keep-together"><code>BigDecimal</code></span>&#13;
class is something to pursue: we know the sample code produces a lot&#13;
of transient&#13;
<span class="keep-together"><code>BigDecimal</code></span>&#13;
objects, but having so many stay around in the heap&#13;
is not what we might ordinarily expect. The output from&#13;
<span class="keep-together"><code>GC.class_histogram</code></span>&#13;
includes only live&#13;
objects, as the command normally forces a full GC. You can include the&#13;
<code>-all</code> flag in the command to skip the full GC, though then the histogram&#13;
contains unreferenced (garbage) objects.</p>&#13;
&#13;
<p>Similar output is available by running this command:</p>&#13;
<pre data-type="programlisting">&#13;
% <strong>jmap -histo process_id</strong>&#13;
</pre>&#13;
&#13;
<p>The output from <code>jmap</code> includes objects that are eligible to be collected (dead&#13;
objects).&#13;
To force a full GC prior to seeing the histogram, run this command instead:</p>&#13;
<pre data-type="programlisting">&#13;
% <strong>jmap -histo:live process_id</strong>&#13;
</pre>&#13;
&#13;
<p>Histograms are small, so gathering one for every test in an automated&#13;
system can be helpful. Still, because they take a few seconds to obtain&#13;
and trigger a full GC,&#13;
they should not be taken during a performance measurement steady state.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Heap Dumps" data-type="sect2"><div class="sect2" id="idm45775553552056">&#13;
<h2>Heap Dumps</h2>&#13;
&#13;
<p><a data-primary="heap analysis" data-secondary="heap dumps" data-type="indexterm" id="ix_ch07-asciidoc3"/><a data-primary="heap dumps" data-type="indexterm" id="ix_ch07-asciidoc4"/>Histograms are great at identifying issues caused by allocating too many&#13;
instances of one or two particular classes, but for deeper analysis, a&#13;
<em>heap dump</em> is required.&#13;
Many tools can look at heap&#13;
dumps, and most of them can connect to a live program to generate the dump.&#13;
It is often easier to generate the dump from the command line,&#13;
which can be done with either of the following&#13;
commands:</p>&#13;
<pre data-type="programlisting">&#13;
% <strong>jcmd process_id GC.heap_dump /path/to/heap_dump.hprof</strong>&#13;
</pre>&#13;
&#13;
<p>or</p>&#13;
<pre data-type="programlisting">&#13;
% <strong>jmap -dump:live,file=/path/to/heap_dump.hprof process_id</strong>&#13;
</pre>&#13;
&#13;
<p>Including the <code>live</code> option in <code>jmap</code> will force a full GC to occur before the&#13;
heap is dumped. That is the default&#13;
for <code>jcmd</code>,&#13;
though if for some reason you want those other (dead) objects&#13;
included, you can specify&#13;
<span class="keep-together"><code>-all</code></span>&#13;
at the end of the <code>jcmd</code>&#13;
command line. If you use the command in a way that forces a full GC, that will&#13;
obviously introduce a long pause into the application, but even if you don’t&#13;
force a full GC, the application will be paused for the time it takes to&#13;
write the heap dump.</p>&#13;
&#13;
<p>Either command creates a file named <em>heap_dump.hprof</em> in the given&#13;
directory; various tools can then be used to open that file.&#13;
The most common of these are as follows:</p>&#13;
<dl>&#13;
<dt><code>jvisualvm</code></dt>&#13;
<dd>&#13;
<p><a data-primary="jvisualvm" data-type="indexterm" id="idm45775553518440"/>The Monitor tab of&#13;
<span class="keep-together"><code>jvisualvm</code></span>&#13;
can take a heap dump from a running program or open a previously produced heap dump. From there, you can browse through the heap, examining the largest retained objects and executing arbitrary queries against the heap.</p>&#13;
</dd>&#13;
</dl>&#13;
<dl class="pagebreak-before">&#13;
<dt><code>mat</code></dt>&#13;
<dd>&#13;
<p><a data-primary="EclipseLink Memory Analyzer Tool (mat)" data-type="indexterm" id="idm45775553514328"/><a data-primary="mat" data-type="indexterm" id="idm45775553513560"/><a data-primary="Memory Analyzer Tool (mat)" data-type="indexterm" id="idm45775553512888"/>The open source EclipseLink Memory Analyzer tool (<code>mat</code>) can load one or more heap dumps and perform analysis on them. It can produce reports that suggest where problems are likely to be found, and it too can be used to browse through the heap and execute SQL-like queries into the heap.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>The first-pass analysis of a heap generally involves retained memory.&#13;
The retained memory of an object&#13;
is the amount of memory that would be freed if the object itself were eligible&#13;
to be collected. In <a data-type="xref" href="#FigureRetainedMemory">Figure 7-1</a>, the retained memory of the&#13;
String Trio object includes the memory occupied by that object&#13;
as well as the memory occupied by the Sally and David objects. It does not&#13;
include the memory used by the Michael object, since that object has another&#13;
reference and won’t be eligible for GC if the String Trio&#13;
is freed.</p>&#13;
&#13;
<figure><div class="figure" id="FigureRetainedMemory">&#13;
<img alt="Object graph showing that some objects have multiple references to them." src="assets/jp2e_0701.png"/>&#13;
<h6><span class="label">Figure 7-1. </span>Object graph of retained memory</h6>&#13;
</div></figure>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45775553507272">&#13;
<h5>Shallow, Retained, and Deep Object Sizes</h5>&#13;
<p><a data-primary="deep object size" data-type="indexterm" id="idm45775553506040"/><a data-primary="shallow object size" data-type="indexterm" id="idm45775553505336"/>Two other useful terms for memory analysis are <em>shallow</em> and <em>deep</em>. The <em>shallow size</em>&#13;
of an object is the size of the object itself. If the object contains a reference&#13;
to another object, the 4 or 8 bytes of the reference is included, but the&#13;
size of the target object is not included.</p>&#13;
&#13;
<p>The <em>deep size</em> of an object includes the size of the object it references. The difference&#13;
between the deep size of an object and the retained memory of an object lies in&#13;
objects that are otherwise shared. In <a data-type="xref" href="#FigureRetainedMemory">Figure 7-1</a>, the deep size of&#13;
the Flute Duo object includes the space consumed by the Michael object, whereas&#13;
the retained size of the Flute Duo object does not.</p>&#13;
</div></aside>&#13;
&#13;
<p><a data-primary="dominators (memory)" data-type="indexterm" id="idm45775553500536"/>Objects that retain a large amount of heap space are&#13;
often called the <em>dominators</em> of the heap.&#13;
If the heap analysis tool shows that a few objects dominate&#13;
the bulk of the heap, things are easy: all you need to do is&#13;
create fewer of them, retain them for a shorter period&#13;
of time, simplify their object graph, or make them smaller.&#13;
That may be easier said than done, but at least&#13;
the analysis is simple.</p>&#13;
&#13;
<p>More commonly, detective work will be necessary because the&#13;
program is likely sharing objects. Like the Michael object in&#13;
the previous figure, those shared objects are not counted in the retained set&#13;
of any other object, since freeing one individual object will not free the&#13;
shared object. Also, the largest retained sizes are often&#13;
classloaders over which you have little&#13;
control.&#13;
As an extreme example, <a data-type="xref" href="#FigureRetainedMatDump">Figure 7-2</a> shows the top retained objects of a heap from a&#13;
version of the stock server that caches items&#13;
strongly based on a client connection, and weakly in a global hash map (so that the&#13;
cached items have multiple references).</p>&#13;
&#13;
<figure><div class="figure" id="FigureRetainedMatDump">&#13;
<img alt="Memory Analyzer chart showing the top objects that retain memory." src="assets/jp2e_0702.png"/>&#13;
<h6><span class="label">Figure 7-2. </span>Retained Memory view in Memory Analyzer</h6>&#13;
</div></figure>&#13;
&#13;
<p>The heap contains 1.4 GB of objects (that value doesn’t appear on&#13;
this tab). Even so, the largest set of objects&#13;
that is referenced singly is only 6 MB (and is, unsurprisingly, part of&#13;
the&#13;
classloading framework). Looking at the objects that directly retain&#13;
the largest amount of memory isn’t going to solve the memory issues.</p>&#13;
&#13;
<p>This example shows multiple instances&#13;
of&#13;
<span class="keep-together"><code>StockPriceHistoryImpl</code></span>&#13;
objects in this list, each of which retains a fair amount of&#13;
memory. It can be deduced from the amount of memory consumed&#13;
by those objects that they&#13;
are the issue. In the general case, though, objects might be shared&#13;
in such a way that looking at the retained heap won’t show anything obvious.</p>&#13;
&#13;
<p>The histogram of objects is a useful second step (see <a data-type="xref" href="#FigureMatHisto">Figure 7-3</a>).</p>&#13;
&#13;
<figure><div class="figure" id="FigureMatHisto">&#13;
<img alt="Histogram of the objects in the stock server application." src="assets/jp2e_0703.png"/>&#13;
<h6><span class="label">Figure 7-3. </span>Histogram view in Memory Analyzer</h6>&#13;
</div></figure>&#13;
&#13;
<p>The histogram aggregates objects of the same type, and in this example&#13;
it is much more apparent that the 1.4 GB of memory retained by the seven&#13;
million&#13;
<span class="keep-together"><code>TreeMap$Entry</code></span>&#13;
objects is the key here.&#13;
Even without knowing what is going on in the program, it is&#13;
straightforward enough&#13;
to use the Memory Analyzer’s facility to trace those objects to see what&#13;
is holding onto them.</p>&#13;
&#13;
<p>Heap analysis tools provide a way to find the GC roots of&#13;
a particular object (or set of objects in this case)—though jumping&#13;
directly to the GC roots isn’t necessarily helpful. The GC roots are the&#13;
system objects that hold a static, global reference that (through a long&#13;
chain of other objects) refers to the object in question. Typically, these&#13;
come from the static variables of a class loaded on the system or&#13;
bootstrap classpath. This includes the&#13;
<span class="keep-together"><code>Thread</code></span>&#13;
class and all active threads;&#13;
threads retain objects either through their thread-local variables or through&#13;
references via their target&#13;
<span class="keep-together"><code>Runnable</code></span>&#13;
object (or, in the case of a subclass&#13;
of the&#13;
<span class="keep-together"><code>Thread</code></span>&#13;
class, any other references the subclass has).</p>&#13;
&#13;
<p>In some cases, knowing the GC roots of a target object is helpful, but if the&#13;
object has multiple references, it will have many GC roots. The references&#13;
here are a tree structure in reverse. Say that two objects refer&#13;
to a particular&#13;
<span class="keep-together"><code>TreeMap$Entry</code></span>&#13;
object. Each of those objects may be referred&#13;
to by two other objects, each of which may be referred to by three other&#13;
objects, and so on. The explosion of references as the roots are traced back&#13;
means that multiple GC roots likely exist for any given object.</p>&#13;
&#13;
<p>Instead, it can be more fruitful to play detective and find the lowest&#13;
point in the object graph where the target object is shared. This is done&#13;
by examining the objects and their incoming references and tracing those&#13;
incoming references until the duplicate path is identified. In this case,&#13;
references to the&#13;
<span class="keep-together"><code>StockPriceHistoryImpl</code></span>&#13;
objects held in the tree map have&#13;
two referents: the&#13;
<span class="keep-together"><code>ConcurrentHashMap</code></span>,&#13;
which holds attribute data for the&#13;
session, and the&#13;
<span class="keep-together"><code>WeakHashMap</code></span>,&#13;
which holds the global cache.</p>&#13;
&#13;
<p>In <a data-type="xref" href="#FigureMatTrace">Figure 7-4</a>, the back traces are expanded enough to show only a&#13;
little data about the two of them. The way to conclude that it is the session&#13;
data is to continue to expand the&#13;
<span class="keep-together"><code>ConcurrentHashMap</code></span>&#13;
path until it becomes&#13;
clear that path is the session data. A similar logic applies to the&#13;
path for the&#13;
<span class="keep-together"><code>WeakHashMap</code>.</span></p>&#13;
&#13;
<figure><div class="figure" id="FigureMatTrace">&#13;
<img alt="Each TreeMap Object is referred to by two other objects." src="assets/jp2e_0704.png"/>&#13;
<h6><span class="label">Figure 7-4. </span>Back traces of object references in Memory Analyzer</h6>&#13;
</div></figure>&#13;
&#13;
<p>The object types used in this example made the analysis a little easier than&#13;
is often the case. If the primary data in this application had been modeled as&#13;
<span class="keep-together"><code>String</code></span>&#13;
objects&#13;
instead of&#13;
<span class="keep-together"><code>BigDecimal</code></span>&#13;
objects, and stored in&#13;
<span class="keep-together"><code>HashMap</code></span>&#13;
objects instead&#13;
of&#13;
<span class="keep-together"><code>TreeMap</code></span>&#13;
objects, things&#13;
would have been more difficult. Hundreds of thousands of other&#13;
strings and tens of thousands of other <code>HashMap</code> objects are in the heap dump. Finding&#13;
paths to the interesting objects, then, takes some patience. As a&#13;
general rule of thumb, start with collection objects&#13;
(e.g.,&#13;
<span class="keep-together"><code>HashMap</code>)</span>&#13;
rather than&#13;
the entries&#13;
(e.g.,&#13;
<span class="keep-together"><code>HashMap$Entry</code>)</span>,&#13;
and look for the biggest collections.</p>&#13;
<div data-type="tip"><h1>Quick Summary</h1>&#13;
<ul>&#13;
<li>&#13;
<p>Knowing which objects are consuming memory is the first step in knowing which objects to optimize in your code.</p>&#13;
</li>&#13;
<li>&#13;
<p>Histograms are a quick and easy way to identify memory issues caused by creating too many objects of a certain type.</p>&#13;
</li>&#13;
<li>&#13;
<p>Heap dump analysis is the most powerful technique to track down memory usage, though it requires patience and effort to be utilized well.<a data-startref="ix_ch07-asciidoc4" data-type="indexterm" id="idm45775553462664"/><a data-startref="ix_ch07-asciidoc3" data-type="indexterm" id="idm45775553461960"/></p>&#13;
</li>&#13;
</ul>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Out-of-Memory Errors" data-type="sect2"><div class="sect2" id="OOMError">&#13;
<h2>Out-of-Memory Errors</h2>&#13;
&#13;
<p><a data-primary="heap analysis" data-secondary="out-of-memory errors" data-type="indexterm" id="ix_ch07-asciidoc5"/><a data-primary="out-of-memory errors" data-type="indexterm" id="ix_ch07-asciidoc6"/>The JVM throws an <em>out-of-memory</em> error under these circumstances:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>No native memory is available for the JVM.</p>&#13;
</li>&#13;
<li>&#13;
<p>The metaspace is out of memory.</p>&#13;
</li>&#13;
<li>&#13;
<p>The Java heap itself is out of memory: the application cannot create any additional objects for the given heap size.</p>&#13;
</li>&#13;
<li>&#13;
<p>The JVM is spending too much time performing GC.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>The last two cases—involving the Java heap itself—are more common, but don’t automatically conclude from an out-of-memory error that the&#13;
heap is the problem. It is necessary to look at why the out-of-memory error occurred (that reason is part of the output of&#13;
the exception).</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Out of native memory" data-type="sect3"><div class="sect3" id="idm45775553451896">&#13;
<h3>Out of native memory</h3>&#13;
&#13;
<p><a data-primary="native memory" data-secondary="out-of-native-memory error" data-type="indexterm" id="idm45775553450456"/><a data-primary="out-of-memory errors" data-secondary="out of native memory" data-type="indexterm" id="idm45775553449416"/>The first case in this list—no native memory available for the JVM—occurs for reasons unrelated to the heap at all. In a 32-bit JVM, the&#13;
maximum size of a process is 4 GB (3 GB on some versions of Windows, and&#13;
about 3.5 GB on some older versions of Linux). Specifying a very large&#13;
heap—say, 3.8 GB—brings the application size dangerously close to that&#13;
limit. Even in a 64-bit JVM, the operating system may not have sufficient&#13;
virtual memory for whatever the JVM requests.</p>&#13;
&#13;
<p>This topic is addressed more fully in <a data-type="xref" href="ch08.html#NativeMemory">Chapter 8</a>. Be aware that if the&#13;
message for the out-of-memory error discusses allocation of native memory, heap tuning isn’t the answer: you need to look into whatever native memory&#13;
issue is mentioned in the error. For example, the following message tells you&#13;
that the native memory for thread stacks is exhausted:</p>&#13;
&#13;
<pre data-type="programlisting">Exception in thread "main" java.lang.OutOfMemoryError:&#13;
unable to create new native thread</pre>&#13;
&#13;
<p>However, be aware that the JVM will sometimes issue this error for things&#13;
that have nothing to do with memory. Users usually have constraints on the&#13;
number of threads they can run; this constraint can be imposed by the OS&#13;
or by a container. For example, in Linux, users are often allowed to create&#13;
only 1,024 processes (a value you can check by running <code>ulimit -u</code>). The&#13;
attempt to create a 1,025th thread will throw that same <code>OutOfMemoryError</code>,&#13;
claiming insufficient memory to create the native thread, when in&#13;
reality, the OS limit on the number of processes caused the error.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="Out of metaspace memory" data-type="sect3"><div class="sect3" id="idm45775553443576">&#13;
<h3>Out of metaspace memory</h3>&#13;
&#13;
<p><a data-primary="metaspace" data-secondary="out-of-metaspace-memory error" data-type="indexterm" id="idm45775553441960"/><a data-primary="out-of-memory errors" data-secondary="out-of-metaspace-memory error" data-type="indexterm" id="idm45775553440968"/>An out-of-metaspace memory error is also not associated with the heap—it occurs because&#13;
the metaspace native memory is full. Because metaspace has no maximum size&#13;
by default, this error typically occurs because you’ve chosen to set the&#13;
maximum size (and the reason for doing so will become clear in this section).</p>&#13;
&#13;
<p>This error can have two root causes:&#13;
The first is simply that the application uses more classes&#13;
than can fit in the metaspace you’ve assigned (see <a data-type="xref" href="ch05.html#GCMetaSpace">“Sizing Metaspace”</a>). The second case is trickier: it involves a classloader memory leak. This&#13;
occurs most frequently in a server that loads classes dynamically. One such&#13;
example is a Java EE application server. Each application&#13;
that is deployed to an app server runs in its own classloader (which provides&#13;
isolation so that classes from one application are not shared with—and&#13;
do not interfere with—classes from another application). In development, each&#13;
time the application is changed, it must be redeployed: a new classloader&#13;
is created to load the new classes, and the old classloader is allowed to&#13;
go out of scope. Once the classloader goes out of scope, the class&#13;
metadata can be collected.</p>&#13;
&#13;
<p>If the old classloader does not go out of scope, the class&#13;
metadata cannot be freed, and eventually the metaspace will fill up and&#13;
throw an out-of-memory error. In this case, increasing the size of the metaspace&#13;
will help, but ultimately that will simply postpone the error.</p>&#13;
&#13;
<p>If this situation occurs in an app server&#13;
environment, there is little to do but contact the app server vendor and get&#13;
them to fix the leak. If you are writing your own application that creates&#13;
and discards lots of classloaders, ensure that the class&#13;
loaders themselves are discarded correctly (in particular, make sure that&#13;
no thread sets its context classloader to one of the temporary classloaders).&#13;
To debug this situation, the heap dump analysis just described is helpful: in the histogram, find all the instances of the&#13;
<span class="keep-together"><code>ClassLoader</code></span>&#13;
class,&#13;
and trace their GC roots to see what is holding onto them.</p>&#13;
&#13;
<p>The key to recognizing this situation is again the full-text output of the&#13;
out-of-memory error. If the metaspace is full, the error text&#13;
will appear like this:</p>&#13;
&#13;
<pre data-type="programlisting">Exception in thread "main" java.lang.OutOfMemoryError: Metaspace</pre>&#13;
&#13;
<p>Classloader leaks, by the way, are the reason you should consider setting&#13;
the maximum size of the metaspace. Left unbounded, a system with a&#13;
classloader leak will consume all the memory on your machine.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Out-of-heap memory" data-type="sect3"><div class="sect3" id="idm45775553432808">&#13;
<h3>Out-of-heap memory</h3>&#13;
&#13;
<p><a data-primary="heap memory" data-secondary="out-of-heap-memory error" data-type="indexterm" id="ix_ch07-asciidoc7"/><a data-primary="out-of-memory errors" data-secondary="out-of-heap-memory error" data-type="indexterm" id="ix_ch07-asciidoc8"/>When the heap itself is out of memory, the error message appears like&#13;
this:</p>&#13;
&#13;
<pre data-type="programlisting">Exception in thread "main" java.lang.OutOfMemoryError: Java heap space</pre>&#13;
&#13;
<p>The common cases in which an out-of-memory condition is triggered by a lack of&#13;
heap space are similar to the example of the metaspace we just discussed.&#13;
The application may simply need&#13;
more heap space: the number of live objects that it is holding onto cannot&#13;
fit in the heap space configured for it. Or, the application&#13;
may have a memory leak: it continues to allocate additional objects without&#13;
allowing other objects to go out of scope. In the first case, increasing&#13;
the heap size will solve the issue; in the second case, increasing the heap&#13;
size will merely postpone the error.</p>&#13;
&#13;
<p>In either case, heap dump analysis is necessary to find out what is consuming&#13;
the most memory; the focus can then be on reducing the number (or size) of&#13;
those objects. If the application has a memory leak, take successive&#13;
heap dumps a few minutes apart and compare them. <code>mat</code> has that functionality&#13;
built into it: if two heap dumps are open, <code>mat</code> has an option to&#13;
calculate the difference in the histograms between the two heaps.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45775553425048">&#13;
<h5>Automatic Heap Dumps</h5>&#13;
<p><a data-primary="heap dump" data-secondary="automatic" data-type="indexterm" id="idm45775553423608"/><a data-primary="out-of-memory errors" data-secondary="automatic heap dump and" data-type="indexterm" id="idm45775553422632"/>Out-of-memory errors can occur unpredictably, making it difficult to know&#13;
when to get a heap dump. Several JVM flags can help:</p>&#13;
<dl>&#13;
<dt><code>-XX:+HeapDumpOnOutOfMemoryError</code></dt>&#13;
<dd>&#13;
<p><a data-primary="-XX:+HeapDumpOnOutOfMemoryError" data-type="indexterm" id="idm45775553419752"/>Turning on this flag (which is <code>false</code> by default) will cause the JVM to create a heap dump whenever an out-of-memory error is&#13;
thrown.</p>&#13;
</dd>&#13;
<dt><code>-XX:HeapDumpPath=&lt;path&gt;</code></dt>&#13;
<dd>&#13;
<p><a data-primary="-XX:HeapDumpPath=&lt;path&gt;" data-type="indexterm" id="idm45775553417096"/>This specifies the location where the heap dump will be written; the default is <em>java_pid&lt;pid&gt;.hprof</em> in the application’s current working directory. The path can specify either a directory (in which case the default filename is used) or the name of the actual file to produce.</p>&#13;
</dd>&#13;
<dt><code>-XX:+HeapDumpAfterFullGC</code></dt>&#13;
<dd>&#13;
<p><a data-primary="-XX:HeapDumpAfterFullGC" data-type="indexterm" id="idm45775553414264"/>This generates a heap dump after running a full GC.</p>&#13;
</dd>&#13;
<dt><code>-XX:+HeapDumpBeforeFullGC</code></dt>&#13;
<dd>&#13;
<p><a data-primary="-XX:HeapDumpBeforeFullGC" data-type="indexterm" id="idm45775553412136"/>This generates a heap dump before running a full GC.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>When multiple heap dumps are generated (e.g., because&#13;
multiple full GCs occur), a sequence number is appended to the heap dump&#13;
filename.</p>&#13;
&#13;
<p>Try turning on these flags if the application unpredictably throws an out-of-memory error due to the heap space and you need the heap dump at that point to&#13;
analyze why the failure occurred. Just be aware that taking the heap dump(s)&#13;
will extend the duration of the pause, because data representing the heap will&#13;
be written to disk.</p>&#13;
</div></aside>&#13;
&#13;
<p><a data-primary="memory leaks" data-secondary="collection class as cause of" data-type="indexterm" id="idm45775553409512"/><a data-type="xref" href="#FigureMatCompare">Figure 7-5</a> shows the classic case of a Java memory leak caused by&#13;
a collection class—in this case, <span class="keep-together"><code>HashMap</code></span>. (Collection classes are the&#13;
most frequent cause of a memory leak: the application inserts items into the&#13;
collection and never frees them.)&#13;
This is a comparison histogram view: it displays the difference in the&#13;
number of objects in two heap dumps. For example, 19,744 more <code>Integer</code> objects occur in the target heap dump compared to its baseline.</p>&#13;
&#13;
<p>The best way to overcome this situation is to change the application logic&#13;
such that items are proactively discarded from the collection when they are&#13;
no longer&#13;
needed. Alternatively, a collection that uses weak or soft references can&#13;
automatically discard the items when nothing else in the application is&#13;
referencing them, but those collections come with a cost (as is discussed&#13;
later in this chapter).</p>&#13;
&#13;
<figure><div class="figure" id="FigureMatCompare">&#13;
<img alt="A comparison of histograms, showing that the number of hash map entries has greatly increased." src="assets/jp2e_0705.png"/>&#13;
<h6><span class="label">Figure 7-5. </span>Histogram comparison</h6>&#13;
</div></figure>&#13;
&#13;
<p>Often when this kind of exception is thrown, the JVM does not exit, because&#13;
the exception affects only a single thread in the JVM. Let’s look at a JVM with&#13;
two threads performing a calculation. One of them may get the&#13;
<code>OutOfMemoryError</code>. By default, the thread handler for that thread will print&#13;
out the stack trace, and that thread will exit.</p>&#13;
&#13;
<p>But the JVM still has another active thread, so the JVM will not exit.&#13;
And because the thread that experienced the error has terminated, a fair amount of memory can likely now be claimed on a future GC cycle:&#13;
all the objects that the terminated thread referenced and that weren’t&#13;
referenced by any other threads. So the surviving thread will be able to&#13;
continue executing and will often have sufficient heap memory to complete&#13;
its task.</p>&#13;
&#13;
<p>Server frameworks with a thread pool handling requests will work essentially&#13;
the same way. They&#13;
will generally catch the error and prevent the thread from terminating, but&#13;
that doesn’t affect this discussion; the memory associated with the&#13;
request that the thread was executing will still become eligible for collection.</p>&#13;
&#13;
<p>So when this error is thrown, it will be fatal to the JVM only if it causes&#13;
the last non-daemon thread in the JVM to terminate. That will never be the&#13;
case in a server framework and often won’t be the case in a standalone&#13;
program with multiple threads. And usually that works out well, since the&#13;
memory associated with the active request will often become eligible for&#13;
collection.</p>&#13;
&#13;
<p><a data-primary="-XX:+ExitOnOutOfMemoryError" data-type="indexterm" id="idm45775553399144"/>If instead you want the JVM to exit whenever&#13;
the heap runs out of memory, you can set the&#13;
<span class="keep-together"><code>-XX:+ExitOnOutOfMemoryError</code></span>&#13;
flag, which by default is <code>false</code>.<a data-startref="ix_ch07-asciidoc8" data-type="indexterm" id="idm45775553397096"/><a data-startref="ix_ch07-asciidoc7" data-type="indexterm" id="idm45775553396392"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="GC overhead limit reached" data-type="sect3"><div class="sect3" id="GCOverhead">&#13;
<h3>GC overhead limit reached</h3>&#13;
&#13;
<p><a data-primary="out-of-memory errors" data-secondary="GC overhead limit reached" data-type="indexterm" id="idm45775553394024"/>The recovery described for the previous case assumes that when a thread gets&#13;
the out-of-memory error, memory associated with whatever that thread is working&#13;
on will become eligible for collection and the JVM can recover. That’s not always true, which leads us to the final case of the JVM throwing an out-of-memory error: when it&#13;
determines that it is spending too much time performing GC:</p>&#13;
&#13;
<pre data-type="programlisting">Exception in thread "main" java.lang.OutOfMemoryError: GC overhead limit exceeded</pre>&#13;
&#13;
<p>This error is&#13;
thrown when all of the following conditions are met:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><a data-primary="-XX:GCTimeLimit=&lt;N&gt;" data-type="indexterm" id="idm45775553390360"/>The amount of time spent in full GCs exceeds the value specified by the&#13;
<span class="keep-together"><code>-XX:GCTimeLimit=</code><em><code>N</code></em></span>&#13;
flag. The default value is 98 (i.e., if 98% of the time is spent in GC).</p>&#13;
</li>&#13;
<li>&#13;
<p><a data-primary="-XX:HeapFreeLimit=&lt;N&gt;" data-type="indexterm" id="idm45775553387208"/>The amount of memory reclaimed by a full GC is less than the value specified by the&#13;
<span class="keep-together"><code>-XX:GCHeapFreeLimit=</code><em><code>N </code></em></span>&#13;
flag. The default value is 2, meaning that if less than 2% of the heap is freed during the full GC, this condition is met.</p>&#13;
</li>&#13;
<li>&#13;
<p>The preceding two conditions have held true for five consecutive full GC cycles (that value is not tunable).</p>&#13;
</li>&#13;
<li>&#13;
<p><a data-primary="-XX:+UseGCOverheadLimit" data-type="indexterm" id="idm45775553383112"/>The value of the&#13;
<span class="keep-together"><code>-XX:+UseGCOverheadLimit</code></span>&#13;
flag is <code>true</code> (which it is by default).</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Note that all four of these conditions must be met. It is common to see&#13;
more than five consecutive full GCs occur in an application that does not&#13;
throw an out-of-memory error. That is because even if the application is spending 98% of its time performing&#13;
full GCs, it may be freeing more than 2% of the heap during each GC. Consider&#13;
increasing the value of&#13;
<span class="keep-together"><code>GCHeapFreeLimit</code></span>&#13;
in that case.</p>&#13;
&#13;
<p>Note that as a last-ditch effort to free memory, if the first two conditions&#13;
hold for four consecutive full GC cycles, then all soft references in the JVM&#13;
will be freed before the fifth full GC cycle. That often prevents the error,&#13;
since that fifth cycle may free more than 2% of the heap (assuming that&#13;
the application uses soft references).</p>&#13;
<div data-type="tip"><h1>Quick Summary</h1>&#13;
<ul>&#13;
<li>&#13;
<p>Out-of-memory errors are thrown for a variety of reasons; do not assume that the heap space is the problem.</p>&#13;
</li>&#13;
<li>&#13;
<p>For both the metaspace and the regular heap, out-of-memory errors most frequently occur because of memory leaks; heap analysis tools can help to find the root cause of the leak<a data-startref="ix_ch07-asciidoc6" data-type="indexterm" id="idm45775553375240"/><a data-startref="ix_ch07-asciidoc5" data-type="indexterm" id="idm45775553374536"/>.<a data-startref="ix_ch07-asciidoc2" data-type="indexterm" id="idm45775553373736"/><a data-startref="ix_ch07-asciidoc1" data-type="indexterm" id="idm45775553373032"/></p>&#13;
</li>&#13;
</ul>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using Less Memory" data-type="sect1"><div class="sect1" id="idm45775553371848">&#13;
<h1>Using Less Memory</h1>&#13;
&#13;
<p><a data-primary="heap memory" data-secondary="using less memory" data-type="indexterm" id="ix_ch07-asciidoc9"/><a data-primary="memory" data-secondary="using less" data-type="indexterm" id="ix_ch07-asciidoc10"/>The first approach to using memory more efficiently in Java is to&#13;
use less heap memory. That statement should be unsurprising: using&#13;
less memory means the heap will fill up less often, requiring fewer GC cycles.&#13;
The effect can multiply: fewer collections of the young generation&#13;
means the tenuring age of an object is increased less often—meaning that&#13;
the object is less likely to be promoted into the old generation. Hence, the&#13;
number of full GC cycles (or concurrent GC cycles) will be reduced. And&#13;
if those full GC cycles can clear up more memory, they will also occur&#13;
less frequently.</p>&#13;
&#13;
<p>This section investigates three ways to use less memory: reducing&#13;
object size, using lazy initialization of objects, and using canonical objects.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Reducing Object Size" data-type="sect2"><div class="sect2" id="ObjectSize">&#13;
<h2>Reducing Object Size</h2>&#13;
&#13;
<p><a data-primary="heap memory" data-secondary="reducing object size" data-type="indexterm" id="ix_ch07-asciidoc11"/><a data-primary="object size" data-secondary="reducing" data-type="indexterm" id="ix_ch07-asciidoc12"/><a data-primary="objects" data-secondary="reducing object size" data-type="indexterm" id="ix_ch07-asciidoc13"/>Objects occupy a certain amount of heap memory, so the simplest way to use less&#13;
memory is to make objects smaller. Given the memory constraints on the machine&#13;
running your program, it may not be possible to increase the heap size by 10%,&#13;
but a 20% reduction of half the objects in the heap can achieve the same goal. As discussed in <a data-type="xref" href="ch12.html#Misc">Chapter 12</a>, Java 11 has just such an optimization for <code>String</code>&#13;
objects, which means that users of Java 11 can frequently set their maximum heap 25% smaller than they required in Java 8—with no impact on GC or performance.</p>&#13;
&#13;
<p>The size of an object can be decreased by (obviously) reducing the number&#13;
of instance variables it holds and (less obviously) by reducing the size&#13;
of those variables. <a data-type="xref" href="#TableObjSize">Table 7-1</a> gives the size of an instance variable&#13;
of all Java types.</p>&#13;
<table id="TableObjSize">&#13;
<caption><span class="label">Table 7-1. </span>Size in bytes of Java instance variables</caption>&#13;
<colgroup>&#13;
<col style="width: 28%,71%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr class="header">&#13;
<th>Type</th>&#13;
<th>Size</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr class="odd">&#13;
<td><p><code>byte</code></p></td>&#13;
<td><p>1</p></td>&#13;
</tr>&#13;
<tr class="even">&#13;
<td><p><code>char</code></p></td>&#13;
<td><p>2</p></td>&#13;
</tr>&#13;
<tr class="odd">&#13;
<td><p><code>short</code></p></td>&#13;
<td><p>2</p></td>&#13;
</tr>&#13;
<tr class="even">&#13;
<td><p><code>int</code></p></td>&#13;
<td><p>4</p></td>&#13;
</tr>&#13;
<tr class="odd">&#13;
<td><p><code>float</code></p></td>&#13;
<td><p>4</p></td>&#13;
</tr>&#13;
<tr class="even">&#13;
<td><p><code>long</code></p></td>&#13;
<td><p>8</p></td>&#13;
</tr>&#13;
<tr class="odd">&#13;
<td><p><code>double</code></p></td>&#13;
<td><p>8</p></td>&#13;
</tr>&#13;
<tr class="even">&#13;
<td><p><code>reference</code></p></td>&#13;
<td><p>8 (on 32-bit Windows JVMs, 4)<sup><a data-type="noteref" href="ch07.html#idm45775553337304" id="idm45775553337304-marker">a</a></sup></p></td>&#13;
</tr>&#13;
</tbody>&#13;
<tbody><tr class="footnotes"><td colspan="2"><p data-type="footnote" id="idm45775553337304"><sup><a href="ch07.html#idm45775553337304-marker">a</a></sup> See <a data-type="xref" href="#CompressedOops">“Compressed Oops”</a> for more details.</p></td></tr></tbody></table>&#13;
&#13;
<p>The <code>reference</code> type here is the reference to any kind of Java object—instances of classes or arrays. That space is the storage only for&#13;
the reference itself. The size of an object that contains references to&#13;
other objects varies depending on whether we want to consider the&#13;
shallow, deep, or retained size of the object, but that size also includes&#13;
some invisible object header fields. For a regular object, the size of the&#13;
header fields is 8 bytes on a 32-bit JVM, and 16 bytes on a 64-bit JVM&#13;
(regardless of heap size).&#13;
For an array, the size of the header fields is 16 bytes on a 32-bit JVM or&#13;
a 64-bit JVM with a heap of less than 32 GB, and 24 bytes otherwise.</p>&#13;
&#13;
<p>For example, consider these class definitions:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">A</code> <code class="o">{</code>&#13;
    <code class="kd">private</code> <code class="kt">int</code> <code class="n">i</code><code class="o">;</code>&#13;
<code class="o">}</code>&#13;
&#13;
<code class="kd">public</code> <code class="kd">class</code> <code class="nc">B</code> <code class="o">{</code>&#13;
    <code class="kd">private</code> <code class="kt">int</code> <code class="n">i</code><code class="o">;</code>&#13;
    <code class="kd">private</code> <code class="n">Locale</code> <code class="n">l</code> <code class="o">=</code> <code class="n">Locale</code><code class="o">.</code><code class="na">US</code><code class="o">;</code>&#13;
<code class="o">}</code>&#13;
&#13;
<code class="kd">public</code> <code class="kd">class</code> <code class="nc">C</code> <code class="o">{</code>&#13;
    <code class="kd">private</code> <code class="kt">int</code> <code class="n">i</code><code class="o">;</code>&#13;
    <code class="kd">private</code> <code class="n">ConcurrentHashMap</code> <code class="n">chm</code> <code class="o">=</code> <code class="k">new</code> <code class="n">ConcurrentHashMap</code><code class="o">();</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>The actual sizes of a single instance of these objects (on a 64-bit JVM with a heap size of less than 32 GB) is given in <a data-type="xref" href="#TableObjectSizes">Table 7-2</a>.</p>&#13;
<table id="TableObjectSizes">&#13;
<caption><span class="label">Table 7-2. </span>Sizes in bytes of simple objects</caption>&#13;
<thead>&#13;
<tr>&#13;
<th/>&#13;
<th>Shallow size</th>&#13;
<th>Deep size</th>&#13;
<th>Retained size</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p><code>A</code></p></td>&#13;
<td><p>16</p></td>&#13;
<td><p>16</p></td>&#13;
<td><p>16</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>B</code></p></td>&#13;
<td><p>24</p></td>&#13;
<td><p>216</p></td>&#13;
<td><p>24</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>C</code></p></td>&#13;
<td><p>24</p></td>&#13;
<td><p>200</p></td>&#13;
<td><p>200</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>In class <code>B</code>, defining the <code>Locale</code> reference&#13;
adds 8 bytes to the object size, but at least in that&#13;
example, the&#13;
<span class="keep-together"><code>Locale</code></span>&#13;
object is shared among other classes. If the&#13;
<span class="keep-together"><code>Locale</code></span>&#13;
object is never needed by the class, including that instance&#13;
variable will waste only the additional bytes for the reference.&#13;
Still, those bytes add up if the application creates a lot of instances&#13;
of class <code>B</code>.</p>&#13;
&#13;
<p>On the other hand, defining and creating a&#13;
<span class="keep-together"><code>ConcurrentHashMap</code></span>&#13;
consumed additional bytes for the object reference, plus additional&#13;
bytes for the hash-map object. If the hash map is never used, instances of&#13;
class <code>C</code> are wasteful.</p>&#13;
&#13;
<p>Defining only required instance variables is one way to save&#13;
space in an object.&#13;
The less obvious case involves using smaller data types.&#13;
If a class needs to keep track of one of eight possible states, it can do&#13;
so using a <code>byte</code> rather than an <code>int</code>—potentially saving 3 bytes.&#13;
Using <code>float</code> instead of <code>double</code>, <code>int</code> instead of <code>long</code>, and so on, can help&#13;
save memory, particularly in classes that are frequently instantiated. As&#13;
discussed in <a data-type="xref" href="ch12.html#Misc">Chapter 12</a>, using appropriately sized collections (or using simple&#13;
instance variables instead of collections) achieves similar savings.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45775553265528">&#13;
<h5>Object Alignment and Object Sizes</h5>&#13;
<p><a data-primary="object alignment, object size and" data-type="indexterm" id="idm45775553264152"/><a data-primary="object size" data-secondary="object alignment and" data-type="indexterm" id="idm45775553263384"/><a data-primary="objects" data-secondary="object alignment and object size" data-type="indexterm" id="idm45775553262440"/>The classes mentioned in <a data-type="xref" href="#TableObjectSizes">Table 7-2</a> all contain an extra integer field&#13;
that was not referenced in the discussion. Why is that there?</p>&#13;
&#13;
<p>In truth, that variable serves the purpose of making the discussion of those&#13;
classes easier to follow: class <code>B</code> contains 8 more bytes than class <code>A</code>,&#13;
which is what we’d expect (and which makes the point more clearly).</p>&#13;
&#13;
<p>That glosses over an important detail: object sizes are always padded so&#13;
that they are a multiple of 8 bytes. Without the definition of <code>i</code> in class&#13;
<code>A</code>, instances of <code>A</code> still consume 16 bytes—the 4 bytes are just used for&#13;
padding the object size to a multiple of 8, rather than being used to&#13;
hold the reference to <code>i</code>. Without the&#13;
definition of <code>i</code>, instances of class <code>B</code> would consume only 16 bytes—the same&#13;
as <code>A</code>, even though <code>B</code> has that extra object reference. That padding is also&#13;
why an instance of <code>B</code> is 8 bytes larger than an instance of <code>A</code> even&#13;
though it contains only one additional (4-byte) reference.</p>&#13;
&#13;
<p>The JVM will also pad&#13;
objects that have an uneven number of bytes so that arrays of that object&#13;
fit neatly along whatever address boundaries are optimal for the underlying&#13;
architecture.</p>&#13;
&#13;
<p>So eliminating some instance fields or reducing some field sizes in an&#13;
object may or may not&#13;
yield a benefit, but there is no reason not to do it.</p>&#13;
&#13;
<p>The OpenJDK project has a separate downloadable tool called&#13;
<a href="https://oreil.ly/cSPvd"><code>jol</code></a> that&#13;
can calculate object sizes.</p>&#13;
</div></aside>&#13;
&#13;
<p>Eliminating instance fields in an object can help make the object smaller,&#13;
but a gray area exists: what about object fields that hold the result&#13;
of a calculation based on&#13;
pieces of data? This is the classic computer science trade-off of time&#13;
versus space: is it better to spend the memory (space) to store the&#13;
value or better to spend the time (CPU cycles) to calculate the value&#13;
as needed? In Java, though, the trade-off applies to CPU time as well,&#13;
since the&#13;
additional memory can cause GC to consume more CPU cycles.</p>&#13;
&#13;
<p>The hash code for a&#13;
<span class="keep-together"><code>String</code></span>,&#13;
for example, is calculated&#13;
by summing an equation involving each character of the string; it is&#13;
somewhat time-consuming to calculate. Hence, the&#13;
<span class="keep-together"><code>String</code></span>&#13;
class stores&#13;
that value in an instance variable so that the hash code needs to be&#13;
calculated only once: in the end, reusing that value will almost always produce&#13;
better performance than any memory savings from not storing it. On the other&#13;
hand, the&#13;
<span class="keep-together"><code>toString()</code></span>&#13;
method of most classes does not cache the&#13;
string representation of the object in an instance variable, which would&#13;
consume memory both for the instance variable and for the string it references.&#13;
Instead, the time required to calculate a new string will usually give&#13;
better performance than the memory required to keep the string reference&#13;
around. (It is also the case that the hash value for a <code>String</code> is&#13;
used frequently, and the <span class="keep-together"><code>toString()</code></span> representation of an object is&#13;
often used rarely.)</p>&#13;
&#13;
<p>This is definitely a your-mileage-may-vary situation and the point&#13;
along the time/space continuum where it makes sense to switch between&#13;
using the memory to cache a value and recalculating the value&#13;
will depend on&#13;
many factors. If reducing GC is the goal, the balance will swing more&#13;
to recalculating.</p>&#13;
<div data-type="tip"><h1>Quick Summary</h1>&#13;
<ul>&#13;
<li>&#13;
<p>Reducing object sizes can often improve the efficiency of GC.</p>&#13;
</li>&#13;
<li>&#13;
<p>The size of an object is not always immediately apparent: objects are padded&#13;
to fit on 8-byte boundaries, and object reference sizes are different between&#13;
32- and 64-bit JVMs.</p>&#13;
</li>&#13;
<li>&#13;
<p>Even <code>null</code> instance variables consume space within object classes.<a data-startref="ix_ch07-asciidoc13" data-type="indexterm" id="idm45775553206200"/><a data-startref="ix_ch07-asciidoc12" data-type="indexterm" id="idm45775553205416"/><a data-startref="ix_ch07-asciidoc11" data-type="indexterm" id="idm45775553204744"/></p>&#13;
</li>&#13;
</ul>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using Lazy Initialization" data-type="sect2"><div class="sect2" id="idm45775553366104">&#13;
<h2>Using Lazy Initialization</h2>&#13;
&#13;
<p><a data-primary="heap memory" data-secondary="using lazy initialization" data-type="indexterm" id="ix_ch07-asciidoc14"/><a data-primary="initialization, lazy" data-type="indexterm" id="ix_ch07-asciidoc15"/><a data-primary="lazy initialization" data-type="indexterm" id="ix_ch07-asciidoc16"/>Much of the time, the decision about whether a particular instance&#13;
variable is needed is not as black-and-white as the previous section suggests.&#13;
A particular class may need a&#13;
<span class="keep-together"><code>Calendar</code></span>&#13;
object only 10% of the time, but&#13;
<span class="keep-together"><code>Calendar</code></span>&#13;
objects are expensive to create, and it definitely makes sense&#13;
to keep that object around rather than re-create it on demand. This is&#13;
a case where <em>lazy initialization</em> can help.</p>&#13;
&#13;
<p>So far, this discussion has assumed that instance variables are&#13;
initialized eagerly. A class that needs to use a&#13;
<span class="keep-together"><code>Calendar</code></span>&#13;
object (and that doesn’t need to be thread-safe) might look something like this:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">CalDateInitialization</code> <code class="o">{</code>&#13;
    <code class="kd">private</code> <code class="n">Calendar</code> <code class="n">calendar</code> <code class="o">=</code> <code class="n">Calendar</code><code class="o">.</code><code class="na">getInstance</code><code class="o">();</code>&#13;
    <code class="kd">private</code> <code class="n">DateFormat</code> <code class="n">df</code> <code class="o">=</code> <code class="n">DateFormat</code><code class="o">.</code><code class="na">getDateInstance</code><code class="o">();</code>&#13;
&#13;
    <code class="kd">private</code> <code class="kt">void</code> <code class="nf">report</code><code class="o">(</code><code class="n">Writer</code> <code class="n">w</code><code class="o">)</code> <code class="o">{</code>&#13;
        <code class="n">w</code><code class="o">.</code><code class="na">write</code><code class="o">(</code><code class="s">"On "</code> <code class="o">+</code> <code class="n">df</code><code class="o">.</code><code class="na">format</code><code class="o">(</code><code class="n">calendar</code><code class="o">.</code><code class="na">getTime</code><code class="o">())</code> <code class="o">+</code> <code class="s">": "</code> <code class="o">+</code> <code class="k">this</code><code class="o">);</code>&#13;
    <code class="o">}</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>Initializing the fields lazily instead carries a small trade-off in terms of&#13;
computation performance—the code must test the state of the variable each&#13;
time the code is <span class="keep-together">executed:</span></p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">CalDateInitialization</code> <code class="o">{</code>&#13;
    <code class="kd">private</code> <code class="n">Calendar</code> <code class="n">calendar</code><code class="o">;</code>&#13;
    <code class="kd">private</code> <code class="n">DateFormat</code> <code class="n">df</code><code class="o">;</code>&#13;
&#13;
    <code class="kd">private</code> <code class="kt">void</code> <code class="nf">report</code><code class="o">(</code><code class="n">Writer</code> <code class="n">w</code><code class="o">)</code> <code class="o">{</code>&#13;
        <code class="k">if</code> <code class="o">(</code><code class="n">calendar</code> <code class="o">==</code> <code class="kc">null</code><code class="o">)</code> <code class="o">{</code>&#13;
            <code class="n">calendar</code> <code class="o">=</code> <code class="n">Calendar</code><code class="o">.</code><code class="na">getInstance</code><code class="o">();</code>&#13;
            <code class="n">df</code> <code class="o">=</code> <code class="n">DateFormat</code><code class="o">.</code><code class="na">getDateInstance</code><code class="o">();</code>&#13;
        <code class="o">}</code>&#13;
        <code class="n">w</code><code class="o">.</code><code class="na">write</code><code class="o">(</code><code class="s">"On "</code> <code class="o">+</code> <code class="n">df</code><code class="o">.</code><code class="na">format</code><code class="o">(</code><code class="n">calendar</code><code class="o">.</code><code class="na">getTime</code><code class="o">())</code> <code class="o">+</code> <code class="s">": "</code> <code class="o">+</code> <code class="k">this</code><code class="o">);</code>&#13;
    <code class="o">}</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>Lazy initialization is best used when the operation in question is&#13;
only infrequently used. If the operation is commonly used, no memory&#13;
will be saved (since it will always be allocated), and&#13;
there will be that slight performance penalty on a common operation.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45775553106040">&#13;
<h5>Lazy Initialization Runtime Performance</h5>&#13;
<p><a data-primary="lazy initialization" data-secondary="runtime performance" data-type="indexterm" id="idm45775553048632"/>The usual performance penalty for checking whether lazily initialized&#13;
variables have been initialized may not always exist. Consider&#13;
this example from the JDK’s&#13;
<span class="keep-together"><code>ArrayList</code></span>&#13;
class. That class&#13;
maintains an array of the elements it stores, and in older versions of Java,&#13;
pseudocode for the class looked like this:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">ArrayList</code> <code class="o">{</code>&#13;
    <code class="kd">private</code> <code class="n">Object</code><code class="o">[]</code> <code class="n">elementData</code> <code class="o">=</code> <code class="k">new</code> <code class="n">Object</code><code class="o">[</code><code class="mi">16</code><code class="o">];</code>&#13;
    <code class="kt">int</code> <code class="n">index</code> <code class="o">=</code> <code class="mi">0</code><code class="o">;</code>&#13;
    <code class="kd">public</code> <code class="kt">void</code> <code class="nf">add</code><code class="o">(</code><code class="n">Object</code> <code class="n">o</code><code class="o">)</code> <code class="o">{</code>&#13;
        <code class="n">ensureCapacity</code><code class="o">();</code>&#13;
        <code class="n">elementData</code><code class="o">[</code><code class="n">index</code><code class="o">++]</code> <code class="o">=</code> <code class="n">o</code><code class="o">;</code>&#13;
    <code class="o">}</code>&#13;
    <code class="kd">private</code> <code class="kt">void</code> <code class="nf">ensureCapacity</code><code class="o">()</code> <code class="o">{</code>&#13;
        <code class="k">if</code> <code class="o">(</code><code class="n">index</code> <code class="o">==</code> <code class="n">elementData</code><code class="o">.</code><code class="na">length</code><code class="o">)</code> <code class="o">{</code>&#13;
            <code class="o">...</code><code class="na">reallocate</code> <code class="n">array</code> <code class="n">and</code> <code class="n">copy</code> <code class="n">old</code> <code class="n">data</code> <code class="n">in</code><code class="o">...</code>&#13;
        <code class="o">}</code>&#13;
    <code class="o">}</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>A few years ago, this class was changed so that the&#13;
<span class="keep-together"><code>elementData</code></span>&#13;
array is&#13;
initialized lazily. But because the&#13;
<span class="keep-together"><code>ensureCapacity()</code></span>&#13;
method already needed to&#13;
check the array size, the common methods of the class didn’t suffer a&#13;
performance penalty: the code to check for initialization is the same&#13;
as the code to check whether the array size needs to be increased. The new code&#13;
uses a static, shared, zero-length array so that performance is the same:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">ArrayList</code> <code class="o">{</code>&#13;
    <code class="kd">private</code> <code class="kd">static</code> <code class="kd">final</code> <code class="n">Object</code><code class="o">[]</code> <code class="n">EMPTY_ELEMENTDATA</code> <code class="o">=</code> <code class="o">{}</code> <code class="o">;</code>&#13;
    <code class="kd">private</code> <code class="n">Object</code><code class="o">[]</code> <code class="n">elementData</code> <code class="o">=</code> <code class="n">EMPTY_ELEMENTDATA</code><code class="o">;</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>That means the&#13;
<span class="keep-together"><code>ensureCapacity()</code></span>&#13;
method can be (essentially) unchanged, since the&#13;
<span class="keep-together"><code>index</code></span>&#13;
and&#13;
<span class="keep-together"><code>elementData.length</code></span>&#13;
will both start at 0.</p>&#13;
</div></aside>&#13;
&#13;
<p>When the code involved must be thread-safe, lazy initialization becomes&#13;
more complicated. As a first step, it is easiest simply to add traditional&#13;
synchronization:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">CalDateInitialization</code> <code class="o">{</code>&#13;
    <code class="kd">private</code> <code class="n">Calendar</code> <code class="n">calendar</code><code class="o">;</code>&#13;
    <code class="kd">private</code> <code class="n">DateFormat</code> <code class="n">df</code><code class="o">;</code>&#13;
&#13;
    <code class="kd">private</code> <code class="kd">synchronized</code> <code class="kt">void</code> <code class="nf">report</code><code class="o">(</code><code class="n">Writer</code> <code class="n">w</code><code class="o">)</code> <code class="o">{</code>&#13;
        <code class="k">if</code> <code class="o">(</code><code class="n">calendar</code> <code class="o">==</code> <code class="kc">null</code><code class="o">)</code> <code class="o">{</code>&#13;
            <code class="n">calendar</code> <code class="o">=</code> <code class="n">Calendar</code><code class="o">.</code><code class="na">getInstance</code><code class="o">();</code>&#13;
            <code class="n">df</code> <code class="o">=</code> <code class="n">DateFormat</code><code class="o">.</code><code class="na">getDateInstance</code><code class="o">();</code>&#13;
        <code class="o">}</code>&#13;
        <code class="n">w</code><code class="o">.</code><code class="na">write</code><code class="o">(</code><code class="s">"On "</code> <code class="o">+</code> <code class="n">df</code><code class="o">.</code><code class="na">format</code><code class="o">(</code><code class="n">calendar</code><code class="o">.</code><code class="na">getTime</code><code class="o">())</code> <code class="o">+</code> <code class="s">": "</code> <code class="o">+</code> <code class="k">this</code><code class="o">);</code>&#13;
    <code class="o">}</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>Introducing synchronization into the solution opens up the possibility that the&#13;
synchronization will become a performance bottleneck. That case should be&#13;
rare. The performance benefit from lazy initialization occurs only when&#13;
the object in question will rarely initialize those fields—since if it usually initializes those fields, no memory has actually been&#13;
saved. So synchronization becomes a bottleneck for&#13;
lazily initialized fields when an infrequently used code path is suddenly subject to use by a lot of&#13;
threads simultaneously. That case is not inconceivable, but it isn’t&#13;
the most common case either.</p>&#13;
&#13;
<p>Solving that synchronization bottleneck can happen only if the&#13;
lazily initialized&#13;
variables are themselves thread-safe.&#13;
<span class="keep-together"><code>DateFormat</code></span>&#13;
objects are not thread-safe, so in the current example, it doesn’t&#13;
really matter if the lock includes the&#13;
<span class="keep-together"><code>Calendar</code></span>&#13;
object: if the lazily initialized objects are suddenly used heavily, the&#13;
required synchronization around the&#13;
<span class="keep-together"><code>DateFormat</code></span>&#13;
object will be an issue no matter what. The thread-safe code would have to&#13;
look like this:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">CalDateInitialization</code> <code class="o">{</code>&#13;
    <code class="kd">private</code> <code class="n">Calendar</code> <code class="n">calendar</code><code class="o">;</code>&#13;
    <code class="kd">private</code> <code class="n">DateFormat</code> <code class="n">df</code><code class="o">;</code>&#13;
&#13;
    <code class="kd">private</code> <code class="kt">void</code> <code class="nf">report</code><code class="o">(</code><code class="n">Writer</code> <code class="n">w</code><code class="o">)</code> <code class="o">{</code>&#13;
        <code class="n">unsychronizedCalendarInit</code><code class="o">();</code>&#13;
        <code class="kd">synchronized</code><code class="o">(</code><code class="n">df</code><code class="o">)</code> <code class="o">{</code>&#13;
            <code class="n">w</code><code class="o">.</code><code class="na">write</code><code class="o">(</code><code class="s">"On "</code> <code class="o">+</code> <code class="n">df</code><code class="o">.</code><code class="na">format</code><code class="o">(</code><code class="n">calendar</code><code class="o">.</code><code class="na">getTime</code><code class="o">())</code> <code class="o">+</code> <code class="s">": "</code> <code class="o">+</code> <code class="k">this</code><code class="o">);</code>&#13;
        <code class="o">}</code>&#13;
    <code class="o">}</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>Lazy initialization involving an instance variable that is not thread-safe&#13;
can always synchronize around that variable (e.g., using the&#13;
<span class="keep-together"><code>synchronized</code></span>&#13;
version of the method shown previously).</p>&#13;
&#13;
<p>Consider a somewhat different example, in which a large&#13;
<span class="keep-together"><code>ConcurrentHashMap</code></span>&#13;
is lazily initialized:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">CHMInitialization</code> <code class="o">{</code>&#13;
    <code class="kd">private</code> <code class="n">ConcurrentHashMap</code> <code class="n">chm</code><code class="o">;</code>&#13;
&#13;
    <code class="kd">public</code> <code class="kt">void</code> <code class="nf">doOperation</code><code class="o">()</code> <code class="o">{</code>&#13;
        <code class="kd">synchronized</code><code class="o">(</code><code class="k">this</code><code class="o">)</code> <code class="o">{</code>&#13;
            <code class="k">if</code> <code class="o">(</code><code class="n">chm</code> <code class="o">==</code> <code class="kc">null</code><code class="o">)</code> <code class="o">{</code>&#13;
                <code class="n">chm</code> <code class="o">=</code> <code class="k">new</code> <code class="n">ConcurrentHashMap</code><code class="o">();</code>&#13;
                <code class="o">...</code> <code class="n">code</code> <code class="n">to</code> <code class="n">populate</code> <code class="n">the</code> <code class="n">map</code> <code class="o">...</code>&#13;
            <code class="o">}</code>&#13;
        <code class="o">}</code>&#13;
        <code class="o">...</code><code class="na">use</code> <code class="n">the</code> <code class="n">chm</code><code class="o">...</code>&#13;
    <code class="o">}</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>Because <span class="keep-together"><code>ConcurrentHashMap</code></span>&#13;
can be safely accessed by multiple threads,&#13;
the extra synchronization in this example is one of the&#13;
infrequent cases where properly used lazy initialization could introduce&#13;
a synchronization bottleneck. (Such a bottleneck should still be rare,&#13;
though; if access to the hash map is that frequent, consider whether anything is&#13;
really saved by initializing it lazily.) The&#13;
bottleneck is solved using the double-checked locking idiom:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">CHMInitialization</code> <code class="o">{</code>&#13;
    <code class="kd">private</code> <code class="kd">volatile</code> <code class="n">ConcurrentHashMap</code> <code class="n">instanceChm</code><code class="o">;</code>&#13;
&#13;
    <code class="kd">public</code> <code class="kt">void</code> <code class="nf">doOperation</code><code class="o">()</code> <code class="o">{</code>&#13;
        <code class="n">ConcurrentHashMap</code> <code class="n">chm</code> <code class="o">=</code> <code class="n">instanceChm</code><code class="o">;</code>&#13;
        <code class="k">if</code> <code class="o">(</code><code class="n">chm</code> <code class="o">==</code> <code class="kc">null</code><code class="o">)</code> <code class="o">{</code>&#13;
            <code class="kd">synchronized</code><code class="o">(</code><code class="k">this</code><code class="o">)</code> <code class="o">{</code>&#13;
                <code class="n">chm</code> <code class="o">=</code> <code class="n">instanceChm</code><code class="o">;</code>&#13;
                <code class="k">if</code> <code class="o">(</code><code class="n">chm</code> <code class="o">==</code> <code class="kc">null</code><code class="o">)</code> <code class="o">{</code>&#13;
                    <code class="n">chm</code> <code class="o">=</code> <code class="k">new</code> <code class="n">ConcurrentHashMap</code><code class="o">();</code>&#13;
                    <code class="o">...</code> <code class="n">code</code> <code class="n">to</code> <code class="n">populate</code> <code class="n">the</code> <code class="n">map</code>&#13;
                    <code class="n">instanceChm</code> <code class="o">=</code> <code class="n">chm</code><code class="o">;</code>&#13;
                <code class="o">}</code>&#13;
            <code class="o">}</code>&#13;
            <code class="o">...</code><code class="na">use</code> <code class="n">the</code> <code class="n">chm</code><code class="o">...</code>&#13;
        <code class="o">}</code>&#13;
    <code class="o">}</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>Important threading issues exist: the instance variable&#13;
must be declared&#13;
<span class="keep-together"><code>volatile</code></span>,&#13;
and a slight performance benefit results from assigning the instance variable to a local variable. More details are given in <a data-type="xref" href="ch09.html#ThreadPerformance">Chapter 9</a>; in the occasional case where&#13;
lazy initialization of threaded code makes sense, this is the design pattern&#13;
to follow.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Eager deinitialization" data-type="sect3"><div class="sect3" id="idm45775551105016">&#13;
<h3>Eager deinitialization</h3>&#13;
&#13;
<p><a data-primary="eager deinitialization" data-type="indexterm" id="idm45775551103608"/><a data-primary="lazy initialization" data-secondary="eager deinitialization" data-type="indexterm" id="idm45775551102904"/>The corollary to lazily initializing variables is <em>eagerly deinitializing</em>&#13;
them by setting their value to <code>null</code>. That allows the object in question to&#13;
be collected more quickly by the garbage collector. While that sounds like&#13;
a good thing in theory, it is useful in only limited circumstances.</p>&#13;
&#13;
<p>A variable that is a candidate for lazy initialization might seem like a candidate for eager deinitialization: in the preceding examples, the <span class="keep-together"><code>Calendar</code></span> and <span class="keep-together"><code>DateFormat</code></span> objects could be set to <span class="keep-together"><code>null</code></span> upon completion of the&#13;
<span class="keep-together"><code>report()</code></span>&#13;
method. However, if the variable isn’t going to be used in subsequent invocations of the method (or elsewhere in the class), there is no reason to make it&#13;
an instance variable in the first place. Simply create the local variable&#13;
in the method, and when the method completes, the local variable will fall&#13;
out of scope and the garbage collector can free it.</p>&#13;
&#13;
<p>The common exception to the rule about not needing to eagerly deinitialize&#13;
variables occurs with classes like those in the&#13;
Java collection framework:&#13;
classes that hold references to data for a long time and&#13;
then are informed that&#13;
the data in question is no longer needed. Consider the implementation of&#13;
the&#13;
<span class="keep-together"><code>remove()</code></span>&#13;
method in the&#13;
<span class="keep-together"><code>ArrayList</code></span>&#13;
class of the JDK (some code is simplified):</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="n">E</code> <code class="nf">remove</code><code class="o">(</code><code class="kt">int</code> <code class="n">index</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="n">E</code> <code class="n">oldValue</code> <code class="o">=</code> <code class="n">elementData</code><code class="o">(</code><code class="n">index</code><code class="o">);</code>&#13;
    <code class="kt">int</code> <code class="n">numMoved</code> <code class="o">=</code> <code class="n">size</code> <code class="o">-</code> <code class="n">index</code> <code class="o">-</code> <code class="mi">1</code><code class="o">;</code>&#13;
    <code class="k">if</code> <code class="o">(</code><code class="n">numMoved</code> <code class="o">&gt;</code> <code class="mi">0</code><code class="o">)</code>&#13;
        <code class="n">System</code><code class="o">.</code><code class="na">arraycopy</code><code class="o">(</code><code class="n">elementData</code><code class="o">,</code> <code class="n">index</code><code class="o">+</code><code class="mi">1</code><code class="o">,</code>&#13;
                         <code class="n">elementData</code><code class="o">,</code> <code class="n">index</code><code class="o">,</code> <code class="n">numMoved</code><code class="o">);</code>&#13;
    <code class="n">elementData</code><code class="o">[--</code><code class="n">size</code><code class="o">]</code> <code class="o">=</code> <code class="kc">null</code><code class="o">;</code> <code class="c1">// clear to let GC do its work</code>&#13;
    <code class="k">return</code> <code class="n">oldValue</code><code class="o">;</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>The code comment about GC appears in the (otherwise sparsely commented)&#13;
JDK source itself: setting the value of a&#13;
variable to&#13;
<span class="keep-together"><code>null</code></span>&#13;
like that&#13;
is an unusual enough operation that some explanation is needed. In this case,&#13;
trace through what happens when the last element of the array is removed.&#13;
The number of items remaining in the array—the&#13;
<span class="keep-together"><code>size</code></span>&#13;
instance variable—is decremented. Say that <code>size</code> is decremented from 5 to 4. Now&#13;
whatever is stored in&#13;
<code>elementData[4]</code>&#13;
cannot be accessed: it is beyond the valid size of the array.</p>&#13;
&#13;
<p><code>elementData[4]</code>&#13;
is, in this case, a stale reference. The&#13;
<span class="keep-together"><code>elementData</code></span> array&#13;
is probably going to remain active for a long time, and so anything that it&#13;
no longer needs to reference needs to be actively set to <code>null</code>.</p>&#13;
&#13;
<p>This notion of stale references is the key: if a long-lived class&#13;
caches and then discards object references, care must be taken to avoid&#13;
stale references. Otherwise, explicitly setting an object reference to&#13;
<span class="keep-together"><code>null</code></span>&#13;
will offer little performance benefit.</p>&#13;
<div data-type="tip"><h1>Quick Summary</h1>&#13;
<ul>&#13;
<li>&#13;
<p>Use lazy initialization only when the common code paths will leave variables uninitialized.</p>&#13;
</li>&#13;
<li>&#13;
<p>Lazy initialization of thread-safe code is unusual but can often piggyback on existing synchronization.</p>&#13;
</li>&#13;
<li>&#13;
<p>Use double-checked locking for lazy initialization of code using thread-safe objects.<a data-startref="ix_ch07-asciidoc16" data-type="indexterm" id="idm45775550996824"/><a data-startref="ix_ch07-asciidoc15" data-type="indexterm" id="idm45775550996120"/><a data-startref="ix_ch07-asciidoc14" data-type="indexterm" id="idm45775550995448"/></p>&#13;
</li>&#13;
</ul>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using Immutable and Canonical Objects" data-type="sect2"><div class="sect2" id="idm45775553202776">&#13;
<h2>Using Immutable and Canonical Objects</h2>&#13;
&#13;
<p><a data-primary="canonical objects" data-type="indexterm" id="ix_ch07-asciidoc17"/><a data-primary="heap memory" data-secondary="using immutable and canonical objects" data-type="indexterm" id="ix_ch07-asciidoc18"/><a data-primary="immutable objects" data-type="indexterm" id="ix_ch07-asciidoc19"/>In Java, many object types are immutable. This includes objects that&#13;
have a corresponding primitive type—<span class="keep-together"><code>Integer</code></span>,&#13;
<span class="keep-together"><code>Double</code></span>,&#13;
<span class="keep-together"><code>Boolean</code></span>,&#13;
and so on—as well as other numeric-based types, like&#13;
<span class="keep-together"><code>BigDecimal</code></span>.&#13;
The&#13;
most common Java object, of course, is the immutable&#13;
<span class="keep-together"><code>String</code></span>.&#13;
From a program design&#13;
perspective, it is often a good idea for custom classes to represent&#13;
immutable objects as well.</p>&#13;
&#13;
<p>When these objects are quickly created and discarded, they have a small&#13;
effect on young collections; as you saw in <a data-type="xref" href="ch05.html#GC">Chapter 5</a>, that impact&#13;
is limited. But as is true of any object, if many immutable&#13;
objects are promoted to the old generation, performance can suffer.</p>&#13;
&#13;
<p>Hence, there is no reason to avoid designing and using immutable objects,&#13;
even if it may seem a little counterproductive that these objects cannot&#13;
be changed and must be re-created. But one optimization that is often possible&#13;
when handling these objects is to avoid creating duplicate copies of the same&#13;
object.</p>&#13;
&#13;
<p><a data-primary="Boolean class" data-type="indexterm" id="idm45775550983144"/>The best example of this is the <span class="keep-together"><code>Boolean</code></span> class. Any Java application needs only two instances of the <span class="keep-together"><code>Boolean</code></span> class: one for true, and one for false. Unfortunately, the&#13;
<span class="keep-together"><code>Boolean</code></span>&#13;
class is badly designed. Because it has a <span class="keep-together"><code>public</code></span> constructor, applications can create as many of these objects as they like, even though they are all exactly the same as one of the two canonical <span class="keep-together"><code>Boolean</code></span> objects. A better design would have been for the <span class="keep-together"><code>Boolean</code></span> class to have only a private constructor, and static methods to return either <span class="keep-together"><code>Boolean.TRUE</code></span> or <span class="keep-together"><code>Boolean.FALSE</code></span> based on their parameter. If such a model can be followed for your own immutable classes, you can prevent them from contributing to the heap usage of your application. (Ideally, it is obvious that you should never create a <code>Boolean</code> object; you should just use <code>Boolean.TRUE</code> or <code>Boolean.FALSE</code> as necessary.)</p>&#13;
&#13;
<p>These singular representations of immutable objects are known as the&#13;
<em>canonical version</em> of the object.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Creating canonical objects" data-type="sect3"><div class="sect3" id="idm45775550972920">&#13;
<h3>Creating canonical objects</h3>&#13;
&#13;
<p><a data-primary="canonical objects" data-secondary="creating" data-type="indexterm" id="idm45775550971480"/>Even if the universe of objects for a particular class is practically&#13;
limitless, using canonical values can often save memory. The JDK provides&#13;
a facility to do this for the most common immutable object: strings can&#13;
call the&#13;
<span class="keep-together"><code>intern()</code></span>&#13;
method to find a canonical version of the string.&#13;
More details of string interning are examined in <a data-type="xref" href="ch12.html#Misc">Chapter 12</a>;&#13;
for now we’ll look at how to accomplish the same thing for&#13;
custom classes.</p>&#13;
&#13;
<p>To canonicalize an object, create a map that stores the canonical&#13;
version of the object. To prevent a memory leak,&#13;
make sure that the objects in the map are weakly referenced. The&#13;
skeleton of such a class looks like this:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">ImmutableObject</code> <code class="o">{</code>&#13;
    <code class="kd">private</code> <code class="kd">static</code> <code class="n">WeakHashMap</code><code class="o">&lt;</code><code class="n">ImmutableObject</code><code class="o">,</code> <code class="n">ImmutableObject</code><code class="o">&gt;</code>&#13;
        <code class="n">map</code> <code class="o">=</code> <code class="k">new</code> <code class="n">WeakHashMap</code><code class="o">();</code>&#13;
&#13;
    <code class="kd">public</code> <code class="n">ImmutableObject</code> <code class="nf">canonicalVersion</code><code class="o">(</code><code class="n">ImmutableObject</code> <code class="n">io</code><code class="o">)</code> <code class="o">{</code>&#13;
        <code class="kd">synchronized</code><code class="o">(</code><code class="n">map</code><code class="o">)</code> <code class="o">{</code>&#13;
            <code class="n">ImmutableObject</code> <code class="n">canonicalVersion</code> <code class="o">=</code> <code class="n">map</code><code class="o">.</code><code class="na">get</code><code class="o">(</code><code class="n">io</code><code class="o">);</code>&#13;
            <code class="k">if</code> <code class="o">(</code><code class="n">canonicalVersion</code> <code class="o">==</code> <code class="kc">null</code><code class="o">)</code> <code class="o">{</code>&#13;
                <code class="n">map</code><code class="o">.</code><code class="na">put</code><code class="o">(</code><code class="n">io</code><code class="o">,</code> <code class="k">new</code> <code class="n">WeakReference</code><code class="o">(</code><code class="n">io</code><code class="o">));</code>&#13;
                <code class="n">canonicalVersion</code> <code class="o">=</code> <code class="n">io</code><code class="o">;</code>&#13;
            <code class="o">}</code>&#13;
            <code class="k">return</code> <code class="n">canonicalVersion</code><code class="o">;</code>&#13;
        <code class="o">}</code>&#13;
    <code class="o">}</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>In a threaded environment, the synchronization could become&#13;
a bottleneck. There’s no easy solution if you stick to JDK classes,&#13;
since they do not provide a concurrent hash map for weak references.&#13;
However, there have been proposals to add a&#13;
<span class="keep-together"><code>CustomConcurrentHashMap</code></span>&#13;
to the JDK—originally as part of Java Specification Request (JSR)166—and&#13;
you can find various&#13;
third-party implementations of such a class.</p>&#13;
<div data-type="tip"><h1>Quick Summary</h1>&#13;
<ul>&#13;
<li>&#13;
<p>Objects that are immutable offer the possibility of special lifecycle management: canonicalization.</p>&#13;
</li>&#13;
<li>&#13;
<p>Eliminating duplicate copies of immutable objects via canonicalization can greatly decrease the amount of heap an application uses<a data-startref="ix_ch07-asciidoc19" data-type="indexterm" id="idm45775550849592"/><a data-startref="ix_ch07-asciidoc18" data-type="indexterm" id="idm45775550848888"/><a data-startref="ix_ch07-asciidoc17" data-type="indexterm" id="idm45775550848216"/>.<a data-startref="ix_ch07-asciidoc10" data-type="indexterm" id="idm45775550847416"/><a data-startref="ix_ch07-asciidoc9" data-type="indexterm" id="idm45775550846712"/></p>&#13;
</li>&#13;
</ul>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Object Life-Cycle Management" data-type="sect1"><div class="sect1" id="idm45775550845528">&#13;
<h1>Object Life-Cycle Management</h1>&#13;
&#13;
<p><a data-primary="heap memory" data-secondary="object life-cycle management" data-type="indexterm" id="ix_ch07-asciidoc20"/><a data-primary="object life-cycle management" data-type="indexterm" id="ix_ch07-asciidoc21"/>The second broad topic of memory management discussed in this chapter is <em>object life-cycle management</em>. For the most part, Java attempts to minimize the effort developers must put into managing the life cycle of objects: the developer creates the objects when needed, and when they are no longer needed, the objects fall out of scope and are freed by the garbage collector.</p>&#13;
&#13;
<p>Sometimes this normal life cycle is not optimal. Some objects are expensive to create, and managing the life cycle of those objects will improve the efficiency of an application, even at the expense of requiring additional work by the garbage collector. This section explores when and how the normal life cycle of objects should be changed, either by reusing the objects or by maintaining special references to them.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Object Reuse" data-type="sect2"><div class="sect2" id="idm45775550840280">&#13;
<h2>Object Reuse</h2>&#13;
&#13;
<p><a data-primary="object life-cycle management" data-secondary="object reuse" data-type="indexterm" id="ix_ch07-asciidoc22"/><a data-primary="object reuse" data-type="indexterm" id="ix_ch07-asciidoc23"/><a data-primary="reusing objects" data-type="indexterm" id="ix_ch07-asciidoc24"/>Object reuse is commonly achieved in two ways: object pools and thread-local variables. GC engineers around the world are now groaning, since either technique hampers the efficiency of GC. Object pooling, in particular, is widely disliked in GC circles for that reason, though for that matter, object pools are also widely disliked in development circles for many other reasons.</p>&#13;
&#13;
<p>At one level, the reason for this position seems obvious: objects that&#13;
are reused stay around for a long time in the heap. If the heap has&#13;
a lot of objects, there is less room to create new objects,&#13;
and hence GC operations will occur more frequently. But that&#13;
is only part of the story.</p>&#13;
&#13;
<p>As you saw in <a data-type="xref" href="ch06.html#Collectors">Chapter 6</a>, when&#13;
an object is created, it is allocated in eden. It will spend a&#13;
few young GC cycles shuffling back and forth between the survivor spaces,&#13;
before finally getting promoted to the old generation. Each time the newly (or recently) created pooled object is processed, the GC&#13;
algorithm must perform some work to copy it and adjust references to it&#13;
until it finally makes it into the old <span class="keep-together">generation.</span></p>&#13;
&#13;
<p>Although that seems like the end of it, once the object is&#13;
promoted to the old generation, it can cause even more performance problems.&#13;
The length of time it takes to perform a full GC is proportional to the&#13;
number of objects that are still alive in the old generation. The amount&#13;
of live data is even more important than the size of the heap;&#13;
it is faster to process a 3 GB old generation with few surviving objects&#13;
than to process a 1 GB old generation where 75% of the objects survive.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45775550831096">&#13;
<h5>GC Efficiency</h5>&#13;
<p><a data-primary="heap" data-secondary="live data and GC efficiency" data-type="indexterm" id="idm45775550829656"/>Just how much does the amount of live data in the heap affect GC times?&#13;
The answer can be more than an order of magnitude.</p>&#13;
&#13;
<p>Here’s the output of a GC log from a test on my standard four-core&#13;
Linux system using a 4 GB heap (of which 1 GB is the fixed size for the new generation):</p>&#13;
&#13;
<pre data-type="programlisting">[Full GC [PSYoungGen: 786432K-&gt;786431K(917504K)]&#13;
        [ParOldGen: 3145727K-&gt;3145727K(3145728K)]&#13;
        3932159K-&gt;3932159K(4063232K)&#13;
        [PSPermGen: 2349K-&gt;2349K(21248K)], 0.5432730 secs]&#13;
        [Times: user=1.72 sys=0.01, real=0.54 secs]&#13;
...&#13;
[Full GC [PSYoungGen: 786432K-&gt;0K(917504K)]&#13;
        [ParOldGen: 3145727K-&gt;210K(3145728K)]&#13;
        3932159K-&gt;210K(4063232K)&#13;
        [PSPermGen: 2349K-&gt;2349K(21248K)], 0.0687770 secs]&#13;
        [Times: user=0.08 sys=0.00, real=0.07 secs]&#13;
...&#13;
[Full GC [PSYoungGen: 349567K-&gt;349567K(699072K)]&#13;
        [ParOldGen: 3145727K-&gt;3145727K(3145728K)]&#13;
        3495295K-&gt;3495295K(3844800K)&#13;
        [PSPermGen: 2349K-&gt;2349K(21248K)], 0.7228880 secs]&#13;
        [Times: user=2.41 sys=0.01, real=0.73 secs]</pre>&#13;
&#13;
<p>Notice that middle output: the application cleared most references to things in&#13;
the old generation, and hence the data in the old generation after the GC was&#13;
only 210 KB. That operation took a mere 70 ms. In the other cases,&#13;
most of the data in the heap is still live;&#13;
the full GC operations, which removed very little data from the heap,&#13;
took between 540 ms and 730 ms. And&#13;
fortunately, four GC threads are running in this test. On a single-core&#13;
system, the short GC in this example took 80 ms, and the long GC&#13;
required 2,410 ms (more than 30 times longer).</p>&#13;
</div></aside>&#13;
&#13;
<p>Using a concurrent collector and avoiding full GCs doesn’t&#13;
make the situation&#13;
that much better, since the time required by the marking phases of the&#13;
concurrent&#13;
collectors similarly depends on the amount of still-live data. And for CMS&#13;
in particular, the objects in a pool are likely to be promoted at&#13;
different times, increasing the chance of a concurrent failure due to&#13;
fragmentation. Overall,&#13;
the longer objects are kept in the heap, the less efficient GC will be.</p>&#13;
&#13;
<p>So: object reuse is bad. Now we can discuss how and when to reuse objects.</p>&#13;
&#13;
<p>The JDK provides some common object pools: the thread pool, which is&#13;
discussed in <a data-type="xref" href="ch09.html#ThreadPerformance">Chapter 9</a>, and soft references. <a data-primary="soft references" data-type="indexterm" id="idm45775550823000"/><em>Soft references</em>, which are discussed later in this section, are essentially a big pool&#13;
of reusable objects.&#13;
Java servers, meanwhile, depend on object pools for connections to&#13;
databases and other resources. The situation is similar for&#13;
thread-local values; the JDK is filled&#13;
with classes that use thread-local variables to avoid reallocating&#13;
certain kinds of objects. Clearly, even Java experts understand the need for object reuse in some <span class="keep-together">circumstances.</span></p>&#13;
&#13;
<p>The reason for reusing objects is that many objects&#13;
are expensive to initialize, and reusing them&#13;
is more efficient than the trade-off in increased GC&#13;
time. That is certainly true of things like the JDBC connection pool:&#13;
creating the network connection, and possibly logging in and establishing&#13;
a database session, is expensive. Object pooling in that case is a big&#13;
performance win. Threads are pooled to save the time associated with&#13;
creating a thread; random number generators are supplied as thread-local&#13;
variables to save the time require to seed them; and so on.</p>&#13;
&#13;
<p>One feature these examples share is that it takes a long time to&#13;
initialize the object.&#13;
In Java, object <em>allocation</em> is fast and&#13;
inexpensive (and arguments against object reuse tend to focus on that&#13;
part of the equation). Object <em>initialization</em> performance depends on&#13;
the object. You&#13;
should consider reusing only objects with a very high initialization cost,&#13;
and only then if the cost of initializing those objects is one of the dominant&#13;
operations in your program.</p>&#13;
&#13;
<p>Another feature these examples share is that the number of shared objects&#13;
tends to&#13;
be small, which minimizes their impact on GC operations: there aren’t enough&#13;
of them to slow down those GC cycles. Having a few objects in a pool isn’t&#13;
going to affect the GC efficiency too much; filling the heap with pooled&#13;
objects will slow down GC <span class="keep-together">significantly.</span></p>&#13;
&#13;
<p>Here are just some examples of where (and why) the JDK and Java programs&#13;
reuse objects:</p>&#13;
<dl>&#13;
<dt>Thread pools</dt>&#13;
<dd>&#13;
<p>Threads are expensive to initialize.</p>&#13;
</dd>&#13;
<dt>JDBC pools</dt>&#13;
<dd>&#13;
<p>Database connections are expensive to initialize.</p>&#13;
</dd>&#13;
<dt>Large arrays</dt>&#13;
<dd>&#13;
<p>Java requires that when an array is allocated,&#13;
all individual elements in the array must be initialized to a default&#13;
zero-based value&#13;
<span class="keep-together">(<code>null</code></span>,&#13;
<code>0</code>, or <code>false</code> as appropriate).  This can be time-consuming&#13;
for large arrays.</p>&#13;
</dd>&#13;
<dt>Native NIO buffers</dt>&#13;
<dd>&#13;
<p>Allocating a direct&#13;
<span class="keep-together"><code>java.nio.Buffer</code></span>&#13;
(a buffer returned from calling the&#13;
<span class="keep-together"><code>allocateDirect()</code></span>&#13;
method) is an expensive operation regardless of the size of the buffer.&#13;
It is better to create one large buffer and manage the buffers from that&#13;
by&#13;
slicing off portions as required and return them to be reused by future&#13;
<span class="keep-together">operations.</span></p>&#13;
</dd>&#13;
<dt>Security classes</dt>&#13;
<dd>&#13;
<p>Instances of&#13;
<span class="keep-together"><code>MessageDigest</code></span>,&#13;
<span class="keep-together"><code>Signature</code></span>,&#13;
and other security algorithms are expensive to initialize.</p>&#13;
</dd>&#13;
<dt>String encoder and decoder objects</dt>&#13;
<dd>&#13;
<p>Various classes in the JDK create and reuse these objects. For the most part,&#13;
these are also soft references, as you’ll see in the&#13;
next section.</p>&#13;
</dd>&#13;
<dt><code>StringBuilder</code> helpers</dt>&#13;
<dd>&#13;
<p>The&#13;
<span class="keep-together"><code>BigDecimal</code></span>&#13;
class reuses a&#13;
<span class="keep-together"><code>StringBuilder</code></span>&#13;
object when calculating intermediate results.</p>&#13;
</dd>&#13;
<dt>Random number generators</dt>&#13;
<dd>&#13;
<p>Instances of either the&#13;
<span class="keep-together"><code>Random</code></span>&#13;
or (especially) <span class="keep-together"><code>SecureRandom</code></span>&#13;
classes are expensive to seed.</p>&#13;
</dd>&#13;
<dt>Names obtained from DNS lookups</dt>&#13;
<dd>&#13;
<p>Network lookups are expensive.</p>&#13;
</dd>&#13;
<dt>ZIP encoders and decoders</dt>&#13;
<dd>&#13;
<p>In an interesting twist, these are not particularly expensive to initialize.&#13;
They&#13;
are, however, expensive to free, because they rely on object finalization&#13;
to ensure that the native memory they use is also freed.&#13;
See <a data-type="xref" href="#Finalizers">“Finalizers and final references”</a> for more details.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Two options (object&#13;
pools and thread-local variables) have differences in performance. Let’s look at those in more detail.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Object pools" data-type="sect3"><div class="sect3" id="idm45775550790664">&#13;
<h3>Object pools</h3>&#13;
&#13;
<p><a data-primary="object pools" data-type="indexterm" id="idm45775550789464"/><a data-primary="object reuse" data-secondary="object pools" data-type="indexterm" id="idm45775550788760"/><em>Object pools</em> are disliked for many reasons, only some of which have to&#13;
do with their performance. They can be difficult to size correctly.&#13;
They also place the burden of object management back on the programmer: rather&#13;
than simply letting an object go out of scope, the programmer must remember&#13;
to return the object to the pool.</p>&#13;
&#13;
<p>The focus here, though, is on the performance of an object pool, which is&#13;
subject to the following:</p>&#13;
<dl>&#13;
<dt>GC impact</dt>&#13;
<dd>&#13;
<p>As you’ve seen, holding lots of objects reduces&#13;
(sometimes drastically) the efficiency of GC.</p>&#13;
</dd>&#13;
<dt>Synchronization</dt>&#13;
<dd>&#13;
<p>Pools of objects are inevitably synchronized,&#13;
and if the objects are frequently removed and replaced, the pool can have&#13;
a lot of contention. The result is that access to the pool can become&#13;
slower than initializing a new object.</p>&#13;
</dd>&#13;
<dt>Throttling</dt>&#13;
<dd>&#13;
<p>This performance impact of pools can be beneficial:&#13;
pools allow access to scarce resources to be throttled. As&#13;
discussed in <a data-type="xref" href="ch02.html#SampleApplications">Chapter 2</a>, if you attempt to increase&#13;
load on a system&#13;
beyond what it can handle, performance will decrease. This&#13;
is one reason thread pools are important. If too many threads run&#13;
simultaneously, the CPUs will be overwhelmed, and&#13;
performance will degrade (an example is shown in&#13;
<a data-type="xref" href="ch09.html#ThreadPerformance">Chapter 9</a>).</p>&#13;
&#13;
<p>This principle applies to remote system access&#13;
as well and is frequently seen with JDBC connections. If more JDBC&#13;
connections are made to a database than&#13;
it can handle, performance of the database will degrade. In these&#13;
situations, it is better to throttle the number of resources (e.g.,&#13;
JDBC connections) by capping&#13;
the size of the pool—even if it means that threads in the application&#13;
must wait for a free <span class="keep-together">resource</span>.</p>&#13;
</dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Thread-local variables" data-type="sect3"><div class="sect3" id="idm45775550739240">&#13;
<h3>Thread-local variables</h3>&#13;
&#13;
<p><a data-primary="object reuse" data-secondary="thread-local variables" data-type="indexterm" id="ix_ch07-asciidoc25"/><a data-primary="thread-local variables" data-type="indexterm" id="ix_ch07-asciidoc26"/>Reusing objects by storing&#13;
them as <em>thread-local variables</em> results in various performance trade-offs:</p>&#13;
<dl>&#13;
<dt>Life-cycle management</dt>&#13;
<dd>&#13;
<p>Thread-local variables are much easier and less expensive to manage than&#13;
objects in a pool. Both techniques require you to obtain the initial object:&#13;
you check it out of the pool, or you call the&#13;
<span class="keep-together"><code>get()</code></span>&#13;
method on the thread-local object. But object pools require that you return the object when you&#13;
are done with it (otherwise no one else can use it). Thread-local objects are&#13;
always available within the thread and needn’t be explicitly returned.</p>&#13;
</dd>&#13;
<dt>Cardinality</dt>&#13;
<dd>&#13;
<p>Thread-local variables usually end up with a one-to-one correspondence&#13;
between the number of threads and the number of saved (reused) objects.&#13;
That isn’t strictly the case. The thread’s copy of the variable isn’t&#13;
created until the first time the thread uses it, so it is possible to have fewer saved objects than threads. But there cannot be any more&#13;
saved objects than threads, and much of the time it ends up being the same&#13;
number.</p>&#13;
&#13;
<p>On the other hand, an object pool may be sized arbitrarily. If a request&#13;
sometimes&#13;
needs one JDBC connection and sometimes needs two,&#13;
the JDBC pool can be sized accordingly (with, say, 12 connections&#13;
for 8 threads). Thread-local variables cannot do this effectively;&#13;
nor can they throttle access to a resource (unless the number of threads&#13;
itself serves as the throttle).</p>&#13;
</dd>&#13;
<dt>Synchronization</dt>&#13;
<dd>&#13;
<p>Thread-local variables need no synchronization&#13;
since they can be used only within a single thread; the&#13;
thread-local&#13;
<span class="keep-together"><code>get()</code></span>&#13;
method is relatively fast. (This wasn’t always&#13;
the case; in early versions of Java, obtaining a thread-local variable was&#13;
expensive. If you shied away from thread-local variables because of&#13;
bad performance in the past, reconsider their use in current versions of&#13;
Java.)</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Synchronization brings up an interesting point, because the performance&#13;
benefit of thread-local objects is often couched in terms of saving&#13;
synchronization costs (rather than in the savings from reusing an object).&#13;
For example, Java supplies a&#13;
<span class="keep-together"><code>ThreadLocalRandom</code></span>&#13;
class; that class (rather than a single&#13;
<span class="keep-together"><code>Random</code></span>&#13;
instance) is used in the sample stock&#13;
applications. Otherwise, many of the examples throughout the book would&#13;
encounter a synchronization bottleneck on the&#13;
<span class="keep-together"><code>next()</code></span>&#13;
method of the single&#13;
<span class="keep-together"><code>Random</code></span>&#13;
object. Using a thread-local object&#13;
is a good way to avoid synchronization bottlenecks, since only one thread&#13;
can ever use that object.</p>&#13;
&#13;
<p>However, that synchronization problem would have been solved just as easily if&#13;
the examples had simply created a new instance of the&#13;
<span class="keep-together"><code>Random</code></span>&#13;
class each time one was needed. Solving the synchronization problem&#13;
that way would not have helped the overall performance, though:&#13;
it is expensive to&#13;
initialize a&#13;
<span class="keep-together"><code>Random</code></span>&#13;
object, and continually creating instances of that class would have&#13;
had worse performance than&#13;
the synchronization bottleneck from many threads sharing one instance of&#13;
the class.</p>&#13;
&#13;
<p><a data-primary="ThreadLocalRandom class" data-type="indexterm" id="idm45775550719512"/>Better performance comes from using the&#13;
<span class="keep-together"><code>ThreadLocalRandom</code></span>&#13;
class, as shown in <a data-type="xref" href="#TableThreadLocalReuse">Table 7-3</a>.&#13;
This example calculates the time required to create 10,000 random numbers&#13;
in each of four threads under three scenarios:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Each thread constructs a new <code>Random</code> object to calculate the 10,000 numbers.</p>&#13;
</li>&#13;
<li>&#13;
<p>All threads share a common, static <code>Random</code> object.</p>&#13;
</li>&#13;
<li>&#13;
<p>All threads share a common, static <code>ThreadLocalRandom</code> object.</p>&#13;
</li>&#13;
</ul>&#13;
<table class="less_space pagebreak-before" id="TableThreadLocalReuse">&#13;
<caption><span class="label">Table 7-3. </span>Effect of <span class="keep-together"><code>ThreadLocalRandom</code></span> on generating 10,000 random numbers</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Operation</th>&#13;
<th>Elapsed time</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>Create new <code>Random</code></p></td>&#13;
<td><p>134.9 ± 0.01 microseconds</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>ThreadLocalRandom</code></p></td>&#13;
<td><p>52.0 ± 0.01 microseconds</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Share <code>Random</code></p></td>&#13;
<td><p>3,763 ± 200 microseconds</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>Microbenchmarking threads that contend on a lock is always unreliable. In the&#13;
last&#13;
row of this table, the threads are almost always contending for the lock on&#13;
the <code>Random</code> object; in a real application, the amount of contention would be&#13;
much less. Still, you can expect to see some contention with a shared object,&#13;
while creating a new object every time is more than two times as expensive as using the&#13;
<code>ThreadLocalRandom</code> object.</p>&#13;
&#13;
<p>The lesson here—and in general for object reuse—is that when&#13;
initialization of objects takes a long time,&#13;
don’t be afraid to explore object pooling or thread-local variables to&#13;
reuse those expensive-to-create objects. As always, though, strike a balance:&#13;
large object pools of generic classes will most certainly lead to more&#13;
performance issues than they solve. Leave these techniques to classes that&#13;
are expensive to initialize and for when the number of the reused objects will&#13;
be small.</p>&#13;
<div data-type="tip"><h1>Quick Summary</h1>&#13;
<ul>&#13;
<li>&#13;
<p>Object reuse is discouraged as a general-purpose operation but may be appropriate for small groups of objects that are expensive to initialize.</p>&#13;
</li>&#13;
<li>&#13;
<p>Trade-offs exist between reusing an object via an object pool or using a thread-local variable. In general, thread-local variables are easier to work with, assuming that a one-to-one correspondence between threads and reusable objects is desired<a data-startref="ix_ch07-asciidoc26" data-type="indexterm" id="idm45775550696392"/><a data-startref="ix_ch07-asciidoc25" data-type="indexterm" id="idm45775550695688"/>.<a data-startref="ix_ch07-asciidoc24" data-type="indexterm" id="idm45775550694888"/><a data-startref="ix_ch07-asciidoc23" data-type="indexterm" id="idm45775550694184"/><a data-startref="ix_ch07-asciidoc22" data-type="indexterm" id="idm45775550693512"/></p>&#13;
</li>&#13;
</ul>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Soft, Weak, and Other References" data-type="sect2"><div class="sect2" id="References">&#13;
<h2>Soft, Weak, and Other References</h2>&#13;
&#13;
<p><a data-primary="indefinite references" data-type="indexterm" id="ix_ch07-asciidoc27"/><a data-primary="object life-cycle management" data-secondary="soft/weak references" data-type="indexterm" id="ix_ch07-asciidoc28"/><a data-primary="references" data-secondary="indefinite" data-type="indexterm" id="ix_ch07-asciidoc29"/>Soft and weak references in Java also allow objects to be reused, though&#13;
as developers, we don’t always think of it in those terms. These kinds of&#13;
references—which we will generally refer to as <em>indefinite references</em>—are more frequently used to cache the result of a long calculation&#13;
or a database lookup rather than to reuse a simple object. For example, in&#13;
the stock server, an indirect reference could be used to cache the result&#13;
of the&#13;
<span class="keep-together"><code>getHistory()</code></span>&#13;
method (which entails either a lengthy calculation or&#13;
a long database call). That result is just an object, and when it is cached&#13;
via an indefinite reference, we are simply reusing the object because it is&#13;
otherwise expensive to initialize.</p>&#13;
<aside class="less_space pagebreak-before" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45775550684696">&#13;
<h5>A Note on Terminology</h5>&#13;
<p>Discussing soft and weak references can be confusing because so much&#13;
of the terminology uses similar words.  Here’s a quick primer on that&#13;
terminology:</p>&#13;
<dl>&#13;
<dt>Reference</dt>&#13;
<dd>&#13;
<p><a data-primary="references" data-secondary="defined" data-type="indexterm" id="idm45775550681336"/>A reference (or object reference) is any kind of reference: strong, weak, soft, and so on. An ordinary instance variable that refers to an object is a strong reference.</p>&#13;
</dd>&#13;
<dt>Indefinite reference</dt>&#13;
<dd>&#13;
<p><a data-primary="indefinite references" data-secondary="defined" data-type="indexterm" id="idm45775550678888"/>This is the term I use for any special kind of references (e.g., soft or weak).&#13;
An indefinite reference is actually an instance of an object (e.g., an&#13;
instance of the&#13;
<span class="keep-together"><code>SoftReference</code></span>&#13;
class).</p>&#13;
</dd>&#13;
<dt>Referent</dt>&#13;
<dd>&#13;
<p><a data-primary="referent, defined" data-type="indexterm" id="idm45775550675608"/>Indefinite references work by embedding another reference (almost always a&#13;
strong reference) within an instance of the indefinite reference class.&#13;
The encapsulated object is called the referent.</p>&#13;
</dd>&#13;
</dl>&#13;
</div></aside>&#13;
&#13;
<p>Still, to many programmers this “feels” different. In fact, even the&#13;
terminology reflects that: no one speaks of “caching” a thread&#13;
for reuse, but we will explore the reuse of indefinite references in&#13;
terms of caching the result of database operations.</p>&#13;
&#13;
<p>The advantage to an indefinite reference over an object pool or a thread-local&#13;
variable is that indefinite references will be (eventually)&#13;
reclaimed by&#13;
the garbage&#13;
collector.  If an object pool contains the last 10,000 stock&#13;
lookups that have been performed and the heap starts running low, the&#13;
application is out&#13;
of luck: whatever heap space remains after those 10,000 elements are&#13;
stored is all the remaining heap the application can use. If those&#13;
lookups are stored&#13;
via indefinite references, the JVM can free up some space (depending on&#13;
the type of reference), giving better GC throughput.</p>&#13;
&#13;
<p>The disadvantage is that indefinite references have a slightly greater effect&#13;
on the efficiency of the garbage collector. <a data-type="xref" href="#FigureRefProc1">Figure 7-6</a> shows a&#13;
side-by-side comparison of the memory used without and with an indefinite&#13;
reference (in this case, a soft reference).</p>&#13;
&#13;
<p>The object being cached occupies 512 bytes. On the left, that’s all the&#13;
memory consumed (absent the memory for the instance variable pointing to the&#13;
object). On the right, the object is being cached inside a&#13;
<span class="keep-together"><code>SoftReference</code></span>&#13;
object, which adds 40&#13;
bytes of memory consumption. Indefinite references are just like any other&#13;
object: they consume memory, and other things (the&#13;
<span class="keep-together"><code>cachedValue</code></span>&#13;
variable on the right side of the diagram)&#13;
reference them strongly.</p>&#13;
&#13;
<p class="pagebreak-before">So the first impact on the garbage collector is that indefinite references&#13;
cause the application to use more memory.&#13;
A second, bigger impact on the garbage collector is that&#13;
it takes at least two GC cycles for the indefinite reference object&#13;
to be reclaimed by the garbage collector.</p>&#13;
&#13;
<figure><div class="figure" id="FigureRefProc1">&#13;
<img alt="Diagram of an indefinite reference's memory use." src="assets/jp2e_0706.png"/>&#13;
<h6><span class="label">Figure 7-6. </span>Memory allocated by indefinite reference</h6>&#13;
</div></figure>&#13;
&#13;
<p><a data-type="xref" href="#FigureRefProc2">Figure 7-7</a> shows what happens when a referent is no longer strongly&#13;
referenced (i.e., the&#13;
<span class="keep-together"><code>lastViewed</code></span>&#13;
variable has been set to <code>null</code>). If no references&#13;
to the <code>StockHistory</code> object exist, it is freed during the next GC that processes&#13;
the generation where that object resides.&#13;
So the left side of the diagram now consumes 0 bytes.</p>&#13;
&#13;
<p>On the right side of the diagram, memory is still consumed. The exact&#13;
point at which the referent gets freed varies by the type of the&#13;
indefinite reference, but for now let’s take the case of a soft reference.&#13;
The referent will stick around until the JVM decides that the object has not&#13;
been used recently enough. When that happens,&#13;
the first GC cycle frees the referent—but not the indefinite reference object&#13;
itself. The application ends up with the memory state shown in&#13;
<a data-type="xref" href="#FigureRefProc3">Figure 7-8</a>.</p>&#13;
&#13;
<figure><div class="figure" id="FigureRefProc2">&#13;
<img alt="Diagram of an indefinite reference's memory use." src="assets/jp2e_0707.png"/>&#13;
<h6><span class="label">Figure 7-7. </span>Indefinite references retain memory through GC cycles</h6>&#13;
</div></figure>&#13;
&#13;
<figure><div class="figure" id="FigureRefProc3">&#13;
<img alt="Diagram of an indefinite reference's memory use." src="assets/jp2e_0708.png"/>&#13;
<h6><span class="label">Figure 7-8. </span>Indefinite references are not cleared immediately</h6>&#13;
</div></figure>&#13;
&#13;
<p>The indefinite reference object itself now has (at least) two strong&#13;
references to it: the original strong reference(s) created by the&#13;
application, and a new strong reference (created by the JVM) on a reference&#13;
queue. All of these strong references must be cleared before the indefinite&#13;
reference object itself can be reclaimed by the garbage collector.</p>&#13;
&#13;
<p>Typically, this cleanup is done by whatever code is processing the reference&#13;
queue. That code will get notified that a new object is on the&#13;
queue and immediately remove all strong references to that object. Then,&#13;
during the next GC cycle, the indefinite reference object (referent)&#13;
will get freed.&#13;
In the worst case, that reference queue will not be processed immediately,&#13;
and there can be many GC cycles before everything is cleaned up. Even in&#13;
the best case, though, the indefinite reference has to go through two&#13;
GC cycles before it is freed.</p>&#13;
&#13;
<p>Depending on the type of indefinite reference, some important&#13;
variations to this general algorithm exist,&#13;
but all indefinite references have this penalty&#13;
to some degree.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45775550654312">&#13;
<h5>GC Logs and Reference Handling</h5>&#13;
<p><a data-primary="garbage collection (GC)" data-secondary="GC logs and reference handling" data-type="indexterm" id="idm45775550653096"/><a data-primary="logging" data-secondary="GC logs and reference handling" data-type="indexterm" id="idm45775550652056"/><a data-primary="references" data-secondary="GC logs and reference handling" data-type="indexterm" id="idm45775550651096"/>When running an application that uses a lot of indefinite references,&#13;
consider adding&#13;
the&#13;
<span class="keep-together"><code>-XX:+PrintReferenceGC</code></span>&#13;
flag (which is&#13;
<span class="keep-together"><code>false</code></span>&#13;
by default). This allows you to see how much time&#13;
is spent processing those references:</p>&#13;
&#13;
<pre data-type="programlisting">[GC[SoftReference, 0 refs, 0.0000060 secs]&#13;
        [WeakReference, 238425 refs, 0.0236510 secs]&#13;
        [FinalReference, 4 refs, 0.0000160 secs]&#13;
        [PhantomReference, 0 refs, 0.0000010 secs]&#13;
        [JNI Weak Reference, 0.0000020 secs]&#13;
        [PSYoungGen: 271630K-&gt;17566K(305856K)]&#13;
        271630K-&gt;17566K(1004928K), 0.0797140 secs]&#13;
        [Times: user=0.16 sys=0.01, real=0.08 secs]</pre>&#13;
&#13;
<p>In this case, the use of 238,425 weak references added 23 ms to the young&#13;
collection.</p>&#13;
</div></aside>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Soft references" data-type="sect3"><div class="sect3" id="idm45775550646392">&#13;
<h3>Soft references</h3>&#13;
&#13;
<p><a data-primary="soft references" data-type="indexterm" id="ix_ch07-asciidoc30"/><em>Soft references</em> are used when the object in question has a good chance of&#13;
being reused in the future, but you want to let the garbage collector reclaim&#13;
the object if it hasn’t been used recently (a calculation that also&#13;
takes into consideration the amount of memory the heap has available).&#13;
Soft references are essentially one large, least recently used (LRU)&#13;
object pool. The key to getting good performance from them is to make sure&#13;
that they are cleared on a timely basis.</p>&#13;
&#13;
<p>Here is an example. The stock server can set up a global&#13;
cache of stock histories keyed by their symbol (or symbol and date). When&#13;
a request comes in for the stock history of <code>TPKS</code> from 9/1/19 to 12/31/19,&#13;
the cache can be consulted to see if the result from a similar request is&#13;
already there.</p>&#13;
&#13;
<p>The reason to cache that data is that requests tend to come in for certain&#13;
items more often than for others. If <code>TPKS</code> is the most requested stock,&#13;
it can be expected to remain in the soft reference cache. On the other&#13;
hand, a lone request for <code>KENG</code>&#13;
will live in the cache for a while but eventually be reclaimed. This also&#13;
accounts for requests over time: a cluster of requests for <code>DNLD</code> can reuse&#13;
the result from the first request. As users realize that <code>DNLD</code> is a bad&#13;
investment, those cached items will eventually age out of the heap.</p>&#13;
&#13;
<p>When, exactly, is a soft reference freed? First the referent must&#13;
not be strongly referenced elsewhere. If the soft reference is the only&#13;
remaining&#13;
reference to its referent, the referent is freed during the next GC cycle only&#13;
if the soft reference has not recently been accessed. Specifically, the&#13;
equation functions like this pseudocode:</p>&#13;
&#13;
<pre data-type="programlisting">long ms = SoftRefLRUPolicyMSPerMB * AmountOfFreeMemoryInMB;&#13;
if (now - last_access_to_reference &gt; ms)&#13;
   free the reference</pre>&#13;
&#13;
<p>This code has two key values. <a data-primary="-XX:SoftRefLRUPolicyMSPerMB=N" data-type="indexterm" id="idm45775550637288"/>The first value is set by the&#13;
<span class="keep-together"><code>-XX:SoftRefLRUPolicyMSPerMB=</code><em><code>N</code></em></span>&#13;
flag, which has a default value of 1,000.</p>&#13;
&#13;
<p>The second value is the amount of free memory in the heap (once the GC&#13;
cycle has completed). The free memory in the heap is calculated based on&#13;
the maximum possible size of the heap minus whatever is in use.</p>&#13;
&#13;
<p>So how does that all work?&#13;
Take the example of a JVM using a 4 GB heap.&#13;
After a full GC (or a concurrent cycle), the heap might be 50% occupied;&#13;
the free heap is therefore 2 GB. The default value of&#13;
<span class="keep-together"><code>SoftRefLRUPolicyMSPerMB</code></span>&#13;
(1,000)&#13;
means that any soft&#13;
reference that has not been used for the past 2,048 seconds&#13;
(2,048,000 ms)&#13;
will be cleared: the free heap is 2,048 (in megabytes), which is multiplied by 1,000:</p>&#13;
&#13;
<pre data-type="programlisting">   long ms = 2048000; // 1000 * 2048&#13;
   if (System.currentTimeMillis() - last_access_to_reference_in_ms &gt; ms)&#13;
       free the reference</pre>&#13;
&#13;
<p>If the 4 GB heap is 75% occupied, objects not accessed in the last 1,024 seconds&#13;
are reclaimed, and so on.</p>&#13;
&#13;
<p><span class="keep-together">To reclaim soft references more frequently, decrease&#13;
the value of the <code>SoftRefLRU</code></span><span class="keep-together"><code>PolicyMSPerMB</code></span>&#13;
flag. Setting that value to 500 means that a JVM with a 4 GB heap that is&#13;
75% full will reclaim objects not accessed in the&#13;
past 512 seconds.</p>&#13;
&#13;
<p>Tuning this flag is often necessary if the heap fills up quickly&#13;
with soft references. Say that the heap has 2 GB free and the application&#13;
starts to create&#13;
soft references. If it creates 1.7 GB of soft references in less than 2,048&#13;
seconds (roughly 34 minutes), none of those soft references will be eligible&#13;
to be reclaimed. There will be only 300 MB of space left in the heap for&#13;
other objects; GC will occur frequently as a result (yielding bad&#13;
overall performance).</p>&#13;
&#13;
<p>If the JVM completely runs out of memory&#13;
or starts thrashing too severely,&#13;
it will clear all soft references, since the alternative would be to throw&#13;
an&#13;
<span class="keep-together"><code>OutOfMemoryError</code></span>.&#13;
Not throwing the error is good,&#13;
but indiscriminately&#13;
throwing away all the cached results is probably not ideal.&#13;
Hence, another time to lower the&#13;
<span class="keep-together"><code>SoftRefLRUPolicyMSPerMB</code></span>&#13;
value is when&#13;
the reference processing GC logs indicates that a very large number of soft&#13;
references are being cleared unexpectedly. As discussed in <a data-type="xref" href="#GCOverhead">“GC overhead limit reached”</a>,&#13;
that will occur only after four consecutive full GC cycles (and if&#13;
other factors apply).</p>&#13;
&#13;
<p>On the other side of the spectrum, a long-running application&#13;
can consider raising that value if two conditions are met:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>A lot of free heap is available.</p>&#13;
</li>&#13;
<li>&#13;
<p>The soft references are infrequently accessed.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>That is an&#13;
unusual situation. It is similar to a situation discussed about&#13;
setting GC policies: you may think that if the soft reference&#13;
policy value is increased, you are&#13;
telling the JVM to discard soft references only as a last resort.&#13;
That is true, but you’ve also told the JVM not to leave any headroom in the&#13;
heap for normal operations, and you are likely to end up spending&#13;
too much time in GC instead.</p>&#13;
&#13;
<p>The caution, then, is not to use too many soft references, since they can&#13;
easily fill up the entire heap. This caution&#13;
is even stronger than the caution against creating an object pool with&#13;
too many instances:&#13;
soft references work well when the number of objects is not too large.&#13;
Otherwise, consider a more traditional object pool with a bounded size,&#13;
implemented as an LRU cache.<a data-startref="ix_ch07-asciidoc30" data-type="indexterm" id="idm45775550620568"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Weak references" data-type="sect3"><div class="sect3" id="idm45775550645768">&#13;
<h3>Weak references</h3>&#13;
&#13;
<p><a data-primary="weak references" data-type="indexterm" id="idm45775550618456"/><em>Weak references</em> should be used when the referent in question will be&#13;
used by several threads simultaneously. Otherwise, the weak reference is&#13;
too likely to be reclaimed by the garbage collector: objects that are only&#13;
weakly referenced are reclaimed at every GC cycle.</p>&#13;
&#13;
<p>This means that weak references never get into the state shown&#13;
(for soft references) in <a data-type="xref" href="#FigureRefProc2">Figure 7-7</a>. When the strong references&#13;
are removed, the weak reference is immediately freed. Hence, the program&#13;
state moves directly from <a data-type="xref" href="#FigureRefProc1">Figure 7-6</a> to <a data-type="xref" href="#FigureRefProc3">Figure 7-8</a>.</p>&#13;
&#13;
<p>The interesting effect here, though, is where the weak reference ends up&#13;
in the heap. Reference objects are just like other Java objects: they&#13;
are created in the young generation and eventually promoted to the old&#13;
generation. If the referent of the weak reference is freed while the weak&#13;
reference itself is still in the young generation, the weak reference will be&#13;
freed quickly (at the next minor GC). (This assumes that the&#13;
<span class="keep-together">reference</span> queue is quickly processed for the object in question.) If the&#13;
referent remains around long&#13;
enough for the weak reference to be promoted into the old generation, the weak reference will not be freed until the next concurrent or full GC&#13;
cycle.</p>&#13;
&#13;
<p>Using the cache of the stock server as an example, let’s say we know that&#13;
if a particular client accesses <code>TPKS</code>, they are almost&#13;
always likely to access it again. It makes sense to keep the values&#13;
for that stock&#13;
as a strong reference based on the client connection: it will always be there&#13;
for them,&#13;
and as soon as they log out, the connection is cleared and the memory&#13;
reclaimed.</p>&#13;
&#13;
<p>Now when another user comes along and needs data for <code>TPKS</code>, how will they&#13;
find it? Since the object is in memory somewhere, we don’t want to look it up&#13;
again, but also the connection-based cache doesn’t work for this second user.&#13;
So&#13;
in addition to keeping a strong reference to the <code>TPKS</code> data based on the&#13;
connection, it makes sense to keep a weak reference to that data in&#13;
a global cache.&#13;
Now the second user will be able to find the <code>TPKS</code> data—assuming that the&#13;
first user has not closed their connection. (This is&#13;
the scenario used in <a data-type="xref" href="#heap_analysis">“Heap Analysis”</a> where the&#13;
data had two references and wasn’t easily found by looking at objects with&#13;
the largest retained memory.)</p>&#13;
&#13;
<p>This is what is meant by simultaneous access. It is as if&#13;
we are saying to the JVM: “Hey, as long as someone else is interested in this&#13;
object, let me know where it is, but if they no longer need it, throw it&#13;
away and I will re-create it myself.” Compare that to a soft reference, which&#13;
essentially says: “Hey, try to keep this around as long as there is enough&#13;
memory and as long as it seems that someone is occasionally accessing it.”</p>&#13;
&#13;
<p>Not understanding this distinction is the most frequent performance issue&#13;
that occurs when using weak references. Don’t make the mistake of&#13;
thinking that a&#13;
weak reference is just like a soft reference except that it is freed more&#13;
quickly:&#13;
a softly referenced object will be available for (usually) minutes or even&#13;
hours, but a weakly referenced object will be available for only as long&#13;
as its referent is still around (subject to the next GC cycle clearing it).</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45775550605896">&#13;
<h5>Indefinite References and Collections</h5>&#13;
<p><a data-primary="collection classes" data-secondary="with indefinite references" data-secondary-sortas=" indefinite references" data-type="indexterm" id="idm45775550604440"/><a data-primary="indefinite references" data-secondary="collections and" data-type="indexterm" id="idm45775550603128"/>Collection classes are frequently the source of memory leaks in Java:&#13;
an application puts objects into (for example) a&#13;
<span class="keep-together"><code>HashMap</code></span>&#13;
object and never removes&#13;
them.&#13;
Over time, the hash map grows ever larger, consuming the heap.</p>&#13;
&#13;
<p>One way developers like to handle this situation is with a collection class&#13;
that holds indefinite references. The JDK provides two such classes:&#13;
<span class="keep-together"><code>WeakHashMap</code></span>&#13;
and&#13;
<span class="keep-together"><code>WeakIdentityMap</code></span>.&#13;
Custom collection classes based on&#13;
soft (and other) references are available from many third-party sources&#13;
(including sample implementations of JSR 166, such as the one used for&#13;
the examples of how to create and store canonical objects).</p>&#13;
&#13;
<p>Using these classes is convenient, but be aware that they have two costs.&#13;
First, as discussed throughout this section, indefinite references can&#13;
have a negative effect on the garbage collector. Second, the class itself&#13;
must periodically perform an operation to clear all the unreferenced data&#13;
in the collection (i.e., that class is responsible for processing the&#13;
reference queue of the indefinite references it stores).</p>&#13;
&#13;
<p><a data-primary="WeakHashMap class" data-type="indexterm" id="idm45775550597400"/>The&#13;
<span class="keep-together"><code>WeakHashMap</code></span>&#13;
class, for instance, uses weak references for its keys. When&#13;
the weakly referenced key is no longer available, the&#13;
<span class="keep-together"><code>WeakHashMap</code></span>&#13;
code must&#13;
clear out the value in the map that used to be associated with that key.&#13;
That operation is carried out every time the map is referenced: the&#13;
reference queue for the weak key is processed, and the value&#13;
associated with any key on the reference queue is removed from the map.</p>&#13;
&#13;
<p>This has two performance implications. First, the weak&#13;
reference and its associated value won’t actually be freed until the map is&#13;
used again. So if the map is used infrequently, the memory&#13;
associated with the map won’t be freed as quickly as desired.</p>&#13;
&#13;
<p>Second, the performance of operations on the map is&#13;
unpredictable. Normally, operations on a hash map are fast; that’s&#13;
why the hash map is so popular. The operation on a&#13;
<span class="keep-together"><code>WeakHashMap</code></span>&#13;
immediately after a GC will have to process the reference queue; that operation no longer&#13;
has a fixed, short time. So even if the keys are freed somewhat infrequently,&#13;
performance will be difficult to predict. Worse, if the keys in the map are&#13;
freed quite frequently, the performance of the&#13;
<span class="keep-together"><code>WeakHashMap</code></span>&#13;
can be&#13;
quite bad.</p>&#13;
&#13;
<p>Collections based on indefinite references can be useful, but they should be&#13;
approached with caution. If it is feasible, have the application manage the&#13;
collection itself.</p>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Finalizers and final references" data-type="sect3"><div class="sect3" id="Finalizers">&#13;
<h3>Finalizers and final references</h3>&#13;
&#13;
<p><a data-primary="finalizers/final references" data-type="indexterm" id="ix_ch07-asciidoc31"/><a data-primary="references" data-secondary="finalizers/final references" data-type="indexterm" id="ix_ch07-asciidoc32"/>Every Java class has a&#13;
<span class="keep-together"><code>finalize()</code></span>&#13;
method inherited from the&#13;
<span class="keep-together"><code>Object</code></span>&#13;
class; that method can be used to clean up data after the object is eligible for&#13;
GC. That sounds like a nice feature, and it is required in&#13;
a few circumstances. In practice, it turns out to be a bad idea, and&#13;
you should try hard not to use&#13;
this method.</p>&#13;
&#13;
<p>Finalizers are so bad that the <code>finalize()</code> method is deprecated in JDK 11&#13;
(though not in JDK 8).&#13;
We’ll get into the details of why finalizers are bad in the rest of this&#13;
section, but first, a little motivation. <em>Finalizers</em> were originally introduced&#13;
into Java to address problems that can arise when the JVM manages the life cycle&#13;
of objects. In a language like C++, where you must explicitly destroy an&#13;
object when you no longer need it, the deconstructor for the object could&#13;
clean up the state of that object. In Java, when the object is automatically&#13;
reclaimed as it goes out of scope, the finalizer served as the deconstructor.</p>&#13;
&#13;
<p>The JDK, for&#13;
example, uses a finalizer in its classes that manipulates ZIP files, because&#13;
opening a ZIP file uses native code that allocates native memory. That&#13;
memory is freed when the ZIP file is closed, but what happens if the&#13;
developer forgets to call the&#13;
<span class="keep-together"><code>close()</code></span>&#13;
method?&#13;
The finalizer can&#13;
ensure that the&#13;
<span class="keep-together"><code>close()</code></span>&#13;
method has been called, even if the developer forgets that.</p>&#13;
&#13;
<p>Numerous classes in JDK 8 use finalizers like that, but&#13;
in JDK 11, they all use a different mechanism: <code>Cleaner</code> objects. Those&#13;
are discussed in the next section. If you have your own code and are tempted&#13;
to use a finalizer (or are running on JDK 8 where the cleaner mechanism is&#13;
not available), read on for ways to cope with them.</p>&#13;
&#13;
<p>Finalizers are bad for functional reasons, and&#13;
they are also bad for performance. <span class="keep-together">Finalizers</span> are actually a special case of&#13;
an indefinite reference: the JVM uses a private reference class&#13;
<span class="keep-together">(<code>java.lang.ref.Finalizer</code></span>,&#13;
which in turn is a <code>java.lang.ref.FinalReference</code>) to keep track of objects&#13;
that have defined a&#13;
<span class="keep-together"><code>finalize()</code></span>&#13;
method. When an object&#13;
that has a&#13;
<span class="keep-together"><code>finalize()</code></span>&#13;
method is allocated, the JVM allocates&#13;
two objects:&#13;
the object itself and a&#13;
<span class="keep-together"><code>Finalizer</code></span>&#13;
reference that uses the object as its&#13;
referent.</p>&#13;
&#13;
<p>As with other indefinite references, it takes at least two&#13;
GC cycles before the indefinite reference object can be freed. However,&#13;
the penalty here is much greater than with other indefinite reference types.&#13;
When the referent of a soft or weak reference is eligible for GC, the&#13;
referent itself is immediately freed; that leads to the memory use previously&#13;
shown in <a data-type="xref" href="#FigureRefProc3">Figure 7-8</a>. The weak or soft reference&#13;
is placed on the&#13;
reference queue, but the reference object no longer refers to anything&#13;
(that is, its&#13;
<span class="keep-together"><code>get()</code></span>&#13;
method returns <code>null</code>&#13;
rather than the original referent).&#13;
In the case of soft and weak references, the two-cycle penalty for&#13;
GC applies only to the reference object itself (and not the&#13;
referent).</p>&#13;
&#13;
<p>This is not the case for final references. The implementation&#13;
of the&#13;
<span class="keep-together"><code>Finalizer</code></span>&#13;
class must have access to the referent in&#13;
order to call the referent’s&#13;
<span class="keep-together"><code>finalize()</code></span>&#13;
method, so the referent cannot be freed when the finalizer reference is&#13;
placed on its reference queue. When the referent of a finalizer becomes&#13;
eligible&#13;
for collection, the program state is reflected by <a data-type="xref" href="#FigureRefProc4">Figure 7-9</a>.</p>&#13;
&#13;
<p>When the reference queue processes the finalizer, the&#13;
<span class="keep-together"><code>Finalizer</code></span>&#13;
object (as usual) will be removed from the queue and then be eligible for&#13;
collection. Only then will the referent also be freed.&#13;
This is why finalizers&#13;
have a much greater performance effect on GC than&#13;
other indefinite references—the memory consumed by the referent can&#13;
be much more significant than the memory consumed by the indefinite reference&#13;
object.</p>&#13;
&#13;
<figure><div class="figure" id="FigureRefProc4">&#13;
<img alt="Diagram of an indefinite reference's memory use." src="assets/jp2e_0709.png"/>&#13;
<h6><span class="label">Figure 7-9. </span>Finalizer references retain more memory</h6>&#13;
</div></figure>&#13;
&#13;
<p>This leads to the functional problem with finalizers, which is that the&#13;
<span class="keep-together"><code>finalize()</code></span>&#13;
method can inadvertently create a new strong reference to the&#13;
referent. That again causes a GC performance penalty: now&#13;
the referent won’t be freed until it is no longer strongly referenced again.&#13;
And&#13;
functionally it creates a big problem, because the next time the referent is&#13;
eligible to be collected, its&#13;
<span class="keep-together"><code>finalize()</code></span>&#13;
method won’t be called, and the&#13;
expected cleanup of the referent won’t happen. This kind of error is reason&#13;
enough for finalizers to be used as seldom as possible.</p>&#13;
&#13;
<p>As a rule, then, if you are in a situation where a finalizer is unavoidable,&#13;
make sure that the memory accessed by the object is kept to a minimum.</p>&#13;
&#13;
<p>An alternative to using finalizers exists that avoids at least some of&#13;
these problems—and in particular, allows&#13;
the referent to be&#13;
freed during normal GC operations. This is accomplished by&#13;
simply using another kind of&#13;
indefinite&#13;
reference rather than implicitly using a&#13;
<span class="keep-together"><code>Finalizer</code></span>&#13;
reference.</p>&#13;
&#13;
<p>It is sometimes recommended to use yet another indefinite reference type&#13;
for this: the&#13;
<span class="keep-together"><code>PhantomReference</code></span>&#13;
class. (In fact, that’s what JDK 11 does, and if you’re on JDK 11,&#13;
the <code>Cleaner</code> object will be much easier to use than the example&#13;
presented here, which is really useful only in JDK 8.)&#13;
That’s a good choice, because the reference&#13;
object will be cleaned up relatively quickly after the referent is no longer&#13;
strongly referenced, and while debugging, the purpose of the reference is&#13;
clear. Still, the same goal can be achieved with a weak&#13;
reference (plus, the weak reference can be used in more places). And in certain&#13;
circumstances, a soft reference could be used if the caching&#13;
semantics of the soft reference match the need of the application.</p>&#13;
&#13;
<p>To create a substitute finalizer, you must create a subclass of the indefinite&#13;
reference&#13;
class to hold any information that needs to be cleaned up after the referent&#13;
has been collected. Then you perform the cleanup in a method of the reference&#13;
object (as opposed to defining a&#13;
<span class="keep-together"><code>finalize()</code></span>&#13;
method in the referent class).</p>&#13;
&#13;
<p>Here is the outline of such a class, which uses a weak reference. The&#13;
constructor here allocates a native resource. Under normal usage,&#13;
the&#13;
<span class="keep-together"><code>setClosed()</code></span>&#13;
method is expected to be called; that will clean up&#13;
the native memory.</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">private</code> <code class="kd">static</code> <code class="kd">class</code> <code class="nc">CleanupFinalizer</code> <code class="kd">extends</code> <code class="n">WeakReference</code> <code class="o">{</code>&#13;
&#13;
    <code class="kd">private</code> <code class="kd">static</code> <code class="n">ReferenceQueue</code><code class="o">&lt;</code><code class="n">CleanupFinalizer</code><code class="o">&gt;</code> <code class="n">finRefQueue</code><code class="o">;</code>&#13;
    <code class="kd">private</code> <code class="kd">static</code> <code class="n">HashSet</code><code class="o">&lt;</code><code class="n">CleanupFinalizer</code><code class="o">&gt;</code> <code class="n">pendingRefs</code> <code class="o">=</code> <code class="k">new</code> <code class="n">HashSet</code><code class="o">&lt;&gt;();</code>&#13;
&#13;
    <code class="kd">private</code> <code class="kt">boolean</code> <code class="n">closed</code> <code class="o">=</code> <code class="kc">false</code><code class="o">;</code>&#13;
&#13;
    <code class="kd">public</code> <code class="nf">CleanupFinalizer</code><code class="o">(</code><code class="n">Object</code> <code class="n">o</code><code class="o">)</code> <code class="o">{</code>&#13;
        <code class="kd">super</code><code class="o">(</code><code class="n">o</code><code class="o">,</code> <code class="n">finRefQueue</code><code class="o">);</code>&#13;
        <code class="n">allocateNative</code><code class="o">();</code>&#13;
        <code class="n">pendingRefs</code><code class="o">.</code><code class="na">add</code><code class="o">(</code><code class="k">this</code><code class="o">);</code>&#13;
    <code class="o">}</code>&#13;
&#13;
    <code class="kd">public</code> <code class="kt">void</code> <code class="nf">setClosed</code><code class="o">()</code> <code class="o">{</code>&#13;
        <code class="n">closed</code> <code class="o">=</code> <code class="kc">true</code><code class="o">;</code>&#13;
        <code class="n">doNativeCleanup</code><code class="o">();</code>&#13;
    <code class="o">}</code>&#13;
&#13;
    <code class="kd">public</code> <code class="kt">void</code> <code class="nf">cleanup</code><code class="o">()</code> <code class="o">{</code>&#13;
        <code class="k">if</code> <code class="o">(!</code><code class="n">closed</code><code class="o">)</code> <code class="o">{</code>&#13;
            <code class="n">doNativeCleanup</code><code class="o">();</code>&#13;
        <code class="o">}</code>&#13;
    <code class="o">}</code>&#13;
&#13;
    <code class="kd">private</code> <code class="kd">native</code> <code class="kt">void</code> <code class="nf">allocateNative</code><code class="o">();</code>&#13;
    <code class="kd">private</code> <code class="kd">native</code> <code class="kt">void</code> <code class="nf">doNativeCleanup</code><code class="o">();</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>However, the weak reference is also placed on a reference queue.&#13;
When the reference is pulled from the queue, it can check to make&#13;
sure the native memory has been cleaned up (and clean it if it has not).</p>&#13;
&#13;
<p>Processing of the reference queue happens in a daemon thread:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">static</code> <code class="o">{</code>&#13;
    <code class="n">finRefQueue</code> <code class="o">=</code> <code class="k">new</code> <code class="n">ReferenceQueue</code><code class="o">&lt;&gt;();</code>&#13;
    <code class="n">Runnable</code> <code class="n">r</code> <code class="o">=</code> <code class="k">new</code> <code class="n">Runnable</code><code class="o">()</code> <code class="o">{</code>&#13;
        <code class="kd">public</code> <code class="kt">void</code> <code class="nf">run</code><code class="o">()</code> <code class="o">{</code>&#13;
            <code class="n">CleanupFinalizer</code> <code class="n">fr</code><code class="o">;</code>&#13;
            <code class="k">while</code> <code class="o">(</code><code class="kc">true</code><code class="o">)</code> <code class="o">{</code>&#13;
                <code class="k">try</code> <code class="o">{</code>&#13;
                    <code class="n">fr</code> <code class="o">=</code> <code class="o">(</code><code class="n">CleanupFinalizer</code><code class="o">)</code> <code class="n">finRefQueue</code><code class="o">.</code><code class="na">remove</code><code class="o">();</code>&#13;
                    <code class="n">fr</code><code class="o">.</code><code class="na">cleanup</code><code class="o">();</code>&#13;
                    <code class="n">pendingRefs</code><code class="o">.</code><code class="na">remove</code><code class="o">(</code><code class="n">fr</code><code class="o">);</code>&#13;
                <code class="o">}</code> <code class="k">catch</code> <code class="o">(</code><code class="n">Exception</code> <code class="n">ex</code><code class="o">)</code> <code class="o">{</code>&#13;
                    <code class="n">Logger</code><code class="o">.</code><code class="na">getLogger</code><code class="o">(</code>&#13;
                           <code class="n">CleanupFinalizer</code><code class="o">.</code><code class="na">class</code><code class="o">.</code><code class="na">getName</code><code class="o">()).</code>&#13;
                           <code class="n">log</code><code class="o">(</code><code class="n">Level</code><code class="o">.</code><code class="na">SEVERE</code><code class="o">,</code> <code class="kc">null</code><code class="o">,</code> <code class="n">ex</code><code class="o">);</code>&#13;
                <code class="o">}</code>&#13;
            <code class="o">}</code>&#13;
        <code class="o">}</code>&#13;
    <code class="o">};</code>&#13;
    <code class="n">Thread</code> <code class="n">t</code> <code class="o">=</code> <code class="k">new</code> <code class="n">Thread</code><code class="o">(</code><code class="n">r</code><code class="o">);</code>&#13;
    <code class="n">t</code><code class="o">.</code><code class="na">setDaemon</code><code class="o">(</code><code class="kc">true</code><code class="o">);</code>&#13;
    <code class="n">t</code><code class="o">.</code><code class="na">start</code><code class="o">();</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>All of that is in a&#13;
<span class="keep-together"><code>private</code></span>&#13;
<span class="keep-together"><code>static</code></span>&#13;
inner class hidden from the developer&#13;
using the actual class, which looks like this:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">CleanupExample</code> <code class="o">{</code>&#13;
    <code class="kd">private</code> <code class="n">CleanupFinalizer</code> <code class="n">cf</code><code class="o">;</code>&#13;
    <code class="kd">private</code> <code class="n">HashMap</code> <code class="n">data</code> <code class="o">=</code> <code class="k">new</code> <code class="n">HashMap</code><code class="o">();</code>&#13;
&#13;
    <code class="kd">public</code> <code class="nf">CleanupExample</code><code class="o">()</code> <code class="o">{</code>&#13;
        <code class="n">cf</code> <code class="o">=</code> <code class="k">new</code> <code class="n">CleanupFinalizer</code><code class="o">(</code><code class="k">this</code><code class="o">);</code>&#13;
    <code class="o">}</code>&#13;
&#13;
    <code class="o">...</code><code class="na">methods</code> <code class="n">to</code> <code class="n">put</code> <code class="n">things</code> <code class="n">into</code> <code class="n">the</code> <code class="n">hashmap</code><code class="o">...</code>&#13;
&#13;
    <code class="kd">public</code> <code class="kt">void</code> <code class="nf">close</code><code class="o">()</code> <code class="o">{</code>&#13;
        <code class="n">data</code> <code class="o">=</code> <code class="kc">null</code><code class="o">;</code>&#13;
        <code class="n">cf</code><code class="o">.</code><code class="na">setClosed</code><code class="o">();</code>&#13;
    <code class="o">}</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>Developers construct this object just as they would any other object. They&#13;
are told to&#13;
call the&#13;
<span class="keep-together"><code>close()</code></span>&#13;
method, which will clean up the native memory—but if they don’t, it’s OK.&#13;
The weak reference still exists behind the scenes, so the&#13;
<span class="keep-together"><code>CleanupFinalizer</code></span>&#13;
class&#13;
has its own chance to clean up that memory when the inner class processes the&#13;
weak reference.</p>&#13;
&#13;
<p>The one tricky part of this example is the need for the&#13;
<span class="keep-together"><code>pendingRefs</code></span>&#13;
set&#13;
of weak references. Without that, the weak references themselves will be&#13;
collected before there is the chance to put them onto the reference queue.</p>&#13;
&#13;
<p>This example overcomes two limitations of the traditional finalizer: it&#13;
offers better performance, because the memory associated with the referent&#13;
object (the&#13;
<span class="keep-together"><code>data</code></span>&#13;
hash map in this case) is released as soon as the referent&#13;
is collected (rather than doing that in the&#13;
<span class="keep-together"><code>finalizer()</code></span>&#13;
method), and&#13;
there is no way for the referent object to be resurrected in the cleanup&#13;
code, since it has already been collected.</p>&#13;
&#13;
<p>Still, other objections that apply to the use of finalizers apply to&#13;
this code as well: you can’t ensure the&#13;
garbage collector will ever get around to freeing the referent, nor that&#13;
the reference queue thread will ever process any particular object on&#13;
the queue. If there are a large number of these objects, processing that&#13;
reference queue will be expensive. Like all indefinite references,&#13;
this example should still be used sparingly.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45775550269560">&#13;
<h5>The Finalizer Queue</h5>&#13;
<p><a data-primary="finalizer queue" data-type="indexterm" id="idm45775550268120"/>The <em>finalizer queue</em> is the reference queue used to process the&#13;
<span class="keep-together"><code>Finalizer</code></span>&#13;
references when the referent is eligible for GC.</p>&#13;
&#13;
<p>When performing heap dump analysis, it is often convenient to make sure&#13;
that no objects are on the finalizer queue: those objects are&#13;
about to be freed anyway, so eliminating them from the heap dump will make&#13;
it easier to see what else is occurring in the heap.&#13;
You can cause the finalizer&#13;
queue to be processed by executing this <span class="keep-together">command:</span></p>&#13;
<pre data-type="programlisting">&#13;
% <strong>jcmd process_id GC.run_finalization</strong>&#13;
</pre>&#13;
&#13;
<p>To monitor the finalizer queue to see if it might&#13;
be an issue for an application, look for its size (which is updated in real&#13;
time) on the VM Summary tab of <code>jconsole</code>. Scripts can gather that&#13;
information by running this command:<a data-startref="ix_ch07-asciidoc32" data-type="indexterm" id="idm45775550262584"/><a data-startref="ix_ch07-asciidoc31" data-type="indexterm" id="idm45775550261880"/></p>&#13;
<pre data-type="programlisting">&#13;
% <strong>jmap -finalizerinfo process_id</strong>&#13;
</pre>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Cleaner objects" data-type="sect3"><div class="sect3" id="idm45775550589560">&#13;
<h3>Cleaner objects</h3>&#13;
&#13;
<p><a data-primary="Cleaner class" data-type="indexterm" id="ix_ch07-asciidoc33"/><a data-primary="references" data-secondary="cleaner objects" data-type="indexterm" id="ix_ch07-asciidoc34"/>In JDK 11, it’s much easier to use the new <code>java.lang.ref.Cleaner</code> class in place of the <code>finalize()</code> method. This class uses&#13;
the <code>PhantomReference</code> class to get notified when the object is no longer&#13;
strongly reachable. This follows the same concepts as the <code>CleanupFinalizer</code>&#13;
class I just suggested for use in JDK 8, but because it’s a core feature&#13;
of the JDK, developers needn’t worry about setting up thread processing and&#13;
their own references: they simply register the appropriate objects that the&#13;
cleaner should process and let the core libraries take care of the rest.</p>&#13;
&#13;
<p>From a performance standpoint, the tricky part here is getting the “appropriate”&#13;
object to register with the cleaner. The cleaner will keep a strong reference&#13;
to the registered object, so by itself, that object will never become&#13;
phantom reachable. Instead, you create a sort of shadow object and register&#13;
that.</p>&#13;
&#13;
<p><a data-primary="Inflater class" data-type="indexterm" id="idm45775550253608"/>As an example, let’s look at the <code>java.util.zip.Inflater</code> class. This class&#13;
needs some sort of cleanup because it must free the native memory it allocated&#13;
during its processing. This cleanup code is executed when the <code>end()</code> method&#13;
is called, and developers are encouraged to call that method when they are&#13;
done with the object. But when the object is discarded, we must ensure that&#13;
the <code>end()</code> method has been called; otherwise, we’ll end up with a native&#13;
memory leak.<sup><a data-type="noteref" href="ch07.html#idm45775550251208" id="idm45775550251208-marker">1</a></sup></p>&#13;
&#13;
<p>In pseudocode, the <code>Inflater</code> class looks like this:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">java</code><code class="o">.</code><code class="na">util</code><code class="o">.</code><code class="na">zip</code><code class="o">.</code><code class="na">Inflater</code> <code class="o">{</code>&#13;
    <code class="kd">private</code> <code class="kd">static</code> <code class="kd">class</code> <code class="nc">InflaterZStreamRef</code> <code class="kd">implements</code> <code class="n">Runnable</code> <code class="o">{</code>&#13;
        <code class="kd">private</code> <code class="kt">long</code> <code class="n">addr</code><code class="o">;</code>&#13;
        <code class="kd">private</code> <code class="kd">final</code> <code class="n">Cleanable</code> <code class="n">cleanable</code><code class="o">;</code>&#13;
        <code class="n">InflaterZStreamRef</code><code class="o">(</code><code class="n">Inflater</code> <code class="n">owner</code><code class="o">,</code> <code class="kt">long</code> <code class="n">addr</code><code class="o">)</code> <code class="o">{</code>&#13;
            <code class="k">this</code><code class="o">.</code><code class="na">addr</code> <code class="o">=</code> <code class="n">addr</code><code class="o">;</code>&#13;
            <code class="n">cleanable</code> <code class="o">=</code> <code class="n">CleanerFactory</code><code class="o">.</code><code class="na">cleaner</code><code class="o">().</code><code class="na">register</code><code class="o">(</code><code class="n">owner</code><code class="o">,</code> <code class="k">this</code><code class="o">);</code>&#13;
        <code class="o">}</code>&#13;
&#13;
        <code class="kt">void</code> <code class="nf">clean</code><code class="o">()</code> <code class="o">{</code>&#13;
            <code class="n">cleanable</code><code class="o">.</code><code class="na">clean</code><code class="o">();</code>&#13;
        <code class="o">}</code>&#13;
&#13;
        <code class="kd">private</code> <code class="kd">static</code> <code class="kd">native</code> <code class="kt">void</code> <code class="nf">freeNativeMemory</code><code class="o">(</code><code class="kt">long</code> <code class="n">addr</code><code class="o">);</code>&#13;
        <code class="kd">public</code> <code class="kd">synchronized</code> <code class="kt">void</code> <code class="nf">run</code><code class="o">()</code> <code class="o">{</code>&#13;
            <code class="n">freeNativeMemory</code><code class="o">(</code><code class="n">addr</code><code class="o">);</code>&#13;
        <code class="o">}</code>&#13;
    <code class="o">}</code>&#13;
&#13;
    <code class="kd">private</code> <code class="n">InflaterZStreamRef</code> <code class="n">zsRef</code><code class="o">;</code>&#13;
&#13;
    <code class="kd">public</code> <code class="nf">Inflater</code><code class="o">()</code> <code class="o">{</code>&#13;
        <code class="k">this</code><code class="o">.</code><code class="na">zsRef</code> <code class="o">=</code> <code class="k">new</code> <code class="n">InflaterZStreamRef</code><code class="o">(</code><code class="k">this</code><code class="o">,</code> <code class="n">allocateNativeMemory</code><code class="o">());</code>&#13;
    <code class="o">}</code>&#13;
&#13;
    <code class="kd">public</code> <code class="kt">void</code> <code class="nf">end</code><code class="o">()</code> <code class="o">{</code>&#13;
        <code class="kd">synchronized</code><code class="o">(</code><code class="n">zsRef</code><code class="o">)</code> <code class="o">{</code>&#13;
            <code class="n">zsRef</code><code class="o">.</code><code class="na">clean</code><code class="o">();</code>&#13;
        <code class="o">}</code>&#13;
    <code class="o">}</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>This code is simpler than the actual implementation, which (for compatibility&#13;
reasons) has to keep track of subclasses that might override the&#13;
<code>end()</code> method, and of course the native memory allocation is more complex.&#13;
The point to understand here is that the inner class provides an object that&#13;
<code>Cleaner</code> can strongly reference. The outer class (the <code>owner</code>) argument&#13;
that is also registered with the cleaner provides the trigger: when it is&#13;
only phantom reachable, the cleaner is triggered, and it can use the&#13;
saved strong reference as the hook to do the cleanup.</p>&#13;
&#13;
<p>Note that the inner class here is <code>static</code>. Otherwise, it would contain an&#13;
implicit reference to the <code>Inflater</code> class itself, and then the <code>Inflater</code>&#13;
object could never become phantom reachable: there would always be a&#13;
strong reference from the <code>Cleaner</code> to the <code>InflaterZStreamRef</code> object and&#13;
a strong reference from that to the <code>Inflater</code> object. As a rule, the&#13;
object that will be doing the cleanup cannot contain a reference to the&#13;
object that needs to be cleaned up. For that reason, developers are&#13;
discouraged from using a lambda rather than a class, as it is again too easy&#13;
for the lambda to reference the enclosing class.</p>&#13;
<div data-type="tip"><h1>Quick Summary</h1>&#13;
<ul>&#13;
<li>&#13;
<p>Indefinite (soft, weak, phantom, and final) references alter the ordinary life cycle of Java objects, allowing them to be reused in ways that may be more GC-friendly than pools or thread-local variables.</p>&#13;
</li>&#13;
<li>&#13;
<p>Weak references should be used when an application is interested in an object but only if that object is strongly referenced elsewhere in the application.</p>&#13;
</li>&#13;
<li>&#13;
<p>Soft references hold onto objects for (possibly) long periods of time, providing a simple GC-friendly LRU cache.</p>&#13;
</li>&#13;
<li>&#13;
<p>Indefinite references consume their own memory and hold onto memory of other objects for long periods of time; they should be used sparingly.</p>&#13;
</li>&#13;
<li>&#13;
<p>Finalizers are a special type of reference originally designed for object cleanup; their use is discouraged in favor of the new <code>Cleaner</code> class<a data-startref="ix_ch07-asciidoc34" data-type="indexterm" id="idm45775550009944"/><a data-startref="ix_ch07-asciidoc33" data-type="indexterm" id="idm45775550009208"/>.<a data-startref="ix_ch07-asciidoc29" data-type="indexterm" id="idm45775550008408"/><a data-startref="ix_ch07-asciidoc28" data-type="indexterm" id="idm45775550007704"/><a data-startref="ix_ch07-asciidoc27" data-type="indexterm" id="idm45775550007032"/></p>&#13;
</li>&#13;
</ul>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Compressed Oops" data-type="sect2"><div class="sect2" id="CompressedOops">&#13;
<h2>Compressed Oops</h2>&#13;
&#13;
<p><a data-primary="compressed oops" data-type="indexterm" id="idm45775550004872"/><a data-primary="object life-cycle management" data-secondary="compressed oops" data-type="indexterm" id="idm45775550004168"/><a data-primary="oops (ordinary object pointers)" data-type="indexterm" id="idm45775550003160"/><a data-primary="ordinary object pointers (oops)" data-type="indexterm" id="idm45775550002472"/>Using simple programming, 64-bit JVMs are slower than 32-bit JVMs.&#13;
This performance gap is because of the 64-bit object references:&#13;
the 64-bit references take up twice the space (8&#13;
bytes) in&#13;
the heap as 32-bit references (4 bytes). That leads to more GC cycles,&#13;
since there&#13;
is now less room in the heap for other data.</p>&#13;
&#13;
<p>The JVM can compensate for that additional memory by using compressed&#13;
oops. <em>Oops</em> stands for <em>ordinary object pointers</em>, which are the handles the&#13;
JVM uses as object references. When oops are only 32 bits long, they&#13;
can reference only 4 GB of memory (<math alttext="2 Superscript 32">&#13;
  <msup><mrow><mn>2</mn></mrow> <mn>32</mn> </msup>&#13;
</math>), which is why a 32-bit JVM is&#13;
limited to a 4 GB heap size. (The same restriction applies at the&#13;
operating system level, which is why any 32-bit process is limited to 4 GB&#13;
of address space.) When oops are 64 bits long, they can reference&#13;
exabytes of memory, or far more than you could ever actually get into a machine.</p>&#13;
&#13;
<p>There is a middle ground here: what if there were 35-bit oops? Then&#13;
the pointer could reference 32 GB of memory (<math alttext="2 Superscript 35">&#13;
  <msup><mrow><mn>2</mn></mrow> <mn>35</mn> </msup>&#13;
</math>) and still take up less&#13;
space&#13;
in the heap than 64-bit references. The problem is that there aren’t&#13;
35-bit registers in which to store such references. Instead, though,&#13;
the JVM can assume that the last 3 bits of the reference are all 0.&#13;
Now every&#13;
reference can be stored in 32 bits in the heap. When the reference is&#13;
stored into a 64-bit register, the JVM can shift it left by 3&#13;
bits (adding three zeros at the end). When the reference is saved from a&#13;
register, the JVM can right-shift it by 3 bits, discarding the zeros at the&#13;
end.</p>&#13;
&#13;
<p>This leaves the JVM with pointers that can reference 32 GB of memory while&#13;
using&#13;
only 32 bits in the heap. However, it also means that the JVM cannot access any&#13;
object at an address that isn’t divisible by 8, since any address from&#13;
a compressed oop ends with three zeros. The first possible oop is&#13;
0x1, which when shifted becomes 0x8. The next oop is 0x2, which when shifted&#13;
becomes 0x10 (16). Objects must therefore be located on an 8-byte boundary.</p>&#13;
&#13;
<p>It turns out that objects are already aligned on an 8-byte boundary in the JVM;&#13;
this is the optimal alignment for most&#13;
processors. So nothing is lost by using compressed oops.&#13;
If the first object in the JVM is stored at location 0 and occupies 57 bytes,&#13;
the next object will be stored at location 64—wasting 7 bytes that&#13;
cannot be allocated. That memory trade-off is worthwhile (and will occur&#13;
whether compressed oops are used&#13;
or not), because the object can be accessed faster given that 8-byte alignment.</p>&#13;
&#13;
<p>But that is the reason that the JVM doesn’t try to emulate a 36-bit reference&#13;
that could access 64 GB of memory. In that case, objects would have to be&#13;
aligned on a&#13;
16-byte boundary, and the savings from storing the compressed pointer in the&#13;
heap would be outweighed by the amount of memory that would be wasted&#13;
between the memory-aligned objects.</p>&#13;
&#13;
<p>This has two implications. First, for heaps that are&#13;
between 4 GB and 32 GB, use compressed oops.&#13;
<a data-primary="-XX:+UseCompressedOops" data-type="indexterm" id="idm45775549991304"/>Compressed oops are enabled using the&#13;
<span class="keep-together"><code>-XX:+UseCompressedOops</code></span>&#13;
flag;&#13;
they are enabled by default whenever the maximum&#13;
heap size is less than 32 GB. (In <a data-type="xref" href="#ObjectSize">“Reducing Object Size”</a>, it was noted that&#13;
the size of an object reference on a 64-bit JVM with a 32 GB heap is 4&#13;
bytes—which is the default case since compressed oops are enabled by&#13;
default.)</p>&#13;
&#13;
<p>Second,&#13;
a program that uses a 31 GB heap and compressed oops will usually be faster&#13;
than a program that uses a 33 GB heap. Although the 33 GB heap is larger,&#13;
the extra space used by the pointers in that heap means that the larger&#13;
heap will perform more-frequent GC cycles and have worse performance.</p>&#13;
&#13;
<p>Hence, it is better to use heaps that are less than 32 GB, or heaps&#13;
that are at least a few GB larger than 32 GB. Once extra memory is added&#13;
to the heap to make up for the space used by the uncompressed references, the&#13;
number of GC cycles will be reduced. No hard rule indicates the amount of memory needed before the GC impact of the uncompressed oops&#13;
is ameliorated—but given that&#13;
20% of an average heap might be used for object references, planning on at&#13;
least 38 GB is a good start.</p>&#13;
<div data-type="tip"><h1>Quick Summary</h1>&#13;
<ul>&#13;
<li>&#13;
<p>Compressed oops are enabled by default whenever they are most useful.</p>&#13;
</li>&#13;
<li>&#13;
<p>A 31 GB heap using compressed oops will often outperform slightly larger heaps that are too big to use compressed oops.<a data-startref="ix_ch07-asciidoc21" data-type="indexterm" id="idm45775549983944"/><a data-startref="ix_ch07-asciidoc20" data-type="indexterm" id="idm45775549983240"/></p>&#13;
</li>&#13;
</ul>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm45775550005848">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>Fast Java programs depend crucially on memory management. Tuning GC is important, but to obtain maximum&#13;
performance, memory must be utilized effectively within <span class="keep-together">applications</span>.</p>&#13;
&#13;
<p>For a while, hardware trends tended to dissuade developers from thinking about&#13;
memory: if my laptop has 16 GB of memory, how concerned need I be with an&#13;
object that has an extra, unused 8-byte object reference? In a cloud world&#13;
of memory-limited containers, that concern is again obvious. Still, even when&#13;
we run applications with large heaps on large hardware, it’s easy to&#13;
forget that the normal time/space trade-off of programming can swing to&#13;
a time/space-and-time trade-off: using too much space in the heap can&#13;
make things slower by requiring more GC. In Java, managing the heap is&#13;
always important.</p>&#13;
&#13;
<p>Much of that management centers around when and how to use special memory&#13;
techniques: object pools, thread-local variables, and indefinite references.&#13;
Judicious use of these techniques can vastly improve the performance of an&#13;
application, but overuse of them can just as easily degrade performance. In&#13;
limited quantities—when the number of objects in question is small and&#13;
bounded—the use of these memory techniques can be quite effective.<a data-startref="ix_ch07-asciidoc0" data-type="indexterm" id="idm45775549978072"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm45775550251208"><sup><a href="ch07.html#idm45775550251208-marker">1</a></sup> If the <code>end()</code> method is not called eagerly and we rely on GC to clear the native memory, we’ll still have the appearance of a native memory leak; see <a data-type="xref" href="ch08.html#NativeMemory">Chapter 8</a> for more details.</p></div></div></section></body></html>