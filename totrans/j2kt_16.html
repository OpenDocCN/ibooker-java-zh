<html><head></head><body><section data-pdf-bookmark="Chapter 16. Interfaces to Functions" data-type="chapter" epub:type="chapter"><div class="chapter" id="interfaces-to-functions">&#13;
<h1><span class="label">Chapter 16. </span>Interfaces to Functions</h1>&#13;
&#13;
<blockquote data-type="epigraph" epub:type="epigraph">&#13;
<p>In Java, we use interfaces to specify a contract between code that defines some functionality and code that needs it.&#13;
Those interfaces couple the two parties together, which can make our software harder to maintain.&#13;
How do function types help solve this problem?</p>&#13;
</blockquote>&#13;
&#13;
<p>Imagine, if<a data-primary="interfaces to functions" data-secondary="hiding details in global variables" data-type="indexterm" id="idm46393373945656"/> you can, that you need to send email from some code that you are writing.&#13;
Just that for now—not receive mail, or list sent messages—just fire and forget.</p>&#13;
&#13;
<p>The code that describes the email is simple enough:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">data</code> <code class="k">class</code> <code class="nc">Email</code><code class="p">(</code>&#13;
    <code class="k">val</code> <code class="py">to</code><code class="p">:</code> <code class="n">EmailAddress</code><code class="p">,</code>&#13;
    <code class="k">val</code> <code class="py">from</code><code class="p">:</code> <code class="n">EmailAddress</code><code class="p">,</code>&#13;
    <code class="k">val</code> <code class="py">subject</code><code class="p">:</code> <code class="n">String</code><code class="p">,</code>&#13;
    <code class="k">val</code> <code class="py">body</code><code class="p">:</code> <code class="n">String</code>&#13;
<code class="p">)</code></pre>&#13;
&#13;
<p>Given an <code>Email</code>, client code would <em>like</em> to call the simplest possible function to send it, which is:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">send</code><code class="p">(</code><code class="n">email</code><code class="p">:</code> <code class="n">Email</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="p">...</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Of course when we come to implement this function, we discover that to actually send email, we require all sorts of other information.&#13;
Not information about the email itself but, rather, configuration about how to send it.&#13;
Things like the sending server’s hostname and security credentials—all the things that your nontechnical relative doesn’t know, but you need to set up their new computer.&#13;
We’ll add three extra parameters to <code>sendEmail</code> to stand in for all this configuration:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">sendEmail</code><code class="p">(</code>&#13;
    <code class="n">email</code><code class="p">:</code> <code class="n">Email</code><code class="p">,</code>&#13;
    <code class="n">serverAddress</code><code class="p">:</code> <code class="n">InetAddress</code><code class="p">,</code>&#13;
    <code class="n">username</code><code class="p">:</code> <code class="n">String</code><code class="p">,</code>&#13;
    <code class="n">password</code><code class="p">:</code> <code class="n">String</code>&#13;
<code class="p">)</code> <code class="p">{</code>&#13;
    <code class="p">...</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>As a client, things have just become a lot less convenient.&#13;
Everywhere we want to send email has to know this configuration; we’ll be passing it around from the top to the bottom of the codebase.&#13;
Solving that problem by hiding the details in global variables works fine until we discover that every run of the unit test suite now sends 50 emails!&#13;
There must be a better way of hiding these petty details.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Object-Oriented Encapsulation" data-type="sect1"><div class="sect1" id="idm46393373808200">&#13;
<h1>Object-Oriented Encapsulation</h1>&#13;
&#13;
<p>Object-oriented languages<a data-primary="interfaces to functions" data-secondary="object-oriented encapsulation" data-type="indexterm" id="IFooencap16"/><a data-primary="object-oriented encapsulation" data-type="indexterm" id="OOencap16"/><a data-primary="encapsulated collections to type aliases" data-secondary="hiding collections inside another object" data-type="indexterm" id="ECThid16"/> have a ready-made solution to this problem—objects can encapsulate the data:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">EmailSender</code><code class="p">(</code>&#13;
    <code class="k">private</code> <code class="k">val</code> <code class="py">serverAddress</code><code class="p">:</code> <code class="n">InetAddress</code><code class="p">,</code>&#13;
    <code class="k">private</code> <code class="k">val</code> <code class="py">username</code><code class="p">:</code> <code class="n">String</code><code class="p">,</code>&#13;
    <code class="k">private</code> <code class="k">val</code> <code class="py">password</code><code class="p">:</code> <code class="n">String</code>&#13;
<code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">fun</code> <code class="nf">send</code><code class="p">(</code><code class="n">email</code><code class="p">:</code> <code class="n">Email</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="n">sendEmail</code><code class="p">(</code>&#13;
            <code class="n">email</code><code class="p">,</code>&#13;
            <code class="n">serverAddress</code><code class="p">,</code>&#13;
            <code class="n">username</code><code class="p">,</code>&#13;
            <code class="n">password</code>&#13;
        <code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Now when we want to send email, we need access to an <code>EmailSender</code> (rather than the static function).&#13;
Once we have an <code>EmailSender</code>, instead of calling a function, we invoke a method, and we don’t need to tell the method all the petty details because it already knows them; they are the fields of its class:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="c1">// Where we know the configuration</code>&#13;
<code class="k">val</code> <code class="py">sender</code><code class="p">:</code> <code class="n">EmailSender</code> <code class="p">=</code> <code class="n">EmailSender</code><code class="p">(</code>&#13;
    <code class="n">inetAddress</code><code class="p">(</code><code class="s">"smtp.travelator.com"</code><code class="p">),</code>&#13;
    <code class="s">"username"</code><code class="p">,</code>&#13;
    <code class="s">"password"</code>&#13;
<code class="p">)</code>&#13;
&#13;
<code class="c1">// Where we send the message</code>&#13;
<code class="k">fun</code> <code class="nf">sendThanks</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="n">sender</code><code class="p">.</code><code class="n">send</code><code class="p">(</code>&#13;
        <code class="n">Email</code><code class="p">(</code>&#13;
            <code class="n">to</code> <code class="p">=</code> <code class="n">parse</code><code class="p">(</code><code class="s">"support@internationalrescue.org"</code><code class="p">),</code>&#13;
            <code class="n">from</code> <code class="p">=</code> <code class="n">parse</code><code class="p">(</code><code class="s">"support@travelator.com"</code><code class="p">),</code>&#13;
            <code class="n">subject</code> <code class="p">=</code> <code class="s">"Thanks for your help"</code><code class="p">,</code>&#13;
            <code class="n">body</code> <code class="p">=</code> <code class="s">"..."</code>&#13;
        <code class="p">)</code>&#13;
    <code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In general, the place where we know the configuration and the place where we want to send an email will be separated in our code, often by many layers.&#13;
Usually in OO, the <code>sender</code> will be captured as a property of a class and used by its methods:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="c1">// Where we know the configuration</code>&#13;
<code class="k">val</code> <code class="py">subsystem</code> <code class="p">=</code> <code class="n">Rescuing</code><code class="p">(</code>&#13;
    <code class="n">EmailSender</code><code class="p">(</code>&#13;
        <code class="n">inetAddress</code><code class="p">(</code><code class="s">"smtp.travelator.com"</code><code class="p">),</code>&#13;
        <code class="s">"username"</code><code class="p">,</code>&#13;
        <code class="s">"password"</code>&#13;
    <code class="p">)</code>&#13;
<code class="p">)</code>&#13;
&#13;
<code class="c1">// Where we send the message</code>&#13;
<code class="k">class</code> <code class="nc">Rescuing</code><code class="p">(</code>&#13;
    <code class="k">private</code> <code class="k">val</code> <code class="py">emailSender</code><code class="p">:</code> <code class="n">EmailSender</code>&#13;
<code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">fun</code> <code class="nf">sendThanks</code><code class="p">()</code> <code class="p">{</code>&#13;
        <code class="n">emailSender</code><code class="p">.</code><code class="n">send</code><code class="p">(</code>&#13;
            <code class="n">Email</code><code class="p">(</code>&#13;
                <code class="n">to</code> <code class="p">=</code> <code class="n">parse</code><code class="p">(</code><code class="s">"support@internationalrescue.org"</code><code class="p">),</code>&#13;
                <code class="n">from</code> <code class="p">=</code> <code class="n">parse</code><code class="p">(</code><code class="s">"support@travelator.com"</code><code class="p">),</code>&#13;
                <code class="n">subject</code> <code class="p">=</code> <code class="s">"Thanks for your help"</code><code class="p">,</code>&#13;
                <code class="n">body</code> <code class="p">=</code> <code class="s">"..."</code>&#13;
            <code class="p">)</code>&#13;
        <code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Often we will extract an interface:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">interface</code> <code class="n">ISendEmail</code> <code class="p">{</code>&#13;
    <code class="k">fun</code> <code class="nf">send</code><code class="p">(</code><code class="n">email</code><code class="p">:</code> <code class="n">Email</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">EmailSender</code><code class="p">(</code>&#13;
        <code class="p">...</code>&#13;
<code class="p">)</code> <code class="p">:</code> <code class="n">ISendEmail</code> <code class="p">{</code>&#13;
    <code class="k">override</code> <code class="k">fun</code> <code class="nf">send</code><code class="p">(</code><code class="n">email</code><code class="p">:</code> <code class="n">Email</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="n">sendEmail</code><code class="p">(</code>&#13;
            <code class="n">email</code><code class="p">,</code>&#13;
            <code class="n">serverAddress</code><code class="p">,</code>&#13;
            <code class="n">username</code><code class="p">,</code>&#13;
            <code class="n">password</code>&#13;
        <code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>If our client code depends on the <code>ISendEmail</code> interface rather than the <code>EmailSender</code> class, we can configure our tests to use a fake implementation of <code>ISendEmail</code>, which doesn’t actually send emails but instead allows us to check what would be sent if it did.&#13;
Not only can we provide fakes that don’t send emails at all, but also different &#13;
<span class="keep-together">genuine</span> implementations like <code>SmtpEmailSender</code> and <code>X400EmailSender</code>, each of which hides both its configuration and implementation from its clients.&#13;
We came for the information hiding but stayed for the implementation hiding.</p>&#13;
&#13;
<p>When we say <em>hiding</em>, it sounds a bit pejorative, but the concealment is useful to both client and implementor.&#13;
The former doesn’t have the problem of having to supply the configuration details at the point of use; the latter is able to evolve separately from its users (provided it doesn’t change API, expressed in the interface).</p>&#13;
&#13;
<p>Before we leave the object-oriented realm, note that we don’t have to create a named class to implement <code>ISendEmail</code>; we can do it anonymously:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">createEmailSender</code><code class="p">(</code>&#13;
    <code class="n">serverAddress</code><code class="p">:</code> <code class="n">InetAddress</code><code class="p">,</code>&#13;
    <code class="n">username</code><code class="p">:</code> <code class="n">String</code><code class="p">,</code>&#13;
    <code class="n">password</code><code class="p">:</code> <code class="n">String</code>&#13;
<code class="p">):</code> <code class="n">ISendEmail</code> <code class="p">=</code>&#13;
    <code class="k">object</code> <code class="err">: </code><code class="nc">ISendEmail</code> <code class="p">{</code>&#13;
        <code class="k">override</code> <code class="k">fun</code> <code class="nf">send</code><code class="p">(</code><code class="n">email</code><code class="p">:</code> <code class="n">Email</code><code class="p">)</code> <code class="p">=</code>&#13;
            <code class="n">sendEmail</code><code class="p">(</code>&#13;
                <code class="n">email</code><code class="p">,</code>&#13;
                <code class="n">serverAddress</code><code class="p">,</code>&#13;
                <code class="n">username</code><code class="p">,</code>&#13;
                <code class="n">password</code>&#13;
            <code class="p">)</code>&#13;
    <code class="p">}</code></pre>&#13;
&#13;
<p>Why might we want to do this?&#13;
Well, when we don’t control all the clients of our code (we are publishing a library external to our organization, for example), this gives us flexibility to change our implementation, safe in the knowledge that clients cannot depend on a specific implementation class by downcasting to it and calling other methods.&#13;
We call the object that we return here a<a data-primary="closures" data-type="indexterm" id="idm46393373379640"/> <em>closure</em>, because it closes over values that it requires from its enclosing context (the function call), capturing them for later reference.</p>&#13;
&#13;
<p>In Kotlin 1.4, we can declare our <code>ISendEmail</code> interface as a <code>fun interface</code> (one with only one abstract method).&#13;
This way, we can define the implementation of the single operation with a lambda rather than with an object with a single method:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">interface</code> <code class="n">ISendEmail</code> <code class="p">{</code>&#13;
    <code class="k">fun</code> <code class="nf">send</code><code class="p">(</code><code class="n">email</code><code class="p">:</code> <code class="n">Email</code><code class="p">)</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="k">fun</code> <code class="nf">createEmailSender</code><code class="p">(</code>&#13;
    <code class="n">serverAddress</code><code class="p">:</code> <code class="n">InetAddress</code><code class="p">,</code>&#13;
    <code class="n">username</code><code class="p">:</code> <code class="n">String</code><code class="p">,</code>&#13;
    <code class="n">password</code><code class="p">:</code> <code class="n">String</code>&#13;
<code class="p">)</code> <code class="p">=</code> <code class="n">ISendEmail</code> <code class="p">{</code> <code class="n">email</code> <code class="p">-&gt;</code>&#13;
    <code class="n">sendEmail</code><code class="p">(</code>&#13;
        <code class="n">email</code><code class="p">,</code>&#13;
        <code class="n">serverAddress</code><code class="p">,</code>&#13;
        <code class="n">username</code><code class="p">,</code>&#13;
        <code class="n">password</code>&#13;
    <code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Again, the lambda here is a closure, capturing the values of the parameters of its enclosing function.<a data-primary="" data-startref="IFooencap16" data-type="indexterm" id="idm46393373350984"/><a data-primary="" data-startref="OOencap16" data-type="indexterm" id="idm46393373295064"/><a data-primary="" data-startref="ECThid16" data-type="indexterm" id="idm46393373294152"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Functional Encapsulation" data-type="sect1"><div class="sect1" id="idm46393373807608">&#13;
<h1>Functional Encapsulation</h1>&#13;
&#13;
<p>Having<a data-primary="interfaces to functions" data-secondary="functional encapsulation" data-type="indexterm" id="IFfunencap16"/><a data-primary="functional encapsulation" data-type="indexterm" id="funencap16"/> seen how an OO programmer solves the problem of encapsulating pesky details so clients don’t have to supply them at the point of use, how would a functional programmer approach the same problem?</p>&#13;
&#13;
<p>Remember that we’re trying to get to a function with this signature:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">send</code><code class="p">(</code><code class="n">email</code><code class="p">:</code> <code class="n">Email</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="p">...</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>But we actually need all this information to send the message:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">sendEmail</code><code class="p">(</code>&#13;
    <code class="n">email</code><code class="p">:</code> <code class="n">Email</code><code class="p">,</code>&#13;
    <code class="n">serverAddress</code><code class="p">:</code> <code class="n">InetAddress</code><code class="p">,</code>&#13;
    <code class="n">username</code><code class="p">:</code> <code class="n">String</code><code class="p">,</code>&#13;
    <code class="n">password</code><code class="p">:</code> <code class="n">String</code>&#13;
<code class="p">)</code> <code class="p">{</code>&#13;
    <code class="p">...</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In<a data-primary="partial application" data-type="indexterm" id="idm46393373200568"/> functional terms, this is an example of <a href="https://oreil.ly/V1KOm"><em>partial application</em></a>: fixing some of the arguments to a function to yield a function with fewer arguments.&#13;
Although some languages provide built-in support for this, in Kotlin the easiest approach is to write a function to partially apply our configuration.</p>&#13;
&#13;
<p>What we want is a function that takes the configuration and returns a function that knows how to send an email:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code><code> </code><code class="nf">createEmailSender</code><code class="p">(</code><code>&#13;
</code><code>    </code><code class="n">serverAddress</code><code class="p">:</code><code> </code><code class="n">InetAddress</code><code class="p">,</code><code>&#13;
</code><code>    </code><code class="n">username</code><code class="p">:</code><code> </code><code class="n">String</code><code class="p">,</code><code>&#13;
</code><code>    </code><code class="n">password</code><code class="p">:</code><code> </code><code class="n">String</code><code>&#13;
</code><code class="p">)</code><code class="p">:</code><code> </code><code class="p">(</code><code class="n">Email</code><code class="p">)</code><code> </code><code class="p">-</code><code class="p">&gt;</code><code> </code><code class="n">Unit</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_introduction_CO29-1" id="co_introduction_CO29-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code>    </code><code class="p">.</code><code class="p">.</code><code class="p">.</code><code>&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_introduction_CO29-1" id="callout_introduction_CO29-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The return type of our function is itself a function that takes an <code>Email</code> and returns <code>Unit</code>.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Thus, <code>createEmailSender</code> is a constructor.&#13;
Not a class constructor, but a function taking the same role.&#13;
Both <code>createEmailSender</code> and <code>::EmailSender</code> are functions that return an object that knows how to send a message.</p>&#13;
&#13;
<p>To see how this works in functions, we can write this in longhand first by defining an inner function that captures the arguments it requires from the parent:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">createEmailSender</code><code class="p">(</code>&#13;
    <code class="n">serverAddress</code><code class="p">:</code> <code class="n">InetAddress</code><code class="p">,</code>&#13;
    <code class="n">username</code><code class="p">:</code> <code class="n">String</code><code class="p">,</code>&#13;
    <code class="n">password</code><code class="p">:</code> <code class="n">String</code>&#13;
<code class="p">):</code> <code class="p">(</code><code class="n">Email</code><code class="p">)</code> <code class="p">-&gt;</code> <code class="n">Unit</code> <code class="p">{</code>&#13;
&#13;
    <code class="k">fun</code> <code class="nf">result</code><code class="p">(</code><code class="n">email</code><code class="p">:</code> <code class="n">Email</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="n">sendEmail</code><code class="p">(</code>&#13;
            <code class="n">email</code><code class="p">,</code>&#13;
            <code class="n">serverAddress</code><code class="p">,</code>&#13;
            <code class="n">username</code><code class="p">,</code>&#13;
            <code class="n">password</code>&#13;
        <code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
    <code class="k">return</code> <code class="o">::</code><code class="n">result</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>We can then make the result a lambda expression:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">createEmailSender</code><code class="p">(</code>&#13;
    <code class="n">serverAddress</code><code class="p">:</code> <code class="n">InetAddress</code><code class="p">,</code>&#13;
    <code class="n">username</code><code class="p">:</code> <code class="n">String</code><code class="p">,</code>&#13;
    <code class="n">password</code><code class="p">:</code> <code class="n">String</code>&#13;
<code class="p">):</code> <code class="p">(</code><code class="n">Email</code><code class="p">)</code> <code class="p">-&gt;</code> <code class="n">Unit</code> <code class="p">{</code>&#13;
&#13;
    <code class="k">val</code> <code class="py">result</code><code class="p">:</code> <code class="p">(</code><code class="n">Email</code><code class="p">)</code> <code class="p">-&gt;</code> <code class="n">Unit</code> <code class="p">=</code>&#13;
        <code class="p">{</code> <code class="n">email</code> <code class="p">-&gt;</code>&#13;
            <code class="n">sendEmail</code><code class="p">(</code>&#13;
                <code class="n">email</code><code class="p">,</code>&#13;
                <code class="n">serverAddress</code><code class="p">,</code>&#13;
                <code class="n">username</code><code class="p">,</code>&#13;
                <code class="n">password</code>&#13;
            <code class="p">)</code>&#13;
        <code class="p">}</code>&#13;
    <code class="k">return</code> <code class="n">result</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>If we inline <code>result</code> and convert the whole function to a single expression, we are left with this functional definition:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">createEmailSender</code><code class="p">(</code>&#13;
    <code class="n">serverAddress</code><code class="p">:</code> <code class="n">InetAddress</code><code class="p">,</code>&#13;
    <code class="n">username</code><code class="p">:</code> <code class="n">String</code><code class="p">,</code>&#13;
    <code class="n">password</code><code class="p">:</code> <code class="n">String</code>&#13;
<code class="p">):</code> <code class="p">(</code><code class="n">Email</code><code class="p">)</code> <code class="p">-&gt;</code> <code class="n">Unit</code> <code class="p">=</code>&#13;
    <code class="p">{</code> <code class="n">email</code> <code class="p">-&gt;</code>&#13;
        <code class="n">sendEmail</code><code class="p">(</code>&#13;
            <code class="n">email</code><code class="p">,</code>&#13;
            <code class="n">serverAddress</code><code class="p">,</code>&#13;
            <code class="n">username</code><code class="p">,</code>&#13;
            <code class="n">password</code>&#13;
        <code class="p">)</code>&#13;
    <code class="p">}</code></pre>&#13;
&#13;
<p>So <code>createEmailSender</code> is a function that returns a lambda that calls <code>sendEmail</code>, combining the lambda’s single <code>Email</code> argument with the configuration from its own parameters.&#13;
This<a data-primary="closures" data-type="indexterm" id="idm46393372898536"/> is a closure in functional land, and it’s not a coincidence that it is very similar to the OO versions with a <code>fun interface</code> or <code>object</code> definition.</p>&#13;
&#13;
<p>To use this function, we can create it in one place and invoke it in another, very much as we did with the object solution:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="c1">// Where we know the configuration&#13;
</code><code class="k">val</code><code> </code><code class="py">sender</code><code class="p">:</code><code> </code><code class="p">(</code><code class="n">Email</code><code class="p">)</code><code> </code><code class="p">-</code><code class="p">&gt;</code><code> </code><code class="n">Unit</code><code> </code><code class="p">=</code><code> </code><code class="n">createEmailSender</code><code class="p">(</code><code>&#13;
</code><code>    </code><code class="n">inetAddress</code><code class="p">(</code><code class="s">"smtp.travelator.com"</code><code class="p">)</code><code class="p">,</code><code>&#13;
</code><code>    </code><code class="s">"username"</code><code class="p">,</code><code>&#13;
</code><code>    </code><code class="s">"password"</code><code>&#13;
</code><code class="p">)</code><code>&#13;
</code><code>&#13;
</code><code class="c1">// Where we send the message&#13;
</code><code class="k">fun</code><code> </code><code class="nf">sendThanks</code><code class="p">(</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
</code><code>    </code><code class="n">sender</code><code class="p">(</code><code> </code><a class="co" href="#callout_introduction_CO30-1" id="co_introduction_CO30-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code>        </code><code class="n">Email</code><code class="p">(</code><code>&#13;
</code><code>            </code><code class="n">to</code><code> </code><code class="p">=</code><code> </code><code class="n">parse</code><code class="p">(</code><code class="s">"support@internationalrescue.org"</code><code class="p">)</code><code class="p">,</code><code>&#13;
</code><code>            </code><code class="n">from</code><code> </code><code class="p">=</code><code> </code><code class="n">parse</code><code class="p">(</code><code class="s">"support@travelator.com"</code><code class="p">)</code><code class="p">,</code><code>&#13;
</code><code>            </code><code class="n">subject</code><code> </code><code class="p">=</code><code> </code><code class="s">"Thanks for your help"</code><code class="p">,</code><code>&#13;
</code><code>            </code><code class="n">body</code><code> </code><code class="p">=</code><code> </code><code class="s">"..."</code><code>&#13;
</code><code>        </code><code class="p">)</code><code>&#13;
</code><code>    </code><code class="p">)</code><code>&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_introduction_CO30-1" id="callout_introduction_CO30-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>An implicit <code>invoke</code> call is hidden here.</p></dd>&#13;
</dl>&#13;
&#13;
<p>This is the same shape as the OO case (if we replace the hidden <code>invoke</code> with <code>send</code>):</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">sendThanks</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="n">sender</code><code class="p">.</code><code class="n">send</code><code class="p">(</code>&#13;
        <code class="n">Email</code><code class="p">(</code>&#13;
            <code class="n">to</code> <code class="p">=</code> <code class="n">parse</code><code class="p">(</code><code class="s">"support@internationalrescue.org"</code><code class="p">),</code>&#13;
            <code class="n">from</code> <code class="p">=</code> <code class="n">parse</code><code class="p">(</code><code class="s">"support@travelator.com"</code><code class="p">),</code>&#13;
            <code class="n">subject</code> <code class="p">=</code> <code class="s">"Thanks for your help"</code><code class="p">,</code>&#13;
            <code class="n">body</code> <code class="p">=</code> <code class="s">"..."</code>&#13;
        <code class="p">)</code>&#13;
    <code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In the unlikely event that you’re joining us from JavaScript or Clojure, the functional form will be familiar, but if you came to Kotlin from Java, this solution probably feels quite alien.<a data-primary="" data-startref="IFfunencap16" data-type="indexterm" id="idm46393372753096"/><a data-primary="" data-startref="funencap16" data-type="indexterm" id="idm46393372721960"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Function Types in Java" data-type="sect1"><div class="sect1" id="idm46393373292296">&#13;
<h1>Function Types in Java</h1>&#13;
&#13;
<p>Both<a data-primary="interfaces to functions" data-secondary="function types in Java" data-type="indexterm" id="IFtypeJ16"/><a data-primary="Java" data-secondary="function types in" data-type="indexterm" id="Jfuntype16"/> the object and functional forms have allowed us to encapsulate things (in this case configuration, but it could equally well have been collaborators)&#13;
to transport them from the place where they are known to the place where they are used.&#13;
Any data structure could have done that, but because the object and the function both have an operation that can be run (<code>send</code> and <code>invoke</code>, respectively), the client can remain oblivious to the details of the configuration and just pass the information that is specific to each invocation (the <code>Email</code>).</p>&#13;
&#13;
<p>One<a data-primary="Single Abstract Method (SAM)" data-type="indexterm" id="idm46393372714184"/><a data-primary="SAM (Single Abstract Method)" data-type="indexterm" id="idm46393372713480"/> way of unifying the functional and OO solutions is to view a function as an object with a single <code>invoke</code> method.&#13;
This is exactly what Java 8 did when it introduced lambdas.&#13;
To refer to a function type, Java uses interfaces with a <em>Single Abstract Method</em> (SAM) that has the desired signature.&#13;
Lambdas in Java are a special syntax to implement a SAM interface.&#13;
The Java runtime defines SAM interfaces named by role: <code>Consumer</code>, <code>Supplier</code>, <code>Function</code>, <code>BiFunction</code>, <code>Predicate</code>, and so on for us.&#13;
It also provides primitive specializations, like <code>DoublePredicate</code>, to avoid boxing issues.</p>&#13;
&#13;
<p>Expressed in Java, our functional solution is:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="c1">// Where we know the configuration&#13;
</code><code class="n">Consumer</code><code class="o">&lt;</code><code class="n">Email</code><code class="o">&gt;</code><code> </code><code class="n">sender</code><code> </code><code class="o">=</code><code> </code><code class="n">createEmailSender</code><code class="o">(</code><code>&#13;
</code><code>    </code><code class="n">inetAddress</code><code class="o">(</code><code class="s">"example.com"</code><code class="o">)</code><code class="o">,</code><code>&#13;
</code><code>    </code><code class="s">"username"</code><code class="o">,</code><code>&#13;
</code><code>    </code><code class="s">"password"</code><code>&#13;
</code><code class="o">)</code><code class="o">;</code><code>&#13;
</code><code>&#13;
</code><code class="c1">// Where we send the message&#13;
</code><code class="kd">public</code><code> </code><code class="kt">void</code><code> </code><code class="nf">sendThanks</code><code class="o">(</code><code class="o">)</code><code> </code><code class="o">{</code><code>&#13;
</code><code>    </code><code class="n">sender</code><code class="o">.</code><code class="na">accept</code><code class="o">(</code><code> </code><a class="co" href="#callout_introduction_CO31-1" id="co_introduction_CO31-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code>        </code><code class="k">new</code><code> </code><code class="nf">Email</code><code class="o">(</code><code>&#13;
</code><code>            </code><code class="n">parse</code><code class="o">(</code><code class="s">"support@internationalrescue.org"</code><code class="o">)</code><code class="o">,</code><code>&#13;
</code><code>            </code><code class="n">parse</code><code class="o">(</code><code class="s">"support@travelator.com"</code><code class="o">)</code><code class="o">,</code><code>&#13;
</code><code>            </code><code class="s">"Thanks for your help"</code><code class="o">,</code><code>&#13;
</code><code>            </code><code class="s">"..."</code><code>&#13;
</code><code>        </code><code class="o">)</code><code>&#13;
</code><code>    </code><code class="o">)</code><code class="o">;</code><code>&#13;
</code><code class="o">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_introduction_CO31-1" id="callout_introduction_CO31-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p><code>accept</code> is the name of the single abstract method on the <code>Consumer</code> interface.</p></dd>&#13;
</dl>&#13;
&#13;
<p class="pagebreak-before"><code>createEmailSender</code> can be implemented with a lambda:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">static</code> <code class="n">Consumer</code><code class="o">&lt;</code><code class="n">Email</code><code class="o">&gt;</code> <code class="nf">createEmailSender</code><code class="o">(</code>&#13;
    <code class="n">InetAddress</code> <code class="n">serverAddress</code><code class="o">,</code>&#13;
    <code class="n">String</code> <code class="n">username</code><code class="o">,</code>&#13;
    <code class="n">String</code> <code class="n">password</code>&#13;
<code class="o">)</code> <code class="o">{</code>&#13;
    <code class="k">return</code> <code class="n">email</code> <code class="o">-&gt;</code> <code class="n">sendEmail</code><code class="o">(</code>&#13;
        <code class="n">email</code><code class="o">,</code>&#13;
        <code class="n">serverAddress</code><code class="o">,</code>&#13;
        <code class="n">username</code><code class="o">,</code>&#13;
        <code class="n">password</code>&#13;
    <code class="o">);</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>This is equivalent to creating an anonymous implementation of the interface, a technique that will be very familiar to those of us who programmed in Java before Java 8:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">static</code> <code class="n">Consumer</code><code class="o">&lt;</code><code class="n">Email</code><code class="o">&gt;</code> <code class="nf">createEmailSender</code><code class="o">(</code>&#13;
    <code class="n">InetAddress</code> <code class="n">serverAddress</code><code class="o">,</code>&#13;
    <code class="n">String</code> <code class="n">username</code><code class="o">,</code>&#13;
    <code class="n">String</code> <code class="n">password</code>&#13;
<code class="o">)</code> <code class="o">{</code>&#13;
    <code class="k">return</code> <code class="k">new</code> <code class="n">Consumer</code><code class="o">&lt;</code><code class="n">Email</code><code class="o">&gt;()</code> <code class="o">{</code>&#13;
        <code class="nd">@Override</code>&#13;
        <code class="kd">public</code> <code class="kt">void</code> <code class="nf">accept</code><code class="o">(</code><code class="n">Email</code> <code class="n">email</code><code class="o">)</code> <code class="o">{</code>&#13;
            <code class="n">sendEmail</code><code class="o">(</code>&#13;
                <code class="n">email</code><code class="o">,</code>&#13;
                <code class="n">serverAddress</code><code class="o">,</code>&#13;
                <code class="n">username</code><code class="o">,</code>&#13;
                <code class="n">password</code>&#13;
            <code class="o">);</code>&#13;
        <code class="o">}</code>&#13;
    <code class="o">};</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>We say “equivalent to creating an anonymous implementation of the interface,” but under the hood, the implementation is more complex to avoid unnecessarily defining classes and instantiating objects.</p>&#13;
&#13;
<p>Note that we can’t assign the <code>(Email) -&gt; Unit</code> result of the Kotlin <code>createEmailSender</code> to a variable of type <code>Consumer&lt;Email&gt;</code>.&#13;
This is because the Kotlin runtime uses its own function types, and the compiler compiles <code>(Email) -&gt; Unit</code> into <code>Function1&lt;Email, Unit&gt;</code>.&#13;
There are a whole series of Kotlin <code>FunctionN</code> interfaces for the different numbers of parameters.</p>&#13;
&#13;
<p class="pagebreak-after">Because the interfaces are not compatible, to mix Java and Kotlin at this functional level, we will have to thunk sometimes.&#13;
Given a Kotlin function type <code>(Email) -&gt; Unit</code>:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="c1">// Kotlin function type</code>&#13;
<code class="k">val</code> <code class="py">sender</code><code class="p">:</code> <code class="p">(</code><code class="n">Email</code><code class="p">)</code> <code class="p">-&gt;</code> <code class="n">Unit</code> <code class="p">=</code> <code class="n">createEmailSender</code><code class="p">(</code>&#13;
    <code class="n">inetAddress</code><code class="p">(</code><code class="s">"smtp.travelator.com"</code><code class="p">),</code>&#13;
    <code class="s">"username"</code><code class="p">,</code>&#13;
    <code class="s">"password"</code>&#13;
<code class="p">)</code></pre>&#13;
&#13;
<p>We can’t just assign <code>sender</code> to <code>Consumer&lt;Email</code>:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code><code> </code><code class="py">consumer</code><code class="p">:</code><code> </code><code class="n">Consumer</code><code class="p">&lt;</code><code class="n">Email</code><code class="p">&gt;</code><code> </code><code class="p">=</code><code> </code><code class="n">sender</code><code> </code><code class="c1">// Doesn't compile </code><a class="co" href="#callout_introduction_CO32-1" id="co_introduction_CO32-1"><img alt="1" src="assets/1.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_introduction_CO32-1" id="callout_introduction_CO32-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p><code>Type mismatch. Required: Consumer&lt;Email&gt; Found:(Email) -&gt; Unit</code></p></dd>&#13;
</dl>&#13;
&#13;
<p>We can, though, convert with a lambda:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">consumer</code><code class="p">:</code> <code class="n">Consumer</code><code class="p">&lt;</code><code class="n">Email</code><code class="p">&gt;</code> <code class="p">=</code> <code class="n">Consumer</code><code class="p">&lt;</code><code class="n">Email</code><code class="p">&gt;</code> <code class="p">{</code> <code class="n">email</code> <code class="p">-&gt;</code>&#13;
    <code class="n">sender</code><code class="p">(</code><code class="n">email</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>There is a situation where we don’t have to convert, which is calling a Java method that takes a SAM parameter, for example, this constructor:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">class</code> <code class="nc">Rescuing</code> <code class="o">{</code>&#13;
    <code class="kd">private</code> <code class="kd">final</code> <code class="n">Consumer</code><code class="o">&lt;</code><code class="n">Email</code><code class="o">&gt;</code> <code class="n">emailSender</code><code class="o">;</code>&#13;
&#13;
    <code class="n">Rescuing</code><code class="o">(</code><code class="n">Consumer</code><code class="o">&lt;</code><code class="n">Email</code><code class="o">&gt;</code> <code class="n">emailSender</code><code class="o">)</code> <code class="o">{</code>&#13;
        <code class="k">this</code><code class="o">.</code><code class="na">emailSender</code> <code class="o">=</code> <code class="n">emailSender</code><code class="o">;</code>&#13;
    <code class="o">}</code>&#13;
    <code class="o">...</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>Here,<a data-primary="" data-startref="IFtypeJ16" data-type="indexterm" id="idm46393372336408"/><a data-primary="" data-startref="Jfuntype16" data-type="indexterm" id="idm46393372290712"/> the compiler <em>is</em> able to convert <code>(Email) -&gt; Unit</code> to <code>Consumer&lt;Email&gt;</code>, because Kotlin will convert parameters automatically, so that we can say:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">Rescuing</code><code class="p">(</code><code class="n">sender</code><code class="p">)</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Mix and Match" data-type="sect1"><div class="sect1" id="idm46393372720264">&#13;
<h1>Mix and Match</h1>&#13;
&#13;
<p>There<a data-primary="interfaces to functions" data-secondary="unifying the approaches" data-type="indexterm" id="IFunify16"/> are two sides to an abstraction, the client code and the implementation code.&#13;
So far, both client and implementor have either been object-oriented or functional.&#13;
In the OO case, fields carry configuration, and the client invokes a method.&#13;
In the functional scheme, a function closes over the configuration, and the client invokes the function.</p>&#13;
&#13;
<p>Can we unify these approaches, passing an OO implementation to a function-expecting client or vice versa?&#13;
Or, in Kotlin terms, can we convert <code>ISendEmail</code> to <code>(Email) -&gt; Unit</code> and the inverse?&#13;
Why yes we can!</p>&#13;
&#13;
<p>Remember that in Java and Kotlin, function types are just interfaces.&#13;
Because of this, <code>EmailSender</code> can implement the type <code>Consumer&lt;Email&gt;</code> or  <code>(Email) -&gt; Unit</code>, respectively, by defining a method with the signature of the function type.</p>&#13;
&#13;
<p>So in Java, we can write:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code> </code><code class="kd">class</code><code> </code><code class="nc">EmailSender</code><code>&#13;
</code><code>    </code><code class="kd">implements</code><code> </code><code class="n">ISendEmail</code><code class="o">,</code><code>&#13;
</code><code>        </code><code class="n">Consumer</code><code class="o">&lt;</code><code class="n">Email</code><code class="o">&gt;</code><code> </code><a class="co" href="#callout_introduction_CO33-1" id="co_introduction_CO33-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code class="o">{</code><code>&#13;
</code><code>        </code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>&#13;
</code><code>    </code><code class="nd">@Override</code><code>&#13;
</code><code>    </code><code class="kd">public</code><code> </code><code class="kt">void</code><code> </code><code class="nf">accept</code><code class="o">(</code><code class="n">Email</code><code> </code><code class="n">email</code><code class="o">)</code><code> </code><code class="o">{</code><code> </code><a class="co" href="#callout_introduction_CO33-2" id="co_introduction_CO33-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
</code><code>        </code><code class="n">send</code><code class="o">(</code><code class="n">email</code><code class="o">)</code><code class="o">;</code><code>&#13;
</code><code>    </code><code class="o">}</code><code>&#13;
</code><code>&#13;
</code><code>    </code><code class="nd">@Override</code><code>&#13;
</code><code>    </code><code class="kd">public</code><code> </code><code class="kt">void</code><code> </code><code class="nf">send</code><code class="o">(</code><code class="n">Email</code><code> </code><code class="n">email</code><code class="o">)</code><code> </code><code class="o">{</code><code>&#13;
</code><code>        </code><code class="n">sendEmail</code><code class="o">(</code><code class="n">email</code><code class="o">,</code><code> </code><code class="n">serverAddress</code><code class="o">,</code><code> </code><code class="n">username</code><code class="o">,</code><code> </code><code class="n">password</code><code class="o">)</code><code class="o">;</code><code>&#13;
</code><code>    </code><code class="o">}</code><code>&#13;
</code><code class="o">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_introduction_CO33-1" id="callout_introduction_CO33-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Declare</p></dd>&#13;
<dt><a class="co" href="#co_introduction_CO33-2" id="callout_introduction_CO33-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Implement</p></dd>&#13;
</dl>&#13;
&#13;
<p>This is the Kotlin equivalent:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code><code> </code><code class="nc">EmailSender</code><code class="p">(</code><code>&#13;
</code><code>        </code><code class="p">.</code><code class="p">.</code><code class="p">.</code><code>&#13;
</code><code class="p">)</code><code> </code><code class="p">:</code><code> </code><code class="n">ISendEmail</code><code class="p">,</code><code>&#13;
</code><code>    </code><code class="p">(</code><code class="n">Email</code><code class="p">)</code><code> </code><code class="p">-</code><code class="p">&gt;</code><code> </code><code class="n">Unit</code><code> </code><a class="co" href="#callout_introduction_CO34-1" id="co_introduction_CO34-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code class="p">{</code><code>&#13;
</code><code>    </code><code class="k">override</code><code> </code><code class="n">operator</code><code> </code><code class="k">fun</code><code> </code><code class="nf">invoke</code><code class="p">(</code><code class="n">email</code><code class="p">:</code><code> </code><code class="n">Email</code><code class="p">)</code><code> </code><code class="p">=</code><code>&#13;
</code><code>        </code><code class="n">send</code><code class="p">(</code><code class="n">email</code><code class="p">)</code><code> </code><a class="co" href="#callout_introduction_CO34-2" id="co_introduction_CO34-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
</code><code>&#13;
</code><code>    </code><code class="k">override</code><code> </code><code class="k">fun</code><code> </code><code class="nf">send</code><code class="p">(</code><code class="n">email</code><code class="p">:</code><code> </code><code class="n">Email</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
</code><code>        </code><code class="n">sendEmail</code><code class="p">(</code><code>&#13;
</code><code>            </code><code class="n">email</code><code class="p">,</code><code>&#13;
</code><code>            </code><code class="n">serverAddress</code><code class="p">,</code><code>&#13;
</code><code>            </code><code class="n">username</code><code class="p">,</code><code>&#13;
</code><code>            </code><code class="n">password</code><code>&#13;
</code><code>        </code><code class="p">)</code><code>&#13;
</code><code>    </code><code class="p">}</code><code>&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_introduction_CO34-1" id="callout_introduction_CO34-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Declare</p></dd>&#13;
<dt><a class="co" href="#co_introduction_CO34-2" id="callout_introduction_CO34-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Implement</p></dd>&#13;
</dl>&#13;
&#13;
<p>If we do this, we can use our class-based sender in place of our functional one.&#13;
We’ll stick with Kotlin now:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="c1">// Where we know the configuration&#13;
</code><code class="k">val</code><code> </code><code class="py">sender</code><code class="p">:</code><code> </code><code class="p">(</code><code class="n">Email</code><code class="p">)</code><code> </code><code class="p">-</code><code class="p">&gt;</code><code> </code><code class="n">Unit</code><code> </code><code class="p">=</code><code> </code><code class="n">EmailSender</code><code class="p">(</code><code>&#13;
</code><code>    </code><code class="n">inetAddress</code><code class="p">(</code><code class="s">"smtp.travelator.com"</code><code class="p">)</code><code class="p">,</code><code>&#13;
</code><code>    </code><code class="s">"username"</code><code class="p">,</code><code>&#13;
</code><code>    </code><code class="s">"password"</code><code>&#13;
</code><code class="p">)</code><code>&#13;
</code><code>&#13;
</code><code class="c1">// Where we send the message&#13;
</code><code class="k">fun</code><code> </code><code class="nf">sendThanks</code><code class="p">(</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
</code><code>    </code><code class="n">sender</code><code class="p">(</code><code> </code><a class="co" href="#callout_introduction_CO35-1" id="co_introduction_CO35-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code>        </code><code class="n">Email</code><code class="p">(</code><code>&#13;
</code><code>            </code><code class="n">to</code><code> </code><code class="p">=</code><code> </code><code class="n">parse</code><code class="p">(</code><code class="s">"support@internationalrescue.org"</code><code class="p">)</code><code class="p">,</code><code>&#13;
</code><code>            </code><code class="n">from</code><code> </code><code class="p">=</code><code> </code><code class="n">parse</code><code class="p">(</code><code class="s">"support@travelator.com"</code><code class="p">)</code><code class="p">,</code><code>&#13;
</code><code>            </code><code class="n">subject</code><code> </code><code class="p">=</code><code> </code><code class="s">"Thanks for your help"</code><code class="p">,</code><code>&#13;
</code><code>            </code><code class="n">body</code><code> </code><code class="p">=</code><code> </code><code class="s">"..."</code><code>&#13;
</code><code>        </code><code class="p">)</code><code>&#13;
</code><code>    </code><code class="p">)</code><code>&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_introduction_CO35-1" id="callout_introduction_CO35-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>There is an implicit <code>invoke</code> here.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Now our object-oriented implementation has gained an <code>invoke</code> method to fit in with the functional approach.&#13;
This calls into question the usefulness of our <code>ISendEmail</code> interface.&#13;
We can see that it is equivalent to the function type <code>(Email) -&gt; Unit</code>.&#13;
All it does is give the name <code>send</code> to what happens when you invoke it.&#13;
Maybe we could just use the type <code>(Email) -&gt; Unit</code> everywhere in place of <code>ISendEmail</code>?</p>&#13;
&#13;
<p>If you think that isn’t expressive enough, then maybe you aren’t a functional programmer.&#13;
Luckily, there is a middle ground: we can use a type alias to give a name to the functional type, thus communicating our intent:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">typealias</code> <code class="n">EmailSenderFunction</code> <code class="p">=</code> <code class="p">(</code><code class="n">Email</code><code class="p">)</code> <code class="p">-&gt;</code> <code class="n">Unit</code>&#13;
&#13;
<code class="k">class</code> <code class="nc">EmailSender</code><code class="p">(</code>&#13;
    <code class="p">...</code>&#13;
<code class="p">)</code> <code class="p">:</code> <code class="n">EmailSenderFunction</code> <code class="p">{</code>&#13;
    <code class="k">override</code> <code class="k">fun</code> <code class="nf">invoke</code><code class="p">(</code><code class="n">email</code><code class="p">:</code> <code class="n">Email</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="n">sendEmail</code><code class="p">(</code>&#13;
            <code class="n">email</code><code class="p">,</code>&#13;
            <code class="n">serverAddress</code><code class="p">,</code>&#13;
            <code class="n">username</code><code class="p">,</code>&#13;
            <code class="n">password</code>&#13;
        <code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In reality, we would probably call <code>EmailSenderFunction</code>, <code>EmailSender</code>.&#13;
Here we’ve given it a different name to avoid confusion with the OO version, but the fact that we want to call them the same thing shows that they serve the same purpose from the client’s perspective.</p>&#13;
<aside class="pagebreak-before less_space" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46393371846728">&#13;
<h5>Expressive Function Types</h5>&#13;
<p>Once<a data-primary="expressive function types" data-type="indexterm" id="idm46393371845032"/> we have our head in the functional mindset, the type <code>(Email) -&gt; Unit</code> may be expressive enough to tell us the role of the function, especially when bound to a variable named <code>sender</code>.&#13;
What can you do with an email that doesn’t return a result?&#13;
Well, if it doesn’t return a result, it must be<a data-primary="actions" data-secondary="expressive function types and" data-type="indexterm" id="idm46393371843144"/> an action (<a data-type="xref" href="ch07.html#actions">“Actions”</a>), but deleting an email might also have a similar signature.&#13;
Objects have that advantage over &#13;
<span class="keep-together">functions—they</span> get to name their methods (<code>send(email)</code> is obviously different than <code>delete(email)</code>)—at the expense of also having to name the type of the object or &#13;
<span class="keep-together">interface</span>.</p>&#13;
&#13;
<p>Kotlin has a feature that can help make function types more expressive: we can name the parameters.&#13;
So if it helps, we could write <code>(toSend: Email) -&gt; Unit</code>.&#13;
It doesn’t make a great difference here but can be very useful in situations with parameters of the same type, for example <code>(username: String, password: String) -&gt;</code> &#13;
<span class="keep-together"><code>AuthenticatedUser</code></span>.&#13;
If we use this form, IntelliJ will even helpfully name the parameters when we implement the function with a lambda or a class.</p>&#13;
</div></aside>&#13;
&#13;
<p>There is another way of bridging the OO–FP gap that doesn’t involve making our classes implement function types: create a function reference at the point of translation.&#13;
Here is our old class-based solution:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">EmailSender</code><code class="p">(</code>&#13;
    <code class="k">private</code> <code class="k">val</code> <code class="py">serverAddress</code><code class="p">:</code> <code class="n">InetAddress</code><code class="p">,</code>&#13;
    <code class="k">private</code> <code class="k">val</code> <code class="py">username</code><code class="p">:</code> <code class="n">String</code><code class="p">,</code>&#13;
    <code class="k">private</code> <code class="k">val</code> <code class="py">password</code><code class="p">:</code> <code class="n">String</code>&#13;
<code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">fun</code> <code class="nf">send</code><code class="p">(</code><code class="n">email</code><code class="p">:</code> <code class="n">Email</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="n">sendEmail</code><code class="p">(</code>&#13;
            <code class="n">email</code><code class="p">,</code>&#13;
            <code class="n">serverAddress</code><code class="p">,</code>&#13;
            <code class="n">username</code><code class="p">,</code>&#13;
            <code class="n">password</code>&#13;
        <code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>We can convert an instance of <code>EmailSender</code> to a function type with a lambda:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">instance</code> <code class="p">=</code> <code class="n">EmailSender</code><code class="p">(</code>&#13;
    <code class="n">inetAddress</code><code class="p">(</code><code class="s">"smtp.travelator.com"</code><code class="p">),</code>&#13;
    <code class="s">"username"</code><code class="p">,</code>&#13;
    <code class="s">"password"</code>&#13;
<code class="p">)</code>&#13;
<code class="k">val</code> <code class="py">sender</code><code class="p">:</code> <code class="p">(</code><code class="n">Email</code><code class="p">)</code> <code class="p">-&gt;</code> <code class="n">Unit</code> <code class="p">=</code> <code class="p">{</code> <code class="n">instance</code><code class="p">.</code><code class="n">send</code><code class="p">(</code><code class="n">it</code><code class="p">)</code> <code class="p">}</code></pre>&#13;
&#13;
<p>or just use a method reference:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">sender</code><code class="p">:</code> <code class="p">(</code><code class="n">Email</code><code class="p">)</code> <code class="p">-&gt;</code> <code class="n">Unit</code> <code class="p">=</code> <code class="n">instance</code><code class="o">::</code><code class="n">send</code></pre>&#13;
&#13;
<p>Although we’ve shown these conversions in Kotlin, they also work in Java (with a slightly different syntax).&#13;
They work with the <code>send</code> method on the <code>ISendEmail</code> interface too, although it’s not clear that the interface is doing much for us if we are using the function type.</p>&#13;
&#13;
<p>Can we do the opposite and pass our functional sender into something that expects an <code>ISendEmail</code>?&#13;
This requires more ceremony, because we have to create an anonymous object implementing <code>ISendEmail</code> to perform the thunk:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">function</code><code class="p">:</code> <code class="p">(</code><code class="n">Email</code><code class="p">)</code> <code class="p">-&gt;</code> <code class="n">Unit</code> <code class="p">=</code> <code class="n">createEmailSender</code><code class="p">(</code>&#13;
    <code class="n">inetAddress</code><code class="p">(</code><code class="s">"smtp.travelator.com"</code><code class="p">),</code>&#13;
    <code class="s">"username"</code><code class="p">,</code>&#13;
    <code class="s">"password"</code>&#13;
<code class="p">)</code>&#13;
&#13;
<code class="k">val</code> <code class="py">sender</code><code class="p">:</code> <code class="n">ISendEmail</code> <code class="p">=</code> <code class="k">object</code> <code class="err">: </code><code class="nc">ISendEmail</code> <code class="p">{</code>&#13;
    <code class="k">override</code> <code class="k">fun</code> <code class="nf">send</code><code class="p">(</code><code class="n">email</code><code class="p">:</code> <code class="n">Email</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="n">function</code><code class="p">(</code><code class="n">email</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>If<a data-primary="" data-startref="IFunify16" data-type="indexterm" id="idm46393371618104"/> we had used a Kotlin 1.4 <code>fun interface</code>, we could again remove some boilerplate:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">interface</code> <code class="n">ISendEmail</code> <code class="p">{</code>&#13;
    <code class="k">fun</code> <code class="nf">send</code><code class="p">(</code><code class="n">email</code><code class="p">:</code> <code class="n">Email</code><code class="p">)</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="k">val</code> <code class="py">sender</code> <code class="p">=</code> <code class="n">ISendEmail</code> <code class="p">{</code> <code class="n">function</code><code class="p">(</code><code class="n">it</code><code class="p">)</code> <code class="p">}</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Comparing the Approaches" data-type="sect1"><div class="sect1" id="idm46393371565688">&#13;
<h1>Comparing the Approaches</h1>&#13;
&#13;
<p>Let’s<a data-primary="interfaces to functions" data-secondary="comparing the approaches" data-type="indexterm" id="IFcomp16"/> remind ourselves of the OO approach.</p>&#13;
&#13;
<p>First we define a type:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">EmailSender</code><code class="p">(</code>&#13;
    <code class="k">private</code> <code class="k">val</code> <code class="py">serverAddress</code><code class="p">:</code> <code class="n">InetAddress</code><code class="p">,</code>&#13;
    <code class="k">private</code> <code class="k">val</code> <code class="py">username</code><code class="p">:</code> <code class="n">String</code><code class="p">,</code>&#13;
    <code class="k">private</code> <code class="k">val</code> <code class="py">password</code><code class="p">:</code> <code class="n">String</code>&#13;
<code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">fun</code> <code class="nf">send</code><code class="p">(</code><code class="n">email</code><code class="p">:</code> <code class="n">Email</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="n">sendEmail</code><code class="p">(</code>&#13;
            <code class="n">email</code><code class="p">,</code>&#13;
            <code class="n">serverAddress</code><code class="p">,</code>&#13;
            <code class="n">username</code><code class="p">,</code>&#13;
            <code class="n">password</code>&#13;
        <code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Then we create instances and call methods:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="c1">// Where we know the configuration</code>&#13;
<code class="k">val</code> <code class="py">sender</code><code class="p">:</code> <code class="n">EmailSender</code> <code class="p">=</code> <code class="n">EmailSender</code><code class="p">(</code>&#13;
    <code class="n">inetAddress</code><code class="p">(</code><code class="s">"smtp.travelator.com"</code><code class="p">),</code>&#13;
    <code class="s">"username"</code><code class="p">,</code>&#13;
    <code class="s">"password"</code>&#13;
<code class="p">)</code>&#13;
&#13;
<code class="c1">// Where we send the message</code>&#13;
<code class="k">fun</code> <code class="nf">sendThanks</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="n">sender</code><code class="p">.</code><code class="n">send</code><code class="p">(</code>&#13;
        <code class="n">Email</code><code class="p">(</code>&#13;
            <code class="n">to</code> <code class="p">=</code> <code class="n">parse</code><code class="p">(</code><code class="s">"support@internationalrescue.org"</code><code class="p">),</code>&#13;
            <code class="n">from</code> <code class="p">=</code> <code class="n">parse</code><code class="p">(</code><code class="s">"support@travelator.com"</code><code class="p">),</code>&#13;
            <code class="n">subject</code> <code class="p">=</code> <code class="s">"Thanks for your help"</code><code class="p">,</code>&#13;
            <code class="n">body</code> <code class="p">=</code> <code class="s">"..."</code>&#13;
        <code class="p">)</code>&#13;
    <code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In functional land, we don’t have to define a type, because <code>(Email) -&gt; Unit</code> just exists (which is to say, is provided by the runtime), so we can just say:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="c1">// Where we know the configuration&#13;
</code><code class="k">val</code><code> </code><code class="py">sender</code><code class="p">:</code><code> </code><code class="p">(</code><code class="n">Email</code><code class="p">)</code><code> </code><code class="p">-</code><code class="p">&gt;</code><code> </code><code class="n">Unit</code><code> </code><code class="p">=</code><code> </code><code class="n">createEmailSender</code><code class="p">(</code><code>&#13;
</code><code>    </code><code class="n">inetAddress</code><code class="p">(</code><code class="s">"smtp.travelator.com"</code><code class="p">)</code><code class="p">,</code><code>&#13;
</code><code>    </code><code class="s">"username"</code><code class="p">,</code><code>&#13;
</code><code>    </code><code class="s">"password"</code><code>&#13;
</code><code class="p">)</code><code>&#13;
</code><code>&#13;
</code><code class="c1">// Where we send the message&#13;
</code><code class="k">fun</code><code> </code><code class="nf">sendThanks</code><code class="p">(</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
</code><code>    </code><code class="n">sender</code><code class="p">(</code><code> </code><a class="co" href="#callout_introduction_CO36-1" id="co_introduction_CO36-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code>        </code><code class="n">Email</code><code class="p">(</code><code>&#13;
</code><code>            </code><code class="n">to</code><code> </code><code class="p">=</code><code> </code><code class="n">parse</code><code class="p">(</code><code class="s">"support@internationalrescue.org"</code><code class="p">)</code><code class="p">,</code><code>&#13;
</code><code>            </code><code class="n">from</code><code> </code><code class="p">=</code><code> </code><code class="n">parse</code><code class="p">(</code><code class="s">"support@travelator.com"</code><code class="p">)</code><code class="p">,</code><code>&#13;
</code><code>            </code><code class="n">subject</code><code> </code><code class="p">=</code><code> </code><code class="s">"Thanks for your help"</code><code class="p">,</code><code>&#13;
</code><code>            </code><code class="n">body</code><code> </code><code class="p">=</code><code> </code><code class="s">"..."</code><code>&#13;
</code><code>        </code><code class="p">)</code><code>&#13;
</code><code>    </code><code class="p">)</code><code>&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_introduction_CO36-1" id="callout_introduction_CO36-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>With or without the <code>invoke</code></p></dd>&#13;
</dl>&#13;
&#13;
<p>Clients using the <em>object</em> have to know to call the <code>send</code> method to send email; in contrast, clients using the <em>function</em> just have to invoke it, but they only know that the function sends email because it has been assigned the name <code>sender</code>.&#13;
If that name got lost in the call hierarchy, we are left to guess what happens from the function &#13;
<span class="keep-together">signature</span>.</p>&#13;
&#13;
<p>The quid pro quo of the OO clients having to know to call the <code>send</code> method is that we could package up a number of email-related operations into an <code>EmailSystem</code>, with methods like <code>send</code>, <code>list</code>, and <code>delete</code>, and pass all this functionality to clients in one go.&#13;
Clients can then choose which they need in which context:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">interface</code> <code class="n">EmailSystem</code> <code class="p">{</code>&#13;
    <code class="k">fun</code> <code class="nf">send</code><code class="p">(</code><code class="n">email</code><code class="p">:</code> <code class="n">Email</code><code class="p">)</code>&#13;
    <code class="k">fun</code> <code class="nf">delete</code><code class="p">(</code><code class="n">email</code><code class="p">:</code> <code class="n">Email</code><code class="p">)</code>&#13;
    <code class="k">fun</code> <code class="nf">list</code><code class="p">(</code><code class="n">folder</code><code class="p">:</code> <code class="n">Folder</code><code class="p">):</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">Email</code><code class="p">&gt;</code>&#13;
    <code class="k">fun</code> <code class="nf">move</code><code class="p">(</code><code class="n">email</code><code class="p">:</code> <code class="n">Email</code><code class="p">,</code> <code class="n">to</code><code class="p">:</code> <code class="n">Folder</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>To achieve this functionally would require either passing individual functions around or some sort of map of name to function, maybe an instance of a class itself:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">EmailSystem</code><code class="p">(</code>&#13;
    <code class="k">val</code> <code class="py">send</code><code class="p">:</code> <code class="p">(</code><code class="n">Email</code><code class="p">)</code> <code class="p">-&gt;</code> <code class="n">Unit</code><code class="p">,</code>&#13;
    <code class="k">val</code> <code class="py">delete</code><code class="p">:</code> <code class="p">(</code><code class="n">Email</code><code class="p">)</code> <code class="p">-&gt;</code> <code class="n">Unit</code><code class="p">,</code>&#13;
    <code class="k">val</code> <code class="py">list</code><code class="p">:</code> <code class="p">(</code><code class="n">folder</code><code class="p">:</code> <code class="n">Folder</code><code class="p">)</code> <code class="p">-&gt;</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">Email</code><code class="p">&gt;,</code>&#13;
    <code class="k">val</code> <code class="py">move</code><code class="p">:</code> <code class="p">(</code><code class="n">email</code><code class="p">:</code> <code class="n">Email</code><code class="p">,</code> <code class="n">to</code><code class="p">:</code> <code class="n">Folder</code><code class="p">)</code> <code class="p">-&gt;</code>  <code class="n">Unit</code>&#13;
<code class="p">)</code></pre>&#13;
&#13;
<p>Given such an object, clients could treat it very much like an implementation of the interface:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">sendThanks</code><code class="p">(</code><code class="n">sender</code><code class="p">:</code> <code class="n">EmailSystem</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="n">sender</code><code class="p">.</code><code class="n">send</code><code class="p">(</code>&#13;
        <code class="n">Email</code><code class="p">(</code>&#13;
            <code class="n">to</code> <code class="p">=</code> <code class="n">parse</code><code class="p">(</code><code class="s">"support@internationalrescue.org"</code><code class="p">),</code>&#13;
            <code class="n">from</code> <code class="p">=</code> <code class="n">parse</code><code class="p">(</code><code class="s">"support@travelator.com"</code><code class="p">),</code>&#13;
            <code class="n">subject</code> <code class="p">=</code> <code class="s">"Thanks for your help"</code><code class="p">,</code>&#13;
            <code class="n">body</code> <code class="p">=</code> <code class="s">"..."</code>&#13;
        <code class="p">)</code>&#13;
    <code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>But this is not the same as the OO code.&#13;
Instead of invoking a <code>send</code> <em>method</em>, what is actually happening here is that we are calling <code>getSender</code> to access a property of function type, and then calling <code>invoke</code> on that function:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">sendThanks</code><code class="p">(</code><code class="n">sender</code><code class="p">:</code> <code class="n">EmailSystem</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="n">sender</code><code class="p">.</code><code class="n">send</code><code class="p">.</code><code class="n">invoke</code><code class="p">(</code>&#13;
        <code class="n">Email</code><code class="p">(</code>&#13;
            <code class="n">to</code> <code class="p">=</code> <code class="n">parse</code><code class="p">(</code><code class="s">"support@internationalrescue.org"</code><code class="p">),</code>&#13;
            <code class="n">from</code> <code class="p">=</code> <code class="n">parse</code><code class="p">(</code><code class="s">"support@travelator.com"</code><code class="p">),</code>&#13;
            <code class="n">subject</code> <code class="p">=</code> <code class="s">"Thanks for your help"</code><code class="p">,</code>&#13;
            <code class="n">body</code> <code class="p">=</code> <code class="s">"..."</code>&#13;
        <code class="p">)</code>&#13;
    <code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The code may read the same, but it generates very different, and fundamentally incompatible, bytecode.<a data-primary="" data-startref="IFcomp16" data-type="indexterm" id="idm46393371035384"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Coupling" data-type="sect1"><div class="sect1" id="idm46393371581016">&#13;
<h1>Coupling</h1>&#13;
&#13;
<p>A<a data-primary="interfaces to functions" data-secondary="coupling" data-type="indexterm" id="idm46393370970568"/><a data-primary="coupling" data-type="indexterm" id="idm46393370969560"/> subtle difference between expressing a dependency as either an implementation of <code>ISendEmail</code>, or as an implementation of the function type <code>(Email) -&gt; Unit</code>, is the coupling between the client and the implementation, in particular when they are in different code modules.</p>&#13;
&#13;
<p><code>ISendEmail</code> has to be defined somewhere.&#13;
The client can’t define it, because the implementor will depend on the interface, and the client on the implementation, leading to a circular dependency.&#13;
So the interface has to be defined either with the implementation, or in a separate place (package or JAR file) depended on by both implementation and its clients.&#13;
The latter (an application of the <a href="https://oreil.ly/AcrWj">dependency inversion principle</a>) is in theory preferable but in practice more work and thus often neglected.</p>&#13;
&#13;
<p>With<a data-primary="dependency inversion" data-type="indexterm" id="idm46393370965656"/> or without dependency inversion, the result is the client and implementation being coupled by the interface in ways that can make systems hard to reason with and refactor.&#13;
Any change to methods on <code>EmailSystem</code> might affect all code that depends on the interface.</p>&#13;
&#13;
<p>In contrast, in the functional world, the runtime defines all the function types, so they don’t introduce a compile-time dependency between the client and an implementation.&#13;
Unlike <code>ISendEmail</code>, which we have to define somewhere, <code>(Email) -&gt; Unit</code> (or in Java, <code>Consumer&lt;Email&gt;</code>) is part of the language.&#13;
Of course, there will be a runtime dependency—the constructor code needs to be visible where the dependency is created, and the client has to be able to invoke the implementation code—but these cause less coupling.&#13;
For example, when a dependency is expressed as a function type, we can rename <code>EmailSystem.send</code>, and the only change in our client code will be to use a different method reference; the internals of <code>sendThanks</code> are unaffected.</p>&#13;
<div data-type="tip"><h1>Only Pass Types That You Own or That the Runtime Defines</h1>&#13;
<p>An early rule of thumb for OO systems was that, on the inside of our systems, we should program in terms of types that we own rather than those supplied by libraries.&#13;
That way we are insulated from changes that we don’t control and are more likely to write code that can be reused with different implementations.</p>&#13;
&#13;
<p>An exception to this rule is taking a dependency on types provided by the runtime; these are very unlikely to change.&#13;
Function types allow us to easily convert from unstable to stable interfaces, allowing parts of our systems to evolve at different rates.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Object-Oriented or Functional?" data-type="sect1"><div class="sect1" id="idm46393370958360">&#13;
<h1>Object-Oriented or Functional?</h1>&#13;
&#13;
<p>Both<a data-primary="interfaces to functions" data-secondary="selecting one over the other" data-type="indexterm" id="IFselect16"/> the object-oriented and functional approaches can achieve the same goals, and with similar levels of expressiveness.&#13;
Which should we choose?</p>&#13;
&#13;
<p>Let’s consider this from the context of the client code.&#13;
If our client only needs to list email, it should have a dependency on a single <code>(Folder) -&gt; List&lt;Email&gt;</code> function.&#13;
This way it is not coupled to an implementation, and the dependency can be satisfied by anything implementing the function type, including:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>A plain function</p>&#13;
</li>&#13;
<li>&#13;
<p>An object implementing the function type</p>&#13;
</li>&#13;
<li>&#13;
<p>Method reference selecting a method with the desired signature</p>&#13;
</li>&#13;
<li>&#13;
<p>A lambda with the desired signature</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Even if we already happen to have an interface, let’s say <code>EmailSystem</code>, which defines the desired method along with <code>send</code>, <code>move</code>, and <code>delete</code>:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">interface</code> <code class="n">EmailSystem</code> <code class="p">{</code>&#13;
    <code class="k">fun</code> <code class="nf">send</code><code class="p">(</code><code class="n">email</code><code class="p">:</code> <code class="n">Email</code><code class="p">)</code>&#13;
    <code class="k">fun</code> <code class="nf">delete</code><code class="p">(</code><code class="n">email</code><code class="p">:</code> <code class="n">Email</code><code class="p">)</code>&#13;
    <code class="k">fun</code> <code class="nf">list</code><code class="p">(</code><code class="n">folder</code><code class="p">:</code> <code class="n">Folder</code><code class="p">):</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">Email</code><code class="p">&gt;</code>&#13;
    <code class="k">fun</code> <code class="nf">move</code><code class="p">(</code><code class="n">email</code><code class="p">:</code> <code class="n">Email</code><code class="p">,</code> <code class="n">to</code><code class="p">:</code> <code class="n">Folder</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>we shouldn’t needlessly couple our client to this interface when the function type will do:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">Organiser</code><code class="p">(</code>&#13;
    <code class="k">private</code> <code class="k">val</code> <code class="py">listing</code><code class="p">:</code> <code class="p">(</code><code class="n">Folder</code><code class="p">)</code> <code class="p">-&gt;</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">Email</code><code class="p">&gt;</code>&#13;
<code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">fun</code> <code class="nf">subjectsIn</code><code class="p">(</code><code class="n">folder</code><code class="p">:</code> <code class="n">Folder</code><code class="p">):</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">String</code><code class="p">&gt;</code> <code class="p">{</code>&#13;
        <code class="k">return</code> <code class="n">listing</code><code class="p">(</code><code class="n">folder</code><code class="p">).</code><code class="n">map</code> <code class="p">{</code> <code class="n">it</code><code class="p">.</code><code class="n">subject</code> <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="k">val</code> <code class="py">emailSystem</code><code class="p">:</code> <code class="n">EmailSystem</code> <code class="p">=</code> <code class="p">...</code>&#13;
<code class="k">val</code> <code class="py">organiser</code> <code class="p">=</code> <code class="n">Organiser</code><code class="p">(</code><code class="n">emailSystem</code><code class="o">::</code><code class="n">list</code><code class="p">)</code></pre>&#13;
&#13;
<p>Depending on the wider interface misses the opportunity to communicate precisely which operations we require and forces clients to provide an implementation of the whole interface.&#13;
This is particularly irritating in tests, where we will have to introduce fake objects just to get our test code to compile.</p>&#13;
&#13;
<p>The drives of communication and reduced coupling are so strong that even if our client needs to send and delete email, and in practice these will be supplied by a single <code>EmailSystem</code>, the client should probably depend on two functions rather than the interface:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">Organiser</code><code class="p">(</code>&#13;
    <code class="k">private</code> <code class="k">val</code> <code class="py">listing</code><code class="p">:</code> <code class="p">(</code><code class="n">Folder</code><code class="p">)</code> <code class="p">-&gt;</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">Email</code><code class="p">&gt;,</code>&#13;
    <code class="k">private</code> <code class="k">val</code> <code class="py">deleting</code><code class="p">:</code> <code class="p">(</code><code class="n">Email</code><code class="p">)</code> <code class="p">-&gt;</code> <code class="n">Unit</code>&#13;
<code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">fun</code> <code class="nf">deleteInternal</code><code class="p">(</code><code class="n">folder</code><code class="p">:</code> <code class="n">Folder</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="n">listing</code><code class="p">(</code><code class="n">rootFolder</code><code class="p">).</code><code class="n">forEach</code> <code class="p">{</code>&#13;
            <code class="k">if</code> <code class="p">(</code><code class="n">it</code><code class="p">.</code><code class="n">to</code><code class="p">.</code><code class="n">isInternal</code><code class="p">())</code> <code class="p">{</code>&#13;
                <code class="n">deleting</code><code class="p">.</code><code class="n">invoke</code><code class="p">(</code><code class="n">it</code><code class="p">)</code>&#13;
            <code class="p">}</code>&#13;
        <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="k">val</code> <code class="py">organiser</code> <code class="p">=</code> <code class="n">Organiser</code><code class="p">(</code>&#13;
    <code class="n">emailSystem</code><code class="o">::</code><code class="n">list</code><code class="p">,</code>&#13;
    <code class="n">emailSystem</code><code class="o">::</code><code class="n">delete</code>&#13;
<code class="p">)</code></pre>&#13;
&#13;
<p>Only when the client requires three related operations does it feel like a multimethod interface should be the default:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">Organiser</code><code class="p">(</code>&#13;
    <code class="k">private</code> <code class="k">val</code> <code class="py">emails</code><code class="p">:</code> <code class="n">EmailSystem</code>&#13;
<code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">fun</code> <code class="nf">organise</code><code class="p">()</code> <code class="p">{</code>&#13;
        <code class="n">emails</code><code class="p">.</code><code class="n">list</code><code class="p">(</code><code class="n">rootFolder</code><code class="p">).</code><code class="n">forEach</code> <code class="p">{</code>&#13;
            <code class="k">if</code> <code class="p">(</code><code class="n">it</code><code class="p">.</code><code class="n">to</code><code class="p">.</code><code class="n">isInternal</code><code class="p">())</code> <code class="p">{</code>&#13;
                <code class="n">emails</code><code class="p">.</code><code class="n">delete</code><code class="p">(</code><code class="n">it</code><code class="p">)</code>&#13;
            <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>&#13;
                <code class="n">emails</code><code class="p">.</code><code class="n">move</code><code class="p">(</code><code class="n">it</code><code class="p">,</code> <code class="n">archiveFolder</code><code class="p">)</code>&#13;
            <code class="p">}</code>&#13;
        <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="k">val</code> <code class="py">organiser</code> <code class="p">=</code> <code class="n">Organiser</code><code class="p">(</code><code class="n">emailSystem</code><code class="p">)</code></pre>&#13;
&#13;
<p>Even here, it might be better for the client to accept an object that only supports the desired operations.&#13;
We can do that with a new interface (<code>Dependencies</code> here), implemented with an <code>object</code>:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">Organiser</code><code class="p">(</code>&#13;
    <code class="k">private</code> <code class="k">val</code> <code class="py">emails</code><code class="p">:</code> <code class="n">Dependencies</code>&#13;
<code class="p">)</code> <code class="p">{</code>&#13;
    <code class="n">interface</code> <code class="n">Dependencies</code> <code class="p">{</code>&#13;
        <code class="k">fun</code> <code class="nf">delete</code><code class="p">(</code><code class="n">email</code><code class="p">:</code> <code class="n">Email</code><code class="p">)</code>&#13;
        <code class="k">fun</code> <code class="nf">list</code><code class="p">(</code><code class="n">folder</code><code class="p">:</code> <code class="n">Folder</code><code class="p">):</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">Email</code><code class="p">&gt;</code>&#13;
        <code class="k">fun</code> <code class="nf">move</code><code class="p">(</code><code class="n">email</code><code class="p">:</code> <code class="n">Email</code><code class="p">,</code> <code class="n">to</code><code class="p">:</code> <code class="n">Folder</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="k">fun</code> <code class="nf">organise</code><code class="p">()</code> <code class="p">{</code>&#13;
        <code class="n">emails</code><code class="p">.</code><code class="n">list</code><code class="p">(</code><code class="n">rootFolder</code><code class="p">).</code><code class="n">forEach</code> <code class="p">{</code>&#13;
            <code class="k">if</code> <code class="p">(</code><code class="n">it</code><code class="p">.</code><code class="n">to</code><code class="p">.</code><code class="n">isInternal</code><code class="p">())</code> <code class="p">{</code>&#13;
                <code class="n">emails</code><code class="p">.</code><code class="n">delete</code><code class="p">(</code><code class="n">it</code><code class="p">)</code>&#13;
            <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>&#13;
                <code class="n">emails</code><code class="p">.</code><code class="n">move</code><code class="p">(</code><code class="n">it</code><code class="p">,</code> <code class="n">archiveFolder</code><code class="p">)</code>&#13;
            <code class="p">}</code>&#13;
        <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="k">val</code> <code class="py">organiser</code> <code class="p">=</code> <code class="n">Organiser</code><code class="p">(</code><code class="k">object</code> <code class="err">: </code><code class="nc">Organiser</code><code class="p">.</code><code class="n">Dependencies</code> <code class="p">{</code>&#13;
    <code class="k">override</code> <code class="k">fun</code> <code class="nf">delete</code><code class="p">(</code><code class="n">email</code><code class="p">:</code> <code class="n">Email</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="n">emailSystem</code><code class="p">.</code><code class="n">delete</code><code class="p">(</code><code class="n">email</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="k">override</code> <code class="k">fun</code> <code class="nf">list</code><code class="p">(</code><code class="n">folder</code><code class="p">:</code> <code class="n">Folder</code><code class="p">):</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">Email</code><code class="p">&gt;</code> <code class="p">{</code>&#13;
        <code class="k">return</code> <code class="n">emailSystem</code><code class="p">.</code><code class="n">list</code><code class="p">(</code><code class="n">folder</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="k">override</code> <code class="k">fun</code> <code class="nf">move</code><code class="p">(</code><code class="n">email</code><code class="p">:</code> <code class="n">Email</code><code class="p">,</code> <code class="n">to</code><code class="p">:</code> <code class="n">Folder</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="n">emailSystem</code><code class="p">.</code><code class="n">move</code><code class="p">(</code><code class="n">email</code><code class="p">,</code> <code class="n">to</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">})</code></pre>&#13;
&#13;
<p>That’s pretty irritating though; maybe this is a place where a class of functions would be better:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">Organiser</code><code class="p">(</code>&#13;
    <code class="k">private</code> <code class="k">val</code> <code class="py">emails</code><code class="p">:</code> <code class="n">Dependencies</code>&#13;
<code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">class</code> <code class="nc">Dependencies</code><code class="p">(</code>&#13;
        <code class="k">val</code> <code class="py">delete</code><code class="p">:</code> <code class="p">(</code><code class="n">Email</code><code class="p">)</code> <code class="p">-&gt;</code> <code class="n">Unit</code><code class="p">,</code>&#13;
        <code class="k">val</code> <code class="py">list</code><code class="p">:</code> <code class="p">(</code><code class="n">folder</code><code class="p">:</code> <code class="n">Folder</code><code class="p">)</code> <code class="p">-&gt;</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">Email</code><code class="p">&gt;,</code>&#13;
        <code class="k">val</code> <code class="py">move</code><code class="p">:</code> <code class="p">(</code><code class="n">email</code><code class="p">:</code> <code class="n">Email</code><code class="p">,</code> <code class="n">to</code><code class="p">:</code> <code class="n">Folder</code><code class="p">)</code> <code class="p">-&gt;</code> <code class="n">Unit</code>&#13;
    <code class="p">)</code>&#13;
&#13;
    <code class="k">fun</code> <code class="nf">organise</code><code class="p">()</code> <code class="p">{</code>&#13;
        <code class="n">emails</code><code class="p">.</code><code class="n">list</code><code class="p">(</code><code class="n">rootFolder</code><code class="p">).</code><code class="n">forEach</code> <code class="p">{</code>&#13;
            <code class="k">if</code> <code class="p">(</code><code class="n">it</code><code class="p">.</code><code class="n">to</code><code class="p">.</code><code class="n">isInternal</code><code class="p">())</code> <code class="p">{</code>&#13;
                <code class="n">emails</code><code class="p">.</code><code class="n">delete</code><code class="p">(</code><code class="n">it</code><code class="p">)</code>&#13;
            <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>&#13;
                <code class="n">emails</code><code class="p">.</code><code class="n">move</code><code class="p">(</code><code class="n">it</code><code class="p">,</code> <code class="n">archiveFolder</code><code class="p">)</code>&#13;
            <code class="p">}</code>&#13;
        <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="k">val</code> <code class="py">organiser</code> <code class="p">=</code> <code class="n">Organiser</code><code class="p">(</code>&#13;
    <code class="n">Organiser</code><code class="p">.</code><code class="n">Dependencies</code><code class="p">(</code>&#13;
        <code class="n">delete</code> <code class="p">=</code> <code class="n">emailSystem</code><code class="o">::</code><code class="n">delete</code><code class="p">,</code>&#13;
        <code class="n">list</code> <code class="p">=</code> <code class="n">emailSystem</code><code class="o">::</code><code class="n">list</code><code class="p">,</code>&#13;
        <code class="n">move</code> <code class="p">=</code> <code class="n">emailSystem</code><code class="o">::</code><code class="n">move</code>&#13;
    <code class="p">)</code>&#13;
<code class="p">)</code></pre>&#13;
&#13;
<p>So, until it becomes hard work, we should default to expressing our client’s needs as function types.&#13;
Our implementation then can be just a function, or something implementing the function type, or a method converted to the function type through method references or lambdas, whichever makes most sense in context.<a data-primary="" data-startref="IFselect16" data-type="indexterm" id="idm46393370351480"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Legacy of Java" data-type="sect1"><div class="sect1" id="idm46393370957736">&#13;
<h1>The Legacy of Java</h1>&#13;
&#13;
<p>Although<a data-primary="interfaces to functions" data-secondary="legacy of Java" data-type="indexterm" id="idm46393370148424"/><a data-primary="Java" data-secondary="dependencies in legacy code" data-type="indexterm" id="idm46393370147528"/> we said earlier that “our runtime defines all the functions types,” that wasn’t true of Java until Java 8 introduced <code>Supplier</code>, <code>Consumer</code>, <code>Predicate</code>, and so on, and the ability to implement them with method references or lambdas.</p>&#13;
&#13;
<p>Because of this, legacy Java code usually expresses dependencies with the same multimethod interfaces that we would use to group them by subsystem (like <code>EmailSystem</code>), even when only one of those methods is required to implement the functionality.&#13;
This leads to the coupling problems described earlier.&#13;
It<a data-primary="mocking frameworks" data-type="indexterm" id="idm46393370143896"/> also leads to a need for mocking (or, more pedantically, faking) frameworks to create test implementations of broad interfaces where in practice only one method will be called.&#13;
These fakes then sprout the functionality to fail early if you call a method that you didn’t mean to call, a problem that would be solved at compile time if a single function expressed the &#13;
<span class="keep-together">dependency</span>.</p>&#13;
&#13;
<p>Once we have introduced a mocking framework into our codebase (or, more usually, two or three mocking frameworks to cater to different tastes), they allow us to solve problems, like generating implementations for unused methods and stubbing out interactions with external systems.&#13;
Usually, though, our code would be improved by restructuring to avoid the need for mocks.&#13;
Expressing dependencies as function types is one example; another is moving the interaction with external systems to the outer layers of our code, as we will see in <a data-type="xref" href="ch20.html#performing-io-to-passing-data">Chapter 20</a>.&#13;
<a data-type="xref" href="ch17.html#mocks-to-maps">Chapter 17</a> looks at how to reduce mock use by refactoring our tests to a more functional form.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Traceability" data-type="sect1"><div class="sect1" id="idm46393370139128">&#13;
<h1>Traceability</h1>&#13;
&#13;
<p>There<a data-primary="interfaces to functions" data-secondary="traceability" data-type="indexterm" id="idm46393370137608"/><a data-primary="traceability" data-type="indexterm" id="idm46393370136600"/><a data-primary="indirection" data-type="indexterm" id="idm46393370135928"/> is a downside to expressing dependencies with function types, and it is a common issue with adding a layer of indirection.&#13;
If we use IntelliJ to find the callers of <code>EmailSystem.send</code>, the trail goes cold at the point where <code>EmailSystem::send</code> is converted to <code>(Email) -&gt; Unit</code>.&#13;
The IDE doesn’t know that invocations of the function are actually calling the method.&#13;
It’s like our hero enters a river, and the posse tracking them has to scour both banks upstream and downstream to find where they get out.</p>&#13;
&#13;
<p>This is a price we pay for indirection with method calls too, but our tooling is wise to these and can at least find all places where a particular method is implemented, and where an implementation is called through an interface.&#13;
As with using unencapsulated collections (<a data-type="xref" href="ch15.html#encapsulated-collections-to-typealiases">Chapter 15</a>), the price that we pay for decoupling and generality is that tooling, and developers, have less context to hang analysis on.&#13;
We trust that IDE support will improve its functional analysis, and in the meantime, we can help by not passing function types too far from where they are initialized to where they are used.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Refactoring from Interfaces to Functions" data-type="sect1"><div class="sect1" id="idm46393370131304">&#13;
<h1>Refactoring from Interfaces to Functions</h1>&#13;
&#13;
<p>Travelator<a data-primary="interfaces to functions" data-secondary="refactoring from interfaces to functions" data-type="indexterm" id="IFrefact16"/><a data-primary="refactoring" data-secondary="interfaces to functions" data-type="indexterm" id="Rinterface16"/> is quite well-designed in the Java fashion, with interfaces expressing the relations between components.&#13;
For example, the <code>Recommendations</code> engine depends on <code>FeaturedDestinations</code> and a <code>DistanceCalculator</code>:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">Recommendations</code> <code class="o">{</code>&#13;
    <code class="kd">private</code> <code class="kd">final</code> <code class="n">FeaturedDestinations</code> <code class="n">featuredDestinations</code><code class="o">;</code>&#13;
    <code class="kd">private</code> <code class="kd">final</code> <code class="n">DistanceCalculator</code> <code class="n">distanceCalculator</code><code class="o">;</code>&#13;
&#13;
    <code class="kd">public</code> <code class="nf">Recommendations</code><code class="o">(</code>&#13;
        <code class="n">FeaturedDestinations</code> <code class="n">featuredDestinations</code><code class="o">,</code>&#13;
        <code class="n">DistanceCalculator</code> <code class="n">distanceCalculator</code>&#13;
    <code class="o">)</code> <code class="o">{</code>&#13;
        <code class="k">this</code><code class="o">.</code><code class="na">featuredDestinations</code> <code class="o">=</code> <code class="n">featuredDestinations</code><code class="o">;</code>&#13;
        <code class="k">this</code><code class="o">.</code><code class="na">distanceCalculator</code> <code class="o">=</code> <code class="n">distanceCalculator</code><code class="o">;</code>&#13;
    <code class="o">}</code>&#13;
    <code class="o">...</code>&#13;
<code class="o">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=16.1&amp;show=file">Example 16.1 [interfaces-to-funs.0:src/main/java/travelator/recommendations/Recommendations.java]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=16.1&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>The <code>FeaturedDestinations</code> interface has a few methods, grouping functionality that accesses a remote service:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">interface</code> <code class="nc">FeaturedDestinations</code> <code class="o">{</code>&#13;
    <code class="n">List</code><code class="o">&lt;</code><code class="n">FeaturedDestination</code><code class="o">&gt;</code> <code class="nf">findCloseTo</code><code class="o">(</code><code class="n">Location</code> <code class="n">location</code><code class="o">);</code>&#13;
    <code class="n">FeaturedDestination</code> <code class="nf">findClosest</code><code class="o">(</code><code class="n">Location</code> <code class="n">location</code><code class="o">);</code>&#13;
&#13;
    <code class="n">FeaturedDestination</code> <code class="nf">add</code><code class="o">(</code><code class="n">FeaturedDestinationData</code> <code class="n">destination</code><code class="o">);</code>&#13;
    <code class="kt">void</code> <code class="nf">remove</code><code class="o">(</code><code class="n">FeaturedDestination</code> <code class="n">destination</code><code class="o">);</code>&#13;
    <code class="kt">void</code> <code class="nf">update</code><code class="o">(</code><code class="n">FeaturedDestination</code> <code class="n">destination</code><code class="o">);</code>&#13;
<code class="o">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=16.2&amp;show=file">Example 16.2 [interfaces-to-funs.0:src/main/java/travelator/destinations/FeaturedDestinations.java]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=16.2&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>It looks like we’ve already converted the <code>DistanceCalculator</code> interface to Kotlin.&#13;
It too has more than one method, and hides another external service:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">interface</code> <code class="n">DistanceCalculator</code> <code class="p">{</code>&#13;
    <code class="k">fun</code> <code class="nf">distanceInMetersBetween</code><code class="p">(</code>&#13;
        <code class="n">start</code><code class="p">:</code> <code class="n">Location</code><code class="p">,</code>&#13;
        <code class="n">end</code><code class="p">:</code> <code class="n">Location</code>&#13;
    <code class="p">):</code> <code class="n">Int</code>&#13;
&#13;
    <code class="k">fun</code> <code class="nf">travelTimeInSecondsBetween</code><code class="p">(</code>&#13;
        <code class="n">start</code><code class="p">:</code> <code class="n">Location</code><code class="p">,</code>&#13;
        <code class="n">end</code><code class="p">:</code> <code class="n">Location</code>&#13;
    <code class="p">):</code> <code class="n">Int</code>&#13;
<code class="p">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=16.3&amp;show=file">Example 16.3 [interfaces-to-funs.0:src/main/java/travelator/domain/DistanceCalculator.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=16.3&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>Despite taking a dependency on a total of seven methods, <code>Recommendations</code> only actually uses two of them in its implementation:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code> </code><code class="n">List</code><code class="o">&lt;</code><code class="n">FeaturedDestinationSuggestion</code><code class="o">&gt;</code><code> </code><code class="nf">recommendationsFor</code><code class="o">(</code><code>&#13;
</code><code>    </code><code class="n">Set</code><code class="o">&lt;</code><code class="n">Location</code><code class="o">&gt;</code><code> </code><code class="n">journey</code><code>&#13;
</code><code class="o">)</code><code> </code><code class="o">{</code><code>&#13;
</code><code>    </code><code class="n">var</code><code> </code><code class="n">results</code><code> </code><code class="o">=</code><code> </code><code class="n">removeDuplicates</code><code class="o">(</code><code>&#13;
</code><code>        </code><code class="n">journey</code><code class="o">.</code><code class="na">stream</code><code class="o">(</code><code class="o">)</code><code>&#13;
</code><code>            </code><code class="o">.</code><code class="na">flatMap</code><code class="o">(</code><code class="n">location</code><code> </code><code class="o">-</code><code class="o">&gt;</code><code>&#13;
</code><code>                </code><code class="n">recommendationsFor</code><code class="o">(</code><code class="n">location</code><code class="o">)</code><code class="o">.</code><code class="na">stream</code><code class="o">(</code><code class="o">)</code><code>&#13;
</code><code>            </code><code class="o">)</code><code>&#13;
</code><code>    </code><code class="o">)</code><code class="o">;</code><code>&#13;
</code><code>    </code><code class="n">results</code><code class="o">.</code><code class="na">sort</code><code class="o">(</code><code class="n">distanceComparator</code><code class="o">)</code><code class="o">;</code><code>&#13;
</code><code>    </code><code class="k">return</code><code> </code><code class="n">results</code><code class="o">;</code><code>&#13;
</code><code class="o">}</code><code>&#13;
</code><code>&#13;
</code><code class="kd">public</code><code> </code><code class="n">List</code><code class="o">&lt;</code><code class="n">FeaturedDestinationSuggestion</code><code class="o">&gt;</code><code> </code><code class="nf">recommendationsFor</code><code class="o">(</code><code>&#13;
</code><code>    </code><code class="n">Location</code><code> </code><code class="n">location</code><code>&#13;
</code><code class="o">)</code><code> </code><code class="o">{</code><code>&#13;
</code><code>    </code><code class="k">return</code><code> </code><code class="n">featuredDestinations</code><code>&#13;
</code><code>        </code><code class="o">.</code><code class="na">findCloseTo</code><code class="o">(</code><code class="n">location</code><code class="o">)</code><code> </code><a class="co" href="#callout_introduction_CO37-1" id="co_introduction_CO37-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code>        </code><code class="o">.</code><code class="na">stream</code><code class="o">(</code><code class="o">)</code><code>&#13;
</code><code>        </code><code class="o">.</code><code class="na">map</code><code class="o">(</code><code class="n">featuredDestination</code><code> </code><code class="o">-</code><code class="o">&gt;</code><code>&#13;
</code><code>            </code><code class="k">new</code><code> </code><code class="nf">FeaturedDestinationSuggestion</code><code class="o">(</code><code>&#13;
</code><code>                </code><code class="n">location</code><code class="o">,</code><code>&#13;
</code><code>                </code><code class="n">featuredDestination</code><code class="o">,</code><code>&#13;
</code><code>                </code><code class="n">distanceCalculator</code><code class="o">.</code><code class="na">distanceInMetersBetween</code><code class="o">(</code><code> </code><a class="co" href="#callout_introduction_CO37-2" id="co_introduction_CO37-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
</code><code>                    </code><code class="n">location</code><code class="o">,</code><code>&#13;
</code><code>                    </code><code class="n">featuredDestination</code><code class="o">.</code><code class="na">getLocation</code><code class="o">(</code><code class="o">)</code><code>&#13;
</code><code>                </code><code class="o">)</code><code>&#13;
</code><code>            </code><code class="o">)</code><code>&#13;
</code><code>        </code><code class="o">)</code><code class="o">.</code><code class="na">collect</code><code class="o">(</code><code class="n">toList</code><code class="o">(</code><code class="o">)</code><code class="o">)</code><code class="o">;</code><code>&#13;
</code><code class="o">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=16.4&amp;show=file">Example 16.4 [interfaces-to-funs.0:src/main/java/travelator/recommendations/Recommendations.java]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=16.4&amp;show=diff">(diff)</a>&#13;
</div>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_introduction_CO37-1" id="callout_introduction_CO37-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Method on <code>FeaturedDestinations</code></p></dd>&#13;
<dt><a class="co" href="#co_introduction_CO37-2" id="callout_introduction_CO37-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Method on <code>DistanceCalculator</code></p></dd>&#13;
</dl>&#13;
&#13;
<p><code>RecommendationsTests</code> uses mocks to provide implementations of its <code>Distance​Cal⁠cula⁠tor</code> and <code>FeaturedDestinations</code>, which are passed to the instance of &#13;
<span class="keep-together"><code>Recommendations</code></span> under test:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">RecommendationsTests</code> <code class="o">{</code>&#13;
&#13;
    <code class="kd">private</code> <code class="kd">final</code> <code class="n">DistanceCalculator</code> <code class="n">distanceCalculator</code> <code class="o">=</code>&#13;
        <code class="n">mock</code><code class="o">(</code><code class="n">DistanceCalculator</code><code class="o">.</code><code class="na">class</code><code class="o">);</code>&#13;
    <code class="kd">private</code> <code class="kd">final</code> <code class="n">FeaturedDestinations</code> <code class="n">featuredDestinations</code> <code class="o">=</code>&#13;
        <code class="n">mock</code><code class="o">(</code><code class="n">FeaturedDestinations</code><code class="o">.</code><code class="na">class</code><code class="o">);</code>&#13;
    <code class="kd">private</code> <code class="kd">final</code> <code class="n">Recommendations</code> <code class="n">recommendations</code> <code class="o">=</code> <code class="k">new</code> <code class="n">Recommendations</code><code class="o">(</code>&#13;
        <code class="n">featuredDestinations</code><code class="o">,</code>&#13;
        <code class="n">distanceCalculator</code>&#13;
    <code class="o">);</code>&#13;
    <code class="o">...</code>&#13;
<code class="o">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=16.5&amp;show=file">Example 16.5 [interfaces-to-funs.0:src/test/java/travelator/recommendations/RecommendationsTests.java]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=16.5&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>The tests specify that the expected interactions with the mocks are using two methods: <code>givenFeaturedDestinationsFor</code> and <code>givenADistanceBetween</code>, which we won’t bore you with:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="nd">@Test</code>&#13;
<code class="kd">public</code> <code class="kt">void</code> <code class="nf">returns_recommendations_for_multi_location</code><code class="o">()</code> <code class="o">{</code>&#13;
    <code class="n">givenFeaturedDestinationsFor</code><code class="o">(</code><code class="n">paris</code><code class="o">,</code>&#13;
        <code class="n">List</code><code class="o">.</code><code class="na">of</code><code class="o">(</code>&#13;
            <code class="n">eiffelTower</code><code class="o">,</code>&#13;
            <code class="n">louvre</code>&#13;
        <code class="o">));</code>&#13;
    <code class="n">givenADistanceBetween</code><code class="o">(</code><code class="n">paris</code><code class="o">,</code> <code class="n">eiffelTower</code><code class="o">,</code> <code class="mi">5000</code><code class="o">);</code>&#13;
    <code class="n">givenADistanceBetween</code><code class="o">(</code><code class="n">paris</code><code class="o">,</code> <code class="n">louvre</code><code class="o">,</code> <code class="mi">1000</code><code class="o">);</code>&#13;
&#13;
    <code class="n">givenFeaturedDestinationsFor</code><code class="o">(</code><code class="n">alton</code><code class="o">,</code>&#13;
        <code class="n">List</code><code class="o">.</code><code class="na">of</code><code class="o">(</code>&#13;
            <code class="n">flowerFarm</code><code class="o">,</code>&#13;
            <code class="n">watercressLine</code>&#13;
        <code class="o">));</code>&#13;
    <code class="n">givenADistanceBetween</code><code class="o">(</code><code class="n">alton</code><code class="o">,</code> <code class="n">flowerFarm</code><code class="o">,</code> <code class="mi">5300</code><code class="o">);</code>&#13;
    <code class="n">givenADistanceBetween</code><code class="o">(</code><code class="n">alton</code><code class="o">,</code> <code class="n">watercressLine</code><code class="o">,</code> <code class="mi">320</code><code class="o">);</code>&#13;
&#13;
    <code class="n">assertEquals</code><code class="o">(</code>&#13;
        <code class="n">List</code><code class="o">.</code><code class="na">of</code><code class="o">(</code>&#13;
            <code class="k">new</code> <code class="nf">FeaturedDestinationSuggestion</code><code class="o">(</code><code class="n">alton</code><code class="o">,</code> <code class="n">watercressLine</code><code class="o">,</code> <code class="mi">320</code><code class="o">),</code>&#13;
            <code class="k">new</code> <code class="nf">FeaturedDestinationSuggestion</code><code class="o">(</code><code class="n">paris</code><code class="o">,</code> <code class="n">louvre</code><code class="o">,</code> <code class="mi">1000</code><code class="o">),</code>&#13;
            <code class="k">new</code> <code class="nf">FeaturedDestinationSuggestion</code><code class="o">(</code><code class="n">paris</code><code class="o">,</code> <code class="n">eiffelTower</code><code class="o">,</code> <code class="mi">5000</code><code class="o">),</code>&#13;
            <code class="k">new</code> <code class="nf">FeaturedDestinationSuggestion</code><code class="o">(</code><code class="n">alton</code><code class="o">,</code> <code class="n">flowerFarm</code><code class="o">,</code> <code class="mi">5300</code><code class="o">)</code>&#13;
        <code class="o">),</code>&#13;
        <code class="n">recommendations</code><code class="o">.</code><code class="na">recommendationsFor</code><code class="o">(</code><code class="n">Set</code><code class="o">.</code><code class="na">of</code><code class="o">(</code><code class="n">paris</code><code class="o">,</code> <code class="n">alton</code><code class="o">))</code>&#13;
    <code class="o">);</code>&#13;
<code class="o">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=16.6&amp;show=file">Example 16.6 [interfaces-to-funs.0:src/test/java/travelator/recommendations/RecommendationsTests.java]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=16.6&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Introduce Functions" data-type="sect2"><div class="sect2" id="idm46393369474600">&#13;
<h2>Introduce Functions</h2>&#13;
&#13;
<p>Before we start moving from interfaces to functions, we’ll convert <code>Recommendations</code> to Kotlin.&#13;
This is the class that currently expresses its dependencies with interfaces, and Kotlin function types are less clunky than Java’s.</p>&#13;
&#13;
<p>Converting to Kotlin and applying the refactorings introduced in Chapters <a href="ch10.html#functions-to-extension-functions">10</a> and <a href="ch13.html#streams-to-sequences">13</a> gives:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">Recommendations</code><code class="p">(</code>&#13;
    <code class="k">private</code> <code class="k">val</code> <code class="py">featuredDestinations</code><code class="p">:</code> <code class="n">FeaturedDestinations</code><code class="p">,</code>&#13;
    <code class="k">private</code> <code class="k">val</code> <code class="py">distanceCalculator</code><code class="p">:</code> <code class="n">DistanceCalculator</code>&#13;
<code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">fun</code> <code class="nf">recommendationsFor</code><code class="p">(</code>&#13;
        <code class="n">journey</code><code class="p">:</code> <code class="n">Set</code><code class="p">&lt;</code><code class="n">Location</code><code class="p">&gt;</code>&#13;
    <code class="p">):</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">FeaturedDestinationSuggestion</code><code class="p">&gt;</code> <code class="p">=</code>&#13;
        <code class="n">journey</code>&#13;
            <code class="p">.</code><code class="n">flatMap</code> <code class="p">{</code> <code class="n">location</code> <code class="p">-&gt;</code> <code class="n">recommendationsFor</code><code class="p">(</code><code class="n">location</code><code class="p">)</code> <code class="p">}</code>&#13;
            <code class="p">.</code><code class="n">deduplicated</code><code class="p">()</code>&#13;
            <code class="p">.</code><code class="n">sortedBy</code> <code class="p">{</code> <code class="n">it</code><code class="p">.</code><code class="n">distanceMeters</code> <code class="p">}</code>&#13;
&#13;
    <code class="k">fun</code> <code class="nf">recommendationsFor</code><code class="p">(</code>&#13;
        <code class="n">location</code><code class="p">:</code> <code class="n">Location</code>&#13;
    <code class="p">):</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">FeaturedDestinationSuggestion</code><code class="p">&gt;</code> <code class="p">=</code>&#13;
        <code class="n">featuredDestinations</code><code class="p">.</code><code class="n">findCloseTo</code><code class="p">(</code><code class="n">location</code><code class="p">)</code>&#13;
            <code class="p">.</code><code class="n">map</code> <code class="p">{</code> <code class="n">featuredDestination</code> <code class="p">-&gt;</code>&#13;
                <code class="n">FeaturedDestinationSuggestion</code><code class="p">(</code>&#13;
                    <code class="n">location</code><code class="p">,</code>&#13;
                    <code class="n">featuredDestination</code><code class="p">,</code>&#13;
                    <code class="n">distanceCalculator</code><code class="p">.</code><code class="n">distanceInMetersBetween</code><code class="p">(</code>&#13;
                        <code class="n">location</code><code class="p">,</code>&#13;
                        <code class="n">featuredDestination</code><code class="p">.</code><code class="n">location</code>&#13;
                    <code class="p">)</code>&#13;
                <code class="p">)</code>&#13;
            <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="k">private</code> <code class="k">fun</code> <code class="nf">List</code><code class="p">&lt;</code><code class="n">FeaturedDestinationSuggestion</code><code class="p">&gt;.</code><code class="n">deduplicated</code><code class="p">()</code> <code class="p">=</code>&#13;
    <code class="n">groupBy</code> <code class="p">{</code> <code class="n">it</code><code class="p">.</code><code class="n">suggestion</code> <code class="p">}</code>&#13;
        <code class="p">.</code><code class="n">values</code>&#13;
        <code class="p">.</code><code class="n">map</code> <code class="p">{</code> <code class="n">suggestionsWithSameDestination</code> <code class="p">-&gt;</code>&#13;
            <code class="n">suggestionsWithSameDestination</code><code class="p">.</code><code class="n">closestToJourneyLocation</code><code class="p">()</code>&#13;
        <code class="p">}</code>&#13;
&#13;
<code class="k">private</code> <code class="k">fun</code> <code class="nf">List</code><code class="p">&lt;</code><code class="n">FeaturedDestinationSuggestion</code><code class="p">&gt;.</code><code class="n">closestToJourneyLocation</code><code class="p">()</code> <code class="p">=</code>&#13;
    <code class="n">minByOrNull</code> <code class="p">{</code> <code class="n">it</code><code class="p">.</code><code class="n">distanceMeters</code> <code class="p">}</code> <code class="o">?:</code> <code class="n">error</code><code class="p">(</code><code class="s">"Unexpected empty group"</code><code class="p">)</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=16.7&amp;show=file">Example 16.7 [interfaces-to-funs.3:src/main/java/travelator/recommendations/Recommendations.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=16.7&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>To see how the internals of <code>Recommendations</code> would use a function rather than the interface, without having to change its interface yet, we can add a property initialized from an interface method.&#13;
Let’s add a property for <code>featuredDestinations::find​Clo⁠seTo</code>, calling it <code>destinationFinder</code>:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code><code> </code><code class="nc">Recommendations</code><code class="p">(</code><code>&#13;
</code><code>    </code><code class="k">private</code><code> </code><code class="k">val</code><code> </code><code class="py">featuredDestinations</code><code class="p">:</code><code> </code><code class="n">FeaturedDestinations</code><code class="p">,</code><code>&#13;
</code><code>    </code><code class="k">private</code><code> </code><code class="k">val</code><code> </code><code class="py">distanceCalculator</code><code class="p">:</code><code> </code><code class="n">DistanceCalculator</code><code>&#13;
</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
</code><code>    </code><code class="k">private</code><code> </code><code class="k">val</code><code> </code><code class="py">destinationFinder</code><code class="p">:</code><code> </code><a class="co" href="#callout_introduction_CO38-1" id="co_introduction_CO38-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code>        </code><code class="p">(</code><code class="n">Location</code><code class="p">)</code><code> </code><code class="p">-</code><code class="p">&gt;</code><code> </code><code class="n">List</code><code class="p">&lt;</code><code class="n">FeaturedDestination</code><code class="p">&gt;</code><code> </code><code class="p">=</code><code>&#13;
</code><code>        </code><code class="n">featuredDestinations</code><code class="o">::</code><code class="n">findCloseTo</code><code>&#13;
</code><code>&#13;
</code><code>    </code><code class="p">.</code><code class="p">.</code><code class="p">.</code><code>&#13;
</code><code>&#13;
</code><code>    </code><code class="k">fun</code><code> </code><code class="nf">recommendationsFor</code><code class="p">(</code><code>&#13;
</code><code>        </code><code class="n">location</code><code class="p">:</code><code> </code><code class="n">Location</code><code>&#13;
</code><code>    </code><code class="p">)</code><code class="p">:</code><code> </code><code class="n">List</code><code class="p">&lt;</code><code class="n">FeaturedDestinationSuggestion</code><code class="p">&gt;</code><code> </code><code class="p">=</code><code>&#13;
</code><code>        </code><code class="n">destinationFinder</code><code class="p">(</code><code class="n">location</code><code class="p">)</code><code> </code><a class="co" href="#callout_introduction_CO38-2" id="co_introduction_CO38-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
</code><code>            </code><code class="p">.</code><code class="n">map</code><code> </code><code class="p">{</code><code> </code><code class="n">featuredDestination</code><code> </code><code class="p">-</code><code class="p">&gt;</code><code>&#13;
</code><code>                </code><code class="n">FeaturedDestinationSuggestion</code><code class="p">(</code><code>&#13;
</code><code>                    </code><code class="n">location</code><code class="p">,</code><code>&#13;
</code><code>                    </code><code class="n">featuredDestination</code><code class="p">,</code><code>&#13;
</code><code>                    </code><code class="n">distanceCalculator</code><code class="p">.</code><code class="n">distanceInMetersBetween</code><code class="p">(</code><code>&#13;
</code><code>                        </code><code class="n">location</code><code class="p">,</code><code>&#13;
</code><code>                        </code><code class="n">featuredDestination</code><code class="p">.</code><code class="n">location</code><code>&#13;
</code><code>                    </code><code class="p">)</code><code>&#13;
</code><code>                </code><code class="p">)</code><code>&#13;
</code><code>            </code><code class="p">}</code><code>&#13;
</code><code class="p">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=16.8&amp;show=file">Example 16.8 [interfaces-to-funs.4:src/main/java/travelator/recommendations/Recommendations.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=16.8&amp;show=diff">(diff)</a>&#13;
</div>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_introduction_CO38-1" id="callout_introduction_CO38-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Extract a function from the interface.</p></dd>&#13;
<dt><a class="co" href="#co_introduction_CO38-2" id="callout_introduction_CO38-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Use it in place of the method.</p></dd>&#13;
</dl>&#13;
&#13;
<p>This passes the tests, so we are on to something.&#13;
It feels like there should be a refactoring to move <code>destinationFinder</code> into the constructor, but we haven’t found anything better than cutting the definition and pasting where we want it:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">Recommendations</code><code class="p">(</code>&#13;
    <code class="k">private</code> <code class="k">val</code> <code class="py">featuredDestinations</code><code class="p">:</code> <code class="n">FeaturedDestinations</code><code class="p">,</code>&#13;
    <code class="k">private</code> <code class="k">val</code> <code class="py">distanceCalculator</code><code class="p">:</code> <code class="n">DistanceCalculator</code><code class="p">,</code>&#13;
    <code class="k">private</code> <code class="k">val</code> <code class="py">destinationFinder</code><code class="p">:</code>&#13;
        <code class="p">(</code><code class="n">Location</code><code class="p">)</code> <code class="p">-&gt;</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">FeaturedDestination</code><code class="p">&gt;</code> <code class="p">=</code>&#13;
        <code class="n">featuredDestinations</code><code class="o">::</code><code class="n">findCloseTo</code>&#13;
<code class="p">)</code> <code class="p">{</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=16.9&amp;show=file">Example 16.9 [interfaces-to-funs.5:src/main/java/travelator/recommendations/Recommendations.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=16.9&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>This<a data-primary="expand-and-contract refactoring" data-type="indexterm" id="idm46393369059272"/><a data-primary="refactoring" data-secondary="expand-and-contract refactoring" data-type="indexterm" id="idm46393369058568"/> is, once again, the <em>expand</em> in <a data-type="xref" href="ch04.html#expand-contract">“Expand-and-Contract Refactoring”</a>.&#13;
Unfortunately, Java doesn’t understand the defaulted parameter, so we have to fix up the call sites to add the function argument.&#13;
It doesn’t really matter, because this is what we want really anyway:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">private</code> <code class="kd">final</code> <code class="n">Recommendations</code> <code class="n">recommendations</code> <code class="o">=</code> <code class="k">new</code> <code class="n">Recommendations</code><code class="o">(</code>&#13;
    <code class="n">featuredDestinations</code><code class="o">,</code>&#13;
    <code class="n">distanceCalculator</code><code class="o">,</code>&#13;
    <code class="nl">featuredDestinations:</code><code class="o">:</code><code class="n">findCloseTo</code>&#13;
<code class="o">);</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=16.10&amp;show=file">Example 16.10 [interfaces-to-funs.5:src/test/java/travelator/recommendations/RecommendationsTests.java]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=16.10&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>Now nothing in <code>Recommendations</code> uses the <code>featuredDestinations</code> property, so we can remove it (contract):</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">Recommendations</code><code class="p">(</code>&#13;
    <code class="k">private</code> <code class="k">val</code> <code class="py">distanceCalculator</code><code class="p">:</code> <code class="n">DistanceCalculator</code><code class="p">,</code>&#13;
    <code class="k">private</code> <code class="k">val</code> <code class="py">destinationFinder</code><code class="p">:</code> <code class="p">(</code><code class="n">Location</code><code class="p">)</code> <code class="p">-&gt;</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">FeaturedDestination</code><code class="p">&gt;</code>&#13;
<code class="p">)</code> <code class="p">{</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=16.11&amp;show=file">Example 16.11 [interfaces-to-funs.6:src/main/java/travelator/recommendations/Recommendations.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=16.11&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>The places in our code that create <code>Recommendations</code> now look like this:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">private</code> <code class="kd">final</code> <code class="n">Recommendations</code> <code class="n">recommendations</code> <code class="o">=</code> <code class="k">new</code> <code class="n">Recommendations</code><code class="o">(</code>&#13;
    <code class="n">distanceCalculator</code><code class="o">,</code>&#13;
    <code class="nl">featuredDestinations:</code><code class="o">:</code><code class="n">findCloseTo</code>&#13;
<code class="o">);</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=16.12&amp;show=file">Example 16.12 [interfaces-to-funs.6:src/test/java/travelator/recommendations/RecommendationsTests.java]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=16.12&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>If you’re used to refactoring tests with mocks, it may surprise you that the tests have continued to pass through this refactoring.&#13;
We can reason that they <em>should</em> pass—the effect of calling the function bound to <code>featuredDestinations::findCloseTo</code> is still to invoke the method on the mocked interface—but our reasoning is so often proved wrong by running the tests that we don’t count our chickens.</p>&#13;
&#13;
<p>We do like a single basket though, so let’s do the same thing with the <code>distance​Cal⁠cula⁠tor</code>, this time in a fell swoop, whatever that is:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code><code> </code><code class="nc">Recommendations</code><code class="p">(</code><code>&#13;
</code><code>    </code><code class="k">private</code><code> </code><code class="k">val</code><code> </code><code class="py">destinationFinder</code><code class="p">:</code><code> </code><code class="p">(</code><code class="n">Location</code><code class="p">)</code><code> </code><code class="p">-</code><code class="p">&gt;</code><code> </code><code class="n">List</code><code class="p">&lt;</code><code class="n">FeaturedDestination</code><code class="p">&gt;</code><code class="p">,</code><code>&#13;
</code><code>    </code><code class="k">private</code><code> </code><code class="k">val</code><code> </code><code class="py">distanceInMetersBetween</code><code class="p">:</code><code> </code><code class="p">(</code><code class="n">Location</code><code class="p">,</code><code> </code><code class="n">Location</code><code class="p">)</code><code> </code><code class="p">-</code><code class="p">&gt;</code><code> </code><code class="n">Int</code><code>&#13;
</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
</code><code>    </code><code class="p">.</code><code class="p">.</code><code class="p">.</code><code>&#13;
</code><code>    </code><code class="k">fun</code><code> </code><code class="nf">recommendationsFor</code><code class="p">(</code><code>&#13;
</code><code>        </code><code class="n">location</code><code class="p">:</code><code> </code><code class="n">Location</code><code>&#13;
</code><code>    </code><code class="p">)</code><code class="p">:</code><code> </code><code class="n">List</code><code class="p">&lt;</code><code class="n">FeaturedDestinationSuggestion</code><code class="p">&gt;</code><code> </code><code class="p">=</code><code>&#13;
</code><code>        </code><code class="n">destinationFinder</code><code class="p">(</code><code class="n">location</code><code class="p">)</code><code>&#13;
</code><code>            </code><code class="p">.</code><code class="n">map</code><code> </code><code class="p">{</code><code> </code><code class="n">featuredDestination</code><code> </code><code class="p">-</code><code class="p">&gt;</code><code>&#13;
</code><code>                </code><code class="n">FeaturedDestinationSuggestion</code><code class="p">(</code><code>&#13;
</code><code>                    </code><code class="n">location</code><code class="p">,</code><code>&#13;
</code><code>                    </code><code class="n">featuredDestination</code><code class="p">,</code><code>&#13;
</code><code>                    </code><code class="n">distanceInMetersBetween</code><code class="p">(</code><code> </code><a class="co" href="#callout_introduction_CO39-1" id="co_introduction_CO39-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code>                        </code><code class="n">location</code><code class="p">,</code><code>&#13;
</code><code>                        </code><code class="n">featuredDestination</code><code class="p">.</code><code class="n">location</code><code>&#13;
</code><code>                    </code><code class="p">)</code><code>&#13;
</code><code>                </code><code class="p">)</code><code>&#13;
</code><code>            </code><code class="p">}</code><code>&#13;
</code><code class="p">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=16.13&amp;show=file">Example 16.13 [interfaces-to-funs.7:src/main/java/travelator/recommendations/Recommendations.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=16.13&amp;show=diff">(diff)</a>&#13;
</div>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_introduction_CO39-1" id="callout_introduction_CO39-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Calling the new function</p></dd>&#13;
</dl>&#13;
&#13;
<p>The constructor invocations are now:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">private</code> <code class="kd">final</code> <code class="n">Recommendations</code> <code class="n">recommendations</code> <code class="o">=</code> <code class="k">new</code> <code class="n">Recommendations</code><code class="o">(</code>&#13;
    <code class="nl">featuredDestinations:</code><code class="o">:</code><code class="n">findCloseTo</code><code class="o">,</code>&#13;
    <code class="nl">distanceCalculator:</code><code class="o">:</code><code class="n">distanceInMetersBetween</code>&#13;
<code class="o">);</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=16.14&amp;show=file">Example 16.14 [interfaces-to-funs.7:src/test/java/travelator/recommendations/RecommendationsTests.java]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=16.14&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>Note that a little thought around what to call functional variables can go a long way to making them seem natural in use, although that does sometimes make them a little cryptic where they are defined.</p>&#13;
&#13;
<p>Again the tests still pass, giving us confidence that our production code will see the transformation the same way.&#13;
It’s particularly nice that we have shown that we can simultaneously cross a method/function boundary and a Java/Kotlin boundary.&#13;
Maybe this interop will work out OK after all!<a data-primary="" data-startref="IFrefact16" data-type="indexterm" id="idm46393368806760"/><a data-primary="" data-startref="Rinterface16" data-type="indexterm" id="idm46393368805784"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Moving On" data-type="sect1"><div class="sect1" id="idm46393369473496">&#13;
<h1>Moving On</h1>&#13;
&#13;
<p>We want our code to be simple and flexible.&#13;
To this end, libraries need to hide implementation details from client code, and we want to be able to substitute one implementation of some functionality with another.</p>&#13;
&#13;
<p>In OO, we hide configuration and implementation inside classes and express substitutable functionality with interfaces.&#13;
In functional programming, functions take both roles.&#13;
We might see the function as more fundamental, but we can view an object as a collection of functions, and a function as an object with a single method.&#13;
Both Kotlin and Java allow us to move between realms at the boundaries between implementations and clients, but Kotlin’s native function type syntax encourages the use of function types rather than interfaces.&#13;
This allows even more decoupling than defining our own interfaces and should be our default approach.</p>&#13;
&#13;
<p>We continue refactoring this example, and examining this relationship, in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch17.html#mocks-to-maps">Chapter 17, <em>Mocks to Maps</em></a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>