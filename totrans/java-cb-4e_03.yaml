- en: Chapter 3\. Strings and Things
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 3.0 Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Character strings are an inevitable part of just about any programming task.
    We use them for printing messages for the user; for referring to files on disk
    or other external media; and for people’s names, addresses, and affiliations.
    The uses of strings are many, almost without number (actually, if you need numbers,
    we’ll get to them in [Chapter 5](ch05.html#javacook-numbers)).
  prefs: []
  type: TYPE_NORMAL
- en: If you’re coming from a programming language like C, you’ll need to remember
    that `String` is a defined type (class) in Java—that is, a string is an object
    and therefore has methods. It is not an array of characters (though it contains
    one) and should not be thought of as an array. Operations like `fileName.endsWith(".gif")`
    and `extension.equals(".gif")` (and the equivalent "`.gif".equals(extension)`)
    are commonplace.^([1](ch03.html#idm45290704847128))
  prefs: []
  type: TYPE_NORMAL
- en: Java old-timers should note that Java 11 and 12 added several new `String` methods,
    including `indent(int n)`, `stripLeading()` and `stripTrailing()`, `Stream<T>`
    `lines()`, `isBlank()`, and `transform()`. Most of these provide obvious functionality;
    the last one allows applying an instance of a functional interface (see [Recipe
    9.0](ch09.html#javacook-fp-intro)) to a string and returning the result of that
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: Although we haven’t discussed the details of the `java.io` package yet (we will,
    in [Chapter 10](ch10.html#javacook-io)), you need to be able to read text files
    for some of these programs. Even if you’re not familiar with `java.io`, you can
    probably see from the examples of reading text files that a `BufferedReader` allows
    you to read chunks of data and that this class has a very convenient `readLine()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going the other way, `System.out.println()` is normally used to print strings
    or other values to the terminal or standard output. String concatenation is commonly
    used here, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'One caveat with string concatenation is that if you are appending a bunch of
    things, and a number and a character are concatenated at the front, they are added
    before concatenation due to Java’s precedence rules. So don’t do as I did in this
    contrived example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Given that `result` is an integer, then `result + ''='' (`result` added to
    the equals sign, which is of the numeric type +char`) is a valid *numeric* expression,
    which will result in a single value of type `int`. If the variable `result` has
    the value 42, and given that the character `=` in a Unicode (or ASCII) code chart
    has the value 61, the two-line fragment would print:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The wrong value and no equals sign! Safer approaches include using parentheses,
    double quotes around the equals sign, a `StringBuilder` (see [Recipe 3.2](#javacook-strings-SECT-3)),
    or `String.format()` (see [Recipe 10.4](ch10.html#javacook-io-SECT-3)). Of course
    in this simple example you could just move the *=* to be part of the string literal,
    but the example was chosen to illustrate the problem of arithmetic on `char` values
    being confused with string contatenation. I won’t show you how to sort an array
    of strings here; the more general notion of sorting a collection of objects will
    be taken up in [Recipe 7.11](ch07.html#javacook-structure-SECT-8).
  prefs: []
  type: TYPE_NORMAL
- en: 'Java 14 enables text blocks, also known as multiline text strings. These are
    delimited with a set of three double quotes, the opening of which *must* have
    a newline after the quotes (which doesn’t become part of the string; the following
    newlines do):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 3.1 Taking Strings Apart with Substrings or Tokenizing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to break a string apart, either by indexing positions or by using fixed
    token characters (e.g., break on spaces to get words).
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For substrings, use the `String` object’s `substring()` method. For tokenizing,
    construct a `StringTokenizer` around your string and call its methods `hasMoreTokens()`
    and `nextToken()`.
  prefs: []
  type: TYPE_NORMAL
- en: Or, use regular expressions (see [Chapter 4](ch04.html#javacook-regex)).
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll look first at substrings, and then discuss tokenizing.
  prefs: []
  type: TYPE_NORMAL
- en: Substrings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `substring()` method constructs a new `String` object made up of a run
    of characters contained somewhere in the original string, the one whose `substring()`
    you called. The `substring` method is overloaded: both forms require a starting
    index (which is always *zero-based*). The one-argument form returns from `startIndex`
    to the end. The two-argument form takes an ending index (not a length, as in some
    languages) so that an index can be generated by the `String` methods `indexOf()`
    or `las⁠t​IndexOf()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When run, this prints the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note that the end index is one beyond the last character! Java adopts this policy
    of having a half-open interval (or inclusive start, exclusive end) fairly consistently;
    there are good practical reasons for adopting this approach, and some other languages
    do so too.
  prefs: []
  type: TYPE_NORMAL
- en: Tokenizing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The easiest way is to use a regular expression. We’ll discuss regular expressions
    in [Chapter 4](ch04.html#javacook-regex), but for now, a string containing a space
    is a valid regular expression to match space characters, so you can most easily
    split a string into words like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If you need to match multiple spaces, or spaces and tabs, use the string `"\s+"`.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to split a file, you can try the string `","` or use one of several
    third-party libraries for CSV files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another method is to use `StringTokenizer`. The `StringTokenizer` methods implement
    the `Iterator` interface and design pattern (see [Recipe 7.6](ch07.html#javacook-structure-iterate)):'
  prefs: []
  type: TYPE_NORMAL
- en: '*main/src/main/java/strings/StrTokDemo.java*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`StringTokenizer` also implements the `Enumeration` interface (see [Recipe
    7.6](ch07.html#javacook-structure-iterate)), but if you use the methods thereof,
    you need to cast the results to `String`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A `StringTokenizer` normally breaks the `String` into tokens at what we would
    think of as word boundaries in European languages. Sometimes you want to break
    at some other character. No problem. When you construct your `StringTokenizer`,
    in addition to passing in the string to be tokenized, pass in a second string
    that lists the break characters, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*main/src/main/java/strings/StrTokDemo2.java*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: It outputs the four words, each on a line by itself, with no punctuation.
  prefs: []
  type: TYPE_NORMAL
- en: But wait, there’s more! What if you are reading lines like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'and your dear old Aunt Begonia hasn’t been employed for the last 38 years?
    Her `Company` field will in all probability be blank.^([3](ch03.html#idm45290704071000))
    If you look very closely at the previous code example, you’ll see that it has
    two delimiters together (the comma and the space); but if you run it, there are
    no “extra” tokens—that is, the `StringTokenizer` normally discards adjacent consecutive
    delimiters. For cases like the phone list, where you need to preserve null fields,
    there is good news and bad news. The good news is that you can do it: you simply
    add a second argument of `true` when constructing the `StringTokenizer`, meaning
    that you wish to see the delimiters as tokens. The bad news is that you now get
    to see the delimiters as tokens, so you have to do the arithmetic yourself. Want
    to see it? Run this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '*main/src/main/java/strings/StrTokDemo3.java*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This isn’t how you’d like `StringTokenizer` to behave, ideally, but it is serviceable
    enough most of the time. [Example 3-1](#javacook-strings-EX-1) processes and ignores
    consecutive tokens, returning the results as an array of `String`s.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-1\. main/src/main/java/strings/StrTokDemo4.java (StringTokenizer)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run this, you will see that `A` is always in Field 1, `B` (if present)
    is in Field 2, and so on. In other words, the null fields are being handled properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Many occurrences of `StringTokenizer` may be replaced with regular expressions
    (see [Chapter 4](ch04.html#javacook-regex)) with considerably more flexibility.
    For example, to extract all the numbers from a `String`, you can use this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This allows user input to be more flexible than you could easily handle with
    a `StringTokenizer`. Assuming that the numbers represent course numbers at some
    educational institution, the inputs “471,472,570” or “Courses 471 and 472, 570”
    or just “471 472 570” should all give the same results.
  prefs: []
  type: TYPE_NORMAL
- en: 3.2 Putting Strings Together with StringBuilder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to put some `String` pieces (back) together.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use string concatenation: the `+` operator. The compiler implicitly constructs
    a `StringBuilder` for you and uses its `append()` methods (unless all the string
    parts are known at compile time).'
  prefs: []
  type: TYPE_NORMAL
- en: Better yet, construct and use a `StringBuilder` yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An object of one of the `StringBuilder` classes basically represents a collection
    of characters. It is similar to a `String` object.^([4](ch03.html#idm45290703693768))
    However, as mentioned, `String`s are immutable; `StringBuilder`s are mutable and
    designed for, well, building `String`s. You typically construct a `StringBuilder`,
    invoke the methods needed to get the character sequence just the way you want
    it, and then call `toString()` to generate a `String` representing the same character
    sequence for use in most of the Java API, which deals in `String`s.
  prefs: []
  type: TYPE_NORMAL
- en: '`StringBuffer` is historical—it’s been around since the beginning of time.
    Some of its methods are synchronized (see [Recipe 16.5](ch16.html#javacook-threads-SECT-5)),
    which involves unneeded overhead in a single-threaded context. In Java 5, this
    class was split into `StringBuffer` (which is synchronized) and `StringBuilder`
    (which is not synchronized); thus, it is faster and preferable for single-threaded
    use. Another new class, `AbstractStringBuilder`, is the parent of both. In the
    following discussion, I’ll use “the `StringBuilder` classes” to refer to all three
    because they mostly have the same methods.'
  prefs: []
  type: TYPE_NORMAL
- en: The book’s example code provides a `StringBuilderDemo` and a `StringBufferDemo`.
    Except for the fact that `StringBuilder` is not thread-safe, these API classes
    are identical and can be used interchangeably, so my two demo programs are almost
    identical except that each one uses the appropriate builder class.
  prefs: []
  type: TYPE_NORMAL
- en: The `StringBuilder` classes have a variety of methods for inserting, replacing,
    and otherwise modifying a given `StringBuilder`. Conveniently, the `append()`
    methods return a reference to the `StringBuilder` itself, so stacked statements
    like `.append(…).append(…)` are fairly common. This style of coding is referred
    to as a *fluent API* because it reads smoothly, like prose from a native speaker
    of a human language. You might even see this style of coding in a `toString()`
    method, for example. [Example 3-2](#javacook-strings-EX-2) shows three ways of
    concatenating strings.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-2\. main/src/main/java/strings/StringBuilderDemo.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In fact, all the methods that modify more than one character of a `StringBuilder`’s
    contents (i.e., `append()`, `delete()`, `deleteCharAt()`, `insert()`, `replace()`,
    and `reverse()`) return a reference to the builder object to facilitate this fluent
    API style of coding.
  prefs: []
  type: TYPE_NORMAL
- en: As another example of using a `StringBuilder`, consider the need to convert
    a list of items into a comma-separated list while avoiding getting an extra comma
    after the last element of the list. This can be done using a `StringBuilder`,
    although in Java 8+ there is a static `String` method to do the same. Code for
    these are shown in [Example 3-3](#javacook-strings-EX-3).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-3\. main/src/main/java/strings/StringBuilderCommaList.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The first method is clearly the most compact; the static `String.join()` makes
    short work of this task. The next method uses the `StringBuilder.length()` method,
    so it will only work correctly when you are starting with an empty `StringBuilder`.
    The second method relies on calling the informational method `hasMoreElements()`
    in the `Enumeration` (or `hasNext()` in an `Iterator`, as discussed in [Recipe
    7.6](ch07.html#javacook-structure-iterate)) more than once on each element. An
    alternative method, particularly when you aren’t starting with an empty builder,
    would be to use a `boolean` flag variable to track whether you’re at the beginning
    of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 3.3 Processing a String One Character at a Time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to process the contents of a string, one character at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use a `for` loop and the `String`’s `charAt()` or `codePointAt()` method. Or
    use a “for each” loop and the `String`’s `toCharArray` method.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A string’s `charAt()` method retrieves a given character by index number (starting
    at zero) from within the `String` object. Since Unicode has had to expand beyond
    16 bits, not all Unicode characters can fit into a Java `char` variable. There
    is thus an analogous `codePointAt()` method, whose return type is `int`. To process
    all the characters in a `String`, one after another, use a `for` loop ranging
    from zero to `String.length()-1`. Here we process all the characters in a `String`:'
  prefs: []
  type: TYPE_NORMAL
- en: '*main/src/main/java/strings/strings/StrCharAt.java*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Given that the “for each” loop has been in the language for ages, you might
    be excused for expecting to be able to write something like `for (char ch : myString)
    {…}`. Unfortunately, this does not work. But you can use `myString.toCharArray()`
    as in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: A *checksum* is a numeric quantity representing and confirming the contents
    of a file. If you transmit the checksum of a file separately from the contents,
    a recipient can checksum the file—assuming the algorithm is known—and verify that
    the file was received intact. [Example 3-4](#javacook-strings-EX-3a) shows the
    simplest possible checksum, computed just by adding the numeric values of each
    character. Note that on files, it does not include the values of the newline characters;
    in order to fix this, retrieve `System​.getProp⁠erty("line.separator");` and add
    its character value(s) into the sum at the end of each line. Or give up on line
    mode and read the file a character at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-4\. main/src/main/java/strings/CheckSum.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 3.4 Aligning, Indenting, and Unindenting Strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to align strings to the left, right, or center.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Do the math yourself, and use `substring` (see [Recipe 3.1](#javacook-strings-SECT-1))
    and a `StringBuilder` (see [Recipe 3.2](#javacook-strings-SECT-3)). Or, use my
    `StringAlign` class, which is based on the `java.text.Format` class. For left
    or right alignment, use `String.format()`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Centering and aligning text comes up fairly often. Suppose you want to print
    a simple report with centered page numbers. There doesn’t seem to be anything
    in the standard API that will do the job fully for you. But I have written a class
    called `String​A⁠lign` that will. Here’s how you might use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If you compile and run this class, it prints the two demonstration line numbers
    centered, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 3-5](#javacook-strings-EX-4) is the code for the `StringAlign` class.
    Note that this class extends the class `Format` in the package `java.text`. There
    is a series of `Format` classes that all have at least one method called `format()`.
    It is thus in a family with numerous other formatters, such as `DateFormat` and
    `NumberFormat`, that we’ll take a look at in upcoming chapters.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-5\. main/src/main/java/strings/StringAlign.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Java 12 introduced a new method `public String indent(int n)` that prepends
    *n* spaces to the string, which is treated as a sequence of lines with line separators.
    This works well in conjunction with the Java 11 `Stream<String> lines()` method.
    For example, for the case where a series of lines, already stored in a single
    string, needs the same indent (`Streams`, and the “::” notation, are explained
    in [Recipe 9.0](ch09.html#javacook-fp-intro)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The alignment of numeric columns is considered in [Chapter 5](ch05.html#javacook-numbers).
  prefs: []
  type: TYPE_NORMAL
- en: 3.5 Converting Between Unicode Characters and Strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to convert between Unicode characters and `String`s.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use Java `char` or `String` data types to deal with characters; these intrinsically
    support Unicode. Print characters as integers to display their *raw* value if
    needed.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unicode is an international standard that aims to represent all known characters
    used by people in their various languages. Though the original ASCII character
    set is a subset, Unicode is huge. At the time Java was created, Unicode was a
    16-bit character set, so it seemed natural to make Java `char` values be 16 bits
    in width, and for years a `char` could hold any Unicode character. However, over
    time, Unicode has grown, to the point that it now includes over a million code
    points, or characters, more than the 65,525 that could be represented in 16 bits.^([5](ch03.html#idm45290702287384))
    Not all possible 16-bit values were defined as characters in UCS-2, the 16-bit
    version of Unicode originally used in Java. A few were reserved as escape characters,
    which allows for multicharacter-length mappings to less common characters. Fortunately,
    there is a go-between standard, called UTF-16 (16-bit Unicode Transformation Format).
    As the `String` class documentation puts it:'
  prefs: []
  type: TYPE_NORMAL
- en: A `String` represents a string in the UTF-16 format in which *supplementary
    characters* are represented by *surrogate pairs* (see the section Unicode Character
    Representations in the `Character` class for more information). Index values refer
    to char code units, so a supplementary character uses two positions in a `String`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `String` class provides methods for dealing with Unicode code points (i.e.,
    characters), in addition to those for dealing with Unicode code units (i.e., `char
    values`).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The `charAt()` method of `String` returns the `char` value for the character
    at the specified offset. The `StringBuilder append()` method has a form that accepts
    a `char`. Because `char` is an integer type, you can even do arithmetic on `char`s,
    though this is not needed as frequently as in, say, C. Nor is it often recommended,
    because the `Character` class provides the methods for which these operations
    were normally used in languages such as C. Here is a program that uses arithmetic
    on `char`s to control a loop and that also appends the characters into a `StringBuilder`
    (see [Recipe 3.2](#javacook-strings-SECT-3)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run it, the expected results are printed for the ASCII characters.
    On Unix and characters in Mac systems, the default fonts don’t include all the
    additional characters, so they are either omitted or mapped to irregular characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The Windows system used to try this doesn’t have most of those characters either,
    but at least it prints as question marks the ones it knows are lacking (Windows
    system fonts are more homogenous than those of the various Unix systems, so it
    is easier to know what won’t work). On the other hand, it tries to print the yen
    sign as an N with a tilde:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The “_” characters are unprintable characters.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Unicode` program in this book’s online source displays any 256-character
    section of the Unicode character set. You can download documentation listing every
    character in the Unicode character set from the [Unicode Consortium](http://www.unicode.org).
  prefs: []
  type: TYPE_NORMAL
- en: 3.6 Reversing a String by Word or by Character
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You wish to reverse a string, a character at a time or a word at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can reverse a string by character easily, using a `StringBuilder`. There
    are several ways to reverse a string a word at a time. One natural way is to use
    a `StringTokenizer` and a stack. `Stack` is a class (defined in `java.util`; see
    [Recipe 7.16](ch07.html#javacook-structure-SECT-14)) that implements an easy-to-use
    last-in, first-out (LIFO) stack of objects.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To reverse the characters in a string, use the `StringBuilder reverse()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*main/src/main/java/strings/StringRevChar.java*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The letters in this example list the order of the sharps in the key signatures
    of Western music; in reverse, it lists the order of flats. Alternatively, of course,
    you could reverse the characters yourself, using character-at-a-time mode (see
    [Recipe 3.3](#javacook-strings-SECT-4)).
  prefs: []
  type: TYPE_NORMAL
- en: A popular mnemonic, or memory aid, to help music students remember the order
    of sharps and flats consists of one word for each sharp instead of just one letter.
    Let’s reverse this *one word at a time*. [Example 3-6](#javacook-strings-EX-5)
    adds each one to a `Stack` (see [Recipe 7.16](ch07.html#javacook-structure-SECT-14)),
    then processes the whole lot in LIFO order, which reverses the order.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-6\. main/src/main/java/strings/StringReverse.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 3.7 Expanding and Compressing Tabs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to convert space characters to tab characters in a file, or vice versa.
    You might want to replace spaces with tabs to save space on disk or go the other
    way to deal with a device or program that can’t handle tabs.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use my `Tabs` class or its subclass `EnTab`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because programs that deal with tabbed text or data expect tab stops to be at
    fixed positions, you cannot use a typical text editor to replace tabs with spaces
    or vice versa. [Example 3-7](#javacook-strings-EX-6) is a listing of `EnTab`,
    complete with a sample main program. The program works a line at a time. For each
    character on the line, if the character is a space, we see if we can coalesce
    it with previous spaces to output a single tab character. This program depends
    on the `Tabs` class, which we’ll come to shortly. The `Tabs` class is used to
    decide which column positions represent tab stops and which do not.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-7\. main/src/main/java/strings/Entab.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This code was patterned after a program in Kernighan and Plauger’s classic work
    *Software Tools*. While their version was in a language called RatFor (Rational
    Fortran), my version has since been through several translations. Their version
    actually worked one character at a time, and for a long time I tried to preserve
    this overall structure. Eventually, I rewrote it to be a line-at-a-time program.
  prefs: []
  type: TYPE_NORMAL
- en: The program that goes in the opposite direction—putting tabs in rather than
    taking them out—is the `DeTab` class shown in [Example 3-8](#javacook-strings-EX-7);
    only the core methods are shown.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-8\. main/src/main/java/strings/DeTab.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Tabs` class provides two methods: `settabpos()` and `istabstop()`. [Example 3-9](#javacook-strings-EX-8)
    is the source for the `Tabs` class.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-9\. main/src/main/java/strings/Tabs.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 3.8 Controlling Case
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to either convert strings to uppercase or lowercase or compare strings
    without regard for case.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `String` class has a number of methods for dealing with documents in a
    particular case. `toUpperCase()` and `toLowerCase()` each return a new string
    that is a copy of the current string but converted, as the name implies. Each
    can be called either with no arguments or with a `Locale` argument specifying
    the conversion rules; this is necessary because of internationalization. Java’s
    API provides significant internationalization and localization features, as covered
    in [“Ian’s Basic Steps: Internationalization and Localization”](#javacook-i18n-SIDEBAR-1).
    Whereas the `equals()` method tells you if another string is exactly the same,
    `equalsIgnoreCase()` tells you if all characters are the same regardless of case.
    Here, you can’t specify an alternative locale; the system’s default locale is
    used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this, it prints the first name changed to uppercase and lowercase,
    then it reports that both methods work as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Regular expressions make it simpler to ignore case in string searching (as we
    see in [Chapter 4](ch04.html#javacook-regex)).
  prefs: []
  type: TYPE_NORMAL
- en: 3.9 Entering Nonprintable Characters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to put nonprintable characters into strings.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the backslash character and one of the Java string escapes.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Java string escapes are listed in [Table 3-1](#javacook-strings-TABLE-1).
  prefs: []
  type: TYPE_NORMAL
- en: Table 3-1\. String escapes
  prefs: []
  type: TYPE_NORMAL
- en: '| To get | Use | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Tab | `\t` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Linefeed (Unix newline) | `\n` | The call `System.getProperty("line.separator")`
    will give you the platform’s line end. |'
  prefs: []
  type: TYPE_TB
- en: '| Carriage return | `\r` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Form feed | `\f` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Backspace | `\b` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Single quote | `\`'' |  |'
  prefs: []
  type: TYPE_TB
- en: '| Double quote | `\`" |  |'
  prefs: []
  type: TYPE_TB
- en: '| Unicode character | `\u` *`NNNN`* | Four hexadecimal digits (no `\x` as in
    C/C++). See [*http://www.unicode.org*](http://www.unicode.org) for codes. |'
  prefs: []
  type: TYPE_TB
- en: '| Octal(!) character | +\+*`NNN`* | Who uses octal (base 8) these days? |'
  prefs: []
  type: TYPE_TB
- en: '| Backslash | `\\` |  |'
  prefs: []
  type: TYPE_TB
- en: 'Here is a code example that shows most of these in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: If you have a lot of non-ASCII characters to enter, you may wish to consider
    using Java’s input methods, discussed briefly in the [online documentation](https://docs.oracle.com/javase/8/docs/technotes/guides/imf/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: 3.10 Trimming Blanks from the End of a String
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to work on a string without regard for extra leading or trailing spaces
    a user may have typed.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `String` class `strip()` or `trim()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are four methods in the `String` class for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`strip()`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a string with all leading and trailing whitespace removed
  prefs: []
  type: TYPE_NORMAL
- en: '`stripLeading()`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a string whose value is this string, with all leading white space removed
  prefs: []
  type: TYPE_NORMAL
- en: '`stripTrailing()`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the string with all trailing whitespace removed
  prefs: []
  type: TYPE_NORMAL
- en: '`String trim()`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the string with all leading and trailing spaces removed
  prefs: []
  type: TYPE_NORMAL
- en: For the `strip()` methods, whitespace is as defined by `Character.isSpace()`.
    For the `trim()` method, space includes any character whose numeric value is less
    than or equal to 32, or *U+0020* (the space character).
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 3-10](#javacook-strings-EX-9) uses `trim()` to strip an arbitrary
    number of leading spaces and/or tabs from lines of Java source code in order to
    look for the characters `//+` and `//-`. These strings are special Java comments
    I previously used to mark the parts of the programs in this book that I wanted
    to include in the printed copy.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-10\. main/src/main/java/strings/GetMark.java (trimming and comparing
    strings)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 3.11 Creating a Message with I18N Resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want your program to take sensitivity training so that it can communicate
    well internationally.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Your program must obtain all control and message strings via the internationalization
    software. Here’s how:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Get a `ResourceBundle`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: I’ll talk about `ResourceBundle` in [Recipe 3.13](#javacook-i18n-SECT-6), but
    briefly, a `ResourceBundle` represents a collection of name-value pairs (resources).
    The names are names you assign to each GUI control or other user interface text,
    and the values are the text to assign to each control in a given language.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Use this `ResourceBundle` to fetch the localized version of each control name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Old way:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'New way:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This may seem quite a bit of code for one control, but you can write a convenience
    routine to simplify it, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The file *I18NUtil.java* is included in the book’s code distribution.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the example is a Swing `JButton`, the same approach goes with other UIs,
    such as the web tier. In JSF, for example, you might place your strings in a properties
    file called *resources.properties* and store it in *src/main/resources*. You would
    load this in *faces-config.xml*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Then in each web page that needs these strings, refer to the resource using
    the `msg` variable in an expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: What happens at runtime?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The default locale is used, because we didn’t specify one. The default locale
    is platform dependent:'
  prefs: []
  type: TYPE_NORMAL
- en: Unix/POSIX
  prefs: []
  type: TYPE_NORMAL
- en: LANG environment variable (per user)
  prefs: []
  type: TYPE_NORMAL
- en: Windows
  prefs: []
  type: TYPE_NORMAL
- en: Control Panel→Regional Settings
  prefs: []
  type: TYPE_NORMAL
- en: macOS
  prefs: []
  type: TYPE_NORMAL
- en: System Preferences→Language & Text
  prefs: []
  type: TYPE_NORMAL
- en: Others
  prefs: []
  type: TYPE_NORMAL
- en: See platform documentation
  prefs: []
  type: TYPE_NORMAL
- en: '`ResourceBundle.getBundle()` locates a file with the named resource bundle
    name (`Menus`, in the previous example), plus an underscore and the locale name
    (if a non-default locale is set), plus another underscore and the locale variation
    (if any variation is set), plus the extension *.properties*. If a variation is
    set but the file can’t be found, it falls back to just the country code. If that
    can’t be found, it falls back to the original default. [Table 3-2](#javacook-i18n-TABLE-1)
    shows some examples for various locales.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that Android apps—usually written in Java or Kotlin—use a similar mechanism
    but with the files in XML format instead of Java Properties and with some small
    changes in the name of the file in which the properties files are found.
  prefs: []
  type: TYPE_NORMAL
- en: Table 3-2\. Property filenames for different locales
  prefs: []
  type: TYPE_NORMAL
- en: '| Locale | Filename |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Default locale | *Menus.Properties* |'
  prefs: []
  type: TYPE_TB
- en: '| Swedish | *Menus_sv.properties* |'
  prefs: []
  type: TYPE_TB
- en: '| Spanish | *Menus_es.properties* |'
  prefs: []
  type: TYPE_TB
- en: '| French | *Menus_fr.properties* |'
  prefs: []
  type: TYPE_TB
- en: '| French-Canadian | *Menus_fr_CA.properties* |'
  prefs: []
  type: TYPE_TB
- en: Locale names are two-letter ISO-639 language codes (lowercase), and they normally
    abbreviate the country’s *endonym* (the name its language speakers refer to it
    by); thus, Sweden is *sv* for *Sverige*, Spain is *es* for *Espanol*, etc. Locale
    variations are two-letter ISO country codes (uppercase); for example, e.g., CA
    for Canada, US for the United States, SV for Sweden, ES for Spain, etc.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the locale
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On Windows, go into Regional Settings in the Control Panel. Changing this setting
    may entail a reboot, so exit any editor windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Unix, set your `LANG` environment variable. For example, a Korn shell user
    in Mexico might have this line in her *.profile*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'On either system, for testing a different locale, you need only define the
    locale in the System Properties at runtime using the command-line option `-D`,
    as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This runs the Java program named `Browser` in package `i18n` in the Spanish
    locale.
  prefs: []
  type: TYPE_NORMAL
- en: You can get a list of the available locales with a call to `Locale.getAvailable​Lo⁠cales()`.
  prefs: []
  type: TYPE_NORMAL
- en: 3.12 Using a Particular Locale
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to use a locale other than the default in a particular operation.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Obtain a `Locale` by using a predefined instance or the `Locale` constructor.
    Optionally make it global to your application by using `Locale.setDefault(newLocale)`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Classes that provide formatting services, such as `DateTimeFormatter` and `NumberFormat`,
    provide overloads so they can be called either with or without a `Locale`-related
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'To obtain a `Locale` object, you can employ one of the predefined locale variables
    provided by the `Locale` class, or you can construct your own `Locale` object
    giving a language code and a country code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'These can then be used in the various formatting operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Either of these can be used to format a date or a number, as shown in class
    `Use​Lo⁠cales`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The program prints the locale name and formats the date in each of the locales:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 3.13 Creating a Resource Bundle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to create a resource bundle for use with I18N.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A resource bundle is simply a collection of names and values. You could write
    a `java.util.ResourceBundle` subclass, but it is easier to create textual `Properties`
    files (see [Recipe 7.10](ch07.html#javacook-structure-SECT-7)) that you then load
    with `ResourceBundle.getBundle()`. The files can be created using any plain text
    editor. Leaving it in a text file format also allows user customization in desktop
    applications; a user whose language is not provided for, or who wishes to change
    the wording somewhat due to local variations in dialect, should be able to edit
    the file.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the resource bundle text file should not have the same name as any
    of your Java classes. The reason is that the `ResourceBundle` constructs a class
    dynamically with the same name as the resource files.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is a sample properties file for a few menu items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Creating the default properties file is usually not a problem, but creating
    properties files for other languages might be. Unless you are a large multinational
    corporation, you will probably not have the resources (pardon the pun) to create
    resource files in-house. If you are shipping commercial software or using the
    web for global reach, you need to identify your target markets and understand
    which of these are most sensitive to wanting menus and the like in their own languages.
    Then, hire a professional translation service that has expertise in the required
    languages to prepare the files. Test them well before you ship, as you would any
    other part of your software.
  prefs: []
  type: TYPE_NORMAL
- en: If you need special characters, multiline text, or other complex entry, remember
    that a `ResourceBundle` is also a `Properties` file, so see the documentation
    for `java.util.Properties`.
  prefs: []
  type: TYPE_NORMAL
- en: '3.14 Program: A Simple Text Formatter'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This program is a primitive text formatter, representative of what people used
    on most computing platforms before the rise of standalone graphics-based word
    processors, laser printers, and, eventually, desktop publishing and office suites.
    It simply reads words from a file, previously created with a text editor, and
    outputs them until it reaches the right margin, when it calls `println()` to append
    a line ending. For example, here is an input file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Given that file as the input, the `Fmt` program prints the lines formatted
    neatly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, it fits the text we gave it to the margin and discards all
    the line breaks present in the original. Here’s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: A slightly fancier version of this program, `Fmt2`, is in the online source
    for this book. It uses *dot commands*—lines beginning with periods—to give limited
    control over the formatting. A family of dot-command formatters includes Unix’s
    *roff*, *nroff, troff*, and *groff*, which are in the same family with programs
    called *runoff* on Digital Equipment systems. The original for this is J. Saltzer’s
    *runoff*, which first appeared on Multics and from there made its way into various
    OSes. To save trees, I did not include `Fmt2` here; it subclasses `Fmt` and overrides
    the `format()` method to include additional functionality (the source code is
    in the full *javasrc* repository for the book).
  prefs: []
  type: TYPE_NORMAL
- en: '3.15 Program: Soundex Name Comparisons'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The difficulties in comparing American-style names inspired the US Census Bureau
    to develop the Soundex algorithm in the early 1900s. Each of a given set of consonants
    maps to a particular number, the effect being to map similar-sounding names together,
    on the grounds that in those days many people were illiterate and could not spell
    their family names consistently. But it is still useful today, for example, in
    a company-wide telephone book application. The names Darwin and Derwin map to
    D650, and Darwent maps to D653, which puts it adjacent to D650\. All of these
    are believed to be historical variants of the same name. Suppose we needed to
    sort lines containing these names together: if we could output the Soundex numbers
    at the beginning of each line, this would be easy. Here is a simple demonstration
    of the `Soundex` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the Darwin-variant names (including Daemon Derwin^([6](ch03.html#idm45290687591464)))
    all sort together and are distinct from the Davidson (and Davis, Davies, etc.)
    names that normally appear between Darwin and Derwin when using a simple alphabetic
    sort. The Soundex algorithm has done its work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `Soundex` class itself—it uses `String`s and `StringBuilder`s to
    convert names into Soundex codes:'
  prefs: []
  type: TYPE_NORMAL
- en: '*main/src/main/java/strings/Soundex.java*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: There are apparently some nuances of the full Soundex algorithm that are not
    implemented by this application. A more complete test using JUnit (see [Recipe
    1.10](ch01.html#javacook-getstarted-junit)) is also online as *SoundexTest.java*,
    in the *src/tests/java/strings* directory. The dedicated reader may use this to
    provoke failures of such nuances and send a pull request with updated versions
    of the test and the code.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Levenshtein string edit distance algorithm can be used for doing approximate
    string comparisons in a different fashion. You can find this in [Apache Commons
    StringUtils](http://commons.apache.org/proper/commons-lang). I show a non-Java
    (Perl) implementation of this algorithm in [Recipe 18.5](ch18.html#javacook-otherlang-SECT-4).
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch03.html#idm45290704847128-marker)) The two `.equals()` calls are equivalent
    with the exception that the first can throw a `NullPointerException` while the
    second cannot.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch03.html#idm45290704715928-marker)) `StringBuilder` was added in Java
    5\. It is functionally equivalent to the older `StringBuffer`. We will delve into
    the details in [Recipe 3.2](#javacook-strings-SECT-3).
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch03.html#idm45290704071000-marker)) Unless, perhaps, you’re as slow at
    updating personal records as I am.
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch03.html#idm45290703693768-marker)) `String` and `StringBuilder` have
    several methods that are forced to be identical by their implementation of the
    `CharSequence` interface.
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](ch03.html#idm45290702287384-marker)) Indeed, there are so many characters
    in Unicode that a fad has emerged of displaying your name upside down using characters
    that approximate upside-down versions of the Latin alphabet. Do a web search for
    “upside-down Unicode.”
  prefs: []
  type: TYPE_NORMAL
- en: ^([6](ch03.html#idm45290687591464-marker)) In Unix terminology, a daemon is
    a server. The old English word has nothing to do with satanic demons but refers
    to a helper or assistant. Derwin Daemon was actually a character in Susannah Coleman’s
    *Source Wars* online comic strip, which long ago was online at a now-departed
    site called *darby.daemonnews.org*.
  prefs: []
  type: TYPE_NORMAL
