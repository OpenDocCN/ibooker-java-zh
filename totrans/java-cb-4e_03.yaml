- en: Chapter 3\. Strings and Things
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章。字符串和其他东西
- en: 3.0 Introduction
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.0 介绍
- en: Character strings are an inevitable part of just about any programming task.
    We use them for printing messages for the user; for referring to files on disk
    or other external media; and for people’s names, addresses, and affiliations.
    The uses of strings are many, almost without number (actually, if you need numbers,
    we’ll get to them in [Chapter 5](ch05.html#javacook-numbers)).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是几乎任何编程任务中不可避免的一部分。我们用它们来向用户打印消息；用来引用磁盘上文件或其他外部媒体；以及用于人们的姓名、地址和所属关系。字符串的用途是多种多样的，几乎不计其数（实际上，如果你需要数字，我们会在[第5章](ch05.html#javacook-numbers)中介绍它们）。
- en: If you’re coming from a programming language like C, you’ll need to remember
    that `String` is a defined type (class) in Java—that is, a string is an object
    and therefore has methods. It is not an array of characters (though it contains
    one) and should not be thought of as an array. Operations like `fileName.endsWith(".gif")`
    and `extension.equals(".gif")` (and the equivalent "`.gif".equals(extension)`)
    are commonplace.^([1](ch03.html#idm45290704847128))
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前有C这样的编程语言的经验，你需要记住在Java中`String`是一个定义的类型（类）——也就是说，字符串是一个对象，因此有方法。它不是一个字符数组（尽管它包含一个），不应该被认为是一个数组。像`fileName.endsWith(".gif")`和`extension.equals(".gif")`（以及相应的
    "`.gif".equals(extension)`）这样的操作是很常见的。^([1](ch03.html#idm45290704847128))
- en: Java old-timers should note that Java 11 and 12 added several new `String` methods,
    including `indent(int n)`, `stripLeading()` and `stripTrailing()`, `Stream<T>`
    `lines()`, `isBlank()`, and `transform()`. Most of these provide obvious functionality;
    the last one allows applying an instance of a functional interface (see [Recipe
    9.0](ch09.html#javacook-fp-intro)) to a string and returning the result of that
    operation.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Java老手应该注意，Java 11和12添加了几个新的`String`方法，包括`indent(int n)`，`stripLeading()`和`stripTrailing()`，`Stream<T>`
    `lines()`，`isBlank()`和`transform()`。其中大多数提供了明显的功能；最后一个允许将一个函数接口的实例（参见[食谱9.0](ch09.html#javacook-fp-intro)）应用于字符串并返回该操作的结果。
- en: Although we haven’t discussed the details of the `java.io` package yet (we will,
    in [Chapter 10](ch10.html#javacook-io)), you need to be able to read text files
    for some of these programs. Even if you’re not familiar with `java.io`, you can
    probably see from the examples of reading text files that a `BufferedReader` allows
    you to read chunks of data and that this class has a very convenient `readLine()`
    method.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们还没有讨论`java.io`包的细节（我们将在[第10章](ch10.html#javacook-io)中讨论），你需要能够读取一些程序所需的文本文件。即使你不熟悉`java.io`，你可能已经从读取文本文件的例子中看到，`BufferedReader`允许你读取数据块，并且这个类有一个非常方便的`readLine()`方法。
- en: 'Going the other way, `System.out.println()` is normally used to print strings
    or other values to the terminal or standard output. String concatenation is commonly
    used here, like this:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 反过来说，`System.out.println()`通常用于将字符串或其他值打印到终端或标准输出。在这里通常使用字符串连接，像这样：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'One caveat with string concatenation is that if you are appending a bunch of
    things, and a number and a character are concatenated at the front, they are added
    before concatenation due to Java’s precedence rules. So don’t do as I did in this
    contrived example:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一个关于字符串连接的警告是，如果你在追加一堆东西时，一个数字和一个字符在前面连接，由于Java的优先规则，它们会在连接之前被添加。因此，不要像我在这个假设的例子中那样做：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Given that `result` is an integer, then `result + ''='' (`result` added to
    the equals sign, which is of the numeric type +char`) is a valid *numeric* expression,
    which will result in a single value of type `int`. If the variable `result` has
    the value 42, and given that the character `=` in a Unicode (or ASCII) code chart
    has the value 61, the two-line fragment would print:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`result`是一个整数，那么`result + '=' (`result`加上等号，这是一个数值类型的+字符`)`就是一个有效的*数值*表达式，其结果将是一个`int`类型的单一值。如果变量`result`的值是42，并且考虑到Unicode（或ASCII）代码表中字符`=`的值是61，那么这两行片段将会打印出：
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The wrong value and no equals sign! Safer approaches include using parentheses,
    double quotes around the equals sign, a `StringBuilder` (see [Recipe 3.2](#javacook-strings-SECT-3)),
    or `String.format()` (see [Recipe 10.4](ch10.html#javacook-io-SECT-3)). Of course
    in this simple example you could just move the *=* to be part of the string literal,
    but the example was chosen to illustrate the problem of arithmetic on `char` values
    being confused with string contatenation. I won’t show you how to sort an array
    of strings here; the more general notion of sorting a collection of objects will
    be taken up in [Recipe 7.11](ch07.html#javacook-structure-SECT-8).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 错误的值和没有等号！更安全的方法包括使用括号、在等号周围加上双引号、使用`StringBuilder`（见[Recipe 3.2](#javacook-strings-SECT-3)）或`String.format()`（见[Recipe
    10.4](ch10.html#javacook-io-SECT-3)）。当然，在这个简单的例子中，你可以将*=*移到字符串字面量的一部分，但选择这个例子是为了说明在`char`值上进行算术运算与字符串连接混淆的问题。我不会在这里向你展示如何对字符串数组进行排序；对对象集合进行排序的更一般概念将在[Recipe
    7.11](ch07.html#javacook-structure-SECT-8)中讨论。
- en: 'Java 14 enables text blocks, also known as multiline text strings. These are
    delimited with a set of three double quotes, the opening of which *must* have
    a newline after the quotes (which doesn’t become part of the string; the following
    newlines do):'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Java 14 支持文本块，也称为多行文本字符串。这些文本块用一组三个双引号界定，开头的引号后面*必须*有一个换行符（这不会成为字符串的一部分；后续的换行符会）：
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 3.1 Taking Strings Apart with Substrings or Tokenizing
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.1 使用子字符串或标记化分解字符串
- en: Problem
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to break a string apart, either by indexing positions or by using fixed
    token characters (e.g., break on spaces to get words).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要将字符串拆分成部分，可以通过索引位置或使用固定的令牌字符（例如，通过空格进行拆分以获取单词）。
- en: Solution
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: For substrings, use the `String` object’s `substring()` method. For tokenizing,
    construct a `StringTokenizer` around your string and call its methods `hasMoreTokens()`
    and `nextToken()`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于子字符串，使用`String`对象的`substring()`方法。对于标记化，构造一个围绕你的字符串的`StringTokenizer`，并调用它的方法`hasMoreTokens()`和`nextToken()`。
- en: Or, use regular expressions (see [Chapter 4](ch04.html#javacook-regex)).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，使用正则表达式（见[第四章](ch04.html#javacook-regex)）。
- en: Discussion
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: We’ll look first at substrings, and then discuss tokenizing.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先看子字符串，然后讨论标记化。
- en: Substrings
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 子字符串
- en: 'The `substring()` method constructs a new `String` object made up of a run
    of characters contained somewhere in the original string, the one whose `substring()`
    you called. The `substring` method is overloaded: both forms require a starting
    index (which is always *zero-based*). The one-argument form returns from `startIndex`
    to the end. The two-argument form takes an ending index (not a length, as in some
    languages) so that an index can be generated by the `String` methods `indexOf()`
    or `las⁠t​IndexOf()`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`substring()`方法构造一个新的`String`对象，由原始字符串的某个位置包含的一系列字符组成，即你调用`substring()`的那个字符串。`substring`方法是重载的：两种形式都需要一个起始索引（始终是*从零开始*）。一种形式的参数返回从`startIndex`到末尾的内容。另一种形式采用一个结束索引（不是长度，如某些语言中那样），以便可以通过`String`方法`indexOf()`或`las⁠t​IndexOf()`生成索引：'
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When run, this prints the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时，这将打印以下内容：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Warning
  id: totrans-28
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Note that the end index is one beyond the last character! Java adopts this policy
    of having a half-open interval (or inclusive start, exclusive end) fairly consistently;
    there are good practical reasons for adopting this approach, and some other languages
    do so too.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，结束索引是最后一个字符的索引加一！Java 在相当大程度上采用了这种半开区间（或包含起始，不包含结束）的策略；采用这种方法有很好的实际理由，一些其他语言也这样做。
- en: Tokenizing
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标记化
- en: 'The easiest way is to use a regular expression. We’ll discuss regular expressions
    in [Chapter 4](ch04.html#javacook-regex), but for now, a string containing a space
    is a valid regular expression to match space characters, so you can most easily
    split a string into words like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是使用正则表达式。我们将在[第四章](ch04.html#javacook-regex)讨论正则表达式，但现在，包含一个空格的字符串是一个有效的正则表达式，可以匹配空格字符，所以你可以最简单地这样将字符串拆分成单词：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you need to match multiple spaces, or spaces and tabs, use the string `"\s+"`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要匹配多个空格，或空格和制表符，请使用字符串`"\s+"`。
- en: If you want to split a file, you can try the string `","` or use one of several
    third-party libraries for CSV files.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要拆分一个文件，可以尝试使用字符串`","`或使用几个第三方库来处理 CSV 文件。
- en: 'Another method is to use `StringTokenizer`. The `StringTokenizer` methods implement
    the `Iterator` interface and design pattern (see [Recipe 7.6](ch07.html#javacook-structure-iterate)):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用`StringTokenizer`。`StringTokenizer`方法实现了`Iterator`接口和设计模式（见[Recipe 7.6](ch07.html#javacook-structure-iterate)）：
- en: '*main/src/main/java/strings/StrTokDemo.java*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*main/src/main/java/strings/StrTokDemo.java*'
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`StringTokenizer` also implements the `Enumeration` interface (see [Recipe
    7.6](ch07.html#javacook-structure-iterate)), but if you use the methods thereof,
    you need to cast the results to `String`.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`StringTokenizer`还实现了`Enumeration`接口（参见[Recipe 7.6](ch07.html#javacook-structure-iterate)），但如果使用其中的方法，您需要将结果转换为`String`。'
- en: 'A `StringTokenizer` normally breaks the `String` into tokens at what we would
    think of as word boundaries in European languages. Sometimes you want to break
    at some other character. No problem. When you construct your `StringTokenizer`,
    in addition to passing in the string to be tokenized, pass in a second string
    that lists the break characters, like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`StringTokenizer`通常会在欧洲语言的单词边界处将`String`拆分为标记。有时您希望在其他字符处进行拆分。没问题。当您构造`StringTokenizer`时，除了传入要标记化的字符串外，还要传入第二个字符串，列出分隔字符，如下所示：
- en: '*main/src/main/java/strings/StrTokDemo2.java*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*main/src/main/java/strings/StrTokDemo2.java*'
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It outputs the four words, each on a line by itself, with no punctuation.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 它按每行一个的方式输出四个单词，没有标点符号。
- en: But wait, there’s more! What if you are reading lines like
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 等等，还有更多！如果您正在读取这样的行
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'and your dear old Aunt Begonia hasn’t been employed for the last 38 years?
    Her `Company` field will in all probability be blank.^([3](ch03.html#idm45290704071000))
    If you look very closely at the previous code example, you’ll see that it has
    two delimiters together (the comma and the space); but if you run it, there are
    no “extra” tokens—that is, the `StringTokenizer` normally discards adjacent consecutive
    delimiters. For cases like the phone list, where you need to preserve null fields,
    there is good news and bad news. The good news is that you can do it: you simply
    add a second argument of `true` when constructing the `StringTokenizer`, meaning
    that you wish to see the delimiters as tokens. The bad news is that you now get
    to see the delimiters as tokens, so you have to do the arithmetic yourself. Want
    to see it? Run this program:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 而你亲爱的老阿姨贝贡尼亚在过去38年没有工作吗？她的`Company`字段很可能为空。^([3](ch03.html#idm45290704071000))
    如果您仔细查看前面的代码示例，您会看到它有两个连续的分隔符（逗号和空格）；但是如果您运行它，没有“额外”的标记——也就是说，`StringTokenizer`通常会丢弃相邻的连续分隔符。对于像电话列表这样需要保留空字段的情况，有好消息和坏消息。好消息是您可以做到：在构造`StringTokenizer`时添加第二个参数`true`，表示希望将分隔符视为标记。坏消息是现在您会看到这些分隔符作为标记，因此您必须自己进行算术计算。想看看吗？运行这个程序：
- en: '*main/src/main/java/strings/StrTokDemo3.java*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*main/src/main/java/strings/StrTokDemo3.java*'
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You will get this output:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您将获得此输出：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This isn’t how you’d like `StringTokenizer` to behave, ideally, but it is serviceable
    enough most of the time. [Example 3-1](#javacook-strings-EX-1) processes and ignores
    consecutive tokens, returning the results as an array of `String`s.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，`StringTokenizer`不应该这样行事，但在大多数情况下，它足够使用了。[Example 3-1](#javacook-strings-EX-1)
    处理并忽略连续的标记，将结果作为`String`数组返回。
- en: Example 3-1\. main/src/main/java/strings/StrTokDemo4.java (StringTokenizer)
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 3-1\. main/src/main/java/strings/StrTokDemo4.java (StringTokenizer)
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When you run this, you will see that `A` is always in Field 1, `B` (if present)
    is in Field 2, and so on. In other words, the null fields are being handled properly:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行此代码时，您会发现`A`始终在字段1中，`B`（如果存在）在字段2中，依此类推。换句话说，空字段被正确处理了：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: See Also
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'Many occurrences of `StringTokenizer` may be replaced with regular expressions
    (see [Chapter 4](ch04.html#javacook-regex)) with considerably more flexibility.
    For example, to extract all the numbers from a `String`, you can use this code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 许多`StringTokenizer`的出现可以用正则表达式替换（参见[Chapter 4](ch04.html#javacook-regex)），具有更大的灵活性。例如，要从一个`String`中提取所有数字，您可以使用以下代码：
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This allows user input to be more flexible than you could easily handle with
    a `StringTokenizer`. Assuming that the numbers represent course numbers at some
    educational institution, the inputs “471,472,570” or “Courses 471 and 472, 570”
    or just “471 472 570” should all give the same results.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许用户输入比您可以轻松处理的`StringTokenizer`更灵活。假设数字表示某个教育机构的课程号，输入“471,472,570”或“课程 471
    和 472, 570”或只是“471 472 570”应该都给出相同的结果。
- en: 3.2 Putting Strings Together with StringBuilder
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.2 使用 StringBuilder 组合字符串
- en: Problem
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to put some `String` pieces (back) together.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要把一些`String`片段（再）组合在一起。
- en: Solution
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use string concatenation: the `+` operator. The compiler implicitly constructs
    a `StringBuilder` for you and uses its `append()` methods (unless all the string
    parts are known at compile time).'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字符串连接：`+`运算符。编译器会为您隐式构造一个`StringBuilder`，并使用其`append()`方法（除非所有字符串部分在编译时都已知）。
- en: Better yet, construct and use a `StringBuilder` yourself.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是自己构建和使用`StringBuilder`。
- en: Discussion
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: An object of one of the `StringBuilder` classes basically represents a collection
    of characters. It is similar to a `String` object.^([4](ch03.html#idm45290703693768))
    However, as mentioned, `String`s are immutable; `StringBuilder`s are mutable and
    designed for, well, building `String`s. You typically construct a `StringBuilder`,
    invoke the methods needed to get the character sequence just the way you want
    it, and then call `toString()` to generate a `String` representing the same character
    sequence for use in most of the Java API, which deals in `String`s.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`StringBuilder`类的对象基本上表示一个字符集合。它类似于一个`String`对象。^([4](ch03.html#idm45290703693768))
    然而，正如前面提到的，`String`是不可变的；而`StringBuilder`是可变的，专门用于构建`String`。通常您会构造一个`StringBuilder`，调用需要的方法以便按照您想要的方式获取字符序列，然后调用`toString()`方法生成表示相同字符序列的`String`，以便在大多数处理`String`的Java
    API中使用。'
- en: '`StringBuffer` is historical—it’s been around since the beginning of time.
    Some of its methods are synchronized (see [Recipe 16.5](ch16.html#javacook-threads-SECT-5)),
    which involves unneeded overhead in a single-threaded context. In Java 5, this
    class was split into `StringBuffer` (which is synchronized) and `StringBuilder`
    (which is not synchronized); thus, it is faster and preferable for single-threaded
    use. Another new class, `AbstractStringBuilder`, is the parent of both. In the
    following discussion, I’ll use “the `StringBuilder` classes” to refer to all three
    because they mostly have the same methods.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`StringBuffer`是历史悠久的——它从时间的开始就存在。它的一些方法是同步的（参见[Recipe 16.5](ch16.html#javacook-threads-SECT-5)），这在单线程环境中会产生不必要的开销。在Java
    5中，这个类被分成了`StringBuffer`（同步的）和`StringBuilder`（非同步的）；因此，对于单线程使用来说，它更快速且更可取。另一个新类`AbstractStringBuilder`是这两者的父类。在接下来的讨论中，我会使用“`StringBuilder`类”来指代这三者，因为它们大部分具有相同的方法。'
- en: The book’s example code provides a `StringBuilderDemo` and a `StringBufferDemo`.
    Except for the fact that `StringBuilder` is not thread-safe, these API classes
    are identical and can be used interchangeably, so my two demo programs are almost
    identical except that each one uses the appropriate builder class.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 书中的示例代码提供了一个`StringBuilderDemo`和一个`StringBufferDemo`。除了`StringBuilder`不是线程安全这一事实外，这些API类完全相同，可以互换使用，因此我的两个演示程序几乎相同，只是每个程序使用了适当的构建器类。
- en: The `StringBuilder` classes have a variety of methods for inserting, replacing,
    and otherwise modifying a given `StringBuilder`. Conveniently, the `append()`
    methods return a reference to the `StringBuilder` itself, so stacked statements
    like `.append(…).append(…)` are fairly common. This style of coding is referred
    to as a *fluent API* because it reads smoothly, like prose from a native speaker
    of a human language. You might even see this style of coding in a `toString()`
    method, for example. [Example 3-2](#javacook-strings-EX-2) shows three ways of
    concatenating strings.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`StringBuilder`类提供了各种方法来插入、替换和修改给定的`StringBuilder`。方便的是，`append()`方法返回对`StringBuilder`本身的引用，因此像`.append(…).append(…)`这样的堆叠语句是相当常见的。这种编码风格被称为*流式API*，因为它读起来流畅，像母语为人类语言的人的散文。例如，在`toString()`方法中甚至可能看到这种编码风格。[Example 3-2](#javacook-strings-EX-2)展示了三种字符串连接的方式。'
- en: Example 3-2\. main/src/main/java/strings/StringBuilderDemo.java
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-2\. main/src/main/java/strings/StringBuilderDemo.java
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In fact, all the methods that modify more than one character of a `StringBuilder`’s
    contents (i.e., `append()`, `delete()`, `deleteCharAt()`, `insert()`, `replace()`,
    and `reverse()`) return a reference to the builder object to facilitate this fluent
    API style of coding.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，所有修改`StringBuilder`内容超过一个字符的方法（即`append()`、`delete()`、`deleteCharAt()`、`insert()`、`replace()`和`reverse()`）都会返回对构建器对象的引用，以支持这种流畅的API编程风格。
- en: As another example of using a `StringBuilder`, consider the need to convert
    a list of items into a comma-separated list while avoiding getting an extra comma
    after the last element of the list. This can be done using a `StringBuilder`,
    although in Java 8+ there is a static `String` method to do the same. Code for
    these are shown in [Example 3-3](#javacook-strings-EX-3).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 再举一个使用`StringBuilder`的例子，考虑将项目列表转换为逗号分隔的列表的需求，同时避免在列表的最后一个元素后面得到额外的逗号。这可以通过`StringBuilder`来实现，尽管在Java
    8+中有一个静态的`String`方法来完成相同的工作。这些代码显示在[Example 3-3](#javacook-strings-EX-3)中。
- en: Example 3-3\. main/src/main/java/strings/StringBuilderCommaList.java
  id: totrans-74
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 3-3\. main/src/main/java/strings/StringBuilderCommaList.java
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The first method is clearly the most compact; the static `String.join()` makes
    short work of this task. The next method uses the `StringBuilder.length()` method,
    so it will only work correctly when you are starting with an empty `StringBuilder`.
    The second method relies on calling the informational method `hasMoreElements()`
    in the `Enumeration` (or `hasNext()` in an `Iterator`, as discussed in [Recipe
    7.6](ch07.html#javacook-structure-iterate)) more than once on each element. An
    alternative method, particularly when you aren’t starting with an empty builder,
    would be to use a `boolean` flag variable to track whether you’re at the beginning
    of the list.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法显然是最紧凑的；静态的`String.join()`可以轻松完成这个任务。接下来的方法使用了`StringBuilder.length()`方法，因此只有在你从一个空的`StringBuilder`开始时才能正确工作。第二种方法依赖于在每个元素上多次调用枚举类型中的信息方法`hasMoreElements()`（或者在`Iterator`中调用`hasNext()`，如[Recipe
    7.6](ch07.html#javacook-structure-iterate)所讨论的那样）。一种替代方法，特别是当你不是从一个空的构建器开始时，可以使用一个`boolean`标志变量来跟踪你是否位于列表的开头。
- en: 3.3 Processing a String One Character at a Time
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.3 逐个字符处理字符串
- en: Problem
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to process the contents of a string, one character at a time.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望逐个字符处理字符串的内容。
- en: Solution
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use a `for` loop and the `String`’s `charAt()` or `codePointAt()` method. Or
    use a “for each” loop and the `String`’s `toCharArray` method.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`for`循环和`String`的`charAt()`或`codePointAt()`方法。或使用“for each”循环和`String`的`toCharArray`方法。
- en: Discussion
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'A string’s `charAt()` method retrieves a given character by index number (starting
    at zero) from within the `String` object. Since Unicode has had to expand beyond
    16 bits, not all Unicode characters can fit into a Java `char` variable. There
    is thus an analogous `codePointAt()` method, whose return type is `int`. To process
    all the characters in a `String`, one after another, use a `for` loop ranging
    from zero to `String.length()-1`. Here we process all the characters in a `String`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串的`charAt()`方法通过索引号（从零开始）从`String`对象中检索给定字符。由于Unicode已经扩展到超过16位，不是所有的Unicode字符都能容纳在Java的`char`变量中。因此有一个类似的`codePointAt()`方法，其返回类型是`int`。要处理`String`中的所有字符，可以使用一个从零到`String.length()-1`的`for`循环。这里我们处理`String`中的所有字符：
- en: '*main/src/main/java/strings/strings/StrCharAt.java*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*main/src/main/java/strings/strings/StrCharAt.java*'
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Given that the “for each” loop has been in the language for ages, you might
    be excused for expecting to be able to write something like `for (char ch : myString)
    {…}`. Unfortunately, this does not work. But you can use `myString.toCharArray()`
    as in the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '鉴于“for each”循环已经存在很久，你可能原谅你期望能够像这样写一些东西`for (char ch : myString) {…}`。不幸的是，这并不起作用。但是你可以使用`myString.toCharArray()`如下所示：'
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: A *checksum* is a numeric quantity representing and confirming the contents
    of a file. If you transmit the checksum of a file separately from the contents,
    a recipient can checksum the file—assuming the algorithm is known—and verify that
    the file was received intact. [Example 3-4](#javacook-strings-EX-3a) shows the
    simplest possible checksum, computed just by adding the numeric values of each
    character. Note that on files, it does not include the values of the newline characters;
    in order to fix this, retrieve `System​.getProp⁠erty("line.separator");` and add
    its character value(s) into the sum at the end of each line. Or give up on line
    mode and read the file a character at a time.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*校验和*是表示和确认文件内容的数字量。如果你将文件的校验和与内容分开传输，接收方可以对文件进行校验——假设算法是已知的——并验证文件是否完整接收。[Example 3-4](#javacook-strings-EX-3a)展示了一种最简单的校验和计算方法，只需将每个字符的数值相加。注意，在文件上，它不包括换行符的值；为了修正这一点，检索`System​.getProp⁠erty("line.separator");`并将其字符值添加到每行的末尾。或者放弃行模式，逐个字符读取文件。'
- en: Example 3-4\. main/src/main/java/strings/CheckSum.java
  id: totrans-89
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 3-4\. main/src/main/java/strings/CheckSum.java
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 3.4 Aligning, Indenting, and Unindenting Strings
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.4 对齐、缩进和取消缩进字符串
- en: Problem
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to align strings to the left, right, or center.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你想将字符串左对齐、右对齐或居中。
- en: Solution
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Do the math yourself, and use `substring` (see [Recipe 3.1](#javacook-strings-SECT-1))
    and a `StringBuilder` (see [Recipe 3.2](#javacook-strings-SECT-3)). Or, use my
    `StringAlign` class, which is based on the `java.text.Format` class. For left
    or right alignment, use `String.format()`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 自己做数学运算，使用 `substring`（参见 [Recipe 3.1](#javacook-strings-SECT-1)） 和 `StringBuilder`（参见
    [Recipe 3.2](#javacook-strings-SECT-3)）。或者，使用我的 `StringAlign` 类，该类基于 `java.text.Format`
    类。对于左对齐或右对齐，使用 `String.format()`。
- en: Discussion
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Centering and aligning text comes up fairly often. Suppose you want to print
    a simple report with centered page numbers. There doesn’t seem to be anything
    in the standard API that will do the job fully for you. But I have written a class
    called `String​A⁠lign` that will. Here’s how you might use it:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 文本居中和对齐经常会出现。假设你想打印一个简单的报告，并希望页面数字居中显示。标准 API 中似乎没有任何可以完全帮助你完成工作的东西。但我写了一个名为
    `String​A⁠lign` 的类可以做到。下面是你可能如何使用它的方法：
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you compile and run this class, it prints the two demonstration line numbers
    centered, as shown:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你编译并运行这个类，它会打印出两个演示行号，并使它们居中显示，如下所示：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[Example 3-5](#javacook-strings-EX-4) is the code for the `StringAlign` class.
    Note that this class extends the class `Format` in the package `java.text`. There
    is a series of `Format` classes that all have at least one method called `format()`.
    It is thus in a family with numerous other formatters, such as `DateFormat` and
    `NumberFormat`, that we’ll take a look at in upcoming chapters.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 3-5](#javacook-strings-EX-4) 是 `StringAlign` 类的代码。注意，该类扩展了 `java.text`
    包中的 `Format` 类。有一系列至少有一个名为 `format()` 的方法的 `Format` 类。因此，它与许多其他格式化程序（如 `DateFormat`
    和 `NumberFormat`）一起，我们将在接下来的章节中看到。'
- en: Example 3-5\. main/src/main/java/strings/StringAlign.java
  id: totrans-102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-5\. main/src/main/java/strings/StringAlign.java
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Java 12 introduced a new method `public String indent(int n)` that prepends
    *n* spaces to the string, which is treated as a sequence of lines with line separators.
    This works well in conjunction with the Java 11 `Stream<String> lines()` method.
    For example, for the case where a series of lines, already stored in a single
    string, needs the same indent (`Streams`, and the “::” notation, are explained
    in [Recipe 9.0](ch09.html#javacook-fp-intro)):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Java 12 引入了一个名为 `public String indent(int n)` 的新方法，该方法将 *n* 个空格添加到字符串前面，字符串被视为带有换行符的行序列。这与
    Java 11 的 `Stream<String> lines()` 方法配合使用效果很好。例如，对于一系列已经存储在单个字符串中的行需要相同的缩进的情况（`Streams`
    和 “::” 符号的使用在 [Recipe 9.0](ch09.html#javacook-fp-intro) 中有介绍）：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: See Also
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The alignment of numeric columns is considered in [Chapter 5](ch05.html#javacook-numbers).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 数字列的对齐考虑在 [第 5 章](ch05.html#javacook-numbers) 中。
- en: 3.5 Converting Between Unicode Characters and Strings
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.5 Unicode 字符和字符串之间的转换
- en: Problem
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to convert between Unicode characters and `String`s.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你想在 Unicode 字符和 `String` 之间转换。
- en: Solution
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use Java `char` or `String` data types to deal with characters; these intrinsically
    support Unicode. Print characters as integers to display their *raw* value if
    needed.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Java `char` 或 `String` 数据类型处理字符；这些类型本身支持 Unicode。如果需要，将字符打印为整数以显示它们的 *原始*
    值。
- en: Discussion
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Unicode is an international standard that aims to represent all known characters
    used by people in their various languages. Though the original ASCII character
    set is a subset, Unicode is huge. At the time Java was created, Unicode was a
    16-bit character set, so it seemed natural to make Java `char` values be 16 bits
    in width, and for years a `char` could hold any Unicode character. However, over
    time, Unicode has grown, to the point that it now includes over a million code
    points, or characters, more than the 65,525 that could be represented in 16 bits.^([5](ch03.html#idm45290702287384))
    Not all possible 16-bit values were defined as characters in UCS-2, the 16-bit
    version of Unicode originally used in Java. A few were reserved as escape characters,
    which allows for multicharacter-length mappings to less common characters. Fortunately,
    there is a go-between standard, called UTF-16 (16-bit Unicode Transformation Format).
    As the `String` class documentation puts it:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode 是一个国际标准，旨在表示人们在各种语言中使用的所有已知字符。尽管原始的 ASCII 字符集是其子集，但 Unicode 是庞大的。在 Java
    创建时，Unicode 是一个 16 位字符集，因此将 Java 的 `char` 值设为 16 位宽度似乎是自然的选择，多年来，`char` 可以容纳任何
    Unicode 字符。然而，随着时间的推移，Unicode 不断增长，现在包括超过一百万个代码点或字符，远远超过了 16 位可以表示的 65,525 个字符。[^5]
    并非所有可能的 16 位值都被定义为 UCS-2 中的字符，UCS-2 是 Java 中最初使用的 16 位版本的 Unicode。一些被保留为转义字符，允许将多字符长度映射到不常见的字符。幸运的是，有一个中间标准，称为
    UTF-16（16 位 Unicode 转换格式）。正如 `String` 类文档所述：
- en: A `String` represents a string in the UTF-16 format in which *supplementary
    characters* are represented by *surrogate pairs* (see the section Unicode Character
    Representations in the `Character` class for more information). Index values refer
    to char code units, so a supplementary character uses two positions in a `String`.
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`String` 表示 UTF-16 格式中的字符串，其中*补充字符*由*代理对*表示（有关更多信息，请参见`Character` 类中 Unicode
    字符表示部分）。索引值指的是字符代码单元，因此补充字符在 `String` 中使用两个位置。'
- en: ''
  id: totrans-116
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `String` class provides methods for dealing with Unicode code points (i.e.,
    characters), in addition to those for dealing with Unicode code units (i.e., `char
    values`).
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`String` 类提供了处理 Unicode 代码点（即字符）的方法，除了处理 Unicode 代码单元（即 `char values`）的方法。'
- en: 'The `charAt()` method of `String` returns the `char` value for the character
    at the specified offset. The `StringBuilder append()` method has a form that accepts
    a `char`. Because `char` is an integer type, you can even do arithmetic on `char`s,
    though this is not needed as frequently as in, say, C. Nor is it often recommended,
    because the `Character` class provides the methods for which these operations
    were normally used in languages such as C. Here is a program that uses arithmetic
    on `char`s to control a loop and that also appends the characters into a `StringBuilder`
    (see [Recipe 3.2](#javacook-strings-SECT-3)):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`String` 的 `charAt()` 方法返回指定偏移量处字符的 `char` 值。`StringBuilder append()` 方法有一种形式接受一个
    `char`。因为 `char` 是一个整数类型，你甚至可以对 `char` 进行算术运算，尽管这不像在 C 中那样频繁需要。也不常推荐，因为 `Character`
    类提供了在诸如 C 语言中通常使用这些操作的方法。这里是一个使用 `char` 算术控制循环并将字符附加到 `StringBuilder` 中的程序（见 [Recipe
    3.2](#javacook-strings-SECT-3)）：'
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When you run it, the expected results are printed for the ASCII characters.
    On Unix and characters in Mac systems, the default fonts don’t include all the
    additional characters, so they are either omitted or mapped to irregular characters:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行它时，预期的结果将为 ASCII 字符打印出来。在 Unix 和 Mac 系统中，默认字体不包括所有附加字符，因此它们要么被省略，要么映射到不规则字符：
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The Windows system used to try this doesn’t have most of those characters either,
    but at least it prints as question marks the ones it knows are lacking (Windows
    system fonts are more homogenous than those of the various Unix systems, so it
    is easier to know what won’t work). On the other hand, it tries to print the yen
    sign as an N with a tilde:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 系统也不包含大多数这些字符，但至少它打印出它知道缺失的字符作为问号（Windows 系统字体比各种 Unix 系统更同质化，因此更容易知道哪些不起作用）。另一方面，它尝试将日元符号打印为带有波浪号的
    N：
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The “_” characters are unprintable characters.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: “_” 字符是不可打印的字符。
- en: See Also
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: The `Unicode` program in this book’s online source displays any 256-character
    section of the Unicode character set. You can download documentation listing every
    character in the Unicode character set from the [Unicode Consortium](http://www.unicode.org).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 本书在线源代码中的`Unicode`程序显示Unicode字符集的任何256字符部分。您可以从[Unicode Consortium](http://www.unicode.org)下载列出Unicode字符集中每个字符的文档。
- en: 3.6 Reversing a String by Word or by Character
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.6 按单词或按字符反转字符串
- en: Problem
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You wish to reverse a string, a character at a time or a word at a time.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望逐字符或逐单词反转字符串。
- en: Solution
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: You can reverse a string by character easily, using a `StringBuilder`. There
    are several ways to reverse a string a word at a time. One natural way is to use
    a `StringTokenizer` and a stack. `Stack` is a class (defined in `java.util`; see
    [Recipe 7.16](ch07.html#javacook-structure-SECT-14)) that implements an easy-to-use
    last-in, first-out (LIFO) stack of objects.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以轻松地按字符反转字符串，使用`StringBuilder`。有几种方法可以按单词反转字符串。一种自然的方法是使用`StringTokenizer`和一个堆栈。`Stack`是一个类（定义在`java.util`中；参见
    [Recipe 7.16](ch07.html#javacook-structure-SECT-14)），实现了一个易于使用的后进先出（LIFO）对象堆栈。
- en: Discussion
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'To reverse the characters in a string, use the `StringBuilder reverse()` method:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要反转字符串中的字符，请使用`StringBuilder reverse()`方法：
- en: '*main/src/main/java/strings/StringRevChar.java*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*main/src/main/java/strings/StringRevChar.java*'
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The letters in this example list the order of the sharps in the key signatures
    of Western music; in reverse, it lists the order of flats. Alternatively, of course,
    you could reverse the characters yourself, using character-at-a-time mode (see
    [Recipe 3.3](#javacook-strings-SECT-4)).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子中的字母列出了西方音乐调号中升调的顺序；反过来，它列出了降调的顺序。当然，您也可以自己反转字符，使用逐字符模式（参见 [Recipe 3.3](#javacook-strings-SECT-4)）。
- en: A popular mnemonic, or memory aid, to help music students remember the order
    of sharps and flats consists of one word for each sharp instead of just one letter.
    Let’s reverse this *one word at a time*. [Example 3-6](#javacook-strings-EX-5)
    adds each one to a `Stack` (see [Recipe 7.16](ch07.html#javacook-structure-SECT-14)),
    then processes the whole lot in LIFO order, which reverses the order.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一种流行的记忆法或助记符，帮助音乐学生记住升调和降调的顺序，是用每个升调的一个单词而不是一个字母。让我们逐个*单词地*反转这一点。 [示例 3-6](#javacook-strings-EX-5)
    将每个添加到一个`Stack`（参见 [Recipe 7.16](ch07.html#javacook-structure-SECT-14)），然后以LIFO顺序处理整个批次，以颠倒顺序。
- en: Example 3-6\. main/src/main/java/strings/StringReverse.java
  id: totrans-138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-6\. main/src/main/java/strings/StringReverse.java
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 3.7 Expanding and Compressing Tabs
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.7 扩展和压缩制表符
- en: Problem
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to convert space characters to tab characters in a file, or vice versa.
    You might want to replace spaces with tabs to save space on disk or go the other
    way to deal with a device or program that can’t handle tabs.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在文件中将空格字符转换为制表符字符，或者反之。您可能希望将空格替换为制表符以节省磁盘空间，或者反之以处理无法处理制表符的设备或程序。
- en: Solution
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use my `Tabs` class or its subclass `EnTab`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我的`Tabs`类或其子类`EnTab`。
- en: Discussion
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Because programs that deal with tabbed text or data expect tab stops to be at
    fixed positions, you cannot use a typical text editor to replace tabs with spaces
    or vice versa. [Example 3-7](#javacook-strings-EX-6) is a listing of `EnTab`,
    complete with a sample main program. The program works a line at a time. For each
    character on the line, if the character is a space, we see if we can coalesce
    it with previous spaces to output a single tab character. This program depends
    on the `Tabs` class, which we’ll come to shortly. The `Tabs` class is used to
    decide which column positions represent tab stops and which do not.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 因为处理带制表符文本或数据的程序期望制表位于固定位置，您不能使用典型的文本编辑器替换制表符为空格或反之。 [示例 3-7](#javacook-strings-EX-6)
    是`EnTab`的列表，包含一个示例主程序。该程序逐行工作。对于每行的每个字符，如果字符是空格，我们看看是否可以与之前的空格合并以输出单个制表符字符。该程序依赖于`Tabs`类，我们稍后会讲到。`Tabs`类用于确定哪些列位置代表制表位，哪些不是。
- en: Example 3-7\. main/src/main/java/strings/Entab.java
  id: totrans-147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-7\. main/src/main/java/strings/Entab.java
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This code was patterned after a program in Kernighan and Plauger’s classic work
    *Software Tools*. While their version was in a language called RatFor (Rational
    Fortran), my version has since been through several translations. Their version
    actually worked one character at a time, and for a long time I tried to preserve
    this overall structure. Eventually, I rewrote it to be a line-at-a-time program.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是模仿Kernighan和Plauger经典著作《软件工具》中的一个程序编写的。虽然他们的版本是用一种叫做RatFor（Rational Fortran）的语言编写的，但我的版本经过多次翻译。他们的版本实际上是逐个字符处理的，我很长一段时间都试图保留这种整体结构。最终，我将其重写为逐行处理的程序。
- en: The program that goes in the opposite direction—putting tabs in rather than
    taking them out—is the `DeTab` class shown in [Example 3-8](#javacook-strings-EX-7);
    only the core methods are shown.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 反方向进行操作——将制表符插入而不是删除——的程序是`DeTab`类，示例见[Example 3-8](#javacook-strings-EX-7)；这里只展示了核心方法。
- en: Example 3-8\. main/src/main/java/strings/DeTab.java
  id: totrans-151
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-8\. main/src/main/java/strings/DeTab.java
- en: '[PRE30]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `Tabs` class provides two methods: `settabpos()` and `istabstop()`. [Example 3-9](#javacook-strings-EX-8)
    is the source for the `Tabs` class.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`Tabs`类提供了两个方法：`settabpos()`和`istabstop()`。[Example 3-9](#javacook-strings-EX-8)是`Tabs`类的源代码。'
- en: Example 3-9\. main/src/main/java/strings/Tabs.java
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-9\. main/src/main/java/strings/Tabs.java
- en: '[PRE31]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 3.8 Controlling Case
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.8 控制大小写
- en: Problem
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to either convert strings to uppercase or lowercase or compare strings
    without regard for case.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要将字符串转换为大写或小写，或者在比较字符串时忽略大小写。
- en: Solution
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'The `String` class has a number of methods for dealing with documents in a
    particular case. `toUpperCase()` and `toLowerCase()` each return a new string
    that is a copy of the current string but converted, as the name implies. Each
    can be called either with no arguments or with a `Locale` argument specifying
    the conversion rules; this is necessary because of internationalization. Java’s
    API provides significant internationalization and localization features, as covered
    in [“Ian’s Basic Steps: Internationalization and Localization”](#javacook-i18n-SIDEBAR-1).
    Whereas the `equals()` method tells you if another string is exactly the same,
    `equalsIgnoreCase()` tells you if all characters are the same regardless of case.
    Here, you can’t specify an alternative locale; the system’s default locale is
    used:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`String`类有多个用于处理特定情况下文档的方法。`toUpperCase()`和`toLowerCase()`分别返回一个新的字符串副本，按照其名称进行转换。每个方法都可以使用无参数或使用指定转换规则的`Locale`参数调用；这是因为国际化的需要。Java的API提供了重要的国际化和本地化功能，详见[“Ian''s
    Basic Steps: Internationalization and Localization”](#javacook-i18n-SIDEBAR-1)。而`equals()`方法告诉您另一个字符串是否完全相同，`equalsIgnoreCase()`告诉您所有字符是否相同，而不考虑大小写。在这里，您不能指定替代区域设置；系统使用默认区域设置：'
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If you run this, it prints the first name changed to uppercase and lowercase,
    then it reports that both methods work as expected:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行此代码，它将打印第一个名称的大写和小写版本，然后报告两种方法按预期工作：
- en: '[PRE33]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: See Also
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Regular expressions make it simpler to ignore case in string searching (as we
    see in [Chapter 4](ch04.html#javacook-regex)).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式使得在字符串搜索中忽略大小写更加简单（见[Chapter 4](ch04.html#javacook-regex)）。
- en: 3.9 Entering Nonprintable Characters
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.9 输入不可打印字符
- en: Problem
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to put nonprintable characters into strings.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要将不可打印字符放入字符串中。
- en: Solution
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the backslash character and one of the Java string escapes.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用反斜杠字符和Java字符串转义序列之一。
- en: Discussion
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The Java string escapes are listed in [Table 3-1](#javacook-strings-TABLE-1).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Java字符串转义列在[Table 3-1](#javacook-strings-TABLE-1)中。
- en: Table 3-1\. String escapes
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 3-1\. 字符串转义
- en: '| To get | Use | Notes |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| 获取 | 使用 | 注释 |'
- en: '| --- | --- | --- |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Tab | `\t` |  |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| 制表符 | `\t` |  |'
- en: '| Linefeed (Unix newline) | `\n` | The call `System.getProperty("line.separator")`
    will give you the platform’s line end. |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| 换行符（Unix换行符） | `\n` | 调用`System.getProperty("line.separator")`将给出平台的行尾。 |'
- en: '| Carriage return | `\r` |  |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 回车符 | `\r` |  |'
- en: '| Form feed | `\f` |  |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| 换页符 | `\f` |  |'
- en: '| Backspace | `\b` |  |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| 退格符 | `\b` |  |'
- en: '| Single quote | `\`'' |  |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| 单引号 | `\`'' |  |'
- en: '| Double quote | `\`" |  |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| 双引号 | `\`" |  |'
- en: '| Unicode character | `\u` *`NNNN`* | Four hexadecimal digits (no `\x` as in
    C/C++). See [*http://www.unicode.org*](http://www.unicode.org) for codes. |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| Unicode字符 | `\u` *`NNNN`* | 四个十六进制数字（无`\x`，类似于C/C++）。参见[*http://www.unicode.org*](http://www.unicode.org)获取代码。
    |'
- en: '| Octal(!) character | +\+*`NNN`* | Who uses octal (base 8) these days? |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| 八进制（！）字符 | +\+*`NNN`* | 现在谁还使用八进制（基数8）？ |'
- en: '| Backslash | `\\` |  |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| 反斜杠 | `\\` |  |'
- en: 'Here is a code example that shows most of these in action:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个代码示例，展示了其中大部分功能：
- en: '[PRE34]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If you have a lot of non-ASCII characters to enter, you may wish to consider
    using Java’s input methods, discussed briefly in the [online documentation](https://docs.oracle.com/javase/8/docs/technotes/guides/imf/index.html).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有很多非 ASCII 字符需要输入，你可能希望考虑使用 Java 的输入方法，这在[在线文档](https://docs.oracle.com/javase/8/docs/technotes/guides/imf/index.html)中简要讨论过。
- en: 3.10 Trimming Blanks from the End of a String
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.10 剥离字符串末尾的空白
- en: Problem
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to work on a string without regard for extra leading or trailing spaces
    a user may have typed.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要处理用户可能输入的额外前导或尾随空格的字符串。
- en: Solution
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the `String` class `strip()` or `trim()` methods.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `String` 类的 `strip()` 或 `trim()` 方法。
- en: Discussion
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'There are four methods in the `String` class for this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`String` 类中有四种方法可以实现这个功能：'
- en: '`strip()`'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`strip()`'
- en: Returns a string with all leading and trailing whitespace removed
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个去除了所有前导和尾随空白的字符串
- en: '`stripLeading()`'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`stripLeading()`'
- en: Returns a string whose value is this string, with all leading white space removed
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个去除了所有前导空白的字符串
- en: '`stripTrailing()`'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`stripTrailing()`'
- en: Returns the string with all trailing whitespace removed
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 返回去除了所有尾随空白的字符串
- en: '`String trim()`'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`String trim()`'
- en: Returns the string with all leading and trailing spaces removed
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 返回去除了所有前导和尾随空格的字符串
- en: For the `strip()` methods, whitespace is as defined by `Character.isSpace()`.
    For the `trim()` method, space includes any character whose numeric value is less
    than or equal to 32, or *U+0020* (the space character).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `strip()` 方法，空白由 `Character.isSpace()` 定义。对于 `trim()` 方法，空格包括任何数值小于或等于 32
    的字符，或 *U+0020*（空格字符）。
- en: '[Example 3-10](#javacook-strings-EX-9) uses `trim()` to strip an arbitrary
    number of leading spaces and/or tabs from lines of Java source code in order to
    look for the characters `//+` and `//-`. These strings are special Java comments
    I previously used to mark the parts of the programs in this book that I wanted
    to include in the printed copy.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 3-10](#javacook-strings-EX-9) 使用 `trim()` 来剥离 Java 源代码行中任意数量的前导空格和/或制表符，以便查找字符
    `//+` 和 `//-`。这些字符串是我之前用来标记本书中要包含在印刷本中的程序部分的特殊 Java 注释。'
- en: Example 3-10\. main/src/main/java/strings/GetMark.java (trimming and comparing
    strings)
  id: totrans-206
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-10\. main/src/main/java/strings/GetMark.java（剥离和比较字符串）
- en: '[PRE35]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 3.11 Creating a Message with I18N Resources
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.11 使用 I18N 资源创建消息
- en: Problem
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want your program to take sensitivity training so that it can communicate
    well internationally.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望你的程序接受敏感性培训，以便能够在国际上良好地沟通。
- en: Solution
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Your program must obtain all control and message strings via the internationalization
    software. Here’s how:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你的程序必须通过国际化软件获取所有控件和消息字符串。下面是方法：
- en: 'Get a `ResourceBundle`:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取一个 `ResourceBundle`：
- en: '[PRE36]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: I’ll talk about `ResourceBundle` in [Recipe 3.13](#javacook-i18n-SECT-6), but
    briefly, a `ResourceBundle` represents a collection of name-value pairs (resources).
    The names are names you assign to each GUI control or other user interface text,
    and the values are the text to assign to each control in a given language.
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我会在[食谱 3.13](#javacook-i18n-SECT-6)中讨论 `ResourceBundle`，但简要来说，`ResourceBundle`
    表示一组名称-值对（资源）。名称是您分配给每个 GUI 控件或其他用户界面文本的名称，而值是分配给每个控件的文本在给定语言中的文本。
- en: Use this `ResourceBundle` to fetch the localized version of each control name.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这个 `ResourceBundle` 来获取每个控件名称的本地化版本。
- en: 'Old way:'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 旧方法：
- en: '[PRE37]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'New way:'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 新方法：
- en: '[PRE38]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This may seem quite a bit of code for one control, but you can write a convenience
    routine to simplify it, like this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个控件来说，这可能是相当多的代码，但是你可以编写一个方便的例程来简化它，就像这样：
- en: '[PRE39]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The file *I18NUtil.java* is included in the book’s code distribution.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 *I18NUtil.java* 包含在书的代码分发中。
- en: 'While the example is a Swing `JButton`, the same approach goes with other UIs,
    such as the web tier. In JSF, for example, you might place your strings in a properties
    file called *resources.properties* and store it in *src/main/resources*. You would
    load this in *faces-config.xml*:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然示例是一个 Swing `JButton`，但同样的方法也适用于其他 UI，比如 Web 层。例如，在 JSF 中，你可以将字符串放在一个名为 *resources.properties*
    的属性文件中，并将其存储在 *src/main/resources* 中。你可以在 *faces-config.xml* 中加载这个文件：
- en: '[PRE40]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then in each web page that needs these strings, refer to the resource using
    the `msg` variable in an expression:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在每个需要这些字符串的 Web 页面中，使用表达式中的 `msg` 变量引用资源：
- en: '[PRE41]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: What happens at runtime?
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行时会发生什么？
- en: 'The default locale is used, because we didn’t specify one. The default locale
    is platform dependent:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 使用默认区域设置，因为我们没有指定任何一个。默认区域设置是依赖于平台的：
- en: Unix/POSIX
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Unix/POSIX
- en: LANG environment variable (per user)
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: LANG 环境变量（每个用户）
- en: Windows
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Windows
- en: Control Panel→Regional Settings
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 控制面板→区域设置
- en: macOS
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: macOS
- en: System Preferences→Language & Text
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 系统首选项→语言与文本
- en: Others
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 其他
- en: See platform documentation
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 查看平台文档
- en: '`ResourceBundle.getBundle()` locates a file with the named resource bundle
    name (`Menus`, in the previous example), plus an underscore and the locale name
    (if a non-default locale is set), plus another underscore and the locale variation
    (if any variation is set), plus the extension *.properties*. If a variation is
    set but the file can’t be found, it falls back to just the country code. If that
    can’t be found, it falls back to the original default. [Table 3-2](#javacook-i18n-TABLE-1)
    shows some examples for various locales.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResourceBundle.getBundle()`会查找具有指定资源包名称的文件（在前面的示例中为`Menus`），加上下划线和语言环境名称（如果设置了非默认语言环境），再加上另一个下划线和语言环境变体（如果设置了变体），最后加上扩展名*.properties*。如果设置了变体但找不到文件，则会回退到只使用国家代码。如果连国家代码也找不到，则会回退到原始默认设置。[表 3-2](#javacook-i18n-TABLE-1)
    显示了各种语言环境的示例。'
- en: Note that Android apps—usually written in Java or Kotlin—use a similar mechanism
    but with the files in XML format instead of Java Properties and with some small
    changes in the name of the file in which the properties files are found.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Android应用程序通常使用类似的机制（但是使用XML格式的文件而不是Java属性文件，并且在找到属性文件的文件名时进行了一些小的更改）。
- en: Table 3-2\. Property filenames for different locales
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 表3-2\. 不同语言环境的属性文件名
- en: '| Locale | Filename |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| 语言环境 | 文件名 |'
- en: '| --- | --- |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Default locale | *Menus.Properties* |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| 默认语言环境 | *Menus.Properties* |'
- en: '| Swedish | *Menus_sv.properties* |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| 瑞典语 | *Menus_sv.properties* |'
- en: '| Spanish | *Menus_es.properties* |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| 西班牙语 | *Menus_es.properties* |'
- en: '| French | *Menus_fr.properties* |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| 法语 | *Menus_fr.properties* |'
- en: '| French-Canadian | *Menus_fr_CA.properties* |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| 加拿大法语 | *Menus_fr_CA.properties* |'
- en: Locale names are two-letter ISO-639 language codes (lowercase), and they normally
    abbreviate the country’s *endonym* (the name its language speakers refer to it
    by); thus, Sweden is *sv* for *Sverige*, Spain is *es* for *Espanol*, etc. Locale
    variations are two-letter ISO country codes (uppercase); for example, e.g., CA
    for Canada, US for the United States, SV for Sweden, ES for Spain, etc.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 语言环境名称是两个字母的ISO-639语言代码（小写），通常是国家的*本土名称*（其语言使用者称呼它的名称）的缩写；因此，瑞典是*sv*表示*Sverige*，西班牙是*es*表示*Español*，等等。语言环境变体是两个字母的ISO国家代码（大写）；例如，CA表示加拿大，US表示美国，SV表示瑞典，ES表示西班牙，等等。
- en: Setting the locale
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置语言环境
- en: On Windows, go into Regional Settings in the Control Panel. Changing this setting
    may entail a reboot, so exit any editor windows.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，进入控制面板中的区域设置。更改此设置可能需要重新启动，因此请关闭所有编辑器窗口。
- en: 'On Unix, set your `LANG` environment variable. For example, a Korn shell user
    in Mexico might have this line in her *.profile*:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unix上，设置您的`LANG`环境变量。例如，墨西哥的Korn shell用户可能在她的*.profile*文件中有如下行：
- en: '[PRE42]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'On either system, for testing a different locale, you need only define the
    locale in the System Properties at runtime using the command-line option `-D`,
    as in:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在任一系统上，要测试不同的语言环境，只需在运行时通过命令行选项`-D`定义语言环境，例如：
- en: '[PRE43]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This runs the Java program named `Browser` in package `i18n` in the Spanish
    locale.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在西班牙语环境中运行名为`Browser`的Java程序，位于`i18n`包中。
- en: You can get a list of the available locales with a call to `Locale.getAvailable​Lo⁠cales()`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过调用`Locale.getAvailable​Lo⁠cales()`获取可用语言环境的列表。
- en: 3.12 Using a Particular Locale
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.12 使用特定的语言环境
- en: Problem
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to use a locale other than the default in a particular operation.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在特定操作中，您可能希望使用除默认语言环境之外的语言环境。
- en: Solution
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Obtain a `Locale` by using a predefined instance or the `Locale` constructor.
    Optionally make it global to your application by using `Locale.setDefault(newLocale)`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 使用预定义实例或`Locale`构造函数来获取`Locale`。如果需要，可以使用`Locale.setDefault(newLocale)`将其设置为应用程序的全局默认值。
- en: Discussion
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Classes that provide formatting services, such as `DateTimeFormatter` and `NumberFormat`,
    provide overloads so they can be called either with or without a `Locale`-related
    argument.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 提供格式化服务的类，如`DateTimeFormatter`和`NumberFormat`，提供了重载方法，可以带有或不带有与`Locale`相关的参数来调用。
- en: 'To obtain a `Locale` object, you can employ one of the predefined locale variables
    provided by the `Locale` class, or you can construct your own `Locale` object
    giving a language code and a country code:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取`Locale`对象，可以使用`Locale`类提供的预定义语言变量之一，或者构造自己的`Locale`对象，提供语言代码和国家代码：
- en: '[PRE44]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'These can then be used in the various formatting operations:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这些语言环境可以在各种格式化操作中使用：
- en: '[PRE45]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Either of these can be used to format a date or a number, as shown in class
    `Use​Lo⁠cales`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用其中任何一种来格式化日期或数字，如`Use​Lo⁠cales`类中所示：
- en: '[PRE46]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The program prints the locale name and formats the date in each of the locales:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 程序在每个区域设置中打印区域名称并格式化日期：
- en: '[PRE47]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 3.13 Creating a Resource Bundle
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.13 创建资源包
- en: Problem
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to create a resource bundle for use with I18N.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要为国际化（I18N）创建一个资源包。
- en: Solution
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: A resource bundle is simply a collection of names and values. You could write
    a `java.util.ResourceBundle` subclass, but it is easier to create textual `Properties`
    files (see [Recipe 7.10](ch07.html#javacook-structure-SECT-7)) that you then load
    with `ResourceBundle.getBundle()`. The files can be created using any plain text
    editor. Leaving it in a text file format also allows user customization in desktop
    applications; a user whose language is not provided for, or who wishes to change
    the wording somewhat due to local variations in dialect, should be able to edit
    the file.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 资源包只是名称和值的集合。您可以编写一个`java.util.ResourceBundle`子类，但创建文本`Properties`文件（参见[Recipe
    7.10](ch07.html#javacook-structure-SECT-7)）然后使用`ResourceBundle.getBundle()`加载它们更容易。可以使用任何纯文本编辑器创建这些文件。将其保留在文本文件格式中还允许桌面应用程序中的用户进行自定义；不提供其语言或希望根据方言的地方变化更改措辞的用户应能够编辑文件。
- en: Note that the resource bundle text file should not have the same name as any
    of your Java classes. The reason is that the `ResourceBundle` constructs a class
    dynamically with the same name as the resource files.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，资源包文本文件不应与任何您的Java类具有相同的名称。原因是`ResourceBundle`动态构建一个与资源文件同名的类。
- en: Discussion
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Here is a sample properties file for a few menu items:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一份用于几个菜单项的示例属性文件：
- en: '[PRE48]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Creating the default properties file is usually not a problem, but creating
    properties files for other languages might be. Unless you are a large multinational
    corporation, you will probably not have the resources (pardon the pun) to create
    resource files in-house. If you are shipping commercial software or using the
    web for global reach, you need to identify your target markets and understand
    which of these are most sensitive to wanting menus and the like in their own languages.
    Then, hire a professional translation service that has expertise in the required
    languages to prepare the files. Test them well before you ship, as you would any
    other part of your software.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 创建默认属性文件通常不是问题，但为其他语言创建属性文件可能会是问题。除非您是一家大型跨国公司，否则可能没有资源（请原谅双关语）在内部创建资源文件。如果您正在发布商业软件或利用全球网络，您需要确定目标市场并了解其中哪些最关注希望以其语言显示菜单等内容。然后，聘请专业的翻译服务公司，该公司具有编制所需语言文件的专业知识。在发货前务必进行充分测试，就像您对软件的任何其他部分所做的那样。
- en: If you need special characters, multiline text, or other complex entry, remember
    that a `ResourceBundle` is also a `Properties` file, so see the documentation
    for `java.util.Properties`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要特殊字符、多行文本或其他复杂条目，请记住`ResourceBundle`也是`Properties`文件，因此请参阅`java.util.Properties`的文档。
- en: '3.14 Program: A Simple Text Formatter'
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.14 程序：一个简单的文本格式化程序
- en: 'This program is a primitive text formatter, representative of what people used
    on most computing platforms before the rise of standalone graphics-based word
    processors, laser printers, and, eventually, desktop publishing and office suites.
    It simply reads words from a file, previously created with a text editor, and
    outputs them until it reaches the right margin, when it calls `println()` to append
    a line ending. For example, here is an input file:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序是一个简单的文本格式化程序，代表了在大多数计算平台上在独立图形化字处理器、激光打印机，以及最终桌面出版和办公套件兴起之前人们所使用的程序。它简单地从先前用文本编辑器创建的文件中读取单词，并在达到右边距时输出这些单词，然后调用`println()`以添加行结束符。例如，这是一个输入文件：
- en: '[PRE49]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Given that file as the input, the `Fmt` program prints the lines formatted
    neatly:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 给定该文件作为输入，`Fmt`程序会将格式化后的行打印出来：
- en: '[PRE50]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'As you can see, it fits the text we gave it to the margin and discards all
    the line breaks present in the original. Here’s the code:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，它将我们提供的文本适应到边距，并且丢弃原始文本中的所有换行符。以下是代码：
- en: '[PRE51]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: A slightly fancier version of this program, `Fmt2`, is in the online source
    for this book. It uses *dot commands*—lines beginning with periods—to give limited
    control over the formatting. A family of dot-command formatters includes Unix’s
    *roff*, *nroff, troff*, and *groff*, which are in the same family with programs
    called *runoff* on Digital Equipment systems. The original for this is J. Saltzer’s
    *runoff*, which first appeared on Multics and from there made its way into various
    OSes. To save trees, I did not include `Fmt2` here; it subclasses `Fmt` and overrides
    the `format()` method to include additional functionality (the source code is
    in the full *javasrc* repository for the book).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的稍微花哨一点的版本，`Fmt2`，位于这本书的在线源代码中。它使用*dot commands*——以句点开头的行——来对格式进行有限控制。一系列点命令格式化程序包括Unix的*roff*，*nroff,
    troff*和*groff*，它们与Digital Equipment系统上称为*runoff*的程序处于同一系列中。这个的原始版本是J. Saltzer的*runoff*，它首先出现在Multics上，然后传入各种操作系统。为了节约树木，我没有在这里包含`Fmt2`；它是`Fmt`的子类，并重写了`format()`方法以包含附加功能（源代码在本书的完整*javasrc*代码库中）。
- en: '3.15 Program: Soundex Name Comparisons'
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.15 程序：Soundex姓名比较
- en: 'The difficulties in comparing American-style names inspired the US Census Bureau
    to develop the Soundex algorithm in the early 1900s. Each of a given set of consonants
    maps to a particular number, the effect being to map similar-sounding names together,
    on the grounds that in those days many people were illiterate and could not spell
    their family names consistently. But it is still useful today, for example, in
    a company-wide telephone book application. The names Darwin and Derwin map to
    D650, and Darwent maps to D653, which puts it adjacent to D650\. All of these
    are believed to be historical variants of the same name. Suppose we needed to
    sort lines containing these names together: if we could output the Soundex numbers
    at the beginning of each line, this would be easy. Here is a simple demonstration
    of the `Soundex` class:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 比较美式姓名的困难启发了美国人口调查局在20世纪初开发了Soundex算法。给定一组辅音，每个辅音都映射到一个特定的数字，其效果是将发音相似的姓名归为一类，因为在那个年代许多人不识字，无法一致拼写他们的姓氏。但是即使今天，例如在公司范围内的电话簿应用中，它仍然很有用。姓名Darwin和Derwin映射为D650，而Darwent映射为D653，这使得它邻近D650。所有这些都被认为是相同姓名的历史变体。假设我们需要将包含这些姓名的行进行排序：如果我们可以在每行开头输出Soundex号码，这将很容易。以下是`Soundex`类的简单演示：
- en: '[PRE52]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Let’s run it:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来运行它：
- en: '[PRE53]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As you can see, the Darwin-variant names (including Daemon Derwin^([6](ch03.html#idm45290687591464)))
    all sort together and are distinct from the Davidson (and Davis, Davies, etc.)
    names that normally appear between Darwin and Derwin when using a simple alphabetic
    sort. The Soundex algorithm has done its work.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，Darwin-variant姓名（包括Daemon Derwin^([6](ch03.html#idm45290687591464)））都被一起排序，并且与Davidson（以及Davis，Davies等）的姓名在简单字母排序时出现在Darwin和Derwin之间的姓名是不同的。Soundex算法已经完成了它的工作。
- en: 'Here is the `Soundex` class itself—it uses `String`s and `StringBuilder`s to
    convert names into Soundex codes:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`Soundex`类本身——它使用`String`和`StringBuilder`将姓名转换为Soundex代码：
- en: '*main/src/main/java/strings/Soundex.java*'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '*main/src/main/java/strings/Soundex.java*'
- en: '[PRE54]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: There are apparently some nuances of the full Soundex algorithm that are not
    implemented by this application. A more complete test using JUnit (see [Recipe
    1.10](ch01.html#javacook-getstarted-junit)) is also online as *SoundexTest.java*,
    in the *src/tests/java/strings* directory. The dedicated reader may use this to
    provoke failures of such nuances and send a pull request with updated versions
    of the test and the code.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这个应用程序没有实现完整的Soundex算法的一些细微差别。使用JUnit进行更完整的测试（参见[Recipe 1.10](ch01.html#javacook-getstarted-junit)）也可以在线进行，名为*SoundexTest.java*，位于*src/tests/java/strings*目录中。热心的读者可以使用此来引发这些细微差别的失败，并发送拉取请求，更新测试和代码的版本。
- en: See Also
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The Levenshtein string edit distance algorithm can be used for doing approximate
    string comparisons in a different fashion. You can find this in [Apache Commons
    StringUtils](http://commons.apache.org/proper/commons-lang). I show a non-Java
    (Perl) implementation of this algorithm in [Recipe 18.5](ch18.html#javacook-otherlang-SECT-4).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: Levenshtein字符串编辑距离算法可以用于以不同方式进行近似字符串比较。你可以在[Apache Commons StringUtils](http://commons.apache.org/proper/commons-lang)中找到这个算法。我展示了这个算法的非Java（Perl）实现，在[Recipe
    18.5](ch18.html#javacook-otherlang-SECT-4)中可以找到。
- en: ^([1](ch03.html#idm45290704847128-marker)) The two `.equals()` calls are equivalent
    with the exception that the first can throw a `NullPointerException` while the
    second cannot.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch03.html#idm45290704847128-marker)) 这两个`.equals()`调用在**除了第一个可能会抛出`NullPointerException`之外**是等价的。
- en: ^([2](ch03.html#idm45290704715928-marker)) `StringBuilder` was added in Java
    5\. It is functionally equivalent to the older `StringBuffer`. We will delve into
    the details in [Recipe 3.2](#javacook-strings-SECT-3).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch03.html#idm45290704715928-marker)) `StringBuilder` 是在 Java 5 中添加的。它在功能上等同于旧版的
    `StringBuffer`。我们将在 [Recipe 3.2](#javacook-strings-SECT-3) 中详细讨论细节。
- en: ^([3](ch03.html#idm45290704071000-marker)) Unless, perhaps, you’re as slow at
    updating personal records as I am.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch03.html#idm45290704071000-marker)) 除非，也许，你更新个人记录的速度和我一样慢。
- en: ^([4](ch03.html#idm45290703693768-marker)) `String` and `StringBuilder` have
    several methods that are forced to be identical by their implementation of the
    `CharSequence` interface.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch03.html#idm45290703693768-marker)) `String` 和 `StringBuilder` 在它们实现的
    `CharSequence` 接口中有几个强制相同的方法。
- en: ^([5](ch03.html#idm45290702287384-marker)) Indeed, there are so many characters
    in Unicode that a fad has emerged of displaying your name upside down using characters
    that approximate upside-down versions of the Latin alphabet. Do a web search for
    “upside-down Unicode.”
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch03.html#idm45290702287384-marker)) 实际上，Unicode 中有如此多的字符，以至于出现了一种潮流，使用近似拉丁字母的倒置版本字符显示你的名字倒置。在网络上搜索“倒置
    Unicode”即可了解更多。
- en: ^([6](ch03.html#idm45290687591464-marker)) In Unix terminology, a daemon is
    a server. The old English word has nothing to do with satanic demons but refers
    to a helper or assistant. Derwin Daemon was actually a character in Susannah Coleman’s
    *Source Wars* online comic strip, which long ago was online at a now-departed
    site called *darby.daemonnews.org*.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch03.html#idm45290687591464-marker)) 在 Unix 术语中，守护进程（daemon）是一个服务器。这个古老的英文单词与撒旦的恶魔无关，而是指一个帮助者或助手。Derwin
    Daemon 实际上是 Susannah Coleman 的 *Source Wars* 在线漫画中的一个角色，很久以前曾经在一个现在已经关闭的网站 *darby.daemonnews.org*
    上在线。
