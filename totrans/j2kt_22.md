# 第二十二章。从类到函数

> 面向对象的程序员擅长通过创建类型来解决问题。而函数式程序员则倾向于使用函数来增强现有类型。在不定义新类型的情况下，我们能走多远呢？

在 第十五章，《封装集合到类型别名》 中，我们看到使用原始集合的优势，在 第十六章，《接口到函数》 中，我们探讨了使用内置函数类型而不是创建新类型。在本章中，我们将应用我们学到的经验，从头开始编写一些 Kotlin 代码。

即使在如今的 REST API 和 Webhooks 的时代，许多自动化的企业间通信仍然以通过安全文件传输协议（SFTP）交换的表格式文本数据形式存在。Travelator 必须导入关于营地位置、景点、未解决的账单等数据，这些数据通常以常规的行和列形式存在，使用不同的列分隔符，并且有时候有表头来命名其余的行。在 第二十章 中，我们看到一个团队已经创建了自己的解析器；在其他地方，我们使用了备受信赖的 [Apache Commons CSV 库](https://oreil.ly/jnI4h)。老实说，对于大多数情况，我们仍然会使用 Commons CSV，因为它可以直接使用，对特殊情况进行了很好的配置，并且与 Kotlin 非常兼容。

今天我们要看看一个干净的 Kotlin 解析器会是什么样子。完成后，我们将比较我们的成果与 Commons CSV 的功能，以便看到 Java 和 Kotlin 的差异 API 和实现。

# 一个验收测试

正如你可能从前面的章节中看到的那样，Travelator 的开发人员是极限编程者（*《极限编程解密：拥抱变化》*）。我们先编写测试，从高级别的验收测试开始。我们正在处理一个表格阅读器，因此我们创建了一个名为 `TableReaderAcceptanceTests` 的类，并添加了一个存根方法，然后检查它是否运行：

```java
class TableReaderAcceptanceTests {
    @Test
    fun test() {
    }
}
```

[示例 22.1 [table-reader.1:src/test/java/travelator/tablereader/TableReaderAcceptanceTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.1&show=file) [(差异)](https://java-to-kotlin.dev/code.html?ref=22.1&show=diff)

它确实运行了（甚至通过了测试！），现在我们可以开始编写真正的代码了。

验收测试的一部分工作是帮助我们决定接口应该是什么样子。在解析了一些文件后，我们知道我们几乎总是希望做的事情是读取文件并返回某种域类型的值列表，每个（非表头）行一个。让我们将其草拟为我们的测试，以 `Measurement` 作为我们的域类型：

```java
class TableReaderAcceptanceTests {
    data class Measurement(
        val t: Double,
        val x: Double,
        val y: Double,
    )

    @Test
    fun `acceptance test`() {
        val input = listOf(
            "time,x,y",
            "0.0,  1,  1",
            "0.1,1.1,1.2",
            "0.2,1.2,1.4",
        )
        val expected = listOf(
            Measurement(0.0, 1.0, 1.0),
            Measurement(0.1, 1.1, 1.2),
            Measurement(0.2, 1.2, 1.4)
        )
        assertEquals(
            expected,
            someFunction(input)
        )
    }

    private fun someFunction(input: List<String>): List<Measurement> {
        TODO("Not yet implemented")
    }
}
```

[示例 22.2 [table-reader.2:src/test/java/travelator/tablereader/TableReaderAcceptanceTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.2&show=file) [(差异)](https://java-to-kotlin.dev/code.html?ref=22.2&show=diff)

这里的`Measurement`是一个值类型，代表我们要从每行表中提取的数据。在 Java 中，我们可能会从创建`TableReader`类开始，但是从测试中我们可以看出，读取表只是一个计算：将输入行映射到我们想要的数据列表（“Calculations”）。因此，我们将默认使用顶层的`someFunction`，直到我们被迫做出更复杂的事情。

我们可以想象各种神奇的方式来实现我们的 API 如何执行`someFunction`，但是除非它对`Measurement`类型有特殊的了解（而库不了解*我们*的类型，这是反过来的错误方法），否则我们将不得不告诉它如何从行的某种表示映射到`Measurement`。

这是我们第二次使用单词*map*了。也许*map*是关键？（一个偶然的双关语。）如果`someFunction`看起来像这样会怎么样？

```java
private fun someFunction(input: List<String>): List<Measurement> =
    readTable(input) ![1](img/1.png)
        .map { record -> ![2](img/2.png) ![3](img/3.png)
        Measurement(
            record["time"].toDouble(), ![4](img/4.png)
            record["x"].toDouble(), ![4](img/4.png)
            record["y"].toDouble(), ![4](img/4.png)
        )
    }
```

[示例 22.3 [table-reader.3:src/test/java/travelator/tablereader/TableReaderAcceptanceTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.3&show=file) [(差异)](https://java-to-kotlin.dev/code.html?ref=22.3&show=diff)

![1](img/#co_introduction_CO49-1)

`readTable`是我们的表读取 API 入口点

![2](img/#co_introduction_CO49-2)

它返回一个具有`map`实现的东西。

![3](img/#co_introduction_CO49-3)

`record`是我们在表中表示一行的数据。

![4](img/#co_introduction_CO49-4)

我们可以通过字段名索引`record`，得到一个`String`，然后我们可以将其转换为其他类型。

这段代码无法编译，因为我们还没有实现`readTable`，但是如果我们在错误上按 Alt-Enter，IntelliJ 会为我们创建这个函数：

```java
private fun readTable(input: List<String>): Any {
    TODO("Not yet implemented")
}
```

[示例 22.4 [table-reader.3:src/test/java/travelator/tablereader/TableReaderAcceptanceTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.4&show=file) [(差异)](https://java-to-kotlin.dev/code.html?ref=22.4&show=diff)

我们还没有给 IntelliJ 足够的关于`readTable`返回类型的线索，所以它选择了`Any`，因此`someFunction`仍然无法编译通过。我们能返回什么类型来解决这个问题呢？如果我们从`readTable`返回一个`List`，那么`map`就是`List`的一个操作。如果这个`List`包含`Map<String, String>`，那么我们的`record`变量就会是`Map<String, String>`，这样我们就可以调用`record["time"]`等操作。唯一的问题是`Map.get`返回一个可空值。这已经足够接近了——在`someFunction`中，我们可以通过在`get`返回`null`时引发错误来处理它：

```java
private fun someFunction(input: List<String>): List<Measurement> =
    readTable(input).map { record ->
        Measurement(
            record["time"]?.toDoubleOrNull() ?: error("in time"),
            record["x"]?.toDoubleOrNull() ?: error("in x"),
            record["y"]?.toDoubleOrNull() ?: error("in y"),
        )
    }

fun readTable(input: List<String>): List<Map<String, String>> {
    TODO("Not yet implemented")
}
```

[示例 22.5 [table-reader.4:src/test/java/travelator/tablereader/TableReaderAcceptanceTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.5&show=file) [(差异)](https://java-to-kotlin.dev/code.html?ref=22.5&show=diff)

这编译通过了，尽管显然`TODO`未通过测试。（你可能会问为什么我们对错误采取这种鲁莽的态度，与我们的法医第二十一章相比。答案是这只是测试代码：`Map.get`的 API 正在迫使我们考虑在错误情况下该怎么做，而我们的测试选择抛出。）

我们戴上客户的帽子来编写验收测试，这些测试显示我们至少可以使用`readTable`函数的签名将行转换为`Measurement`列表。现在我们有了一个合理的 API，我们可以将`readTable`的定义移到*src/main/travelator/tablereader/table-reading.kt*中：

```java
fun readTable(input: List<String>): List<Map<String, String>> {
    TODO("Not yet implemented")
}
```

[示例 22.6 [table-reader.5:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.6&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=22.6&show=diff)

最后，在这个第一阶段中，我们可以内联`someFunction`以提供我们的验收测试：

```java
@Disabled
@Test
fun `acceptance test`() {
    val input = listOf(
        "time,x,y",
        "0.0,  1,  1",
        "0.1,1.1,1.2",
        "0.2,1.2,1.4",
    )
    val expected = listOf(
        Measurement(0.0, 1.0, 1.0),
        Measurement(0.1, 1.1, 1.2),
        Measurement(0.2, 1.2, 1.4)
    )
    assertEquals(
        expected,
        readTable(input).map { record ->
            Measurement(
                t = record["time"]?.toDoubleOrNull() ?: error("in time"),
                x = record["x"]?.toDoubleOrNull() ?: error("in x"),
                y = record["y"]?.toDoubleOrNull() ?: error("in y"),
            )
        }
    )
}
```

[示例 22.7 [table-reader.5:src/test/java/travelator/tablereader/TableReaderAcceptanceTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.7&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=22.7&show=diff)

请注意，我们已经禁用了这个测试，因为在让它运行之前还需要一些时间。对于验收测试来说这没问题。我们不指望很快通过它们，更多的是告诉我们何时完成。目前，它已经完成了它的工作，帮助我们勾画出一个简单的 API，现在我们可以实现它了。

在我们继续之前，让我们反思一下，我们成功定义了解析器的接口，而没有定义任何新的类型，而是使用了`String`的`List`和`Map`。通过使用标准类型，我们知道我们有丰富的 Kotlin API 来提供我们正在读取的`List`，并解释我们正在返回的`Map`的`List`。

# 单元测试

现在我们有了一个要实现的接口，我们可以停止验收测试并编写一个最小的单元测试。什么是最小的？我们喜欢从空白开始：如果我们读取一个空文件会发生什么？

```java
class TableReaderTests {
    @Test
    fun `empty list returns empty list`() {
        val input: List<String> = emptyList()
        val expectedResult: List<Map<String, String>> = emptyList()
        assertEquals(
            expectedResult,
            readTable(input)
        )
    }
}
```

[示例 22.8 [table-reader.6:src/test/java/travelator/tablereader/TableReaderTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.8&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=22.8&show=diff)

让`readTable`返回预设结果是通过的最简单方法：

```java
fun readTable(input: List<String>): List<Map<String, String>> {
    return emptyList()
}
```

[示例 22.9 [table-reader.7:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.9&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=22.9&show=diff)

这一步通过了。看起来可能微不足道，但是为了空输入编写一个测试总是一个好主意。我们的算法越复杂，它在这种情况下失败的可能性就越大。然而，总是返回空结果的解析器是不好的，所以让我们继续前进。遵循 TDD（*通过示例驱动开发*），我们首先需要添加一个失败的测试来给我们改变实现的理由。我们选择添加读取没有标题行但有一行数据的表格的情况。

为什么要这样做，而不是使用标题和一行数据呢？坦率地说，这只是我脑海中的第一件事；也许如果我们真的在这个时候一起工作，你会建议使用标题行。我们的选择让我们不得不决定如何命名列，并且我们决定使用它们的索引的 `String` 表示，第一列为 `"0"`，第二列为 `"1"`，以此类推；这感觉是我们生成 `String` 键的最简单方法：

```java
@Test
fun `empty list returns empty list`() {
    assertEquals(
        emptyList<Map<String, String>>(),
        readTable(emptyList())
    )
}

@Test
fun `one line of input with default field names`() {
    assertEquals(
        listOf(
            mapOf("0" to "field0", "1" to "field1")
        ),
        readTable(listOf(
            "field0,field1"
        ))
    )
}
```

[示例 22.10 [table-reader.8:src/test/java/travelator/tablereader/TableReaderTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.10&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=22.10&show=diff)

我们*可以*选择在没有标题行时使 `readTable` 返回 `<Map<Int, String>>`。如果你有空闲时间，这可能是一个值得探索的路径。

回到我们当前的困境，我们有一个失败的测试，我们可以聪明地处理，也可以快速解决。我们选择快速方式，通过再次硬编码结果直接使测试通过：

```java
fun readTable(lines: List<String>): List<Map<String, String>> {
    return if (lines.isEmpty())
        emptyList()
    else listOf(
        mapOf("0" to "field0", "1" to "field1")
    )
}
```

[示例 22.11 [table-reader.8:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.11&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=22.11&show=diff)

现在我们的测试通过了，我们可以通过注意到我们希望输出的每一行与输入的每一行对应来简化实现。`Iterable::map` 可以做到这一点，使我们可以移除 `if` 表达式：

```java
fun readTable(lines: List<String>): List<Map<String, String>> {
    return lines.map {
        mapOf("0" to "field0", "1" to "field1")
    }
}
```

[示例 22.12 [table-reader.9:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.12&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=22.12&show=diff)

这样继续通过测试，并且现在可以处理更多行（相同的数据）！但这只是一个过渡阶段，允许我们将 lambda 提取为一个函数：

```java
fun readTable(lines: List<String>): List<Map<String, String>> {
    return lines.map(::parseLine)
}

private fun parseLine(line: String) = mapOf("0" to "field0", "1" to "field1")
```

[示例 22.13 [table-reader.10:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.13&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=22.13&show=diff)

现在我们将通过将键值对分为 `keys` 和 `values` 来开始移除硬编码的值：

```java
private fun parseLine(line: String): Map<String, String> {
    val keys = listOf("0", "1")
    val values = listOf("field0", "field1")
    return keys.zip(values).toMap()
}
```

[示例 22.14 [table-reader.11:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.14&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=22.14&show=diff)

我们仍然在坚定地作弊，但是现在我们可以看到`keys`中的模式，并从`values`中生成这些：

```java
private fun parseLine(line: String): Map<String, String> {
    val values = listOf("field0", "field1")
    val keys = values.indices.map(Int::toString)
    return keys.zip(values).toMap()
}
```

[示例 22.15 [table-reader.12:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.15&show=file) [(差异)](https://java-to-kotlin.dev/code.html?ref=22.15&show=diff)

对于`values`，我们可以将行按逗号分割：

```java
private fun parseLine(line: String): Map<String, String> {
    val values = line.split(",")
    val keys = values.indices.map(Int::toString)
    return keys.zip(values).toMap()
}
```

[示例 22.16 [table-reader.13:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.16&show=file) [(差异)](https://java-to-kotlin.dev/code.html?ref=22.16&show=diff)

成功：我们已经移除了硬编码的键和值，测试仍然通过。因为我们在`readTable`中使用了`lines.map`，我们相信该函数对任意数量的行都有效，但最好有一个测试来确认这一点。

我们要做个笔记，因为有些东西让我们感到不安，我们想先看一下。如果你和作者一样老（或更年轻且有天赋），你可能已经对代码产生了直觉，当你看到那个`split`时，它可能会让你感到不安。如果我们试图分割一个空行会发生什么？实际上，当`readTable`读取到一个空行时应该返回什么？

讨论之后，我们得出结论，一个空行应该返回一个空的`Map`。这感觉很清晰，所以我们编写了一个测试来记录我们的决定并验证它是否有效：

```java
@Test
fun `empty line returns empty map`() {
    assertEquals(
        listOf(
            emptyMap<String, String>()
        ),
        readTable(listOf(
            ""
        ))
    )
}
```

[示例 22.17 [table-reader.14:src/test/java/travelator/tablereader/TableReaderTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.17&show=file) [(差异)](https://java-to-kotlin.dev/code.html?ref=22.17&show=diff)

啊哈！

```java
org.opentest4j.AssertionFailedError:
Expected :[{}]
Actual   :[{0=}]
```

在一番调查之后，我们发现在空`String`上调用`split`会返回一个单个空`String`的`List`。也许在其他情况下这是有道理的。也许是这样，但这混乱了我们的算法，所以我们不得不在`parseLine`中特别处理：

```java
private fun parseLine(line: String): Map<String, String> {
    val values = if (line.isEmpty()) emptyList() else line.split(",")
    val keys = values.indices.map(Int::toString)
    return keys.zip(values).toMap()
}
```

[示例 22.18 [table-reader.14:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.18&show=file) [(差异)](https://java-to-kotlin.dev/code.html?ref=22.18&show=diff)

这样测试通过了，但是让`parseLine`函数变得混乱了。所以我们将混乱的部分提取到了一个名为`splitFields`的函数中：

```java
private fun parseLine(line: String): Map<String, String> {
    val values = splitFields(line)
    val keys = values.indices.map(Int::toString)
    return keys.zip(values).toMap()
}

private fun splitFields(line: String): List<String> =
    if (line.isEmpty()) emptyList() else line.split(",")
```

[示例 22.19 [table-reader.15:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.19&show=file) [(差异)](https://java-to-kotlin.dev/code.html?ref=22.19&show=diff)

如果我们将`splitFields`作为扩展函数，并引入一个`separators`参数，我们就得到了我们真正想要`split`成为的函数：

```java
private fun parseLine(line: String): Map<String, String> {
    val values = line.splitFields(",")
    val keys = values.indices.map(Int::toString)
    return keys.zip(values).toMap()
}

private fun String.splitFields(separators: String): List<String> =
    if (isEmpty()) emptyList() else split(separators)
```

[示例 22.20 [table-reader.16:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.20&show=file) [(差异)](https://java-to-kotlin.dev/code.html?ref=22.20&show=diff)

到目前为止，我们已经使代码能够处理空输入和单行输入。如果我们编写了一个命令式解决方案，现在可能必须添加一个循环来处理更多输入，但 `map` 已经为我们做好了，因为它将始终返回与我们给它的一样多的项目。我们相信 `readTable` 应该适用于程序员已知的所有数字：0、1 和无穷大（好吧，好吧，不是实际的无穷大而是 2³¹ - 1）。

“信任但验证”他们说，所以我们添加了一个测试：

```java
@Test
fun `two lines of input with default field names`() {
    assertEquals(
        listOf(
            mapOf("0" to "row0field0", "1" to "row0field1"),
            mapOf("0" to "row1field0", "1" to "row1field1")
        ),
        readTable(listOf(
            "row0field0,row0field1",
            "row1field0,row1field1"
        ))
    )
}
```

[示例 22.21 [table-reader.17:src/test/java/travelator/tablereader/TableReaderTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.21&show=file) [(差异)](https://java-to-kotlin.dev/code.html?ref=22.21&show=diff)

它通过了，我们推断 `(0, 1, 2)` 接近于 `(0, 1, 2147483647)`，所以我们暂时完成了。这似乎是一个检查点，可以去喝杯新鲜咖啡，然后处理掉上一杯咖啡，继续工作了。

# 头部

准备好再次启动了吗？好的，头部行呢？

首先，我们的 API 应该如何知道要期望一个头部？我们可以在 `readTable` 中添加一个标志来告诉它我们的数据有一个头部，或者我们可以添加另一个函数。通常我们更喜欢为不同的功能添加不同的函数，所以让我们添加一个名为 `readTableWithHeader` 的函数。

与 `readTable` 一样，我们首先添加一个调用我们希望有的函数的测试：

```java
@Test
fun `takes headers from header line`() {
    assertEquals(
        listOf(
            mapOf("H0" to "field0", "H1" to "field1")
        ),
        readTableWithHeader(
            listOf(
                "H0,H1",
                "field0,field1"
            )
        )
    )
}
```

[示例 22.22 [table-reader.18:src/test/java/travelator/tablereader/TableReaderTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.22&show=file) [(差异)](https://java-to-kotlin.dev/code.html?ref=22.22&show=diff)

在 `readTableWithHeader` 上的编译错误上按 Alt-Enter，IntelliJ 将为我们创建它。然后我们现在可以命名参数并委托给我们的原始函数：

```java
fun readTableWithHeader(lines: List<String>): List<Map<String, String>> {
    return readTable(lines)
}

fun readTable(lines: List<String>): List<Map<String, String>> {
    return lines.map(::parseLine)
}
```

[示例 22.23 [table-reader.18:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.23&show=file) [(差异)](https://java-to-kotlin.dev/code.html?ref=22.23&show=diff)

这个编译了，但是测试失败了，正如我们所预料的：

```java
org.opentest4j.AssertionFailedError:
Expected :[{H0=field0, H1=field1}]
Actual   :[{0=H0, 1=H1}, {0=field0, 1=field1}]
```

要使测试通过，我们可以像以前一样硬编码结果，但这次我们将修改代码以为功能留出空间。当我们说 *留出空间* 时，我们的目标是编写当前代码（使用 `Int::toString` 字段名称）并且我们能够 *扩展* 而不是修改以支持新功能。然后，新功能将是一个添加 *而不是* 修改（[开闭原则](https://oreil.ly/MwO5l)）。

目前，字段名信息被深埋在 `parseLine` 中：

```java
private fun parseLine(line: String): Map<String, String> {
    val values = line.splitFields(",")
    val keys = values.indices.map(Int::toString)
    return keys.zip(values).toMap()
}
```

[示例 22.24 [table-reader.18:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.24&show=file) [(差异)](https://java-to-kotlin.dev/code.html?ref=22.24&show=diff)

我们将其从这里提取到一个我们可以使用头部行来提供的地方。

`Int::toString` 是我们从索引到键的当前映射。让我们准备通过引入一个名为 `headerProvider` 的变量来使其可配置：

```java
private fun parseLine(line: String): Map<String, String> {
    val values = line.splitFields(",")
    val headerProvider: (Int) -> String = Int::toString
    val keys = values.indices.map(headerProvider)
    return keys.zip(values).toMap()
}
```

[示例 22.25 [table-reader.19:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.25&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=22.25&show=diff)

尽管我们的测试仍然通过，但新的`takes headers from header line`仍然失败。我们真的不应该在测试失败时进行重构，因为每次运行测试时，我们都必须检查任何失败是否确实是我们期望的失败。所以我们暂时将其`@Disabled`，仅在重构完成的功能上运行测试。

在`headerProvider`行上“引入参数”，并将其命名为`headerProvider`，将允许我们支持不同的行为：

```java
private fun parseLine(
    line: String,
    headerProvider: (Int) -> String
): Map<String, String> {
    val values = line.splitFields(",")
    val keys = values.indices.map(headerProvider)
    return keys.zip(values).toMap()
}
```

[示例 22.26 [table-reader.20:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.26&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=22.26&show=diff)

不幸的是，IntelliJ 目前无法使此重构生效，导致`readTable`出现问题：

```java
fun readTableWithHeader(lines: List<String>): List<Map<String, String>> {
    return readTable(lines)
}

fun readTable(lines: List<String>): List<Map<String, String>> {
    return lines.map(::parseLine) ![1](img/1.png)
}
```

[示例 22.27 [table-reader.20:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.27&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=22.27&show=diff)

![1](img/#co_introduction_CO50-1)

我们之前可以在`parseLine`只有一个参数时使用函数引用。现在它需要两个参数，但`map`只能提供一个。

“在重构之前用 lambda 替换函数引用”现在本应使一切正常，但我们将失败前进，现在扩展 lambda 并将`Int::toString`添加为`headerProvider`来使编译通过：

```java
fun readTableWithHeader(lines: List<String>): List<Map<String, String>> {
    return readTable(lines)
}

fun readTable(lines: List<String>): List<Map<String, String>> {
    return lines.map { parseLine(it, Int::toString) }
}
```

[示例 22.28 [table-reader.21:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.28&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=22.28&show=diff)

所有测试仍然通过，所以我们相当自信我们没有破坏任何东西。

我们这样做的目的是让新的`readTableWithHeader`读取头行以创建`headerProvider`以传递给`parseLine`。坐在`readTableWithHeader`和`parseLine`之间的是我们旧的`readTable`调用，因此它也需要一个`headerProvider`参数，以便它可以中继该值。所以这又是“引入参数”（带“引入默认值”），这次在`Int::toString`中的`readTable`上：

```java
fun readTableWithHeader(lines: List<String>): List<Map<String, String>> {
    return readTable(lines)
}

fun readTable(
    lines: List<String>,
    headerProvider: KFunction1<Int, String> = Int::toString ![1](img/1.png)
): List<Map<String, String>> {
    return lines.map { parseLine(it, headerProvider) }
}
```

[示例 22.29 [table-reader.22:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.29&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=22.29&show=diff)

![1](img/#co_introduction_CO51-1)

不编译：`Unresolved reference: KFunction1`

很难说为什么 IntelliJ（写作时）有时在重构时使用函数类型，有时使用`KFunctionN`类型。如果能保持一致，或者至少生成编译的代码，那就太好了。我们将手动将`KFunction1`转换为`(Int) -> String`，对于这第二次失败的重构，我们有点怨念：

```java
fun readTableWithHeader(lines: List<String>): List<Map<String, String>> {
    return readTable(lines)
}

fun readTable(
    lines: List<String>,
    headerProvider: (Int) -> String = Int::toString
): List<Map<String, String>> {
    return lines.map { parseLine(it, headerProvider) }
}
```

[示例 22.30 [table-reader.23:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.30&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=22.30&show=diff)

正面的是，由于`headerProvider`参数有默认值，我们的测试保持不变，仍然通过。

现在我们可以解析标题行了；`readTableWithHeader`需要读取标题，创建一个`headerProvider`（一个`(Int) -> String`记住），然后委托给`readTable`。它需要将行拆分为标题（`Iterable.first()`）和其余部分（`Iterable.drop(1)`）。如果没有行，`Iterable.first`将失败，因此我们注意要添加一个针对此情况的测试。至于将标题行转换为`headerProvider`，我们假装有一个叫做`headerProviderFrom(String)`的函数可以做到：

```java
fun readTableWithHeader(lines: List<String>): List<Map<String, String>> {
    return readTable(
        lines.drop(1),
        headerProviderFrom(lines.first())
    )
}
```

[示例 22.31 [table-reader.24:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.31&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=22.31&show=diff)

在新函数的调用上按 Alt-Enter 允许我们创建它，得到：

```java
fun headerProviderFrom(header: String): (Int) -> String {
    TODO("Not yet implemented")
}
```

[示例 22.32 [table-reader.24:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.32&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=22.32&show=diff)

这是一个需要返回函数类型的函数。我们可以用一个 lambda 实现返回值，该 lambda 接受一个`Int`索引并返回一个`String`。我们需要返回的`String`是该索引处的标题字段。我们可以再次使用我们的`splitFields`：

```java
private fun headerProviderFrom(header: String): (Int) -> String {
    val headers = header.splitFields(",")
    return { index -> headers[index] }
}
```

[示例 22.33 [table-reader.25:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.33&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=22.33&show=diff)

我们注意到在 lambda 外部分割了`header`；否则，它将发生在表的每一行之后。我们的测试仍然通过，如果我们正确，之前禁用的`readTableWithHeader`的测试也会通过。让我们解禁它：

```java
@Test
fun `takes headers from header line`() {
    assertEquals(
        listOf(
            mapOf("H0" to "field0", "H1" to "field1")
        ),
        readTableWithHeader(
            listOf(
                "H0,H1",
                "field0,field1"
            )
        )
    )
}
```

[示例 22.34 [table-reader.26:src/test/java/travelator/tablereader/TableReaderTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.34&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=22.34&show=diff)

这通过了，万岁！我们准备宣布我们暂时完成了，直到我们看到待办事项清单，记得我们预测`readTableWithHeader`在空输入时应该失败。所以我们写了一个测试来断言所需的行为，即返回一个空的`List`：

```java
@Test
fun `readTableWithHeader on empty list returns empty list`() {
    assertEquals(
        emptyList<String>(),
        readTableWithHeader(
            emptyList()
        )
    )
}
```

[示例 22.35 [table-reader.26:src/test/java/travelator/tablereader/TableReaderTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.35&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=22.35&show=diff)

正如我们所料，这会因为在空的`List`上调用`lines.first()`而失败，抛出`java.util.NoSuchElementException: List is empty.`：

```java
fun readTableWithHeader(lines: List<String>): List<Map<String, String>> {
    return readTable(
        lines.drop(1),
        headerProviderFrom(lines.first())
    )
}
```

[示例 22.36 [table-reader.25:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.36&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=22.36&show=diff)

我们对未完成感到不满，但是我们的正确性使我们感到宽慰！最简单的修复方法是将函数拆分为两个定义，并使用`when`来选择它们之间的函数。这通过了所有的测试并清空了我们的待办事项列表。因此，这是我们的公共 API：

```java
fun readTableWithHeader(
    lines: List<String>
): List<Map<String, String>> =
    when {
        lines.isEmpty() -> emptyList()
        else -> readTable(
            lines.drop(1),
            headerProviderFrom(lines.first())
        )
    }

fun readTable(
    lines: List<String>,
    headerProvider: (Int) -> String = Int::toString
): List<Map<String, String>> =
    lines.map { parseLine(it, headerProvider) }
```

[示例 22.37 [table-reader.26:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.37&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=22.37&show=diff)

这很好。现在我们的客户可以选择是否使用标题行进行阅读。但是等等！看着代码，我们意识到，如果他们想要为`readTable`指定自己的字段名称，可以通过重写`readTable`中的默认`headerProvider`来实现这一点。我们免费提供了一个功能！让我们编写一个测试来演示它：

```java
@Test
fun `can specify header names when there is no header row`() {
    val headers = listOf("apple", "banana")
    assertEquals(
        listOf(
            mapOf(
                "apple" to "field0",
                "banana" to "field1",
            )
        ),
        readTable(
            listOf("field0,field1"),
            headers::get
        )
    )
}
```

[示例 22.38 [table-reader.27:src/test/java/travelator/tablereader/TableReaderTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.38&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=22.38&show=diff)

看看使用方法引用`headers::get`从`List<String>`转换为我们的标题提供者函数`(Int) -> String`是多么容易？这是查看集合的一种有趣方式。我们可以查看：

| 类型 | 作为函数类型 | 通过 |
| --- | --- | --- |
| `List<T>` | `(index: Int) -> T` | `List.get(index)` |
| `Set<T>` | `(item: T) -> Boolean` | `Set.contains(item)` |
| `Map<K, V>` | `(key: K) -> V?` | `Map.get(key)` |

如果我们能够将依赖表达为这些函数类型之一，那么我们的客户和我们的测试可以使用标准集合来提供实现。

现在我们已经实现了带标题的表格读取，我们可以尝试运行我们的验收测试。这是：

```java
@Disabled
@Test
fun `acceptance test`() {
    val input = listOf(
        "time,x,y",
        "0.0,  1,  1",
        "0.1,1.1,1.2",
        "0.2,1.2,1.4",
    )
    val expected = listOf(
        Measurement(0.0, 1.0, 1.0),
        Measurement(0.1, 1.1, 1.2),
        Measurement(0.2, 1.2, 1.4)
    )
    assertEquals(
        expected,
        readTable(input).map { record ->
            Measurement(
                t = record["time"]?.toDoubleOrNull() ?: error("in time"),
                x = record["x"]?.toDoubleOrNull() ?: error("in x"),
                y = record["y"]?.toDoubleOrNull() ?: error("in y"),
            )
        }
    )
}
```

[示例 22.39 [table-reader.26:src/test/java/travelator/tablereader/TableReaderAcceptanceTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.39&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=22.39&show=diff)

当我们编写测试时，我们认为我们将调用`readTable`函数，结果发现实际上调用的是`readTableWithHeader`，所以我们进行了更改并运行了测试：

```java
assertEquals(
    expected,
    readTableWithHeader(input).map { record ->
        Measurement(
            t = record["time"]?.toDoubleOrNull() ?: error("in time"),
            x = record["x"]?.toDoubleOrNull() ?: error("in x"),
            y = record["y"]?.toDoubleOrNull() ?: error("in y"),
        )
    }
```

[示例 22.40 [table-reader.27:src/test/java/travelator/tablereader/TableReaderAcceptanceTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.40&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=22.40&show=diff)

它通过了，我们迎来了一点多巴胺的满足感，检查了代码并休息一下喝咖啡。

# 不同的字段分隔符

喝完咖啡回来后，我们快速调查了 Travelator 中读取表格的不同位置。有趣的是，我们只有一个用例读取经典的“逗号”，“分隔”，“变量”（带引号），但有几个需要使用分号作为字段分隔符。看起来，一些法国 SQL Server 导出作业正在使用分号，然后将文件保存为 *.CSV* 扩展名；也许 *C* 代表分号？我们将在接下来解决读取这些内容，但尝试找到一个可以处理更复杂引号和转义规则的接口。为了增加灵活性，我们需要识别一个抽象，就像我们之前对 `headerProvider` 所做的那样。这里的抽象是什么？

查看代码，我们发现标题和正文解析都调用了 `splitFields`：

```java
private fun headerProviderFrom(header: String): (Int) -> String {
    val headers = header.splitFields(",")
    return { index -> headers[index] }
}

private fun parseLine(
    line: String,
    headerProvider: (Int) -> String
): Map<String, String> {
    val values = line.splitFields(",")
    val keys = values.indices.map(headerProvider)
    return keys.zip(values).toMap()
}

private fun String.splitFields(separators: String): List<String> =
    if (isEmpty()) emptyList() else split(separators)
```

[示例 22.41 [table-reader.28:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.41&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=22.41&show=diff)

既不是标题解析也不是正文解析真正想要依赖于分割应该如何发生的细节，因此让我们将其抽象为一个函数 `(String)` `-> List<String>`。为什么是这个签名而不只是将字符参数化？

这是一个有趣的问题，谢谢你问。向 `parseLine` 和 `headerProviderFrom` 引入 `separators` 参数，最终引入他们的调用者 `readTable` 和 `readTableWithHeader`，会是我们可以做的最简单的事情。然而，使用函数类型会给我们带来更多的灵活性，因为我们可以隐藏分割、引用和转义的所有细节在这个签名后面。在 Java 中，使用 lambda 之前，灵活性的好处并不值得引入和实现一个 SAM 接口的成本，至少在我们真正需要所有那些控制权之前是这样。在 Java 中，这种灵活性的好处并不值得引入和实现一个 SAM 接口的成本，至少在我们真正需要所有这些控制权之前是这样。在 Kotlin 中，从一开始就设计了函数类型作为语言的一部分，我们更容易使用它们。一旦我们需要参数化代码的一个方面，自然会问是否函数会比一个简单值提供更多的价值。

让我们从 `parseLine` 开始。为了提取当前的分割实现，我们可以选择 `line.splitFields(",")` 并选择“引入函数参数”，选择参数名称 `splitter`：

```java
fun readTable(
    lines: List<String>,
    headerProvider: (Int) -> String = Int::toString
): List<Map<String, String>> =
    lines.map {
        parseLine(it, headerProvider) { line -> ![1](img/1.png)
            line.splitFields(",")
        }
    }

...

private fun parseLine(
    line: String,
    headerProvider: (Int) -> String,
    splitter: (String) -> List<String>, ![2](img/2.png)
): Map<String, String> {
    val values = splitter(line)
    val keys = values.indices.map(headerProvider)
    return keys.zip(values).toMap()
}
```

[示例 22.42 [table-reader.29:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.42&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=22.42&show=diff)

![1](img/#co_introduction_CO52-1)

这个 lambda…

![2](img/#co_introduction_CO52-2)

…实现了分割器。

如果我们继续这个过程，将分隔符 lambda 提取到顶层将会使我们的生活变得更轻松，因此我们选择`readTable`中的 lambda，命名为`splitOnComma`并选择“引入变量”：

```java
fun readTable(
    lines: List<String>,
    headerProvider: (Int) -> String = Int::toString
): List<Map<String, String>> =
    lines.map {
        val splitOnComma: (String) -> List<String> = { line ->
            line.splitFields(",")
        }
        parseLine(it, headerProvider, splitOnComma)
    }
```

[示例 22.43 [table-reader.30:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.43&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=22.43&show=diff)

现在我们可以从函数中删除`val`并移到顶层。在撰写时，感觉应该有自动重构的工具，但目前还没有什么有效的方法：

```java
fun readTable(
    lines: List<String>,
    headerProvider: (Int) -> String = Int::toString
): List<Map<String, String>> =
    lines.map {
        parseLine(it, headerProvider, splitOnComma)
    }

val splitOnComma: (String) -> List<String> = { line ->
    line.splitFields(",")
}
```

[示例 22.44 [table-reader.31:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.44&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=22.44&show=diff)

现在`splitOnComma`是一个全局属性，我们可以方便地将其作为默认值使用。我们在`readTable`中选择对它的引用，然后选择“引入参数”，并使用“引入默认值”，命名新参数为`splitter`。结果如下：

```java
fun readTable(
    lines: List<String>,
    headerProvider: (Int) -> String = Int::toString,
    splitter: (String) -> List<String> = splitOnComma
): List<Map<String, String>> =
    lines.map {
        parseLine(it, headerProvider, splitter)
    }

val splitOnComma: (String) -> List<String> = { line ->
    line.splitFields(",")
}
```

[示例 22.45 [table-reader.32:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.45&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=22.45&show=diff)

由于有了默认值，我们无需更改任何客户端，并且测试继续通过。目前，`readTable`正在使用提供的`splitter`，但`headerProviderFrom`没有：

```java
private fun headerProviderFrom(header: String): (Int) -> String {
    val headers = header.splitFields(",")
    return { index -> headers[index] }
}
```

[示例 22.46 [table-reader.32:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.46&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=22.46&show=diff)

为`header.splitFields(...)`引入一个函数参数产生：

```java
fun readTableWithHeader(
    lines: List<String>
): List<Map<String, String>> =
    when {
        lines.isEmpty() -> emptyList()
        else -> readTable(
            lines.drop(1),
            headerProviderFrom(lines.first()) { header -> ![1](img/1.png)
                header.splitFields(",")
            }
        )
    }

...

val splitOnComma: (String) -> List<String> = { line ->
    line.splitFields(",")
}

private fun headerProviderFrom(
    header: String,
    splitter: (String) -> List<String> ![2](img/2.png)
): (Int) -> String {
    val headers = splitter(header)
    return { index -> headers[index] }
}
```

[示例 22.47 [table-reader.33:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.47&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=22.47&show=diff)

![1](img/#co_introduction_CO53-1)

这个 lambda…

![2](img/#co_introduction_CO53-2)

…实现了分隔符。

现在`readTableWithHeader`中的 lambda 与`splitOnComma`的代码相同，因此我们使用它：

```java
fun readTableWithHeader(
    lines: List<String>
): List<Map<String, String>> =
    when {
        lines.isEmpty() -> emptyList()
        else -> readTable(
            lines.drop(1),
            headerProviderFrom(lines.first(), splitOnComma)
        )
    }

...

val splitOnComma: (String) -> List<String> = { line ->
    line.splitFields(",")
}
```

[示例 22.48 [table-reader.34:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.48&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=22.48&show=diff)

你可以看到这里的模式。现在我们将`splitOnComma`引用提取为一个参数，再次使用默认值以避免破坏现有客户端：

```java
fun readTableWithHeader(
    lines: List<String>,
    splitter: (String) -> List<String> = splitOnComma
): List<Map<String, String>> =
    when {
        lines.isEmpty() -> emptyList()
        else -> readTable(
            lines.drop(1),
            headerProviderFrom(lines.first(), splitter)
        )
    }
```

[示例 22.49 [table-reader.35:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.49&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=22.49&show=diff)

最后，在`readTableWithHeader`中调用`readTable`时没有提供`splitter`，因此它将使用默认的`splitOnComma`。我们不希望如此，因此我们将参数传递下去。标题和正文应该使用相同的分隔符，所以我们将它从`readTableWithHeader`传递到内部的`readTable`：

```java
fun readTableWithHeader(
    lines: List<String>,
    splitter: (String) -> List<String> = splitOnComma
): List<Map<String, String>> =
    when {
        lines.isEmpty() -> emptyList()
        else -> readTable(
            lines.drop(1),
            headerProviderFrom(lines.first(), splitter),
            splitter ![1](img/1.png)
        )
    }

fun readTable(
    lines: List<String>,
    headerProvider: (Int) -> String = Int::toString,
    splitter: (String) -> List<String> = splitOnComma
): List<Map<String, String>> =
    lines.map {
        parseLine(it, headerProvider, splitter)
    }
```

[例子 22.50 [table-reader.36:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.50&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=22.50&show=diff)

![1](img/#co_introduction_CO54-1)

传递`splitter`。

一些测试驱动开发者可能会坚持先写一个失败的测试来展示最后一步的必要性。我们确实应该编写一个测试来演示使用分隔符的情况，但在此之前，让我们更方便地创建一个。这是`splitOnComma`：

```java
val splitOnComma: (String) -> List<String> = { line ->
    line.splitFields(",")
}
```

[例子 22.51 [table-reader.36:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.51&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=22.51&show=diff)

如果能够不必每次都定义一个 lambda 来创建分隔符，那就太好了。这样，我们的法国客户就可以使用`splitter = splitOn(";")`来调用`readTable`。`splitOn`函数将接收分隔符并返回一个`(String) -> List<String>`类型的函数值。我们可以尝试从当前的`splitOnComma` lambda 中提取这个函数，但重构工作很繁琐，所以我们直接定义这个函数并调用它：

```java
fun splitOn(
    separators: String
): (String) -> List<String> = { line: String ->
    line.splitFields(separators)
}

val splitOnComma: (String) -> List<String> = splitOn(",")
val splitOnTab: (String) -> List<String> = splitOn("\t")
```

[例子 22.52 [table-reader.37:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.52&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=22.52&show=diff)

我们还定义了一个`splitOnTab`，这样我们就可以在我们承诺要写的新测试中使用它：

```java
@Test
fun `can specify splitter`() {
    assertEquals(
        listOf(
            mapOf(
                "header1" to "field0",
                "header2" to "field1",
            )
        ),
        readTableWithHeader(
            listOf(
                "header1\theader2",
                "field0\tfield1"
            ),
            splitOnTab
        )
    )
}
```

[例子 22.53 [table-reader.38:src/test/java/travelator/tablereader/TableReaderTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.53&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=22.53&show=diff)

这一切顺利进行，给了我们安心和文档支持。让我们将其检入并在休息几分钟后回来看看情况。

# 序列

现在我们已经拥有了一个基本的表格解析器，而且除了标准 Kotlin 运行时中的类型之外，我们没有引入任何新类型。这在更功能化的方法中经常发生。Kotlin 的特点是利用标准库提供的丰富抽象，而 Java 程序更有可能定义新类型。正如我们在第六章和第十五章中看到的那样，这种差异的原因之一是 Kotlin 允许我们将集合视为值，这使它们比 Java 的可变对象更安全地可组合。我们能够定义一个接受和返回集合类型的 API，而不必担心别名问题。

值类型可能导致由可预测计算组成的 API，但它们可能会带来自己的问题。我们的天真 API 遇到了与我们在第二十章中看到的相同问题：它在加载到内存中的`List<String>`上运行，并且生成一个同样在内存中的`List<Map<String, String>>`。即使不考虑数据结构的成本，`readTable`的内存占用量是输入字节的两倍，这可能是 UTF-8 编码文件包含的数据的两倍大小。为了处理大文件，最好是按照序列而不是列表的方式工作，因为如果需要，序列可以在管道的每个阶段仅保留一个项目在内存中。

正如我们在第十三章中所看到的，我们可以非常容易地将`Sequence`转换为`List`，然后再转回（有些限制），因此我们可以通过委托给现有的`List` API 来实现`Sequence`函数。然而，这并不会减少我们的内存占用，所以我们将编写`Sequence`版本，并将`List`版本委托给它们。如果我们聪明的话，我们可以通过便捷的`List` API 进行测试，从而一举获得两套测试。

目前，`readTable`看起来像这样：

```java
fun readTable(
    lines: List<String>,
    headerProvider: (Int) -> String = Int::toString,
    splitter: (String) -> List<String> = splitOnComma
): List<Map<String, String>> =
    lines.map {
        parseLine(it, headerProvider, splitter)
    }
```

[示例 22.54 [table-reader.39:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.54&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=22.54&show=diff)

我们可以通过在管道的中间转换为和从`Sequence`尝试我们的计划：

```java
fun readTable(
    lines: List<String>,
    headerProvider: (Int) -> String = Int::toString,
    splitter: (String) -> List<String> = splitOnComma
): List<Map<String, String>> =
    lines
        .asSequence()
        .map {
            parseLine(it, headerProvider, splitter)
        }
        .toList()
```

[示例 22.55 [table-reader.40:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.55&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=22.55&show=diff)

这些测试都通过了，它们都通过这个函数汇聚，所以这很令人放心。现在我们可以将内部工作提取出来，以一个接受并返回`Sequence`的函数；这是根据“提取管道的一部分”的描述提取的一部分：

```java
fun readTable(
    lines: List<String>,
    headerProvider: (Int) -> String = Int::toString,
    splitter: (String) -> List<String> = splitOnComma
): List<Map<String, String>> =
    readTable(
        lines.asSequence(),
        headerProvider,
        splitter
    ).toList()

fun readTable(
    lines: Sequence<String>,
    headerProvider: (Int) -> String = Int::toString,
    splitter: (String) -> List<String> = splitOnComma
) = lines.map {
        parseLine(it, headerProvider, splitter)
    }
```

[示例 22.56 [table-reader.41:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.56&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=22.56&show=diff)

这给我们提供了一个`Sequence`版本的`readTable`，`List`版本调用它，并且`List`版本已经经过良好测试。现在轮到外部的`readTableWithHeader`。它看起来像这样：

```java
fun readTableWithHeader(
    lines: List<String>,
    splitter: (String) -> List<String> = splitOnComma
): List<Map<String, String>> =
    when {
        lines.isEmpty() -> emptyList()
        else -> readTable(
            lines.drop(1),
            headerProviderFrom(lines.first(), splitter),
            splitter
        )
    }
```

[示例 22.57 [table-reader.42:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.57&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=22.57&show=diff)

目前，`readTableWithHeader`正在委托给`List`版本的`readTable`。如果我们想生成一个`Sequence`版本（确实是这样），它应该调用`readTable`的`Sequence`版本，因此我们在这里内联调用以得到：

```java
fun readTableWithHeader(
    lines: List<String>,
    splitter: (String) -> List<String> = splitOnComma
): List<Map<String, String>> =
    when {
        lines.isEmpty() -> emptyList()
        else -> readTable(
            lines.drop(1).asSequence(),
            headerProviderFrom(lines.first(), splitter),
            splitter
        ).toList()
    }
```

[示例 22.58 [table-reader.43:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.58&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=22.58&show=diff)

现在，手动创建一个`linesAsSequence`作为变量，并将其用作`lines`的替代。这几乎可以工作：

```java
fun readTableWithHeader(
    lines: List<String>,
    splitter: (String) -> List<String> = splitOnComma
): List<Map<String, String>> {
    val linesAsSequence = lines.asSequence()
    return when {
        linesAsSequence.isEmpty() -> emptySequence() ![1](img/1.png)
        else -> {
            readTable(
                linesAsSequence.drop(1),
                headerProviderFrom(linesAsSequence.first(), splitter),
                splitter
            )
        }
    }.toList()
}
```

[示例 22.59 [table-reader.44:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.59&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=22.59&show=diff)

![1](img/#co_introduction_CO55-1)

编译失败是因为没有`Sequence<T>.isEmpty()`。

我们如何判断`Sequence`是否为空？`linesAsSequence.firstOrNull() == null`就可以：

```java
fun readTableWithHeader(
    lines: List<String>,
    splitter: (String) -> List<String> = splitOnComma
): List<Map<String, String>> {
    val linesAsSequence = lines.asSequence()
    return when {
        linesAsSequence.firstOrNull() == null -> emptySequence()
        else -> {
            readTable(
                linesAsSequence.drop(1),
                headerProviderFrom(linesAsSequence.first(), splitter),
                splitter
            )
        }
    }.toList()
}
```

[示例 22.60 [table-reader.45:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.60&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=22.60&show=diff)

这通过了测试，因此我们可以再次提取在`return`和`.toList()`之间的表达式作为我们正在寻找的函数。提取并整理后，我们有了`readTableWithHeader`的`Sequence`版本：

```java
fun readTableWithHeader(
    lines: List<String>,
    splitter: (String) -> List<String> = splitOnComma
): List<Map<String, String>> =
    readTableWithHeader(
        lines.asSequence(),
        splitter
    ).toList()

fun readTableWithHeader(
    lines: Sequence<String>,
    splitter: (String) -> List<String> = splitOnComma
) = when {
    lines.firstOrNull() == null -> emptySequence()
    else -> {
        readTable(
            lines.drop(1),
            headerProviderFrom(lines.first(), splitter),
            splitter
        )
    }
}
```

[示例 22.61 [table-reader.46:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.61&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=22.61&show=diff)

在这一点上，我们有`readTable`和`readTableWithHeader`的两个版本：每个都有一个`List`版本和一个`Sequence`版本。考虑到将`List`参数转换为`Sequence`，将`Sequence`结果转换为`List`是多么容易，也许`List`变体并没有起到多大作用？让我们把它们的定义移到测试中，因为我们没有任何生产用途。这样，测试可以使用它们保持简单，而生产代码则保持最小化。

因此，这是我们表解析器的整个公共接口：

```java
fun readTableWithHeader(
    lines: Sequence<String>,
    splitter: (String) -> List<String> = splitOnComma
): Sequence<Map<String, String>> =
    when {
        lines.firstOrNull() == null -> emptySequence()
        else -> readTable(
            lines.drop(1),
            headerProviderFrom(lines.first(), splitter),
            splitter
        )
    }

fun readTable(
    lines: Sequence<String>,
    headerProvider: (Int) -> String = Int::toString,
    splitter: (String) -> List<String> = splitOnComma
): Sequence<Map<String, String>> =
    lines.map {
        parseLine(it, headerProvider, splitter)
    }

val splitOnComma: (String) -> List<String> = splitOn(",")
val splitOnTab: (String) -> List<String> = splitOn("\t")

fun splitOn(
    separators: String
) = { line: String ->
    line.splitFields(separators)
}
```

[示例 22.62 [table-reader.47:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.62&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=22.62&show=diff)

这由三个实用函数支持：

```java
private fun headerProviderFrom(
    header: String,
    splitter: (String) -> List<String>
): (Int) -> String {
    val headers = splitter(header)
    return { index -> headers[index] }
}

private fun parseLine(
    line: String,
    headerProvider: (Int) -> String,
    splitter: (String) -> List<String>,
): Map<String, String> {
    val values = splitter(line)
    val keys = values.indices.map(headerProvider)
    return keys.zip(values).toMap()
}

// Necessary because String.split returns a list of an empty string
// when called on an empty string.
private fun String.splitFields(separators: String): List<String> =
    if (isEmpty()) emptyList() else split(separators)
```

[示例 22.63 [table-reader.47:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.63&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=22.63&show=diff)

当我们回顾代码时，我们意识到不清楚*为什么*我们需要`splitFields`，因此我们添加了注释。回顾时，我们通常更容易理解我们要返回的代码，而不是我们刚刚写的代码。除此之外，我们认为代码已经相当自解释了。有时我们对此会有误解。如果我们读这段代码时需要更多时间才能理解正在发生的事情，我们将利用这个机会添加更多注释，或者更好地重构以提升表达力。

# 从文件读取

这在抽象中似乎是一个很好的接口，但是当我们第一次愤怒地使用它时，我们遇到了一个障碍。让我们通过一个测试来说明问题。这调用了`readTableWithHeader`的`Sequence`版本：

```java
@Test
fun `read from reader`() {
    val fileContents = """
        H0,H1
        row0field0,row0field1
        row1field0,row1field1
    """.trimIndent()
    StringReader(fileContents).useLines { lines ->
        val result = readTableWithHeader(lines).toList()
        assertEquals(
            listOf(
                mapOf("H0" to "row0field0", "H1" to "row0field1"),
                mapOf("H0" to "row1field0", "H1" to "row1field1")
            ),
            result
        )
    }
}
```

[示例 22.64 [table-reader.48:src/test/java/travelator/tablereader/TableReaderTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.64&show=file) [(差异)](https://java-to-kotlin.dev/code.html?ref=22.64&show=diff)

你能看出为什么会失败吗？如果我们说它失败了，会出现`java.lang.IllegalState​Ex⁠ception: This sequence can be consumed only once.`吗？

是的，再次（“多次迭代”），`Sequence`让我们感到困扰，因为我们没有测试两种类型——可以和不可以两次消耗的输入：

```java
fun readTableWithHeader(
    lines: Sequence<String>,
    splitter: (String) -> List<String> = splitOnComma
): Sequence<Map<String, String>> =
    when {
        lines.firstOrNull() == null -> emptySequence()
        else -> readTable(
            lines.drop(1),
            headerProviderFrom(lines.first(), splitter),
            splitter
        )
    }
```

[示例 22.65 [table-reader.47:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.65&show=file) [(差异)](https://java-to-kotlin.dev/code.html?ref=22.65&show=diff)

因此，`lines.firstOrNull()`消耗了这个序列，当从`Reader`中读取时，我们不能简单地返回并重新开始以评估`lines.drop(1)`和`lines.first()`。我们所有的单元测试都是从所有文件行的`List`开始的；这些序列*可以*被再次消耗，因为它们保存在内存中。

要在文件中使用我们的`Sequence`接口，我们要么必须将所有数据加载到内存中，要么找到一种方法来获取`Sequence`的第一个和其余部分，而不必尝试两次读取它。鉴于我们专门引入了`Sequence`以避免一次性加载所有数据到内存中，我们选择了后者。那么我们所需要做的就是在不消耗`Sequence`的情况下检查它是否有任何项。你能看到吗？

啊，那是一个诡计问题。要检查，我们*必须*在`Sequence`上调用`iterator()`，这正是消耗它的东西。我们无法看到`Sequence`是否为空，然后稍后再次使用它。但有时在逻辑上，当我们无法单独执行我们想要的事情时，我们可以一起执行我们想要的事情和另一件事情。在这种情况下，我们不仅想要查看`Sequence`是否为空；我们还想将其拆分为其头部和尾部（如果它不为空）。我们可以通过使用这样一个函数来解构`Sequence`来实现更广泛的目标：

```java
fun <T> Sequence<T>.destruct()
    : Pair<T, Sequence<T>>? {
    val iterator = this.iterator()
    return when {
        iterator.hasNext() ->
            iterator.next() to iterator.asSequence()
        else -> null
    }
}
```

[示例 22.66 [table-reader.49:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.66&show=file) [(差异)](https://java-to-kotlin.dev/code.html?ref=22.66&show=diff)

如果`Sequence`为空，则此`destruct`返回`null`；否则，它返回头部和尾部的`Pair`（其中尾部可能是一个空的`Sequence`）。它消耗了原始（通过调用`iterator()`），但提供了一个新的`Sequence`来继续处理。我们可以使用它来重构当前的`readTableWithHeader`：

```java
fun readTableWithHeader(
    lines: Sequence<String>,
    splitter: (String) -> List<String> = splitOnComma
): Sequence<Map<String, String>> =
    when {
        lines.firstOrNull() == null -> emptySequence()
        else -> readTable(
            lines.drop(1),
            headerProviderFrom(lines.first(), splitter),
            splitter
        )
    }
```

[示例 22.67 [table-reader.48:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.67&show=file) [(差异)](https://java-to-kotlin.dev/code.html?ref=22.67&show=diff)

这绝对不是一个微不足道的重新排列，但我们可以将其转化为：

```java
fun readTableWithHeader(
    lines: Sequence<String>,
    splitter: (String) -> List<String> = splitOnComma
): Sequence<Map<String, String>> {
    val firstAndRest = lines.destruct()
    return when {
        firstAndRest == null -> emptySequence()
        else -> readTable(
            firstAndRest.second,
            headerProviderFrom(firstAndRest.first, splitter),
            splitter
        )
    }
}
```

[示例 22.68 [table-reader.49:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.68&show=file) [(差异)](https://java-to-kotlin.dev/code.html?ref=22.68&show=diff)

新形式通过所有测试，因为它不会多次消耗`lines`。如果感觉有点笨拙，我们可以结合`?.let`、解构和 Elvis 运算符，给出一个你可能接受的单一表达式。结果是这个公共 API：

```java
fun readTableWithHeader(
    lines: Sequence<String>,
    splitter: (String) -> List<String> = splitOnComma
): Sequence<Map<String, String>> =
    lines.destruct()?.let { (first, rest) ->
        readTable(
            rest,
            headerProviderFrom(first, splitter),
            splitter
        )
    } ?: emptySequence()

fun readTable(
    lines: Sequence<String>,
    headerProvider: (Int) -> String = Int::toString,
    splitter: (String) -> List<String> = splitOnComma
): Sequence<Map<String, String>> =
    lines.map {
        parseLine(it, headerProvider, splitter)
    }

val splitOnComma: (String) -> List<String> = splitOn(",")
val splitOnTab: (String) -> List<String> = splitOn("\t")

fun splitOn(
    separators: String
) = { line: String ->
    line.splitFields(separators)
}
```

[示例 22.69 [table-reader.50:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.69&show=file) [(差异)](https://java-to-kotlin.dev/code.html?ref=22.69&show=diff)

我们几乎完成了，我们保证。

现在 API 已经围绕两个函数结晶化，最后一步是利用这个机会使测试更具表现力：

```java
class TableReaderTests {
    @Test
    fun `empty input returns empty`() {
        checkReadTable(
            lines = emptyList(),
            shouldReturn = emptyList()
        )
    }

    @Test
    fun `one line of input with default field names`() {
        checkReadTable(
            lines = listOf("field0,field1"),
            shouldReturn = listOf(
                mapOf("0" to "field0", "1" to "field1")
            )
        )
    }

    ...
    @Test
    fun `can specify header names when there is no header row`() {
        val headers = listOf("apple", "banana")
        checkReadTable(
            lines = listOf("field0,field1"),
            withHeaderProvider = headers::get,
            shouldReturn = listOf(
                mapOf(
                    "apple" to "field0",
                    "banana" to "field1",
                )
            )
        )
    }

    @Test
    fun `readTableWithHeader takes headers from header line`() {
        checkReadTableWithHeader(
            lines = listOf(
                "H0,H1",
                "field0,field1"
            ),
            shouldReturn = listOf(
                mapOf("H0" to "field0", "H1" to "field1")
            )
        )
    }

    ...
}

private fun checkReadTable(
    lines: List<String>,
    withHeaderProvider: (Int) -> String = Int::toString,
    shouldReturn: List<Map<String, String>>,
) {
    assertEquals(
        shouldReturn,
        readTable(
            lines.asSequence().constrainOnce(),
            headerProvider = withHeaderProvider,
            splitter = splitOnComma
        ).toList()
    )
}

private fun checkReadTableWithHeader(
    lines: List<String>,
    withSplitter: (String) -> List<String> = splitOnComma,
    shouldReturn: List<Map<String, String>>,
) {
    assertEquals(
        shouldReturn,
        readTableWithHeader(
            lines.asSequence().constrainOnce(),
            splitter = withSplitter
        ).toList()
    )
}
```

[示例 22.70 [table-reader.52:src/test/java/travelator/tablereader/TableReaderTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.70&show=file) [(差异)](https://java-to-kotlin.dev/code.html?ref=22.70&show=diff)

这是一个重要的步骤。正如我们在第十七章中所看到的，找到我们测试中的模式，并在函数中表达它们（比如`checkReadTable`），既帮助测试的读者看到代码在做什么，也可以帮助我们找到测试覆盖中的空白。例如，当字段多于标题或反之时，我们的解析器的行为是什么？我们为了在测试驱动实现时获得快速反馈而编写的测试，如果返回实现并对其进行修改，可能不太可能有效地用于 API 沟通、问题发现或捕捉回归。如果我们将 TDD 作为设计技术使用，我们不能忘记确保最终的测试适合确定正确性、添加文档和防止回归。

# 与 Commons CSV 的比较

我们在本章开始时说，在大多数实际情况下，我们会选择 Apache Commons CSV 而不是自己编写解析器。在我们完成本章之前，让我们将我们的 API 与 Commons 的等效 API 进行比较。

表解析器最常见的用例是读取具有已知列的文件，并将每行转换为某些数据类。以下是我们如何使用我们的解析器来实现这一点：

```java
@Test
fun example() {
    reader.useLines { lines ->
        val measurements: Sequence<Measurement> =
            readTableWithHeader(lines, splitOnComma)
                .map { record ->
                    Measurement(
                        t = record["time"]?.toDoubleOrNull()
                            ?: error("in time"),
                        x = record["x"]?.toDoubleOrNull()
                            ?: error("in x"),
                        y = record["y"]?.toDoubleOrNull()
                            ?: error("in y"),
                    )
                }
        assertEquals(
            expected,
            measurements.toList()
        )
    }
}
```

[示例 22.71 [table-reader.53:src/test/java/travelator/tablereader/CsvExampleTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.71&show=file) [(差异)](https://java-to-kotlin.dev/code.html?ref=22.71&show=diff)

真实世界的代码可能需要更多的错误处理（我们可以在第二十一章中看到如何处理），但这展示了基本的用例。我们使用 Kotlin 的 `Reader.useLines` 扩展函数生成一个 `Sequence<String>`，然后我们的解析器将其转换为 `Sequence<Map<String, String>>`。我们可以对这些 `Map` 进行 `map` 操作，按字段名索引提取我们需要的数据并将其转换为我们实际想要的类型（`Measurement`）。这个设计并非偶然——这是我们在最开始做出的决策，尽管当时使用的是 `List` 而不是 `Sequence`。

下面是 Commons CSV 版本的代码：

```java
@Test
fun `commons csv`() {
    reader.use { reader ->
        val parser = CSVParser.parse(
            reader,
            CSVFormat.DEFAULT.withFirstRecordAsHeader()
        )
        val measurements: Sequence<Measurement> = parser
            .asSequence()
            .map { record ->
                Measurement(
                    t = record["time"]?.toDoubleOrNull()
                        ?: error("in time"),
                    x = record["x"]?.toDoubleOrNull()
                        ?: error("in x"),
                    y = record["y"]?.toDoubleOrNull()
                        ?: error("in y"),
                )
            }
        assertEquals(
            expected,
            measurements.toList()
        )
    }
}
```

[示例 22.72 [table-reader.53:src/test/java/travelator/tablereader/CsvExampleTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.72&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=22.72&show=diff)

它也有一个静态函数入口点，`CSVParser.parse`，它还接受关于表格格式的配置（在本例中为 `CSVFormat.DEFAULT.withFirstRecordAsHeader()`；在我们的例子中为 `splitOnComma`）。我们有两个函数来区分是否有标题的文件；Apache API 将这些函数合并到 `CSVFormat` 中。

Commons 的 `parse` 接受一个 `Reader`，而不是我们的 `Sequence<String>`。这使得它能够处理除换行符外的记录分隔符，并处理字段中间有换行符的情况，但会导致 `parse` 方法的泛滥。有多个变体接受 `Path`、`File`、`InputStream`、`String` 和 `URL`。开发者可能认为这些变体是必要的，因为 Java 对于这些类型的源和安全处理它们的支持很少。由 `parse` 静态方法返回的 `CSVParser` 具有大量代码来管理资源。我们的 API 将这些委托给 `Sequence` 的工作以及 Kotlin 生命周期函数如 `use` 和 `useLines`。

在处理行的问题上，你必须在代码示例中读懂它们之间的联系，但 `CSVParser` 实现了 `Iterable<CSVRecord>`。这是一个巧妙的设计选择，因为它允许 Java 开发者使用 `for` 循环遍历记录，并允许 Kotlin 开发者使用 `.asSequence` 将其转换为 `Sequence`。事实上，Kotlin 的易用性归功于 Kotlin 标准库的设计，该标准库建立在与 Apache 开发者同样利用的 `Iterable` 抽象之上。

接下来，两个示例中创建单个 `Measurement` 的代码看起来完全相同：

```java
.map { record ->
    Measurement(
        t = record["time"]?.toDoubleOrNull()
            ?: error("in time"),
        x = record["x"]?.toDoubleOrNull()
            ?: error("in x"),
        y = record["y"]?.toDoubleOrNull()
            ?: error("in y"),
    )
}
```

[示例 22.73 [table-reader.53:src/test/java/travelator/tablereader/CsvExampleTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.73&show=file) [(diff)](https://java-to-kotlin.dev/code.html?ref=22.73&show=diff)

尽管我们的解析器中 `record` 的类型是 `Map<String, String>`，但在 Commons 情况下是 `CSVRecord`。`CSVRecord` 有一个 `get(String)` 方法，这是 `record["time"]` 等的解决方法。它还有方法：`get(int)` 通过索引检索字段，我们可以使用 `Map.values.get(Int)`；`size()` 而不是 `Map.size()`；以及 `isSet(String)` 代替 `Map.hasKey(String)`。

基本上，`CSVRecord` 手工复制了 `Map` 接口，而不仅仅是*成为*一个 `Map`。为什么呢？因为正如我们在 第六章 讨论的那样，Java `Map` 接口是可变的，在从文件中读取字段的上下文中，变异毫无意义；变异显然不会写回到源中。在 Java 编程中，我们发现自己不得不创建新类型来解决问题，而在 Kotlin 中，我们可以用标准类型表达自己，然后享受 Kotlin API 的丰富性。

Commons CSV 库 Excels™️ 的一个优点是它提供了现成的解析器默认值。这些值在 `CSVFormat` 类中表示为常量。我们已经见过 `CSVFormat.DEFAULT`，但还有许多其他值，比如 `CSVFormat.EXCEL`。有了 `CSVFormat`，你可以像我们之前看到的那样将其传递给 `CSVParser.parse` 方法，或者直接使用它，例如 `CSVFormat.EXCEL.parse(reader)`。我们能否在不在 API 中定义新类型的情况下提供此功能？比如，使用 `splitOnComma` 就好像它是我们的配置：

```java
@Test
fun `configuration example`() {
    reader.use { reader ->
        val measurements = splitOnComma.readTableWithHeader(reader)
            .map { record ->
                Measurement(
                    t = record["time"]?.toDoubleOrNull()
                        ?: error("in time"),
                    x = record["x"]?.toDoubleOrNull()
                        ?: error("in x"),
                    y = record["y"]?.toDoubleOrNull()
                        ?: error("in y"),
                )
            }
        assertEquals(
            expected,
            measurements.toList()
        )
    }
}
```

[示例 22.74 [table-reader.54:src/test/java/travelator/tablereader/CsvExampleTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.74&show=file) [(差异)](https://java-to-kotlin.dev/code.html?ref=22.74&show=diff)

我们可以通过将 `splitOnComma.readTableWithHeader(reader)` 定义为函数类型的扩展函数来实现这一点：

```java
fun ((String) -> List<String>).readTableWithHeader(
    reader: StringReader
): Sequence<Map<String, String>> =
    readTableWithHeader(reader.buffered().lineSequence(), this)
```

[示例 22.75 [table-reader.54:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.75&show=file) [(差异)](https://java-to-kotlin.dev/code.html?ref=22.75&show=diff)

实际上，`CSVFormat` 表示了一整套策略，用于转义规则、空白行处理等，而不仅仅是如何分割一行。当我们的解析器增加了这些功能时，可能希望创建一个数据类来收集它们。在此之前，我们一直能够使用内置类型和 Kotlin 语言特性来取得进展。

Commons 接口提供了另一个有用的功能，而我们的接口却没有，这最终需要我们创建一个类型来实现。Commons CSV 有 `CSVParser.getHeaderNames` 来提供对头信息的访问。我们能否在不修改当前 API 或至少不需要更改客户端代码的情况下添加此功能？

对于许多输入，我们可以简单地在输出 `Sequence` 的第一个上调用 `Map.keys`，但如果表没有数据行，只有标题，这种方法就行不通了。要返回标题信息和解析记录，我们可以返回一个 `Pair<List<String>, Sequence<Map<String, String>>`，但这将强制我们当前的客户端丢弃一对中的第一个。相反，我们可以返回一个实现 `Sequence<Map<String, String>>` 且具有标题属性的 `Table` 类型。这样一来，我们所有现有的调用者都保持不变，但我们可以在需要时访问 `headers`：

```java
@Test
fun `Table contains headers`() {
    val result: Table = readTableWithHeader(
        listOf(
            "H0,H1",
            "field0,field1"
        ).asSequence()
    )
    assertEquals(
        listOf("H0", "H1"),
        result.headers
    )
}

@Test
fun `Table contains empty headers for empty input`() {
    assertEquals(
        emptyList<String>(),
        readTableWithHeader(emptySequence()).headers
    )
}
```

[示例 22.76 [table-reader.55:src/test/java/travelator/tablereader/TableReaderTests.kt]](https://java-to-kotlin.dev/code.html?ref=22.76&show=file) [(差异)](https://java-to-kotlin.dev/code.html?ref=22.76&show=diff)

我们会略过重构步骤，但这里是实现代码：

```java
class Table(
    val headers: List<String>,
    val records: Sequence<Map<String, String>>
) : Sequence<Map<String, String>> by records

fun readTableWithHeader(
    lines: Sequence<String>,
    splitter: (String) -> List<String> = splitOnComma
): Table =
    lines.destruct()?.let { (first, rest) ->
        tableOf(splitter, first, rest)
    } ?: Table(emptyList(), emptySequence())

private fun tableOf(
    splitter: (String) -> List<String>,
    first: String,
    rest: Sequence<String>
): Table {
    val headers = splitter(first)
    val sequence = readTable(
        lines = rest,
        headerProvider = headers::get,
        splitter = splitter
    )
    return Table(headers, sequence)
}
```

[示例 22.77 [table-reader.55:src/main/java/travelator/tablereader/table-reading.kt]](https://java-to-kotlin.dev/code.html?ref=22.77&show=file) [(差异)](https://java-to-kotlin.dev/code.html?ref=22.77&show=diff)

# 移动

在我们旅程的最后阶段，我们豁免了从头开始编写 Kotlin 而不是重构我们现有的 Java 的奢侈。即便如此，我们还是从测试开始，然后将测试数据复制到我们的实现中，并从那里进行重构。我们不能以这种方式编写所有的代码，但当我们的代码只是计算时，这确实效果很好，而且代码中计算的部分越多，我们的代码工作得就越好。

我们看到了在 第十五章，*封装集合到类型别名* 和 第十六章，*接口到函数* 中重复使用内置类型的强大，以及在 第十章，*函数到扩展函数* 中定义 API 作为扩展函数。在这个例子中，集合和函数类型很好地结合在一起，我们甚至设法在函数类型上定义了一个扩展函数！在 Java 中，如果我们需要定义新的类来封装可变集合，并且编写操作这些集合的方法，那么我们将 Kotlin 的不可变集合传递给我们的函数，并在这些集合类型上编写应用程序特定的扩展。如果我们需要在 Java 中定义接口，我们可以使用 Kotlin 的函数类型。

再次强调，并非所有问题都可以或应该这样解决，但作者们发现，虽然让 Java 朝这个方向弯曲是困难的，但 Kotlin 的特性结合起来积极鼓励这种风格。我们不应该在不定义新类型上纠缠不放，但也不应该一下子用一个新类解决每一个问题。
