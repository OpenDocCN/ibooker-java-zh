# 第三章  轻装上路

> 欲望旅行愉快者，必先轻装上路。
> 
> 圣埃克絮佩里

在上一章中，您构建了一个基于微服务的系统，并且我们还向您展示了从现有应用程序迁移的一些步骤。但是所有示例的挑战在于它们为了更易于理解而删除了复杂性。对于较小的示例来说可能很清晰的事情，但在实际的业务系统中变得具有挑战性。特别是，请考虑复杂的遗留系统。正如第一章概述的那样，多年来开发的技术和方法已经导致了今天用于开发现代企业系统的最佳实践和工具。仅仅因为我们的行业现在拥有了更广泛的工具箱，可以使用闪亮新东西来工作，并不意味着您应该总是使用它们。如果您考虑到这一点以及我们日益增长的框架、方法和技术的数量，那么一个问题变得更加紧迫：对于您的下一个系统，您应该使用什么工具和架构，以及您将如何在何处运行它们？在您做出决定之前，您需要对过去几年中出现的最突出的企业应用程序架构风格进行一些思考（三层架构、企业集成、面向服务架构、微服务和事件驱动架构）。

# 三层或分布式系统

企业 Java 世界主要由单片应用程序所主导。它们通常被设计为随服务器实例和群集功能扩展的单一执行单元。它们也经常被称为“三层系统”，以反映它们由三个主要部分组成：客户端用户界面、服务器端业务逻辑实现和服务器端数据持久性或集成层。服务器端部分被称为“单体”，因为它们被打包为单个大型可执行文件。对系统的任何更改通常都涉及构建和部署新版本。

###### 提示

了解更多关于构建微服务的信息，请参阅 [Sam Newman 的杰出著作 *Building Microservices*（O’Reilly）](https://oreil.ly/JZqsr)，目前已经推出第二版。

基于微服务的架构是开发单个应用程序的一种方法，将其作为一套小型服务的集合，每个服务在自己的进程中运行，并使用轻量级机制进行通信，通常是 HTTP 资源 API 或作为事件驱动架构（EDA）的一部分。这些服务围绕业务能力构建，并且可以通过完全自动化的部署机制独立部署。这些服务的集中管理最小化，它们可能是用不同的编程语言编写的，并且使用不同的数据存储技术。

单体架构和微服务风格之间的差异可以说是根本性的。同样的，非功能性需求也决定了采用哪种架构风格。最关键的需求源于极其灵活的扩展场景。作为一名经验丰富的开发者和架构师，您知道如何评估功能和非功能需求，以确定您具体项目的最佳选择。在本章中，我们将帮助您制定迁移策略和目标平台。您的旅程始于审视现代化的动机。让我们深入探讨一下普遍的现代化动机以及寻找机会的起点。

## 技术更新、现代化和转型

企业软件的开发旨在将业务价值转化为能够在非功能性和功能性需求内执行的代码。创造价值取决于我们快速交付应用程序的能力。不仅要提高质量，而且要快速响应变化，使企业能够应对市场上的新挑战或监管变化。而这些挑战是多方面的。首先，您通过云原生应用程序解决扩展挑战，以处理更大的交易量。新的业务案例还将要求您进一步分析数据，并可能通过人工智能（AI）和机器学习（ML）来解决。最后但同样重要的是，我们互联互通的世界从物联网（IoT）产生更多数据。从架构上看似乎是自然的进展，但实际上，不断变化的业务需求通过改变功能和非功能性需求来推动现代化和架构演进。

此外，您还会发现操作上的考虑在影响现代化需求方面起到了作用。例如，过期的维护合同或过时的技术可能促使技术更新。随着 Java 语言不断发展和缩短的发布周期，也会影响现代化决策。现代化可以发生在项目的任何层次，从执行环境（例如虚拟机到容器）到 Java 虚拟机（JVM 版本或供应商）、个别依赖项、外部接口和服务。

在这里，区分现代化的三个不同角度至关重要。虽然在现有流程和边界内进行的技术更新对软件项目来说是一个熟悉且早已建立的挑战，但现代化涉及的是另一种事物。通常与“数字化”一词搭配使用，“现代化”一词指的是采用新技术。它涉及使用新功能升级系统、平台和软件。可以是简单的将现有的纸质流程转变为使用新软件和硬件的数字流程，也可以是更复杂的任务，例如逐步淘汰现有基础设施并转移到云端。有时您会在讨论现代系统时听到“转型”。数字化转型意味着利用现代技术重新构想组织的流程、文化、人员和客户体验。它可能导致新的商业模型、收入流、政策和价值观。转型是一个对组织进行全面审视的镜头，专注于从根本上改变业务绩效。现代化被内嵌并成为软件开发人员和架构师需要导航的核心。

尽管您在现代化应用程序的首要步骤中有项目特定的原因，但必须记住，现代化本身并不对特定目标环境或技术有任何特定的要求。它是一组不断变化和增长的候选技术，使公司能够在其行业中竞争和成长。您可以在技术趋势报告（例如，[ThoughtWorks 技术雷达](https://oreil.ly/SWvEH)）或炒作周期（[Gartner 炒作周期](https://oreil.ly/JT4jE)）中找到其中一些。但正如您在第一章中看到的那样，持续创新的两个最强动力是速度和成本压力。现代化、云原生和基于微服务的架构都能解决这两个问题。

## The 6 Rs

现在您已经了解了应用现代化背后的动机，您希望确定现代化的一般方法，并为现有应用程序定义分类。这样做有助于您管理各种不同的应用程序，特别是在平台现代化项目中。与查看单个应用程序的细节不同，考虑传统企业 Java 应用程序的完整运行时架构。在这种情况下，您通常会识别出本地硬件，这些硬件通常是虚拟化的，并通过一组单独的实例提供给项目使用。鉴于很少有单个项目被视为没有任何集成系统的孤立岛屿，您需要找到一个协调的方法，来处理不止一个项目的情况。

让我们首先看看 6 个 R 是什么，以及这个概念的来源。基本上，您可以将每个“R”看作是应用程序可用的迁移策略。每种策略都表示转换后应用程序的明确结果，但不一定是实际的迁移步骤。这个概念最初由 Gartner 分析师 Richard Watson 在 2011 年提到。最初的五种策略——即重新主机化、重构、修改、重建和替换——在 2016 年由 AWS 的 Stephen Orban 在一篇流行的博客文章中进行了修订和适应。Orban 保留了一些 Gartner 的策略，并添加了一个新的策略。因此，5 个 R 变成了 6 个 R。今天，这 6 个 R 被用作几乎任何云转型的基本指南。尽管对是否应该添加更多策略仍然存在争议，甚至可以找到 7 个 R，但在本书中我们坚持使用 6 个 R，如图 3-1 所示。

![分类现有应用程序的六种方法](img/moej_0301.png)

###### 图 3-1。六种现代化方法，6 个 R 的概述

### 保留-稍后或根本不进行现代化

每个人都听过一个著名公司地下室里的大型机的刻板故事，那里存储了所有商业机密。这些大型机通常以 CICS（客户信息控制系统，一系列混合语言应用服务器，为 IBM 大型机系统上的在线事务管理和连接提供支持）编程，并且数据存储在 IMS（IBM 信息管理系统，一种早期的数据库）中。这并不一定是件坏事。也许现有系统非常适合业务，并且不需要参与现代化项目。为了正确确定转型和现代化工作的范围，您需要识别这些系统并将其排除在现代化进程之外。这类系统需要一种特定的集成方法，需要明确设计。想象一下，一个高度可扩展的移动应用后端直接连接到大型机上。在这种情况下，来自可能众多移动设备的请求会过载昂贵的大型机。在这种情况下，“保留”并不意味着“不动”，而是意味着“不迁移”。

### 关闭系统-关闭系统

有些候选人可能已经显然到达了生命周期的终点，已经迁移并替换，或者仅仅是一个未来不再需要的遗物。轻装前行，并确保标记这些系统。后续的清理工作与建设新事物同样重要。投入时间来验证并决定退役一个系统的价值，与重新设计同样宝贵。

### 重新购买-购买新版本

在某些情况下，您可以重新购买现成的软件并为其新的执行环境做好准备。这听起来很简单，但很可能需要包括迁移项目和重新评估功能列表，主要是因为您不太可能在不更改产品版本或其 API 的情况下进行更新。在一些罕见的情况下，您甚至可能会发现缺失的集成文档成为一个阻碍因素。这就是为什么将其视为现代化项目而不是简单的软件更新至关重要的原因。

### 重新托管—放入容器中

通常称为“提升和迁移”的一种选项是将现有架构简单地移植到容器内运行。尽管这听起来很简单，但在实施过程中可能会遇到一些挑战。特别是在优化 JVM 以适应受限容器运行时时可能会遇到困难。一些现有的中间件应用服务器配备了供应商支持的基础镜像，使切换运行时变得更加便捷。对于有状态应用程序运行时，应重点关注存储。Java 应用服务器需要一些数据在容器重新启动时保留，并需要持久卷映射。事务、负载平衡和内存会话复制需要扩展配置以确保正确的关闭行为和节点通信。计划充分的研究和测试，并确保遵循供应商的建议。此步骤解决的是基础设施现代化问题，并不直接涉及应用程序代码。符合此方法的现有应用程序是那些需要在重构之前或在切换数据中心概念的中间步骤之前移至容器运行时的应用程序。

###### 注意

Martin Fowler 创造了术语[“strangler pattern”](https://oreil.ly/0otPb)，作为从单片应用中提取功能的一种方法。它以澳大利亚的勒死榕树为名，后者会从树枝上的种子生长根直至触及地面。

### 重新平台化—进行轻微调整

作为重新托管的延伸，重新平台化将经历概念或功能变化的应用程序分类为运行时切换。它也可以按照其“lift”名称变体，“提升和调整”进行引用。它可能与被勒死的功能相关联，后者可能在新技术堆栈上实现，或者在数据存储或集成系统中进行更改。我们建议将此方法用作重构和解耦合单片应用程序的初始步骤。在以下扩展和解耦合阶段执行时，通过在此步骤前加入重新平台化，可以实现更顺畅的操作。选择重新平台化，您正在为现代化应用程序和务实演化提供温和的起始。

### 重构—建立新的

[重构](https://refactoring.com)是一种有纪律的技术，用于重构现有代码库，改变其内部结构而不改变其外部行为。重构是将现有应用程序迁移到新的运行时或平台上最耗时和昂贵的方式。它可能包括或不包括切换到不同的架构风格或本地或云主机。

# 分割和容器化

现在我们已经看过了现有应用程序的不同现代化策略，也知道如何何时应用它们。是时候考虑我们目标平台的其他先决条件了。

## Kubernetes 作为新的应用服务器？

“平台”一词在企业 Java 世界中通常指应用服务器。应用服务器遵循有保护栏的软件开发方法，具有标准化的 API。垂直层次由通常被称为三层系统技术层的内容定义。在顶部是业务，下面是数据访问和/或集成。水平地，我们通常会找到业务组件或领域。虽然垂直层通常是良好分离和解耦的，但在水平组件之间通常会发现共享类和违反的访问规则。如果这种情况在代码库中频繁发生，我们称之为纠缠设计，随着时间的推移会变成难以维护的单块。但无论应用代码多么纠缠，它仍从标准应用服务器功能中受益，这些功能包括安全性、隔离、容错、事务管理、配置管理等。

如果我们快进到今天的分布式架构，应用程序由许多小服务组成，我们会观察到两件事：没有捷径可以获得良好的组件设计，标准应用服务器功能不再适用于我们的组件。

第一个观察结果导致了一个强制性要求。分布式服务必须是设计良好、松耦合和强封装的组件。我们将在第五章更多地讨论现代化单块的设计原则和方法。第二个观察结果列出了云原生运行时中缺失的功能清单。如果一个应用服务器不提供像我们提到的常用功能的支持，那么只剩下两个选择。一个可以是微服务框架的选择（例如 Quarkus），另一个可能是基于 Kubernetes 的附加框架或产品。

让我们在接下来的章节中详细查看一些最关键的功能需求。我们称它们为*微服务能力*。这个术语指的是除了业务逻辑外，一个服务必须实现的一系列横切关注点，以解决这些问题，如图 3-2 所总结的。

![分布式应用程序的微服务化](img/moej_0302.png)

###### 图 3-2。分布式应用程序的微服务化

### 发现和配置

容器镜像是不可变的。在其内部存储不同环境或阶段的配置选项是不被鼓励的。相反，配置必须被外部化并通过实例进行配置。外部化配置也是云原生应用程序的关键原则之一。服务发现是从运行时环境获取配置信息的一种方式，而不是硬编码在应用程序中。其他方法包括使用 ConfigMaps 和 Secrets。Kubernetes 提供开箱即用的服务发现，但这可能不足以满足您的应用程序需求。虽然您可以通过 YAML 文件管理每个运行时环境的环境设置，但额外的用户界面或命令行界面可以使 DevOps 团队更轻松地共享责任。

### 基本调用

在容器内运行的应用程序通过 Ingress 控制器访问。Ingress 公开从集群外部到集群内部服务的 HTTP 和 HTTPS 路由。流量路由由在 Ingress 资源上定义的规则控制。传统上，这可以与基于 Apache HTTP 的负载均衡器进行比较。其他替代方案包括像 [HAProxy](http://www.haproxy.org) 或 Nginx 的项目。您可以利用路由能力来进行滚动部署，作为复杂 CI/CD 策略的基础。对于像批处理这样的一次性作业，Kubernetes 提供了作业和定时作业功能。

### 弹性

Kubernetes 的 ReplicaSets 控制 pod 的扩展。这是一种协调期望状态的方式：你告诉 Kubernetes 系统应该处于什么状态，以便它能够确定如何达到预期结果。ReplicaSet 控制容器的副本数量，即任何时候应该运行的确切副本或拷贝数量。听起来像是一个大部分静态操作的东西可以被自动化。水平 Pod 自动缩放器基于观察到的 CPU 利用率来调整 pod 数量。可以使用自定义指标或几乎任何其他由应用程序提供的指标作为输入。

### 日志

分布式应用程序中较具挑战性的一个方面是每个活动部分日志的相关性。这是一个区别于传统应用服务器非常显著的领域，因为过去它非常简单，而在新世界中并非如此。不建议单独存储每个容器的日志，因为这样会失去整体视野，难以调试副作用和问题的根本原因。有各种方法处理这个问题，其中大多数都广泛使用[ELK](https://oreil.ly/XflXI)（[Elasticsearch](https://oreil.ly/FKoKx)、[Logstash](https://oreil.ly/YLtNc)、[Kibana](https://oreil.ly/h2nIX)）堆栈或其变体。在这些堆栈中，Elasticsearch 是对象存储，存储所有日志。Logstash 收集来自节点的日志并将其提供给 Elasticsearch。Kibana 是 Elasticsearch 的 Web UI，用于搜索来自各种来源的聚合日志文件。

### 监控

在分布式应用程序中，监控是确保所有部分持续工作的重要组成部分。与日志记录相比，监控是主动观察，通常与警报配对，而不仅仅是记录事件。[Prometheus](https://prometheus.io) 是存储生成信息的事实标准。它实质上是一个完整的开源监控系统，包括时间序列数据库。Prometheus 的 Web UI 允许您访问指标查询、警报和可视化，帮助您深入了解系统。

### 构建和部署管道

CI/CD（持续集成/持续交付）对于企业 Java 应用程序或分布式应用程序并不新鲜。作为良好的软件开发实践，每个生产代码都应遵循严格的自动化发布周期。由于一个应用可能包含大量服务，自动化至少应该达到 100% 的覆盖率。传统上由开源工具[Jenkins](https://www.jenkins.io)处理这些工作，现代容器平台已经摒弃了集中式构建系统，转向了分布式 CI/CD 的方法。一个例子是[Tekton](https://tekton.dev)。其目标是通过构建、测试和部署创建可靠的软件发布。我们在第四章深入探讨了这一点。

### 韧性和容错性

心理学家将“韧性”定义为在逆境、创伤、悲剧、威胁或重大压力来源面前适应良好的过程。在分布式应用程序中，这意味着在没有人为干预的情况下从失败或负载场景中恢复。Kubernetes 为集群本身提供了韧性选项，但只零星支持应用程序的韧性和容错性。例如，可以通过支持复制卷的 PersistentVolumes 或确保集群中的 Pod 副本数量一致的 ReplicaSets 来促进应用程序级的韧性。在应用程序级别，可以通过 Istio 或像 [Cloudstate](https://cloudstate.io) 这样的各种框架来支持韧性和容错性。你可能会使用诸如重试规则、断路器和池摘除等功能。

###### 注意

[Istio](https://istio.io) 是一个开源的服务网格，可透明地叠加到现有的分布式应用程序上。它还是一个平台，包括集成到任何日志平台、遥测或策略系统的 API。

### 安全

Kubernetes 本身不包括服务之间的身份验证或授权。有两种实现方式。使用 Istio，每个服务都提供了一个强身份，代表其角色，并支持跨集群和云的互操作性。它保护了服务与服务之间的通信，并提供了一个关键管理来自动化密钥和证书的生成、分发、旋转和吊销。一个更加应用程序中心的替代方案是使用类似 [Keycloak](https://www.keycloak.org) 这样的单点登录组件，或依赖于 [Eclipse MicroProfile JSON Web Token](https://oreil.ly/bVETR) (JWT)。

### 追踪

追踪为你提供了一种通过追踪回到起源的方式跟踪系统中的请求路径和事件，跨越个别应用程序部分。今天，你可以在社区中找到不同的方法。与你打算使用的语言、框架或技术无关，Istio 可以实现分布式追踪。还有其他商业和开源项目可用于帮助跨应用程序组件进行分布式追踪。[Zipkin](https://zipkin.io) 和 [Jaeger](https://www.jaegertracing.io) 是两种可能的解决方案。

## 定义目标平台

需要注意的是，前面提到的九个元素侧重于应用程序开发，并没有涵盖现代容器平台的所有必需品。仅仅看这个狭隘的焦点会忽略重要的领域。容器平台需要为从开发到运维的完整团队提供功能和能力。根据具体需求，没有一种一刀切的解决方案。定义目标平台的综合方法是从核心、客户体验和集成三个主要层面开始，然后在优化的技术栈上构建应用程序景观。听起来像一个可直接使用的检查表，但实际上并非如此。公司在文化、技术和需求方面各不相同，以下列表仅作为建议的起点，没有宣称全面性。我们建议将项目作为评估类别使用，并定义个别功能和非功能需求，根据从零（不可用）到三（完全支持）的满足评分，中间得分为二（可行），作为中等评估。最后，根据产品比较添加加权逻辑以达到完整评估。它可以作为直接产品与自主实施（DIY）比较的核心框架，并且也是平台文档的起点。

### 定义核心部分

从评估平台的核心部分开始。此类别包括基本功能，如容器编排，存储映射，滚动升级，站点可靠性工程（SRE）要求，对所需部署模型的开箱即用支持，甚至可能包括对虚拟机的进一步支持。这一类别代表了目标平台的技术基础：

+   现有的核心能力

+   功能差距评估

+   混合云支持

+   安全集成

+   管理服务支持

+   可用的运营商/市场（例如，[OperatorHub](https://operatorhub.io)，[Red Hat Marketplace](https://oreil.ly/sFuDg)）

+   可用的支持级别

+   目标部署模型

+   核心现代化方法

### 定义客户体验层

在考虑平台时，有一个部分得到了太少的关注：客户体验层，其中包含对平台客户通道的技术定义。通道可以是 B2X（业务到某些东西）门户或其他特定的前端。一个完整的平台可以托管各种应用程序，还需要包括对个别服务技术组成的清晰定义：

+   定义客户中心需求

+   评估现有的 CX 框架与构建之间的差异

+   微前端（例如，[Entando](https://dev.entando.org)）

+   集成需求

+   数据差距分析

+   移动支持

### 定义集成

在容器化的世界中，集成成为一个新的挑战。从传统的企业景观出发，集成通常是一个集中的解决方案（企业服务总线或类似的），或者是各个应用程序的一部分，使用类似 Apache Camel 的某些常见集成框架。这两种方法都不完全适合于无状态容器导向的平台。在目标平台中，您寻找的是消息组件、数据转换逻辑和服务集成之间的无缝集成。所有相关部分都需要在分布式系统的无状态环境中良好地扩展，并且应该可以轻松地通过新功能扩展组合的应用程序：

+   现有的集成能力

+   评估合作伙伴解决方案生态系统

+   定义集成需求（数据源、服务集成、消息传递、API）

+   定义标准和框架（例如，[骆驼 K](https://oreil.ly/kfXw1)）

+   评估无服务器/Knative 集成（例如 Camel K）

### 定义技术栈

剩余类别关注的是个别技术和框架。可以将其视为定义生产环境中相关技术、服务和方法论的蓝图存储库。在这一类别的需求中被低估的因素是组织中可用的开发技能。对于传统的企业 Java 背景来说，完全转向反应式开发方法和无状态应用设计并不容易。此外，熟悉现有 API 并在新平台上提高生产力所需的时间在选择最合适的技术栈时起着至关重要的作用：

+   在核心、CX 和外部服务方面进行技术栈评估

+   微服务框架（例如 Quarkus、Spring Boot）

+   实施建议（反应式，命令式，消息驱动等）

+   部署模型（IaaS，PaaS，混合）

+   定义目标开发平台

+   开发技能缺口分析

完成此评估后，您将为迁移到容器化应用平台做好充分准备。接下来，您需要制定并计划您的容器化策略。

# 强制性迁移步骤和工具

遵循的基本假设是您已经有了现有的应用程序景观，不能将所有事情都作为全新项目开始。回顾之前的六个 R，您首先要考虑的应用程序应该属于以下几种 R 中的一种：重新托管（Rehost）、重新平台化（Replatform）和重构（Refactor）（图 3-3）。尽管它们在描述上看起来相似，但这三种方法之间最重要的区别在于业务价值与迁移时间及成本之间的平衡。

![业务价值评估](img/moej_0303.png)

###### 图 3-3\. 工作负载迁移模式

开始现代化的具体步骤和起点取决于应用程序。尽管具体步骤可能会有所不同，但首先要确定正确的候选者。因此，我们需要分析现有应用程序，进行目录分类，并将其分组以分配给最终的迁移模式。最后一步是执行各个迁移项目。

## 创建应用程序组合

创建这样一个应用程序目录或者组合的方法有很多种。你很可能已经有了一种方式来选择与某个业务领域相关的应用程序。如果没有，可以直接跳转到第五章，我们在那里讨论了[Konveyor 项目](https://oreil.ly/1wPUF)。

# 准备迎接重大事务

现代化中最负盛名的过程是重构现有应用程序。为了覆盖将现有单体系统转换为微服务架构的成熟方法，我们推荐 Sam Newman 的[*Monolith to Microservices*](https://oreil.ly/0x6oq)（O’Reilly）。虽然他向你展示了许多不同的方法，并为各种情况创建了详细的流程，但也有更简单的方法，比如卡内基梅隆大学软件工程研究所的 Brent Frye 提出的方法。他推荐了八个简单的步骤来拆分单体系统。他专注于组件和组件组。*组件*是逻辑数据对象集合及系统对这些对象执行的操作。组件组成了他所称的*宏服务*。宏服务与微服务类似，但有两个主要区别。首先，宏服务可能与遗留的单体系统或其他宏服务共享数据存储。其次，与微服务不同，宏服务可能提供对多个数据对象的访问。在最后一步，宏服务进一步分解。

根据 Frye 拆分单体的逻辑步骤如下：

1.  确定逻辑组件。

1.  平铺并重构组件。

1.  确定组件依赖关系。

1.  确定组件组。

1.  为远程用户界面创建 API。

1.  迁移组件组到宏服务：

    1.  将组件组移动到单独的项目中。

    1.  进行独立部署。

1.  将宏服务迁移到微服务。

1.  重复步骤 6-7 直到完成。

这也是 Chris Richardson 的更一般性建议。正如他在他的[O’Reilly SACON 伦敦主题演讲](https://oreil.ly/CZn61)中概述的那样，他寻求一种从最有前途的功能开始的增量方法。

逐步进行，并重复提取步骤，直到单体最终消除或解决初始软件交付问题，如图 3-4 所示。

![移动功能，尽可能长。](img/moej_0304.png)

###### 图 3-4. 逐步将单体架构移至服务的过程中，通过增量方式逐步提取它们

这三种方法在深度、角度和细节上有所不同。虽然理查德森谈论了最有价值的功能，并专注于首先提取它，弗莱创造了一种简单的方法论，可适用于所有情况。最后，纽曼为现代化旅程中的各种情况开发了最详细的手册。这三者对你的个人旅程都将有所帮助。然而，我们确信，理查德森采取的方法是最佳的起点。就像 Thomas Huijskens 对数据科学家说的那样，我们也坚信：“你编写的代码只有在成为生产代码时才有用。”

每一次现代化努力都必须遵循业务需求并支持生产功能。基于这一思路，只有当你确定了正确的候选者时，整个现代化项目才能成功。

# 摘要

本章介绍了一些迁移策略的基本定义，并展示了目标开发平台的评估路径。我们已经看过技术建议，现在你知道如何评估现有应用程序以进行重新托管、重新平台化和重构。
