<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 4. Immutability" data-type="chapter" epub:type="chapter"><div class="chapter" id="_02-data-structures">
<h1><span class="label">Chapter 4. </span>Immutability</h1>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45115247833536">
<h1>A Note for Early Release Readers</h1>
<p>With Early Release ebooks, you get books in their earliest form—the author’s raw and unedited content as they write—so you can take advantage of these technologies long before the official release of these titles.</p>
<p>This will be the 4th chapter of the final book. Please note that the GitHub repo will be made active later on.</p>
<p>If you have comments about how we might improve the content and/or examples in this book, or if you notice missing material within this chapter, please reach out to the editor at <em>rfernando@oreilly.com</em>.</p>
</div></aside>
<p>Dealing with data structures — constructs dedicated to storing and organizing data values — is a core task of almost any program.
In OOP, this usually means dealing with a <em>mutable</em> program state, often encapsulated in objects.
For a functional approach, however, <em>immutability</em> is the preferred way of handling data and a prerequisite for many of its concepts.</p>
<p>In functional programming languages like Haskell or even multi-paradigm but more functionally inclined ones like Scala, immutability is treated as a prevalent feature.
In those languages, immutability is a necessity and often strictly enforced, not just an afterthought to their design.
Like most other principles introduced in this book, immutability isn’t restricted to functional programming and provides many benefits, regardless of your chosen paradigm.</p>
<p>In this chapter, you will learn about immutable types already available in the JDK and how to make your data structures immutable to avoid side effects, either with the tools provided by the JDK or with the help of third-party libraries.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The term “data structure” used in this chapter represents any construct that stores and organizes data, like collections, or custom objects.</p>
</div>
<section data-pdf-bookmark="Mutability and Data Structures in OOP" data-type="sect1"><div class="sect1" id="_02-data-sructures_mutability">
<h1>Mutability and Data Structures in OOP</h1>
<p>As an object-oriented inclined language, typical Java code encapsulates an object’s state in a mutable form.
Its state is usually mutable by using “setter” methods.
This approach makes the program state <em>ephemeral</em>, meaning any change to an existing data structure updates its current state in-place, which also affects anyone else who references it, and the previous state is lost.</p>
<p>Let’s take a look at the most common forms used to handle mutable state in OOP Java code: <em>JavaBeans</em> and <em>Plain Old Java Objects (POJO)</em>.
A lot of confusion exists about those two data structures and their distinct properties.
In a sense, they are both ordinary Java objects supposed to create reusability between components by encapsulating all relevant states.
They have similar goals, although their design philosophy and rules differ.</p>
<p>POJOs don’t have any restrictions regarding their design.
They are supposed to “just” encapsulate the business logic state, and you can even design them to be immutable.
How you implement them is up to you and what matches your environment best.
They usually provide “getters” and “setters” for their fields to be more flexible in an object-oriented context with a mutable state.</p>
<p>JavaBeans, on the other hand, are a special kind of POJO that allows easier introspection and reusability, which requires them to oblige certain rules.
These rules are necessary because JavaBeans were initially designed to be a standardized shareable machine-readable state between components, like a UI widget in your IDE<sup><a data-type="noteref" href="ch04.xhtml#idm45115247823168" id="idm45115247823168-marker">1</a></sup>.
The differences between POJOs and JavaBeans are listed in <a data-type="xref" href="#_02-data-structures_pojo-vs-bean">Table 4-1</a>.</p>
<table id="_02-data-structures_pojo-vs-bean">
<caption><span class="label">Table 4-1. </span>POJOs versus JavaBeans</caption>
<thead>
<tr>
<th/>
<th>POJO</th>
<th>JavaBean</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>General Restrictions</p></td>
<td><p>Only those imposed by the Java language itself</p></td>
<td><p>Imposed by JavaBean API specification</p></td>
</tr>
<tr>
<td><p>Serialization</p></td>
<td><p>Optional</p></td>
<td><p>Must implement <code>java.io.Serializable</code></p></td>
</tr>
<tr>
<td><p>Field Visibility</p></td>
<td><p>No restrictions</p></td>
<td><p><code>private</code> only</p></td>
</tr>
<tr>
<td><p>Field Access</p></td>
<td><p>No restrictions</p></td>
<td><p>Only accessible via getters and setters</p></td>
</tr>
<tr>
<td><p>Constructors</p></td>
<td><p>No restrictions</p></td>
<td><p>No-arg constructor must exist.</p></td>
</tr>
</tbody>
</table>
<p>Many of the available data structures in the JDK, like the <em>collections framework</em>⁠<sup><a data-type="noteref" href="ch04.xhtml#idm45115247804480" id="idm45115247804480-marker">2</a></sup> are mostly built around the concept of mutable state and in-place changes.
Take <code>List&lt;E&gt;</code> for an example.
Its mutating methods, like <code>add(E value)</code> or <code>remove(E value)</code>, only return a <code>boolean</code> to indicate that a change occurred, and change the collection in place, so the previous state is lost.
You might not need to think much about it in a local context, but as soon as a data structure leaves your direct sphere of influence, it’s no longer guaranteed to remain in its current state as long as you hold a reference to it.</p>
<p>Mutable state breeds complexity and uncertainty.
You must include all possible state changes in your mental model at any time to understand and reason with your code.
This isn’t restricted to a single component, though.
Sharing mutable state increases the complexity to cover the lifetime of any components having access to such shared state.
Especially concurrent programming suffers under the complexities of shared state, where many problems originate in mutability and require intricate and often misused solutions like access synchronization and atomic references.</p>
<p>Ensuring the correctness of your code and shared state becomes a Sisyphean task of endless unit tests and state validation.
And the required additional work multiplies as soon as mutable state interacts with more mutable components, resulting in even more verification of their behavior.</p>
<p>That’s where immutability provides another approach to handling data structures and restoring reasonability.</p>
</div></section>
<section data-pdf-bookmark="Immutability (not only) in FP" data-type="sect1"><div class="sect1" id="idm45115247798848">
<h1>Immutability (not only) in FP</h1>
<p>The core idea of immutability is simple: data structures can no longer change after their creation.
Many functional programming languages support it by design at their core.
The concept isn’t bound to functional programming per se, and it has many advantages in any paradigm.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Immutability provides elegant solutions to many problems, even outside of programming languages.
For example, the distributed version control system <em>Git</em> essentially uses a tree of pointers to immutable blobs and diffs to provide a robust representation of historical changes.</p>
</div>
<p>Immutable data structures are <em>persistent</em> views of their data without a direct option to change it.
To “mutate” such a data structure, you must create a new copy with the intended changes.
Not being able to mutate data “in place” can feel weird in Java at first.
Compared to the usually mutable nature of object-oriented code, why should you take the extra steps necessary to simply change a value?
Such creation of new instances by copying data incurs a particular overhead that accumulates quickly for naive implementations of immutability.</p>
<p>Despite the overhead and initial weirdness of not being able to change data in place, the benefits of immutability can make it worthwhile even without a more functional approach to Java:</p>
<dl>
<dt>Predictability</dt>
<dd>
<p>Data structures won’t change without you noticing because they simply can’t.
As long as you reference a data structure, you know it is the same as at the time of its creation.
Even if you share that reference or use it in a concurrent fashion, no one can change your copy of it.</p>
</dd>
<dt>Validity</dt>
<dd>
<p>After initialization, a data structure is <em>complete</em>.
It only needs to be verified once and stays valid (or invalid) indefinitely.
If you need to build a data structure in multiple steps, the <em>builder-pattern</em>, shown later in <a data-type="xref" href="ch05.xhtml#_01-immutables_step-by-step">“Step-by-Step Creation”</a>, decouples the building and initialization of a data structure.</p>
</dd>
<dt>No hidden side effects</dt>
<dd>
<p>  Dealing with side effects is a really tough problem in programming — besides naming and cache invalidation<sup><a data-type="noteref" href="ch04.xhtml#idm45115247787824" id="idm45115247787824-marker">3</a></sup>.
  A byproduct of immutable data structures is the elimination of side effects; they’re always  <em>as-is</em>.
  Even if moved around a lot through different parts of your code or using it in a third-party library out of your control, they won’t change their values or surprise you with an unintended side effect.</p>
</dd>
<dt>Thread-safety</dt>
<dd>
<p>Without side effects, immutable data structures can move freely between thread boundaries.
No thread can change them, so reasoning about your program becomes more straightforward due to no more unexpected changes or race conditions.</p>
</dd>
<dt>Cacheability and optimization</dt>
<dd>
<p>Because they are <em>as-is</em> right after creation, you can cache immutable data structures with ease of mind.
Optimization techniques, like memoization, are only possible with immutable data structures, as discussed in <a data-type="xref" href="ch02.xhtml#_01-functional-java">Chapter 2</a>.</p>
</dd>
<dt>Change tracking</dt>
<dd>
<p>If every change results in a whole new data structure, you can track their history by storing the previous references.
You no longer need to intricately track single property changes to support an <em>undo</em> feature.
Restoring a previous state is as simple as using a prior reference to the data structure.</p>
</dd>
</dl>
<p>Remember, all these benefits are independent of the chosen programming paradigm.
Even if you decide that a functional approach might not be the right solution for your codebase, your data handling can still benefit immensely from immutability.</p>
</div></section>
<section data-pdf-bookmark="The State of Java Immutability" data-type="sect1"><div class="sect1" id="idm45115247780416">
<h1>The State of Java Immutability</h1>
<p>Java’s initial design didn’t include immutability as a deeply integrated language feature or a variety of immutable data structures.
Certain aspects of the language and its types were always immutable, but it was nowhere close to the level of support in other more functional languages.
This all changed when Java 14 was released and introduced <em>Records</em>, a built-in language-level immutable data structure: <em>Records</em>.</p>
<p>Even if you might not know it yet, you’re already using immutable types in all your Java programs.
The reasons behind their immutability might differ, like runtime optimizations or ensuring their correct usage,
but regardless of their intentions, they’ll make your code safer and less error-prone.</p>
<p>Let’s take a look at all the different immutable parts available in the JDK today.</p>
<section data-pdf-bookmark="java.lang.String" data-type="sect2"><div class="sect2" id="idm45115247776896">
<h2>java.lang.String</h2>
<p>One of the first types every Java developer learns about is the <code>String</code> type.
Strings are everywhere!
That’s why it needs to be a highly optimized and safe type.
One of these optimizations is that it’s immutable.</p>
<p><code>String</code> is not a primitive value-based type, like <code>int</code> or <code>char</code>.
Still, it supports the + (plus) operator to concatenate a <code>String</code> with another value:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">String</code> <code class="n">first</code> <code class="o">=</code> <code class="s">"hello, "</code><code class="p">;</code>
<code class="n">String</code> <code class="n">second</code> <code class="o">=</code> <code class="s">"world!"</code><code class="p">;</code>
<code class="n">String</code> <code class="n">result</code> <code class="o">=</code> <code class="n">first</code> <code class="o">+</code> <code class="n">second</code><code class="p">;</code>
<code class="c1">// =&gt; "hello, world!"</code></pre>
<p>Like any other expression, concatenating strings creates a result, and in this case, a new object.
That’s why Java developers are taught early not to overuse manual <code>String</code> concatenation.
Each time you concatenate strings by using the + (plus) operator, a new <code>String</code> instance is created on the heap, occupying memory, as depicted in <a data-type="xref" href="#_02-data-structures_string-allocation">Figure 4-1</a>.
These newly created instances can add up quickly, especially if concatenation is done in a loop statement like <code>for</code> or <code>while</code>.</p>
<figure><div class="figure" id="_02-data-structures_string-allocation">
<img alt="String memory allocation" height="175" src="assets/afaj_0401.png" width="378"/>
<h6><span class="label">Figure 4-1. </span>String memory allocation</h6>
</div></figure>
<p>Even though the JVM will garbage-collect no longer needed instances, the memory overhead of endless <code>String</code> creation can be a real burden on the runtime.
That’s why the JVM uses multiple optimization techniques “behind the scenes” to reduce <code>String</code> creation, like replacing concatenations with a <code>java.lang.StringBuilder</code>, or even using the opcode <code>invokedynamic</code> to support multiple optimization strategies<sup><a data-type="noteref" href="ch04.xhtml#idm45115247700816" id="idm45115247700816-marker">4</a></sup>.</p>
<p>Because <code>String</code> is such a fundamental type, it is sensible to make it immutable for multiple reasons.
Having such a base type being thread-safe by design solves issues associated with concurrency, like synchronization, before they even exist.
Concurrency is hard enough without worrying about a <code>String</code> to change without notice.
Immutability removes the risk of race conditions, side effects, or a simple unintended change.</p>
<p><code>String</code> literals also get special treatment from the JVM.
Thanks to <em>string pooling</em>, identical literals are only stored once and reused to save precious heap space.
If a <code>String</code> could change, it would change for everyone using a reference to it in the pool.
It’s possible to allocate a new <code>String</code> by explicitly calling one of its constructors instead of creating a literal to circumvent pooling.
The other way around is possible, too.
By calling <code>intern()</code> on any instance, which returns a <code>String</code> with the same content from the string pool.</p>
<div data-type="tip"><h1>String Equality</h1>
<p>The specialized handling of <code>String</code> instances and literals is why you should <em>never</em> use the equality operator <code>==</code> (double-equal) to compare Strings.
That’s why you should always use either the <code>equals</code> or <code>equalsIgnoreCase</code> method to test for equality.</p>
</div>
<p>However, the <code>String</code> type isn’t “completely” immutable, at least from a technical point of view.
It calculates its <code>hashCode</code> lazily due to performance considerations because it needs to read the whole <code>String</code> to calculate it.
Still, it’s a pure function: the same <code>String</code> will always result in the same <code>hashCode</code>.</p>
<p>Using lazy evaluation to hide expensive just-in-time calculations to achieve logical immutability requires extra care during the design and implementation of a type to ensure it remains thread-safe and predictable.</p>
<p>All these properties make <code>String</code> something between a primitive and an object type, at least from a usability standpoint.
Performance optimization possibilities and safety might have been the main reasons for its immutability, but the implicit advantages of immutability are still a welcome addition to such a fundamental type.</p>
</div></section>
<section data-pdf-bookmark="Immutable Collections" data-type="sect2"><div class="sect2" id="_02-data-structures_immutable-collections">
<h2>Immutable Collections</h2>
<p>Another fundamental and ubiquitous group of types that benefit significantly from immutability is collections, like <code>Set</code>, <code>List</code>, <code>Map</code>, etc.</p>
<p>Although Java’s collection framework wasn’t designed with immutability as a core principle, it still has a way of providing a certain degree of immutability with three options:</p>
<ul>
<li>
<p>Unmodifiable collections</p>
</li>
<li>
<p>Immutable collection factory methods (Java 9+)</p>
</li>
<li>
<p>Immutable copies (Java 10+)</p>
</li>
</ul>
<p>All options aren’t <code>public</code> types you can instantiate directly using the <code>new</code> keyword.
Instead, the relevant types have <code>static</code> convenience methods to create the necessary instances.
Also, they’re only <em>shallowly</em> immutable, meaning that you can not add or remove any elements, but the elements themselves aren’t guaranteed to be immutable.
Anyone holding a reference to an element can change it without the knowledge of the collection it currently resides in.</p>
<div data-type="warning" epub:type="warning"><h1>Shallow immutability</h1>
<p>Shallowly immutable data structures only provide immutability at their topmost level.
This means that the <em>reference</em> to the data structure itself can’t be changed.
The referenced data structure, however, in the case of a Collection, its elements — can still be mutated.</p>
</div>
<p>To have a fully immutable collection, you need to use only fully immutable elements, too.
Nevertheless, the three options still provide you with a helpful tool against unintended modification.</p>
<section data-pdf-bookmark="Unmodifiable Collections" data-type="sect3"><div class="sect3" id="idm45115247675344">
<h3>Unmodifiable Collections</h3>
<p>The first option, <em>unmodifiable collections</em>, is created from an existing collection by calling one of the following generic <code>static</code> methods of <code>java.util.Collections</code>:</p>
<ul>
<li>
<p><code>Collection&lt;T&gt; unmodifiableCollection(Collection&lt;? extends T&gt; c))</code></p>
</li>
<li>
<p><code>Set&lt;T&gt; unmodifiableSet(Set&lt;? extends T&gt; s)</code></p>
</li>
<li>
<p><code>List&lt;T&gt; unmodifiableList(List&lt;? extends T&gt; list)</code></p>
</li>
<li>
<p><code>Map&lt;K,V&gt; unmodifiableMap(Map&lt;? extends K, ? extends V&gt; m)</code><br/></p>
</li>
<li>
<p><code>SortedSet&lt;T&gt; unmodifiableSortedSet(SortedSet&lt;T&gt; s)</code></p>
</li>
<li>
<p><code>SortedMap&lt;K, V&gt; unmodifiableSortedMap(SortedMap&lt;K, ? extends V&gt; m)</code><br/></p>
</li>
<li>
<p><code>NavigableSet&lt;T&gt; unmodifiableNavigableSet(NavigableSet&lt;T&gt; s)</code></p>
</li>
<li>
<p><code>NavigableMap&lt;K, V&gt; unmodifiableNavigableMap(NavigableMap&lt;K, V&gt; m)</code></p>
</li>
</ul>
<p>As you can see, each method returns the same type as was provided for the method’s single argument.
The difference between the original and the returned instance is that any attempt to modify the returned instance will throw an <code>UnsupportedOperationException</code>, as demonstrated in the following code:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">modifiable</code> <code class="o">=</code> <code class="k">new</code> <code class="n">ArrayList</code><code class="o">&lt;&gt;</code><code class="p">();</code>
<code class="n">modifiable</code><code class="p">.</code><code class="na">add</code><code class="p">(</code><code class="s">"blue"</code><code class="p">);</code>
<code class="n">modifiable</code><code class="p">.</code><code class="na">add</code><code class="p">(</code><code class="s">"red"</code><code class="p">);</code>

<code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">unmodifiable</code> <code class="o">=</code> <code class="n">Collections</code><code class="p">.</code><code class="na">unmodifiableList</code><code class="p">(</code><code class="n">modifiable</code><code class="p">);</code>
<code class="n">unmodifiable</code><code class="p">.</code><code class="na">clear</code><code class="p">();</code>
<code class="c1">// throws UnsupportedOperationException</code></pre>
<p>The obvious downside of an “unmodifiable view” is that it’s only an abstraction over an existing collection.
The following code shows how the underlying collection is still modifiable and affects the unmodifiable view:</p>
<pre data-code-language="java" data-type="programlisting"><code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">original</code> <code class="o">=</code> <code class="k">new</code> <code class="n">ArrayList</code><code class="o">&lt;&gt;</code><code class="p">();</code>
<code class="n">original</code><code class="p">.</code><code class="na">add</code><code class="p">(</code><code class="s">"blue"</code><code class="p">);</code>
<code class="n">original</code><code class="p">.</code><code class="na">add</code><code class="p">(</code><code class="s">"red"</code><code class="p">);</code>

<code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">unmodifiable</code> <code class="o">=</code> <code class="n">Collections</code><code class="p">.</code><code class="na">unmodifiableList</code><code class="p">(</code><code class="n">original</code><code class="p">);</code>

<code class="n">original</code><code class="p">.</code><code class="na">add</code><code class="p">(</code><code class="s">"green"</code><code class="p">);</code>

<code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">unmodifiable</code><code class="p">.</code><code class="na">size</code><code class="p">());</code>
<code class="c1">// OUTPUT:</code>
<code class="c1">// 3</code></pre>
<p>The reason for still being modifiable via the original reference is how the data structure is stored in memory, as illustrated in <a data-type="xref" href="#_02-data-structures_unmodifiable-memory">Figure 4-2</a>.
The unmodified version is only a view of the original list, so any changes directly to the original circumvent the intended unmodifiable nature of the view.</p>
<figure><div class="figure" id="_02-data-structures_unmodifiable-memory">
<img alt="Memory layout of unmodifiable Collections" height="228" src="assets/afaj_0402.png" width="470"/>
<h6><span class="label">Figure 4-2. </span>Memory layout of unmodifiable Collections</h6>
</div></figure>
<p>The common use for unmodifiable views is to freeze collections for unwanted modification before using them as a return value.</p>
</div></section>
<section data-pdf-bookmark="Immutable Collection Factory Methods" data-type="sect3"><div class="sect3" id="idm45115247674720">
<h3>Immutable Collection Factory Methods</h3>
<p>The second option — <em>immutable collection factory methods</em> — has been available since Java 9 and isn’t based on preexisting collections.
Instead, the elements must be provided directly to the <code>static</code> convenience methods available on the following collection types:</p>
<ul>
<li>
<p><code>List.of(E e1, …​)</code></p>
</li>
<li>
<p><code>Set.of(E e1, …​)</code></p>
</li>
<li>
<p><code>Map.of(K k1, V v1, …​)</code></p>
</li>
</ul>
<p>Each <code>of</code> method exists with zero or more elements and uses an optimized internal collection type based on the number of elements used.</p>
</div></section>
<section data-pdf-bookmark="Immutable Copies" data-type="sect3"><div class="sect3" id="idm45115247491840">
<h3>Immutable Copies</h3>
<p>The third option, <em>immutable copies</em>, is available in Java 10+ and provides a deeper level of immutability by calling the <code>static copyOf</code> method on the following three types:</p>
<ul>
<li>
<p><code>Set&lt;E&gt; copyOf(Collection&lt;? extends E&gt; coll)</code></p>
</li>
<li>
<p><code>List&lt;E&gt; copyOf(Collection&lt;? extends E&gt; coll)</code></p>
</li>
<li>
<p><code>Map&lt;K, V&gt; copyOf(Map&lt;? extends K, ? extends V&gt; map)</code></p>
</li>
</ul>
<p>Instead of being a mere view, <code>copyOf</code> creates a new list holding its own references to the elements:</p>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// SETUP ORIGINAL LIST</code>
<code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">original</code> <code class="o">=</code> <code class="k">new</code> <code class="n">ArrayList</code><code class="o">&lt;&gt;</code><code class="p">();</code>
<code class="n">original</code><code class="p">.</code><code class="na">add</code><code class="p">(</code><code class="s">"blue"</code><code class="p">);</code>
<code class="n">original</code><code class="p">.</code><code class="na">add</code><code class="p">(</code><code class="s">"red"</code><code class="p">);</code>

<code class="c1">// CREATE COPY</code>
<code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">copiedList</code> <code class="o">=</code> <code class="n">List</code><code class="p">.</code><code class="na">copyOf</code><code class="p">(</code><code class="n">original</code><code class="p">);</code>

<code class="c1">// ADD NEW ITEM TO ORIGINAL LIST</code>
<code class="n">original</code><code class="p">.</code><code class="na">add</code><code class="p">(</code><code class="s">"green"</code><code class="p">);</code>

<code class="c1">// CHECK CONTENT</code>
<code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">original</code><code class="p">);</code>
<code class="c1">// [blue, red, green]</code>
<code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">copiedList</code><code class="p">);</code>
<code class="c1">// [blue, red]</code></pre>
<p>The copied collection prevents any addition or removal of elements through the original list, but the actual elements are still shared, as illustrated in <a data-type="xref" href="#_02-data-structures_copyOf-memory">Figure 4-3</a>, and open to changes.</p>
<figure><div class="figure" id="_02-data-structures_copyOf-memory">
<img alt="Memory layout of copied Collections" height="234" src="assets/afaj_0403.png" width="454"/>
<h6><span class="label">Figure 4-3. </span>Memory layout of copied Collections</h6>
</div></figure>
<p>Which option of immutable collections to choose depends on your context and intentions.
If a collection can’t be created in a single call, like in a <code>for</code>-loop, an unmodifiable view or immutable copy is a sensible approach.
Use a mutable collection locally and “freeze” it by returning an unmodifiable view or copy it when the data leaves your current scope.
Immutable collection factory methods don’t support an intermediary collection that might get modified but require you to know all the elements beforehand.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Primitives &amp; Primitive Wrappers" data-type="sect2"><div class="sect2" id="idm45115247686528">
<h2>Primitives &amp; Primitive Wrappers</h2>
<p>So far, you’ve learned mostly about immutable object types, but not everything in Java is an object.
Java’s <em>primitive</em> types — <code>byte</code>, <code>char</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>float</code>, <code>double</code>, <code>boolean</code> — are handled differently from object types.
They are simple values that are initialized by either a literal or an expression.
Representing only a single value, they are practically immutable.</p>
<p>Besides the primitive types themselves, Java provides corresponding object wrapper types.
They encapsulate their respective primitives in a concrete object type to make them usable in scenarios where primitives aren’t allowed (yet), like generics.
Otherwise, <em>autoboxing</em> — the automatic conversion between the object wrapper types and their corresponding primitive type — could lead to inconsistent behavior.</p>
</div></section>
<section data-pdf-bookmark="Immutable Math" data-type="sect2"><div class="sect2" id="idm45115247405776">
<h2>Immutable Math</h2>
<p>Most simple calculations in Java rely on <em>primitives</em> types like <code>int</code> or <code>long</code> for whole numbers, and <code>float</code> or <code>double</code> for floating-point calculations.
The package <code>java.math</code>, however, has two immutable alternatives for safer and more precise integer and decimal calculations, which are both immutable: <code>java.math.BigInteger</code> and <code>java.math.BigDecimal</code>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>In this context, “integer” means a number without a fractional component and not Java’s <code>int</code> or <code>Integer</code> type.
The word integer comes from Latin and is used in mathematics as a colloquial term to represent whole numbers in the range from <math alttext="negative normal infinity">
<mrow>
<mo>-</mo>
<mi>∞</mi>
</mrow>
</math> to <math alttext="plus normal infinity">
<mrow>
<mo>+</mo>
<mi>∞</mi>
</mrow>
</math>, including zero.</p>
</div>
<p>Just like with <code>String</code>, why should you burden your code with the overhead of immutability?
Because they allow side-effect-free calculations in a greater range with higher precision.</p>
<p>The pitfall of using immutable math objects, though, is the possibility of simply forgetting to use the actual result of a calculation.
Even though method names like <code>add</code> or <code>subtract</code> suggest modification, at least in an OO context, the <code>java.math</code> types return a new object with the result, as follows:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">var</code> <code class="n">theAnswer</code> <code class="o">=</code> <code class="k">new</code> <code class="n">BigDecimal</code><code class="p">(</code><code class="mi">42</code><code class="p">);</code>

<code class="kd">var</code> <code class="n">result</code> <code class="o">=</code> <code class="n">theAnswer</code><code class="p">.</code><code class="na">add</code><code class="p">(</code><code class="n">BigDecimal</code><code class="p">.</code><code class="na">ONE</code><code class="p">);</code>

<code class="c1">// RESULT OF THE CALCULATION</code>
<code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">result</code><code class="p">);</code>
<code class="c1">// OUTPUT:</code>
<code class="c1">// 43</code>

<code class="c1">//</code>
<code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">theAnswer</code><code class="p">);</code>
<code class="c1">// OUTPUT:</code>
<code class="c1">// 42</code></pre>
<p>The immutable math types are still objects with the usual overhead and use more memory to achieve their precisions.
Nevertheless, if calculation speed is not your limiting factor, you should always prefer the <code>BigDecimal</code> type for floating-point arithmetic due to its arbitrary precision<sup><a data-type="noteref" href="ch04.xhtml#idm45115247276768" id="idm45115247276768-marker">5</a></sup>.</p>
<p>The <code>BigInteger</code> type is the integer equivalent to <code>BigDecimal</code>, also with built-in immutability.
Another advantage is the extended range of at least<sup><a data-type="noteref" href="ch04.xhtml#idm45115247274704" id="idm45115247274704-marker">6</a></sup> from -2<sup>2,147,483,647</sup> up to 2<sup>2,147,483,647</sup> (both exclusive), compared to the range of <code>int</code> from -2<sup>31</sup> to 2<sup>31</sup>.</p>
</div></section>
<section data-pdf-bookmark="Java Time API (JSR-310)" data-type="sect2"><div class="sect2" id="idm45115247270592">
<h2>Java Time API (JSR-310)</h2>
<p>Java 8 introduced the Java Time API (<a href="https://jcp.org/en/jsr/detail?id=310">JSR-310</a>), which was designed with immutability as a core tenet.
Before its release, you only had three<sup><a data-type="noteref" href="ch04.xhtml#idm45115247268240" id="idm45115247268240-marker">7</a></sup> types in the package <code>java.util</code> at your disposal for all your date- and time-related needs: <code>Date</code>, <code>Calendar</code>, and <code>TimeZone</code>.
Performing calculations were a chore and error-prone.
That’s why <a href="https://www.joda.org/joda-time/">Joda Time library</a> became the de-facto standard for date and time classes before Java 8 and subsequently became the conceptual foundation for JSR-310.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Like with immutable math, any calculation with methods such as <code>plus</code> or <code>minus</code> won’t affect the object they’re called on.
Instead, you have to use the return value.</p>
</div>
<p>Rather than the previous three types in <code>java.util</code>, there now are multiple date- and time-related types with different precisions, with and without timezones, available in the <code>java.time</code> package.
They are all immutable, giving them all the related advantages like no side effects and safe use in concurrent environments.</p>
</div></section>
<section data-pdf-bookmark="Enums" data-type="sect2"><div class="sect2" id="idm45115247216800">
<h2>Enums</h2>
<p>Java enums are special types consisting of constants.
And constants are, well, <em>constant</em>, and therefore immutable.
Besides the constant values, an enum can contain additional fields which aren’t implicitly constant.</p>
<p>Usually, <code>final</code> primitives or Strings are used for these fields, but no one stops you from using a mutable object type or a setter for a primitive.
It will most likely lead to problems, and I strongly advise against it.
Also, it’s considered a <em>code smell</em>⁠<sup><a data-type="noteref" href="ch04.xhtml#idm45115247213936" id="idm45115247213936-marker">8</a></sup>.</p>
</div></section>
<section data-pdf-bookmark="The final keyword" data-type="sect2"><div class="sect2" id="_02-data-structures-final">
<h2>The final keyword</h2>
<p>Since Java’s inception, the <code>final</code> keyword provides a certain form of immutability depending on its context, but it’s not a magic keyword to make any data structure immutable.
So what exactly does it mean for a reference, method, or class to be <code>final</code>?</p>
<p>The <code>final</code> keyword is similar to the <code>const</code> keyword of the programming language <code>C</code>.
It has several implications if applied to classes, methods, fields, or references:</p>
<ul>
<li>
<p><code>final</code> classes cannot be subclassed.</p>
</li>
<li>
<p><code>final</code> methods cannot be overridden.</p>
</li>
<li>
<p><code>final</code> fields must be assigned <em>exactly</em> once — either by the constructors or on declaration — and can never be reassigned.</p>
</li>
<li>
<p><code>final</code> variable references behave like a field by being assignable <em>exactly</em> once — at declaration.
It only affects the reference itself, not the referenced variable content.</p>
</li>
</ul>
<p>The <code>final</code> keyword grants a particular form of immutability for fields and variables.
However, their immutability might not be what you expect because the reference <em>itself</em> becomes immutable but not the underlying data structure.
That means you can’t reassign the reference but still change the data structure, as shown in <a data-type="xref" href="#_02-data-structures_final_01">Example 4-1</a>.</p>
<div data-type="example" id="_02-data-structures_final_01">
<h5><span class="label">Example 4-1. </span>Collections and <code>final</code> References</h5>
<pre data-code-language="java" data-type="programlisting"><code class="kd">final</code> <code class="n">List</code><code class="o">&lt;</code><code class="n">String</code><code class="o">&gt;</code> <code class="n">fruits</code> <code class="o">=</code> <code class="k">new</code> <code class="n">ArrayList</code><code class="o">&lt;</code><code class="o">&gt;</code><code class="p">(</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_immutability_CO1-1" id="co_immutability_CO1-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>

<code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">fruits</code><code class="p">.</code><code class="na">isEmpty</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code class="p">;</code>
<code class="c1">// =&gt; true</code>

<code class="n">fruits</code><code class="p">.</code><code class="na">add</code><code class="p">(</code><code class="s">"</code><code class="s">Apple</code><code class="s">"</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_immutability_CO1-2" id="co_immutability_CO1-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a>

<code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">fruits</code><code class="p">.</code><code class="na">isEmpty</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code class="p">;</code>
<code class="c1">// =&gt; false</code>

<code class="n">fruits</code> <code class="o">=</code> <code class="n">List</code><code class="p">.</code><code class="na">of</code><code class="p">(</code><code class="s">"</code><code class="s">Mango</code><code class="s">"</code><code class="p">,</code> <code class="s">"</code><code class="s">Melon</code><code class="s">"</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_immutability_CO1-3" id="co_immutability_CO1-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a>
<code class="c1">// =&gt; WON'T COMPILE</code></pre></div>
<dl class="calloutlist">
<dt><a class="co" href="#co_immutability_CO1-1" id="callout_immutability_CO1-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>The <code>final</code> keyword only affects the reference <code>fruits</code>, not the actually referenced <code>ArrayList</code>.</p></dd>
<dt><a class="co" href="#co_immutability_CO1-2" id="callout_immutability_CO1-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>The <code>ArrayList</code> itself doesn’t have any concept of immutability, so you can freely add new items to it, even if its reference is <code>final</code>.</p></dd>
<dt><a class="co" href="#co_immutability_CO1-3" id="callout_immutability_CO1-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a></dt>
<dd><p>Re-assigning a <code>final</code> reference is prohibited.</p></dd>
</dl>
<p>As I discussed in <a data-type="xref" href="ch02.xhtml#_01-functions_lambdas_effectively-final">“Effectively final”</a>, having effectively <code>final</code> references are a necessity for lambda expressions.
Making every reference in your code <code>final</code> is an option, however, I wouldn’t recommend it.
The compiler detects automatically if a reference behaves like a <code>final</code> reference even without adding an explicit keyword.
Most problems created by the lack of immutability come from the underlying data structure itself and not reassigned references anyway.
To make sure a data structure won’t change unexpectedly as long as it’s in active use, you must choose an immutable data structure from the get-go.
The newest addition to Java to achieve this goal is <em>Records</em>.</p>
</div></section>
<section data-pdf-bookmark="Records" data-type="sect2"><div class="sect2" id="_02-data-structures_records">
<h2>Records</h2>
<p>In 2020, Java 14 introduced a new type of class with its own keyword to complement or even replace POJOs and JavaBeans in certain instances: <em>Records</em>.</p>
<p>Records are “plain data” aggregates with less ceremony than POJOs or Java beans.
Their feature set is reduced to an absolute minimum to serve that purpose, making them as concise as they are:</p>
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">record</code> <code class="nc">Address</code><code class="p">(</code><code class="n">String</code> <code class="n">name</code><code class="p">,</code>
                      <code class="n">String</code> <code class="n">street</code><code class="p">,</code>
                      <code class="n">String</code> <code class="n">state</code><code class="p">,</code>
                      <code class="n">String</code> <code class="n">zipCode</code><code class="p">,</code>
                      <code class="n">Country</code> <code class="n">country</code><code class="p">)</code> <code class="p">{</code>
  <code class="c1">// NO BODY</code>
<code class="p">}</code></pre>
<p>Records are shallowly immutable data carriers primarily consisting of their state’s declaration.
Without any additional code, the <code>Address</code> record provides automatically generated getters for the named components, equality comparison, <code>toString()</code> and <code>hashCode()</code>, and more.</p>
<p><a data-type="xref" href="ch05.xhtml#_02-records">Chapter 5</a> will deep-dive into Records on how to create and use them in different scenarios.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="How to Achieve Immutability" data-type="sect1"><div class="sect1" id="idm45115247779824">
<h1>How to Achieve Immutability</h1>
<p>Now that you know about the immutable parts the JVM provides, it’s time to look at how to combine them to achieve immutability for your program state.</p>
<p>The easiest way to make a type immutable is by not giving it a chance to change in the first place.
Without any setters, a data structure with <code>final</code> fields won’t change after creation because it can’t.
For real-world code, though, the solution might not be as simple as that.</p>
<p>Immutability requires a new way of thinking about data creation because many shared data structures are seldom created in one fell swoop.
Instead of mutating a single data structure over time, you should work with immutable constructs along the way, if possible, and compose a “final” and immutable data structure in the end.
<a data-type="xref" href="#_02-data-structures_record-data-holders">Figure 4-4</a> depicts the general idea of different data components contributing to a “final” immutable Record.
Even if the individual components aren’t immutable, you should always strive to wrap them in an immutable shell, Record or otherwise.</p>
<figure><div class="figure" id="_02-data-structures_record-data-holders">
<img alt="Records as Data Holders" height="305" src="assets/afaj_0404.png" width="482"/>
<h6><span class="label">Figure 4-4. </span>Records as Data Holders</h6>
</div></figure>
<p>Keeping track of the required components and their validation might be challenging in more complicated data structures.
In <a data-type="xref" href="ch05.xhtml#_02-records">Chapter 5</a>, I’ll discuss tools and techniques that improve data structure creation and reduce the required cognitive complexity.</p>
</div></section>
<section data-pdf-bookmark="Common Practices" data-type="sect1"><div class="sect1" id="idm45115246975504">
<h1>Common Practices</h1>
<p>Like the functional approach in general, immutability doesn’t have to be an all-or-nothing approach.
Due to their advantages, having only immutable data structures sounds intriguing, and your key goal should be to use immutable data structures and references as your default approach.
Converting existing mutable data structures to immutable ones, though, is often a pretty complex task requiring a lot of refactoring or conceptual redesign.
Instead, you could introduce immutability gradually by following common practices and treating your data as if it were already immutable.</p>
<dl>
<dt>Immutability by default</dt>
<dd>
<p>Any new data structure, like data-transfer objects, value objects, or any kind of state, should be designed as immutable.
If the JDK or another framework or library you’re using provides an immutable alternative, you should consider it over a mutable type.
Dealing with immutability right from the start with a new type will influence and shape any code that will use it.</p>
</dd>
<dt>Always expect Immutability</dt>
<dd>
<p>Assume all data structures are immutable unless you created them or it’s stated explicitly otherwise, especially when dealing with Collections.
If you need to change them, it’s safer to create a new one based on them.</p>
</dd>
<dt>Modifying existing types</dt>
<dd>
<p>Even if a pre-existing type isn’t immutable, new additions should be, if possible.
There might be reasons for making it mutable, but unnecessary mutability increases the bug surface, and all the advantages of immutability vanish instantly.</p>
</dd>
<dt>Break immutability if necessary</dt>
<dd>
<p>If it doesn’t fit, don’t force it, especially in legacy codebases.
The main goal of immutability is providing safer, more reasonable data structures, which requires their environment to support them accordingly.</p>
</dd>
<dt>Treat foreign data structures as immutable</dt>
<dd>
<p>Always treat any data structure not under your scope’s control as immutable.
For example, receiving a collection as a method argument should be considered immutable.
Instead of manipulating it directly, create a mutable wrapper view for any changes, and return an unmodifiable collection type.
This approach keeps the method pure and prevents any unintended changes the callee hasn’t expected.</p>
</dd>
</dl>
<p>Following these common practices will make it easier to create immutable data structures from the start or gradually transition to a more immutable program state along the way.</p>
</div></section>
<section data-pdf-bookmark="Takeaways" data-type="sect1"><div class="sect1" id="idm45115246966816">
<h1>Takeaways</h1>
<ul>
<li>
<p>Immutability is a simple concept but requires a new mindset and approach to handling data and change.</p>
</li>
<li>
<p>Lots of JDK types are already designed with immutability in mind</p>
</li>
<li>
<p>Records provide a new and concise way to reduce boilerplate for creating immutable data structures but deliberately lack certain flexibility to be as transparent and straightforward as possible.</p>
</li>
<li>
<p>You can achieve immutability with the built-in tools of the JDK, and third-party libraries can provide simple solutions to the missing pieces.</p>
</li>
<li>
<p>Introducing immutability into your code doesn’t have to be an all-or-nothing approach.
You can gradually apply common immutability practices to your existing code to reduce state-related bugs and ease refactoring efforts.</p>
</li>
</ul>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="idm45115247823168"><sup><a href="ch04.xhtml#idm45115247823168-marker">1</a></sup> JavaBeans are specified in the official <a href="https://download.oracle.com/otndocs/jcp/7224-javabeans-1.01-fr-spec-oth-JSpec/">JavaBeans API specification 1.01</a>, which is over a hundred pages long. For the scope of this book, however, you don’t need to know all of it, but the mentioned differences to other data structures.</p><p data-type="footnote" id="idm45115247804480"><sup><a href="ch04.xhtml#idm45115247804480-marker">2</a></sup> Since Java 1.2, the Java collections framework provides a multitude of common reusable data structures, like <code>List&lt;E&gt;</code>, <code>Set&lt;E&gt;</code>, etc. The <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/collections/overview.xhtml">Oracle Java documentation</a> has an overview of the available types included in the framework.</p><p data-type="footnote" id="idm45115247787824"><sup><a href="ch04.xhtml#idm45115247787824-marker">3</a></sup> Phil Karton, an accomplished software engineer who for many years as a principal developer at Xerox PARC, Digital, Silicon Graphics, and Netscape, coined the quote, “There are only two hard things in Computer Science: cache invalidation and naming things.” It became a mainstream joke in the software community over the years and is often amended by adding “one-off errors” without changing the count of two.</p><p data-type="footnote" id="idm45115247700816"><sup><a href="ch04.xhtml#idm45115247700816-marker">4</a></sup> The JDK Enhancement Proposal (JEP) 280, <a href="http://openjdk.java.net/jeps/280">“Indify String Concatenation”</a>, describes the reasoning behind using <code>invokedynamic</code> in more detail.</p><p data-type="footnote" id="idm45115247276768"><sup><a href="ch04.xhtml#idm45115247276768-marker">5</a></sup> Arbitrary-precision arithmetic — also known as bignum arithmetic, multiple-precision arithmetic, or sometimes infinite-precision arithmetic — performs calculations on numbers whose digits of precision are only limited by the available memory, not a fixed number.</p><p data-type="footnote" id="idm45115247274704"><sup><a href="ch04.xhtml#idm45115247274704-marker">6</a></sup> The actual range of <code>BigInteger</code> depends on the actual implementation of the used JDK, as stated in an implementation note in the <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/math/BigInteger.xhtml">offical documentation</a>.</p><p data-type="footnote" id="idm45115247268240"><sup><a href="ch04.xhtml#idm45115247268240-marker">7</a></sup> Technically there’s a forth type, <code>java.sql.Date</code>, which is a thin wrapper to improve JDBC support.</p><p data-type="footnote" id="idm45115247213936"><sup><a href="ch04.xhtml#idm45115247213936-marker">8</a></sup> A <em>code smell</em> is a known code characteristic that might indicate a deeper problem. It’s not a bug or error <em>per se</em>, but it might cause trouble in the long run. These <em>smells</em> are subjective and vary by programming language, developer, and paradigms. <a href="https://www.sonarsource.com/">SonarSource</a>, the well-known company that develops open-source software for continuous code quality and security, lists mutable enums as rule <a href="https://rules.sonarsource.com/java/RSPEC-3066">RSPEC-3066</a></p></div></div></section></div></body></html>