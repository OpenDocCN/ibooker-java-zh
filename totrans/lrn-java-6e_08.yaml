- en: Chapter 8\. Text and Core Utilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you’ve been reading this book sequentially, you’ve read all about the core
    Java language constructs, including the object-oriented aspects of the language
    and the use of threads. Now it’s time to shift gears and start talking about the
    collection of classes that compose the standard Java packages and come with every
    Java implementation. Java’s core packages are one of its most distinguishing features.
    Many other object-oriented languages have similar features, but none has as extensive
    a set of standardized classes and tools as Java does. This is both a reflection
    of—and a reason for—Java’s success.
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ll start by taking a closer look at the Java `String` class (or, more specifically,
    `java.lang.String`). Because working with `String`s is so fundamental, it’s important
    to understand how they are implemented and what you can do with them. A `String`
    object encapsulates a sequence of Unicode characters. Internally, these characters
    are stored in a regular Java array, but the `String` object guards this array
    jealously and gives you access to it only through its own API. This is to support
    the idea that `String`s are *immutable*; once you create a `String` object, you
    can’t change its value. Lots of operations on a `String` object appear to change
    the characters or length of a string, but what they really do is return a new
    `String` object that copies or internally references the needed characters of
    the original. Java implementations make an effort to consolidate identical strings
    used in the same class into a shared-string pool and to share parts of `String`s
    where possible.
  prefs: []
  type: TYPE_NORMAL
- en: The original motivation for all of this was performance. Immutable `String`s
    can save memory and the Java VM can optimize their use for speed. But they aren’t
    magic. You should have a basic understanding of the `String` class to avoid creating
    an excessive number of `String` objects in places where performance is an issue.^([1](ch08.html#id1542))
  prefs: []
  type: TYPE_NORMAL
- en: Constructing Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Literal strings, defined in your source code, are declared with double quotes
    and can be assigned to a `String` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Java automatically converts the literal string into a `String` object and assigns
    it to the variable.
  prefs: []
  type: TYPE_NORMAL
- en: '`String`s keep track of their own length, so `String` objects in Java don’t
    require special terminators. You can get the length of a `String` with the `length()`
    method. You can also test for a zero-length string by using `isEmpty()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`String`s can take advantage of the only overloaded operator in Java, the `+`
    operator, for string concatenation. The following two lines produce equivalent
    strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'For chunks of text larger than a name, Java 13 introduced text blocks. We can
    store a poem with fairly little effort by using three double-quotes to mark the
    beginning and end of the multiline block. This feature even preserves leading
    space in a clever way: the leftmost nonspace character becomes the left “edge.”
    Spaces to the left of that edge on subsequent lines are ignored, but spaces after
    that edge are retained. Consider redoing our poem in *jshell*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Embedding lengthy text in source code is not normally something you want to
    do. For text longer than a few dozen lines, [Chapter 10](ch10.html#learnjava6-CHP-10)
    looks at ways to load `String`s from files.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to making strings from literal expressions, you can construct a
    `String` directly from an array of characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also construct a `String` from an array of bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the second argument to the `String` constructor is the name of
    a character-encoding scheme. The `String` constructor uses it to convert the raw
    bytes in the specified encoding to the internal encoding chosen by the runtime.
    If you don’t specify a character encoding, the default encoding scheme on your
    system is used.^([2](ch08.html#id1549))
  prefs: []
  type: TYPE_NORMAL
- en: 'Conversely, the `charAt()` method of the `String` class lets you access the
    characters of a `String` in an array-like fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This code prints the characters of the string one at a time.
  prefs: []
  type: TYPE_NORMAL
- en: The notion that a `String` is a sequence of characters is also codified by the
    `String` class implementing the interface `java.lang.CharSequence`, which prescribes
    the methods `length()` and `charAt()` as a way to get a subset of the characters.
  prefs: []
  type: TYPE_NORMAL
- en: Strings from Things
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Objects and primitive types in Java can be turned into a default textual representation
    as a `String`. For primitive types like numbers, the string should be fairly obvious;
    for object types, it is under the control of the object itself. We can get the
    string representation of an item with the static `String.valueOf()` method. Various
    overloaded versions of this method accept each of the primitive types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'All objects in Java have a `toString()` method that is inherited from the `Object`
    class. For many objects, this method returns a useful result that displays the
    contents of the object. For example, a `java`.`util`.`Date` object’s `toString()`
    method returns the date it represents formatted as a string. For objects that
    do not provide a representation, the string result is just a unique identifier
    that you can use for debugging. The `String.valueOf()` method, when called for
    an object, invokes the object’s `toString()` method and returns the result. The
    only real difference in using this method is that if you pass it a null object
    reference, it returns the `String` “null” for you, instead of producing a `NullPointerException`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'String concatenation uses the `valueOf()` method internally, so if you “add”
    an object or primitive using the plus operator (+), you get a `String`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll sometimes see people use the empty string and the plus operator (+)
    as shorthand to get the string value of an object. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: It’s a bit of a cheat, but it does work and it is visually succinct.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The standard `equals()` method can compare strings for *equality*; they must
    contain exactly the same characters in the same order. You can use a different
    method, `equalsIgnoreCase()`, to check the equivalence of strings in a case-insensitive
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'A common mistake for novice programmers in Java is to compare strings with
    the `==` operator when they actually need the `equals()` method. Remember that
    strings are objects in Java, and `==` tests for object *identity*: that is, whether
    the two arguments being tested are the same object. In Java, it’s easy to make
    two strings that have the same characters but are not the same string object.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This mistake is particularly dangerous because it often works for the common
    case in which you are comparing *literal strings* (strings declared with double
    quotes right in the code). The reason for this is that Java tries to manage strings
    efficiently by combining them. At compile time, Java finds all the identical strings
    within a given class and makes only one object for them. This is safe because
    strings are immutable and cannot change, but it does leave room for this comparison
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `compareTo()` method compares the lexical value of the `String` to another
    `String`, using the Unicode specification to compare the relative positions of
    two strings within the “alphabet.” (We use quotes as Unicode has many more characters
    than just the letters of the English alphabet.) It returns an integer that is
    less than, equal to, or greater than zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You can’t really use the actual value returned by `compareTo()` beyond these
    three possibilities. Any negative number, be it -1, -5, or -1,000, simply means
    the first string is “less than” the second string. The `compareTo()` method compares
    strings strictly by their characters’ positions in the Unicode specification.
    This works for simple text but does not handle all language variations well. If
    you need more sophisticated comparisons with broader internationalization support,
    check out the documentation for [the `java.text.Collator` class](https://oreil.ly/KrVCG).
  prefs: []
  type: TYPE_NORMAL
- en: Searching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `String` class provides several simple methods for finding fixed substrings
    within a string. The `startsWith()` and `endsWith()` methods compare an argument
    string with the beginning and end of the `String`, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `indexOf()` method searches for the first occurrence of a character or
    substring and returns the starting character position, or `-1` if the substring
    is not found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, `lastIndexOf()` searches backward through the string for the last
    occurrence of a character or substring.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `contains()` method handles the very common task of checking to see whether
    a given substring is contained in the target string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: For more complex searching, you can use the Regular Expression API, which allows
    you to look for and parse complex patterns. We’ll talk about regular expressions
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: String Method Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Table 8-1](#learnjava6-CHP-8-TABLE-1) summarizes the methods provided by the
    `String` class. We’ve included several methods not discussed in this chapter.
    Feel free to try these methods out in *jshell* or look up the [documentation online](https://oreil.ly/lbM1R).'
  prefs: []
  type: TYPE_NORMAL
- en: Table 8-1\. String methods
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Functionality |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `charAt()` | Gets a particular character in the string |'
  prefs: []
  type: TYPE_TB
- en: '| `compareTo()` | Compares the string with another string |'
  prefs: []
  type: TYPE_TB
- en: '| `concat()` | Concatenates the string with another string |'
  prefs: []
  type: TYPE_TB
- en: '| `contains()` | Checks whether the string contains another string |'
  prefs: []
  type: TYPE_TB
- en: '| `copyValueOf()` | Returns a string equivalent to the specified character
    array |'
  prefs: []
  type: TYPE_TB
- en: '| `endsWith()` | Checks whether the string ends with a specified suffix |'
  prefs: []
  type: TYPE_TB
- en: '| `equals()` | Compares the string with another string |'
  prefs: []
  type: TYPE_TB
- en: '| `equalsIgnoreCase()` | Compares the string with another string, ignoring
    case |'
  prefs: []
  type: TYPE_TB
- en: '| `getBytes()` | Copies characters from the string into a byte array |'
  prefs: []
  type: TYPE_TB
- en: '| `getChars()` | Copies characters from the string into a character array |'
  prefs: []
  type: TYPE_TB
- en: '| `hashCode()` | Returns a hashcode for the string |'
  prefs: []
  type: TYPE_TB
- en: '| `indexOf()` | Searches for the first occurrence of a character or substring
    in the string |'
  prefs: []
  type: TYPE_TB
- en: '| `intern()` | Fetches a unique instance of the string from a global shared-string
    pool |'
  prefs: []
  type: TYPE_TB
- en: '| `isBlank()` | Returns true if the string is zero length or contains only
    whitespace |'
  prefs: []
  type: TYPE_TB
- en: '| `isEmpty()` | Returns true if the string is zero length |'
  prefs: []
  type: TYPE_TB
- en: '| `lastIndexOf()` | Searches for the last occurrence of a character or substring
    in a string |'
  prefs: []
  type: TYPE_TB
- en: '| `length()` | Returns the length of the string |'
  prefs: []
  type: TYPE_TB
- en: '| `lines()` | Returns a stream of lines separated by line terminators |'
  prefs: []
  type: TYPE_TB
- en: '| `matches()` | Determines if the whole string matches a regular expression
    pattern |'
  prefs: []
  type: TYPE_TB
- en: '| `regionMatches()` | Checks whether a region of the string matches the specified
    region of another string |'
  prefs: []
  type: TYPE_TB
- en: '| `repeat()` | Returns a concatenation of this string, repeated a given number
    of times |'
  prefs: []
  type: TYPE_TB
- en: '| `replace()` | Replaces all occurrences of a character in the string with
    another character |'
  prefs: []
  type: TYPE_TB
- en: '| `replaceAll()` | Replaces all occurrences of a regular expression pattern
    with a pattern |'
  prefs: []
  type: TYPE_TB
- en: '| `replaceFirst()` | Replaces the first occurrence of a regular expression
    pattern with a pattern |'
  prefs: []
  type: TYPE_TB
- en: '| `split()` | Splits the string into an array of strings using a regular expression
    pattern as a delimiter |'
  prefs: []
  type: TYPE_TB
- en: '| `startsWith()` | Checks whether the string starts with a specified prefix
    |'
  prefs: []
  type: TYPE_TB
- en: '| `strip()` | Removes leading and trailing whitespace as defined by [`Character.isWhitespace()`](https://oreil.ly/NK1Nl)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `stripLeading()` | Removes leading whitespace, similar to `strip()` |'
  prefs: []
  type: TYPE_TB
- en: '| `stripTrailing()` | Removes trailing whitespace, similar to `strip()` |'
  prefs: []
  type: TYPE_TB
- en: '| `substring()` | Returns a substring from the string |'
  prefs: []
  type: TYPE_TB
- en: '| `toCharArray()` | Returns the array of characters from the string |'
  prefs: []
  type: TYPE_TB
- en: '| `toLowerCase()` | Converts the string to lowercase |'
  prefs: []
  type: TYPE_TB
- en: '| `toString()` | Returns the string value of an object |'
  prefs: []
  type: TYPE_TB
- en: '| `toUpperCase()` | Converts the string to uppercase |'
  prefs: []
  type: TYPE_TB
- en: '| `trim()` | Removes leading and trailing whitespace, defined here as any character
    with a Unicode position (called its *codepoint*) less than or equal to 32 (the
    “space” character) |'
  prefs: []
  type: TYPE_TB
- en: '| `valueOf()` | Returns a string representation of a value |'
  prefs: []
  type: TYPE_TB
- en: Things from Strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Parsing and formatting text is a large, open-ended topic. So far in this chapter,
    we’ve looked at only primitive operations on strings—creation, searching, and
    turning simple values into strings. Now we’d like to move on to more structured
    forms of text. Java has a rich set of APIs for parsing and printing formatted
    strings, including numbers, dates, times, and currency values. We’ll cover most
    of these topics in this chapter, but we’ll wait to discuss date and time formatting
    in [“Local Dates and Times”](#learnjava6-CHP-8-SECT-5.1).
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start with *parsing*—reading primitive numbers and values from strings,
    and chopping long strings into tokens. Then we’ll take a look at regular expressions,
    the most powerful text-parsing tool Java offers. Regular expressions let you define
    your own patterns of arbitrary complexity, search for them, and parse them from
    text.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing Primitive Numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Java, numbers, characters, and booleans are primitive types—not objects.
    But for each primitive type, Java also defines a *primitive wrapper* class. Specifically,
    the `java.lang` package includes the following classes: `Byte`, `Short`, `Integer`,
    `Long`, `Float`, `Double`, `Character`, and `Boolean`. We talked about these in
    [“Wrappers for Primitive Types”](ch05.html#learnjava6-CHP-5-SECT-2.6), but we
    bring them up now because these classes hold static utility methods that parse
    their respective types from strings. Each of these primitive wrapper classes has
    a static “parse” method that reads a `String` and returns the corresponding primitive
    type. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You can find other ways to convert from strings to base types and back again,
    but these wrapper class methods are straightforward and easy to read. And in the
    case of `Integer` and `Long`, you can also supply an optional *radix* argument
    (the base of a number system; decimal numbers have a radix of 10, for example)
    to convert strings with octal or hexadecimal numbers. (Nondecimal data sometimes
    pops up when dealing with things such as cryptographic signatures or email attachments.)
  prefs: []
  type: TYPE_NORMAL
- en: Tokenizing Text
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’ll rarely encounter strings with just one number to parse or with only the
    word you need. It’s a more common programming task to parse a longer string of
    text into individual words, or *tokens*, that are separated by some set of *delimiter
    characters*, such as spaces or commas.
  prefs: []
  type: TYPE_NORMAL
- en: Programmers talk about tokens as a generic way to discuss different values or
    types present in a piece of text. A token might be a simple word, a username,
    an email address, or a number. Let’s take a look at some examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the sample text below. The first line contains words separated by
    single spaces. The remaining pair of lines involves comma-delimited fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Java has several (unfortunately overlapping) methods and classes for handling
    situations like this. We’ll use the powerful `split()` method from the `String`
    class. It utilizes regular expressions to allow you to break up a string based
    on arbitrary patterns. We’ll talk about regular expressions shortly, but to show
    you how this works, we’ll just give you the necessary magic now.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `split()` method accepts a regular expression that describes a delimiter.
    It uses that expression to chop the string into an array of smaller `String`s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the first example, we used the regular expression `\\s`, which matches a
    single whitespace character (space, tab, or carriage return). Calling `split()`
    on our `text1` variable returns an array of eight strings. In the second example,
    we used a more complicated regular expression, `\\s*,\\s*`, which matches a comma
    surrounded by any amount of optional whitespace. This reduced our text to three
    nice, tidy fields.
  prefs: []
  type: TYPE_NORMAL
- en: Regular Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now it’s time to take a brief detour on our trip through Java and enter the
    land of *regular expressions*. A regular expression, or *regex* for short, describes
    a text pattern. Regular expressions are used with many tools—including the `java.util.regex`
    package, text editors, and many scripting languages—to provide sophisticated text-searching
    and string-manipulation capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Regular expressions can help you find all of the phone numbers in a large file.
    They can help you find all of the phone numbers with a particular area code. They
    can help you find all of the phone numbers that do *not* have a particular area
    code. You can use a regular expression to find links in the source of a web page.
    You can even use regular expressions to do some editing in a text file. You could
    look for phone numbers with the area code in parentheses, say (123) 456-7890,
    and replace it with the simpler 123-456-7890 format, for example. And key to the
    power of regular expressions, you can find *every* phone number in your block
    of text with parentheses and convert it—not just one specific phone number.
  prefs: []
  type: TYPE_NORMAL
- en: If you are already familiar with the concept of regular expressions and how
    they are used with other languages, you may wish to skim through this section,
    but don’t skip it entirely. At the very least, you’ll need to look at [“The java.util.regex
    API”](#learnjava6-CHP-8-SECT-3.2) later in this chapter, which covers the Java
    classes necessary to use them. If you’re wondering exactly what regular expressions
    are, then grab a can or a cup of your favorite beverage and get ready. You are
    about to learn about the most powerful tool in the arsenal of text manipulation,
    as well as a tiny language within a language, all in the span of a few pages.
  prefs: []
  type: TYPE_NORMAL
- en: Regex Notation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A regular expression (regex) describes a pattern in text. By *pattern*, we mean
    just about any feature you can imagine identifying in text from the literal characters
    alone, without actually understanding their meaning. This includes features such
    as words, word groupings, lines and paragraphs, punctuation, upper- or lowercase,
    and more generally, strings and numbers with a specific structure to them. (Think
    of things like phone numbers, email addresses, or zip codes.) With regular expressions,
    you can search the dictionary for all the words that have the letter “q” without
    its pal “u” next to it, or words that start and end with the same letter. Once
    you have constructed a pattern, you can use simple tools to hunt for it in text
    or to determine if a given string matches it.
  prefs: []
  type: TYPE_NORMAL
- en: Write once, run away
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Regular expressions constitute a simple form of programming language. Think
    for a moment about the examples we cited earlier. We would need something like
    a language to describe even simple patterns—such as email addresses—that have
    common elements but also some variation in form.
  prefs: []
  type: TYPE_NORMAL
- en: A computer science textbook would classify regular expressions at the bottom
    of the hierarchy of computer languages, in terms of both what they can describe
    and what you can do with them. They are still capable of being quite sophisticated,
    however. As with most programming languages, the elements of regular expressions
    are simple, but you can combine them to create something quite complex. And that
    potential complexity is where things start to get sticky.
  prefs: []
  type: TYPE_NORMAL
- en: Since regexes work on strings, which can be found everywhere in Java code, it
    is convenient to have a very compact notation. But compact notation can be cryptic,
    and experience shows that it is much easier to write a complex statement than
    to read it again later. Such is the curse of the regular expression. You may find
    yourself in a moment of late-night, caffeine-fueled inspiration, writing a single
    glorious pattern to simplify the rest of your program down to one line. When you
    return to read that line the next day, however, it may look like Egyptian hieroglyphics
    to you. Simpler is generally better, but if you can break your problem more clearly
    into several steps, maybe you should.
  prefs: []
  type: TYPE_NORMAL
- en: Escaped characters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that you’ve been properly warned, we have to throw one more thing at you
    before we build you back up. Not only can the regex notation get a little hairy,
    but it is also somewhat ambiguous when used with ordinary Java strings. An important
    part of the notation is the escaped character—a character with a backslash in
    front of it. For example, in regex notation, the escaped `d` character, `\d`,
    (backslash “d”) is a shorthand for any single digit character (0–9). However,
    you cannot simply write `\d` as part of a Java string, because Java uses the backslash
    for its own special characters and to specify Unicode character sequences (`\uxxxx`).
    Fortunately, Java gives us a replacement: an *escaped backslash*: two backslashes
    (`\\`). It represents a literal backslash. The rule is, when you want a backslash
    to appear in your regex, you must escape it with an extra one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'It gets weirder! Because regex notation itself uses a backslash to denote special
    characters, it must provide the same “escape hatch” for itself. You need to double
    up backslashes if you want your regex to match a literal backslash. It looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the “magic” operator characters in this section operate on the character
    that precedes them, so you must escape them if you want their literal meaning.
    This includes such characters as `.`, `*`, `+`, `{}`, and `()`. An expression
    that can match formal US phone numbers (with the area code inside a pair of parentheses)
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If you need to create part of an expression that has lots of literal characters
    in it, you can use the special delimiters `\Q` and `\E` to help you. Any text
    appearing between `\Q` and `\E` is automatically escaped. (You still need the
    Java `String` escapes—double backslashes for backslash, but not quadruple.) There
    is also a static method called `Pattern.quote()` that does the same thing, returning
    a properly escaped version of whatever string you give it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have one more suggestion to help maintain your cool when working with these
    examples. Write out the plain regex using a comment line above the real Java string
    (where you must double up all backslashes). We also tend to include a comment
    with an example of the text we hope to match. Here’s that US phone number example
    again with this commenting approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: And don’t forget about *jshell*! It can be a very powerful playground for testing
    and tweaking your patterns. We’ll see several examples of testing patterns with
    *jshell* in [“The java.util.regex API”](#learnjava6-CHP-8-SECT-3.2). But first,
    let’s look at more of the elements you can use to construct patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Characters and character classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, let’s dive into the actual regex syntax. The simplest form of a regular
    expression is plain, literal text, which has no special meaning and is matched
    directly (character for character) in the input. This can be a single character
    or more. For example, in the following string, the pattern `s` can match the character
    “s” in the words “rose” and “is”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The pattern “rose” can match only the literal word `rose`. But this isn’t very
    interesting. Let’s crank things up a notch by introducing some special characters
    and the notion of character “classes”:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Any character: dot* (`.`)'
  prefs: []
  type: TYPE_NORMAL
- en: The special character dot (`.`) matches any single character. The pattern `.ose`
    matches “rose,” “nose,” “_ose” (space followed by “ose”), or any other character
    followed by the sequence “ose.” Two dots match any two characters (“prose,” “close”),
    and so on. The dot operator is very broad; it normally stops only for a *line
    terminator* (a newline, carriage return, or combination of both). Think of `.`
    as representing the class of all characters.
  prefs: []
  type: TYPE_NORMAL
- en: '*Whitespace or nonwhitespace character:* `\s`, `\S`'
  prefs: []
  type: TYPE_NORMAL
- en: The special character `\s` matches whitespace. *Whitespace* includes any character
    that relates to visual space in text or that marks the end of a line. Common whitespace
    characters include the literal space character (what you get when you press the
    space bar on your keyboard), `\t` (tab), `\r` (carriage return), `\n` (newline),
    and `\f` (formfeed). The corresponding special character `\S` does the inverse,
    matching any character that is *not* whitespace.
  prefs: []
  type: TYPE_NORMAL
- en: '*Digit or nondigit character*: `\d`, `\D`'
  prefs: []
  type: TYPE_NORMAL
- en: '`\d` matches any of the digits from 0 to 9\. `\D` does the inverse, matching
    all characters except digits.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Word or nonword character*: `\w`, `\W`'
  prefs: []
  type: TYPE_NORMAL
- en: '`\w` matches characters typically found in “words,” such as upper- and lowercase
    letters A–Z, a–z, the digits 0–9, and the underscore character (_). `\W` matches
    everything except those characters.'
  prefs: []
  type: TYPE_NORMAL
- en: Custom character classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can define your own character classes using square brackets (`[ ]`) around
    the characters you want. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The special `x-y` *range notation* can be used as shorthand for consecutive
    runs of alphanumeric characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Placing a caret (`^`) as the first character inside the brackets inverts the
    character class, matching any character *except* those included in the brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Nesting character classes simply concatenates them into a single class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the `&&` logical AND notation (similar to the Boolean operator
    we saw in [“Operators”](ch04.html#learnjava6-CHP-4-SECT-5.2.1)) to take the *intersection*
    (characters in common):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Position markers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The pattern `[Aa] rose` (including an upper- or lowercase A) matches three
    times in the following phrase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Position characters allow you to designate the relative location of a match
    within a line. The most important are `^` and `$`, which match the beginning and
    end of a line, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: To be a little more precise, `^` and `$` match the beginning and end of “input,”
    which is usually a single line. If you are working with multiple lines of text
    and wish to match the beginnings and endings of lines within a single large string,
    you can turn on “multiline” mode with a flag, as described later in [“Special
    options”](#learnjava6-CHP-8-SECT-3.1.8).
  prefs: []
  type: TYPE_NORMAL
- en: 'The position markers `\b` and `\B` match a word boundary (whitespace, punctuation,
    or the beginning or end of a line), or a nonword boundary (the middle of a word),
    respectively. For example, the first pattern matches “rose” and “rosemary,” but
    not “primrose.” The second pattern matches “primrose” and “prose,” but not “rose”
    at the beginning of a word or by itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: You often use these position markers when you need to look for or exclude prefixes
    or suffixes.
  prefs: []
  type: TYPE_NORMAL
- en: Iteration (multiplicity)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Simply matching fixed-character patterns will not get us very far. Next, we
    look at operators that count the number of occurrences of a character (or more
    generally, of a pattern, as we’ll see in [“Pattern”](#learnjava6-CHP-8-SECT-3.2.1)):'
  prefs: []
  type: TYPE_NORMAL
- en: '*Any (zero or more iterations): asterisk* (`*`)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Placing an asterisk (*) after a character or character class means “allow any
    number of that type of character”—in other words, zero or more. For example, the
    following pattern matches a digit with any number of leading zeros (possibly none):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '*Some (one or more iterations): plus sign* (`+`)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The plus sign (+) means “one or more” iterations and is equivalent to XX* (pattern
    followed by pattern asterisk). For example, the following pattern matches a number
    with one or more digits, plus optional leading zeros:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: It may seem redundant to match the zeros at the beginning of an expression because
    zero is a digit and is thus matched by the `\d+` portion of the expression anyway.
    However, we’ll show later how you can pick apart the string using a regex and
    get at just the pieces you want. In this case, you might want to strip off the
    leading zeros and keep only the digits.
  prefs: []
  type: TYPE_NORMAL
- en: '*Optional (zero or one iteration): question mark* (`?`)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The question mark operator (`?`) allows exactly zero or one iteration. For
    example, the following pattern matches a credit card expiration date, which may
    or may not have a slash in the middle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '*Range (between x and y iterations, inclusive)*: `{x,y}`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `{x,y}` curly brace range operator is the most general iteration operator.
    It specifies a precise range to match. A range takes two arguments: a lower bound
    and an upper bound, separated by a comma. This regex matches any word with five
    to seven characters, inclusive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '*At least x or more iterations (y is infinite)*: `{x,}`'
  prefs: []
  type: TYPE_NORMAL
- en: If you omit the upper bound, simply leaving a dangling comma in the range, the
    upper bound becomes infinite. This is a way to specify a minimum of occurrences
    with no maximum.
  prefs: []
  type: TYPE_NORMAL
- en: Alternation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The vertical bar (`|`) operator denotes the logical OR operation, also called
    *alternation* or *choice*. The `|` operator does not operate on individual characters
    but instead applies to everything on either side of it. It splits the expression
    in two unless constrained by parentheses grouping. For example, a slightly naive
    approach to parsing dates might be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In this expression, the left matches patterns such as “Fri, Oct 12, 2001,” and
    the right matches “10/12/01.”
  prefs: []
  type: TYPE_NORMAL
- en: 'The following regex might be used to match email addresses with one of three
    domains (*net*, *edu*, and *gov*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This pattern is by no means complete in terms of true, valid email addresses.
    But it does highlight how you can use alternation to help build regular expressions
    with some useful characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: Special options
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Several special options affect the way the regex engine performs its matching.
    These options can be applied in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: You can supply one or more special arguments (flags) to the `Pattern.compile()`
    step (discussed in [“The java.util.regex API”](#learnjava6-CHP-8-SECT-3.2)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can include a special block of code in your regex.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll show the latter approach here. To do this, include one or more flags in
    a special block `(?`*`x`*`)`, where *`x`* is the flag for the option we want to
    turn on. Generally, you do this at the beginning of the regex. You can also turn
    off flags by adding a minus sign `(?-`*`x`*`)`, which allows you to apply flags
    to select parts of your pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following flags are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Case-insensitive*: `(?i)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `(?i)` flag tells the regex engine to ignore character case while matching.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '*Dot all*: `(?s)`'
  prefs: []
  type: TYPE_NORMAL
- en: The `(?s)` flag turns on “dot all” mode, allowing the dot character to match
    anything, including end-of-line characters. It is useful if you are matching patterns
    that span multiple lines. The `s` stands for “single-line mode,” a somewhat confusing
    name derived from Perl.
  prefs: []
  type: TYPE_NORMAL
- en: '*Multiline*: `(?m)`'
  prefs: []
  type: TYPE_NORMAL
- en: By default, `^` and `$` don’t really match the beginnings and ends of lines
    (as defined by carriage return or newline combinations). Instead, they match the
    beginning or end of the entire input text. In many cases, “one line” is synonymous
    with the entire input.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a big block of text to process, you’ll often break that block into
    separate lines for other reasons. If you do that, checking any given line for
    a regular expression will be straightforward, and `^` and `$` will behave as expected.
    However, if you want to use a regex with the entire input string containing multiple
    lines (separated by those carriage return or newline combinations), you can turn
    on multiline mode with `(?m)`. This flag causes `^` and `$` to match the beginning
    and end of the individual lines *within* the block of text, *as well as* the beginning
    and end of the entire block. Specifically, this means the spot before the first
    character, the spot after the last character, and the spots just before and after
    line terminators inside the string.
  prefs: []
  type: TYPE_NORMAL
- en: '*Unix lines*: `(?d)`'
  prefs: []
  type: TYPE_NORMAL
- en: The `(?d)` flag limits the definition of the line terminator for the `^`, `$`,
    and `.` special characters to Unix-style newline only (`\n`). By default, carriage
    return newline (`\r\n`) is also allowed.
  prefs: []
  type: TYPE_NORMAL
- en: The java.util.regex API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we’ve covered the theory of how to construct regular expressions, the
    hard part is over. All that’s left is to investigate the Java API to see how to
    apply these expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we’ve said, the regex patterns that we write as strings are, in actuality,
    little programs describing how to match text. At runtime, the Java regex package
    compiles these little programs into a form that it can execute against some target
    text. Several simple convenience methods accept strings directly to use as patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'The static method `Pattern.matches()` takes two strings—a regex and a target
    string—and determines if the target matches the regex. This is very convenient
    if you want to do a quick test once in your application. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This line of code can test whether the string `myText` contains a Java-style
    floating-point number such as “42.0f.” Note that the string must match completely
    to be considered a match. If you want to see if a small pattern is contained within
    a larger string but don’t care about the rest of the string, you have to use a
    `Matcher`, as described in [“The Matcher”](#learnjava6-CHP-8-SECT-3.2.2).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try another (simplified) pattern that we could use in our game once we
    start letting multiple players compete against each other. Many login systems
    use email addresses as the user identifier. Such systems aren’t perfect, of course,
    but an email address will work for our needs. We would like to invite users to
    input their email address, but we want to make sure it looks valid before using
    it. A regular expression can be a quick way to perform such a validation.^([3](ch08.html#id1659))
  prefs: []
  type: TYPE_NORMAL
- en: 'Much like writing algorithms to solve programming problems, designing a regular
    expression requires you to break your pattern matching problem into bite-sized
    pieces. If we think about email addresses, a few patterns stand out right away.
    The most obvious is the `@` in the middle of every address. A naive (but better
    than nothing!) pattern relying on that fact could be built like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'But that pattern is too permissive. It will certainly recognize valid email
    addresses, but it will also recognize many invalid ones like `"bad.address@"`
    or `"@also.bad"` or even `"@@"`. Let’s test these out in *jshell*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Try to cook up a few more bad examples of your own. You’ll quickly see that
    our simple email pattern is definitely too simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'How can we make better matches? One quick adjustment would be to use the `+`
    modifier instead of the `*`. The upgraded pattern now requires at least one character
    on each side of the `@`. But we know a few other things about email addresses.
    For example, the left “half” of the address (the name portion) cannot contain
    the `@` character. For that matter, neither can the domain portion. We can use
    a custom character class for this next upgrade:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This pattern is better but still allows several invalid addresses such as `"still@bad"`
    since domain names have at least a name followed by a period (`.`) followed by
    a top-level domain (TLD) such as “oreilly.com.” So maybe a pattern like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'That pattern fixes our issue with an address like `"still@bad"`, but we’ve
    gone a bit too far the other way. There are many, many TLDs—too many to reasonably
    list even if we ignore the problem of maintaining that list as new TLDs are added.^([4](ch08.html#id1660))
    So let’s step back a little. We’ll keep the “dot” in the domain portion, but remove
    the specific TLD and just accept a simple run of letters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Much better. We can add one last tweak to make sure we don’t worry about the
    case of the address since all email addresses are case-insensitive. Just tack
    on the `(?i)` flag at the beginning of our pattern string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, this is by no means a perfect email validator, but it is definitely
    a good start and suffices for our hypothetical login system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In these examples, we typed in the full `Pattern.matches(…​)` line only once.
    After that it was a simple up arrow, edit, and then hit Return for the subsequent
    five lines. Can you spot the flaw in our final pattern that causes the match to
    fail?
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you want to tinker around with the validation pattern and expand or improve
    it, remember you can “reuse” lines in *jshell* with the keyboard arrow keys. Use
    the up arrow to retrieve the previous line. Indeed, you can use the up arrow and
    down arrow to navigate all of your recent lines. Within a line, use the left arrow
    and right arrow to move around and delete/add/edit your command. Then just press
    the Return key to run the newly altered command—you do not need to move the cursor
    to the end of the line before pressing Return.
  prefs: []
  type: TYPE_NORMAL
- en: The Matcher
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `Matcher` associates a pattern with a string and provides tools for testing,
    finding, and iterating over matches of the pattern against it. The `Matcher` is
    “stateful.” For example, the `find()` method tries to find the next match each
    time it is called. But you can clear the `Matcher` and start over by calling its
    `reset()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a `Matcher` object, you first need to compile your pattern string
    into a `Pattern` object using the static `Pattern.compile()` method. With that
    pattern object in hand, you can use the `matcher()` method to get your `Matcher`,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: If you’re just interested in “one big match”—that is, you’re expecting your
    string to either match the pattern or not—you can use `matches()` or `lookingAt()`.
    These correspond roughly to the methods `equals()` and `startsWith()` of the `String`
    class. The `matches()` method asks if the string matches the pattern in its entirety
    (with no string characters left over) and returns `true` or `false`. The `lookingAt()`
    method does the same, except that it asks only whether the string starts with
    the pattern and doesn’t care if the pattern uses up all the string’s characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'More generally, you’ll want to be able to search through the string and find
    one or more matches. To do this, you can use the `find()` method. Each call to
    `find()` returns `true` or `false` for the next match of the pattern and internally
    notes the position of the matching text. You can get the starting and ending character
    positions with the `Matcher start()` and `end()` methods, or you can simply retrieve
    the matched text with the `group()` method. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous snippet prints the starting location of the words “horse” and
    “course” (four in all):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Splitting strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A very common need is to parse a string into a bunch of fields based on some
    delimiter, such as a comma. It’s such a common problem that the `String` class
    contains a method for doing just this. The `split()` method accepts a regular
    expression and returns an array of substrings broken around that pattern. Consider
    the following string and `split()` calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The first `split()` returns a `String` array, but the naive use of `,` to separate
    the string means the space characters in our `text` variable remain stuck to the
    more interesting characters. We get `“Foo”` as a single word, as expected, but
    then we get `“bar<space>”` and finally `“<space><space><space>blah”`. Yikes! The
    second `split()` also yields a `String` array, but this time containing the expected
    `“Foo”, “bar”` (with no trailing space), and `“blah”` (with no leading spaces).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are going to use an operation like this more than a few times in your
    code, you should probably compile the pattern and use its `split()` method, which
    is identical to the version in `String`. The `String split()` method is equivalent
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: As we noted before, there is a lot to learn about regular expressions above
    and beyond the few regex capabilities we covered here. Check out the [documentation
    on patterns](https://oreil.ly/L8BUD). Play around on your own using *jshell*.
    Modify the *ch08/examples/ValidEmail.java* file and see if you can create a better
    email validator! This is definitely a topic that benefits from practice.
  prefs: []
  type: TYPE_NORMAL
- en: Math Utilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Of course, string manipulation and pattern matching are not the only types of
    operations Java can do. Java supports integer and floating-point arithmetic directly
    in the language. Higher-level math operations are supported through the `java.lang.Math`
    class. As you have seen, wrapper classes for primitive data types allow you to
    treat them as objects. Wrapper classes also hold some methods for basic conversions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with a quick look at the built-in arithmetic in Java. Java handles
    errors in integer arithmetic by throwing an `ArithmeticException`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: To generate the error in this example, we created the intermediate variable
    `zero`. The compiler is somewhat crafty. It would have caught us if we had tried
    to divide by `0` directly.
  prefs: []
  type: TYPE_NORMAL
- en: Floating-point arithmetic expressions, on the other hand, don’t throw exceptions.
    Instead, they take on the special out-of-range values shown in [Table 8-2](#learnjava6-CHP-8-TABLE-2).
  prefs: []
  type: TYPE_NORMAL
- en: Table 8-2\. Special floating-point values
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | Mathematical representation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `POSITIVE_INFINITY` | 1.0/0.0 |'
  prefs: []
  type: TYPE_TB
- en: '| `NEGATIVE_INFINITY` | -1.0/0.0 |'
  prefs: []
  type: TYPE_TB
- en: '| `NaN` | 0.0/0.0 |'
  prefs: []
  type: TYPE_TB
- en: 'The following example generates an infinite result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The special value `NaN` (not a number) indicates the result of dividing zero
    by zero. This value has the special mathematical distinction of not being equal
    to itself (`NaN != NaN` evaluates to `true`). Use `Float.isNaN()` or `Double.isNaN()`
    to test for `NaN`.
  prefs: []
  type: TYPE_NORMAL
- en: The java.lang.Math Class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `java.lang.Math` class is Java’s math library. It holds a suite of static
    methods covering all of the usual mathematical operations like `sin()`, `cos()`,
    and `sqrt()`. The `Math` class isn’t very object-oriented (you can’t create an
    instance of `Math`). Instead, it’s really just a convenient holder for static
    methods that are more like global functions. As we saw in [Chapter 5](ch05.html#learnjava6-CHP-5),
    it’s possible to use the static import functionality to import the names of static
    methods and constants like this directly into the scope of our class and use them
    by their simple, unqualified names.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 8-3](#learnjava6-CHP-8-TABLE-3) summarizes the methods in `java.lang.Math`.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 8-3\. Methods in java.lang.Math
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Argument type(s) | Functionality |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.abs(a)` | `int`, `long`, `float`, `double` | Absolute value |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.acos(a)` | `double` | Arc cosine |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.asin(a)` | `double` | Arc sine |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.atan(a)` | `double` | Arc tangent |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.atan2(a,b)` | `double` | Angle part of rectangular-to-polar coordinate
    transform |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.ceil(a)` | `double` | Smallest whole number greater than or equal to
    `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.cbrt(a)` | `double` | Cube root of `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.cos(a)` | `double` | Cosine |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.cosh(a)` | `double` | Hyperbolic cosine |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.exp(a)` | `double` | `Math.E` to the power `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.floor(a)` | `double` | Largest whole number less than or equal to `a`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.hypot(a,b)` | `double` | Precision calculation of the `sqrt()` of `a`2
    + `b`2 |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.log(a)` | `double` | Natural logarithm of `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.log10(a)` | `double` | Log base 10 of `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.max(a, b)` | `int`, `long`, `float`, `double` | The value `a` or `b`
    closer to `Long.MAX_VALUE` |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.min(a, b)` | `int`, `long`, `float`, `double` | The value `a` or `b`
    closer to `Long.MIN_VALUE` |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.pow(a, b)` | `double` | `a` to the power `b` |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.random()` | `None` | Random-number generator |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.rint(a)` | `double` | Converts double value to integral value in double
    format |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.round(a)` | `float`, `double` | Rounds to whole number |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.signum(a)` | `float`, `double` | Get the sign of the number at 1.0,
    –1.0, or 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.sin(a)` | `double` | Sine |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.sinh(a)` | `double` | Hyperbolic sine |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.sqrt(a)` | `double` | Square root |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.tan(a)` | `double` | Tangent |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.tanh(a)` | `double` | Hyperbolic tangent |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.toDegrees(a)` | `double` | Convert radians to degrees |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.toRadians(a)` | `double` | Convert degrees to radians |'
  prefs: []
  type: TYPE_TB
- en: 'The methods `log()`, `pow()`, and `sqrt()` can throw a runtime `ArithmeticException`.
    The methods `abs()`, `max()`, and `min()` are overloaded for all the scalar values
    (`int`, `long`, `float`, and `double`) and return the corresponding type. Versions
    of `Math.round()` accept either `float` or `double` and return `int` or `long`,
    respectively. The rest of the methods operate on and return `double` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Just to highlight the convenience of that static import option, try these simple
    functions in *jshell*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '`Math` also contains the static final double constants `E` and `PI`. To find
    the perimeter of a circle, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Math in action
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ve already touched on using the `Math` class and its static methods in [“Accessing
    Fields and Methods”](ch05.html#learnjava6-CHP-5-SECT-1.2). We can use it again
    to make our game a little more fun by randomizing where the trees appear. The
    `Math.random()` method returns a random `double` greater than or equal to 0 and
    less than 1\. Add in a little arithmetic and rounding or truncating, and you can
    use that value to create random numbers in any range you need. In particular,
    converting this value into a desired range follows this formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Try it! Try to generate a random four-digit number in *jshell*. You could set
    the `min` to 1,000 and the `max` to 10,000, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'To place our trees, we’ll need two random numbers for the x and y coordinates.
    We can set a range that will keep the trees on the screen by thinking about a
    margin around the edges. For the x coordinate, one way to do that might look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Set up a similar method for finding a y value, and you should start to see
    something like the image shown in [Figure 8-1](#learnjava6-CHP-8-FIG-1). You could
    even get fancy and use the `isTouching()` method we discussed back in [Chapter 5](ch05.html#learnjava6-CHP-5)
    to avoid placing any trees in direct contact with our physicist. Here’s our upgraded
    tree setup loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '![ljv6 0801](assets/ljv6_0801.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-1\. Randomly distributed trees
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Try quitting the game and launching it again. You should see the trees in different
    places each time you run the application.
  prefs: []
  type: TYPE_NORMAL
- en: Big/Precise Numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If the `long` and `double` types are not large or precise enough for you, the
    `java.math` package provides two classes, `BigInteger` and `BigDecimal`, that
    support arbitrary-precision numbers. These full-featured classes have a bevy of
    methods for performing arbitrary-precision^([5](ch08.html#id1702)) math and precisely
    controlling rounding of remainders. In the following example, we use `BigDecimal`
    to add two very large numbers and then create a fraction with a 100-digit result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: If you implement cryptographic or scientific algorithms for fun, `BigInteger`
    is crucial. `BigDecimal`, in turn, can be found in applications dealing with currency
    and financial data. Other than that, you’re not likely to need these classes.
  prefs: []
  type: TYPE_NORMAL
- en: Dates and Times
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with dates and times without the proper tools can be a chore. Java includes
    three classes that handle simple cases for you. The `java.util.Date` class encapsulates
    a point in time. The `java.util.GregorianCalendar` class, which extends the abstract
    `java.util.Calendar`, translates between a point in time and calendar fields like
    month, day, and year. Finally, the `java.text.DateFormat` class knows how to generate
    and parse string representations of dates and times in many languages and locales.
  prefs: []
  type: TYPE_NORMAL
- en: While the `Date` and `Calendar` classes covered many use cases, they lacked
    granularity and were missing other features. Several third-party libraries cropped
    up, all aimed at making it easier for developers to work with dates and times
    and time durations. Java 8 provided much needed improvements in this area with
    the addition of the `java.time` package. The rest of this chapter explores this
    package, but you will still encounter many, many `Date` and `Calendar` examples
    in the wild, so it’s useful to know they exist. As always, the [online docs](https://oreil.ly/Behlk)
    are an invaluable source for reviewing parts of the Java API we don’t tackle here.
  prefs: []
  type: TYPE_NORMAL
- en: Local Dates and Times
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `java.time.LocalDate` class represents a date without time information
    for your local region. Think of an annual event such as the winter solstice on
    December 21\. Similarly, `java.time.LocalTime` represents a time without any date
    information. Perhaps your alarm clock goes off at 7:15 every morning. The `java.time.LocalDateTime`
    stores both date and time values for things like appointments with your eye doctor
    (so you can keep reading books on Java). All of these classes offer static methods
    for creating new instances, either using appropriate numeric values with the method
    `of()` or by parsing strings with `parse()`. Let’s pop into *jshell* and try creating
    a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Another great static method for creating these objects is `now()`, which provides
    the current date, time, or date-and-time as you might expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Great! After importing the `java.time` package, you can create instances of
    each of the `Local…​` classes for specific moments or for “right now.” You may
    have noticed the objects created with `now()` include seconds and nanoseconds
    in the time. You can supply those values to the `of()` and `parse()` methods if
    you want or need them. Not much exciting there, but once you have these objects,
    you can do a lot with them. Read on!
  prefs: []
  type: TYPE_NORMAL
- en: Comparing and Manipulating Dates and Times
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the big advantages of using `java.time` classes is the consistent set
    of methods available for comparing and changing dates and times. For example,
    many chat applications will show you “how long ago” a message was sent. The `java.time.temporal`
    subpackage has just what we need: the `ChronoUnit` interface. It contains several
    date and time units such as `MONTHS`, `DAYS`, `HOURS`, `MINUTES`, etc. These units
    can be used to calculate differences. For example, we could calculate how long
    it takes us to create two example date-times in *jshell* using the `between()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: A visual spot check shows that it did indeed take about 11 seconds to type in
    the line that created our `second` variable. Check out the [docs for `ChronoUnit`](https://oreil.ly/BhCr2)
    for a complete list, but you get the full range, from nanoseconds up to millennia.
  prefs: []
  type: TYPE_NORMAL
- en: 'Those units can also help you manipulate dates and times with the `plus()`
    and `minus()` methods. To set a reminder for one week from today, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Neat! But this `reminder` example brings up another bit of manipulation you
    may need to perform from time to time. You might want a reminder at a particular
    time on the 7th. You can convert between dates, times, and date-times easily enough
    with the `atDate()` or `atTime()` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Now you’ll get a reminder at 9 A.M. Except, what if you set that reminder in
    Atlanta and then flew to San Francisco? When would the alarm go off? `LocalDateTime`
    is, well, local! So the `T09:00` portion is still 9 A.M. wherever you are when
    you run the program. But if you are handling something like scheduling a meeting,
    you can’t ignore the different time zones involved. Fortunately the `java.time`
    package has thought of that, too.
  prefs: []
  type: TYPE_NORMAL
- en: Time Zones
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The authors of the new `java.time` package encourage you to use the local variations
    of the time and date classes where possible. Adding support for time zones means
    adding complexity to your app—they want you to avoid that complexity if possible.
    But there are many scenarios where support for time zones is unavoidable. You
    can work with “zoned” dates and times using the `ZonedDateTime` and `OffsetDateTime`
    classes. The zoned variant understands named time zones and things like daylight
    saving adjustments. The offset variant is a constant, simple numeric offset from
    UTC/Greenwich.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most user-facing uses of dates and times will use the named zone approach,
    so let’s look at creating a zoned date-time. To attach a zone, we use the `ZoneId`
    class, which has the common `of()` static method for creating new instances. You
    can supply a region zone as a `String` to get your zoned value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'And now you can do things like make sure your friends in Paris can join you
    at the correct moment using the verbosely but aptly named `withZoneSameInstant()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have other friends who aren’t conveniently located in a major metropolitan
    region but you want them to join as well, you can use the `systemDefault()` method
    of `ZoneId` to pick up their time zone programmatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: We were running *jshell* on a laptop in the Eastern time zone of the United
    States. `piOther` comes out exactly as hoped. The `systemDefault()` zone ID is
    a very handy way to quickly tailor date-times from other zones to match what your
    user’s clock and calendar are most likely to say. In commercial applications you
    may want to let the user tell you their preferred zone, but `systemDefault()`
    is usually a good guess.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing and Formatting Dates and Times
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For creating and showing our local and zoned date-times using strings, we’ve
    been relying on the default formats that follow ISO values. These generally work
    wherever we need to accept or display dates and times. But as every programmer
    knows, “generally” is not “always.” Fortunately, you can use the utility class
    `java.time.format.DateTimeFormatter` to help with parsing input and formatting
    output.
  prefs: []
  type: TYPE_NORMAL
- en: The core of `DateTimeFormatter` centers on building a format string that governs
    both parsing and formatting. You build up your format with the pieces listed in
    [Table 8-4](#learnjava6-CHP-8-TABLE-4). We are listing only a portion of the options
    available here, but these should get you through the bulk of the dates and times
    you will encounter. Note that case matters when using the characters mentioned!
  prefs: []
  type: TYPE_NORMAL
- en: Table 8-4\. Popular and useful `DateTimeFormatter` elements
  prefs: []
  type: TYPE_NORMAL
- en: '| Character | Description | Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a | am-pm-of-day | PM |'
  prefs: []
  type: TYPE_TB
- en: '| d | day-of-month | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| E | day-of-week | Tue; Tuesday; T |'
  prefs: []
  type: TYPE_TB
- en: '| G | era | BCE, CE |'
  prefs: []
  type: TYPE_TB
- en: '| k | clock-hour-of-day (1-24) | 24 |'
  prefs: []
  type: TYPE_TB
- en: '| K | hour-of-am-pm (0-11) | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| L | month-of-year | Jul; July; J |'
  prefs: []
  type: TYPE_TB
- en: '| h | clock-hour-of-am-pm (1-12) | 12 |'
  prefs: []
  type: TYPE_TB
- en: '| H | hour-of-day (0-23) | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| m | minute-of-hour | 30 |'
  prefs: []
  type: TYPE_TB
- en: '| M | month-of-year | 7; 07 |'
  prefs: []
  type: TYPE_TB
- en: '| s | second-of-minute | 55 |'
  prefs: []
  type: TYPE_TB
- en: '| S | fraction-of-second | 033954 |'
  prefs: []
  type: TYPE_TB
- en: '| u | year (without era) | 2004; 04 |'
  prefs: []
  type: TYPE_TB
- en: '| y | year-of-era | 2004; 04 |'
  prefs: []
  type: TYPE_TB
- en: '| z | time-zone name | Pacific Standard Time; PST |'
  prefs: []
  type: TYPE_TB
- en: '| Z | zone-offset | +0000; -0800; -08:00 |'
  prefs: []
  type: TYPE_TB
- en: 'To put together a common US short format, for example, you could use the `M`,
    `d`, and `y` characters. You build the formatter using the static `ofPattern()`
    method. Now you can use (and reuse) the formatter with the `parse()` method of
    any of the date or time classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'And as we mentioned earlier, the formatter works in both directions. Just use
    the `format()` method of your formatter to produce a string representation of
    your date or time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Of course, formatters work for times and date-times as well!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Notice in the `ZonedDateTime` portion that follows that we put the time zone
    identifier (the `z` character) at the end—probably not where you were expecting
    it!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: We wanted to illustrate the power of these formats. You can design a format
    to accommodate a very wide range of input or output styles. Legacy data and poorly
    designed web forms come to mind as direct examples where `DateTimeFormatter` can
    help.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing Errors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Even with all this parsing power at your fingertips, things will sometimes
    go wrong. Regrettably, the exceptions you see are often too vague to be immediately
    useful. Consider the following attempt to parse a time with hours, minutes, and
    seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Yikes! Java will throw a `DateTimeParseException` any time it cannot parse
    the string input. Java will also throw the exception in cases like our example
    above; the fields were correctly parsed from the string, but they did not supply
    enough information to create a `LocalTime` object. It may not be obvious, but
    our time, `“3:14:15,”` could be either mid-afternoon or very early in the morning.
    Our choice of the `hh` pattern for the hours turns out to be the culprit. We can
    either pick an hour pattern that uses an unambiguous 24-hour scale or we can add
    an explicit A.M./P.M. element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'If you ever get a `DateTimeParseException` but your input looks like a correct
    match for the format, double-check that your format itself includes everything
    necessary to create your date or time. One parting thought on these exceptions:
    you may need to use the nonmnemonic `u` character for parsing years if your dates
    don’t naturally include an era designator such as `CE`.'
  prefs: []
  type: TYPE_NORMAL
- en: There are many, *many* more details on `DateTimeFormatter`. For this, more than
    for most utility classes, it’s worth a trip to [read the docs online](https://oreil.ly/rhosl).
  prefs: []
  type: TYPE_NORMAL
- en: Formatting Dates and Times
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that you know how to create, parse, and store dates and times, you need
    to display that handy data. Happily, you can build nice, human-readable strings
    using the same formatter you built to parse dates and times from strings. Remember
    our `withSeconds` and `military` formatters? You can pick up the current time
    and quickly turn it into either format, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: You can use any date or time pattern you build from the parts shown in [Table 8-4](#learnjava6-CHP-8-TABLE-4)
    to produce this formatted output. Hop into *jshell* and try creating a few formats.
    You can use the `LocalTime.now()` and `LocalDate.now()` methods to create some
    easy targets for your formatting tests.
  prefs: []
  type: TYPE_NORMAL
- en: Timestamps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One other popular date-time concept that `java.time` understands is timestamps.
    In any situation where you need to track the flow of information, you’ll need
    a record of exactly when the information is produced or modified. You will still
    see the `java.util.Date` class used to store these moments in time, but the `java.time.Instant`
    class carries everything you need for a timestamp and comes with all the other
    benefits of the other classes in the `java.time` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: If dates or times appear in your work, the `java.time` package makes for a welcome
    helper. You have a mature, well-designed set of tools for dealing with this data—no
    third-party libraries needed!
  prefs: []
  type: TYPE_NORMAL
- en: Other Useful Utilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve looked at some of Java’s building blocks, including strings and numbers,
    as well as one of the most popular combinations of those strings and numbers—dates—in
    the `LocalDate` and `LocalTime` classes. We hope this range of utilities has given
    you a sense of how Java works with many of the elements you are likely to encounter.
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to read the documentation on the `java.util`, `java.text`, and `java.time`
    packages for more utilities that may come in handy. For example, you could look
    into using `java.util.Random` for generating the random coordinates of the trees
    in [Figure 8-1](#learnjava6-CHP-8-FIG-1). Sometimes “utility” work is actually
    complex and requires careful attention to detail. Searching online for code examples
    or even complete libraries written by other developers may speed up your own efforts.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we’ll start building on these fundamental concepts. Java remains as
    popular as it is because it includes support for more advanced techniques in addition
    to the basics. One of those techniques is the “thread” features, which are baked
    right in. Threads provide better access to modern, powerful systems, keeping your
    applications performant even while handling many complex tasks. We’ll show you
    how to take advantage of this signature feature in [Chapter 9](ch09.html#learnjava6-CHP-9).
  prefs: []
  type: TYPE_NORMAL
- en: Review Questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Which class contains the constant π? Do you need to import that class to use
    π?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which package contains better replacements for the original `java.util.Date`
    class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which class should you use to format a date for user-friendly output?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What symbol would you use in a regular expression to help match the words “yes”
    and “yup”?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you convert the string “42” into the integer 42?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you compare two strings (such as “yes” and “YES”) to see if they match,
    ignoring any capitalization?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which operator concatenates strings?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Code Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s revisit our graphical Hello Java application and upgrade it using some
    new utilities and string features discussed in this chapter. You can start with
    the `HelloChapter8` class in the *exercises/ch08* folder. We want the program
    to support some command-line arguments for the message and initial position.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your program should accept 0, 1, or 2 arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: Zero arguments should place the text “Hello, utilities!” at the center to start.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One argument should be treated as the message to display; it should be centered
    to start:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember that multiword messages must be enclosed in quotes.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the message is the word `today`, your code should generate a formatted date
    to use as the message.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Two arguments represent the message and initial coordinates for where to display
    it:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The coordinates should be a quoted string containing a pair of numbers separated
    by a comma and optional whitespace. These are all valid coordinate strings:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`150,150`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`50, 50`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`100, 220`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The coordinates argument may also be the word `random`, meaning your code should
    generate a random initial position.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: If the user tries to pass three or more arguments, your code should generate
    an error message and exit.
  prefs: []
  type: TYPE_NORMAL
- en: Start by testing the number of arguments. If your program gets at least one
    argument, use the first argument for the message. If it gets two, you’ll need
    to split the coordinates and convert them to numbers. If you get the `random`
    argument, be sure to generate random numbers that will keep the message visible.
    (You can assume some reasonable default length for the message; it’s OK if some
    of a longer message gets truncated on the right side.)
  prefs: []
  type: TYPE_NORMAL
- en: Test out your solution with a few runs. Try different coordinates. Try the randomized
    option. Try the randomized option a few times successively to make sure the starting
    position really does change. What happens if you misspell `random` in the second
    argument?
  prefs: []
  type: TYPE_NORMAL
- en: 'For a further upgrade: try to write a regular expression to accept some variations
    on `random` while still ignoring the case:'
  prefs: []
  type: TYPE_NORMAL
- en: '`random`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rand`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rndm`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`r`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As always, you can find a few hints for this problem in [Appendix B](app02.html#learnjava6-APP-B).
    Our solutions are in the *ch08/exercises* folder of the source code.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch08.html#id1542-marker)) When in doubt, measure it! If your `String`-manipulating
    code is clean and easy to understand, don’t rewrite it until someone proves to
    you that it is too slow. Chances are that they will be wrong. And don’t be fooled
    by relative comparisons. A millisecond is a thousand times slower than a microsecond,
    but it still may be negligible to your application’s overall performance.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch08.html#id1549-marker)) On most platforms the default encoding is UTF-8\.
    You can get more details on character sets, default sets, and standard sets supported
    by Java in the [official Javadoc documentation](https://oreil.ly/UarRO) for the
    `java.nio.charset.Charset` class.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch08.html#id1659-marker)) Validating email addresses turns out to be much
    trickier than we can address here. Regular expressions can cover most valid addresses,
    but if you are doing validation for a commercial or other professional application,
    you may want to investigate third-party libraries, such as those available from
    [Apache Commons](https://oreil.ly/JEjEk).
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch08.html#id1660-marker)) You are welcome to [apply for your own, custom
    global TLD](https://oreil.ly/lMRnm) if you have a few hundred thousand dollars
    lying around.
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](ch08.html#id1702-marker)) The `float` type is “single-precision,” and
    `double` is, well, double-precision. (Hence its name!) A `double` can retain numbers
    with roughly twice the precision as a `float`. Arbitrary-precision simply means
    that you can have as many digits as you need before and after the decimal point.
    To be fair, NASA uses a value for π with only 15 digits of precision, which `double`
    can handle fine.
  prefs: []
  type: TYPE_NORMAL
