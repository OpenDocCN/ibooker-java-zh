- en: Chapter 8\. Text and Core Utilities
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章 文本和核心实用程序
- en: If you’ve been reading this book sequentially, you’ve read all about the core
    Java language constructs, including the object-oriented aspects of the language
    and the use of threads. Now it’s time to shift gears and start talking about the
    collection of classes that compose the standard Java packages and come with every
    Java implementation. Java’s core packages are one of its most distinguishing features.
    Many other object-oriented languages have similar features, but none has as extensive
    a set of standardized classes and tools as Java does. This is both a reflection
    of—and a reason for—Java’s success.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按顺序阅读本书，你已经学习了所有关于核心Java语言构造的内容，包括语言的面向对象方面和线程的使用。现在是时候转变思路，开始讨论组成标准Java包并随每个Java实现提供的类集合了。Java的核心包是其最显著的特点之一。许多其他面向对象的语言具有类似的功能，但没有一个像Java那样拥有如此广泛的标准化类和工具集。这既是Java成功的反映，也是其成功的原因之一。
- en: Strings
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串
- en: We’ll start by taking a closer look at the Java `String` class (or, more specifically,
    `java.lang.String`). Because working with `String`s is so fundamental, it’s important
    to understand how they are implemented and what you can do with them. A `String`
    object encapsulates a sequence of Unicode characters. Internally, these characters
    are stored in a regular Java array, but the `String` object guards this array
    jealously and gives you access to it only through its own API. This is to support
    the idea that `String`s are *immutable*; once you create a `String` object, you
    can’t change its value. Lots of operations on a `String` object appear to change
    the characters or length of a string, but what they really do is return a new
    `String` object that copies or internally references the needed characters of
    the original. Java implementations make an effort to consolidate identical strings
    used in the same class into a shared-string pool and to share parts of `String`s
    where possible.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先仔细查看Java的`String`类（更具体地说是`java.lang.String`）。因为与`String`一起工作如此基础，了解它们的实现方式及其可执行的操作是非常重要的。`String`对象封装了一系列Unicode字符。在内部，这些字符存储在常规的Java数组中，但`String`对象嫉妒地保护这个数组，并且只能通过其自己的API访问它。这是为了支持`String`是不可变的想法；一旦创建了`String`对象，就无法更改其值。对`String`对象的许多操作似乎会改变字符串的字符或长度，但实际上它们只是返回一个新的`String`对象，该对象复制或内部引用原始所需的字符。Java实现会努力将在同一类中使用的相同字符串合并为共享字符串池，并在可能的情况下共享`String`的部分。
- en: The original motivation for all of this was performance. Immutable `String`s
    can save memory and the Java VM can optimize their use for speed. But they aren’t
    magic. You should have a basic understanding of the `String` class to avoid creating
    an excessive number of `String` objects in places where performance is an issue.^([1](ch08.html#id1542))
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这一切最初的动机都是性能。不可变的`String`可以节省内存，并且Java虚拟机可以优化它们的使用以提高速度。但它们并非神奇。为了避免在性能受到影响的地方创建过多的`String`对象，您应该对`String`类有基本的理解。^([1](ch08.html#id1542))
- en: Constructing Strings
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造字符串
- en: 'Literal strings, defined in your source code, are declared with double quotes
    and can be assigned to a `String` variable:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 字面字符串在源代码中用双引号定义，并可以分配给`String`变量：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Java automatically converts the literal string into a `String` object and assigns
    it to the variable.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Java会自动将字面字符串转换为`String`对象，并将其分配给变量。
- en: '`String`s keep track of their own length, so `String` objects in Java don’t
    require special terminators. You can get the length of a `String` with the `length()`
    method. You can also test for a zero-length string by using `isEmpty()`:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`String`对象在Java中跟踪其自身的长度，因此不需要特殊的终止符。您可以使用`length()`方法获取`String`的长度。您还可以通过使用`isEmpty()`测试零长度字符串：'
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`String`s can take advantage of the only overloaded operator in Java, the `+`
    operator, for string concatenation. The following two lines produce equivalent
    strings:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`String`可以利用Java中唯一的重载运算符`+`进行字符串连接。以下两行产生的字符串是等效的：'
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For chunks of text larger than a name, Java 13 introduced text blocks. We can
    store a poem with fairly little effort by using three double-quotes to mark the
    beginning and end of the multiline block. This feature even preserves leading
    space in a clever way: the leftmost nonspace character becomes the left “edge.”
    Spaces to the left of that edge on subsequent lines are ignored, but spaces after
    that edge are retained. Consider redoing our poem in *jshell*:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大于一个名称的文本块，Java 13引入了文本块。我们可以通过使用三个双引号来标记多行块的开始和结束，轻松存储一首诗。这个特性甚至以聪明的方式保留了前导空格：最左边的非空格字符成为左侧的“边缘”。在后续行中，在该边缘左侧的空格将被忽略，但该边缘后面的空格将被保留。考虑在*jshell*中重新制作我们的诗：
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Embedding lengthy text in source code is not normally something you want to
    do. For text longer than a few dozen lines, [Chapter 10](ch10.html#learnjava6-CHP-10)
    looks at ways to load `String`s from files.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在源代码中嵌入长文本通常不是您想做的事情。对于超过几十行的文本，[第10章](ch10.html#learnjava6-CHP-10)介绍了从文件加载`String`的方法。
- en: 'In addition to making strings from literal expressions, you can construct a
    `String` directly from an array of characters:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 除了从文字表达中生成字符串外，你还可以直接从字符数组构造`String`：
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can also construct a `String` from an array of bytes:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以从字节数组构造一个`String`：
- en: '[PRE5]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this case, the second argument to the `String` constructor is the name of
    a character-encoding scheme. The `String` constructor uses it to convert the raw
    bytes in the specified encoding to the internal encoding chosen by the runtime.
    If you don’t specify a character encoding, the default encoding scheme on your
    system is used.^([2](ch08.html#id1549))
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`String`构造函数的第二个参数是字符编码方案的名称。`String`构造函数使用它来将指定编码中的原始字节转换为运行时选择的内部编码。如果不指定字符编码，则使用系统上的默认编码方案。^([2](ch08.html#id1549))
- en: 'Conversely, the `charAt()` method of the `String` class lets you access the
    characters of a `String` in an array-like fashion:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，`String`类的`charAt()`方法允许你以类似数组的方式访问`String`的字符：
- en: '[PRE6]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This code prints the characters of the string one at a time.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码逐个打印字符串的字符。
- en: The notion that a `String` is a sequence of characters is also codified by the
    `String` class implementing the interface `java.lang.CharSequence`, which prescribes
    the methods `length()` and `charAt()` as a way to get a subset of the characters.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`String`类实现`java.lang.CharSequence`接口，这个概念将`String`定义为字符序列，并指定了`length()`和`charAt()`方法作为获取字符子集的方式。'
- en: Strings from Things
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从事物中获取字符串
- en: 'Objects and primitive types in Java can be turned into a default textual representation
    as a `String`. For primitive types like numbers, the string should be fairly obvious;
    for object types, it is under the control of the object itself. We can get the
    string representation of an item with the static `String.valueOf()` method. Various
    overloaded versions of this method accept each of the primitive types:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Java中的对象和原始类型可以被转换为一个默认的文本表示作为`String`。对于诸如数字之类的原始类型，字符串应该是显而易见的；对于对象类型，则由对象本身控制。我们可以通过静态的`String.valueOf()`方法获取项目的字符串表示。这个方法的各种重载版本接受每个原始类型：
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'All objects in Java have a `toString()` method that is inherited from the `Object`
    class. For many objects, this method returns a useful result that displays the
    contents of the object. For example, a `java`.`util`.`Date` object’s `toString()`
    method returns the date it represents formatted as a string. For objects that
    do not provide a representation, the string result is just a unique identifier
    that you can use for debugging. The `String.valueOf()` method, when called for
    an object, invokes the object’s `toString()` method and returns the result. The
    only real difference in using this method is that if you pass it a null object
    reference, it returns the `String` “null” for you, instead of producing a `NullPointerException`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Java中的所有对象都有一个从`Object`类继承而来的`toString()`方法。对于许多对象，这个方法返回一个有用的结果，显示对象的内容。例如，`java.util.Date`对象的`toString()`方法返回它表示的日期格式化为字符串。对于不提供表示的对象，字符串结果只是一个可以用于调试的唯一标识符。当针对对象调用`String.valueOf()`方法时，它会调用对象的`toString()`方法并返回结果。使用这个方法的唯一真正的区别是，如果传递给它一个空对象引用，它会为你返回`String`“null”，而不是产生`NullPointerException`：
- en: '[PRE8]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'String concatenation uses the `valueOf()` method internally, so if you “add”
    an object or primitive using the plus operator (+), you get a `String`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串连接在内部使用`valueOf()`方法，因此如果使用加号运算符（+）“添加”对象或原始类型，则会得到一个`String`：
- en: '[PRE9]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You’ll sometimes see people use the empty string and the plus operator (+)
    as shorthand to get the string value of an object. For example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你会看到人们使用空字符串和加号运算符（+）作为快捷方式来获取对象的字符串值。例如：
- en: '[PRE10]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It’s a bit of a cheat, but it does work and it is visually succinct.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点欺骗，但确实有效，而且视觉上简洁。
- en: Comparing Strings
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较字符串
- en: 'The standard `equals()` method can compare strings for *equality*; they must
    contain exactly the same characters in the same order. You can use a different
    method, `equalsIgnoreCase()`, to check the equivalence of strings in a case-insensitive
    way:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的 `equals()` 方法可以比较字符串是否 *相等*；它们必须按相同顺序包含完全相同的字符。你可以使用 `equalsIgnoreCase()`
    方法以不区分大小写的方式检查字符串的等价性：
- en: '[PRE11]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'A common mistake for novice programmers in Java is to compare strings with
    the `==` operator when they actually need the `equals()` method. Remember that
    strings are objects in Java, and `==` tests for object *identity*: that is, whether
    the two arguments being tested are the same object. In Java, it’s easy to make
    two strings that have the same characters but are not the same string object.
    For example:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，初学者常见的错误是在需要 `equals()` 方法时使用 `==` 运算符比较字符串。请记住，Java 中字符串是对象，`==` 测试对象的
    *身份*：即测试两个被测试参数是否是同一个对象。在 Java 中，很容易创建两个具有相同字符但不是同一个字符串对象的字符串。例如：
- en: '[PRE12]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This mistake is particularly dangerous because it often works for the common
    case in which you are comparing *literal strings* (strings declared with double
    quotes right in the code). The reason for this is that Java tries to manage strings
    efficiently by combining them. At compile time, Java finds all the identical strings
    within a given class and makes only one object for them. This is safe because
    strings are immutable and cannot change, but it does leave room for this comparison
    problem.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误特别危险，因为它通常对比较“字面字符串”（直接在代码中用双引号声明的字符串）有效。这是因为 Java 尝试通过组合它们来有效管理字符串。在编译时，Java
    找出给定类中的所有相同字符串，并为它们创建一个对象。这是安全的，因为字符串是不可变的，不能改变，但这确实为此比较问题留下了空间。
- en: 'The `compareTo()` method compares the lexical value of the `String` to another
    `String`, using the Unicode specification to compare the relative positions of
    two strings within the “alphabet.” (We use quotes as Unicode has many more characters
    than just the letters of the English alphabet.) It returns an integer that is
    less than, equal to, or greater than zero:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`compareTo()` 方法比较 `String` 的词法值与另一个 `String`，使用 Unicode 规范比较两个字符串在“字母表”中的相对位置。（我们用引号是因为
    Unicode 不仅包含英语字母的许多更多字符。）它返回一个整数，小于、等于或大于零：'
- en: '[PRE13]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can’t really use the actual value returned by `compareTo()` beyond these
    three possibilities. Any negative number, be it -1, -5, or -1,000, simply means
    the first string is “less than” the second string. The `compareTo()` method compares
    strings strictly by their characters’ positions in the Unicode specification.
    This works for simple text but does not handle all language variations well. If
    you need more sophisticated comparisons with broader internationalization support,
    check out the documentation for [the `java.text.Collator` class](https://oreil.ly/KrVCG).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`compareTo()` 方法返回的实际值有三种可能性，你不能真正使用它们。任何负数，比如 `-1`、`-5` 或 `-1,000`，仅意味着第一个字符串“小于”第二个字符串。`compareTo()`
    方法严格按照 Unicode 规范中字符的位置比较字符串。这对简单文本有效，但不能很好地处理所有语言变体。如果你需要更复杂的比较及更广泛的国际化支持，请查阅
    [java.text.Collator 类的文档](https://oreil.ly/KrVCG)。'
- en: Searching
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索
- en: 'The `String` class provides several simple methods for finding fixed substrings
    within a string. The `startsWith()` and `endsWith()` methods compare an argument
    string with the beginning and end of the `String`, respectively:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`String` 类提供了几个简单的方法来查找字符串中的固定子字符串。`startsWith()` 和 `endsWith()` 方法分别与 `String`
    的开头和结尾的参数字符串进行比较：'
- en: '[PRE14]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `indexOf()` method searches for the first occurrence of a character or
    substring and returns the starting character position, or `-1` if the substring
    is not found:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`indexOf()` 方法搜索字符或子字符串的第一个出现位置，并返回起始字符位置，如果未找到子字符串，则返回 `-1`：'
- en: '[PRE15]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Similarly, `lastIndexOf()` searches backward through the string for the last
    occurrence of a character or substring.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`lastIndexOf()` 向后搜索字符串中字符或子字符串的最后一个出现位置。
- en: 'The `contains()` method handles the very common task of checking to see whether
    a given substring is contained in the target string:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`contains()` 方法处理一个非常常见的任务，即检查目标字符串中是否包含给定的子字符串：'
- en: '[PRE16]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: For more complex searching, you can use the Regular Expression API, which allows
    you to look for and parse complex patterns. We’ll talk about regular expressions
    later in this chapter.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的搜索，可以使用正则表达式 API，它允许您查找和解析复杂模式。我们将在本章后面讨论正则表达式。
- en: String Method Summary
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串方法摘要
- en: '[Table 8-1](#learnjava6-CHP-8-TABLE-1) summarizes the methods provided by the
    `String` class. We’ve included several methods not discussed in this chapter.
    Feel free to try these methods out in *jshell* or look up the [documentation online](https://oreil.ly/lbM1R).'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 8-1](#learnjava6-CHP-8-TABLE-1) 总结了 `String` 类提供的方法。我们包含了本章未讨论的几种方法。可以在
    *jshell* 中尝试这些方法，或者查看[在线文档](https://oreil.ly/lbM1R)。'
- en: Table 8-1\. String methods
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-1\. 字符串方法
- en: '| Method | Functionality |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 功能 |'
- en: '| --- | --- |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `charAt()` | Gets a particular character in the string |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `charAt()` | 获取字符串中特定位置的字符 |'
- en: '| `compareTo()` | Compares the string with another string |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `compareTo()` | 比较字符串与另一个字符串 |'
- en: '| `concat()` | Concatenates the string with another string |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `concat()` | 将字符串与另一个字符串连接起来 |'
- en: '| `contains()` | Checks whether the string contains another string |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `contains()` | 检查字符串是否包含另一个字符串 |'
- en: '| `copyValueOf()` | Returns a string equivalent to the specified character
    array |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `copyValueOf()` | 返回与指定字符数组等效的字符串 |'
- en: '| `endsWith()` | Checks whether the string ends with a specified suffix |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `endsWith()` | 检查字符串是否以指定后缀结尾 |'
- en: '| `equals()` | Compares the string with another string |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `equals()` | 比较字符串与另一个字符串是否相等 |'
- en: '| `equalsIgnoreCase()` | Compares the string with another string, ignoring
    case |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `equalsIgnoreCase()` | 忽略大小写比较字符串与另一个字符串 |'
- en: '| `getBytes()` | Copies characters from the string into a byte array |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `getBytes()` | 将字符从字符串复制到字节数组 |'
- en: '| `getChars()` | Copies characters from the string into a character array |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `getChars()` | 将字符串中的字符复制到字符数组 |'
- en: '| `hashCode()` | Returns a hashcode for the string |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `hashCode()` | 返回字符串的哈希码 |'
- en: '| `indexOf()` | Searches for the first occurrence of a character or substring
    in the string |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `indexOf()` | 在字符串中搜索字符或子字符串的第一次出现位置 |'
- en: '| `intern()` | Fetches a unique instance of the string from a global shared-string
    pool |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `intern()` | 从全局共享字符串池中获取字符串的唯一实例 |'
- en: '| `isBlank()` | Returns true if the string is zero length or contains only
    whitespace |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `isBlank()` | 如果字符串长度为零或仅包含空白字符，则返回 true |'
- en: '| `isEmpty()` | Returns true if the string is zero length |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `isEmpty()` | 如果字符串长度为零，则返回 true |'
- en: '| `lastIndexOf()` | Searches for the last occurrence of a character or substring
    in a string |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `lastIndexOf()` | 在字符串中搜索字符或子字符串的最后一次出现位置 |'
- en: '| `length()` | Returns the length of the string |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `length()` | 返回字符串的长度 |'
- en: '| `lines()` | Returns a stream of lines separated by line terminators |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `lines()` | 返回由行终止符分隔的流 |'
- en: '| `matches()` | Determines if the whole string matches a regular expression
    pattern |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `matches()` | 确定整个字符串是否与正则表达式模式匹配 |'
- en: '| `regionMatches()` | Checks whether a region of the string matches the specified
    region of another string |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `regionMatches()` | 检查字符串的区域是否与另一个字符串的指定区域匹配 |'
- en: '| `repeat()` | Returns a concatenation of this string, repeated a given number
    of times |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `repeat()` | 返回重复给定次数的此字符串的连接 |'
- en: '| `replace()` | Replaces all occurrences of a character in the string with
    another character |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `replace()` | 将字符串中所有出现的字符替换为另一个字符 |'
- en: '| `replaceAll()` | Replaces all occurrences of a regular expression pattern
    with a pattern |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `replaceAll()` | 使用模式替换字符串中所有正则表达式模式的匹配项 |'
- en: '| `replaceFirst()` | Replaces the first occurrence of a regular expression
    pattern with a pattern |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `replaceFirst()` | 使用模式替换字符串中第一次出现的正则表达式模式 |'
- en: '| `split()` | Splits the string into an array of strings using a regular expression
    pattern as a delimiter |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `split()` | 使用正则表达式模式作为分隔符，将字符串拆分为字符串数组 |'
- en: '| `startsWith()` | Checks whether the string starts with a specified prefix
    |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `startsWith()` | 检查字符串是否以指定前缀开头 |'
- en: '| `strip()` | Removes leading and trailing whitespace as defined by [`Character.isWhitespace()`](https://oreil.ly/NK1Nl)
    |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `strip()` | 根据 [`Character.isWhitespace()`](https://oreil.ly/NK1Nl) 定义，移除字符串的前导和尾随空白
    |'
- en: '| `stripLeading()` | Removes leading whitespace, similar to `strip()` |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `stripLeading()` | 类似于 `strip()`，移除前导空白 |'
- en: '| `stripTrailing()` | Removes trailing whitespace, similar to `strip()` |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `stripTrailing()` | 类似于 `strip()`，移除尾随空白 |'
- en: '| `substring()` | Returns a substring from the string |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `substring()` | 返回字符串的子串 |'
- en: '| `toCharArray()` | Returns the array of characters from the string |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `toCharArray()` | 返回字符串的字符数组 |'
- en: '| `toLowerCase()` | Converts the string to lowercase |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `toLowerCase()` | 将字符串转换为小写 |'
- en: '| `toString()` | Returns the string value of an object |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `toString()` | 返回对象的字符串值 |'
- en: '| `toUpperCase()` | Converts the string to uppercase |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `toUpperCase()` | 将字符串转换为大写 |'
- en: '| `trim()` | Removes leading and trailing whitespace, defined here as any character
    with a Unicode position (called its *codepoint*) less than or equal to 32 (the
    “space” character) |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `trim()` | 删除前导和尾随空白，这里定义为任何Unicode位置（称为其*代码点*）小于或等于32的字符（“空格”字符） |'
- en: '| `valueOf()` | Returns a string representation of a value |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `valueOf()` | 返回值的字符串表示形式 |'
- en: Things from Strings
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串的用途
- en: Parsing and formatting text is a large, open-ended topic. So far in this chapter,
    we’ve looked at only primitive operations on strings—creation, searching, and
    turning simple values into strings. Now we’d like to move on to more structured
    forms of text. Java has a rich set of APIs for parsing and printing formatted
    strings, including numbers, dates, times, and currency values. We’ll cover most
    of these topics in this chapter, but we’ll wait to discuss date and time formatting
    in [“Local Dates and Times”](#learnjava6-CHP-8-SECT-5.1).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 解析和格式化文本是一个庞大而开放的主题。到目前为止，在本章中，我们只研究了字符串的原始操作—创建、搜索和将简单值转换为字符串。现在我们想要转向更结构化的文本形式。Java有一套丰富的API用于解析和打印格式化的字符串，包括数字、日期、时间和货币值。我们将在本章中涵盖大多数这些主题，但我们将等待在[“本地日期和时间”](#learnjava6-CHP-8-SECT-5.1)中讨论日期和时间格式化。
- en: We’ll start with *parsing*—reading primitive numbers and values from strings,
    and chopping long strings into tokens. Then we’ll take a look at regular expressions,
    the most powerful text-parsing tool Java offers. Regular expressions let you define
    your own patterns of arbitrary complexity, search for them, and parse them from
    text.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将从*解析*开始—从字符串中读取原始数字和值，并将长字符串切割成标记。然后我们将看一下正则表达式，Java提供的最强大的文本解析工具。正则表达式允许您定义任意复杂度的模式，搜索它们并从文本中解析它们。 '
- en: Parsing Primitive Numbers
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析原始数字
- en: 'In Java, numbers, characters, and booleans are primitive types—not objects.
    But for each primitive type, Java also defines a *primitive wrapper* class. Specifically,
    the `java.lang` package includes the following classes: `Byte`, `Short`, `Integer`,
    `Long`, `Float`, `Double`, `Character`, and `Boolean`. We talked about these in
    [“Wrappers for Primitive Types”](ch05.html#learnjava6-CHP-5-SECT-2.6), but we
    bring them up now because these classes hold static utility methods that parse
    their respective types from strings. Each of these primitive wrapper classes has
    a static “parse” method that reads a `String` and returns the corresponding primitive
    type. For example:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，数字、字符和布尔值是原始类型—而不是对象。但是对于每种原始类型，Java还定义了一个*原始包装*类。具体来说，`java.lang`包包括以下类：`Byte`、`Short`、`Integer`、`Long`、`Float`、`Double`、`Character`和`Boolean`。我们在[“原始类型的包装器”](ch05.html#learnjava6-CHP-5-SECT-2.6)中谈到过这些，但我们现在提到它们是因为这些类包含了解析其各自类型的静态实用方法。每个这些原始包装类都有一个静态的“parse”方法，它读取一个`String`并返回相应的原始类型。例如：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can find other ways to convert from strings to base types and back again,
    but these wrapper class methods are straightforward and easy to read. And in the
    case of `Integer` and `Long`, you can also supply an optional *radix* argument
    (the base of a number system; decimal numbers have a radix of 10, for example)
    to convert strings with octal or hexadecimal numbers. (Nondecimal data sometimes
    pops up when dealing with things such as cryptographic signatures or email attachments.)
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以找到其他将字符串转换为基本类型并再次转换的方法，但这些包装类方法简单直接易于阅读。在`Integer`和`Long`的情况下，您还可以提供一个可选的*radix*参数（数字系统的基数；例如，十进制数字的基数为10）来转换带有八进制或十六进制数字的字符串。（处理诸如加密签名或电子邮件附件等内容时，非十进制数据有时会出现。）
- en: Tokenizing Text
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分词文本
- en: You’ll rarely encounter strings with just one number to parse or with only the
    word you need. It’s a more common programming task to parse a longer string of
    text into individual words, or *tokens*, that are separated by some set of *delimiter
    characters*, such as spaces or commas.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你很少会遇到只有一个数字要解析或只有你需要的单词的字符串。将长字符串解析为由一些*分隔符字符*（如空格或逗号）分隔的单个单词或*标记*是一项更常见的编程任务。
- en: Programmers talk about tokens as a generic way to discuss different values or
    types present in a piece of text. A token might be a simple word, a username,
    an email address, or a number. Let’s take a look at some examples.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员们谈论标记（tokens）作为讨论文本中不同值或类型的通用方式。标记可以是一个简单的单词，一个用户名，一个电子邮件地址或一个数字。让我们看几个例子。
- en: 'Consider the sample text below. The first line contains words separated by
    single spaces. The remaining pair of lines involves comma-delimited fields:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑下面的样本文本。第一行包含由单个空格分隔的单词。剩下的一对行包括以逗号分隔的字段：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Java has several (unfortunately overlapping) methods and classes for handling
    situations like this. We’ll use the powerful `split()` method from the `String`
    class. It utilizes regular expressions to allow you to break up a string based
    on arbitrary patterns. We’ll talk about regular expressions shortly, but to show
    you how this works, we’ll just give you the necessary magic now.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Java 有几种（不幸地重叠）处理此类情况的方法和类。我们将使用 `String` 类中强大的 `split()` 方法。它利用正则表达式允许你根据任意模式分割字符串。我们稍后会讨论正则表达式，但现在为了向你展示它是如何工作的，我们先告诉你必要的魔法。
- en: 'The `split()` method accepts a regular expression that describes a delimiter.
    It uses that expression to chop the string into an array of smaller `String`s:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`split()` 方法接受描述分隔符的正则表达式。它使用该表达式将字符串分割成一个较小的 `String` 数组：'
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the first example, we used the regular expression `\\s`, which matches a
    single whitespace character (space, tab, or carriage return). Calling `split()`
    on our `text1` variable returns an array of eight strings. In the second example,
    we used a more complicated regular expression, `\\s*,\\s*`, which matches a comma
    surrounded by any amount of optional whitespace. This reduced our text to three
    nice, tidy fields.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，我们使用了正则表达式 `\\s`，它匹配单个空白字符（空格、制表符或换行符）。在我们的 `text1` 变量上调用 `split()`
    返回一个包含八个字符串的数组。在第二个例子中，我们使用了一个更复杂的正则表达式 `\\s*,\\s*`，它匹配由任意量的可选空白字符包围的逗号。这将我们的文本减少为三个漂亮整洁的字段。
- en: Regular Expressions
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正则表达式
- en: Now it’s time to take a brief detour on our trip through Java and enter the
    land of *regular expressions*. A regular expression, or *regex* for short, describes
    a text pattern. Regular expressions are used with many tools—including the `java.util.regex`
    package, text editors, and many scripting languages—to provide sophisticated text-searching
    and string-manipulation capabilities.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候在我们通过 Java 的旅程中稍作停顿，进入 *正则表达式* 的领域了。正则表达式，简称 *regex*，描述了一个文本模式。正则表达式与许多工具一起使用——包括
    `java.util.regex` 包、文本编辑器和许多脚本语言——提供了复杂的文本搜索和字符串操作能力。
- en: Regular expressions can help you find all of the phone numbers in a large file.
    They can help you find all of the phone numbers with a particular area code. They
    can help you find all of the phone numbers that do *not* have a particular area
    code. You can use a regular expression to find links in the source of a web page.
    You can even use regular expressions to do some editing in a text file. You could
    look for phone numbers with the area code in parentheses, say (123) 456-7890,
    and replace it with the simpler 123-456-7890 format, for example. And key to the
    power of regular expressions, you can find *every* phone number in your block
    of text with parentheses and convert it—not just one specific phone number.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式可以帮助你在大文件中找到所有的电话号码。它们可以帮助你找到带有特定区号的所有电话号码。它们可以帮助你找到没有特定区号的所有电话号码。你可以使用正则表达式在网页源码中找到链接。甚至可以使用正则表达式在文本文件中进行一些编辑。例如，你可以查找带有括号区号的电话号码，如
    (123) 456-7890，并将其替换为更简单的 123-456-7890 格式。正则表达式的强大之处在于，你可以找到文本块中带有括号的 *每一个* 电话号码，并对其进行转换，而不仅仅是一个特定的电话号码。
- en: If you are already familiar with the concept of regular expressions and how
    they are used with other languages, you may wish to skim through this section,
    but don’t skip it entirely. At the very least, you’ll need to look at [“The java.util.regex
    API”](#learnjava6-CHP-8-SECT-3.2) later in this chapter, which covers the Java
    classes necessary to use them. If you’re wondering exactly what regular expressions
    are, then grab a can or a cup of your favorite beverage and get ready. You are
    about to learn about the most powerful tool in the arsenal of text manipulation,
    as well as a tiny language within a language, all in the span of a few pages.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经熟悉了正则表达式的概念以及它们如何与其他语言一起使用，你可能想要快速浏览一下这一部分，但不要完全跳过。至少，你需要稍后查看本章中的 [“The
    java.util.regex API”](#learnjava6-CHP-8-SECT-3.2)，它涵盖了使用它们所需的Java类。如果你想知道正则表达式到底是什么，那就准备好一罐或一杯你最喜欢的饮料吧。你将在几页之内了解到文本操作工具中最强大的工具，以及一种语言中的微小语言。
- en: Regex Notation
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正则表达式符号
- en: A regular expression (regex) describes a pattern in text. By *pattern*, we mean
    just about any feature you can imagine identifying in text from the literal characters
    alone, without actually understanding their meaning. This includes features such
    as words, word groupings, lines and paragraphs, punctuation, upper- or lowercase,
    and more generally, strings and numbers with a specific structure to them. (Think
    of things like phone numbers, email addresses, or zip codes.) With regular expressions,
    you can search the dictionary for all the words that have the letter “q” without
    its pal “u” next to it, or words that start and end with the same letter. Once
    you have constructed a pattern, you can use simple tools to hunt for it in text
    or to determine if a given string matches it.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式（regex）描述了文本中的模式。通过 *模式*，我们指的是几乎可以想象出的任何你可以单纯从文本中的文字了解的特征，而不必真正理解它们的含义。这包括诸如单词、单词组合、行和段落、标点、大写或小写，以及更一般地说，具有特定结构的字符串和数字。
    （想想电话号码、电子邮件地址或邮政编码之类的东西。）使用正则表达式，你可以搜索字典中所有包含字母“q”但其旁边没有它的“u”的单词，或者以相同字母开头和结尾的单词。一旦你构建了一个模式，你就可以使用简单的工具在文本中搜索它，或确定给定的字符串是否与之匹配。
- en: Write once, run away
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一次编写，一次逃避
- en: Regular expressions constitute a simple form of programming language. Think
    for a moment about the examples we cited earlier. We would need something like
    a language to describe even simple patterns—such as email addresses—that have
    common elements but also some variation in form.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式构成了一种简单的编程语言形式。想一想我们之前引用的例子。我们需要类似一种语言来描述甚至是简单模式——比如电子邮件地址——它们具有共同的元素但形式上也有些变化。
- en: A computer science textbook would classify regular expressions at the bottom
    of the hierarchy of computer languages, in terms of both what they can describe
    and what you can do with them. They are still capable of being quite sophisticated,
    however. As with most programming languages, the elements of regular expressions
    are simple, but you can combine them to create something quite complex. And that
    potential complexity is where things start to get sticky.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学教科书会将正则表达式分类为计算机语言的底层，无论是从它们能描述的内容还是你可以用它们做什么来看。但是，它们仍然有可能非常复杂。与大多数编程语言一样，正则表达式的元素很简单，但你可以将它们组合起来创建一些相当复杂的东西。而这种潜在的复杂性正是事情开始变得棘手的地方。
- en: Since regexes work on strings, which can be found everywhere in Java code, it
    is convenient to have a very compact notation. But compact notation can be cryptic,
    and experience shows that it is much easier to write a complex statement than
    to read it again later. Such is the curse of the regular expression. You may find
    yourself in a moment of late-night, caffeine-fueled inspiration, writing a single
    glorious pattern to simplify the rest of your program down to one line. When you
    return to read that line the next day, however, it may look like Egyptian hieroglyphics
    to you. Simpler is generally better, but if you can break your problem more clearly
    into several steps, maybe you should.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 由于正则表达式适用于字符串，而Java代码中的字符串无处不在，因此具有非常紧凑的表示法是很方便的。但紧凑的表示法可能很神秘，经验表明，编写一个复杂的语句要比稍后再次阅读它要容易得多。这就是正则表达式的诅咒。你可能会发现自己在一个深夜、咖啡因推动的灵感时刻，写下一个辉煌的模式来简化你程序的其余部分到一行。然而，当你第二天回来阅读这一行时，它可能对你来说就像埃及象形文字一样难以理解。更简单通常更好，但如果你能更清晰地将问题分解为几个步骤，也许你应该这样做。
- en: Escaped characters
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转义字符
- en: 'Now that you’ve been properly warned, we have to throw one more thing at you
    before we build you back up. Not only can the regex notation get a little hairy,
    but it is also somewhat ambiguous when used with ordinary Java strings. An important
    part of the notation is the escaped character—a character with a backslash in
    front of it. For example, in regex notation, the escaped `d` character, `\d`,
    (backslash “d”) is a shorthand for any single digit character (0–9). However,
    you cannot simply write `\d` as part of a Java string, because Java uses the backslash
    for its own special characters and to specify Unicode character sequences (`\uxxxx`).
    Fortunately, Java gives us a replacement: an *escaped backslash*: two backslashes
    (`\\`). It represents a literal backslash. The rule is, when you want a backslash
    to appear in your regex, you must escape it with an extra one:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经得到了适当的警告，在我们重建您之前，我们还需要介绍一件事情。正则表达式的表示法不仅可能有些复杂，而且在普通的Java字符串中使用时也有些模糊。表示法的一个重要部分是转义字符——带有反斜杠的字符。例如，在正则表达式表示法中，转义字符`\d`（反斜杠“d”）是任意单个数字字符（0-9）的缩写。然而，您不能简单地在Java字符串中写`\d`，因为Java使用反斜杠来表示自己的特殊字符和指定Unicode字符序列（`\uxxxx`）。幸运的是，Java给了我们一个替代方案：*转义的反斜杠*：两个反斜杠（`\\`）。它代表一个字面上的反斜杠。规则是，当您希望在正则表达式中出现反斜杠时，必须用额外的一个反斜杠对其进行转义：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'It gets weirder! Because regex notation itself uses a backslash to denote special
    characters, it must provide the same “escape hatch” for itself. You need to double
    up backslashes if you want your regex to match a literal backslash. It looks like
    this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 它变得更加奇怪了！因为正则表达式表示法本身使用反斜杠来表示特殊字符，所以它必须为自己提供相同的“逃逸舱口”。如果您希望您的正则表达式匹配一个字面上的反斜杠，您需要双倍反斜杠。它看起来像这样：
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Most of the “magic” operator characters in this section operate on the character
    that precedes them, so you must escape them if you want their literal meaning.
    This includes such characters as `.`, `*`, `+`, `{}`, and `()`. An expression
    that can match formal US phone numbers (with the area code inside a pair of parentheses)
    looks like this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中大多数“魔术”运算符字符都作用于它们之前的字符，所以如果要保留它们的字面意义，就必须对它们进行转义。这些字符包括`.`、`*`、`+`、`{}`和`()`。一个可以匹配标准美国电话号码（带有括号内的区号）的表达式看起来是这样的：
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If you need to create part of an expression that has lots of literal characters
    in it, you can use the special delimiters `\Q` and `\E` to help you. Any text
    appearing between `\Q` and `\E` is automatically escaped. (You still need the
    Java `String` escapes—double backslashes for backslash, but not quadruple.) There
    is also a static method called `Pattern.quote()` that does the same thing, returning
    a properly escaped version of whatever string you give it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要创建一个表达式的一部分，其中包含许多字面上的字符，您可以使用特殊的分隔符`\Q`和`\E`来帮助您。出现在`\Q`和`\E`之间的任何文本都会自动转义。
    （您仍然需要Java的`String`转义——对于反斜杠，双反斜杠，但不是四倍。）还有一个名为`Pattern.quote()`的静态方法，它执行相同的操作，返回您给定字符串的正确转义版本。
- en: 'We have one more suggestion to help maintain your cool when working with these
    examples. Write out the plain regex using a comment line above the real Java string
    (where you must double up all backslashes). We also tend to include a comment
    with an example of the text we hope to match. Here’s that US phone number example
    again with this commenting approach:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在处理这些示例时，我们还有一个建议可以帮助您保持冷静。在实际的Java字符串（在其中必须加倍所有反斜杠）上面写出纯正则表达式，我们也倾向于在其中包含一个带有希望匹配的文本示例的注释。这里再次是带有这种注释方法的美国电话号码示例：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: And don’t forget about *jshell*! It can be a very powerful playground for testing
    and tweaking your patterns. We’ll see several examples of testing patterns with
    *jshell* in [“The java.util.regex API”](#learnjava6-CHP-8-SECT-3.2). But first,
    let’s look at more of the elements you can use to construct patterns.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 还有别忘了*jshell*！它可以是一个非常强大的测试和调整模式的场所。我们将在[“java.util.regex API”](https://learnjava6-CHP-8-SECT-3.2)中看到几个在*jshell*中测试模式的例子。但首先，让我们看看更多可以用来构造模式的元素。
- en: Characters and character classes
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符和字符类
- en: 'Now, let’s dive into the actual regex syntax. The simplest form of a regular
    expression is plain, literal text, which has no special meaning and is matched
    directly (character for character) in the input. This can be a single character
    or more. For example, in the following string, the pattern `s` can match the character
    “s” in the words “rose” and “is”:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解实际的正则表达式语法。正则表达式的最简单形式是纯文本，它没有特殊含义，直接（逐个字符）与输入匹配。这可以是一个或多个字符。例如，在下面的字符串中，模式`s`可以匹配单词“rose”和“is”中的字符“s”：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The pattern “rose” can match only the literal word `rose`. But this isn’t very
    interesting. Let’s crank things up a notch by introducing some special characters
    and the notion of character “classes”:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 模式“rose”只能匹配字面上的单词 `rose`。但这并不是非常有趣。我们通过引入一些特殊字符和字符“类”的概念来提高一点难度：
- en: '*Any character: dot* (`.`)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*任何字符：点*（`.`）'
- en: The special character dot (`.`) matches any single character. The pattern `.ose`
    matches “rose,” “nose,” “_ose” (space followed by “ose”), or any other character
    followed by the sequence “ose.” Two dots match any two characters (“prose,” “close”),
    and so on. The dot operator is very broad; it normally stops only for a *line
    terminator* (a newline, carriage return, or combination of both). Think of `.`
    as representing the class of all characters.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊字符点 (`.`) 匹配任何单个字符。模式 `.ose` 匹配“rose”、“nose”、“_ose”（空格后跟“ose”），或者任何其他字符后跟序列“ose”。两个点匹配任何两个字符（“prose”、“close”），依此类推。点操作符非常广泛；通常仅在*行终止符*（换行符、回车符或两者的组合）时停止。将
    `.` 视为表示所有字符的类。
- en: '*Whitespace or nonwhitespace character:* `\s`, `\S`'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*空白或非空白字符：*`\s`, `\S`'
- en: The special character `\s` matches whitespace. *Whitespace* includes any character
    that relates to visual space in text or that marks the end of a line. Common whitespace
    characters include the literal space character (what you get when you press the
    space bar on your keyboard), `\t` (tab), `\r` (carriage return), `\n` (newline),
    and `\f` (formfeed). The corresponding special character `\S` does the inverse,
    matching any character that is *not* whitespace.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊字符 `\s` 匹配空白字符。*空白字符*包括与文本中的视觉空间相关的任何字符，或标记行尾的字符。常见的空白字符包括文字空格字符（按键盘空格键时得到的内容）、`\t`（制表符）、`\r`（回车符）、`\n`（换行符）和
    `\f`（换页符）。对应的特殊字符 `\S` 则相反，匹配*非*空白字符。
- en: '*Digit or nondigit character*: `\d`, `\D`'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*数字或非数字字符*：`\d`, `\D`'
- en: '`\d` matches any of the digits from 0 to 9\. `\D` does the inverse, matching
    all characters except digits.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`\d` 匹配从 0 到 9 的任何数字。`\D` 则相反，匹配除数字外的所有字符。'
- en: '*Word or nonword character*: `\w`, `\W`'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*字母或非字母字符*：`\w`, `\W`'
- en: '`\w` matches characters typically found in “words,” such as upper- and lowercase
    letters A–Z, a–z, the digits 0–9, and the underscore character (_). `\W` matches
    everything except those characters.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`\w` 匹配通常在“单词”中找到的字符，例如大写和小写字母 A–Z，a–z，数字 0–9 和下划线字符 (_)。`\W` 匹配除这些字符以外的所有内容。'
- en: Custom character classes
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义字符类
- en: 'You can define your own character classes using square brackets (`[ ]`) around
    the characters you want. Here are some examples:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用方括号 (`[ ]`) 定义自己的字符类，包围您想要的字符。以下是一些示例：
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The special `x-y` *range notation* can be used as shorthand for consecutive
    runs of alphanumeric characters:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊 `x-y` *范围表示法* 可以用作连续运行的字母数字字符的简写：
- en: '[PRE26]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Placing a caret (`^`) as the first character inside the brackets inverts the
    character class, matching any character *except* those included in the brackets:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在方括号内将插入符号 (`^`) 作为第一个字符会反转字符类，匹配除了方括号中包括的字符以外的任何字符：
- en: '[PRE27]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Nesting character classes simply concatenates them into a single class:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套字符类简单地将它们连接成一个单一的类：
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You can use the `&&` logical AND notation (similar to the Boolean operator
    we saw in [“Operators”](ch04.html#learnjava6-CHP-4-SECT-5.2.1)) to take the *intersection*
    (characters in common):'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `&&` 逻辑 AND 表示法（类似于我们在 [“运算符”](https://example.org/operators) 中看到的布尔运算符）来取*交集*（共同的字符）：
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Position markers
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 位置标记
- en: 'The pattern `[Aa] rose` (including an upper- or lowercase A) matches three
    times in the following phrase:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 模式 `[Aa] rose`（包括大写或小写字母 A）在以下短语中匹配三次：
- en: '[PRE30]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Position characters allow you to designate the relative location of a match
    within a line. The most important are `^` and `$`, which match the beginning and
    end of a line, respectively:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 位置字符允许您指定匹配在行内的相对位置。最重要的是 `^` 和 `$`，分别匹配行的开头和结尾：
- en: '[PRE31]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: To be a little more precise, `^` and `$` match the beginning and end of “input,”
    which is usually a single line. If you are working with multiple lines of text
    and wish to match the beginnings and endings of lines within a single large string,
    you can turn on “multiline” mode with a flag, as described later in [“Special
    options”](#learnjava6-CHP-8-SECT-3.1.8).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要更加精确一些，`^` 和 `$` 匹配“输入”的开头和结尾，通常这是单行。如果您处理多行文本，并希望匹配单个大字符串内行的开头和结尾，可以通过标志打开“多行”模式，如后面在
    [“特殊选项”](https://example.org/special_options) 中描述。
- en: 'The position markers `\b` and `\B` match a word boundary (whitespace, punctuation,
    or the beginning or end of a line), or a nonword boundary (the middle of a word),
    respectively. For example, the first pattern matches “rose” and “rosemary,” but
    not “primrose.” The second pattern matches “primrose” and “prose,” but not “rose”
    at the beginning of a word or by itself:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 位置标记符`\b`和`\B`匹配单词边界（空格、标点或行的开头或结尾），或非单词边界（单词的中间），分别如下。例如，第一个模式匹配“rose”和“rosemary”，但不匹配“primrose”。第二个模式匹配“primrose”和“prose”，但不匹配单词开头的“rose”或独立的“rose”：
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You often use these position markers when you need to look for or exclude prefixes
    or suffixes.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要查找或排除前缀或后缀时，通常使用这些位置标记符。
- en: Iteration (multiplicity)
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 迭代（多重性）
- en: 'Simply matching fixed-character patterns will not get us very far. Next, we
    look at operators that count the number of occurrences of a character (or more
    generally, of a pattern, as we’ll see in [“Pattern”](#learnjava6-CHP-8-SECT-3.2.1)):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地匹配固定字符模式将无法使我们走得更远。接下来，我们看一下可以计数字符（或更一般地说，模式的出现次数，正如我们将在[“模式”](#learnjava6-CHP-8-SECT-3.2.1)中看到的那样）的操作符。
- en: '*Any (zero or more iterations): asterisk* (`*`)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*任意（零个或多个迭代）：星号*（`*`）'
- en: 'Placing an asterisk (*) after a character or character class means “allow any
    number of that type of character”—in other words, zero or more. For example, the
    following pattern matches a digit with any number of leading zeros (possibly none):'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在字符或字符类之后放置星号（`*`）表示“允许任意数量的该类型字符”——换句话说，零个或更多。例如，下面的模式匹配具有任意数量前导零的数字（可能没有）：
- en: '[PRE33]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '*Some (one or more iterations): plus sign* (`+`)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*一些（一个或多个迭代）：加号* (`+`)'
- en: 'The plus sign (+) means “one or more” iterations and is equivalent to XX* (pattern
    followed by pattern asterisk). For example, the following pattern matches a number
    with one or more digits, plus optional leading zeros:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 加号（+）表示“一个或多个”迭代，等同于XX*（模式后跟模式星号）。例如，下面的模式匹配一个带有一个或多个数字的数字，加上可选的前导零：
- en: '[PRE34]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: It may seem redundant to match the zeros at the beginning of an expression because
    zero is a digit and is thus matched by the `\d+` portion of the expression anyway.
    However, we’ll show later how you can pick apart the string using a regex and
    get at just the pieces you want. In this case, you might want to strip off the
    leading zeros and keep only the digits.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在表达式开头匹配零似乎是多余的，因为零是一个数字，因此会被表达式中`\d+`部分匹配。然而，稍后我们将展示如何使用正则表达式分析字符串并仅获取想要的部分。在这种情况下，您可能希望去掉前导零，只保留数字。
- en: '*Optional (zero or one iteration): question mark* (`?`)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*可选（零个或一次迭代）：问号*（`?`）'
- en: 'The question mark operator (`?`) allows exactly zero or one iteration. For
    example, the following pattern matches a credit card expiration date, which may
    or may not have a slash in the middle:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 问号操作符（`?`）允许零次或一次迭代。例如，下面的模式匹配信用卡过期日期，中间可能有或可能没有斜杠：
- en: '[PRE35]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '*Range (between x and y iterations, inclusive)*: `{x,y}`'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*范围（介于x和y次迭代之间，包括x和y）*：`{x,y}`'
- en: 'The `{x,y}` curly brace range operator is the most general iteration operator.
    It specifies a precise range to match. A range takes two arguments: a lower bound
    and an upper bound, separated by a comma. This regex matches any word with five
    to seven characters, inclusive:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`{x,y}` 花括号范围运算符是最常见的迭代运算符。它指定一个精确的匹配范围。一个范围接受两个参数：一个下界和一个上界，用逗号分隔。这个正则表达式匹配任何具有五到七个字符的单词：'
- en: '[PRE36]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '*At least x or more iterations (y is infinite)*: `{x,}`'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*至少x次或更多次迭代（y是无穷大）*：`{x,}`'
- en: If you omit the upper bound, simply leaving a dangling comma in the range, the
    upper bound becomes infinite. This is a way to specify a minimum of occurrences
    with no maximum.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略上界，只留下范围中的悬挂逗号，上界将变为无限大。这是指定具有无最大次数的最小出现次数的方法。
- en: Alternation
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 替换
- en: 'The vertical bar (`|`) operator denotes the logical OR operation, also called
    *alternation* or *choice*. The `|` operator does not operate on individual characters
    but instead applies to everything on either side of it. It splits the expression
    in two unless constrained by parentheses grouping. For example, a slightly naive
    approach to parsing dates might be the following:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 竖线（`|`）操作符表示逻辑OR操作，也称为*替换*或*选择*。`|`操作符不操作单个字符，而是应用于其两侧的所有内容。它将表达式分成两部分，除非受到括号分组的限制。例如，对解析日期的稍微天真的方法可能如下所示：
- en: '[PRE37]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this expression, the left matches patterns such as “Fri, Oct 12, 2001,” and
    the right matches “10/12/01.”
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个表达式中，左侧匹配诸如“Fri, Oct 12, 2001,” 这样的模式，右侧匹配“10/12/01”。
- en: 'The following regex might be used to match email addresses with one of three
    domains (*net*, *edu*, and *gov*):'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 以下正则表达式可能用于匹配具有*net*、*edu*和*gov*三个域名中的电子邮件地址之一：
- en: '[PRE38]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This pattern is by no means complete in terms of true, valid email addresses.
    But it does highlight how you can use alternation to help build regular expressions
    with some useful characteristics.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式在真实有效的电子邮件地址方面并不完整。但它确实突显了如何使用交替来构建具有一些有用特性的正则表达式。
- en: Special options
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 特殊选项
- en: 'Several special options affect the way the regex engine performs its matching.
    These options can be applied in two ways:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 几个特殊选项会影响正则表达式引擎的匹配方式。这些选项可以通过两种方式应用：
- en: You can supply one or more special arguments (flags) to the `Pattern.compile()`
    step (discussed in [“The java.util.regex API”](#learnjava6-CHP-8-SECT-3.2)).
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在`Pattern.compile()`步骤中提供一个或多个特殊参数（标志）（见[“java.util.regex API”](#learnjava6-CHP-8-SECT-3.2)）。
- en: You can include a special block of code in your regex.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在你的正则表达式中包含一个特殊的代码块。
- en: We’ll show the latter approach here. To do this, include one or more flags in
    a special block `(?`*`x`*`)`, where *`x`* is the flag for the option we want to
    turn on. Generally, you do this at the beginning of the regex. You can also turn
    off flags by adding a minus sign `(?-`*`x`*`)`, which allows you to apply flags
    to select parts of your pattern.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里展示后一种方法。为此，在一个特殊块`(?`*`x`*`)`中包含一个或多个标志，其中*`x`*是我们想要打开选项的标志。通常，你在正则表达式的开头这样做。你也可以通过添加减号来关闭标志`(?-`*`x`*`)`，这允许你对模式的部分区域应用标志。
- en: 'The following flags are available:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 可用以下标志：
- en: '*Case-insensitive*: `(?i)`'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '*不区分大小写*：`(?i)`'
- en: 'The `(?i)` flag tells the regex engine to ignore character case while matching.
    For example:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`(?i)`标志告诉正则表达式引擎在匹配时忽略字符大小写。例如：'
- en: '[PRE39]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '*Dot all*: `(?s)`'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*点全部*：`(?s)`'
- en: The `(?s)` flag turns on “dot all” mode, allowing the dot character to match
    anything, including end-of-line characters. It is useful if you are matching patterns
    that span multiple lines. The `s` stands for “single-line mode,” a somewhat confusing
    name derived from Perl.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`(?s)`标志打开了“点任意”模式，允许点字符匹配任何内容，包括行尾字符。如果你要匹配跨多行的模式，这很有用。`s`代表“单行模式”，这个名字有点令人困惑，来源于Perl。'
- en: '*Multiline*: `(?m)`'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '*多行模式*：`(?m)`'
- en: By default, `^` and `$` don’t really match the beginnings and ends of lines
    (as defined by carriage return or newline combinations). Instead, they match the
    beginning or end of the entire input text. In many cases, “one line” is synonymous
    with the entire input.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`^`和`$`实际上不匹配行的开头和结尾（由回车或换行符组合定义）。相反，它们匹配整个输入文本的开头或结尾。在许多情况下，“一行”与整个输入是同义的。
- en: If you have a big block of text to process, you’ll often break that block into
    separate lines for other reasons. If you do that, checking any given line for
    a regular expression will be straightforward, and `^` and `$` will behave as expected.
    However, if you want to use a regex with the entire input string containing multiple
    lines (separated by those carriage return or newline combinations), you can turn
    on multiline mode with `(?m)`. This flag causes `^` and `$` to match the beginning
    and end of the individual lines *within* the block of text, *as well as* the beginning
    and end of the entire block. Specifically, this means the spot before the first
    character, the spot after the last character, and the spots just before and after
    line terminators inside the string.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个大文本块需要处理，通常会出于其他原因将该块分成单独的行。如果你这样做，检查给定行是否符合正则表达式将会很简单，并且`^`和`$`将会按预期行为。然而，如果你想要在包含多行的整个输入字符串上使用正则表达式（由那些回车或换行符组合分隔），你可以打开多行模式`(?m)`。此标志导致`^`和`$`匹配文本块内单个行的开头和结尾，*以及*整个块的开头和结尾。具体来说，这意味着第一个字符之前的位置，最后一个字符之后的位置，以及字符串内的行终止符之前和之后的位置。
- en: '*Unix lines*: `(?d)`'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '*Unix行*：`(?d)`'
- en: The `(?d)` flag limits the definition of the line terminator for the `^`, `$`,
    and `.` special characters to Unix-style newline only (`\n`). By default, carriage
    return newline (`\r\n`) is also allowed.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`(?d)`标志将`^`、`$`和`.`特殊字符的行终止符定义限制为仅Unix风格的换行符（`\n`）。默认情况下，也允许回车换行符（`\r\n`）。'
- en: The java.util.regex API
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: java.util.regex API
- en: Now that we’ve covered the theory of how to construct regular expressions, the
    hard part is over. All that’s left is to investigate the Java API to see how to
    apply these expressions.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了如何构建正则表达式的理论部分，困难的部分已经过去了。剩下的就是调查Java API，看看如何应用这些表达式。
- en: Pattern
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模式
- en: As we’ve said, the regex patterns that we write as strings are, in actuality,
    little programs describing how to match text. At runtime, the Java regex package
    compiles these little programs into a form that it can execute against some target
    text. Several simple convenience methods accept strings directly to use as patterns.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说，我们写成字符串形式的正则表达式模式实际上是描述如何匹配文本的小程序。在运行时，Java正则表达式包将这些小程序编译成一种可以针对某个目标文本执行的形式。几个简单的便捷方法直接接受字符串以用作模式。
- en: 'The static method `Pattern.matches()` takes two strings—a regex and a target
    string—and determines if the target matches the regex. This is very convenient
    if you want to do a quick test once in your application. For example:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法`Pattern.matches()`接受两个字符串——一个正则表达式和一个目标字符串——并确定目标是否与正则表达式匹配。如果您想在应用程序中进行快速测试，这非常方便。例如：
- en: '[PRE40]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This line of code can test whether the string `myText` contains a Java-style
    floating-point number such as “42.0f.” Note that the string must match completely
    to be considered a match. If you want to see if a small pattern is contained within
    a larger string but don’t care about the rest of the string, you have to use a
    `Matcher`, as described in [“The Matcher”](#learnjava6-CHP-8-SECT-3.2.2).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码可以测试字符串`myText`是否包含类似“42.0f.”这样的Java风格浮点数。请注意，字符串必须完全匹配才能被认为是匹配的。如果你想查看一个小模式是否包含在较大的字符串中，但不关心字符串的其余部分，你必须使用`Matcher`，如[“Matcher”](#learnjava6-CHP-8-SECT-3.2.2)中所述。
- en: Let’s try another (simplified) pattern that we could use in our game once we
    start letting multiple players compete against each other. Many login systems
    use email addresses as the user identifier. Such systems aren’t perfect, of course,
    but an email address will work for our needs. We would like to invite users to
    input their email address, but we want to make sure it looks valid before using
    it. A regular expression can be a quick way to perform such a validation.^([3](ch08.html#id1659))
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试另一个（简化的）模式，一旦我们开始让多个玩家相互竞争，我们可以在我们的游戏中使用。许多登录系统使用电子邮件地址作为用户标识符。当然，这样的系统并不完美，但电子邮件地址将符合我们的需求。我们希望邀请用户输入他们的电子邮件地址，但在使用之前，我们希望确保它看起来是有效的。正则表达式可以快速进行这样的验证[^3]。
- en: 'Much like writing algorithms to solve programming problems, designing a regular
    expression requires you to break your pattern matching problem into bite-sized
    pieces. If we think about email addresses, a few patterns stand out right away.
    The most obvious is the `@` in the middle of every address. A naive (but better
    than nothing!) pattern relying on that fact could be built like this:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 就像编写算法来解决编程问题一样，设计正则表达式需要您将模式匹配问题分解为易于处理的部分。如果我们考虑电子邮件地址，几个模式立即显而易见。最明显的是每个地址中间的`@`符号。依赖于这个事实的一个天真（但比没有好！）的模式可以构建如下：
- en: '[PRE41]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'But that pattern is too permissive. It will certainly recognize valid email
    addresses, but it will also recognize many invalid ones like `"bad.address@"`
    or `"@also.bad"` or even `"@@"`. Let’s test these out in *jshell*:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 但这个模式太宽容了。它确实能够识别有效的电子邮件地址，但也会识别许多无效的地址，比如`"bad.address@"`或`"@also.bad"`甚至`"@@"`。让我们在*jshell*中测试一下：
- en: '[PRE42]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Try to cook up a few more bad examples of your own. You’ll quickly see that
    our simple email pattern is definitely too simple.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 试着自己制造一些更糟糕的例子。你很快就会发现，我们简单的电子邮件模式确实太简单了。
- en: 'How can we make better matches? One quick adjustment would be to use the `+`
    modifier instead of the `*`. The upgraded pattern now requires at least one character
    on each side of the `@`. But we know a few other things about email addresses.
    For example, the left “half” of the address (the name portion) cannot contain
    the `@` character. For that matter, neither can the domain portion. We can use
    a custom character class for this next upgrade:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何做出更好的匹配？一个快速的调整是使用`+`修饰符而不是`*`。升级后的模式现在要求`@`符号两边至少有一个字符。但我们对电子邮件地址还了解其他一些情况。例如，地址的左半部分（名称部分）不能包含`@`字符。同样，域部分也不能包含。对于这种下一个升级，我们可以使用自定义字符类：
- en: '[PRE43]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This pattern is better but still allows several invalid addresses such as `"still@bad"`
    since domain names have at least a name followed by a period (`.`) followed by
    a top-level domain (TLD) such as “oreilly.com.” So maybe a pattern like this:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式更好一些，但仍然允许一些无效地址，比如`"still@bad"`，因为域名至少有一个名称，后面跟着一个点(`.`)，然后是顶级域(TLD)，比如“oreilly.com.”
    所以也许可以像这样设置一个模式：
- en: '[PRE44]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'That pattern fixes our issue with an address like `"still@bad"`, but we’ve
    gone a bit too far the other way. There are many, many TLDs—too many to reasonably
    list even if we ignore the problem of maintaining that list as new TLDs are added.^([4](ch08.html#id1660))
    So let’s step back a little. We’ll keep the “dot” in the domain portion, but remove
    the specific TLD and just accept a simple run of letters:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 那个模式修复了我们在像`"still@bad"`这样的地址上的问题，但我们可能有点过火了。有许多、许多顶级域名后缀 —— 即使我们忽略了随着新的顶级域名后缀的添加而保持该列表的问题，也无法合理地列出所有顶级域名后缀。^([4](ch08.html#id1660))
    所以让我们稍微退一步。我们会保留域名部分的“点”，但移除特定的顶级域名后缀，只接受简单的字母序列：
- en: '[PRE45]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Much better. We can add one last tweak to make sure we don’t worry about the
    case of the address since all email addresses are case-insensitive. Just tack
    on the `(?i)` flag at the beginning of our pattern string:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 好多了。我们可以添加最后一个微调，以确保我们不用担心地址的大小写，因为所有电子邮件地址都是不区分大小写的。只需在我们的模式字符串的开头添加`(?i)`标志即可：
- en: '[PRE46]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Again, this is by no means a perfect email validator, but it is definitely
    a good start and suffices for our hypothetical login system:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这绝不是一个完美的电子邮件验证器，但它绝对是一个很好的开始，足以满足我们虚拟的登录系统的需求：
- en: '[PRE47]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In these examples, we typed in the full `Pattern.matches(…​)` line only once.
    After that it was a simple up arrow, edit, and then hit Return for the subsequent
    five lines. Can you spot the flaw in our final pattern that causes the match to
    fail?
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些例子中，我们只需一次输入完整的`Pattern.matches(…​)`行。之后只需简单地按向上箭头、编辑，然后按回车键即可获取接下来的五行。你能找出我们最终模式中导致匹配失败的缺陷吗？
- en: Note
  id: totrans-227
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to tinker around with the validation pattern and expand or improve
    it, remember you can “reuse” lines in *jshell* with the keyboard arrow keys. Use
    the up arrow to retrieve the previous line. Indeed, you can use the up arrow and
    down arrow to navigate all of your recent lines. Within a line, use the left arrow
    and right arrow to move around and delete/add/edit your command. Then just press
    the Return key to run the newly altered command—you do not need to move the cursor
    to the end of the line before pressing Return.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想调整验证模式并进行扩展或改进，请记住你可以使用键盘的上箭头在*jshell*中“重复使用”行。使用向上箭头检索前一行。确实，你可以使用上箭头和下箭头来导航你最近的所有行。在一行内，使用左箭头和右箭头移动、删除、添加或编辑你的命令。然后只需按回车键运行新修改的命令
    —— 你不需要在按回车键之前将光标移动到行尾。
- en: The Matcher
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Matcher`'
- en: A `Matcher` associates a pattern with a string and provides tools for testing,
    finding, and iterating over matches of the pattern against it. The `Matcher` is
    “stateful.” For example, the `find()` method tries to find the next match each
    time it is called. But you can clear the `Matcher` and start over by calling its
    `reset()` method.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`Matcher`关联模式与字符串，并提供测试、查找和迭代匹配项的工具。`Matcher`是“有状态的”。例如，`find()`方法每次调用时都会尝试找到下一个匹配项。但你可以通过调用其`reset()`方法来清除`Matcher`并重新开始。'
- en: 'To create a `Matcher` object, you first need to compile your pattern string
    into a `Pattern` object using the static `Pattern.compile()` method. With that
    pattern object in hand, you can use the `matcher()` method to get your `Matcher`,
    like so:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个`Matcher`对象，首先需要使用静态的`Pattern.compile()`方法将模式字符串编译成一个`Pattern`对象。有了该模式对象后，你可以使用`matcher()`方法获取你的`Matcher`，如下所示：
- en: '[PRE48]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: If you’re just interested in “one big match”—that is, you’re expecting your
    string to either match the pattern or not—you can use `matches()` or `lookingAt()`.
    These correspond roughly to the methods `equals()` and `startsWith()` of the `String`
    class. The `matches()` method asks if the string matches the pattern in its entirety
    (with no string characters left over) and returns `true` or `false`. The `lookingAt()`
    method does the same, except that it asks only whether the string starts with
    the pattern and doesn’t care if the pattern uses up all the string’s characters.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只对“一次大匹配”感兴趣 —— 也就是说，你期望你的字符串要么与模式匹配要么不匹配 —— 你可以使用`matches()`或`lookingAt()`。这些方法大致对应于`String`类的`equals()`和`startsWith()`方法。`matches()`方法询问字符串是否完全匹配模式（没有多余的字符串字符）并返回`true`或`false`。`lookingAt()`方法做同样的事情，只是它只询问字符串是否以该模式开头，并不在乎模式是否使用完所有字符串的字符。
- en: 'More generally, you’ll want to be able to search through the string and find
    one or more matches. To do this, you can use the `find()` method. Each call to
    `find()` returns `true` or `false` for the next match of the pattern and internally
    notes the position of the matching text. You can get the starting and ending character
    positions with the `Matcher start()` and `end()` methods, or you can simply retrieve
    the matched text with the `group()` method. For example:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 更普遍地，您希望能够搜索字符串并找到一个或多个匹配项。为此，可以使用`find()`方法。每次调用`find()`返回模式的下一个匹配项的`true`或`false`，并在内部记录匹配文本的位置。您可以使用`Matcher
    start()`和`end()`方法获取匹配文本的起始和结束字符位置，或者简单地使用`group()`方法检索匹配的文本。例如：
- en: '[PRE49]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The previous snippet prints the starting location of the words “horse” and
    “course” (four in all):'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段打印了单词“horse”和“course”的起始位置（总共四个）：
- en: '[PRE50]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Splitting strings
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串拆分
- en: 'A very common need is to parse a string into a bunch of fields based on some
    delimiter, such as a comma. It’s such a common problem that the `String` class
    contains a method for doing just this. The `split()` method accepts a regular
    expression and returns an array of substrings broken around that pattern. Consider
    the following string and `split()` calls:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 非常常见的需求是根据某个分隔符（例如逗号）将字符串解析为一堆字段。这是一个如此常见的问题，以至于`String`类中包含了一个专门用于此目的的方法。`split()`方法接受一个正则表达式，并返回围绕该模式分割的子字符串数组。考虑以下字符串和`split()`调用：
- en: '[PRE51]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The first `split()` returns a `String` array, but the naive use of `,` to separate
    the string means the space characters in our `text` variable remain stuck to the
    more interesting characters. We get `“Foo”` as a single word, as expected, but
    then we get `“bar<space>”` and finally `“<space><space><space>blah”`. Yikes! The
    second `split()` also yields a `String` array, but this time containing the expected
    `“Foo”, “bar”` (with no trailing space), and `“blah”` (with no leading spaces).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`split()`返回一个`String`数组，但是使用逗号进行简单分隔的结果意味着我们的`text`变量中的空格字符仍然粘在更有趣的字符上。我们得到了`“Foo”`作为一个单词，正如预期的那样，但接着我们得到了`“bar<space>”`，最后是`“<space><space><space>blah”`。哎呀！第二个`split()`也产生一个`String`数组，但这次包含了预期的`“Foo”,
    “bar”`（没有尾随空格），和`“blah”`（没有前导空格）。
- en: 'If you are going to use an operation like this more than a few times in your
    code, you should probably compile the pattern and use its `split()` method, which
    is identical to the version in `String`. The `String split()` method is equivalent
    to:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在代码中要多次使用这样的操作，你应该编译模式并使用它的`split()`方法，该方法与`String`中的版本相同。`String split()`方法等同于：
- en: '[PRE52]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: As we noted before, there is a lot to learn about regular expressions above
    and beyond the few regex capabilities we covered here. Check out the [documentation
    on patterns](https://oreil.ly/L8BUD). Play around on your own using *jshell*.
    Modify the *ch08/examples/ValidEmail.java* file and see if you can create a better
    email validator! This is definitely a topic that benefits from practice.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，关于正则表达式的知识远远超出了我们在这里介绍的几个正则表达式功能。查看[模式文档](https://oreil.ly/L8BUD)。在自己的*jshell*上玩耍。修改*ch08/examples/ValidEmail.java*文件，看看能否创建更好的电子邮件验证器！这绝对是一个需要实践的主题。
- en: Math Utilities
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数学工具
- en: Of course, string manipulation and pattern matching are not the only types of
    operations Java can do. Java supports integer and floating-point arithmetic directly
    in the language. Higher-level math operations are supported through the `java.lang.Math`
    class. As you have seen, wrapper classes for primitive data types allow you to
    treat them as objects. Wrapper classes also hold some methods for basic conversions.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，字符串操作和模式匹配并不是Java唯一能做的操作。Java直接支持整数和浮点数算术。通过`java.lang.Math`类支持更高级别的数学运算。正如您所见，基本数据类型的包装类允许您将它们视为对象处理。包装类还包含一些基本转换的方法。
- en: 'Let’s start with a quick look at the built-in arithmetic in Java. Java handles
    errors in integer arithmetic by throwing an `ArithmeticException`:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速浏览一下Java中的内置算术功能。Java通过抛出`ArithmeticException`来处理整数算术中的错误：
- en: '[PRE53]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: To generate the error in this example, we created the intermediate variable
    `zero`. The compiler is somewhat crafty. It would have caught us if we had tried
    to divide by `0` directly.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 要在这个示例中生成错误，我们创建了中间变量`zero`。编译器有点狡猾。如果我们直接尝试除以`0`，它会抓住我们。
- en: Floating-point arithmetic expressions, on the other hand, don’t throw exceptions.
    Instead, they take on the special out-of-range values shown in [Table 8-2](#learnjava6-CHP-8-TABLE-2).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，浮点算术表达式不会抛出异常。相反，它们会采用在[表8-2](#learnjava6-CHP-8-TABLE-2)中显示的特殊超出范围值。
- en: Table 8-2\. Special floating-point values
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-2\. 特殊浮点值
- en: '| Value | Mathematical representation |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| 值 | 数学表示 |'
- en: '| --- | --- |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `POSITIVE_INFINITY` | 1.0/0.0 |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| `POSITIVE_INFINITY` | 1.0/0.0 |'
- en: '| `NEGATIVE_INFINITY` | -1.0/0.0 |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| `NEGATIVE_INFINITY` | -1.0/0.0 |'
- en: '| `NaN` | 0.0/0.0 |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| `NaN` | 0.0/0.0 |'
- en: 'The following example generates an infinite result:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的例子生成一个无限的结果：
- en: '[PRE54]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The special value `NaN` (not a number) indicates the result of dividing zero
    by zero. This value has the special mathematical distinction of not being equal
    to itself (`NaN != NaN` evaluates to `true`). Use `Float.isNaN()` or `Double.isNaN()`
    to test for `NaN`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊值`NaN`（不是一个数字）表示将零除以零的结果。这个值在数学上有特殊的区别，即它不等于自身（`NaN != NaN`计算结果为`true`）。使用`Float.isNaN()`或`Double.isNaN()`来测试`NaN`。
- en: The java.lang.Math Class
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`java.lang.Math` 类'
- en: The `java.lang.Math` class is Java’s math library. It holds a suite of static
    methods covering all of the usual mathematical operations like `sin()`, `cos()`,
    and `sqrt()`. The `Math` class isn’t very object-oriented (you can’t create an
    instance of `Math`). Instead, it’s really just a convenient holder for static
    methods that are more like global functions. As we saw in [Chapter 5](ch05.html#learnjava6-CHP-5),
    it’s possible to use the static import functionality to import the names of static
    methods and constants like this directly into the scope of our class and use them
    by their simple, unqualified names.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.lang.Math` 类是 Java 的数学库。它包含一系列静态方法，涵盖了所有常见的数学操作，如 `sin()`、`cos()` 和 `sqrt()`。`Math`
    类不是很面向对象（不能创建 `Math` 的实例）。相反，它只是一个方便的静态方法的容器，更像是全局函数。正如我们在[第5章](ch05.html#learnjava6-CHP-5)看到的，可以使用静态导入功能将静态方法和常量的名称直接导入到我们类的范围内，并通过它们简单而不加修饰地使用它们。'
- en: '[Table 8-3](#learnjava6-CHP-8-TABLE-3) summarizes the methods in `java.lang.Math`.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '[表8-3](#learnjava6-CHP-8-TABLE-3)总结了 `java.lang.Math` 中的方法。'
- en: Table 8-3\. Methods in java.lang.Math
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: Table 8-3\. `java.lang.Math` 中的方法
- en: '| Method | Argument type(s) | Functionality |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 参数类型 | 功能 |'
- en: '| --- | --- | --- |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `Math.abs(a)` | `int`, `long`, `float`, `double` | Absolute value |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| `Math.abs(a)` | `int`, `long`, `float`, `double` | 绝对值 |'
- en: '| `Math.acos(a)` | `double` | Arc cosine |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| `Math.acos(a)` | `double` | 反余弦 |'
- en: '| `Math.asin(a)` | `double` | Arc sine |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| `Math.asin(a)` | `double` | 反正弦 |'
- en: '| `Math.atan(a)` | `double` | Arc tangent |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| `Math.atan(a)` | `double` | 反正切 |'
- en: '| `Math.atan2(a,b)` | `double` | Angle part of rectangular-to-polar coordinate
    transform |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| `Math.atan2(a,b)` | `double` | 矩形到极坐标转换的角度部分 |'
- en: '| `Math.ceil(a)` | `double` | Smallest whole number greater than or equal to
    `a` |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| `Math.ceil(a)` | `double` | 大于或等于 `a` 的最小整数 |'
- en: '| `Math.cbrt(a)` | `double` | Cube root of `a` |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| `Math.cbrt(a)` | `double` | `a` 的立方根 |'
- en: '| `Math.cos(a)` | `double` | Cosine |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| `Math.cos(a)` | `double` | 余弦 |'
- en: '| `Math.cosh(a)` | `double` | Hyperbolic cosine |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| `Math.cosh(a)` | `double` | 双曲余弦 |'
- en: '| `Math.exp(a)` | `double` | `Math.E` to the power `a` |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| `Math.exp(a)` | `double` | `Math.E` 的 `a` 次幂 |'
- en: '| `Math.floor(a)` | `double` | Largest whole number less than or equal to `a`
    |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| `Math.floor(a)` | `double` | 小于或等于 `a` 的最大整数 |'
- en: '| `Math.hypot(a,b)` | `double` | Precision calculation of the `sqrt()` of `a`2
    + `b`2 |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| `Math.hypot(a,b)` | `double` | 精确计算 `sqrt()` 的 `a`2 + `b`2 |'
- en: '| `Math.log(a)` | `double` | Natural logarithm of `a` |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| `Math.log(a)` | `double` | `a` 的自然对数 |'
- en: '| `Math.log10(a)` | `double` | Log base 10 of `a` |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| `Math.log10(a)` | `double` | `a` 的以 10 为底的对数 |'
- en: '| `Math.max(a, b)` | `int`, `long`, `float`, `double` | The value `a` or `b`
    closer to `Long.MAX_VALUE` |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| `Math.max(a, b)` | `int`, `long`, `float`, `double` | 值 `a` 或 `b` 更接近 `Long.MAX_VALUE`
    |'
- en: '| `Math.min(a, b)` | `int`, `long`, `float`, `double` | The value `a` or `b`
    closer to `Long.MIN_VALUE` |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| `Math.min(a, b)` | `int`, `long`, `float`, `double` | 值 `a` 或 `b` 更接近 `Long.MIN_VALUE`
    |'
- en: '| `Math.pow(a, b)` | `double` | `a` to the power `b` |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| `Math.pow(a, b)` | `double` | `a` 的 `b` 次幂 |'
- en: '| `Math.random()` | `None` | Random-number generator |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| `Math.random()` | `None` | 随机数生成器 |'
- en: '| `Math.rint(a)` | `double` | Converts double value to integral value in double
    format |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| `Math.rint(a)` | `double` | 将双精度值转换为双精度格式中的整数值 |'
- en: '| `Math.round(a)` | `float`, `double` | Rounds to whole number |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| `Math.round(a)` | `float`, `double` | 四舍五入到整数 |'
- en: '| `Math.signum(a)` | `float`, `double` | Get the sign of the number at 1.0,
    –1.0, or 0 |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| `Math.signum(a)` | `float`, `double` | 获取数字的符号，为1.0，-1.0或0 |'
- en: '| `Math.sin(a)` | `double` | Sine |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| `Math.sin(a)` | `double` | 正弦 |'
- en: '| `Math.sinh(a)` | `double` | Hyperbolic sine |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| `Math.sinh(a)` | `double` | 双曲正弦 |'
- en: '| `Math.sqrt(a)` | `double` | Square root |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| `Math.sqrt(a)` | `double` | 平方根 |'
- en: '| `Math.tan(a)` | `double` | Tangent |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| `Math.tan(a)` | `double` | 正切 |'
- en: '| `Math.tanh(a)` | `double` | Hyperbolic tangent |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| `Math.tanh(a)` | `double` | 双曲正切 |'
- en: '| `Math.toDegrees(a)` | `double` | Convert radians to degrees |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| `Math.toDegrees(a)` | `double` | 将弧度转换为角度 |'
- en: '| `Math.toRadians(a)` | `double` | Convert degrees to radians |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| `Math.toRadians(a)` | `double` | 将角度转换为弧度 |'
- en: 'The methods `log()`, `pow()`, and `sqrt()` can throw a runtime `ArithmeticException`.
    The methods `abs()`, `max()`, and `min()` are overloaded for all the scalar values
    (`int`, `long`, `float`, and `double`) and return the corresponding type. Versions
    of `Math.round()` accept either `float` or `double` and return `int` or `long`,
    respectively. The rest of the methods operate on and return `double` values:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 `log()`、`pow()` 和 `sqrt()` 可能会抛出运行时的 `ArithmeticException`。方法 `abs()`、`max()`
    和 `min()` 都针对所有标量值（`int`、`long`、`float` 和 `double`）进行了重载，并返回相应的类型。`Math.round()`
    的版本接受 `float` 或 `double`，分别返回 `int` 或 `long`，其余的方法均操作并返回 `double` 值：
- en: '[PRE55]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Just to highlight the convenience of that static import option, try these simple
    functions in *jshell*:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 只是为了突显静态导入选项的便利性，请在 *jshell* 中尝试这些简单的函数：
- en: '[PRE56]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '`Math` also contains the static final double constants `E` and `PI`. To find
    the perimeter of a circle, for example:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math` 还包含静态的最终双精度常量 `E` 和 `PI`。例如，要找到圆的周长：'
- en: '[PRE57]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Math in action
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数学的实际应用
- en: 'We’ve already touched on using the `Math` class and its static methods in [“Accessing
    Fields and Methods”](ch05.html#learnjava6-CHP-5-SECT-1.2). We can use it again
    to make our game a little more fun by randomizing where the trees appear. The
    `Math.random()` method returns a random `double` greater than or equal to 0 and
    less than 1\. Add in a little arithmetic and rounding or truncating, and you can
    use that value to create random numbers in any range you need. In particular,
    converting this value into a desired range follows this formula:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了如何在 [“访问字段和方法”](ch05.html#learnjava6-CHP-5-SECT-1.2) 中使用 `Math` 类及其静态方法。我们可以再次使用它，通过随机化树木出现的位置使我们的游戏更加有趣。`Math.random()`
    方法返回一个大于或等于 0 且小于 1 的随机 `double`。通过一些算术运算和舍入或截断，您可以使用该值创建任何所需范围内的随机数。特别地，将该值转换为所需范围的方法如下：
- en: '[PRE58]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Try it! Try to generate a random four-digit number in *jshell*. You could set
    the `min` to 1,000 and the `max` to 10,000, like so:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 试一试！尝试在 *jshell* 中生成一个随机的四位数。您可以将 `min` 设置为 1,000，将 `max` 设置为 10,000，如下所示：
- en: '[PRE59]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'To place our trees, we’ll need two random numbers for the x and y coordinates.
    We can set a range that will keep the trees on the screen by thinking about a
    margin around the edges. For the x coordinate, one way to do that might look like
    this:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 要放置我们的树木，我们需要两个随机数来获取 x 和 y 坐标。我们可以设置一个边缘周围的范围，通过在边缘周围留出一些空白来保持树木在屏幕上。对于 x 坐标，可能会像这样：
- en: '[PRE60]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Set up a similar method for finding a y value, and you should start to see
    something like the image shown in [Figure 8-1](#learnjava6-CHP-8-FIG-1). You could
    even get fancy and use the `isTouching()` method we discussed back in [Chapter 5](ch05.html#learnjava6-CHP-5)
    to avoid placing any trees in direct contact with our physicist. Here’s our upgraded
    tree setup loop:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 设置一个类似的方法来查找 y 值，你应该会看到类似于 [图 8-1](#learnjava6-CHP-8-FIG-1) 中显示的图像。您甚至可以使用我们在
    [第 5 章](ch05.html#learnjava6-CHP-5) 中讨论过的 `isTouching()` 方法，以避免将任何树木放置在与我们的物理学家直接接触的位置。这是我们升级后的树木设置循环：
- en: '[PRE61]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '![ljv6 0801](assets/ljv6_0801.png)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0801](assets/ljv6_0801.png)'
- en: Figure 8-1\. Randomly distributed trees
  id: totrans-310
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-1\. 随机分布的树木
- en: Try quitting the game and launching it again. You should see the trees in different
    places each time you run the application.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试退出游戏并再次启动它。您应该会看到每次运行应用程序时树木的不同位置。
- en: Big/Precise Numbers
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大/精确数值
- en: 'If the `long` and `double` types are not large or precise enough for you, the
    `java.math` package provides two classes, `BigInteger` and `BigDecimal`, that
    support arbitrary-precision numbers. These full-featured classes have a bevy of
    methods for performing arbitrary-precision^([5](ch08.html#id1702)) math and precisely
    controlling rounding of remainders. In the following example, we use `BigDecimal`
    to add two very large numbers and then create a fraction with a 100-digit result:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `long` 和 `double` 类型对您来说不够大或精确，那么 `java.math` 包提供了两个类，`BigInteger` 和 `BigDecimal`，支持任意精度的数字。这些功能齐全的类具有大量方法，用于执行任意精度数学运算并精确控制余数的舍入。在以下示例中，我们使用
    `BigDecimal` 来添加两个非常大的数字，然后创建一个带有 100 位小数的分数：
- en: '[PRE62]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: If you implement cryptographic or scientific algorithms for fun, `BigInteger`
    is crucial. `BigDecimal`, in turn, can be found in applications dealing with currency
    and financial data. Other than that, you’re not likely to need these classes.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您为了乐趣实施加密或科学算法，`BigInteger` 是至关重要的。反过来，`BigDecimal` 可在涉及货币和财务数据的应用程序中找到。除此之外，您可能不太需要这些类。
- en: Dates and Times
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日期和时间
- en: Working with dates and times without the proper tools can be a chore. Java includes
    three classes that handle simple cases for you. The `java.util.Date` class encapsulates
    a point in time. The `java.util.GregorianCalendar` class, which extends the abstract
    `java.util.Calendar`, translates between a point in time and calendar fields like
    month, day, and year. Finally, the `java.text.DateFormat` class knows how to generate
    and parse string representations of dates and times in many languages and locales.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有适当的工具，处理日期和时间可能会很繁琐。Java 包含三个类来处理简单的情况。`java.util.Date` 类封装了一个时间点。`java.util.GregorianCalendar`
    类继承自抽象类 `java.util.Calendar`，在时间点和日历字段（如月份、日期和年份）之间进行转换。最后，`java.text.DateFormat`
    类知道如何生成和解析多种语言和区域设置下的日期和时间的字符串表示。
- en: While the `Date` and `Calendar` classes covered many use cases, they lacked
    granularity and were missing other features. Several third-party libraries cropped
    up, all aimed at making it easier for developers to work with dates and times
    and time durations. Java 8 provided much needed improvements in this area with
    the addition of the `java.time` package. The rest of this chapter explores this
    package, but you will still encounter many, many `Date` and `Calendar` examples
    in the wild, so it’s useful to know they exist. As always, the [online docs](https://oreil.ly/Behlk)
    are an invaluable source for reviewing parts of the Java API we don’t tackle here.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `Date` 和 `Calendar` 类涵盖了许多用例，但它们缺乏精确性和其他功能。出现了几个第三方库，旨在使开发人员更容易处理日期、时间和时间段。Java
    8 在这方面提供了非常必要的改进，引入了 `java.time` 包。本章的其余部分将探讨该包，但你仍然会遇到很多 `Date` 和 `Calendar`
    的示例，因此了解它们的存在是有用的。正如始终如此，[在线文档](https://oreil.ly/Behlk) 是回顾我们未涉及的 Java API 部分的宝贵资源。
- en: Local Dates and Times
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地日期和时间
- en: 'The `java.time.LocalDate` class represents a date without time information
    for your local region. Think of an annual event such as the winter solstice on
    December 21\. Similarly, `java.time.LocalTime` represents a time without any date
    information. Perhaps your alarm clock goes off at 7:15 every morning. The `java.time.LocalDateTime`
    stores both date and time values for things like appointments with your eye doctor
    (so you can keep reading books on Java). All of these classes offer static methods
    for creating new instances, either using appropriate numeric values with the method
    `of()` or by parsing strings with `parse()`. Let’s pop into *jshell* and try creating
    a few examples:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.time.LocalDate` 类代表您本地区域的无时间信息的日期。想象一年一度的事件，例如每年的冬至，即 12 月 21 日。类似地，`java.time.LocalTime`
    表示没有任何日期信息的时间。也许你的闹钟每天早上 7:15 分响起。`java.time.LocalDateTime` 存储日期和时间值，例如与眼科医生的约会（这样您就可以继续阅读关于
    Java 的书）。所有这些类都提供了静态方法来创建新实例，可以使用适当的数值和 `of()` 方法，或者使用 `parse()` 方法解析字符串。让我们进入
    *jshell* 并尝试创建一些示例：'
- en: '[PRE63]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Another great static method for creating these objects is `now()`, which provides
    the current date, time, or date-and-time as you might expect:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这些对象的另一个很棒的静态方法是 `now()`，它会提供当前的日期、时间或日期时间，正如你期望的那样：
- en: '[PRE64]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Great! After importing the `java.time` package, you can create instances of
    each of the `Local…​` classes for specific moments or for “right now.” You may
    have noticed the objects created with `now()` include seconds and nanoseconds
    in the time. You can supply those values to the `of()` and `parse()` methods if
    you want or need them. Not much exciting there, but once you have these objects,
    you can do a lot with them. Read on!
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！在导入 `java.time` 包后，您可以为特定时刻或“现在”创建每个 `Local…​` 类的实例。您可能已经注意到用 `now()` 创建的对象包括时间的秒和纳秒。如果需要，您可以向
    `of()` 和 `parse()` 方法提供这些值。虽然这里没有太多激动人心的内容，但一旦您拥有这些对象，您可以做很多事情。继续阅读！
- en: Comparing and Manipulating Dates and Times
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较和操作日期和时间
- en: 'One of the big advantages of using `java.time` classes is the consistent set
    of methods available for comparing and changing dates and times. For example,
    many chat applications will show you “how long ago” a message was sent. The `java.time.temporal`
    subpackage has just what we need: the `ChronoUnit` interface. It contains several
    date and time units such as `MONTHS`, `DAYS`, `HOURS`, `MINUTES`, etc. These units
    can be used to calculate differences. For example, we could calculate how long
    it takes us to create two example date-times in *jshell* using the `between()`
    method:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `java.time` 类的一个重要优势是可用于比较和修改日期和时间的一致方法集。例如，许多聊天应用程序会显示消息发送“多久前”的信息。`java.time.temporal`
    子包正是我们所需的：`ChronoUnit` 接口。它包含几个日期和时间单位，如 `MONTHS`, `DAYS`, `HOURS`, `MINUTES`
    等。这些单位可用于计算时间差。例如，我们可以使用 `between()` 方法在 *jshell* 中计算创建两个示例日期时间所需的时间：
- en: '[PRE65]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: A visual spot check shows that it did indeed take about 11 seconds to type in
    the line that created our `second` variable. Check out the [docs for `ChronoUnit`](https://oreil.ly/BhCr2)
    for a complete list, but you get the full range, from nanoseconds up to millennia.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 视觉检查显示，确实花费大约 11 秒的时间输入创建我们的 `second` 变量的行。查看 [ChronoUnit 的文档](https://oreil.ly/BhCr2)
    获取完整列表，但你将获得从纳秒到千年的全范围。
- en: 'Those units can also help you manipulate dates and times with the `plus()`
    and `minus()` methods. To set a reminder for one week from today, for example:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这些单位还可以帮助你使用 `plus()` 和 `minus()` 方法操作日期和时间。例如，设置一周后的提醒：
- en: '[PRE66]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Neat! But this `reminder` example brings up another bit of manipulation you
    may need to perform from time to time. You might want a reminder at a particular
    time on the 7th. You can convert between dates, times, and date-times easily enough
    with the `atDate()` or `atTime()` methods:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！但是这个 `reminder` 示例提出了你可能需要偶尔执行的另一个操作。你可能希望在第 7 天的特定时间提醒。你可以使用 `atDate()`
    或 `atTime()` 方法轻松在日期、时间和日期时间之间进行转换：
- en: '[PRE67]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Now you’ll get a reminder at 9 A.M. Except, what if you set that reminder in
    Atlanta and then flew to San Francisco? When would the alarm go off? `LocalDateTime`
    is, well, local! So the `T09:00` portion is still 9 A.M. wherever you are when
    you run the program. But if you are handling something like scheduling a meeting,
    you can’t ignore the different time zones involved. Fortunately the `java.time`
    package has thought of that, too.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你将在上午 9 点收到提醒。但是，如果你在亚特兰大设置提醒然后飞往旧金山，闹钟会在什么时候响？`LocalDateTime` 是本地的！所以 `T09:00`
    部分无论你何时运行程序都是上午 9 点。但是如果你要处理像安排会议这样涉及不同时区的事情，就不能忽视不同的时区了。幸运的是 `java.time` 包也考虑到了这一点。
- en: Time Zones
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时区
- en: The authors of the new `java.time` package encourage you to use the local variations
    of the time and date classes where possible. Adding support for time zones means
    adding complexity to your app—they want you to avoid that complexity if possible.
    But there are many scenarios where support for time zones is unavoidable. You
    can work with “zoned” dates and times using the `ZonedDateTime` and `OffsetDateTime`
    classes. The zoned variant understands named time zones and things like daylight
    saving adjustments. The offset variant is a constant, simple numeric offset from
    UTC/Greenwich.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 新 `java.time` 包的作者鼓励你尽可能使用时间和日期类的本地变体。支持时区意味着向你的应用程序添加复杂性——他们希望你尽可能避免这种复杂性。但是有许多场景是无法避免支持时区的。你可以使用
    `ZonedDateTime` 和 `OffsetDateTime` 类处理带“区域”日期和时间。区域变体理解命名时区和夏令时调整等内容。偏移量变体是与 UTC/Greenwich
    的恒定简单数值偏移量。
- en: 'Most user-facing uses of dates and times will use the named zone approach,
    so let’s look at creating a zoned date-time. To attach a zone, we use the `ZoneId`
    class, which has the common `of()` static method for creating new instances. You
    can supply a region zone as a `String` to get your zoned value:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数用户界面上使用日期和时间的地方会使用命名区域方法，因此让我们看一下创建带区域日期时间的方法。为了附加一个区域，我们使用 `ZoneId` 类，它具有用于创建新实例的常见
    `of()` 静态方法。你可以提供一个区域区作为 `String` 来获取你的区域值：
- en: '[PRE68]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'And now you can do things like make sure your friends in Paris can join you
    at the correct moment using the verbosely but aptly named `withZoneSameInstant()`
    method:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以确保巴黎的朋友可以在正确的时刻加入你，使用命名为 `withZoneSameInstant()` 的方法：
- en: '[PRE69]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'If you have other friends who aren’t conveniently located in a major metropolitan
    region but you want them to join as well, you can use the `systemDefault()` method
    of `ZoneId` to pick up their time zone programmatically:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有其他朋友并非方便位于主要都会区域，但您也希望他们参与，您可以使用`ZoneId`的`systemDefault()`方法以编程方式选择他们的时区：
- en: '[PRE70]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: We were running *jshell* on a laptop in the Eastern time zone of the United
    States. `piOther` comes out exactly as hoped. The `systemDefault()` zone ID is
    a very handy way to quickly tailor date-times from other zones to match what your
    user’s clock and calendar are most likely to say. In commercial applications you
    may want to let the user tell you their preferred zone, but `systemDefault()`
    is usually a good guess.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在美国东部时区的笔记本电脑上运行*jshell*。`piOther`的输出正如预期的那样。`systemDefault()`时区ID是一种非常方便的方式，可以快速调整来自其他时区的日期时间，以便与用户的时钟和日历匹配。在商业应用中，您可能希望让用户告诉您他们首选的时区，但通常`systemDefault()`是一个很好的猜测。
- en: Parsing and Formatting Dates and Times
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析和格式化日期和时间
- en: For creating and showing our local and zoned date-times using strings, we’ve
    been relying on the default formats that follow ISO values. These generally work
    wherever we need to accept or display dates and times. But as every programmer
    knows, “generally” is not “always.” Fortunately, you can use the utility class
    `java.time.format.DateTimeFormatter` to help with parsing input and formatting
    output.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用字符串创建和显示我们的本地日期时间和带区域的日期时间，我们一直依赖于遵循ISO值的默认格式。这些通常在我们需要接受或显示日期和时间的任何地方起作用。但是正如每个程序员所知，“通常”并非“总是”。幸运的是，您可以使用实用类`java.time.format.DateTimeFormatter`来帮助解析输入和格式化输出。
- en: The core of `DateTimeFormatter` centers on building a format string that governs
    both parsing and formatting. You build up your format with the pieces listed in
    [Table 8-4](#learnjava6-CHP-8-TABLE-4). We are listing only a portion of the options
    available here, but these should get you through the bulk of the dates and times
    you will encounter. Note that case matters when using the characters mentioned!
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '`DateTimeFormatter`的核心在于构建一个格式字符串，该字符串管理解析和格式化。您可以通过在[表8-4](#learnjava6-CHP-8-TABLE-4)中列出的部分选项来构建格式。这里我们仅列出了部分选项，但这些选项应该能够涵盖您遇到的大部分日期和时间。请注意，在使用上述字符时大小写是敏感的！'
- en: Table 8-4\. Popular and useful `DateTimeFormatter` elements
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 表8-4。流行且有用的`DateTimeFormatter`元素
- en: '| Character | Description | Example |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| 字符 | 描述 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| a | am-pm-of-day | PM |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| a | 上午/下午 | PM |'
- en: '| d | day-of-month | 10 |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| d | 一个月中的日期 | 10 |'
- en: '| E | day-of-week | Tue; Tuesday; T |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| E | 一周中的日期 | 周二; Tuesday; T |'
- en: '| G | era | BCE, CE |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| G | 纪元 | BCE, CE |'
- en: '| k | clock-hour-of-day (1-24) | 24 |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| k | 一天中的时钟小时数（1-24） | 24 |'
- en: '| K | hour-of-am-pm (0-11) | 0 |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| K | 上午/下午的小时数（0-11） | 0 |'
- en: '| L | month-of-year | Jul; July; J |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| L | 月份 | 7月; July; J |'
- en: '| h | clock-hour-of-am-pm (1-12) | 12 |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| h | 上午/下午的时钟小时数（1-12） | 12 |'
- en: '| H | hour-of-day (0-23) | 0 |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| H | 一天中的小时数（0-23） | 0 |'
- en: '| m | minute-of-hour | 30 |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| m | 一个小时中的分钟数 | 30 |'
- en: '| M | month-of-year | 7; 07 |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| M | 月份 | 7; 07 |'
- en: '| s | second-of-minute | 55 |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| s | 分钟的秒数 | 55 |'
- en: '| S | fraction-of-second | 033954 |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| S | 秒的小数部分 | 033954 |'
- en: '| u | year (without era) | 2004; 04 |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '| u | 年份（不包含纪元） | 2004; 04 |'
- en: '| y | year-of-era | 2004; 04 |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '| y | 纪元年份 | 2004; 04 |'
- en: '| z | time-zone name | Pacific Standard Time; PST |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| z | 时区名称 | 太平洋标准时间; PST |'
- en: '| Z | zone-offset | +0000; -0800; -08:00 |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| Z | 时区偏移 | +0000; -0800; -08:00 |'
- en: 'To put together a common US short format, for example, you could use the `M`,
    `d`, and `y` characters. You build the formatter using the static `ofPattern()`
    method. Now you can use (and reuse) the formatter with the `parse()` method of
    any of the date or time classes:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，如果要创建一个常见的美国短格式，您可以使用`M`、`d`和`y`字符。您可以通过静态的`ofPattern()`方法来构建格式化器。现在，您可以使用（并重复使用）任何日期或时间类的`parse()`方法来使用该格式化器：
- en: '[PRE71]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'And as we mentioned earlier, the formatter works in both directions. Just use
    the `format()` method of your formatter to produce a string representation of
    your date or time:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，格式化器可以双向工作。只需使用您的格式化器的`format()`方法，即可生成日期或时间的字符串表示：
- en: '[PRE72]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Of course, formatters work for times and date-times as well!
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，格式化器同样适用于时间和日期时间！
- en: '[PRE73]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Notice in the `ZonedDateTime` portion that follows that we put the time zone
    identifier (the `z` character) at the end—probably not where you were expecting
    it!
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在接下来的`ZonedDateTime`部分中，我们将时区标识符（`z`字符）放在了最后——这可能不是您预期的位置！
- en: '[PRE74]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: We wanted to illustrate the power of these formats. You can design a format
    to accommodate a very wide range of input or output styles. Legacy data and poorly
    designed web forms come to mind as direct examples where `DateTimeFormatter` can
    help.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望说明这些格式的强大之处。您可以设计一个格式，以适应非常广泛的输入或输出样式。传统数据和设计不良的Web表单显然是直接需要`DateTimeFormatter`帮助的例子。
- en: Parsing Errors
  id: totrans-375
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解析错误
- en: 'Even with all this parsing power at your fingertips, things will sometimes
    go wrong. Regrettably, the exceptions you see are often too vague to be immediately
    useful. Consider the following attempt to parse a time with hours, minutes, and
    seconds:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管您可以随时利用这种解析能力，但有时候事情会出错。遗憾的是，您看到的异常通常过于模糊，无法立即派上用场。考虑以下尝试解析包含小时、分钟和秒的时间：
- en: '[PRE75]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Yikes! Java will throw a `DateTimeParseException` any time it cannot parse
    the string input. Java will also throw the exception in cases like our example
    above; the fields were correctly parsed from the string, but they did not supply
    enough information to create a `LocalTime` object. It may not be obvious, but
    our time, `“3:14:15,”` could be either mid-afternoon or very early in the morning.
    Our choice of the `hh` pattern for the hours turns out to be the culprit. We can
    either pick an hour pattern that uses an unambiguous 24-hour scale or we can add
    an explicit A.M./P.M. element:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 糟糕！Java在无法解析字符串输入时会抛出`DateTimeParseException`异常。在我们上面的例子中，即使正确从字符串中解析了字段，但未提供足够的信息来创建`LocalTime`对象时，Java也会抛出异常。也许不太明显，但我们的时间`“3:14:15,”`可能是下午或清晨。我们选择的`hh`模式作为小时的原因是罪魁祸首。我们可以选择一个使用明确的24小时制的小时模式，或者添加显式的上午/下午元素：
- en: '[PRE76]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'If you ever get a `DateTimeParseException` but your input looks like a correct
    match for the format, double-check that your format itself includes everything
    necessary to create your date or time. One parting thought on these exceptions:
    you may need to use the nonmnemonic `u` character for parsing years if your dates
    don’t naturally include an era designator such as `CE`.'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您曾经遇到`DateTimeParseException`，但您的输入看起来是格式正确的匹配，请确保您的格式本身包括创建日期或时间所需的所有内容。关于这些异常的最后一点思考：如果您的日期不自然地包括一个诸如`CE`的纪元指示符，您可能需要使用非助记符`u`字符来解析年份。
- en: There are many, *many* more details on `DateTimeFormatter`. For this, more than
    for most utility classes, it’s worth a trip to [read the docs online](https://oreil.ly/rhosl).
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`DateTimeFormatter`的详细信息还有很多，*很多*。对于这一点，相较于大多数实用程序类而言，阅读[在线文档](https://oreil.ly/rhosl)是值得的。
- en: Formatting Dates and Times
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 格式化日期和时间
- en: 'Now that you know how to create, parse, and store dates and times, you need
    to display that handy data. Happily, you can build nice, human-readable strings
    using the same formatter you built to parse dates and times from strings. Remember
    our `withSeconds` and `military` formatters? You can pick up the current time
    and quickly turn it into either format, like this:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何创建、解析和存储日期和时间了，接下来需要展示这些便捷的数据。幸运的是，您可以使用同一格式化程序创建用于解析日期和时间的漂亮、易读的字符串。还记得我们的`withSeconds`和`military`格式化程序吗？您可以获取当前时间并快速将其转换为任何格式，如下所示：
- en: '[PRE77]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: You can use any date or time pattern you build from the parts shown in [Table 8-4](#learnjava6-CHP-8-TABLE-4)
    to produce this formatted output. Hop into *jshell* and try creating a few formats.
    You can use the `LocalTime.now()` and `LocalDate.now()` methods to create some
    easy targets for your formatting tests.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用从[Table 8-4](#learnjava6-CHP-8-TABLE-4)中显示的部分构建任何日期或时间模式，以生成这种格式化的输出。进入*jshell*并尝试创建几个格式。您可以使用`LocalTime.now()`和`LocalDate.now()`方法创建一些易于格式化测试的目标。
- en: Timestamps
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时间戳
- en: 'One other popular date-time concept that `java.time` understands is timestamps.
    In any situation where you need to track the flow of information, you’ll need
    a record of exactly when the information is produced or modified. You will still
    see the `java.util.Date` class used to store these moments in time, but the `java.time.Instant`
    class carries everything you need for a timestamp and comes with all the other
    benefits of the other classes in the `java.time` package:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.time`理解的另一个流行日期时间概念是时间戳。在任何需要跟踪信息流的情况下，您都需要记录信息生成或修改的确切时间。您仍然会看到`java.util.Date`类用于存储这些时间点，但`java.time.Instant`类提供了生成时间戳所需的一切，同时还具备`java.time`包中其他类的所有其他优势：'
- en: '[PRE78]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: If dates or times appear in your work, the `java.time` package makes for a welcome
    helper. You have a mature, well-designed set of tools for dealing with this data—no
    third-party libraries needed!
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的工作中涉及日期或时间，`java.time`包将是一个非常有用的助手。 您有一套成熟、设计良好的工具，用于处理这些数据——无需第三方库！
- en: Other Useful Utilities
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他有用的工具
- en: We’ve looked at some of Java’s building blocks, including strings and numbers,
    as well as one of the most popular combinations of those strings and numbers—dates—in
    the `LocalDate` and `LocalTime` classes. We hope this range of utilities has given
    you a sense of how Java works with many of the elements you are likely to encounter.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经查看了Java的一些构建块，包括字符串和数字，以及其中一个最受欢迎的组合——日期——在`LocalDate`和`LocalTime`类中。 我们希望这些实用程序的范围为您展示了Java如何处理您可能会遇到的许多元素。
- en: Be sure to read the documentation on the `java.util`, `java.text`, and `java.time`
    packages for more utilities that may come in handy. For example, you could look
    into using `java.util.Random` for generating the random coordinates of the trees
    in [Figure 8-1](#learnjava6-CHP-8-FIG-1). Sometimes “utility” work is actually
    complex and requires careful attention to detail. Searching online for code examples
    or even complete libraries written by other developers may speed up your own efforts.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 请务必阅读关于`java.util`、`java.text`和`java.time`包的文档，以了解更多可能有用的工具。 例如，您可以查看使用`java.util.Random`生成[图8-1](#learnjava6-CHP-8-FIG-1)中树木随机坐标的方法。
    有时，“实用程序”工作实际上是复杂的，并需要仔细的细节注意。 在线搜索其他开发人员编写的代码示例甚至完整库可能加快您的工作进度。
- en: Next up, we’ll start building on these fundamental concepts. Java remains as
    popular as it is because it includes support for more advanced techniques in addition
    to the basics. One of those techniques is the “thread” features, which are baked
    right in. Threads provide better access to modern, powerful systems, keeping your
    applications performant even while handling many complex tasks. We’ll show you
    how to take advantage of this signature feature in [Chapter 9](ch09.html#learnjava6-CHP-9).
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将开始构建这些基本概念。 Java之所以如此受欢迎，是因为它除了包含基础支持外，还包括更高级技术的支持。 其中之一是“线程”功能，它们已经内置。
    线程提供了更好的访问现代强大系统的方式，即使处理许多复杂任务，您的应用程序也能保持高效。 我们将向您展示如何利用这一标志性特性在[第9章](ch09.html#learnjava6-CHP-9)中。
- en: Review Questions
  id: totrans-394
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复习问题
- en: Which class contains the constant π? Do you need to import that class to use
    π?
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个类包含常量π？ 需要导入该类以使用π吗？
- en: Which package contains better replacements for the original `java.util.Date`
    class?
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个包含了用于替代原`java.util.Date`类的更好的替代品？
- en: Which class should you use to format a date for user-friendly output?
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于格式化日期以便用户友好输出的类应该是哪个？
- en: What symbol would you use in a regular expression to help match the words “yes”
    and “yup”?
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您会在正则表达式中使用什么符号来帮助匹配“yes”和“yup”这两个单词？
- en: How would you convert the string “42” into the integer 42?
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何将字符串“42”转换为整数42？
- en: How would you compare two strings (such as “yes” and “YES”) to see if they match,
    ignoring any capitalization?
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何比较两个字符串（例如“yes”和“YES”），以忽略任何大写？
- en: Which operator concatenates strings?
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个运算符用于连接字符串？
- en: Code Exercises
  id: totrans-402
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码练习
- en: Let’s revisit our graphical Hello Java application and upgrade it using some
    new utilities and string features discussed in this chapter. You can start with
    the `HelloChapter8` class in the *exercises/ch08* folder. We want the program
    to support some command-line arguments for the message and initial position.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新审视我们的图形化Hello Java应用程序，并使用本章讨论的一些新实用程序和字符串功能进行升级。 您可以从*exercises/ch08*文件夹中的`HelloChapter8`类开始。
    我们希望程序支持一些用于消息和初始位置的命令行参数。
- en: 'Your program should accept 0, 1, or 2 arguments:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 您的程序应接受0、1或2个参数：
- en: Zero arguments should place the text “Hello, utilities!” at the center to start.
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零参数应该将文本“Hello, utilities!”居中开始。
- en: 'One argument should be treated as the message to display; it should be centered
    to start:'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个参数应该被视为要显示的消息；应该居中开始：
- en: Remember that multiword messages must be enclosed in quotes.
  id: totrans-407
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请记住，多个单词的消息必须用引号括起来。
- en: If the message is the word `today`, your code should generate a formatted date
    to use as the message.
  id: totrans-408
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果消息是单词`today`，您的代码应生成一个格式化日期以用作消息。
- en: 'Two arguments represent the message and initial coordinates for where to display
    it:'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个参数分别表示消息和初始坐标以确定显示位置：
- en: 'The coordinates should be a quoted string containing a pair of numbers separated
    by a comma and optional whitespace. These are all valid coordinate strings:'
  id: totrans-410
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 坐标应为带有逗号和可选空格分隔的一对数字的引用字符串。以下都是有效的坐标字符串：
- en: '`150,150`'
  id: totrans-411
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`150,150`'
- en: '`50, 50`'
  id: totrans-412
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`50, 50`'
- en: '`100, 220`'
  id: totrans-413
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`100, 220`'
- en: The coordinates argument may also be the word `random`, meaning your code should
    generate a random initial position.
  id: totrans-414
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 坐标参数也可以是单词`random`，意味着您的代码应生成一个随机的初始位置。
- en: 'Here are some examples:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些示例：
- en: '[PRE79]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: If the user tries to pass three or more arguments, your code should generate
    an error message and exit.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户尝试传递三个或更多参数，您的代码应生成错误消息并退出。
- en: Start by testing the number of arguments. If your program gets at least one
    argument, use the first argument for the message. If it gets two, you’ll need
    to split the coordinates and convert them to numbers. If you get the `random`
    argument, be sure to generate random numbers that will keep the message visible.
    (You can assume some reasonable default length for the message; it’s OK if some
    of a longer message gets truncated on the right side.)
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 从测试参数数量开始。如果您的程序至少获得一个参数，请使用第一个参数作为消息。如果获得两个参数，您需要拆分坐标并将其转换为数字。如果您获得`random`参数，请确保生成的随机数将使消息保持可见。（您可以假设消息的默认长度是合理的；如果更长的消息右侧被截断，这是可以接受的。）
- en: Test out your solution with a few runs. Try different coordinates. Try the randomized
    option. Try the randomized option a few times successively to make sure the starting
    position really does change. What happens if you misspell `random` in the second
    argument?
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 使用几次运行测试您的解决方案。尝试不同的坐标。尝试随机化选项。连续几次尝试随机化选项以确保起始位置确实改变。如果在第二个参数中拼写`random`错误会发生什么？
- en: 'For a further upgrade: try to write a regular expression to accept some variations
    on `random` while still ignoring the case:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 对于进一步的升级：尝试编写一个正则表达式来接受一些`random`的变体，同时忽略大小写：
- en: '`random`'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`random`'
- en: '`rand`'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rand`'
- en: '`rndm`'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rndm`'
- en: '`r`'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r`'
- en: As always, you can find a few hints for this problem in [Appendix B](app02.html#learnjava6-APP-B).
    Our solutions are in the *ch08/exercises* folder of the source code.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 始终可以在[附录 B](app02.html#learnjava6-APP-B)中找到关于这个问题的一些提示。我们的解决方案位于源代码的*ch08/exercises*文件夹中。
- en: ^([1](ch08.html#id1542-marker)) When in doubt, measure it! If your `String`-manipulating
    code is clean and easy to understand, don’t rewrite it until someone proves to
    you that it is too slow. Chances are that they will be wrong. And don’t be fooled
    by relative comparisons. A millisecond is a thousand times slower than a microsecond,
    but it still may be negligible to your application’s overall performance.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch08.html#id1542-marker)) 当存在疑问时，请测量它！如果您的`String`操作代码干净且易于理解，请不要重写它，直到有人向您证明它速度太慢。有可能他们是错误的。不要被相对比较所愚弄。毫秒比微秒慢一千倍，但对于您应用程序的整体性能可能是可以忽略不计的。
- en: ^([2](ch08.html#id1549-marker)) On most platforms the default encoding is UTF-8\.
    You can get more details on character sets, default sets, and standard sets supported
    by Java in the [official Javadoc documentation](https://oreil.ly/UarRO) for the
    `java.nio.charset.Charset` class.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch08.html#id1549-marker)) 在大多数平台上，默认的编码是UTF-8。您可以在[官方Javadoc文档](https://oreil.ly/UarRO)中获取有关Java支持的字符集、默认集和标准集的更多详细信息。
- en: ^([3](ch08.html#id1659-marker)) Validating email addresses turns out to be much
    trickier than we can address here. Regular expressions can cover most valid addresses,
    but if you are doing validation for a commercial or other professional application,
    you may want to investigate third-party libraries, such as those available from
    [Apache Commons](https://oreil.ly/JEjEk).
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch08.html#id1659-marker)) 验证电子邮件地址比我们在这里能够解决的要困难得多。正则表达式可以涵盖大多数有效的地址，但如果您正在为商业或其他专业应用程序进行验证，您可能希望调查第三方库，例如来自[Apache
    Commons](https://oreil.ly/JEjEk)的库。
- en: ^([4](ch08.html#id1660-marker)) You are welcome to [apply for your own, custom
    global TLD](https://oreil.ly/lMRnm) if you have a few hundred thousand dollars
    lying around.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch08.html#id1660-marker)) 如果您手头有几十万美元，欢迎[申请您自己的定制全球顶级域名](https://oreil.ly/lMRnm)。
- en: ^([5](ch08.html#id1702-marker)) The `float` type is “single-precision,” and
    `double` is, well, double-precision. (Hence its name!) A `double` can retain numbers
    with roughly twice the precision as a `float`. Arbitrary-precision simply means
    that you can have as many digits as you need before and after the decimal point.
    To be fair, NASA uses a value for π with only 15 digits of precision, which `double`
    can handle fine.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch08.html#id1702-marker)) `float` 类型是“单精度”的，而 `double` 类型则是“双精度”的。（因此得名！）`double`
    类型可以保留大约两倍于 `float` 类型的精度。任意精度意味着你可以在小数点前后拥有需要的任意位数的数字。公平地说，NASA 使用的 π 值精确到 15
    位小数，这对 `double` 类型来说处理得很好。
