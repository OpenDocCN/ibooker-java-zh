- en: Chapter 8\. Text and Core Utilities
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章 文本和核心实用程序
- en: If you’ve been reading this book sequentially, you’ve read all about the core
    Java language constructs, including the object-oriented aspects of the language
    and the use of threads. Now it’s time to shift gears and start talking about the
    collection of classes that compose the standard Java packages and come with every
    Java implementation. Java’s core packages are one of its most distinguishing features.
    Many other object-oriented languages have similar features, but none has as extensive
    a set of standardized classes and tools as Java does. This is both a reflection
    of—and a reason for—Java’s success.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按顺序阅读本书，你已经学习了所有关于核心Java语言构造的内容，包括语言的面向对象方面和线程的使用。现在是时候转变思路，开始讨论组成标准Java包并随每个Java实现提供的类集合了。Java的核心包是其最显著的特点之一。许多其他面向对象的语言具有类似的功能，但没有一个像Java那样拥有如此广泛的标准化类和工具集。这既是Java成功的反映，也是其成功的原因之一。
- en: Strings
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串
- en: We’ll start by taking a closer look at the Java `String` class (or, more specifically,
    `java.lang.String`). Because working with `String`s is so fundamental, it’s important
    to understand how they are implemented and what you can do with them. A `String`
    object encapsulates a sequence of Unicode characters. Internally, these characters
    are stored in a regular Java array, but the `String` object guards this array
    jealously and gives you access to it only through its own API. This is to support
    the idea that `String`s are *immutable*; once you create a `String` object, you
    can’t change its value. Lots of operations on a `String` object appear to change
    the characters or length of a string, but what they really do is return a new
    `String` object that copies or internally references the needed characters of
    the original. Java implementations make an effort to consolidate identical strings
    used in the same class into a shared-string pool and to share parts of `String`s
    where possible.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先仔细查看Java的`String`类（更具体地说是`java.lang.String`）。因为与`String`一起工作如此基础，了解它们的实现方式及其可执行的操作是非常重要的。`String`对象封装了一系列Unicode字符。在内部，这些字符存储在常规的Java数组中，但`String`对象嫉妒地保护这个数组，并且只能通过其自己的API访问它。这是为了支持`String`是不可变的想法；一旦创建了`String`对象，就无法更改其值。对`String`对象的许多操作似乎会改变字符串的字符或长度，但实际上它们只是返回一个新的`String`对象，该对象复制或内部引用原始所需的字符。Java实现会努力将在同一类中使用的相同字符串合并为共享字符串池，并在可能的情况下共享`String`的部分。
- en: The original motivation for all of this was performance. Immutable `String`s
    can save memory and the Java VM can optimize their use for speed. But they aren’t
    magic. You should have a basic understanding of the `String` class to avoid creating
    an excessive number of `String` objects in places where performance is an issue.^([1](ch08.html#id1542))
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这一切最初的动机都是性能。不可变的`String`可以节省内存，并且Java虚拟机可以优化它们的使用以提高速度。但它们并非神奇。为了避免在性能受到影响的地方创建过多的`String`对象，您应该对`String`类有基本的理解。^([1](ch08.html#id1542))
- en: Constructing Strings
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造字符串
- en: 'Literal strings, defined in your source code, are declared with double quotes
    and can be assigned to a `String` variable:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 字面字符串在源代码中用双引号定义，并可以分配给`String`变量：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Java automatically converts the literal string into a `String` object and assigns
    it to the variable.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Java会自动将字面字符串转换为`String`对象，并将其分配给变量。
- en: '`String`s keep track of their own length, so `String` objects in Java don’t
    require special terminators. You can get the length of a `String` with the `length()`
    method. You can also test for a zero-length string by using `isEmpty()`:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`String`对象在Java中跟踪其自身的长度，因此不需要特殊的终止符。您可以使用`length()`方法获取`String`的长度。您还可以通过使用`isEmpty()`测试零长度字符串：'
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`String`s can take advantage of the only overloaded operator in Java, the `+`
    operator, for string concatenation. The following two lines produce equivalent
    strings:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`String`可以利用Java中唯一的重载运算符`+`进行字符串连接。以下两行产生的字符串是等效的：'
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For chunks of text larger than a name, Java 13 introduced text blocks. We can
    store a poem with fairly little effort by using three double-quotes to mark the
    beginning and end of the multiline block. This feature even preserves leading
    space in a clever way: the leftmost nonspace character becomes the left “edge.”
    Spaces to the left of that edge on subsequent lines are ignored, but spaces after
    that edge are retained. Consider redoing our poem in *jshell*:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大于一个名称的文本块，Java 13引入了文本块。我们可以通过使用三个双引号来标记多行块的开始和结束，轻松存储一首诗。这个特性甚至以聪明的方式保留了前导空格：最左边的非空格字符成为左侧的“边缘”。在后续行中，在该边缘左侧的空格将被忽略，但该边缘后面的空格将被保留。考虑在*jshell*中重新制作我们的诗：
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Embedding lengthy text in source code is not normally something you want to
    do. For text longer than a few dozen lines, [Chapter 10](ch10.html#learnjava6-CHP-10)
    looks at ways to load `String`s from files.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在源代码中嵌入长文本通常不是您想做的事情。对于超过几十行的文本，[第10章](ch10.html#learnjava6-CHP-10)介绍了从文件加载`String`的方法。
- en: 'In addition to making strings from literal expressions, you can construct a
    `String` directly from an array of characters:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 除了从文字表达中生成字符串外，你还可以直接从字符数组构造`String`：
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can also construct a `String` from an array of bytes:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以从字节数组构造一个`String`：
- en: '[PRE5]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this case, the second argument to the `String` constructor is the name of
    a character-encoding scheme. The `String` constructor uses it to convert the raw
    bytes in the specified encoding to the internal encoding chosen by the runtime.
    If you don’t specify a character encoding, the default encoding scheme on your
    system is used.^([2](ch08.html#id1549))
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`String`构造函数的第二个参数是字符编码方案的名称。`String`构造函数使用它来将指定编码中的原始字节转换为运行时选择的内部编码。如果不指定字符编码，则使用系统上的默认编码方案。^([2](ch08.html#id1549))
- en: 'Conversely, the `charAt()` method of the `String` class lets you access the
    characters of a `String` in an array-like fashion:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，`String`类的`charAt()`方法允许你以类似数组的方式访问`String`的字符：
- en: '[PRE6]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This code prints the characters of the string one at a time.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码逐个打印字符串的字符。
- en: The notion that a `String` is a sequence of characters is also codified by the
    `String` class implementing the interface `java.lang.CharSequence`, which prescribes
    the methods `length()` and `charAt()` as a way to get a subset of the characters.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`String`类实现`java.lang.CharSequence`接口，这个概念将`String`定义为字符序列，并指定了`length()`和`charAt()`方法作为获取字符子集的方式。'
- en: Strings from Things
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从事物中获取字符串
- en: 'Objects and primitive types in Java can be turned into a default textual representation
    as a `String`. For primitive types like numbers, the string should be fairly obvious;
    for object types, it is under the control of the object itself. We can get the
    string representation of an item with the static `String.valueOf()` method. Various
    overloaded versions of this method accept each of the primitive types:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Java中的对象和原始类型可以被转换为一个默认的文本表示作为`String`。对于诸如数字之类的原始类型，字符串应该是显而易见的；对于对象类型，则由对象本身控制。我们可以通过静态的`String.valueOf()`方法获取项目的字符串表示。这个方法的各种重载版本接受每个原始类型：
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'All objects in Java have a `toString()` method that is inherited from the `Object`
    class. For many objects, this method returns a useful result that displays the
    contents of the object. For example, a `java`.`util`.`Date` object’s `toString()`
    method returns the date it represents formatted as a string. For objects that
    do not provide a representation, the string result is just a unique identifier
    that you can use for debugging. The `String.valueOf()` method, when called for
    an object, invokes the object’s `toString()` method and returns the result. The
    only real difference in using this method is that if you pass it a null object
    reference, it returns the `String` “null” for you, instead of producing a `NullPointerException`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Java中的所有对象都有一个从`Object`类继承而来的`toString()`方法。对于许多对象，这个方法返回一个有用的结果，显示对象的内容。例如，`java.util.Date`对象的`toString()`方法返回它表示的日期格式化为字符串。对于不提供表示的对象，字符串结果只是一个可以用于调试的唯一标识符。当针对对象调用`String.valueOf()`方法时，它会调用对象的`toString()`方法并返回结果。使用这个方法的唯一真正的区别是，如果传递给它一个空对象引用，它会为你返回`String`“null”，而不是产生`NullPointerException`：
- en: '[PRE8]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'String concatenation uses the `valueOf()` method internally, so if you “add”
    an object or primitive using the plus operator (+), you get a `String`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串连接在内部使用`valueOf()`方法，因此如果使用加号运算符（+）“添加”对象或原始类型，则会得到一个`String`：
- en: '[PRE9]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You’ll sometimes see people use the empty string and the plus operator (+)
    as shorthand to get the string value of an object. For example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It’s a bit of a cheat, but it does work and it is visually succinct.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Comparing Strings
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The standard `equals()` method can compare strings for *equality*; they must
    contain exactly the same characters in the same order. You can use a different
    method, `equalsIgnoreCase()`, to check the equivalence of strings in a case-insensitive
    way:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'A common mistake for novice programmers in Java is to compare strings with
    the `==` operator when they actually need the `equals()` method. Remember that
    strings are objects in Java, and `==` tests for object *identity*: that is, whether
    the two arguments being tested are the same object. In Java, it’s easy to make
    two strings that have the same characters but are not the same string object.
    For example:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This mistake is particularly dangerous because it often works for the common
    case in which you are comparing *literal strings* (strings declared with double
    quotes right in the code). The reason for this is that Java tries to manage strings
    efficiently by combining them. At compile time, Java finds all the identical strings
    within a given class and makes only one object for them. This is safe because
    strings are immutable and cannot change, but it does leave room for this comparison
    problem.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'The `compareTo()` method compares the lexical value of the `String` to another
    `String`, using the Unicode specification to compare the relative positions of
    two strings within the “alphabet.” (We use quotes as Unicode has many more characters
    than just the letters of the English alphabet.) It returns an integer that is
    less than, equal to, or greater than zero:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can’t really use the actual value returned by `compareTo()` beyond these
    three possibilities. Any negative number, be it -1, -5, or -1,000, simply means
    the first string is “less than” the second string. The `compareTo()` method compares
    strings strictly by their characters’ positions in the Unicode specification.
    This works for simple text but does not handle all language variations well. If
    you need more sophisticated comparisons with broader internationalization support,
    check out the documentation for [the `java.text.Collator` class](https://oreil.ly/KrVCG).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Searching
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `String` class provides several simple methods for finding fixed substrings
    within a string. The `startsWith()` and `endsWith()` methods compare an argument
    string with the beginning and end of the `String`, respectively:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `indexOf()` method searches for the first occurrence of a character or
    substring and returns the starting character position, or `-1` if the substring
    is not found:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Similarly, `lastIndexOf()` searches backward through the string for the last
    occurrence of a character or substring.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'The `contains()` method handles the very common task of checking to see whether
    a given substring is contained in the target string:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: For more complex searching, you can use the Regular Expression API, which allows
    you to look for and parse complex patterns. We’ll talk about regular expressions
    later in this chapter.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: String Method Summary
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Table 8-1](#learnjava6-CHP-8-TABLE-1) summarizes the methods provided by the
    `String` class. We’ve included several methods not discussed in this chapter.
    Feel free to try these methods out in *jshell* or look up the [documentation online](https://oreil.ly/lbM1R).'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Table 8-1\. String methods
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Functionality |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
- en: '| `charAt()` | Gets a particular character in the string |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
- en: '| `compareTo()` | Compares the string with another string |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
- en: '| `concat()` | Concatenates the string with another string |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
- en: '| `contains()` | Checks whether the string contains another string |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
- en: '| `copyValueOf()` | Returns a string equivalent to the specified character
    array |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
- en: '| `endsWith()` | Checks whether the string ends with a specified suffix |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
- en: '| `equals()` | Compares the string with another string |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
- en: '| `equalsIgnoreCase()` | Compares the string with another string, ignoring
    case |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
- en: '| `getBytes()` | Copies characters from the string into a byte array |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
- en: '| `getChars()` | Copies characters from the string into a character array |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
- en: '| `hashCode()` | Returns a hashcode for the string |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
- en: '| `indexOf()` | Searches for the first occurrence of a character or substring
    in the string |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
- en: '| `intern()` | Fetches a unique instance of the string from a global shared-string
    pool |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
- en: '| `isBlank()` | Returns true if the string is zero length or contains only
    whitespace |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
- en: '| `isEmpty()` | Returns true if the string is zero length |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
- en: '| `lastIndexOf()` | Searches for the last occurrence of a character or substring
    in a string |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
- en: '| `length()` | Returns the length of the string |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
- en: '| `lines()` | Returns a stream of lines separated by line terminators |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
- en: '| `matches()` | Determines if the whole string matches a regular expression
    pattern |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
- en: '| `regionMatches()` | Checks whether a region of the string matches the specified
    region of another string |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
- en: '| `repeat()` | Returns a concatenation of this string, repeated a given number
    of times |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
- en: '| `replace()` | Replaces all occurrences of a character in the string with
    another character |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
- en: '| `replaceAll()` | Replaces all occurrences of a regular expression pattern
    with a pattern |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
- en: '| `replaceFirst()` | Replaces the first occurrence of a regular expression
    pattern with a pattern |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
- en: '| `split()` | Splits the string into an array of strings using a regular expression
    pattern as a delimiter |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
- en: '| `startsWith()` | Checks whether the string starts with a specified prefix
    |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
- en: '| `strip()` | Removes leading and trailing whitespace as defined by [`Character.isWhitespace()`](https://oreil.ly/NK1Nl)
    |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
- en: '| `stripLeading()` | Removes leading whitespace, similar to `strip()` |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
- en: '| `stripTrailing()` | Removes trailing whitespace, similar to `strip()` |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
- en: '| `substring()` | Returns a substring from the string |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
- en: '| `toCharArray()` | Returns the array of characters from the string |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
- en: '| `toLowerCase()` | Converts the string to lowercase |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `toLowerCase()` | 将字符串转换为小写 |'
- en: '| `toString()` | Returns the string value of an object |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `toString()` | 返回对象的字符串值 |'
- en: '| `toUpperCase()` | Converts the string to uppercase |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `toUpperCase()` | 将字符串转换为大写 |'
- en: '| `trim()` | Removes leading and trailing whitespace, defined here as any character
    with a Unicode position (called its *codepoint*) less than or equal to 32 (the
    “space” character) |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `trim()` | 删除前导和尾随空白，这里定义为任何Unicode位置（称为其*代码点*）小于或等于32的字符（“空格”字符） |'
- en: '| `valueOf()` | Returns a string representation of a value |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `valueOf()` | 返回值的字符串表示形式 |'
- en: Things from Strings
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串的用途
- en: Parsing and formatting text is a large, open-ended topic. So far in this chapter,
    we’ve looked at only primitive operations on strings—creation, searching, and
    turning simple values into strings. Now we’d like to move on to more structured
    forms of text. Java has a rich set of APIs for parsing and printing formatted
    strings, including numbers, dates, times, and currency values. We’ll cover most
    of these topics in this chapter, but we’ll wait to discuss date and time formatting
    in [“Local Dates and Times”](#learnjava6-CHP-8-SECT-5.1).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 解析和格式化文本是一个庞大而开放的主题。到目前为止，在本章中，我们只研究了字符串的原始操作—创建、搜索和将简单值转换为字符串。现在我们想要转向更结构化的文本形式。Java有一套丰富的API用于解析和打印格式化的字符串，包括数字、日期、时间和货币值。我们将在本章中涵盖大多数这些主题，但我们将等待在[“本地日期和时间”](#learnjava6-CHP-8-SECT-5.1)中讨论日期和时间格式化。
- en: We’ll start with *parsing*—reading primitive numbers and values from strings,
    and chopping long strings into tokens. Then we’ll take a look at regular expressions,
    the most powerful text-parsing tool Java offers. Regular expressions let you define
    your own patterns of arbitrary complexity, search for them, and parse them from
    text.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将从*解析*开始—从字符串中读取原始数字和值，并将长字符串切割成标记。然后我们将看一下正则表达式，Java提供的最强大的文本解析工具。正则表达式允许您定义任意复杂度的模式，搜索它们并从文本中解析它们。 '
- en: Parsing Primitive Numbers
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析原始数字
- en: 'In Java, numbers, characters, and booleans are primitive types—not objects.
    But for each primitive type, Java also defines a *primitive wrapper* class. Specifically,
    the `java.lang` package includes the following classes: `Byte`, `Short`, `Integer`,
    `Long`, `Float`, `Double`, `Character`, and `Boolean`. We talked about these in
    [“Wrappers for Primitive Types”](ch05.html#learnjava6-CHP-5-SECT-2.6), but we
    bring them up now because these classes hold static utility methods that parse
    their respective types from strings. Each of these primitive wrapper classes has
    a static “parse” method that reads a `String` and returns the corresponding primitive
    type. For example:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，数字、字符和布尔值是原始类型—而不是对象。但是对于每种原始类型，Java还定义了一个*原始包装*类。具体来说，`java.lang`包包括以下类：`Byte`、`Short`、`Integer`、`Long`、`Float`、`Double`、`Character`和`Boolean`。我们在[“原始类型的包装器”](ch05.html#learnjava6-CHP-5-SECT-2.6)中谈到过这些，但我们现在提到它们是因为这些类包含了解析其各自类型的静态实用方法。每个这些原始包装类都有一个静态的“parse”方法，它读取一个`String`并返回相应的原始类型。例如：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can find other ways to convert from strings to base types and back again,
    but these wrapper class methods are straightforward and easy to read. And in the
    case of `Integer` and `Long`, you can also supply an optional *radix* argument
    (the base of a number system; decimal numbers have a radix of 10, for example)
    to convert strings with octal or hexadecimal numbers. (Nondecimal data sometimes
    pops up when dealing with things such as cryptographic signatures or email attachments.)
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以找到其他将字符串转换为基本类型并再次转换的方法，但这些包装类方法简单直接易于阅读。在`Integer`和`Long`的情况下，您还可以提供一个可选的*radix*参数（数字系统的基数；例如，十进制数字的基数为10）来转换带有八进制或十六进制数字的字符串。（处理诸如加密签名或电子邮件附件等内容时，非十进制数据有时会出现。）
- en: Tokenizing Text
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分词文本
- en: You’ll rarely encounter strings with just one number to parse or with only the
    word you need. It’s a more common programming task to parse a longer string of
    text into individual words, or *tokens*, that are separated by some set of *delimiter
    characters*, such as spaces or commas.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你很少会遇到只有一个数字要解析或只有你需要的单词的字符串。将长字符串解析为由一些*分隔符字符*（如空格或逗号）分隔的单个单词或*标记*是一项更常见的编程任务。
- en: Programmers talk about tokens as a generic way to discuss different values or
    types present in a piece of text. A token might be a simple word, a username,
    an email address, or a number. Let’s take a look at some examples.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the sample text below. The first line contains words separated by
    single spaces. The remaining pair of lines involves comma-delimited fields:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Java has several (unfortunately overlapping) methods and classes for handling
    situations like this. We’ll use the powerful `split()` method from the `String`
    class. It utilizes regular expressions to allow you to break up a string based
    on arbitrary patterns. We’ll talk about regular expressions shortly, but to show
    you how this works, we’ll just give you the necessary magic now.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'The `split()` method accepts a regular expression that describes a delimiter.
    It uses that expression to chop the string into an array of smaller `String`s:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the first example, we used the regular expression `\\s`, which matches a
    single whitespace character (space, tab, or carriage return). Calling `split()`
    on our `text1` variable returns an array of eight strings. In the second example,
    we used a more complicated regular expression, `\\s*,\\s*`, which matches a comma
    surrounded by any amount of optional whitespace. This reduced our text to three
    nice, tidy fields.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Regular Expressions
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now it’s time to take a brief detour on our trip through Java and enter the
    land of *regular expressions*. A regular expression, or *regex* for short, describes
    a text pattern. Regular expressions are used with many tools—including the `java.util.regex`
    package, text editors, and many scripting languages—to provide sophisticated text-searching
    and string-manipulation capabilities.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Regular expressions can help you find all of the phone numbers in a large file.
    They can help you find all of the phone numbers with a particular area code. They
    can help you find all of the phone numbers that do *not* have a particular area
    code. You can use a regular expression to find links in the source of a web page.
    You can even use regular expressions to do some editing in a text file. You could
    look for phone numbers with the area code in parentheses, say (123) 456-7890,
    and replace it with the simpler 123-456-7890 format, for example. And key to the
    power of regular expressions, you can find *every* phone number in your block
    of text with parentheses and convert it—not just one specific phone number.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: If you are already familiar with the concept of regular expressions and how
    they are used with other languages, you may wish to skim through this section,
    but don’t skip it entirely. At the very least, you’ll need to look at [“The java.util.regex
    API”](#learnjava6-CHP-8-SECT-3.2) later in this chapter, which covers the Java
    classes necessary to use them. If you’re wondering exactly what regular expressions
    are, then grab a can or a cup of your favorite beverage and get ready. You are
    about to learn about the most powerful tool in the arsenal of text manipulation,
    as well as a tiny language within a language, all in the span of a few pages.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经熟悉了正则表达式的概念以及它们如何与其他语言一起使用，你可能想要快速浏览一下这一部分，但不要完全跳过。至少，你需要稍后查看本章中的 [“The
    java.util.regex API”](#learnjava6-CHP-8-SECT-3.2)，它涵盖了使用它们所需的Java类。如果你想知道正则表达式到底是什么，那就准备好一罐或一杯你最喜欢的饮料吧。你将在几页之内了解到文本操作工具中最强大的工具，以及一种语言中的微小语言。
- en: Regex Notation
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正则表达式符号
- en: A regular expression (regex) describes a pattern in text. By *pattern*, we mean
    just about any feature you can imagine identifying in text from the literal characters
    alone, without actually understanding their meaning. This includes features such
    as words, word groupings, lines and paragraphs, punctuation, upper- or lowercase,
    and more generally, strings and numbers with a specific structure to them. (Think
    of things like phone numbers, email addresses, or zip codes.) With regular expressions,
    you can search the dictionary for all the words that have the letter “q” without
    its pal “u” next to it, or words that start and end with the same letter. Once
    you have constructed a pattern, you can use simple tools to hunt for it in text
    or to determine if a given string matches it.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式（regex）描述了文本中的模式。通过 *模式*，我们指的是几乎可以想象出的任何你可以单纯从文本中的文字了解的特征，而不必真正理解它们的含义。这包括诸如单词、单词组合、行和段落、标点、大写或小写，以及更一般地说，具有特定结构的字符串和数字。
    （想想电话号码、电子邮件地址或邮政编码之类的东西。）使用正则表达式，你可以搜索字典中所有包含字母“q”但其旁边没有它的“u”的单词，或者以相同字母开头和结尾的单词。一旦你构建了一个模式，你就可以使用简单的工具在文本中搜索它，或确定给定的字符串是否与之匹配。
- en: Write once, run away
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一次编写，一次逃避
- en: Regular expressions constitute a simple form of programming language. Think
    for a moment about the examples we cited earlier. We would need something like
    a language to describe even simple patterns—such as email addresses—that have
    common elements but also some variation in form.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式构成了一种简单的编程语言形式。想一想我们之前引用的例子。我们需要类似一种语言来描述甚至是简单模式——比如电子邮件地址——它们具有共同的元素但形式上也有些变化。
- en: A computer science textbook would classify regular expressions at the bottom
    of the hierarchy of computer languages, in terms of both what they can describe
    and what you can do with them. They are still capable of being quite sophisticated,
    however. As with most programming languages, the elements of regular expressions
    are simple, but you can combine them to create something quite complex. And that
    potential complexity is where things start to get sticky.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学教科书会将正则表达式分类为计算机语言的底层，无论是从它们能描述的内容还是你可以用它们做什么来看。但是，它们仍然有可能非常复杂。与大多数编程语言一样，正则表达式的元素很简单，但你可以将它们组合起来创建一些相当复杂的东西。而这种潜在的复杂性正是事情开始变得棘手的地方。
- en: Since regexes work on strings, which can be found everywhere in Java code, it
    is convenient to have a very compact notation. But compact notation can be cryptic,
    and experience shows that it is much easier to write a complex statement than
    to read it again later. Such is the curse of the regular expression. You may find
    yourself in a moment of late-night, caffeine-fueled inspiration, writing a single
    glorious pattern to simplify the rest of your program down to one line. When you
    return to read that line the next day, however, it may look like Egyptian hieroglyphics
    to you. Simpler is generally better, but if you can break your problem more clearly
    into several steps, maybe you should.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 由于正则表达式适用于字符串，而Java代码中的字符串无处不在，因此具有非常紧凑的表示法是很方便的。但紧凑的表示法可能很神秘，经验表明，编写一个复杂的语句要比稍后再次阅读它要容易得多。这就是正则表达式的诅咒。你可能会发现自己在一个深夜、咖啡因推动的灵感时刻，写下一个辉煌的模式来简化你程序的其余部分到一行。然而，当你第二天回来阅读这一行时，它可能对你来说就像埃及象形文字一样难以理解。更简单通常更好，但如果你能更清晰地将问题分解为几个步骤，也许你应该这样做。
- en: Escaped characters
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转义字符
- en: 'Now that you’ve been properly warned, we have to throw one more thing at you
    before we build you back up. Not only can the regex notation get a little hairy,
    but it is also somewhat ambiguous when used with ordinary Java strings. An important
    part of the notation is the escaped character—a character with a backslash in
    front of it. For example, in regex notation, the escaped `d` character, `\d`,
    (backslash “d”) is a shorthand for any single digit character (0–9). However,
    you cannot simply write `\d` as part of a Java string, because Java uses the backslash
    for its own special characters and to specify Unicode character sequences (`\uxxxx`).
    Fortunately, Java gives us a replacement: an *escaped backslash*: two backslashes
    (`\\`). It represents a literal backslash. The rule is, when you want a backslash
    to appear in your regex, you must escape it with an extra one:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'It gets weirder! Because regex notation itself uses a backslash to denote special
    characters, it must provide the same “escape hatch” for itself. You need to double
    up backslashes if you want your regex to match a literal backslash. It looks like
    this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Most of the “magic” operator characters in this section operate on the character
    that precedes them, so you must escape them if you want their literal meaning.
    This includes such characters as `.`, `*`, `+`, `{}`, and `()`. An expression
    that can match formal US phone numbers (with the area code inside a pair of parentheses)
    looks like this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If you need to create part of an expression that has lots of literal characters
    in it, you can use the special delimiters `\Q` and `\E` to help you. Any text
    appearing between `\Q` and `\E` is automatically escaped. (You still need the
    Java `String` escapes—double backslashes for backslash, but not quadruple.) There
    is also a static method called `Pattern.quote()` that does the same thing, returning
    a properly escaped version of whatever string you give it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'We have one more suggestion to help maintain your cool when working with these
    examples. Write out the plain regex using a comment line above the real Java string
    (where you must double up all backslashes). We also tend to include a comment
    with an example of the text we hope to match. Here’s that US phone number example
    again with this commenting approach:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: And don’t forget about *jshell*! It can be a very powerful playground for testing
    and tweaking your patterns. We’ll see several examples of testing patterns with
    *jshell* in [“The java.util.regex API”](#learnjava6-CHP-8-SECT-3.2). But first,
    let’s look at more of the elements you can use to construct patterns.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Characters and character classes
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, let’s dive into the actual regex syntax. The simplest form of a regular
    expression is plain, literal text, which has no special meaning and is matched
    directly (character for character) in the input. This can be a single character
    or more. For example, in the following string, the pattern `s` can match the character
    “s” in the words “rose” and “is”:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The pattern “rose” can match only the literal word `rose`. But this isn’t very
    interesting. Let’s crank things up a notch by introducing some special characters
    and the notion of character “classes”:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '*Any character: dot* (`.`)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: The special character dot (`.`) matches any single character. The pattern `.ose`
    matches “rose,” “nose,” “_ose” (space followed by “ose”), or any other character
    followed by the sequence “ose.” Two dots match any two characters (“prose,” “close”),
    and so on. The dot operator is very broad; it normally stops only for a *line
    terminator* (a newline, carriage return, or combination of both). Think of `.`
    as representing the class of all characters.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '*Whitespace or nonwhitespace character:* `\s`, `\S`'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: The special character `\s` matches whitespace. *Whitespace* includes any character
    that relates to visual space in text or that marks the end of a line. Common whitespace
    characters include the literal space character (what you get when you press the
    space bar on your keyboard), `\t` (tab), `\r` (carriage return), `\n` (newline),
    and `\f` (formfeed). The corresponding special character `\S` does the inverse,
    matching any character that is *not* whitespace.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '*Digit or nondigit character*: `\d`, `\D`'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '`\d` matches any of the digits from 0 to 9\. `\D` does the inverse, matching
    all characters except digits.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '*Word or nonword character*: `\w`, `\W`'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '`\w` matches characters typically found in “words,” such as upper- and lowercase
    letters A–Z, a–z, the digits 0–9, and the underscore character (_). `\W` matches
    everything except those characters.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Custom character classes
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can define your own character classes using square brackets (`[ ]`) around
    the characters you want. Here are some examples:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The special `x-y` *range notation* can be used as shorthand for consecutive
    runs of alphanumeric characters:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Placing a caret (`^`) as the first character inside the brackets inverts the
    character class, matching any character *except* those included in the brackets:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Nesting character classes simply concatenates them into a single class:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You can use the `&&` logical AND notation (similar to the Boolean operator
    we saw in [“Operators”](ch04.html#learnjava6-CHP-4-SECT-5.2.1)) to take the *intersection*
    (characters in common):'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Position markers
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The pattern `[Aa] rose` (including an upper- or lowercase A) matches three
    times in the following phrase:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Position characters allow you to designate the relative location of a match
    within a line. The most important are `^` and `$`, which match the beginning and
    end of a line, respectively:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: To be a little more precise, `^` and `$` match the beginning and end of “input,”
    which is usually a single line. If you are working with multiple lines of text
    and wish to match the beginnings and endings of lines within a single large string,
    you can turn on “multiline” mode with a flag, as described later in [“Special
    options”](#learnjava6-CHP-8-SECT-3.1.8).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'The position markers `\b` and `\B` match a word boundary (whitespace, punctuation,
    or the beginning or end of a line), or a nonword boundary (the middle of a word),
    respectively. For example, the first pattern matches “rose” and “rosemary,” but
    not “primrose.” The second pattern matches “primrose” and “prose,” but not “rose”
    at the beginning of a word or by itself:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 位置标记符`\b`和`\B`匹配单词边界（空格、标点或行的开头或结尾），或非单词边界（单词的中间），分别如下。例如，第一个模式匹配“rose”和“rosemary”，但不匹配“primrose”。第二个模式匹配“primrose”和“prose”，但不匹配单词开头的“rose”或独立的“rose”：
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You often use these position markers when you need to look for or exclude prefixes
    or suffixes.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要查找或排除前缀或后缀时，通常使用这些位置标记符。
- en: Iteration (multiplicity)
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 迭代（多重性）
- en: 'Simply matching fixed-character patterns will not get us very far. Next, we
    look at operators that count the number of occurrences of a character (or more
    generally, of a pattern, as we’ll see in [“Pattern”](#learnjava6-CHP-8-SECT-3.2.1)):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地匹配固定字符模式将无法使我们走得更远。接下来，我们看一下可以计数字符（或更一般地说，模式的出现次数，正如我们将在[“模式”](#learnjava6-CHP-8-SECT-3.2.1)中看到的那样）的操作符。
- en: '*Any (zero or more iterations): asterisk* (`*`)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*任意（零个或多个迭代）：星号*（`*`）'
- en: 'Placing an asterisk (*) after a character or character class means “allow any
    number of that type of character”—in other words, zero or more. For example, the
    following pattern matches a digit with any number of leading zeros (possibly none):'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在字符或字符类之后放置星号（`*`）表示“允许任意数量的该类型字符”——换句话说，零个或更多。例如，下面的模式匹配具有任意数量前导零的数字（可能没有）：
- en: '[PRE33]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '*Some (one or more iterations): plus sign* (`+`)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*一些（一个或多个迭代）：加号* (`+`)'
- en: 'The plus sign (+) means “one or more” iterations and is equivalent to XX* (pattern
    followed by pattern asterisk). For example, the following pattern matches a number
    with one or more digits, plus optional leading zeros:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 加号（+）表示“一个或多个”迭代，等同于XX*（模式后跟模式星号）。例如，下面的模式匹配一个带有一个或多个数字的数字，加上可选的前导零：
- en: '[PRE34]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: It may seem redundant to match the zeros at the beginning of an expression because
    zero is a digit and is thus matched by the `\d+` portion of the expression anyway.
    However, we’ll show later how you can pick apart the string using a regex and
    get at just the pieces you want. In this case, you might want to strip off the
    leading zeros and keep only the digits.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在表达式开头匹配零似乎是多余的，因为零是一个数字，因此会被表达式中`\d+`部分匹配。然而，稍后我们将展示如何使用正则表达式分析字符串并仅获取想要的部分。在这种情况下，您可能希望去掉前导零，只保留数字。
- en: '*Optional (zero or one iteration): question mark* (`?`)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*可选（零个或一次迭代）：问号*（`?`）'
- en: 'The question mark operator (`?`) allows exactly zero or one iteration. For
    example, the following pattern matches a credit card expiration date, which may
    or may not have a slash in the middle:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 问号操作符（`?`）允许零次或一次迭代。例如，下面的模式匹配信用卡过期日期，中间可能有或可能没有斜杠：
- en: '[PRE35]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '*Range (between x and y iterations, inclusive)*: `{x,y}`'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*范围（介于x和y次迭代之间，包括x和y）*：`{x,y}`'
- en: 'The `{x,y}` curly brace range operator is the most general iteration operator.
    It specifies a precise range to match. A range takes two arguments: a lower bound
    and an upper bound, separated by a comma. This regex matches any word with five
    to seven characters, inclusive:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`{x,y}` 花括号范围运算符是最常见的迭代运算符。它指定一个精确的匹配范围。一个范围接受两个参数：一个下界和一个上界，用逗号分隔。这个正则表达式匹配任何具有五到七个字符的单词：'
- en: '[PRE36]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '*At least x or more iterations (y is infinite)*: `{x,}`'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*至少x次或更多次迭代（y是无穷大）*：`{x,}`'
- en: If you omit the upper bound, simply leaving a dangling comma in the range, the
    upper bound becomes infinite. This is a way to specify a minimum of occurrences
    with no maximum.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略上界，只留下范围中的悬挂逗号，上界将变为无限大。这是指定具有无最大次数的最小出现次数的方法。
- en: Alternation
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 替换
- en: 'The vertical bar (`|`) operator denotes the logical OR operation, also called
    *alternation* or *choice*. The `|` operator does not operate on individual characters
    but instead applies to everything on either side of it. It splits the expression
    in two unless constrained by parentheses grouping. For example, a slightly naive
    approach to parsing dates might be the following:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 竖线（`|`）操作符表示逻辑OR操作，也称为*替换*或*选择*。`|`操作符不操作单个字符，而是应用于其两侧的所有内容。它将表达式分成两部分，除非受到括号分组的限制。例如，对解析日期的稍微天真的方法可能如下所示：
- en: '[PRE37]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this expression, the left matches patterns such as “Fri, Oct 12, 2001,” and
    the right matches “10/12/01.”
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个表达式中，左侧匹配诸如“Fri, Oct 12, 2001,” 这样的模式，右侧匹配“10/12/01”。
- en: 'The following regex might be used to match email addresses with one of three
    domains (*net*, *edu*, and *gov*):'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 以下正则表达式可能用于匹配具有*net*、*edu*和*gov*三个域名中的电子邮件地址之一：
- en: '[PRE38]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This pattern is by no means complete in terms of true, valid email addresses.
    But it does highlight how you can use alternation to help build regular expressions
    with some useful characteristics.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式在真实有效的电子邮件地址方面并不完整。但它确实突显了如何使用交替来构建具有一些有用特性的正则表达式。
- en: Special options
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 特殊选项
- en: 'Several special options affect the way the regex engine performs its matching.
    These options can be applied in two ways:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 几个特殊选项会影响正则表达式引擎的匹配方式。这些选项可以通过两种方式应用：
- en: You can supply one or more special arguments (flags) to the `Pattern.compile()`
    step (discussed in [“The java.util.regex API”](#learnjava6-CHP-8-SECT-3.2)).
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在`Pattern.compile()`步骤中提供一个或多个特殊参数（标志）（见[“java.util.regex API”](#learnjava6-CHP-8-SECT-3.2)）。
- en: You can include a special block of code in your regex.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在你的正则表达式中包含一个特殊的代码块。
- en: We’ll show the latter approach here. To do this, include one or more flags in
    a special block `(?`*`x`*`)`, where *`x`* is the flag for the option we want to
    turn on. Generally, you do this at the beginning of the regex. You can also turn
    off flags by adding a minus sign `(?-`*`x`*`)`, which allows you to apply flags
    to select parts of your pattern.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里展示后一种方法。为此，在一个特殊块`(?`*`x`*`)`中包含一个或多个标志，其中*`x`*是我们想要打开选项的标志。通常，你在正则表达式的开头这样做。你也可以通过添加减号来关闭标志`(?-`*`x`*`)`，这允许你对模式的部分区域应用标志。
- en: 'The following flags are available:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 可用以下标志：
- en: '*Case-insensitive*: `(?i)`'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '*不区分大小写*：`(?i)`'
- en: 'The `(?i)` flag tells the regex engine to ignore character case while matching.
    For example:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`(?i)`标志告诉正则表达式引擎在匹配时忽略字符大小写。例如：'
- en: '[PRE39]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '*Dot all*: `(?s)`'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*点全部*：`(?s)`'
- en: The `(?s)` flag turns on “dot all” mode, allowing the dot character to match
    anything, including end-of-line characters. It is useful if you are matching patterns
    that span multiple lines. The `s` stands for “single-line mode,” a somewhat confusing
    name derived from Perl.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`(?s)`标志打开了“点任意”模式，允许点字符匹配任何内容，包括行尾字符。如果你要匹配跨多行的模式，这很有用。`s`代表“单行模式”，这个名字有点令人困惑，来源于Perl。'
- en: '*Multiline*: `(?m)`'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '*多行模式*：`(?m)`'
- en: By default, `^` and `$` don’t really match the beginnings and ends of lines
    (as defined by carriage return or newline combinations). Instead, they match the
    beginning or end of the entire input text. In many cases, “one line” is synonymous
    with the entire input.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`^`和`$`实际上不匹配行的开头和结尾（由回车或换行符组合定义）。相反，它们匹配整个输入文本的开头或结尾。在许多情况下，“一行”与整个输入是同义的。
- en: If you have a big block of text to process, you’ll often break that block into
    separate lines for other reasons. If you do that, checking any given line for
    a regular expression will be straightforward, and `^` and `$` will behave as expected.
    However, if you want to use a regex with the entire input string containing multiple
    lines (separated by those carriage return or newline combinations), you can turn
    on multiline mode with `(?m)`. This flag causes `^` and `$` to match the beginning
    and end of the individual lines *within* the block of text, *as well as* the beginning
    and end of the entire block. Specifically, this means the spot before the first
    character, the spot after the last character, and the spots just before and after
    line terminators inside the string.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个大文本块需要处理，通常会出于其他原因将该块分成单独的行。如果你这样做，检查给定行是否符合正则表达式将会很简单，并且`^`和`$`将会按预期行为。然而，如果你想要在包含多行的整个输入字符串上使用正则表达式（由那些回车或换行符组合分隔），你可以打开多行模式`(?m)`。此标志导致`^`和`$`匹配文本块内单个行的开头和结尾，*以及*整个块的开头和结尾。具体来说，这意味着第一个字符之前的位置，最后一个字符之后的位置，以及字符串内的行终止符之前和之后的位置。
- en: '*Unix lines*: `(?d)`'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '*Unix行*：`(?d)`'
- en: The `(?d)` flag limits the definition of the line terminator for the `^`, `$`,
    and `.` special characters to Unix-style newline only (`\n`). By default, carriage
    return newline (`\r\n`) is also allowed.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`(?d)`标志将`^`、`$`和`.`特殊字符的行终止符定义限制为仅Unix风格的换行符（`\n`）。默认情况下，也允许回车换行符（`\r\n`）。'
- en: The java.util.regex API
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: java.util.regex API
- en: Now that we’ve covered the theory of how to construct regular expressions, the
    hard part is over. All that’s left is to investigate the Java API to see how to
    apply these expressions.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了如何构建正则表达式的理论部分，困难的部分已经过去了。剩下的就是调查Java API，看看如何应用这些表达式。
- en: Pattern
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模式
- en: As we’ve said, the regex patterns that we write as strings are, in actuality,
    little programs describing how to match text. At runtime, the Java regex package
    compiles these little programs into a form that it can execute against some target
    text. Several simple convenience methods accept strings directly to use as patterns.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'The static method `Pattern.matches()` takes two strings—a regex and a target
    string—and determines if the target matches the regex. This is very convenient
    if you want to do a quick test once in your application. For example:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This line of code can test whether the string `myText` contains a Java-style
    floating-point number such as “42.0f.” Note that the string must match completely
    to be considered a match. If you want to see if a small pattern is contained within
    a larger string but don’t care about the rest of the string, you have to use a
    `Matcher`, as described in [“The Matcher”](#learnjava6-CHP-8-SECT-3.2.2).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try another (simplified) pattern that we could use in our game once we
    start letting multiple players compete against each other. Many login systems
    use email addresses as the user identifier. Such systems aren’t perfect, of course,
    but an email address will work for our needs. We would like to invite users to
    input their email address, but we want to make sure it looks valid before using
    it. A regular expression can be a quick way to perform such a validation.^([3](ch08.html#id1659))
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'Much like writing algorithms to solve programming problems, designing a regular
    expression requires you to break your pattern matching problem into bite-sized
    pieces. If we think about email addresses, a few patterns stand out right away.
    The most obvious is the `@` in the middle of every address. A naive (but better
    than nothing!) pattern relying on that fact could be built like this:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'But that pattern is too permissive. It will certainly recognize valid email
    addresses, but it will also recognize many invalid ones like `"bad.address@"`
    or `"@also.bad"` or even `"@@"`. Let’s test these out in *jshell*:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Try to cook up a few more bad examples of your own. You’ll quickly see that
    our simple email pattern is definitely too simple.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'How can we make better matches? One quick adjustment would be to use the `+`
    modifier instead of the `*`. The upgraded pattern now requires at least one character
    on each side of the `@`. But we know a few other things about email addresses.
    For example, the left “half” of the address (the name portion) cannot contain
    the `@` character. For that matter, neither can the domain portion. We can use
    a custom character class for this next upgrade:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This pattern is better but still allows several invalid addresses such as `"still@bad"`
    since domain names have at least a name followed by a period (`.`) followed by
    a top-level domain (TLD) such as “oreilly.com.” So maybe a pattern like this:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'That pattern fixes our issue with an address like `"still@bad"`, but we’ve
    gone a bit too far the other way. There are many, many TLDs—too many to reasonably
    list even if we ignore the problem of maintaining that list as new TLDs are added.^([4](ch08.html#id1660))
    So let’s step back a little. We’ll keep the “dot” in the domain portion, but remove
    the specific TLD and just accept a simple run of letters:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 那个模式修复了我们在像`"still@bad"`这样的地址上的问题，但我们可能有点过火了。有许多、许多顶级域名后缀 —— 即使我们忽略了随着新的顶级域名后缀的添加而保持该列表的问题，也无法合理地列出所有顶级域名后缀。^([4](ch08.html#id1660))
    所以让我们稍微退一步。我们会保留域名部分的“点”，但移除特定的顶级域名后缀，只接受简单的字母序列：
- en: '[PRE45]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Much better. We can add one last tweak to make sure we don’t worry about the
    case of the address since all email addresses are case-insensitive. Just tack
    on the `(?i)` flag at the beginning of our pattern string:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 好多了。我们可以添加最后一个微调，以确保我们不用担心地址的大小写，因为所有电子邮件地址都是不区分大小写的。只需在我们的模式字符串的开头添加`(?i)`标志即可：
- en: '[PRE46]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Again, this is by no means a perfect email validator, but it is definitely
    a good start and suffices for our hypothetical login system:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这绝不是一个完美的电子邮件验证器，但它绝对是一个很好的开始，足以满足我们虚拟的登录系统的需求：
- en: '[PRE47]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In these examples, we typed in the full `Pattern.matches(…​)` line only once.
    After that it was a simple up arrow, edit, and then hit Return for the subsequent
    five lines. Can you spot the flaw in our final pattern that causes the match to
    fail?
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些例子中，我们只需一次输入完整的`Pattern.matches(…​)`行。之后只需简单地按向上箭头、编辑，然后按回车键即可获取接下来的五行。你能找出我们最终模式中导致匹配失败的缺陷吗？
- en: Note
  id: totrans-227
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to tinker around with the validation pattern and expand or improve
    it, remember you can “reuse” lines in *jshell* with the keyboard arrow keys. Use
    the up arrow to retrieve the previous line. Indeed, you can use the up arrow and
    down arrow to navigate all of your recent lines. Within a line, use the left arrow
    and right arrow to move around and delete/add/edit your command. Then just press
    the Return key to run the newly altered command—you do not need to move the cursor
    to the end of the line before pressing Return.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想调整验证模式并进行扩展或改进，请记住你可以使用键盘的上箭头在*jshell*中“重复使用”行。使用向上箭头检索前一行。确实，你可以使用上箭头和下箭头来导航你最近的所有行。在一行内，使用左箭头和右箭头移动、删除、添加或编辑你的命令。然后只需按回车键运行新修改的命令
    —— 你不需要在按回车键之前将光标移动到行尾。
- en: The Matcher
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Matcher`'
- en: A `Matcher` associates a pattern with a string and provides tools for testing,
    finding, and iterating over matches of the pattern against it. The `Matcher` is
    “stateful.” For example, the `find()` method tries to find the next match each
    time it is called. But you can clear the `Matcher` and start over by calling its
    `reset()` method.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`Matcher`关联模式与字符串，并提供测试、查找和迭代匹配项的工具。`Matcher`是“有状态的”。例如，`find()`方法每次调用时都会尝试找到下一个匹配项。但你可以通过调用其`reset()`方法来清除`Matcher`并重新开始。'
- en: 'To create a `Matcher` object, you first need to compile your pattern string
    into a `Pattern` object using the static `Pattern.compile()` method. With that
    pattern object in hand, you can use the `matcher()` method to get your `Matcher`,
    like so:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个`Matcher`对象，首先需要使用静态的`Pattern.compile()`方法将模式字符串编译成一个`Pattern`对象。有了该模式对象后，你可以使用`matcher()`方法获取你的`Matcher`，如下所示：
- en: '[PRE48]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: If you’re just interested in “one big match”—that is, you’re expecting your
    string to either match the pattern or not—you can use `matches()` or `lookingAt()`.
    These correspond roughly to the methods `equals()` and `startsWith()` of the `String`
    class. The `matches()` method asks if the string matches the pattern in its entirety
    (with no string characters left over) and returns `true` or `false`. The `lookingAt()`
    method does the same, except that it asks only whether the string starts with
    the pattern and doesn’t care if the pattern uses up all the string’s characters.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只对“一次大匹配”感兴趣 —— 也就是说，你期望你的字符串要么与模式匹配要么不匹配 —— 你可以使用`matches()`或`lookingAt()`。这些方法大致对应于`String`类的`equals()`和`startsWith()`方法。`matches()`方法询问字符串是否完全匹配模式（没有多余的字符串字符）并返回`true`或`false`。`lookingAt()`方法做同样的事情，只是它只询问字符串是否以该模式开头，并不在乎模式是否使用完所有字符串的字符。
- en: 'More generally, you’ll want to be able to search through the string and find
    one or more matches. To do this, you can use the `find()` method. Each call to
    `find()` returns `true` or `false` for the next match of the pattern and internally
    notes the position of the matching text. You can get the starting and ending character
    positions with the `Matcher start()` and `end()` methods, or you can simply retrieve
    the matched text with the `group()` method. For example:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The previous snippet prints the starting location of the words “horse” and
    “course” (four in all):'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Splitting strings
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A very common need is to parse a string into a bunch of fields based on some
    delimiter, such as a comma. It’s such a common problem that the `String` class
    contains a method for doing just this. The `split()` method accepts a regular
    expression and returns an array of substrings broken around that pattern. Consider
    the following string and `split()` calls:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The first `split()` returns a `String` array, but the naive use of `,` to separate
    the string means the space characters in our `text` variable remain stuck to the
    more interesting characters. We get `“Foo”` as a single word, as expected, but
    then we get `“bar<space>”` and finally `“<space><space><space>blah”`. Yikes! The
    second `split()` also yields a `String` array, but this time containing the expected
    `“Foo”, “bar”` (with no trailing space), and `“blah”` (with no leading spaces).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are going to use an operation like this more than a few times in your
    code, you should probably compile the pattern and use its `split()` method, which
    is identical to the version in `String`. The `String split()` method is equivalent
    to:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: As we noted before, there is a lot to learn about regular expressions above
    and beyond the few regex capabilities we covered here. Check out the [documentation
    on patterns](https://oreil.ly/L8BUD). Play around on your own using *jshell*.
    Modify the *ch08/examples/ValidEmail.java* file and see if you can create a better
    email validator! This is definitely a topic that benefits from practice.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Math Utilities
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Of course, string manipulation and pattern matching are not the only types of
    operations Java can do. Java supports integer and floating-point arithmetic directly
    in the language. Higher-level math operations are supported through the `java.lang.Math`
    class. As you have seen, wrapper classes for primitive data types allow you to
    treat them as objects. Wrapper classes also hold some methods for basic conversions.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with a quick look at the built-in arithmetic in Java. Java handles
    errors in integer arithmetic by throwing an `ArithmeticException`:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: To generate the error in this example, we created the intermediate variable
    `zero`. The compiler is somewhat crafty. It would have caught us if we had tried
    to divide by `0` directly.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Floating-point arithmetic expressions, on the other hand, don’t throw exceptions.
    Instead, they take on the special out-of-range values shown in [Table 8-2](#learnjava6-CHP-8-TABLE-2).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Table 8-2\. Special floating-point values
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | Mathematical representation |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
- en: '| `POSITIVE_INFINITY` | 1.0/0.0 |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
- en: '| `NEGATIVE_INFINITY` | -1.0/0.0 |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
- en: '| `NaN` | 0.0/0.0 |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
- en: 'The following example generates an infinite result:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The special value `NaN` (not a number) indicates the result of dividing zero
    by zero. This value has the special mathematical distinction of not being equal
    to itself (`NaN != NaN` evaluates to `true`). Use `Float.isNaN()` or `Double.isNaN()`
    to test for `NaN`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: The java.lang.Math Class
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `java.lang.Math` class is Java’s math library. It holds a suite of static
    methods covering all of the usual mathematical operations like `sin()`, `cos()`,
    and `sqrt()`. The `Math` class isn’t very object-oriented (you can’t create an
    instance of `Math`). Instead, it’s really just a convenient holder for static
    methods that are more like global functions. As we saw in [Chapter 5](ch05.html#learnjava6-CHP-5),
    it’s possible to use the static import functionality to import the names of static
    methods and constants like this directly into the scope of our class and use them
    by their simple, unqualified names.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 8-3](#learnjava6-CHP-8-TABLE-3) summarizes the methods in `java.lang.Math`.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Table 8-3\. Methods in java.lang.Math
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Argument type(s) | Functionality |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
- en: '| `Math.abs(a)` | `int`, `long`, `float`, `double` | Absolute value |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
- en: '| `Math.acos(a)` | `double` | Arc cosine |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
- en: '| `Math.asin(a)` | `double` | Arc sine |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
- en: '| `Math.atan(a)` | `double` | Arc tangent |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
- en: '| `Math.atan2(a,b)` | `double` | Angle part of rectangular-to-polar coordinate
    transform |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
- en: '| `Math.ceil(a)` | `double` | Smallest whole number greater than or equal to
    `a` |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
- en: '| `Math.cbrt(a)` | `double` | Cube root of `a` |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
- en: '| `Math.cos(a)` | `double` | Cosine |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
- en: '| `Math.cosh(a)` | `double` | Hyperbolic cosine |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
- en: '| `Math.exp(a)` | `double` | `Math.E` to the power `a` |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
- en: '| `Math.floor(a)` | `double` | Largest whole number less than or equal to `a`
    |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
- en: '| `Math.hypot(a,b)` | `double` | Precision calculation of the `sqrt()` of `a`2
    + `b`2 |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
- en: '| `Math.log(a)` | `double` | Natural logarithm of `a` |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
- en: '| `Math.log10(a)` | `double` | Log base 10 of `a` |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
- en: '| `Math.max(a, b)` | `int`, `long`, `float`, `double` | The value `a` or `b`
    closer to `Long.MAX_VALUE` |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
- en: '| `Math.min(a, b)` | `int`, `long`, `float`, `double` | The value `a` or `b`
    closer to `Long.MIN_VALUE` |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
- en: '| `Math.pow(a, b)` | `double` | `a` to the power `b` |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
- en: '| `Math.random()` | `None` | Random-number generator |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
- en: '| `Math.rint(a)` | `double` | Converts double value to integral value in double
    format |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
- en: '| `Math.round(a)` | `float`, `double` | Rounds to whole number |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
- en: '| `Math.signum(a)` | `float`, `double` | Get the sign of the number at 1.0,
    –1.0, or 0 |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
- en: '| `Math.sin(a)` | `double` | Sine |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
- en: '| `Math.sinh(a)` | `double` | Hyperbolic sine |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| `Math.sinh(a)` | `double` | 双曲正弦 |'
- en: '| `Math.sqrt(a)` | `double` | Square root |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| `Math.sqrt(a)` | `double` | 平方根 |'
- en: '| `Math.tan(a)` | `double` | Tangent |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| `Math.tan(a)` | `double` | 正切 |'
- en: '| `Math.tanh(a)` | `double` | Hyperbolic tangent |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| `Math.tanh(a)` | `double` | 双曲正切 |'
- en: '| `Math.toDegrees(a)` | `double` | Convert radians to degrees |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| `Math.toDegrees(a)` | `double` | 将弧度转换为角度 |'
- en: '| `Math.toRadians(a)` | `double` | Convert degrees to radians |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| `Math.toRadians(a)` | `double` | 将角度转换为弧度 |'
- en: 'The methods `log()`, `pow()`, and `sqrt()` can throw a runtime `ArithmeticException`.
    The methods `abs()`, `max()`, and `min()` are overloaded for all the scalar values
    (`int`, `long`, `float`, and `double`) and return the corresponding type. Versions
    of `Math.round()` accept either `float` or `double` and return `int` or `long`,
    respectively. The rest of the methods operate on and return `double` values:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 `log()`、`pow()` 和 `sqrt()` 可能会抛出运行时的 `ArithmeticException`。方法 `abs()`、`max()`
    和 `min()` 都针对所有标量值（`int`、`long`、`float` 和 `double`）进行了重载，并返回相应的类型。`Math.round()`
    的版本接受 `float` 或 `double`，分别返回 `int` 或 `long`，其余的方法均操作并返回 `double` 值：
- en: '[PRE55]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Just to highlight the convenience of that static import option, try these simple
    functions in *jshell*:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 只是为了突显静态导入选项的便利性，请在 *jshell* 中尝试这些简单的函数：
- en: '[PRE56]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '`Math` also contains the static final double constants `E` and `PI`. To find
    the perimeter of a circle, for example:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math` 还包含静态的最终双精度常量 `E` 和 `PI`。例如，要找到圆的周长：'
- en: '[PRE57]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Math in action
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数学的实际应用
- en: 'We’ve already touched on using the `Math` class and its static methods in [“Accessing
    Fields and Methods”](ch05.html#learnjava6-CHP-5-SECT-1.2). We can use it again
    to make our game a little more fun by randomizing where the trees appear. The
    `Math.random()` method returns a random `double` greater than or equal to 0 and
    less than 1\. Add in a little arithmetic and rounding or truncating, and you can
    use that value to create random numbers in any range you need. In particular,
    converting this value into a desired range follows this formula:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了如何在 [“访问字段和方法”](ch05.html#learnjava6-CHP-5-SECT-1.2) 中使用 `Math` 类及其静态方法。我们可以再次使用它，通过随机化树木出现的位置使我们的游戏更加有趣。`Math.random()`
    方法返回一个大于或等于 0 且小于 1 的随机 `double`。通过一些算术运算和舍入或截断，您可以使用该值创建任何所需范围内的随机数。特别地，将该值转换为所需范围的方法如下：
- en: '[PRE58]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Try it! Try to generate a random four-digit number in *jshell*. You could set
    the `min` to 1,000 and the `max` to 10,000, like so:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 试一试！尝试在 *jshell* 中生成一个随机的四位数。您可以将 `min` 设置为 1,000，将 `max` 设置为 10,000，如下所示：
- en: '[PRE59]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'To place our trees, we’ll need two random numbers for the x and y coordinates.
    We can set a range that will keep the trees on the screen by thinking about a
    margin around the edges. For the x coordinate, one way to do that might look like
    this:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 要放置我们的树木，我们需要两个随机数来获取 x 和 y 坐标。我们可以设置一个边缘周围的范围，通过在边缘周围留出一些空白来保持树木在屏幕上。对于 x 坐标，可能会像这样：
- en: '[PRE60]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Set up a similar method for finding a y value, and you should start to see
    something like the image shown in [Figure 8-1](#learnjava6-CHP-8-FIG-1). You could
    even get fancy and use the `isTouching()` method we discussed back in [Chapter 5](ch05.html#learnjava6-CHP-5)
    to avoid placing any trees in direct contact with our physicist. Here’s our upgraded
    tree setup loop:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 设置一个类似的方法来查找 y 值，你应该会看到类似于 [图 8-1](#learnjava6-CHP-8-FIG-1) 中显示的图像。您甚至可以使用我们在
    [第 5 章](ch05.html#learnjava6-CHP-5) 中讨论过的 `isTouching()` 方法，以避免将任何树木放置在与我们的物理学家直接接触的位置。这是我们升级后的树木设置循环：
- en: '[PRE61]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '![ljv6 0801](assets/ljv6_0801.png)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0801](assets/ljv6_0801.png)'
- en: Figure 8-1\. Randomly distributed trees
  id: totrans-310
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-1\. 随机分布的树木
- en: Try quitting the game and launching it again. You should see the trees in different
    places each time you run the application.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试退出游戏并再次启动它。您应该会看到每次运行应用程序时树木的不同位置。
- en: Big/Precise Numbers
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大/精确数值
- en: 'If the `long` and `double` types are not large or precise enough for you, the
    `java.math` package provides two classes, `BigInteger` and `BigDecimal`, that
    support arbitrary-precision numbers. These full-featured classes have a bevy of
    methods for performing arbitrary-precision^([5](ch08.html#id1702)) math and precisely
    controlling rounding of remainders. In the following example, we use `BigDecimal`
    to add two very large numbers and then create a fraction with a 100-digit result:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `long` 和 `double` 类型对您来说不够大或精确，那么 `java.math` 包提供了两个类，`BigInteger` 和 `BigDecimal`，支持任意精度的数字。这些功能齐全的类具有大量方法，用于执行任意精度数学运算并精确控制余数的舍入。在以下示例中，我们使用
    `BigDecimal` 来添加两个非常大的数字，然后创建一个带有 100 位小数的分数：
- en: '[PRE62]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: If you implement cryptographic or scientific algorithms for fun, `BigInteger`
    is crucial. `BigDecimal`, in turn, can be found in applications dealing with currency
    and financial data. Other than that, you’re not likely to need these classes.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Dates and Times
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with dates and times without the proper tools can be a chore. Java includes
    three classes that handle simple cases for you. The `java.util.Date` class encapsulates
    a point in time. The `java.util.GregorianCalendar` class, which extends the abstract
    `java.util.Calendar`, translates between a point in time and calendar fields like
    month, day, and year. Finally, the `java.text.DateFormat` class knows how to generate
    and parse string representations of dates and times in many languages and locales.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: While the `Date` and `Calendar` classes covered many use cases, they lacked
    granularity and were missing other features. Several third-party libraries cropped
    up, all aimed at making it easier for developers to work with dates and times
    and time durations. Java 8 provided much needed improvements in this area with
    the addition of the `java.time` package. The rest of this chapter explores this
    package, but you will still encounter many, many `Date` and `Calendar` examples
    in the wild, so it’s useful to know they exist. As always, the [online docs](https://oreil.ly/Behlk)
    are an invaluable source for reviewing parts of the Java API we don’t tackle here.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: Local Dates and Times
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `java.time.LocalDate` class represents a date without time information
    for your local region. Think of an annual event such as the winter solstice on
    December 21\. Similarly, `java.time.LocalTime` represents a time without any date
    information. Perhaps your alarm clock goes off at 7:15 every morning. The `java.time.LocalDateTime`
    stores both date and time values for things like appointments with your eye doctor
    (so you can keep reading books on Java). All of these classes offer static methods
    for creating new instances, either using appropriate numeric values with the method
    `of()` or by parsing strings with `parse()`. Let’s pop into *jshell* and try creating
    a few examples:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Another great static method for creating these objects is `now()`, which provides
    the current date, time, or date-and-time as you might expect:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Great! After importing the `java.time` package, you can create instances of
    each of the `Local…​` classes for specific moments or for “right now.” You may
    have noticed the objects created with `now()` include seconds and nanoseconds
    in the time. You can supply those values to the `of()` and `parse()` methods if
    you want or need them. Not much exciting there, but once you have these objects,
    you can do a lot with them. Read on!
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: Comparing and Manipulating Dates and Times
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the big advantages of using `java.time` classes is the consistent set
    of methods available for comparing and changing dates and times. For example,
    many chat applications will show you “how long ago” a message was sent. The `java.time.temporal`
    subpackage has just what we need: the `ChronoUnit` interface. It contains several
    date and time units such as `MONTHS`, `DAYS`, `HOURS`, `MINUTES`, etc. These units
    can be used to calculate differences. For example, we could calculate how long
    it takes us to create two example date-times in *jshell* using the `between()`
    method:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: A visual spot check shows that it did indeed take about 11 seconds to type in
    the line that created our `second` variable. Check out the [docs for `ChronoUnit`](https://oreil.ly/BhCr2)
    for a complete list, but you get the full range, from nanoseconds up to millennia.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: 'Those units can also help you manipulate dates and times with the `plus()`
    and `minus()` methods. To set a reminder for one week from today, for example:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Neat! But this `reminder` example brings up another bit of manipulation you
    may need to perform from time to time. You might want a reminder at a particular
    time on the 7th. You can convert between dates, times, and date-times easily enough
    with the `atDate()` or `atTime()` methods:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Now you’ll get a reminder at 9 A.M. Except, what if you set that reminder in
    Atlanta and then flew to San Francisco? When would the alarm go off? `LocalDateTime`
    is, well, local! So the `T09:00` portion is still 9 A.M. wherever you are when
    you run the program. But if you are handling something like scheduling a meeting,
    you can’t ignore the different time zones involved. Fortunately the `java.time`
    package has thought of that, too.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: Time Zones
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The authors of the new `java.time` package encourage you to use the local variations
    of the time and date classes where possible. Adding support for time zones means
    adding complexity to your app—they want you to avoid that complexity if possible.
    But there are many scenarios where support for time zones is unavoidable. You
    can work with “zoned” dates and times using the `ZonedDateTime` and `OffsetDateTime`
    classes. The zoned variant understands named time zones and things like daylight
    saving adjustments. The offset variant is a constant, simple numeric offset from
    UTC/Greenwich.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: 'Most user-facing uses of dates and times will use the named zone approach,
    so let’s look at creating a zoned date-time. To attach a zone, we use the `ZoneId`
    class, which has the common `of()` static method for creating new instances. You
    can supply a region zone as a `String` to get your zoned value:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'And now you can do things like make sure your friends in Paris can join you
    at the correct moment using the verbosely but aptly named `withZoneSameInstant()`
    method:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'If you have other friends who aren’t conveniently located in a major metropolitan
    region but you want them to join as well, you can use the `systemDefault()` method
    of `ZoneId` to pick up their time zone programmatically:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: We were running *jshell* on a laptop in the Eastern time zone of the United
    States. `piOther` comes out exactly as hoped. The `systemDefault()` zone ID is
    a very handy way to quickly tailor date-times from other zones to match what your
    user’s clock and calendar are most likely to say. In commercial applications you
    may want to let the user tell you their preferred zone, but `systemDefault()`
    is usually a good guess.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: Parsing and Formatting Dates and Times
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For creating and showing our local and zoned date-times using strings, we’ve
    been relying on the default formats that follow ISO values. These generally work
    wherever we need to accept or display dates and times. But as every programmer
    knows, “generally” is not “always.” Fortunately, you can use the utility class
    `java.time.format.DateTimeFormatter` to help with parsing input and formatting
    output.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: The core of `DateTimeFormatter` centers on building a format string that governs
    both parsing and formatting. You build up your format with the pieces listed in
    [Table 8-4](#learnjava6-CHP-8-TABLE-4). We are listing only a portion of the options
    available here, but these should get you through the bulk of the dates and times
    you will encounter. Note that case matters when using the characters mentioned!
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: Table 8-4\. Popular and useful `DateTimeFormatter` elements
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '| Character | Description | Example |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
- en: '| a | am-pm-of-day | PM |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
- en: '| d | day-of-month | 10 |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
- en: '| E | day-of-week | Tue; Tuesday; T |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
- en: '| G | era | BCE, CE |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
- en: '| k | clock-hour-of-day (1-24) | 24 |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
- en: '| K | hour-of-am-pm (0-11) | 0 |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
- en: '| L | month-of-year | Jul; July; J |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
- en: '| h | clock-hour-of-am-pm (1-12) | 12 |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
- en: '| H | hour-of-day (0-23) | 0 |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
- en: '| m | minute-of-hour | 30 |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
- en: '| M | month-of-year | 7; 07 |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
- en: '| s | second-of-minute | 55 |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
- en: '| S | fraction-of-second | 033954 |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
- en: '| u | year (without era) | 2004; 04 |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
- en: '| y | year-of-era | 2004; 04 |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
- en: '| z | time-zone name | Pacific Standard Time; PST |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
- en: '| Z | zone-offset | +0000; -0800; -08:00 |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
- en: 'To put together a common US short format, for example, you could use the `M`,
    `d`, and `y` characters. You build the formatter using the static `ofPattern()`
    method. Now you can use (and reuse) the formatter with the `parse()` method of
    any of the date or time classes:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'And as we mentioned earlier, the formatter works in both directions. Just use
    the `format()` method of your formatter to produce a string representation of
    your date or time:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Of course, formatters work for times and date-times as well!
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Notice in the `ZonedDateTime` portion that follows that we put the time zone
    identifier (the `z` character) at the end—probably not where you were expecting
    it!
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: We wanted to illustrate the power of these formats. You can design a format
    to accommodate a very wide range of input or output styles. Legacy data and poorly
    designed web forms come to mind as direct examples where `DateTimeFormatter` can
    help.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: Parsing Errors
  id: totrans-375
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Even with all this parsing power at your fingertips, things will sometimes
    go wrong. Regrettably, the exceptions you see are often too vague to be immediately
    useful. Consider the following attempt to parse a time with hours, minutes, and
    seconds:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Yikes! Java will throw a `DateTimeParseException` any time it cannot parse
    the string input. Java will also throw the exception in cases like our example
    above; the fields were correctly parsed from the string, but they did not supply
    enough information to create a `LocalTime` object. It may not be obvious, but
    our time, `“3:14:15,”` could be either mid-afternoon or very early in the morning.
    Our choice of the `hh` pattern for the hours turns out to be the culprit. We can
    either pick an hour pattern that uses an unambiguous 24-hour scale or we can add
    an explicit A.M./P.M. element:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'If you ever get a `DateTimeParseException` but your input looks like a correct
    match for the format, double-check that your format itself includes everything
    necessary to create your date or time. One parting thought on these exceptions:
    you may need to use the nonmnemonic `u` character for parsing years if your dates
    don’t naturally include an era designator such as `CE`.'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: There are many, *many* more details on `DateTimeFormatter`. For this, more than
    for most utility classes, it’s worth a trip to [read the docs online](https://oreil.ly/rhosl).
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: Formatting Dates and Times
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that you know how to create, parse, and store dates and times, you need
    to display that handy data. Happily, you can build nice, human-readable strings
    using the same formatter you built to parse dates and times from strings. Remember
    our `withSeconds` and `military` formatters? You can pick up the current time
    and quickly turn it into either format, like this:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: You can use any date or time pattern you build from the parts shown in [Table 8-4](#learnjava6-CHP-8-TABLE-4)
    to produce this formatted output. Hop into *jshell* and try creating a few formats.
    You can use the `LocalTime.now()` and `LocalDate.now()` methods to create some
    easy targets for your formatting tests.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: Timestamps
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One other popular date-time concept that `java.time` understands is timestamps.
    In any situation where you need to track the flow of information, you’ll need
    a record of exactly when the information is produced or modified. You will still
    see the `java.util.Date` class used to store these moments in time, but the `java.time.Instant`
    class carries everything you need for a timestamp and comes with all the other
    benefits of the other classes in the `java.time` package:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: If dates or times appear in your work, the `java.time` package makes for a welcome
    helper. You have a mature, well-designed set of tools for dealing with this data—no
    third-party libraries needed!
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: Other Useful Utilities
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve looked at some of Java’s building blocks, including strings and numbers,
    as well as one of the most popular combinations of those strings and numbers—dates—in
    the `LocalDate` and `LocalTime` classes. We hope this range of utilities has given
    you a sense of how Java works with many of the elements you are likely to encounter.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to read the documentation on the `java.util`, `java.text`, and `java.time`
    packages for more utilities that may come in handy. For example, you could look
    into using `java.util.Random` for generating the random coordinates of the trees
    in [Figure 8-1](#learnjava6-CHP-8-FIG-1). Sometimes “utility” work is actually
    complex and requires careful attention to detail. Searching online for code examples
    or even complete libraries written by other developers may speed up your own efforts.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we’ll start building on these fundamental concepts. Java remains as
    popular as it is because it includes support for more advanced techniques in addition
    to the basics. One of those techniques is the “thread” features, which are baked
    right in. Threads provide better access to modern, powerful systems, keeping your
    applications performant even while handling many complex tasks. We’ll show you
    how to take advantage of this signature feature in [Chapter 9](ch09.html#learnjava6-CHP-9).
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: Review Questions
  id: totrans-394
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Which class contains the constant π? Do you need to import that class to use
    π?
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which package contains better replacements for the original `java.util.Date`
    class?
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which class should you use to format a date for user-friendly output?
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What symbol would you use in a regular expression to help match the words “yes”
    and “yup”?
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you convert the string “42” into the integer 42?
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you compare two strings (such as “yes” and “YES”) to see if they match,
    ignoring any capitalization?
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which operator concatenates strings?
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Code Exercises
  id: totrans-402
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s revisit our graphical Hello Java application and upgrade it using some
    new utilities and string features discussed in this chapter. You can start with
    the `HelloChapter8` class in the *exercises/ch08* folder. We want the program
    to support some command-line arguments for the message and initial position.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: 'Your program should accept 0, 1, or 2 arguments:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: Zero arguments should place the text “Hello, utilities!” at the center to start.
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One argument should be treated as the message to display; it should be centered
    to start:'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember that multiword messages must be enclosed in quotes.
  id: totrans-407
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the message is the word `today`, your code should generate a formatted date
    to use as the message.
  id: totrans-408
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Two arguments represent the message and initial coordinates for where to display
    it:'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The coordinates should be a quoted string containing a pair of numbers separated
    by a comma and optional whitespace. These are all valid coordinate strings:'
  id: totrans-410
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`150,150`'
  id: totrans-411
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`50, 50`'
  id: totrans-412
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`100, 220`'
  id: totrans-413
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The coordinates argument may also be the word `random`, meaning your code should
    generate a random initial position.
  id: totrans-414
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some examples:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: If the user tries to pass three or more arguments, your code should generate
    an error message and exit.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: Start by testing the number of arguments. If your program gets at least one
    argument, use the first argument for the message. If it gets two, you’ll need
    to split the coordinates and convert them to numbers. If you get the `random`
    argument, be sure to generate random numbers that will keep the message visible.
    (You can assume some reasonable default length for the message; it’s OK if some
    of a longer message gets truncated on the right side.)
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: Test out your solution with a few runs. Try different coordinates. Try the randomized
    option. Try the randomized option a few times successively to make sure the starting
    position really does change. What happens if you misspell `random` in the second
    argument?
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: 'For a further upgrade: try to write a regular expression to accept some variations
    on `random` while still ignoring the case:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '`random`'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rand`'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rndm`'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`r`'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As always, you can find a few hints for this problem in [Appendix B](app02.html#learnjava6-APP-B).
    Our solutions are in the *ch08/exercises* folder of the source code.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch08.html#id1542-marker)) When in doubt, measure it! If your `String`-manipulating
    code is clean and easy to understand, don’t rewrite it until someone proves to
    you that it is too slow. Chances are that they will be wrong. And don’t be fooled
    by relative comparisons. A millisecond is a thousand times slower than a microsecond,
    but it still may be negligible to your application’s overall performance.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch08.html#id1549-marker)) On most platforms the default encoding is UTF-8\.
    You can get more details on character sets, default sets, and standard sets supported
    by Java in the [official Javadoc documentation](https://oreil.ly/UarRO) for the
    `java.nio.charset.Charset` class.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch08.html#id1659-marker)) Validating email addresses turns out to be much
    trickier than we can address here. Regular expressions can cover most valid addresses,
    but if you are doing validation for a commercial or other professional application,
    you may want to investigate third-party libraries, such as those available from
    [Apache Commons](https://oreil.ly/JEjEk).
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch08.html#id1660-marker)) You are welcome to [apply for your own, custom
    global TLD](https://oreil.ly/lMRnm) if you have a few hundred thousand dollars
    lying around.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](ch08.html#id1702-marker)) The `float` type is “single-precision,” and
    `double` is, well, double-precision. (Hence its name!) A `double` can retain numbers
    with roughly twice the precision as a `float`. Arbitrary-precision simply means
    that you can have as many digits as you need before and after the decimal point.
    To be fair, NASA uses a value for π with only 15 digits of precision, which `double`
    can handle fine.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
