- en: Chapter 6\. Packaging Quarkus Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn about packaging a Quarkus service into a JVM
    or a native format so that it can be distributed and deployed. Today, when containers
    are becoming the standard way to distribute applications, you need to know how
    to containerize them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to package a Quarkus application for running in the JVM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to package a Quarkus application in a native executable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to containerize a Quarkus application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6.1 Running in Command Mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create a CLI application.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With Quarkus, you can also write applications that run and then optionally exit.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable command mode in Quarkus, you need to create a class that implements
    the `io.quarkus.runtime.QuarkusApplication` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_packaging_quarkus_applications_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Interface to set Quarkus in command mode
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_packaging_quarkus_applications_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The method executed when the `main` is called
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_packaging_quarkus_applications_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Do not exit but wait until Quarkus process is stopped
  prefs: []
  type: TYPE_NORMAL
- en: 'Then you can implement the well-known Java `main` method. One of the requirements
    is that the class with the `main` method must be annotated with the `@io.quarkus.runtime.annotations.QuarkusMain`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_packaging_quarkus_applications_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the class as `main`
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_packaging_quarkus_applications_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Starts the process
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to access the command arguments, you can inject them using the
    `@io.quarkus.runtime.annotations.CommandLineArguments` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_packaging_quarkus_applications_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Injects the command-line arguments
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you can build the project and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Two different methods can be used to implement applications that exit. We explained
    the first method in the previous section; the second method is by annotating the
    class that is implementing the `io.quarkus.runtime.QuarkusApplication` interface
    with `@io.quarkus.runtime.annotations.QuarkusMain annotation`.
  prefs: []
  type: TYPE_NORMAL
- en: The drawback of the second solution is that you cannot run it from the IDE,
    and this is the reason we suggest you use the former approach.
  prefs: []
  type: TYPE_NORMAL
- en: As you’ve seen in the example, if you want to run some logic on startup and
    then run it like a normal application (i.e., not exit), then you should call `Quarkus.waitForExit`
    from the main thread. If you don’t call this method, then the Quarkus application
    is started and then terminated, so your application effectively behaves like any
    other CLI program.
  prefs: []
  type: TYPE_NORMAL
- en: 6.2 Creating a Runnable JAR File
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create a runnable JAR file to be distributed/containerized into
    a machine with a JVM installed.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the *Quarkus Maven plug-in* to create a runnable JAR.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Quarkus Maven plug-in is installed by default if you have scaffolded the
    project using any of the starters mentioned in previous recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then run `package` goal to build the JAR file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `target` directory contains the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_packaging_quarkus_applications_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: An executable JAR (not über-JAR)
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_packaging_quarkus_applications_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Location of dependencies
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_packaging_quarkus_applications_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Lib folder with application dependencies
  prefs: []
  type: TYPE_NORMAL
- en: If you want to deploy the application, it is important to copy together the
    *executable JAR* with the `lib` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can run the application by running the next command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Running Quarkus in this way is known as running Quarkus in the *JVM mode*. This
    means that you are not producing a native compilation but are running your application
    inside the JVM.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you want to package a Quarkus application in JVM mode into a container, we
    recommend using this approach because the layers created during the container
    build stage are cached to be reused later. Libraries are something that do not
    usually change, so this dependency layer might be reused several times in future
    executions, speeding up the container build time.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a runnable JAR file with Gradle, you can run the `quarkusBuild` task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are interested in how to create an über-JAR or how to containerize a
    Quarkus application, see [Recipe 6.3](#uber_jar_packaging).
  prefs: []
  type: TYPE_NORMAL
- en: 6.3 Über-JAR Packaging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create an über-JAR of your Quarkus application.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Quarkus Maven plug-in supports the generation of über-JARs by specifying an
    `uberJar` configuration option in your *pom.xml*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an über-JAR, a JAR that contains your code `runnable classes` and
    all required dependencies, you need to configure Quarkus accordingly in the *application.properties*
    file by setting `quarkus.package.uber-jar` to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 6.4 Building a Native Executable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to build your Quarkus application as a native executable file.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use Quarkus and GraalVM to build a native runnable file that is ideal for containers
    and serverless loads.
  prefs: []
  type: TYPE_NORMAL
- en: Native executables make Quarkus applications ideal for containers and serverless
    workloads. Quarkus relies on [GraalVM](https://www.graalvm.org) to build a Java
    application as a native executable.
  prefs: []
  type: TYPE_NORMAL
- en: Before building a native executable, make sure to have the `GRAALVM_HOME` environment
    variable set to the GraalVM 19.3.1 or 20.0.0 installation directory.
  prefs: []
  type: TYPE_NORMAL
- en: Important
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If you are using macOS, the variable should point to the *Home* sub-directory:
    `export GRAALVM_HOME=<installation_dir>/Development/graalvm/Contents/Home/`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When a Quarkus project is generated using any of the methods explained before,
    it registers a default Maven profile with the name `native` that can be used to
    build a Quarkus native executable application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you need to build the project with the `native` profile enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'After a few minutes, a native executable will be present in `target` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To build a native executable in Gradle, you can use the `buildNative` task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 6.5 Building a Docker Container for JAR File
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to build a container with the JAR built in the [Recipe 6.2](#runnable_jar)
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the *Dockerfile.jvm* file provided to build the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a Quarkus project is generated using any of the methods explained before,
    two Dockerfiles are created in *src/main/docker*: one for generating a Docker
    container using Quarkus in the JVM mode and another one for the native executable.'
  prefs: []
  type: TYPE_NORMAL
- en: To generate a container for running Quarkus inside the JVM (no native), you
    can use the *Dockerfile.jvm* file to build the container. This Dockerfile adds
    the *lib* directory and the runnable JAR and exposes JMX.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build the Docker image, you need to package the project as shown in [Recipe
    6.2](#runnable_jar) and then build the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The container can be started by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 6.6 Building a Docker Container for Native File
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to build a native executable container image.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To generate a container for running a Quarkus native executable, you can use
    the *Dockerfile.native* file to build the container.
  prefs: []
  type: TYPE_NORMAL
- en: To build the Docker image, you need to create a native file that can be run
    in a Docker container. For this reason, don’t use local GraalVM to build the native
    executable because the result file will be specific to your operating system and
    will not be able to run inside a container.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an executable that will run in a container, use the following command
    in your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This command creates a Docker image that contains GraalVM installed to produce
    a 64-bit Linux executable from your code.
  prefs: []
  type: TYPE_NORMAL
- en: Important
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You need to have `native` profile defined in your *pom.xml*, as explained in
    the [Recipe 6.4](#native_executable) recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step is to build the Docker image with the native executable that
    was generated in the previous step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then the container can be started by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, Quarkus uses `docker` to build the container. The container runtime
    can be changed by using the `quarkus.native.container-runtime` property. At the
    time of writing the book, `docker` and `podman` are the supported options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 6.7 Build and Dockerize a Native SSL Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When building a native executable, you want to secure connections to prevent
    an attacker from stealing sensitive information.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Enable Quarkus to use SSL to secure connections in a native executable.
  prefs: []
  type: TYPE_NORMAL
- en: If you are running the Quarkus application in JVM mode, SSL is supported without
    any problem, just as any other JVM application. But SSL is not supported out of
    the box in the case of native executables, and some extra steps (especially when
    Dockerizing the application) must be executed to enable SSL support.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s enable SSL support for native executables in Quarkus by adding the `quarkus.ssl.native`
    configuration property at *application.properties*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Enabling this property allows the Graal VM `native-image` process to enable
    SSL. Create a native executable using the next command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the important flags that are added automatically by the process
    to enable SSL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: To Dockerize this native executable, the Docker-related scripts need to be modified
    slightly to support SSL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `.dockeringnore` and add the `keystore.jks` file as a nonignorable file
    to be added into the resulted container. This is necessary because the keystore
    file needs to be copied together with the executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The *src/main/docker/Dockerfile.native* file must also be adapted to package
    the following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: The SunEC library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The collection of trusted certificate authority files needed to verify certificates
    used in the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_packaging_quarkus_applications_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Gets SunEC library and `cacerts` from GraalVM Docker image
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_packaging_quarkus_applications_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Copies custom `keystore.jks` at root working directory
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_packaging_quarkus_applications_CO5-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets up permissions
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_packaging_quarkus_applications_CO5-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Exposes HTTPS port
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_packaging_quarkus_applications_CO5-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Loads SunEC and `cacerts` when running the application
  prefs: []
  type: TYPE_NORMAL
- en: 'The container image can be built by running the next command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Security and SSL are common now, and it is good practice to always have all
    your services communicate using SSL. For this reason, Quarkus enables SSL support
    automatically when any of the following extensions are registered:'
  prefs: []
  type: TYPE_NORMAL
- en: Agroal connection pooling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amazon DynamoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hibernate Search Elasticsearch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Infinispan Client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jaeger
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JGit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keycloak
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mailer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MongoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Neo4j
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OAuth2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: REST client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As long as you have one of those extensions in your project, the `quarkus.native.ssl`
    property is set to `true` by default.
  prefs: []
  type: TYPE_NORMAL
