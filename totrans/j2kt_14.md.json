["```java\nval fx: ExchangeRates = ...\nval userCurrency = ...\nval calculator = CostSummaryCalculator(userCurrency, fx) ![1](assets/1.png)\n\nfun costSummary(i: Itinerary): CostSummary {\n    i.addCostsTo(calculator) ![2](assets/2.png)\n    return calculator.summarise() ![3](assets/3.png)\n}\n```", "```java\ndata class Itinerary(\n    val id: Id<Itinerary>,\n    val route: Route,\n    val accommodations: List<Accommodation> = emptyList()\n) {\n    ...\n\n    fun addCostsTo(calculator: CostSummaryCalculator) {\n        route.addCostsTo(calculator)\n        accommodations.addCostsTo(calculator)\n    }\n\n    ...\n}\n\nfun Iterable<Accommodation>.addCostsTo(calculator: CostSummaryCalculator) {\n    forEach { a ->\n        a.addCostsTo(calculator)\n    }\n}\n```", "```java\ndata class CurrencyConversion(\n    val fromMoney: Money,\n    val toMoney: Money\n)\n```", "```java\npublic class CostSummary {\n    private final List<CurrencyConversion> lines = new ArrayList<>();\n    private Money total;\n\n    public CostSummary(Currency userCurrency) {\n        this.total = Money.of(0, userCurrency);\n    }\n\n    public void addLine(CurrencyConversion line) {\n        lines.add(line);\n        total = total.add(line.getToMoney());\n    }\n\n    public List<CurrencyConversion> getLines() {\n        return List.copyOf(lines);\n    }\n\n    public Money getTotal() {\n        return total;\n    }\n}\n```", "```java\npublic class CostSummaryCalculator {\n    private final Currency userCurrency;\n    private final ExchangeRates exchangeRates;\n    private final Map<Currency, Money> currencyTotals = new HashMap<>();\n\n    public CostSummaryCalculator(\n        Currency userCurrency,\n        ExchangeRates exchangeRates\n    ) {\n        this.userCurrency = userCurrency;\n        this.exchangeRates = exchangeRates;\n    }\n\n    public void addCost(Money cost) {\n        currencyTotals.merge(cost.getCurrency(), cost, Money::add);\n    }\n\n    public CostSummary summarise() {\n        var totals = new ArrayList<>(currencyTotals.values());\n        totals.sort(comparing(m -> m.getCurrency().getCurrencyCode()));\n\n        CostSummary summary = new CostSummary(userCurrency);\n        for (var total : totals) {\n            summary.addLine(exchangeRates.convert(total, userCurrency));\n        }\n\n        return summary;\n    }\n\n    public void reset() {\n        currencyTotals.clear();\n    }\n}\n```", "```java\nclass CostSummary(userCurrency: Currency) {\n    private val _lines = mutableListOf<CurrencyConversion>()\n\n    var total: Money = Money.of(0, userCurrency)\n        private set\n\n    val lines: List<CurrencyConversion>\n        get() = _lines.toList()\n\n    fun addLine(line: CurrencyConversion) {\n        _lines.add(line)\n        total += line.toMoney\n    }\n}\n```", "```java\nclass CostSummaryCalculator(\n    private val userCurrency: Currency,\n    private val exchangeRates: ExchangeRates\n) {\n    private val currencyTotals = mutableMapOf<Currency, Money>()\n\n    fun addCost(cost: Money) {\n        currencyTotals.merge(cost.currency, cost, Money::add)\n    }\n\n    fun summarise(): CostSummary {\n        val totals = ArrayList(currencyTotals.values)\n        totals.sortWith(comparing { m: Money -> m.currency.currencyCode })\n\n        val summary = CostSummary(userCurrency)\n        for (total in totals) {\n            summary.addLine(exchangeRates.convert(total, userCurrency))\n        }\n        return summary\n    }\n\n    fun reset() {\n        currencyTotals.clear()\n    }\n}\n```", "```java\nfun summarise(): CostSummary {\n    val totals = currencyTotals.values.sortedBy {\n        it.currency.currencyCode\n    }\n    val summary = CostSummary(userCurrency)\n    for (total in totals) {\n        summary.addLine(exchangeRates.convert(total, userCurrency))\n    }\n    return summary\n}\n```", "```java\nfun summarise(): CostSummary {\n    val totals = currencyTotals.values.sortedBy {\n        it.currency.currencyCode\n    }\n    val summary = CostSummary(userCurrency).apply {\n        for (total in totals) {\n            addLine(exchangeRates.convert(total, userCurrency))\n        }\n    }\n    return summary\n}\n```", "```java\nfun summarise(): CostSummary {\n    val conversions = currencyTotals.values.sortedBy {\n        it.currency.currencyCode\n    }.map { exchangeRates.convert(it, userCurrency) }\n\n    return CostSummary(userCurrency).apply {\n        conversions.forEach(this::addLine)\n    }\n}\n```", "```java\nclass CostSummary(userCurrency: Currency) {\n    private val _lines = mutableListOf<CurrencyConversion>()\n\n    var total: Money = Money.of(0, userCurrency)\n        private set\n\n    val lines: List<CurrencyConversion>\n        get() = _lines.toList()\n\n    constructor(\n        userCurrency: Currency,\n        lines: List<CurrencyConversion>\n    ): this(userCurrency) {\n        lines.forEach(::addLine)\n    }\n\n    fun addLine(line: CurrencyConversion) {\n        _lines.add(line)\n        total += line.toMoney\n    }\n}\n```", "```java\nfun summarise(): CostSummary {\n    val conversions = currencyTotals.values.sortedBy {\n        it.currency.currencyCode\n    }.map { exchangeRates.convert(it, userCurrency) }\n\n    return CostSummary(userCurrency, conversions)\n}\n```", "```java\nclass CostSummary(\n    userCurrency: Currency,\n    val lines: List<CurrencyConversion>\n) {\n\n    var total: Money = Money.of(0, userCurrency)\n        private set\n\n    init {\n        lines.forEach {\n            total += it.toMoney\n        }\n    }\n}\n```", "```java\nclass CostSummary(\n    userCurrency: Currency,\n    val lines: List<CurrencyConversion>\n) {\n    val total = lines\n        .map { it.toMoney }\n        .fold(Money.of(0, userCurrency), Money::add)\n}\n```", "```java\nclass CostSummary(\n    val lines: List<CurrencyConversion>,\n    total: Money\n) {\n    val total = total\n}\n```", "```java\nclass CostSummary(\n    val lines: List<CurrencyConversion>,\n    val total: Money\n)\n```", "```java\nfun summarise(): CostSummary {\n    val lines = currencyTotals.values\n        .sortedBy { it.currency.currencyCode }\n        .map { exchangeRates.convert(it, userCurrency) }\n\n    val total = lines\n        .map { it.toMoney }\n        .fold(Money.of(0, userCurrency), Money::add)\n\n    return CostSummary(lines, total)\n}\n```", "```java\ndata class CostSummary(\n    val lines: List<CurrencyConversion>,\n    val total: Money\n)\n```", "```java\nclass CostSummary(userCurrency: Currency) {\n    private val _lines = mutableListOf<CurrencyConversion>()\n\n    var total: Money = Money.of(0, userCurrency)\n        private set\n\n    val lines: List<CurrencyConversion>\n        get() = _lines.toList()\n\n    fun addLine(line: CurrencyConversion) {\n        _lines.add(line)\n        total += line.toMoney\n    }\n}\n```", "```java\nval total = lines\n    .map { it.toMoney }\n    .fold(Money.of(0, userCurrency), Money::add)\n```", "```java\nclass CostSummaryCalculator(\n    private val userCurrency: Currency,\n    private val exchangeRates: ExchangeRates\n) {\n    private val currencyTotals = mutableMapOf<Currency, Money>()\n\n    fun addCost(cost: Money) {\n        currencyTotals.merge(cost.currency, cost, Money::add)\n    }\n\n    fun summarise(): CostSummary {\n        val lines = currencyTotals.values\n            .sortedBy { it.currency.currencyCode }\n            .map { exchangeRates.convert(it, userCurrency) }\n\n        val total = lines\n            .map { it.toMoney }\n            .fold(Money.of(0, userCurrency), Money::add)\n\n        return CostSummary(lines, total)\n    }\n\n    fun reset() {\n        currencyTotals.clear()\n    }\n}\n```", "```java\nfun summarise(costs: Iterable<Money>): CostSummary {\n    val delegate = CostSummaryCalculator(userCurrency, exchangeRates)\n    costs.forEach(delegate::addCost)\n    return delegate.summarise()\n}\n```", "```java\nval fx: ExchangeRates = ...\nval userCurrency = ...\nval calculator = CostSummaryCalculator(userCurrency, fx)\n\nfun costSummary(i: Itinerary) =\n    calculator.summarise(i.costs())\n```", "```java\ndata class Itinerary(\n    val id: Id<Itinerary>,\n    val route: Route,\n    val accommodations: List<Accommodation> = emptyList()\n) {\n    ...\n\n    fun costs(): List<Money> = route.costs() + accommodations.costs()\n    ...\n}\n\nfun Iterable<Accommodation>.costs(): List<Money> = flatMap { it.costs() }\n```", "```java\nfun summarise(costs: Iterable<Money>): CostSummary {\n    val delegate = CostSummaryCalculator(userCurrency, exchangeRates)\n    costs.forEach(delegate::addCost)\n    return delegate.summarise()\n}\n```", "```java\nfun summarise(costs: Iterable<Money>): CostSummary {\n    val currencyTotals = mutableMapOf<Currency, Money>()\n    costs.forEach {\n        currencyTotals.merge(it.currency, it, Money::plus)\n    }\n    val lines = currencyTotals.values\n        .sortedBy { it.currency.currencyCode }\n        .map { exchangeRates.convert(it, userCurrency) }\n    val total = lines\n        .map { it.toMoney }\n        .fold(Money(0, userCurrency), Money::add)\n    return CostSummary(lines, total)\n}\n```", "```java\nclass CostSummaryCalculator(\n    private val userCurrency: Currency,\n    private val exchangeRates: ExchangeRates\n) {\n    fun summarise(costs: Iterable<Money>): CostSummary {\n        val currencyTotals: List<Money> = costs\n            .groupBy { it.currency }\n            .values\n            .map { moneys -> moneys.reduce(Money::add) }\n        val lines: List<CurrencyConversion> = currencyTotals\n            .sortedBy { it.currency.currencyCode }\n            .map { exchangeRates.convert(it, userCurrency) }\n        val total = lines\n            .map { it.toMoney }\n            .fold(Money(0, userCurrency), Money::add)\n        return CostSummary(lines, total)\n    }\n}\n```", "```java\nclass PricingContext(\n    private val userCurrency: Currency,\n    private val exchangeRates: ExchangeRates\n) {\n    fun toUserCurrency(money: Money) =\n        exchangeRates.convert(money, userCurrency)\n\n    fun summarise(costs: Iterable<Money>): CostSummary {\n        val currencyTotals: List<Money> = costs\n            .groupBy { it.currency }\n            .values\n            .map {\n                it.sumOrNull() ?: error(\"Unexpected empty list\")\n            }\n        val lines: List<CurrencyConversion> = currencyTotals\n            .sortedBy { it.currency.currencyCode }\n            .map(::toUserCurrency)\n        val total = lines\n            .map { it.toMoney }\n            .sum(userCurrency)\n        return CostSummary(lines, total)\n    }\n}\n```", "```java\nval fx: ExchangeRates = ...\nval userCurrency = ...\nval pricing = PricingContext(userCurrency, fx)\n\nfun costSummary(i: Itinerary) = pricing.summarise(i.costs())\n```"]