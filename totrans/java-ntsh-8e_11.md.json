["```java\nString pet = \"Cat\";\n```", "```java\nchar[] pullingTeeth = {'C', 'a', 't'};\nString pet = new String(pullingTeeth);\n```", "```java\nSystem.out.println(\"Dog\".length());\n```", "```java\nString lyrics = \"\"\"\n This is the song that never ends\n This song goes on and one my friend\n ...\"\"\";\n```", "```java\n    public void println(Object x) {\n        String s = String.valueOf(x);\n        synchronized (this) {\n            print(s);\n            newLine();\n        }\n    }\n```", "```java\n    public static String valueOf(Object obj) {\n        return (obj == null) ? \"null\" : obj.toString();\n    }\n```", "```java\nString s1 = \"AB\";\nString s2 = \"CD\";\n\nString s3 = s1;\nSystem.out.println(s1 == s3); // Same object? Yes.\n\ns3 = s1 + s2;\nSystem.out.println(s1 == s3); // Still same? Nope!\nSystem.out.println(s1);\nSystem.out.println(s3);\n```", "```java\nString pet = \"Cat\";\nStringBuilder sb = new StringBuilder(pet);\nsb.append(\"amaran\");\nString boat = sb.toString();\nSystem.out.println(boat);\n```", "```java\nString pet = \"Cat\";\nString boat = pet + \"amaran\";\nSystem.out.println(boat);\n```", "```java\n    public int hashCode() {\n        int h = hash;\n        if (h == 0 && value.length > 0) {\n            char val[] = value;\n\n            for (int i = 0; i < value.length; i++) {\n                h = 31 * h + val[i];\n            }\n            hash = h;\n        }\n        return h;\n    }\n```", "```java\n// Result is the string \"The 1 pet is a cat: true?\"\nvar s = String.format(\"The %d pet is a %s: %b?%n\", 1, \"cat\", true);\n\n// Same result, but called on string instance instead of statically\ns = \"The %d pet is a %s: %b?%n\".formatted(1, \"cat\", true);\n```", "```java\n// Some common locales are available as constants\n// A much longer list can be accessed at runtime\nvar locale = Locale.US;\n\nNumberFormat.getNumberInstance(locale).format(1_000_000_000L)\n// 1,000,000,000\n\nNumberFormat.getCurrencyInstance(locale).format(1_000_000_000L)\n// $1,000,000,000.00\n\nNumberFormat.getPercentInstance(locale).format(0.1)\n// 10%\n\nNumberFormat.getCompactNumberInstance(locale , NumberFormat.Style.LONG)\n            .format(1_000_000_000L)\n// 1 billion\n\nNumberFormat.getCompactNumberInstance(locale, NumberFormat.Style.SHORT)\n            .format(1_000_000_000L)\n// 1B\n```", "```java\nls *.java\n```", "```java\nPattern p = Pattern.compile(\"honou?r\");\n\nString caesarUK = \"For Brutus is an honourable man\";\nMatcher mUK = p.matcher(caesarUK);\n\nString caesarUS = \"For Brutus is an honorable man\";\nMatcher mUS = p.matcher(caesarUS);\n\nSystem.out.println(\"Matches UK spelling? \" + mUK.find());\nSystem.out.println(\"Matches US spelling? \" + mUS.find());\n```", "```java\nPattern p = Pattern.compile(\"minimi[sz]e\");\n```", "```java\nString text = \"Apollo 13\";\n\n// A numeric digit. Note we must use \\\\ because we need a literal \\\n// and Java uses a single \\ as an escape character, as per the table\nPattern p = Pattern.compile(\"\\\\d\");\nMatcher m = p.matcher(text);\nSystem.out.print(p + \" matches \" + text + \"? \" + m.find());\nSystem.out.println(\" ; match: \" + m.group());\n\n// A single letter\np = Pattern.compile(\"[a-zA-Z]\");\nm = p.matcher(text);\nSystem.out.print(p + \" matches \" + text + \"? \" + m.find());\nSystem.out.println(\" ; match: \" + m.group());\n\n// Any number of letters, which must all be in the range 'a' to 'j'\n// but can be upper- or lowercase\np = Pattern.compile(\"([a-jA-J]*)\");\nm = p.matcher(text);\nSystem.out.print(p + \" matches \" + text + \"? \" + m.find());\nSystem.out.println(\" ; match: \" + m.group());\n\n// 'a' followed by any four characters, followed by 'b'\ntext = \"abacab\";\np = Pattern.compile(\"a....b\");\nm = p.matcher(text);\nSystem.out.print(p + \" matches \" + text + \"? \" + m.find());\nSystem.out.println(\" ; match: \" + m.group());\n```", "```java\nString text = \"Apollo 13\";\n\nPattern p = Pattern.compile(\"Apollo (\\\\d*)\");\nMatcher m = p.matcher(text);\nSystem.out.print(p + \" matches \" + text + \"? \" + m.find());\nSystem.out.println(\"; mission: \" + m.group(1));\n```", "```java\n// Detect if there are any double-quoted passages in string\n// Note standard string literal requires escaping quotations\nPattern oldQuoted = Pattern.compile(\".*\\\".*\\\".*\");\n\nPattern newQuoted = Pattern.compile(\"\"\"\n .*\".*\".*\"\"\");\n```", "```java\n// Contains a numeric digit\nPattern p = Pattern.compile(\"\\\\d\");\n\nList<String> ls = List.of(\"Cat\", \"Dog\", \"Ice-9\", \"99 Luftballoons\");\nList<String> containDigits = ls.stream()\n        .filter(p.asPredicate())\n        .toList();\n\nSystem.out.println(containDigits);\n```", "```java\nbyte b = 0b0000_0001;\nSystem.out.println(b); // 1\n\nb = 0b0000_0010;\nSystem.out.println(b); // 2\n\nb = 0b0000_0011;\nSystem.out.println(b); // 3\n\n// ...\n\nb = 0b0111_1111;\nSystem.out.println(b); // 127\n```", "```java\nb = (byte) 0b1111_1111; // -1\nSystem.out.println(b);\nb++;\nSystem.out.println(b);\n\nb = (byte) 0b1111_1110; // -2\nSystem.out.println(b);\nb++;\nSystem.out.println(b);\n```", "```java\nb = (byte) 0b1000_0000;\nSystem.out.println(b); // -128\n```", "```java\npublic static final double E = 2.7182818284590452354;\npublic static final double PI = 3.14159265358979323846;\n```", "```java\nThis starts to suggest the basis of how floating-point numbers work. We\nuse some of the bits to represent the significant digits (`314159265`,\nin our example) of the number and some bits to represent the *exponent*\nof the base (`-8`, in our example). The collection of significant digits\nis called the *significand* and the exponent describes whether we need\nto shift the significand up or down to get to the desired number.\nOf course, in the examples we’ve met until now, we’ve been working in\nbase-10\\. Computers use binary, so we need to use this as the base in our\nfloating-point examples. This introduces some additional complications.\n\n###### Note\n\nThe number `0.1` cannot be expressed as a finite sequence of binary\ndigits. This means that virtually all calculations that humans care\nabout will lose precision when performed in floating point, and rounding\nerror is essentially inevitable.\n\nLet’s look at an example that shows the rounding problem:\n\n```", "```java\n\nThe official standard that describes floating-point arithmetic is IEEE-754, and\nJava’s support for floating point is based on that standard. The standard uses\n24 binary digits for standard precision and 53 binary digits for double\nprecision.\nAs we mentioned briefly in [Chapter 2](ch02.xhtml#javanut8-CHP-2), Java previously allowed deviation\nfrom this standard, resulting in greater precision when some hardware features\nwere used to accelerate calculations. As of Java 17, this is no longer allowed,\nand all floating-point operations comply with the IEEE-754 standard.\n\n### BigDecimal\n\nRounding error is a constant source of headaches for programmers who\nwork with floating-point numbers. In response, Java has a class\n`java.math.BigDecimal` that provides arbitrary precision arithmetic, in\na decimal representation. This works around the problem of `0.1` not\nhaving a finite representation in binary, but there are still some edge\nconditions when converting to or from Java’s primitive types, as you can\nsee:\n\n```", "```java\n\nHowever, even with all arithmetic performed in base-10, there are still\nnumbers, such as `1/3`, that do not have a terminating decimal\nrepresentation. Let’s see what happens when we try to represent such\nnumbers using `BigDecimal`:\n\n```", "```java\n\nAs `BigDecimal` can’t represent `1/3` precisely, the call to `divide()`\nblows up with `ArithmeticException`. When you are working with `BigDecimal`, it\nis therefore necessary to be acutely aware of exactly which operations\ncould result in a nonterminating decimal result. To make matters worse,\n`ArithmeticException` is an unchecked, runtime exception and so the Java\ncompiler does not even warn about possible exceptions of this type.\n\nAs a final note on floating-point numbers, the paper “What Every\nComputer Scientist Should Know About Floating-Point Arithmetic” by David\nGoldberg should be considered essential further reading for all\nprofessional programmers. It is easily and freely obtainable on the\ninternet.\n\n```", "```java\nSystem.out.println(Math.abs(2));\nSystem.out.println(Math.abs(-2));\n\ndouble cosp3 = Math.cos(0.3);\ndouble sinp3 = Math.sin(0.3);\nSystem.out.println((cosp3 * cosp3 + sinp3 * sinp3)); // Always 1.0\n\nSystem.out.println(Math.max(0.3, 0.7));\nSystem.out.println(Math.max(0.3, -0.3));\nSystem.out.println(Math.max(-0.3, -0.7));\n\nSystem.out.println(Math.min(0.3, 0.7));\nSystem.out.println(Math.min(0.3, -0.3));\nSystem.out.println(Math.min(-0.3, -0.7));\n\nSystem.out.println(Math.floor(1.3));\nSystem.out.println(Math.ceil(1.3));\nSystem.out.println(Math.floor(7.5));\nSystem.out.println(Math.ceil(7.5));\n\nSystem.out.println(Math.round(1.3)); // Returns long\nSystem.out.println(Math.round(7.5)); // Returns long\n\nSystem.out.println(Math.pow(2.0, 10.0));\nSystem.out.println(Math.exp(1));\nSystem.out.println(Math.exp(2));\nSystem.out.println(Math.log(2.718281828459045));\nSystem.out.println(Math.log10(100_000));\nSystem.out.println(Math.log10(Integer.MAX_VALUE));\n\nSystem.out.println(Math.random());\nSystem.out.println(\"Let's toss a coin: \");\nif (Math.random() > 0.5) {\n    System.out.println(\"It's heads\");\n} else {\n    System.out.println(\"It's tails\");\n}\n```", "```java\n    // From java.util.Random\n    public double nextDouble() {\n        return (((long)(next(26)) << 27) + next(27)) * DOUBLE_UNIT;\n    }\n```", "```java\npublic class BirthdayDiary {\n    private Map<String, LocalDate> birthdays;\n\n    public BirthdayDiary() {\n        birthdays = new HashMap<>();\n    }\n\n    public LocalDate addBirthday(String name, int day, int month,\n                                 int year) {\n        LocalDate birthday = LocalDate.of(year, month, day);\n        birthdays.put(name, birthday);\n        return birthday;\n    }\n\n    public LocalDate getBirthdayFor(String name) {\n        return birthdays.get(name);\n    }\n\n    public int getAgeInYear(String name, int year) {\n        Period period = Period.between(\n              birthdays.get(name),\n              birthdays.get(name).withYear(year));\n\n        return period.getYears();\n    }\n\n    public Set<String> getFriendsOfAgeIn(int age, int year) {\n        return birthdays.keySet().stream()\n                .filter(p -> getAgeInYear(p, year) == age)\n                .collect(Collectors.toSet());\n    }\n\n    public int getDaysUntilBirthday(String name) {\n        Period period = Period.between(\n              LocalDate.now(),\n              birthdays.get(name));\n\n        return period.getDays();\n    }\n\n    public Set<String> getBirthdaysIn(Month month) {\n        return birthdays.entrySet().stream()\n                .filter(p -> p.getValue().getMonth() == month)\n                .map(p -> p.getKey())\n                .collect(Collectors.toSet());\n    }\n\n    public Set<String> getBirthdaysInCurrentMonth() {\n        return getBirthdaysIn(LocalDate.now().getMonth());\n    }\n\n    public int getTotalAgeInYears() {\n        return birthdays.keySet().stream()\n                .mapToInt(p -> getAgeInYear(p,\n                      LocalDate.now().getYear()))\n                .sum();\n    }\n}\n```", "```java\npublic interface TemporalQuery<R> {\n    R queryFrom(TemporalAccessor temporal);\n}\n```", "```java\nLocalDate today = LocalDate.now();\nMonth currentMonth = today.getMonth();\nMonth firstMonthofQuarter = currentMonth.firstMonthOfQuarter();\n```", "```java\npublic enum Quarter {\n    FIRST, SECOND, THIRD, FOURTH;\n}\n```", "```java\npublic class QuarterOfYearQuery implements TemporalQuery<Quarter> {\n    @Override\n    public Quarter queryFrom(TemporalAccessor temporal) {\n        LocalDate now = LocalDate.from(temporal);\n\n        if(now.isBefore(now.with(Month.APRIL).withDayOfMonth(1))) {\n            return Quarter.FIRST;\n        } else if(now.isBefore(now.with(Month.JULY)\n                               .withDayOfMonth(1))) {\n            return Quarter.SECOND;\n        } else if(now.isBefore(now.with(Month.NOVEMBER)\n                               .withDayOfMonth(1))) {\n            return Quarter.THIRD;\n        } else {\n           return Quarter.FOURTH;\n        }\n    }\n}\n```", "```java\nQuarterOfYearQuery q = new QuarterOfYearQuery();\n\n// Direct\nQuarter quarter = q.queryFrom(LocalDate.now());\nSystem.out.println(quarter);\n\n// Indirect\nquarter = LocalDate.now().query(q);\nSystem.out.println(quarter);\n```", "```java\npublic class FirstDayOfQuarter implements TemporalAdjuster {\n    @Override\n    public Temporal adjustInto(Temporal temporal) {\n        final int currentQuarter = YearMonth.from(temporal)\n                .get(IsoFields.QUARTER_OF_YEAR);\n\n        final Month firstMonthOfQuarter = switch (currentQuarter) {\n            case 1 -> Month.JANUARY;\n            case 2 -> Month.APRIL;\n            case 3 -> Month.JULY;\n            case 4 -> Month.OCTOBER;\n            default -> throw new IllegalArgumentException(\"Impossible\");\n        };\n\n        return LocalDate.from(temporal)\n                .withMonth(firstMonthOfQuarter.getValue())\n                .with(TemporalAdjusters.firstDayOfMonth());\n    }\n}\n```", "```java\nLocalDate now = LocalDate.now();\nTemporal fdoq = now.with(new FirstDayOfQuarter());\nSystem.out.println(fdoq);\n```", "```java\n// Defaults to timestamp when called\nvar oldDate = new java.util.Date();\n\n// Note both forms require specifying timezone -\n// part of the failing in the old API\nvar newDate = LocalDate.ofInstant(\n                  oldDate.toInstant(),\n                  ZoneId.systemDefault());\n\nvar newTime = LocalDateTime.ofInstant(\n                  oldDate.toInstant(),\n                  ZoneId.systemDefault());\n```"]