- en: Chapter 2\. Performance Testing Methodology
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章。性能测试方法论
- en: Performance testing is undertaken for a variety of reasons. In this chapter
    we will introduce the different types of performance test that a team may wish
    to execute, and discuss some best practices for each subtype of testing.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 进行性能测试有多种原因。在本章中，我们将介绍团队可能希望执行的不同类型的性能测试，并讨论每个子类型测试的一些最佳实践。
- en: Later in the chapter we will discuss statistics, and some very important human
    factors that, are often neglected when considering performance problems.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章稍后我们将讨论统计数据和一些非常重要的人因素，这些因素在考虑性能问题时经常被忽视。
- en: Types of Performance Test
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能测试类型
- en: Performance tests are frequently conducted for the wrong reasons, or conducted
    badly. The reasons for this vary widely, but are often rooted in a failure to
    understand the nature of performance analysis and a belief that “doing something
    is better than doing nothing.” As we will see several times throughout the book,
    this belief is often a dangerous half-truth at best.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 经常以错误的原因进行性能测试，或者测试做得很差。造成这种情况的原因各不相同，但通常根源于未能理解性能分析的本质以及认为“做点什么总比什么都不做好”的信念。正如我们将在本书中多次看到的那样，这种信念通常最多只能算是半个真理，却往往是危险的。
- en: One of the more common mistakes is to speak generally of “performance testing”
    without engaging with the specifics. In fact, there are many different types of
    large-scale performance tests that can be conducted on a system.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更常见的错误是泛泛地谈论“性能测试”，而不深入讨论具体问题。事实上，可以对系统进行许多不同类型的大规模性能测试。
- en: Note
  id: totrans-6
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Good performance tests are quantitative. They ask questions that produce a numeric
    answer that can be handled as an experimental output and subjected to statistical
    analysis.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的性能测试是定量的。它们提出能够产生数值答案的问题，并且可以作为实验输出进行统计分析。
- en: The types of performance tests we will discuss in this book usually have independent
    (but somewhat overlapping) goals. It is therefore important to understand the
    quantitative questions you are trying to answer before deciding what type of testing
    should be carried out.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将讨论的性能测试类型通常具有独立的（但有些重叠的）目标。因此，在决定应进行哪种类型的测试之前，了解您试图回答的定量问题非常重要。
- en: This doesn’t have to be that complex—​simply writing down the questions the
    test is intended to answer can be enough. However, it is usual to consider why
    these tests are important for the application and confirming the reason with the
    application owner (or key customers).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不一定那么复杂——仅仅写下测试意图要回答的问题可能就足够了。然而，通常考虑为何这些测试对应用程序很重要，并通过应用程序所有者（或关键客户）确认这一点是常见的。
- en: 'Some of the most common test types, and an example question for each, are as
    follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一些最常见的测试类型及其每种类型的示例问题如下：
- en: Latency test
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟测试
- en: What is the end-to-end transaction time?
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的端到端事务时间是多少？
- en: Throughput test
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 吞吐量测试
- en: How many concurrent transactions can the current system capacity deal with?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当前系统容量能够处理多少并发事务？
- en: Load test
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 负载测试
- en: Can the system handle a specific load?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 系统能够处理特定负载吗？
- en: Stress test
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 压力测试
- en: What is the breaking point of the system?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的破坏点在哪里？
- en: Endurance test
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 耐久性测试
- en: What performance anomalies are discovered when the system is run for an extended
    period?
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 系统长时间运行时会发现什么性能异常？
- en: Capacity planning test
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 容量规划测试
- en: Does the system scale as expected when additional resources are added?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当增加额外资源时，系统是否按预期扩展？
- en: Degradation
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 退化
- en: What happens when the system is partially failed?
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统部分失败时会发生什么？
- en: Let’s look in more detail at each of these test types in turn.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们依次更详细地查看每种测试类型。
- en: Latency Test
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 延迟测试
- en: 'Latency is one of the most common types of performance test, because it is
    often a system observable of keen interest to management (and users): how long
    are our customers waiting for a transaction (or a page load)?'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟通常是性能测试中最常见的类型之一，因为它通常是一个系统可观察的重点，对管理层（和用户）而言尤为关注：我们的客户等待交易（或页面加载）多长时间？
- en: This can a double-edged sword, because the simplicity of the question (that
    a latency test seeks to answer) can cause teams to focus too much on latency.
    This, in turn, can cause the team to ignore the necessity of identifying quantitative
    questions for other types of performance tests.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是一个两面刃，因为延迟测试试图回答的问题的简单性可能会导致团队过分关注延迟。这反过来可能导致团队忽视识别其他类型性能测试的定量问题的必要性。
- en: Note
  id: totrans-29
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The goal of a latency tuning exercise is usually to directly improve the user
    experience, or to meet a service-level agreement.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: However, even in the simplest of cases, a latency test has some subtleties that
    must be treated carefully. One of the most noticeable is that a simple mean (average)
    is not very useful as a measure of how well an application is reacting to requests.
    We will discuss this subject more fully in [“Statistics for JVM Performance”](#pracjavaperf-CHP-2-SECT-4)
    and explore additional measures.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Throughput Test
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Throughput is probably the second most common quantity to be performance-tested.
    It can even be thought of as dual to latency, in some senses.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: For example, when we are conducting a latency test, it is important to state
    (and control) the concurrent transactions count when producing a distribution
    of latency results. Similarly, when we are conducting a throughput test, we must
    make sure to keep an eye on latency and check that it is not blowing up to unacceptable
    values as we ramp up.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-35
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The observed latency of a system should be stated at known and controlled throughput
    levels, and vice versa.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: We determine the “maximum throughput” by noticing when the latency distribution
    suddenly changes—effectively a “breaking point” (also called an *inflection point*)
    of the system. The point of a stress test, as we will see in an upcoming section,
    is to locate such points and the load levels at which they occur.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: A throughput test, on the other hand, is about measuring the observed maximum
    throughput before the system starts to degrade. Once again, these test types are
    discussed separately, but are rarely truly independent in practice.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Stress Test
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One way to think about a stress test is as a way to determine how much spare
    headroom the system has. The test typically proceeds by placing the system into
    a steady state of transactions—that is, a specified throughput level (often the
    current peak). The test then ramps up the concurrent transactions slowly, until
    the system observables start to degrade.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: The value just before the observables started to degrade determines the maximum
    throughput achieved in a stress test.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Load Test
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A load test differs from a throughput test (or a stress test) in that it is
    usually framed as a binary test: “Can the system handle this projected load or
    not?” Load tests are sometimes conducted in advance of expected business events—for
    example, the onboarding of a new customer or market that is expected to drive
    greatly increased traffic to the application.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Other examples of possible events that could warrant performing this type of
    test include advertising campaigns, social media events, and “viral content.”
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Endurance Test
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some problems manifest only over much longer periods of time (often measured
    in days). These include slow memory leaks, cache pollution, and memory fragmentation
    (especially for applications that may eventually suffer a GC concurrent mode failure;
    see Chapter 5 for more details).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: To detect these types of issues, an endurance test (also known as a soak test)
    is the usual approach. These are run at average (or high) utilization, but within
    observed realistic loads for the system. During the test, resource levels are
    closely monitored to spot any breakdowns or exhaustions of resources.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要检测这些问题类型，耐久性测试（也称为浸泡测试）是通常的方法。这些测试在系统的观察到的实际负载范围内以平均（或高）利用率运行。在测试期间，会密切监控资源水平，以发现任何资源耗尽或耗尽的情况。
- en: This type of test is more common in low-latency systems, as it is very common
    that those systems will not be able to tolerate the length of a stop-the-world
    event caused by a full GC cycle (see Chapter 4 and subsequent chapters for more
    on stop-the-world events and related GC concepts).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这种测试在低延迟系统中更为常见，因为这些系统很常见地无法容忍因全GC周期（见第4章及后续章节了解有关全停顿事件和相关GC概念的更多信息）引起的停顿事件的长度。
- en: Endurance tests are not performed as often as they perhaps should be, for the
    simple reason that they take a long time to run and can be very expensive—​but
    there are no shortcuts. There is also the inherent difficulty of testing with
    realistic data or usage patterns over a long period. This can be one of the major
    reasons why teams end up “testing in production”.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 耐久性测试并不像它们应有的频率那样经常进行，因为它们运行时间长且非常昂贵——但是没有捷径。另外，长时间内使用真实数据或使用模式进行测试也存在困难。这可能是团队最终“在生产环境中测试”的主要原因之一。
- en: This type of test is also not always applicable to microservice or other architectures
    where there may be a lot of code changes deployed in a short time.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的测试在微服务或其他架构中并不总是适用，因为在短时间内可能会部署许多代码更改。
- en: Capacity Planning Test
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容量规划测试
- en: Capacity planning tests bear many similarities to stress tests, but they are
    a distinct type of test. The role of a stress test is to find out what the current
    system will cope with, whereas a capacity planning test is more forward-looking
    and seeks to find out what load an upgraded system could handle.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 容量规划测试与压力测试有很多相似之处，但它们是不同类型的测试。压力测试的作用是找出当前系统能够承受什么，而容量规划测试更具前瞻性，旨在找出升级系统能够处理的负载。
- en: For this reason, capacity planning tests are often carried out as part of a
    scheduled planning exercise, rather than in response to a specific event or threat.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 出于这个原因，容量规划测试通常作为计划性规划活动的一部分进行，而不是对特定事件或威胁的响应。
- en: Degradation Test
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 降级测试
- en: Once upon a time, rigorous failover and recovery testing was really only practiced
    in the most highly regulated and scrutinized environments (including banks and
    financial institutions). However, as applications have migrated to the cloud,
    clustered deployments (e.g. based on Kubernetes) have become more and more common.
    One primary consequence of this is that more and more developers now need to be
    aware of the possible failure modes of clustered applications.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 曾经，严格的故障转移和恢复测试实际上只在最高度规范和审查的环境中（包括银行和金融机构）进行。然而，随着应用程序迁移到云端，基于 Kubernetes 等的集群部署变得越来越普遍。这带来的一个主要后果是，越来越多的开发人员现在需要意识到集群应用可能的故障模式。
- en: Note
  id: totrans-56
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A full discussion of all aspects of resilience and fail-over testing is outside
    the scope of this book. In Chapter 15, we will discuss some of the simpler effects
    that can be seen in cloud systems when a cluster partially fails, or needs to
    recover.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 本书不包括所有弹性和故障转移测试的全面讨论。在第15章中，我们将讨论云系统中出现部分集群故障或需要恢复时可能见到的一些较简单的影响。
- en: In this section, the only type of resilience test we will discuss is the degradation
    test—​this type of test is also known as a *partial failure* test.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将仅讨论一种弹性测试类型，即降级测试——这种测试也被称为*部分失效*测试。
- en: The basic approach to this test is to see how the system behaves when a component
    or entire subsystem suddenly loses capacity while the system is running at simulated
    loads equivalent to usual production volumes. Examples could be application server
    clusters that suddenly lose members, or network bandwidth that suddenly drops.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这种测试的基本方法是观察系统在模拟负载下运行时，当组件或整个子系统突然失去容量时的行为。例如，可能是应用服务器集群突然失去成员，或者网络带宽突然下降。
- en: Key observables during a degradation test include the transaction latency distribution
    and throughput.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 降级测试期间的关键观测点包括事务延迟分布和吞吐量。
- en: One particularly interesting subtype of partial failure test is known as the
    [*Chaos Monkey*](https://github.com/Netflix/chaosmonkey). This is named after
    a project at Netflix that was undertaken to verify the robustness of its infrastructure.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 部分故障测试中一个特别有趣的子类型被称为[*Chaos Monkey*](https://github.com/Netflix/chaosmonkey)。这是Netflix为验证其基础设施的稳健性而开展的一个项目的名字。
- en: The idea behind Chaos Monkey is that in a truly resilient architecture, the
    failure of a single component should not be able to cause a cascading failure
    or have a meaningful impact on the overall system.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Chaos Monkey的想法是，在一个真正具有弹性的架构中，单个组件的故障不应该导致级联故障或对整体系统产生有意义的影响。
- en: Chaos Monkey forces system operators to confront this possibility by randomly
    killing off live processes in the production environment.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Chaos Monkey通过在生产环境中随机终止活跃进程，迫使系统操作员面对这种可能性。
- en: In order to successfully implement Chaos Monkey–type systems, an organization
    must have very high levels of system hygiene, service design, and operational
    excellence. Nevertheless, it is an area of interest and aspiration for an increasing
    number of companies and teams.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要成功实施Chaos Monkey类型的系统，组织必须拥有非常高的系统卫生、服务设计和运营卓越水平。尽管如此，它仍然是越来越多公司和团队感兴趣和渴望的领域。
- en: Best Practices Primer
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳实践指南
- en: 'When deciding where to focus your effort in a performance tuning exercise,
    there are three golden rules that can provide useful guidance:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定在性能调优中集中精力的地方时，有三个黄金规则可以提供有用的指导：
- en: Identify what you care about and figure out how to measure it.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定你关心的内容，并找出如何衡量它。
- en: Optimize what matters, not what is easy to optimize.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化重要的，而不是容易优化的。
- en: Play the big points first.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 先处理主要问题。
- en: The second point has a converse, which is to remind yourself not to fall into
    the trap of attaching too much significance to whatever quantity you can easily
    measure. Not every observable is significant to a business, but it is sometimes
    tempting to report on an easy measure, rather than the right measure.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 第二点的反面是提醒自己不要陷入过于重视任何容易测量的量的陷阱。不所有可观察的指标对业务都重要，但有时报告容易测量的指标，而不是正确的指标是很有诱惑的。
- en: To the third point, it is also easy to fall into the trap of optimizing small
    things simply for the sake of optimizing.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 关于第三点，优化小事情的陷阱也很容易让人陷入，只是为了优化而优化。
- en: Top-Down Performance
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自上而下的性能
- en: One of the aspects of Java performance that many engineers miss at first sight
    is that large-scale benchmarking of Java applications is usually much easier than
    trying to get accurate numbers for small sections of code.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Java性能的一个方面，许多工程师初看时会忽略的是，大规模基准测试Java应用程序通常比尝试获得小代码段的准确数据要容易得多。
- en: This is such a widely misunderstood point, that to deliberately deemphasize
    it, we do not discuss *microbenchmarking* in the main book text at all. Instead,
    it is discussed in Appendix A --a placement that more accurately reflects the
    utility of the technique for the majority of applications.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个广泛误解的观点，为了刻意弱化它，我们在主要书文本中根本没有讨论*微基准测试*。相反，在附录A中讨论，这更准确地反映了该技术对大多数应用的实用性。
- en: Note
  id: totrans-75
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The approach of starting with the performance behavior of an entire application
    is usually called *top-down* performance.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从整个应用程序的性能行为开始的方法通常称为*自上而下*性能。
- en: To make the most of the top-down approach, a testing team needs a test environment,
    a clear understanding of what it needs to measure and optimize, and an understanding
    of how the performance exercise will fit into the overall software development
    lifecycle.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用自上而下的方法，测试团队需要一个测试环境，清楚了解需要测量和优化的内容，并了解性能测试如何融入整体软件开发生命周期。
- en: Creating a Test Environment
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建测试环境
- en: Setting up a test environment is one of the first tasks most performance testing
    teams will need to undertake. Wherever possible, this should be an exact duplicate
    of the production environment, in all aspects.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 设置测试   设置测试环境是大多数性能测试团队需要首先完成的任务。尽可能地，这应该是生产环境的准确复制，所有方面都要一致。
- en: Note
  id: totrans-80
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Some teams may be in a position where they are forced to forgo testing environments
    and simply measure in production using modern deployment and Observability techniques.
    This is the subject of Chapter 10, but it is not recommended as an approach unless
    it’s necessary.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一些团队可能会被迫放弃测试环境，仅使用现代部署和可观察性技术在生产中进行测量。这是第10章的主题，但除非必要，不建议采用这种方法。
- en: This includes not only application servers (which servers should have the same
    number of CPUs, same version of the OS and Java runtime, etc.), but web servers,
    databases, message queues, and so on. Any services (e.g., third-party network
    services that are not easy to replicate, or do not have sufficient QA capacity
    to handle a production-equivalent load) will need to be mocked for a representative
    performance testing environment.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅包括应用服务器（应该具有相同数量的 CPU、相同版本的操作系统和 Java 运行时环境等），还包括 Web 服务器、数据库、消息队列等。任何服务（例如，难以复制或没有足够
    QA 能力处理与生产等效负载的第三方网络服务）都需要为代表性性能测试环境进行模拟。
- en: Note
  id: totrans-83
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Performance testing environments that are significantly different from the production
    deployments that they purport to represent are usually ineffective—​they fail
    to produce results that have any usefulness or predictive power in the live environment.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 通常无法有效运行的性能测试环境与它们所代表的生产部署明显不同——它们未能产生在实际环境中有用或具有预测力的结果。
- en: For traditional (i.e., non-cloud-based) environments, a production-like performance
    testing environment is relatively straightforward to achieve in theory—​the team
    simply buys as many machines as are in use in the production environment and then
    configures them in exactly the same way as production is configured.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于传统（即非基于云的）环境，理论上实现类似生产环境的性能测试环境相对较为简单——团队只需购买与生产环境中使用的机器数量相同的机器，然后以与生产配置完全相同的方式配置它们。
- en: Management is sometimes resistant to the additional infrastructure cost that
    this represents. This is almost always a false economy, but sadly many organizations
    fail to account correctly for the cost of outages. This can lead to a belief that
    the savings from not having an accurate performance testing environment are meaningful,
    as it fails to properly account for the risks introduced by having a QA environment
    that does not mirror production.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 管理层有时会对这种额外基础设施成本表示抵触。这几乎总是一种错误的经济理念，但遗憾的是，许多组织未能正确考虑停机的成本。这可能导致一种信念，即不拥有准确的性能测试环境的节省是有意义的，因为它未能正确计算由于
    QA 环境与生产环境不匹配而引入的风险。
- en: The advent of cloud technologies, has changed this picture. More dynamic approaches
    to infrastructure management are now widespread. This includes on-demand and autoscaling
    infrastructure, as well as approaches such as *immutable infrastructure*, also
    referred to as treating server infrastructure as “livestock, not pets”.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 云技术的出现改变了这一局面。现在普遍采用更动态的基础设施管理方法。这包括按需和自动扩展基础设施，以及不可变基础设施的方法，也称为将服务器基础设施视为“牲畜而非宠物”。
- en: 'In theory, these trends make the construction of a performance testing environment
    that looks like production easier. However, there are subtleties here. For example:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，这些趋势使得构建类似生产环境的性能测试环境变得更加容易。然而，这里存在一些微妙之处。例如：
- en: Having a process that allows changes to be made in a test environment first
    and then migrated to production
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个允许首先在测试环境中进行更改，然后再迁移到生产环境的过程
- en: Making sure that a test environment does not have some overlooked dependencies
    that depend upon production
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保测试环境不具有依赖于生产环境的某些被忽视的依赖关系
- en: Ensuring that test environments have realistic authentication and authorization
    systems, not dummy components
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保测试环境具有逼真的身份验证和授权系统，而不是虚拟组件
- en: Despite these concerns, the possibility of setting up a testing environment
    that can be turned off when not in use is a key advantage of cloud-based deployments.
    This can bring significant cost savings to the project, but it requires a proper
    process for starting up and shutting down the environment as scheduled.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在这些担忧，能够在不使用时关闭测试环境的可能性是基于云的部署的一个关键优势。这可以为项目带来显著的成本节省，但需要一个适当的启动和按计划关闭环境的过程。
- en: Identifying Performance Requirements
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确定性能需求
- en: The overall performance of a system is not solely determined by your application
    code. As we will discover throughout the rest of this book, the container, operating
    system, and hardware all have a role to play.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的整体性能不仅仅由您的应用程序代码决定。正如我们将在本书的其余部分中发现的那样，容器、操作系统和硬件都起着重要作用。
- en: Therefore, the metrics that we will use to evaluate performance should not be
    thought about solely in terms of the code. Instead, we must consider systems as
    a whole and the observable quantities that are important to customers and management.
    These are usually referred to as performance *nonfunctional requirements* (NFRs),
    and are the key indicators that we want to optimize.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们用来评估性能的度量标准不应仅仅考虑代码方面。相反，我们必须将系统作为一个整体和对客户和管理层重要的可观察量考虑进去。这些通常被称为性能 *非功能性需求*（NFRs），是我们想要优化的关键指标。
- en: Note
  id: totrans-96
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In Chapter 7, we will meet a simple system model that describes in more detail
    how the interaction between OS, hardware, JVM and code impacts performance.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 7 章中，我们将会遇到一个简单的系统模型，更详细地描述了操作系统、硬件、JVM 和代码之间的交互如何影响性能。
- en: 'Some performance goals are obvious:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一些性能目标显而易见：
- en: Reduce 95% percentile transaction time by 100 ms.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少 95% 百分位事务时间，减少 100 毫秒。
- en: Improve system so that 5x throughput on existing hardware is possible.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进系统，使得在现有硬件上的吞吐量提高 5 倍成为可能。
- en: Improve average response time by 30%.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改善平均响应时间 30%。
- en: 'Others may be less apparent:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 其他可能不太明显：
- en: Reduce resource cost to serve the average customer by 50%.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少为服务平均客户的资源成本 50%。
- en: Ensure system is still within 25% of response targets, even when application
    clusters are degraded by 50%.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保系统即使在应用程序集群降级了 50% 的情况下，仍保持在响应目标的 25% 范围内。
- en: Reduce customer “drop-off” rate by 25% by removing 10 ms of latency.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过减少 10 毫秒的延迟来将客户“流失”率减少 25%。
- en: An open discussion with the stakeholders as to exactly what should be measured
    and what goals are to be achieved is essential. Ideally, this discussion should
    form part of the first kick-off meeting for any performance exercise.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 与利益相关者进行开放讨论，确切地确定应该测量什么以及应该达到什么目标是至关重要的。理想情况下，这种讨论应该成为任何性能练习的第一次启动会议的一部分。
- en: Performance Testing as Part of the SDLC
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作为 SDLC 的一部分的性能测试
- en: Some companies and teams prefer to think of performance testing as an occasional,
    one-off activity. However, more sophisticated teams tend to make ongoing performance
    tests, and in particular performance regression testing, an integral part of their
    software development lifecycle (SDLC).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一些公司和团队更倾向于将性能测试视为偶发的、一次性的活动。然而，更复杂的团队往往会将持续性能测试，特别是性能回归测试，作为他们软件开发生命周期（SDLC）的一个组成部分。
- en: This requires collaboration between developers and infrastructure teams to control
    which versions of code are present in the performance testing environment at any
    given time. It is also virtually impossible to implement without a dedicated testing
    environment.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要开发人员和基础设施团队之间的合作，以控制任何给定时间在性能测试环境中存在的代码版本。这也几乎不可能在没有专用测试环境的情况下实施。
- en: Java-Specific Issues
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java 特定问题
- en: Much of the science of performance analysis is applicable to any modern software
    system. However, the nature of the JVM is such that there are certain additional
    complications that the performance engineer should be aware of and consider carefully.
    These largely stem from the dynamic self-management capabilities of the JVM, such
    as the dynamic tuning of memory areas and JIT compilation.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 性能分析的许多科学方法适用于任何现代软件系统。然而，JVM 的性质使得性能工程师必须注意并仔细考虑某些额外的复杂性。这些主要源于 JVM 的动态自管理能力，如内存区域的动态调整和
    JIT 编译等。
- en: 'For example, modern JVMs analyze which methods are being run to identify candidates
    for JIT compilation to optimized machine code. This means that if a method is
    not being JIT-compiled, then one of two things is true about the method:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，现代 JVM 分析正在运行的方法，以识别适合进行 JIT 编译以优化机器代码的候选方法。这意味着如果一个方法没有被 JIT 编译，那么该方法可能存在以下两种情况之一：
- en: It is not being run frequently enough to warrant being compiled.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它没有被频繁运行，因此不值得进行编译。
- en: The method is too large or complex to be analyzed for compilation.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种方法过于庞大或复杂，无法进行编译分析。
- en: The second condition is, by the way, much rarer than the first. In Chapter 6
    we will discuss JIT compilation in detail, and show some simple techniques for
    ensuring that the important methods of applications are targeted for JIT compilation
    by the JVM.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个情况比第一个情况要少得多。在第6章中，我们将详细讨论JIT编译，并展示一些简单的技术，确保应用程序的重要方法被JVM选中进行JIT编译。
- en: Having discussed some of the most common best practices for performance, let’s
    now turn our attention to the pitfalls and antipatterns that teams can fall prey
    to.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论了一些性能的最佳实践之后，现在让我们转向团队可能会陷入的陷阱和反模式。
- en: Causes of performance antipatterns
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能反模式的原因
- en: An antipattern is an undesired behavior of a software project or team that is
    observed across a large number of projects.^([1](ch02.xhtml#id96)) The frequency
    of occurrence leads to the conclusion (or suspicion) that some underlying factor
    is responsible for creating the unwanted behavior. Some antipatterns may at first
    sight seem to be justified, with their non-ideal aspects not immediately obvious.
    Others are the result of negative project practices slowly accreting over time.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 反模式是指软件项目或团队的一种不良行为，在许多项目中都能观察到。^([1](ch02.xhtml#id96)) 发生频率导致结论（或怀疑）认为某些潜在因素导致了不良行为的产生。有些反模式乍一看似乎是合理的，其非理想的方面不会立即显现出来。其他反模式则是由负面项目实践随着时间的推移逐渐累积而成。
- en: A partial catalogue of antipatterns can be found in Appendix B—​where an example
    of the first kind would be something like *Distracted By Shiny*, whereas *Tuning
    By Folklore* is an example of the second kind.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 反模式的部分目录可以在附录B中找到—​第一类的一个例子是*Distracted By Shiny*，而*Tuning By Folklore*是第二类的例子。
- en: In some cases the behavior may be driven by social or team constraints, or by
    common misapplied management techniques, or by simple human (and developer) nature.
    By classifying and categorizing these unwanted features, we develop a *pattern
    language* for discussing them, and hopefully eliminating them from our projects.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，行为可能受到社会或团队的限制，或受到常见的错误管理技术的驱动，或者仅仅是人类（和开发者）的自然属性。通过对这些不良特征进行分类和归类，我们形成了一个用于讨论它们的*模式语言*，并希望能从我们的项目中消除它们。
- en: 'Performance tuning should always be treated as a very objective process, with
    precise goals set early in the planning phase. This is easier said than done:
    when a team is under pressure or not operating under reasonable circumstances,
    this can simply fall by the wayside.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 性能调优应始终被视为一个非常客观的过程，在规划阶段早期设定明确的目标。这说起来容易做起来难：当团队承受压力或者不在合理的情况下运作时，这通常会被忽视。
- en: Many readers will have seen the situation where a new client is going live or
    a new feature is being launched, and an unexpected outage occurs—in user acceptance
    testing (UAT) if you are lucky, but often in production. The team is then left
    scrambling to find and fix what has caused the bottleneck. This usually means
    performance testing has not been carried out, or the team “ninja” made an assumption
    and has now disappeared (ninjas are good at this).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 许多读者可能会遇到这样的情况：一个新客户即将上线或者正在推出一个新功能，突然出现了故障—如果你运气好的话，是在用户验收测试（UAT）中，但通常是在生产环境中。然后团队只能抓瞎地寻找和修复导致瓶颈的原因。这通常意味着性能测试未进行，或者团队的“忍者”做出了假设，然后消失了（忍者在这方面很擅长）。
- en: A team that works in this way will likely fall victim to antipatterns more often
    than a team that follows good performance testing practices and has open and reasoned
    conversations. As with many development issues, it is often the human elements,
    such as communication problems, rather than any technical aspect that leads to
    an application having problems.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种工作方式的团队往往比遵循良好性能测试实践并进行开放和理性对话的团队更容易陷入反模式。与许多开发问题一样，通常是人为因素，如沟通问题，而不是任何技术因素导致应用程序出现问题。
- en: One interesting possibility for classification was provided in a blog post by
    Carey Flichel called [“Why Developers Keep Making Bad Technology Choices”](http://www.carfey.com/blog/why-developers-keep-making-bad-technology-choices/).
    The post specifically calls out five main reasons that cause developers to make
    bad choices. Let’s look at each in turn.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的分类可能性在Carey Flichel的博客文章中提到，文章名为[“为什么开发者继续做出糟糕的技术选择”](http://www.carfey.com/blog/why-developers-keep-making-bad-technology-choices/)。这篇文章明确指出了导致开发者做出糟糕选择的五个主要原因。让我们依次看一看。
- en: Boredom
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无聊
- en: Most developers have experienced boredom in a role, and for some this doesn’t
    have to last very long before they are seeking a new challenge or role either
    in the company or elsewhere. However, other opportunities may not be present in
    the organization, and moving somewhere else may not be possible.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数开发人员在工作中都曾经历过无聊的时刻，对一些人来说，这在他们寻求新的挑战或在公司内部或其他地方寻找新角色之前不必持续太长时间。然而，在组织中可能不存在其他机会，而去其他地方也可能不可行。
- en: It is likely many readers have come across a developer who is simply riding
    it out, perhaps even actively seeking an easier life. However, bored developers
    can harm a project in a number of ways.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能许多读者遇到过一个只是在混日子的开发人员，甚至可能在积极寻求更轻松的生活。然而，无聊的开发人员可能以多种方式损害项目。
- en: For example, they might introduce code complexity that is not required, such
    as writing a sorting algorithm directly in code when a simple `Collections.sort()`
    would be sufficient. They might also express their boredom by looking to build
    components with technologies that are unknown or perhaps don’t fit the use case
    just as an opportunity to use them—which leads us to the next section.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，他们可能会引入不需要的代码复杂性，比如在代码中直接编写排序算法，而简单的`Collections.sort()`就足够了。他们还可能通过使用未知的技术构建组件，或许并不适合使用情况，只是为了利用这些技术的机会来表达他们的无聊—这导致我们进入下一节。
- en: Résumé Padding
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简历填充
- en: Occasionally the overuse of technology is not tied to boredom, but rather represents
    the developer exploiting an opportunity to boost their experience with a particular
    technology on their résumé (or CV).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，技术的过度使用并不是由于无聊，而是开发人员利用机会来增加他们在简历（或 CV）上对特定技术的经验。
- en: In this scenario, the developer is making an active attempt to increase their
    potential salary and marketability as they’re about to re-enter the job market.
    It’s unlikely that many people would get away with this inside a well-functioning
    team, but it can still be the root of a choice that takes a project down an unnecessary
    path.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，开发人员正在积极尝试提高他们重新进入职场时的潜在薪水和市场竞争力。在一个运作良好的团队内，很少有人能逃脱这样做，但这仍然可能是导致项目走上不必要道路的根源选择。
- en: The consequences of an unnecessary technology being added due to a developer’s
    boredom or résumé padding can be far-reaching and very long-lived, lasting for
    many years after the original developer has left.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 由于开发人员无聊或简历填充而添加不必要的技术，其后果可能是深远的，而且持续时间很长，甚至在原始开发人员离开多年后仍然存在。
- en: Social Pressure
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 社会压力
- en: Technical decisions are often at their worst when concerns are not voiced or
    discussed at the time choices are being made. This can manifest in a few ways;
    for example, perhaps a junior developer doesn’t want to make a mistake in front
    of more senior members of their team, or perhaps a developer fears appearing to
    their peers as uninformed on a particular topic.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在技术决策的时候，如果担忧没有被表达或讨论，通常会出现最糟糕的情况。这可能以几种方式表现出来；例如，也许一位初级开发人员不想在他们团队的更高级成员面前犯错，或者一位开发人员担心在某个特定主题上显得无知。
- en: Another particularly toxic type of social pressure is for competitive teams,
    wanting to be seen as having high development velocity, to rush key decisions
    without fully exploring all the consequences.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种特别有毒的社会压力类型是对于竞争激烈的团队来说，他们希望被视为开发速度很高，从而在完全探索所有后果之前匆忙做出关键决策。
- en: Lack of Understanding
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缺乏理解
- en: Developers may look to introduce new tools to help solve a problem because they
    are not aware of the full capability of their current tools. It is often tempting
    to turn to a new and exciting technology component because it is great at performing
    one specific task. However, introducing more technical complexity must be taken
    on balance with what the current tools can actually do.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员可能会试图引入新的工具来帮助解决问题，因为他们不了解当前工具的全部功能。通常会诱人的是转向一个新的和令人兴奋的技术组件，因为它擅长执行一个特定的任务。然而，引入更多的技术复杂性必须与当前工具的实际能力取得平衡。
- en: For example, Hibernate is sometimes seen as the answer to simplifying translation
    between domain objects and databases. If there is only limited understanding of
    Hibernate on the team, developers can make assumptions about its suitability based
    on having seen it used in another project.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Hibernate有时被视为简化领域对象和数据库之间转换的答案。如果团队对Hibernate的理解有限，开发人员可能会根据在另一个项目中看到它的使用情况做出适用性的假设。
- en: This lack of understanding can cause overcomplicated usage of Hibernate and
    unrecoverable production outages. By contrast, rewriting the entire data layer
    using simple JDBC calls allows the developer to stay on familiar territory.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这种缺乏理解可能导致对Hibernate的过度复杂使用和无法恢复的生产停机。相比之下，使用简单的JDBC调用重写整个数据层允许开发人员保持在熟悉的领域。
- en: One of the authors taught a Hibernate course that contained an attendee in exactly
    this position; they were trying to learn enough Hibernate to see if the application
    could be recovered, but ended up having to rip out Hibernate over the course of
    a weekend—​definitely not an enviable position.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一位作者曾教授过一门包含一个与这种情况完全相同的参与者的Hibernate课程；他们试图学习足够的Hibernate以查看应用程序是否可以恢复，但最终在周末期间不得不将Hibernate剔除—绝对不是令人羡慕的处境。
- en: Misunderstood/Nonexistent Problem
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 被误解/不存在的问题。
- en: Developers may often use a technology to solve a particular issue where the
    problem space itself has not been adequately investigated. Without having measured
    performance values, it is almost impossible to understand the success of a particular
    solution. Often collating these performance metrics enables a better understanding
    of the problem.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员经常使用技术来解决特定问题，其中问题空间本身尚未充分调查。如果没有测量性能值，几乎无法理解特定解决方案的成功性。通常汇总这些性能指标可以更好地理解问题。
- en: To avoid antipatterns it is important to ensure that communication about technical
    issues is open to all participants in the team, and actively encouraged. Where
    things are unclear, gathering factual evidence and working on prototypes can help
    to steer team decisions. A technology may look attractive; however, if the prototype
    does not measure up then the team can make a more informed decision.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要避免反模式，重要的是确保技术问题的沟通对所有团队成员开放，并积极鼓励。在事情不明确的情况下，收集事实依据并进行原型工作可以帮助引导团队决策。技术可能看起来很有吸引力；然而，如果原型不符合要求，团队可以做出更明智的决定。
- en: To see how these underlying causes can lead to a variety of performance antipatterns,
    interested readers should consult Appendix B.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解这些潜在原因如何导致各种性能反模式的读者可以查阅附录B。
- en: Statistics for JVM Performance
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JVM性能统计。
- en: If performance analysis is truly an experimental science, then we will inevitably
    find ourselves dealing with distributions of results data. Statisticians and scientists
    know that results that stem from the real world are virtually never represented
    by clean, stand-out signals. We must deal with the world as we find it, rather
    than the overidealized state in which we would like to find it.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果性能分析确实是一门实验科学，那么我们将不可避免地发现自己在处理结果数据的分布。统计学家和科学家知道，来自现实世界的结果几乎永远不会被清晰地表现出来。我们必须应对我们所发现的世界，而不是我们希望找到的过度理想化状态。
- en: In God we trust; all others must use data.^([2](ch02.xhtml#id97))
  id: totrans-147
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们信赖上帝；其他人必须使用数据。^([2](ch02.xhtml#id97))
- en: ''
  id: totrans-148
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: W. Edwards Deming (attr)
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: W. Edwards Deming（归因）
- en: All measurements contain some amount of error. In the next section we’ll describe
    the two main types of error that a Java developer may expect to encounter when
    doing performance analysis.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 所有测量都包含一定程度的误差。在下一节中，我们将描述Java开发人员在进行性能分析时可能遇到的两种主要类型的误差。
- en: Types of Error
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误类型。
- en: 'There are two main sources of error that an engineer may encounter. These are:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 工程师可能遇到的两种主要误差源是：
- en: Random error
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 随机误差。
- en: A measurement error or an unconnected factor affects results in an uncorrelated
    manner
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 测量误差或未连接因素以不相关方式影响结果。
- en: Systematic error
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 系统误差。
- en: An unaccounted factor affects measurement of the observable in a correlated
    way
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一个未经考虑的因素以相关方式影响可观察量的测量结果。
- en: There are specific words associated with each type of error. For example, *accuracy*
    is used to describe the level of systematic error in a measurement; high accuracy
    corresponds to low systematic error. Similarly, *precision* is the term corresponding
    to random error; high precision is low random error.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 每种误差类型都有特定的词汇。例如，*准确性*用于描述测量中系统误差的水平；高准确性对应低系统误差。同样，*精度*是与随机误差对应的术语；高精度意味着低随机误差。
- en: The graphics in [Figure 2-1](#pracjavaperf-CHP-2-FIG-1) show the effect of these
    two types of error on a measurement. The extreme left image shows a clustering
    of shots (which represent our measurements) around the true result (the “center
    of the target”). These measurements have both high precision and high accuracy.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-1](#pracjavaperf-CHP-2-FIG-1)中的图形显示了这两种误差对测量的影响。最左边的图像显示了（代表我们的测量）在真实结果周围聚集的射击。这些测量具有高精度和高准确度。'
- en: The second image has a systematic effect (miscalibrated sights perhaps?) that
    is causing all the shots to be off-target, so these measurements have high precision,
    but low accuracy. The third image shows shots basically on target but loosely
    clustered around the center, so low precision but high accuracy. The final image
    shows no clear pattern, as a result of having both low precision and low accuracy.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 第二张图片存在系统效应（可能是误校准的准星？），导致所有射击偏离目标，因此这些测量具有高精度但低准确度。第三张图片显示射击基本在目标周围松散聚集，因此精度低但准确度高。最后一张图片显示没有明显的模式，因此既精度低又准确度低。
- en: '![opjv 0501](assets/opjv_0501.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![opjv 0501](assets/opjv_0501.png)'
- en: Figure 2-1\. Different types of error
  id: totrans-161
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-1\. 不同类型的误差
- en: Let’s move on to explore these types of error in more detail, starting with
    random error.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续详细探讨这些类型的误差，从随机误差开始。
- en: Random error
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 随机误差
- en: Random errors are hopefully familiar to most people—​they are a very well-trodden
    path. However, they still deserve a mention here, as any handling of observed
    or experimental data needs to contend with them to some level.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 随机误差对大多数人来说应该很熟悉，它们是一个非常熟悉的领域。然而，在这里仍然值得一提，因为任何观察到或实验数据的处理都需要在某种程度上处理它们。
- en: Note
  id: totrans-165
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: The discussion assumes readers are familiar with basic statistical handling
    of normally distributed measurements (mean, mode, standard deviation, etc.); readers
    who aren’t should consult a basic textbook, such as [*The Handbook of Biological
    Statistics*](http://biostathandbook.com/).^([3](ch02.xhtml#id98))
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论假设读者熟悉基本的正态分布测量统计处理（均值、模式、标准差等）；若读者不熟悉，应参考基础教材，比如[*生物统计手册*](http://biostathandbook.com/)^([3](ch02.xhtml#id98))。
- en: Random errors are caused by unknown or unpredictable changes in the environment.
    In general scientific usage, these changes may occur in either the measuring instrument
    or the environment, but for software we assume that our measuring harness is reliable,
    and so the source of random error can only be the operating environment.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 随机误差是由环境中未知或不可预测的变化引起的。在一般科学用法中，这些变化可能发生在测量仪器或环境中的任一方，但对于软件而言，我们假设我们的测量工具是可靠的，因此随机误差的来源只能是操作环境。
- en: Random error is usually considered to obey a Gaussian (aka normal) distribution.
    A couple of typical examples of Gaussian distributions are shown in [Figure 2-2](#pracjavaperf-CHP-2-FIG-3).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 随机误差通常认为服从高斯（也称正态）分布。[图 2-2](#pracjavaperf-CHP-2-FIG-3)展示了几个典型的高斯分布示例。
- en: '![opjv 0503](assets/opjv_0503.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![opjv 0503](assets/opjv_0503.png)'
- en: Figure 2-2\. A Gaussian distribution (aka normal distribution or bell curve)
  id: totrans-170
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-2\. 高斯分布（又称正态分布或钟形曲线）
- en: The distribution is a good model for the case where an error is equally likely
    to make a positive or negative contribution to an observable. However, as we will
    see in the section on non-normal statistics, the situation for JVM measurements
    is a little more complicated.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分布是当一个误差对观测值可能产生正面或负面贡献时的良好模型。然而，正如我们将在非正态统计部分中看到的那样，JVM测量的情况稍微复杂一些。
- en: Systematic error
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 系统误差
- en: As an example of systematic error, consider a performance test running against
    a group of backend Java web services that send and receive JSON. This type of
    test is very common when it is problematic to directly use the application frontend
    for load testing.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 举例说明系统误差，考虑针对一组后端Java Web服务运行的性能测试，这些服务发送和接收JSON。当直接使用应用程序前端进行负载测试存在问题时，这种类型的测试非常常见。
- en: '[Figure 2-3](#pracjavaperf-CHP-2-FIG-2) was generated from the Apache JMeter
    load-generation tool. In it, there are actually two systematic effects at work.
    The first is the linear pattern observed in the topmost line (the outlier service),
    which represents slow exhaustion of some limited server resource.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-3](#pracjavaperf-CHP-2-FIG-2)由Apache JMeter负载生成工具生成。图中实际上有两种系统效应。首先是顶部线路（异常服务）中观察到的线性模式，代表某些有限服务器资源的慢耗尽。'
- en: '![opjv 0502](assets/opjv_0502.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![opjv 0502](assets/opjv_0502.png)'
- en: Figure 2-3\. Systematic error
  id: totrans-176
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-3\. 系统误差
- en: This type of pattern is often associated with a memory leak, or some other resource
    being used and not released by a thread during request handling, and represents
    a candidate for investigation—​it looks like it could be a genuine problem.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式通常与内存泄漏或在请求处理期间由线程使用但未释放的其他资源相关，并且可能需要调查——看起来可能是一个真正的问题。
- en: Note
  id: totrans-178
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Further analysis would be needed to confirm the type of resource that was being
    affected; we can’t just conclude that it’s a memory leak.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 需要进一步分析以确认受影响的资源类型；我们不能简单地得出这是内存泄漏的结论。
- en: The second effect that should be noticed is the consistency of the majority
    of the other services at around the 180 ms level. This is suspicious, as the services
    are doing very different amounts of work in response to a request. So why are
    the results so consistent?
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意到的第二个效应是大多数其他服务在约180毫秒水平上的一致性。这是值得怀疑的，因为服务在响应请求时做的工作量差异很大。那么为什么结果如此一致呢？
- en: The answer is that while the services under test are located in London, this
    load test was conducted from Mumbai, India. The observed response time includes
    the irreducible round-trip network latency from Mumbai to London. This is in the
    range 120–150 ms, and so accounts for the vast majority of the observed time for
    the services other than the outlier.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是，虽然测试中的服务位于伦敦，但这次负载测试是从印度孟买进行的。观察到的响应时间包括从孟买到伦敦的不可避免的往返网络延迟。这个范围是120-150毫秒，因此占据了除异常值之外服务的绝大部分观察时间。
- en: This large, systematic effect is drowning out the differences in the actual
    response time (as the services are actually responding in much less than 120 ms).
    This is an example of a systematic error that does not represent a problem with
    our application.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这种大规模的系统效应淹没了实际响应时间的差异（因为服务实际上的响应时间远远小于120毫秒）。这是一个例子，说明了一个系统误差，并不代表我们的应用存在问题。
- en: Instead, this error stems from a problem in our test setup, and so the good
    news is that this artifact completely disappeared (as expected) when the test
    was rerun from London.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，这个错误源于我们的测试设置存在问题，因此好消息是当从伦敦重新运行测试时，这个人为因素完全消失了（如预期的那样）。
- en: To finish off this section, let’s take a quick look at a notorious problem that
    frequently accompanies systematic error—​the spurious correlation.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 结束本节时，让我们快速看一下经常伴随系统误差出现的一个臭名昭著的问题——虚假相关性。
- en: Spurious correlation
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 虚假相关性
- en: One of the most famous aphorisms about statistics is “correlation does not imply
    causation” —-that is, just because two variables appear to behave similarly does
    not imply that there is an underlying connection between them.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 统计学中关于“相关性不意味着因果关系”的最著名的格言之一是“相关性不意味着因果关系”——也就是说，只因为两个变量表现出类似的行为并不意味着它们之间存在根本联系。
- en: In the most extreme examples, if a practitioner looks hard enough, then a correlation
    can be found between [entirely unrelated measurements](http://tylervigen.com/spurious-correlations).
    For example, in [Figure 2-4](#pracjavaperf-CHP-2-FIG-4) we can see that consumption
    of chicken in the US is well correlated with total import of crude oil.^([4](ch02.xhtml#id99))
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在最极端的例子中，如果从业者足够努力地寻找，就可以发现[完全不相关的测量结果](http://tylervigen.com/spurious-correlations)之间存在关联。例如，在[图2-4](#pracjavaperf-CHP-2-FIG-4)中，我们可以看到美国的鸡肉消费与原油总进口存在很好的相关性。^([4](ch02.xhtml#id99))
- en: '![opjv 0504](assets/opjv_0504.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![opjv 0504](assets/opjv_0504.png)'
- en: Figure 2-4\. A completely spurious correlation (Vigen)
  id: totrans-189
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-4。一个完全虚假的相关性（Vigen）
- en: These numbers are clearly not causally related; there is no factor that drives
    both the import of crude oil and the eating of chicken. However, it isn’t the
    absurd and ridiculous correlations that the practitioner needs to be wary of.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数字显然没有因果关系；没有任何因素同时推动原油进口和鸡肉食用。然而，从业者需要警惕的不是荒谬和可笑的相关性。
- en: In [Figure 2-5](#pracjavaperf-CHP-2-FIG-5), we see the revenue generated by
    video arcades correlated to the number of computer science PhDs awarded. It isn’t
    too much of a stretch to imagine a sociological study that claimed a link between
    these observables, perhaps arguing that “stressed doctoral students were finding
    relaxation with a few hours of video games.” These types of claim are depressingly
    common, despite no such common factor actually existing.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图2-5](#pracjavaperf-CHP-2-FIG-5)中，我们看到视频游戏机所产生的收入与授予的计算机科学博士学位的数量相关。可以想象一项社会学研究声称这些可观察到的变量之间存在联系，也许会认为“压力山大的博士生通过几个小时的视频游戏来放松”。尽管事实上并不存在这样的共同因素，但这类主张却是令人沮丧地常见的。
- en: '![opjv 0505](assets/opjv_0505.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![opjv 0505](assets/opjv_0505.png)'
- en: Figure 2-5\. A less spurious correlation? (Vigen)
  id: totrans-193
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-5\. 一个不那么虚假的相关性？（维根）
- en: In the realm of the JVM and performance analysis, we need to be especially careful
    not to attribute a causal relationship between measurements based solely on correlation
    and that the connection “seems plausible.”
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JVM 和性能分析领域，我们需要特别小心，不要仅仅基于相关性就断定因果关系“看起来合理”。
- en: The first principle is that you must not fool yourself—​and you are the easiest
    person to fool.^([5](ch02.xhtml#id100))
  id: totrans-195
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第一原则是你不能欺骗自己——你是最容易被自己欺骗的人。^([5](ch02.xhtml#id100))
- en: ''
  id: totrans-196
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Richard Feynman
  id: totrans-197
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 理查德·费曼
- en: We’ve met some examples of sources of error and mentioned the notorious bear
    traps of spurious correlation and fooling oneself, so let’s move on to discuss
    an aspect of JVM performance measurement that requires some special care and attention
    to detail.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经见过一些错误来源的例子，并提到了虚假相关性和自欺欺人的陷阱，所以现在让我们继续讨论一下 JVM 性能测量的一个方面，这需要特别注意细节。
- en: Non-Normal Statistics
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非正态统计
- en: Statistics based on the normal distribution do not require much mathematical
    sophistication. For this reason, the standard approach to statistics that is typically
    taught at pre-college or undergraduate level focuses heavily on the analysis of
    normally distributed data.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 基于正态分布的统计学并不需要太多数学复杂性。因此，通常在高中或大学本科阶段教授的统计学标准方法，重点放在正态分布数据的分析上。
- en: Students are taught to calculate the mean and the standard deviation (or variance),
    and sometimes higher moments, such as skew and kurtosis. However, these techniques
    have a serious drawback, in that the results can easily become distorted if the
    distribution has even relatively few far-flung outlying points.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 学生们被教导计算均值和标准差（或方差），有时还包括更高阶的矩，如偏度和峰度。然而，这些技术有一个严重的缺陷，即如果分布中有一些偏离较远的点，结果很容易变得扭曲。
- en: Note
  id: totrans-202
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: In Java performance, the outliers represent slow transactions and unhappy customers.
    We need to pay special attention to these points, and avoid techniques that dilute
    the importance of outliers.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 性能中，异常值代表了慢速交易和不满意的客户。我们需要特别注意这些点，并避免那些削弱异常值重要性的技术。
- en: 'To consider it from another viewpoint: unless a large number of customers are
    already complaining, it is unlikely that improving the average response time is
    a useful performance goal. For sure, doing so will improve the experience for
    everyone, but it is far more usual for a few disgruntled customers to be the cause
    of a latency tuning exercise. This implies that the outlier events are likely
    to be of more interest than the experience of the majority who are receiving satisfactory
    service.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 从另一个角度考虑：除非已有大量客户在投诉，否则改善平均响应时间可能并不是一个有用的性能目标。当然，这样做会改善每个人的体验，但往往只有少数不满的客户才是延迟调优的原因。这意味着异常事件可能比那些接受满意服务的大多数人更值得关注。
- en: In [Figure 2-6](#pracjavaperf-CHP-2-FIG-6) we can see a more realistic curve
    for the likely distribution of method (or transaction) times. It is clearly not
    a normal distribution.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在图 [Figure 2-6](#pracjavaperf-CHP-2-FIG-6) 中，我们可以看到方法（或事务）时间可能分布的更真实的曲线。显然，这不是一个正态分布。
- en: '![opjv 0506](assets/opjv_0506.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![opjv 0506](assets/opjv_0506.png)'
- en: Figure 2-6\. A more realistic view of the distribution of transaction times
  id: totrans-207
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-6\. 更真实地展示了交易时间分布的视角
- en: 'The shape of the distribution in [Figure 2-6](#pracjavaperf-CHP-2-FIG-6) shows
    something that we know intuitively about the JVM: it has “hot paths” where all
    the relevant code is already JIT-compiled, there are no GC cycles, and so on.
    These represent a best-case scenario (albeit a common one); there simply are no
    calls that are “a bit faster” due to random effects.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在图 [Figure 2-6](#pracjavaperf-CHP-2-FIG-6) 中显示的分布形状，直观上展示了我们对 JVM 的认知：它具有“热路径”，所有相关代码已经
    JIT 编译，没有 GC 周期等。这代表了一个最佳情况（尽管是常见情况）；因此，没有因随机效应而“稍微快一些”的调用。
- en: This violates a fundamental assumption of Gaussian statistics and forces us
    to consider distributions that are non-normal.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这违反了高斯统计的基本假设，并迫使我们考虑非正态分布的情况。
- en: Note
  id: totrans-210
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: For distributions that are non-normal, many “basic rules” of normally distributed
    statistics are violated. In particular, standard deviation/variance and other
    higher moments are basically useless.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非正态分布的情况，许多正态分布统计的“基本规则”都被违反了。特别是，标准差/方差以及其他更高阶的矩基本上是无用的。
- en: One technique that is very useful for handling the non-normal, “long-tail” distributions
    that the JVM produces is to use a modified scheme of percentiles. Remember that
    a distribution is a whole collection of points—​a shape of data, and is not well-represented
    by a single number.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 处理JVM生成的非正常“长尾”分布非常有用的一种技术是使用百分位数的修改方案。请记住，分布是一整套点的集合——数据的形状，并且不适合用单个数字来代表。
- en: Instead of computing just the mean, which tries to express the whole distribution
    in a single result, we can use a sampling of the distribution at intervals. When
    used for normally distributed data, the samples are usually taken at regular intervals.
    However, a small adaptation allows the technique to be used more effectively for
    JVM statistics.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用百分位数的采样，而不是仅仅计算平均值，后者试图用单一结果来表达整个分布。当用于正态分布数据时，通常会在固定间隔内进行采样。然而，通过小幅调整，该技术可以更有效地用于JVM统计数据。
- en: 'The modification is to use a sampling that takes into account the long-tail
    distribution by starting from the mean, then the 90th percentile, and then moving
    out logarithmically, as shown in the following method timing results. This means
    that we’re sampling according to a pattern that better corresponds to the shape
    of the data:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 修改的方法是使用从平均值开始的采样，然后是第90百分位数，然后按对数方式向外移动，如下所示的方法定时结果。这意味着我们按照更符合数据形状的模式进行采样：
- en: '[PRE0]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The samples show us that while the average time was 23 ns to execute a getter
    method, for 1 request in 1,000 the time was an order of magnitude worse, and for
    1 request in 100,000 it was *two* orders of magnitude worse than average.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 样本告诉我们，虽然平均执行获取器方法的时间为23 ns，但每1,000次请求中有一次的时间比平均值差一个数量级，而每1,000,000次请求中有一次的时间比平均值差*两个*数量级。
- en: Long-tail distributions can also be referred to as *high dynamic range* distributions.
    The dynamic range of an observable is usually defined as the maximum recorded
    value divided by the minimum (assuming it’s nonzero).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 长尾分布也可以称为*高动态范围*分布。可观察量的动态范围通常定义为最大记录值除以最小记录值（假设非零）。
- en: Logarithmic percentiles are a useful simple tool for understanding the long
    tail. However, for more sophisticated analysis, we can use a public domain library
    for handling datasets with high dynamic range. The library is called HdrHistogram
    and is [available from GitHub](https://github.com/HdrHistogram/HdrHistogram).
    It was originally created by Gil Tene (Azul Systems), with additional work by
    Mike Barker and other contributors.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 对数百分位数是理解长尾的一种有用的简单工具。然而，对于更复杂的分析，我们可以使用处理高动态范围数据集的公共领域库。该库称为HdrHistogram，可以从[Github上获取](https://github.com/HdrHistogram/HdrHistogram)。最初由Gil
    Tene（Azul Systems）创建，Mike Barker和其他贡献者进行了额外工作。
- en: Note
  id: totrans-219
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A histogram is a way of summarizing data by using a finite set of ranges (called
    *buckets*) and displaying how often data falls into each bucket.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图是通过使用有限的一组范围（称为*桶*）来总结数据，并显示数据落入每个桶的频率的一种方法。
- en: 'HdrHistogram is also available on Maven Central. At the time of writing, the
    current version is 2.1.12, and you can add it to your projects by adding this
    dependency stanza to *pom.xml*:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: HdrHistogram也可以在Maven中心获取。在撰写本文时，当前版本为2.1.12，您可以通过将此依赖项段添加到*pom.xml*来将其添加到您的项目中：
- en: '[PRE1]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let’s look at a simple example using HdrHistogram. This example takes in a
    file of numbers and computes the HdrHistogram for the difference between successive
    results:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个使用HdrHistogram的简单例子。此示例接受数字文件并计算连续结果之间的HdrHistogram：
- en: '[PRE2]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output shows the times between successive garbage collections. As we’ll
    see in Chapters 4 and 5, GC does do not occur at regular intervals, and understanding
    the distribution of how frequently it occurs could be useful. Here’s what the
    histogram plotter produces for a sample GC log:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示了连续垃圾收集之间的时间间隔。正如我们将在第四章和第五章看到的那样，GC并不是以固定的间隔发生的，理解它发生频率的分布可能会很有用。以下是直方图绘制器为示例GC日志生成的内容：
- en: '[PRE3]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The raw output of the formatter is rather hard to analyze, but fortunately,
    the HdrHistogram project includes an [online formatter](http://hdrhistogram.github.io/HdrHistogram/plotFiles.xhtml)
    that can be used to generate visual histograms from the raw output.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 格式化程序的原始输出相当难以分析，但幸运的是，HdrHistogram项目包含一个[在线格式化程序](http://hdrhistogram.github.io/HdrHistogram/plotFiles.xhtml)，可用于从原始输出生成可视化直方图。
- en: For this example, it produces output like that shown in [Figure 2-7](#pracjavaperf-CHP-2-FIG-7).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于此示例，它生成类似于[图 2-7](#pracjavaperf-CHP-2-FIG-7)所示的输出。
- en: '![opjv 0507](assets/opjv_0507.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
- en: Figure 2-7\. Example HdrHistogram visualization
  id: totrans-230
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For many observables that we wish to measure in Java performance tuning, the
    statistics are often highly non-normal, and HdrHistogram can be a very useful
    tool in helping to understand and visualize the shape of the data.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Interpretation of Statistics
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Empirical data and observed results do not exist in a vacuum, and it is quite
    common that one of the hardest jobs lies in interpreting the results that we obtain
    from measuring our applications.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: No matter what the problem is, it’s always a people problem.
  id: totrans-234
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-235
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Gerald Weinberg (attr)
  id: totrans-236
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In [Figure 2-8](#pracjavaperf-CHP-2-FIG-8) we show an example memory allocation
    rate for a real Java application. This example is for a reasonably well-performing
    application.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '![opjv 0508](assets/opjv_0508.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
- en: Figure 2-8\. Example allocation rate
  id: totrans-239
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The interpretation of the allocation data is relatively straightforward, as
    there is a clear signal present. Over the time period covered (almost a day),
    allocation rates were basically stable between 350 and 700 MB per second. There
    is a downward trend starting approximately 5 hours after the JVM started up, and
    a clear minimum between 9 and 10 hours, after which the allocation rate starts
    to rise again.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: These types of trends in observables are very common, as the allocation rate
    will usually reflect the amount of work an application is actually doing, and
    this will vary widely depending on the time of day. However, when we are interpreting
    real observables, the picture can rapidly become more complicated.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: This can lead to what is sometimes called the “Hat/Elephant” problem, after
    a passage in *The Little Prince* by Antoine de Saint-Exupéry. In the book, the
    narrator describes drawing, at age six, a picture of a boa constrictor that has
    eaten an elephant. However, as the view is external, the picture just resembles
    (at least to the ignorant eyes of the adults in the story) a slightly shapeless
    hat.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: The metaphor stands as an admonition to the reader to have some imagination
    and to think more deeply about what you are really seeing, rather than just accepting
    a shallow explanation at face value.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: The problem, as applied to software, is illustrated by [Figure 2-9](#pracjavaperf-CHP-2-FIG-9).
    All we can initially see is a complex histogram of HTTP request-response times.
    However, just like the narrator of the book, if we can imagine or analyze a bit
    more, we can see that the complex picture is actually made up of several fairly
    simple pieces.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '![opjv 0509](assets/opjv_0509.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
- en: Figure 2-9\. Hat, or elephant eaten by a boa?
  id: totrans-246
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The key to decoding the response histogram is to realize that “web application
    responses” is a very general category, including successful requests (so-called
    2xx responses), client errors (4xx, including the infamous 404 error), and server
    errors (5xx, especially 500 Internal Server Error).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Each type of response has a different characteristic distribution for response
    times. If a client makes a request for a URL that has no mapping (a 404), then
    the web server can immediately reply with a response. This means that the histogram
    for only client error responses looks more like [Figure 2-10](#pracjavaperf-CHP-2-FIG-10).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 每种类型的响应时间分布特征各不相同。如果客户端请求一个没有映射的URL（即404），那么Web服务器可以立即回复一个响应。这意味着仅客户端错误响应的直方图看起来更像是[图
    2-10](#pracjavaperf-CHP-2-FIG-10)。
- en: '![opjv 0510](assets/opjv_0510.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![opjv 0510](assets/opjv_0510.png)'
- en: Figure 2-10\. Client errors
  id: totrans-250
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-10\. 客户端错误
- en: By contrast, server errors often occur after a large amount of processing time
    has been expended (for example, due to backend resources being under stress or
    timing out). So, the histogram for server error responses might look like [Figure 2-11](#pracjavaperf-CHP-2-FIG-11).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，服务器错误通常发生在大量处理时间消耗后（例如，由于后端资源压力或超时），因此服务器错误响应的直方图可能看起来像[图 2-11](#pracjavaperf-CHP-2-FIG-11)。
- en: '![opjv 0512](assets/opjv_0512.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![opjv 0512](assets/opjv_0512.png)'
- en: Figure 2-11\. Server errors
  id: totrans-253
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-11\. 服务器错误
- en: The successful requests will have a long-tail distribution, but in reality we
    may expect the response distribution to be “multimodal” and have several local
    maxima. An example is shown in [Figure 2-12](#pracjavaperf-CHP-2-FIG-12), and
    represents the possibility that there could be two common execution paths through
    the application with quite different response times.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的请求将具有长尾分布，但实际上我们可能预期响应分布是“多模态”的，并且具有几个局部最大值。例如，[图 2-12](#pracjavaperf-CHP-2-FIG-12)中显示的例子，代表了应用程序可能存在两条常见执行路径，其响应时间完全不同的可能性。
- en: '![opjv 0511](assets/opjv_0511.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![opjv 0511](assets/opjv_0511.png)'
- en: Figure 2-12\. Successful requests
  id: totrans-256
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-12\. 成功请求
- en: Combining these different types of responses into a single graph results in
    the structure shown in [Figure 2-13](#pracjavaperf-CHP-2-FIG-13). We have rederived
    our original “hat” shape from the separate histograms.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些不同类型的响应合并到单个图表中，结果如图[2-13](#pracjavaperf-CHP-2-FIG-13)所示的结构。我们已经从分开的直方图中重新推导出了我们最初的“帽子”形状。
- en: '![opjv 0513](assets/opjv_0513.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![opjv 0513](assets/opjv_0513.png)'
- en: Figure 2-13\. Hat or elephant revisited
  id: totrans-259
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-13\. 帽子或大象再访
- en: The concept of breaking down a general observable into more meaningful sub-populations
    is a very useful one. It shows that we need to make sure that we understand our
    data and domain well enough before trying to infer conclusions from our results.
    We may well want to further break down our data into smaller sets; for example,
    the successful requests may have very different distributions for requests that
    are predominantly read, as opposed to requests that are updates or uploads.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个普通的可观察现象分解成更有意义的子群体的概念非常有用。这表明在我们试图从结果推断结论之前，我们需要确保充分理解我们的数据和领域。例如，成功的请求可能在主要是读取的请求和更新或上传的请求之间具有非常不同的分布。
- en: The engineering team at PayPal have written extensively about their use of statistics
    and analysis; [they have a blog](https://www.paypal-engineering.com/) that contains
    excellent resources. In particular, the piece [“Statistics for Software”](https://medium.com/paypal-tech/statistics-for-software-e395ca08005d/)
    by Mahmoud Hashemi is a great introduction to their methodologies, and includes
    a version of the Hat/Elephant problem discussed earlier.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: PayPal 的工程团队已经广泛地写了关于他们使用统计和分析的内容；[他们有一个博客](https://www.paypal-engineering.com/)，其中包含了很多优秀的资源。特别是
    Mahmoud Hashemi 的文章[“软件统计”](https://medium.com/paypal-tech/statistics-for-software-e395ca08005d/)，是对他们方法论的很好介绍，并包含了前面讨论过的帽子/大象问题的版本。
- en: Also worth mentioning is the “Datasaurus Dozen” --a collection of datasets that
    have the same basic statistics but wildly different appearances.^([6](ch02.xhtml#id101))
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得一提的是“数据龙头十二” ——一组具有相同基本统计特征但外观迥异的数据集。^([6](ch02.xhtml#id101))
- en: Cognitive Biases and Performance Testing
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认知偏差与性能测试
- en: Humans can be bad at forming accurate opinions quickly—​even when faced with
    a problem where they can draw upon past experiences and similar situations.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 人类在迅速形成准确观点方面可能表现不佳——即使面对可以借鉴过去经验和类似情况的问题。
- en: A cognitive bias is a psychological effect that causes the human brain to draw
    incorrect conclusions. It is especially problematic because the person exhibiting
    the bias is usually unaware of it and may believe they are being rational.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 认知偏差是一种心理效应，导致人类大脑得出错误的结论。这种情况尤为棘手，因为表现出此类偏差的人通常并不自知，并可能认为自己的行为是理性的。
- en: Many of the antipatterns we observe in performance analysis (such as those in
    Appendix B, which you might want to read in conjunction with this section) are
    caused, in whole or in part, by one or more cognitive biases that are in turn
    based on an unconscious assumptions.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们观察到的许多性能分析反模式（例如附录B中的反模式，您可能希望与本节一起阅读）的原因，全部或部分是由于一个或多个认知偏见造成的，这些偏见又基于无意识的假设。
- en: For example, with the *Blame Donkey* antipattern, if a component has caused
    several recent outages the team may be biased to expect that same component to
    be the cause of any new performance problem. Any data that’s analyzed may be more
    likely to be considered credible if it confirms the idea that the Blame Donkey
    component is responsible.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于*Blame Donkey*反模式，如果某个组件导致了几次最近的故障，团队可能会倾向于期望同一组件导致任何新的性能问题。分析的任何数据，如果确认了Blame
    Donkey组件负责，可能更容易被视为可信。
- en: The antipattern combines aspects of the biases known as confirmation bias and
    recency bias (a tendency to assume that whatever has been happening recently will
    keep happening).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 该反模式结合了被称为确认偏见和最近性偏见的偏见的方面（即倾向于认为最近发生的事情将继续发生）。
- en: Note
  id: totrans-269
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: A single component in Java can behave differently from application to application
    depending on how it is optimized at runtime. In order to remove any pre-existing
    bias, it is important to look at the application as a whole.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，一个单一组件在运行时优化的方式可能会导致在不同应用程序中表现不同。为了消除任何已有的偏见，重要的是要整体看待应用程序。
- en: Biases can be complementary or dual to each other. For example, some developers
    may be biased to assume that the problem is not software-related at all, and the
    cause must be the infrastructure the software is running on; this is common in
    the *Works for Me* antipattern, characterized by statements like “This worked
    fine in UAT, so there must be a problem with the production kit.” The converse
    is to assume that every problem must be caused by software, because that’s the
    part of the system the developer knows about and can directly affect.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 偏见可以相互补充或对立。例如，一些开发人员可能倾向于假设问题根本不是与软件相关，而是软件运行的基础设施；这在*Works for Me*反模式中很常见，其特征是“在UAT中运行良好，所以问题一定是生产环境设备有问题。”反之则是假设每个问题都必须由软件引起，因为这是开发人员了解并直接影响的系统部分。
- en: Let’s meet some of the most common biases that every performance engineer should
    look out for.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来认识一些每个性能工程师都应该警惕的最常见偏见。
- en: Knowing where the trap is—​that’s the first step in evading it.^([7](ch02.xhtml#id102))
  id: totrans-273
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 知道陷阱在哪里——这是规避它的第一步。^([7](ch02.xhtml#id102))
- en: ''
  id: totrans-274
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Duke Leto Atreides I
  id: totrans-275
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 杜克·莱托·亚特雷德一世
- en: By recognizing these biases in ourselves, and others, we increase the chance
    of being able to do sound performance analysis and solve the problems in our systems.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 通过认识自己和他人中的这些偏见，我们增加了进行合理性能分析和解决系统问题的可能性。
- en: Reductionist Thinking
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简化思维
- en: The reductionist thinking cognitive bias is based on an analytical approach
    that presupposes that if you break a system into small enough pieces, you can
    understand it by understanding its constituent parts. Understanding each part
    means reducing the chance of incorrect assumptions being made.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 简化思维认知偏见基于一种分析方法，预设如果将系统分解得足够小，就可以通过理解其组成部分来理解它。理解每个部分意味着减少可能出现错误假设的机会。
- en: The major problem with this view is simple to explain—​in complex systems it
    just isn’t true. Nontrivial software (or physical) systems almost always display
    emergent behavior, where the whole is greater than a simple summation of its parts
    would indicate.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这种观点的主要问题很容易解释——在复杂系统中，这并不成立。非平凡的软件（或物理）系统几乎总是展示出新兴行为，整体远大于其部分简单加总的表现。
- en: Confirmation Bias
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确认偏见
- en: Confirmation bias can lead to significant problems when it comes to performance
    testing or attempting to look at an application subjectively. A confirmation bias
    is introduced, usually not intentionally, when a poor test set is selected or
    results from the test are not analyzed in a statistically sound way. Confirmation
    bias is quite hard to counter, because there are often strong motivational or
    emotional factors at play (such as someone in the team trying to prove a point).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及性能测试或试图主观地查看应用程序时，确认偏见可能会导致重大问题。确认偏见通常是无意中引入的，当选择了不良的测试集或者测试结果没有以统计学上合理的方式进行分析时。确认偏见很难对抗，因为通常会涉及强烈的动机或情感因素（例如团队中的某人试图证明一个观点）。
- en: Consider an antipattern such as *Distracted by Shiny*, where a team member is
    looking to bring in the latest and greatest NoSQL database. They run some tests
    against data that isn’t like production data, because representing the full schema
    is too complicated for evaluation purposes.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个反模式，比如*Distracted by Shiny*，团队成员试图引入最新和最棒的NoSQL数据库。他们对不像生产数据的数据进行了一些测试，因为完整表示整个模式对于评估目的来说太复杂了。
- en: They quickly prove that on a test set the NoSQL database produces superior access
    times on their local machine. The developer has already told everyone this would
    be the case, and on seeing the results they proceed with a full implementation.
    There are several antipatterns at work here, all leading to new unproved assumptions
    in the new library stack.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 他们很快证明了在测试集上，NoSQL数据库在他们的本地机器上产生了优越的访问时间。开发者已经告诉大家这将会发生，并且在看到结果后，他们继续进行了全面实施。这里存在几种反模式，都导致了新的库堆栈中的未经验证的假设。
- en: Fog of War (Action Bias)
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 战争迷雾（行动偏向）
- en: 'The fog of war bias usually manifests itself during outages or situations where
    the system is not performing as expected and the team are under pressure. Some
    common causes include:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 战争迷雾偏见通常在停机或系统表现不如预期并且团队处于压力下的情况下显现。一些常见的原因包括：
- en: Changes to infrastructure that the system runs on, perhaps without notification
    or realizing there would be an impact
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对系统运行的基础设施进行更改，可能没有通知或意识到会产生影响
- en: Changes to libraries that the system is dependent on
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改系统依赖的库
- en: A strange bug or race condition the manifests itself, but only on busy days
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个奇怪的bug或竞争条件，表现出来，但只在繁忙的日子里
- en: In a well-maintained application with sufficient logging and monitoring, these
    should generate clear error messages that will lead the support team to the cause
    of the problem.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个良好维护的应用程序中，具有足够的日志记录和监控，这些应该会生成清晰的错误消息，将引导支持团队找到问题的原因。
- en: However, too many applications have not tested failure scenarios and lack appropriate
    logging. Under these circumstances even experienced engineers can fall into the
    trap of needing to feel that they’re doing something to resolve the outage and
    mistaking motion for velocity—​the “fog of war” descends.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，太多的应用程序没有测试失败场景，并且缺乏适当的日志记录。在这些情况下，即使是经验丰富的工程师也会陷入需要感觉正在解决停机问题并将运动误认为速度的陷阱中——“战争迷雾”降临。
- en: At this time, many of the human elements discussed in this chapter can come
    into play if participants are not systematic about their approach to the problem.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，如果参与者对问题的处理方法不够系统化，本章讨论的许多人类因素可能会发挥作用。
- en: For example, an antipattern such as *Blame Donkey* may shortcut a full investigation
    and lead the production team down a particular path of investigation—​often missing
    the bigger picture. Similarly, the team may be tempted to break the system down
    into its constituent parts and look through the code at a low level without first
    establishing in which subsystem the problem truly resides.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，*Blame Donkey*这样的反模式可能会捷径一次全面的调查，并引导生产团队沿着特定的调查路径进行—通常会忽视更大的局面。类似地，团队可能会诱使将系统分解为其组成部分，并在低级别查看代码，而不先确定问题真正存在于哪个子系统中。
- en: Risk Bias
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 风险偏向
- en: Humans are naturally risk averse and resistant to change. Mostly this is because
    people have seen examples of how change can cause things to go wrong—​this leads
    them to attempt to avoid that risk. This can be incredibly frustrating when taking
    small, calculated risks could move the product forward. Much of this risk aversion
    arises from teams that are reluctant to make changes that might modify the performance
    profile of the application.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 人类天生对风险保守且抗拒变化。主要是因为人们见过变化如何导致问题，因此他们试图避免这种风险。当然，当小心计算的风险可以推动产品发展时，这种风险规避可能非常令人沮丧。大部分这种风险规避来自于团队不愿意进行可能修改应用程序性能配置文件的更改。
- en: We can reduce this risk bias significantly by having a robust set of unit tests
    and production regression tests. The performance regression tests are a great
    place to link in the system’s non-functional requirements and ensure that the
    concerns the NFRs represent are reflected in the regression tests.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 通过拥有一套强大的单元测试和生产回归测试，我们可以显著减少这种风险偏好。性能回归测试是将系统非功能性需求纳入的好地方，并确保这些NFR所代表的关注点在回归测试中得到反映。
- en: However, if either of these is not sufficiently trusted by the team, change
    becomes extremely difficult and the risk factor is not controlled. This bias often
    manifests in a failure to learn from application problems (including service outages)
    and implement appropriate mitigation.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果团队对其中任何一方缺乏足够的信任，改变将变得极其困难，风险因素也无法控制。这种偏见通常表现为未能从应用程序问题（包括服务停机）中吸取教训并实施适当的缓解措施。
- en: Summary
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: When you are evaluating performance results, it is essential to handle the data
    in an appropriate manner and avoid falling into unscientific and subjective thinking.
    This includes avoiding the statistical pitfalls of relying upon Gaussian models
    when they are not appropriate.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估性能结果时，必须以适当的方式处理数据，并避免陷入非科学和主观思维。这包括在不适当时避免依赖高斯模型的统计陷阱。
- en: In this chapter, we have met some different types of performance tests, testing
    best practices, and human problems that are native to performance analysis.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们遇到了一些不同类型的性能测试、测试最佳实践以及性能分析本地化的人类问题。
- en: In the next chapter, we’re going to move on to an overview of the JVM, introducing
    the basic subsystems, the lifecycle of a “classic” Java application and a first
    look at monitoring and tooling.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续介绍 JVM 的概述，介绍基本子系统，“经典” Java 应用程序的生命周期，以及首次了解监控和工具。
- en: '^([1](ch02.xhtml#id96-marker)) The term was popularized by the book *AntiPatterns:
    Refactoring Software, Architectures, and Projects in Crisis*, by William J. Brown,
    Raphael C. Malvo, Hays W. McCormick III, and Thomas J. Malbray (New York: Wiley,
    1998).'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch02.xhtml#id96-marker)) 这个术语由William J. Brown、Raphael C. Malvo、Hays W.
    McCormick III和Thomas J. Malbray的书《反模式：重构软件、架构和项目危机》（纽约：Wiley，1998年）普及。
- en: ^([2](ch02.xhtml#id97-marker)) M. Walton, *The Deming Management Method* (Mercury
    Books, 1989)
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch02.xhtml#id97-marker)) M. Walton，《丁宁管理方法》（Mercury Books，1989年）
- en: '^([3](ch02.xhtml#id98-marker)) John H. McDonald, *Handbook of Biological Statistics*,
    3rd ed. (Baltimore, MD: Sparky House Publishing, 2014).'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch02.xhtml#id98-marker)) John H. McDonald，《生物统计手册》，第3版（马里兰州巴尔的摩：Sparky
    House Publishing，2014年）。
- en: ^([4](ch02.xhtml#id99-marker)) The spurious correlations in this section come
    from Tyler Vigen’s site and are reused here with permission under CC BY 4.0\.
    If you enjoy them, there is a book with many more amusing examples available from
    his website.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch02.xhtml#id99-marker)) 本节中的伪相关性来自Tyler Vigen的网站，并在此处根据CC BY 4.0许可证重新使用。如果您喜欢，可以从他的网站上获取更多有趣的例子。
- en: ^([5](ch02.xhtml#id100-marker)) R. Feynman and R. Leighton, “Surely You’re Joking
    Mr Feynman” (W.W. Norton, 1985)
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch02.xhtml#id100-marker)) R. Feynman 和 R. Leighton，《你一定在开玩笑，费曼先生》（W.W.
    Norton，1985年）
- en: '^([6](ch02.xhtml#id101-marker)) J. Matejka and G. Fitzmaurice, “Same stats,
    different graphs: Generating datasets with varied appearance and identical statistics
    through simulated annealing,” CHI 2017, Denver USA (2017)'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch02.xhtml#id101-marker)) J. Matejka 和 G. Fitzmaurice，“同样的统计数据，不同的图形：通过模拟退火生成外观各异但统计数据相同的数据集”，CHI
    2017，美国丹佛（2017）
- en: ^([7](ch02.xhtml#id102-marker)) F. Herbert, *Dune*, (Chilton Books 1965)
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch02.xhtml#id102-marker)) F. Herbert，《沙丘》（Chilton Books，1965年）
