- en: Chapter 6\. Dates and Times
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 6.0 Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developers suffered for a decade and a half under the inconsistencies and ambiguities
    of the `Date` class from Java 1.0 and its replacement wannabe, the `Calendar`
    class from Java 1.1\. Several alternative `Date` replacement packages emerged,
    including the simple and sensible [Date4J](http://date4j.net) and the more comprehensive
    [Joda-Time package](http://www.joda.org/joda-time). Java 8 introduced a new, consistent,
    and well-thought-out package for date and time handling under the aegis of the
    Java Community Process, JSR-310, shepherded by developer Stephen Colebourne, based
    on his earlier package Joda-Time, but with several important design changes.^([1](ch06.html#idm45290675934040))
    This package is biased toward ISO 8601 dates; the default format is, for example,
    2015-10-23T10:22:45\. But it can, of course, work with other calendar schemes.
  prefs: []
  type: TYPE_NORMAL
- en: One of the key benefits of the new API is that it provides *useful operations*
    such as adding/subtracting dates/times. Much time was wasted by developers reimplementing
    these useful operations again and again. With the new APIs, one can use the built-in
    functionality. That said, millions of lines of code are based on the old APIs,
    so we’ll review them briefly, and consider interfacing the new API to legacy code
    in the final recipe of this chapter, [Recipe 6.9](#javacook-dates-legacy).
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage of the new API is that almost all objects are immutable and
    thus thread-safe. This can be of considerable benefit as we move headlong into
    the massively parallel era.
  prefs: []
  type: TYPE_NORMAL
- en: Because there are no `set` methods, and thus the getter method paradigm doesn’t
    always make sense, the API provides a series of new methods to replace such methods,
    listed in [Table 6-1](#javacook-dates-intro-METHODS).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 6-1\. New date/time API: common methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `at` | Combines with another object |'
  prefs: []
  type: TYPE_TB
- en: '| `format` | Use provided formatter to produce a formatted string |'
  prefs: []
  type: TYPE_TB
- en: '| `from` | Factory: convert input parameters to instance of target |'
  prefs: []
  type: TYPE_TB
- en: '| `get` | Retrieve one field from the instance |'
  prefs: []
  type: TYPE_TB
- en: '| `is` | Examine the state of the given object |'
  prefs: []
  type: TYPE_TB
- en: '| `minus` | Return a copy with the given amount subtracted |'
  prefs: []
  type: TYPE_TB
- en: '| `now` | BuilderFactory: get the current time, date, etc. |'
  prefs: []
  type: TYPE_TB
- en: '| `of` | Factory: create new method by parsing inputs |'
  prefs: []
  type: TYPE_TB
- en: '| `parse` | Factory: parse single input string to produce instance of target
    |'
  prefs: []
  type: TYPE_TB
- en: '| `plus` | Return a copy with the given amount added |'
  prefs: []
  type: TYPE_TB
- en: '| `to` | Convert this object to another type |'
  prefs: []
  type: TYPE_TB
- en: '| `with` | Return a copy with the given field changed; replaces `set` methods
    |'
  prefs: []
  type: TYPE_TB
- en: 'The JSR 310 API specifies a dozen or so main classes. Those representing times
    are either continuous time or human time. *Continuous time* is based on Unix time,
    a deeper truth from the dawn of (computer) time, and is represented as a single
    monotonically increasing number. The time value of 0 in Unix represented the first
    second of January 1, 1970 UTC—about the time Unix was invented. Each unit of increment
    there represented one second of time. This has been used as a time base in most
    operating systems developed since. However, a 32-bit integer representing the
    number of seconds since 1970 runs out fairly soon—in the year 2038 AD. Most Unix
    systems have, in the aftermath of the Y2K frenzy, quietly and well in advance
    headed off a possible Y2038 frenzy by converting the time value from a 32-bit
    quantity to a 64-bit quantity. Java also used this time base, but used 64 bits,
    and stored its time in milliseconds, because a 64-bit time in milliseconds since
    1970 will not overlow until quite a few years into the future (keep this date
    open in your calendar—August 17, 292,278,994 CE). Here is a calculation that shows
    how I got that date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The new API is in five packages, as shown in [Table 6-2](#table_0602); as usual,
    the top-level one contains the most commonly used pieces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 6-2\. New date/time API: packages'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `java.time` | Common classes for dates, times, instants, and durations |'
  prefs: []
  type: TYPE_TB
- en: '| `java.time.chrono` | API for non-ISO calendar systems |'
  prefs: []
  type: TYPE_TB
- en: '| `java.time.format` | Formatting classes (see [Recipe 6.2](#javacook-dates-format))
    |'
  prefs: []
  type: TYPE_TB
- en: '| `java.time.temporal` | Date and time access using fields, units, and adjusters
    |'
  prefs: []
  type: TYPE_TB
- en: '| `java.time.zone` | Support for time zones and their rules |'
  prefs: []
  type: TYPE_TB
- en: The basic `java.time` package contains a dozen or so classes, as well as a couple
    of enums and one general-purpose exception (shown in Tables [6-3](#table_0603),
    [6-4](#table_0604), and [6-5](#table_0605)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 6-3\. New date/time API: basics'
  prefs: []
  type: TYPE_NORMAL
- en: '| Class | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Clock` | Replaceable factory for getting current time |'
  prefs: []
  type: TYPE_TB
- en: '| `Instant` | A point in time since January 1, 1970, expressed in nanoseconds
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Duration` | A length of time, also expressed in nanoseconds |'
  prefs: []
  type: TYPE_TB
- en: Human time represents times and dates as we use them in our everyday life. These
    classes are listed in [Table 6-4](#table_0604).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 6-4\. New date/time API: human time'
  prefs: []
  type: TYPE_NORMAL
- en: '| Class | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Calendrical` | Connects to the low-level API |'
  prefs: []
  type: TYPE_TB
- en: '| `DateTimeFields` | Stores a map of field-value pairs, which are not required
    to be consistent |'
  prefs: []
  type: TYPE_TB
- en: '| `DayOfWeek` | A day of the week (e.g., Tuesday) |'
  prefs: []
  type: TYPE_TB
- en: '| `LocalDate` | A bare date (day, month, and year) with no adjustments |'
  prefs: []
  type: TYPE_TB
- en: '| `LocalTime` | A bare time (hour, minute, seconds) with no adjustments |'
  prefs: []
  type: TYPE_TB
- en: '| `LocalDateTime` | The combination of the above |'
  prefs: []
  type: TYPE_TB
- en: '| `MonthDay` | Month and day |'
  prefs: []
  type: TYPE_TB
- en: '| `OffsetTime` | A time of day with a time zone offset like –04:00, with no
    date or zone |'
  prefs: []
  type: TYPE_TB
- en: '| `OffsetDateTime` | A date and time with a time zone offset like –04:00, with
    no time zone |'
  prefs: []
  type: TYPE_TB
- en: '| `Period` | A descriptive amount of time, such as “2 months and 3 days” |'
  prefs: []
  type: TYPE_TB
- en: '| `ZonedDateTime` | The date and time with a time zone and an offset |'
  prefs: []
  type: TYPE_TB
- en: '| `Year` | A year by itself |'
  prefs: []
  type: TYPE_TB
- en: '| `YearMonth` | A year and month |'
  prefs: []
  type: TYPE_TB
- en: Almost all the top-level classes directly extend `java.lang.Object` and are
    held to consistency by a variety of interfaces, which are declared in the subpackages.
    The date and time classes mostly implement `Comparable`, which makes sense.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 6-5](#table_0605) shows the two time-zone-specific classes used with
    `ZonedDateTime`, `OffsetDateTime`, and `OffsetTime`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 6-5\. New date/time API: support'
  prefs: []
  type: TYPE_NORMAL
- en: '| Class | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `ZoneOffset` | A time offset from UTC (hours, minutes, seconds) |'
  prefs: []
  type: TYPE_TB
- en: '| `ZoneId` | Defines a time zone such as *Canada/Eastern* and its conversion
    rules |'
  prefs: []
  type: TYPE_TB
- en: 'The new API is a *fluent API*, in which most operations return the object they
    have operated upon, so that you can chain multiple calls without the need for
    tedious and annoying temporary variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This results in a more natural and convenient coding style, in my opinion. You
    can always write code with lots of temporary variables if you want; you’re the
    one who will have to read through it later.
  prefs: []
  type: TYPE_NORMAL
- en: 6.1 Finding Today’s Date
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to find today’s date and/or time.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Invoke the appropriate builder to obtain a `LocalDate`, `LocalTime`, or `LocalDateTime`
    object and call its `toString()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These classes do not provide public constructors, so you will need to call
    one of its factory methods to get an instance. They all provide a `now()` method,
    which does what its name implies. The `CurrentDateTime` demo program shows simple
    use of all three:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Running it produces this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The formatting is nothing spectacular, but it’s adequate. We’ll deal with fancier
    formatting in [Recipe 6.2](#javacook-dates-format).
  prefs: []
  type: TYPE_NORMAL
- en: While this works, in full-scale applications, it’s recommended to pass a `Clock`
    instance into all the `now()` methods. `Clock` is a factory object that is used
    internally to find the current time. In testing, you often want to have a known
    date or time used so you can compare against known output. The `Clock` class makes
    this easy. [Example 6-1](#javacook-datetime-EX-clock) uses a `Clock` and allows
    replacing the default `Clock` by calling a setter. Alternately you could use a
    dependency injection framework like CDI or Spring to provide the correct version
    of the `Clock` class.
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-1\. main/src/main/java/datetime/TestableDateTime
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In normal operation this would get the current date and time. In testing you
    would call the `setClock()` method with a `Clock` instance obtained from the static
    method `Clock.fixed(Instant fixedInstant, ZoneId zone)`, passing in the time that
    your testing code expects. The fixed clock does not tick, so don’t worry about
    the milliseconds between setting the clock to fixed and the invocation of your
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: 6.2 Formatting Dates and Times
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to provide better formatting for date and time objects.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use `java.time.format.DateTimeFormatter`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `DateTimeFormatter` class provides an amazing number of possible formatting
    styles. If you don’t want to use one of the provided 20 or so predefined formats,
    you can define your own using `DateTimeFormatter.ofPattern(String pattern)`. The
    `pattern` string can contain any characters, but almost every letter of the alphabet
    has been defined to mean something, in addition to the obvious *Y*, *M*, *D*,
    *h*, *m*, and *s*. In addition, the quote character and square bracket characters
    are defined, and the sharp sign (*#*) and curly braces are reserved for future
    use.
  prefs: []
  type: TYPE_NORMAL
- en: As is common with date formatting languages, the number of repetitions of a
    letter in the pattern gives a clue to its intended length of detail. Thus, for
    example, “MMM” gives “Jan,” whereas “MMMM” gives “January.”
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 6-6](#javacook-dates-format-chars) is an attempt at a complete list
    of the formatting characters, adapted from the javadoc for JSR-310.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-6\. DateFormatter format characters
  prefs: []
  type: TYPE_NORMAL
- en: '| Symbol | Meaning | Presentation | Examples |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `G` | Era | Text | AD; Anno Domini |'
  prefs: []
  type: TYPE_TB
- en: '| `y` | Year of era | Year | 2004; 04 |'
  prefs: []
  type: TYPE_TB
- en: '| `u` | Year of era | Year | See note. |'
  prefs: []
  type: TYPE_TB
- en: '| `D` | Day of year | Number | 189 |'
  prefs: []
  type: TYPE_TB
- en: '| `M/L` | Month of year | Number/text | 7; 07; Jul; July; J |'
  prefs: []
  type: TYPE_TB
- en: '| `d` | Day of month | Number | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| `Q/q` | Quarter of year | Number/text | 3; 03; Q3, 3rd quarter |'
  prefs: []
  type: TYPE_TB
- en: '| `Y` | Week based year | Year | 1996; 96 |'
  prefs: []
  type: TYPE_TB
- en: '| `w` | Week of week based year | Number | 27 |'
  prefs: []
  type: TYPE_TB
- en: '| `W` | Week of month | Number | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| `e/c` | Localized day of week | Number/text | 2; 02; Tue; Tuesday; T |'
  prefs: []
  type: TYPE_TB
- en: '| `E` | Day of week | Text | Tue; Tuesday; T |'
  prefs: []
  type: TYPE_TB
- en: '| `F` | Week of month | Number | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| `a` | am pm of day | Text | PM |'
  prefs: []
  type: TYPE_TB
- en: '| `h` | Clock hour of am pm (1-12) | Number | 12 |'
  prefs: []
  type: TYPE_TB
- en: '| `K` | Hour of am pm (0-11) | Number | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `k` | Clock hour of am pm (1-24) | Number | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `H` | Hour of day (0-23) | Number | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `m` | Minute of hour | Number | 30 |'
  prefs: []
  type: TYPE_TB
- en: '| `s` | Second of minute | Number | 55 |'
  prefs: []
  type: TYPE_TB
- en: '| `S` | Fraction of second | Fraction | 978 |'
  prefs: []
  type: TYPE_TB
- en: '| `A` | Millisecond of day | Number | 1234 |'
  prefs: []
  type: TYPE_TB
- en: '| `n` | Nanosecond of second | Number | 987654321 |'
  prefs: []
  type: TYPE_TB
- en: '| `N` | Nanosecond of day | Number | 1234000000 |'
  prefs: []
  type: TYPE_TB
- en: '| `V` | Time zone ID | Zone-id | America/Los_Angeles; Z; –08:30 |'
  prefs: []
  type: TYPE_TB
- en: '| `z` | Time zone name | Zone-name | Pacific Standard Time; PST |'
  prefs: []
  type: TYPE_TB
- en: '| `X` | Zone offset *Z* for zero | Offset-X | Z; –08; –0830; –08:30; –083015;
    –08:30:15; |'
  prefs: []
  type: TYPE_TB
- en: '| `x` | Zone offset | Offset-x | +0000; –08; –0830; –08:30; –083015; –08:30:15;
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Z` | Zone offset | Offset-Z | +0000; –0800; –08:00; |'
  prefs: []
  type: TYPE_TB
- en: '| `O` | Localized zone offset | Offset-O | GMT+8; GMT+08:00; UTC–08:00; |'
  prefs: []
  type: TYPE_TB
- en: '| `p` | Pad next | Pad modifier | 1 |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '*y* and *u* work the same for AD years; however, for a year of 3 BC, the *y*
    pattern returns 3, whereas the *u* pattern returns –2 (a.k.a. proleptic year).'
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 6-2](#javacook-dates-dateformatter) contains some examples of converting
    in both directions between strings and dates.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-2\. main/src/main/java/datetime/DateFormatter.java (example date formatting
    and parsing)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 6.3 Converting Among Dates/Times, YMDHMS, and Epoch Seconds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to convert among dates/times, YMDHMS, epoch seconds, or some other
    numeric value.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the appropriate date/time factory or retrieval methods.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The epoch is the beginning of time as far as modern operating systems go. Unix
    time, and some versions of Windows time, count off inexorably the seconds since
    the epoch. When Ken Thompson and Dennis Ritchie came up with this format in 1970,
    seconds seemed like a fine measure, and 32 bits’ worth of seconds seemed nearly
    infinite. On operating systems that store the epoch in a 32-bit integer, however,
    time is running out. Older versions of most operating systems stored this as a
    32-bit signed integer, which unfortunately will overflow in the year 2038.
  prefs: []
  type: TYPE_NORMAL
- en: When Java first came out, it featured a method called `System.currentTimeMillis()`,
    presenting epoch seconds with millisecond accuracy. The new Java API uses epoch
    nanoseconds that are still on the same time base and can be obtained with a call
    to `System.nanoTime()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any of these epoch-related numbers can be converted into, or obtained from,
    a local date/time. Other numbers can also be used, such as integer years, months,
    and days. As usual, there are factory methods that create new objects where a
    change is requested. Here is a program that shows some of these conversions in
    action:'
  prefs: []
  type: TYPE_NORMAL
- en: '*main/src/main/java/datetime/DateConversions.java*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 6.4 Parsing Strings into Dates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to convert user input into `java.time` objects.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use a `parse()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Many of the date/time classes have a `parse()` factory method, which tries
    to parse a string into an object of that class. For example, `LocalDate.parse(String)`
    returns a `LocalDate` object for the date given in the input `String`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As you probably expect by now, the default format is the ISO8601 date format.
    However, we often have to deal with dates in other formats. For this, the `DateTimeFormatter`
    allows you to specify a particular pattern. For example, “dd MMM uuuu” represents
    the day of the month (two digits), three letters of the name of the month (Jan,
    Feb, Mar, …), and a four-digit year:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DateTimeFormatter` object is bidirectional; it can both parse input and
    format output. We could add this line to the `DateParse` example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the program, we see the output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `DateTimeFormatter` is also localized (see [Recipe 3.12](ch03.html#javacook-i18n-SECT-8)),
    and can be configured by calling `withLocale()` after calling `ofPattern()`.
  prefs: []
  type: TYPE_NORMAL
- en: 6.5 Difference Between Two Dates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to compute the difference between two dates.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the static method `Period.between()` to find the difference between two
    `LocalDates`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Given two `LocalDate` objects, you can find the difference between them, as
    a `Period`, simply using the static `Period.between()` method. You can `toString()`
    the `Period` or, if its default format isn’t good enough, format the result yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'I wrote this recipe at the end of October 2013; the 20th century AD ended at
    the end of 2000, so the value should be about 12 ^(10)/[12] years, and it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Because of the APIs regularity, you can use the same technique with `LocalTime`
    or `LocalDateTime`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also `ChronoUnit`, which has numerous range values such as `DAYS`,
    `HOURS`, `MINUTES`, etc. (actually ranging from `NANOS` for nanoseconds up to
    `MILLENIA`, `ERAS`, and even `FOREVER`). If you want difference information in
    a certain unit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Unix is on its fifth decade!
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A higher-level way of formatting date/time values is discussed in [Recipe 6.2](#javacook-dates-format).
  prefs: []
  type: TYPE_NORMAL
- en: 6.6 Adding to or Subtracting from a Date
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to add or subtract a fixed period to or from a date.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a past or future date by using a locution such as `Local⁠Date.plus​(Period.ofDays(N));`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`java.time` offers a `Period` class to represent a length of time, such as
    a number of days or hours and minutes. `LocalDate` and friends offer `plus()`
    and `minus()` methods to add or subtract a `Period` or other time-related object.
    `Period` offers factory methods such as `ofDays()`. The following code computes
    what the date will be 700 days from now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this program reports the current date and time and what the date and
    time will be 700 days from now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 6.7 Handling Recurring Events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to deal with recurring dates, for example, the third Wednesday of every
    month.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `TemporalAdjusters` class.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `TemporalAdjuster` interface and the `TemporalAdjusters` factory class provide
    most of what you need for recurring events. There are many interesting and powerful
    adjusters available, shown in [Table 6-7](#javacook-dates-recurring-temporalAdjusters),
    and you can, of course, develop your own.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 6-7\. New date/time API: TemporalAdjusters factory methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method signature |'
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  prefs: []
  type: TYPE_TB
- en: '| public static TemporalAdjuster firstDayOfMonth(); |'
  prefs: []
  type: TYPE_TB
- en: '| public static TemporalAdjuster lastDayOfMonth(); |'
  prefs: []
  type: TYPE_TB
- en: '| public static TemporalAdjuster firstDayOfNextMonth(); |'
  prefs: []
  type: TYPE_TB
- en: '| public static TemporalAdjuster firstDayOfYear(); |'
  prefs: []
  type: TYPE_TB
- en: '| public static TemporalAdjuster lastDayOfYear(); |'
  prefs: []
  type: TYPE_TB
- en: '| public static TemporalAdjuster firstDayOfNextYear(); |'
  prefs: []
  type: TYPE_TB
- en: '| public static TemporalAdjuster firstInMonth(java.time.DayOfWeek); |'
  prefs: []
  type: TYPE_TB
- en: '| public static TemporalAdjuster lastInMonth(java.time.DayOfWeek); |'
  prefs: []
  type: TYPE_TB
- en: '| public static TemporalAdjuster dayOfWeekInMonth(int, java.time.DayOfWeek);
    |'
  prefs: []
  type: TYPE_TB
- en: '| public static TemporalAdjuster next(java.time.DayOfWeek); |'
  prefs: []
  type: TYPE_TB
- en: '| public static TemporalAdjuster nextOrSame(java.time.DayOfWeek); |'
  prefs: []
  type: TYPE_TB
- en: '| public static TemporalAdjuster previous(java.time.DayOfWeek); |'
  prefs: []
  type: TYPE_TB
- en: '| public static TemporalAdjuster previousOrSame(java.time.DayOfWeek); |'
  prefs: []
  type: TYPE_TB
- en: '| public static TemporalAdjuster ofDateAdjuster( java.util.function.UnaryOperator<java.time.LocalDate>);
    |'
  prefs: []
  type: TYPE_TB
- en: The names of most of these tell you directly what they do. The last one will
    make sense after reading about functional interfaces such as `UnaryOperator` in
    [Chapter 9](ch09.html#javacook-fp).
  prefs: []
  type: TYPE_NORMAL
- en: 'These are used with the `with()` method of a date/time object. For example,
    the GTABUG group ([*http://gtabug.org*](http://gtabug.org)) meets on the third
    Wednesday of every month. I have a `RecurringEventDatePicker` class in the `darwinsys-api`
    library; the core of it started as the method `getMeetingDateInMonth(LocalDate
    dateContainingMonth)`, which in our case picks the third Wednesday of a given
    month (given that *`dayOfWeek`* and *`weekOfMonth`* are both set in the constructor).
    We take the month (`dateContainingMonth`), adjust it to the first Wednesday in
    the month using the `firstInMonth()` factory method to get a temporal adjuster,
    then add the number of weeks to get the Wednesday in the correct week:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The second version simplified it to better use the existing API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Since this version was only one statement and is only used twice, we inlined
    it into the `getNextMeeting(int howManyMonthsAway)` method, which returns a `LocalDate`
    for the correct day of the given month. Its only complexity is that, for the current
    month, the meeting might be before or after today’s date, so we adjust accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This in turn is called within a JavaServer Page (JSP) web view (somewhat simplified;
    the real code has the complexities of an Add To Calendar API done in JavaScript).
    If you’ve not used JSPs, plain HTML code is *outputted* directly, the contents
    of `<% %>` tags are *executed*, and the contents of `<%= %>` tags are *evaluated
    and printed* into the HTML page, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'When visiting this site in June or July of 2015, you would have seen something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 6.8 Computing Dates Involving Time Zones
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine a problem like “Your kids are traveling on a trans-Atlantic flight from
    Toronto to London that takes 5 hours 10 minutes from the actual time of departure
    from YYZ. Your in-laws need one hour to get to LHR and find parking. What time
    should you phone them to leave for the airport?”
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The solution needs to take account of time zone differences. It can be solved
    using the `ZonedDateTime` class and methods such as `plus()` and `minus()` from
    that class.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The basic steps are shown in [Example 6-3](#javacook-datetime-flight-1).
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-3\. main/src/main/java/datetime/FlightArrivalTimeCalc.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_dates_and_times_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Get the departure time as a `LocalDateTime` (defaulting to `now()` if no arguments
    passed into `main()`, on the assumption that we run the app when the flight takes
    off).
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_dates_and_times_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Convert departure time to `ZonedDateTime`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_dates_and_times_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Convert flight time to a `Duration`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_dates_and_times_CO1-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Get the arrival time by adding the departure time to the flight duration.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_dates_and_times_CO1-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Convert the arrival time to London time with `atZone()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_dates_and_times_CO1-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Since the family takes an hour to get to the airport, subtract that from the
    arrival time. This yields the time when you should phone them.
  prefs: []
  type: TYPE_NORMAL
- en: 6.9 Interfacing with Legacy Date and Calendar Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to deal with the old `Date` and `Calendar` classes.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Assuming you have code using the original `java.util.Date` and `java.util.Calendar`,
    you can convert values as needed using conversion methods.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All the classes and interfaces in the new API were chosen to avoid conflicting
    with the traditional API. It is thus possible, and will be common for a while,
    to have imports from both packages into the same code.
  prefs: []
  type: TYPE_NORMAL
- en: To keep the new API clean, most of the necessary conversion routines were added
    *to the old API*. [Table 6-8](#javacook-dates-legacytable) summarizes these conversion
    routines; note that the methods are static if they are shown being invoked with
    a capitalized class name, otherwise they are instance methods.
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-8\. Legacy date/time interchange
  prefs: []
  type: TYPE_NORMAL
- en: '| Legacy class | Convert to legacy | Convert to modern |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `java.util.Date` | `date.from(Instant)` | `Date.toInstant()` |'
  prefs: []
  type: TYPE_TB
- en: '| `java.util.Calendar` | `calendar.toInstant()` | - |'
  prefs: []
  type: TYPE_TB
- en: '| `java.util.GregorianCalendar` | `GregorianCalendar.from(ZonedDateTime)` |
    `calendar.toZonedDateTime()` |'
  prefs: []
  type: TYPE_TB
- en: '| `java.util.TimeZone` | - | `timeZone.toZoneId()` |'
  prefs: []
  type: TYPE_TB
- en: '| `java.time.DateTimeFormatter` | - | `dateTimeFormatter.toFormat()` |'
  prefs: []
  type: TYPE_TB
- en: '[Example 6-4](#example_6_4) shows some of these APIs in action.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-4\. main/src/main/java/datetime/LegacyDates.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Of course you do not have to use these legacy converters; you are free to write
    your own. The file *LegacyDatesDIY.java* in the *javasrc* repository explores
    this option in the unlikely event you wish to pursue it.
  prefs: []
  type: TYPE_NORMAL
- en: Given the amount of code written before Java 8, it is likely that the legacy
    `Date` and `Calendar` will be around until the end of Java time.
  prefs: []
  type: TYPE_NORMAL
- en: The new date/time API has many capabilities that we have not explored. Almost
    enough for a small book on the subject, in fact. Meanwhile, you can study the
    API details at [Oracle](https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/time/package-summary.html).
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch06.html#idm45290675934040-marker)) For those with an interest in historical
    arcana, the differences are documented on his [blog](http://blog.joda.org/2009/11/why-jsr-310-isn-joda-time_4941.html).
  prefs: []
  type: TYPE_NORMAL
