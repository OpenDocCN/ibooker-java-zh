- en: Chapter 6\. Dates and Times
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章。日期和时间
- en: 6.0 Introduction
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.0 引言
- en: Developers suffered for a decade and a half under the inconsistencies and ambiguities
    of the `Date` class from Java 1.0 and its replacement wannabe, the `Calendar`
    class from Java 1.1\. Several alternative `Date` replacement packages emerged,
    including the simple and sensible [Date4J](http://date4j.net) and the more comprehensive
    [Joda-Time package](http://www.joda.org/joda-time). Java 8 introduced a new, consistent,
    and well-thought-out package for date and time handling under the aegis of the
    Java Community Process, JSR-310, shepherded by developer Stephen Colebourne, based
    on his earlier package Joda-Time, but with several important design changes.^([1](ch06.html#idm45290675934040))
    This package is biased toward ISO 8601 dates; the default format is, for example,
    2015-10-23T10:22:45\. But it can, of course, work with other calendar schemes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员在 Java 1.0 的 `Date` 类和其替代品 Java 1.1 的 `Calendar` 类的不一致性和模糊性下遭受了长达十五年的苦难。出现了几种替代
    `Date` 的包，包括简单而明智的 [Date4J](http://date4j.net) 和更全面的 [Joda-Time 包](http://www.joda.org/joda-time)。Java
    8 引入了一个新的、一致且经过深思熟虑的日期和时间处理包，由 Java 社区流程 JSR-310 主持，由开发人员 Stephen Colebourne 提出，基于他早期的
    Joda-Time 包，但进行了几个重要的设计更改。^([1](ch06.html#idm45290675934040)) 该包偏向于 ISO 8601 日期；例如，默认格式为
    2015-10-23T10:22:45。当然，它也可以与其他日历方案一起使用。
- en: One of the key benefits of the new API is that it provides *useful operations*
    such as adding/subtracting dates/times. Much time was wasted by developers reimplementing
    these useful operations again and again. With the new APIs, one can use the built-in
    functionality. That said, millions of lines of code are based on the old APIs,
    so we’ll review them briefly, and consider interfacing the new API to legacy code
    in the final recipe of this chapter, [Recipe 6.9](#javacook-dates-legacy).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 新 API 的一个关键优势是它提供了像添加/减去日期/时间等 *有用的操作*。开发人员曾多次浪费时间重复实现这些有用的操作。有了新的 API，可以使用内置功能。尽管如此，数百万行代码基于旧的
    API，因此我们将简要回顾它们，并在本章的最后一节（[Recipe 6.9](#javacook-dates-legacy)）考虑将新 API 与遗留代码进行接口化。
- en: Another advantage of the new API is that almost all objects are immutable and
    thus thread-safe. This can be of considerable benefit as we move headlong into
    the massively parallel era.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 新 API 的另一个优点是几乎所有对象都是不可变的，因此是线程安全的。随着我们迅速进入大规模并行的时代，这可能带来相当大的好处。
- en: Because there are no `set` methods, and thus the getter method paradigm doesn’t
    always make sense, the API provides a series of new methods to replace such methods,
    listed in [Table 6-1](#javacook-dates-intro-METHODS).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有 `set` 方法，因此 getter 方法范式并不总是有意义，API 提供了一系列新方法来替换这些方法，列在 [表 6-1](#javacook-dates-intro-METHODS)
    中。
- en: 'Table 6-1\. New date/time API: common methods'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-1。新日期/时间 API：常见方法
- en: '| Name | Description |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| Name | Description |'
- en: '| --- | --- |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `at` | Combines with another object |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| `at` | 与另一个对象结合 |'
- en: '| `format` | Use provided formatter to produce a formatted string |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| `format` | 使用提供的格式化器生成格式化字符串 |'
- en: '| `from` | Factory: convert input parameters to instance of target |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| `from` | 工厂：将输入参数转换为目标实例 |'
- en: '| `get` | Retrieve one field from the instance |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| `get` | 从实例中检索一个字段 |'
- en: '| `is` | Examine the state of the given object |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| `is` | 检查给定对象的状态 |'
- en: '| `minus` | Return a copy with the given amount subtracted |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| `minus` | 返回减去给定量的副本 |'
- en: '| `now` | BuilderFactory: get the current time, date, etc. |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `now` | BuilderFactory：获取当前时间、日期等 |'
- en: '| `of` | Factory: create new method by parsing inputs |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `of` | 工厂：通过解析输入创建新的方法 |'
- en: '| `parse` | Factory: parse single input string to produce instance of target
    |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `parse` | 工厂：解析单个输入字符串以生成目标实例 |'
- en: '| `plus` | Return a copy with the given amount added |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `plus` | 返回添加了给定量的副本 |'
- en: '| `to` | Convert this object to another type |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `to` | 将此对象转换为另一种类型 |'
- en: '| `with` | Return a copy with the given field changed; replaces `set` methods
    |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `with` | 返回更改了给定字段的副本；替换 `set` 方法 |'
- en: 'The JSR 310 API specifies a dozen or so main classes. Those representing times
    are either continuous time or human time. *Continuous time* is based on Unix time,
    a deeper truth from the dawn of (computer) time, and is represented as a single
    monotonically increasing number. The time value of 0 in Unix represented the first
    second of January 1, 1970 UTC—about the time Unix was invented. Each unit of increment
    there represented one second of time. This has been used as a time base in most
    operating systems developed since. However, a 32-bit integer representing the
    number of seconds since 1970 runs out fairly soon—in the year 2038 AD. Most Unix
    systems have, in the aftermath of the Y2K frenzy, quietly and well in advance
    headed off a possible Y2038 frenzy by converting the time value from a 32-bit
    quantity to a 64-bit quantity. Java also used this time base, but used 64 bits,
    and stored its time in milliseconds, because a 64-bit time in milliseconds since
    1970 will not overlow until quite a few years into the future (keep this date
    open in your calendar—August 17, 292,278,994 CE). Here is a calculation that shows
    how I got that date:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: JSR 310 API 指定了大约十几个主要类。表示时间的那些类要么是连续时间，要么是人类时间。*连续时间* 基于Unix时间，这是计算机时间的黎明时期的更深层真相，表示为单个单调递增的数字。Unix中的时间值0代表1970年1月1日UTC的第一秒，大约是Unix发明的时候。每个增量单位代表一秒钟的时间。自从Y2K事件后，大多数Unix系统已经在2038年前通过将时间值从32位转换为64位来静静地避免了可能的Y2038事件。Java也使用了这种时间基准，但使用了64位，并且以毫秒为单位存储其时间，因为自1970年以来的64位毫秒时间不会在未来几年内溢出（请在您的日历中保留此日期——292,278,994年8月17日）。下面是我得到该日期的计算：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The new API is in five packages, as shown in [Table 6-2](#table_0602); as usual,
    the top-level one contains the most commonly used pieces.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 新API包含五个包，如[表 6-2](#table_0602)所示；通常，顶层包含最常用的部分。
- en: 'Table 6-2\. New date/time API: packages'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-2\. 新的日期/时间 API：包
- en: '| Name | Description |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `java.time` | Common classes for dates, times, instants, and durations |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `java.time` | 日期、时间、时刻和持续时间的通用类 |'
- en: '| `java.time.chrono` | API for non-ISO calendar systems |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `java.time.chrono` | 非ISO日历系统的API |'
- en: '| `java.time.format` | Formatting classes (see [Recipe 6.2](#javacook-dates-format))
    |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `java.time.format` | 格式化类（参见[Recipe 6.2](#javacook-dates-format)） |'
- en: '| `java.time.temporal` | Date and time access using fields, units, and adjusters
    |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `java.time.temporal` | 使用字段、单位和调整器访问日期和时间 |'
- en: '| `java.time.zone` | Support for time zones and their rules |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `java.time.zone` | 支持时区及其规则 |'
- en: The basic `java.time` package contains a dozen or so classes, as well as a couple
    of enums and one general-purpose exception (shown in Tables [6-3](#table_0603),
    [6-4](#table_0604), and [6-5](#table_0605)).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 基础的`java.time`包包含大约十几个类，以及几个枚举和一个通用异常（在表格 [6-3](#table_0603)、[6-4](#table_0604)
    和 [6-5](#table_0605) 中显示）。
- en: 'Table 6-3\. New date/time API: basics'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-3\. 新的日期/时间 API：基础
- en: '| Class | Description |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 类 | 描述 |'
- en: '| --- | --- |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Clock` | Replaceable factory for getting current time |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `Clock` | 可替换的工厂，用于获取当前时间 |'
- en: '| `Instant` | A point in time since January 1, 1970, expressed in nanoseconds
    |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `Instant` | 表示自1970年1月1日以来的某一时刻，以纳秒表示 |'
- en: '| `Duration` | A length of time, also expressed in nanoseconds |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `Duration` | 表示一段时间，以纳秒表示 |'
- en: Human time represents times and dates as we use them in our everyday life. These
    classes are listed in [Table 6-4](#table_0604).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 人类时间将时间和日期表示为我们日常生活中使用的方式。这些类在[表 6-4](#table_0604)中列出。
- en: 'Table 6-4\. New date/time API: human time'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-4\. 新的日期/时间 API：人类时间
- en: '| Class | Description |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 类 | 描述 |'
- en: '| --- | --- |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Calendrical` | Connects to the low-level API |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `Calendrical` | 连接到低级API |'
- en: '| `DateTimeFields` | Stores a map of field-value pairs, which are not required
    to be consistent |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `DateTimeFields` | 存储字段-值对的映射，这些对不需要保持一致 |'
- en: '| `DayOfWeek` | A day of the week (e.g., Tuesday) |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `DayOfWeek` | 一周的某一天（例如星期二） |'
- en: '| `LocalDate` | A bare date (day, month, and year) with no adjustments |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `LocalDate` | 仅表示日期（日、月、年），没有任何调整 |'
- en: '| `LocalTime` | A bare time (hour, minute, seconds) with no adjustments |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `LocalTime` | 仅表示时间（小时、分钟、秒），没有任何调整 |'
- en: '| `LocalDateTime` | The combination of the above |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `LocalDateTime` | 上述所有内容的组合 |'
- en: '| `MonthDay` | Month and day |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `MonthDay` | 月份和日期 |'
- en: '| `OffsetTime` | A time of day with a time zone offset like –04:00, with no
    date or zone |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `OffsetTime` | 带有时区偏移（例如 -04:00）的某一天的时间，没有日期或时区 |'
- en: '| `OffsetDateTime` | A date and time with a time zone offset like –04:00, with
    no time zone |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `OffsetDateTime` | 带有时间偏移的日期和时间，如 –04:00，但没有时区 |'
- en: '| `Period` | A descriptive amount of time, such as “2 months and 3 days” |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `Period` | 描述性的时间量，例如“2 个月 3 天” |'
- en: '| `ZonedDateTime` | The date and time with a time zone and an offset |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `ZonedDateTime` | 带有时区和偏移量的日期和时间 |'
- en: '| `Year` | A year by itself |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `Year` | 一个年份 |'
- en: '| `YearMonth` | A year and month |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `YearMonth` | 年和月份 |'
- en: Almost all the top-level classes directly extend `java.lang.Object` and are
    held to consistency by a variety of interfaces, which are declared in the subpackages.
    The date and time classes mostly implement `Comparable`, which makes sense.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有顶级类直接扩展 `java.lang.Object` 并通过各种接口保持一致性，这些接口在子包中声明。日期和时间类大多实现了 `Comparable`，这是有意义的。
- en: '[Table 6-5](#table_0605) shows the two time-zone-specific classes used with
    `ZonedDateTime`, `OffsetDateTime`, and `OffsetTime`.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 6-5](#table_0605) 展示了与 `ZonedDateTime`, `OffsetDateTime`, 和 `OffsetTime`
    一起使用的两个特定于时区的类。'
- en: 'Table 6-5\. New date/time API: support'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-5\. 新的日期/时间 API：支持
- en: '| Class | Description |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 类 | 描述 |'
- en: '| --- | --- |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `ZoneOffset` | A time offset from UTC (hours, minutes, seconds) |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `ZoneOffset` | 从 UTC 偏移的时间偏移量（小时，分钟，秒） |'
- en: '| `ZoneId` | Defines a time zone such as *Canada/Eastern* and its conversion
    rules |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `ZoneId` | 定义诸如 *Canada/Eastern* 等时区及其转换规则 |'
- en: 'The new API is a *fluent API*, in which most operations return the object they
    have operated upon, so that you can chain multiple calls without the need for
    tedious and annoying temporary variables:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 新 API 是*流畅 API*，大多数操作返回它们所操作的对象，因此您可以在不需要繁琐和烦人的临时变量的情况下链式调用多个调用：
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This results in a more natural and convenient coding style, in my opinion. You
    can always write code with lots of temporary variables if you want; you’re the
    one who will have to read through it later.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，这样会产生更自然和方便的编码风格。如果您愿意，总是可以编写带有大量临时变量的代码；最后需要读这些代码的是您自己。
- en: 6.1 Finding Today’s Date
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.1 寻找今天的日期
- en: Problem
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to find today’s date and/or time.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望找到今天的日期和/或时间。
- en: Solution
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Invoke the appropriate builder to obtain a `LocalDate`, `LocalTime`, or `LocalDateTime`
    object and call its `toString()` method.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 调用适当的构建器以获取 `LocalDate`, `LocalTime`, 或 `LocalDateTime` 对象，并调用其 `toString()`
    方法。
- en: Discussion
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'These classes do not provide public constructors, so you will need to call
    one of its factory methods to get an instance. They all provide a `now()` method,
    which does what its name implies. The `CurrentDateTime` demo program shows simple
    use of all three:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类没有公共构造函数，因此您需要调用其中一个工厂方法来获取实例。它们都提供一个 `now()` 方法，其功能如其名称所示。`CurrentDateTime`
    演示程序展示了所有三个类的简单用法：
- en: '[PRE2]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Running it produces this output:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 运行它会产生以下输出：
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The formatting is nothing spectacular, but it’s adequate. We’ll deal with fancier
    formatting in [Recipe 6.2](#javacook-dates-format).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 格式化并不引人注目，但足够使用。我们将在[食谱 6.2](#javacook-dates-format) 中处理更复杂的格式化。
- en: While this works, in full-scale applications, it’s recommended to pass a `Clock`
    instance into all the `now()` methods. `Clock` is a factory object that is used
    internally to find the current time. In testing, you often want to have a known
    date or time used so you can compare against known output. The `Clock` class makes
    this easy. [Example 6-1](#javacook-datetime-EX-clock) uses a `Clock` and allows
    replacing the default `Clock` by calling a setter. Alternately you could use a
    dependency injection framework like CDI or Spring to provide the correct version
    of the `Clock` class.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这样可以工作，在大型应用程序中，建议将一个 `Clock` 实例传递给所有的 `now()` 方法。`Clock` 是一个工厂对象，用于在内部查找当前时间。在测试中，通常希望使用已知的日期或时间进行比较以获取已知的输出。`Clock`
    类使这变得容易。[示例 6-1](#javacook-datetime-EX-clock) 使用了一个 `Clock` 并允许通过调用 setter 来替换默认的
    `Clock`。或者，您可以使用像 CDI 或 Spring 这样的依赖注入框架来提供正确版本的 `Clock` 类。
- en: Example 6-1\. main/src/main/java/datetime/TestableDateTime
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-1\. main/src/main/java/datetime/TestableDateTime
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In normal operation this would get the current date and time. In testing you
    would call the `setClock()` method with a `Clock` instance obtained from the static
    method `Clock.fixed(Instant fixedInstant, ZoneId zone)`, passing in the time that
    your testing code expects. The fixed clock does not tick, so don’t worry about
    the milliseconds between setting the clock to fixed and the invocation of your
    tests.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常操作中，会获取当前日期和时间。在测试中，您可以使用 `setClock()` 方法和从静态方法 `Clock.fixed(Instant fixedInstant,
    ZoneId zone)` 获得的 `Clock` 实例，传入您的测试代码期望的时间。固定时钟不会滴答，所以在将时钟设置为固定时和调用测试之间的毫秒数不必担心。
- en: 6.2 Formatting Dates and Times
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.2 格式化日期和时间
- en: Problem
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to provide better formatting for date and time objects.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望为日期和时间对象提供更好的格式化。
- en: Solution
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use `java.time.format.DateTimeFormatter`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `java.time.format.DateTimeFormatter`。
- en: Discussion
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The `DateTimeFormatter` class provides an amazing number of possible formatting
    styles. If you don’t want to use one of the provided 20 or so predefined formats,
    you can define your own using `DateTimeFormatter.ofPattern(String pattern)`. The
    `pattern` string can contain any characters, but almost every letter of the alphabet
    has been defined to mean something, in addition to the obvious *Y*, *M*, *D*,
    *h*, *m*, and *s*. In addition, the quote character and square bracket characters
    are defined, and the sharp sign (*#*) and curly braces are reserved for future
    use.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`DateTimeFormatter` 类提供了大量可能的格式化样式。如果您不想使用提供的约 20 种预定义格式之一，可以使用 `DateTimeFormatter.ofPattern(String
    pattern)` 来定义自己的格式。`pattern` 字符串可以包含任何字符，但除了明显的 *Y*, *M*, *D*, *h*, *m*, 和 *s*
    外，几乎每个字母都有其特定含义。此外，引号字符和方括号也有定义，井号 (*#*) 和花括号则保留供将来使用。'
- en: As is common with date formatting languages, the number of repetitions of a
    letter in the pattern gives a clue to its intended length of detail. Thus, for
    example, “MMM” gives “Jan,” whereas “MMMM” gives “January.”
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如日期格式化语言通常所示，模式中字母的重复次数提示了其意图的详细程度。因此，例如，“MMM” 表示 “Jan”，而 “MMMM” 表示 “January”。
- en: '[Table 6-6](#javacook-dates-format-chars) is an attempt at a complete list
    of the formatting characters, adapted from the javadoc for JSR-310.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[表格 6-6](#javacook-dates-format-chars) 是从 JSR-310 的 javadoc 改编的格式字符完整列表的尝试。'
- en: Table 6-6\. DateFormatter format characters
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 6-6\. DateFormatter 格式字符
- en: '| Symbol | Meaning | Presentation | Examples |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 符号 | 含义 | 显示方式 | 示例 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `G` | Era | Text | AD; Anno Domini |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `G` | 纪元 | 文本 | AD; Anno Domini |'
- en: '| `y` | Year of era | Year | 2004; 04 |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `y` | 年份 | 年份 | 2004; 04 |'
- en: '| `u` | Year of era | Year | See note. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `u` | 年份 | 年份 | 见备注。 |'
- en: '| `D` | Day of year | Number | 189 |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `D` | 年份中的日期 | 数字 | 189 |'
- en: '| `M/L` | Month of year | Number/text | 7; 07; Jul; July; J |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `M/L` | 月份 | 数字/文本 | 7; 07; Jul; July; J |'
- en: '| `d` | Day of month | Number | 10 |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `d` | 月份中的日期 | 数字 | 10 |'
- en: '| `Q/q` | Quarter of year | Number/text | 3; 03; Q3, 3rd quarter |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `Q/q` | 年份的季度 | 数字/文本 | 3; 03; Q3, 3rd quarter |'
- en: '| `Y` | Week based year | Year | 1996; 96 |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `Y` | 基于周的年份 | 年份 | 1996; 96 |'
- en: '| `w` | Week of week based year | Number | 27 |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `w` | 基于年的周数 | 数字 | 27 |'
- en: '| `W` | Week of month | Number | 4 |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `W` | 月中的周数 | 数字 | 4 |'
- en: '| `e/c` | Localized day of week | Number/text | 2; 02; Tue; Tuesday; T |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `e/c` | 本地化的星期几 | 数字/文本 | 2; 02; Tue; Tuesday; T |'
- en: '| `E` | Day of week | Text | Tue; Tuesday; T |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `E` | 星期几 | 文本 | Tue; Tuesday; T |'
- en: '| `F` | Week of month | Number | 3 |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `F` | 月中的周数 | 数字 | 3 |'
- en: '| `a` | am pm of day | Text | PM |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `a` | 上午/下午 | 文本 | PM |'
- en: '| `h` | Clock hour of am pm (1-12) | Number | 12 |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `h` | 上午/下午的小时数 (1-12) | 数字 | 12 |'
- en: '| `K` | Hour of am pm (0-11) | Number | 0 |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `K` | 上午/下午的小时数 (0-11) | 数字 | 0 |'
- en: '| `k` | Clock hour of am pm (1-24) | Number | 0 |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `k` | 上午/下午的小时数 (1-24) | 数字 | 0 |'
- en: '| `H` | Hour of day (0-23) | Number | 0 |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `H` | 一天中的小时数 (0-23) | 数字 | 0 |'
- en: '| `m` | Minute of hour | Number | 30 |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `m` | 小时中的分钟数 | 数字 | 30 |'
- en: '| `s` | Second of minute | Number | 55 |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `s` | 分钟中的秒数 | 数字 | 55 |'
- en: '| `S` | Fraction of second | Fraction | 978 |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `S` | 秒的分数 | 分数 | 978 |'
- en: '| `A` | Millisecond of day | Number | 1234 |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `A` | 一天中的毫秒数 | 数字 | 1234 |'
- en: '| `n` | Nanosecond of second | Number | 987654321 |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `n` | 秒中的纳秒数 | 数字 | 987654321 |'
- en: '| `N` | Nanosecond of day | Number | 1234000000 |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `N` | 一天中的纳秒数 | 数字 | 1234000000 |'
- en: '| `V` | Time zone ID | Zone-id | America/Los_Angeles; Z; –08:30 |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `V` | 时区 ID | 时区ID | America/Los_Angeles; Z; –08:30 |'
- en: '| `z` | Time zone name | Zone-name | Pacific Standard Time; PST |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `z` | 时区名称 | 时区名称 | Pacific Standard Time; PST |'
- en: '| `X` | Zone offset *Z* for zero | Offset-X | Z; –08; –0830; –08:30; –083015;
    –08:30:15; |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `X` | 零时区偏移量 *Z* | 偏移量-X | Z; –08; –0830; –08:30; –083015; –08:30:15; |'
- en: '| `x` | Zone offset | Offset-x | +0000; –08; –0830; –08:30; –083015; –08:30:15;
    |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `x` | 时区偏移 | 偏移-x | +0000; –08; –0830; –08:30; –083015; –08:30:15; |'
- en: '| `Z` | Zone offset | Offset-Z | +0000; –0800; –08:00; |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `Z` | 时区偏移 | 偏移-Z | +0000; –0800; –08:00; |'
- en: '| `O` | Localized zone offset | Offset-O | GMT+8; GMT+08:00; UTC–08:00; |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `O` | 本地化时区偏移 | 偏移-O | GMT+8; GMT+08:00; UTC–08:00; |'
- en: '| `p` | Pad next | Pad modifier | 1 |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `p` | 下一个填充 | 填充修饰符 | 1 |'
- en: Note
  id: totrans-124
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '*y* and *u* work the same for AD years; however, for a year of 3 BC, the *y*
    pattern returns 3, whereas the *u* pattern returns –2 (a.k.a. proleptic year).'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*y* 和 *u* 对于公元年份是相同的；但是，对于公元前 3 年，*y* 模式返回 3，而 *u* 模式返回 -2（也称为预测年）。'
- en: '[Example 6-2](#javacook-dates-dateformatter) contains some examples of converting
    in both directions between strings and dates.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6-2](#javacook-dates-dateformatter)包含一些在字符串和日期之间进行双向转换的示例。'
- en: Example 6-2\. main/src/main/java/datetime/DateFormatter.java (example date formatting
    and parsing)
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-2\. main/src/main/java/datetime/DateFormatter.java（示例日期格式化和解析）
- en: '[PRE5]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 6.3 Converting Among Dates/Times, YMDHMS, and Epoch Seconds
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.3 在日期/时间、YMDHMS 和时代秒之间进行转换
- en: Problem
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to convert among dates/times, YMDHMS, epoch seconds, or some other
    numeric value.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在日期/时间、YMDHMS、时代秒或其他一些数字值之间进行转换。
- en: Solution
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the appropriate date/time factory or retrieval methods.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用适当的日期/时间工厂或检索方法。
- en: Discussion
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The epoch is the beginning of time as far as modern operating systems go. Unix
    time, and some versions of Windows time, count off inexorably the seconds since
    the epoch. When Ken Thompson and Dennis Ritchie came up with this format in 1970,
    seconds seemed like a fine measure, and 32 bits’ worth of seconds seemed nearly
    infinite. On operating systems that store the epoch in a 32-bit integer, however,
    time is running out. Older versions of most operating systems stored this as a
    32-bit signed integer, which unfortunately will overflow in the year 2038.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 时代是现代操作系统开始的时间。Unix 时间和一些 Windows 时间版本从时代开始不可避免地计算秒数。1970 年，肯·汤普森和丹尼斯·里奇提出这种格式时，秒数看起来像是一个不错的度量单位，32
    位的秒数似乎近乎无限。然而，在将时代存储为 32 位整数的操作系统上，时间正在流逝。大多数操作系统的旧版本将其存储为 32 位有符号整数，不幸的是，这将在
    2038 年溢出。
- en: When Java first came out, it featured a method called `System.currentTimeMillis()`,
    presenting epoch seconds with millisecond accuracy. The new Java API uses epoch
    nanoseconds that are still on the same time base and can be obtained with a call
    to `System.nanoTime()`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Java 刚发布时，它有一个叫做`System.currentTimeMillis()`的方法，以毫秒精度表示时代秒。新的 Java API 使用的是纳秒时代，仍然处于相同的时间基准上，可以通过调用`System.nanoTime()`获得。
- en: 'Any of these epoch-related numbers can be converted into, or obtained from,
    a local date/time. Other numbers can also be used, such as integer years, months,
    and days. As usual, there are factory methods that create new objects where a
    change is requested. Here is a program that shows some of these conversions in
    action:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这些与时代相关的任何数字都可以转换为本地日期/时间，也可以从中获取。还可以使用其他数字，如整数年份、月份和天数。通常情况下，有一些工厂方法可以在请求更改时创建新对象。下面是一个演示这些转换的程序：
- en: '*main/src/main/java/datetime/DateConversions.java*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*main/src/main/java/datetime/DateConversions.java*'
- en: '[PRE6]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 6.4 Parsing Strings into Dates
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.4 将字符串解析为日期
- en: Problem
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to convert user input into `java.time` objects.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要将用户输入转换为`java.time`对象。
- en: Solution
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use a `parse()` method.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`parse()`方法。
- en: Discussion
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Many of the date/time classes have a `parse()` factory method, which tries
    to parse a string into an object of that class. For example, `LocalDate.parse(String)`
    returns a `LocalDate` object for the date given in the input `String`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 许多日期/时间类都有一个`parse()`工厂方法，试图将字符串解析为该类的对象。例如，`LocalDate.parse(String)`返回一个给定日期的`LocalDate`对象：
- en: '[PRE7]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As you probably expect by now, the default format is the ISO8601 date format.
    However, we often have to deal with dates in other formats. For this, the `DateTimeFormatter`
    allows you to specify a particular pattern. For example, “dd MMM uuuu” represents
    the day of the month (two digits), three letters of the name of the month (Jan,
    Feb, Mar, …), and a four-digit year:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你现在可能预期的那样，默认格式是 ISO8601 日期格式。但是，我们经常需要处理其他格式的日期。为此，`DateTimeFormatter`允许您指定特定的模式。例如，“dd
    MMM uuuu”表示月份中的日期（两位数字）、月份名称的三个字母（Jan、Feb、Mar，…）和四位数字年份：
- en: '[PRE8]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `DateTimeFormatter` object is bidirectional; it can both parse input and
    format output. We could add this line to the `DateParse` example:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`DateTimeFormatter`对象是双向的；它既可以解析输入，也可以格式化输出。我们可以将这一行添加到`DateParse`示例中：'
- en: '[PRE9]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When we run the program, we see the output as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行程序时，输出如下所示：
- en: '[PRE10]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `DateTimeFormatter` is also localized (see [Recipe 3.12](ch03.html#javacook-i18n-SECT-8)),
    and can be configured by calling `withLocale()` after calling `ofPattern()`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`DateTimeFormatter`也是本地化的（参见[配方 3.12](ch03.html#javacook-i18n-SECT-8)），可以在调用`ofPattern()`后调用`withLocale()`进行配置。'
- en: 6.5 Difference Between Two Dates
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.5 两个日期之间的差异
- en: Problem
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to compute the difference between two dates.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要计算两个日期之间的差异。
- en: Solution
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the static method `Period.between()` to find the difference between two
    `LocalDates`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用静态方法`Period.between()`来找到两个`LocalDate`之间的差异。
- en: Discussion
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Given two `LocalDate` objects, you can find the difference between them, as
    a `Period`, simply using the static `Period.between()` method. You can `toString()`
    the `Period` or, if its default format isn’t good enough, format the result yourself:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 给定两个`LocalDate`对象，你可以使用静态方法`Period.between()`简单地找到它们之间的差异作为一个`Period`。你可以`toString()`这个`Period`，或者如果默认格式不够好，可以自己格式化结果：
- en: '[PRE11]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'I wrote this recipe at the end of October 2013; the 20th century AD ended at
    the end of 2000, so the value should be about 12 ^(10)/[12] years, and it is:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我在2013年10月底写下了这个配方；公元20世纪末在2000年末结束，所以值应约为12^(10)/[12]年，即：
- en: '[PRE12]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Because of the APIs regularity, you can use the same technique with `LocalTime`
    or `LocalDateTime`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 由于API的规律性，你可以在`LocalTime`或`LocalDateTime`中使用相同的技术。
- en: 'There is also `ChronoUnit`, which has numerous range values such as `DAYS`,
    `HOURS`, `MINUTES`, etc. (actually ranging from `NANOS` for nanoseconds up to
    `MILLENIA`, `ERAS`, and even `FOREVER`). If you want difference information in
    a certain unit:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChronoUnit`也存在，包含许多范围值，比如`DAYS`、`HOURS`、`MINUTES`等（实际范围从`NANOS`到`MILLENIA`、`ERAS`甚至`FOREVER`）。如果你想要在某个单位获取差异信息：'
- en: '[PRE13]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Unix is on its fifth decade!
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Unix已经进入了它的第五个十年！
- en: See Also
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: A higher-level way of formatting date/time values is discussed in [Recipe 6.2](#javacook-dates-format).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论[配方 6.2](#javacook-dates-format)讨论了格式化日期/时间值的高级方法。
- en: 6.6 Adding to or Subtracting from a Date
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.6 增加或减少日期
- en: Problem
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to add or subtract a fixed period to or from a date.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要对日期加上或减去一个固定的周期。
- en: Solution
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Create a past or future date by using a locution such as `Local⁠Date.plus​(Period.ofDays(N));`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 使用如`Local⁠Date.plus​(Period.ofDays(N));`这样的表达式可以创建过去或未来的日期。
- en: Discussion
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: '`java.time` offers a `Period` class to represent a length of time, such as
    a number of days or hours and minutes. `LocalDate` and friends offer `plus()`
    and `minus()` methods to add or subtract a `Period` or other time-related object.
    `Period` offers factory methods such as `ofDays()`. The following code computes
    what the date will be 700 days from now:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.time`提供了`Period`类来表示一段时间，比如几天、几小时和几分钟。`LocalDate`等类提供了`plus()`和`minus()`方法来增加或减少`Period`或其他与时间相关的对象。`Period`还提供了像`ofDays()`这样的工厂方法。以下代码计算从现在起700天后的日期：'
- en: '[PRE14]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Running this program reports the current date and time and what the date and
    time will be 700 days from now:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个程序会报告当前的日期和时间，以及从现在起700天后的日期和时间：
- en: '[PRE15]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 6.7 Handling Recurring Events
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.7 处理重复事件
- en: Problem
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to deal with recurring dates, for example, the third Wednesday of every
    month.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要处理重复发生的日期，例如每个月的第三个星期三。
- en: Solution
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the `TemporalAdjusters` class.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`TemporalAdjusters`类。
- en: Discussion
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The `TemporalAdjuster` interface and the `TemporalAdjusters` factory class provide
    most of what you need for recurring events. There are many interesting and powerful
    adjusters available, shown in [Table 6-7](#javacook-dates-recurring-temporalAdjusters),
    and you can, of course, develop your own.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`TemporalAdjuster`接口和`TemporalAdjusters`工厂类提供了大部分处理重复事件所需的功能。有许多有趣而强大的调整器可用，如[表 6-7](https://wiki.example.org/javacook-dates-recurring-temporalAdjusters)中所示，当然你也可以自己开发。'
- en: 'Table 6-7\. New date/time API: TemporalAdjusters factory methods'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-7\. 新日期/时间API：TemporalAdjusters工厂方法
- en: '| Method signature |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| 方法签名 |'
- en: '| --- |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| public static TemporalAdjuster firstDayOfMonth(); |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| public static TemporalAdjuster firstDayOfMonth(); |'
- en: '| public static TemporalAdjuster lastDayOfMonth(); |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| public static TemporalAdjuster lastDayOfMonth(); |'
- en: '| public static TemporalAdjuster firstDayOfNextMonth(); |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| public static TemporalAdjuster firstDayOfNextMonth(); |'
- en: '| public static TemporalAdjuster firstDayOfYear(); |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| public static TemporalAdjuster firstDayOfYear(); |'
- en: '| public static TemporalAdjuster lastDayOfYear(); |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| public static TemporalAdjuster lastDayOfYear(); |'
- en: '| public static TemporalAdjuster firstDayOfNextYear(); |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| public static TemporalAdjuster firstDayOfNextYear(); |'
- en: '| public static TemporalAdjuster firstInMonth(java.time.DayOfWeek); |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| public static TemporalAdjuster firstInMonth(java.time.DayOfWeek); |'
- en: '| public static TemporalAdjuster lastInMonth(java.time.DayOfWeek); |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| public static TemporalAdjuster lastInMonth(java.time.DayOfWeek); |'
- en: '| public static TemporalAdjuster dayOfWeekInMonth(int, java.time.DayOfWeek);
    |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| public static TemporalAdjuster dayOfWeekInMonth(int, java.time.DayOfWeek);
    |'
- en: '| public static TemporalAdjuster next(java.time.DayOfWeek); |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| public static TemporalAdjuster next(java.time.DayOfWeek); |'
- en: '| public static TemporalAdjuster nextOrSame(java.time.DayOfWeek); |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| public static TemporalAdjuster nextOrSame(java.time.DayOfWeek); |'
- en: '| public static TemporalAdjuster previous(java.time.DayOfWeek); |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| public static TemporalAdjuster previous(java.time.DayOfWeek); |'
- en: '| public static TemporalAdjuster previousOrSame(java.time.DayOfWeek); |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| public static TemporalAdjuster previousOrSame(java.time.DayOfWeek); |'
- en: '| public static TemporalAdjuster ofDateAdjuster( java.util.function.UnaryOperator<java.time.LocalDate>);
    |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| public static TemporalAdjuster ofDateAdjuster( java.util.function.UnaryOperator<java.time.LocalDate>);
    |'
- en: The names of most of these tell you directly what they do. The last one will
    make sense after reading about functional interfaces such as `UnaryOperator` in
    [Chapter 9](ch09.html#javacook-fp).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数名称直接告诉您它们的功能。在阅读有关如 `UnaryOperator` 的函数接口的第九章 [Chapter 9](ch09.html#javacook-fp)
    后，最后一个将变得清晰明了。
- en: 'These are used with the `with()` method of a date/time object. For example,
    the GTABUG group ([*http://gtabug.org*](http://gtabug.org)) meets on the third
    Wednesday of every month. I have a `RecurringEventDatePicker` class in the `darwinsys-api`
    library; the core of it started as the method `getMeetingDateInMonth(LocalDate
    dateContainingMonth)`, which in our case picks the third Wednesday of a given
    month (given that *`dayOfWeek`* and *`weekOfMonth`* are both set in the constructor).
    We take the month (`dateContainingMonth`), adjust it to the first Wednesday in
    the month using the `firstInMonth()` factory method to get a temporal adjuster,
    then add the number of weeks to get the Wednesday in the correct week:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这些与日期/时间对象的 `with()` 方法一起使用。例如，GTABUG 小组 ([*http://gtabug.org*](http://gtabug.org))
    每月第三个星期三举行会议。在 `darwinsys-api` 库中有一个 `RecurringEventDatePicker` 类；其核心部分始于方法 `getMeetingDateInMonth(LocalDate
    dateContainingMonth)`，在我们的情况下选择给定月份的第三个星期三（在构造函数中设置了 *`dayOfWeek`* 和 *`weekOfMonth`*）。我们获取月份
    (`dateContainingMonth`)，使用 `firstInMonth()` 工厂方法调整为该月的第一个星期三，然后添加周数以获取正确星期的星期三：
- en: '[PRE16]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The second version simplified it to better use the existing API:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个版本简化了它以更好地使用现有的 API：
- en: '[PRE17]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Since this version was only one statement and is only used twice, we inlined
    it into the `getNextMeeting(int howManyMonthsAway)` method, which returns a `LocalDate`
    for the correct day of the given month. Its only complexity is that, for the current
    month, the meeting might be before or after today’s date, so we adjust accordingly:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此版本仅包含一个语句，且仅使用两次，我们将其内联到`getNextMeeting(int howManyMonthsAway)`方法中，该方法返回给定月份中正确日期的`LocalDate`。其唯一的复杂性在于，对于当前月份，会议可能在今天的日期之前或之后，因此我们进行相应调整：
- en: '[PRE18]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This in turn is called within a JavaServer Page (JSP) web view (somewhat simplified;
    the real code has the complexities of an Add To Calendar API done in JavaScript).
    If you’ve not used JSPs, plain HTML code is *outputted* directly, the contents
    of `<% %>` tags are *executed*, and the contents of `<%= %>` tags are *evaluated
    and printed* into the HTML page, like this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在 JavaServer Page (JSP) web 视图中调用此方法（略有简化；真实代码具有 JavaScript 中的 Add To Calendar
    API 的复杂性）。如果您尚未使用 JSP，请直接输出纯 HTML 代码，`<% %>` 标签的内容将被执行，`<%= %>` 标签的内容将被评估并打印到
    HTML 页面中，例如：
- en: '[PRE19]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When visiting this site in June or July of 2015, you would have seen something
    like this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 2015 年的六月或七月访问此网站时，您可能会看到类似以下内容：
- en: '[PRE20]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 6.8 Computing Dates Involving Time Zones
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.8 计算涉及时区的日期
- en: Problem
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Imagine a problem like “Your kids are traveling on a trans-Atlantic flight from
    Toronto to London that takes 5 hours 10 minutes from the actual time of departure
    from YYZ. Your in-laws need one hour to get to LHR and find parking. What time
    should you phone them to leave for the airport?”
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个问题：“您的孩子正在从多伦多飞往伦敦的跨大西洋航班，从实际起飞时间（YYZ）起需 5 小时 10 分钟。您的岳父母需要一个小时到达 LHR 并找到停车位。您应该在什么时间打电话告诉他们去机场？”
- en: Solution
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: The solution needs to take account of time zone differences. It can be solved
    using the `ZonedDateTime` class and methods such as `plus()` and `minus()` from
    that class.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案需要考虑时区差异。可以使用 `ZonedDateTime` 类及其 `plus()` 和 `minus()` 方法来解决。
- en: Discussion
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The basic steps are shown in [Example 6-3](#javacook-datetime-flight-1).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 基本步骤如示例 [Example 6-3](#javacook-datetime-flight-1) 中所示。
- en: Example 6-3\. main/src/main/java/datetime/FlightArrivalTimeCalc.java
  id: totrans-223
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-3\. main/src/main/java/datetime/FlightArrivalTimeCalc.java
- en: '[PRE21]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[![1](assets/1.png)](#co_dates_and_times_CO1-1)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_dates_and_times_CO1-1)'
- en: Get the departure time as a `LocalDateTime` (defaulting to `now()` if no arguments
    passed into `main()`, on the assumption that we run the app when the flight takes
    off).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 获取出发时间作为 `LocalDateTime`（如果没有传入参数到 `main()`，则默认为 `now()`，假设我们在飞机起飞时运行应用程序）。
- en: '[![2](assets/2.png)](#co_dates_and_times_CO1-3)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_dates_and_times_CO1-3)'
- en: Convert departure time to `ZonedDateTime`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 将出发时间转换为 `ZonedDateTime`。
- en: '[![3](assets/3.png)](#co_dates_and_times_CO1-4)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_dates_and_times_CO1-4)'
- en: Convert flight time to a `Duration`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 将航班时间转换为 `Duration`。
- en: '[![4](assets/4.png)](#co_dates_and_times_CO1-5)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_dates_and_times_CO1-5)'
- en: Get the arrival time by adding the departure time to the flight duration.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将出发时间加上飞行持续时间来获取到达时间。
- en: '[![5](assets/5.png)](#co_dates_and_times_CO1-6)'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_dates_and_times_CO1-6)'
- en: Convert the arrival time to London time with `atZone()`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `atZone()` 将到达时间转换为伦敦时间。
- en: '[![6](assets/6.png)](#co_dates_and_times_CO1-7)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_dates_and_times_CO1-7)'
- en: Since the family takes an hour to get to the airport, subtract that from the
    arrival time. This yields the time when you should phone them.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 由于全家需要一个小时才能到达机场，从到达时间减去这段时间。这会得出你应该打电话的时间。
- en: 6.9 Interfacing with Legacy Date and Calendar Classes
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.9 与旧版日期和日历类的接口
- en: Problem
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to deal with the old `Date` and `Calendar` classes.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要处理旧的 `Date` 和 `Calendar` 类。
- en: Solution
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Assuming you have code using the original `java.util.Date` and `java.util.Calendar`,
    you can convert values as needed using conversion methods.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您的代码使用原始的 `java.util.Date` 和 `java.util.Calendar`，您可以根据需要使用转换方法转换值。
- en: Discussion
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: All the classes and interfaces in the new API were chosen to avoid conflicting
    with the traditional API. It is thus possible, and will be common for a while,
    to have imports from both packages into the same code.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 新 API 中的所有类和接口都被选择为避免与传统 API 冲突。因此，在相同的代码中导入这两个包可能是可能的，并且在一段时间内将是常见的。
- en: To keep the new API clean, most of the necessary conversion routines were added
    *to the old API*. [Table 6-8](#javacook-dates-legacytable) summarizes these conversion
    routines; note that the methods are static if they are shown being invoked with
    a capitalized class name, otherwise they are instance methods.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持新的 API 的整洁，大部分必要的转换例程被添加到*旧 API*中。[Table 6-8](#javacook-dates-legacytable)
    总结了这些转换例程；请注意，如果显示的是以大写类名调用的静态方法，则这些方法是静态的，否则它们是实例方法。
- en: Table 6-8\. Legacy date/time interchange
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Table 6-8\. 传统日期/时间互操作性
- en: '| Legacy class | Convert to legacy | Convert to modern |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| 传统类 | 转换为传统 | 转换为现代 |'
- en: '| --- | --- | --- |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `java.util.Date` | `date.from(Instant)` | `Date.toInstant()` |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| `java.util.Date` | `date.from(Instant)` | `Date.toInstant()` |'
- en: '| `java.util.Calendar` | `calendar.toInstant()` | - |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| `java.util.Calendar` | `calendar.toInstant()` | - |'
- en: '| `java.util.GregorianCalendar` | `GregorianCalendar.from(ZonedDateTime)` |
    `calendar.toZonedDateTime()` |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| `java.util.GregorianCalendar` | `GregorianCalendar.from(ZonedDateTime)` |
    `calendar.toZonedDateTime()` |'
- en: '| `java.util.TimeZone` | - | `timeZone.toZoneId()` |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| `java.util.TimeZone` | - | `timeZone.toZoneId()` |'
- en: '| `java.time.DateTimeFormatter` | - | `dateTimeFormatter.toFormat()` |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| `java.time.DateTimeFormatter` | - | `dateTimeFormatter.toFormat()` |'
- en: '[Example 6-4](#example_6_4) shows some of these APIs in action.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '[Example 6-4](#example_6_4) 展示了其中一些 API 的运行情况。'
- en: Example 6-4\. main/src/main/java/datetime/LegacyDates.java
  id: totrans-254
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 6-4\. main/src/main/java/datetime/LegacyDates.java
- en: '[PRE22]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Of course you do not have to use these legacy converters; you are free to write
    your own. The file *LegacyDatesDIY.java* in the *javasrc* repository explores
    this option in the unlikely event you wish to pursue it.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您不必使用这些旧的转换器；您可以自由地编写自己的转换器。如果您希望追求这种选择，*javasrc* 仓库中的 *LegacyDatesDIY.java*
    文件探讨了这个选项。
- en: Given the amount of code written before Java 8, it is likely that the legacy
    `Date` and `Calendar` will be around until the end of Java time.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于在 Java 8 之前编写的大量代码，直到 Java 的终结，传统的 `Date` 和 `Calendar` 可能会存在。
- en: The new date/time API has many capabilities that we have not explored. Almost
    enough for a small book on the subject, in fact. Meanwhile, you can study the
    API details at [Oracle](https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/time/package-summary.html).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 新的日期/时间 API 有许多我们尚未探索的功能。事实上，这几乎足以编写一本关于该主题的小书。同时，您可以在 [Oracle](https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/time/package-summary.html)
    学习 API 的详细信息。
- en: ^([1](ch06.html#idm45290675934040-marker)) For those with an interest in historical
    arcana, the differences are documented on his [blog](http://blog.joda.org/2009/11/why-jsr-310-isn-joda-time_4941.html).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch06.html#idm45290675934040-marker)) 对于那些对历史奥秘感兴趣的人来说，这些差异在他的[博客](http://blog.joda.org/2009/11/why-jsr-310-isn-joda-time_4941.html)上有详细记录。
