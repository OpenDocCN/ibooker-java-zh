- en: Chapter 2\. Java Syntax from the Ground Up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is fairly dense but should provide a comprehensive introduction
    to Java syntax. It is written primarily for readers who are new to the language
    but have some previous programming experience. Determined novices with no prior
    programming experience may also find it useful. If you already know Java, you
    should find it a useful language reference. The chapter includes some comparisons
    of Java to JavaScript, C, and C++ for the benefit of programmers coming from those
    languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter documents the syntax of Java programs by starting at the very
    lowest level of Java syntax and building from there, moving on to increasingly
    higher orders of structure. It covers:'
  prefs: []
  type: TYPE_NORMAL
- en: The characters used to write Java programs and the encoding of those characters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Literal values, identifiers, and other tokens that comprise a Java program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data types that Java can manipulate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The operators used in Java to group individual tokens into larger expressions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Statements, which group expressions and other statements to form logical chunks
    of Java code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods, which are named collections of Java statements that can be invoked
    by other Java code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes, which are collections of methods and fields. Classes are the central
    program element in Java and form the basis for object-oriented programming. [Chapter 3](ch03.xhtml#javanut8-CHP-3)
    is devoted entirely to a discussion of classes and objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packages, which are collections of related classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java programs, which consist of one or more interacting classes that may be
    drawn from one or more packages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The syntax of most programming languages is complex, and Java is no exception.
    In general, it is not possible to document all elements of a language without
    referring to other elements that have not yet been discussed. For example, it
    is not really possible to explain in a meaningful way the operators and statements
    supported by Java without referring to objects. But it is also not possible to
    document objects thoroughly without referring to the operators and statements
    of the language. The process of learning Java, or any language, is therefore an
    iterative one.
  prefs: []
  type: TYPE_NORMAL
- en: Java Programs from the Top Down
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we begin our bottom-up exploration of Java syntax, let’s take a moment
    for a top-down overview of a Java program. Java programs consist of one or more
    files, or *compilation units*, of Java source code. Near the end of the chapter,
    we describe the structure of a Java file and explain how to compile and run a
    Java program. Each compilation unit begins with an optional `package` declaration
    followed by zero or more `import` declarations. These declarations specify the
    namespace within which the compilation unit will define names and the namespaces
    from which the compilation unit imports names. We’ll see `package` and `import`
    again later in this chapter in [“Packages and the Java Namespace”](#javanut8-CHP-2-SECT-10).
  prefs: []
  type: TYPE_NORMAL
- en: The optional `package` and `import` declarations are followed by zero or more
    reference type definitions. We will meet the full variety of possible reference
    types in Chapters [3](ch03.xhtml#javanut8-CHP-3) and [4](ch04.xhtml#javanut8-CHP-4),
    but for now, we should note that these are most often either `class` or `interface`
    definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Within the definition of a reference type, we will encounter *members* such
    as *fields*, *methods*, and *constructors*. Methods are the most important kind
    of member. Methods are blocks of Java code composed of *statements*.
  prefs: []
  type: TYPE_NORMAL
- en: With these basic terms defined, let’s start by approaching a Java program from
    the bottom up by examining the basic units of syntax—often referred to as *lexical
    tokens*.
  prefs: []
  type: TYPE_NORMAL
- en: Lexical Structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section explains the lexical structure of a Java program. It starts with
    a discussion of the Unicode character set in which Java programs are written.
    It then covers the tokens that comprise a Java program, explaining comments, identifiers,
    reserved words, literals, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The Unicode Character Set
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Java programs are written using Unicode. You can use Unicode characters anywhere
    in a Java program, including comments and identifiers such as variable names.
    Unlike the 7-bit ASCII character set, which is useful only for English, and the
    8-bit ISO Latin-1 character set, which is useful only for major Western European
    languages, the Unicode character set can represent virtually every written language
    in common use on the planet.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you do not use a Unicode-enabled text editor, or if you do not want to force
    other programmers who view or edit your code to use a Unicode-enabled editor,
    you can embed Unicode characters into your Java programs using the special Unicode
    escape sequence `\u*xxxx*`—that is, a backslash and a lowercase u, followed by
    four hexadecimal characters. For example, `\u0020` is the space character, and
    `\u03c0` is the character π.
  prefs: []
  type: TYPE_NORMAL
- en: Java has invested a large amount of time and engineering effort in ensuring
    that its Unicode support is first class. If your business application needs to
    deal with global users, especially in non-Western markets, then the Java platform
    is a great choice. Java also has support for multiple encodings and character
    sets, in case applications need to interact with non-Java applications that do
    not speak Unicode.
  prefs: []
  type: TYPE_NORMAL
- en: Case Sensitivity and Whitespace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Java is a case-sensitive language. Its keywords are written in lowercase and
    must always be used that way. That is, `While` and `WHILE` are not the same as
    the `while` keyword. Similarly, if you declare a variable named `i` in your program,
    you may not refer to it as `I`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In general, relying on case sensitivity to distinguish identifiers is a terrible
    idea. The more similar identifiers there are, the more difficult the code is to
    read and understand. Do not use it in your own code, and in particular never give
    an identifier the same name as a keyword but differently cased.
  prefs: []
  type: TYPE_NORMAL
- en: Java ignores spaces, tabs, newlines, and other whitespace, except when they
    appear within quoted characters and string literals. Programmers typically use
    whitespace to format and indent their code for easy readability, but it has no
    influence on the program’s behavior as indents do in Python. You will see common
    indentation conventions in this book’s code examples.
  prefs: []
  type: TYPE_NORMAL
- en: Comments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Comments are natural-language text intended for human readers of a program.
    They are ignored by the Java compiler. Java supports three types of comments.
    The first type is a single-line comment, which begins with the characters `//`
    and continues until the end of the current line. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The second kind of comment is a multiline comment. It begins with the characters
    `/*` and continues, over any number of lines, until the characters `*/`. Any text
    between the `/*` and the `*/` is ignored by `javac`. Although this style of comment
    is typically used for multiline comments, it also can be used for single-line
    comments. This type of comment cannot be nested (i.e., one `/* */` comment cannot
    appear within another). When writing multiline comments, programmers often use
    extra `*` characters to make the comments stand out. Here is a typical multiline
    comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The third type of comment is a special case of the second. If a comment begins
    with `/**`, it is regarded as a special *doc comment*. Like regular multiline
    comments, doc comments end with `*/` and cannot be nested. When you write a Java
    class you expect other programmers to use, provide doc comments to embed documentation
    about the class and each of its methods directly into the source code. A program
    named `javadoc` extracts these comments and processes them to create online documentation
    for your class. A doc comment can contain HTML tags and can use additional syntax
    understood by `javadoc`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: See [Chapter 7](ch07.xhtml#javanut8-CHP-7) for more information on the doc comment
    syntax and [Chapter 13](ch13.xhtml#javanut8-CHP-13) for more information on the
    `javadoc` program.
  prefs: []
  type: TYPE_NORMAL
- en: Comments may appear between any tokens of a Java program but may not appear
    within a token. In particular, comments may not appear within double-quoted string
    literals. A comment within a string literal simply becomes a literal part of that
    string.
  prefs: []
  type: TYPE_NORMAL
- en: Reserved Words
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following words are reserved in Java (they are part of the syntax of the
    language and may not be used to name variables, classes, and so forth):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Of these, `true`, `false,` and `null` are technically literals.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `const` and `goto` are reserved but aren’t actually used in the language
    and that `interface` has an additional variant form—`@interface`, which is used
    when defining types known as annotations. Some of the reserved words (notably
    `final` and `default`) have a variety of meanings depending on context.
  prefs: []
  type: TYPE_NORMAL
- en: Other keywords exist that are not reserved in general and are known as *contextual
    keywords*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`var` indicates a local variable that should be type-inferred. `sealed`, `non-sealed`,
    and `record` are used when defining classes, which we’ll meet in [Chapter 3](ch03.xhtml#javanut8-CHP-3).
    `yield` appears within `switch` expressions we’ll meet later in this chapter,
    while the remaining contextual keywords deal with modules, the syntax and use
    of which are covered in [Chapter 12](ch12.xhtml#javanut8-CHP-12).'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Using contextual keywords as variable names, while allowed for compatibility,
    is discouraged. `var var = "var";` may be a valid statement, but it is a valid
    statement that ought to be viewed with suspicion.
  prefs: []
  type: TYPE_NORMAL
- en: Identifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An *identifier* is simply a name given to some part of a Java program, such
    as a class, a method within a class, or a variable declared within a method. Identifiers
    may be of any length and may contain letters and digits drawn from the entire
    Unicode character set. An identifier may not begin with a digit.
  prefs: []
  type: TYPE_NORMAL
- en: In general, identifiers may not contain punctuation characters. Exceptions include
    the dollar sign (`$`) as well as other Unicode currency symbols such as `£` and
    `¥`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Currency symbols are intended for use in automatically generated source code,
    such as code produced by `javac`. By avoiding the use of currency symbols in your
    own identifiers, you don’t have to worry about collisions with automatically generated
    identifiers.
  prefs: []
  type: TYPE_NORMAL
- en: The ASCII underscore (`_`) also deserves special mention. Originally, the underscore
    could be freely used as an identifier or part of one. However, in recent versions
    of Java, including Java 17, the underscore may not be used as an identifier.
  prefs: []
  type: TYPE_NORMAL
- en: The underscore character can still appear in a Java identifier, but it is no
    longer legal as a complete identifier by itself. This is to support an expected
    forthcoming language feature whereby the underscore will acquire a special new
    syntactic meaning.
  prefs: []
  type: TYPE_NORMAL
- en: The usual Java convention is to name variables using *camel case*. This means
    that the first letter of a variable should be lowercase but that the first letter
    of any other words in the identifier should be uppercase.
  prefs: []
  type: TYPE_NORMAL
- en: Formally, the characters allowed at the beginning of and within an identifier
    are defined by the methods `isJavaIdentifierStart()` and `isJavaIdentifierPart()`
    of the class `java.lang.Character`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are examples of legal identifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note in particular the example of a UTF-8 identifier, `獺`. This is the Kanji
    character for “otter” and is perfectly legal as a Java identifier. The use of
    non-ASCII identifiers is unusual in programs predominantly written by Westerners,
    but it is sometimes seen.
  prefs: []
  type: TYPE_NORMAL
- en: Literals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Literals are sequences of source characters that directly represent constant
    values that appear as is in Java source code. They include integer and floating-point
    numbers, single characters within single quotes, strings of characters within
    double quotes, and the reserved words `true`, `false`, and `null`. For example,
    the following are all literals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The syntax for expressing numeric, character, and string literals is detailed
    in [“Primitive Data Types”](#javanut8-CHP-2-SECT-3).
  prefs: []
  type: TYPE_NORMAL
- en: Punctuation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Java also uses a number of punctuation characters as tokens. The Java Language
    Specification divides these characters (somewhat arbitrarily) into two categories,
    separators and operators. The 12 separators are:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `( )` | `{ }` | `[ ]` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `...` | `@` | `::` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `;` | `,` | `.` |  |'
  prefs: []
  type: TYPE_TB
- en: 'The operators are:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `+` | `—` | `*` | `/` | `%` | `&` | `&#124;` | `^` | `<<` | `>>` | `>>>`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `+=` | `-=` | `*=` | `/=` | `%=` | `&=` | `&#124;=` | `^=` | `<<=` | `>>=`
    | `>>>=` |'
  prefs: []
  type: TYPE_TB
- en: '| `=` | `==` | `!=` | `<` | `<=` | `>` | `>=` |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| `!` | `~` | `&&` | &#124;&#124; | `++` | `--` | `?` | `:` | `->` |  |  |'
  prefs: []
  type: TYPE_TB
- en: We’ll see separators throughout the book and will cover each operator individually
    in [“Expressions and Operators”](#javanut8-CHP-2-SECT-4).
  prefs: []
  type: TYPE_NORMAL
- en: Primitive Data Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java supports eight basic data types known as *primitive types* as described
    in [Table 2-1](#javanut8-CHP-2-TABLE-1). The primitive types include a boolean
    type, a character type, four integer types, and two floating-point types. The
    four integer types and the two floating-point types differ in the number of bits
    that represent them and therefore in the range of numbers they can represent.
    Note that the size of these types is the notional size in the Java language. Different
    JVM implementations may use more actual space to hold these values due to padding,
    alignment, and the like.
  prefs: []
  type: TYPE_NORMAL
- en: Table 2-1\. Java primitive data types
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Contains | Default | Size | Range |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `boolean` | `true` or `false` | `false` | 1 bit | NA |'
  prefs: []
  type: TYPE_TB
- en: '| `char` | Unicode character | `\u0000` | 16 bits | `\u0000` to `\uFFFF` |'
  prefs: []
  type: TYPE_TB
- en: '| `byte` | Signed integer | 0 | 8 bits | –128 to 127 |'
  prefs: []
  type: TYPE_TB
- en: '| `short` | Signed integer | 0 | 16 bits | –32768 to 32767 |'
  prefs: []
  type: TYPE_TB
- en: '| `int` | Signed integer | 0 | 32 bits | –2147483648 to 2147483647 |'
  prefs: []
  type: TYPE_TB
- en: '| `long` | Signed integer | 0 | 64 bits | –9223372036854775808 to 9223372036854775807
    |'
  prefs: []
  type: TYPE_TB
- en: '| `float` | IEEE 754 floating point | 0.0 | 32 bits | 1.4E–45 to 3.4028235E+38
    |'
  prefs: []
  type: TYPE_TB
- en: '| `double` | IEEE 754 floating point | 0.0 | 64 bits | 4.9E–324 to 1.7976931348623157E+308
    |'
  prefs: []
  type: TYPE_TB
- en: The next section summarizes these primitive data types. In addition to these
    primitive types, Java supports nonprimitive data types known as reference types,
    which are introduced in [“Reference Types”](#javanut8-CHP-2-SECT-9).
  prefs: []
  type: TYPE_NORMAL
- en: The boolean Type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `boolean` type represents truth values. This type has only two possible
    values, representing the two Boolean states: on or off, yes or no, true or false.
    Java reserves the words `true` and `false` to represent these two Boolean values.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Programmers coming to Java from other languages (especially JavaScript, Python,
    or C) should note that Java is much stricter about its Boolean values than other
    languages; in particular, a `boolean` is neither an integral nor an object type,
    and incompatible values cannot be used in place of a `boolean`. In other words,
    you cannot take shortcuts such as the following in Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, Java forces you to write cleaner code by explicitly stating the comparisons
    you want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The char Type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `char` type represents Unicode characters. Java has a slightly unique approach
    to representing characters—`javac` accepts identifiers and literals as UTF-8 (a
    variable-width encoding) in input. However, internally, Java represents chars
    in a fixed-width encoding—​either a 16-bit encoding (before Java 9) or as ISO-8859-1
    (an 8-bit encoding, used for Western European languages, also called Latin-1)
    if possible (Java 9 and later).
  prefs: []
  type: TYPE_NORMAL
- en: 'This distinction between external and internal representation does not normally
    need to concern the developer. In most cases, all that is required is to remember
    the rule that to include a character literal in a Java program, simply place it
    between single quotes (apostrophes):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You can, of course, use Unicode characters as character literals with the `\u`
    Unicode escape sequence. In addition, Java supports a number of other escape sequences
    that make it easy both to represent commonly used nonprinting ASCII characters,
    such as `newline,` and to escape certain punctuation characters that have special
    meaning in Java. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[Table 2-2](#javanut8-CHP-2-TABLE-2) lists the escape characters that can be
    used in `char` literals. These characters can also be used in string literals,
    which are covered in the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 2-2\. Java escape characters
  prefs: []
  type: TYPE_NORMAL
- en: '| Escape sequence | Character value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `\b` | Backspace |'
  prefs: []
  type: TYPE_TB
- en: '| `\t` | Horizontal tab |'
  prefs: []
  type: TYPE_TB
- en: '| `\n` | Newline |'
  prefs: []
  type: TYPE_TB
- en: '| `\f` | Form feed |'
  prefs: []
  type: TYPE_TB
- en: '| `\r` | Carriage return |'
  prefs: []
  type: TYPE_TB
- en: '| `\`" | Double quote |'
  prefs: []
  type: TYPE_TB
- en: '| `\`'' | Single quote |'
  prefs: []
  type: TYPE_TB
- en: '| `\\` | Backslash |'
  prefs: []
  type: TYPE_TB
- en: '| `\*xxx*` | The Latin-1 character with the encoding *`xxx`*, where *`xxx`*
    is an octal (base 8) number between 000 and 377. The forms *`\x`* and *`\xx`*
    are also legal, as in *`\0`*, but are not recommended because they can cause difficulties
    in string constants where the escape sequence is followed by a regular digit.
    This form is generally discouraged in favor of the `\uXXXX` form. |'
  prefs: []
  type: TYPE_TB
- en: '| `\u*xxxx*` | The Unicode character with encoding *`xxxx`*, where *`xxxx`*
    is four hexadecimal digits. Unicode escapes can appear anywhere in a Java program,
    not only in character and string literals. |'
  prefs: []
  type: TYPE_TB
- en: '`char` values can be converted to and from the various integral types, and
    the `char` data type is a 16-bit integral type. Unlike `byte`, `short`, `int`,
    and `long`, however, `char` is an unsigned type and may receive values only in
    the range 0 to 65535. The `Character` class defines a number of useful `static`
    methods for working with characters, including `isDigit()`, `isJavaLetter()`,
    `isLowerCase()`, and `toUpperCase()`.'
  prefs: []
  type: TYPE_NORMAL
- en: The Java language and its `char` type were designed with Unicode in mind. The
    Unicode standard is evolving, however, and each new version of Java adopts a new
    version of Unicode. Java 11 uses Unicode 10.0.0 and Java 17 uses Unicode 13.0.
  prefs: []
  type: TYPE_NORMAL
- en: A complication in recent Unicode releases is the introduction of characters
    whose encodings, or *codepoints*, do not fit in 16 bits. These supplementary characters,
    which are mostly infrequently used Han (Chinese) ideographs, occupy 21 bits and
    cannot be represented in a single `char` value. Instead, you must use an `int`
    value to hold the codepoint of a supplementary character, or you must encode it
    into a so-called “surrogate pair” of two `char` values.
  prefs: []
  type: TYPE_NORMAL
- en: Unless you commonly write programs that use Asian languages, you are unlikely
    to encounter any supplementary characters. If you do anticipate having to process
    characters that do not fit into a `char`, methods have been added to the `Character`,
    `String`, and related classes for working with text using `int` codepoints.
  prefs: []
  type: TYPE_NORMAL
- en: String literals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In addition to the `char` type, Java also has a data type for working with
    strings of text (usually simply called *strings*). The `String` type is a class,
    however, and is not one of the primitive types of the language. Because strings
    are so commonly used, though, Java does have syntax for including string values
    literally in a program. A `String` literal consists of arbitrary text within double
    quotes (as opposed to the single quotes for `char` literals). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Recent versions of Java also introduced a multiline string literal syntax called
    *text blocks*. A text block begins with a `"""` and a newline and ends when another
    sequence of `"""` is seen. These are handled entirely by the `javac` compiler
    and result in identical string literals to normal `"` strings in bytecode.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: String literals can contain any of the escape sequences that can appear as `char`
    literals (see [Table 2-2](#javanut8-CHP-2-TABLE-2)). Use the `\`" sequence to
    include a double quote within a standard `String` literal. Text blocks allow such
    escape sequences but do not require them for newlines or double quotes.
  prefs: []
  type: TYPE_NORMAL
- en: Because `String` is a reference type, string literals are described in more
    detail later in this chapter in [“String literals”](#javanut8-CHP-2-SECT-7.5).
    [Chapter 9](ch09.xhtml#javanut8-CHP-9) contains more details on some of the ways
    you can work with `String` objects in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Integer Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The integer types in Java are `byte`, `short`, `int`, and `long`. As shown in
    [Table 2-1](#javanut8-CHP-2-TABLE-1), these four types differ only in the number
    of bits and, therefore, in the range of numbers each type can represent. All integral
    types represent signed numbers; there is no `unsigned` keyword as there is in
    C and C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'Literals for each of these types are written exactly as you would expect: as
    a sequence of decimal digits, optionally preceded by a minus sign.^([1](ch02.xhtml#idm45927772106240))
    Digits in any of these literals may be separated by an underscore (`_`) for better
    readability. Here are some legal integer literals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Integer literals are 32-bit values (and so are taken to be the Java type `int`)
    unless they end with the character `L` or `l`, in which case they are 64-bit values
    (and are understood to be the Java type `long`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Integer literals can also be expressed in hexadecimal, binary, or octal notation.
    A literal that begins with `0x` or `0X` is taken as a hexadecimal number, using
    the letters `A` to `F` (or `a` to `f`) as the additional digits required for base-16
    numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Integer binary literals start with `0b` and may, of course, feature only the
    digits 1 or 0\. Use of the underscore separator in binary literals is very common,
    as binary literals can be very long.
  prefs: []
  type: TYPE_NORMAL
- en: 'Java also supports octal (base-8) integer literals. These literals begin with
    a leading `0` and cannot include the digits 8 or 9\. They are not often used and
    should be avoided unless needed. Legal hexadecimal, binary, and octal literals
    include:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Integer arithmetic in Java never produces an overflow or an underflow when
    you exceed the range of a given integer type. Instead, numbers just wrap around.
    For example, let’s look at an overflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'and the corresponding underflow behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Neither the Java compiler nor the Java interpreter warns you in any way when
    this occurs. When doing integer arithmetic, you simply must ensure that the type
    you are using has a sufficient range for the purposes you intend. Integer division
    by zero and modulo by zero are illegal and cause an `ArithmeticException` to be
    thrown. (We’ll see more about exceptions soon in [“Checked and Unchecked Exceptions”](#javanut8-CHP-2-SECT-6.3)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Each integer type has a corresponding wrapper class: `Byte`, `Short`, `Integer`,
    and `Long`. Each of these classes defines `MIN_VALUE` and `MAX_VALUE` constants
    that describe the range of the type. Each class also provides a static `valueOf()`
    method that is strongly preferred for creating an instance of the wrapper class
    from a primitive value. While the wrapper classes have plain constructors that
    take the primitives, they are deprecated and should be avoided. The wrapper classes
    also define useful static methods, such as `Byte.parseByte()` and `Integer.parseInt()`,
    for converting strings to integer values.'
  prefs: []
  type: TYPE_NORMAL
- en: Floating-Point Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Real numbers in Java are represented by the `float` and `double` data types.
    As shown in [Table 2-1](#javanut8-CHP-2-TABLE-1), `float` is a 32-bit, single-precision,
    floating-point value, and `double` is a 64-bit, double-precision, floating-point
    value. Both types adhere to the IEEE 754-1985 standard, which specifies both the
    format of the numbers and the behavior of arithmetic for the numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Floating-point values can be included literally in a Java program as an optional
    string of digits, followed by a decimal point and another string of digits. Here
    are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Floating-point literals can also use exponential, or scientific, notation,
    in which a number is followed by the letter `e` or `E` (for exponent) and another
    number. This second number represents the power of 10 by which the first number
    is multiplied. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Floating-point literals are `double` values by default. To include a `float`
    value literally in a program, follow the number with `f` or `F`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Floating-point literals cannot be expressed in hexadecimal, binary, or octal
    notation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to representing ordinary numbers, the `float` and `double` types
    can also represent four special values: positive and negative infinity, zero,
    and NaN. The infinity values result when a floating-point computation produces
    a value that overflows the representable range of a `float` or `double`.'
  prefs: []
  type: TYPE_NORMAL
- en: When a floating-point computation underflows the representable range of a `float`
    or a `double`, a zero value results.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We can imagine repeatedly dividing the double value `1.0` by `2.0` (e.g., in
    a `while` loop). In mathematics, no matter how often we perform the division,
    the result will never become equal to zero. However, in a floating-point representation,
    after enough divisions, the result will eventually be so small as to be indistinguishable
    from zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Java floating-point types make a distinction between positive zero and
    negative zero, depending on the direction from which the underflow occurred. In
    practice, positive and negative zero behave pretty much the same. Finally, the
    last special floating-point value is NaN, which stands for “Not a Number.” The
    NaN value results when an illegal floating-point operation, such as 0.0/0.0, is
    performed. Here are examples of statements that result in these special values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `float` and `double` primitive types have corresponding classes, named
    `Float` and `Double`. Each of these classes defines the following useful constants:
    `MIN_VALUE`, `MAX_VALUE`, `NEGATIVE_INFINITY`, `POSITIVE_INFINITY`, and `NaN`.
    Much like the integer wrapper classes, the floating-point wrappers also have a
    static `valueOf()` for constructing instances.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Java floating-point types can handle overflow to infinity and underflow to zero
    and have a special NaN value. This means floating-point arithmetic never throws
    exceptions, even when performing illegal operations, like dividing zero by zero
    or taking the square root of a negative number.
  prefs: []
  type: TYPE_NORMAL
- en: 'The infinite floating-point values behave as you would expect. Adding or subtracting
    any finite value to or from infinity, for example, yields infinity. Negative zero
    behaves almost identically to positive zero, and, in fact, the `==` equality operator
    reports that negative zero is equal to positive zero. One way to distinguish negative
    zero from positive, or regular, zero is to divide by it: `1.0/0.0` yields positive
    infinity, but `1.0` divided by negative zero yields negative infinity. Finally,
    because NaN is Not a Number, the `==` operator says that it is not equal to any
    other number, including itself!'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: To check whether a `float` or `double` value is NaN, you must use the `Float.isNaN()`
    and `Double.isNaN()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Primitive Type Conversions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Java allows conversions between integer values and floating-point values. In
    addition, because every character corresponds to a number in the Unicode encoding,
    `char` values can be converted to and from the integer and floating-point types.
    In fact, `boolean` is the only primitive type that cannot be converted to or from
    another primitive type in Java.
  prefs: []
  type: TYPE_NORMAL
- en: There are two basic types of conversions. A *widening conversion* occurs when
    a value of one type is converted to a wider type—one that has a larger range of
    legal values. For example, Java performs widening conversions automatically when
    you assign an `int` literal to a `double` variable or a `char` literal to an `int`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Narrowing conversions are another matter, however. A *narrowing conversion*
    occurs when a value is converted to a type that is not wider than it is. Narrowing
    conversions are not always safe: it is reasonable to convert the integer value
    13 to a `byte`, for example, but it is not reasonable to convert 13,000 to a `byte`,
    because `byte` can hold only numbers between –128 and 127\. Because you can lose
    data in a narrowing conversion, `javac` complains when you attempt any narrowing
    conversion, even if the value being converted would in fact fit in the narrower
    range of the specified type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The one exception to this rule is that you can assign an integer literal (an
    `int` value) to a `byte` or `short` variable if the literal falls within the range
    of the variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need to perform a narrowing conversion and are confident you can do
    so without losing data or precision, you can force Java to perform the conversion
    using a language construct known as a *cast*. Perform a cast by placing the name
    of the desired type in parentheses before the value to be converted. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Casts of primitive types are most often used to convert floating-point values
    to integers. When you do this, the fractional part of the floating-point value
    is simply truncated (i.e., the floating-point value is rounded toward zero, not
    toward the nearest integer). The static methods `Math.round()`, `Math.floor()`,
    and `Math.ceil()` perform other types of rounding.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `char` type acts like an integer type in most ways, so a `char` value can
    be used anywhere an `int` or `long` value is required. Recall, however, that the
    `char` type is *unsigned*, so it behaves differently than the `short` type, even
    though both are 16 bits wide:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[Table 2-3](#javanut8-CHP-2-TABLE-3) shows which primitive types can be converted
    to which other types and how the conversion is performed. The letter N in the
    table means that the conversion cannot be performed. The letter Y means that the
    conversion is a widening conversion and is therefore performed automatically and
    implicitly by Java. The letter C means that the conversion is a narrowing conversion
    and requires an explicit cast.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the notation Y* means that the conversion is an automatic widening
    conversion, but some of the least significant digits of the value may be lost
    in the conversion. This can happen when you are converting an `int` or `long`
    to a floating-point type—see the table for details. The floating-point types have
    a larger range than the integer types, so any `int` or `long` can be represented
    by a `float` or `double`. However, the floating-point types are approximations
    of numbers and cannot always hold as many significant digits as the integer types
    (see [Chapter 9](ch09.xhtml#javanut8-CHP-9) for some more detail about floating-point
    numbers).
  prefs: []
  type: TYPE_NORMAL
- en: Table 2-3\. Java primitive type conversions
  prefs: []
  type: TYPE_NORMAL
- en: '|   | Convert to: |   |   |   |   |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Convert from: | `boolean` | `byte` | `short` | `char` | `int` | `long` |
    `float` | `double` |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `boolean` | - | N | N | N | N | N | N | N |'
  prefs: []
  type: TYPE_TB
- en: '| `byte` | N | - | Y | C | Y | Y | Y | Y |'
  prefs: []
  type: TYPE_TB
- en: '| `short` | N | C | - | C | Y | Y | Y | Y |'
  prefs: []
  type: TYPE_TB
- en: '| `char` | N | C | C | - | Y | Y | Y | Y |'
  prefs: []
  type: TYPE_TB
- en: '| `int` | N | C | C | C | - | Y | Y* | Y |'
  prefs: []
  type: TYPE_TB
- en: '| `long` | N | C | C | C | C | - | Y* | Y* |'
  prefs: []
  type: TYPE_TB
- en: '| `float` | N | C | C | C | C | C | - | Y |'
  prefs: []
  type: TYPE_TB
- en: '| `double` | N | C | C | C | C | C | C | - |'
  prefs: []
  type: TYPE_TB
- en: Expressions and Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this chapter, we’ve learned about the primitive types that Java programs
    can manipulate and seen how to include primitive values as *literals* in a Java
    program. We’ve also used *variables* as symbolic names that represent, or hold,
    values. These literals and variables are the tokens out of which Java programs
    are built.
  prefs: []
  type: TYPE_NORMAL
- en: 'An *expression* is the next higher level of structure in a Java program. The
    Java interpreter *evaluates* an expression to compute its value. The very simplest
    expressions are called *primary expressions* and consist of literals and variables.
    So, for example, the following are all expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: When the Java interpreter evaluates a literal expression, the resulting value
    is the literal itself. When the interpreter evaluates a variable expression, the
    resulting value is the value stored in the variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Primary expressions are not very interesting. More complex expressions are
    made by using *operators* to combine primary expressions. For example, the following
    expression uses the assignment operator to combine two primary expressions—a variable
    and a floating-point literal—into an assignment expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'But operators are used not just with primary expressions; they also can be
    used with expressions at any level of complexity. The following are all legal
    expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Operator Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The kinds of expressions you can write in a programming language depend entirely
    on the set of operators available to you. Java has a wealth of operators, but
    to work effectively with them, you must understand two important concepts: *precedence*
    and *associativity*. These concepts—and the operators themselves—are explained
    in more detail in the following sections.'
  prefs: []
  type: TYPE_NORMAL
- en: Precedence
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The P column of [Table 2-4](#javanut8-CHP-2-TABLE-4) specifies the *precedence*
    of each operator. Precedence specifies the order in which operations are performed.
    Operations that have higher precedence are performed before those with lower precedence.
    For example, consider this expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The multiplication operator has higher precedence than the addition operator,
    so `a` is added to the product of `b` and `c`, just as we expect from elementary
    mathematics. Operator precedence can be thought of as a measure of how tightly
    operators bind to their operands. The higher the number, the more tightly they
    bind.
  prefs: []
  type: TYPE_NORMAL
- en: 'Default operator precedence can be overridden through the use of parentheses
    that explicitly specify the order of operations. The previous expression can be
    rewritten to specify that the addition should be performed before the multiplication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The default operator precedence in Java was chosen for compatibility with C;
    the designers of C chose this precedence so that most expressions can be written
    naturally without parentheses. Only a few common Java idioms require parentheses.
    Examples include:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Associativity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Associativity is a property of operators that defines how to evaluate expressions
    that would otherwise be ambiguous. This is particularly important when an expression
    involves several operators that have the same precedence.
  prefs: []
  type: TYPE_NORMAL
- en: Most operators are left-to-right associative, which means that the operations
    are performed from left to right. The assignment and unary operators, however,
    have right-to-left associativity. The A column of [Table 2-4](#javanut8-CHP-2-TABLE-4)
    specifies the associativity of each operator or group of operators. The value
    L means left to right, and R means right to left.
  prefs: []
  type: TYPE_NORMAL
- en: 'The additive operators are all left-to-right associative, so the expression
    `a+b-c` is evaluated from left to right: `(a+b)-c`. Unary operators and assignment
    operators are evaluated from right to left. Consider this complex expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This is evaluated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As with operator precedence, operator associativity establishes a default order
    of evaluation for an expression. This default order can be overridden through
    the use of parentheses. However, the default operator associativity in Java has
    been chosen to yield a natural expression syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Operator summary table
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Table 2-4](#javanut8-CHP-2-TABLE-4) summarizes the operators available in
    Java. The P and A columns of the table specify the precedence and associativity
    of each group of related operators, respectively. The table is ordered from highest
    precedence to lowest. Use this table as a quick reference for operators (especially
    their precedence) when required.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 2-4\. Java operators
  prefs: []
  type: TYPE_NORMAL
- en: '| P | A | Operator | Operand type(s) | Operation performed |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 16 | L | . | object, member | Object member access |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | `[ ]` | array, int | Array element access |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | `( *args* )` | method, arglist | Method invocation |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | `++`, `--` | variable | Post-increment, post-decrement |'
  prefs: []
  type: TYPE_TB
- en: '| 15 | R | `++`, `--` | variable | Pre-increment, pre-decrement |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | `+`, `-` | number | Unary plus, unary minus |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | `~` | integer | Bitwise complement |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | `!` | boolean | Boolean NOT |'
  prefs: []
  type: TYPE_TB
- en: '| 14 | R | `new` | class, arglist | Object creation |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | `( *type* )` | type, any | Cast (type conversion) |'
  prefs: []
  type: TYPE_TB
- en: '| 13 | L | `*`, `/`, `%` | number, number | Multiplication, division, remainder
    |'
  prefs: []
  type: TYPE_TB
- en: '| 12 | L | `+`, `-` | number, number | Addition, subtraction |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | `+` | string, any | String concatenation |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | L | `<<` | integer, integer | Left shift |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | `>>` | integer, integer | Right shift with sign extension |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | `>>>` | integer, integer | Right shift with zero extension |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | L | `<`, `<=` | number, number | Less than, less than or equal |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | `>`, `>=` | number, number | Greater than, greater than or equal |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | `instanceof` | reference, type | Type comparison |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | L | `==` | primitive, primitive | Equal (have identical values) |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | `!=` | primitive, primitive | Not equal (have different values) |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | `==` | reference, reference | Equal (refer to same object) |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | `!=` | reference, reference | Not equal (refer to different objects)
    |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | L | `&` | integer, integer | Bitwise AND |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | `&` | boolean, boolean | Boolean AND |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | L | `^` | integer, integer | Bitwise XOR |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | `^` | boolean, boolean | Boolean XOR |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | L | `ǀ` | integer, integer | Bitwise OR |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | `ǀ` | boolean, boolean | Boolean OR |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | L | `&&` | boolean, boolean | Conditional AND |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | L | `ǀǀ` | boolean, boolean | Conditional OR |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | R | `? :` | boolean, any | Conditional (ternary) operator |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | R | `=` | variable, any | Assignment |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | `*=`, `/=`, `%=`, | variable, any | Assignment with operation |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | `+=`, `-=`, `<<=`, |  |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | `>>=`, `>>>=`, |  |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | `&=`, `^=`, `ǀ=` |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | R | `→` | arglist, method body | lambda expression |'
  prefs: []
  type: TYPE_TB
- en: Operand number and type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The fourth column of [Table 2-4](#javanut8-CHP-2-TABLE-4) specifies the number
    and type of the operands expected by each operator. Some operators operate on
    only one operand; these are called unary operators. For example, the unary minus
    operator changes the sign of a single number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Most operators, however, are binary operators that operate on two operand values.
    The `–` operator actually comes in both forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Java also defines one ternary operator, often called the conditional operator.
    It is like an `if` statement inside an expression. Its three operands are separated
    by a question mark and a colon; the second and third operands must be convertible
    to the same type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to expecting a certain number of operands, each operator also expects
    particular types of operands. The fourth column of the table lists the operand
    types. Some of the codes used in that column require further explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: Number
  prefs: []
  type: TYPE_NORMAL
- en: An integer, floating-point value, or character (i.e., any primitive type except
    `boolean`). Auto-unboxing (see [“Boxing and Unboxing Conversions”](#javanut8-CHP-2-SECT-9.4))
    means that the wrapper classes (such as `Character`, `Integer`, and `Double`)
    for these types can be used in this context as well.
  prefs: []
  type: TYPE_NORMAL
- en: Integer
  prefs: []
  type: TYPE_NORMAL
- en: A `byte`, `short`, `int`, `long`, or `char` value (`long` values are not allowed
    for the array access operator `[ ]`). With auto-unboxing, `Byte`, `Short`, `Integer`,
    `Long`, and `Character` values are also allowed.
  prefs: []
  type: TYPE_NORMAL
- en: Reference
  prefs: []
  type: TYPE_NORMAL
- en: An object or array.
  prefs: []
  type: TYPE_NORMAL
- en: Variable
  prefs: []
  type: TYPE_NORMAL
- en: A variable or anything else, such as an array element, to which a value can
    be assigned.
  prefs: []
  type: TYPE_NORMAL
- en: Return type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just as every operator expects its operands to be of specific types, each operator
    produces a value of a specific type. The arithmetic, increment and decrement,
    bitwise, and shift operators return a `double` if at least one of the operands
    is a `double`. They return a `float` if at least one of the operands is a `float`.
    They return a `long` if at least one of the operands is a `long`. Otherwise, they
    return an `int`, even if both operands are `byte`, `short`, or `char` types that
    are narrower than `int`.
  prefs: []
  type: TYPE_NORMAL
- en: The comparison, equality, and Boolean operators always return `boolean` values.
    Each assignment operator returns whatever value it assigned, which is of a type
    compatible with the variable on the left side of the expression. The conditional
    operator returns the value of its second or third argument (which must both be
    convertible to the same type).
  prefs: []
  type: TYPE_NORMAL
- en: Side effects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every operator computes a value based on one or more operand values. Some operators,
    however, have *side effects* in addition to their basic evaluation. If an expression
    contains side effects, evaluating it changes the state of a Java program in such
    a way that evaluating the expression again may yield a different result.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the `++` increment operator has the side effect of incrementing
    a variable. The expression `++a` increments the variable `a` and returns the newly
    incremented value. If this expression is evaluated again, the value will be different.
    The various assignment operators also have side effects. For example, the expression
    `a*=2` can also be written as `a=a*2`. The value of the expression is the value
    of `a` multiplied by 2, but the expression has the side effect of storing that
    value back into `a`.
  prefs: []
  type: TYPE_NORMAL
- en: The method invocation operator `()` has side effects if the invoked method has
    side effects. Some methods, such as `Math.sqrt()`, simply compute and return a
    value without side effects of any kind. Typically, however, methods do have side
    effects. Finally, the `new` operator has the profound side effect of creating
    a new object.
  prefs: []
  type: TYPE_NORMAL
- en: Order of evaluation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When the Java interpreter evaluates an expression, it performs the various
    operations in an order specified by the parentheses in the expression, the precedence
    of the operators, and the associativity of the operators. Before any operation
    is performed, however, the interpreter first evaluates the operands of the operator.
    (The exceptions are the `&&`, `||`, and `?`: operators, which do not always evaluate
    all their operands.) The interpreter always evaluates operands in order from left
    to right. This matters if any of the operands are expressions that contain side
    effects. Consider this code, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Although the multiplication is performed before the addition, the operands of
    the `+` operator are evaluated first. As the operand of `++` are both `++a`, these
    are evaluated to `3` and `4`, and so the expression evaluates to `3 + 4 * 5`,
    or `23`.
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The arithmetic operators can be used with integers, floating-point numbers,
    and even characters (i.e., they can be used with any primitive type other than
    `boolean`). If either of the operands is a floating-point number, floating-point
    arithmetic is used; otherwise, integer arithmetic is used. This matters because
    integer arithmetic and floating-point arithmetic differ in the way division is
    performed and in the way underflows and overflows are handled, for example. The
    arithmetic operators are:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Addition* (`+`)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `+` operator adds two numbers. As we’ll see shortly, the `+` operator can
    also be used to concatenate strings. If either operand of `+` is a string, the
    other one is converted to a string as well. Be sure to use parentheses when you
    want to combine addition with concatenation. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `+` operator can also be used in unary form to express a positive number,
    such as `+42`.
  prefs: []
  type: TYPE_NORMAL
- en: '*Subtraction* (`-`)'
  prefs: []
  type: TYPE_NORMAL
- en: When the `-` operator is used as a binary operator, it subtracts its second
    operand from its first. For example, `7-3` evaluates to `4`. The `-` operator
    can also perform unary negation.
  prefs: []
  type: TYPE_NORMAL
- en: '*Multiplication* (`*`)'
  prefs: []
  type: TYPE_NORMAL
- en: The `*` operator multiplies its two operands. For example, `7*3` evaluates to
    `21`.
  prefs: []
  type: TYPE_NORMAL
- en: '*Division* (`/`)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `/` operator divides its first operand by its second. If both operands
    are integers, the result is an integer, and any remainder is lost. If either operand
    is a floating-point value, however, the result is a floating-point value. When
    you divide two integers, division by zero throws an `ArithmeticException`. For
    floating-point calculations, however, division by zero simply yields an infinite
    result or `NaN`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '*Modulo* (`%`)'
  prefs: []
  type: TYPE_NORMAL
- en: The `%` operator computes the first operand modulo the second operand (i.e.,
    it returns the remainder when the first operand is divided by the second operand
    an integral number of times). For example, `7%3` is `1`. The sign of the result
    is the same as the sign of the first operand. While the modulo operator is typically
    used with integer operands, it also works for floating-point values. For example,
    `4.3%2.1` evaluates to `0.1`. When you are operating with integers, trying to
    compute a value modulo zero causes an `ArithmeticException`. When you are working
    with floating-point values, anything modulo `0.0` evaluates to `NaN`, as does
    infinity modulo anything.
  prefs: []
  type: TYPE_NORMAL
- en: '*Unary minus* (`-`)'
  prefs: []
  type: TYPE_NORMAL
- en: When the `-` operator is used as a unary operator—that is, before a single operand—it
    performs unary negation. In other words, it converts a positive value to an equivalently
    negative value, and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: String Concatenation Operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to adding numbers, the `+` operator (and the related `+=` operator)
    also concatenates, or joins, strings. If either of the operands to `+` is a string,
    the operator converts the other operand to a string. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As a result, you must be careful to put any addition expressions in parentheses
    when combining them with string concatenation. If you do not, the addition operator
    is interpreted as a concatenation operator.
  prefs: []
  type: TYPE_NORMAL
- en: Java has built-in string conversions for all primitive types. An object is converted
    to a string by invoking its `toString()` method. Some classes define custom `toString()`
    methods so that objects of that class can easily be converted to strings in this
    way. Sadly not all classes return friendly results when converted to strings.
    For example, the built-in `toString()` for an array doesn’t return a useful string
    representation of its contents, only information about the array object itself.
  prefs: []
  type: TYPE_NORMAL
- en: Increment and Decrement Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `++` operator increments its single operand, which must be a variable, an
    element of an array, or a field of an object, by 1\. The behavior of this operator
    depends on its position relative to the operand. When used before the operand,
    where it is known as the *pre-increment* operator, it increments the operand and
    evaluates to the incremented value of that operand. When used after the operand,
    where it is known as the *post-increment* operator, it increments its operand
    but evaluates to the value of that operand before it was incremented.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following code sets both `i` and `j` to 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'But these lines set `i` to 2 and `j` to 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, the `--` operator decrements its single numeric operand, which must
    be a variable, an element of an array, or a field of an object, by one. Like the
    `++` operator, the behavior of `--` depends on its position relative to the operand.
    When used before the operand, it decrements the operand and returns the decremented
    value. When used after the operand, it decrements the operand but returns the
    *undecremented* value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The expressions `x++` and `x--` are equivalent to `x = x + 1` and `x = x -
    1`, respectively, except that when you are using the increment and decrement operators,
    `x` is evaluated only once. If `x` is itself an expression with side effects,
    this makes a big difference. For example, these two expressions are not equivalent,
    as the second form increments `i` twice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: These operators, in both prefix and postfix forms, are most commonly used to
    increment or decrement the counter that controls a loop. However, an increasing
    number of programmers prefer to avoid using the increment and decrement operators
    altogether, preferring to use explicit code. This view is motivated by the large
    number of bugs that have, historically, been caused by incorrect usage of the
    operators.
  prefs: []
  type: TYPE_NORMAL
- en: Comparison Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The comparison operators consist of the equality operators that test values
    for equality or inequality and the relational operators used with ordered types
    (numbers and characters) to test for greater than and less than relationships.
    Both types of operators yield a `boolean` result, so they are typically used with
    `if` statements, the ternary conditional operator, or `while` and `for` loops
    to make branching and looping decisions. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Java provides the following equality operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Equals* (`==`)'
  prefs: []
  type: TYPE_NORMAL
- en: The `==` operator evaluates to `true` if its two operands are equal and `false`
    otherwise. With primitive operands, it tests whether the operand values themselves
    are identical. For operands of reference types, however, it tests whether the
    operands refer to the same object or array. In other words, it does not test the
    equality of two distinct objects or arrays. In particular, note that you cannot
    test two distinct strings for equality with this operator.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you experiment comparing strings via `==` you may see results that suggest
    it works properly. This is a side effect of Java’s internal caching of strings,
    known as *interning*. The only reliable way to compare strings (or any other reference
    type for that matter) for equality is the `equals()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The same applies with primitive wrapper classes, so `new Integer(1) != new Integer(1)`,
    while the preferred `Integer.valueOf(1) == Integer.valueOf(1)` does. The lesson
    is clearly that looking at equality on any nonprimitive type should be done with
    `equals()`. More discussion of object equality can be found in [“equals()”](ch05.xhtml#javanut8-CHP-5-SECT-2-2).
  prefs: []
  type: TYPE_NORMAL
- en: If `==` is used to compare two numeric or character operands that are not of
    the same type, the narrower operand is converted to the type of the wider operand
    before the comparison is done. For example, when you are comparing a `short` to
    a `float`, the `short` is first converted to a `float` before the comparison is
    performed. For floating-point numbers, the special negative zero value tests equal
    to the regular, positive zero value. Also, the special `NaN` (Not a Number) value
    is not equal to any other number, including itself. To test whether a floating-point
    value is `NaN`, use the `Float.isNan()` or `Double.isNan()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '*Not equals* (`!=`)'
  prefs: []
  type: TYPE_NORMAL
- en: The `!=` operator is exactly the opposite of the `==` operator. It evaluates
    to `true` if its two primitive operands have different values or if its two reference
    operands refer to different objects or arrays. Otherwise, it evaluates to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: The relational operators can be used with numbers and characters but not with
    `boolean` values, objects, or arrays because those types are not ordered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Java provides the following relational operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Less than* (`<`)'
  prefs: []
  type: TYPE_NORMAL
- en: Evaluates to `true` if the first operand is less than the second.
  prefs: []
  type: TYPE_NORMAL
- en: '*Less than or equal* (`<=`)'
  prefs: []
  type: TYPE_NORMAL
- en: Evaluates to `true` if the first operand is less than or equal to the second.
  prefs: []
  type: TYPE_NORMAL
- en: '*Greater than* (`>`)'
  prefs: []
  type: TYPE_NORMAL
- en: Evaluates to `true` if the first operand is greater than the second.
  prefs: []
  type: TYPE_NORMAL
- en: '*Greater than or equal* (`>=`)'
  prefs: []
  type: TYPE_NORMAL
- en: Evaluates to `true` if the first operand is greater than or equal to the second.
  prefs: []
  type: TYPE_NORMAL
- en: Boolean Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we’ve just seen, the comparison operators compare their operands and yield
    a `boolean` result, which is often used in branching and looping statements. In
    order to make branching and looping decisions based on conditions more interesting
    than a single comparison, you can use the Boolean (or logical) operators to combine
    multiple comparison expressions into a single, more complex expression. The Boolean
    operators require their operands to be `boolean` values and they evaluate to `boolean`
    values. The operators are:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Conditional AND* (`&&`)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This operator performs a Boolean AND operation on its operands. It evaluates
    to `true` if and only if both its operands are `true`. If either or both operands
    are `false`, it evaluates to `false`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This operator (and all the Boolean operators except the unary `!` operator)
    have a lower precedence than the comparison operators. Thus, it is perfectly legal
    to write a line of code like the one just shown. However, some programmers prefer
    to use parentheses to make the order of evaluation explicit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: You should use whichever style you find easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'This operator is called a conditional AND because it conditionally evaluates
    its second operand. If the first operand evaluates to `false`, the value of the
    expression is `false`, regardless of the value of the second operand. Therefore,
    to increase efficiency, the Java interpreter takes a shortcut and skips the second
    operand. The second operand is not guaranteed to be evaluated, so you must use
    caution when using this operator with expressions that have side effects. On the
    other hand, the conditional nature of this operator allows us to write Java expressions
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The second and third comparisons in this expression would cause errors if the
    first or second comparisons evaluated to `false`. Fortunately, we don’t have to
    worry about this because of the conditional behavior of the `&&` operator.
  prefs: []
  type: TYPE_NORMAL
- en: '*Conditional OR* (`||`)'
  prefs: []
  type: TYPE_NORMAL
- en: This operator performs a Boolean OR operation on its two `boolean` operands.
    It evaluates to `true` if either or both of its operands are `true`. If both operands
    are `false`, it evaluates to `false`. Like the `&&` operator, `||` does not always
    evaluate its second operand. If the first operand evaluates to `true`, the value
    of the expression is `true`, regardless of the value of the second operand. Thus,
    the operator simply skips the second operand in that case.
  prefs: []
  type: TYPE_NORMAL
- en: '*Boolean NOT* (`!`)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This unary operator changes the `boolean` value of its operand. If applied
    to a `true` value, it evaluates to `false`, and if applied to a `false` value,
    it evaluates to `true`. It is useful in expressions like these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Because `!` is a unary operator, it has a high precedence and often must be
    used with parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '*Boolean AND* (`&`)'
  prefs: []
  type: TYPE_NORMAL
- en: When used with `boolean` operands, the `&` operator behaves like the `&&` operator,
    except that it always evaluates both operands, regardless of the value of the
    first operand. This operator is almost always used as a bitwise operator with
    integer operands, however, and many Java programmers would not even recognize
    its use with `boolean` operands as legal Java code.
  prefs: []
  type: TYPE_NORMAL
- en: '*Boolean OR* (`|`)'
  prefs: []
  type: TYPE_NORMAL
- en: This operator performs a Boolean OR operation on its two `boolean` operands.
    It is like the `||` operator, except that it always evaluates both operands, even
    if the first one is `true`. The `|` operator is almost always used as a bitwise
    operator on integer operands; its use with `boolean` operands is very rare.
  prefs: []
  type: TYPE_NORMAL
- en: '*Boolean XOR* (`^`)'
  prefs: []
  type: TYPE_NORMAL
- en: When used with `boolean` operands, this operator computes the exclusive OR (XOR)
    of its operands. It evaluates to `true` if exactly one of the two operands is
    `true`. In other words, it evaluates to `false` if both operands are `false` or
    if both operands are `true`. Unlike the `&&` and `||` operators, this one must
    always evaluate both operands. The `^` operator is much more commonly used as
    a bitwise operator on integer operands. With `boolean` operands, this operator
    is equivalent to the `!=` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Bitwise and Shift Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The bitwise and shift operators are low-level operators that manipulate the
    individual bits that make up an integer value. The bitwise operators are not commonly
    used in modern Java except for low-level work (e.g., network programming). They
    are used for testing and setting individual flag bits in a value. To understand
    their behavior, you must understand binary (base-2) numbers and the two’s complement
    format used to represent negative integers.
  prefs: []
  type: TYPE_NORMAL
- en: You cannot use these operators with floating-point, `boolean`, array, or object
    operands. When used with `boolean` operands, the `&`, `|`, and `^` operators perform
    a different operation, as described in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'If either of the arguments to a bitwise operator is a `long`, the result is
    a `long`. Otherwise, the result is an `int`. If the left operand of a shift operator
    is a `long`, the result is a `long`; otherwise, the result is an `int`. The operators
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Bitwise complement* (`~`)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The unary `~` operator is known as the bitwise complement, or bitwise NOT,
    operator. It inverts each bit of its single operand, converting 1s to 0s and 0s
    to 1s. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '*Bitwise AND* (`&`)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This operator combines its two integer operands by performing a Boolean AND
    operation on their individual bits. The result has a bit set only if the corresponding
    bit is set in both operands. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: When used with `boolean` operands, `&` is the infrequently used Boolean AND
    operator described earlier.
  prefs: []
  type: TYPE_NORMAL
- en: '*Bitwise OR* (`|`)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This operator combines its two integer operands by performing a Boolean OR
    operation on their individual bits. The result has a bit set if the corresponding
    bit is set in either or both of the operands. It has a zero bit only where both
    corresponding operand bits are zero. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: When used with `boolean` operands, `|` is the infrequently used Boolean OR operator
    described earlier.
  prefs: []
  type: TYPE_NORMAL
- en: '*Bitwise XOR* (`^`)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This operator combines its two integer operands by performing a Boolean XOR
    (exclusive OR) operation on their individual bits. The result has a bit set if
    the corresponding bits in the two operands are different. If the corresponding
    operand bits are both 1s or both 0s, the result bit is a 0\. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: When used with `boolean` operands, `^` is the seldom used Boolean XOR operator.
  prefs: []
  type: TYPE_NORMAL
- en: '*Left shift* (`<<`)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `<<` operator shifts the bits of the left operand left by the number of
    places specified by the right operand. High-order bits of the left operand are
    lost, and zero bits are shifted in from the right. Shifting an integer left by
    *n* places is equivalent to multiplying that number by 2^(*n*). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: If the left operand is a `long`, the right operand should be between 0 and 63\.
    Otherwise, the left operand is taken to be an `int`, and the right operand should
    be between 0 and 31\. If either of these ranges is exceeded, you may see unintuitive
    wrapping behavior from these operators.
  prefs: []
  type: TYPE_NORMAL
- en: '*Signed right shift* (`>>`)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `>>` operator shifts the bits of the left operand to the right by the number
    of places specified by the right operand. The low-order bits of the left operand
    are shifted away and are lost. The high-order bits shifted in are the same as
    the original high-order bit of the left operand. In other words, if the left operand
    is positive, 0s are shifted into the high-order bits. If the left operand is negative,
    1s are shifted in instead. This technique is known as *sign extension*; it is
    used to preserve the sign of the left operand. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: If the left operand is positive and the right operand is *n*, the `>>` operator
    is the same as integer division by 2^(*n*).
  prefs: []
  type: TYPE_NORMAL
- en: '*Unsigned right shift* (`>>>`)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This operator is like the `>>` operator, except that it always shifts zeros
    into the high-order bits of the result, regardless of the sign of the lefthand
    operand. This technique is called *zero extension*; it is appropriate when the
    left operand is being treated as an unsigned value (despite the fact that Java
    integer types are all signed). These are examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Assignment Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The assignment operators store, or assign, a value into a piece of the computer’s
    memory--often referred to as a *storage location*. The left operand must evaluate
    to an appropriate local variable, array element, or object field.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The lefthand side of an assignment expression is sometimes called an `*lvalue*`.
    In Java it must refer to some assignable storage (i.e., memory that can be written
    to).
  prefs: []
  type: TYPE_NORMAL
- en: The righthand side (the `*rvalue*`) can be any value of a type compatible with
    the variable. An assignment expression evaluates to the value that is assigned
    to the variable. More importantly, however, the expression has the side effect
    of actually performing the assignment—​storing the `rvalue` in the `lvalue`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Unlike all other binary operators, the assignment operators are right-associative,
    which means that the assignments in `a=b=c` are performed right to left, as follows:
    `a=(b=c)`.'
  prefs: []
  type: TYPE_NORMAL
- en: The basic assignment operator is `=`. Do not confuse it with the equality operator,
    `==`. To keep these two operators distinct, we recommend that you read `=` as
    “is assigned the value.”
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to this simple assignment operator, Java also defines 11 other
    operators that combine assignment with the 5 arithmetic operators and the 6 bitwise
    and shift operators. For example, the `+=` operator reads the value of the left
    variable, adds the value of the right operand to it, stores the sum back into
    the left variable as a side effect, and returns the sum as the value of the expression.
    Thus, the expression `x+=2` is almost the same as `x=x+2`. The difference between
    these two expressions is that when you use the `+=` operator, the left operand
    is evaluated only once. This makes a difference when that operand has a side effect.
    Consider the following two expressions, which are not equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The general form of these combination assignment operators is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'This is equivalent (unless there are side effects in `lvalue`) to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The available operators are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The most commonly used operators are `+=` and `-=`, although `&=` and `|=`
    can also be useful when you are working with `boolean` or bitwise flags. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The Conditional Operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The conditional operator `?`: is a somewhat obscure ternary (three-operand)
    operator inherited from C. It allows you to embed a conditional within an expression.
    You can think of it as the operator version of the `if/else` statement. The first
    and second operands of the conditional operator are separated by a question mark
    (`?`), while the second and third operands are separated by a colon (:). The first
    operand must evaluate to a `boolean` value. The second and third operands can
    be of any type, but they must be convertible to the same type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The conditional operator starts by evaluating its first operand. If it is `true`,
    the operator evaluates its second operand and uses that as the value of the expression.
    On the other hand, if the first operand is `false`, the conditional operator evaluates
    and returns its third operand. The conditional operator never evaluates both its
    second and third operand, so be careful when using expressions with side effects
    with this operator. Examples of this operator are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the `?`: operator has lower precedence than all other operators except
    the assignment operators, so parentheses are not usually necessary around the
    operands of this operator. Many programmers find conditional expressions easier
    to read if the first operand is placed within parentheses, however. This is especially
    true because the conditional `if` statement always has its conditional expression
    written within parentheses.'
  prefs: []
  type: TYPE_NORMAL
- en: The instanceof Operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `instanceof` operator is intimately bound up with objects and the operation
    of the Java type system. If this is your first look at Java, it may be preferable
    to skim this definition and return to this section after you have a decent grasp
    of Java’s objects.
  prefs: []
  type: TYPE_NORMAL
- en: '`instanceof` requires an object or array value as its left operand and the
    name of a reference type as its right operand. In its basic form, it evaluates
    to `true` if the object or array is an *instance* of the specified type; it returns
    `false` otherwise. If the left operand is `null`, `instanceof` always evaluates
    to `false`. If an `instanceof` expression evaluates to `true`, it means that you
    can safely cast and assign the left operand to a variable of the type of the right
    operand.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `instanceof` operator can be used only with reference types and objects,
    not primitive types and values. Examples of `instanceof` are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: In Java 17 `instanceof` has an extended form known as *pattern matching*. The
    final example above demonstrates a common pattern-checking `instanceof` and then
    casting to the type within a conditional. With pattern matching we can express
    this all at once by including a variable after the reference type. If `instanceof`
    sees the type is compatible, the variable is assigned the casted object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: This sort of pattern matching is a recent addition in Java. Upcoming releases
    are expected to provide more of these sorts of convenience throughout the language.
  prefs: []
  type: TYPE_NORMAL
- en: Historically using `instanceof` was discouraged in favor of other more object-oriented
    solutions we’ll see in [Chapter 5](ch05.xhtml#javanut8-CHP-5). Java’s increasing
    adoption of pattern matching, though, is changing attitudes about this operator.
    `instanceof` is especially well suited to the common scenarios around receiving
    data in unpredictable formats through an API and is often a pragmatic option these
    days rather than a last resort.
  prefs: []
  type: TYPE_NORMAL
- en: Special Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Java has six language constructs that are sometimes considered operators and
    sometimes considered simply part of the basic language syntax. These “operators”
    were included in [Table 2-4](#javanut8-CHP-2-TABLE-4) to show their precedence
    relative to the other true operators. The use of these language constructs is
    detailed elsewhere in this book, but it is described briefly here so that you
    can recognize them in code examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Member access* (`.`)'
  prefs: []
  type: TYPE_NORMAL
- en: An *object* is a collection of data and methods that operate on that data; the
    data fields and methods of an object are called its members. The dot (.) operator
    accesses these members. If `o` is an expression that evaluates to an object reference
    (or a class name), and `f` is the name of a field of the class, `o.f` evaluates
    to the value contained in that field. If `m` is the name of a method, `o.m` refers
    to that method and allows it to be invoked using the `()` operator shown later.
  prefs: []
  type: TYPE_NORMAL
- en: '*Array element access* (`[]`)'
  prefs: []
  type: TYPE_NORMAL
- en: An *array* is a numbered list of values. Each element of an array can be referred
    to by its number, or *index*. The `[ ]` operator allows you to refer to the individual
    elements of an array. If `a` is an array, and `i` is an expression that evaluates
    to an `int`, `a[i]` refers to one of the elements of `a`. Unlike other operators
    that work with integer values, this operator restricts array index values to be
    of type `int` or narrower.
  prefs: []
  type: TYPE_NORMAL
- en: '*Method invocation* (`()`)'
  prefs: []
  type: TYPE_NORMAL
- en: A *method* is a named collection of Java code that can be run, or *invoked*,
    by following the name of the method with zero or more comma-separated expressions
    contained within parentheses. The values of these expressions are the *arguments*
    to the method. The method processes the arguments and optionally returns a value
    that becomes the value of the method invocation expression. If `o.m` is a method
    that expects no arguments, the method can be invoked with `o.m()`. If the method
    expects three arguments, for example, it can be invoked with an expression such
    as `o.m(x,y,z)`. `o` is referred to as the *receiver* of the method—if `o` is
    an object, then it is said to be the *receiver object*. Before the Java interpreter
    invokes a method, it evaluates each of the arguments to be passed to the method.
    These expressions are guaranteed to be evaluated in order from left to right (which
    matters if any of the arguments have side effects).
  prefs: []
  type: TYPE_NORMAL
- en: '*Lambda expression* (`->`)'
  prefs: []
  type: TYPE_NORMAL
- en: A *lambda expression* is an anonymous collection of executable Java code, essentially
    a method body. It consists of a method argument list (zero or more comma-separated
    expressions contained within parentheses) followed by the lambda *arrow* operator
    followed by a block of Java code. If the block of code comprises just a single
    statement, then the usual curly braces to denote block boundaries can be omitted.
    If the lambda takes only a single argument, the parentheses around the argument
    can be omitted.
  prefs: []
  type: TYPE_NORMAL
- en: '*Object creation* (`new`)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java, objects are created with the `new` operator, which is followed by
    the type of the object to be created and a parenthesized list of arguments to
    be passed to the object *constructor*. A constructor is a special block of code
    that initializes a newly created object, so the object creation syntax is similar
    to the Java method invocation syntax. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '*Array creation* (`new`)'
  prefs: []
  type: TYPE_NORMAL
- en: Arrays are a special case of objects and they too are created with the `new`
    operator, with a slightly different syntax. The keyword is followed by the type
    of the array to be created and the size of the array encased in square brackets—​for
    example, as `new int[5]`. In some circumstances, arrays can also be created using
    the *array literal* syntax.
  prefs: []
  type: TYPE_NORMAL
- en: '*Type conversion or casting* (`()`)'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we’ve already seen, parentheses can also be used as an operator to perform
    narrowing type conversions, or casts. The first operand of this operator is the
    type to be converted to; it is placed between the parentheses. The second operand
    is the value to be converted; it follows the parentheses. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A *statement* is a basic unit of execution in the Java language—it expresses
    a single piece of intent by the programmer. Unlike expressions, Java statements
    do not have a value. Statements also typically contain expressions and operators
    (especially assignment operators) and are frequently executed for the side effects
    that they cause.
  prefs: []
  type: TYPE_NORMAL
- en: Many of the statements defined by Java are flow-control statements, such as
    conditionals and loops, that can alter the default, linear order of execution
    in well-defined ways. [Table 2-5](#javanut8-CHP-2-TABLE-5) summarizes the statements
    defined by Java.
  prefs: []
  type: TYPE_NORMAL
- en: Table 2-5\. Table 2-5\. Java statements
  prefs: []
  type: TYPE_NORMAL
- en: '| Statement | Purpose | Syntax |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| *expression* | side effects | *`variable`* `=` *`expr`* `;` *`expr`* `++;`
    *`method`* `();` `new` *`Type`* `( );` |'
  prefs: []
  type: TYPE_TB
- en: '| *compound* | group statements | `{` *`statements`* `}` |'
  prefs: []
  type: TYPE_TB
- en: '| *empty* | do nothing | `;` |'
  prefs: []
  type: TYPE_TB
- en: '| *labeled* | name a statement | *`label`* : *`statement`* |'
  prefs: []
  type: TYPE_TB
- en: '| *variable* | declare a variable | `[final]` *`type`* *`name`* `[=` *`value`*
    `]` `[`, *`name`* `[=` *`value`* `]] …;` |'
  prefs: []
  type: TYPE_TB
- en: '| `if` | conditional | `if (` *`expr`* `)` *`statement`* `[ else` *`statement`*
    `]` |'
  prefs: []
  type: TYPE_TB
- en: '| `switch` | conditional | `switch (` *`expr`* `) {` `[ case` *`expr`* : *`statements`*
    `] …` `[ default`: *`statements`* `]` `}` |'
  prefs: []
  type: TYPE_TB
- en: '| `switch` | conditional expression | `switch (` *`expr`* `) {` `[ case` *`expr`*
    `, [` *`expr`* `…] ->` *`expr`* `;] …` `[ default ->` *`expr`* `;]` `}` |'
  prefs: []
  type: TYPE_TB
- en: '| `while` | loop | `while (` *`expr`* `)` *`statement`* |'
  prefs: []
  type: TYPE_TB
- en: '| `do` | loop | `do` *`statement`* `while (` *`expr`* `);` |'
  prefs: []
  type: TYPE_TB
- en: '| `for` | simplified loop | `for (` *`init`* `;` *`test`* `;` *`increment`*
    `)` *`statement`* |'
  prefs: []
  type: TYPE_TB
- en: '| *foreach* | collection iteration | `for (` *`variable`* : *`iterable`* `)`
    *`statement`* |'
  prefs: []
  type: TYPE_TB
- en: '| `break` | exit block | `break [` *`label`* `] ;` |'
  prefs: []
  type: TYPE_TB
- en: '| `continue` | restart loop | `continue [` *`label`* `] ;` |'
  prefs: []
  type: TYPE_TB
- en: '| `return` | end method | `return [` *`expr`* `] ;` |'
  prefs: []
  type: TYPE_TB
- en: '| `synchronized` | critical section | `synchronized (` *`expr`* `) {` *`statements`*
    `}` |'
  prefs: []
  type: TYPE_TB
- en: '| `throw` | throw exception | `throw` *`expr`* `;` |'
  prefs: []
  type: TYPE_TB
- en: '| `try` | handle exception | `try {` *`statements`* `}` `[ catch (` *`type`*
    *`name`* `) {` *`statements`* `} ] …` `[ finally {` *`statements`* `} ]` |'
  prefs: []
  type: TYPE_TB
- en: '| `try` | handle exception, closing resources | `try ([` *`variable`* `=` *`expr`*
    `]) {` *`statements`* `}` `[ catch (` *`type`* *`name`* `) {` *`statements`* `}
    ] …` `[ finally {` *`statements`* `} ]` |'
  prefs: []
  type: TYPE_TB
- en: '| `assert` | verify invariant | `assert` *`invariant`* `[` *`error`* ]; |'
  prefs: []
  type: TYPE_TB
- en: Expression Statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we saw earlier in the chapter, certain types of Java expressions have side
    effects. In other words, they do not simply evaluate to some value; they also
    change the program state in some way. You can use any expression with side effects
    as a statement simply by following it with a semicolon. The legal types of expression
    statements are assignments, increments and decrements, method calls, and object
    creation. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Compound Statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *compound statement* is any number and kind of statements grouped together
    within curly braces. You can use a compound statement anywhere a statement is
    required by Java syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The Empty Statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An *empty statement* in Java is written as a single semicolon. The empty statement
    doesn’t do anything, but the syntax is occasionally useful. For example, you can
    use it to indicate an empty loop body in a `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Labeled Statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *labeled statement* is simply a statement that you have given a name by prepending
    an identifier and a colon to it. Labels are used by the `break` and `continue`
    statements. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Local Variable Declaration Statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *local variable*, often simply called a variable, is a symbolic name for a
    location to store a value that is defined within a method or compound statement.
    All variables must be declared before they can be used; this is done with a variable
    declaration statement. Because Java is a statically typed language, a variable
    declaration specifies the type of the variable, and only values of that type can
    be stored in the variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'In its simplest form, a variable declaration specifies a variable’s type and
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'A variable declaration can also include an *initializer*, an expression that
    specifies an initial value for the variable. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The Java compiler does not allow you to use a local variable that has not been
    initialized, so it is usually convenient to combine variable declaration and initialization
    into a single statement. The initializer expression need not be a literal value
    or a constant expression that can be evaluated by the compiler; it can be an arbitrarily
    complex expression whose value is computed when the program is run.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a variable has an initializer, then the programmer can use a special syntax
    to ask the compiler to automatically work out the type, if it is possible to do
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: This can be a useful syntax, but it is potentially harder to read. Our second
    example, for instance, requires that you know that the return type of `readLine()`
    is `String` to know what type will be inferred for `s`. For this reason, throughout
    the text we only use `var` in examples when the initializer makes the type completely
    redundant. As you learn the Java language, this may be a reasonable policy to
    follow while you become familiar with the Java type system.
  prefs: []
  type: TYPE_NORMAL
- en: 'A single variable declaration statement can declare and initialize more than
    one variable, but all variables must be of the same explicitly declared type.
    Variable names and optional initializers are separated from each other with commas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Variable declaration statements can begin with the `final` keyword. This modifier
    specifies that once an initial value is defined for the variable, that value is
    never allowed to change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: We will have more to say about the `final` keyword later on, especially when
    talking about the design of classes and the immutable style of programming.
  prefs: []
  type: TYPE_NORMAL
- en: Java variable declaration statements can appear anywhere in Java code; they
    are not restricted to the beginning of a method or block of code. Local variable
    declarations can also be integrated with the *initialize* portion of a `for` loop,
    as we’ll discuss shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Local variables can be used only within the method or block of code in which
    they are defined. This is called their *scope* or *lexical scope*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: The if/else Statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `if` statement is a fundamental control statement that allows Java to make
    decisions or, more precisely, to execute statements conditionally. The `if` statement
    has an associated expression and statement. If the expression evaluates to `true`,
    the interpreter executes the statement. If the expression evaluates to `false`,
    the interpreter skips the statement.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Java allows the expression to be of the wrapper type `Boolean` instead of the
    primitive type `boolean`. In this case, the wrapper object is automatically unboxed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Although they look extraneous, the parentheses around the expression are a
    required part of the syntax for the `if` statement. As we already saw, a block
    of statements enclosed in curly braces is itself a statement, so we can write
    `if` statements that look like this as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'An `if` statement can include an optional `else` keyword that is followed by
    a second statement. In this form of the statement, the expression is evaluated,
    and, if it is `true`, the first statement is executed. Otherwise, the second statement
    is executed. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'When you use nested `if/else` statements, some caution is required to ensure
    that the `else` clause goes with the appropriate `if` statement. Consider the
    following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the inner `if` statement forms the single statement allowed
    by the syntax of the outer `if` statement. Unfortunately, it is not clear (except
    from the hint given by the indentation) which `if` the `else` goes with. And in
    this example, the indentation hint is wrong. The rule is that an `else` clause
    like this is associated with the nearest `if` statement. Properly indented, this
    code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'This is legal code, but it is clearly not what the programmer had in mind.
    When working with nested `if` statements, you should use curly braces to make
    your code easier to read. Here is a better way to write the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: The else if clause
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `if/else` statement is useful for testing a condition and choosing between
    two statements or blocks of code to execute. But what about when you need to choose
    between several blocks of code? This is typically done with an `else` `if` clause,
    which is not really new syntax but a common idiomatic usage of the standard `if/else`
    statement. It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'There is nothing special about this code. It is just a series of `if` statements,
    where each `if` is part of the `else` clause of the previous statement. Using
    the `else` `if` idiom is preferable to, and more legible than, writing these statements
    out in their fully nested form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: The switch Statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An `if` statement causes a branch in the flow of a program’s execution. You
    can use multiple `if` statements, as shown in the previous section, to perform
    a multiway branch. This is not always the best solution, however, especially when
    all of the branches depend on the value of a single variable.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the repeated `if` statements may seriously hamper readability,
    especially if the code has been refactored over time or features multiple levels
    of nested `if`.
  prefs: []
  type: TYPE_NORMAL
- en: A better solution is to use a `switch` statement, which is inherited from the
    C programming language. Note, however, that the syntax of this statement is not
    nearly as elegant as other parts of Java. The failure to revisit the design of
    the feature is widely regarded as a mistake, one that has been partially addressed
    in recent versions with an expression form of `switch` we’ll examine in a moment.
    However, that alternative format won’t erase the long history of `switch` statements
    in the language, so it’s good to come to grips with it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A `switch` statement starts with an expression whose type is an `int`, `short`,
    `char`, `byte` (or their wrapper type), `String`, or an enum (see [Chapter 4](ch04.xhtml#javanut8-CHP-4)
    for more on enumerated types).
  prefs: []
  type: TYPE_NORMAL
- en: 'This expression is followed by a block of code in curly braces that contains
    various entry points that correspond to possible values for the expression. For
    example, the following `switch` statement is equivalent to the repeated `if` and
    `else/if` statements shown in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the example, the various entry points into a `switch` statement
    are labeled either with the keyword `case`, followed by an integer value and a
    colon, or with the special `default` keyword, followed by a colon. When a `switch`
    statement executes, the interpreter computes the value of the expression in parentheses
    and then looks for a `case` label that matches that value. If it finds one, the
    interpreter starts executing the block of code at the first statement following
    the `case` label. If it does not find a `case` label with a matching value, the
    interpreter starts execution at the first statement following a special-case `default`:
    label. Or, if there is no `default`: label, the interpreter skips the body of
    the `switch` statement altogether.'
  prefs: []
  type: TYPE_NORMAL
- en: Note the use of the `break` keyword at the end of each `case` in the previous
    code. The `break` statement is described later in this chapter, but, in this example,
    it causes the interpreter to exit the body of the `switch` statement. The `case`
    clauses in a `switch` statement specify only the starting point of the desired
    code. The individual `cases` are not independent blocks of code, and they do not
    have any implicit ending point.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You must explicitly specify the end of each `case` with a `break` or related
    statement. In the absence of `break` statements, a `switch` statement begins executing
    code at the first statement after the matching `case` label and continues executing
    statements until it reaches the end of the block. The control flow will *fall
    through* into the next `case` label and continue executing, rather than exit the
    block.
  prefs: []
  type: TYPE_NORMAL
- en: On rare occasions, it is useful to write code like this that falls through from
    one `case` label to the next, but 99% of the time you should be careful to end
    every `case` and `default` section with a statement that causes the `switch` statement
    to stop executing. Normally you use a `break` statement, but `return` and `throw`
    also work.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a consequence of this default fall-through, a `switch` statement can have
    more than one `case` clause labeling the same statement. Consider the `switch`
    statement in the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: The `switch` statement and its `case` labels have some important restrictions.
    First, the expression associated with a `switch` statement must have an appropriate
    type—either `byte`, `char`, `short`, `int` (or their wrappers), or an enum type
    or a `String`. The floating-point and `boolean` types are not supported, and neither
    is `long`, even though `long` is an integer type. Second, the value associated
    with each `case` label must be a constant value or a constant expression the compiler
    can evaluate. A `case` label cannot contain a runtime expression involving variables
    or method calls, for example. Third, the `case` label values must be within the
    range of the data type used for the `switch` expression. And finally, it is not
    legal to have two or more `case` labels with the same value or more than one `default`
    label.
  prefs: []
  type: TYPE_NORMAL
- en: With all those caveats, let’s look at how the new `switch` expression makes
    for a cleaner experience.
  prefs: []
  type: TYPE_NORMAL
- en: The switch Expression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A frequent problem with the classic `switch` statement arises when capturing
    a variable value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: For the variable to be available after the `switch`, it must be declared outside
    the statement and provided an initial value. Then each `case` must be certain
    to set the variable. However, we have no guarantees, and in code with more branches
    than this simple example, it’s an easy thing to miss and introduce a bug.
  prefs: []
  type: TYPE_NORMAL
- en: The `switch` expression is explicitly designed to address these and other faults.
    As the name calls out, it’s an *expression*—one of the more syntactically complex
    ones in the language—and as such results in a value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Much like the `switch` statement, each `case` here evaluates the input against
    its value. After an `->` you provide the resulting value for the switch expression
    as a whole. In this example, we’re assigning that to our variable `yesOrNo`, which
    no longer needs to be the nullable wrapper type.
  prefs: []
  type: TYPE_NORMAL
- en: Our code as written here hides one of the protections that the `switch` expressions
    is giving us. If we remove the `default` clause, the compiler will give us an
    error because the expression cannot always be evaluated fully.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Switch expressions do not fall through like the statement form. To support multiple
    values evaluating to the same result, each `case` can take a comma-separated list
    of values instead of just a single value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Our desired result can’t always be expressed as a single value or method call.
    To support that, curly braces may introduce a statement. However, the statement
    must end with either `yield` to exit the switch with a value, or a `return` leaving
    the entire enclosing method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: And in fact, if we don’t make use of the `switch` expression result, we can
    even use this syntax, with its improved branch checking and safety, purely for
    side effects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: The while Statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `while` statement is a basic statement that allows Java to perform repetitive
    actions—or, to put it another way, it is one of Java’s primary *looping constructs*.
    It has the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: The `while` statement works by first evaluating the *`expression`*, which must
    result in a `boolean` or `Boolean` value. If the value is `false`, the interpreter
    skips the *`statement`* associated with the loop and moves to the next statement
    in the program. If it is `true`, however, the *`statement`* that forms the body
    of the loop is executed, and the *`expression`* is reevaluated. Again, if the
    value of *`expression`* is `false`, the interpreter moves on to the next statement
    in the program; otherwise, it executes the *`statement`* again. This cycle continues
    while the *`expression`* remains `true` (i.e., until it evaluates to `false`),
    at which point the `while` statement ends, and the interpreter moves on to the
    next statement. You can create an infinite loop with the syntax `while(true)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example `while` loop that prints the numbers 0 to 9:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the variable `count` starts off at 0 in this example and is
    incremented each time the body of the loop runs. Once the loop has executed 10
    times, the expression becomes `false` (i.e., `count` is no longer less than 10),
    the `while` statement finishes, and the Java interpreter can move to the next
    statement in the program. Most loops have a counter variable like `count`. The
    variable names `i`, `j`, and `k` are commonly used as loop counters, although
    you should use more descriptive names if it makes your code easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: The do Statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A `do` loop is much like a `while` loop, except that the loop expression is
    tested at the bottom of the loop rather than at the top. This means that the body
    of the loop is always executed at least once. The syntax is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice a couple of differences between the `do` loop and the more ordinary
    `while` loop. First, the `do` loop requires both the `do` keyword to mark the
    beginning of the loop and the `while` keyword to mark the end and introduce the
    loop condition. Also, unlike the `while` loop, the `do` loop is terminated with
    a semicolon. This is because the `do` loop ends with the loop condition rather
    than simply ending with a curly brace that marks the end of the loop body. The
    following `do` loop prints the same output as the `while` loop just discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: The `do` loop is much less commonly used than its `while` cousin because, in
    practice, it is unusual to encounter a situation where you are sure you always
    want a loop to execute at least once.
  prefs: []
  type: TYPE_NORMAL
- en: The for Statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `for` statement provides a looping construct that is often more convenient
    than the `while` and `do` loops. The `for` statement takes advantage of a common
    looping pattern. Most loops have a counter, or state variable of some kind, that
    is initialized before the loop starts, tested to determine whether to execute
    the loop body, and then incremented or updated somehow at the end of the loop
    body before the test expression is evaluated again. The *`initialize`*, *`test`*,
    and *`update`* steps are the three crucial manipulations of a loop variable, and
    the `for` statement makes these three steps an explicit part of the loop syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'This `for` loop is basically equivalent to the following `while` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Placing the *`initialize`*, *`test`*, and *`update`* expressions at the top
    of a `for` loop makes it especially easy to understand what the loop is doing,
    and it prevents mistakes such as forgetting to initialize or update the loop variable.
    The interpreter discards the values of the *`initialize`* and *`update`* expressions,
    so to be useful, these expressions must have side effects. *`initialize`* is typically
    an assignment expression, while *`update`* is usually an increment, decrement,
    or some other assignment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `for` loop prints the numbers 0 to 9, just as the previous `while`
    and `do` loops have done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Notice how this syntax places all the important information about the loop variable
    on a single line, making it very clear how the loop executes. Placing the *`update`*
    expression in the `for` statement itself also simplifies the body of the loop
    to a single statement; we don’t even need to use curly braces to produce a statement
    block.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `for` loop supports some additional syntax that makes it even more convenient
    to use. Because many loops use their loop variables only within the loop, the
    `for` loop allows the *`initialize`* expression to be a full variable declaration,
    so that the variable is scoped to the body of the loop and is not visible outside
    of it. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, the `for` loop syntax does not restrict you to writing loops that
    use only a single variable. Both the *`initialize`* and *`update`* expressions
    of a `for` loop can use a comma to separate multiple initializations and update
    expressions. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Even though all the examples so far have counted numbers, `for` loops are not
    restricted to loops that count numbers. For example, you might use a `for` loop
    to iterate through the elements of a linked list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: The *`initialize`*, *`test`*, and *`update`* expressions of a `for` loop are
    all optional; only the semicolons that separate the expressions are required.
    If the *`test`* expression is omitted, it is assumed to be `true`. Thus, you can
    write an infinite loop as `for(;;)`.
  prefs: []
  type: TYPE_NORMAL
- en: The foreach Statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Java’s `for` loop works well for primitive types, but it is needlessly clunky
    for handling collections of objects. Instead, an alternative syntax known as a
    *foreach* loop is used for handling collections of objects that need to be looped
    over.
  prefs: []
  type: TYPE_NORMAL
- en: 'The foreach loop uses the keyword `for` followed by an opening parenthesis,
    a variable declaration (without initializer), a colon, an expression, a closing
    parenthesis, and finally the statement (or block) that forms the body of the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Despite its name, the foreach loop does not have a keyword `foreach`—instead,
    it is common to read the colon as “in”—as in “foreach name in studentNames.”
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `while`, `do`, and `for` loops, we’ve shown an example that prints
    10 numbers. The foreach loop can do this too, but it needs a collection to iterate
    over. In order to loop 10 times (to print out 10 numbers), we need an array or
    other collection with 10 elements. Here’s code we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: What foreach cannot do
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The foreach is different from the `while`, `for`, or `do` loops, because it
    hides the loop counter or `Iterator` from you. This is a very powerful idea, as
    we’ll see when we discuss lambda expressions, but there are some algorithms that
    cannot be expressed very naturally with a foreach loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose you want to print the elements of an array as a comma-separated
    list. To do this, you need to print a comma after every element of the array except
    the last, or equivalently, before every element of the array except the first.
    With a traditional `for` loop, the code might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: This is a very straightforward task, but you simply cannot do it with foreach
    without keeping track of additional state. The problem is that the foreach loop
    doesn’t give you a loop counter or any other way to tell if you’re on the first
    iteration, the last iteration, or somewhere in between.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A similar issue exists when you’re using foreach to iterate through the elements
    of a collection. Just as a foreach loop over an array has no way to obtain the
    array index of the current element, a foreach loop over a collection has no way
    to obtain the `Iterator` object that is being used to itemize the elements of
    the collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some other things you cannot do with a foreach-style loop:'
  prefs: []
  type: TYPE_NORMAL
- en: Iterate backward through the elements of an array or `List`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a single loop counter to access the same-numbered elements of two distinct
    arrays.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterate through the elements of a `List` using calls to its `get()` method rather
    than calls to its iterator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The break Statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A `break` statement causes the Java interpreter to skip immediately to the
    end of a containing statement. We have already seen the `break` statement used
    with the `switch` statement. The `break` statement is most often written as simply
    the keyword `break` followed by a semicolon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'When used in this form, it causes the Java interpreter to immediately exit
    the innermost containing `while`, `do`, `for`, or `switch` statement. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'The `break` statement can also be followed by the name of a containing labeled
    statement. When used in this form, `break` causes the Java interpreter to immediately
    exit the named block, which can be any kind of statement, not just a loop or `switch`.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: The continue Statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While a `break` statement exits a loop, a `continue` statement quits the current
    iteration of a loop and starts the next one. `continue`, in both its unlabeled
    and labeled forms, can be used only within a `while`, `do`, or `for` loop. When
    used without a label, `continue` causes the innermost loop to start a new iteration.
    When used with a label that is the name of a containing loop, it causes the named
    loop to start a new iteration. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '`while`, `do`, and `for` loops differ slightly in the way that `continue` starts
    a new iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: With a `while` loop, the Java interpreter simply returns to the top of the loop,
    tests the loop condition again, and, if it evaluates to `true`, executes the body
    of the loop again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With a `do` loop, the interpreter jumps to the bottom of the loop, where it
    tests the loop condition to decide whether to perform another iteration of the
    loop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With a `for` loop, the interpreter jumps to the top of the loop, where it first
    evaluates the *`update`* expression and then evaluates the *`test`* expression
    to decide whether to loop again. As you can see from the examples, the behavior
    of a `for` loop with a `continue` statement is different from the behavior of
    the “basically equivalent” `while` loop presented earlier; *`update`* gets evaluated
    in the `for` loop but not in the equivalent `while` loop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The return Statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A `return` statement tells the Java interpreter to stop executing the current
    method. If the method is declared to return a value, the `return` statement must
    be followed by an expression. The value of the expression becomes the return value
    of the method. For example, the following method computes and returns the square
    of a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Some methods are declared `void` to indicate that they do not return any value.
    The Java interpreter runs methods like this by executing their statements one
    by one until it reaches the end of the method. After executing the last statement,
    the interpreter returns implicitly. Sometimes, however, a `void` method has to
    return explicitly before reaching the last statement. In this case, it can use
    the `return` statement by itself, without any expression. For example, the following
    method prints, but does not return, the square root of its argument. If the argument
    is a negative number, it returns without printing anything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: The synchronized Statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Java has always provided support for multithreaded programming. We cover this
    in some detail later on (especially in [“Java’s Support for Concurrency”](ch06.xhtml#javanut8-CHP-6-SECT-5));
    however, be aware that concurrency is difficult to get right and has a number
    of subtleties.
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, when working with multiple threads, you must often take care
    to prevent multiple threads from modifying an object simultaneously in a way that
    might corrupt the object’s state. Java provides the `synchronized` statement to
    help the programmer prevent corruption. The syntax is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '*`expression`* is an expression that must evaluate to an object (including
    arrays). *`statements`* constitute the code of the section that could cause damage
    and must be enclosed in curly braces.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In Java, the protection of object state (i.e., data) is the primary concern
    of the concurrency primitives. This is unlike some other languages, where the
    exclusion of threads from *critical sections* (i.e., code) is the main focus.
  prefs: []
  type: TYPE_NORMAL
- en: Before executing the statement block, the Java interpreter first obtains an
    exclusive lock on the object or array specified by *`expression`*. It holds the
    lock until it is finished running the block, then releases it. While a thread
    holds the lock on an object, no other thread can obtain that lock.
  prefs: []
  type: TYPE_NORMAL
- en: As well as the block form, `synchronized` can also be used as a method modifier
    in Java. When applied to a method, the keyword indicates that the entire method
    is treated as `synchronized`.
  prefs: []
  type: TYPE_NORMAL
- en: For a `synchronized` instance method, Java obtains an exclusive lock on the
    class instance. (Class and instance methods are discussed in [Chapter 3](ch03.xhtml#javanut8-CHP-3).)
    It can be thought of as a `synchronized (this) { ... }` block that covers the
    entire method.
  prefs: []
  type: TYPE_NORMAL
- en: A `static synchronized` method (a class method) causes Java to obtain an exclusive
    lock on the class (technically the class object corresponding to the type) before
    executing the method.
  prefs: []
  type: TYPE_NORMAL
- en: The throw Statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An *exception* is a signal that indicates some sort of exceptional condition
    or error has occurred. To *throw* an exception is to signal an exceptional condition.
    To *catch* an exception is to handle it—to take whatever actions are necessary
    to recover from it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java, the `throw` statement is used to throw an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'The *`expression`* must evaluate to an exception object that describes the
    exception or error that has occurred. We’ll talk more about types of exceptions
    shortly; for now, all you need to know is that an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: Is represented by an object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has a type that is a subclass of `Exception`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has a slightly specialized role in Java’s syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Can be of two different types: *checked* or *unchecked*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is some example code that throws an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: When the Java interpreter executes a `throw` statement, it immediately stops
    normal program execution and starts looking for an exception handler that can
    catch, or handle, the exception. Exception handlers are written with the `try/catch/finally`
    statement, which is described in the next section. The Java interpreter first
    looks at the enclosing block of code to see if it has an associated exception
    handler. If so, it exits that block of code and starts running the exception-handling
    code associated with the block. After running the exception handler, the interpreter
    continues execution at the statement immediately following the handler code.
  prefs: []
  type: TYPE_NORMAL
- en: If the enclosing block of code does not have an appropriate exception handler,
    the interpreter checks the next higher enclosing block of code in the method.
    This continues until a handler is found. If the method does not contain an exception
    handler that can handle the exception thrown by the `throw` statement, the interpreter
    stops running the current method and returns to the caller. Now the interpreter
    starts looking for an exception handler in the blocks of code of the calling method.
    In this way, exceptions propagate up through the lexical structure of Java methods,
    up the call stack of the Java interpreter. If the exception is never caught, it
    propagates all the way up to the `main()` method of the program. If it is not
    handled in that method, the Java interpreter prints an error message, prints a
    stack trace to indicate where the exception occurred, and then exits.
  prefs: []
  type: TYPE_NORMAL
- en: The try/catch/finally Statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Java has two slightly different exception-handling mechanisms. The classic form
    is the `try/catch/finally` statement. The `try` clause of this statement establishes
    a block of code for exception handling. This `try` block is followed by zero or
    more `catch` clauses, each of which is a block of statements designed to handle
    specific exceptions. Each `catch` block can handle more than one different exception—to
    indicate that a `catch` block should handle multiple exceptions, we use the `|`
    symbol to separate the different exceptions a `catch` block should handle. The
    `catch` clauses are followed by an optional `finally` block that contains cleanup
    code guaranteed to be executed regardless of what happens in the `try` block.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code illustrates the syntax and purpose of the `try/catch/finally`
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: try
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `try` clause simply establishes a block of code that either has its exceptions
    handled or needs special cleanup code to be run when it terminates for any reason.
    The `try` clause by itself doesn’t do anything interesting; it is the `catch`
    and `finally` clauses that do the exception-handling and cleanup operations.
  prefs: []
  type: TYPE_NORMAL
- en: catch
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `try` block can be followed by zero or more `catch` clauses that specify code
    to handle various types of exceptions. Each `catch` clause is declared with a
    single argument that specifies the types of exceptions the clause can handle (possibly
    using the special `|` syntax to indicate that the `catch` block can handle more
    than one type of exception) and also provides a name the clause can use to refer
    to the exception object it is currently handling. Any type that a `catch` block
    wishes to handle must be some subclass of `Throwable`.
  prefs: []
  type: TYPE_NORMAL
- en: When an exception is thrown, the Java interpreter looks for a `catch` clause
    with an argument that matches the same type as the exception object or a superclass
    of that type. The interpreter invokes the first such `catch` clause it finds.
    The code within a `catch` block should take whatever action is necessary to cope
    with the exceptional condition. If the exception is a `java.io.FileNotFoundException`,
    for example, you might handle it by asking the user to check their spelling and
    try again.
  prefs: []
  type: TYPE_NORMAL
- en: It is not required to have a `catch` clause for every possible exception; in
    some cases, the correct response is to allow the exception to propagate up and
    be caught by the invoking method. In other cases, such as a programming error
    signaled by `NullPointerException`, the correct response is probably not to catch
    the exception at all but allow it to propagate and have the Java interpreter exit
    with a stack trace and an error message.
  prefs: []
  type: TYPE_NORMAL
- en: finally
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `finally` clause is generally used to clean up after the code in the `try`
    clause (e.g., close files and shut down network connections). The `finally` clause
    is useful because it is guaranteed to be executed if any portion of the `try`
    block is executed, regardless of how the code in the `try` block completes. In
    fact, the only way a `try` clause can exit without allowing the `finally` clause
    to be executed is by invoking the `System.exit()` method, which causes the Java
    interpreter to stop running.
  prefs: []
  type: TYPE_NORMAL
- en: In the normal case, control reaches the end of the `try` block and then proceeds
    to the `finally` block, which performs any necessary cleanup. If control leaves
    the `try` block because of a `return`, `continue`, or `break` statement, the `finally`
    block is executed before control transfers to its new destination.
  prefs: []
  type: TYPE_NORMAL
- en: If an exception occurs in the `try` block and there is an associated `catch`
    block to handle the exception, control transfers first to the `catch` block and
    then to the `finally` block. If there is no local `catch` block to handle the
    exception, control transfers first to the `finally` block, and then propagates
    up to the nearest containing `catch` clause that can handle the exception.
  prefs: []
  type: TYPE_NORMAL
- en: If a `finally` block itself transfers control with a `return`, `continue`, `break`,
    or `throw` statement or by calling a method that throws an exception, the pending
    control transfer is abandoned, and this new transfer is processed. For example,
    if a `finally` clause throws an exception, that exception replaces any exception
    that was in the process of being thrown. If a `finally` clause issues a `return`
    statement, the method returns normally, even if an exception has been thrown and
    has not yet been handled.
  prefs: []
  type: TYPE_NORMAL
- en: '`try` and `finally` can be used together without exceptions or any `catch`
    clauses. In this case, the `finally` block is simply cleanup code that is guaranteed
    to be executed, regardless of any `break`, `continue`, or `return` statements
    within the `try` clause.'
  prefs: []
  type: TYPE_NORMAL
- en: The try-with-resources Statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The standard form of a `try` block is very general, but there is a common set
    of circumstances that require developers to be very careful when writing `catch`
    and `finally` blocks. These circumstances are when operating with resources that
    need to be cleaned up or closed when they are no longer needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Java provides a very useful mechanism for automatically closing resources that
    require cleanup. This is known as *try-with-resources*, or TWR. We discuss TWR
    in detail in [“Classic Java I/O”](ch10.xhtml#javanut8-CHP-10-SECT-1), but for
    completeness, let’s introduce the syntax now. The following example shows how
    to open a file using the `FileInputStream` class (which results in an object that
    will require cleanup):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: This new form of `try` takes parameters that are all objects that require cleanup.^([2](ch02.xhtml#idm45927754904640))
    These objects are scoped to this `try` block and are then cleaned up automatically
    no matter how this block is exited. The developer does not need to write any `catch`
    or `finally` blocks—the Java compiler automatically inserts correct cleanup code.
  prefs: []
  type: TYPE_NORMAL
- en: All new code that deals with resources should be written in the TWR style—it
    is considerably less error prone than manually writing `catch` blocks and does
    not suffer from the problems that plague techniques such as finalization (see
    [“Finalization”](ch06.xhtml#javanut8-CHP-6-SECT-4) for details).
  prefs: []
  type: TYPE_NORMAL
- en: The assert Statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An `assert` statement is an attempt to provide a capability to verify design
    assumptions in Java code. An *assertion* consists of the `assert` keyword followed
    by a boolean expression that the programmer believes should always evaluate to
    `true`. By default, assertions are not enabled, and the `assert` statement does
    not actually do anything.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to enable assertions as a debugging tool, however; when this
    is done, the `assert` statement evaluates the expression. If it is indeed `true`,
    `assert` does nothing. On the other hand, if the expression evaluates to `false`,
    the assertion fails, and the `assert` statement throws a `java.lang.AssertionError`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Outside of the core JDK libraries, the `assert` statement is *extremely* rarely
    used. It turns out to be too inflexible for testing most applications and is not
    often used by ordinary developers. Instead, developers use ordinary testing libraries,
    such as JUnit.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `assert` statement may include an optional second expression, separated
    from the first by a colon. When assertions are enabled and the first expression
    evaluates to `false`, the value of the second expression is taken as an error
    code or error message and is passed to the `AssertionError()` constructor. The
    full syntax of the statement is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: To use assertions effectively, you must also be aware of a couple of fine points.
    First, remember that your programs will normally run with assertions disabled
    and only sometimes with assertions enabled. This means that you should be careful
    not to write assertion expressions that contain side effects.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You should never throw `AssertionError` from your own code, as it may have unexpected
    results in future versions of the platform.
  prefs: []
  type: TYPE_NORMAL
- en: If an `AssertionError` is thrown, it indicates that one of the programmer’s
    assumptions has not held up. This means that the code is being used outside of
    the parameters for which it was designed, and it cannot be expected to work correctly.
    In short, there is no plausible way to recover from an `AssertionError`, and you
    should not attempt to catch it (unless you catch it at the top level simply so
    that you can display the error in a more user-friendly fashion).
  prefs: []
  type: TYPE_NORMAL
- en: Enabling assertions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For efficiency, it does not make sense to test assertions each time code is
    executed—`assert` statements encode assumptions that should always be true. Thus,
    by default, assertions are disabled, and `assert` statements have no effect. The
    assertion code remains compiled in the class files, however, so it can always
    be enabled for diagnostic or debugging purposes. You can enable assertions, either
    across the board or selectively, with command-line arguments to the Java interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable assertions in all classes except for system classes, use the `-ea`
    argument. To enable assertions in system classes, use `-esa`. To enable assertions
    within a specific class, use `-ea` followed by a colon and the class name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'To enable assertions for all classes in a package and in all of its subpackages,
    follow the `-ea` argument with a colon, the package name, and three dots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'You can disable assertions in the same way, using the `-da` argument. For example,
    to enable assertions throughout a package and then disable them in a specific
    class or subpackage, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: Finally, it is possible to control whether or not assertions are enabled or
    disabled at classloading time. If you use a custom classloader (see [Chapter 11](ch11.xhtml#javanut8-CHP-11)
    for details on custom classloading) in your program and want to turn on assertions,
    you may be interested in these methods.
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A *method* is a named sequence of Java statements that can be invoked by other
    Java code. When a method is invoked, it is passed zero or more values known as
    *arguments*. The method performs some computations and, optionally, returns a
    value. As described earlier in [“Expressions and Operators”](#javanut8-CHP-2-SECT-4),
    a method invocation is an expression that is evaluated by the Java interpreter.
    Because method invocations can have side effects, however, they also can be used
    as expression statements. This section does not discuss method invocation but
    instead describes how to define methods.
  prefs: []
  type: TYPE_NORMAL
- en: Defining Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You already know how to define the body of a method; it is simply an arbitrary
    sequence of statements enclosed within curly braces. What is more interesting
    about a method is its *signature*.^([3](ch02.xhtml#idm45927754603040)) The signature
    specifies:'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number, order, type, and name of the parameters used by the method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type of the value returned by the method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The checked exceptions that the method can throw (the signature may also list
    unchecked exceptions, but these are not required)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various method modifiers that provide additional information about the method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A method signature defines everything you need to know about a method before
    calling it. It is the method *specification* and defines the API for the method.
    To use the Java platform’s online API reference, you need to know how to read
    a method signature. And, to write Java programs, you need to know how to define
    your own methods, each of which begins with a method signature.
  prefs: []
  type: TYPE_NORMAL
- en: 'A method signature looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: The signature (the method specification) is followed by the method body (the
    method implementation), which is simply a sequence of Java statements enclosed
    in curly braces. If the method is *abstract* (see [Chapter 3](ch03.xhtml#javanut8-CHP-3)),
    the implementation is omitted, and the method body is replaced with a single semicolon.
  prefs: []
  type: TYPE_NORMAL
- en: The signature of a method may also include type variable declarations—such methods
    are known as *generic methods*. Generic methods and type variables are discussed
    in [Chapter 4](ch04.xhtml#javanut8-CHP-4).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some example method definitions, which begin with the signature and
    are followed by the method body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '*`modifiers`* are zero or more special modifier keywords, separated from each
    other by spaces. A method might be declared with the `public` and `static` modifiers,
    for example. The allowed modifiers and their meanings are described in the next
    section.'
  prefs: []
  type: TYPE_NORMAL
- en: The *`type`* in a method signature specifies the return type of the method.
    If the method does not return a value, *`type`* must be `void`. If a method is
    declared with a non-`void` return type, it must include a `return` statement that
    returns a value of (or is convertible to) the declared type.
  prefs: []
  type: TYPE_NORMAL
- en: A *constructor* is a block of code, similar to a method, that is used to initialize
    newly created objects. As we’ll see in [Chapter 3](ch03.xhtml#javanut8-CHP-3),
    constructors are defined in a very similar way to methods, except that their signatures
    do not include this *`type`* specification and must be named the same as the class.
  prefs: []
  type: TYPE_NORMAL
- en: The *`name`* of a method follows the specification of its modifiers and type.
    Method names, like variable names, are Java identifiers and, like all Java identifiers,
    may contain letters in any language represented by the Unicode character set.
    It is legal, and often quite useful, to define more than one method with the same
    name, as long as each version of the method has a different parameter list. Defining
    multiple methods with the same name is called *method overloading*.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Unlike some other languages, Java does not have anonymous methods. Instead,
    Java 8 introduces lambda expressions, which are similar to anonymous methods,
    but which the Java runtime automatically converts to a suitable named method—see
    [“Lambda Expressions”](#javanut8-CHP-2-SECT-7.5a) for more details.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the `System.out.println()` method we’ve seen already is an overloaded
    method. One method by this name prints a string, and other methods by the same
    name print the values of the various primitive types. The Java compiler decides
    which method to call based on the type of the argument passed to the method.
  prefs: []
  type: TYPE_NORMAL
- en: When you are defining a method, the name of the method is always followed by
    the method’s parameter list, which must be enclosed in parentheses. The parameter
    list defines zero or more arguments that are passed to the method. The parameter
    specifications, if there are any, each consist of a type and a name and the specifications
    are separated from each other by commas (if there are multiple parameters). When
    a method is invoked, the argument values it is passed must match the number, type,
    and order of the parameters specified in this method signature line. The values
    passed need not have exactly the same type as specified in the signature, but
    they must be convertible to those types without casting.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When a Java method expects no arguments, its parameter list is simply `()`,
    not `(void)`. Java does not regard `void` as a type—C and C++ programmers in particular
    should pay heed.
  prefs: []
  type: TYPE_NORMAL
- en: Java allows the programmer to define and invoke methods that accept a variable
    number of arguments, using a syntax known colloquially as *varargs*. Varargs are
    covered in detail later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The final part of a method signature is the `throws` clause, which is used to
    list the *checked exceptions* that a method can throw. Checked exceptions are
    a category of exception classes that must be listed in the `throws` clauses of
    methods that can throw them.
  prefs: []
  type: TYPE_NORMAL
- en: If a method uses the `throw` statement to throw a checked exception, the method
    must declare that it can throw that exception. The method must also declare that
    it can throw in the case that it calls some other method that throws a checked
    exception, and the calling method does not explicitly catch that exception.
  prefs: []
  type: TYPE_NORMAL
- en: If a method can throw one or more checked exceptions, it specifies this by placing
    the `throws` keyword after the argument list and following it by the name of the
    exception class or classes it can throw. If a method does not throw any checked
    exceptions, it does not use the `throws` keyword. If a method throws more than
    one type of checked exception, separate the names of the exception classes from
    each other with commas. More on this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: Method Modifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The modifiers of a method consist of zero or more modifier keywords such as
    `public`, `static`, or `abstract`. Here is a list of allowed modifiers and their
    meanings:'
  prefs: []
  type: TYPE_NORMAL
- en: '`abstract`'
  prefs: []
  type: TYPE_NORMAL
- en: An `abstract` method is a specification without an implementation. The curly
    braces and Java statements that would normally comprise the body of the method
    are replaced with a single semicolon. A class that includes an `abstract` method
    must itself be declared `abstract`. Such a class is incomplete and cannot be instantiated
    (see [Chapter 3](ch03.xhtml#javanut8-CHP-3)).
  prefs: []
  type: TYPE_NORMAL
- en: '`default`'
  prefs: []
  type: TYPE_NORMAL
- en: A `default` method may be defined only on an interface. All classes implementing
    the interface receive the default method unless they override it directly. Implementing
    interfaces in classes is explored thoroughly in [Chapter 3](ch03.xhtml#javanut8-CHP-3).
  prefs: []
  type: TYPE_NORMAL
- en: '`final`'
  prefs: []
  type: TYPE_NORMAL
- en: A `final` method may not be overridden or hidden by a subclass, which makes
    it amenable to compiler optimizations that are not possible for regular methods.
    All `private` methods are implicitly `final`, as are all methods of any class
    that is declared `final`.
  prefs: []
  type: TYPE_NORMAL
- en: '`native`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `native` modifier specifies that the method implementation is written in
    some “native” language such as C and is provided externally to the Java program.
    Like `abstract` methods, `native` methods have no body: the curly braces are replaced
    with a semicolon.'
  prefs: []
  type: TYPE_NORMAL
- en: '`public`, `protected`, `private`'
  prefs: []
  type: TYPE_NORMAL
- en: These access modifiers specify whether and where a method can be used outside
    of the class that defines it. These very important modifiers are explained in
    [Chapter 3](ch03.xhtml#javanut8-CHP-3).
  prefs: []
  type: TYPE_NORMAL
- en: '`static`'
  prefs: []
  type: TYPE_NORMAL
- en: A method declared `static` is a *class method* associated with the class itself
    rather than with an instance of the class (we cover this in more detail in [Chapter 3](ch03.xhtml#javanut8-CHP-3)).
  prefs: []
  type: TYPE_NORMAL
- en: '`strictfp`'
  prefs: []
  type: TYPE_NORMAL
- en: The `fp` in this awkwardly named, rarely used modifier stands for “floating
    point.” For performance reasons, in Java 1.2 the language allowed for subtle deviation
    from the strict IEEE-754 standard when using certain floating-point acceleration
    hardware. The `strictfp` keyword was added to force Java to strictly obey the
    standard. These hardware considerations haven’t been relevant for many years,
    so Java 17 returns the default to the IEEE standard. Use of the `strictfp` keyword
    will emit a warning, as it is no longer necessary.
  prefs: []
  type: TYPE_NORMAL
- en: '`synchronized`'
  prefs: []
  type: TYPE_NORMAL
- en: The `synchronized` modifier makes a method threadsafe. Before a thread can invoke
    a `synchronized` method, it must obtain a lock on the method’s class (for `static`
    methods) or on the relevant instance of the class (for non-`static` methods).
    This prevents two threads from executing the method at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: The `synchronized` modifier is an implementation detail (because methods can
    make themselves threadsafe in other ways) and is not formally part of the method
    specification or API. Good documentation specifies explicitly whether a method
    is threadsafe; you should not rely on the presence or absence of the `synchronized`
    keyword when working with multithreaded programs.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Annotations are an interesting special case (see [Chapter 4](ch04.xhtml#javanut8-CHP-4)
    for more on annotations)—they can be thought of as a halfway house between a method
    modifier and additional supplementary type information.
  prefs: []
  type: TYPE_NORMAL
- en: Checked and Unchecked Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Java exception-handling scheme distinguishes between two types of exceptions,
    known as *checked* and *unchecked* exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: The distinction between checked and unchecked exceptions has to do with the
    circumstances under which the exceptions could be thrown. Checked exceptions arise
    in specific, well-defined circumstances, and very often are conditions from which
    the application may be able to partially or fully recover.
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider some code that might find its configuration file in one
    of several possible directories. If we attempt to open the file from a directory
    it isn’t present in, then a `FileNotFoundException` will be thrown. In our example,
    we want to catch this exception and move on to try the next possible location
    for the file. In other words, although the file not being present is an exceptional
    condition, it is one from which we can recover, and it is an understood and anticipated
    failure.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, in the Java environment there are a set of failures that
    cannot easily be predicted or anticipated, due to such things as runtime conditions
    or abuse of library code. There is no good way to predict an `OutOfMemoryError`,
    for example, and any method that uses objects or arrays can throw a `NullPointerException`
    if it is passed an invalid `null` argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the unchecked exceptions—and practically any method can throw an
    unchecked exception at essentially any time. They are the Java environment’s version
    of Murphy’s law: “Anything that can go wrong, will go wrong.” Recovery from an
    unchecked exception is usually very difficult, if not impossible—simply due to
    their sheer unpredictability.'
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether an exception is checked or unchecked, remember that exceptions
    are `Throwable` objects and that these fall into two main categories, specified
    by the `Error` and `Exception` subclasses. Any exception object that is an `Error`
    is unchecked. There is also a subclass of `Exception` called `RuntimeException`—and
    any subclass of `RuntimeException` is also an unchecked exception. All other exceptions
    are checked exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Working with checked exceptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Java has different rules for working with checked and unchecked exceptions.
    If you write a method that throws a checked exception, you must use a `throws`
    clause to declare the exception in the method signature. The Java compiler checks
    to make sure you have declared them in method signatures and produces a compilation
    error if you have not (that’s why they’re called “checked exceptions”).
  prefs: []
  type: TYPE_NORMAL
- en: Even if you never throw a checked exception yourself, sometimes you must use
    a `throws` clause to declare a checked exception. If your method calls a method
    that can throw a checked exception, you must either include exception-handling
    code to handle that exception or use `throws` to declare that your method can
    also throw that exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following method tries to estimate the size of a web page—it
    uses the standard `java.net` libraries and the class `URL` (we’ll meet these in
    [Chapter 10](ch10.xhtml#javanut8-CHP-10)) to contact the web page. It uses methods
    and constructors that can throw various types of `java.io.IOException` objects,
    so it declares this fact with a `throws` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, the preceding code has a bug: we’ve misspelled the protocol specifier—there’s
    no such protocol as *htp://*. So, the `estimateHomepageSize()` method will always
    fail with a `MalformedURLException`.'
  prefs: []
  type: TYPE_NORMAL
- en: How do you know if the method you are calling can throw a checked exception?
    You can look at its method signature to find out. Or, failing that, the Java compiler
    will tell you (by reporting a compilation error) if you’ve called a method whose
    exceptions you must handle or declare.
  prefs: []
  type: TYPE_NORMAL
- en: Variable-Length Argument Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Methods may be declared to accept, and may be invoked with, variable numbers
    of arguments. Such methods are commonly known as *varargs* methods. The “print
    formatted” method `System.out.printf()` as well as the related `format()` methods
    of `String` use varargs, as do a number of important methods from the Reflection
    API of `java.lang.reflect`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To declare a variable-length argument list, follow the type of the last argument
    to the method with an ellipsis (`...`), indicating that this last argument can
    be repeated zero or more times. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'Varargs methods are handled purely by the compiler. They operate by converting
    the variable number of arguments into an array. To the Java runtime, the `max()`
    method is indistinguishable from this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: To convert a varargs signature to the “real” signature, simply replace `...`
    with `[ ]`. Remember that only one ellipsis can appear in a parameter list, and
    it may only appear on the last parameter in the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s flesh out the `max()` example a little:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'This `max()` method is declared with two arguments. The first is just a regular
    `int` value. The second, however, may be repeated zero or more times. All of the
    following are legal invocations of `max()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Because varargs methods are compiled into methods that expect an array of arguments,
    invocations of those methods are compiled to include code that creates and initializes
    such an array. So the call `max(1,2,3)` is compiled to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, if you already have method arguments stored in an array, it is perfectly
    legal for you to pass them to the method that way, instead of writing them out
    individually. You can treat any `...` argument as if it were declared as an array.
    The converse is not true, however: you can use varargs method invocation syntax
    only when the method is actually declared as a varargs method using an ellipsis.'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Classes and Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have introduced operators, expressions, statements, and methods,
    we can finally talk about classes. A *class* is a named collection of fields that
    holds data values and methods that operate on those values. Classes are just one
    of five reference types supported by Java, but they are the most important type.
    Classes are thoroughly documented in a chapter of their own ([Chapter 3](ch03.xhtml#javanut8-CHP-3)).
    We introduce them here, however, because they are the next higher level of syntax
    after methods, and because the rest of this chapter requires a basic familiarity
    with the concept of a class and the basic syntax for defining a class, instantiating
    it, and using the resulting *object*.
  prefs: []
  type: TYPE_NORMAL
- en: The most important thing about classes is that they define new data types. For
    example, you might define a class named `Account` to represent a bank account
    that holds a balance. The class would define fields to hold data items such as
    the balance (perhaps represented as a `double`), account holder’s name and address
    (as `String` instances) and methods to manipulate and operate on the account.
    The `Account` class is a new data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'When discussing data types, it is important to distinguish between the data
    type itself and the values the data type represents. `char` is a data type: it
    represents Unicode characters. But a `char` value represents a single specific
    character. A class is a data type; a class value is called an *object*. We use
    the name class because each class defines a type (or kind, or species, or class)
    of objects. The `Account` class is a data type that represents bank accounts,
    while an `Account` object represents a single specific account. As you might imagine,
    classes and their objects are closely linked. In the sections that follow, we
    will discuss both.'
  prefs: []
  type: TYPE_NORMAL
- en: Defining a Class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is a possible definition of the `Account` class we have been discussing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: This class definition is stored in a file named *Account.java* and compiled
    to a file named *Account.class*, where it is available for use by Java programs
    and other classes. This class definition is provided here for completeness and
    to provide context, but don’t expect to understand all the details just yet; most
    of [Chapter 3](ch03.xhtml#javanut8-CHP-3) is devoted to the topic of defining
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that you don’t have to define every class you want to use in a
    Java program. The Java platform includes thousands of predefined classes that
    are guaranteed to be available on every computer that runs that given version
    of Java.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have defined the `Account` class as a new data type, we can use
    the following line to declare a variable that holds an `Account` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'Declaring a variable to hold an `Account` object does not create the object
    itself, however. To actually create an object, you must use the `new` operator.
    This keyword is followed by the object’s class (i.e., its type) and an optional
    argument list in parentheses. These arguments are passed to the constructor for
    the class, which initializes internal fields in the new object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: The `new` keyword is by far the most common way to create objects in Java. A
    few other ways are also worth mentioning. First, classes that meet certain criteria
    are so important that Java defines special literal syntax for creating objects
    of those types (as we discuss later in this section). Second, Java supports a
    mechanism that allows programs to load classes and create instances of those classes
    dynamically. See [Chapter 11](ch11.xhtml#javanut8-CHP-11) for more details. Finally,
    objects can also be created by deserializing them. An object that has had its
    state saved, or serialized, usually to a file, can be recreated using the `java.io.ObjectInputStream`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Using an Object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we’ve seen how to define classes and instantiate them by creating
    objects, we need to look at the Java syntax that allows us to use those objects.
    Recall that a class defines a collection of fields and methods. Each object has
    its own copies of those fields and has access to those methods. We use the dot
    character (.) to access the named fields and methods of an object. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: This syntax is very common when programming in object-oriented languages, and
    Java is no exception. Note, in particular, the expression `a.toString()`. This
    tells the Java compiler to look up a method named `toString` (which is defined
    by the parent `Object` class of `Account`) and use that method to perform a computation
    on the object `a`. We’ll cover the details of this operation in [Chapter 3](ch03.xhtml#javanut8-CHP-3).
  prefs: []
  type: TYPE_NORMAL
- en: Object Literals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our discussion of primitive types, we saw that each primitive type has a
    literal syntax for including values of the type literally into the text of a program.
    Java also defines a literal syntax for a few special reference types, as described
    next.
  prefs: []
  type: TYPE_NORMAL
- en: String literals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `String` class represents text as a string of characters. Because programs
    usually communicate with their users through the written word, the ability to
    manipulate strings of text is quite important in any programming language. In
    Java, strings are objects; the data type used to represent text is the `String`
    class. Modern Java programs usually use more string data than anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Accordingly, because strings are such a fundamental data type, Java allows you
    to include text literally in programs in one of two formats. Traditional strings
    are placed between double-quote (`"`) characters, or a newer text block form may
    be used between sequences of three double-quote characters (`"""`).
  prefs: []
  type: TYPE_NORMAL
- en: 'A traditional double-quoted string looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: Don’t confuse the double-quote characters that surround string literals with
    the single-quote (or apostrophe) characters that surround `char` literals.
  prefs: []
  type: TYPE_NORMAL
- en: 'String literals of either form can contain any of the escape sequences `char`
    literals can (see [Table 2-2](#javanut8-CHP-2-TABLE-2)). Traditional double-quoted
    strings require escape sequences to embed double-quote characters or newlines.
    They also must consist of a single line in our Java code. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: The primary use for text blocks instead of traditional strings is representing
    multi-line strings. Text blocks start with `"""`, followed by a newline, and end
    when a concluding `"""` is reached.
  prefs: []
  type: TYPE_NORMAL
- en: Along with their support for multiline strings, text blocks also allow us to
    use double quotes without escaping. This often makes text blocks much easier to
    read, particularly when expressing another programming language (such as SQL or
    HTML) in our Java code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: Examining the output from this code reveals one more interesting fact about
    text blocks regarding indentation. The above prints with `<html>` in the first
    column of the output with no leading spaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler finds the smallest indentation across the lines of our text block
    and strips that many leading spaces from each line. If this is not desired, the
    placement of the closing `"""` also participates in choosing the indent. We could
    retain the full white space with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: Before text blocks were introduced in Java, it was common to break up string
    literals for easier reading using `+` to concatenate them. Along with existing
    in many code bases, this remains a valid technique if your string shouldn’t include
    newlines.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: Literals, whether traditional or text blocks, are concatenated when your program
    is compiled, not when it is run, so you do not need to worry about any kind of
    performance penalty.
  prefs: []
  type: TYPE_NORMAL
- en: Type literals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The second type that supports its own special object literal syntax is the
    class named `Class`. Instances of the `Class` class represent a Java data type
    and contain metadata about the type that is referred to. To include a `Class`
    object literally in a Java program, follow the name of any data type with `.class`.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: The null reference
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `null` keyword is a special literal value that is a reference to nothing,
    or an absence of a reference. The `null` value is unique because it is a member
    of every reference type. You can assign `null` to variables of any reference type.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: Lambda Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Java 8 introduced a major new feature—*lambda expressions*. These are a very
    common programming language construct and in particular are extremely widely used
    in the family of languages known as *functional programming languages* (e.g.,
    Lisp, Haskell, and OCaml). The power and flexibility of lambdas goes far beyond
    just functional languages, and they can be found in almost all modern programming
    languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for a lambda expression looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'One simple, very traditional example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: When a lambda expression is used as a value, it is automatically converted to
    a new object of the correct type for the variable it is being placed into. This
    autoconversion and *type inference* is essential to Java’s approach to lambda
    expressions. Unfortunately, it relies on a proper understanding of Java’s type
    system as a whole. [“Nested Types”](ch04.xhtml#javanut8-CHP-4-SECT-5) provides
    a more detailed explanation of lambda expressions—so for now, it suffices to simply
    recognize the syntax for lambdas.
  prefs: []
  type: TYPE_NORMAL
- en: 'A slightly more complex example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An *array* is a special kind of object that holds zero or more primitive values
    or references. These values are held in the *elements* of the array, which are
    unnamed variables referred to by their position or *index*. The type of an array
    is characterized by its *element type*, and all elements of the array must be
    of that type.
  prefs: []
  type: TYPE_NORMAL
- en: Array elements are numbered starting with zero, and valid indexes range from
    zero to the number of elements minus one. The array element with index 1, for
    example, is the *second* element in the array. The number of elements in an array
    is its *length*. The length of an array is specified when the array is created,
    and it never changes (unlike Java collections, which we’ll see in [Chapter 8](ch08.xhtml#javanut8-CHP-8)).
  prefs: []
  type: TYPE_NORMAL
- en: The element type of an array may be any valid Java type, including array types.
    This means that Java supports arrays of arrays, which provide a kind of multidimensional
    array capability. Java does not support the matrix-style multidimensional arrays
    found in some languages.
  prefs: []
  type: TYPE_NORMAL
- en: While Java’s Collection API, covered thoroughly in [Chapter 8](ch08.xhtml#javanut8-CHP-8),
    is often more flexible and feature-rich than basic arrays, arrays remain common
    throughout the platform and it’s worth understanding the details of using them.
  prefs: []
  type: TYPE_NORMAL
- en: Array Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Array types are reference types, just as classes are. Instances of arrays are
    objects, just as the instances of a class are.^([4](ch02.xhtml#idm45927752917984))
    Unlike classes, array types do not have to be defined. Simply place square brackets
    after the element type. For example, the following code declares three variables
    of array type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: The length of an array is not part of the array type. It is not possible, for
    example, to declare a method that expects an array of exactly four `int` values.
    If a method parameter is of type `int[]`, a caller can pass an array with any
    number (including zero) of elements.
  prefs: []
  type: TYPE_NORMAL
- en: Array types are not classes, but array instances are objects. This means that
    arrays inherit the methods of `java.lang.Object`. Arrays implement the `Cloneable`
    interface and override the `clone()` method to guarantee that an array can always
    be cloned and that `clone()` never throws a `CloneNotSupportedException`. Arrays
    also implement `Serializable` so that any array can be serialized if its element
    type can be serialized. Finally, all arrays have a `public final int` field named
    `length` that specifies the number of elements in the array.
  prefs: []
  type: TYPE_NORMAL
- en: Array type widening conversions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Because arrays extend `Object` and implement the `Cloneable` and `Serializable`
    interfaces, any array type can be widened to any of these three types. But certain
    array types can also be widened to other array types. If the element type of an
    array is a reference type `T`, and `T` is assignable to a type `S`, the array
    type `T[]` is assignable to the array type `S[]`. Note that there are no widening
    conversions of this sort for arrays of a given primitive type. As examples, the
    following lines of code show legal array widening conversions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: This ability to widen an array type to another array type means that the compile-time
    type of an array is not always the same as its runtime type.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This widening is known as *array covariance*, and as we shall see in [“Bounded
    Type Parameters”](ch04.xhtml#javanut8-CHP-4-SECT-2.5), it is regarded by modern
    standards as a historical artifact and a misfeature, because of the mismatch between
    compile and runtime typing that it exposes.
  prefs: []
  type: TYPE_NORMAL
- en: The compiler must usually insert runtime checks before any operation that stores
    a reference value into an array element to ensure that the runtime type of the
    value matches the runtime type of the array element. An `ArrayStoreException`
    is thrown if the runtime check fails.
  prefs: []
  type: TYPE_NORMAL
- en: C compatibility syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we’ve seen, you write an array type simply by placing brackets after the
    element type. For compatibility with C and C++, however, Java supports an alternative
    syntax in variable declarations: brackets may be placed after the name of the
    variable instead of, or in addition to, the element type. This applies to local
    variables, fields, and method parameters. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This compatibility syntax is extremely uncommon, and you should not use it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and Initializing Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create an array value in Java, you use the `new` keyword, just as you do
    to create an object. Array types don’t have constructors, but you are required
    to specify a length whenever you create an array. Specify the desired size of
    your array as a nonnegative integer between square brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'When you create an array with this syntax, each of the array elements is automatically
    initialized to the same default value that is used for the fields of a class:
    `false` for `boolean` elements, `\u0000` for `char` elements, `0` for integer
    elements, `0.0` for floating-point elements, and `null` for elements of reference
    type.'
  prefs: []
  type: TYPE_NORMAL
- en: Array creation expressions can also be used to create and initialize a multidimensional
    array of arrays. This syntax is somewhat more complicated and is explained later
    in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Array initializers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To create an array and initialize its elements in a single expression, omit
    the array length and follow the square brackets with a comma-separated list of
    expressions within curly braces. The type of each expression must be assignable
    to the element type of the array, of course. The length of the array that is created
    is equal to the number of expressions. It is legal, but not necessary, to include
    a trailing comma following the last expression in the list. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this syntax allows arrays to be created, initialized, and used without
    ever being assigned to a variable. In a sense, these array creation expressions
    are anonymous array literals. Here are examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'When an array initializer is part of a variable declaration, you may omit the
    `new` keyword and element type and list the desired array elements within curly
    braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'Array literals are created and initialized when the program is run, not when
    the program is compiled. Consider the following array literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'This is compiled into Java bytecodes that are equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'The fact that Java does all array initialization at runtime has an important
    corollary. It means that the expressions in an array initializer may be computed
    at runtime and need not be compile-time constants. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: Using Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once an array has been created, you are ready to start using it. The following
    sections explain basic access to the elements of an array and cover common idioms
    of array usage, such as iterating through the elements of an array and copying
    an array or part of an array.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing array elements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The elements of an array are variables. When an array element appears in an
    expression, it evaluates to the value held in the element. And when an array element
    appears on the lefthand side of an assignment operator, a new value is stored
    into that element. Unlike a normal variable, however, an array element has no
    name, only a number. Array elements are accessed using a square bracket notation.
    If `a` is an expression that evaluates to an array reference, you index that array
    and refer to a specific element with `a[i]`, where `i` is an integer literal or
    an expression that evaluates to an `int`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'The array index expression must be of type `int`, or a type that can be widened
    to an `int`: `byte`, `short`, or even `char`. It is obviously not legal to index
    an array with a `boolean`, `float`, or `double` value. Remember that the `length`
    field of an array is an `int` and that arrays may not have more than `Integer.MAX_VALUE`
    elements. Indexing an array with an expression of type `long` generates a compile-time
    error, even if the value of that expression at runtime would be within the range
    of an `int`.'
  prefs: []
  type: TYPE_NORMAL
- en: Array bounds
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that the first element of an array `a` is `a[0]` , the second element
    is `a[1]`, and the last is `a[a.length-1]`.
  prefs: []
  type: TYPE_NORMAL
- en: A common bug involving arrays is use of an index that is too small (a negative
    index) or too large (greater than or equal to the array `length`). In languages
    like C or C++, accessing elements before the beginning or after the end of an
    array yields unpredictable behavior that can vary from invocation to invocation
    and platform to platform. Such bugs may not always be caught, and if a failure
    occurs, it may be at some later time. While it is just as easy to write faulty
    array indexing code in Java, Java guarantees predictable results by checking every
    array access at runtime. If an array index is too small or too large, Java immediately
    throws an `ArrayIndexOutOfBoundsException`.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is common to write loops that iterate through each of the elements of an
    array in order to perform some operation on it. This is typically done with a
    `for` loop. The following code, for example, computes the sum of an array of integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'The structure of this `for` loop is idiomatic, and you’ll see it frequently.
    Java also has the foreach syntax that we’ve already met. The summing code could
    be rewritten succinctly as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: Copying arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All array types implement the `Cloneable` interface, and any array can be copied
    by invoking its `clone()` method. Note that a cast is required to convert the
    return value to the appropriate array type, but the `clone()` method of arrays
    is guaranteed not to throw a `CloneNotSupportedException`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: The `clone()` method makes a shallow copy. If the element type of the array
    is a reference type, only the references are copied, not the referenced objects
    themselves. Because the copy is shallow, any array can be cloned, even if the
    element type is not itself `Cloneable`.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes you simply want to copy elements from one existing array to another
    existing array. The `System.arraycopy()` method is designed to do this efficiently,
    and you can assume that Java VM implementations perform this method using high-speed
    block copy operations on the underlying hardware.
  prefs: []
  type: TYPE_NORMAL
- en: '`arraycopy()` is a straightforward function that is difficult to use only because
    it has five arguments to remember. First, pass the source array from which elements
    are to be copied. Second, pass the index of the start element in that array. Pass
    the destination array and the destination index as the third and fourth arguments.
    Finally, as the fifth argument, specify the number of elements to be copied.'
  prefs: []
  type: TYPE_NORMAL
- en: '`arraycopy()` works correctly even for overlapping copies within the same array.
    For example, if you’ve “deleted” the element at index `0` from array `a` and want
    to shift the elements between indexes `1` and `n` down one so that they occupy
    indexes `0` through `n-1,` you could do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: Array utilities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `java.util.Arrays` class contains a number of static utility methods for
    working with arrays. Most of these methods are heavily overloaded, with versions
    for arrays of each primitive type and another version for arrays of objects.
  prefs: []
  type: TYPE_NORMAL
- en: The `sort()` and `binarySearch()` methods are particularly useful for sorting
    and searching arrays. The `equals()` method allows you to compare the content
    of two arrays. The `toString()` method is useful when you want to convert array
    content to a string, such as for debugging or logging output. `copyOf()` is a
    useful alternative to `arraycopy()` we’ve seen before if you’re ok with a new
    array being allocated rather than copying into an existing one.
  prefs: []
  type: TYPE_NORMAL
- en: The `Arrays` class also includes `deepEquals()`, `deepHashCode()`, and `deepToString()`
    methods that work correctly for multidimensional arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Multidimensional Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we’ve seen, an array type is written as the element type followed by a pair
    of square brackets. An array of `char` is `char[]`, and an array of arrays of
    `char` is `char[][]`. When the elements of an array are themselves arrays, we
    say that the array is *multidimensional*. In order to work with multidimensional
    arrays, you need to understand a few additional details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that you want to use a multidimensional array to represent a multiplication
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: Each of the pairs of square brackets represents one dimension, so this is a
    two-dimensional array. To access a single `int` element of this two-dimensional
    array, you must specify two index values, one for each dimension. Assuming that
    this array was actually initialized as a multiplication table, the `int` value
    stored at any given element would be the product of the two indexes. That is,
    `products[2][4]` would be 8, and `products[3][7]` would be 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new multidimensional array, use the `new` keyword and specify the
    size of both dimensions of the array. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: 'In some languages, an array like this would be created as a single block of
    100 `int` values. Java does not work this way. This line of code does three things:'
  prefs: []
  type: TYPE_NORMAL
- en: Declares a variable named `products` to hold an array of arrays of `int`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates a 10-element array to hold 10 arrays of `int`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates 10 more arrays, each of which is a 10-element array of `int`. It assigns
    each of these 10 new arrays to the elements of the initial array. The default
    value of every `int` element of each of these 10 new arrays is 0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To put this another way, the previous single line of code is equivalent to
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: 'The `new` keyword performs this additional initialization automatically for
    you. It works with arrays with more than two dimensions as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'When using `new` with multidimensional arrays, you do not have to specify a
    size for all dimensions of the array, only the leftmost dimension or dimensions.
    For example, the following two lines are legal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line creates a single-dimensional array, where each element of the
    array can hold a `float[][]`. The second line creates a two-dimensional array,
    where each element of the array is a `float[]`. If you specify a size for only
    some of the dimensions of an array, however, those dimensions must be the leftmost
    ones. The following lines are not legal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'Like a one-dimensional array, a multidimensional array can be initialized using
    an array initializer. Simply use nested sets of curly braces to nest arrays within
    arrays. For example, we can declare, create, and initialize a 5 × 5 multiplication
    table like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, if you want to use a multidimensional array without declaring a variable,
    you can use the anonymous initializer syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: 'When you create a multidimensional array using the `new` keyword, it is usually
    good practice to use only *rectangular* arrays: ones in which all the array values
    for a given dimension have the same size.'
  prefs: []
  type: TYPE_NORMAL
- en: Reference Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we’ve covered arrays and introduced classes and objects, we can turn
    to a more general description of *reference types*. Classes and arrays are two
    of Java’s five kinds of reference types. Classes were introduced earlier and are
    covered in complete detail, along with *interfaces*, in [Chapter 3](ch03.xhtml#javanut8-CHP-3).
    Enumerated types and annotation types are reference types introduced in [Chapter 4](ch04.xhtml#javanut8-CHP-4).
  prefs: []
  type: TYPE_NORMAL
- en: This section does not cover specific syntax for any particular reference type
    but instead explains the general behavior of reference types and illustrates how
    they differ from Java’s primitive types. In this section, the term *object* refers
    to a value or instance of any reference type, including arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Reference Versus Primitive Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Reference types and objects differ substantially from primitive types and their
    primitive values:'
  prefs: []
  type: TYPE_NORMAL
- en: Eight primitive types are defined by the Java language, and the programmer cannot
    define new primitive types.
  prefs: []
  type: TYPE_NORMAL
- en: Reference types are user-defined, so there is an unlimited number of them. For
    example, a program might define a class named `Account` and use objects of this
    newly defined type to store and track user bank accounts.
  prefs: []
  type: TYPE_NORMAL
- en: Primitive types represent single values.
  prefs: []
  type: TYPE_NORMAL
- en: Reference types are aggregate types that hold zero or more primitive values
    or objects. Our hypothetical `Account` class, for example, might hold a numeric
    value for the balance, along with identifiers for the account owner. The `char[]`
    and `Account[]` array types are aggregate types because they hold a sequence of
    primitive `char` values or `Account` objects.
  prefs: []
  type: TYPE_NORMAL
- en: Primitive types require between one and eight bytes of memory.
  prefs: []
  type: TYPE_NORMAL
- en: When a primitive value is stored in a variable or passed to a method, the computer
    makes a copy of the bytes that hold the value. Objects, on the other hand, may
    require substantially more memory. Memory to store an object is dynamically allocated
    on the heap when the object is created, and this memory is automatically “garbage
    collected” when the object is no longer needed.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When an object is assigned to a variable or passed to a method, the memory that
    represents the object is not copied. Instead, only a reference to that memory
    is stored in the variable or passed to the method.
  prefs: []
  type: TYPE_NORMAL
- en: References are completely opaque in Java and the representation of a reference
    is an implementation detail of the Java runtime. If you are a C programmer, however,
    you can safely imagine a reference as a pointer or a memory address. Remember,
    though, that Java programs cannot manipulate references in any way.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike pointers in C and C++, references cannot be converted to or from integers,
    and they cannot be incremented or decremented. C and C++ programmers should also
    note that Java does not support the `&` address-of operator or the `*` and `->`
    dereference operators.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating Objects and Reference Copies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following code manipulates a primitive `int` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: After these lines execute, the variable `y` contains a copy of the value held
    in the variable `x`. Inside the Java VM, there are two independent copies of the
    32-bit integer 42.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now think about what happens if we run the same basic code but use a reference
    type instead of a primitive type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: 'After this code runs, the variable `b` holds a copy of the reference held in
    the variable `a`. There is still only one copy of the `Account` object in the
    VM, but there are now two copies of the reference to that object. This has some
    important implications. Suppose the two previous lines of code are followed by
    this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the variables `a` and `b` hold references to the same object, either
    variable can be used to make changes to the object, and those changes are visible
    through the other variable as well. As arrays are a kind of object, the same thing
    happens with arrays, as illustrated by the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: 'A similar difference in behavior between primitive types and reference types
    occurs when arguments are passed to methods. Consider the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: When this method is invoked, the method is given a copy of the argument used
    to invoke the method in the parameter `x`. The code in the method uses `x` as
    a loop counter and decrements it to zero. Because `x` is a primitive type, the
    method has its own private copy of this value, so this is a perfectly reasonable
    thing to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, consider what happens if we modify the method so that the
    parameter is a reference type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: 'When this method is invoked, it is passed a private copy of a reference to
    a `Account` object and can use this reference to change the `Account` object.
    For example, consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: When the `changeReference()` method is invoked, it is passed a copy of the reference
    held in variable `a`. Now both the variable `a` and the method parameter `b` hold
    references to the same object. The method can use its reference to change the
    contents of the object. Note, however, that it cannot change the contents of the
    variable `a`. In other words, the method can change the `Account` object beyond
    recognition, but it cannot change the fact that the variable `a` refers to that
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ve seen that primitive types and reference types differ significantly in
    the way they are assigned to variables, passed to methods, and copied. The types
    also differ in the way they are compared for equality. When used with primitive
    values, the equality operator (`==`) simply tests whether two values are identical
    (i.e., whether they have exactly the same bits). With reference types, however,
    `==` compares references, not actual objects. In other words, `==` tests whether
    two references refer to the same object; it does not test whether two objects
    have the same content. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: 'When working with reference types, keep in mind there are two kinds of equality:
    equality of reference and equality of object. It is important to distinguish between
    these two kinds of equality. One way to do this is to use the word “identical”
    when talking about equality of references and the word “equal” when talking about
    two distinct objects that have the same content. To test two nonidentical objects
    for equality, pass one of them to the `equals()` method of the other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: All objects inherit an `equals()` method (from `Object`), but the default implementation
    simply uses `==` to test for identity of references, not equality of content.
    A class that wants to allow objects to be compared for equality can define its
    own version of the `equals()` method. Our `Account` class does not do this, but
    the `String` class does, as indicated in the code example. You can call the `equals()`
    method on an array, but it is the same as using the `==` operator, because arrays
    always inherit the default `equals()` method that compares references rather than
    array content. You can compare arrays for equality with the `java.util.Arrays.equals()`
    convenience method.
  prefs: []
  type: TYPE_NORMAL
- en: Boxing and Unboxing Conversions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Primitive types and reference types behave quite differently. It is sometimes
    useful to treat primitive values as objects, and for this reason, the Java platform
    includes *wrapper classes* for each of the primitive types. `Boolean`, `Byte`,
    `Short`, `Character`, `Integer`, `Long`, `Float`, and `Double` are immutable,
    final classes whose instances each hold a single primitive value. These wrapper
    classes are usually used when you want to store primitive values in collections
    such as `java.util.List`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: Java allows types of conversions known as boxing and unboxing conversions. Boxing
    conversions convert a primitive value to its corresponding wrapper object and
    unboxing conversions do the opposite. You may explicitly specify a boxing or unboxing
    conversion with a cast, but this is unnecessary, as these conversions are automatically
    performed when you assign a value to a variable or pass a value to a method. Furthermore,
    unboxing conversions are also automatic if you use a wrapper object when a Java
    operator or statement expects a primitive value. Because Java performs boxing
    and unboxing automatically, this language feature is often known as *autoboxing*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of automatic boxing and unboxing conversions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: 'Autoboxing makes dealing with collections much easier as well. Let’s look at
    an example that uses Java’s *generics* (a language feature we’ll meet properly
    in [“Java Generics”](ch04.xhtml#javanut8-CHP-4-SECT-2)) that allows us to restrict
    what types can be put into lists and other collections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: Packages and the Java Namespace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A *package* is a named collection of classes, interfaces, and other reference
    types. Packages serve to group related classes and define a namespace for the
    classes they contain.
  prefs: []
  type: TYPE_NORMAL
- en: The core classes of the Java platform are in packages whose names begin with
    `java`. For example, the most fundamental classes of the language are in the package
    `java.lang`. Various utility classes are in `java.util`. Classes for input and
    output are in `java.io`, and classes for networking are in `java.net`. Some of
    these packages contain subpackages, such as `java.lang.reflect` and `java.util.regex`.
    Extensions to the Java platform that have been standardized by Oracle (or originally
    Sun) typically have package names that begin with `javax`. Some of these extensions,
    such as `javax.swing` and its myriad subpackages, were later adopted into the
    core platform itself. Finally, the Java platform also includes several “endorsed
    standards,” which have packages named after the standards body that created them,
    such as `org.w3c` and `org.omg`.
  prefs: []
  type: TYPE_NORMAL
- en: Every class has both a simple name, which is the name given to it in its definition,
    and a fully qualified name, which includes the name of the package of which it
    is a part. The `String` class, for example, is part of the `java.lang` package,
    so its fully qualified name is `java.lang.String`.
  prefs: []
  type: TYPE_NORMAL
- en: This section explains how to place your own classes and interfaces into a package
    and how to choose a package name that won’t conflict with anyone else’s package
    name. Next, it explains how to selectively import type names or static members
    into the namespace so that you don’t have to type the package name of every class
    or interface you use.
  prefs: []
  type: TYPE_NORMAL
- en: Package Declaration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To specify the package a class belongs to, you use a `package` declaration.
    The `package` keyword, if it appears, must be the first token of Java code (i.e.,
    the first thing other than comments and space) in the Java file. The keyword should
    be followed by the name of the desired package and a semicolon. Consider a Java
    file that begins with this directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: All classes defined by this file are part of the package `org.apache.commons.net`.
  prefs: []
  type: TYPE_NORMAL
- en: If no `package` directive appears in a Java file, all classes defined in that
    file are part of an unnamed default package. In this case, the qualified and unqualified
    names of a class are the same.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The possibility of naming conflicts means that you should not use the default
    package. As your project grows more complicated, conflicts become almost inevitable—much
    better to create packages right from the start.
  prefs: []
  type: TYPE_NORMAL
- en: Globally Unique Package Names
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the important functions of packages is to partition the Java namespace
    and prevent name collisions between classes. It is only their package names that
    keep the `java.util.List` and `java.awt.List` classes distinct, for example. For
    this to work, however, package names must themselves be distinct. As the developer
    of Java, Oracle controls all package names that begin with `java`, `javax`, and
    `sun`.
  prefs: []
  type: TYPE_NORMAL
- en: One common scheme is to use your domain name, with its elements reversed, as
    the prefix for all your package names. For example, the Apache Project produces
    a networking library as part of the Apache Commons project. The Commons project
    can be found at [*http://commons.apache.org*](http://commons.apache.org) and accordingly,
    the package name used for the networking library is `org.apache.commons.net`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that these package-naming rules apply primarily to API developers. If other
    programmers will be using classes that you develop along with unknown other classes,
    it is important that your package name be globally unique. On the other hand,
    if you are developing a Java application and will not be releasing any of the
    classes for reuse by others, you know the complete set of classes that your application
    will be deployed with and do not have to worry about unforeseen naming conflicts.
    In this case, you can choose a package-naming scheme for your own convenience
    rather than for global uniqueness. One common approach is to use the application
    name as the main package name (it may have subpackages beneath it).
  prefs: []
  type: TYPE_NORMAL
- en: Importing Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When referring to a class or interface in your Java code, you must, by default,
    use the fully qualified name of the type, including the package name. If you’re
    writing code to manipulate a file and need to use the `File` class of the `java.io`
    package, you must type `java.io.File`. This rule has three exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: Types from the package `java.lang` are so important and so commonly used that
    they can always be referred to by their simple names.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code in a type `p.T` may refer to other types defined in the package `p`
    by their simple names.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types that have been *imported* into the namespace with an `import` declaration
    may be referred to by their simple names.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first two exceptions are known as “automatic imports.” The types from `java.lang`
    and the current package are “imported” into the namespace so that they can be
    used without their package name. Typing the package name of commonly used types
    that are not in `java.lang` or the current package quickly becomes tedious, and
    so it is also possible to explicitly import types from other packages into the
    namespace. This is done with the `import` declaration.
  prefs: []
  type: TYPE_NORMAL
- en: '`import` declarations must appear at the start of a Java file, immediately
    after the `package` declaration, if there is one, and before any type definitions.
    You may use any number of `import` declarations in a file. An `import` declaration
    applies to all type definitions in the file (but not to any `import` declarations
    that follow it).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `import` declaration has two forms. To import a single type into the namespace,
    follow the `import` keyword with the name of the type and a semicolon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: This is known as the “single type `import`” declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other form of `import` declaration is the “on-demand type `import`.” In
    this form, you specify the name of a package followed by the characters `.*` to
    indicate that any type from that package may be used without its package name.
    Thus, if you want to use several other classes from the `java.io` package in addition
    to the `File` class, you can simply import the entire package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: This on-demand `import` syntax does not apply to subpackages. If I import the
    `java.util` package, I must still refer to the `java.util.zip.ZipInputStream`
    class by its fully qualified name or import it.
  prefs: []
  type: TYPE_NORMAL
- en: Using an on-demand type `import` declaration is not the same as explicitly writing
    out a single type `import` declaration for every type in the package. It is more
    like an explicit single type `import` for every type in the package *that you
    actually use* in your code. This is the reason it’s called “on demand”; types
    are imported as you use them.
  prefs: []
  type: TYPE_NORMAL
- en: Naming conflicts and shadowing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`import` declarations are invaluable to Java programming. They do expose us
    to the possibility of naming conflicts, however. Consider the packages `java.util`
    and `java.awt`. Both contain types named `List`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`java.util.List` is an important and commonly used interface. The `java.awt`
    package contains a number of important types that are commonly used in client-side
    applications, but `java.awt.List` has been superseded and is not one of these
    important types. It is illegal to import both `java.util.List` and `java.awt.List`
    in the same Java file. The following single type `import` declarations produce
    a compilation error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: 'Using on-demand type imports for the two packages is legal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: Difficulty arises, however, if you actually try to use the type `List`. This
    type can be imported “on demand” from either package, and any attempt to use `List`
    as an unqualified type name produces a compilation error. The workaround, in this
    case, is to explicitly specify the package name you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because `java.util.List` is much more commonly used than `java.awt.List`, it
    is useful to combine the two on-demand type `import` declarations with a single
    type `import` declaration that serves to disambiguate what we mean when we say
    `List`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: With these `import` declarations in place, we can use `List` to mean the `java.util.List`
    interface. If we actually need to use the `java.awt.List` class, we can still
    do so as long as we include its package name. There are no other naming conflicts
    between `java.util` and `java.awt`, and their types will be imported “on demand”
    when we use them without a package name.
  prefs: []
  type: TYPE_NORMAL
- en: Importing Static Members
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As well as types, you can import the static members of types using the keywords
    `import static`. (Static members are explained in [Chapter 3](ch03.xhtml#javanut8-CHP-3).
    If you are not already familiar with them, you may want to come back to this section
    later.) Like type `import` declarations, these static `import` declarations come
    in two forms: single static member `import` and on-demand static member `import`.
    Suppose, for example, that you are writing a text-based program that sends a lot
    of output to `System.out`. In this case, you might use this single static member
    `import` to save yourself typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then use `out.println()` instead of `System.out.println()`. Or suppose
    you are writing a program that uses many of the trigonometric and other functions
    of the `Math` class. In a program that is clearly focused on numerical methods
    like this, having to repeatedly type the class name “Math” does not add clarity
    to your code; it just gets in the way. In this case, an on-demand static member
    `import` may be appropriate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: With this `import` declaration, you are free to write concise expressions like
    `sqrt(abs(sin(x)))` without having to prefix the name of each static method with
    the class name `Math`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another important use of `import static` declarations is to import the names
    of constants into your code. This works particularly well with enumerated types
    (see [Chapter 4](ch04.xhtml#javanut8-CHP-4)). Suppose, for example, that you want
    to use the values of this enumerated type in code you are writing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: 'You could import the type `climate.temperate.Seasons` and then prefix the constants
    with the type name: `Seasons.SPRING`. For more concise code, you could import
    the enumerated values themselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: Using static member `import` declarations for constants is generally a better
    technique than implementing an interface that defines the constants.
  prefs: []
  type: TYPE_NORMAL
- en: Static member imports and overloaded methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A static `import` declaration imports a *name*, not any one specific member
    with that name. Because Java allows method overloading and allows a type to have
    fields and methods with the same name, a single static member `import` declaration
    may actually import more than one member. Consider this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: This declaration imports the name “sort” into the namespace, not any one of
    the 19 `sort()` methods defined by `java.util.Arrays`. If you use the imported
    name `sort` to invoke a method, the compiler will look at the types of the method
    arguments to determine which method you mean.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is even legal to import static methods with the same name from two or more
    different types as long as the methods all have different signatures. Here is
    one natural example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: You might expect that this code would cause a syntax error. In fact, it does
    not because the `sort()` methods defined by the `Collections` class have different
    signatures than all of the `sort()` methods defined by the `Arrays` class. When
    you use the name “sort” in your code, the compiler looks at the types of the arguments
    to determine which of the 21 possible imported methods you mean.
  prefs: []
  type: TYPE_NORMAL
- en: Java Source File Structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter has taken us from the smallest to the largest elements of Java
    syntax, from individual characters and tokens to operators, expressions, statements,
    and methods, and on up to classes and packages. From a practical standpoint, the
    unit of Java program structure you will be dealing with most often is the Java
    file. A Java file is the smallest unit of Java code that can be compiled by the
    Java compiler. A Java file consists of:'
  prefs: []
  type: TYPE_NORMAL
- en: An optional `package` directive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zero or more `import` or `import static` directives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One or more type definitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These elements can be interspersed with comments, of course, but they must appear
    in this order. This is all there is to a Java file. All Java statements (except
    the `package` and `import` directives, which are not true statements, and the
    specialized module descriptors we’ll discuss in [Chapter 12](ch12.xhtml#javanut8-CHP-12))
    must appear within methods, and all methods must appear within a type definition.
  prefs: []
  type: TYPE_NORMAL
- en: A special Java file named `module-info.java` is used only in declaring the structure
    and visibility of our packages in a modular Java application. These more advanced
    techniques and syntax are covered in detail in [Chapter 12](ch12.xhtml#javanut8-CHP-12).
  prefs: []
  type: TYPE_NORMAL
- en: Java files have a couple of other important restrictions. First, each file can
    contain at most one top-level class that is declared `public`. A `public` class
    is one that is designed for use by other classes in other packages. A class can
    contain any number of nested or inner classes that are `public`. We’ll see more
    about the `public` modifier and nested classes in [Chapter 3](ch03.xhtml#javanut8-CHP-3).
  prefs: []
  type: TYPE_NORMAL
- en: The second restriction concerns the filename of a Java file. If a Java file
    contains a `public` class, the name of the file must be the same as the name of
    the class, with the extension *.java* appended. Therefore, if `Account` is defined
    as a `public` class, its source code must appear in a file named *Account.java*.
    Regardless of whether your classes are `public` or not, it is good programming
    practice to define only one per file and to give the file the same name as the
    class.
  prefs: []
  type: TYPE_NORMAL
- en: When a Java file is compiled, each of the classes it defines is compiled into
    a separate *class* file that contains Java bytecodes to be executed by the Java
    Virtual Machine. A class file has the same name as the class it defines, with
    the extension *.class* appended. Thus, if the file *Account.java* defines a class
    named `Account`, a Java compiler compiles it to a file named *Account.class*.
    On most systems, class files are stored in directories that correspond to their
    package names. For example, the class `com.davidflanagan.examples.Account` is
    defined by the class file *com/davidflanagan/**examples/Account.class*.
  prefs: []
  type: TYPE_NORMAL
- en: The Java runtime knows where the class files for the standard system classes
    are located and can load them as needed. When the interpreter runs a program that
    wants to use a class named `com.davidflanagan.examples.Account`, it knows that
    the code for that class is located in a directory named *com/davidflanagan/examples/*
    and, by default, it “looks” in the current directory for a subdirectory of that
    name. In order to tell the interpreter to look in locations other than the current
    directory, you must use the `-classpath` option when invoking the interpreter
    or set the `CLASSPATH` environment variable. For details, see the documentation
    for the Java executable, *java*, in [Chapter 13](ch13.xhtml#javanut8-CHP-13).
  prefs: []
  type: TYPE_NORMAL
- en: Defining and Running Java Programs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A Java program consists of a set of interacting class definitions. But not
    every Java class or Java file defines a program. To create a program, you must
    define a class that has a special method with the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: This `main()` method is the main entry point for your program. It is where the
    Java interpreter starts running. This method is passed an array of strings and
    returns no value. When `main()` returns, the Java interpreter exits (unless `main()`
    has created separate threads, in which case the interpreter waits for all those
    threads to exit).
  prefs: []
  type: TYPE_NORMAL
- en: 'To run a Java program, you run the Java executable, *java*, specifying the
    fully qualified name of the class that contains the `main()` method. Note that
    you specify the name of the class, *not* the name of the class file that contains
    the class. Any additional arguments you specify on the command line are passed
    to the `main()` method as its `String[]` parameter. You may also need to specify
    the `-classpath` option (or `-cp`) to tell the interpreter where to look for the
    classes needed by the program. Consider the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '`java` is the command to run the Java interpreter. `-classpath /opt/Jude` tells
    the interpreter where to look for *.class* files. `com.davidflanagan.jude.Jude`
    is the name of the program to run (i.e., the name of the class that defines the
    `main()` method). Finally, `datafile.jude` is a string that is passed to that
    `main()` method as the single element of an array of `String` objects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is an easier way to run programs. If a program and all its auxiliary
    classes (except those that are part of the Java platform) have been properly bundled
    in a Java archive (JAR) file, you can run the program simply by specifying the
    name of the JAR file. In the next example, we show how to start up a log analyzer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: 'Some operating systems make JAR files automatically executable. On those systems,
    you can simply say:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: 'Java 17 also introduced the ability to run `java` against a source file directly,
    similar to what’s available in scripting languages such as Python. You still must
    define a class matching the name of the file and a `main()` method, but then you
    can execute the program with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: See [Chapter 13](ch13.xhtml#javanut8-CHP-13) for more details on how to execute
    Java programs.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ve introduced the basic syntax of the Java language. Due
    to the interlocking nature of the syntax of programming languages, it is perfectly
    fine if you don’t feel at this point that you have completely grasped all of the
    syntax of the language. It is by practice that we acquire proficiency in any language,
    human or computer.
  prefs: []
  type: TYPE_NORMAL
- en: It is also worth observing that some parts of syntax are far more regularly
    used than others. For example, the `strictfp` and `assert` keywords are almost
    never used. Rather than trying to grasp every aspect of Java’s syntax, it is far
    better to begin to acquire facility in the core aspects of Java and then return
    to any details of syntax that may still be troubling you. With this in mind, let’s
    move to the next chapter and begin to discuss the classes and objects that are
    so central to Java and the basics of Java’s approach to object-oriented programming.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch02.xhtml#idm45927772106240-marker)) Technically, the minus sign is an
    operator that operates on the literal and not part of the literal itself.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch02.xhtml#idm45927754904640-marker)) Technically, they must all implement
    the `AutoCloseable` interface.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch02.xhtml#idm45927754603040-marker)) In the Java Language Specification,
    the term “signature” has a technical meaning that is slightly different than that
    used here. This book uses a less formal definition of method signature.
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch02.xhtml#idm45927752917984-marker)) There is a terminology difficulty
    in discussions of arrays. Unlike with classes and their instances, we use the
    term “array” for both the array type and the array instance. In practice, it is
    usually clear from context whether a type or a value is being discussed.
  prefs: []
  type: TYPE_NORMAL
