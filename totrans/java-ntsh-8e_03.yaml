- en: Chapter 2\. Java Syntax from the Ground Up
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。从基础开始的Java语法
- en: This chapter is fairly dense but should provide a comprehensive introduction
    to Java syntax. It is written primarily for readers who are new to the language
    but have some previous programming experience. Determined novices with no prior
    programming experience may also find it useful. If you already know Java, you
    should find it a useful language reference. The chapter includes some comparisons
    of Java to JavaScript, C, and C++ for the benefit of programmers coming from those
    languages.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容较为密集，但应提供Java语法的全面介绍。主要面向对该语言新手，但具有一定编程经验的读者。对于没有任何编程经验的决心新手，也可能会发现它有用。如果你已经了解Java，你会发现它是一个有用的语言参考。本章还包括一些将Java与JavaScript、C和C++进行比较的内容，以帮助那些来自这些语言的程序员。
- en: 'This chapter documents the syntax of Java programs by starting at the very
    lowest level of Java syntax and building from there, moving on to increasingly
    higher orders of structure. It covers:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章从Java语法的最低级别开始，逐步构建并移向越来越高层次的结构，来记录Java程序的语法。涵盖内容包括：
- en: The characters used to write Java programs and the encoding of those characters.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于编写Java程序的字符及其编码方式。
- en: Literal values, identifiers, and other tokens that comprise a Java program.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java程序中包含的字面值、标识符和其他标记。
- en: The data types that Java can manipulate.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java可以操作的数据类型。
- en: The operators used in Java to group individual tokens into larger expressions.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java中用于将单个标记组合成较大表达式的运算符。
- en: Statements, which group expressions and other statements to form logical chunks
    of Java code.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语句，将表达式和其他语句分组形成Java代码的逻辑块。
- en: Methods, which are named collections of Java statements that can be invoked
    by other Java code.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法，是可以被其他Java代码调用的命名Java语句集合。
- en: Classes, which are collections of methods and fields. Classes are the central
    program element in Java and form the basis for object-oriented programming. [Chapter 3](ch03.xhtml#javanut8-CHP-3)
    is devoted entirely to a discussion of classes and objects.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类，是方法和字段的集合。类是Java中的中心程序元素，并且构成面向对象编程的基础。[第3章](ch03.xhtml#javanut8-CHP-3)完全专注于讨论类和对象。
- en: Packages, which are collections of related classes.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包，是相关类的集合。
- en: Java programs, which consist of one or more interacting classes that may be
    drawn from one or more packages.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java程序由一个或多个相互作用的类组成，这些类可以来自一个或多个包。
- en: The syntax of most programming languages is complex, and Java is no exception.
    In general, it is not possible to document all elements of a language without
    referring to other elements that have not yet been discussed. For example, it
    is not really possible to explain in a meaningful way the operators and statements
    supported by Java without referring to objects. But it is also not possible to
    document objects thoroughly without referring to the operators and statements
    of the language. The process of learning Java, or any language, is therefore an
    iterative one.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言的语法都很复杂，Java也不例外。一般而言，不可能在不涉及尚未讨论的其他元素的情况下记录语言的所有元素。例如，不可能真正有意义地解释Java支持的运算符和语句而不涉及对象。但也不可能在不涉及语言的运算符和语句的情况下彻底记录对象。因此，学习Java或任何语言的过程是一个迭代的过程。
- en: Java Programs from the Top Down
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自上而下的Java程序
- en: Before we begin our bottom-up exploration of Java syntax, let’s take a moment
    for a top-down overview of a Java program. Java programs consist of one or more
    files, or *compilation units*, of Java source code. Near the end of the chapter,
    we describe the structure of a Java file and explain how to compile and run a
    Java program. Each compilation unit begins with an optional `package` declaration
    followed by zero or more `import` declarations. These declarations specify the
    namespace within which the compilation unit will define names and the namespaces
    from which the compilation unit imports names. We’ll see `package` and `import`
    again later in this chapter in [“Packages and the Java Namespace”](#javanut8-CHP-2-SECT-10).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始自底向上探索Java语法之前，让我们来了解一下Java程序的概述。Java程序由一个或多个Java源代码文件或*编译单元*组成。在本章末尾附近，我们描述了Java文件的结构，并解释了如何编译和运行Java程序。每个编译单元以一个可选的`package`声明开头，后跟零个或多个`import`声明。这些声明指定了编译单元将定义名称的命名空间以及编译单元从中导入名称的命名空间。我们将在本章后面再次看到`package`和`import`，详见[“包和Java命名空间”](#javanut8-CHP-2-SECT-10)。
- en: The optional `package` and `import` declarations are followed by zero or more
    reference type definitions. We will meet the full variety of possible reference
    types in Chapters [3](ch03.xhtml#javanut8-CHP-3) and [4](ch04.xhtml#javanut8-CHP-4),
    but for now, we should note that these are most often either `class` or `interface`
    definitions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的`package`和`import`声明后面可以跟零个或多个引用类型定义。我们将在第[3](ch03.xhtml#javanut8-CHP-3)章和第[4](ch04.xhtml#javanut8-CHP-4)章中详细介绍可能的引用类型，但现在需要注意的是，这些类型通常是`class`或`interface`定义之一。
- en: Within the definition of a reference type, we will encounter *members* such
    as *fields*, *methods*, and *constructors*. Methods are the most important kind
    of member. Methods are blocks of Java code composed of *statements*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在引用类型的定义中，我们将遇到*成员*，例如*字段*、*方法*和*构造函数*。方法是最重要的成员类型。方法是由*语句*组成的Java代码块。
- en: With these basic terms defined, let’s start by approaching a Java program from
    the bottom up by examining the basic units of syntax—often referred to as *lexical
    tokens*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通过定义这些基本术语，让我们从底层向上探索Java程序，通过检查*词法标记*的基本语法单元开始。
- en: Lexical Structure
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 词法结构
- en: This section explains the lexical structure of a Java program. It starts with
    a discussion of the Unicode character set in which Java programs are written.
    It then covers the tokens that comprise a Java program, explaining comments, identifiers,
    reserved words, literals, and so on.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本节解释了Java程序的词法结构。它从编写Java程序的Unicode字符集讨论开始。然后，它涵盖了组成Java程序的标记，解释了注释、标识符、保留字、字面量等内容。
- en: The Unicode Character Set
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Unicode字符集
- en: Java programs are written using Unicode. You can use Unicode characters anywhere
    in a Java program, including comments and identifiers such as variable names.
    Unlike the 7-bit ASCII character set, which is useful only for English, and the
    8-bit ISO Latin-1 character set, which is useful only for major Western European
    languages, the Unicode character set can represent virtually every written language
    in common use on the planet.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Java程序使用Unicode编写。您可以在Java程序的任何地方使用Unicode字符，包括注释和标识符（如变量名）。与仅对英语有用的7位ASCII字符集以及仅对主要西欧语言有用的8位ISO
    Latin-1字符集不同，Unicode字符集可以表示几乎全球所有通用的书面语言。
- en: Tip
  id: totrans-22
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: If you do not use a Unicode-enabled text editor, or if you do not want to force
    other programmers who view or edit your code to use a Unicode-enabled editor,
    you can embed Unicode characters into your Java programs using the special Unicode
    escape sequence `\u*xxxx*`—that is, a backslash and a lowercase u, followed by
    four hexadecimal characters. For example, `\u0020` is the space character, and
    `\u03c0` is the character π.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不使用支持Unicode的文本编辑器，或者不想强迫查看或编辑您代码的其他程序员使用支持Unicode的编辑器，您可以使用特殊的Unicode转义序列`\u*xxxx*`将Unicode字符嵌入到Java程序中——即反斜杠和小写u，后跟四个十六进制字符。例如，`\u0020`是空格字符，`\u03c0`是π字符。
- en: Java has invested a large amount of time and engineering effort in ensuring
    that its Unicode support is first class. If your business application needs to
    deal with global users, especially in non-Western markets, then the Java platform
    is a great choice. Java also has support for multiple encodings and character
    sets, in case applications need to interact with non-Java applications that do
    not speak Unicode.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Java在确保其Unicode支持一流的情况下投入了大量时间和工程努力。如果您的业务应用程序需要处理全球用户，特别是非西方市场的用户，那么Java平台是一个很好的选择。此外，Java还支持多种编码和字符集，以便与不支持Unicode的非Java应用程序进行交互。
- en: Case Sensitivity and Whitespace
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大小写敏感性和空白字符
- en: Java is a case-sensitive language. Its keywords are written in lowercase and
    must always be used that way. That is, `While` and `WHILE` are not the same as
    the `while` keyword. Similarly, if you declare a variable named `i` in your program,
    you may not refer to it as `I`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Java是大小写敏感的语言。它的关键字以小写形式编写并且必须始终使用。也就是说，`While`和`WHILE`与`while`关键字不同。同样，如果您在程序中声明了一个名为`i`的变量，您不能将其称为`I`。
- en: Tip
  id: totrans-27
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: In general, relying on case sensitivity to distinguish identifiers is a terrible
    idea. The more similar identifiers there are, the more difficult the code is to
    read and understand. Do not use it in your own code, and in particular never give
    an identifier the same name as a keyword but differently cased.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，依赖大小写敏感性来区分标识符是一个糟糕的主意。标识符越相似，代码的可读性和理解难度就越大。不要在自己的代码中使用它，特别是不要给一个关键字相同但大小写不同的标识符。
- en: Java ignores spaces, tabs, newlines, and other whitespace, except when they
    appear within quoted characters and string literals. Programmers typically use
    whitespace to format and indent their code for easy readability, but it has no
    influence on the program’s behavior as indents do in Python. You will see common
    indentation conventions in this book’s code examples.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Java 忽略空格、制表符、换行符和其他空白字符，除非它们出现在引号字符和字符串字面值内。程序员通常使用空白字符来格式化和缩进他们的代码以便于阅读，但这不会像
    Python 中的缩进那样影响程序的行为。您将在本书的代码示例中看到常见的缩进约定。
- en: Comments
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注释
- en: 'Comments are natural-language text intended for human readers of a program.
    They are ignored by the Java compiler. Java supports three types of comments.
    The first type is a single-line comment, which begins with the characters `//`
    and continues until the end of the current line. For example:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注释是为程序的人类读者而设计的自然语言文本。它们被 Java 编译器忽略。Java 支持三种类型的注释。第一种类型是单行注释，以字符 `//` 开始，并延续至当前行的结尾。例如：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The second kind of comment is a multiline comment. It begins with the characters
    `/*` and continues, over any number of lines, until the characters `*/`. Any text
    between the `/*` and the `*/` is ignored by `javac`. Although this style of comment
    is typically used for multiline comments, it also can be used for single-line
    comments. This type of comment cannot be nested (i.e., one `/* */` comment cannot
    appear within another). When writing multiline comments, programmers often use
    extra `*` characters to make the comments stand out. Here is a typical multiline
    comment:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种类型的注释是多行注释。它以字符 `/*` 开始，并在任意行数后续续，直到字符 `*/`。`javac` 忽略 `/*` 和 `*/` 之间的任何文本。虽然这种注释风格通常用于多行注释，但也可以用于单行注释。这种类型的注释不能嵌套（即一个
    `/* */` 注释不能出现在另一个注释内）。编程人员在编写多行注释时经常使用额外的 `*` 字符来使注释突出显示。这是一个典型的多行注释示例：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The third type of comment is a special case of the second. If a comment begins
    with `/**`, it is regarded as a special *doc comment*. Like regular multiline
    comments, doc comments end with `*/` and cannot be nested. When you write a Java
    class you expect other programmers to use, provide doc comments to embed documentation
    about the class and each of its methods directly into the source code. A program
    named `javadoc` extracts these comments and processes them to create online documentation
    for your class. A doc comment can contain HTML tags and can use additional syntax
    understood by `javadoc`. For example:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种类型的注释是第二种的特例。如果一个注释以 `/**` 开头，它被视为特殊的*文档注释*。与常规的多行注释类似，文档注释以 `*/` 结尾，不能嵌套。当你编写一个希望其他程序员使用的
    Java 类时，提供文档注释以将关于类及其每个方法的文档直接嵌入源代码中。一个名为 `javadoc` 的程序会提取这些注释并处理它们以创建类的在线文档。文档注释可以包含
    HTML 标签，并且可以使用 `javadoc` 理解的额外语法。例如：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: See [Chapter 7](ch07.xhtml#javanut8-CHP-7) for more information on the doc comment
    syntax and [Chapter 13](ch13.xhtml#javanut8-CHP-13) for more information on the
    `javadoc` program.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于文档注释语法的信息请参见[第 7 章](ch07.xhtml#javanut8-CHP-7)，更多关于 `javadoc` 程序的信息请参见[第
    13 章](ch13.xhtml#javanut8-CHP-13)。
- en: Comments may appear between any tokens of a Java program but may not appear
    within a token. In particular, comments may not appear within double-quoted string
    literals. A comment within a string literal simply becomes a literal part of that
    string.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注释可以出现在 Java 程序的任何标记之间，但不能出现在标记内部。特别是，注释不能出现在双引号字符串字面值内。字符串字面值内的注释简单地成为该字符串的字面部分。
- en: Reserved Words
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保留字
- en: 'The following words are reserved in Java (they are part of the syntax of the
    language and may not be used to name variables, classes, and so forth):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 下列单词在 Java 中是保留的（它们是语言的语法的一部分，不能用于变量名、类名等）：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Of these, `true`, `false,` and `null` are technically literals.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，`true`、`false` 和 `null` 在技术上是字面值。
- en: Note that `const` and `goto` are reserved but aren’t actually used in the language
    and that `interface` has an additional variant form—`@interface`, which is used
    when defining types known as annotations. Some of the reserved words (notably
    `final` and `default`) have a variety of meanings depending on context.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意 `const` 和 `goto` 虽然被保留但实际上在语言中并未使用，而 `interface` 有一个额外的变体形式——`@interface`，用于定义称为注解的类型。一些保留字（特别是
    `final` 和 `default`）根据上下文有多种含义。
- en: Other keywords exist that are not reserved in general and are known as *contextual
    keywords*.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他一些关键字不是通常的保留字，被称为*上下文关键字*。
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`var` indicates a local variable that should be type-inferred. `sealed`, `non-sealed`,
    and `record` are used when defining classes, which we’ll meet in [Chapter 3](ch03.xhtml#javanut8-CHP-3).
    `yield` appears within `switch` expressions we’ll meet later in this chapter,
    while the remaining contextual keywords deal with modules, the syntax and use
    of which are covered in [Chapter 12](ch12.xhtml#javanut8-CHP-12).'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`var`表示应该进行类型推断的局部变量。在定义类时使用`sealed`、`non-sealed`和`record`，我们将在[第三章](ch03.xhtml#javanut8-CHP-3)中遇到。`yield`出现在稍后本章中将遇到的`switch`表达式中，而其他上下文关键字涉及模块，其语法和用法在[第12章](ch12.xhtml#javanut8-CHP-12)中有详细介绍。'
- en: Warning
  id: totrans-47
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Using contextual keywords as variable names, while allowed for compatibility,
    is discouraged. `var var = "var";` may be a valid statement, but it is a valid
    statement that ought to be viewed with suspicion.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管允许使用上下文关键字作为变量名，但不建议这样做。`var var = "var";`可能是一个有效的语句，但是这是一个应该引起怀疑的有效语句。
- en: Identifiers
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标识符
- en: An *identifier* is simply a name given to some part of a Java program, such
    as a class, a method within a class, or a variable declared within a method. Identifiers
    may be of any length and may contain letters and digits drawn from the entire
    Unicode character set. An identifier may not begin with a digit.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*标识符*只是Java程序中某部分（如类、类内方法或方法内声明的变量）的名称。标识符可以任意长度，并且可以包含来自整个Unicode字符集的字母和数字。标识符不能以数字开头。'
- en: In general, identifiers may not contain punctuation characters. Exceptions include
    the dollar sign (`$`) as well as other Unicode currency symbols such as `£` and
    `¥`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一般情况下，标识符不能包含标点符号字符。例外包括美元符号（`$`）以及其他Unicode货币符号，如`£`和`¥`。
- en: Tip
  id: totrans-52
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Currency symbols are intended for use in automatically generated source code,
    such as code produced by `javac`. By avoiding the use of currency symbols in your
    own identifiers, you don’t have to worry about collisions with automatically generated
    identifiers.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 货币符号用于自动生成的源代码，例如`javac`生成的代码。通过避免在您自己的标识符中使用货币符号，您就不必担心与自动生成的标识符发生冲突。
- en: The ASCII underscore (`_`) also deserves special mention. Originally, the underscore
    could be freely used as an identifier or part of one. However, in recent versions
    of Java, including Java 17, the underscore may not be used as an identifier.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ASCII下划线（`_`）也值得特别提及。最初，下划线可以自由地用作标识符或其一部分。然而，在包括Java 17在内的最新版本中，下划线不能作为标识符使用。
- en: The underscore character can still appear in a Java identifier, but it is no
    longer legal as a complete identifier by itself. This is to support an expected
    forthcoming language feature whereby the underscore will acquire a special new
    syntactic meaning.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 下划线字符仍然可以出现在Java标识符中，但不能再单独作为完整的标识符合法存在。这是为了支持即将推出的语言特性，其中下划线将获得新的特殊语法意义。
- en: The usual Java convention is to name variables using *camel case*. This means
    that the first letter of a variable should be lowercase but that the first letter
    of any other words in the identifier should be uppercase.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 通常的Java约定是使用*驼峰命名法*命名变量。这意味着变量的第一个字母应小写，但标识符中其他单词的第一个字母应大写。
- en: Formally, the characters allowed at the beginning of and within an identifier
    are defined by the methods `isJavaIdentifierStart()` and `isJavaIdentifierPart()`
    of the class `java.lang.Character`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 正式地说，标识符的起始和内部允许的字符由`java.lang.Character`类的`isJavaIdentifierStart()`和`isJavaIdentifierPart()`方法定义。
- en: 'The following are examples of legal identifiers:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是合法标识符的示例：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note in particular the example of a UTF-8 identifier, `獺`. This is the Kanji
    character for “otter” and is perfectly legal as a Java identifier. The use of
    non-ASCII identifiers is unusual in programs predominantly written by Westerners,
    but it is sometimes seen.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意UTF-8标识符的例子，`獺`。这是表示“水獭”的汉字字符，作为Java标识符完全合法。在主要由西方人编写的程序中使用非ASCII标识符是不寻常的，但有时会见到。
- en: Literals
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字面量
- en: 'Literals are sequences of source characters that directly represent constant
    values that appear as is in Java source code. They include integer and floating-point
    numbers, single characters within single quotes, strings of characters within
    double quotes, and the reserved words `true`, `false`, and `null`. For example,
    the following are all literals:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 字面量是源代码中直接表示常量值的源字符序列。它们包括整数和浮点数、单引号内的单个字符、双引号内的字符序列，以及保留字`true`、`false`和`null`。例如，以下都是字面量：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The syntax for expressing numeric, character, and string literals is detailed
    in [“Primitive Data Types”](#javanut8-CHP-2-SECT-3).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 表达数字、字符和字符串字面值的语法在[“原始数据类型”](#javanut8-CHP-2-SECT-3)中详细说明。
- en: Punctuation
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标点符号
- en: 'Java also uses a number of punctuation characters as tokens. The Java Language
    Specification divides these characters (somewhat arbitrarily) into two categories,
    separators and operators. The 12 separators are:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Java 还使用一些标点符号字符作为标记。Java 语言规范将这些字符（有些是任意的）分为两类，分隔符和操作符。这 12 种分隔符包括：
- en: '| `( )` | `{ }` | `[ ]` |  |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `( )` | `{ }` | `[ ]` |  |'
- en: '| `...` | `@` | `::` |  |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `...` | `@` | `::` |  |'
- en: '| `;` | `,` | `.` |  |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `;` | `,` | `.` |  |'
- en: 'The operators are:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符包括：
- en: '| `+` | `—` | `*` | `/` | `%` | `&` | `&#124;` | `^` | `<<` | `>>` | `>>>`
    |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `+` | `—` | `*` | `/` | `%` | `&` | `&#124;` | `^` | `<<` | `>>` | `>>>`
    |'
- en: '| `+=` | `-=` | `*=` | `/=` | `%=` | `&=` | `&#124;=` | `^=` | `<<=` | `>>=`
    | `>>>=` |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `+=` | `-=` | `*=` | `/=` | `%=` | `&=` | `&#124;=` | `^=` | `<<=` | `>>=`
    | `>>>=` |'
- en: '| `=` | `==` | `!=` | `<` | `<=` | `>` | `>=` |  |  |  |  |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `=` | `==` | `!=` | `<` | `<=` | `>` | `>=` |  |  |  |  |'
- en: '| `!` | `~` | `&&` | &#124;&#124; | `++` | `--` | `?` | `:` | `->` |  |  |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `!` | `~` | `&&` | &#124;&#124; | `++` | `--` | `?` | `:` | `->` |  |  |'
- en: We’ll see separators throughout the book and will cover each operator individually
    in [“Expressions and Operators”](#javanut8-CHP-2-SECT-4).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会在全书中看到分隔符，并且会在[“表达式和操作符”](#javanut8-CHP-2-SECT-4)中单独介绍每个操作符。
- en: Primitive Data Types
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原始数据类型
- en: Java supports eight basic data types known as *primitive types* as described
    in [Table 2-1](#javanut8-CHP-2-TABLE-1). The primitive types include a boolean
    type, a character type, four integer types, and two floating-point types. The
    four integer types and the two floating-point types differ in the number of bits
    that represent them and therefore in the range of numbers they can represent.
    Note that the size of these types is the notional size in the Java language. Different
    JVM implementations may use more actual space to hold these values due to padding,
    alignment, and the like.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Java 支持八种基本数据类型，称为*原始类型*，如[表 2-1](#javanut8-CHP-2-TABLE-1)所述。原始类型包括布尔类型、字符类型、四种整数类型和两种浮点类型。这四种整数类型和两种浮点类型在表示它们的位数和因此它们可以表示的数字范围上有所不同。请注意，这些类型的大小是
    Java 语言中的概念大小。由于填充、对齐等原因，不同的 JVM 实现可能使用更多的实际空间来保存这些值。
- en: Table 2-1\. Java primitive data types
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-1\. Java 原始数据类型
- en: '| Type | Contains | Default | Size | Range |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 包含 | 默认 | 大小 | 范围 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `boolean` | `true` or `false` | `false` | 1 bit | NA |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `boolean` | `true` or `false` | `false` | 1 位 | NA |'
- en: '| `char` | Unicode character | `\u0000` | 16 bits | `\u0000` to `\uFFFF` |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `char` | Unicode 字符 | `\u0000` | 16 位 | `\u0000` 到 `\uFFFF` |'
- en: '| `byte` | Signed integer | 0 | 8 bits | –128 to 127 |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `byte` | 有符号整数 | 0 | 8 位 | –128 到 127 |'
- en: '| `short` | Signed integer | 0 | 16 bits | –32768 to 32767 |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `short` | 有符号整数 | 0 | 16 位 | –32768 到 32767 |'
- en: '| `int` | Signed integer | 0 | 32 bits | –2147483648 to 2147483647 |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `int` | 有符号整数 | 0 | 32 位 | –2147483648 到 2147483647 |'
- en: '| `long` | Signed integer | 0 | 64 bits | –9223372036854775808 to 9223372036854775807
    |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `long` | 有符号整数 | 0 | 64 位 | –9223372036854775808 到 9223372036854775807 |'
- en: '| `float` | IEEE 754 floating point | 0.0 | 32 bits | 1.4E–45 to 3.4028235E+38
    |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `float` | IEEE 754 浮点数 | 0.0 | 32 位 | 1.4E–45 到 3.4028235E+38 |'
- en: '| `double` | IEEE 754 floating point | 0.0 | 64 bits | 4.9E–324 to 1.7976931348623157E+308
    |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `double` | IEEE 754 浮点数 | 0.0 | 64 位 | 4.9E–324 到 1.7976931348623157E+308
    |'
- en: The next section summarizes these primitive data types. In addition to these
    primitive types, Java supports nonprimitive data types known as reference types,
    which are introduced in [“Reference Types”](#javanut8-CHP-2-SECT-9).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节总结了这些原始数据类型。除了这些原始类型外，Java 还支持称为引用类型的非原始类型，这些类型在[“引用类型”](#javanut8-CHP-2-SECT-9)中介绍。
- en: The boolean Type
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔类型
- en: 'The `boolean` type represents truth values. This type has only two possible
    values, representing the two Boolean states: on or off, yes or no, true or false.
    Java reserves the words `true` and `false` to represent these two Boolean values.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`boolean` 类型代表真值。这种类型只有两个可能的值，表示两个布尔状态：开启或关闭，是或否，真或假。Java 保留了 `true` 和 `false`
    用于表示这两个布尔值。'
- en: 'Programmers coming to Java from other languages (especially JavaScript, Python,
    or C) should note that Java is much stricter about its Boolean values than other
    languages; in particular, a `boolean` is neither an integral nor an object type,
    and incompatible values cannot be used in place of a `boolean`. In other words,
    you cannot take shortcuts such as the following in Java:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 从其他语言（特别是JavaScript、Python或C）转到Java的程序员应该注意，Java对其布尔值要求比其他语言严格得多；特别是，`boolean`既不是整数类型也不是对象类型，不兼容的值不能用于`boolean`的位置。换句话说，在Java中不能像以下示例中那样使用捷径：
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Instead, Java forces you to write cleaner code by explicitly stating the comparisons
    you want:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Java要求您通过明确声明想要的比较来编写更清晰的代码：
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The char Type
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符类型
- en: The `char` type represents Unicode characters. Java has a slightly unique approach
    to representing characters—`javac` accepts identifiers and literals as UTF-8 (a
    variable-width encoding) in input. However, internally, Java represents chars
    in a fixed-width encoding—​either a 16-bit encoding (before Java 9) or as ISO-8859-1
    (an 8-bit encoding, used for Western European languages, also called Latin-1)
    if possible (Java 9 and later).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`char` 类型表示Unicode字符。Java在表示字符方面有着略微独特的方法—`javac`接受输入时将标识符和字面值作为UTF-8（一种可变宽度编码）。然而，在内部，Java以固定宽度编码表示字符—​在Java
    9之前是16位编码，在Java 9及以后可能是ISO-8859-1（一种用于西欧语言的8位编码，也称为Latin-1）。'
- en: 'This distinction between external and internal representation does not normally
    need to concern the developer. In most cases, all that is required is to remember
    the rule that to include a character literal in a Java program, simply place it
    between single quotes (apostrophes):'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 外部和内部表示之间的区别通常不需要开发人员关注。在大多数情况下，只需记住这条规则即可：要在Java程序中包含字符字面值，只需将其放在单引号（撇号）之间：
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can, of course, use Unicode characters as character literals with the `\u`
    Unicode escape sequence. In addition, Java supports a number of other escape sequences
    that make it easy both to represent commonly used nonprinting ASCII characters,
    such as `newline,` and to escape certain punctuation characters that have special
    meaning in Java. For example:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您可以使用 `\u` Unicode 转义序列将Unicode字符作为字符字面值。此外，Java还支持许多其他转义序列，使得表示常用的非打印ASCII字符（如
    `newline`）以及转义某些在Java中具有特殊含义的标点字符变得更加容易。例如：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[Table 2-2](#javanut8-CHP-2-TABLE-2) lists the escape characters that can be
    used in `char` literals. These characters can also be used in string literals,
    which are covered in the next section.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 2-2](#javanut8-CHP-2-TABLE-2) 列出了可以在 `char` 字面值中使用的转义字符。这些字符也可以用于字符串字面值，这将在下一节中介绍。'
- en: Table 2-2\. Java escape characters
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-2\. Java转义字符
- en: '| Escape sequence | Character value |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 转义序列 | 字符值 |'
- en: '| --- | --- |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `\b` | Backspace |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `\b` | 退格符 |'
- en: '| `\t` | Horizontal tab |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `\t` | 水平制表符 |'
- en: '| `\n` | Newline |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `\n` | 换行符 |'
- en: '| `\f` | Form feed |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `\f` | 换页符 |'
- en: '| `\r` | Carriage return |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `\r` | 回车符 |'
- en: '| `\`" | Double quote |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `\`" | 双引号 |'
- en: '| `\`'' | Single quote |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `\`'' | 单引号 |'
- en: '| `\\` | Backslash |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `\\` | 反斜杠 |'
- en: '| `\*xxx*` | The Latin-1 character with the encoding *`xxx`*, where *`xxx`*
    is an octal (base 8) number between 000 and 377. The forms *`\x`* and *`\xx`*
    are also legal, as in *`\0`*, but are not recommended because they can cause difficulties
    in string constants where the escape sequence is followed by a regular digit.
    This form is generally discouraged in favor of the `\uXXXX` form. |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `\*xxx*` | 使用编码为 *`xxx`* 的 Latin-1 字符，其中 *`xxx`* 是一个在000到377之间的八进制（基数为8）数字。形式
    *`\x`* 和 *`\xx`* 也是合法的，如 *`\0`*，但不建议使用，因为它们可能在字符串常量中引起困扰，后面跟随的是普通数字。一般不推荐此形式，而是更倾向于使用
    `\uXXXX` 形式。 |'
- en: '| `\u*xxxx*` | The Unicode character with encoding *`xxxx`*, where *`xxxx`*
    is four hexadecimal digits. Unicode escapes can appear anywhere in a Java program,
    not only in character and string literals. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `\u*xxxx*` | 使用编码为 *`xxxx`* 的Unicode字符，其中 *`xxxx`* 是四位十六进制数字。Unicode转义可以出现在Java程序的任何位置，不仅限于字符和字符串字面值中。
    |'
- en: '`char` values can be converted to and from the various integral types, and
    the `char` data type is a 16-bit integral type. Unlike `byte`, `short`, `int`,
    and `long`, however, `char` is an unsigned type and may receive values only in
    the range 0 to 65535. The `Character` class defines a number of useful `static`
    methods for working with characters, including `isDigit()`, `isJavaLetter()`,
    `isLowerCase()`, and `toUpperCase()`.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`char`值可以与各种整数类型相互转换，`char`数据类型是16位整数类型。但与`byte`、`short`、`int`和`long`不同，`char`是无符号类型，只能接收0到65535范围内的值。`Character`类定义了一些有用的静态方法，用于处理字符，包括`isDigit()`、`isJavaLetter()`、`isLowerCase()`和`toUpperCase()`。'
- en: The Java language and its `char` type were designed with Unicode in mind. The
    Unicode standard is evolving, however, and each new version of Java adopts a new
    version of Unicode. Java 11 uses Unicode 10.0.0 and Java 17 uses Unicode 13.0.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Java语言及其`char`类型是以Unicode为基础设计的。然而，Unicode标准在不断发展，每个新版本的Java都会采用新版本的Unicode。Java
    11使用Unicode 10.0.0，Java 17使用Unicode 13.0。
- en: A complication in recent Unicode releases is the introduction of characters
    whose encodings, or *codepoints*, do not fit in 16 bits. These supplementary characters,
    which are mostly infrequently used Han (Chinese) ideographs, occupy 21 bits and
    cannot be represented in a single `char` value. Instead, you must use an `int`
    value to hold the codepoint of a supplementary character, or you must encode it
    into a so-called “surrogate pair” of two `char` values.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 近期Unicode版本的复杂之处在于引入了一些字符，其编码或*代码点*不适合16位。这些补充字符大多是罕见使用的汉字，占用21位，无法用单个`char`值表示。相反，您必须使用一个`int`值来保存补充字符的代码点，或者使用所谓的“代理对”来编码成两个`char`值。
- en: Unless you commonly write programs that use Asian languages, you are unlikely
    to encounter any supplementary characters. If you do anticipate having to process
    characters that do not fit into a `char`, methods have been added to the `Character`,
    `String`, and related classes for working with text using `int` codepoints.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 除非您经常编写使用亚洲语言的程序，否则不太可能遇到任何补充字符。如果您预计要处理不适合`char`的字符，已向`Character`、`String`及相关类添加了方法，用于使用`int`代码点处理文本。
- en: String literals
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串字面量
- en: 'In addition to the `char` type, Java also has a data type for working with
    strings of text (usually simply called *strings*). The `String` type is a class,
    however, and is not one of the primitive types of the language. Because strings
    are so commonly used, though, Java does have syntax for including string values
    literally in a program. A `String` literal consists of arbitrary text within double
    quotes (as opposed to the single quotes for `char` literals). For example:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`char`类型外，Java还有一种用于处理文本字符串的数据类型（通常简称为*字符串*）。`String`类型是一个类，而不是语言的基本类型之一。然而，由于字符串被广泛使用，Java确实有语法可以在程序中直接包含字符串值。`String`字面量由双引号中的任意文本组成（与`char`字面量的单引号相对）。例如：
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Recent versions of Java also introduced a multiline string literal syntax called
    *text blocks*. A text block begins with a `"""` and a newline and ends when another
    sequence of `"""` is seen. These are handled entirely by the `javac` compiler
    and result in identical string literals to normal `"` strings in bytecode.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Java的最新版本还引入了一种称为*文本块*的多行字符串字面量语法。文本块以`"""`和换行符开头，当看到另一个`"""`序列时结束。这些由`javac`编译器完全处理，并且在字节码中与普通`"`字符串字面量相同。
- en: '[PRE12]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: String literals can contain any of the escape sequences that can appear as `char`
    literals (see [Table 2-2](#javanut8-CHP-2-TABLE-2)). Use the `\`" sequence to
    include a double quote within a standard `String` literal. Text blocks allow such
    escape sequences but do not require them for newlines or double quotes.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串字面量可以包含任何作为`char`字面量出现的转义序列（参见[表2-2](#javanut8-CHP-2-TABLE-2)）。使用`\\"`序列在标准`String`字面量中包含双引号。文本块允许使用这些转义序列，但在换行符或双引号时不需要它们。
- en: Because `String` is a reference type, string literals are described in more
    detail later in this chapter in [“String literals”](#javanut8-CHP-2-SECT-7.5).
    [Chapter 9](ch09.xhtml#javanut8-CHP-9) contains more details on some of the ways
    you can work with `String` objects in Java.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`String`是引用类型，字符串字面量将在本章后面的[“字符串字面量”](#javanut8-CHP-2-SECT-7.5)中详细描述。[第9章](ch09.xhtml#javanut8-CHP-9)详细介绍了在Java中处理`String`对象的一些方法。
- en: Integer Types
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整数类型
- en: The integer types in Java are `byte`, `short`, `int`, and `long`. As shown in
    [Table 2-1](#javanut8-CHP-2-TABLE-1), these four types differ only in the number
    of bits and, therefore, in the range of numbers each type can represent. All integral
    types represent signed numbers; there is no `unsigned` keyword as there is in
    C and C++.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Java中的整数类型是`byte`、`short`、`int`和`long`。如[表 2-1](#javanut8-CHP-2-TABLE-1)所示，这四种类型仅在位数和因此在每种类型可以表示的数字范围方面有所不同。所有整数类型都表示有符号数；与C和C++中的`unsigned`关键字不同。
- en: 'Literals for each of these types are written exactly as you would expect: as
    a sequence of decimal digits, optionally preceded by a minus sign.^([1](ch02.xhtml#idm45927772106240))
    Digits in any of these literals may be separated by an underscore (`_`) for better
    readability. Here are some legal integer literals:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每种类型的字面量，它们的写法与你期望的完全相同：一系列十进制数字，可选地以减号开头。^([1](ch02.xhtml#idm45927772106240))这些字面量中的数字可以用下划线(`_`)分隔以提高可读性。以下是一些合法的整数字面量：
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Integer literals are 32-bit values (and so are taken to be the Java type `int`)
    unless they end with the character `L` or `l`, in which case they are 64-bit values
    (and are understood to be the Java type `long`):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 整数字面量是32位值（因此被视为Java类型`int`），除非它们以字符`L`或`l`结尾，此时它们是64位值（并被理解为Java类型`long`）：
- en: '[PRE14]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Integer literals can also be expressed in hexadecimal, binary, or octal notation.
    A literal that begins with `0x` or `0X` is taken as a hexadecimal number, using
    the letters `A` to `F` (or `a` to `f`) as the additional digits required for base-16
    numbers.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 整数字面量也可以用十六进制、二进制或八进制表示法表示。以`0x`或`0X`开头的字面量被视为十六进制数，使用字母`A`到`F`（或`a`到`f`）作为基数为16的数字所需的额外数字。
- en: Integer binary literals start with `0b` and may, of course, feature only the
    digits 1 or 0\. Use of the underscore separator in binary literals is very common,
    as binary literals can be very long.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制整数字面量以`0b`开头，当然，只能包含数字1或0。二进制字面量中使用下划线分隔符是非常常见的，因为二进制字面量可以非常长。
- en: 'Java also supports octal (base-8) integer literals. These literals begin with
    a leading `0` and cannot include the digits 8 or 9\. They are not often used and
    should be avoided unless needed. Legal hexadecimal, binary, and octal literals
    include:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Java还支持八进制（基数为8）整数字面量。这些字面量以前导`0`开头，不能包括数字8或9。它们并不经常使用，除非需要，应该避免使用。合法的十六进制、二进制和八进制字面量包括：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Integer arithmetic in Java never produces an overflow or an underflow when
    you exceed the range of a given integer type. Instead, numbers just wrap around.
    For example, let’s look at an overflow:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当超出给定整数类型的范围时，Java中的整数运算永远不会产生溢出或下溢。相反，数字会简单地循环。例如，让我们看一个溢出的例子：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'and the corresponding underflow behavior:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以及相应的下溢行为：
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Neither the Java compiler nor the Java interpreter warns you in any way when
    this occurs. When doing integer arithmetic, you simply must ensure that the type
    you are using has a sufficient range for the purposes you intend. Integer division
    by zero and modulo by zero are illegal and cause an `ArithmeticException` to be
    thrown. (We’ll see more about exceptions soon in [“Checked and Unchecked Exceptions”](#javanut8-CHP-2-SECT-6.3)).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生这种情况时，Java编译器和Java解释器都不会以任何方式警告你。在进行整数运算时，你必须确保所使用的类型对你打算的目的具有足够的范围。整数除以零和模零是非法的，并导致抛出`ArithmeticException`。（我们很快将在[“已检查和未检查的异常”](#javanut8-CHP-2-SECT-6.3)中详细了解更多异常）。
- en: 'Each integer type has a corresponding wrapper class: `Byte`, `Short`, `Integer`,
    and `Long`. Each of these classes defines `MIN_VALUE` and `MAX_VALUE` constants
    that describe the range of the type. Each class also provides a static `valueOf()`
    method that is strongly preferred for creating an instance of the wrapper class
    from a primitive value. While the wrapper classes have plain constructors that
    take the primitives, they are deprecated and should be avoided. The wrapper classes
    also define useful static methods, such as `Byte.parseByte()` and `Integer.parseInt()`,
    for converting strings to integer values.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 每种整数类型都有一个对应的包装类：`Byte`、`Short`、`Integer`和`Long`。每个这些类都定义了`MIN_VALUE`和`MAX_VALUE`常量来描述该类型的范围。每个类还提供了一个静态的`valueOf()`方法，强烈建议使用该方法从原始值创建包装类的实例。虽然包装类具有接受原始类型的普通构造函数，但它们已被弃用，应避免使用。包装类还定义了一些有用的静态方法，如`Byte.parseByte()`和`Integer.parseInt()`，用于将字符串转换为整数值。
- en: Floating-Point Types
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浮点类型
- en: Real numbers in Java are represented by the `float` and `double` data types.
    As shown in [Table 2-1](#javanut8-CHP-2-TABLE-1), `float` is a 32-bit, single-precision,
    floating-point value, and `double` is a 64-bit, double-precision, floating-point
    value. Both types adhere to the IEEE 754-1985 standard, which specifies both the
    format of the numbers and the behavior of arithmetic for the numbers.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，实数由`float`和`double`数据类型表示。如表[2-1](#javanut8-CHP-2-TABLE-1)所示，`float`是32位单精度浮点值，而`double`是64位双精度浮点值。这两种类型都遵循IEEE
    754-1985标准，该标准指定了数字的格式以及数字的算术行为。
- en: 'Floating-point values can be included literally in a Java program as an optional
    string of digits, followed by a decimal point and another string of digits. Here
    are some examples:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点值可以直接作为Java程序中的可选数字字符串包含，后面跟着小数点和另一个数字字符串。以下是一些示例：
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Floating-point literals can also use exponential, or scientific, notation,
    in which a number is followed by the letter `e` or `E` (for exponent) and another
    number. This second number represents the power of 10 by which the first number
    is multiplied. For example:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点文字面量还可以使用指数或科学表示法，其中一个数字后跟着字母`e`或`E`（指数），然后是另一个数字。第二个数字表示第一个数字乘以的10的幂。例如：
- en: '[PRE19]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Floating-point literals are `double` values by default. To include a `float`
    value literally in a program, follow the number with `f` or `F`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点文字面量默认为`double`值。要在程序中直接包含`float`值，请在数字后面跟上`f`或`F`：
- en: '[PRE20]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Floating-point literals cannot be expressed in hexadecimal, binary, or octal
    notation.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点文字面量不能用十六进制、二进制或八进制表示。
- en: 'In addition to representing ordinary numbers, the `float` and `double` types
    can also represent four special values: positive and negative infinity, zero,
    and NaN. The infinity values result when a floating-point computation produces
    a value that overflows the representable range of a `float` or `double`.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 除了表示普通数字外，`float`和`double`类型还可以表示四个特殊值：正无穷大、负无穷大、零和NaN。当浮点计算产生超出`float`或`double`可表示范围的值时，会得到无穷大值。
- en: When a floating-point computation underflows the representable range of a `float`
    or a `double`, a zero value results.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当浮点计算下溢到`float`或`double`的可表示范围时，将得到零值。
- en: Note
  id: totrans-154
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: We can imagine repeatedly dividing the double value `1.0` by `2.0` (e.g., in
    a `while` loop). In mathematics, no matter how often we perform the division,
    the result will never become equal to zero. However, in a floating-point representation,
    after enough divisions, the result will eventually be so small as to be indistinguishable
    from zero.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以想象重复地将双精度值`1.0`除以`2.0`（例如，在`while`循环中）。在数学上，无论我们进行多少次除法，结果永远不会变成零。然而，在浮点表示中，经过足够多的除法之后，结果最终会变得非常小，以至于与零几乎无法区分。
- en: 'The Java floating-point types make a distinction between positive zero and
    negative zero, depending on the direction from which the underflow occurred. In
    practice, positive and negative zero behave pretty much the same. Finally, the
    last special floating-point value is NaN, which stands for “Not a Number.” The
    NaN value results when an illegal floating-point operation, such as 0.0/0.0, is
    performed. Here are examples of statements that result in these special values:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Java浮点类型区分正零和负零，具体取决于下溢发生的方向。实际上，正零和负零的行为几乎相同。最后，最后一个特殊浮点值是NaN，表示“不是一个数字”。当执行非法浮点操作（例如0.0/0.0）时，将得到NaN值。以下是导致这些特殊值的语句示例：
- en: '[PRE21]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `float` and `double` primitive types have corresponding classes, named
    `Float` and `Double`. Each of these classes defines the following useful constants:
    `MIN_VALUE`, `MAX_VALUE`, `NEGATIVE_INFINITY`, `POSITIVE_INFINITY`, and `NaN`.
    Much like the integer wrapper classes, the floating-point wrappers also have a
    static `valueOf()` for constructing instances.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`float`和`double`原始类型有相应的类，名为`Float`和`Double`。每个类定义了以下有用的常量：`MIN_VALUE`、`MAX_VALUE`、`NEGATIVE_INFINITY`、`POSITIVE_INFINITY`和`NaN`。与整数包装类类似，浮点包装类也有一个用于构造实例的静态`valueOf()`方法。'
- en: Note
  id: totrans-159
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Java floating-point types can handle overflow to infinity and underflow to zero
    and have a special NaN value. This means floating-point arithmetic never throws
    exceptions, even when performing illegal operations, like dividing zero by zero
    or taking the square root of a negative number.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Java浮点类型可以处理溢出到无穷大和下溢到零以及具有特殊NaN值的情况。这意味着浮点算术永远不会抛出异常，即使执行非法操作，如零除以零或对负数取平方根。
- en: 'The infinite floating-point values behave as you would expect. Adding or subtracting
    any finite value to or from infinity, for example, yields infinity. Negative zero
    behaves almost identically to positive zero, and, in fact, the `==` equality operator
    reports that negative zero is equal to positive zero. One way to distinguish negative
    zero from positive, or regular, zero is to divide by it: `1.0/0.0` yields positive
    infinity, but `1.0` divided by negative zero yields negative infinity. Finally,
    because NaN is Not a Number, the `==` operator says that it is not equal to any
    other number, including itself!'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 无限浮点值的行为如预期。例如，将任何有限值加或减无穷大将得到无穷大。负零的行为与正零几乎相同，事实上，`==`等号操作符报告负零等于正零。区分负零和正常零的一种方法是通过除以它来进行：`1.0/0.0`得到正无穷大，但`1.0`除以负零得到负无穷大。最后，因为NaN不是一个数字，`==`操作符表明它与任何其他数字（包括自身）都不相等！
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: To check whether a `float` or `double` value is NaN, you must use the `Float.isNaN()`
    and `Double.isNaN()` methods.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查`float`或`double`值是否为NaN，必须使用`Float.isNaN()`和`Double.isNaN()`方法。
- en: Primitive Type Conversions
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原始类型转换
- en: Java allows conversions between integer values and floating-point values. In
    addition, because every character corresponds to a number in the Unicode encoding,
    `char` values can be converted to and from the integer and floating-point types.
    In fact, `boolean` is the only primitive type that cannot be converted to or from
    another primitive type in Java.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Java允许在整数值和浮点值之间进行转换。此外，因为Unicode编码中的每个字符对应一个数字，`char`值可以在整数和浮点类型之间转换。事实上，`boolean`是Java中唯一不能转换为其他原始类型或从其他原始类型转换的类型。
- en: There are two basic types of conversions. A *widening conversion* occurs when
    a value of one type is converted to a wider type—one that has a larger range of
    legal values. For example, Java performs widening conversions automatically when
    you assign an `int` literal to a `double` variable or a `char` literal to an `int`
    variable.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种基本类型的转换。*扩展转换*是指将一种类型的值转换为更宽的类型，即具有更大合法值范围的类型。例如，当你将`int`字面量分配给`double`变量或`char`字面量分配给`int`变量时，Java会自动执行扩展转换。
- en: 'Narrowing conversions are another matter, however. A *narrowing conversion*
    occurs when a value is converted to a type that is not wider than it is. Narrowing
    conversions are not always safe: it is reasonable to convert the integer value
    13 to a `byte`, for example, but it is not reasonable to convert 13,000 to a `byte`,
    because `byte` can hold only numbers between –128 and 127\. Because you can lose
    data in a narrowing conversion, `javac` complains when you attempt any narrowing
    conversion, even if the value being converted would in fact fit in the narrower
    range of the specified type:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，窄化转换是另一回事。*窄化转换*是指将值转换为不比其宽的类型。窄化转换并不总是安全的：例如，将整数值13转换为`byte`是合理的，但将13000转换为`byte`是不合理的，因为`byte`只能保存在-128到127之间的数字。由于在窄化转换中可能丢失数据，即使要转换的值实际上可以适合指定类型的更窄范围，`javac`也会在尝试任何窄化转换时发出警告：
- en: '[PRE23]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The one exception to this rule is that you can assign an integer literal (an
    `int` value) to a `byte` or `short` variable if the literal falls within the range
    of the variable.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的例外是，如果字面量在变量的范围内，可以将整数字面量（`int`值）分配给`byte`或`short`变量。
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If you need to perform a narrowing conversion and are confident you can do
    so without losing data or precision, you can force Java to perform the conversion
    using a language construct known as a *cast*. Perform a cast by placing the name
    of the desired type in parentheses before the value to be converted. For example:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要执行窄化转换并且确信不会丢失数据或精度，可以使用称为*强制转换*的语言结构强制Java执行转换。通过在要转换的值之前在括号中放置所需类型的名称来执行转换。例如：
- en: '[PRE25]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Casts of primitive types are most often used to convert floating-point values
    to integers. When you do this, the fractional part of the floating-point value
    is simply truncated (i.e., the floating-point value is rounded toward zero, not
    toward the nearest integer). The static methods `Math.round()`, `Math.floor()`,
    and `Math.ceil()` perform other types of rounding.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 原始类型的强制转换通常用于将浮点值转换为整数。这样做时，浮点值的小数部分会被简单截断（即浮点值向零舍入，而不是向最接近的整数舍入）。静态方法`Math.round()`、`Math.floor()`和`Math.ceil()`执行其他类型的舍入。
- en: 'The `char` type acts like an integer type in most ways, so a `char` value can
    be used anywhere an `int` or `long` value is required. Recall, however, that the
    `char` type is *unsigned*, so it behaves differently than the `short` type, even
    though both are 16 bits wide:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`char` 类型在大多数情况下像整数类型，因此 `char` 值可以在需要 `int` 或 `long` 值的任何地方使用。然而，请记住，`char`
    类型是 *无符号* 的，因此它与 `short` 类型行为不同，即使两者都是16位宽度：'
- en: '[PRE26]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[Table 2-3](#javanut8-CHP-2-TABLE-3) shows which primitive types can be converted
    to which other types and how the conversion is performed. The letter N in the
    table means that the conversion cannot be performed. The letter Y means that the
    conversion is a widening conversion and is therefore performed automatically and
    implicitly by Java. The letter C means that the conversion is a narrowing conversion
    and requires an explicit cast.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 2-3（#javanut8-CHP-2-TABLE-3）显示了哪些基本类型可以转换为哪些其他类型以及转换的执行方式。表中的字母 N 表示无法执行转换。字母
    Y 表示这是一种自动扩展转换，因此Java会自动隐式执行。字母 C 表示这是一种缩小转换，需要显式转换。
- en: Finally, the notation Y* means that the conversion is an automatic widening
    conversion, but some of the least significant digits of the value may be lost
    in the conversion. This can happen when you are converting an `int` or `long`
    to a floating-point type—see the table for details. The floating-point types have
    a larger range than the integer types, so any `int` or `long` can be represented
    by a `float` or `double`. However, the floating-point types are approximations
    of numbers and cannot always hold as many significant digits as the integer types
    (see [Chapter 9](ch09.xhtml#javanut8-CHP-9) for some more detail about floating-point
    numbers).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Y* 表示转换为自动扩展转换，但在转换过程中可能会丢失一些最低有效位数。当你将 `int` 或 `long` 转换为浮点类型时会发生这种情况——详细信息请参见表格。浮点类型的范围比整数类型更大，因此任何
    `int` 或 `long` 都可以被表示为 `float` 或 `double`。然而，浮点类型是数字的近似值，不能始终保存与整数类型一样多的有效位数（详见[第9章](ch09.xhtml#javanut8-CHP-9)关于浮点数的详细信息）。
- en: Table 2-3\. Java primitive type conversions
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-3\. Java基本类型转换
- en: '|   | Convert to: |   |   |   |   |   |   |   |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '|   | 转换为: |   |   |   |   |   |   |   |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| Convert from: | `boolean` | `byte` | `short` | `char` | `int` | `long` |
    `float` | `double` |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| 从以下类型转换: | `boolean` | `byte` | `short` | `char` | `int` | `long` | `float`
    | `double` |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| `boolean` | - | N | N | N | N | N | N | N |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `boolean` | - | N | N | N | N | N | N | N |'
- en: '| `byte` | N | - | Y | C | Y | Y | Y | Y |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `byte` | N | - | Y | C | Y | Y | Y | Y |'
- en: '| `short` | N | C | - | C | Y | Y | Y | Y |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `short` | N | C | - | C | Y | Y | Y | Y |'
- en: '| `char` | N | C | C | - | Y | Y | Y | Y |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `char` | N | C | C | - | Y | Y | Y | Y |'
- en: '| `int` | N | C | C | C | - | Y | Y* | Y |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `int` | N | C | C | C | - | Y | Y* | Y |'
- en: '| `long` | N | C | C | C | C | - | Y* | Y* |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `long` | N | C | C | C | C | - | Y* | Y* |'
- en: '| `float` | N | C | C | C | C | C | - | Y |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `float` | N | C | C | C | C | C | - | Y |'
- en: '| `double` | N | C | C | C | C | C | C | - |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `double` | N | C | C | C | C | C | C | - |'
- en: Expressions and Operators
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式和运算符
- en: So far in this chapter, we’ve learned about the primitive types that Java programs
    can manipulate and seen how to include primitive values as *literals* in a Java
    program. We’ve also used *variables* as symbolic names that represent, or hold,
    values. These literals and variables are the tokens out of which Java programs
    are built.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们已经了解了Java程序可以操作的基本类型，并看到如何将基本值作为 *字面值* 包含在Java程序中。我们还使用了 *变量* 作为表示或保存值的符号名称。这些字面值和变量是构成Java程序的标记。
- en: 'An *expression* is the next higher level of structure in a Java program. The
    Java interpreter *evaluates* an expression to compute its value. The very simplest
    expressions are called *primary expressions* and consist of literals and variables.
    So, for example, the following are all expressions:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '*表达式* 是Java程序中的下一个更高级的结构。Java解释器 *评估* 表达式以计算其值。最简单的表达式称为 *主表达式*，由字面值和变量组成。因此，例如以下都是表达式：'
- en: '[PRE27]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When the Java interpreter evaluates a literal expression, the resulting value
    is the literal itself. When the interpreter evaluates a variable expression, the
    resulting value is the value stored in the variable.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当Java解释器评估字面表达式时，结果值是字面本身。当解释器评估变量表达式时，结果值是变量中存储的值。
- en: 'Primary expressions are not very interesting. More complex expressions are
    made by using *operators* to combine primary expressions. For example, the following
    expression uses the assignment operator to combine two primary expressions—a variable
    and a floating-point literal—into an assignment expression:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'But operators are used not just with primary expressions; they also can be
    used with expressions at any level of complexity. The following are all legal
    expressions:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Operator Summary
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The kinds of expressions you can write in a programming language depend entirely
    on the set of operators available to you. Java has a wealth of operators, but
    to work effectively with them, you must understand two important concepts: *precedence*
    and *associativity*. These concepts—and the operators themselves—are explained
    in more detail in the following sections.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Precedence
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The P column of [Table 2-4](#javanut8-CHP-2-TABLE-4) specifies the *precedence*
    of each operator. Precedence specifies the order in which operations are performed.
    Operations that have higher precedence are performed before those with lower precedence.
    For example, consider this expression:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The multiplication operator has higher precedence than the addition operator,
    so `a` is added to the product of `b` and `c`, just as we expect from elementary
    mathematics. Operator precedence can be thought of as a measure of how tightly
    operators bind to their operands. The higher the number, the more tightly they
    bind.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'Default operator precedence can be overridden through the use of parentheses
    that explicitly specify the order of operations. The previous expression can be
    rewritten to specify that the addition should be performed before the multiplication:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The default operator precedence in Java was chosen for compatibility with C;
    the designers of C chose this precedence so that most expressions can be written
    naturally without parentheses. Only a few common Java idioms require parentheses.
    Examples include:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Associativity
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Associativity is a property of operators that defines how to evaluate expressions
    that would otherwise be ambiguous. This is particularly important when an expression
    involves several operators that have the same precedence.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Most operators are left-to-right associative, which means that the operations
    are performed from left to right. The assignment and unary operators, however,
    have right-to-left associativity. The A column of [Table 2-4](#javanut8-CHP-2-TABLE-4)
    specifies the associativity of each operator or group of operators. The value
    L means left to right, and R means right to left.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'The additive operators are all left-to-right associative, so the expression
    `a+b-c` is evaluated from left to right: `(a+b)-c`. Unary operators and assignment
    operators are evaluated from right to left. Consider this complex expression:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This is evaluated as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As with operator precedence, operator associativity establishes a default order
    of evaluation for an expression. This default order can be overridden through
    the use of parentheses. However, the default operator associativity in Java has
    been chosen to yield a natural expression syntax.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符的结合性与操作符优先级一样，为表达式的默认评估顺序建立了一个默认顺序。可以通过使用括号来覆盖这个默认顺序。然而，在Java中，默认的操作符结合性被选择为产生自然的表达式语法。
- en: Operator summary table
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 操作符总结表
- en: '[Table 2-4](#javanut8-CHP-2-TABLE-4) summarizes the operators available in
    Java. The P and A columns of the table specify the precedence and associativity
    of each group of related operators, respectively. The table is ordered from highest
    precedence to lowest. Use this table as a quick reference for operators (especially
    their precedence) when required.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '[表格 2-4](#javanut8-CHP-2-TABLE-4) 总结了Java中可用的操作符。表格中的P和A列指定了每组相关操作符的优先级和结合性。表格按优先级从高到低排序。在需要时，可以将此表格作为操作符（尤其是它们的优先级）的快速参考。'
- en: Table 2-4\. Java operators
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-4\. Java 操作符
- en: '| P | A | Operator | Operand type(s) | Operation performed |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| P | A | 操作符 | 操作数类型 | 执行的操作 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '--- | --- | --- | --- | --- |'
- en: '| 16 | L | . | object, member | Object member access |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| 16 | L | . | object, member | 对象成员访问 |'
- en: '|  |  | `[ ]` | array, int | Array element access |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '|  |  | `[ ]` | array, int | 数组元素访问 |'
- en: '|  |  | `( *args* )` | method, arglist | Method invocation |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '|  |  | `( *args* )` | method, arglist | Method invocation |'
- en: '|  |  | `++`, `--` | variable | Post-increment, post-decrement |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '|  |  | `++`, `--` | variable | 后增量，后减量 |'
- en: '| 15 | R | `++`, `--` | variable | Pre-increment, pre-decrement |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| 15 | R | `++`, `--` | variable | 前增量，前减量 |'
- en: '|  |  | `+`, `-` | number | Unary plus, unary minus |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '|  |  | `+`, `-` | number | 一元加，一元减 |'
- en: '|  |  | `~` | integer | Bitwise complement |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '|  |  | `~` | integer | 位取反 |'
- en: '|  |  | `!` | boolean | Boolean NOT |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '|  |  | `!` | boolean | Boolean NOT |'
- en: '| 14 | R | `new` | class, arglist | Object creation |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| 14 | R | `new` | class, arglist | 对象创建 |'
- en: '|  |  | `( *type* )` | type, any | Cast (type conversion) |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '|  |  | `( *type* )` | type, any | 强制类型转换 |'
- en: '| 13 | L | `*`, `/`, `%` | number, number | Multiplication, division, remainder
    |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| 13 | L | `*`, `/`, `%` | number, number | 乘法，除法，求余 |'
- en: '| 12 | L | `+`, `-` | number, number | Addition, subtraction |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| 12 | L | `+`, `-` | number, number | 加法，减法 |'
- en: '|  |  | `+` | string, any | String concatenation |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '|  |  | `+` | string, any | 字符串连接 |'
- en: '| 11 | L | `<<` | integer, integer | Left shift |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| 11 | L | `<<` | integer, integer | 左移 |'
- en: '|  |  | `>>` | integer, integer | Right shift with sign extension |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '|  |  | `>>` | integer, integer | 带符号右移 |'
- en: '|  |  | `>>>` | integer, integer | Right shift with zero extension |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '|  |  | `>>>` | integer, integer | 无符号右移 |'
- en: '| 10 | L | `<`, `<=` | number, number | Less than, less than or equal |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| 10 | L | `<`, `<=` | number, number | 小于，小于等于 |'
- en: '|  |  | `>`, `>=` | number, number | Greater than, greater than or equal |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '|  |  | `>`, `>=` | number, number | 大于，大于等于 |'
- en: '|  |  | `instanceof` | reference, type | Type comparison |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '|  |  | `instanceof` | reference, type | Type comparison |'
- en: '| 9 | L | `==` | primitive, primitive | Equal (have identical values) |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| 9 | L | `==` | primitive, primitive | 等于（具有相同的值） |'
- en: '|  |  | `!=` | primitive, primitive | Not equal (have different values) |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '|  |  | `!=` | primitive, primitive | 不等于（具有不同的值） |'
- en: '|  |  | `==` | reference, reference | Equal (refer to same object) |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '|  |  | `==` | reference, reference | 等于（引用同一对象） |'
- en: '|  |  | `!=` | reference, reference | Not equal (refer to different objects)
    |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '|  |  | `!=` | reference, reference | 不等于（引用不同对象） |'
- en: '| 8 | L | `&` | integer, integer | Bitwise AND |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| 8 | L | `&` | integer, integer | 位与 |'
- en: '|  |  | `&` | boolean, boolean | Boolean AND |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '|  |  | `&` | boolean, boolean | 布尔与 |'
- en: '| 7 | L | `^` | integer, integer | Bitwise XOR |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| 7 | L | `^` | integer, integer | 位异或 |'
- en: '|  |  | `^` | boolean, boolean | Boolean XOR |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '|  |  | `^` | boolean, boolean | 布尔异或 |'
- en: '| 6 | L | `ǀ` | integer, integer | Bitwise OR |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| 6 | L | `ǀ` | integer, integer | 位或 |'
- en: '|  |  | `ǀ` | boolean, boolean | Boolean OR |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '|  |  | `ǀ` | boolean, boolean | 布尔或 |'
- en: '| 5 | L | `&&` | boolean, boolean | Conditional AND |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| 5 | L | `&&` | boolean, boolean | 条件与 |'
- en: '| 4 | L | `ǀǀ` | boolean, boolean | Conditional OR |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| 4 | L | `ǀǀ` | boolean, boolean | 条件或 |'
- en: '| 3 | R | `? :` | boolean, any | Conditional (ternary) operator |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| 3 | R | `? :` | boolean, any | 条件（三元）操作符 |'
- en: '| 2 | R | `=` | variable, any | Assignment |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| 2 | R | `=` | variable, any | 赋值 |'
- en: '|  |  | `*=`, `/=`, `%=`, | variable, any | Assignment with operation |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '|  |  | `*=`, `/=`, `%=`, | variable, any | Assignment with operation |'
- en: '|  |  | `+=`, `-=`, `<<=`, |  |  |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '|  |  | `+=`, `-=`, `<<=`, |  |  |'
- en: '|  |  | `>>=`, `>>>=`, |  |  |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '|  |  | `>>=`, `>>>=`, |  |  |'
- en: '|  |  | `&=`, `^=`, `ǀ=` |  |  |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '|  |  | `&=`, `^=`, `ǀ=` |  |  |'
- en: '| 1 | R | `→` | arglist, method body | lambda expression |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| 1 | R | `→` | arglist, method body | lambda expression |'
- en: Operand number and type
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 操作数的数量和类型
- en: 'The fourth column of [Table 2-4](#javanut8-CHP-2-TABLE-4) specifies the number
    and type of the operands expected by each operator. Some operators operate on
    only one operand; these are called unary operators. For example, the unary minus
    operator changes the sign of a single number:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '[表格 2-4](#javanut8-CHP-2-TABLE-4)的第四列指定了每个运算符期望的操作数的数量和类型。有些运算符仅作用于一个操作数；这些被称为一元运算符。例如，一元减号运算符改变单个数字的符号：'
- en: '[PRE35]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Most operators, however, are binary operators that operate on two operand values.
    The `–` operator actually comes in both forms:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数运算符都是二元运算符，操作两个操作数的值。减号`–`运算符实际上有两种形式：
- en: '[PRE36]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Java also defines one ternary operator, often called the conditional operator.
    It is like an `if` statement inside an expression. Its three operands are separated
    by a question mark and a colon; the second and third operands must be convertible
    to the same type:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: Java还定义了一个三元运算符，通常称为条件运算符。它类似于表达式中的`if`语句。它的三个操作数由问号和冒号分隔；第二和第三个操作数必须可以转换为相同的类型：
- en: '[PRE37]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In addition to expecting a certain number of operands, each operator also expects
    particular types of operands. The fourth column of the table lists the operand
    types. Some of the codes used in that column require further explanation:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 除了期望特定数量的操作数外，每个运算符还期望特定类型的操作数。表中的第四列列出了操作数类型。该列中使用的一些代码需要进一步解释：
- en: Number
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 数字
- en: An integer, floating-point value, or character (i.e., any primitive type except
    `boolean`). Auto-unboxing (see [“Boxing and Unboxing Conversions”](#javanut8-CHP-2-SECT-9.4))
    means that the wrapper classes (such as `Character`, `Integer`, and `Double`)
    for these types can be used in this context as well.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 整数、浮点值或字符（即任何原始类型，除了`boolean`）。自动拆箱（参见[“装箱和拆箱转换”](#javanut8-CHP-2-SECT-9.4)）意味着这些类型的包装类（如`Character`、`Integer`和`Double`）也可以在此上下文中使用。
- en: Integer
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 整数
- en: A `byte`, `short`, `int`, `long`, or `char` value (`long` values are not allowed
    for the array access operator `[ ]`). With auto-unboxing, `Byte`, `Short`, `Integer`,
    `Long`, and `Character` values are also allowed.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`byte`、`short`、`int`、`long`或`char`值（数组访问操作符`[ ]`不允许`long`值）。使用自动拆箱，也可以允许`Byte`、`Short`、`Integer`、`Long`和`Character`值。'
- en: Reference
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 引用
- en: An object or array.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对象或数组。
- en: Variable
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 变量
- en: A variable or anything else, such as an array element, to which a value can
    be assigned.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 变量或其他任何可以分配值的内容，如数组元素。
- en: Return type
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回类型
- en: Just as every operator expects its operands to be of specific types, each operator
    produces a value of a specific type. The arithmetic, increment and decrement,
    bitwise, and shift operators return a `double` if at least one of the operands
    is a `double`. They return a `float` if at least one of the operands is a `float`.
    They return a `long` if at least one of the operands is a `long`. Otherwise, they
    return an `int`, even if both operands are `byte`, `short`, or `char` types that
    are narrower than `int`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 就像每个运算符期望其操作数具有特定的类型一样，每个运算符也产生特定类型的值。算术、递增和递减、位和移位运算符中，如果至少有一个操作数是`double`，则返回`double`。如果至少有一个操作数是`float`，则返回`float`。如果至少有一个操作数是`long`，则返回`long`。否则，返回`int`，即使两个操作数都是比`int`更窄的`byte`、`short`或`char`类型。
- en: The comparison, equality, and Boolean operators always return `boolean` values.
    Each assignment operator returns whatever value it assigned, which is of a type
    compatible with the variable on the left side of the expression. The conditional
    operator returns the value of its second or third argument (which must both be
    convertible to the same type).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 比较、相等和布尔运算符始终返回`boolean`值。每个赋值运算符返回其分配的值，该值与表达式左侧的变量兼容。条件运算符返回其第二或第三个参数的值（这两个参数必须可以转换为相同的类型）。
- en: Side effects
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 副作用
- en: Every operator computes a value based on one or more operand values. Some operators,
    however, have *side effects* in addition to their basic evaluation. If an expression
    contains side effects, evaluating it changes the state of a Java program in such
    a way that evaluating the expression again may yield a different result.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 每个运算符基于一个或多个操作数的值计算一个值。然而，一些运算符除了基本计算外，还有*副作用*。如果一个表达式包含副作用，评估它会改变Java程序的状态，因此再次评估表达式可能会产生不同的结果。
- en: For example, the `++` increment operator has the side effect of incrementing
    a variable. The expression `++a` increments the variable `a` and returns the newly
    incremented value. If this expression is evaluated again, the value will be different.
    The various assignment operators also have side effects. For example, the expression
    `a*=2` can also be written as `a=a*2`. The value of the expression is the value
    of `a` multiplied by 2, but the expression has the side effect of storing that
    value back into `a`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`++`增量运算符具有增加变量的副作用。表达式`++a`增加变量`a`并返回新增后的值。如果再次评估此表达式，则值将不同。各种赋值运算符也具有副作用。例如，表达式`a*=2`也可以写为`a=a*2`。表达式的值是`a`乘以2的值，但表达式具有将该值存储回`a`的副作用。
- en: The method invocation operator `()` has side effects if the invoked method has
    side effects. Some methods, such as `Math.sqrt()`, simply compute and return a
    value without side effects of any kind. Typically, however, methods do have side
    effects. Finally, the `new` operator has the profound side effect of creating
    a new object.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 方法调用运算符`()`如果调用的方法具有副作用，则具有副作用。例如`Math.sqrt()`等一些方法仅计算并返回值，没有任何副作用。通常情况下，方法确实具有副作用。最后，`new`运算符具有创建新对象的深远副作用。
- en: Order of evaluation
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 评估顺序
- en: 'When the Java interpreter evaluates an expression, it performs the various
    operations in an order specified by the parentheses in the expression, the precedence
    of the operators, and the associativity of the operators. Before any operation
    is performed, however, the interpreter first evaluates the operands of the operator.
    (The exceptions are the `&&`, `||`, and `?`: operators, which do not always evaluate
    all their operands.) The interpreter always evaluates operands in order from left
    to right. This matters if any of the operands are expressions that contain side
    effects. Consider this code, for example:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 当Java解释器评估表达式时，它根据表达式中括号的顺序、运算符的优先级和运算符的结合性执行各种操作。然而，在执行任何操作之前，解释器首先评估运算符的操作数。（但是，`&&`、`||`和`?`运算符除外，它们并不总是评估所有操作数。）解释器总是按从左到右的顺序评估操作数。如果操作数中有包含副作用的表达式，则这很重要。例如，考虑以下代码：
- en: '[PRE38]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Although the multiplication is performed before the addition, the operands of
    the `+` operator are evaluated first. As the operand of `++` are both `++a`, these
    are evaluated to `3` and `4`, and so the expression evaluates to `3 + 4 * 5`,
    or `23`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然乘法在加法之前执行，但`+`运算符的操作数首先被评估。因为`++`的操作数都是`++a`，它们被评估为`3`和`4`，因此表达式评估为`3 + 4
    * 5`，即`23`。
- en: Arithmetic Operators
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算术运算符
- en: 'The arithmetic operators can be used with integers, floating-point numbers,
    and even characters (i.e., they can be used with any primitive type other than
    `boolean`). If either of the operands is a floating-point number, floating-point
    arithmetic is used; otherwise, integer arithmetic is used. This matters because
    integer arithmetic and floating-point arithmetic differ in the way division is
    performed and in the way underflows and overflows are handled, for example. The
    arithmetic operators are:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 算术运算符可用于整数、浮点数，甚至字符（即它们可以用于除`boolean`以外的任何基本类型）。如果操作数中有任一操作数是浮点数，则使用浮点数算术；否则，使用整数算术。这很重要，因为整数算术和浮点数算术在执行除法的方式以及处理下溢和上溢的方式等方面有所不同。算术运算符包括：
- en: '*Addition* (`+`)'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '*加法* (`+`)'
- en: 'The `+` operator adds two numbers. As we’ll see shortly, the `+` operator can
    also be used to concatenate strings. If either operand of `+` is a string, the
    other one is converted to a string as well. Be sure to use parentheses when you
    want to combine addition with concatenation. For example:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`+`运算符添加两个数字。正如我们将很快看到的，`+`运算符也可以用于连接字符串。如果`+`的任一操作数是字符串，则另一个操作数也将转换为字符串。当您希望将加法与连接结合时，请务必使用括号。例如：'
- en: '[PRE39]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `+` operator can also be used in unary form to express a positive number,
    such as `+42`.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`+`运算符也可以作为一元运算符使用，表示正数，例如`+42`。'
- en: '*Subtraction* (`-`)'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '*减法* (`-`)'
- en: When the `-` operator is used as a binary operator, it subtracts its second
    operand from its first. For example, `7-3` evaluates to `4`. The `-` operator
    can also perform unary negation.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 当`-`运算符用作二元运算符时，它将其第二个操作数从第一个操作数中减去。例如，`7-3`的结果为`4`。`-`运算符还可以执行一元否定。
- en: '*Multiplication* (`*`)'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '*乘法* (`*`)'
- en: The `*` operator multiplies its two operands. For example, `7*3` evaluates to
    `21`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`*`运算符将其两个操作数相乘。例如，`7*3`的结果为`21`。'
- en: '*Division* (`/`)'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '*除法* (`/`)'
- en: 'The `/` operator divides its first operand by its second. If both operands
    are integers, the result is an integer, and any remainder is lost. If either operand
    is a floating-point value, however, the result is a floating-point value. When
    you divide two integers, division by zero throws an `ArithmeticException`. For
    floating-point calculations, however, division by zero simply yields an infinite
    result or `NaN`:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`/`运算符将其第一个操作数除以第二个操作数。如果两个操作数都是整数，则结果是整数，并且任何余数都会丢失。但是，如果任一操作数是浮点值，则结果是浮点值。当你除以零时，整数除法会抛出`ArithmeticException`。然而，对于浮点数计算，除以零会简单地产生一个无限的结果或`NaN`：'
- en: '[PRE40]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '*Modulo* (`%`)'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '*模运算*（`%`）'
- en: The `%` operator computes the first operand modulo the second operand (i.e.,
    it returns the remainder when the first operand is divided by the second operand
    an integral number of times). For example, `7%3` is `1`. The sign of the result
    is the same as the sign of the first operand. While the modulo operator is typically
    used with integer operands, it also works for floating-point values. For example,
    `4.3%2.1` evaluates to `0.1`. When you are operating with integers, trying to
    compute a value modulo zero causes an `ArithmeticException`. When you are working
    with floating-point values, anything modulo `0.0` evaluates to `NaN`, as does
    infinity modulo anything.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`%`运算符计算第一个操作数除以第二个操作数的余数（即，当第一个操作数被第二个操作数整除时的余数）。例如，`7%3`为`1`。结果的符号与第一个操作数的符号相同。虽然模运算符通常用于整数操作数，但它也适用于浮点值。例如，`4.3%2.1`评估为`0.1`。当你操作整数时，尝试计算模零的值会导致`ArithmeticException`。当你使用浮点值时，任何值模`0.0`都会评估为`NaN`，正如无穷大模任何值一样。'
- en: '*Unary minus* (`-`)'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '*一元减号*（`-`）'
- en: When the `-` operator is used as a unary operator—that is, before a single operand—it
    performs unary negation. In other words, it converts a positive value to an equivalently
    negative value, and vice versa.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 当`-`运算符用作一元运算符时——即在单个操作数之前时——它执行一元否定。换句话说，它将正值转换为等效的负值，反之亦然。
- en: String Concatenation Operator
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串连接运算符
- en: 'In addition to adding numbers, the `+` operator (and the related `+=` operator)
    also concatenates, or joins, strings. If either of the operands to `+` is a string,
    the operator converts the other operand to a string. For example:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 除了添加数字外，`+`运算符（以及相关的`+=`运算符）还可以连接或拼接字符串。如果`+`的任一操作数是字符串，则运算符会将另一个操作数转换为字符串。例如：
- en: '[PRE41]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As a result, you must be careful to put any addition expressions in parentheses
    when combining them with string concatenation. If you do not, the addition operator
    is interpreted as a concatenation operator.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在将任何附加表达式与字符串连接时，务必将其放在括号中。如果不这样做，加法运算符将被解释为连接运算符。
- en: Java has built-in string conversions for all primitive types. An object is converted
    to a string by invoking its `toString()` method. Some classes define custom `toString()`
    methods so that objects of that class can easily be converted to strings in this
    way. Sadly not all classes return friendly results when converted to strings.
    For example, the built-in `toString()` for an array doesn’t return a useful string
    representation of its contents, only information about the array object itself.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: Java为所有基本类型提供了内置的字符串转换。对象通过调用其`toString()`方法转换为字符串。一些类定义了自定义的`toString()`方法，以便可以轻松地将该类的对象转换为字符串。但遗憾的是，并非所有类在转换为字符串时都返回友好的结果。例如，数组的内置`toString()`并不返回其内容的有用字符串表示，而仅返回有关数组对象本身的信息。
- en: Increment and Decrement Operators
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递增和递减运算符
- en: The `++` operator increments its single operand, which must be a variable, an
    element of an array, or a field of an object, by 1\. The behavior of this operator
    depends on its position relative to the operand. When used before the operand,
    where it is known as the *pre-increment* operator, it increments the operand and
    evaluates to the incremented value of that operand. When used after the operand,
    where it is known as the *post-increment* operator, it increments its operand
    but evaluates to the value of that operand before it was incremented.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`++`运算符递增其单个操作数，该操作数必须是变量、数组的元素或对象的字段，递增量为1。此运算符的行为取决于其相对于操作数的位置。当用于操作数之前时，称为*前递增*运算符，它递增操作数并评估为递增后的值。当用于操作数之后时，称为*后递增*运算符，它递增其操作数但评估为递增前的值。'
- en: 'For example, the following code sets both `i` and `j` to 2:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码将`i`和`j`都设置为2：
- en: '[PRE42]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'But these lines set `i` to 2 and `j` to 1:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这些行将`i`设置为2，`j`设置为1：
- en: '[PRE43]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Similarly, the `--` operator decrements its single numeric operand, which must
    be a variable, an element of an array, or a field of an object, by one. Like the
    `++` operator, the behavior of `--` depends on its position relative to the operand.
    When used before the operand, it decrements the operand and returns the decremented
    value. When used after the operand, it decrements the operand but returns the
    *undecremented* value.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，`--`运算符将其单个数值操作数递减1。与`++`运算符类似，`--`的行为取决于其相对于操作数的位置。当在操作数之前使用时，它会递减操作数并返回递减后的值。当在操作数之后使用时，它会递减操作数但返回*未递减*的值。
- en: 'The expressions `x++` and `x--` are equivalent to `x = x + 1` and `x = x -
    1`, respectively, except that when you are using the increment and decrement operators,
    `x` is evaluated only once. If `x` is itself an expression with side effects,
    this makes a big difference. For example, these two expressions are not equivalent,
    as the second form increments `i` twice:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式`x++`和`x--`分别等同于`x = x + 1`和`x = x - 1`，但是当你使用增量和减量运算符时，`x`只计算一次。如果`x`本身是一个具有副作用的表达式，这将产生很大的不同。例如，这两个表达式并不等同，因为第二种形式会使`i`增加两次：
- en: '[PRE44]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: These operators, in both prefix and postfix forms, are most commonly used to
    increment or decrement the counter that controls a loop. However, an increasing
    number of programmers prefer to avoid using the increment and decrement operators
    altogether, preferring to use explicit code. This view is motivated by the large
    number of bugs that have, historically, been caused by incorrect usage of the
    operators.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这些运算符，无论是前缀还是后缀形式，最常用于增加或减少控制循环计数器。然而，越来越多的程序员更喜欢避免使用增量和减量运算符，而是更喜欢使用显式的代码。这种观点是由于历史上由于操作符的错误使用而导致的大量bug。
- en: Comparison Operators
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较运算符
- en: 'The comparison operators consist of the equality operators that test values
    for equality or inequality and the relational operators used with ordered types
    (numbers and characters) to test for greater than and less than relationships.
    Both types of operators yield a `boolean` result, so they are typically used with
    `if` statements, the ternary conditional operator, or `while` and `for` loops
    to make branching and looping decisions. For example:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 比较运算符包括测试值是否相等或不等的相等运算符和与有序类型（数字和字符）一起使用的关系运算符。这两种类型的运算符产生一个`boolean`结果，因此它们通常与`if`语句、三元条件运算符或`while`和`for`循环一起使用，以进行分支和循环决策。例如：
- en: '[PRE45]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Java provides the following equality operators:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: Java提供以下相等运算符：
- en: '*Equals* (`==`)'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '*等于* (`==`)'
- en: The `==` operator evaluates to `true` if its two operands are equal and `false`
    otherwise. With primitive operands, it tests whether the operand values themselves
    are identical. For operands of reference types, however, it tests whether the
    operands refer to the same object or array. In other words, it does not test the
    equality of two distinct objects or arrays. In particular, note that you cannot
    test two distinct strings for equality with this operator.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`==`运算符在其两个操作数相等时求值为`true`，否则为`false`。对于原始操作数，它测试操作数值本身是否相同。然而，对于引用类型的操作数，它测试操作数是否引用同一个对象或数组。换句话说，它不测试两个不同的对象或数组的相等性。特别地，请注意，你不能使用此运算符测试两个不同的字符串是否相等。'
- en: Warning
  id: totrans-326
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: If you experiment comparing strings via `==` you may see results that suggest
    it works properly. This is a side effect of Java’s internal caching of strings,
    known as *interning*. The only reliable way to compare strings (or any other reference
    type for that matter) for equality is the `equals()` method.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你通过`==`比较字符串，可能会看到结果表明它正常工作。这是Java内部字符串缓存的副作用，称为*interning*。比较字符串（或任何其他引用类型）的唯一可靠方法是使用`equals()`方法。
- en: The same applies with primitive wrapper classes, so `new Integer(1) != new Integer(1)`,
    while the preferred `Integer.valueOf(1) == Integer.valueOf(1)` does. The lesson
    is clearly that looking at equality on any nonprimitive type should be done with
    `equals()`. More discussion of object equality can be found in [“equals()”](ch05.xhtml#javanut8-CHP-5-SECT-2-2).
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基本包装类也是一样的，所以`new Integer(1) != new Integer(1)`，而推荐的`Integer.valueOf(1) ==
    Integer.valueOf(1)`则相等。显然，任何非原始类型的等式比较都应该使用`equals()`方法。关于对象等式的更多讨论可以在[“equals()”](ch05.xhtml#javanut8-CHP-5-SECT-2-2)中找到。
- en: If `==` is used to compare two numeric or character operands that are not of
    the same type, the narrower operand is converted to the type of the wider operand
    before the comparison is done. For example, when you are comparing a `short` to
    a `float`, the `short` is first converted to a `float` before the comparison is
    performed. For floating-point numbers, the special negative zero value tests equal
    to the regular, positive zero value. Also, the special `NaN` (Not a Number) value
    is not equal to any other number, including itself. To test whether a floating-point
    value is `NaN`, use the `Float.isNan()` or `Double.isNan()` method.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用`==`比较两个不同类型的数值或字符操作数，窄操作数在比较之前会被转换为宽操作数的类型。例如，当你比较一个`short`和一个`float`时，`short`会先转换为`float`再进行比较。对于浮点数，特殊的负零值与常规的正零值相等。此外，特殊的`NaN`（不是一个数字）值不等于任何其他数字，包括自身。要测试浮点数值是否为`NaN`，可以使用`Float.isNan()`或`Double.isNan()`方法。
- en: '*Not equals* (`!=`)'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '*不等于* (`!=`)'
- en: The `!=` operator is exactly the opposite of the `==` operator. It evaluates
    to `true` if its two primitive operands have different values or if its two reference
    operands refer to different objects or arrays. Otherwise, it evaluates to `false`.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '`!=`运算符与`==`运算符正好相反。如果其两个基本操作数具有不同的值，或者其两个引用操作数引用不同的对象或数组，则评估为`true`。否则，评估为`false`。'
- en: The relational operators can be used with numbers and characters but not with
    `boolean` values, objects, or arrays because those types are not ordered.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 关系运算符可以用于数字和字符，但不能用于`boolean`值、对象或数组，因为这些类型没有顺序。
- en: 'Java provides the following relational operators:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: Java提供以下关系运算符：
- en: '*Less than* (`<`)'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '*小于* (`<`)'
- en: Evaluates to `true` if the first operand is less than the second.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一个操作数小于第二个，则评估为`true`。
- en: '*Less than or equal* (`<=`)'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '*小于或等于* (`<=`)'
- en: Evaluates to `true` if the first operand is less than or equal to the second.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一个操作数小于或等于第二个，则评估为`true`。
- en: '*Greater than* (`>`)'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '*大于* (`>`)'
- en: Evaluates to `true` if the first operand is greater than the second.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一个操作数大于第二个，则评估为`true`。
- en: '*Greater than or equal* (`>=`)'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '*大于或等于* (`>=`)'
- en: Evaluates to `true` if the first operand is greater than or equal to the second.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一个操作数大于或等于第二个，则评估为`true`。
- en: Boolean Operators
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔运算符
- en: 'As we’ve just seen, the comparison operators compare their operands and yield
    a `boolean` result, which is often used in branching and looping statements. In
    order to make branching and looping decisions based on conditions more interesting
    than a single comparison, you can use the Boolean (or logical) operators to combine
    multiple comparison expressions into a single, more complex expression. The Boolean
    operators require their operands to be `boolean` values and they evaluate to `boolean`
    values. The operators are:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚刚看到的，比较运算符比较它们的操作数，并产生一个`boolean`结果，通常用于分支和循环语句。为了使基于条件的分支和循环决策更有趣，而不仅仅是单个比较，你可以使用布尔（或逻辑）运算符将多个比较表达式组合成一个单一的、更复杂的表达式。布尔运算符要求其操作数为`boolean`值，并评估为`boolean`值。这些运算符包括：
- en: '*Conditional AND* (`&&`)'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '*条件与* (`&&`)'
- en: 'This operator performs a Boolean AND operation on its operands. It evaluates
    to `true` if and only if both its operands are `true`. If either or both operands
    are `false`, it evaluates to `false`. For example:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 此运算符对其操作数执行布尔AND操作。如果且仅当其两个操作数都为`true`时，评估为`true`。如果其中一个或两个操作数为`false`，则评估为`false`。例如：
- en: '[PRE46]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This operator (and all the Boolean operators except the unary `!` operator)
    have a lower precedence than the comparison operators. Thus, it is perfectly legal
    to write a line of code like the one just shown. However, some programmers prefer
    to use parentheses to make the order of evaluation explicit:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 此运算符（以及所有布尔运算符，除了一元`!`运算符外）的优先级低于比较运算符。因此，像刚刚显示的代码行是完全合法的。但是，一些程序员喜欢使用括号来显式地指定评估顺序：
- en: '[PRE47]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: You should use whichever style you find easier to read.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该使用你觉得阅读更容易的风格。
- en: 'This operator is called a conditional AND because it conditionally evaluates
    its second operand. If the first operand evaluates to `false`, the value of the
    expression is `false`, regardless of the value of the second operand. Therefore,
    to increase efficiency, the Java interpreter takes a shortcut and skips the second
    operand. The second operand is not guaranteed to be evaluated, so you must use
    caution when using this operator with expressions that have side effects. On the
    other hand, the conditional nature of this operator allows us to write Java expressions
    such as the following:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这个运算符称为条件AND，因为它有条件地评估其第二个操作数。如果第一个操作数评估为`false`，则表达式的值为`false`，无论第二个操作数的值如何。因此，为了提高效率，Java解释器采取了一种捷径，并跳过第二个操作数。不能保证评估第二个操作数，因此在使用具有副作用的表达式与此运算符时必须小心。另一方面，此运算符的条件性质允许我们编写如下的Java表达式：
- en: '[PRE48]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The second and third comparisons in this expression would cause errors if the
    first or second comparisons evaluated to `false`. Fortunately, we don’t have to
    worry about this because of the conditional behavior of the `&&` operator.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 此表达式中的第二个和第三个比较如果第一个或第二个比较结果为`false`将导致错误。幸运的是，由于`&&`运算符的条件行为，我们不必担心这个问题。
- en: '*Conditional OR* (`||`)'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '*条件或* (`||`)'
- en: This operator performs a Boolean OR operation on its two `boolean` operands.
    It evaluates to `true` if either or both of its operands are `true`. If both operands
    are `false`, it evaluates to `false`. Like the `&&` operator, `||` does not always
    evaluate its second operand. If the first operand evaluates to `true`, the value
    of the expression is `true`, regardless of the value of the second operand. Thus,
    the operator simply skips the second operand in that case.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 这个运算符在其两个`boolean`操作数上执行布尔OR操作。如果其任一或两个操作数为`true`，则评估为`true`。如果两个操作数都为`false`，则评估为`false`。与`&&`运算符类似，`||`运算符并不总是评估其第二个操作数。如果第一个操作数评估为`true`，则表达式的值为`true`，无论第二个操作数的值如何。因此，在这种情况下，该运算符简单地跳过第二个操作数。
- en: '*Boolean NOT* (`!`)'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '*布尔非* (`!`)'
- en: 'This unary operator changes the `boolean` value of its operand. If applied
    to a `true` value, it evaluates to `false`, and if applied to a `false` value,
    it evaluates to `true`. It is useful in expressions like these:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 此一元运算符改变其操作数的`boolean`值。如果应用于`true`值，则评估为`false`，如果应用于`false`值，则评估为`true`。在这些表达式中很有用：
- en: '[PRE49]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Because `!` is a unary operator, it has a high precedence and often must be
    used with parentheses:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`!`是一元运算符，具有很高的优先级，并且通常必须与括号一起使用：
- en: '[PRE50]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '*Boolean AND* (`&`)'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '*布尔与* (`&`)'
- en: When used with `boolean` operands, the `&` operator behaves like the `&&` operator,
    except that it always evaluates both operands, regardless of the value of the
    first operand. This operator is almost always used as a bitwise operator with
    integer operands, however, and many Java programmers would not even recognize
    its use with `boolean` operands as legal Java code.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 当与`boolean`操作数一起使用时，`&`运算符的行为类似于`&&`运算符，但始终评估两个操作数，而不管第一个操作数的值如何。然而，此运算符几乎总是作为整数操作数的位运算符使用，因此许多Java程序员甚至不会认识其在`boolean`操作数中作为合法Java代码的使用。
- en: '*Boolean OR* (`|`)'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '*布尔或* (`|`)'
- en: This operator performs a Boolean OR operation on its two `boolean` operands.
    It is like the `||` operator, except that it always evaluates both operands, even
    if the first one is `true`. The `|` operator is almost always used as a bitwise
    operator on integer operands; its use with `boolean` operands is very rare.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 这个运算符在其两个`boolean`操作数上执行布尔OR操作。它与`||`运算符类似，但始终评估两个操作数，即使第一个操作数为`true`。`|`运算符几乎总是用作整数操作数的位运算符；在`boolean`操作数中很少见到其使用。
- en: '*Boolean XOR* (`^`)'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '*布尔异或* (`^`)'
- en: When used with `boolean` operands, this operator computes the exclusive OR (XOR)
    of its operands. It evaluates to `true` if exactly one of the two operands is
    `true`. In other words, it evaluates to `false` if both operands are `false` or
    if both operands are `true`. Unlike the `&&` and `||` operators, this one must
    always evaluate both operands. The `^` operator is much more commonly used as
    a bitwise operator on integer operands. With `boolean` operands, this operator
    is equivalent to the `!=` operator.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 当与`boolean`操作数一起使用时，此运算符计算其操作数的异或（XOR）。如果两个操作数中恰好一个为`true`，则评估为`true`。换句话说，如果两个操作数都为`false`或者两个操作数都为`true`，则评估为`false`。与`&&`和`||`运算符不同，此运算符必须始终评估两个操作数。`^`运算符在整数操作数中作为位运算符使用得更为常见。对于`boolean`操作数，此运算符等同于`!=`运算符。
- en: Bitwise and Shift Operators
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 位运算符和移位运算符
- en: The bitwise and shift operators are low-level operators that manipulate the
    individual bits that make up an integer value. The bitwise operators are not commonly
    used in modern Java except for low-level work (e.g., network programming). They
    are used for testing and setting individual flag bits in a value. To understand
    their behavior, you must understand binary (base-2) numbers and the two’s complement
    format used to represent negative integers.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 位与移位运算符是操作整数值中构成其个别位的低级运算符。位运算符在现代Java中不常用，除非进行低级工作（例如网络编程）。它们用于测试和设置值中的单个标志位。要理解它们的行为，您必须理解用于表示负整数的二进制（基数2）数和两补码格式。
- en: You cannot use these operators with floating-point, `boolean`, array, or object
    operands. When used with `boolean` operands, the `&`, `|`, and `^` operators perform
    a different operation, as described in the previous section.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能将这些运算符与浮点、`boolean`、数组或对象操作数一起使用。当与`boolean`操作数一起使用时，`&`、`|`和`^`运算符执行不同的操作，如前一节所述。
- en: 'If either of the arguments to a bitwise operator is a `long`, the result is
    a `long`. Otherwise, the result is an `int`. If the left operand of a shift operator
    is a `long`, the result is a `long`; otherwise, the result is an `int`. The operators
    are:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 如果位运算符的任一参数是`long`，则结果是`long`。否则，结果是`int`。如果位移运算符的左操作数是`long`，则结果是`long`；否则，结果是`int`。这些运算符是：
- en: '*Bitwise complement* (`~`)'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '*位取反*（`~`）'
- en: 'The unary `~` operator is known as the bitwise complement, or bitwise NOT,
    operator. It inverts each bit of its single operand, converting 1s to 0s and 0s
    to 1s. For example:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 一元`~`运算符称为位取反或位NOT运算符。它反转其单个操作数的每个位，将1转换为0，将0转换为1。例如：
- en: '[PRE51]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '*Bitwise AND* (`&`)'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '*位与*（`&`）'
- en: 'This operator combines its two integer operands by performing a Boolean AND
    operation on their individual bits. The result has a bit set only if the corresponding
    bit is set in both operands. For example:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 该运算符通过对其两个整数操作数的各自位执行布尔AND运算来结合它们。只有在两个操作数中的相应位都设置时，结果才具有一个位设置。例如：
- en: '[PRE52]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: When used with `boolean` operands, `&` is the infrequently used Boolean AND
    operator described earlier.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`boolean`操作数时，`&`是之前描述的不常用的布尔AND运算符。
- en: '*Bitwise OR* (`|`)'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '*位或*（`|`）'
- en: 'This operator combines its two integer operands by performing a Boolean OR
    operation on their individual bits. The result has a bit set if the corresponding
    bit is set in either or both of the operands. It has a zero bit only where both
    corresponding operand bits are zero. For example:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 该运算符通过对其两个整数操作数的各自位执行布尔OR运算来结合它们。如果相应位在一个或两个操作数中被设置，则结果有一个位设置。仅在两个相应操作数位都为零时，它具有零位。例如：
- en: '[PRE53]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: When used with `boolean` operands, `|` is the infrequently used Boolean OR operator
    described earlier.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 当与`boolean`操作数一起使用时，`|`是之前描述的不常用的布尔OR运算符。
- en: '*Bitwise XOR* (`^`)'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '*位异或*（`^`）'
- en: 'This operator combines its two integer operands by performing a Boolean XOR
    (exclusive OR) operation on their individual bits. The result has a bit set if
    the corresponding bits in the two operands are different. If the corresponding
    operand bits are both 1s or both 0s, the result bit is a 0\. For example:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 该运算符通过对其各自位执行布尔异或（exclusive OR）操作来结合其两个整数操作数的位。如果两个操作数中的对应位不同，则结果具有一个位设置。如果对应的操作数位都是1或都是0，则结果位为0。例如：
- en: '[PRE54]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: When used with `boolean` operands, `^` is the seldom used Boolean XOR operator.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 当与`boolean`操作数一起使用时，`^`是很少使用的布尔XOR运算符。
- en: '*Left shift* (`<<`)'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '*左移*（`<<`）'
- en: 'The `<<` operator shifts the bits of the left operand left by the number of
    places specified by the right operand. High-order bits of the left operand are
    lost, and zero bits are shifted in from the right. Shifting an integer left by
    *n* places is equivalent to multiplying that number by 2^(*n*). For example:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '`<<`运算符将左操作数的位左移右操作数指定的位数。左操作数的高阶位将丢失，并且从右侧移入零位。将整数左移*n*位等效于将该数字乘以2^(*n*)。例如：'
- en: '[PRE55]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: If the left operand is a `long`, the right operand should be between 0 and 63\.
    Otherwise, the left operand is taken to be an `int`, and the right operand should
    be between 0 and 31\. If either of these ranges is exceeded, you may see unintuitive
    wrapping behavior from these operators.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 如果左操作数是`long`，则右操作数应在0到63之间。否则，左操作数被视为`int`，右操作数应在0到31之间。如果超出这些范围，则可能会看到这些运算符的不直观的包装行为。
- en: '*Signed right shift* (`>>`)'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '*有符号右移*（`>>`）'
- en: 'The `>>` operator shifts the bits of the left operand to the right by the number
    of places specified by the right operand. The low-order bits of the left operand
    are shifted away and are lost. The high-order bits shifted in are the same as
    the original high-order bit of the left operand. In other words, if the left operand
    is positive, 0s are shifted into the high-order bits. If the left operand is negative,
    1s are shifted in instead. This technique is known as *sign extension*; it is
    used to preserve the sign of the left operand. For example:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '`>>` 运算符将左操作数的位向右移动右操作数指定的位数。左操作数的低位位移并丢失。位于左操作数中的高位位移相同于原始左操作数的高位位。换句话说，如果左操作数为正，则将
    0 移入高位位。如果左操作数为负，则移入的是 1。这种技术称为*符号扩展*；它用于保留左操作数的符号。例如：'
- en: '[PRE56]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: If the left operand is positive and the right operand is *n*, the `>>` operator
    is the same as integer division by 2^(*n*).
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 如果左操作数为正，右操作数为 *n*，则 `>>` 运算符与整数除法相同除以 2^(*n*)。
- en: '*Unsigned right shift* (`>>>`)'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '*无符号右移* (`>>>`)'
- en: 'This operator is like the `>>` operator, except that it always shifts zeros
    into the high-order bits of the result, regardless of the sign of the lefthand
    operand. This technique is called *zero extension*; it is appropriate when the
    left operand is being treated as an unsigned value (despite the fact that Java
    integer types are all signed). These are examples:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 此运算符类似于 `>>` 运算符，但它总是将零移入结果的高阶位，而不管左操作数的符号如何。这种技术称为*零扩展*；当左操作数被视为无符号值时（尽管 Java
    整数类型都是有符号的），这是适当的。以下是示例：
- en: '[PRE57]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Assignment Operators
  id: totrans-396
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 赋值运算符
- en: The assignment operators store, or assign, a value into a piece of the computer’s
    memory--often referred to as a *storage location*. The left operand must evaluate
    to an appropriate local variable, array element, or object field.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值运算符将值存储或分配到计算机的一部分内存中--通常称为*存储位置*。左操作数必须评估为适当的局部变量，数组元素或对象字段。
- en: Note
  id: totrans-398
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The lefthand side of an assignment expression is sometimes called an `*lvalue*`.
    In Java it must refer to some assignable storage (i.e., memory that can be written
    to).
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值表达式的左操作数有时被称为 `*lvalue*`。在 Java 中，它必须引用一些可赋值的存储（即可写入的内存）。
- en: The righthand side (the `*rvalue*`) can be any value of a type compatible with
    the variable. An assignment expression evaluates to the value that is assigned
    to the variable. More importantly, however, the expression has the side effect
    of actually performing the assignment—​storing the `rvalue` in the `lvalue`.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 右操作数（`*rvalue*`）可以是与变量兼容的任何类型的值。赋值表达式的评估结果是分配给变量的值。然而，更重要的是，该表达式具有实际执行分配的副作用—将
    `rvalue` 存储在 `lvalue` 中。
- en: Tip
  id: totrans-401
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'Unlike all other binary operators, the assignment operators are right-associative,
    which means that the assignments in `a=b=c` are performed right to left, as follows:
    `a=(b=c)`.'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有其他二进制运算符不同，赋值运算符是右关联的，这意味着 `a=b=c` 中的赋值是从右向左执行的，如下所示： `a=(b=c)`。
- en: The basic assignment operator is `=`. Do not confuse it with the equality operator,
    `==`. To keep these two operators distinct, we recommend that you read `=` as
    “is assigned the value.”
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 基本赋值运算符是 `=`。不要将其与相等运算符 `==` 混淆。为了区分这两个运算符，我们建议将 `=` 读作“被赋予值”。
- en: 'In addition to this simple assignment operator, Java also defines 11 other
    operators that combine assignment with the 5 arithmetic operators and the 6 bitwise
    and shift operators. For example, the `+=` operator reads the value of the left
    variable, adds the value of the right operand to it, stores the sum back into
    the left variable as a side effect, and returns the sum as the value of the expression.
    Thus, the expression `x+=2` is almost the same as `x=x+2`. The difference between
    these two expressions is that when you use the `+=` operator, the left operand
    is evaluated only once. This makes a difference when that operand has a side effect.
    Consider the following two expressions, which are not equivalent:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个简单的赋值运算符之外，Java 还定义了另外 11 个将赋值与 5 个算术运算符和 6 个位和移位运算符结合的运算符。例如，`+=` 运算符读取左变量的值，将右操作数的值添加到它中，作为副作用将总和存储回左变量，并返回总和作为表达式的值。因此，表达式
    `x+=2` 几乎与 `x=x+2` 相同。这两个表达式之间的区别在于当您使用 `+=` 运算符时，左操作数只被评估一次。当该操作数具有副作用时，这是有区别的。考虑以下两个不等式：
- en: '[PRE58]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The general form of these combination assignment operators is:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组合赋值运算符的一般形式是：
- en: '[PRE59]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This is equivalent (unless there are side effects in `lvalue`) to:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 这与以下内容等效（除非在 `lvalue` 中存在副作用）：
- en: '[PRE60]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The available operators are:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的运算符有：
- en: '[PRE61]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The most commonly used operators are `+=` and `-=`, although `&=` and `|=`
    can also be useful when you are working with `boolean` or bitwise flags. For example:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的运算符是 `+=` 和 `-=`，尽管 `&=` 和 `|=` 在处理布尔值或位标志时也很有用。例如：
- en: '[PRE62]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The Conditional Operator
  id: totrans-414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件运算符
- en: 'The conditional operator `?`: is a somewhat obscure ternary (three-operand)
    operator inherited from C. It allows you to embed a conditional within an expression.
    You can think of it as the operator version of the `if/else` statement. The first
    and second operands of the conditional operator are separated by a question mark
    (`?`), while the second and third operands are separated by a colon (:). The first
    operand must evaluate to a `boolean` value. The second and third operands can
    be of any type, but they must be convertible to the same type.'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '条件运算符 `?`: 是从C语言继承过来的一个有些晦涩的三元（三操作数）运算符。它允许你在表达式中嵌入条件判断。你可以将它视为`if/else`语句的运算符版本。条件运算符的第一和第二操作数之间用问号
    (`?`) 分隔，第二和第三操作数之间用冒号 (`:`) 分隔。第一操作数必须求值为布尔值。第二和第三操作数可以是任何类型，但它们必须可转换为相同的类型。'
- en: 'The conditional operator starts by evaluating its first operand. If it is `true`,
    the operator evaluates its second operand and uses that as the value of the expression.
    On the other hand, if the first operand is `false`, the conditional operator evaluates
    and returns its third operand. The conditional operator never evaluates both its
    second and third operand, so be careful when using expressions with side effects
    with this operator. Examples of this operator are:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 条件运算符首先评估其第一个操作数。如果它为 `true`，则运算符评估其第二个操作数并将其用作表达式的值。另一方面，如果第一个操作数为 `false`，则条件运算符评估并返回其第三个操作数。条件运算符永远不会同时评估其第二和第三个操作数，因此在使用具有副作用的表达式时要小心。此运算符的示例有：
- en: '[PRE63]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Note that the `?`: operator has lower precedence than all other operators except
    the assignment operators, so parentheses are not usually necessary around the
    operands of this operator. Many programmers find conditional expressions easier
    to read if the first operand is placed within parentheses, however. This is especially
    true because the conditional `if` statement always has its conditional expression
    written within parentheses.'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '注意，`?`: 运算符的优先级低于除赋值运算符之外的所有其他运算符，因此通常不需要在此运算符的操作数周围使用括号。然而，许多程序员发现如果将第一个操作数放在括号内，条件表达式更易于阅读。这一点尤其重要，因为条件
    `if` 语句总是将其条件表达式写在括号内。'
- en: The instanceof Operator
  id: totrans-419
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: instanceof 运算符
- en: The `instanceof` operator is intimately bound up with objects and the operation
    of the Java type system. If this is your first look at Java, it may be preferable
    to skim this definition and return to this section after you have a decent grasp
    of Java’s objects.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '`instanceof` 运算符与对象和Java类型系统的操作密切相关。如果这是您第一次了解Java，可能最好先略过这个定义，等您对Java的对象有了较好的理解后再回到这部分。'
- en: '`instanceof` requires an object or array value as its left operand and the
    name of a reference type as its right operand. In its basic form, it evaluates
    to `true` if the object or array is an *instance* of the specified type; it returns
    `false` otherwise. If the left operand is `null`, `instanceof` always evaluates
    to `false`. If an `instanceof` expression evaluates to `true`, it means that you
    can safely cast and assign the left operand to a variable of the type of the right
    operand.'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '`instanceof` 要求其左操作数为对象或数组值，右操作数为引用类型的名称。在其基本形式中，如果对象或数组是指定类型的*实例*，则它评估为 `true`；否则返回
    `false`。如果左操作数为 `null`，`instanceof` 总是评估为 `false`。如果 `instanceof` 表达式评估为 `true`，这意味着您可以安全地将左操作数强制转换并赋值给右操作数类型的变量。'
- en: 'The `instanceof` operator can be used only with reference types and objects,
    not primitive types and values. Examples of `instanceof` are:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '`instanceof` 运算符只能与引用类型和对象一起使用，不能与基本类型和值一起使用。`instanceof` 的示例有：'
- en: '[PRE64]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In Java 17 `instanceof` has an extended form known as *pattern matching*. The
    final example above demonstrates a common pattern-checking `instanceof` and then
    casting to the type within a conditional. With pattern matching we can express
    this all at once by including a variable after the reference type. If `instanceof`
    sees the type is compatible, the variable is assigned the casted object.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 17 中，`instanceof` 有一个被称为*模式匹配*的扩展形式。上面最后的示例展示了一个常见的模式检查 `instanceof`，然后在条件中将其转换为类型。使用模式匹配，我们可以一次性地表达这一切，包括引用类型后面的变量。如果
    `instanceof` 看到类型兼容，变量将被赋予转换后的对象。
- en: '[PRE65]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This sort of pattern matching is a recent addition in Java. Upcoming releases
    are expected to provide more of these sorts of convenience throughout the language.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式匹配是 Java 中的一个最新添加。预计未来的版本将在整个语言中提供更多此类便利功能。
- en: Historically using `instanceof` was discouraged in favor of other more object-oriented
    solutions we’ll see in [Chapter 5](ch05.xhtml#javanut8-CHP-5). Java’s increasing
    adoption of pattern matching, though, is changing attitudes about this operator.
    `instanceof` is especially well suited to the common scenarios around receiving
    data in unpredictable formats through an API and is often a pragmatic option these
    days rather than a last resort.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 历史上，鼓励使用 `instanceof` 以支持其他更面向对象的解决方案，我们将在 [Chapter 5](ch05.xhtml#javanut8-CHP-5)
    中看到。然而，Java 对模式匹配的日益采用正在改变对这个运算符的态度。在通过 API 接收不可预测格式的数据的常见情况下，`instanceof` 尤其适合，并且这些天通常是一种务实的选择，而不是最后的手段。
- en: Special Operators
  id: totrans-428
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊运算符
- en: 'Java has six language constructs that are sometimes considered operators and
    sometimes considered simply part of the basic language syntax. These “operators”
    were included in [Table 2-4](#javanut8-CHP-2-TABLE-4) to show their precedence
    relative to the other true operators. The use of these language constructs is
    detailed elsewhere in this book, but it is described briefly here so that you
    can recognize them in code examples:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: Java 有六种语言构造，有时被认为是运算符，有时被认为仅仅是基本语言语法的一部分。这些“运算符”在 [Table 2-4](#javanut8-CHP-2-TABLE-4)
    中列出，以显示它们相对于其他真正运算符的优先级。这些语言构造的使用在本书的其他地方有详细说明，但在这里简要描述，以便您能够在代码示例中识别它们：
- en: '*Member access* (`.`)'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '*成员访问*（`.`）'
- en: An *object* is a collection of data and methods that operate on that data; the
    data fields and methods of an object are called its members. The dot (.) operator
    accesses these members. If `o` is an expression that evaluates to an object reference
    (or a class name), and `f` is the name of a field of the class, `o.f` evaluates
    to the value contained in that field. If `m` is the name of a method, `o.m` refers
    to that method and allows it to be invoked using the `()` operator shown later.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*对象*是一组操作数据和操作该数据的方法的集合；对象的数据字段和方法称为其成员。点（.）运算符用于访问这些成员。如果 `o` 是一个求值为对象引用（或类名）的表达式，并且
    `f` 是类的字段名，则 `o.f` 求值为该字段包含的值。如果 `m` 是一个方法名，则 `o.m` 引用该方法并允许使用稍后显示的 `()` 运算符调用它。
- en: '*Array element access* (`[]`)'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '*数组元素访问*（`[]`）'
- en: An *array* is a numbered list of values. Each element of an array can be referred
    to by its number, or *index*. The `[ ]` operator allows you to refer to the individual
    elements of an array. If `a` is an array, and `i` is an expression that evaluates
    to an `int`, `a[i]` refers to one of the elements of `a`. Unlike other operators
    that work with integer values, this operator restricts array index values to be
    of type `int` or narrower.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*数组*是值的编号列表。数组的每个元素可以通过其编号或*索引*引用。`[]` 运算符允许您引用数组的单个元素。如果 `a` 是一个数组，并且 `i`
    是一个求值为 `int` 的表达式，则 `a[i]` 引用数组 `a` 的一个元素。与处理整数值的其他运算符不同，此运算符将数组索引值限制为 `int` 类型或更窄。
- en: '*Method invocation* (`()`)'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '*方法调用*（`()`）'
- en: A *method* is a named collection of Java code that can be run, or *invoked*,
    by following the name of the method with zero or more comma-separated expressions
    contained within parentheses. The values of these expressions are the *arguments*
    to the method. The method processes the arguments and optionally returns a value
    that becomes the value of the method invocation expression. If `o.m` is a method
    that expects no arguments, the method can be invoked with `o.m()`. If the method
    expects three arguments, for example, it can be invoked with an expression such
    as `o.m(x,y,z)`. `o` is referred to as the *receiver* of the method—if `o` is
    an object, then it is said to be the *receiver object*. Before the Java interpreter
    invokes a method, it evaluates each of the arguments to be passed to the method.
    These expressions are guaranteed to be evaluated in order from left to right (which
    matters if any of the arguments have side effects).
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '*方法*是一组命名的Java代码，可以通过在方法名后跟随零个或多个逗号分隔的表达式括在括号中来运行或*调用*。这些表达式的值是方法的*参数*。方法处理这些参数并可选择返回一个值，该值成为方法调用表达式的值。如果`o.m`是一个不带参数的方法，则可以使用`o.m()`来调用该方法。例如，如果方法期望三个参数，则可以使用表达式`o.m(x,y,z)`来调用它。`o`称为方法的*接收者*
    —— 如果`o`是一个对象，则称其为*接收对象*。在Java解释器调用方法之前，它会评估要传递给方法的每个参数。这些表达式将按从左到右的顺序进行评估（如果其中任何一个参数具有副作用，则这一点很重要）。'
- en: '*Lambda expression* (`->`)'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '*Lambda表达式* (`->`)'
- en: A *lambda expression* is an anonymous collection of executable Java code, essentially
    a method body. It consists of a method argument list (zero or more comma-separated
    expressions contained within parentheses) followed by the lambda *arrow* operator
    followed by a block of Java code. If the block of code comprises just a single
    statement, then the usual curly braces to denote block boundaries can be omitted.
    If the lambda takes only a single argument, the parentheses around the argument
    can be omitted.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '*Lambda表达式*是一个匿名的可执行Java代码集合，本质上是一个方法体。它由一个方法参数列表（零个或多个逗号分隔的表达式括在括号中）后跟lambda*箭头*运算符，然后是一段Java代码块组成。如果代码块只包含单个语句，则可以省略通常用于标识块边界的大括号。如果lambda只接受一个参数，则可以省略参数周围的括号。'
- en: '*Object creation* (`new`)'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '*对象创建* (`new`)'
- en: 'In Java, objects are created with the `new` operator, which is followed by
    the type of the object to be created and a parenthesized list of arguments to
    be passed to the object *constructor*. A constructor is a special block of code
    that initializes a newly created object, so the object creation syntax is similar
    to the Java method invocation syntax. For example:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，对象是使用`new`运算符创建的，后面跟着要创建的对象类型和用括号括起的要传递给对象*构造函数*的参数列表。构造函数是一个特殊的代码块，用于初始化新创建的对象，因此对象创建语法类似于Java方法调用语法。例如：
- en: '[PRE66]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '*Array creation* (`new`)'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '*数组创建* (`new`)'
- en: Arrays are a special case of objects and they too are created with the `new`
    operator, with a slightly different syntax. The keyword is followed by the type
    of the array to be created and the size of the array encased in square brackets—​for
    example, as `new int[5]`. In some circumstances, arrays can also be created using
    the *array literal* syntax.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是对象的一种特殊情况，它们也是使用`new`运算符创建的，但语法略有不同。关键字后跟要创建的数组类型和用方括号括起的数组大小 —— 例如，`new
    int[5]`。在某些情况下，还可以使用*数组字面值*语法创建数组。
- en: '*Type conversion or casting* (`()`)'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '*类型转换或强制转换* (`()`)'
- en: 'As we’ve already seen, parentheses can also be used as an operator to perform
    narrowing type conversions, or casts. The first operand of this operator is the
    type to be converted to; it is placed between the parentheses. The second operand
    is the value to be converted; it follows the parentheses. For example:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经看到的，括号也可以用作运算符来执行类型转换或强制转换。此运算符的第一个操作数是要转换的类型；它位于括号之间。第二个操作数是要转换的值；它跟在括号后面。例如：
- en: '[PRE67]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Statements
  id: totrans-446
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语句
- en: A *statement* is a basic unit of execution in the Java language—it expresses
    a single piece of intent by the programmer. Unlike expressions, Java statements
    do not have a value. Statements also typically contain expressions and operators
    (especially assignment operators) and are frequently executed for the side effects
    that they cause.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '*语句*是Java语言中执行的基本单元 —— 它表达了程序员的单一意图。与表达式不同，Java语句没有值。语句通常包含表达式和操作符（特别是赋值操作符），并且通常执行引起的副作用。'
- en: Many of the statements defined by Java are flow-control statements, such as
    conditionals and loops, that can alter the default, linear order of execution
    in well-defined ways. [Table 2-5](#javanut8-CHP-2-TABLE-5) summarizes the statements
    defined by Java.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: Java定义的许多语句是流程控制语句，例如条件语句和循环语句，可以以明确定义的方式改变默认的线性执行顺序。[表 2-5](#javanut8-CHP-2-TABLE-5)总结了Java定义的语句。
- en: Table 2-5\. Table 2-5\. Java statements
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 表2-5\. Java语句
- en: '| Statement | Purpose | Syntax |'
  id: totrans-450
  prefs: []
  type: TYPE_TB
  zh: '| 语句 | 用途 | 语法 |'
- en: '| --- | --- | --- |'
  id: totrans-451
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| *expression* | side effects | *`variable`* `=` *`expr`* `;` *`expr`* `++;`
    *`method`* `();` `new` *`Type`* `( );` |'
  id: totrans-452
  prefs: []
  type: TYPE_TB
  zh: '| *表达式* | 副作用 | *`variable`* `=` *`expr`* `;` *`expr`* `++;` *`method`* `();`
    `new` *`Type`* `( );` |'
- en: '| *compound* | group statements | `{` *`statements`* `}` |'
  id: totrans-453
  prefs: []
  type: TYPE_TB
  zh: '| *复合* | 组合语句 | `{` *`statements`* `}` |'
- en: '| *empty* | do nothing | `;` |'
  id: totrans-454
  prefs: []
  type: TYPE_TB
  zh: '| *空* | 什么也不做 | `;` |'
- en: '| *labeled* | name a statement | *`label`* : *`statement`* |'
  id: totrans-455
  prefs: []
  type: TYPE_TB
  zh: '| *带标签的* | 命名语句 | *`label`* : *`statement`* |'
- en: '| *variable* | declare a variable | `[final]` *`type`* *`name`* `[=` *`value`*
    `]` `[`, *`name`* `[=` *`value`* `]] …;` |'
  id: totrans-456
  prefs: []
  type: TYPE_TB
  zh: '| *变量* | 声明变量 | `[final]` *`type`* *`name`* `[=` *`value`* `]` `[`, *`name`*
    `[=` *`value`* `]] …;` |'
- en: '| `if` | conditional | `if (` *`expr`* `)` *`statement`* `[ else` *`statement`*
    `]` |'
  id: totrans-457
  prefs: []
  type: TYPE_TB
  zh: '| `if` | 条件 | `if (` *`expr`* `)` *`statement`* `[ else` *`statement`* `]`
    |'
- en: '| `switch` | conditional | `switch (` *`expr`* `) {` `[ case` *`expr`* : *`statements`*
    `] …` `[ default`: *`statements`* `]` `}` |'
  id: totrans-458
  prefs: []
  type: TYPE_TB
  zh: '| `switch` | 条件 | `switch (` *`expr`* `) {` `[ case` *`expr`* : *`statements`*
    `] …` `[ default`: *`statements`* `]` `}` |'
- en: '| `switch` | conditional expression | `switch (` *`expr`* `) {` `[ case` *`expr`*
    `, [` *`expr`* `…] ->` *`expr`* `;] …` `[ default ->` *`expr`* `;]` `}` |'
  id: totrans-459
  prefs: []
  type: TYPE_TB
  zh: '| `switch` | 条件表达式 | `switch (` *`expr`* `) {` `[ case` *`expr`* `, [` *`expr`*
    `…] ->` *`expr`* `;] …` `[ default ->` *`expr`* `;]` `}` |'
- en: '| `while` | loop | `while (` *`expr`* `)` *`statement`* |'
  id: totrans-460
  prefs: []
  type: TYPE_TB
  zh: '| `while` | 循环 | `while (` *`expr`* `)` *`statement`* |'
- en: '| `do` | loop | `do` *`statement`* `while (` *`expr`* `);` |'
  id: totrans-461
  prefs: []
  type: TYPE_TB
  zh: '| `do` | 循环 | `do` *`statement`* `while (` *`expr`* `);` |'
- en: '| `for` | simplified loop | `for (` *`init`* `;` *`test`* `;` *`increment`*
    `)` *`statement`* |'
  id: totrans-462
  prefs: []
  type: TYPE_TB
  zh: '| `for` | 简化循环 | `for (` *`init`* `;` *`test`* `;` *`increment`* `)` *`statement`*
    |'
- en: '| *foreach* | collection iteration | `for (` *`variable`* : *`iterable`* `)`
    *`statement`* |'
  id: totrans-463
  prefs: []
  type: TYPE_TB
  zh: '| *foreach* | 集合迭代 | `for (` *`variable`* : *`iterable`* `)` *`statement`*
    |'
- en: '| `break` | exit block | `break [` *`label`* `] ;` |'
  id: totrans-464
  prefs: []
  type: TYPE_TB
  zh: '| `break` | 退出循环 | `break [` *`label`* `] ;` |'
- en: '| `continue` | restart loop | `continue [` *`label`* `] ;` |'
  id: totrans-465
  prefs: []
  type: TYPE_TB
  zh: '| `continue` | 重新开始循环 | `continue [` *`label`* `] ;` |'
- en: '| `return` | end method | `return [` *`expr`* `] ;` |'
  id: totrans-466
  prefs: []
  type: TYPE_TB
  zh: '| `return` | 结束方法 | `return [` *`expr`* `] ;` |'
- en: '| `synchronized` | critical section | `synchronized (` *`expr`* `) {` *`statements`*
    `}` |'
  id: totrans-467
  prefs: []
  type: TYPE_TB
  zh: '| `synchronized` | 临界区 | `synchronized (` *`expr`* `) {` *`statements`* `}`
    |'
- en: '| `throw` | throw exception | `throw` *`expr`* `;` |'
  id: totrans-468
  prefs: []
  type: TYPE_TB
  zh: '| `throw` | 抛出异常 | `throw` *`expr`* `;` |'
- en: '| `try` | handle exception | `try {` *`statements`* `}` `[ catch (` *`type`*
    *`name`* `) {` *`statements`* `} ] …` `[ finally {` *`statements`* `} ]` |'
  id: totrans-469
  prefs: []
  type: TYPE_TB
  zh: '| `try` | 处理异常 | `try {` *`statements`* `}` `[ catch (` *`type`* *`name`* `)
    {` *`statements`* `} ] …` `[ finally {` *`statements`* `} ]` |'
- en: '| `try` | handle exception, closing resources | `try ([` *`variable`* `=` *`expr`*
    `]) {` *`statements`* `}` `[ catch (` *`type`* *`name`* `) {` *`statements`* `}
    ] …` `[ finally {` *`statements`* `} ]` |'
  id: totrans-470
  prefs: []
  type: TYPE_TB
  zh: '| `try` | 处理异常，关闭资源 | `try ([` *`variable`* `=` *`expr`* `]) {` *`statements`*
    `}` `[ catch (` *`type`* *`name`* `) {` *`statements`* `} ] …` `[ finally {` *`statements`*
    `} ]` |'
- en: '| `assert` | verify invariant | `assert` *`invariant`* `[` *`error`* ]; |'
  id: totrans-471
  prefs: []
  type: TYPE_TB
  zh: '| `assert` | 验证不变性 | `assert` *`invariant`* `[` *`error`* ]; |'
- en: Expression Statements
  id: totrans-472
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表达式语句
- en: 'As we saw earlier in the chapter, certain types of Java expressions have side
    effects. In other words, they do not simply evaluate to some value; they also
    change the program state in some way. You can use any expression with side effects
    as a statement simply by following it with a semicolon. The legal types of expression
    statements are assignments, increments and decrements, method calls, and object
    creation. For example:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章前面看到的那样，Java的某些类型的表达式具有副作用。换句话说，它们不仅仅评估为某个值；它们还以某种方式改变程序状态。您可以使用具有副作用的任何表达式作为语句，只需在分号后面跟随它即可。表达式语句的合法类型包括赋值、增量和减量、方法调用和对象创建。例如：
- en: '[PRE68]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Compound Statements
  id: totrans-475
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复合语句
- en: 'A *compound statement* is any number and kind of statements grouped together
    within curly braces. You can use a compound statement anywhere a statement is
    required by Java syntax:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '*复合语句* 是任意数量和类型的语句在花括号内组合在一起。您可以在Java语法所需的任何位置使用复合语句作为语句：'
- en: '[PRE69]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The Empty Statement
  id: totrans-478
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空语句
- en: 'An *empty statement* in Java is written as a single semicolon. The empty statement
    doesn’t do anything, but the syntax is occasionally useful. For example, you can
    use it to indicate an empty loop body in a `for` loop:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: Java中的*空语句*写为一个单分号。空语句不做任何事情，但语法偶尔会有用。例如，您可以在`for`循环中使用它来指示一个空的循环体：
- en: '[PRE70]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Labeled Statements
  id: totrans-481
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标记语句
- en: 'A *labeled statement* is simply a statement that you have given a name by prepending
    an identifier and a colon to it. Labels are used by the `break` and `continue`
    statements. For example:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '*标记语句*简单地说就是给一个语句起了一个名字，方法是在其前面加上标识符和冒号。标签由`break`和`continue`语句使用。例如：'
- en: '[PRE71]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Local Variable Declaration Statements
  id: totrans-484
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地变量声明语句
- en: A *local variable*, often simply called a variable, is a symbolic name for a
    location to store a value that is defined within a method or compound statement.
    All variables must be declared before they can be used; this is done with a variable
    declaration statement. Because Java is a statically typed language, a variable
    declaration specifies the type of the variable, and only values of that type can
    be stored in the variable.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '*局部变量*，通常简称为变量，是一个在方法或复合语句中定义的用于存储值的位置的符号名称。所有变量在使用前必须声明；这通过变量声明语句完成。因为Java是一种静态类型语言，所以变量声明指定变量的类型，只有该类型的值可以存储在变量中。'
- en: 'In its simplest form, a variable declaration specifies a variable’s type and
    name:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最简单的形式中，变量声明指定变量的类型和名称：
- en: '[PRE72]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'A variable declaration can also include an *initializer*, an expression that
    specifies an initial value for the variable. For example:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 变量声明还可以包括一个*初始化器*，这是一个指定变量初始值的表达式。例如：
- en: '[PRE73]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The Java compiler does not allow you to use a local variable that has not been
    initialized, so it is usually convenient to combine variable declaration and initialization
    into a single statement. The initializer expression need not be a literal value
    or a constant expression that can be evaluated by the compiler; it can be an arbitrarily
    complex expression whose value is computed when the program is run.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: Java编译器不允许使用未初始化的局部变量，所以通常方便将变量声明和初始化结合为一个语句。初始化器表达式不必是编译器可以评估的文字值或常量表达式；它可以是在程序运行时计算值的任意复杂表达式。
- en: 'If a variable has an initializer, then the programmer can use a special syntax
    to ask the compiler to automatically work out the type, if it is possible to do
    so:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 如果变量有一个初始化器，那么程序员可以使用特殊的语法要求编译器自动计算类型，如果可能的话：
- en: '[PRE74]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This can be a useful syntax, but it is potentially harder to read. Our second
    example, for instance, requires that you know that the return type of `readLine()`
    is `String` to know what type will be inferred for `s`. For this reason, throughout
    the text we only use `var` in examples when the initializer makes the type completely
    redundant. As you learn the Java language, this may be a reasonable policy to
    follow while you become familiar with the Java type system.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是一种有用的语法，但可能更难阅读。例如，我们的第二个例子需要您知道`readLine()`的返回类型是`String`，才能知道`var`将推断为何种类型。因此，在文本中，我们只在初始化器使类型完全冗余时在示例中使用`var`。当您学习Java语言时，这可能是一个合理的政策，因为您熟悉Java类型系统时需要遵循这个政策。
- en: 'A single variable declaration statement can declare and initialize more than
    one variable, but all variables must be of the same explicitly declared type.
    Variable names and optional initializers are separated from each other with commas:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 单变量声明语句可以声明和初始化多个变量，但所有变量必须是显式声明类型相同的。变量名称和可选的初始化器用逗号分隔：
- en: '[PRE75]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Variable declaration statements can begin with the `final` keyword. This modifier
    specifies that once an initial value is defined for the variable, that value is
    never allowed to change:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 变量声明语句可以以`final`关键字开头。这个修饰符指定了一旦为变量定义了初始值，那么该值就永远不允许更改：
- en: '[PRE76]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: We will have more to say about the `final` keyword later on, especially when
    talking about the design of classes and the immutable style of programming.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会更详细地讨论`final`关键字，特别是在谈论类的设计和编程的不可变风格时。
- en: Java variable declaration statements can appear anywhere in Java code; they
    are not restricted to the beginning of a method or block of code. Local variable
    declarations can also be integrated with the *initialize* portion of a `for` loop,
    as we’ll discuss shortly.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: Java变量声明语句可以出现在Java代码的任何地方；它们不限于方法或代码块的开头。局部变量声明也可以与`for`循环的*初始化*部分集成，我们将很快讨论。
- en: 'Local variables can be used only within the method or block of code in which
    they are defined. This is called their *scope* or *lexical scope*:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 局部变量只能在定义它们的方法或代码块内部使用。这称为它们的*作用域*或*词法作用域*：
- en: '[PRE77]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The if/else Statement
  id: totrans-502
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: if/else 语句
- en: The `if` statement is a fundamental control statement that allows Java to make
    decisions or, more precisely, to execute statements conditionally. The `if` statement
    has an associated expression and statement. If the expression evaluates to `true`,
    the interpreter executes the statement. If the expression evaluates to `false`,
    the interpreter skips the statement.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句是一个基本的控制语句，允许Java进行决策，更准确地说，有条件地执行语句。`if`语句有一个关联的表达式和语句。如果表达式求值为`true`，解释器将执行语句。如果表达式求值为`false`，解释器将跳过该语句。'
- en: Note
  id: totrans-504
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: Java allows the expression to be of the wrapper type `Boolean` instead of the
    primitive type `boolean`. In this case, the wrapper object is automatically unboxed.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: Java允许表达式是包装类型`Boolean`而不是基本类型`boolean`。在这种情况下，包装对象将自动取消装箱。
- en: 'Here is an example `if` statement:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例`if`语句：
- en: '[PRE78]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Although they look extraneous, the parentheses around the expression are a
    required part of the syntax for the `if` statement. As we already saw, a block
    of statements enclosed in curly braces is itself a statement, so we can write
    `if` statements that look like this as well:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们看起来是多余的，但是表达式周围的括号是`if`语句语法的必需部分。正如我们已经看到的，被花括号括起来的语句块本身就是一个语句，所以我们也可以编写如下形式的`if`语句：
- en: '[PRE79]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'An `if` statement can include an optional `else` keyword that is followed by
    a second statement. In this form of the statement, the expression is evaluated,
    and, if it is `true`, the first statement is executed. Otherwise, the second statement
    is executed. For example:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句可以包括一个可选的`else`关键字，后面跟着第二个语句。在这种形式的语句中，表达式被求值，如果它是`true`，则执行第一个语句。否则，执行第二个语句。例如：'
- en: '[PRE80]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'When you use nested `if/else` statements, some caution is required to ensure
    that the `else` clause goes with the appropriate `if` statement. Consider the
    following lines:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用嵌套的`if/else`语句时，需要谨慎确保`else`子句与适当的`if`语句配对。考虑以下行：
- en: '[PRE81]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'In this example, the inner `if` statement forms the single statement allowed
    by the syntax of the outer `if` statement. Unfortunately, it is not clear (except
    from the hint given by the indentation) which `if` the `else` goes with. And in
    this example, the indentation hint is wrong. The rule is that an `else` clause
    like this is associated with the nearest `if` statement. Properly indented, this
    code looks like this:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，内部`if`语句形成了外部`if`语句语法允许的单个语句。不幸的是，不清楚（除了缩进给出的提示之外）`else`与哪个`if`配对。在这个例子中，缩进提示是错误的。规则是这样的：这样的`else`子句与最近的`if`语句关联。正确缩进后，此代码如下所示：
- en: '[PRE82]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'This is legal code, but it is clearly not what the programmer had in mind.
    When working with nested `if` statements, you should use curly braces to make
    your code easier to read. Here is a better way to write the code:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 这是合法的代码，但显然不是程序员所想要的。在使用嵌套`if`语句时，应该使用花括号使您的代码更易于阅读。以下是编写代码的更好方法：
- en: '[PRE83]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The else if clause
  id: totrans-518
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: else if 子句
- en: 'The `if/else` statement is useful for testing a condition and choosing between
    two statements or blocks of code to execute. But what about when you need to choose
    between several blocks of code? This is typically done with an `else` `if` clause,
    which is not really new syntax but a common idiomatic usage of the standard `if/else`
    statement. It looks like this:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '`if/else`语句用于测试条件并选择要执行的两个语句或代码块之间的选择。但是，当您需要在几个代码块之间进行选择时呢？这通常使用`else` `if`子句来完成，这并不是真正的新语法，而是标准`if/else`语句的一种常见习惯用法。它看起来像这样：'
- en: '[PRE84]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'There is nothing special about this code. It is just a series of `if` statements,
    where each `if` is part of the `else` clause of the previous statement. Using
    the `else` `if` idiom is preferable to, and more legible than, writing these statements
    out in their fully nested form:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码并没有什么特别之处。它只是一系列`if`语句，每个`if`语句都是上一条语句的`else`子句的一部分。使用`else` `if`习语比完全嵌套形式更可取，并且更易读：
- en: '[PRE85]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The switch Statement
  id: totrans-523
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: switch 语句
- en: An `if` statement causes a branch in the flow of a program’s execution. You
    can use multiple `if` statements, as shown in the previous section, to perform
    a multiway branch. This is not always the best solution, however, especially when
    all of the branches depend on the value of a single variable.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句会导致程序执行流程的分支。您可以使用多个`if`语句，如前一节所示，执行多路分支。然而，并非总是最佳解决方案，特别是当所有分支都依赖于单个变量的值时。'
- en: In this case, the repeated `if` statements may seriously hamper readability,
    especially if the code has been refactored over time or features multiple levels
    of nested `if`.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，重复的`if`语句可能会严重影响可读性，特别是如果代码经过了重构或具有多层嵌套的`if`。
- en: A better solution is to use a `switch` statement, which is inherited from the
    C programming language. Note, however, that the syntax of this statement is not
    nearly as elegant as other parts of Java. The failure to revisit the design of
    the feature is widely regarded as a mistake, one that has been partially addressed
    in recent versions with an expression form of `switch` we’ll examine in a moment.
    However, that alternative format won’t erase the long history of `switch` statements
    in the language, so it’s good to come to grips with it.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的解决方案是使用`switch`语句，这是从C编程语言继承而来的。然而，请注意，此语句的语法并不像Java的其他部分那样优雅。没有重新审视这一特性的设计被普遍认为是一个错误，这在最近的版本中部分得到了纠正，引入了我们将在稍后讨论的`switch`表达式形式。然而，该替代格式不会抹去语言中长期存在的`switch`语句的历史，因此理解它是有益的。
- en: Note
  id: totrans-527
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A `switch` statement starts with an expression whose type is an `int`, `short`,
    `char`, `byte` (or their wrapper type), `String`, or an enum (see [Chapter 4](ch04.xhtml#javanut8-CHP-4)
    for more on enumerated types).
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`语句以一个表达式开始，其类型为`int`、`short`、`char`、`byte`（或它们的包装类型）、`String`或枚举（详见[第四章](ch04.xhtml#javanut8-CHP-4)关于枚举类型的更多信息）。'
- en: 'This expression is followed by a block of code in curly braces that contains
    various entry points that correspond to possible values for the expression. For
    example, the following `switch` statement is equivalent to the repeated `if` and
    `else/if` statements shown in the previous section:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 此表达式后跟着一个带有多个入口点的代码块，这些入口点对应于表达式可能的值。例如，以下`switch`语句等效于前一节中显示的重复`if`和`else/if`语句：
- en: '[PRE86]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'As you can see from the example, the various entry points into a `switch` statement
    are labeled either with the keyword `case`, followed by an integer value and a
    colon, or with the special `default` keyword, followed by a colon. When a `switch`
    statement executes, the interpreter computes the value of the expression in parentheses
    and then looks for a `case` label that matches that value. If it finds one, the
    interpreter starts executing the block of code at the first statement following
    the `case` label. If it does not find a `case` label with a matching value, the
    interpreter starts execution at the first statement following a special-case `default`:
    label. Or, if there is no `default`: label, the interpreter skips the body of
    the `switch` statement altogether.'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您从示例中看到的那样，`switch`语句中的各个入口点要么用关键字`case`标记，后面跟着一个整数值和一个冒号，要么用特殊的`default`关键字标记，后面跟着一个冒号。当`switch`语句执行时，解释器计算括号中表达式的值，然后查找与该值匹配的`case`标签。如果找到匹配的标签，解释器将从`case`标签后的第一条语句开始执行代码块。如果没有找到具有匹配值的`case`标签，则解释器将从特殊的`default:`标签后的第一条语句开始执行。或者，如果没有`default:`标签，则解释器完全跳过`switch`语句的主体。
- en: Note the use of the `break` keyword at the end of each `case` in the previous
    code. The `break` statement is described later in this chapter, but, in this example,
    it causes the interpreter to exit the body of the `switch` statement. The `case`
    clauses in a `switch` statement specify only the starting point of the desired
    code. The individual `cases` are not independent blocks of code, and they do not
    have any implicit ending point.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，在每个`case`结尾处使用了`break`关键字，请注意。`break`语句将在本章后面进行解释，但在此示例中，它使解释器退出`switch`语句的主体。`switch`语句中的`case`子句仅指定所需代码的起始点。各个`case`不是独立的代码块，并且它们没有任何隐含的结束点。
- en: Warning
  id: totrans-533
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: You must explicitly specify the end of each `case` with a `break` or related
    statement. In the absence of `break` statements, a `switch` statement begins executing
    code at the first statement after the matching `case` label and continues executing
    statements until it reaches the end of the block. The control flow will *fall
    through* into the next `case` label and continue executing, rather than exit the
    block.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须显式指定每个 `case` 的结束，使用 `break` 或相关语句。在缺少 `break` 语句的情况下，`switch` 语句从匹配的 `case`
    标签后的第一个语句开始执行代码，并继续执行语句，直到达到块的末尾。控制流会 *fall through* 到下一个 `case` 标签并继续执行，而不是退出块。
- en: On rare occasions, it is useful to write code like this that falls through from
    one `case` label to the next, but 99% of the time you should be careful to end
    every `case` and `default` section with a statement that causes the `switch` statement
    to stop executing. Normally you use a `break` statement, but `return` and `throw`
    also work.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 在罕见情况下，编写这样的代码是有用的，从一个 `case` 标签穿透到下一个 `case` 标签，但 99% 的情况下，您应该小心地结束每个 `case`
    和 `default` 部分，使得 `switch` 语句停止执行。通常使用 `break` 语句，但也可以使用 `return` 和 `throw` 语句。
- en: 'As a consequence of this default fall-through, a `switch` statement can have
    more than one `case` clause labeling the same statement. Consider the `switch`
    statement in the following method:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 由于默认的 fall-through 特性，一个 `switch` 语句可以有多个标记相同语句的 `case` 子句。考虑下面方法中的 `switch`
    语句：
- en: '[PRE87]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The `switch` statement and its `case` labels have some important restrictions.
    First, the expression associated with a `switch` statement must have an appropriate
    type—either `byte`, `char`, `short`, `int` (or their wrappers), or an enum type
    or a `String`. The floating-point and `boolean` types are not supported, and neither
    is `long`, even though `long` is an integer type. Second, the value associated
    with each `case` label must be a constant value or a constant expression the compiler
    can evaluate. A `case` label cannot contain a runtime expression involving variables
    or method calls, for example. Third, the `case` label values must be within the
    range of the data type used for the `switch` expression. And finally, it is not
    legal to have two or more `case` labels with the same value or more than one `default`
    label.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch` 语句及其 `case` 标签有一些重要限制。首先，与 `switch` 语句关联的表达式必须具有适当的类型 —— `byte`、`char`、`short`、`int`（或它们的包装类）、枚举类型或
    `String`。不支持浮点型和 `boolean` 类型，即使 `long` 是整数类型也不支持。其次，与每个 `case` 标签关联的值必须是编译器可以评估的常量值或常量表达式。例如，`case`
    标签不能包含涉及变量或方法调用的运行时表达式。第三，`case` 标签的值必须在用于 `switch` 表达式的数据类型的范围内。最后，不能有两个或更多具有相同值的
    `case` 标签或一个以上的 `default` 标签是不合法的。'
- en: With all those caveats, let’s look at how the new `switch` expression makes
    for a cleaner experience.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些注意事项，让我们看看新的 `switch` 表达式如何提供更清晰的体验。
- en: The switch Expression
  id: totrans-540
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`switch` 表达式'
- en: A frequent problem with the classic `switch` statement arises when capturing
    a variable value.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 经典 `switch` 语句的一个常见问题是捕获变量值时产生的问题。
- en: '[PRE88]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: For the variable to be available after the `switch`, it must be declared outside
    the statement and provided an initial value. Then each `case` must be certain
    to set the variable. However, we have no guarantees, and in code with more branches
    than this simple example, it’s an easy thing to miss and introduce a bug.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 变量在 `switch` 后仍然可用，必须在语句外声明并赋予初始值。然后，每个 `case` 必须确保设置变量。但是，我们没有保证，在比这个简单示例更多分支的代码中，很容易忽略并引入错误。
- en: The `switch` expression is explicitly designed to address these and other faults.
    As the name calls out, it’s an *expression*—one of the more syntactically complex
    ones in the language—and as such results in a value.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch` 表达式明确设计用于解决这些及其他缺陷。正如其名称所示，它是一个 *表达式* —— 是语言中语法上较复杂的表达式之一，并因此产生一个值。'
- en: '[PRE89]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Much like the `switch` statement, each `case` here evaluates the input against
    its value. After an `->` you provide the resulting value for the switch expression
    as a whole. In this example, we’re assigning that to our variable `yesOrNo`, which
    no longer needs to be the nullable wrapper type.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `switch` 语句一样，每个 `case` 在此处评估输入与其值。在 `->` 之后，您提供整个 `switch` 表达式的结果值。在此示例中，我们将其分配给我们的变量
    `yesOrNo`，这不再需要是可空包装类型。
- en: Our code as written here hides one of the protections that the `switch` expressions
    is giving us. If we remove the `default` clause, the compiler will give us an
    error because the expression cannot always be evaluated fully.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里编写的代码隐藏了`switch`表达式为我们提供的保护之一。如果我们移除`default`子句，编译器会报错，因为表达式不能始终完全评估。
- en: '[PRE90]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Switch expressions do not fall through like the statement form. To support multiple
    values evaluating to the same result, each `case` can take a comma-separated list
    of values instead of just a single value.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: Switch表达式不像语句形式那样会掉落到下一个`case`。为了支持多个值评估为相同结果，每个`case`可以接受逗号分隔的值列表，而不仅仅是单个值。
- en: '[PRE91]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Our desired result can’t always be expressed as a single value or method call.
    To support that, curly braces may introduce a statement. However, the statement
    must end with either `yield` to exit the switch with a value, or a `return` leaving
    the entire enclosing method.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的期望结果并非总是可以表示为单个值或方法调用。为了支持这一点，花括号可以引入一个语句。但是，该语句必须以`yield`结束以退出带有值的`switch`，或者使用`return`离开整个封闭方法。
- en: '[PRE92]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: And in fact, if we don’t make use of the `switch` expression result, we can
    even use this syntax, with its improved branch checking and safety, purely for
    side effects.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，如果我们不使用`switch`表达式的结果，甚至可以仅用于副作用的语法，具有改进的分支检查和安全性。
- en: '[PRE93]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The while Statement
  id: totrans-555
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`while`语句'
- en: 'The `while` statement is a basic statement that allows Java to perform repetitive
    actions—or, to put it another way, it is one of Java’s primary *looping constructs*.
    It has the following syntax:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`语句是一个基本语句，允许Java执行重复的操作——换句话说，它是Java的主要*循环结构*之一。它的语法如下：'
- en: '[PRE94]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The `while` statement works by first evaluating the *`expression`*, which must
    result in a `boolean` or `Boolean` value. If the value is `false`, the interpreter
    skips the *`statement`* associated with the loop and moves to the next statement
    in the program. If it is `true`, however, the *`statement`* that forms the body
    of the loop is executed, and the *`expression`* is reevaluated. Again, if the
    value of *`expression`* is `false`, the interpreter moves on to the next statement
    in the program; otherwise, it executes the *`statement`* again. This cycle continues
    while the *`expression`* remains `true` (i.e., until it evaluates to `false`),
    at which point the `while` statement ends, and the interpreter moves on to the
    next statement. You can create an infinite loop with the syntax `while(true)`.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`语句首先评估*`expression`*，该表达式必须返回`boolean`或`Boolean`值。如果值为`false`，解释器跳过循环关联的*`statement`*，并移动到程序的下一条语句。然而，如果值为`true`，则执行循环体形成的*`statement`*，并重新评估*`expression`*。再次，如果*`expression`*的值为`false`，解释器继续执行程序的下一条语句；否则，它再次执行*`statement`*。这个循环在*`expression`*保持`true`（即直到它评估为`false`）时继续，此时`while`语句结束，解释器继续执行程序的下一条语句。您可以使用语法`while(true)`创建无限循环。'
- en: 'Here is an example `while` loop that prints the numbers 0 to 9:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个打印数字0到9的示例`while`循环：
- en: '[PRE95]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: As you can see, the variable `count` starts off at 0 in this example and is
    incremented each time the body of the loop runs. Once the loop has executed 10
    times, the expression becomes `false` (i.e., `count` is no longer less than 10),
    the `while` statement finishes, and the Java interpreter can move to the next
    statement in the program. Most loops have a counter variable like `count`. The
    variable names `i`, `j`, and `k` are commonly used as loop counters, although
    you should use more descriptive names if it makes your code easier to understand.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，变量`count`在这个示例中从0开始，并且每次循环体运行时都会递增。一旦循环执行了10次，表达式变为`false`（即`count`不再小于10），`while`语句结束，Java解释器可以转到程序中的下一条语句。大多数循环都有像`count`这样的计数器变量。变量名`i`、`j`和`k`通常用作循环计数器，尽管如果使您的代码更易于理解，您应该使用更具描述性的名称。
- en: The do Statement
  id: totrans-562
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`do`语句'
- en: 'A `do` loop is much like a `while` loop, except that the loop expression is
    tested at the bottom of the loop rather than at the top. This means that the body
    of the loop is always executed at least once. The syntax is:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: '`do`循环与`while`循环非常相似，不同之处在于循环表达式在循环体底部测试，而不是在顶部测试。这意味着循环体至少会执行一次。语法如下：'
- en: '[PRE96]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Notice a couple of differences between the `do` loop and the more ordinary
    `while` loop. First, the `do` loop requires both the `do` keyword to mark the
    beginning of the loop and the `while` keyword to mark the end and introduce the
    loop condition. Also, unlike the `while` loop, the `do` loop is terminated with
    a semicolon. This is because the `do` loop ends with the loop condition rather
    than simply ending with a curly brace that marks the end of the loop body. The
    following `do` loop prints the same output as the `while` loop just discussed:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`do`循环与更普通的`while`循环之间的一些区别。首先，`do`循环需要`do`关键字标记循环的开始和`while`关键字标记结束并引入循环条件。此外，与`while`循环不同，`do`循环以分号结束。这是因为`do`循环以循环条件结束，而不仅仅是以标记循环体结束的花括号结束。以下的`do`循环打印了与前述`while`循环相同的输出：
- en: '[PRE97]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The `do` loop is much less commonly used than its `while` cousin because, in
    practice, it is unusual to encounter a situation where you are sure you always
    want a loop to execute at least once.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: '`do`循环比它的`while`表兄弟要少见得多，因为实际上很少遇到您确信总是希望至少执行一次循环的情况。'
- en: The for Statement
  id: totrans-568
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`for`语句'
- en: 'The `for` statement provides a looping construct that is often more convenient
    than the `while` and `do` loops. The `for` statement takes advantage of a common
    looping pattern. Most loops have a counter, or state variable of some kind, that
    is initialized before the loop starts, tested to determine whether to execute
    the loop body, and then incremented or updated somehow at the end of the loop
    body before the test expression is evaluated again. The *`initialize`*, *`test`*,
    and *`update`* steps are the three crucial manipulations of a loop variable, and
    the `for` statement makes these three steps an explicit part of the loop syntax:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`语句提供了一个循环结构，通常比`while`和`do`循环更方便。`for`语句利用了一种常见的循环模式。大多数循环都有一个计数器或某种状态变量，在循环开始前初始化，在测试后确定是否执行循环体，并在循环体结束前以某种方式递增或更新。*`initialize`*、*`test`*和*`update`*步骤是循环变量的三个关键操作，而`for`语句使这三个步骤成为循环语法的显式部分：'
- en: '[PRE98]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'This `for` loop is basically equivalent to the following `while` loop:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`for`循环基本上等同于以下的`while`循环：
- en: '[PRE99]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Placing the *`initialize`*, *`test`*, and *`update`* expressions at the top
    of a `for` loop makes it especially easy to understand what the loop is doing,
    and it prevents mistakes such as forgetting to initialize or update the loop variable.
    The interpreter discards the values of the *`initialize`* and *`update`* expressions,
    so to be useful, these expressions must have side effects. *`initialize`* is typically
    an assignment expression, while *`update`* is usually an increment, decrement,
    or some other assignment.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 将*`initialize`*、*`test`*和*`update`*表达式放在`for`循环的顶部使得理解循环正在做什么特别容易，并且防止像忘记初始化或更新循环变量这样的错误。解释器会丢弃*`initialize`*和*`update`*表达式的值，因此为了有用，这些表达式必须具有副作用。*`initialize`*通常是赋值表达式，而*`update`*通常是增量、减量或其他一些赋值。
- en: 'The following `for` loop prints the numbers 0 to 9, just as the previous `while`
    and `do` loops have done:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的`for`循环打印出0到9的数字，就像之前的`while`和`do`循环所做的那样：
- en: '[PRE100]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Notice how this syntax places all the important information about the loop variable
    on a single line, making it very clear how the loop executes. Placing the *`update`*
    expression in the `for` statement itself also simplifies the body of the loop
    to a single statement; we don’t even need to use curly braces to produce a statement
    block.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这种语法如何将关于循环变量的所有重要信息放在一行上，使得循环执行过程非常清晰。将*`update`*表达式放在`for`语句本身中也简化了循环体到一个单一语句；我们甚至不需要使用花括号来生成语句块。
- en: 'The `for` loop supports some additional syntax that makes it even more convenient
    to use. Because many loops use their loop variables only within the loop, the
    `for` loop allows the *`initialize`* expression to be a full variable declaration,
    so that the variable is scoped to the body of the loop and is not visible outside
    of it. For example:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环支持一些额外的语法，使其更加方便使用。因为许多循环仅在循环内部使用它们的循环变量，所以`for`循环允许*`initialize`*表达式是一个完整的变量声明，因此该变量的作用域仅限于循环体内部，在外部不可见。例如：'
- en: '[PRE101]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Furthermore, the `for` loop syntax does not restrict you to writing loops that
    use only a single variable. Both the *`initialize`* and *`update`* expressions
    of a `for` loop can use a comma to separate multiple initializations and update
    expressions. For example:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Even though all the examples so far have counted numbers, `for` loops are not
    restricted to loops that count numbers. For example, you might use a `for` loop
    to iterate through the elements of a linked list:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: The *`initialize`*, *`test`*, and *`update`* expressions of a `for` loop are
    all optional; only the semicolons that separate the expressions are required.
    If the *`test`* expression is omitted, it is assumed to be `true`. Thus, you can
    write an infinite loop as `for(;;)`.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: The foreach Statement
  id: totrans-584
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Java’s `for` loop works well for primitive types, but it is needlessly clunky
    for handling collections of objects. Instead, an alternative syntax known as a
    *foreach* loop is used for handling collections of objects that need to be looped
    over.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: 'The foreach loop uses the keyword `for` followed by an opening parenthesis,
    a variable declaration (without initializer), a colon, an expression, a closing
    parenthesis, and finally the statement (or block) that forms the body of the loop:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Despite its name, the foreach loop does not have a keyword `foreach`—instead,
    it is common to read the colon as “in”—as in “foreach name in studentNames.”
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `while`, `do`, and `for` loops, we’ve shown an example that prints
    10 numbers. The foreach loop can do this too, but it needs a collection to iterate
    over. In order to loop 10 times (to print out 10 numbers), we need an array or
    other collection with 10 elements. Here’s code we can use:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: What foreach cannot do
  id: totrans-591
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The foreach is different from the `while`, `for`, or `do` loops, because it
    hides the loop counter or `Iterator` from you. This is a very powerful idea, as
    we’ll see when we discuss lambda expressions, but there are some algorithms that
    cannot be expressed very naturally with a foreach loop.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose you want to print the elements of an array as a comma-separated
    list. To do this, you need to print a comma after every element of the array except
    the last, or equivalently, before every element of the array except the first.
    With a traditional `for` loop, the code might look like this:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: This is a very straightforward task, but you simply cannot do it with foreach
    without keeping track of additional state. The problem is that the foreach loop
    doesn’t give you a loop counter or any other way to tell if you’re on the first
    iteration, the last iteration, or somewhere in between.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-596
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A similar issue exists when you’re using foreach to iterate through the elements
    of a collection. Just as a foreach loop over an array has no way to obtain the
    array index of the current element, a foreach loop over a collection has no way
    to obtain the `Iterator` object that is being used to itemize the elements of
    the collection.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some other things you cannot do with a foreach-style loop:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些你不能在 foreach 风格循环中做的事情：
- en: Iterate backward through the elements of an array or `List`.
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反向迭代数组或 `List` 的元素。
- en: Use a single loop counter to access the same-numbered elements of two distinct
    arrays.
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用单个循环计数器访问两个不同数组的相同编号元素。
- en: Iterate through the elements of a `List` using calls to its `get()` method rather
    than calls to its iterator.
  id: totrans-601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用调用其 `get()` 方法而不是调用其迭代器来遍历 `List` 的元素。
- en: The break Statement
  id: totrans-602
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`break` 语句'
- en: 'A `break` statement causes the Java interpreter to skip immediately to the
    end of a containing statement. We have already seen the `break` statement used
    with the `switch` statement. The `break` statement is most often written as simply
    the keyword `break` followed by a semicolon:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: '`break` 语句会导致 Java 解释器立即跳过包含语句的末尾。我们已经看到 `break` 语句与 `switch` 语句一起使用。`break`
    语句通常简单地写为关键字 `break` 后跟一个分号：'
- en: '[PRE107]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'When used in this form, it causes the Java interpreter to immediately exit
    the innermost containing `while`, `do`, `for`, or `switch` statement. For example:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种形式下，它会导致 Java 解释器立即退出最内层的包含的 `while`、`do`、`for` 或 `switch` 语句。例如：
- en: '[PRE108]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The `break` statement can also be followed by the name of a containing labeled
    statement. When used in this form, `break` causes the Java interpreter to immediately
    exit the named block, which can be any kind of statement, not just a loop or `switch`.
    For example:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: '`break` 语句也可以跟随包含的标记语句的名称。在这种形式下，`break` 会导致 Java 解释器立即退出命名的块，该块可以是任何类型的语句，而不仅仅是循环或
    `switch`。例如：'
- en: '[PRE109]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: The continue Statement
  id: totrans-609
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`continue` 语句'
- en: 'While a `break` statement exits a loop, a `continue` statement quits the current
    iteration of a loop and starts the next one. `continue`, in both its unlabeled
    and labeled forms, can be used only within a `while`, `do`, or `for` loop. When
    used without a label, `continue` causes the innermost loop to start a new iteration.
    When used with a label that is the name of a containing loop, it causes the named
    loop to start a new iteration. For example:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `break` 语句退出循环，但 `continue` 语句结束当前循环迭代并开始下一个迭代。`continue` 在其未标记和标记形式中，只能在
    `while`、`do` 或 `for` 循环内使用。未带标记时，`continue` 导致最内层循环开始新的迭代。当使用包含循环名称的标签时，它导致命名循环开始新的迭代。例如：
- en: '[PRE110]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '`while`, `do`, and `for` loops differ slightly in the way that `continue` starts
    a new iteration:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`、`do` 和 `for` 循环在 `continue` 启动新迭代的方式上略有不同：'
- en: With a `while` loop, the Java interpreter simply returns to the top of the loop,
    tests the loop condition again, and, if it evaluates to `true`, executes the body
    of the loop again.
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `while` 循环，Java 解释器简单地返回到循环的顶部，重新测试循环条件，如果评估为 `true`，则再次执行循环体。
- en: With a `do` loop, the interpreter jumps to the bottom of the loop, where it
    tests the loop condition to decide whether to perform another iteration of the
    loop.
  id: totrans-614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `do` 循环，解释器跳到循环的底部，检查循环条件以决定是否执行循环的另一个迭代。
- en: With a `for` loop, the interpreter jumps to the top of the loop, where it first
    evaluates the *`update`* expression and then evaluates the *`test`* expression
    to decide whether to loop again. As you can see from the examples, the behavior
    of a `for` loop with a `continue` statement is different from the behavior of
    the “basically equivalent” `while` loop presented earlier; *`update`* gets evaluated
    in the `for` loop but not in the equivalent `while` loop.
  id: totrans-615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `for` 循环，解释器跳到循环的顶部，首先评估 *`update`* 表达式，然后评估 *`test`* 表达式以决定是否再次循环。从这些例子中可以看出，带有
    `continue` 语句的 `for` 循环的行为与之前介绍的“基本等效”的 `while` 循环的行为不同；*`update`* 在 `for` 循环中被评估，但在等效的
    `while` 循环中却不是。
- en: The return Statement
  id: totrans-616
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`return` 语句'
- en: 'A `return` statement tells the Java interpreter to stop executing the current
    method. If the method is declared to return a value, the `return` statement must
    be followed by an expression. The value of the expression becomes the return value
    of the method. For example, the following method computes and returns the square
    of a number:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: '`return` 语句告诉 Java 解释器停止执行当前方法。如果方法声明要返回一个值，则 `return` 语句后必须跟表达式。表达式的值成为方法的返回值。例如，以下方法计算并返回一个数字的平方：'
- en: '[PRE111]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Some methods are declared `void` to indicate that they do not return any value.
    The Java interpreter runs methods like this by executing their statements one
    by one until it reaches the end of the method. After executing the last statement,
    the interpreter returns implicitly. Sometimes, however, a `void` method has to
    return explicitly before reaching the last statement. In this case, it can use
    the `return` statement by itself, without any expression. For example, the following
    method prints, but does not return, the square root of its argument. If the argument
    is a negative number, it returns without printing anything:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 有些方法声明为`void`，表示它们不返回任何值。Java 解释器通过逐一执行它们的语句直到方法结束来运行这些方法。执行完最后一个语句后，解释器会隐式返回。然而，有时`void`方法必须在到达最后一个语句之前显式返回。在这种情况下，它可以使用`return`语句本身，不带任何表达式。例如，以下方法打印但不返回其参数的平方根。如果参数是负数，则打印之前返回而不打印任何内容：
- en: '[PRE112]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: The synchronized Statement
  id: totrans-621
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步语句
- en: Java has always provided support for multithreaded programming. We cover this
    in some detail later on (especially in [“Java’s Support for Concurrency”](ch06.xhtml#javanut8-CHP-6-SECT-5));
    however, be aware that concurrency is difficult to get right and has a number
    of subtleties.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: Java 一直为多线程编程提供支持。我们稍后会详细介绍这一点（特别是在[“Java 对并发的支持”](ch06.xhtml#javanut8-CHP-6-SECT-5)中）；然而，请注意，编写正确的并发代码很难且有许多微妙之处。
- en: 'In particular, when working with multiple threads, you must often take care
    to prevent multiple threads from modifying an object simultaneously in a way that
    might corrupt the object’s state. Java provides the `synchronized` statement to
    help the programmer prevent corruption. The syntax is:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是在处理多个线程时，通常需要注意防止多个线程同时修改对象的方式，这可能会破坏对象的状态。Java 提供了`synchronized`语句来帮助程序员防止这种破坏。语法是：
- en: '[PRE113]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '*`expression`* is an expression that must evaluate to an object (including
    arrays). *`statements`* constitute the code of the section that could cause damage
    and must be enclosed in curly braces.'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: '*`expression`* 是必须求值为对象（包括数组）的表达式。*`statements`* 构成可能会造成损害的部分的代码，并且必须用大括号括起来。'
- en: Note
  id: totrans-626
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In Java, the protection of object state (i.e., data) is the primary concern
    of the concurrency primitives. This is unlike some other languages, where the
    exclusion of threads from *critical sections* (i.e., code) is the main focus.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，对象状态（即数据）的保护是并发原语的主要关注点。这与其他一些语言不同，其他语言更关注对*临界区*（即代码）的排除。
- en: Before executing the statement block, the Java interpreter first obtains an
    exclusive lock on the object or array specified by *`expression`*. It holds the
    lock until it is finished running the block, then releases it. While a thread
    holds the lock on an object, no other thread can obtain that lock.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行语句块之前，Java 解释器首先获取由*`expression`*指定的对象或数组的独占锁。它在运行完块后释放锁。当一个线程持有对象的锁时，其他线程无法获取该锁。
- en: As well as the block form, `synchronized` can also be used as a method modifier
    in Java. When applied to a method, the keyword indicates that the entire method
    is treated as `synchronized`.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 除了块形式外，`synchronized`在 Java 中还可以作为方法修饰符使用。当应用于方法时，该关键字表示整个方法被视为`synchronized`。
- en: For a `synchronized` instance method, Java obtains an exclusive lock on the
    class instance. (Class and instance methods are discussed in [Chapter 3](ch03.xhtml#javanut8-CHP-3).)
    It can be thought of as a `synchronized (this) { ... }` block that covers the
    entire method.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`synchronized`实例方法，Java 获取类实例的独占锁。（类方法和实例方法在[第 3 章](ch03.xhtml#javanut8-CHP-3)中有详细讨论。）它可以被视为覆盖整个方法的`synchronized
    (this) { ... }`块。
- en: A `static synchronized` method (a class method) causes Java to obtain an exclusive
    lock on the class (technically the class object corresponding to the type) before
    executing the method.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: '`static synchronized` 方法（类方法）会导致 Java 在执行该方法之前获取类（技术上对应于类型的类对象）的独占锁。'
- en: The throw Statement
  id: totrans-632
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抛出语句
- en: An *exception* is a signal that indicates some sort of exceptional condition
    or error has occurred. To *throw* an exception is to signal an exceptional condition.
    To *catch* an exception is to handle it—to take whatever actions are necessary
    to recover from it.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '*异常* 是指示发生了某种异常条件或错误的信号。*抛出*异常是为了信号异常条件。*捕获*异常是为了处理它，采取必要的措施以从中恢复。'
- en: 'In Java, the `throw` statement is used to throw an exception:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，`throw`语句用于抛出异常：
- en: '[PRE114]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'The *`expression`* must evaluate to an exception object that describes the
    exception or error that has occurred. We’ll talk more about types of exceptions
    shortly; for now, all you need to know is that an exception:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: '*`expression`* 必须评估为描述发生的异常或错误的异常对象。稍后我们将更详细地讨论异常的类型；现在你只需要知道，异常：'
- en: Is represented by an object
  id: totrans-637
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由对象表示
- en: Has a type that is a subclass of `Exception`
  id: totrans-638
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其类型是 `Exception` 的子类
- en: Has a slightly specialized role in Java’s syntax
  id: totrans-639
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Java 语法中具有稍微专门化的角色
- en: 'Can be of two different types: *checked* or *unchecked*'
  id: totrans-640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以是两种不同类型：*checked* 或 *unchecked*
- en: 'Here is some example code that throws an exception:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个抛出异常的示例代码：
- en: '[PRE115]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: When the Java interpreter executes a `throw` statement, it immediately stops
    normal program execution and starts looking for an exception handler that can
    catch, or handle, the exception. Exception handlers are written with the `try/catch/finally`
    statement, which is described in the next section. The Java interpreter first
    looks at the enclosing block of code to see if it has an associated exception
    handler. If so, it exits that block of code and starts running the exception-handling
    code associated with the block. After running the exception handler, the interpreter
    continues execution at the statement immediately following the handler code.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Java 解释器执行 `throw` 语句时，它立即停止正常的程序执行，并开始寻找能够捕获或处理异常的异常处理程序。异常处理程序使用 `try/catch/finally`
    语句编写，下一节将对此进行描述。Java 解释器首先查看包含代码块，看看是否有相关联的异常处理程序。如果有，则退出该代码块，并开始运行与该代码块相关联的异常处理代码。运行完异常处理程序后，解释器继续执行跟在处理程序代码之后的语句。
- en: If the enclosing block of code does not have an appropriate exception handler,
    the interpreter checks the next higher enclosing block of code in the method.
    This continues until a handler is found. If the method does not contain an exception
    handler that can handle the exception thrown by the `throw` statement, the interpreter
    stops running the current method and returns to the caller. Now the interpreter
    starts looking for an exception handler in the blocks of code of the calling method.
    In this way, exceptions propagate up through the lexical structure of Java methods,
    up the call stack of the Java interpreter. If the exception is never caught, it
    propagates all the way up to the `main()` method of the program. If it is not
    handled in that method, the Java interpreter prints an error message, prints a
    stack trace to indicate where the exception occurred, and then exits.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 如果包含代码块没有适当的异常处理程序，则解释器检查方法中的下一个更高的包含代码块。这将继续，直到找到处理程序。如果方法中没有可以处理 `throw` 语句抛出的异常的异常处理程序，则解释器停止运行当前方法，并返回给调用者。现在解释器开始在调用方法的代码块中寻找异常处理程序。通过这种方式，异常沿着
    Java 方法的词法结构向上传播，沿着 Java 解释器的调用堆栈向上传播。如果异常从未被捕获，则它一直传播到程序的 `main()` 方法。如果在该方法中未处理它，则
    Java 解释器打印错误消息，打印堆栈跟踪以指示异常发生的位置，然后退出。
- en: The try/catch/finally Statement
  id: totrans-645
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`try/catch/finally` 语句'
- en: Java has two slightly different exception-handling mechanisms. The classic form
    is the `try/catch/finally` statement. The `try` clause of this statement establishes
    a block of code for exception handling. This `try` block is followed by zero or
    more `catch` clauses, each of which is a block of statements designed to handle
    specific exceptions. Each `catch` block can handle more than one different exception—to
    indicate that a `catch` block should handle multiple exceptions, we use the `|`
    symbol to separate the different exceptions a `catch` block should handle. The
    `catch` clauses are followed by an optional `finally` block that contains cleanup
    code guaranteed to be executed regardless of what happens in the `try` block.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: Java 有两种略有不同的异常处理机制。经典形式是 `try/catch/finally` 语句。此语句的 `try` 子句建立了一个用于异常处理的代码块。这个
    `try` 块后面是零个或多个 `catch` 子句，每个 `catch` 子句是一组语句块，用于处理特定的异常。每个 `catch` 块可以处理多个不同的异常—为了指示一个
    `catch` 块应该处理多个异常，我们使用 `|` 符号分隔不同的异常。`catch` 子句后面是一个可选的 `finally` 块，其中包含保证执行的清理代码，无论
    `try` 块中发生了什么。
- en: 'The following code illustrates the syntax and purpose of the `try/catch/finally`
    statement:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码说明了 `try/catch/finally` 语句的语法和目的：
- en: '[PRE116]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: try
  id: totrans-649
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: try
- en: The `try` clause simply establishes a block of code that either has its exceptions
    handled or needs special cleanup code to be run when it terminates for any reason.
    The `try` clause by itself doesn’t do anything interesting; it is the `catch`
    and `finally` clauses that do the exception-handling and cleanup operations.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: '`try`子句简单地建立一个代码块，要么处理其异常，要么在任何情况下终止时运行特殊的清理代码。`try`子句本身不执行任何有趣的操作；是`catch`和`finally`子句执行异常处理和清理操作。'
- en: catch
  id: totrans-651
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 捕获
- en: A `try` block can be followed by zero or more `catch` clauses that specify code
    to handle various types of exceptions. Each `catch` clause is declared with a
    single argument that specifies the types of exceptions the clause can handle (possibly
    using the special `|` syntax to indicate that the `catch` block can handle more
    than one type of exception) and also provides a name the clause can use to refer
    to the exception object it is currently handling. Any type that a `catch` block
    wishes to handle must be some subclass of `Throwable`.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`try`块后面可以跟随零个或多个`catch`子句，这些子句指定处理各种类型异常的代码。每个`catch`子句声明一个参数，指定该子句可以处理的异常类型（可能使用特殊的`|`语法来表示`catch`块可以处理多种类型的异常），并且为该子句提供一个名称，用于引用它当前正在处理的异常对象。`catch`块希望处理的任何类型必须是`Throwable`的某个子类。
- en: When an exception is thrown, the Java interpreter looks for a `catch` clause
    with an argument that matches the same type as the exception object or a superclass
    of that type. The interpreter invokes the first such `catch` clause it finds.
    The code within a `catch` block should take whatever action is necessary to cope
    with the exceptional condition. If the exception is a `java.io.FileNotFoundException`,
    for example, you might handle it by asking the user to check their spelling and
    try again.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 当抛出异常时，Java解释器会查找一个带有与异常对象类型相匹配或超类匹配的`catch`子句。解释器调用它找到的第一个这样的`catch`子句。`catch`块内的代码应采取必要的操作来处理异常情况。例如，如果异常是`java.io.FileNotFoundException`，你可以通过要求用户检查拼写并重试来处理它。
- en: It is not required to have a `catch` clause for every possible exception; in
    some cases, the correct response is to allow the exception to propagate up and
    be caught by the invoking method. In other cases, such as a programming error
    signaled by `NullPointerException`, the correct response is probably not to catch
    the exception at all but allow it to propagate and have the Java interpreter exit
    with a stack trace and an error message.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 并非每个可能的异常都需要有一个`catch`子句；在某些情况下，正确的响应是允许异常传播并被调用方法捕获。在其他情况下，比如由`NullPointerException`信号的编程错误，正确的响应可能并不是捕获异常，而是允许其传播，并让Java解释器输出堆栈跟踪和错误消息。
- en: finally
  id: totrans-655
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最终
- en: The `finally` clause is generally used to clean up after the code in the `try`
    clause (e.g., close files and shut down network connections). The `finally` clause
    is useful because it is guaranteed to be executed if any portion of the `try`
    block is executed, regardless of how the code in the `try` block completes. In
    fact, the only way a `try` clause can exit without allowing the `finally` clause
    to be executed is by invoking the `System.exit()` method, which causes the Java
    interpreter to stop running.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: '`finally`子句通常用于在`try`子句中的代码之后进行清理（例如关闭文件和关闭网络连接）。`finally`子句非常有用，因为它保证在执行`try`块的任何部分之后执行，无论`try`块中的代码如何完成。实际上，`try`子句退出而不允许执行`finally`子句的唯一方法是调用`System.exit()`方法，这将导致Java解释器停止运行。'
- en: In the normal case, control reaches the end of the `try` block and then proceeds
    to the `finally` block, which performs any necessary cleanup. If control leaves
    the `try` block because of a `return`, `continue`, or `break` statement, the `finally`
    block is executed before control transfers to its new destination.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常情况下，控制流程到达`try`块的末尾，然后继续执行`finally`块，执行任何必要的清理工作。如果控制流程因为`return`、`continue`或`break`语句离开`try`块，那么在转移到新目的地之前将执行`finally`块。
- en: If an exception occurs in the `try` block and there is an associated `catch`
    block to handle the exception, control transfers first to the `catch` block and
    then to the `finally` block. If there is no local `catch` block to handle the
    exception, control transfers first to the `finally` block, and then propagates
    up to the nearest containing `catch` clause that can handle the exception.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`try`块中发生异常，并且有相关的`catch`块来处理异常，则控制首先转移到`catch`块，然后再到`finally`块。如果没有局部`catch`块来处理异常，则控制首先转移到`finally`块，然后传播到最近的能处理异常的包含`catch`子句。
- en: If a `finally` block itself transfers control with a `return`, `continue`, `break`,
    or `throw` statement or by calling a method that throws an exception, the pending
    control transfer is abandoned, and this new transfer is processed. For example,
    if a `finally` clause throws an exception, that exception replaces any exception
    that was in the process of being thrown. If a `finally` clause issues a `return`
    statement, the method returns normally, even if an exception has been thrown and
    has not yet been handled.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`finally`块本身使用`return`、`continue`、`break`或`throw`语句转移控制，或通过调用抛出异常的方法，挂起的控制转移将被放弃，并处理这种新的转移。例如，如果`finally`子句抛出异常，则该异常将替换正在被抛出的任何异常。如果`finally`子句发出`return`语句，则方法会正常返回，即使已经抛出异常且尚未处理。
- en: '`try` and `finally` can be used together without exceptions or any `catch`
    clauses. In this case, the `finally` block is simply cleanup code that is guaranteed
    to be executed, regardless of any `break`, `continue`, or `return` statements
    within the `try` clause.'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: '`try`和`finally`可以一起使用，不带异常或任何`catch`子句。在这种情况下，`finally`块只是保证执行的清理代码，无论`try`子句中有任何`break`、`continue`或`return`语句。'
- en: The try-with-resources Statement
  id: totrans-661
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**尝试使用资源语句**'
- en: The standard form of a `try` block is very general, but there is a common set
    of circumstances that require developers to be very careful when writing `catch`
    and `finally` blocks. These circumstances are when operating with resources that
    need to be cleaned up or closed when they are no longer needed.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: '`try`块的标准形式非常通用，但在编写`catch`和`finally`块时，需要开发人员在操作需要在不再需要时清理或关闭的资源时特别小心。'
- en: 'Java provides a very useful mechanism for automatically closing resources that
    require cleanup. This is known as *try-with-resources*, or TWR. We discuss TWR
    in detail in [“Classic Java I/O”](ch10.xhtml#javanut8-CHP-10-SECT-1), but for
    completeness, let’s introduce the syntax now. The following example shows how
    to open a file using the `FileInputStream` class (which results in an object that
    will require cleanup):'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: Java 提供了一种非常有用的机制来自动关闭需要清理的资源。这就是*try-with-resources*（TWR），或称为尝试资源。我们在[“经典 Java
    I/O”](ch10.xhtml#javanut8-CHP-10-SECT-1)中详细讨论了TWR，但为了完整起见，让我们现在介绍一下语法。以下示例展示了如何使用`FileInputStream`类打开文件（这会生成一个需要清理的对象）：
- en: '[PRE117]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: This new form of `try` takes parameters that are all objects that require cleanup.^([2](ch02.xhtml#idm45927754904640))
    These objects are scoped to this `try` block and are then cleaned up automatically
    no matter how this block is exited. The developer does not need to write any `catch`
    or `finally` blocks—the Java compiler automatically inserts correct cleanup code.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 这种新形式的`try`接受的参数都是需要清理的对象，^([2](ch02.xhtml#idm45927754904640))这些对象的作用域限于此`try`块，然后无论如何退出此块，它们都会自动清理。开发人员不需要编写任何`catch`或`finally`块——Java编译器会自动插入正确的清理代码。
- en: All new code that deals with resources should be written in the TWR style—it
    is considerably less error prone than manually writing `catch` blocks and does
    not suffer from the problems that plague techniques such as finalization (see
    [“Finalization”](ch06.xhtml#javanut8-CHP-6-SECT-4) for details).
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 所有涉及资源的新代码都应以TWR风格编写——这比手动编写`catch`块容易出错得多，并且不会遭受像最终化技术（详见[“终结”](ch06.xhtml#javanut8-CHP-6-SECT-4)）那样的问题。
- en: The assert Statement
  id: totrans-667
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**断言语句**'
- en: An `assert` statement is an attempt to provide a capability to verify design
    assumptions in Java code. An *assertion* consists of the `assert` keyword followed
    by a boolean expression that the programmer believes should always evaluate to
    `true`. By default, assertions are not enabled, and the `assert` statement does
    not actually do anything.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: '`assert`语句是在Java代码中验证设计假设的一种尝试。*断言*由`assert`关键字后跟程序员认为应始终评估为`true`的布尔表达式组成。默认情况下，断言是禁用的，而`assert`语句实际上不执行任何操作。'
- en: It is possible to enable assertions as a debugging tool, however; when this
    is done, the `assert` statement evaluates the expression. If it is indeed `true`,
    `assert` does nothing. On the other hand, if the expression evaluates to `false`,
    the assertion fails, and the `assert` statement throws a `java.lang.AssertionError`.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将断言作为调试工具启用，但是当这样做时，`assert` 语句会评估表达式。如果它确实是 `true`，`assert` 不会执行任何操作。另一方面，如果表达式评估为
    `false`，断言将失败，并且 `assert` 语句将抛出一个 `java.lang.AssertionError`。
- en: Tip
  id: totrans-670
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Outside of the core JDK libraries, the `assert` statement is *extremely* rarely
    used. It turns out to be too inflexible for testing most applications and is not
    often used by ordinary developers. Instead, developers use ordinary testing libraries,
    such as JUnit.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 除了核心的 JDK 库之外，`assert` 语句几乎*极少*被使用。事实证明，它对于测试大多数应用程序来说过于不灵活，并且普通开发人员很少使用它。相反，开发者使用普通的测试库，比如
    JUnit。
- en: 'The `assert` statement may include an optional second expression, separated
    from the first by a colon. When assertions are enabled and the first expression
    evaluates to `false`, the value of the second expression is taken as an error
    code or error message and is passed to the `AssertionError()` constructor. The
    full syntax of the statement is:'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: '`assert` 语句可以包含一个可选的第二表达式，用冒号与第一个表达式分隔。当启用断言并且第一个表达式评估为 `false` 时，第二个表达式的值将作为错误代码或错误消息，并传递给
    `AssertionError()` 构造函数。语句的完整语法是：'
- en: '[PRE118]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'or:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE119]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: To use assertions effectively, you must also be aware of a couple of fine points.
    First, remember that your programs will normally run with assertions disabled
    and only sometimes with assertions enabled. This means that you should be careful
    not to write assertion expressions that contain side effects.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 要有效地使用断言，您还必须了解一些细节。首先，请记住，您的程序通常会禁用断言并且仅在某些时候启用断言。这意味着您应该小心，不要编写包含副作用的断言表达式。
- en: Warning
  id: totrans-677
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: You should never throw `AssertionError` from your own code, as it may have unexpected
    results in future versions of the platform.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 您不应该从自己的代码中抛出 `AssertionError`，因为它可能会在平台的将来版本中产生意外的结果。
- en: If an `AssertionError` is thrown, it indicates that one of the programmer’s
    assumptions has not held up. This means that the code is being used outside of
    the parameters for which it was designed, and it cannot be expected to work correctly.
    In short, there is no plausible way to recover from an `AssertionError`, and you
    should not attempt to catch it (unless you catch it at the top level simply so
    that you can display the error in a more user-friendly fashion).
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 如果抛出 `AssertionError`，则表明程序员的某些假设不成立。这意味着代码正在超出其设计的参数范围，并且不能期望其能正常工作。简而言之，没有合理的方式可以从
    `AssertionError` 中恢复，您不应尝试捕获它（除非您仅在顶层捕获它，以便以更用户友好的方式显示错误）。
- en: Enabling assertions
  id: totrans-680
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启用断言
- en: For efficiency, it does not make sense to test assertions each time code is
    executed—`assert` statements encode assumptions that should always be true. Thus,
    by default, assertions are disabled, and `assert` statements have no effect. The
    assertion code remains compiled in the class files, however, so it can always
    be enabled for diagnostic or debugging purposes. You can enable assertions, either
    across the board or selectively, with command-line arguments to the Java interpreter.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 为了效率，每次执行代码时测试断言是没有意义的 — `assert` 语句编码了应始终为真的假设。因此，默认情况下禁用断言，`assert` 语句没有任何效果。但是，断言代码仍然编译在类文件中，因此始终可以为诊断或调试目的启用它们。您可以使用
    Java 解释器的命令行参数启用断言，要么全面启用，要么选择性启用。
- en: 'To enable assertions in all classes except for system classes, use the `-ea`
    argument. To enable assertions in system classes, use `-esa`. To enable assertions
    within a specific class, use `-ea` followed by a colon and the class name:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 要在所有类中除系统类外启用断言，请使用 `-ea` 参数。要在系统类中启用断言，请使用 `-esa`。要在特定类内启用断言，请使用 `-ea` 后跟一个冒号和类名：
- en: '[PRE120]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'To enable assertions for all classes in a package and in all of its subpackages,
    follow the `-ea` argument with a colon, the package name, and three dots:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 要为包及其所有子包中的所有类启用断言，请在 `-ea` 参数后跟一个冒号，包名称和三个点：
- en: '[PRE121]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'You can disable assertions in the same way, using the `-da` argument. For example,
    to enable assertions throughout a package and then disable them in a specific
    class or subpackage, use:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以以相同的方式禁用断言，使用 `-da` 参数。例如，要在一个包中全面启用断言，然后在特定类或子包中禁用它们，请使用：
- en: '[PRE122]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Finally, it is possible to control whether or not assertions are enabled or
    disabled at classloading time. If you use a custom classloader (see [Chapter 11](ch11.xhtml#javanut8-CHP-11)
    for details on custom classloading) in your program and want to turn on assertions,
    you may be interested in these methods.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  id: totrans-689
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A *method* is a named sequence of Java statements that can be invoked by other
    Java code. When a method is invoked, it is passed zero or more values known as
    *arguments*. The method performs some computations and, optionally, returns a
    value. As described earlier in [“Expressions and Operators”](#javanut8-CHP-2-SECT-4),
    a method invocation is an expression that is evaluated by the Java interpreter.
    Because method invocations can have side effects, however, they also can be used
    as expression statements. This section does not discuss method invocation but
    instead describes how to define methods.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
- en: Defining Methods
  id: totrans-691
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You already know how to define the body of a method; it is simply an arbitrary
    sequence of statements enclosed within curly braces. What is more interesting
    about a method is its *signature*.^([3](ch02.xhtml#idm45927754603040)) The signature
    specifies:'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
- en: The name of the method
  id: totrans-693
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number, order, type, and name of the parameters used by the method
  id: totrans-694
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type of the value returned by the method
  id: totrans-695
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The checked exceptions that the method can throw (the signature may also list
    unchecked exceptions, but these are not required)
  id: totrans-696
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various method modifiers that provide additional information about the method
  id: totrans-697
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A method signature defines everything you need to know about a method before
    calling it. It is the method *specification* and defines the API for the method.
    To use the Java platform’s online API reference, you need to know how to read
    a method signature. And, to write Java programs, you need to know how to define
    your own methods, each of which begins with a method signature.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
- en: 'A method signature looks like this:'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: The signature (the method specification) is followed by the method body (the
    method implementation), which is simply a sequence of Java statements enclosed
    in curly braces. If the method is *abstract* (see [Chapter 3](ch03.xhtml#javanut8-CHP-3)),
    the implementation is omitted, and the method body is replaced with a single semicolon.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
- en: The signature of a method may also include type variable declarations—such methods
    are known as *generic methods*. Generic methods and type variables are discussed
    in [Chapter 4](ch04.xhtml#javanut8-CHP-4).
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some example method definitions, which begin with the signature and
    are followed by the method body:'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '*`modifiers`* are zero or more special modifier keywords, separated from each
    other by spaces. A method might be declared with the `public` and `static` modifiers,
    for example. The allowed modifiers and their meanings are described in the next
    section.'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
- en: The *`type`* in a method signature specifies the return type of the method.
    If the method does not return a value, *`type`* must be `void`. If a method is
    declared with a non-`void` return type, it must include a `return` statement that
    returns a value of (or is convertible to) the declared type.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 方法签名中的*`type`*指定方法的返回类型。如果方法不返回值，*`type`*必须是`void`。如果方法声明具有非`void`返回类型，则必须包含一个返回语句，该语句返回声明类型的值（或可转换为其的值）。
- en: A *constructor* is a block of code, similar to a method, that is used to initialize
    newly created objects. As we’ll see in [Chapter 3](ch03.xhtml#javanut8-CHP-3),
    constructors are defined in a very similar way to methods, except that their signatures
    do not include this *`type`* specification and must be named the same as the class.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: '*构造函数*是一段代码块，类似于方法，用于初始化新创建的对象。正如我们将在[第 3 章](ch03.xhtml#javanut8-CHP-3)中看到的，构造函数的定义方式与方法非常相似，只是它们的签名不包括这个*`type`*规范，并且必须与类名相同。'
- en: The *`name`* of a method follows the specification of its modifiers and type.
    Method names, like variable names, are Java identifiers and, like all Java identifiers,
    may contain letters in any language represented by the Unicode character set.
    It is legal, and often quite useful, to define more than one method with the same
    name, as long as each version of the method has a different parameter list. Defining
    multiple methods with the same name is called *method overloading*.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 方法的*`name`*遵循其修饰符和类型的规范。方法名像变量名一样是 Java 标识符，并且像所有 Java 标识符一样，可以包含由 Unicode 字符集表示的任何语言中的字母。定义具有相同名称的多个方法通常是合法且非常有用的，只要每个方法的版本具有不同的参数列表。定义具有相同名称的多个方法称为*方法重载*。
- en: Tip
  id: totrans-709
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Unlike some other languages, Java does not have anonymous methods. Instead,
    Java 8 introduces lambda expressions, which are similar to anonymous methods,
    but which the Java runtime automatically converts to a suitable named method—see
    [“Lambda Expressions”](#javanut8-CHP-2-SECT-7.5a) for more details.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 不同于其他一些语言，Java 没有匿名方法。相反，Java 8 引入了 lambda 表达式，它们类似于匿名方法，但 Java 运行时会自动将它们转换为适当命名的方法——详见[“Lambda
    Expressions”](#javanut8-CHP-2-SECT-7.5a)了解更多细节。
- en: For example, the `System.out.println()` method we’ve seen already is an overloaded
    method. One method by this name prints a string, and other methods by the same
    name print the values of the various primitive types. The Java compiler decides
    which method to call based on the type of the argument passed to the method.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们已经见过的`System.out.println()`方法是一个重载方法。同名的一个方法打印一个字符串，同名的其他方法打印各种基本类型的值。Java
    编译器根据传递给方法的参数类型决定调用哪个方法。
- en: When you are defining a method, the name of the method is always followed by
    the method’s parameter list, which must be enclosed in parentheses. The parameter
    list defines zero or more arguments that are passed to the method. The parameter
    specifications, if there are any, each consist of a type and a name and the specifications
    are separated from each other by commas (if there are multiple parameters). When
    a method is invoked, the argument values it is passed must match the number, type,
    and order of the parameters specified in this method signature line. The values
    passed need not have exactly the same type as specified in the signature, but
    they must be convertible to those types without casting.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 当你定义一个方法时，方法名后总是跟着方法的参数列表，参数列表必须用括号括起来。参数列表定义了零个或多个传递给方法的参数。如果有参数规范，每个规范包括类型和名称，并且规范之间用逗号分隔（如果有多个参数）。当调用一个方法时，传递给它的参数值必须与该方法签名行中指定的参数的数量、类型和顺序匹配。传递的值不需要与签名中指定的类型完全相同，但必须可以在不进行强制转换的情况下转换为这些类型。
- en: Note
  id: totrans-713
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: When a Java method expects no arguments, its parameter list is simply `()`,
    not `(void)`. Java does not regard `void` as a type—C and C++ programmers in particular
    should pay heed.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个 Java 方法不希望有参数时，其参数列表仅为`()`，而不是`(void)`。Java 不将`void`视为一种类型——特别是 C 和 C++
    程序员应该注意。
- en: Java allows the programmer to define and invoke methods that accept a variable
    number of arguments, using a syntax known colloquially as *varargs*. Varargs are
    covered in detail later in this chapter.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: Java 允许程序员定义和调用接受可变数量参数的方法，使用一种俗称为*varargs*的语法。有关 varargs 的详细信息稍后在本章中讨论。
- en: The final part of a method signature is the `throws` clause, which is used to
    list the *checked exceptions* that a method can throw. Checked exceptions are
    a category of exception classes that must be listed in the `throws` clauses of
    methods that can throw them.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 方法签名的最后一部分是`throws`子句，用于列出方法可以抛出的*受检异常*。受检异常是一类必须在方法的`throws`子句中列出的异常类。
- en: If a method uses the `throw` statement to throw a checked exception, the method
    must declare that it can throw that exception. The method must also declare that
    it can throw in the case that it calls some other method that throws a checked
    exception, and the calling method does not explicitly catch that exception.
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个方法使用`throw`语句抛出一个受检异常，那么该方法必须声明它可以抛出该异常。在调用某个抛出受检异常的其他方法且调用方法没有明确捕获该异常的情况下，方法必须声明它可以抛出异常。
- en: If a method can throw one or more checked exceptions, it specifies this by placing
    the `throws` keyword after the argument list and following it by the name of the
    exception class or classes it can throw. If a method does not throw any checked
    exceptions, it does not use the `throws` keyword. If a method throws more than
    one type of checked exception, separate the names of the exception classes from
    each other with commas. More on this in a bit.
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个方法可能抛出一个或多个受检异常，它会通过在参数列表之后放置`throws`关键字并跟随异常类的名称来指定这一点。如果一个方法不会抛出任何受检异常，则不使用`throws`关键字。如果一个方法抛出多种类型的受检异常，使用逗号将异常类的名称分开。稍后详细介绍。
- en: Method Modifiers
  id: totrans-719
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法修饰符
- en: 'The modifiers of a method consist of zero or more modifier keywords such as
    `public`, `static`, or `abstract`. Here is a list of allowed modifiers and their
    meanings:'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 方法的修饰符由零个或多个修饰符关键字组成，例如`public`、`static`或`abstract`。以下是允许的修饰符及其含义列表：
- en: '`abstract`'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: '`abstract`'
- en: An `abstract` method is a specification without an implementation. The curly
    braces and Java statements that would normally comprise the body of the method
    are replaced with a single semicolon. A class that includes an `abstract` method
    must itself be declared `abstract`. Such a class is incomplete and cannot be instantiated
    (see [Chapter 3](ch03.xhtml#javanut8-CHP-3)).
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: '`abstract`方法是没有实现的规范。方法的大括号和Java语句通常组成方法体的部分被替换为一个分号。包含`abstract`方法的类本身必须声明为`abstract`。这样的类是不完整的，不能被实例化（参见[第3章](ch03.xhtml#javanut8-CHP-3)）。'
- en: '`default`'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: '`default`'
- en: A `default` method may be defined only on an interface. All classes implementing
    the interface receive the default method unless they override it directly. Implementing
    interfaces in classes is explored thoroughly in [Chapter 3](ch03.xhtml#javanut8-CHP-3).
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: '`default`方法只能在接口上定义。实现接口的所有类都会接收默认方法，除非它们直接覆盖它。在[第3章](ch03.xhtml#javanut8-CHP-3)中详细探讨了在类中实现接口。'
- en: '`final`'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: '`final`'
- en: A `final` method may not be overridden or hidden by a subclass, which makes
    it amenable to compiler optimizations that are not possible for regular methods.
    All `private` methods are implicitly `final`, as are all methods of any class
    that is declared `final`.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: '`final`方法不能被子类重写或隐藏，这使得它适合进行编译器优化，这对于普通方法来说是不可能的。所有`private`方法都隐式地是`final`的，同样，所有声明为`final`的类的方法也是`final`的。'
- en: '`native`'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: '`native`'
- en: 'The `native` modifier specifies that the method implementation is written in
    some “native” language such as C and is provided externally to the Java program.
    Like `abstract` methods, `native` methods have no body: the curly braces are replaced
    with a semicolon.'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: '`native`修饰符指定方法实现是用某些“本地”语言编写的，比如C，并且是外部提供给Java程序的。与`abstract`方法类似，`native`方法没有方法体：大括号被分号替代。'
- en: '`public`, `protected`, `private`'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: '`public`, `protected`, `private`'
- en: These access modifiers specify whether and where a method can be used outside
    of the class that defines it. These very important modifiers are explained in
    [Chapter 3](ch03.xhtml#javanut8-CHP-3).
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 这些访问修饰符指定方法是否以及在哪里可以在定义它的类的外部使用。这些非常重要的修饰符在[第3章](ch03.xhtml#javanut8-CHP-3)中有详细解释。
- en: '`static`'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: '`static`'
- en: A method declared `static` is a *class method* associated with the class itself
    rather than with an instance of the class (we cover this in more detail in [Chapter 3](ch03.xhtml#javanut8-CHP-3)).
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 声明为`static`的方法是与类本身关联的*类方法*，而不是与类的实例关联的（我们在[第3章](ch03.xhtml#javanut8-CHP-3)中详细讨论这一点）。
- en: '`strictfp`'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: '`strictfp`'
- en: The `fp` in this awkwardly named, rarely used modifier stands for “floating
    point.” For performance reasons, in Java 1.2 the language allowed for subtle deviation
    from the strict IEEE-754 standard when using certain floating-point acceleration
    hardware. The `strictfp` keyword was added to force Java to strictly obey the
    standard. These hardware considerations haven’t been relevant for many years,
    so Java 17 returns the default to the IEEE standard. Use of the `strictfp` keyword
    will emit a warning, as it is no longer necessary.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 这个笨拙命名、很少使用的修饰符中的`fp`代表“浮点”。出于性能原因，在Java 1.2中，当使用某些浮点加速硬件时，语言允许对严格的IEEE-754标准进行微小的偏离。添加了`strictfp`关键字以强制Java严格遵守该标准。这些硬件考虑多年来已不再相关，因此Java
    17将默认返回IEEE标准。使用`strictfp`关键字将会发出警告，因为它已不再必要。
- en: '`synchronized`'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: '`synchronized`'
- en: The `synchronized` modifier makes a method threadsafe. Before a thread can invoke
    a `synchronized` method, it must obtain a lock on the method’s class (for `static`
    methods) or on the relevant instance of the class (for non-`static` methods).
    This prevents two threads from executing the method at the same time.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: '`synchronized`修饰符使方法具有线程安全性。在线程调用`synchronized`方法之前，它必须获取方法类（对于静态方法）或类的相关实例（对于非静态方法）的锁定。这可以防止两个线程同时执行该方法。'
- en: The `synchronized` modifier is an implementation detail (because methods can
    make themselves threadsafe in other ways) and is not formally part of the method
    specification or API. Good documentation specifies explicitly whether a method
    is threadsafe; you should not rely on the presence or absence of the `synchronized`
    keyword when working with multithreaded programs.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: '`synchronized`修饰符是一个实现细节（因为方法可以以其他方式使自己线程安全），并不是方法规范或API的正式部分。良好的文档明确指定方法是否线程安全；在处理多线程程序时，不应依赖于`synchronized`关键字的存在或缺失。'
- en: Tip
  id: totrans-738
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Annotations are an interesting special case (see [Chapter 4](ch04.xhtml#javanut8-CHP-4)
    for more on annotations)—they can be thought of as a halfway house between a method
    modifier and additional supplementary type information.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 注解是一个有趣的特例（详见[第4章](ch04.xhtml#javanut8-CHP-4)关于注解的更多内容）——它们可以被看作是方法修饰符和额外补充类型信息之间的一种中间形式。
- en: Checked and Unchecked Exceptions
  id: totrans-740
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Checked和Unchecked Exceptions
- en: The Java exception-handling scheme distinguishes between two types of exceptions,
    known as *checked* and *unchecked* exceptions.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: Java的异常处理方案区分为两种类型的异常，称为*checked*和*unchecked*异常。
- en: The distinction between checked and unchecked exceptions has to do with the
    circumstances under which the exceptions could be thrown. Checked exceptions arise
    in specific, well-defined circumstances, and very often are conditions from which
    the application may be able to partially or fully recover.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 区分checked和unchecked异常与异常可能被抛出的情况有关。Checked异常发生在特定而明确定义的情况下，并且应用程序可能能够部分或完全恢复。
- en: For example, consider some code that might find its configuration file in one
    of several possible directories. If we attempt to open the file from a directory
    it isn’t present in, then a `FileNotFoundException` will be thrown. In our example,
    we want to catch this exception and move on to try the next possible location
    for the file. In other words, although the file not being present is an exceptional
    condition, it is one from which we can recover, and it is an understood and anticipated
    failure.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一些可能在几个可能的目录中找到其配置文件的代码。如果尝试从不存在的目录中打开文件，则会抛出`FileNotFoundException`。在我们的例子中，我们希望捕获此异常并继续尝试文件的下一个可能位置。换句话说，虽然文件不存在是一个异常情况，但这是一个我们可以恢复的情况，并且是一种可以理解和预见的失败。
- en: On the other hand, in the Java environment there are a set of failures that
    cannot easily be predicted or anticipated, due to such things as runtime conditions
    or abuse of library code. There is no good way to predict an `OutOfMemoryError`,
    for example, and any method that uses objects or arrays can throw a `NullPointerException`
    if it is passed an invalid `null` argument.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在Java环境中，存在一组无法轻易预测或预见的失败，原因可能是运行时条件或滥用库代码。例如，无法有效预测`OutOfMemoryError`，而且任何使用对象或数组的方法，如果传递了无效的`null`参数，都可能抛出`NullPointerException`。
- en: 'These are the unchecked exceptions—and practically any method can throw an
    unchecked exception at essentially any time. They are the Java environment’s version
    of Murphy’s law: “Anything that can go wrong, will go wrong.” Recovery from an
    unchecked exception is usually very difficult, if not impossible—simply due to
    their sheer unpredictability.'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是未检查的异常——基本上任何方法都可能在任何时候抛出未检查的异常。它们是 Java 环境版本的墨菲定律：“任何可能出错的事情，最终都会出错。” 由于它们的完全不可预测性，从未检查的异常中恢复通常非常困难，甚至是不可能的。
- en: To figure out whether an exception is checked or unchecked, remember that exceptions
    are `Throwable` objects and that these fall into two main categories, specified
    by the `Error` and `Exception` subclasses. Any exception object that is an `Error`
    is unchecked. There is also a subclass of `Exception` called `RuntimeException`—and
    any subclass of `RuntimeException` is also an unchecked exception. All other exceptions
    are checked exceptions.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定异常是已检查还是未检查的，记住异常是 `Throwable` 对象，这些对象分为两大类，由 `Error` 和 `Exception` 子类指定。任何
    `Error` 类型的异常对象都是未检查的。还有一个名为 `RuntimeException` 的 `Exception` 子类——任何 `RuntimeException`
    子类也都是未检查的异常。所有其他异常都是已检查的异常。
- en: Working with checked exceptions
  id: totrans-747
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理已检查的异常
- en: Java has different rules for working with checked and unchecked exceptions.
    If you write a method that throws a checked exception, you must use a `throws`
    clause to declare the exception in the method signature. The Java compiler checks
    to make sure you have declared them in method signatures and produces a compilation
    error if you have not (that’s why they’re called “checked exceptions”).
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: Java 对处理已检查和未检查的异常有不同的规则。如果你编写一个会抛出已检查异常的方法，你必须在方法签名中使用 `throws` 子句来声明异常。Java
    编译器会检查你是否在方法签名中声明了它们，如果没有声明就会产生编译错误（这就是它们被称为“已检查的异常”的原因）。
- en: Even if you never throw a checked exception yourself, sometimes you must use
    a `throws` clause to declare a checked exception. If your method calls a method
    that can throw a checked exception, you must either include exception-handling
    code to handle that exception or use `throws` to declare that your method can
    also throw that exception.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你自己从不抛出已检查的异常，有时你也必须使用 `throws` 子句来声明已检查的异常。如果你的方法调用了一个可能抛出已检查异常的方法，你必须要么包含处理异常的代码来处理该异常，要么使用
    `throws` 来声明你的方法也可以抛出该异常。
- en: 'For example, the following method tries to estimate the size of a web page—it
    uses the standard `java.net` libraries and the class `URL` (we’ll meet these in
    [Chapter 10](ch10.xhtml#javanut8-CHP-10)) to contact the web page. It uses methods
    and constructors that can throw various types of `java.io.IOException` objects,
    so it declares this fact with a `throws` clause:'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下方法尝试估算网页的大小——它使用标准的 `java.net` 库和类 `URL`（我们将在[第10章](ch10.xhtml#javanut8-CHP-10)中了解到这些内容）来联系网页。它使用可能抛出各种类型的
    `java.io.IOException` 对象的方法和构造函数，因此它使用 `throws` 子句声明了这一事实：
- en: '[PRE125]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'In fact, the preceding code has a bug: we’ve misspelled the protocol specifier—there’s
    no such protocol as *htp://*. So, the `estimateHomepageSize()` method will always
    fail with a `MalformedURLException`.'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，前面的代码有一个错误：我们拼错了协议说明符——*htp://* 并不存在这样的协议。所以，`estimateHomepageSize()` 方法将始终失败并抛出
    `MalformedURLException`。
- en: How do you know if the method you are calling can throw a checked exception?
    You can look at its method signature to find out. Or, failing that, the Java compiler
    will tell you (by reporting a compilation error) if you’ve called a method whose
    exceptions you must handle or declare.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 你怎么知道你正在调用的方法是否会抛出已检查的异常？你可以查看它的方法签名来找出。或者，如果你调用了必须处理或声明异常的方法，Java 编译器会告诉你（通过报告编译错误）。
- en: Variable-Length Argument Lists
  id: totrans-754
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可变长度的参数列表
- en: Methods may be declared to accept, and may be invoked with, variable numbers
    of arguments. Such methods are commonly known as *varargs* methods. The “print
    formatted” method `System.out.printf()` as well as the related `format()` methods
    of `String` use varargs, as do a number of important methods from the Reflection
    API of `java.lang.reflect`.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 方法可以声明接受和被调用时传递可变数量的参数。这样的方法通常称为 *varargs* 方法。 “print formatted” 方法 `System.out.printf()`
    以及相关的 `String` 的 `format()` 方法使用 varargs，`java.lang.reflect` 的 Reflection API
    中的一些重要方法也是如此。
- en: 'To declare a variable-length argument list, follow the type of the last argument
    to the method with an ellipsis (`...`), indicating that this last argument can
    be repeated zero or more times. For example:'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明一个可变长度的参数列表，请在方法的最后一个参数的类型后面跟着省略号（`...`），表示这个最后一个参数可以重复零次或更多次。例如：
- en: '[PRE126]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Varargs methods are handled purely by the compiler. They operate by converting
    the variable number of arguments into an array. To the Java runtime, the `max()`
    method is indistinguishable from this one:'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 可变参数方法由编译器纯粹处理。它们通过将可变数量的参数转换为数组来运作。对于Java运行时而言，`max()`方法与此方法无异：
- en: '[PRE127]'
  id: totrans-759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: To convert a varargs signature to the “real” signature, simply replace `...`
    with `[ ]`. Remember that only one ellipsis can appear in a parameter list, and
    it may only appear on the last parameter in the list.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 要将可变参数签名转换为“真实”签名，只需将`...`替换为`[ ]`。请记住，参数列表中只能出现一个省略号，并且它只能出现在列表中的最后一个参数上。
- en: 'Let’s flesh out the `max()` example a little:'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微详细说明一下`max()`的示例：
- en: '[PRE128]'
  id: totrans-762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'This `max()` method is declared with two arguments. The first is just a regular
    `int` value. The second, however, may be repeated zero or more times. All of the
    following are legal invocations of `max()`:'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`max()`方法声明了两个参数。第一个参数是一个普通的`int`值。然而，第二个参数可以重复零次或多次。以下所有调用`max()`方法的方式都是合法的：
- en: '[PRE129]'
  id: totrans-764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Because varargs methods are compiled into methods that expect an array of arguments,
    invocations of those methods are compiled to include code that creates and initializes
    such an array. So the call `max(1,2,3)` is compiled to this:'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 因为可变参数方法被编译为期望一个参数数组的方法，调用这些方法被编译为包括创建和初始化这样一个数组的代码。因此，调用`max(1,2,3)`被编译为这样：
- en: '[PRE130]'
  id: totrans-766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'In fact, if you already have method arguments stored in an array, it is perfectly
    legal for you to pass them to the method that way, instead of writing them out
    individually. You can treat any `...` argument as if it were declared as an array.
    The converse is not true, however: you can use varargs method invocation syntax
    only when the method is actually declared as a varargs method using an ellipsis.'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，如果您已经将方法参数存储在数组中，您可以合法地以这种方式将它们传递给方法，而不是逐个写出它们。您可以将任何`...`参数视为已声明为数组。然而，反之则不成立：只有当方法实际上使用省略号声明为可变参数方法时，您才能使用可变参数方法调用语法。
- en: Introduction to Classes and Objects
  id: totrans-768
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类和对象介绍
- en: Now that we have introduced operators, expressions, statements, and methods,
    we can finally talk about classes. A *class* is a named collection of fields that
    holds data values and methods that operate on those values. Classes are just one
    of five reference types supported by Java, but they are the most important type.
    Classes are thoroughly documented in a chapter of their own ([Chapter 3](ch03.xhtml#javanut8-CHP-3)).
    We introduce them here, however, because they are the next higher level of syntax
    after methods, and because the rest of this chapter requires a basic familiarity
    with the concept of a class and the basic syntax for defining a class, instantiating
    it, and using the resulting *object*.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了操作符、表达式、语句和方法，我们终于可以讨论类了。*类*是一个命名的字段集合，其中包含存储数据值和操作这些值的方法。类只是Java支持的五种引用类型之一，但它们是最重要的类型。类在单独的章节中有详细的文档说明（[第3章](ch03.xhtml#javanut8-CHP-3)）。然而，我们在这里介绍它们，是因为它们是方法之后的下一个更高级别的语法，以及本章的其余部分需要对类的概念有基本的熟悉，以及定义类、实例化类和使用生成的*对象*的基本语法。
- en: The most important thing about classes is that they define new data types. For
    example, you might define a class named `Account` to represent a bank account
    that holds a balance. The class would define fields to hold data items such as
    the balance (perhaps represented as a `double`), account holder’s name and address
    (as `String` instances) and methods to manipulate and operate on the account.
    The `Account` class is a new data type.
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 类最重要的一点是它们定义了新的数据类型。例如，您可以定义一个名为`Account`的类来表示一个持有余额的银行账户。该类将定义字段来存储数据项，如余额（可能表示为`double`）、账户持有人的姓名和地址（作为`String`实例），以及操作账户的方法。`Account`类就是一个新的数据类型。
- en: 'When discussing data types, it is important to distinguish between the data
    type itself and the values the data type represents. `char` is a data type: it
    represents Unicode characters. But a `char` value represents a single specific
    character. A class is a data type; a class value is called an *object*. We use
    the name class because each class defines a type (or kind, or species, or class)
    of objects. The `Account` class is a data type that represents bank accounts,
    while an `Account` object represents a single specific account. As you might imagine,
    classes and their objects are closely linked. In the sections that follow, we
    will discuss both.'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
- en: Defining a Class
  id: totrans-772
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is a possible definition of the `Account` class we have been discussing:'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: This class definition is stored in a file named *Account.java* and compiled
    to a file named *Account.class*, where it is available for use by Java programs
    and other classes. This class definition is provided here for completeness and
    to provide context, but don’t expect to understand all the details just yet; most
    of [Chapter 3](ch03.xhtml#javanut8-CHP-3) is devoted to the topic of defining
    classes.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that you don’t have to define every class you want to use in a
    Java program. The Java platform includes thousands of predefined classes that
    are guaranteed to be available on every computer that runs that given version
    of Java.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Object
  id: totrans-777
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have defined the `Account` class as a new data type, we can use
    the following line to declare a variable that holds an `Account` object:'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-779
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Declaring a variable to hold an `Account` object does not create the object
    itself, however. To actually create an object, you must use the `new` operator.
    This keyword is followed by the object’s class (i.e., its type) and an optional
    argument list in parentheses. These arguments are passed to the constructor for
    the class, which initializes internal fields in the new object:'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: The `new` keyword is by far the most common way to create objects in Java. A
    few other ways are also worth mentioning. First, classes that meet certain criteria
    are so important that Java defines special literal syntax for creating objects
    of those types (as we discuss later in this section). Second, Java supports a
    mechanism that allows programs to load classes and create instances of those classes
    dynamically. See [Chapter 11](ch11.xhtml#javanut8-CHP-11) for more details. Finally,
    objects can also be created by deserializing them. An object that has had its
    state saved, or serialized, usually to a file, can be recreated using the `java.io.ObjectInputStream`
    class.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
- en: Using an Object
  id: totrans-783
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we’ve seen how to define classes and instantiate them by creating
    objects, we need to look at the Java syntax that allows us to use those objects.
    Recall that a class defines a collection of fields and methods. Each object has
    its own copies of those fields and has access to those methods. We use the dot
    character (.) to access the named fields and methods of an object. For example:'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: This syntax is very common when programming in object-oriented languages, and
    Java is no exception. Note, in particular, the expression `a.toString()`. This
    tells the Java compiler to look up a method named `toString` (which is defined
    by the parent `Object` class of `Account`) and use that method to perform a computation
    on the object `a`. We’ll cover the details of this operation in [Chapter 3](ch03.xhtml#javanut8-CHP-3).
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
- en: Object Literals
  id: totrans-787
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our discussion of primitive types, we saw that each primitive type has a
    literal syntax for including values of the type literally into the text of a program.
    Java also defines a literal syntax for a few special reference types, as described
    next.
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
- en: String literals
  id: totrans-789
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `String` class represents text as a string of characters. Because programs
    usually communicate with their users through the written word, the ability to
    manipulate strings of text is quite important in any programming language. In
    Java, strings are objects; the data type used to represent text is the `String`
    class. Modern Java programs usually use more string data than anything else.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
- en: Accordingly, because strings are such a fundamental data type, Java allows you
    to include text literally in programs in one of two formats. Traditional strings
    are placed between double-quote (`"`) characters, or a newer text block form may
    be used between sequences of three double-quote characters (`"""`).
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
- en: 'A traditional double-quoted string looks like this:'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-793
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Don’t confuse the double-quote characters that surround string literals with
    the single-quote (or apostrophe) characters that surround `char` literals.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
- en: 'String literals of either form can contain any of the escape sequences `char`
    literals can (see [Table 2-2](#javanut8-CHP-2-TABLE-2)). Traditional double-quoted
    strings require escape sequences to embed double-quote characters or newlines.
    They also must consist of a single line in our Java code. For example:'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: The primary use for text blocks instead of traditional strings is representing
    multi-line strings. Text blocks start with `"""`, followed by a newline, and end
    when a concluding `"""` is reached.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
- en: Along with their support for multiline strings, text blocks also allow us to
    use double quotes without escaping. This often makes text blocks much easier to
    read, particularly when expressing another programming language (such as SQL or
    HTML) in our Java code.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-799
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Examining the output from this code reveals one more interesting fact about
    text blocks regarding indentation. The above prints with `<html>` in the first
    column of the output with no leading spaces.
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler finds the smallest indentation across the lines of our text block
    and strips that many leading spaces from each line. If this is not desired, the
    placement of the closing `"""` also participates in choosing the indent. We could
    retain the full white space with:'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-802
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Before text blocks were introduced in Java, it was common to break up string
    literals for easier reading using `+` to concatenate them. Along with existing
    in many code bases, this remains a valid technique if your string shouldn’t include
    newlines.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-804
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: Literals, whether traditional or text blocks, are concatenated when your program
    is compiled, not when it is run, so you do not need to worry about any kind of
    performance penalty.
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
- en: Type literals
  id: totrans-806
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The second type that supports its own special object literal syntax is the
    class named `Class`. Instances of the `Class` class represent a Java data type
    and contain metadata about the type that is referred to. To include a `Class`
    object literally in a Java program, follow the name of any data type with `.class`.
    For example:'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-808
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: The null reference
  id: totrans-809
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `null` keyword is a special literal value that is a reference to nothing,
    or an absence of a reference. The `null` value is unique because it is a member
    of every reference type. You can assign `null` to variables of any reference type.
    For example:'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  id: totrans-811
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: Lambda Expressions
  id: totrans-812
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Java 8 introduced a major new feature—*lambda expressions*. These are a very
    common programming language construct and in particular are extremely widely used
    in the family of languages known as *functional programming languages* (e.g.,
    Lisp, Haskell, and OCaml). The power and flexibility of lambdas goes far beyond
    just functional languages, and they can be found in almost all modern programming
    languages.
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for a lambda expression looks like this:'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  id: totrans-815
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'One simple, very traditional example:'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: When a lambda expression is used as a value, it is automatically converted to
    a new object of the correct type for the variable it is being placed into. This
    autoconversion and *type inference* is essential to Java’s approach to lambda
    expressions. Unfortunately, it relies on a proper understanding of Java’s type
    system as a whole. [“Nested Types”](ch04.xhtml#javanut8-CHP-4-SECT-5) provides
    a more detailed explanation of lambda expressions—so for now, it suffices to simply
    recognize the syntax for lambdas.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
- en: 'A slightly more complex example:'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  id: totrans-820
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Arrays
  id: totrans-821
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An *array* is a special kind of object that holds zero or more primitive values
    or references. These values are held in the *elements* of the array, which are
    unnamed variables referred to by their position or *index*. The type of an array
    is characterized by its *element type*, and all elements of the array must be
    of that type.
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
- en: Array elements are numbered starting with zero, and valid indexes range from
    zero to the number of elements minus one. The array element with index 1, for
    example, is the *second* element in the array. The number of elements in an array
    is its *length*. The length of an array is specified when the array is created,
    and it never changes (unlike Java collections, which we’ll see in [Chapter 8](ch08.xhtml#javanut8-CHP-8)).
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
- en: The element type of an array may be any valid Java type, including array types.
    This means that Java supports arrays of arrays, which provide a kind of multidimensional
    array capability. Java does not support the matrix-style multidimensional arrays
    found in some languages.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
- en: While Java’s Collection API, covered thoroughly in [Chapter 8](ch08.xhtml#javanut8-CHP-8),
    is often more flexible and feature-rich than basic arrays, arrays remain common
    throughout the platform and it’s worth understanding the details of using them.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
- en: Array Types
  id: totrans-826
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Array types are reference types, just as classes are. Instances of arrays are
    objects, just as the instances of a class are.^([4](ch02.xhtml#idm45927752917984))
    Unlike classes, array types do not have to be defined. Simply place square brackets
    after the element type. For example, the following code declares three variables
    of array type:'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  id: totrans-828
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: The length of an array is not part of the array type. It is not possible, for
    example, to declare a method that expects an array of exactly four `int` values.
    If a method parameter is of type `int[]`, a caller can pass an array with any
    number (including zero) of elements.
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
- en: Array types are not classes, but array instances are objects. This means that
    arrays inherit the methods of `java.lang.Object`. Arrays implement the `Cloneable`
    interface and override the `clone()` method to guarantee that an array can always
    be cloned and that `clone()` never throws a `CloneNotSupportedException`. Arrays
    also implement `Serializable` so that any array can be serialized if its element
    type can be serialized. Finally, all arrays have a `public final int` field named
    `length` that specifies the number of elements in the array.
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
- en: Array type widening conversions
  id: totrans-831
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Because arrays extend `Object` and implement the `Cloneable` and `Serializable`
    interfaces, any array type can be widened to any of these three types. But certain
    array types can also be widened to other array types. If the element type of an
    array is a reference type `T`, and `T` is assignable to a type `S`, the array
    type `T[]` is assignable to the array type `S[]`. Note that there are no widening
    conversions of this sort for arrays of a given primitive type. As examples, the
    following lines of code show legal array widening conversions:'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  id: totrans-833
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: This ability to widen an array type to another array type means that the compile-time
    type of an array is not always the same as its runtime type.
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-835
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This widening is known as *array covariance*, and as we shall see in [“Bounded
    Type Parameters”](ch04.xhtml#javanut8-CHP-4-SECT-2.5), it is regarded by modern
    standards as a historical artifact and a misfeature, because of the mismatch between
    compile and runtime typing that it exposes.
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
- en: The compiler must usually insert runtime checks before any operation that stores
    a reference value into an array element to ensure that the runtime type of the
    value matches the runtime type of the array element. An `ArrayStoreException`
    is thrown if the runtime check fails.
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
- en: C compatibility syntax
  id: totrans-838
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we’ve seen, you write an array type simply by placing brackets after the
    element type. For compatibility with C and C++, however, Java supports an alternative
    syntax in variable declarations: brackets may be placed after the name of the
    variable instead of, or in addition to, the element type. This applies to local
    variables, fields, and method parameters. For example:'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  id: totrans-840
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: Tip
  id: totrans-841
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This compatibility syntax is extremely uncommon, and you should not use it.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
- en: Creating and Initializing Arrays
  id: totrans-843
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create an array value in Java, you use the `new` keyword, just as you do
    to create an object. Array types don’t have constructors, but you are required
    to specify a length whenever you create an array. Specify the desired size of
    your array as a nonnegative integer between square brackets:'
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  id: totrans-845
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'When you create an array with this syntax, each of the array elements is automatically
    initialized to the same default value that is used for the fields of a class:
    `false` for `boolean` elements, `\u0000` for `char` elements, `0` for integer
    elements, `0.0` for floating-point elements, and `null` for elements of reference
    type.'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
- en: Array creation expressions can also be used to create and initialize a multidimensional
    array of arrays. This syntax is somewhat more complicated and is explained later
    in this section.
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
- en: Array initializers
  id: totrans-848
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To create an array and initialize its elements in a single expression, omit
    the array length and follow the square brackets with a comma-separated list of
    expressions within curly braces. The type of each expression must be assignable
    to the element type of the array, of course. The length of the array that is created
    is equal to the number of expressions. It is legal, but not necessary, to include
    a trailing comma following the last expression in the list. For example:'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'Note that this syntax allows arrays to be created, initialized, and used without
    ever being assigned to a variable. In a sense, these array creation expressions
    are anonymous array literals. Here are examples:'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  id: totrans-852
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'When an array initializer is part of a variable declaration, you may omit the
    `new` keyword and element type and list the desired array elements within curly
    braces:'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  id: totrans-854
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Array literals are created and initialized when the program is run, not when
    the program is compiled. Consider the following array literal:'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  id: totrans-856
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'This is compiled into Java bytecodes that are equivalent to:'
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  id: totrans-858
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'The fact that Java does all array initialization at runtime has an important
    corollary. It means that the expressions in an array initializer may be computed
    at runtime and need not be compile-time constants. For example:'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  id: totrans-860
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: Using Arrays
  id: totrans-861
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once an array has been created, you are ready to start using it. The following
    sections explain basic access to the elements of an array and cover common idioms
    of array usage, such as iterating through the elements of an array and copying
    an array or part of an array.
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
- en: Accessing array elements
  id: totrans-863
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The elements of an array are variables. When an array element appears in an
    expression, it evaluates to the value held in the element. And when an array element
    appears on the lefthand side of an assignment operator, a new value is stored
    into that element. Unlike a normal variable, however, an array element has no
    name, only a number. Array elements are accessed using a square bracket notation.
    If `a` is an expression that evaluates to an array reference, you index that array
    and refer to a specific element with `a[i]`, where `i` is an integer literal or
    an expression that evaluates to an `int`. For example:'
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  id: totrans-865
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'The array index expression must be of type `int`, or a type that can be widened
    to an `int`: `byte`, `short`, or even `char`. It is obviously not legal to index
    an array with a `boolean`, `float`, or `double` value. Remember that the `length`
    field of an array is an `int` and that arrays may not have more than `Integer.MAX_VALUE`
    elements. Indexing an array with an expression of type `long` generates a compile-time
    error, even if the value of that expression at runtime would be within the range
    of an `int`.'
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
- en: Array bounds
  id: totrans-867
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that the first element of an array `a` is `a[0]` , the second element
    is `a[1]`, and the last is `a[a.length-1]`.
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
- en: A common bug involving arrays is use of an index that is too small (a negative
    index) or too large (greater than or equal to the array `length`). In languages
    like C or C++, accessing elements before the beginning or after the end of an
    array yields unpredictable behavior that can vary from invocation to invocation
    and platform to platform. Such bugs may not always be caught, and if a failure
    occurs, it may be at some later time. While it is just as easy to write faulty
    array indexing code in Java, Java guarantees predictable results by checking every
    array access at runtime. If an array index is too small or too large, Java immediately
    throws an `ArrayIndexOutOfBoundsException`.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
- en: Iterating arrays
  id: totrans-870
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is common to write loops that iterate through each of the elements of an
    array in order to perform some operation on it. This is typically done with a
    `for` loop. The following code, for example, computes the sum of an array of integers:'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  id: totrans-872
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'The structure of this `for` loop is idiomatic, and you’ll see it frequently.
    Java also has the foreach syntax that we’ve already met. The summing code could
    be rewritten succinctly as follows:'
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  id: totrans-874
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: Copying arrays
  id: totrans-875
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All array types implement the `Cloneable` interface, and any array can be copied
    by invoking its `clone()` method. Note that a cast is required to convert the
    return value to the appropriate array type, but the `clone()` method of arrays
    is guaranteed not to throw a `CloneNotSupportedException`:'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  id: totrans-877
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: The `clone()` method makes a shallow copy. If the element type of the array
    is a reference type, only the references are copied, not the referenced objects
    themselves. Because the copy is shallow, any array can be cloned, even if the
    element type is not itself `Cloneable`.
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes you simply want to copy elements from one existing array to another
    existing array. The `System.arraycopy()` method is designed to do this efficiently,
    and you can assume that Java VM implementations perform this method using high-speed
    block copy operations on the underlying hardware.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
- en: '`arraycopy()` is a straightforward function that is difficult to use only because
    it has five arguments to remember. First, pass the source array from which elements
    are to be copied. Second, pass the index of the start element in that array. Pass
    the destination array and the destination index as the third and fourth arguments.
    Finally, as the fifth argument, specify the number of elements to be copied.'
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
- en: '`arraycopy()` works correctly even for overlapping copies within the same array.
    For example, if you’ve “deleted” the element at index `0` from array `a` and want
    to shift the elements between indexes `1` and `n` down one so that they occupy
    indexes `0` through `n-1,` you could do this:'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  id: totrans-882
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: Array utilities
  id: totrans-883
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `java.util.Arrays` class contains a number of static utility methods for
    working with arrays. Most of these methods are heavily overloaded, with versions
    for arrays of each primitive type and another version for arrays of objects.
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
- en: The `sort()` and `binarySearch()` methods are particularly useful for sorting
    and searching arrays. The `equals()` method allows you to compare the content
    of two arrays. The `toString()` method is useful when you want to convert array
    content to a string, such as for debugging or logging output. `copyOf()` is a
    useful alternative to `arraycopy()` we’ve seen before if you’re ok with a new
    array being allocated rather than copying into an existing one.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
- en: The `Arrays` class also includes `deepEquals()`, `deepHashCode()`, and `deepToString()`
    methods that work correctly for multidimensional arrays.
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
- en: Multidimensional Arrays
  id: totrans-887
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we’ve seen, an array type is written as the element type followed by a pair
    of square brackets. An array of `char` is `char[]`, and an array of arrays of
    `char` is `char[][]`. When the elements of an array are themselves arrays, we
    say that the array is *multidimensional*. In order to work with multidimensional
    arrays, you need to understand a few additional details.
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that you want to use a multidimensional array to represent a multiplication
    table:'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  id: totrans-890
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: Each of the pairs of square brackets represents one dimension, so this is a
    two-dimensional array. To access a single `int` element of this two-dimensional
    array, you must specify two index values, one for each dimension. Assuming that
    this array was actually initialized as a multiplication table, the `int` value
    stored at any given element would be the product of the two indexes. That is,
    `products[2][4]` would be 8, and `products[3][7]` would be 21.
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new multidimensional array, use the `new` keyword and specify the
    size of both dimensions of the array. For example:'
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  id: totrans-893
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'In some languages, an array like this would be created as a single block of
    100 `int` values. Java does not work this way. This line of code does three things:'
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
- en: Declares a variable named `products` to hold an array of arrays of `int`.
  id: totrans-895
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates a 10-element array to hold 10 arrays of `int`.
  id: totrans-896
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates 10 more arrays, each of which is a 10-element array of `int`. It assigns
    each of these 10 new arrays to the elements of the initial array. The default
    value of every `int` element of each of these 10 new arrays is 0.
  id: totrans-897
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To put this another way, the previous single line of code is equivalent to
    the following code:'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  id: totrans-899
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'The `new` keyword performs this additional initialization automatically for
    you. It works with arrays with more than two dimensions as well:'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  id: totrans-901
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'When using `new` with multidimensional arrays, you do not have to specify a
    size for all dimensions of the array, only the leftmost dimension or dimensions.
    For example, the following two lines are legal:'
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  id: totrans-903
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'The first line creates a single-dimensional array, where each element of the
    array can hold a `float[][]`. The second line creates a two-dimensional array,
    where each element of the array is a `float[]`. If you specify a size for only
    some of the dimensions of an array, however, those dimensions must be the leftmost
    ones. The following lines are not legal:'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  id: totrans-905
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'Like a one-dimensional array, a multidimensional array can be initialized using
    an array initializer. Simply use nested sets of curly braces to nest arrays within
    arrays. For example, we can declare, create, and initialize a 5 × 5 multiplication
    table like this:'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  id: totrans-907
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'Or, if you want to use a multidimensional array without declaring a variable,
    you can use the anonymous initializer syntax:'
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  id: totrans-909
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'When you create a multidimensional array using the `new` keyword, it is usually
    good practice to use only *rectangular* arrays: ones in which all the array values
    for a given dimension have the same size.'
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
- en: Reference Types
  id: totrans-911
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we’ve covered arrays and introduced classes and objects, we can turn
    to a more general description of *reference types*. Classes and arrays are two
    of Java’s five kinds of reference types. Classes were introduced earlier and are
    covered in complete detail, along with *interfaces*, in [Chapter 3](ch03.xhtml#javanut8-CHP-3).
    Enumerated types and annotation types are reference types introduced in [Chapter 4](ch04.xhtml#javanut8-CHP-4).
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
- en: This section does not cover specific syntax for any particular reference type
    but instead explains the general behavior of reference types and illustrates how
    they differ from Java’s primitive types. In this section, the term *object* refers
    to a value or instance of any reference type, including arrays.
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
- en: Reference Versus Primitive Types
  id: totrans-914
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Reference types and objects differ substantially from primitive types and their
    primitive values:'
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
- en: Eight primitive types are defined by the Java language, and the programmer cannot
    define new primitive types.
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
- en: Reference types are user-defined, so there is an unlimited number of them. For
    example, a program might define a class named `Account` and use objects of this
    newly defined type to store and track user bank accounts.
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
- en: Primitive types represent single values.
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
- en: Reference types are aggregate types that hold zero or more primitive values
    or objects. Our hypothetical `Account` class, for example, might hold a numeric
    value for the balance, along with identifiers for the account owner. The `char[]`
    and `Account[]` array types are aggregate types because they hold a sequence of
    primitive `char` values or `Account` objects.
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
- en: Primitive types require between one and eight bytes of memory.
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
- en: When a primitive value is stored in a variable or passed to a method, the computer
    makes a copy of the bytes that hold the value. Objects, on the other hand, may
    require substantially more memory. Memory to store an object is dynamically allocated
    on the heap when the object is created, and this memory is automatically “garbage
    collected” when the object is no longer needed.
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-922
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When an object is assigned to a variable or passed to a method, the memory that
    represents the object is not copied. Instead, only a reference to that memory
    is stored in the variable or passed to the method.
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
- en: References are completely opaque in Java and the representation of a reference
    is an implementation detail of the Java runtime. If you are a C programmer, however,
    you can safely imagine a reference as a pointer or a memory address. Remember,
    though, that Java programs cannot manipulate references in any way.
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
- en: Unlike pointers in C and C++, references cannot be converted to or from integers,
    and they cannot be incremented or decremented. C and C++ programmers should also
    note that Java does not support the `&` address-of operator or the `*` and `->`
    dereference operators.
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating Objects and Reference Copies
  id: totrans-926
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following code manipulates a primitive `int` value:'
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  id: totrans-928
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: After these lines execute, the variable `y` contains a copy of the value held
    in the variable `x`. Inside the Java VM, there are two independent copies of the
    32-bit integer 42.
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
- en: 'Now think about what happens if we run the same basic code but use a reference
    type instead of a primitive type:'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  id: totrans-931
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'After this code runs, the variable `b` holds a copy of the reference held in
    the variable `a`. There is still only one copy of the `Account` object in the
    VM, but there are now two copies of the reference to that object. This has some
    important implications. Suppose the two previous lines of code are followed by
    this code:'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  id: totrans-933
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'Because the variables `a` and `b` hold references to the same object, either
    variable can be used to make changes to the object, and those changes are visible
    through the other variable as well. As arrays are a kind of object, the same thing
    happens with arrays, as illustrated by the following code:'
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  id: totrans-935
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'A similar difference in behavior between primitive types and reference types
    occurs when arguments are passed to methods. Consider the following method:'
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  id: totrans-937
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: When this method is invoked, the method is given a copy of the argument used
    to invoke the method in the parameter `x`. The code in the method uses `x` as
    a loop counter and decrements it to zero. Because `x` is a primitive type, the
    method has its own private copy of this value, so this is a perfectly reasonable
    thing to do.
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, consider what happens if we modify the method so that the
    parameter is a reference type:'
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  id: totrans-940
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'When this method is invoked, it is passed a private copy of a reference to
    a `Account` object and can use this reference to change the `Account` object.
    For example, consider:'
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  id: totrans-942
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: When the `changeReference()` method is invoked, it is passed a copy of the reference
    held in variable `a`. Now both the variable `a` and the method parameter `b` hold
    references to the same object. The method can use its reference to change the
    contents of the object. Note, however, that it cannot change the contents of the
    variable `a`. In other words, the method can change the `Account` object beyond
    recognition, but it cannot change the fact that the variable `a` refers to that
    object.
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
- en: Comparing Objects
  id: totrans-944
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ve seen that primitive types and reference types differ significantly in
    the way they are assigned to variables, passed to methods, and copied. The types
    also differ in the way they are compared for equality. When used with primitive
    values, the equality operator (`==`) simply tests whether two values are identical
    (i.e., whether they have exactly the same bits). With reference types, however,
    `==` compares references, not actual objects. In other words, `==` tests whether
    two references refer to the same object; it does not test whether two objects
    have the same content. Here’s an example:'
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  id: totrans-946
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'When working with reference types, keep in mind there are two kinds of equality:
    equality of reference and equality of object. It is important to distinguish between
    these two kinds of equality. One way to do this is to use the word “identical”
    when talking about equality of references and the word “equal” when talking about
    two distinct objects that have the same content. To test two nonidentical objects
    for equality, pass one of them to the `equals()` method of the other:'
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  id: totrans-948
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: All objects inherit an `equals()` method (from `Object`), but the default implementation
    simply uses `==` to test for identity of references, not equality of content.
    A class that wants to allow objects to be compared for equality can define its
    own version of the `equals()` method. Our `Account` class does not do this, but
    the `String` class does, as indicated in the code example. You can call the `equals()`
    method on an array, but it is the same as using the `==` operator, because arrays
    always inherit the default `equals()` method that compares references rather than
    array content. You can compare arrays for equality with the `java.util.Arrays.equals()`
    convenience method.
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
- en: Boxing and Unboxing Conversions
  id: totrans-950
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Primitive types and reference types behave quite differently. It is sometimes
    useful to treat primitive values as objects, and for this reason, the Java platform
    includes *wrapper classes* for each of the primitive types. `Boolean`, `Byte`,
    `Short`, `Character`, `Integer`, `Long`, `Float`, and `Double` are immutable,
    final classes whose instances each hold a single primitive value. These wrapper
    classes are usually used when you want to store primitive values in collections
    such as `java.util.List`:'
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  id: totrans-952
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: Java allows types of conversions known as boxing and unboxing conversions. Boxing
    conversions convert a primitive value to its corresponding wrapper object and
    unboxing conversions do the opposite. You may explicitly specify a boxing or unboxing
    conversion with a cast, but this is unnecessary, as these conversions are automatically
    performed when you assign a value to a variable or pass a value to a method. Furthermore,
    unboxing conversions are also automatic if you use a wrapper object when a Java
    operator or statement expects a primitive value. Because Java performs boxing
    and unboxing automatically, this language feature is often known as *autoboxing*.
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of automatic boxing and unboxing conversions:'
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  id: totrans-955
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'Autoboxing makes dealing with collections much easier as well. Let’s look at
    an example that uses Java’s *generics* (a language feature we’ll meet properly
    in [“Java Generics”](ch04.xhtml#javanut8-CHP-4-SECT-2)) that allows us to restrict
    what types can be put into lists and other collections:'
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  id: totrans-957
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: Packages and the Java Namespace
  id: totrans-958
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A *package* is a named collection of classes, interfaces, and other reference
    types. Packages serve to group related classes and define a namespace for the
    classes they contain.
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
- en: The core classes of the Java platform are in packages whose names begin with
    `java`. For example, the most fundamental classes of the language are in the package
    `java.lang`. Various utility classes are in `java.util`. Classes for input and
    output are in `java.io`, and classes for networking are in `java.net`. Some of
    these packages contain subpackages, such as `java.lang.reflect` and `java.util.regex`.
    Extensions to the Java platform that have been standardized by Oracle (or originally
    Sun) typically have package names that begin with `javax`. Some of these extensions,
    such as `javax.swing` and its myriad subpackages, were later adopted into the
    core platform itself. Finally, the Java platform also includes several “endorsed
    standards,” which have packages named after the standards body that created them,
    such as `org.w3c` and `org.omg`.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
- en: Every class has both a simple name, which is the name given to it in its definition,
    and a fully qualified name, which includes the name of the package of which it
    is a part. The `String` class, for example, is part of the `java.lang` package,
    so its fully qualified name is `java.lang.String`.
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
- en: This section explains how to place your own classes and interfaces into a package
    and how to choose a package name that won’t conflict with anyone else’s package
    name. Next, it explains how to selectively import type names or static members
    into the namespace so that you don’t have to type the package name of every class
    or interface you use.
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
- en: Package Declaration
  id: totrans-963
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To specify the package a class belongs to, you use a `package` declaration.
    The `package` keyword, if it appears, must be the first token of Java code (i.e.,
    the first thing other than comments and space) in the Java file. The keyword should
    be followed by the name of the desired package and a semicolon. Consider a Java
    file that begins with this directive:'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  id: totrans-965
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: All classes defined by this file are part of the package `org.apache.commons.net`.
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
- en: If no `package` directive appears in a Java file, all classes defined in that
    file are part of an unnamed default package. In this case, the qualified and unqualified
    names of a class are the same.
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-968
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The possibility of naming conflicts means that you should not use the default
    package. As your project grows more complicated, conflicts become almost inevitable—much
    better to create packages right from the start.
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
- en: Globally Unique Package Names
  id: totrans-970
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the important functions of packages is to partition the Java namespace
    and prevent name collisions between classes. It is only their package names that
    keep the `java.util.List` and `java.awt.List` classes distinct, for example. For
    this to work, however, package names must themselves be distinct. As the developer
    of Java, Oracle controls all package names that begin with `java`, `javax`, and
    `sun`.
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
- en: One common scheme is to use your domain name, with its elements reversed, as
    the prefix for all your package names. For example, the Apache Project produces
    a networking library as part of the Apache Commons project. The Commons project
    can be found at [*http://commons.apache.org*](http://commons.apache.org) and accordingly,
    the package name used for the networking library is `org.apache.commons.net`.
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
- en: Note that these package-naming rules apply primarily to API developers. If other
    programmers will be using classes that you develop along with unknown other classes,
    it is important that your package name be globally unique. On the other hand,
    if you are developing a Java application and will not be releasing any of the
    classes for reuse by others, you know the complete set of classes that your application
    will be deployed with and do not have to worry about unforeseen naming conflicts.
    In this case, you can choose a package-naming scheme for your own convenience
    rather than for global uniqueness. One common approach is to use the application
    name as the main package name (it may have subpackages beneath it).
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
- en: Importing Types
  id: totrans-974
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When referring to a class or interface in your Java code, you must, by default,
    use the fully qualified name of the type, including the package name. If you’re
    writing code to manipulate a file and need to use the `File` class of the `java.io`
    package, you must type `java.io.File`. This rule has three exceptions:'
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
- en: Types from the package `java.lang` are so important and so commonly used that
    they can always be referred to by their simple names.
  id: totrans-976
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code in a type `p.T` may refer to other types defined in the package `p`
    by their simple names.
  id: totrans-977
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types that have been *imported* into the namespace with an `import` declaration
    may be referred to by their simple names.
  id: totrans-978
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first two exceptions are known as “automatic imports.” The types from `java.lang`
    and the current package are “imported” into the namespace so that they can be
    used without their package name. Typing the package name of commonly used types
    that are not in `java.lang` or the current package quickly becomes tedious, and
    so it is also possible to explicitly import types from other packages into the
    namespace. This is done with the `import` declaration.
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
- en: '`import` declarations must appear at the start of a Java file, immediately
    after the `package` declaration, if there is one, and before any type definitions.
    You may use any number of `import` declarations in a file. An `import` declaration
    applies to all type definitions in the file (but not to any `import` declarations
    that follow it).'
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
- en: 'The `import` declaration has two forms. To import a single type into the namespace,
    follow the `import` keyword with the name of the type and a semicolon:'
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  id: totrans-982
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: This is known as the “single type `import`” declaration.
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
- en: 'The other form of `import` declaration is the “on-demand type `import`.” In
    this form, you specify the name of a package followed by the characters `.*` to
    indicate that any type from that package may be used without its package name.
    Thus, if you want to use several other classes from the `java.io` package in addition
    to the `File` class, you can simply import the entire package:'
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  id: totrans-985
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: This on-demand `import` syntax does not apply to subpackages. If I import the
    `java.util` package, I must still refer to the `java.util.zip.ZipInputStream`
    class by its fully qualified name or import it.
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
- en: Using an on-demand type `import` declaration is not the same as explicitly writing
    out a single type `import` declaration for every type in the package. It is more
    like an explicit single type `import` for every type in the package *that you
    actually use* in your code. This is the reason it’s called “on demand”; types
    are imported as you use them.
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
- en: Naming conflicts and shadowing
  id: totrans-988
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`import` declarations are invaluable to Java programming. They do expose us
    to the possibility of naming conflicts, however. Consider the packages `java.util`
    and `java.awt`. Both contain types named `List`.'
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
- en: '`java.util.List` is an important and commonly used interface. The `java.awt`
    package contains a number of important types that are commonly used in client-side
    applications, but `java.awt.List` has been superseded and is not one of these
    important types. It is illegal to import both `java.util.List` and `java.awt.List`
    in the same Java file. The following single type `import` declarations produce
    a compilation error:'
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  id: totrans-991
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'Using on-demand type imports for the two packages is legal:'
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  id: totrans-993
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: Difficulty arises, however, if you actually try to use the type `List`. This
    type can be imported “on demand” from either package, and any attempt to use `List`
    as an unqualified type name produces a compilation error. The workaround, in this
    case, is to explicitly specify the package name you want.
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
- en: 'Because `java.util.List` is much more commonly used than `java.awt.List`, it
    is useful to combine the two on-demand type `import` declarations with a single
    type `import` declaration that serves to disambiguate what we mean when we say
    `List`:'
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  id: totrans-996
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: With these `import` declarations in place, we can use `List` to mean the `java.util.List`
    interface. If we actually need to use the `java.awt.List` class, we can still
    do so as long as we include its package name. There are no other naming conflicts
    between `java.util` and `java.awt`, and their types will be imported “on demand”
    when we use them without a package name.
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
- en: Importing Static Members
  id: totrans-998
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As well as types, you can import the static members of types using the keywords
    `import static`. (Static members are explained in [Chapter 3](ch03.xhtml#javanut8-CHP-3).
    If you are not already familiar with them, you may want to come back to this section
    later.) Like type `import` declarations, these static `import` declarations come
    in two forms: single static member `import` and on-demand static member `import`.
    Suppose, for example, that you are writing a text-based program that sends a lot
    of output to `System.out`. In this case, you might use this single static member
    `import` to save yourself typing:'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  id: totrans-1000
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'You can then use `out.println()` instead of `System.out.println()`. Or suppose
    you are writing a program that uses many of the trigonometric and other functions
    of the `Math` class. In a program that is clearly focused on numerical methods
    like this, having to repeatedly type the class name “Math” does not add clarity
    to your code; it just gets in the way. In this case, an on-demand static member
    `import` may be appropriate:'
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  id: totrans-1002
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: With this `import` declaration, you are free to write concise expressions like
    `sqrt(abs(sin(x)))` without having to prefix the name of each static method with
    the class name `Math`.
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
- en: 'Another important use of `import static` declarations is to import the names
    of constants into your code. This works particularly well with enumerated types
    (see [Chapter 4](ch04.xhtml#javanut8-CHP-4)). Suppose, for example, that you want
    to use the values of this enumerated type in code you are writing:'
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  id: totrans-1005
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'You could import the type `climate.temperate.Seasons` and then prefix the constants
    with the type name: `Seasons.SPRING`. For more concise code, you could import
    the enumerated values themselves:'
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  id: totrans-1007
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: Using static member `import` declarations for constants is generally a better
    technique than implementing an interface that defines the constants.
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
- en: Static member imports and overloaded methods
  id: totrans-1009
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A static `import` declaration imports a *name*, not any one specific member
    with that name. Because Java allows method overloading and allows a type to have
    fields and methods with the same name, a single static member `import` declaration
    may actually import more than one member. Consider this code:'
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  id: totrans-1011
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: This declaration imports the name “sort” into the namespace, not any one of
    the 19 `sort()` methods defined by `java.util.Arrays`. If you use the imported
    name `sort` to invoke a method, the compiler will look at the types of the method
    arguments to determine which method you mean.
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
- en: 'It is even legal to import static methods with the same name from two or more
    different types as long as the methods all have different signatures. Here is
    one natural example:'
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  id: totrans-1014
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: You might expect that this code would cause a syntax error. In fact, it does
    not because the `sort()` methods defined by the `Collections` class have different
    signatures than all of the `sort()` methods defined by the `Arrays` class. When
    you use the name “sort” in your code, the compiler looks at the types of the arguments
    to determine which of the 21 possible imported methods you mean.
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
- en: Java Source File Structure
  id: totrans-1016
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter has taken us from the smallest to the largest elements of Java
    syntax, from individual characters and tokens to operators, expressions, statements,
    and methods, and on up to classes and packages. From a practical standpoint, the
    unit of Java program structure you will be dealing with most often is the Java
    file. A Java file is the smallest unit of Java code that can be compiled by the
    Java compiler. A Java file consists of:'
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
- en: An optional `package` directive
  id: totrans-1018
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zero or more `import` or `import static` directives
  id: totrans-1019
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One or more type definitions
  id: totrans-1020
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These elements can be interspersed with comments, of course, but they must appear
    in this order. This is all there is to a Java file. All Java statements (except
    the `package` and `import` directives, which are not true statements, and the
    specialized module descriptors we’ll discuss in [Chapter 12](ch12.xhtml#javanut8-CHP-12))
    must appear within methods, and all methods must appear within a type definition.
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
- en: A special Java file named `module-info.java` is used only in declaring the structure
    and visibility of our packages in a modular Java application. These more advanced
    techniques and syntax are covered in detail in [Chapter 12](ch12.xhtml#javanut8-CHP-12).
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
- en: Java files have a couple of other important restrictions. First, each file can
    contain at most one top-level class that is declared `public`. A `public` class
    is one that is designed for use by other classes in other packages. A class can
    contain any number of nested or inner classes that are `public`. We’ll see more
    about the `public` modifier and nested classes in [Chapter 3](ch03.xhtml#javanut8-CHP-3).
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
- en: The second restriction concerns the filename of a Java file. If a Java file
    contains a `public` class, the name of the file must be the same as the name of
    the class, with the extension *.java* appended. Therefore, if `Account` is defined
    as a `public` class, its source code must appear in a file named *Account.java*.
    Regardless of whether your classes are `public` or not, it is good programming
    practice to define only one per file and to give the file the same name as the
    class.
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
- en: When a Java file is compiled, each of the classes it defines is compiled into
    a separate *class* file that contains Java bytecodes to be executed by the Java
    Virtual Machine. A class file has the same name as the class it defines, with
    the extension *.class* appended. Thus, if the file *Account.java* defines a class
    named `Account`, a Java compiler compiles it to a file named *Account.class*.
    On most systems, class files are stored in directories that correspond to their
    package names. For example, the class `com.davidflanagan.examples.Account` is
    defined by the class file *com/davidflanagan/**examples/Account.class*.
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
- en: The Java runtime knows where the class files for the standard system classes
    are located and can load them as needed. When the interpreter runs a program that
    wants to use a class named `com.davidflanagan.examples.Account`, it knows that
    the code for that class is located in a directory named *com/davidflanagan/examples/*
    and, by default, it “looks” in the current directory for a subdirectory of that
    name. In order to tell the interpreter to look in locations other than the current
    directory, you must use the `-classpath` option when invoking the interpreter
    or set the `CLASSPATH` environment variable. For details, see the documentation
    for the Java executable, *java*, in [Chapter 13](ch13.xhtml#javanut8-CHP-13).
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
- en: Defining and Running Java Programs
  id: totrans-1027
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A Java program consists of a set of interacting class definitions. But not
    every Java class or Java file defines a program. To create a program, you must
    define a class that has a special method with the following signature:'
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  id: totrans-1029
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: This `main()` method is the main entry point for your program. It is where the
    Java interpreter starts running. This method is passed an array of strings and
    returns no value. When `main()` returns, the Java interpreter exits (unless `main()`
    has created separate threads, in which case the interpreter waits for all those
    threads to exit).
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
- en: 'To run a Java program, you run the Java executable, *java*, specifying the
    fully qualified name of the class that contains the `main()` method. Note that
    you specify the name of the class, *not* the name of the class file that contains
    the class. Any additional arguments you specify on the command line are passed
    to the `main()` method as its `String[]` parameter. You may also need to specify
    the `-classpath` option (or `-cp`) to tell the interpreter where to look for the
    classes needed by the program. Consider the following command:'
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  id: totrans-1032
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '`java` is the command to run the Java interpreter. `-classpath /opt/Jude` tells
    the interpreter where to look for *.class* files. `com.davidflanagan.jude.Jude`
    is the name of the program to run (i.e., the name of the class that defines the
    `main()` method). Finally, `datafile.jude` is a string that is passed to that
    `main()` method as the single element of an array of `String` objects.'
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
- en: 'There is an easier way to run programs. If a program and all its auxiliary
    classes (except those that are part of the Java platform) have been properly bundled
    in a Java archive (JAR) file, you can run the program simply by specifying the
    name of the JAR file. In the next example, we show how to start up a log analyzer:'
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  id: totrans-1035
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: 'Some operating systems make JAR files automatically executable. On those systems,
    you can simply say:'
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  id: totrans-1037
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'Java 17 also introduced the ability to run `java` against a source file directly,
    similar to what’s available in scripting languages such as Python. You still must
    define a class matching the name of the file and a `main()` method, but then you
    can execute the program with:'
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  id: totrans-1039
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: See [Chapter 13](ch13.xhtml#javanut8-CHP-13) for more details on how to execute
    Java programs.
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-1041
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ve introduced the basic syntax of the Java language. Due
    to the interlocking nature of the syntax of programming languages, it is perfectly
    fine if you don’t feel at this point that you have completely grasped all of the
    syntax of the language. It is by practice that we acquire proficiency in any language,
    human or computer.
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
- en: It is also worth observing that some parts of syntax are far more regularly
    used than others. For example, the `strictfp` and `assert` keywords are almost
    never used. Rather than trying to grasp every aspect of Java’s syntax, it is far
    better to begin to acquire facility in the core aspects of Java and then return
    to any details of syntax that may still be troubling you. With this in mind, let’s
    move to the next chapter and begin to discuss the classes and objects that are
    so central to Java and the basics of Java’s approach to object-oriented programming.
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch02.xhtml#idm45927772106240-marker)) Technically, the minus sign is an
    operator that operates on the literal and not part of the literal itself.
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch02.xhtml#idm45927754904640-marker)) Technically, they must all implement
    the `AutoCloseable` interface.
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch02.xhtml#idm45927754603040-marker)) In the Java Language Specification,
    the term “signature” has a technical meaning that is slightly different than that
    used here. This book uses a less formal definition of method signature.
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch02.xhtml#idm45927752917984-marker)) There is a terminology difficulty
    in discussions of arrays. Unlike with classes and their instances, we use the
    term “array” for both the array type and the array instance. In practice, it is
    usually clear from context whether a type or a value is being discussed.
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
