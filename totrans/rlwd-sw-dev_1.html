<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" class="pagenumrestart" data-pdf-bookmark="Chapter 1. Starting the Journey"><div class="chapter" id="chapter_01">
<h1><span class="label">Chapter 1. </span>Starting the Journey</h1>


<p>In this chapter, we’ll give you an introduction to the concepts and principles of this book.<a data-type="indexterm" data-primary="practices and principles over technology" id="idm45816839670056"/> A good way of summarizing the overall approach is <em>Practices and Principles over Technology</em>.
There are already many books about specific technologies, and we aren’t seeking to add to that enormous pile. That isn’t to say that the detailed knowledge that is specific to a given
language, framework, or library isn’t useful. It’s just that it has a shorter shelf-life than general practices and principles that apply over longer periods of time and across different languages and frameworks. That’s where this book can help you.</p>






<section data-type="sect1" data-pdf-bookmark="Themes"><div class="sect1" id="idm45816839668280">
<h1>Themes</h1>

<p>Throughout the book we’ve used a project-based structure to aid learning.<a data-type="indexterm" data-primary="themes" id="ix_them"/> It’s worth thinking
about the different themes that run through the chapters, how they link up together, and why
we chose them.
Following are the four different themes that weave through the chapters.</p>








<section data-type="sect2" data-pdf-bookmark="Java Features"><div class="sect2" id="idm45816839665288">
<h2>Java Features</h2>

<p>Structuring code with classes and interfaces is discussed in <a data-type="xref" href="ch02.xhtml#chapter_02">Chapter 2</a>. We move<a data-type="indexterm" data-primary="Java" data-secondary="features" id="idm45816839662936"/><a data-type="indexterm" data-primary="themes" data-secondary="Java features" id="idm45816839661960"/> onto
exceptions and packages in <a data-type="xref" href="ch03.xhtml#chapter_03">Chapter 3</a>. You will also get a short overview of lambda expressions in <a data-type="xref" href="ch03.xhtml#chapter_03">Chapter 3</a>. Then local variable type inferences and switch expressions are explained in <a data-type="xref" href="ch05.xhtml#chapter_05">Chapter 5</a>, and finally lambda expressions and method references are covered in detail in <a data-type="xref" href="ch07.xhtml#chapter_07">Chapter 7</a>. Java language features are important because so many software
projects are written in Java, so it’s useful language to know the workings of it. Many of these
language features are useful in other programming languages as well, such as C#, C++, Ruby, or Python.
Even though those languages have differences, understanding the how to use a class and core OOP
concepts will be valuable across different languages.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Software Design and Architecture"><div class="sect2" id="idm45816839657128">
<h2>Software Design and Architecture</h2>

<p>Throughout the book a series of design patterns are introduced that help provide you with common
solutions to common problems that developers encounter.<a data-type="indexterm" data-primary="software design and architecture" id="idm45816839655544"/><a data-type="indexterm" data-primary="themes" data-secondary="software design and architecture" id="idm45816839654824"/> These are important to know because even
though it may seem like every software project is different and comes with its own set of problems,
in practice many of these have been encountered before. Understanding common problems and
solutions that have <span class="keep-together">been solved</span> by developers keeps you from reinventing the wheel in a new
software project and enables you to deliver software faster and more reliably.</p>

<p>The higher-level concepts of coupling and cohesion are introduced early on the book in <a data-type="xref" href="ch02.xhtml#chapter_02">Chapter 2</a>. The Notification pattern is introduced in <a data-type="xref" href="ch03.xhtml#chapter_03">Chapter 3</a>. How to design a user-friendly Fluent API and the Builder pattern are introduced in <a data-type="xref" href="ch05.xhtml#chapter_05">Chapter 5</a>.
We look at the big-picture concepts of event-driven and hexagonal architectures in <a data-type="xref" href="ch06.xhtml#chapter_06">Chapter 6</a> and the Repository pattern in <a data-type="xref" href="ch07.xhtml#chapter_07">Chapter 7</a>. Finally, you’re also introduced to functional programming in <a data-type="xref" href="ch07.xhtml#chapter_07">Chapter 7</a>.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="SOLID"><div class="sect2" id="idm45816839646776">
<h2>SOLID</h2>

<p>We cover all the SOLID principles throughout various chapters.<a data-type="indexterm" data-primary="SOLID principles" data-seealso="listings under individual principle names" id="idm45816839645224"/><a data-type="indexterm" data-primary="themes" data-secondary="SOLID principles" id="idm45816839644200"/> These are a set of principles
designed to help make software easier to maintain. While we like to think of writing software
as the fun part, if the software that you write is successful it will need to evolve,
grow, and be maintained. Trying to make the software as easy to maintain as
possible helps this evolution, maintenance, and long-term addition of features. The SOLID principles<a data-type="indexterm" data-primary="Liskov substitution principle (LSP)" id="idm45816839642728"/><a data-type="indexterm" data-primary="interface segregation principle (ISP)" id="idm45816839642040"/><a data-type="indexterm" data-primary="dependency inversion principle (DIP)" id="idm45816839641352"/><a data-type="indexterm" data-primary="open/closed principle (OCP)" id="idm45816839640664"/><a data-type="indexterm" data-primary="single responsibility principle (SRP)" id="idm45816839639976"/><a data-type="indexterm" data-primary="SOLID principles" data-secondary="single responsibility principle (SRP)" id="idm45816839639288"/><a data-type="indexterm" data-primary="SOLID principles" data-secondary="open/closed principle (OCP)" id="idm45816839638328"/><a data-type="indexterm" data-primary="SOLID principles" data-secondary="Liskov substitution principle (LSP)" id="idm45816839637368"/><a data-type="indexterm" data-primary="SOLID principles" data-secondary="interface segregation principle (ISP)" id="idm45816839636408"/><a data-type="indexterm" data-primary="SOLID principles" data-secondary="dependency inversion principle (DIP)" id="idm45816839635448"/>
and the chapters where we will discuss them are:</p>

<ul>
<li>
<p>Single Responsibility Principle (SRP), discussed in <a data-type="xref" href="ch02.xhtml#chapter_02">Chapter 2</a></p>
</li>
<li>
<p>Open/Closed Principle (OCP), discussed in <a data-type="xref" href="ch03.xhtml#chapter_03">Chapter 3</a></p>
</li>
<li>
<p>Liskov Substitution Principle (LSP), discussed in <a data-type="xref" href="ch04.xhtml#chapter_04">Chapter 4</a></p>
</li>
<li>
<p>Interface Segregation Principle (ISP), discussed in <a data-type="xref" href="ch05.xhtml#chapter_05">Chapter 5</a></p>
</li>
<li>
<p>Dependency Inversion Principle (DIP), discussed in <a data-type="xref" href="ch07.xhtml#chapter_07">Chapter 7</a></p>
</li>
</ul>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Testing"><div class="sect2" id="idm45816839328920">
<h2>Testing</h2>

<p>Writing reliable code that can be easily evolved over time is really important. Automated
tests are key to this.<a data-type="indexterm" data-primary="themes" data-secondary="testing" id="idm45816839327496"/><a data-type="indexterm" data-primary="testing" id="idm45816839326520"/> As the software that you write scales in size it becomes increasingly
hard to manually test different possible cases. You need to automate your testing processes to avoid the days of human effort it would take to test your software without it.</p>

<p>You learn about the basics of writing tests in Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch02.xhtml#chapter_02">2</a> and
<a data-type="xref" data-xrefstyle="select:labelnumber" href="ch04.xhtml#chapter_04">4</a>. This
is extended to test-driven development, or TDD, in <a data-type="xref" href="ch05.xhtml#chapter_05">Chapter 5</a>. In <a data-type="xref" href="ch06.xhtml#chapter_06">Chapter 6</a> we cover the use
of test doubles, including mocks and stubs.<a data-type="indexterm" data-primary="themes" data-startref="ix_them" id="idm45816839320760"/></p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Chapter Summary"><div class="sect1" id="idm45816839319480">
<h1>Chapter Summary</h1>

<p>Here’s the outline of the chapters.</p>
<dl>
<dt><a data-type="xref" data-xrefstyle="chap-num-title" href="ch02.xhtml#chapter_02">Chapter 2, <em>The Bank Statements Analyzer</em></a></dt>
<dd>
<p>You’ll write a program to analyze bank
statements in order to help people understand their finances better. This will help you
to learn more about core object-oriented design techniques such as <em>Single Responsibility
Principle</em> (SRP), coupling, and cohesion.</p>
</dd>
<dt><a data-type="xref" data-xrefstyle="chap-num-title" href="ch03.xhtml#chapter_03">Chapter 3, <em>Extending the Bank Statements Analyzer</em></a></dt>
<dd>
<p>In this chapter you learn how to
extend the code from <a data-type="xref" href="ch02.xhtml#chapter_02">Chapter 2</a>, adding more features, using the Strategy Design pattern,
the Open/Closed Principle, and how to model failures using exceptions.</p>
</dd>
<dt><a data-type="xref" data-xrefstyle="chap-num-title" href="ch04.xhtml#chapter_04">Chapter 4, <em>The Document Management System</em></a></dt>
<dd>
<p>In this chapter we help a successful doctor
manage her patient records better. This introduces concepts such as inheritance
within software design, the Liskov Substitution Principle, and tradeoffs between composition and inheritance. You will also learn how to write more reliable software with
automated test code.</p>
</dd>
<dt><a data-type="xref" data-xrefstyle="chap-num-title" href="ch05.xhtml#chapter_05">Chapter 5, <em>The Business Rules Engine</em></a></dt>
<dd>
<p>You’ll learn about building a core business rules
engine—a way of defining business logic that is flexible and easy to maintain.
This chapter introduces the topics of test-driven development, developing a Fluent API, and the
Interface Segregation Principle.</p>
</dd>
<dt><a data-type="xref" data-xrefstyle="chap-num-title" href="ch06.xhtml#chapter_06">Chapter 6, <em>Twootr</em></a></dt>
<dd>
<p><em>Twootr</em> is a messaging platform that enables people to broadcast
short messages to other users who follow them. This chapter builds out the core of a simple Twootr system. You’ll learn how to think outside-in—to go from requirements through to the core of your application. You’ll also learn how to use test doubles to isolate and test interactions from different components within your codebase.</p>
</dd>
<dt><a data-type="xref" data-xrefstyle="chap-num-title" href="ch07.xhtml#chapter_07">Chapter 7, <em>Extending Twootr</em></a></dt>
<dd>
<p>The final project-based chapter in the book extends the Twootr implementation from the previous chapter. It explains the Dependency Inversion Principle and introduces bigger picture architectural choices such as event-driven and hexagonal architectures.
This chapter can help you extend your knowledge of automated
testing by covering test doubles, such as stubs and mocks, and also functional programming
techniques.</p>
</dd>
<dt><a data-type="xref" data-xrefstyle="chap-num-title" href="ch08.xhtml#chapter_08">Chapter 8, <em>Conclusion</em></a></dt>
<dd>
<p>This final concluding chapter revisits the major themes and concepts of the book and offers additional resources as you continue in your programming career.</p>
</dd>
</dl>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Iterating on You"><div class="sect1" id="idm45816839317352">
<h1>Iterating on You</h1>

<p>As a software developer you may well approach projects in an iterative fashion.
That’s to say, slice off the highest priority week or two’s worth of work items,
implement them, and then use the feedback in order to decide on the next set of items.
We’ve found that it’s often worth evaluating the progress of your own skills in the same
way.</p>

<p>At the end of every chapter there is a brief “Iterating on You” section with a few
suggestions on how you improve upon on the learning from the chapter in your own time.</p>

<p>Now that you know what you can expect from this book, let’s get to work!</p>
</div></section>







</div></section></div>



  </body></html>