- en: Chapter 13\. Streams to Iterables to Sequences
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章 流到可迭代对象到序列
- en: Java and Kotlin both allow us to transform and reduce collections. They have
    different design goals and implementations, though. What does Kotlin use instead
    of Java streams, when should we convert, and how?
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Java 和 Kotlin 都允许我们转换和减少集合。不过它们具有不同的设计目标和实现。Kotlin 在何时使用而不是 Java 流，何时进行转换，以及如何进行呢？
- en: Java Streams
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 流
- en: 'Java 8 introduced streams in 2014, making good use of the new lambdas. Say
    we want to work out the average length of some strings, except that blank strings
    (those with only whitespace characters) should be treated as if they are empty.
    Previously we might have written:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8 在 2014 年引入了流，充分利用了新的 lambda。假设我们想计算一些字符串的平均长度，但空白字符串（只包含空白字符）应视为空字符串处理。以前我们可能会这样写：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'With Java streams, we can express this algorithm as `filter`, `map`, and `reduce`
    by first converting the `List` to a `Stream` and applying transformations:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Java 流，我们可以将这个算法表达为 `filter`、`map` 和 `reduce`，首先将 `List` 转换为 `Stream` 并应用转换：
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Rather than having to run the for-loop in our heads to see what this code is
    doing, we can see the steps of the algorithm declared line by line and rely on
    the runtime to implement those steps for us.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 与在我们的头脑中运行 for 循环来查看这段代码在做什么相比，我们可以逐行声明算法的步骤，并依赖运行时来为我们实现这些步骤。
- en: 'If we are really in a hurry for those results, we can even write:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们真的急于获得这些结果，我们甚至可以这样写：
- en: '[PRE2]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[![1](assets/1.png)](#co_introduction_CO21-1)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_introduction_CO21-1)'
- en: '`parallelStream` will divide the work across multiple threads.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`parallelStream` 将工作分配到多个线程中。'
- en: 'There are different types of fundamental operations going on here: `map` changes
    the type of items, not their number; `filter` keeps or rejects items depending
    on some property, but keeps their type the same; and `sum` is a reduction of the
    collection to a single property. Not shown in this example are the operations
    `skip(n)` and `limit(n)`. These return streams without the first and last `n`
    elements, respectively.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这里进行了不同类型的基本操作：`map` 改变了项目的类型，而不是它们的数量；`filter` 根据某些属性保留或拒绝项目，但保持它们的类型不变；而 `sum`
    是将集合减少到单个属性。在这个例子中未显示的操作还有 `skip(n)` 和 `limit(n)`。它们分别返回无头部和尾部 `n` 个元素的流。
- en: 'Java streams are lazy: `strings.filter(...).mapToInt(...)` does nothing but
    set up a pipeline for some terminal operation, `sum` in this case, to suck values
    through. Laziness means that later pipeline stages can limit the amount of work
    earlier stages have to perform. Consider translating a list of words until we
    see the word `STOP`. The loop version might look like this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Java 流是惰性的：`strings.filter(...).mapToInt(...)` 仅设置了一个管道用于某些终端操作，如本例中的 `sum`，来吸收值。惰性意味着后续的管道阶段可以限制前面阶段必须执行的工作量。考虑翻译一个单词列表直到我们看到单词
    `STOP`。循环版本可能如下所示：
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'By breaking out of the loop, we don’t translate all the words, only the minimum
    we need. Java 9 introduced `dropWhile` and `takeWhile`, which allow us to express
    this as:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通过退出循环，我们不需要翻译所有的单词，只翻译我们需要的最少数量。Java 9 引入了 `dropWhile` 和 `takeWhile`，使我们可以表达如下：
- en: '[PRE4]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This works because the `collect` causes values to be sucked through the pipeline,
    and `takeWhile` stops sucking from its predecessor when its predicate returns
    `false`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这起作用是因为 `collect` 导致值通过管道被吸收，而 `takeWhile` 在其谓词返回 `false` 时停止从其前身吸收。
- en: On the subject of sucking, streams can be surprisingly slow for small collections.
    They are great for large-scale data crunching where we want to throw all available
    cores at a problem—not so great for summing the cost of five items in a shopping
    cart. The problem is that Java streams were designed to provide general collection
    transformations, lazy evaluation, *and* parallel processing, and these have different
    demands. Kotlin doesn’t try to implement parallel operations, leaving two abstractions;
    iterables are good for transforming and reducing collections, whereas sequences
    give lazy evaluation.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在提到吸收的主题上，对于小集合而言，流可能会令人惊讶地慢。它们非常适合大规模数据处理，其中我们希望投入所有可用的核心解决问题，但对于计算购物车中五件物品的成本来说效果不佳。问题在于
    Java 流被设计为提供一般集合转换、惰性评估以及*并行处理*，而这些具有不同的需求。Kotlin 不尝试实现并行操作，留下了两种抽象；可迭代对象适合于转换和减少集合，而序列则提供惰性评估。
- en: Kotlin Iterables
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kotlin 可迭代对象
- en: 'Instead of creating a new interface to define collections operations, Kotlin
    provides extension functions on `Iterable`. The simplest Kotlin expression of
    the same algorithm is:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 不是通过创建一个新的接口来定义集合操作，而是提供了 `Iterable` 上的扩展函数。相同算法的最简单 Kotlin 表达式是：
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here `filter` is an extension function on `Iterable`. Unlike the `Stream.filter`,
    though, which returns another `Stream`, the Kotlin `filter` returns a `List` (which
    is `Iterable`, so we can continue the chain); `map` returns a `List`, too, so
    this single expression creates two additional lists in memory.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这里 `filter` 是 `Iterable` 上的一个扩展函数。不同于 `Stream.filter` 返回另一个 `Stream`，Kotlin
    的 `filter` 返回一个 `List`（它是 `Iterable`，所以我们可以继续链式调用）；`map` 也返回一个 `List`，因此这个单一表达式在内存中创建了两个额外的列表。
- en: The first is a `List` of the nonblank strings, the second is a `List` of the
    lengths of those strings. When (if) we care about performance, this can be a problem,
    because both of those lists will take time to populate and memory to support.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是非空字符串的 `List`，第二个是这些字符串长度的 `List`。当（如果）我们关心性能时，这可能是一个问题，因为这两个列表都需要时间来填充和支持内存。
- en: The `List` of lengths is a particular issue, because the integers will have
    been *boxed* (wrapped in an `Integer` object) to fit in the list. The Java streams
    example used `mapToInt(String::length)` to avoid this problem. `IntStream` (and
    `LongStream` and `DoubleStream`, but curiously not `BooleanStream` or `CharStream`)
    were created to prevent streams having to box and unbox, but you have to remember
    to use them, and `IntStream` is not a `Stream<Integer>`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 长度的 `List` 是一个特殊的问题，因为整数将会被 *装箱*（包装在 `Integer` 对象中）以适应列表。Java 流示例使用了 `mapToInt(String::length)`
    来避免这个问题。`IntStream`（以及 `LongStream` 和 `DoubleStream`，但奇怪的是不包括 `BooleanStream`
    或 `CharStream`）被创建出来以防止流必须进行装箱和拆箱，但是你必须记住使用它们，而且 `IntStream` 不是一个 `Stream<Integer>`。
- en: Should we care about performance? Mostly no—this Kotlin will be fast *unless*
    we have large collections, the opposite of streams, which are only fast *if* we
    have large collections. When we do have large collections, we can switch over
    to sequences.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该关心性能吗？大多数情况下不需要——这个 Kotlin 会很快，*除非*我们有大型集合，与之相反的是流，只有 *如果* 我们有大型集合才会很快。当我们有大型集合时，我们可以切换到序列。
- en: Kotlin Sequences
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kotlin 序列
- en: 'The Kotlin `Sequence` abstraction offers the same lazy evaluation as Java streams.
    The `map` operation on a `Sequence` returns another `Sequence`: the operations
    in the chain are only performed when some terminal operation requires their evaluation.
    If we have a `Collection`, `Iterable`, or even an `Iterator`, there are `asSequence()`
    extension functions to convert. After that the API is suspiciously familiar:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 的 `Sequence` 抽象提供了与 Java 流相同的惰性评估。`Sequence` 上的 `map` 操作返回另一个 `Sequence`：链中的操作只有在某些终端操作需要对它们进行评估时才执行。如果我们有一个
    `Collection`、`Iterable` 或者甚至是一个 `Iterator`，都可以使用 `asSequence()` 扩展函数进行转换。之后，API
    就会变得令人熟悉：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The familiarity is suspicious because all those operations (`filter`, `map`,
    `sum`) are now extensions not on `Iterable` but `Sequence`, and they don’t return
    a `List`; they return another `Sequence`. Except, that is, for `sum`, which can’t
    even pretend to do its job without reading all the data, so it is a terminal operation.
    This code reads the same as the iterable version, but each of the functions is
    actually different.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉性令人怀疑，因为所有这些操作（`filter`、`map`、`sum`）现在都是 `Sequence` 而不是 `Iterable` 的扩展，并且它们不返回一个
    `List`；它们返回另一个 `Sequence`。除了 `sum`，它甚至不能假装在没有读取所有数据的情况下完成它的工作，所以它是一个终端操作。这段代码读起来与可迭代版本相同，但是每个函数实际上是不同的。
- en: 'The sequence version of `averageNonBlankLength` won’t pay the price of creating
    the intermediate lists to hold the results of each stage, but for small numbers
    of items, the cost of setting up and executing the pipeline may be higher than
    creating the lists. In this case the `Int` lengths will still be boxed as `Integer`,
    albeit one at a time rather than creating a whole list of them. In many cases,
    the API designers will have provided a clever solution to remove boxing. In this
    case, it is `sumBy`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`averageNonBlankLength` 的序列版本不会付出创建中间列表以保存每个阶段结果的代价，但是对于少量项目，设置和执行流水线的成本可能高于创建列表。在这种情况下，`Int`
    长度仍然会被装箱为 `Integer`，尽管只是一个接一个地装箱，而不是创建一个完整的列表。在许多情况下，API 设计者会提供一个聪明的解决方案来消除装箱。在这种情况下，就是
    `sumBy`：'
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`sumBy` (also available as an extension on `Iterable`) avoids boxing by taking
    a function that returns an `Int`. It can do this because it is a terminal operation,
    so it doesn’t return another sequence or collection.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`sumBy`（也作为`Iterable`的扩展可用）通过接受返回`Int`的函数来避免装箱。它能做到这一点是因为它是一个终端操作，所以它不会返回另一个序列或集合。'
- en: Multiple Iterations
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多次迭代
- en: 'If you use Java streams, you have probably tried to do something like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用Java流，您可能已经尝试过像这样做一些事情：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This looks very plausible: we’ve just extracted a function, taking a `Stream`
    parameter rather than the `List`. There is no `size` property on `Stream`, but
    `count()` gives the same result, so we use that. When we run it, though, we get
    `java.lang.IllegalState​Excep⁠tion: stream has already been operated upon or closed`.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '这看起来非常合理：我们刚刚提取了一个函数，它接受一个`Stream`参数而不是`List`。在`Stream`上没有`size`属性，但`count()`给出了相同的结果，所以我们使用它。然而，当我们运行它时，我们得到`java.lang.IllegalState​Excep⁠tion:
    stream has already been operated upon or closed`。'
- en: The problem is that a `Stream` has hidden state. Once we have consumed all its
    items (and `sum` does just that), we can’t go around again to `count` them. Even
    though `sum` is actually a method on `IntStream`, each stream in the pipeline
    consumes its predecessor, so the input `strings` is consumed by the `sum`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于`Stream`具有隐藏状态。一旦我们消耗了它的所有项目（`sum`就是这样做的），我们不能再去`count`它们了。即使`sum`实际上是`IntStream`上的一个方法，流管道中的每个流都消耗了其前驱，所以输入`strings`被`sum`消耗了。
- en: 'In Java this is enough to put you off extracting `Stream` operations into functions.
    Let’s try the same thing with a Kotlin `Sequence`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，这已经足以让你放弃将`Stream`操作提取到函数中。让我们尝试一下使用Kotlin的`Sequence`：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In Kotlin, we can call the `Sequence` version from the `List` version and all
    is fine…for now.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中，我们可以从`List`版本调用`Sequence`版本，一切都很顺利...目前为止。
- en: 'We are storing up trouble though. To see why, let’s step out another layer
    and add a function that takes an `Iterator`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们正在积累麻烦。为了理解为什么，让我们再多加一层，添加一个接受`Iterator`的函数：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If we call this function, we now get `java.lang.IllegalStateException: This
    sequence can be consumed only once.` (Comparing this to the streams error, we
    see that the Kotlin developers seem to be more grammatically pedantic than the
    JVM developers.) Now the `Sequence` is acting like a Java `Stream`, but previously
    it wasn’t. What changed?'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '如果我们调用这个函数，我们现在会得到`java.lang.IllegalStateException: This sequence can be consumed
    only once.`（与流错误进行比较，我们可以看到Kotlin开发者似乎比JVM开发者更注重语法上的严谨性。）现在`Sequence`的行为就像Java的`Stream`一样，但之前不是。发生了什么变化？'
- en: 'It turns out that some sequences can safely be iterated over multiple times:
    those backed by a collection that is held in memory, for example. Others cannot.
    Now that our `Sequence` is provided by an `Iterator`, the first run through (to
    calculate the `sum`) continued until `Iterator.hasNext()` returned `false`. If
    we were to try to run through the `Sequence` again (to `count`), the `Iterator`
    state would not have changed, so `hasNext()` would immediately return `false`.
    This would lead `strings.count()` to return `0`, resulting in `averageNonBlankLength`
    always returning `Infinity` (if there was any input).'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 原来有一些序列可以安全地多次迭代：那些由内存中保存的集合支持的序列，例如。其他则不能。现在我们的`Sequence`由`Iterator`提供，第一次运行（计算`sum`）持续到`Iterator.hasNext()`返回`false`。如果我们尝试再次运行`Sequence`（来计算`count`），`Iterator`的状态不会改变，因此`hasNext()`会立即返回`false`。这将导致`strings.count()`返回`0`，从而导致`averageNonBlankLength`始终返回`Infinity`（如果有任何输入）。
- en: This sort of behavior is, erm, *undesirable*, so sequences wrapping iterators
    are deliberately hobbled with `Sequence.constrainOnce()` to prevent this. It is
    `constrainOnce()` that throws the `IllegalStateException` if we try to consume
    twice.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为有点，嗯，*不可取*，因此包装迭代器的序列通过`Sequence.constrainOnce()`有意地进行了限制，以防止多次消费。如果我们试图两次消费，`constrainOnce()`将抛出`IllegalStateException`。
- en: The other canonical example of a `Sequence` that cannot be consumed more than
    once is one backed by reading from an external resource, such as a file or network
    socket. In such cases we can’t in general just go back and replay input to iterate
    again.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sequence`的另一个经典例子是不能被多次消费的一个`Sequence`，它是由读取外部资源（比如文件或网络套接字）支持的。在这种情况下，我们通常不能简单地回溯并重放输入以进行再次迭代。'
- en: Unfortunately, the difference between the two types of `Sequence` is not reflected
    in the type system, so we will only discover any incompatibility between our algorithm
    and our input at runtime. As we will see in [Chapter 20](ch20.html#performing-io-to-passing-data),
    this is exacerbated by the common technique of using `sequenceOf(...)` or `List.asSequence()`
    as our test data; these sequences *do* support multiple iterations and won’t warn
    us of the problem.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，两种类型的`Sequence`之间的差异并未在类型系统中反映出来，因此我们只能在运行时发现算法与输入之间的任何不兼容性。正如我们将在[第20章](ch20.html#performing-io-to-passing-data)中看到的那样，这种情况会被常见的使用`sequenceOf(...)`或`List.asSequence()`作为我们的测试数据的技术加剧；这些序列*确实*支持多次迭代，并且不会警告我们这个问题。
- en: In practice, this problem is usually only an irritation, causing some wasted
    time and reworking. It will tend not to happen if you are converting from streams
    code, because that will not have had the issue in the first place, but rather
    when applying a `Sequence` from scratch or converting from an `Iterable`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，这个问题通常只是一种烦恼，导致了一些浪费的时间和重新工作。如果你正在从流代码转换，那么这个问题通常不会出现，因为最初的流代码本身就没有这个问题，而是在从头开始应用`Sequence`或从`Iterable`转换时才会出现。
- en: 'In this particular case, we can make things work by keeping count of items
    as they whiz past in the first iteration, rather than counting again at the end:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种特定情况下，我们可以通过在第一次迭代时即时统计项目数量来解决问题，而不是在最后再次计数：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is the first problem that we have solved in this book with a mutable local
    variable! We can hide our shame inside a more generally useful utility class:
    `CountingSequence`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本书中我们用可变的局部变量解决的第一个问题！我们可以将我们的羞愧隐藏在一个更通用的实用工具类中：`CountingSequence`：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This a recurrent theme in Kotlin algorithms: we might occasionally need to
    stoop to mutation to implement something in a sensible or efficient way, but we
    can usually hide the mutation in a way that both reduces its visibility and makes
    for a useful abstraction. In this case, this is aided by the fact that `Sequence`
    is an interface with just one method, making it very easy to implement it ourselves.
    Java’s `Stream` is also an interface, but with 42 methods and no `AbstractStream`
    class to provide default implementations!'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Kotlin 算法中的一个反复出现的主题：我们偶尔可能需要通过变异来实现某些有意义或高效的东西，但我们通常可以隐藏变异，以减少其可见性并形成一个有用的抽象。在这种情况下，`Sequence`是一个仅有一个方法的接口，因此我们很容易自己实现它。Java
    的`Stream`也是一个接口，但它有42个方法，且没有`AbstractStream`类来提供默认实现！
- en: Before we leave this section, you may have been silently fuming ever since we
    introduced `Stream.count()`. If not, can you see what the issue is?
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们离开本节之前，自从我们介绍了`Stream.count()`以来，您可能一直在默默发怒。如果没有，您能看出问题是什么吗？
- en: One of the points of `Stream` and `Sequence` is that they allow us to work on
    arbitrarily large datasets, and finding the size of these datasets by counting
    them individually is not very efficient, even if it can sometimes be done. In
    general, even if we can, in practice, iterate over a `Sequence` more than once,
    it is likely to be inefficient in the use cases that caused us to use `Sequence`
    in the first place.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stream`和`Sequence`的一个优点是它们允许我们处理任意大的数据集，通过逐个计数来确定这些数据集的大小并不是很有效，即使有时可以这样做。总的来说，即使在实践中我们可以多次迭代`Sequence`，在最初使用`Sequence`的那些用例中，这样做可能是低效的。'
- en: Only Iterate Over a Sequence Once
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 只对序列进行一次迭代
- en: As a rule of thumb, if they operate on a `Sequence`, our algorithms should complete
    in a single pass. This way, they will be able to work with sequences that do not
    support multiple iteration and can be efficient with large numbers of items.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，如果它们操作的是一个`Sequence`，我们的算法应该在单次遍历内完成。这样，它们就能处理那些不支持多次迭代且能够高效处理大量项目的序列。
- en: We can use `Sequence.constrainOnce()` in our tests to make sure that we don’t
    accidentally go around again.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在测试中使用`Sequence.constrainOnce()`来确保我们不会意外再次遍历。
- en: Choosing Between Streams, Iterables, and Sequences
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择流、可迭代对象和序列之间的区别
- en: 'If we already have code using Java streams, it will continue to run just fine
    on the JVM, even when converted to Kotlin. It will even look a little nicer, since
    Kotlin can move the lambda outside the method and allow the use of the implicit
    `it` lambda parameter:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们已经有了使用 Java 流的代码，在 JVM 上转换为 Kotlin 后，它将继续正常运行。甚至看起来会更好看一些，因为 Kotlin 可以将
    lambda 移到方法外部，并允许使用隐式的`it` lambda 参数：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In addition, we can use extension functions to *add* operations to streams,
    in the same way as Kotlin defines its `Sequence` operations.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以使用扩展函数*添加*操作到流中，就像 Kotlin 定义其`Sequence`操作一样。
- en: If our code is working on large collections, and in particular using `parallelStream()`,
    then the default should be to leave the streams alone, because in these cases
    they are well optimized by the JVM. The Kotlin standard library even provides
    extensions `Stream<T>.asSequence()` and `Sequence<T>.asStream()` that allow us
    to swap horses mid, erm, `Stream`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的代码正在处理大型集合，特别是使用`parallelStream()`，那么默认情况应该是保持流不变，因为在这些情况下它们由 JVM 进行了优化。Kotlin
    标准库甚至提供了扩展`Stream<T>.asSequence()`和`Sequence<T>.asStream()`，允许我们在中途转换操作，嗯，`Stream`。
- en: If we decide to convert to a Kotlin abstraction, then we can choose `Iterable`
    or `Sequence`, depending on whether the streams code takes advantage of lazy evaluation.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们决定转换为 Kotlin 抽象，则可以根据流代码是否利用惰性评估来选择`Iterable`或`Sequence`。
- en: 'Lazy evaluation is required if:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要惰性评估：
- en: We need to produce results before we have finished reading the input.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要在完成读取输入之前产生结果。
- en: We need to process more data than we can fit into memory (including intermediate
    results).
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要处理比我们可以放入内存中的更多数据（包括中间结果）。
- en: 'Lazy evaluation may give better performance for:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 惰性评估可能会为以下情况提供更好的性能：
- en: Large collections with many pipeline stages, where building intermediate collections
    may be slow.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有许多管道阶段的大型集合，其中构建中间集合可能会很慢。
- en: Pipelines where early stages could be skipped, depending on information only
    available in later stages.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在早期阶段可能会被跳过的管道，取决于仅在后期阶段可用的信息。
- en: 'We can illustrate the last point with the same translation example we saw with
    streams:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用与流相同的翻译示例来说明最后一点：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can convert this to the equivalent iterable expression:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将此转换为等效的可迭代表达式：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'But then *all* words in the input `List` will be translated to another `List`
    by `map`, even those after `STOP`. Using a `Sequence` avoids translating words
    we aren’t going to return:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 但是然后*所有*输入`List`中的单词将通过`map`被翻译为另一个`List`，即使是在`STOP`之后的单词也是如此。使用`Sequence`可以避免翻译我们不打算返回的单词：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If we don’t need lazy evaluation, and for smaller collections, or when writing
    from scratch in Kotlin, `Iterable` pipelines are simple, generally quick, and
    easy to reason with. Your authors will often convert streams to iterables to take
    advantage of the far richer API that Kotlin provides. If iterables prove too slow
    (or sometimes too greedy for memory) with large collections, then we can convert
    to sequences. If that still isn’t enough, we can move (hopefully not back) to
    streams, and maybe even take advantage of parallelism.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不需要惰性评估，并且对于较小的集合或在 Kotlin 中从头开始编写时，`Iterable`管道简单、通常快速且易于理解。你的作者通常会将流转换为可迭代对象，以利用
    Kotlin 提供的更丰富的 API。如果可迭代对象在处理大型集合时过于慢（或者有时对内存过于贪婪），那么我们可以转换为序列。如果这还不够，我们可以转向（希望不要再转回）流，甚至利用并行处理。
- en: Algebraic Transformation
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代数变换
- en: 'Laziness and parallelism will of course affect *when* the stages of our pipeline
    are invoked. If any of our algorithm depends on the order of operations, it may
    be broken if we swap between streams, iterables, and sequences. What we want is
    code with a predictable *algebra*: a set of rules for manipulating operations
    while preserving behavior.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 惰性和并行当然会影响我们管道阶段何时被调用。如果我们的任何算法依赖于操作的顺序，如果我们在流、可迭代和序列之间切换，可能会导致破坏。我们想要的是具有可预测*代数*的代码：一组规则，用于操作操作同时保持行为。
- en: We saw in [Chapter 7](ch07.html#actions-to-calculations) that we can categorize
    functions (actually any code, including lambdas) according to whether they depend
    on when they are run. Calculations ([“Calculations”](ch07.html#calculations))
    are safe to refactor because we can move their invocations around without affecting
    their result or the result of any other code. In contrast, moving an action ([“Actions”](ch07.html#actions))
    from an iterable to a sequence, or vice versa, may change when it is invoked,
    and hence the outcome of our program. The more of our code that is expressed as
    calculations, the more we can treat its representation as something that we can
    transform according to rules.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第7章](ch07.html#actions-to-calculations)中看到，我们可以根据它们运行的时间依赖性对函数（实际上包括任何代码，包括lambda）进行分类。计算（[“Calculations”](ch07.html#calculations)）是安全重构的，因为我们可以移动它们的调用而不影响它们的结果或任何其他代码的结果。相反，将一个操作（[“Actions”](ch07.html#actions)）从可迭代对象移动到序列中，或者反之，可能会改变其调用时间，从而影响程序的结果。我们的代码中表达为计算的部分越多，我们就越能把它的表示视为可以根据规则转换的东西。
- en: 'We can also apply another algebra—arithmetic—to simplify our definition of
    `averageNonBlankLength`. This is currently:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以应用另一个代数——算术——来简化我们对`averageNonBlankLength`的定义。当前情况是：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'All that complication arises because we don’t want the simple average, but
    the average where blank strings are counted as if empty. Filtering the blanks
    from the sum, but not the count, is one way to do this. Mathematically, though,
    it is equivalent to the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些复杂性的原因是因为我们不想要简单的平均数，而是在空白字符串被视为空的情况下的平均数。从总和中过滤空白，但不过滤计数，是实现这一目标的一种方法。尽管从数学上来说，它等效于以下方式：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is a mathematical rearrangement, and, as with our code refactoring, works
    only if all the operations are calculations. It is also dangerously seductive,
    because we have slipped back to boxing our integers to pass them to `average`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种数学上的重新排列，并且与我们的代码重构一样，仅当所有操作都是计算时才有效。这也是非常具有诱惑力的，因为我们又滑回了将整数装箱以传递给`average`的地步。
- en: 'What we need is an `averageBy` analog of `sumBy`. We can do that by mating
    the Kotlin runtime definitions of `Sequence.sumBy` with `Sequence.average` to
    give:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个`sumBy`的平均数版本。我们可以通过将Kotlin运行时定义的`Sequence.sumBy`与`Sequence.average`相结合来实现这一点：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This again stoops to mutation in the name of efficiency, and finally allows
    us to write:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这又是出于效率考虑而妥协到变异，最终使我们能够编写：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Why did we not just write it that way in the first place? Well, sometimes we
    see these equivalences, sometimes we don’t! Remember that we started here:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么不一开始就这样写呢？嗯，有时我们看到这些等价，有时我们看不到！记住我们从这里开始：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Given this code, it is natural to translate the `if` statement to a `filter`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于这段代码，将`if`语句转换为`filter`是很自然的：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'What if our original code had been more functional? Rather than using an `if`
    statement to decide *whether* to add, it might have used a ternary expression
    to calculate *the amount* to add:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的原始代码更加函数式呢？而不是使用`if`语句来决定是否添加，它可能使用三元表达式来计算要添加的数量：
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Ah—then our initial translation would probably have been:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 啊，那么我们最初的翻译可能是：
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In that case, we would have had a shorter chapter but learned less.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在那种情况下，我们可能会有一个更短的章节，但学到的东西会更少。
- en: Refactoring from Streams to Iterables and Sequences
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从流到可迭代和序列的重构
- en: Travelator logs operational events as it runs, so we know that it is working
    as we expect. These are sent as JSON to an indexing server, which can generate
    pretty graphs and alerts specified with its own query language. Somehow, though,
    those nice people in marketing are always asking questions that we can’t write
    queries for.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Travelator在运行时记录操作事件，因此我们知道它正如我们所期望的那样工作。这些事件以JSON格式发送到一个索引服务器，该服务器可以使用其自己的查询语言生成漂亮的图形和警报。不过，市场部门的人总是问一些我们无法为之编写查询的问题。
- en: 'In these cases, we fetch events from the server and process them locally. The
    querying, marshaling, and paging of the events is hidden behind a simple `EventStore`
    interface that returns an `Iterator<Map<String, Object>>`, where `Map<String,
    Object>` represents JSON objects:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，我们从服务器获取事件并在本地处理它们。事件的查询、编组和分页隐藏在一个简单的`EventStore`接口背后，该接口返回一个`Iterator<Map<String,
    Object>>`，其中`Map<String, Object>`表示JSON对象：
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[Example 13.1 [streams-to-sequences.0:src/main/java/travelator/analytics/EventStore.java]](https://java-to-kotlin.dev/code.html?ref=13.1&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=13.1&show=diff)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 13.1 [streams-to-sequences.0:src/main/java/travelator/analytics/EventStore.java]](https://java-to-kotlin.dev/code.html?ref=13.1&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=13.1&show=diff)'
- en: The interface contains its own conversion of the `Iterator` to a `Stream` for
    our happy convenience. (Amazingly, no conversion function is built into the JDK.)
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接口包含了将`Iterator`转换为`Stream`的便利方法。（令人惊讶的是，JDK 中没有内置的转换函数。）
- en: 'Here is the sort of thing that we haven’t been able to write in the indexing
    server’s query language. It calculates the average number of interactions customers
    make to complete a booking successfully:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们无法用索引服务器的查询语言编写的一种情况。它计算了顾客成功完成预订所需的平均互动次数：
- en: '[PRE26]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[Example 13.2 [streams-to-sequences.0:src/main/java/travelator/analytics/MarketingAnalytics.java]](https://java-to-kotlin.dev/code.html?ref=13.2&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=13.2&show=diff)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 13.2 [streams-to-sequences.0:src/main/java/travelator/analytics/MarketingAnalytics.java]](https://java-to-kotlin.dev/code.html?ref=13.2&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=13.2&show=diff)'
- en: 'We did our best when we wrote this to make it understandable. We named intermediate
    variables, and specified their types when and only when it seemed to help, and
    formatted carefully—and it still looks like someone knocked the code onto the
    floor and tried to put it back together in the hope that we didn’t notice. We
    sometimes end up in a losing battle like this: we could extract a function to
    simplify code at the call site, but if we can’t give that function a good name,
    we have just kicked the can down the source file.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写这段代码时，我们尽力使其易于理解。我们为中间变量命名，并在似乎有帮助时指定它们的类型，并仔细格式化——但它看起来仍然像是有人把代码扔到地板上，然后试图把它重新拼凑起来，希望我们没有注意到。我们有时会陷入这样一场失败的战斗：我们可以提取一个函数以简化调用点的代码，但如果我们无法给出一个好的名称，我们只是把问题推到了源文件。
- en: Implicit or Explicit Types
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐式或显式类型
- en: Sometimes a variable’s type is essential to understanding how code works; other
    times it just clutters an already wordy block. In this respect, explicit types
    are like comments, but they have the added advantage of being checked and enforced
    by the compiler. As with comments, we should try to write code that doesn’t need
    explicit variable types. Good naming can help, as can refactoring into functions
    where the return type can be shown.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 有时变量的类型对于理解代码的工作方式至关重要；其他时候，它只会使已经冗长的代码块更加混乱。在这方面，显式类型就像注释一样，但它们具有编译器检查和强制执行的额外优势。与注释一样，我们应该尽量编写不需要显式变量类型的代码。良好的命名可以帮助，重构成可以显示返回类型的函数也可以帮助。
- en: If these fail though, there is no shame in showing a variables type if it improves
    the readability of the code, and we should certainly prefer to communicate in
    types rather than comments.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些方法失败了，那么在提高代码可读性的情况下展示变量的类型并没有什么可耻的，我们应该更愿意通过类型来交流，而不是通过注释。
- en: 'We’re going to convert this code to Kotlin in the fervent hope that our favorite
    language will allow us to do a better job. Here is the result of the automated
    conversion:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这段代码转换为 Kotlin，热切地希望我们最喜爱的语言能让我们做得更好。这是自动转换的结果：
- en: '[PRE27]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[Example 13.3 [streams-to-sequences.1:src/main/java/travelator/analytics/MarketingAnalytics.kt]](https://java-to-kotlin.dev/code.html?ref=13.3&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=13.3&show=diff)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 13.3 [streams-to-sequences.1:src/main/java/travelator/analytics/MarketingAnalytics.kt]](https://java-to-kotlin.dev/code.html?ref=13.3&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=13.3&show=diff)'
- en: 'At the time of writing, the Java to Kotlin converter is not as clever as it
    might be mapping between lambdas in the two languages. This is particularly noticeable
    in streams code, because that is where most Java lambdas are to be found. Most
    of the issues can be fixed with Alt-Enter on the odd code and accepting a quick
    fix. Let’s start by tidying up nullability, removing the vestigial `Function`,
    and simplifying that ugly `mapToInt` lambda:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Java 到 Kotlin 转换器在两种语言之间的 lambda 映射方面还不够聪明。这在流代码中尤为明显，因为那里是大多数 Java lambda
    的地方。大多数问题都可以通过在奇怪的代码上按下 Alt-Enter 并接受快速修复来解决。让我们从整理空值开始，移除剩余的`Function`，并简化那个丑陋的`mapToInt`
    lambda。
- en: '[PRE28]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[Example 13.4 [streams-to-sequences.2:src/main/java/travelator/analytics/MarketingAnalytics.kt]](https://java-to-kotlin.dev/code.html?ref=13.4&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=13.4&show=diff)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 13.4 [streams-to-sequences.2:src/main/java/travelator/analytics/MarketingAnalytics.kt]](https://java-to-kotlin.dev/code.html?ref=13.4&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=13.4&show=diff)'
- en: 'The Java code before conversion mixed some old-style explicitly typed variables:
    `Stream<Map<String, Object>>`, for example, with the implicit `var averageNumberOf​Event⁠sPerCompletedBooking`.
    The conversion has dropped the explicit types. It is certainly less intimidating
    this way, but also less comprehensible if we actually care how it is doing whatever
    it is doing. We’ll leave it this way for now but review our decision before we
    finish.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在转换之前的Java代码中，混合了一些旧式显式类型的变量，例如`Stream<Map<String, Object>>`，以及隐式的`var averageNumberOf​Event⁠sPerCompletedBooking`。转换已经删除了显式类型。这种方式确实少了些威胁感，但如果我们真的关心它是如何做到的，它也更难以理解。我们暂时保持这种状态，但在完成之前会重新审视我们的决定。
- en: At this point, we have Kotlin code using Java streams that runs just fine. We
    could leave it alone. Travelator is a huge success, with many thousands of completed
    bookings a day, and streams are a good choice for throughput, so why convert to
    Kotlin? You didn’t buy this book for that sort of attitude though, so we’ll push
    on under the pretense that we are measuring performance at every stage and will
    stop if we see it degrade significantly.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们有一个使用Java流运行良好的Kotlin代码。我们可以不做任何更改。Travelator非常成功，每天完成数千次预订，流对于吞吐量是一个很好的选择，那么为什么要转换为Kotlin呢？不过你不是为了这种态度而买这本书的，所以我们会在假装在每个阶段测量性能，并且如果看到性能显著降低，我们会停下来。
- en: Iterables First
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 首先是Iterable
- en: 'Looking at the code, we see that it has two stages. The first stage processes
    an input of indeterminate length, producing a collection in memory:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 查看代码时，我们可以看到它有两个阶段。第一个阶段处理一个长度不确定的输入，生成内存中的一个集合：
- en: '[PRE29]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[Example 13.5 [streams-to-sequences.2:src/main/java/travelator/analytics/MarketingAnalytics.kt]](https://java-to-kotlin.dev/code.html?ref=13.5&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=13.5&show=diff)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 13.5 [streams-to-sequences.2:src/main/java/travelator/analytics/MarketingAnalytics.kt]](https://java-to-kotlin.dev/code.html?ref=13.5&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=13.5&show=diff)'
- en: 'The second processes that collection:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个阶段处理该集合：
- en: '[PRE30]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[Example 13.6 [streams-to-sequences.2:src/main/java/travelator/analytics/MarketingAnalytics.kt]](https://java-to-kotlin.dev/code.html?ref=13.6&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=13.6&show=diff)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 13.6 [streams-to-sequences.2:src/main/java/travelator/analytics/MarketingAnalytics.kt]](https://java-to-kotlin.dev/code.html?ref=13.6&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=13.6&show=diff)'
- en: As we saw earlier, Java uses streams for both these cases, whereas in Kotlin
    we would tend to use a `Sequence` to process input of unknown length and an `Iterable`
    to process data in memory. Acting on in-memory data is easier to reason with,
    so we’ll convert `averageNumberOfEventsPerCompletedBooking` first.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，Java在这两种情况下都使用流，而在Kotlin中，我们倾向于使用`Sequence`来处理长度未知的输入，使用`Iterable`来处理内存中的数据。操作内存数据更容易理解，所以我们将首先转换`averageNumberOfEventsPerCompletedBooking`。
- en: Until IntelliJ comes up with automated refactoring, we are left having to do
    this by hand. Usually, we would have tests to make this safer, but this is fast-moving
    and arbitrary analytics code, so it turns out we cut corners. Before we begin
    refactoring proper, we write a quick test that talks to production and shows that
    the result for yesterday was 7.44; now we can keep running that to check that
    it doesn’t change.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在IntelliJ提出自动重构之前，我们只能手工操作。通常情况下，我们会有测试来使这个过程更安全，但这是快速变动和任意的分析代码，所以我们略有疏忽。在正式进行重构之前，我们编写了一个快速的测试，与生产环境交互，并显示昨天的结果为7.44；现在我们可以继续运行以检查它是否发生变化。
- en: 'We know that we can apply collection operations directly to `Map.values` in
    Kotlin (those on `Iterable`), so we can remove the `.stream()`; `average()` is
    an operation on `IntStream` in Java, but Kotlin conveniently declares `Iterable<Int>.average()`,
    so we don’t have to `mapToInt`, just `map`. Finally, where `IntStream.average()`
    returns an empty `OptionalDouble` if the stream has no elements, Kotlin’s `Iterable<Int>.average()`
    returns `NaN` (not a number), which means we can use the result directly:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们可以直接对`Map.values`应用集合操作，因此我们可以去除`.stream()`；在Java中，`average()`是`IntStream`的操作，但是Kotlin方便地声明了`Iterable<Int>.average()`，因此我们不需要`mapToInt`，只需`map`。最后，在Java中，如果流没有元素，`IntStream.average()`返回一个空的`OptionalDouble`，而Kotlin的`Iterable<Int>.average()`返回`NaN`（不是一个数字），这意味着我们可以直接使用结果：
- en: '[PRE31]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[Example 13.7 [streams-to-sequences.3:src/main/java/travelator/analytics/MarketingAnalytics.kt]](https://java-to-kotlin.dev/code.html?ref=13.7&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=13.7&show=diff)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 13.7 [streams-to-sequences.3:src/main/java/travelator/analytics/MarketingAnalytics.kt]](https://java-to-kotlin.dev/code.html?ref=13.7&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=13.7&show=diff)'
- en: Has this been a good change though?
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 不过这次改动是否好呢？
- en: Looking at the code, we are now creating an intermediate `List<Int>` on which
    to call `average()`. This will result in boxing each value, and this time there
    is no `averageBy()` (as there was `sumBy()` in the previous example) to prevent
    this.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 查看代码，我们现在创建了一个中间的 `List<Int>` 来调用 `average()`。这将导致每个值都要装箱，而这次没有 `averageBy()`（就像之前的例子中有
    `sumBy()` 一样）来阻止这种情况。
- en: 'Whether this code performs better or worse than the stream version will depend
    on the number of values in the `Map`, how our particular JVM optimizes boxing,
    and how heavily HotSpot has optimized this path; only measuring in real conditions
    will tell. If we have to choose a generic solution, we should probably write our
    own `Collection.averageBy`. That way we can leverage knowing the size of a `Collection`.
    We could use the one we prepared earlier in the chapter (albeit for `Sequence`)
    or refactor from here. We can refactor from here by extracting `values` and using
    `sumBy()`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的性能优劣将取决于 `Map` 中值的数量，我们特定的 JVM 如何优化装箱，以及 HotSpot 在这条路径上的优化程度；只有在真实条件下进行测量才能告诉我们。如果我们必须选择一个通用解决方案，我们可能应该编写自己的
    `Collection.averageBy`。这样我们可以利用了解 `Collection` 大小的优势。我们可以使用本章前面准备的（尽管是用于 `Sequence`
    的）那个，或者从这里重构。我们可以通过提取 `values` 并使用 `sumBy()` 从这里重构：
- en: '[PRE32]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[Example 13.8 [streams-to-sequences.4:src/main/java/travelator/analytics/MarketingAnalytics.kt]](https://java-to-kotlin.dev/code.html?ref=13.8&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=13.8&show=diff)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 13.8 [streams-to-sequences.4:src/main/java/travelator/analytics/MarketingAnalytics.kt]](https://java-to-kotlin.dev/code.html?ref=13.8&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=13.8&show=diff)'
- en: 'Now “Extract Function” `averageBy` on the returned expression:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在返回的表达式上“提取函数” `averageBy`：
- en: '[PRE33]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[Example 13.9 [streams-to-sequences.5:src/main/java/travelator/analytics/MarketingAnalytics.kt]](https://java-to-kotlin.dev/code.html?ref=13.9&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=13.9&show=diff)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 13.9 [streams-to-sequences.5:src/main/java/travelator/analytics/MarketingAnalytics.kt]](https://java-to-kotlin.dev/code.html?ref=13.9&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=13.9&show=diff)'
- en: '[PRE34]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[Example 13.10 [streams-to-sequences.5:src/main/java/travelator/analytics/MarketingAnalytics.kt]](https://java-to-kotlin.dev/code.html?ref=13.10&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=13.10&show=diff)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 13.10 [streams-to-sequences.5:src/main/java/travelator/analytics/MarketingAnalytics.kt]](https://java-to-kotlin.dev/code.html?ref=13.10&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=13.10&show=diff)'
- en: 'Eeek! It turns out that the type of `bookingEventsByInteractionId` was a lot
    more mutable than we wanted. It came from `Collectors.groupingBy`, a stream operation
    that only has Java collections to return after all. We’ll change it to use `Collection`
    in place of the `MutableCollection` for now, and then “Introduce Parameter” named
    `selector` on the lambda:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 噢唷！原来 `bookingEventsByInteractionId` 的类型比我们想要的要可变得多。它来自 `Collectors.groupingBy`，这是一个只返回
    Java 集合的流操作。我们将其更改为暂时使用 `Collection` 代替 `MutableCollection`，然后在 lambda 上“引入参数”命名为
    `selector`：
- en: '[PRE35]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[Example 13.11 [streams-to-sequences.6:src/main/java/travelator/analytics/MarketingAnalytics.kt]](https://java-to-kotlin.dev/code.html?ref=13.11&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=13.11&show=diff)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 13.11 [streams-to-sequences.6:src/main/java/travelator/analytics/MarketingAnalytics.kt]](https://java-to-kotlin.dev/code.html?ref=13.11&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=13.11&show=diff)'
- en: 'Now we don’t want to care about the actual type of items in the `Collection`.
    If we select the `MutableList<MutableMap<String, Any>>`, and “Extract/Introduce
    Type Parameter”, we get the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们不想关心 `Collection` 中项的实际类型。如果我们选择 `MutableList<MutableMap<String, Any>>`
    并且“提取/引入类型参数”，我们会得到以下结果：
- en: '[PRE36]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[Example 13.12 [streams-to-sequences.7:src/main/java/travelator/analytics/MarketingAnalytics.kt]](https://java-to-kotlin.dev/code.html?ref=13.12&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=13.12&show=diff)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 13.12 [streams-to-sequences.7:src/main/java/travelator/analytics/MarketingAnalytics.kt]](https://java-to-kotlin.dev/code.html?ref=13.12&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=13.12&show=diff)'
- en: 'That refactoring is clever enough that we don’t begrudge having to tell IntelliJ
    that `T` can be anything really (by removing the `MutableList<MutableMap<String,
    Any>>` type restriction):'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 那个重构是如此巧妙，以至于我们不介意告诉 IntelliJ，`T` 实际上可以是任何东西（通过移除 `MutableList<MutableMap<String,
    Any>>` 类型限制）：
- en: '[PRE37]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[Example 13.13 [streams-to-sequences.8:src/main/java/travelator/analytics/MarketingAnalytics.kt]](https://java-to-kotlin.dev/code.html?ref=13.13&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=13.13&show=diff)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 13.13 [流到序列.8:src/main/java/travelator/analytics/MarketingAnalytics.kt]](https://java-to-kotlin.dev/code.html?ref=13.13&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=13.13&show=diff)'
- en: 'IntelliJ also added the type to the call for some reason:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: IntelliJ 也由于某种原因在调用时添加了类型：
- en: '[PRE38]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[Example 13.14 [streams-to-sequences.7:src/main/java/travelator/analytics/MarketingAnalytics.kt]](https://java-to-kotlin.dev/code.html?ref=13.14&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=13.14&show=diff)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 13.14 [流到序列.7:src/main/java/travelator/analytics/MarketingAnalytics.kt]](https://java-to-kotlin.dev/code.html?ref=13.14&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=13.14&show=diff)'
- en: So we remove the `MutableList<MutableMap<String, Any>>` from there too.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 因此我们也从那里删除了 `MutableList<MutableMap<String, Any>>`。
- en: 'Finally, we can make `averageBy` the tiny single-expression inline extension
    function it was born to be (see Chapters [9](ch09.html#multi-to-single-expression-functions)
    and [10](ch10.html#functions-to-extension-functions)):'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以将 `averageBy` 变成它天生应该是的小型单表达式内联扩展函数（参见[第9章](ch09.html#multi-to-single-expression-functions)和[第10章](ch10.html#functions-to-extension-functions)）：
- en: '[PRE39]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[Example 13.15 [streams-to-sequences.9:src/main/java/travelator/analytics/MarketingAnalytics.kt]](https://java-to-kotlin.dev/code.html?ref=13.15&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=13.15&show=diff)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 13.15 [流到序列.9:src/main/java/travelator/analytics/MarketingAnalytics.kt]](https://java-to-kotlin.dev/code.html?ref=13.15&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=13.15&show=diff)'
- en: This version doesn’t box integers nor iterate more than once, so it is probably
    as efficient as we are going to get. But again, only measuring in our specific
    circumstances will tell for sure.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本不会装箱整数，也不会多次迭代，因此它可能是我们能够获得的最有效的版本。但是再次强调，只有在我们特定的情况下测量才能确定。
- en: Note that when we wrote `Sequence.averageNonBlankLength` earlier, we had to
    count the number of items. By defining `averageBy` as an extension on `Collection`
    rather than on `Iterable`, we can use the fact that we can ask the `size` of in-memory
    collections to avoid the tedious bookkeeping.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们之前编写 `Sequence.averageNonBlankLength` 时，我们必须计算项数。通过将 `averageBy` 定义为 `Collection`
    的扩展而不是 `Iterable` 的扩展，我们可以利用内存中集合的 `size` 来避免繁琐的记账工作。
- en: Then Sequences
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 然后是序列
- en: So far, we have converted the in-memory pipeline. Now we are left with the code
    that reads an unknown number of events from the `eventStore`. We will want to
    keep this code lazy.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经将内存中的管道转换为了 Kotlin。现在我们剩下的是从 `eventStore` 读取未知数量事件的代码。我们希望保持这段代码是惰性的。
- en: 'Returning to the entry point, we now have:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 回到入口点，我们现在有：
- en: '[PRE40]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[Example 13.16 [streams-to-sequences.9:src/main/java/travelator/analytics/MarketingAnalytics.kt]](https://java-to-kotlin.dev/code.html?ref=13.16&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=13.16&show=diff)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 13.16 [流到序列.9:src/main/java/travelator/analytics/MarketingAnalytics.kt]](https://java-to-kotlin.dev/code.html?ref=13.16&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=13.16&show=diff)'
- en: 'Now the variable `bookingEventsByInteractionId` is only really there to give
    a checkpoint in the algorithm: it names an intermediate in the hope that it aids
    understanding. Moving up the function, `eventsForSuccessfulBookings` is a `Stream`,
    so we can convert the `collect(groupingBy(...))` to Kotlin with `asSequence().groupBy
    {...}`; the lambda remains unchanged:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在变量 `bookingEventsByInteractionId` 只是在算法中提供了一个检查点：它命名了一个中间值，希望有助于理解。在函数中向上移动，`eventsForSuccessfulBookings`
    是一个 `Stream`，因此我们可以将 `collect(groupingBy(...))` 转换为 Kotlin 的 `asSequence().groupBy
    {...}`；lambda 保持不变：
- en: '[PRE41]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[Example 13.17 [streams-to-sequences.10:src/main/java/travelator/analytics/MarketingAnalytics.kt]](https://java-to-kotlin.dev/code.html?ref=13.17&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=13.17&show=diff)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 13.17 [流到序列.10:src/main/java/travelator/analytics/MarketingAnalytics.kt]](https://java-to-kotlin.dev/code.html?ref=13.17&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=13.17&show=diff)'
- en: Swapping out one method for another method (or extension function) with a similar
    name that takes a compatible lambda is a good sign that we are on the right track.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 用类似名称的另一种方法（或扩展函数）替换一种方法，它接受兼容的 lambda，这表明我们走在正确的轨道上。
- en: 'Now for that `flatMap`, used to fetch all the events for any interaction that
    had a completed booking:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来看那个 `flatMap`，用于获取任何完成预订的交互的所有事件：
- en: '[PRE42]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[Example 13.18 [streams-to-sequences.10:src/main/java/travelator/analytics/MarketingAnalytics.kt]](https://java-to-kotlin.dev/code.html?ref=13.18&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=13.18&show=diff)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 13.18 [streams-to-sequences.10:src/main/java/travelator/analytics/MarketingAnalytics.kt]](https://java-to-kotlin.dev/code.html?ref=13.18&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=13.18&show=diff)'
- en: 'This would also *probably just work™* if we had sequences rather than streams.
    Thankfully, we know how to convert from the `Stream` to a `Sequence`: it’s the
    `.asSequence()` extension provided by the Kotlin JDK interop. We need to apply
    it to both streams:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用的是序列而不是流，这也很可能*只是工作™*。幸运的是，我们知道如何从`Stream`转换为`Sequence`：这是由 Kotlin JDK
    互操作提供的`.asSequence()`扩展。我们需要将其应用于两个流：
- en: '[PRE43]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[Example 13.19 [streams-to-sequences.11:src/main/java/travelator/analytics/MarketingAnalytics.kt]](https://java-to-kotlin.dev/code.html?ref=13.19&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=13.19&show=diff)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 13.19 [streams-to-sequences.11:src/main/java/travelator/analytics/MarketingAnalytics.kt]](https://java-to-kotlin.dev/code.html?ref=13.19&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=13.19&show=diff)'
- en: 'Awesomely, this continues to compile and pass our (cursory) test! It compiles
    because, although we have changed the type of `eventsForSuccessfulBookings` from
    `Stream` to `Sequence`, we then call `eventsForSuccessfulBookings.asSequence()`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，这继续编译并通过了我们（粗略的）测试！这是因为，尽管我们已经将`eventsForSuccessfulBookings`的类型从`Stream`更改为`Sequence`，但我们随后调用了`eventsForSuccessfulBookings.asSequence()`：
- en: '[PRE44]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[Example 13.20 [streams-to-sequences.11:src/main/java/travelator/analytics/MarketingAnalytics.kt]](https://java-to-kotlin.dev/code.html?ref=13.20&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=13.20&show=diff)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 13.20 [streams-to-sequences.11:src/main/java/travelator/analytics/MarketingAnalytics.kt]](https://java-to-kotlin.dev/code.html?ref=13.20&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=13.20&show=diff)'
- en: 'This resolves to `Sequence.asSequence()`, which is a no-op. We can inline `asSequence`
    to prove it:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这解析为`Sequence.asSequence()`，这是一个无操作。我们可以内联`asSequence`来证明它：
- en: '[PRE45]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[Example 13.21 [streams-to-sequences.12:src/main/java/travelator/analytics/MarketingAnalytics.kt]](https://java-to-kotlin.dev/code.html?ref=13.21&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=13.21&show=diff)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 13.21 [streams-to-sequences.12:src/main/java/travelator/analytics/MarketingAnalytics.kt]](https://java-to-kotlin.dev/code.html?ref=13.21&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=13.21&show=diff)'
- en: 'Returning to `eventsForSuccessfulBookings`, we now have:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`eventsForSuccessfulBookings`，我们现在有：
- en: '[PRE46]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[Example 13.22 [streams-to-sequences.11:src/main/java/travelator/analytics/MarketingAnalytics.kt]](https://java-to-kotlin.dev/code.html?ref=13.22&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=13.22&show=diff)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 13.22 [streams-to-sequences.11:src/main/java/travelator/analytics/MarketingAnalytics.kt]](https://java-to-kotlin.dev/code.html?ref=13.22&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=13.22&show=diff)'
- en: 'What we really wanted was for `EventStore` to support `queryAsSequence`. We
    can do this without modifying it by introducing an extension function:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真正想要的是`EventStore`支持`queryAsSequence`。我们可以通过引入扩展函数来实现这一点，而无需修改它：
- en: '[PRE47]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[Example 13.23 [streams-to-sequences.12:src/main/java/travelator/analytics/MarketingAnalytics.kt]](https://java-to-kotlin.dev/code.html?ref=13.23&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=13.23&show=diff)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 13.23 [streams-to-sequences.12:src/main/java/travelator/analytics/MarketingAnalytics.kt]](https://java-to-kotlin.dev/code.html?ref=13.23&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=13.23&show=diff)'
- en: 'This allows us to remove the `asSequence` calls from the calling function:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们可以从调用函数中移除`asSequence`调用：
- en: '[PRE48]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[Example 13.24 [streams-to-sequences.12:src/main/java/travelator/analytics/MarketingAnalytics.kt]](https://java-to-kotlin.dev/code.html?ref=13.24&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=13.24&show=diff)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 13.24 [streams-to-sequences.12:src/main/java/travelator/analytics/MarketingAnalytics.kt]](https://java-to-kotlin.dev/code.html?ref=13.24&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=13.24&show=diff)'
- en: OK, time to review. We’ve converted our Java to Kotlin, and are using iterables
    to process the in-memory operations, and sequences (backed by streams in `EventStore`)
    to process the unbounded operations. We really can’t claim, though, that the structure
    of the algorithm has become much clearer. A little less noisy, yes, but hardly
    expressive.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，是时候进行审查了。我们已经将我们的 Java 转换为 Kotlin，并且正在使用可迭代对象来处理内存中的操作，并使用序列（由`EventStore`中的流支持）来处理无界操作。不过，我们真的不能声称算法的结构变得更清晰了。有点嘈杂减少了，是的，但很难表达。
- en: 'The function is currently divided into three parts, and if we’re honest, they
    are pretty arbitrary. Sometimes we can gain greater insight by inlining everything
    and seeing what we have, so let’s do that:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 函数目前分为三部分，如果我们诚实的话，它们是相当随意的。有时候，通过内联所有内容并查看我们拥有的东西，我们可以获得更深入的洞察，所以让我们这样做：
- en: '[PRE49]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[Example 13.25 [streams-to-sequences.13:src/main/java/travelator/analytics/MarketingAnalytics.kt]](https://java-to-kotlin.dev/code.html?ref=13.25&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=13.25&show=diff)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 13.25 [streams-to-sequences.13:src/main/java/travelator/analytics/MarketingAnalytics.kt]](https://java-to-kotlin.dev/code.html?ref=13.25&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=13.25&show=diff)'
- en: It looks like the part starting with `flatMap` and ending before `groupBy` might
    standalone. Let’s see how to extract part of a pipeline into its own function.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来从`flatMap`开始到`groupBy`之前的部分可能是独立的。让我们看看如何将管道的一部分提取为自己的函数。
- en: Extracting Part of a Pipeline
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提取管道的一部分
- en: 'First we select from the start of the pipeline to the last stage we want to
    include, so from `eventStore` up to but not including `.groupBy`. “Extract Function”,
    calling it (in this case) `allEventsInSameInteractions`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从管道的开头选择到我们想要包含的最后一个阶段，所以从`eventStore`到`.groupBy`之前。“提取函数”，称其为（在本例中）`allEventsInSameInteractions`：
- en: '[PRE50]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[Example 13.26 [streams-to-sequences.14:src/main/java/travelator/analytics/MarketingAnalytics.kt]](https://java-to-kotlin.dev/code.html?ref=13.26&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=13.26&show=diff)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 13.26 [streams-to-sequences.14:src/main/java/travelator/analytics/MarketingAnalytics.kt]](https://java-to-kotlin.dev/code.html?ref=13.26&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=13.26&show=diff)'
- en: 'Now we select the bits of the pipeline that we don’t want in the new function,
    so `e⁠v⁠e⁠n⁠t​S⁠t⁠o⁠r⁠e` to before `.flatMap`, and “Introduce Parameter”. Accept
    any name that IntelliJ chooses—it won’t live long:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们选择管道中不需要的部分，即`e⁠v⁠e⁠n⁠t​S⁠t⁠o⁠r⁠e`到`.flatMap`之前，并且“引入参数”。接受 IntelliJ 选择的任何名称——它不会存活很长时间：
- en: '[PRE51]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[Example 13.27 [streams-to-sequences.15:src/main/java/travelator/analytics/MarketingAnalytics.kt]](https://java-to-kotlin.dev/code.html?ref=13.27&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=13.27&show=diff)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 13.27 [streams-to-sequences.15:src/main/java/travelator/analytics/MarketingAnalytics.kt]](https://java-to-kotlin.dev/code.html?ref=13.27&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=13.27&show=diff)'
- en: 'That’s really ugly, but once we convert the `sequence` parameter of `allEventsInSame​In⁠teractions`
    to a receiver and reformat, we have:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 那真的很丑，但是一旦我们将`allEventsInSame​In⁠teractions`的`sequence`参数转换为接收者并重新格式化，我们有：
- en: '[PRE52]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[Example 13.28 [streams-to-sequences.16:src/main/java/travelator/analytics/MarketingAnalytics.kt]](https://java-to-kotlin.dev/code.html?ref=13.28&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=13.28&show=diff)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 13.28 [streams-to-sequences.16:src/main/java/travelator/analytics/MarketingAnalytics.kt]](https://java-to-kotlin.dev/code.html?ref=13.28&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=13.28&show=diff)'
- en: As we discussed in [Chapter 10](ch10.html#functions-to-extension-functions),
    extension functions really come into their own when we are chaining operations.
    In Java, we couldn’t extend the Streams API with `allEventsInSameInteractions()`,
    so we ended up breaking the chain, either by calling a function or by introducing
    an explaining variable.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第10章](ch10.html#functions-to-extension-functions)中讨论的，扩展函数在我们链式操作时真正展现了自己的价值。在Java中，我们无法通过`allEventsInSameInteractions()`扩展Streams
    API，因此我们最终通过调用函数或引入解释性变量来打破链条。
- en: Final Tidy
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最终整理
- en: 'This is still a little clunky, and we could probably make it more efficient
    by not creating lists in the grouping, but that will do. Oh, except for a wafer-thin
    type alias and extension property:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然有些笨拙，我们可能可以通过在分组时不创建列表来提高效率，但这样做就足够了。哦，除了一个薄如纸片的类型别名和扩展属性外：
- en: '[PRE53]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[Example 13.29 [streams-to-sequences.17:src/main/java/travelator/analytics/MarketingAnalytics.kt]](https://java-to-kotlin.dev/code.html?ref=13.29&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=13.29&show=diff)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 13.29 [streams-to-sequences.17:src/main/java/travelator/analytics/MarketingAnalytics.kt]](https://java-to-kotlin.dev/code.html?ref=13.29&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=13.29&show=diff)'
- en: 'This lets us concentrate on the hard stuff when we read the code:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们在阅读代码时可以集中精力处理困难的部分：
- en: '[PRE54]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[Example 13.30 [streams-to-sequences.17:src/main/java/travelator/analytics/MarketingAnalytics.kt]](https://java-to-kotlin.dev/code.html?ref=13.30&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=13.30&show=diff)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 13.30 [streams-to-sequences.17:src/main/java/travelator/analytics/MarketingAnalytics.kt]](https://java-to-kotlin.dev/code.html?ref=13.30&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=13.30&show=diff)'
- en: In passing, note that `allEventsInSameInteractions` is an example of an extension
    function as method that we discussed in [Chapter 10](ch10.html#functions-to-extension-functions).
    It has access to both `this` from `MarketingAnalytics` (to access `eventStore`)
    and `this` from `Sequence<Event>`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，注意`allEventsInSameInteractions`是我们在[第10章](ch10.html#functions-to-extension-functions)讨论过的一个扩展函数作为方法的示例。它可以访问`MarketingAnalytics`中的`this`（以访问`eventStore`）以及`Sequence<Event>`中的`this`。
- en: Moving On
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进入下一步
- en: We aren’t going to claim that the refactored Kotlin code in this example is
    beautiful, but we do think that it is a significant improvement on the original
    Java. Extension functions, Kotlin’s lambda syntax, and improved type inference
    combine to reduce a lot of the noise associated with Java streams. When we have
    in-memory collections, using iterables rather than streams can also be more efficient
    as well as cleaner.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并不打算声称这个示例中重构后的 Kotlin 代码很美观，但我们确实认为它在原始 Java 代码的基础上有了显著的改进。扩展函数、Kotlin 的
    lambda 语法以及改进的类型推断结合在一起，减少了与 Java 流相关的许多噪音。当我们使用内存中的集合时，使用迭代器而不是流可能更高效、更清晰。
