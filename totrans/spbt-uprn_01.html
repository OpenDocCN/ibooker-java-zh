<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" class="pagenumrestart" data-pdf-bookmark="Chapter 1. Spring Boot in a Nutshell"><div class="chapter" id="sbur-01">
<h1><span class="label">Chapter 1. </span>Spring Boot in a Nutshell</h1>


<p><a data-type="indexterm" data-primary="Kinesis" data-see="Amazon Kinesis" id="idm45693974029304"/><a data-type="indexterm" data-primary="Actuator" data-see="Spring Boot Actuator" id="idm45693974027928"/><a data-type="indexterm" data-primary="bearer tokens" data-see="JWT" id="idm45693974026984"/><a data-type="indexterm" data-primary="Bills of Materials" data-see="BOMs" id="idm45693974279224"/><a data-type="indexterm" data-primary="Command Line Interface" data-see="CLI" id="idm45693974278280"/><a data-type="indexterm" data-primary="communications" data-see="Spring MVC" id="idm45693974277336"/><a data-type="indexterm" data-primary="Cross Site Scripting" data-see="XSS" id="idm45693974276392"/><a data-type="indexterm" data-primary="Data Definition Language" data-see="DDL" id="idm45693974275448"/><a data-type="indexterm" data-primary="Data Manipulation Language" data-see="DML" id="idm45693974274488"/><a data-type="indexterm" data-primary="data storage and retrieval" data-see="Spring Data" id="idm45693974273528"/><a data-type="indexterm" data-primary="Initializr" data-see="Spring Initializr" id="idm45693974272568"/><a data-type="indexterm" data-primary="Integrated Development Environment" data-see="IDE" id="idm45693974271624"/><a data-type="indexterm" data-primary="Internet Engineering Task Force" data-see="IETF" id="idm45693974270664"/><a data-type="indexterm" data-primary="JavaScript Object Notation" data-see="JSON" id="idm45693974269704"/><a data-type="indexterm" data-primary="Java Virtual Machine" data-see="JVM" id="idm45693974268744"/><a data-type="indexterm" data-primary="JSON Web Token" data-see="JWT" id="idm45693974267800"/><a data-type="indexterm" data-primary="Kafka" data-see="Apache Kafka" id="idm45693974266856"/><a data-type="indexterm" data-primary="Maven" data-see="Apache Maven" id="idm45693974265912"/><a data-type="indexterm" data-primary="Model-View-Controller" data-see="Spring MVC" id="idm45693974264968"/><a data-type="indexterm" data-primary="Multi-Factor Authentication" data-see="MFA" id="idm45693974264024"/><a data-type="indexterm" data-primary="NetBeans" data-see="Apache NetBeans" id="idm45693974263064"/><a data-type="indexterm" data-primary="Reactor" data-see="Project Reactor" id="idm45693974262120"/><a data-type="indexterm" data-primary="RocketMQ" data-see="Apache RocketMQ" id="idm45693974261176"/><a data-type="indexterm" data-primary="RS" data-see="Reactive Streams" id="idm45693974260232"/><a data-type="indexterm" data-primary="security" data-see="Spring Security" id="idm45693974259288"/><a data-type="indexterm" data-primary="Spring Expression Language" data-see="SpEL" id="idm45693974258344"/><a data-type="indexterm" data-primary="SQL" data-see="MySQL" id="idm45693974257384"/><a data-type="indexterm" data-primary="view technologies" data-see="Spring MVC" id="idm45693974256440"/><a data-type="indexterm" data-primary="WebFlux" data-see="Spring WebFlux" id="idm45693974255496"/><a data-type="indexterm" data-primary="World Wide Web Consortium" data-see="W3C" id="idm45693974254552"/>This chapter explores the three core features of Spring Boot and how they are force multipliers for you as a developer.</p>






<section data-type="sect1" data-pdf-bookmark="Spring Boot’s Three Foundational Features"><div class="sect1" id="idm45693974028904">
<h1>Spring Boot’s Three Foundational Features</h1>

<p><a data-type="indexterm" data-primary="Spring Boot" data-secondary="features" id="ix_Spring_Boot_feature"/>The three core features of Spring Boot upon which everything else builds are simplified dependency management, simplified deployment, and autoconfiguration.</p>








<section data-type="sect2" data-pdf-bookmark="Starters for Simplified Dependency Management"><div class="sect2" id="idm45693974250504">
<h2>Starters for Simplified Dependency Management</h2>

<p><a data-type="indexterm" data-primary="dependency management" data-secondary="simplified" id="ix_depend_man_simpl"/>One of the genius aspects of Spring Boot is that it makes dependency management…manageable.</p>

<p>If you’ve been developing software of any import for any length of time, you’ve almost certainly had to contend with several headaches surrounding dependency management. Any capability you provide in your application typically requires a number of “frontline” dependencies. For example, if you want to provide a RESTful web API, you must provide a way to expose endpoints over HTTP, listen for requests, tie those endpoints to methods/functions that will process those requests, and then build and return appropriate responses.</p>

<p>Almost invariably, each primary dependency incorporates numerous other secondary dependencies in order to fulfill its promised functionality. Continuing with our example of providing a RESTful API, we might expect to see a collection of dependencies (in some sensible but debatable structure) that includes code to supply responses in a particular format, e.g., JSON, XML, HTML; code to marshal/unmarshal objects to requested format(s); code to listen for and process requests and return responses to same; code to decode complex URIs used to create versatile APIs; code to support various wire protocols; and more.</p>

<p>Even for this fairly simple example, we’re already likely to require a large number of dependencies in our build file. And we haven’t even considered what functionality we may wish to include in our application at this point, only its outward interactions.</p>

<p>Now, let’s talk versions. Of each and every one of those dependencies.</p>

<p>Using libraries together requires a certain degree of rigor, as one version of a particular dependency may have been tested (or even function correctly) only with a specific version of another dependency. When these issues inevitably arise, it leads to what I refer to as “Dependency Whack-a-Mole.”</p>

<p>Like its namesake carnival game, Dependency Whack-a-Mole can be a frustrating experience. Unlike its namesake, when it comes to chasing down and bashing bugs stemming from mismatches that pop up between dependencies, there are no prizes, only elusive conclusive diagnoses and <em>hours</em> wasted pursuing them.</p>

<p>Enter Spring Boot and its starters. <a data-type="indexterm" data-primary="BOMs (Bills of Materials)" id="idm45693974242104"/>Spring Boot starters are Bills of Materials (BOMs) built around the proven premise that the vast majority of times you provide a particular capability, you do it in nearly the same way, nearly every time.</p>

<p>In the previous example, each time we build an API, we expose endpoints, listen for requests, process requests, convert to and from objects, exchange information in 1+ standard formats, send and receive data over the wire using a particular protocol, and more. This design/development/usage pattern doesn’t vary much; it’s an approach adopted industry-wide, with few variations. And like other similar patterns, it’s handily captured in a Spring Boot starter.</p>

<p>Adding a single starter, e.g., <code>spring-boot-starter-web</code>, provides all of those related functionalities in a <em>single application dependency</em>. All dependencies encompassed by that single starter are version-synchronized too, meaning that they’ve been tested successfully together and the included version of library A is proven to function properly with the included version of library B…and C…and D…etc. This dramatically simplifies your dependency list and your life, as it practically eliminates any chance you’ll have difficult-to-identify version conflicts among dependencies you need to provide your application’s critical capabilities.</p>

<p>In those rare cases when you must incorporate functionality provided by a different version of an included dependency, you can simply override the tested version.</p>
<div data-type="caution"><h6>Caution</h6>
<p>If you must override the default version of a dependency, do so…but you should probably increase your level of testing to mitigate risks you introduce by doing so.</p>
</div>

<p>You can also exclude dependencies if they are unnecessary for your application, but the same cautionary note applies.</p>

<p>All in all, Spring Boot’s concept of starters greatly streamlines your dependencies and reduces the work required to add whole sets of capabilities to your applications. It also dramatically diminishes the overhead you incur testing, maintaining, and upgrading them.<a data-type="indexterm" data-primary="" data-startref="ix_depend_man_simpl" id="idm45693973999912"/></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Executable JARs for Simplified Deployment"><div class="sect2" id="idm45693974249912">
<h2>Executable JARs for Simplified Deployment</h2>

<p><a data-type="indexterm" data-primary="JAR files" id="ix_JAR_files"/><a data-type="indexterm" data-primary="Java" data-secondary="executable JARs" id="ix_Java_exec_JARs"/><a data-type="indexterm" data-primary="executable JAR files" id="ix_exec_JAR"/>Long ago, in the days when application servers roamed the earth, deployments of Java applications were a complex affair.</p>

<p>In order to field a working application with, say, database access—like many microservices today and nearly all monoliths then and now—you would need to do the following:</p>
<ol>
<li>
<p>Install and configure the Application Server.</p>
</li>
<li>
<p>Install database drivers.</p>
</li>
<li>
<p>Create a database connection.</p>
</li>
<li>
<p>Create a connection pool.</p>
</li>
<li>
<p>Build and test your application.</p>
</li>
<li>
<p>Deploy your application and its (usually numerous) dependencies to the Application Server.</p>
</li>

</ol>

<p>Note that this list assumes you had administrators to configure the machine/virtual machine and that at some point you had created the database independently of this process.</p>

<p>Spring Boot turned much of this cumbersome deployment process on its head and collapsed the previous steps into one, or perhaps two, if you count copying or <code>cf push</code>-ing a single file to a destination as an actual <em>step</em>.</p>

<p>Spring Boot wasn’t the origin of the so-called über JAR, but it revolutionized it. Rather than teasing out every file from the application JAR and all dependent JARs, then combining them into a single destination JAR—sometimes referred to as 
<span class="keep-together"><em>shading</em></span>—the designers of Spring Boot approached things from a truly novel perspective: what if we could <em>nest JARs</em>, retaining their intended and delivered format?</p>

<p>Nesting JARs instead of shading them alleviates <em>many</em> potential problems, as there are no potential version conflicts to be encountered when dependency JAR A and dependency JAR B each use a different version of C; it also removes potential legal issues due to repackaging software and combining it with other software using a different license. Keeping all dependent JARs in their original format cleanly avoids those and other issues.</p>

<p>It is also trivial to extract the contents of a Spring Boot executable JAR, should you wish to do that. There are some good reasons for doing so in some circumstances, and I’ll discuss those in this book as well. For now, just know that the Spring Boot executable JAR has you covered.</p>

<p>That single Spring Boot JAR with all dependencies makes deployment a breeze. Rather than collecting and verifying all dependencies are deployed, the Spring Boot plug-in ensures they’re all zipped into the output JAR. <a data-type="indexterm" data-primary="JVM (Java Virtual Machine)" data-secondary="executable JARs" id="idm45693973980472"/>Once you have that, the application can be run anywhere there is a Java Virtual Machine (JVM) just by executing a command like <code>java -jar &lt;SpringBootAppName.jar&gt;</code>.</p>

<p>There’s more.</p>

<p>By setting a single property in your build file, the Spring Boot build plug-in can also make that single JAR entirely (self) executable. Still assuming a JVM is present, rather than having to type or script that entire bothersome line of <code>java -jar &lt;SpringBootAppName.jar&gt;</code>, you could simply type <code>&lt;SpringBootAppName.jar&gt;</code> (replacing with your filename, of course), and Bob’s your uncle—you’re up and running. It doesn’t get any easier than that.<a data-type="indexterm" data-primary="" data-startref="ix_exec_JAR" id="idm45693973976664"/><a data-type="indexterm" data-primary="" data-startref="ix_JAR_files" id="idm45693973975688"/><a data-type="indexterm" data-primary="" data-startref="ix_Java_exec_JARs" id="idm45693973974744"/></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Autoconfiguration"><div class="sect2" id="idm45693973998344">
<h2>Autoconfiguration</h2>

<p><a data-type="indexterm" data-primary="configuration" data-secondary="autoconfiguration" id="ix_config_auto"/><a data-type="indexterm" data-primary="autoconfiguration" id="ix_auto_config"/>Sometimes called “magic” by those new to Spring Boot, autoconfiguration is perhaps the greatest “force multiplier” that Spring Boot brings to developers. I often refer to it as a developer’s superpower: Spring Boot gives you <em>insane productivity</em> by bringing opinions to widely used and -repeated use cases.</p>

<p>Opinions in software? How does that help?!?</p>

<p>If you’ve been a developer for very long at all, you’ll doubtless have noticed that some patterns repeat themselves frequently. Not perfectly, of course, but in the high percentages; perhaps 80–90% of the time things fall within a certain range of design, development, or activity.</p>

<p>I alluded earlier to this repetition within software, as this is what makes Spring Boot’s starters amazingly consistent and useful. The repetition also means that these activities, when it comes to the code that must be written to complete a particular task, are ripe for streamlining.</p>

<p>To borrow an example from Spring Data, a Spring Boot–related and –enabled project, we know that every time we need to access a database, we need to open some manner of connection to that database. We also know that when our application completes its tasks, that connection must be closed to avoid potential issues. In between, we are likely to make numerous requests to the database using queries—simple and complex, read-only and write-enabled—and those queries will require some effort to create properly.</p>

<p>Now imagine we could streamline all of that. Automatically open a connection when we specify the database. Automatically close the connection when the application terminates. Follow a simple and expected convention to create queries <em>automatically</em> with minimal effort from you, the developer. Enable easy customization of even that minimal code, again by simple convention, to create complex bespoke queries that are reliably consistent and efficient.</p>

<p>This approach to code is sometimes referred to as <em>convention over configuration</em>, and if you’re new to a particular convention, it can appear mildly jarring (no pun intended) at first glance. But if you’ve implemented similar features before, writing often hundreds of repetitive, mind-numbing lines of setup/teardown/configuration code to accomplish even the simplest of tasks, it’s like a gust of fresh air. Spring Boot (and most Spring projects) follow the <em>convention over configuration</em> mantra, providing the assurance that if you follow simple, well-established and -documented conventions to do something, the configuration code you must write is minimal, or none at all.</p>

<p>Another way in which autoconfiguration gives you superpowers is the Spring team’s laserlike focus on “developer-first” environment configuration. As developers, we are most productive when we can focus on the task at hand and not a million setup chores. How does Spring Boot make that happen?</p>

<p><a data-type="indexterm" data-primary="SCSt (Spring Cloud Stream)" id="idm45693973962184"/>Let’s borrow an example from another Spring Boot–related project, Spring Cloud Stream: when connecting to a messaging platform like RabbitMQ or Apache Kafka, a developer typically must specify certain settings for said messaging platform in order to connect to and use it—hostname, port, credentials, and more. Focusing on the development experience means that defaults are provided when none are specified that <em>favor the developer working locally</em>: localhost, default port, etc. This makes sense as an <em>opinion</em> because it’s nearly 100% consistent for development environments, while it isn’t so in production. In prod, you would need to provide specific values due to widely varying platform and hosting environments.</p>

<p>Shared development projects using those defaults also eliminate a great deal of time required for developer environment setup. Win for you, win for your team.</p>

<p>There are occasions when your specific use cases don’t exactly match the 80–90% of use cases that are typical, when you fall into the other 10–20% of valid use cases. In those instances, autoconfiguration can be selectively overridden, or even disabled entirely, but you lose all of your superpowers then, of course. Overriding certain opinions is typically a matter of setting one or more properties as you wish them to be or providing one or more beans to accomplish something that Spring Boot would normally autoconfigure on your behalf. In other words, this is often a very simple matter to accomplish on those rare occasions when you must do so. In the end, autoconfiguration is a powerful tool that silently and tirelessly works on your behalf to make your life easier and you insanely productive.<a data-type="indexterm" data-primary="" data-startref="ix_Spring_Boot_feature" id="idm45693973957960"/><a data-type="indexterm" data-primary="" data-startref="ix_auto_config" id="idm45693973956984"/><a data-type="indexterm" data-primary="" data-startref="ix_config_auto" id="idm45693973956040"/></p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Summary"><div class="sect1" id="idm45693973973208">
<h1>Summary</h1>

<p>The three core features of Spring Boot upon which everything else builds are simplified dependency management, simplified deployment, and autoconfiguration. All three are customizable, but you’ll seldom need to do so. And all three work hard to make you a better, more productive developer. Spring Boot gives you wings!</p>

<p>In the next chapter, we’ll take a look at some of the great options you have when getting started creating Spring Boot applications. Choices are good!</p>
</div></section>







</div></section></div></body></html>