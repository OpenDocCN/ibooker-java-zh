<html><head></head><body><section data-pdf-bookmark="Chapter 2. Java to Kotlin Projects" data-type="chapter" epub:type="chapter"><div class="chapter" id="java-to-kotlin-projects">&#13;
<h1><span class="label">Chapter 2. </span>Java to Kotlin Projects</h1>&#13;
&#13;
<blockquote data-type="epigraph" epub:type="epigraph">&#13;
<p class="lrgquote">What is the first step of the journey from pure Java to a mixed and then increasingly Kotlin codebase?</p>&#13;
</blockquote>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Strategy" data-type="sect1"><div class="sect1" id="idm46393419433864">&#13;
<h1>Strategy</h1>&#13;
&#13;
<p>The<a data-primary="Java Way to Kotlin Way" data-secondary="strategy behind Java to Kotlin projects" data-type="indexterm" id="idm46393419432136"/> first time we, Nat and Duncan, introduced Kotlin to a Java codebase, we were members of a small team that included six developers, building a relatively greenfield project.&#13;
We had already deployed some web applications with Kotlin, but our enterprise architects insisted that we write the new system in Java 8.&#13;
This was shortly after Kotlin 1.0 had been released, but before Google announced that Kotlin was an official language for Android, so the architects were understandably wary about committing to a language with an uncertain future for a strategic system that they expected to be around for decades.</p>&#13;
&#13;
<p>In Java, we leaned toward a functional approach, designing the core application domain model as immutable data types transformed by pipelines.&#13;
However, we kept bumping into Java’s limitations: the verbosity required to implement immutable value types, the distinction between primitive and reference types, null references, and Streams lacking common higher-order functions.&#13;
Meanwhile, we could see Kotlin being adopted at an ever-increasing rate across the industry and even within the company.&#13;
When we saw Google’s announcement, we decided to start converting our Java to Kotlin.</p>&#13;
&#13;
<p>Our judgment was that starting in the core domain model would give us the biggest bang for our buck.&#13;
Kotlin’s data classes shrank the code significantly, in some cases replacing hundreds of lines of code with a single declaration.&#13;
We started carefully, using IntelliJ to convert a small value class that had no dependencies on other classes beyond those in the standard library, and examined how that affected the rest of our Java codebase.&#13;
It had no effect at all!&#13;
Emboldened by this success, we picked up the pace.&#13;
Whenever a new feature needed changes to a Java domain model class, we would first convert it to a Kotlin data class, commit the conversion, and then implement the feature.</p>&#13;
&#13;
<p>As more of the domain model logic became pure Kotlin, we were able to make better use of Kotlin features.&#13;
For example, we replaced calls to the Stream API with Kotlin’s standard functions on collections and sequences.&#13;
The biggest improvement though, was replacing our use of Java’s Optional type with nullable references.&#13;
This simplified our code and gave us greater confidence in its null safety.</p>&#13;
&#13;
<p>Another project in the company adopted Kotlin for a different reason.&#13;
They had a mature Java system that was built on a dependency injection framework.&#13;
The developers found that the framework’s use of reflection and annotations made the code difficult to understand and navigate in the IDE.&#13;
Kotlin’s lightweight syntax for closures offered a way to define the structure of their application and distinguish between object graphs instantiated for the whole application, for each HTTP request, or for each database transaction.&#13;
They gradually refactored the underpinnings of their system from a framework that obscured the architecture to a style that composed functions and made the architecture visible in the code.&#13;
This work became the <a href="https://http4k.org">http4k</a> web programming toolkit.</p>&#13;
&#13;
<p>As these two examples show, your choice of starting point should depend on a number of factors, including why your team is adopting Kotlin, how large the codebase is, and how frequently it changes.&#13;
You know your project and can decide what is most important to change.</p>&#13;
&#13;
<p>If you are choosing Kotlin for its language features, it makes sense to convert the classes you are working in most frequently, as we did in our first project.&#13;
If you are choosing Kotlin to use a specific library, then it makes sense to start writing Kotlin against the API, annotate it to make your Kotlin code convenient to the Java code in the rest of the app, and continue from there.</p>&#13;
&#13;
<p>In a small team it’s easy to establish the Kotlin coding style for your system (beyond the standard style guide), for instance, error handling conventions, how code is to be organized into files, what should be a top-level declaration and what should be in an object, and so on.</p>&#13;
&#13;
<p>Above a certain size, you run the risk of Kotlin code becoming inconsistent as people establish their own conventions in different parts of the system.&#13;
So it may be worth starting with a small subteam working in one area of the system, who establish conventions and build up a body of example code.&#13;
Once there are some established conventions, you can expand the effort to the rest of the team and other parts of the system.</p>&#13;
&#13;
<p class="pagebreak-before">In the rest of this book, we will examine in detail how to progress, how to keep your Java code maintainable while you are introducing Kotlin that it depends upon, and how to take advantage of Kotlin’s features to simplify the code further after IntelliJ has performed its conversion magic.&#13;
But all that follows the first small step.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Adding Kotlin Support to a Java Build" data-type="sect1"><div class="sect1" id="idm46393419433304">&#13;
<h1>Adding Kotlin Support to a Java Build</h1>&#13;
&#13;
<p>If<a data-primary="Java Way to Kotlin Way" data-secondary="adding Kotlin support to Java builds" data-type="indexterm" id="JWKWsupport02"/><a data-primary="Gradle build configuration" data-type="indexterm" id="gradle02"/> we want to refactor our Java to Kotlin, the first change we must make is to give ourselves the ability to write Kotlin code in our codebase.&#13;
Happily, the Kotlin build tools and IDE make this very straightforward.&#13;
It takes a few additional lines in our Gradle build configuration for it to compile Kotlin as well as Java.&#13;
IntelliJ<a data-primary="IntelliJ IDE" data-secondary="adding Kotlin support to Java builds" data-type="indexterm" id="idm46393419416824"/> will pick up that configuration when we resync the build file, allowing us to navigate, autocomplete, and refactor across both languages almost seamlessly.</p>&#13;
&#13;
<p>To add Kotlin to our Gradle build, we need to add the Kotlin plug-in.&#13;
There is a different plug-in for each target that Kotlin supports (JVM, JavaScript, and native code), and a plug-in for building multiplatform projects.&#13;
Because we have a Java project, we can ignore other platforms and use the Kotlin JVM plug-in.</p>&#13;
&#13;
<p>We also need to add the Kotlin standard library to our dependencies and specify the minimum JVM version that the output bytecode will support.&#13;
Our project targets JDK 11 (the latest LTS at the time of writing).&#13;
At the time of writing, the Kotlin compiler can generate bytecode compatible with JDK 1.6 or JDK 1.8. JDK 1.8 bytecode is more efficient and runs fine on JDK 11, so we will pick that.</p>&#13;
<div data-type="warning" epub:type="warning"><h1>Kotlin Versions</h1>&#13;
<p>The<a data-primary="Kotlin" data-secondary="versions" data-type="indexterm" id="idm46393419412712"/> Kotlin language and standard library are still maturing, but JetBrains policy is to provide a clear migration path.&#13;
The current version of Kotlin was 1.3 when we started writing this book.&#13;
As we finish it, 1.5 has just been released, deprecating some standard APIs used in our code examples!&#13;
We have chosen not to migrate to their replacements, so that the code is able to run on Kotlin 1.4 and 1.5.</p>&#13;
</div>&#13;
&#13;
<p>Here are the relevant parts of our <code>build.gradle</code> before the changes:</p>&#13;
&#13;
<pre data-code-language="groovy" data-type="programlisting"><code class="n">plugins</code> <code class="o">{</code>&#13;
    <code class="n">id</code><code class="o">(</code><code class="s2">"java"</code><code class="o">)</code>&#13;
<code class="o">}</code>&#13;
&#13;
<code class="n">java</code><code class="o">.</code><code class="na">sourceCompatibility</code> <code class="o">=</code> <code class="n">JavaVersion</code><code class="o">.</code><code class="na">VERSION_11</code>&#13;
<code class="n">java</code><code class="o">.</code><code class="na">targetCompatibility</code> <code class="o">=</code> <code class="n">JavaVersion</code><code class="o">.</code><code class="na">VERSION_11</code>&#13;
<code class="o">...</code> <code class="n">and</code> <code class="n">other</code> <code class="n">project</code> <code class="n">settings</code> <code class="o">...</code>&#13;
&#13;
<code class="n">dependencies</code> <code class="o">{</code>&#13;
    <code class="n">implementation</code> <code class="s2">"com.fasterxml.jackson.core:jackson-databind:2.10.0"</code>&#13;
    <code class="n">implementation</code> <code class="s2">"com.fasterxml.jackson.datatype:jackson-datatype-jsr310:2.10.0"</code>&#13;
    <code class="n">implementation</code> <code class="s2">"com.fasterxml.jackson.datatype:jackson-datatype-jdk8:2.10.0"</code>&#13;
    <code class="o">...</code> <code class="n">and</code> <code class="n">the</code> <code class="n">rest</code> <code class="n">of</code> <code class="n">our</code> <code class="n">app</code><code class="s1">'s implementation dependencies</code>&#13;
&#13;
<code class="s1">    testImplementation "org.junit.jupiter:junit-jupiter-api:5.4.2"</code>&#13;
<code class="s1">    testImplementation "org.junit.jupiter:junit-jupiter-params:5.4.2"</code>&#13;
<code class="s1">    testRuntimeOnly "org.junit.jupiter:junit-jupiter-engine:5.5.2"</code>&#13;
<code class="s1">    testRuntimeOnly "org.junit.platform:junit-platform-launcher:1.4.2"</code>&#13;
<code class="s1">    ... and the rest of our app'</code><code class="n">s</code> <code class="n">test</code> <code class="n">dependencies</code>&#13;
<code class="o">}</code>&#13;
&#13;
<code class="o">...</code> <code class="n">and</code> <code class="n">the</code> <code class="n">rest</code> <code class="n">of</code> <code class="n">our</code> <code class="n">build</code> <code class="n">rules</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=2.1&amp;show=file">Example 2.1 [projects.0:build.gradle]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=2.1&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>After we have added the Kotlin plug-in, our build file looks like this:</p>&#13;
&#13;
<pre data-code-language="groovy" data-type="programlisting"><code class="n">plugins</code> <code class="o">{</code>&#13;
    <code class="n">id</code> <code class="s1">'org.jetbrains.kotlin.jvm'</code> <code class="n">version</code> <code class="s2">"1.5.0"</code>&#13;
<code class="o">}</code>&#13;
&#13;
<code class="n">java</code><code class="o">.</code><code class="na">sourceCompatibility</code> <code class="o">=</code> <code class="n">JavaVersion</code><code class="o">.</code><code class="na">VERSION_11</code>&#13;
<code class="n">java</code><code class="o">.</code><code class="na">targetCompatibility</code> <code class="o">=</code> <code class="n">JavaVersion</code><code class="o">.</code><code class="na">VERSION_11</code>&#13;
<code class="o">...</code> <code class="n">and</code> <code class="n">other</code> <code class="n">project</code> <code class="n">settings</code> <code class="o">...</code>&#13;
&#13;
<code class="n">dependencies</code> <code class="o">{</code>&#13;
    <code class="n">implementation</code> <code class="s2">"org.jetbrains.kotlin:kotlin-stdlib-jdk8"</code>&#13;
    <code class="o">...</code> <code class="n">and</code> <code class="n">the</code> <code class="n">rest</code> <code class="n">of</code> <code class="n">our</code> <code class="n">app</code><code class="err">'</code><code class="n">s</code> <code class="n">dependencies</code>&#13;
<code class="o">}</code>&#13;
&#13;
<code class="n">tasks</code><code class="o">.</code><code class="na">withType</code><code class="o">(</code><code class="n">org</code><code class="o">.</code><code class="na">jetbrains</code><code class="o">.</code><code class="na">kotlin</code><code class="o">.</code><code class="na">gradle</code><code class="o">.</code><code class="na">tasks</code><code class="o">.</code><code class="na">KotlinCompile</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="n">kotlinOptions</code> <code class="o">{</code>&#13;
        <code class="n">jvmTarget</code> <code class="o">=</code> <code class="s2">"11"</code>&#13;
        <code class="n">javaParameters</code> <code class="o">=</code> <code class="kc">true</code>&#13;
        <code class="n">freeCompilerArgs</code> <code class="o">=</code> <code class="o">[</code><code class="s2">"-Xjvm-default=all"</code><code class="o">]</code>&#13;
    <code class="o">}</code>&#13;
<code class="o">}</code>&#13;
&#13;
<code class="o">...</code> <code class="n">and</code> <code class="n">the</code> <code class="n">rest</code> <code class="n">of</code> <code class="n">our</code> <code class="n">build</code> <code class="n">rules</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=2.2&amp;show=file">Example 2.2 [projects.1:build.gradle]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=2.2&amp;show=diff">(diff)</a>&#13;
</div>&#13;
&#13;
<p>Given those changes, we can rerun our build, and see that…</p>&#13;
&#13;
<p>…the build still works!</p>&#13;
&#13;
<p>If we resync the Gradle project in IntelliJ (this may happen automatically on saving), we can run our tests and programs within the IDE.</p>&#13;
&#13;
<p>Our tests still pass, so we haven’t broken anything, but neither have we proved that we can use Kotlin in our project.&#13;
Let’s test that by writing a “hello world” program.&#13;
We create a file, <em>HelloWorld.kt</em>, in the root package of our Java source tree, <em>src/main/java</em>:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">main</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="n">println</code><code class="p">(</code><code class="s">"hello, world"</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
<div class="coderef">&#13;
    <a class="orm:hideurl" href="https://java-to-kotlin.dev/code.html?ref=2.3&amp;show=file">Example 2.3 [projects.2:src/main/java/HelloWorld.kt]</a> <a class="orm:hideurl print-hide" href="https://java-to-kotlin.dev/code.html?ref=2.3&amp;show=diff">(diff)</a>&#13;
</div>&#13;
<div data-type="tip"><h1>Where to Put Kotlin Source</h1>&#13;
<p>The<a data-primary="Kotlin" data-secondary="source placement" data-type="indexterm" id="idm46393419186744"/> Kotlin build plug-in adds additional source roots, <em>src/main/kotlin</em> and <em>src/test/kotlin</em>, and compiles Kotlin source files found in any of their subdirectories.</p>&#13;
&#13;
<p>It will also compile Kotlin source found in Java source trees, in particular <em>src/main/java</em> and <em>src/test/java</em>.&#13;
Although you can separate your source files by language, putting Java files in the <em>java</em> directories and Kotlin into <em>kotlin</em>, in practice your authors don’t bother.&#13;
It’s nice to be able to look into a directory and see all the source for the corresponding package rather than casting around the filesystem.&#13;
To make this work, though, we keep Kotlin source in directories mirroring the package structure rather than taking advantage of Kotlin’s ability to have files in a single directory but multiple &#13;
<span class="keep-together">packages</span>.</p>&#13;
&#13;
<p>In a similar vein, while Kotlin does allow multiple public classes to be defined in a single class, when we are mixing Java and Kotlin in a project, we tend to stick to one class per file for consistency.</p>&#13;
</div>&#13;
&#13;
<p>We can run that within the IDE by clicking the little green arrow in the lefthand margin next to <code>fun main()</code>.</p>&#13;
&#13;
<p>We can run our build and then run it from the command line with the <code>java</code> command.&#13;
Compiling the source file named <em>HelloWorld.kt</em> creates a Java class file named <code>HelloWorldKt</code>.&#13;
We’ll look into how Kotlin source gets translated into Java class files in more detail later, but for now, we can run our program with the <code>java</code> command, like so:</p>&#13;
&#13;
<pre data-code-language="text" data-type="programlisting">$ java -cp build/classes/kotlin/main HelloWorldKt&#13;
hello, world</pre>&#13;
&#13;
<p>It lives!</p>&#13;
&#13;
<p>Let’s delete <em>HelloWorld.kt</em>—it’s done its job—commit and push.</p>&#13;
&#13;
<p>We now have the <em>option</em> to use Kotlin in our project; the first part of this chapter gives some pointers to <em>where</em> to start using it.<a data-primary="" data-startref="gradle02" data-type="indexterm" id="idm46393419167208"/></p>&#13;
<aside class="pagebreak-before less_space" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46393419166184">&#13;
<h5>Other Build Systems</h5>&#13;
<p>We’ve<a data-primary="Java Way to Kotlin Way" data-secondary="build systems other than Gradle" data-type="indexterm" id="idm46393419171768"/> chosen to show the changes necessary to add Kotlin support to a Gradle build here, but you can use Maven or Ant by following the instructions provided in the Tools section of <a href="https://oreil.ly/bWi9n">the Kotlin documentation</a>.&#13;
This also gives instructions for using the command-line compiler, <code>kotlinc</code>.</p>&#13;
&#13;
<p>If you use Gradle, there is the option to use Kotlin, rather than the traditional Groovy, as the build definition language.&#13;
This has the advantage of providing better tool &#13;
<span class="keep-together">support</span> through strong typing, at the expense of having to translate historical StackOverflow answers into a new language.</p>&#13;
&#13;
<p>As we are Java and Kotlin developers rather than Java and Groovy developers, your authors start new projects with the Kotlin DSL, but we don’t feel the need to convert existing Groovy builds, at least not immediately.&#13;
As with the Java and Kotlin in production code, we can mix and match Kotlin and Groovy in our build, so this is a conversion that we can take our time over.&#13;
We don’t recommend that you switch your build from Groovy to Kotlin as your first act of conversion, and certainly don’t look to us to write a Groovy to Kotlin Gradle book!<a data-primary="" data-startref="JWKWsupport02" data-type="indexterm" id="idm46393419085048"/></p>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Moving On" data-type="sect1"><div class="sect1" id="idm46393419420552">&#13;
<h1>Moving On</h1>&#13;
&#13;
<p>We expect the technical information in this chapter to date very quickly, as neither Gradle nor its plug-ins have a very stable interface.&#13;
Your current Java build file is also almost certainly incompatible with our example in some crucial way.&#13;
Despite this, though, adding Kotlin to a Java build is generally straightforward.</p>&#13;
&#13;
<p>Devising a strategy for moving code from Java to Kotlin is more complicated and context specific.&#13;
Or at least differently complicated and context specific.&#13;
Individual projects should examine where Java is and isn’t working for them, and where using Kotlin would alleviate problems and improve the code.&#13;
You might choose to dive in and write some Kotlin from scratch, or to convert an existing Java class to Kotlin.&#13;
In the spirit of this book, the latter is the approach we’ll take in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch03.html#java-to-kotlin-classes">Chapter 3, <em>Java to Kotlin Classes</em></a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>