- en: Chapter 5\. Beans to Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many Java projects have settled on mutable JavaBeans or POJO (plain old Java
    object) conventions for representing data. Mutability brings complications, though.
    Why are immutable values a better choice, and how can we reduce the cost of mutability
    in a codebase?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Beans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discussed in [“Bean Style”](ch01.html#bean-java-style), JavaBeans were
    introduced to allow the development of drag-and-drop GUI builders in the Visual
    Basic style. A developer could drop a button onto a form, change its title and
    icon, and then wire in an on-click handler. Behind the scenes, the GUI builder
    would write code to instantiate a button object and then call setters for the
    properties that the developer had changed.
  prefs: []
  type: TYPE_NORMAL
- en: To define a JavaBean, a class needs a default (no-argument) constructor, getters
    for its properties, and setters for its mutable properties. (We’ll gloss over
    the `Serializable` requirement, because even Sun never really took this seriously.)
    This makes sense for objects that have a lot of properties. GUI components typically
    have foreground and background colors, font, label, borders, size, alignments,
    paddings, and so on. Mostly the defaults for these properties are fine, so calling
    setters for just the special values minimizes the amount of code to be generated.
    Even today, a mutable component model is a solid choice for GUI toolkits.
  prefs: []
  type: TYPE_NORMAL
- en: When JavaBeans were introduced, though, we thought of most objects as mutable,
    not just UI components. I mean, why not? The point of objects was to encapsulate
    properties and manage the relationships between them. They were *designed* to
    solve problems like updating the width of a component when its bounds are changed,
    or the total of a shopping cart as items are added. Objects were the solution
    to the problem of managing mutable state. Java was quite radical at the time in
    having an immutable `String` class (although it couldn’t help itself and still
    plumped for a mutable `Date`).
  prefs: []
  type: TYPE_NORMAL
- en: As a profession, we have a more sophisticated understanding these days. We appreciate
    that we can use objects to represent different types of things—values, entities,
    services, actions, transactions, and so on. And yet the default pattern for a
    Java object is still the JavaBean, a mutable object with getters and setters for
    its properties. Although it may be appropriate for a UI toolkit, this is not a
    good default pattern. For most things that we want to represent with objects,
    a value would be better.
  prefs: []
  type: TYPE_NORMAL
- en: Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Value* is a much overloaded term in English. In computing, we say that variables,
    parameters, and fields have values: the primitive or reference that they are bound
    to. When we refer to *a value* in this book, we are referring to a specific type
    of primitive or reference: those with value semantics. An object has value semantics
    if only its value is significant in its interactions, not its identity. Java primitives
    all have value semantics: every `7` is equal to every other `7`. Objects may or
    may not have value semantics though; in particular, mutable objects do not. In
    later chapters we’ll look at finer distinctions, but for now, let’s just define
    a *value* to be an immutable piece of data, and a *value type* to be a type that
    defines the behavior of an immutable piece of data.'
  prefs: []
  type: TYPE_NORMAL
- en: So `7` is a value, and the boxed `Integer` is a value type (because boxed types
    are immutable), `banana` is a value (because `String`s are immutable), a `URI`
    is a value (because `URI`s are immutable), but `java.util.Date` is not a value
    type (because we can call `setYear` and others on the date).
  prefs: []
  type: TYPE_NORMAL
- en: An instance of an immutable `DBConnectionInfo` is a value, but an instance of
    `Database` is not a value, even if all its properties are immutable. This is because
    it is not a piece of data; it is a means of accessing, and mutating, pieces of
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Are JavaBeans values? UI component JavaBeans are not values because UI components
    aren’t just data—two otherwise identical buttons have different identities. In
    the case of beans used to represent plain data, it will depend on whether they
    are immutable. It is possible to create immutable beans, but most developers would
    think of these more as plain old java objects.
  prefs: []
  type: TYPE_NORMAL
- en: Are POJOs values? The term was coined to refer to classes that don’t have to
    extend from framework types to be useful. They usually represent data and conform
    to the JavaBeans conventions for accessor methods. Many POJOs will not have a
    default constructor, but instead define constructors to initialize properties
    that don’t have sensible defaults. Because of this, immutable POJOs are common
    and may have value semantics. Mutable POJOs still seem to be the default though,
    so much so that many people consider that object-oriented programming in Java
    is synonymous with mutable objects. Mutable POJOs are not values.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, a bean could technically be a value but rarely is. POJOs more often
    have value semantics, especially in the modern Java age. So whereas *Beans to
    Values* is snappy, in this chapter we’re really looking at refactoring from mutable
    objects to immutable data, so maybe we should have called it *Mutable POJOs to
    Values*. We hope you’ll forgive the sloppy title.
  prefs: []
  type: TYPE_NORMAL
- en: Why Should We Prefer Values?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A value is immutable data. Why should we prefer immutable objects to mutable
    objects, and objects that represent data to other types of objects? This is a
    theme that we will visit time and again in this book. For now, let’s just say
    that immutable objects are easier to reason about because they don’t change, and
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: We can put them into sets or use them as map keys.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We never have to worry about an immutable collection changing as we iterate
    over its contents.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can explore different scenarios without having to deep-copy initial states
    (which also makes it easy to implement undo and redo).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can safely share immutable objects between different threads.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring Beans to Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s look at refactoring a use of a mutable bean or POJO to a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Travelator has a mobile app, and the Android version is written in Java. In
    that code, we represent user preferences with a `UserPreferences` JavaBean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 5.1 [beans-to-values.0:src/main/java/travelator/mobile/UserPreferences.java]](https://java-to-kotlin.dev/code.html?ref=5.1&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=5.1&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Application` has a `preferences` property, which it passes to views that
    need it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 5.2 [beans-to-values.0:src/main/java/travelator/mobile/Application.java]](https://java-to-kotlin.dev/code.html?ref=5.2&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=5.2&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: (Any similarity to an actual UI framework, living or dead, is purely coincidental.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, `PreferencesView` updates its `preferences` when the user makes changes.
    We know that there has been a change because `onThingChange()` will be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 5.3 [beans-to-values.0:src/main/java/travelator/mobile/PreferencesView.java]](https://java-to-kotlin.dev/code.html?ref=5.3&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=5.3&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This design, though simple, is fraught with complications typical of mutable
    data, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: If the `PreferencesView` and `WelcomeView` are both active, the `WelcomeView`
    can get out of sync with the current values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UserPreferences` equality and hash-code depend on the values of its properties,
    which may be changed. So we can’t reliably use `UserPreferences` in sets or as
    keys in maps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is nothing to indicate that the `WelcomeView` only reads from the preferences.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If reading and writing occur on different threads, we have to manage synchronization
    at the preference property level.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before we refactor to using an immutable value, let’s convert `Application`
    and `User​Pre⁠ferences` to Kotlin, which will help us see the nature of our model.
    `Application` is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 5.4 [beans-to-values.1:src/main/java/travelator/mobile/Application.kt]](https://java-to-kotlin.dev/code.html?ref=5.4&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=5.4&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: '`UserPreferences` is more complicated. “Convert to Kotlin” in IntelliJ yields
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 5.5 [beans-to-values.1:src/main/java/travelator/mobile/UserPreferences.kt]](https://java-to-kotlin.dev/code.html?ref=5.5&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=5.5&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: This is quite a sophisticated conversion. The `@JVMOverloads` annotation tells
    the compiler to generate multiple constructors that allow combinations of `greeting`,
    `locale`, or `currency` to be defaulted. This wasn’t what our original Java did;
    it had just two constructors (one of which was the default, no-argument constructor).
  prefs: []
  type: TYPE_NORMAL
- en: At this stage we haven’t changed the functioning of our application, just simplified
    its expression. Those `var` (as opposed to `val`) properties are the sign that
    we have mutable data. It’s worth reminding ourselves at this point that the Kotlin
    compiler is going to generate a private field, a getter method, and a setter method
    for each property, so that our Java continues to see the data class as a bean.
    Kotlin embraces the beans naming convention, and `var` properties allow us to
    define mutable beans, for better or worse.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming worse, how now do we make `UserPreferences` immutable? After all, we
    do need the preferences as seen in the app to reflect any changes the user makes.
    The answer is to move the mutation. In common with many of the refactorings in
    this book, we’re going to move the problematic thing (in this case mutation) up.
    Which is to say, toward the entry point, or into the higher-level, more application-specific
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of mutating the preferences, we are going to update the reference in
    the `Application`. The reference we’re going to use will be an updated copy returned
    by `PreferencesView`. In short, our strategy is to replace an immutable reference
    to a mutable object with a mutable reference to an immutable value. Why? Well,
    this reduces both the number and visibility of the potentially moving parts, and
    it is visibility of mutation that causes us problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll work our way there gradually, starting by converting `PreferencesView`
    to Kotlin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 5.6 [beans-to-values.3:src/main/java/travelator/mobile/PreferencesView.kt]](https://java-to-kotlin.dev/code.html?ref=5.6&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=5.6&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: '`show()` overrides a method in `View` that makes the view visible and blocks
    the calling thread until it is dismissed. To avoid mutation, we would like a version
    that returns a copy of the `UserPreferences` with any changes applied, but we
    can’t add a return type to the `View` method. So instead, we’ll rename `show`
    to `showModal`, returning the existing mutable `preferences` property once `super.show()`
    has returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 5.7 [beans-to-values.4:src/main/java/travelator/mobile/PreferencesView.kt]](https://java-to-kotlin.dev/code.html?ref=5.7&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=5.7&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: '`Application.editPreferences()` was calling its `preferencesView.show()` and
    relying on the fact that it and `PreferencesView` shared a reference to a mutable
    object to see any edits. We’ll now make `Application.preferences` a mutable property,
    set from the result of `showModal`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 5.8 [beans-to-values.4:src/main/java/travelator/mobile/Application.kt]](https://java-to-kotlin.dev/code.html?ref=5.8&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=5.8&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: '[![1](assets/1.png)](#co_introduction_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Now a `var`
  prefs: []
  type: TYPE_NORMAL
- en: 'The `showModal` method is currently returning the same object passed to the
    view in the constructor, so this doesn’t change anything really. In fact, we have
    the worst of both worlds: a mutable reference to mutable data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We haven’t finished though; we can make things even worse by making the `preferences`
    property in `PreferencesView` mutable too, so that we can set it to a new `UserPreferences`
    object when any UI elements are updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 5.9 [beans-to-values.5:src/main/java/travelator/mobile/PreferencesView.kt]](https://java-to-kotlin.dev/code.html?ref=5.9&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=5.9&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Actually, we say “even worse,” but this has now removed all the uses of the
    setters on `UserPreferences`. Without setters, we can make it a proper value,
    initializing its properties in its constructor and never modifying them. In Kotlin
    this means changing the `var` properties to `val` and inlining any use of the
    default constructor. This allows us to reduce `UserPreferences` to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 5.10 [beans-to-values.6:src/main/java/travelator/mobile/UserPreferences.kt]](https://java-to-kotlin.dev/code.html?ref=5.10&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=5.10&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: The eagle-eyed reader will notice that we sneakily made `UserPreferences` a
    data class. We didn’t do that before now, because it was mutable. While Kotlin
    *allows* mutable data classes, we should be even more wary of them than of other
    mutable classes, because data classes implement `equals` and `hashCode`.
  prefs: []
  type: TYPE_NORMAL
- en: What have we achieved so far? We’ve replaced two immutable references to shared
    mutable data with two mutable references to immutable values. Now we can see at
    a glance which views can update the preferences, and if we had to manage updates
    across threads, we could do that at the application level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having a mutable reference in `PreferencesView` is a bit irritating though.
    We can fix that by not holding a reference at all, but instead passing the preferences
    into `showModal`. `PreferencesView` doesn’t need a `UserPreferences` property;
    it can just distribute its values into the UI before it shows itself and gather
    them back in when it is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 5.11 [beans-to-values.7:src/main/java/travelator/mobile/PreferencesView.kt]](https://java-to-kotlin.dev/code.html?ref=5.11&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=5.11&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is still mutation here, because we are setting values into the pickers,
    but these are UI components and only have default constructors, so this has to
    happen somewhere. To finish the job, we also have to update `Application` to move
    the `preferences` argument from the `PreferencesView` constructor to `showModal`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 5.12 [beans-to-values.7:src/main/java/travelator/mobile/Application.kt]](https://java-to-kotlin.dev/code.html?ref=5.12&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=5.12&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: Now we have only one place that preferences can change, made clear by the assignment
    in `editPreferences`. It is also clear that `showWelcome` can only read from the
    object. It may seem a bit of a waste to create a new `UserPreferences` to return
    from `showModal` even if nothing has changed. If you’re used to sharing mutable
    objects, it may even seem dangerous. In the world of values, though, two `UserPreferences`
    with the same values are to almost all intents and purposes the same object (see
    [“Object Equality”](#object-equality)), and you would have to be in a very constrained
    environment to detect the extra allocation.
  prefs: []
  type: TYPE_NORMAL
- en: Moving On
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we’ve seen some advantages of immutable values over mutable
    objects. The refactoring example showed how to migrate mutation toward our application’s
    entry points and event handlers by replacing immutable references to mutable objects
    with mutable references to immutable objects. The result is that less of our code
    has to deal with the consequences and complications of mutability.
  prefs: []
  type: TYPE_NORMAL
- en: That said, JavaBeans were designed for use in user interface frameworks, and
    UIs are in many ways the last bastion of mutable objects. If we had more exacting
    liveness requirements—for example, updating a `WelcomeView` when the greeting
    preference changed—we might prefer using shared objects with change events rather
    than using immutable values.
  prefs: []
  type: TYPE_NORMAL
- en: Converting mutable objects to values and transformations is a repeating motif.
    [Chapter 6, *Java to Kotlin Collections*](ch06.html#java-to-kotlin-collections),
    continues the discussion with respect to collections. [Chapter 14, *Accumulating
    Objects to Transformations*](ch14.html#accumulating-objects-to-transformations),
    looks at how to translate code that uses accumulating parameters to use higher-order
    functions over collections instead.
  prefs: []
  type: TYPE_NORMAL
