<html><head></head><body><section data-pdf-bookmark="Chapter 6. Error Handling" data-type="chapter" epub:type="chapter"><div class="chapter" id="learnjava6-CHP-6">&#13;
<h1><span class="label">Chapter 6. </span>Error Handling</h1>&#13;
&#13;
&#13;
<p>You will always encounter <a data-primary="error handling" data-type="indexterm" id="ix_error_handling_ch6"/>errors in the real world. How you handle them helps show the quality of your code.</p>&#13;
&#13;
<p>Java has its roots in embedded systems—software that runs inside specialized devices, such as the handheld computers, cellular phones, and fancy toasters that we might consider part of the internet of things (IoT) these days. In those applications, it’s especially important that software errors be handled robustly. Most users would agree that it’s unacceptable for their phone to  crash on a regular basis or for their toast (and perhaps their house) to burn because some software failed. Given that we can’t eliminate the possibility of software errors, recognizing and dealing with application-level errors methodically is a good step in the right direction.</p>&#13;
&#13;
<p>Some languages leave the responsibility for handling errors entirely with the programmer. The language itself provides no help in identifying error types and no tools for dealing with them easily. In the C language, for example, functions generally indicate a failure by returning an “unreasonable” value (like the idiomatic <code>-1</code> or a <code>null</code>). As the programmer, you must know what constitutes a bad result and what it means. It’s often awkward to work around the limitations of passing error values in the normal path of data flow.<sup><a data-type="noteref" href="ch06.html#id1273" id="id1273-marker">1</a></sup> An even worse problem is that certain types of errors can legitimately occur almost anywhere, and it’s slow and costly to test for them explicitly at every point in the software.</p>&#13;
&#13;
<p>In this chapter we’ll consider how Java tackles the problem of problems. We’ll go over the notion of exceptions to look at how and why they occur, as well as how and where to handle them. We’ll also be looking at errors and assertions. <em>Errors</em> are more serious problems that often cannot be fixed at runtime but can still be logged for debugging. <em>Assertions</em> are a popular way of inoculating your code against exceptions or errors by verifying ahead of time that safe conditions exist.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Exceptions" data-type="sect1"><div class="sect1" id="learnjava6-CHP-6-SECT-1">&#13;
<h1>Exceptions</h1>&#13;
&#13;
<p>Java offers an <a data-primary="exceptions" data-type="indexterm" id="ix_except_ch6"/>elegant solution to aid the programmer in addressing common coding and runtime problems through exceptions. (Java exception handling is similar to, but not quite the same as, exception handling in C++.) An <em>exception</em> indicates an unusual condition or an error condition. When a problem occurs, the runtime transfers control (or “throws”) to a specially designated section of your code that can handle (or “catch”) the condition. In this way, error handling is independent of the normal flow of the program. We don’t need special return values for all of our methods; errors are handled by a separate mechanism. Java  can pass control a long distance from a deeply nested routine and handle errors in a single location when that is desirable, or an error can be handled immediately at its source. A few standard Java methods still return a special value such as <code>-1</code>, but these are generally limited to situations where expecting and handling a special value is relatively straightforward.<sup><a data-type="noteref" href="ch06.html#id1274" id="id1274-marker">2</a></sup></p>&#13;
&#13;
<p>You must specify any known exceptions your methods can throw, and the compiler makes sure that callers of the method handle them. In this way, Java treats information about what errors a method can produce with the same level of importance as its argument and return types. You may still decide to punt and ignore some errors, but in Java you must do so explicitly. (We’ll discuss runtime exceptions and errors, which don’t require this explicit declaration, in a moment.)</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Exceptions and Error Classes" data-type="sect2"><div class="sect2" id="learnjava6-CHP-6-SECT-1.1">&#13;
<h2>Exceptions and Error Classes</h2>&#13;
&#13;
<p>Exceptions are <a data-primary="exceptions" data-secondary="and error classes" data-secondary-sortas="error classes" data-type="indexterm" id="ix_except_class"/><a data-primary="error handling" data-secondary="error classes" data-type="indexterm" id="ix_error_class"/><a data-primary="classes" data-secondary="error" data-type="indexterm" id="ix_class_error"/>represented by instances of the class <code>java.lang.Exception</code> and its subclasses. <a data-primary="Exception class" data-type="indexterm" id="id1275"/><a data-primary="java.lang package" data-secondary="Exception class" data-type="indexterm" id="id1276"/>Subclasses of <code>Exception</code> can hold specialized information (and possibly behavior) for different kinds of exceptional conditions. However, more often they are simply “logical” subclasses that serve only to identify a new exception type. <a data-type="xref" href="#learnjava6-CHP-6-FIG-1">Figure 6-1</a> shows the subclasses of <code>Exception</code> in the <code>java.lang</code> package. It should give you a feel for how exceptions are organized. Most packages define their own exception types, which usually are subclasses of <code>Exception</code> itself or of its important subclass <code>RuntimeException</code>, which we’ll get to in a moment.</p>&#13;
&#13;
<p>For example, let’s <a data-primary="java.io package" data-secondary="and error classes" data-secondary-sortas="error classes" data-type="indexterm" id="ix_java_io_error"/><a data-primary="IOException" data-type="indexterm" id="id1277"/>look at another important exception class: <code>java.io.IOException</code>. The <code>IOException</code> class extends <code>Exception</code> and has many subclasses of its own for typical I/O problems, such as a <code>FileNotFoundException</code>. Notice how explicit (and useful) the class name is. <a data-primary="MalformedURLException" data-type="indexterm" id="id1278"/><a data-primary="java.net package" data-seealso="sockets; web services" data-type="indexterm" id="id1279"/>Many network exceptions further extend &#13;
<span class="keep-together"><code>IOException</code></span>—they do involve input and output—but following conventions, exceptions like &#13;
<span class="keep-together"><code>MalformedURLException</code></span> belong to the <code>java.net</code> package alongside other networking classes.</p>&#13;
&#13;
<figure><div class="figure" id="learnjava6-CHP-6-FIG-1">&#13;
<img alt="ljv6 0601" src="assets/ljv6_0601.png"/>&#13;
<h6><span class="label">Figure 6-1. </span>The <code>java.lang.Exception</code> subclasses</h6>&#13;
</div></figure>&#13;
&#13;
<p>The <a data-primary="stack traces" data-type="indexterm" id="id1280"/><a data-primary="exceptions" data-secondary="stack traces" data-type="indexterm" id="id1281"/>runtime creates an <code>Exception</code> object at the point where the error condition arises. It can be designed to hold any information necessary to describe the exceptional condition. It also includes a full stack trace for debugging. A <em>stack trace</em> is the (occasionally unwieldy) list of all the methods called and the order in which they were called from your <code>main()</code> method up to the point where the exception was thrown. (We’ll look at these useful lists in more detail in <a data-type="xref" href="#learnjava6-CHP-6-SECT-1.4">“Stack Traces”</a>.) The <code>Exception</code> object is <a data-primary="exceptions" data-secondary="throwing" data-type="indexterm" id="id1282"/>passed as an argument to the handling block of code, along with the flow of control. <a data-primary="throw/catch, exceptions" data-type="indexterm" id="id1283"/>This is where the terms <em>throw</em> and <em>catch</em> come from: the <code>Exception</code> object is thrown from one point in the code and caught by another, where execution resumes, as shown in <a data-type="xref" href="#learnjava6-CHP-6-FIG-throw-flow">Figure 6-2</a>.</p>&#13;
&#13;
<figure><div class="figure" id="learnjava6-CHP-6-FIG-throw-flow">&#13;
<img alt="ljv6 0602" src="assets/ljv6_0602.png"/>&#13;
<h6><span class="label">Figure 6-2. </span>The flow of control when an exception occurs</h6>&#13;
</div></figure>&#13;
&#13;
<p>Java also <a data-primary="AssertionError type" data-type="indexterm" id="id1284"/><a data-primary="Error class" data-type="indexterm" id="id1285"/><a data-primary="java.lang package" data-secondary="Error class" data-type="indexterm" id="id1286"/>defines the <code>java.lang.Error</code> class for unrecoverable errors. The subclasses of <code>Error</code> in the <code>java.lang</code> package are shown in <a data-type="xref" href="#learnjava6-CHP-6-FIG-2">Figure 6-3</a>. A notable <code>Error</code> type is <code>AssertionError</code>, which is used by the Java <code>assert</code> statement (more on this statement later in this chapter) to indicate a failure. A few other packages define their own subclasses of <code>Error</code>, but subclasses of <code>Error</code> are much less common (and less useful) than subclasses of <code>Exception</code>. You generally won’t need to worry about these errors in your code; they are intended to indicate fatal problems or virtual machine errors, which usually cause the Java interpreter to display a message and exit. Java’s designers actively discourage developers from trying to catch or recover from these errors because they are supposed to indicate a fatal program bug, possibly in the JVM itself, not a routine condition.</p>&#13;
&#13;
<p>Both <code>Exception</code> and <code>Error</code> are <a data-primary="Throwable class" data-type="indexterm" id="id1287"/>subclasses of <code>Throwable</code>. The <code>Throwable</code> class is the base class for objects that can be “thrown” with the <code>throw</code> statement. While you can technically extend <code>Throwable</code> yourself, you should generally extend only <code>Exception</code>, <code>Error</code>, or one of their subclasses if you want to create your own throwable type.<a data-primary="" data-startref="ix_class_error" data-type="indexterm" id="id1288"/><a data-primary="" data-startref="ix_error_class" data-type="indexterm" id="id1289"/><a data-primary="" data-startref="ix_except_class" data-type="indexterm" id="id1290"/><a data-primary="" data-startref="ix_java_io_error" data-type="indexterm" id="id1291"/></p>&#13;
&#13;
<figure><div class="figure" id="learnjava6-CHP-6-FIG-2">&#13;
<img alt="ljv6 0603" src="assets/ljv6_0603.png"/>&#13;
<h6><span class="label">Figure 6-3. </span>The <code>java.lang.Error</code> subclasses</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Exception Handling" data-type="sect2"><div class="sect2" id="learnjava6-CHP-6-SECT-1.2">&#13;
<h2>Exception Handling</h2>&#13;
&#13;
<p>To catch and handle an _Italicized Textix<a data-primary="exceptions" data-secondary="try/catch blocks" data-type="indexterm" id="ix_except_try_catch"/><a data-primary="java.io package" data-secondary="try/catch blocks" data-type="indexterm" id="ix_java_io_error_try"/><a data-primary="try/catch blocks" data-type="indexterm" id="ix_try_catch"/>exception, you wrap blocks of your code in <code>try/catch</code> guarding statements:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="k">try</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">readFromFile</code><code class="p">(</code><code class="s">"foo"</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">      </code><code class="c1">// do other file things ...</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"> </code><code class="k">catch</code><code class="w"> </code><code class="p">(</code><code class="n">Exception</code><code class="w"> </code><code class="n">e</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="c1">// Handle error</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="s">"Exception while reading file: "</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">e</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>In this example, any <a data-primary="catch clause" data-type="indexterm" id="ix_catch_clause"/>exceptions that occur within the body of the <code>try</code> portion of the statement are directed to the <code>catch</code> clause for possible handling. The <code>catch</code> clause acts like a method; it specifies the type of exception it wants to handle. If it’s invoked, the clause receives the <code>Exception</code> object as an argument. Here, we receive the object in the variable <code>e</code> and print it along with a message.</p>&#13;
&#13;
<p>We can try this ourselves. Recall the simple program to calculate the greatest common denominator (GCD) using the Euclid algorithm back in <a data-type="xref" href="ch04.html#learnjava6-CHP-4">Chapter 4</a>. We could augment that program to allow the user to pass in the two numbers <code>a</code> and <code>b</code> as command-line arguments via that <code>args[]</code> array in the <code>main()</code> method. However, that array is of type <code>String</code>. If we cheat a little bit and steal some code from <a data-type="xref" href="ch08.html#learnjava6-CHP-8-SECT-2.1">“Parsing Primitive Numbers”</a>, we can use a text parsing method to turn those strings into <code>int</code> values. However, that parsing method can throw an exception if we don’t pass a valid number. Here’s a look at our new <code>Euclid2</code> class:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code><code class="w"> </code><code class="kd">class</code> <code class="nc">Euclid2</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="kd">static</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">main</code><code class="p">(</code><code class="n">String</code><code class="w"> </code><code class="n">args</code><code class="o">[]</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="kt">int</code><code class="w"> </code><code class="n">a</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">2701</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="kt">int</code><code class="w"> </code><code class="n">b</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">222</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">// Only try to parse arguments if we have exactly 2</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">args</code><code class="p">.</code><code class="na">length</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">2</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="k">try</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">        </code><code class="n">a</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Integer</code><code class="p">.</code><code class="na">parseInt</code><code class="p">(</code><code class="n">args</code><code class="o">[</code><code class="mi">0</code><code class="o">]</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">        </code><code class="n">b</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">Integer</code><code class="p">.</code><code class="na">parseInt</code><code class="p">(</code><code class="n">args</code><code class="o">[</code><code class="mi">1</code><code class="o">]</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">}</code><code class="w"> </code><code class="k">catch</code><code class="w"> </code><code class="p">(</code><code class="n">NumberFormatException</code><code class="w"> </code><code class="n">nfe</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">        </code><code class="n">System</code><code class="p">.</code><code class="na">err</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="s">"Arguments were not both numbers."</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">        </code><code class="n">System</code><code class="p">.</code><code class="na">err</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="s">"Using defaults."</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"> </code><code class="k">else</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">System</code><code class="p">.</code><code class="na">err</code><code class="p">.</code><code class="na">print</code><code class="p">(</code><code class="s">"Wrong number of arguments"</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">System</code><code class="p">.</code><code class="na">err</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="s">" expected 2)."</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">System</code><code class="p">.</code><code class="na">err</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="s">"Using defaults."</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">print</code><code class="p">(</code><code class="s">"The GCD of "</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">a</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="s">" and "</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">b</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="s">" is "</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">while</code><code class="w"> </code><code class="p">(</code><code class="n">b</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="mi">0</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">a</code><code class="w"> </code><code class="o">&gt;</code><code class="w"> </code><code class="n">b</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">        </code><code class="n">a</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">a</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="n">b</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">}</code><code class="w"> </code><code class="k">else</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">        </code><code class="n">b</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">b</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="n">a</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="n">a</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>Notice that we limit our <code>try/catch</code> to just the potentially problematic code. <a data-primary="NumberFormatException" data-type="indexterm" id="id1292"/>It’s common to see several different <code>try/catch</code> blocks in a method. This small scope allows us to better tailor the code in the <code>catch</code> block to whatever problems we’re anticipating. In this case, we know we might get some bad input from the user, so we can check for the (very) specific <code>NumberFormatException</code> and print a friendly message for the user.</p>&#13;
&#13;
<p>If we run this program from a terminal window or use the command-line arguments option in our IDE like we did in <a data-type="xref" href="ch02.html#learnjava6-CHP-2-FIG-9">Figure 2-10</a>, we can now find the GCD of several number pairs without recompiling:</p>&#13;
&#13;
<pre class="less_space pagebreak-before" data-type="programlisting">$ javac ch06/examples/Euclid2.java&#13;
$ java ch06.examples.Euclid2&#13;
The GCD of 18 and 6 is 6&#13;
&#13;
$ java ch06.examples.Euclid2 547832 2798&#13;
The GCD of 547832 and 2798 is 2</pre>&#13;
&#13;
<p>But if we pass in arguments that are not numeric, we’ll get that <code>NumberFormatException</code> and see our error message. Note, however, that our code recovers gracefully and still provides some output. This recovery is the essence of error handling:</p>&#13;
&#13;
<pre data-type="programlisting">$ java ch06.examples.Euclid2 apples oranges&#13;
Arguments were not both numbers.&#13;
Using defaults.&#13;
The GCD of 2701 and 222 is 37</pre>&#13;
&#13;
<p>A <code>try</code> statement can have multiple <code>catch</code> clauses that specify different types (subclasses) of <code>Exception</code>:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="k">try</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">readFromFile</code><code class="p">(</code><code class="s">"foo"</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">      </code><code class="c1">// do any other file things</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"> </code><code class="k">catch</code><code class="w"> </code><code class="p">(</code><code class="n">FileNotFoundException</code><code class="w"> </code><code class="n">e</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="c1">// Handle file not found</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"> </code><code class="k">catch</code><code class="w"> </code><code class="p">(</code><code class="n">IOException</code><code class="w"> </code><code class="n">e</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="c1">// Handle read error</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"> </code><code class="k">catch</code><code class="w"> </code><code class="p">(</code><code class="n">Exception</code><code class="w"> </code><code class="n">e</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="c1">// Handle all other errors</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>The <code>catch</code> clauses are <a data-primary="readFromFile() method" data-type="indexterm" id="id1293"/><a data-primary="FileNotFoundException" data-type="indexterm" id="id1294"/><a data-primary="IOException" data-type="indexterm" id="id1295"/>evaluated in order, and Java picks the first assignable match. At most, one <code>catch</code> clause is executed, which means that the exceptions should be listed from most specific to most generic. In the previous example, we anticipate that the hypothetical <code>readFromFile()</code> method can throw two different kinds of exceptions: one for a file not found and another for a more general read error. Maybe the file exists but we don’t have permission to open it. <code>FileNotFoundException</code> is a subclass of <code>IOException</code>, so if we had swapped the first two <code>catch</code> clauses, the more general <code>IOException</code> clause would catch the missing file exception.</p>&#13;
&#13;
<p>What if we completely reverse the order of the <code>catch</code> clauses? You can assign any subclass of <code>Exception</code> to the parent type <code>Exception</code>, so that clause catches <em>every</em> exception. If you use a <code>catch</code> with type <code>Exception</code>, always put it as the last possible clause. It acts like the <code>default</code> case in a <code>switch</code> statement and handles any remaining possibilities.</p>&#13;
&#13;
<p>One advantage of the <code>try/catch</code> scheme is that any statement in the <code>try</code> block can assume that all previous statements in the block succeeded. A problem won’t arise suddenly because you forgot to check the return value from a method. If an earlier statement fails, execution jumps immediately to a <code>catch</code> clause; later statements inside the <code>try</code> are never executed.</p>&#13;
&#13;
<p>There is an <a data-primary="or syntax (|)" data-type="indexterm" id="id1296"/><a data-primary="| (vertical bar)" data-secondary="or syntax" data-type="indexterm" id="id1297"/><a data-primary="vertical bar (|)" data-secondary="or syntax" data-type="indexterm" id="id1298"/>alternative to using multiple <code>catch</code> clauses. You can handle multiple discrete exception types in a single <code>catch</code> clause, using the <em>or syntax</em> (written using the pipe character, “|”):</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="k">try</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="c1">// read from network...</code><code class="w"/>&#13;
<code class="w">      </code><code class="c1">// write to file..</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"> </code><code class="k">catch</code><code class="w"> </code><code class="p">(</code><code class="n">ZipException</code><code class="w"> </code><code class="o">|</code><code class="w"> </code><code class="n">SSLException</code><code class="w"> </code><code class="n">e</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">logException</code><code class="p">(</code><code class="n">e</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>Using this “|” syntax, we receive both types of exception in the same <code>catch</code> clause.</p>&#13;
&#13;
<p>What is the <a data-primary="SSLException" data-type="indexterm" id="id1299"/><a data-primary="ZipException" data-type="indexterm" id="id1300"/>actual type of the <code>e</code> variable that we are passing to our log method? What can we do with it? In this case, <code>e</code>’s type will be neither <code>ZipException</code> nor <code>SSLException</code> but <code>IOException</code>, which is the nearest common ancestor (the closest parent class type to which they are both assignable) for the two exceptions. In many cases, the nearest common type among the two or more argument exception types may simply be <code>Exception</code>, the parent of all exception types.</p>&#13;
&#13;
<p>The difference between catching these discrete exception types with a multiple-type <code>catch</code> clause and simply catching the common parent exception type is that we are limiting our <code>catch</code> to only these specifically enumerated exception types. We will not catch any of the other <code>IOException</code> types. Combining multiple-type <code>catch</code> clauses with ordering the clauses from specific to broad types gives you great flexibility in handling exceptions. You can consolidate error-handling logic where appropriate and avoid repeating code. There are more nuances to this feature, and we will return to it after we have discussed “throwing” and “re-throwing” exceptions.<a data-primary="" data-startref="ix_catch_clause" data-type="indexterm" id="id1301"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Bubbling Up" data-type="sect2"><div class="sect2" id="learnjava6-CHP-6-SECT-1.3">&#13;
<h2>Bubbling Up</h2>&#13;
&#13;
<p>What if we hadn’t caught the <a data-primary="java.io package" data-secondary="bubbling up of" data-type="indexterm" id="ix_java_io_bubble"/><a data-primary="exceptions" data-secondary="bubbling up of" data-type="indexterm" id="ix_except_bubble"/>exception? Where would it have gone? Well, if there is no enclosing <code>try/catch</code> statement, the exception pops up from the method in which it originated (halting further execution of that method) and is thrown from that method up to its caller. If that calling method has a <code>try</code> clause, control passes to the corresponding <code>catch</code> clause. Otherwise, the exception continues propagating up the call stack, from one method to its caller. The exception bubbles up until it’s caught or until it pops out of the top of the program and terminates it with a runtime error message. Sometimes there’s a bit more to it; the compiler might force you to deal with the exception along the way. <a data-type="xref" href="#learnjava6-CHP-6-SECT-1.5">“Checked and Unchecked Exceptions”</a> talks about this distinction in more detail.</p>&#13;
&#13;
<p>Let’s look at another example. In <a data-type="xref" href="#learnjava6-CHP-6-FIG-propagation">Figure 6-4</a>, the <a data-primary="getContent() method" data-secondary="try/catch" data-type="indexterm" id="id1302"/><a data-primary="openConnection() method" data-secondary="try/catch" data-type="indexterm" id="id1303"/><a data-primary="sendRequest() method, try/catch" data-type="indexterm" id="id1304"/><a data-primary="write() method" data-secondary="try/catch" data-type="indexterm" id="id1305"/>method <code>getContent()</code> invokes the method <code>openConnection()</code> from within a <code>try/catch</code> statement (step 1 in the figure). In turn, <code>openConnection()</code> invokes the method <code>sendRequest()</code> (step 2), which calls the method <code>write()</code> to send some data.</p>&#13;
&#13;
<figure><div class="figure" id="learnjava6-CHP-6-FIG-propagation">&#13;
<img alt="ljv6 0604" src="assets/ljv6_0604.png"/>&#13;
<h6><span class="label">Figure 6-4. </span>Exception propagation</h6>&#13;
</div></figure>&#13;
&#13;
<p>In this figure, the second call to <code>write()</code> throws an <code>IOException</code> (step 3). Since <code>sendRequest()</code> doesn’t contain a <code>try/catch</code> statement to handle the exception, it’s thrown again from the point where it was called in the method <code>openConnection()</code> (step 4). But <code>openConnection()</code> doesn’t catch the exception either, so it’s thrown once more (step 5). Finally, it’s caught by the <code>try</code> statement in <code>getContent()</code> and handled by its <code>catch</code> clause. Notice that each throwing method must declare that it can throw a particular type of exception with a <code>throws</code> clause. We’ll discuss this in <a data-type="xref" href="#learnjava6-CHP-6-SECT-1.5">“Checked and Unchecked Exceptions”</a>.</p>&#13;
&#13;
<p>Adding a <a data-primary="threads" data-secondary="background" data-type="indexterm" id="id1306"/><a data-primary="background threads" data-type="indexterm" id="id1307"/>high-level <code>try</code> statement early in your code can also help handle errors that might bubble up from background threads. We’ll discuss threads in much more detail in <a data-type="xref" href="ch09.html#learnjava6-CHP-9">Chapter 9</a>, but uncaught exceptions can lead to debugging headaches in larger, more complex programs.<a data-primary="" data-startref="ix_except_try_catch" data-type="indexterm" id="id1308"/><a data-primary="" data-startref="ix_java_io_error_try" data-type="indexterm" id="id1309"/><a data-primary="" data-startref="ix_try_catch" data-type="indexterm" id="id1310"/><a data-primary="" data-startref="ix_except_bubble" data-type="indexterm" id="id1311"/><a data-primary="" data-startref="ix_java_io_bubble" data-type="indexterm" id="id1312"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Stack Traces" data-type="sect2"><div class="sect2" id="learnjava6-CHP-6-SECT-1.4">&#13;
<h2>Stack Traces</h2>&#13;
&#13;
<p>Because an <a data-primary="exceptions" data-secondary="stack traces" data-type="indexterm" id="id1313"/><a data-primary="java.io package" data-secondary="stack traces" data-type="indexterm" id="id1314"/><a data-primary="stack traces" data-type="indexterm" id="id1315"/>exception can bubble up quite a distance before it is caught and handled, we need a way to determine exactly where it was thrown. It’s also important to know how that problematic code was reached. Which methods called which other methods to get to that point? For debugging, all exceptions can dump a <em>stack trace</em> that lists their method of <span class="keep-together">origin</span> and all the nested method calls they took to arrive there. Most commonly, the user sees a stack trace when it is printed using the <code>printStackTrace()</code> method:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="k">try</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="c1">// complex, deeply nested task</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"> </code><code class="k">catch</code><code class="w"> </code><code class="p">(</code><code class="n">Exception</code><code class="w"> </code><code class="n">e</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="c1">// dump information about where the exception occurred</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">e</code><code class="p">.</code><code class="na">printStackTrace</code><code class="p">(</code><code class="n">System</code><code class="p">.</code><code class="na">err</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>Such a stack trace for an exception might look like this:</p>&#13;
&#13;
<pre data-type="programlisting">java.io.FileNotFoundException: myfile.xml&#13;
      at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java)&#13;
      at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java)&#13;
      at MyApplication.loadFile(MyApplication.java:137)&#13;
      at MyApplication.main(MyApplication.java:5)</pre>&#13;
&#13;
<p>This <a data-primary="loadFile() method" data-type="indexterm" id="id1316"/>stack trace indicates that line 5 (in your source code) of the <code>main()</code> method of the class <code>MyApplication</code> called the method <code>loadFile()</code>. The <code>loadFile()</code> method then tried to construct a <code>FileInputStream</code> at line 137, which threw the &#13;
<span class="keep-together"><code>FileNotFound</code></span><code>Exception</code>.</p>&#13;
&#13;
<p>Once the stack trace reaches Java system classes (like <code>FileInputStream</code>), the line numbers may be lost. This can also happen if the code has been optimized. Usually, there is a way to disable the optimization temporarily to find the exact line numbers, but sometimes other debugging techniques may be required. We’ll look at many of those techniques later in this chapter.</p>&#13;
&#13;
<p>Methods in the <code>Throwable</code> <a data-primary="Throwable class" data-type="indexterm" id="id1317"/><a data-primary="methods" data-secondary="Throwable class list" data-type="indexterm" id="id1318"/>class allow you to retrieve the stack trace information programmatically, by using the <code> getStackTrace()</code> method. (Recall that <code>Throwable</code> is the parent class of <code>Exception</code> and <code>Error</code>.) <a data-primary="StackTraceElement objects" data-type="indexterm" id="id1319"/>This method returns an array of <code>StackTraceElement</code> objects, each of which represents a method call on the stack. You can ask a <code>StackTraceElement</code> for details about that method’s location using the methods <code>getFileName()</code>, <code>getClassName()</code>, <code>getMethodName()</code>, and <code>getLineNumber()</code>. Element zero of the array is the top of the stack, the final line of code that caused the exception; subsequent elements step back one method call each until the original <code>main()</code> method is reached in the last element.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Checked and Unchecked Exceptions" data-type="sect2"><div class="sect2" id="learnjava6-CHP-6-SECT-1.5">&#13;
<h2>Checked and Unchecked Exceptions</h2>&#13;
&#13;
<p>We <a data-primary="unchecked and checked exceptions" data-type="indexterm" id="id1320"/><a data-primary="checked and unchecked exceptions" data-type="indexterm" id="id1321"/><a data-primary="exceptions" data-secondary="checked and unchecked" data-type="indexterm" id="id1322"/><a data-primary="java.io package" data-secondary="checked and unchecked" data-type="indexterm" id="id1323"/>mentioned earlier that Java forces us to be explicit about our error handling, but it’s not necessary to require that every conceivable type of error be handled explicitly in every situation. Java exceptions are therefore divided into two categories: <em>checked</em> and <em>unchecked</em>. Most application-level exceptions are checked, which means that any method that throws one must declare it with a special <code>throws</code> clause in its definition, like this:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">  </code><code class="kt">void</code><code class="w"> </code><code class="nf">readFile</code><code class="p">(</code><code class="n">String</code><code class="w"> </code><code class="n">s</code><code class="p">)</code><code class="w"> </code><code class="kd">throws</code><code class="w"> </code><code class="n">IOException</code><code class="p">,</code><code class="w"> </code><code class="n">InterruptedException</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">// do some I/O work, maybe using threads for background processing</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>Our <code>readFile()</code> method <a data-primary="readFile() method" data-type="indexterm" id="id1324"/>anticipates throwing two types of exceptions: by generating them itself (as we’ll discuss in <a data-type="xref" href="#learnjava6-CHP-6-SECT-1.6">“Throwing Exceptions”</a>) and by ignoring ones that occur within it. For now, all you need to know is that methods have to declare the checked exceptions they can throw or allow to be thrown.</p>&#13;
&#13;
<p>The <code>throws</code> clause tells the <a data-primary="throws keyword" data-type="indexterm" id="id1325"/><a data-primary="exceptions" data-secondary="try/catch blocks" data-type="indexterm" id="id1326"/><a data-primary="try/catch blocks" data-type="indexterm" id="id1327"/><a data-primary="java.io package" data-secondary="try/catch blocks" data-type="indexterm" id="id1328"/>compiler that a method is a possible source of that type of checked exception and that anyone calling that method must be prepared to deal with it. The caller must then either use a <code>try/catch</code> block to handle it or, in turn, declare that it can throw the exception from itself.</p>&#13;
&#13;
<p>In contrast, <a data-primary="java.lang package" data-secondary="Error class" data-type="indexterm" id="id1329"/><a data-primary="java.lang package" data-secondary="RuntimeException class" data-type="indexterm" id="id1330"/><a data-primary="RuntimeException class" data-type="indexterm" id="id1331"/><a data-primary="Error class" data-type="indexterm" id="id1332"/>exceptions that are subclasses of either the class <code>java.lang.RuntimeException</code> or the class <code>java.lang.Error</code> are unchecked. See <a data-type="xref" href="#learnjava6-CHP-6-FIG-1">Figure 6-1</a> for the subclasses of <code>RuntimeException</code>. It’s not a compile-time error to ignore the possibility of these exceptions; methods also don’t have to declare they can throw them. In all other respects, unchecked exceptions behave the same as other exceptions. You are free to catch them if you wish, but in this case you aren’t required to.</p>&#13;
&#13;
<p>Checked exceptions are intended to cover application-level problems, such as missing files and unavailable network hosts. As good programmers (and upstanding citizens), we should design software to recover gracefully from these kinds of conditions. Unchecked exceptions are intended for system-level problems, such as “array index out of bounds.” While these may indicate application-level programming errors, they can occur almost anywhere. Fortunately, because they are unchecked exceptions, you don’t have to wrap every one of your array operations in a <code>try/catch</code> statement or declare all of the calling methods as a potential source of them.</p>&#13;
&#13;
<p>To sum up, checked exceptions are problems that a reasonable application should try to handle gracefully. Unchecked exceptions (runtime exceptions or errors) are problems from which we would not normally expect our software to recover, but you can provide a polite and hopefully informative message to the user about what happened. Error types, such as “out of memory” errors, are conditions we typically cannot recover from.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Throwing Exceptions" data-type="sect2"><div class="sect2" id="learnjava6-CHP-6-SECT-1.6">&#13;
<h2>Throwing Exceptions</h2>&#13;
&#13;
<p>We can <a data-primary="throw statement" data-type="indexterm" id="id1333"/><a data-primary="exceptions" data-secondary="throwing" data-type="indexterm" id="ix_except_throw"/><a data-primary="java.io package" data-secondary="throwing" data-type="indexterm" id="id1334"/>throw our own exceptions—either instances of <code>Exception</code>, one of its existing subclasses, or our own specialized exception classes. All we have to do is create an instance of the appropriate exception class and throw it with the <code>throw</code> statement:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="k">throw</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">IOException</code><code class="p">();</code><code class="w"/></pre>&#13;
&#13;
<p>Execution stops and is transferred to the nearest enclosing <code>try/catch</code> statement that can handle the exception type. Notice we didn’t put the new exception into a variable. There is little point in keeping a reference to the <code>IOException</code> object we’ve created here, as the <code>throw</code> statement immediately halts the current flow through our code.</p>&#13;
&#13;
<p>An alternative constructor for exceptions lets us specify a string with an error &#13;
<span class="keep-together">message</span>:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="k">throw</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">IOException</code><code class="p">(</code><code class="s">"Sunspots!"</code><code class="p">);</code><code class="w"/></pre>&#13;
&#13;
<p>You can <a data-primary="getMessage() method, Exception" data-type="indexterm" id="id1335"/>retrieve this string by using the <code>Exception</code> object’s <code>getMessage()</code> method. Often, though, you can just print the exception object itself to get the message and stack trace.</p>&#13;
&#13;
<p>By <a data-primary="String class" data-secondary="for error messages" data-secondary-sortas="error messages" data-type="indexterm" id="id1336"/>convention, all types of <code>Exception</code> have a <code>String</code> constructor like this. The “Sunspots!” message is whimsical but not very helpful. Normally, you will throw a more specific subclass of <code>Exception</code>, which captures extra details about the fault or at least provides a more useful string explanation. Here’s another example:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">checkRead</code><code class="p">(</code><code class="n">String</code><code class="w"> </code><code class="n">s</code><code class="p">)</code><code class="w"> </code><code class="kd">throws</code><code class="w"> </code><code class="n">SecurityException</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">// ...</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="k">new</code><code class="w"> </code><code class="n">File</code><code class="p">(</code><code class="n">s</code><code class="p">).</code><code class="na">isAbsolute</code><code class="p">()</code><code class="w"> </code><code class="o">||</code><code class="w"> </code><code class="p">(</code><code class="n">s</code><code class="p">.</code><code class="na">indexOf</code><code class="p">(</code><code class="s">".."</code><code class="p">)</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="o">-</code><code class="mi">1</code><code class="p">))</code><code class="w"/>&#13;
<code class="w">      </code><code class="k">throw</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">SecurityException</code><code class="p">(</code><code class="w"/>&#13;
<code class="w">          </code><code class="s">"Access to file : "</code><code class="o">+</code><code class="w"> </code><code class="n">s</code><code class="w"> </code><code class="o">+</code><code class="s">" denied."</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">// ...</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>In this code, we partially implement a method to check for an illegal path. If we find one, we <a data-primary="SecurityException" data-type="indexterm" id="id1337"/>throw a <code>SecurityException</code> with some information about the transgression.</p>&#13;
&#13;
<p>Of course, we could include any other information that is useful in our own specialized subclasses of <code>Exception</code>. Often, though, just having a new type of exception is good enough because it’s sufficient to help direct the flow of control. For example, if we are building a program to read and parse the contents of a web page, we might want to make our own kind of exception to indicate a particular failure:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">class</code> <code class="nc">ParseException</code><code class="w"> </code><code class="kd">extends</code><code class="w"> </code><code class="n">Exception</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">private</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">lineNumber</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="n">ParseException</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="kd">super</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">this</code><code class="p">.</code><code class="na">lineNumber</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">-</code><code class="mi">1</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="n">ParseException</code><code class="p">(</code><code class="n">String</code><code class="w"> </code><code class="n">desc</code><code class="p">,</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">lineNumber</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="kd">super</code><code class="p">(</code><code class="n">desc</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">this</code><code class="p">.</code><code class="na">lineNumber</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">lineNumber</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="kd">public</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="nf">getLineNumber</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="n">lineNumber</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>See <a data-type="xref" href="ch05.html#learnjava6-CHP-5-SECT-3.1">“Constructors”</a> for a full description of classes and class constructors. <a data-primary="ParseException" data-type="indexterm" id="id1338"/>The body of our <code>Exception</code> class here simply allows a <code>ParseException</code> to be created in the conventional ways (either generically or with a little extra information). Now that we have our new exception type, we can guard against any poorly formatted content like this:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="c1">// Get some input from a file and parse it</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">try</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">parseStream</code><code class="p">(</code><code class="n">input</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"> </code><code class="k">catch</code><code class="w"> </code><code class="p">(</code><code class="n">ParseException</code><code class="w"> </code><code class="n">pe</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="c1">// Bad input... We can even tell them which line was bad!</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">System</code><code class="p">.</code><code class="na">err</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="s">"Bad input on line "</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">pe</code><code class="p">.</code><code class="na">getLineNumber</code><code class="p">());</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"> </code><code class="k">catch</code><code class="w"> </code><code class="p">(</code><code class="n">IOException</code><code class="w"> </code><code class="n">ioe</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="c1">// Other, low-level communications problem</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>Even without special information like the line number where our input caused a problem, our custom exception lets us distinguish a parse error from some other I/O error in the same chunk of code.<a data-primary="" data-startref="ix_except_throw" data-type="indexterm" id="id1339"/><a data-primary="" data-startref="ix_java_io_throw" data-type="indexterm" id="id1340"/></p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Chaining and re-throwing exceptions" data-type="sect3"><div class="sect3" id="learnjava6-CHP-6-SECT-1.6.1">&#13;
<h3>Chaining and re-throwing exceptions</h3>&#13;
&#13;
<p>Sometimes you’ll <a data-primary="exception chaining" data-type="indexterm" id="id1341"/><a data-primary="chaining" data-secondary="exceptions" data-type="indexterm" id="id1342"/><a data-primary="re-throwing exceptions" data-type="indexterm" id="id1343"/>want to take some action based on an exception and then turn around and throw a new exception in its place. This is common when building frameworks where low-level detailed exceptions are handled and represented by higher-level exceptions that can be managed more easily. For example, you might want to catch an <code>IOException</code> in a communications package, possibly perform some cleanup, and then throw a higher-level exception of your own, maybe something like <code>LostServerConnection</code>.</p>&#13;
&#13;
<p>You can do this in the obvious way by simply catching the exception and then throwing a new one, but then you lose important information, including the stack trace of the original “causal” exception. To deal with this, you can use the technique of <em>exception chaining</em>. This means that you include the causal exception in the new exception that you throw. Java has explicit support for exception chaining. The base <code>Exception</code> class can be constructed with an exception as an argument or the standard <code>String</code> message and an exception:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="k">throw</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">Exception</code><code class="p">(</code><code class="s">"Here's the story..."</code><code class="p">,</code><code class="w"> </code><code class="n">causalException</code><code class="p">);</code><code class="w"/></pre>&#13;
&#13;
<p>You can get <a data-primary="getCause() method, Exception" data-type="indexterm" id="id1344"/>access to the wrapped exception later with the <code>getCause()</code> method. More importantly, Java automatically prints both exceptions and their respective stack traces if you print the exception or if it is shown to the user.</p>&#13;
&#13;
<p>You can <a data-primary="initCause() method, Throwable" data-type="indexterm" id="id1345"/><a data-primary="Throwable class" data-type="indexterm" id="id1346"/>add this kind of constructor to your own exception subclasses (delegating to the parent constructor). You can also take advantage of this pattern by using the <span class="keep-together"><code>Throwable</code></span> method <code>initCause()</code> to set the causal exception explicitly after constructing your own exception and before throwing it:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="k">try</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="c1">// ...</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"> </code><code class="k">catch</code><code class="w"> </code><code class="p">(</code><code class="n">IOException</code><code class="w"> </code><code class="n">cause</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">Exception</code><code class="w"> </code><code class="n">e</code><code class="w"> </code><code class="o">=</code><code class="w"/>&#13;
<code class="w">        </code><code class="k">new</code><code class="w"> </code><code class="n">IOException</code><code class="p">(</code><code class="s">"What we have here is a failure to communicate..."</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">e</code><code class="p">.</code><code class="na">initCause</code><code class="p">(</code><code class="n">cause</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">      </code><code class="k">throw</code><code class="w"> </code><code class="n">e</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>Sometimes it’s enough to simply do some logging or take some intermediate action and then re-throw the original exception:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="k">try</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="c1">// ...</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"> </code><code class="k">catch</code><code class="w"> </code><code class="p">(</code><code class="n">IOException</code><code class="w"> </code><code class="n">cause</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">log</code><code class="p">(</code><code class="n">cause</code><code class="p">);</code><code class="w"> </code><code class="c1">// Log it</code><code class="w"/>&#13;
<code class="w">      </code><code class="k">throw</code><code class="w"> </code><code class="n">cause</code><code class="p">;</code><code class="w">  </code><code class="c1">// re-throw it</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>You see this pattern crop up when you have exceptions that don’t contain enough information to handle locally. You can do something with what information is available (like printing an error message to help during debugging), but you don’t have enough information to recover from the problem. You have to pass on the exception and hope that some calling method with more resources will know what to do.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="try Creep" data-type="sect2"><div class="sect2" id="learnjava6-CHP-6-SECT-1.7">&#13;
<h2>try Creep</h2>&#13;
&#13;
<p>The <code>try</code> statement imposes a <a data-primary="java.io package" data-secondary="try/catch blocks" data-type="indexterm" id="ix_java_io_try_catch2"/><a data-primary="try/catch blocks" data-type="indexterm" id="ix_try_catch2"/><a data-primary="exceptions" data-secondary="try/catch blocks" data-type="indexterm" id="ix_except_try_catch2"/><a data-primary="java.io package" data-secondary="try creep" data-type="indexterm" id="ix_java_io_try_creep"/><a data-primary="try creep" data-type="indexterm" id="ix_try_creep"/><a data-primary="exceptions" data-secondary="try creep" data-type="indexterm" id="ix_except_try_creep"/>condition on the statements that it guards. It says that if an exception occurs within it, the remaining statements will be abandoned. This has consequences for local variable initialization. If the compiler can’t determine whether a local variable assignment placed inside a <code>try/catch</code> block will happen, it won’t let us use the variable. For example:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">  </code><code class="kt">void</code><code class="w"> </code><code class="nf">myMethod</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="kt">int</code><code class="w"> </code><code class="n">foo</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="w">    </code><code class="k">try</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">foo</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">getResults</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">catch</code><code class="w"> </code><code class="p">(</code><code class="n">Exception</code><code class="w"> </code><code class="n">e</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="c1">// handle our exception ...</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/>&#13;
&#13;
<code class="w">    </code><code class="kt">int</code><code class="w"> </code><code class="n">bar</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">foo</code><code class="p">;</code><code class="w"> </code><code class="c1">// Compile-time error: foo may not have been initialized</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>In this example, we can’t use <code>foo</code> in the indicated place because there’s a chance it was never assigned a value. One option is to move the assignment for <code>bar</code> inside the <code>try</code> statement:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="k">try</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">foo</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">getResults</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">      </code><code class="kt">int</code><code class="w"> </code><code class="n">bar</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">foo</code><code class="p">;</code><code class="w">  </code><code class="c1">// Okay because we get here only</code><code class="w"/>&#13;
<code class="w">                      </code><code class="c1">// if previous assignment succeeds</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">catch</code><code class="w"> </code><code class="p">(</code><code class="n">Exception</code><code class="w"> </code><code class="n">e</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="c1">// handle our exception ...</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>Sometimes this works just fine. However, now we have the same problem if we want to use <code>bar</code> later in <code>myMethod()</code>. If we’re not careful, we might end up pulling everything into the <code>try</code> statement. The situation changes, however, if we transfer control out of the method in the <code>catch</code> clause:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="k">try</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">foo</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">getResults</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">catch</code><code class="w"> </code><code class="p">(</code><code class="n">Exception</code><code class="w"> </code><code class="n">e</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="c1">// log our exception or show the user a warning message</code><code class="w"/>&#13;
<code class="w">      </code><code class="k">return</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">    </code><code class="kt">int</code><code class="w"> </code><code class="n">bar</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">foo</code><code class="p">;</code><code class="w">  </code><code class="c1">// Okay because we get here only</code><code class="w"/>&#13;
<code class="w">                    </code><code class="c1">// if previous try block succeeds</code><code class="w"/></pre>&#13;
&#13;
<p>The compiler is smart enough to know that if an error had occurred in the <code>try</code> clause, we wouldn’t have reached the <code>bar</code> assignment, so it allows us to refer to <code>foo</code>. Your code may have different requirements; we just want you to be aware of the options.<a data-primary="" data-startref="ix_except_try_creep" data-type="indexterm" id="id1347"/><a data-primary="" data-startref="ix_java_io_try_creep" data-type="indexterm" id="id1348"/><a data-primary="" data-startref="ix_try_creep" data-type="indexterm" id="id1349"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The finally Clause" data-type="sect2"><div class="sect2" id="learnjava6-CHP-6-SECT-1.8">&#13;
<h2>The finally Clause</h2>&#13;
&#13;
<p>What if we have <a data-primary="exceptions" data-secondary="finally clause" data-type="indexterm" id="id1350"/><a data-primary="finally clause, exceptions" data-type="indexterm" id="id1351"/><a data-primary="java.io package" data-secondary="finally clause" data-type="indexterm" id="id1352"/>something important to do before we exit our method from one of the <code>catch</code> clauses? To avoid duplicating the code in each <code>catch</code> branch and to make the cleanup more explicit, you can use the <code>finally</code> clause. A <code>finally</code> clause can be added after a <code>try</code> block and its associated <code>catch</code> clauses. Any statements in the body of the <code>finally</code> clause are guaranteed to be executed no matter how control leaves the <code>try</code> body, whether an exception is thrown or not:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="k">try</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="c1">// Do something here</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">catch</code><code class="w"> </code><code class="p">(</code><code class="n">FileNotFoundException</code><code class="w"> </code><code class="n">e</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="c1">// handle a missing file ...</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">catch</code><code class="w"> </code><code class="p">(</code><code class="n">IOException</code><code class="w"> </code><code class="n">e</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="c1">// handle other file problems ...</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">catch</code><code class="w"> </code><code class="p">(</code><code class="n">Exception</code><code class="w"> </code><code class="n">e</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="c1">// eek, handle even bigger problems ...</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">finally</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="c1">// Any cleanup here is always executed</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>In this example, the statements at the cleanup point are executed eventually, no matter how control leaves the <code>try</code>. If control transfers to one of the <code>catch</code> clauses, the statements in <code>finally</code> are executed after the <code>catch</code> completes. If none of the <code>catch</code> clauses handles the exception, the <code>finally</code> statements are executed before the exception propagates to the next level.</p>&#13;
&#13;
<p>Even if the statements in the <code>try</code> execute cleanly, or if we perform a <code>return</code>, <code>break</code>, or <code>continue</code>, the statements in the <code>finally</code> clause are still executed. To guarantee that some operations will run, we can even use <code>try</code> and <code>finally</code> without any <code>catch</code> clauses:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="k">try</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="c1">// Do something here that might cause an exception</code><code class="w"/>&#13;
<code class="w">      </code><code class="k">return</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"> </code><code class="k">finally</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">System</code><code class="p">.</code><code class="na">out</code><code class="p">.</code><code class="na">println</code><code class="p">(</code><code class="s">"Whoo-hoo!"</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>Exceptions that occur in a <code>catch</code> or <code>finally</code> clause are handled normally; the search for an enclosing <code>try/catch</code> begins outside the offending <code>try</code> statement, after the <code>finally</code> has been executed.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="try with Resources" data-type="sect2"><div class="sect2" id="learnjava6-CHP-6-SECT-1.9">&#13;
<h2>try with Resources</h2>&#13;
&#13;
<p>A <a data-primary="java.io package" data-secondary="try with resources" data-type="indexterm" id="ix_java_io_try_res"/><a data-primary="try with resources" data-type="indexterm" id="ix_try_res"/><a data-primary="resources" data-secondary="and finally clause" data-secondary-sortas="finally clause" data-type="indexterm" id="id1353"/><a data-primary="exceptions" data-secondary="try with resources" data-type="indexterm" id="ix_except_try_res"/>common use of the <code>finally</code> clause is to ensure that resources used in a <code>try</code> clause are cleaned up, no matter how the code exits the block. Consider opening a network socket (more on these in <a data-type="xref" href="ch13.html#learnjava6-CHP-13">Chapter 13</a>):</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="k">try</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">Socket</code><code class="w"> </code><code class="n">sock</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">Socket</code><code class="p">(...);</code><code class="w"/>&#13;
<code class="w">      </code><code class="c1">// work with the socket</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"> </code><code class="k">catch</code><code class="p">(</code><code class="n">IOException</code><code class="w"> </code><code class="n">e</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="c1">// handle our network problem ...</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"> </code><code class="k">finally</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">sock</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">null</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">sock</code><code class="p">.</code><code class="na">close</code><code class="p">();</code><code class="w"> </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>What we mean by “cleaning up” here is deallocating expensive resources or closing connections to things such as files, network sockets, or databases. In some cases, these resources might get cleaned up on their own eventually as Java reclaims the garbage, but at best, that would happen at an unknown time in the future. At worst, the cleanup may never happen or may not happen before you run out of resources. You should always guard against these situations.</p>&#13;
&#13;
<p>In the real world, however, there are two problems with staying on top of such resource allocation. First, it requires extra work to carry out a proper cleanup pattern in all of your code, including important things like null checks, as shown in our hypothetical example. Second, if you are juggling multiple resources in a single <code>finally</code> block, you have the possibility of your cleanup code itself throwing an exception (e.g., on <code>close()</code>) and leaving the job unfinished.</p>&#13;
&#13;
<p>The “try with resources” form of the <code>try</code> clause can help. In this extended form, you place one or more resource initialization statements within parentheses after the <code>try</code> keyword. Those resources will automatically be “closed” for you when control leaves the <code>try</code> block:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="k">try</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">Socket</code><code class="w"> </code><code class="n">sock</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">Socket</code><code class="p">(</code><code class="s">"192.168.100.1"</code><code class="p">,</code><code class="w"> </code><code class="mi">80</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">FileWriter</code><code class="w"> </code><code class="n">file</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">FileWriter</code><code class="p">(</code><code class="s">"foo"</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">)</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="c1">// work with sock and file</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"> </code><code class="k">catch</code><code class="w"> </code><code class="p">(</code><code class="n">IOException</code><code class="w"> </code><code class="n">e</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="c1">// ...</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">// Both sock and file have been cleaned up by this point</code><code class="w"/></pre>&#13;
&#13;
<p>In this example, we <a data-primary="FileWriter class" data-type="indexterm" id="id1354"/><a data-primary="Socket object" data-type="indexterm" id="id1355"/>initialize both a <code>Socket</code> object and a <code>FileWriter</code> object within the <code>try</code>-with-resources clause, and we can use them within the body of the <code>try</code> statement. When control leaves the <code>try</code> statement, either after successful completion or because of an exception, Java automatically closes both resources by calling their respective <code>close()</code> methods. Java closes these resources in the <em>reverse of the order</em> in which you constructed them, so you can accommodate any dependencies among them.</p>&#13;
&#13;
<p>Java <a data-primary="AutoCloseable interface" data-type="indexterm" id="id1356"/>supports this behavior for any class that implements the <code>AutoCloseable</code> interface (which, at current count, over one hundred different built-in classes do). The <code>close()</code> method of this interface is prescribed to release all resources associated with the object, and you can implement this easily in your own classes as well. Now when using <code>try</code>-with-resources, we don’t have to add any code specifically to close the file or socket; it is done for us automatically.</p>&#13;
&#13;
<p>Another <a data-primary="close() method" data-secondary="InputStream" data-type="indexterm" id="id1357"/>problem that <code>try</code>-with-resources solves is the pesky situation where an exception is thrown during a close operation. Looking back to the prior example in which we used a <code>finally</code> clause to do our cleanup, if an exception had been raised by the <code>close()</code> method, the new exception would have been thrown at that point, completely abandoning the original exception from the body of the <code>try</code> clause. But <code>try</code>-with-resources preserves the original exception. If an exception occurs within the body of the <code>try</code> and one or more exceptions are raised during the subsequent auto-closing operations, it is the original exception from the body of the <code>try</code> that will bubble up to the caller. Let’s look at an example:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="k">try</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">      </code><code class="c1">// potential exception #3</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">Socket</code><code class="w"> </code><code class="n">sock</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">Socket</code><code class="p">(</code><code class="s">"192.168.100.1"</code><code class="p">,</code><code class="w"> </code><code class="mi">80</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">      </code><code class="c1">// potential exception #2</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">FileWriter</code><code class="w"> </code><code class="n">file</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">FileWriter</code><code class="p">(</code><code class="s">"foo"</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">)</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="c1">// work with sock and file // potential exception #1</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>Once the <code>try</code> has begun, if an exception occurs at exception point #1, <a data-primary="getSuppressed() method, Socket" data-type="indexterm" id="id1358"/>Java will attempt to close both resources in reverse order, leading to potential exceptions at locations #2 and #3. In this case, the calling code will still receive exception #1. Exceptions #2 and #3 are not lost, however; they are merely “suppressed.” You can retrieve them via the <code>getSuppressed()</code> method of the exception thrown to the caller. This method returns an array of all of the suppressed exceptions.<a data-primary="" data-startref="ix_except_ch6" data-type="indexterm" id="id1359"/><a data-primary="" data-startref="ix_except_try_catch2" data-type="indexterm" id="id1360"/><a data-primary="" data-startref="ix_java_io_try_catch2" data-type="indexterm" id="id1361"/><a data-primary="" data-startref="ix_try_catch2" data-type="indexterm" id="id1362"/><a data-primary="" data-startref="ix_except_try_res" data-type="indexterm" id="id1363"/><a data-primary="" data-startref="ix_java_io_try_res" data-type="indexterm" id="id1364"/><a data-primary="" data-startref="ix_try_res" data-type="indexterm" id="id1365"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Performance Issues" data-type="sect2"><div class="sect2" id="learnjava6-CHP-6-SECT-1.10">&#13;
<h2>Performance Issues</h2>&#13;
&#13;
<p>Because of the way the <a data-primary="exceptions" data-secondary="performance issues" data-type="indexterm" id="id1366"/><a data-primary="java.io package" data-secondary="performance issues" data-type="indexterm" id="id1367"/><a data-primary="performance" data-secondary="exceptions" data-type="indexterm" id="id1368"/>Java VM is implemented, using a <code>try</code> block to guard against an exception being thrown is free, meaning it doesn’t add any overhead to the execution of your code. However, throwing an exception is not free. When an exception is thrown, Java has to locate the appropriate <code>try/catch</code> block and perform other time-consuming activities at runtime.</p>&#13;
&#13;
<p>That’s why you should <a data-primary="throwing exceptions" data-type="indexterm" id="id1369"/>throw exceptions only in truly “exceptional” circumstances and avoid using them for expected conditions, especially when performance is an issue. For example, if you have a loop, it may be better to perform a small test on each pass and avoid a <code>try</code> block rather than potentially throwing an exception several times over the run of the loop. On the other hand, if the exception is thrown only once in a gazillion times, you may want to eliminate the overhead of your small checks and not worry about the cost of throwing that very rare exception. The general rule should be that exceptions are used for abnormal situations, not routine or expected conditions (such as the end of a file or a missing web resource).</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Assertions" data-type="sect1"><div class="sect1" id="learnjava6-CHP-6-SECT-2">&#13;
<h1>Assertions</h1>&#13;
&#13;
<p>Java supports <a data-primary="error handling" data-secondary="assertions" data-type="indexterm" id="ix_error_assertions_ch6"/><a data-primary="assertions" data-type="indexterm" id="ix_assertions_ch6"/>assertions as another mechanism for validating the state of your program. An <em>assertion</em> is a simple pass/fail test of some condition, performed while your application is running. You can use assertions to “sanity check” your code. Assertions are distinct from other kinds of tests because they check conditions that should never be violated at a logical level: if the assertion fails, it means some code you wrote is not doing its job and the application generally halts with an appropriate error message. Assertions are supported directly by the Java language, and they can be turned on or off at runtime to remove any performance penalty associated with including them in your code.</p>&#13;
&#13;
<p>Using assertions to test for the correct behavior of your application is a simple but powerful technique for ensuring software quality. It fills a gap between those aspects of software that the compiler can check automatically and those more generally checked by “unit tests” or human testing. Assertions test your own assumptions about program behavior and turn those assumptions into guarantees (at least while assertions are activated).</p>&#13;
&#13;
<p>If you have programmed before, you may have seen something like the following:<sup><a data-type="noteref" href="ch06.html#id1370" id="id1370-marker">3</a></sup></p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="o">!</code><code class="n">condition</code><code class="p">)</code><code class="w"/>&#13;
<code class="w">      </code><code class="k">throw</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">AssertionError</code><code class="p">(</code><code class="s">"fatal error: 42"</code><code class="p">);</code><code class="w"/></pre>&#13;
&#13;
<p>An <a data-primary="assert keyword" data-type="indexterm" id="id1371"/><a data-primary="AssertionError type" data-type="indexterm" id="id1372"/>assertion in Java is equivalent to this example, but you use the <code>assert</code> keyword. It takes a Boolean condition and an optional expression value. If the assertion fails, an <code>AssertionError</code> is thrown, which usually causes Java to bail out of the application. The idea behind bailing out is that an assertion failure reveals a logical flaw in your code—and it is your responsibility as the programmer to find and fix that flaw.</p>&#13;
&#13;
<p>The optional expression may evaluate to either a primitive value or object type. Either way, its sole purpose is to be turned into a string and shown to the user if the assertion fails. Most often you’ll use a string message explicitly. Here are some examples:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="k">assert</code><code class="w"> </code><code class="kc">false</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">assert</code><code class="w"> </code><code class="p">(</code><code class="n">array</code><code class="p">.</code><code class="na">length</code><code class="w"> </code><code class="o">&gt;</code><code class="w"> </code><code class="n">min</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">assert</code><code class="w"> </code><code class="n">a</code><code class="w"> </code><code class="o">&gt;</code><code class="w"> </code><code class="mi">0</code><code class="w"> </code><code class="p">:</code><code class="w"> </code><code class="n">a</code><code class="w">  </code><code class="c1">// shows value of a to the user</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">assert</code><code class="w"> </code><code class="n">foo</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">null</code><code class="w"> </code><code class="p">:</code><code class="w">  </code><code class="s">"foo is null!"</code><code class="w"> </code><code class="c1">// shows message "foo is null!" to user</code><code class="w"/></pre>&#13;
&#13;
<p>In the event of failure, the first two assertions print only a generic message. The third prints the value of <code>a</code>, and the last prints the <code>foo is null!</code> message.</p>&#13;
&#13;
<p>The <a data-primary="if condition versus assertion" data-type="indexterm" id="id1373"/>important thing about assertions is not just that they are more terse than the equivalent <code>if</code> condition, but that you can enable or disable them when you run the application. Disabling assertions means that their test conditions are not even evaluated, so there is no performance penalty for including them in your code (other than, perhaps, still consuming a small bit of space in the class files when they are loaded).</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Enabling and Disabling Assertions" data-type="sect2"><div class="sect2" id="learnjava6-CHP-6-SECT-2.1">&#13;
<h2>Enabling and Disabling Assertions</h2>&#13;
&#13;
<p>You turn assertions on or off at runtime. When disabled, assertions still exist in the class files but are not executed and do not consume CPU time. You can enable and disable assertions for an entire application, package by package, or even class by class. Remember, assertions are meant to be sanity checks for <em>you</em> during development. They are not usually meant to be seen by your end users. Using them as you work on your project but disabling them for “production” is a common tactic.</p>&#13;
&#13;
<p>By default, <a data-primary="-enableassertions (or -ea) flag" data-primary-sortas="enableassertions (or -ea) flag" data-type="indexterm" id="id1374"/><a data-primary="java command" data-type="indexterm" id="id1375"/>assertions are turned off in Java. To enable them for your code, use the <code>java</code> command flag <code>-ea</code> or <code>-enableassertions</code>:</p>&#13;
&#13;
<pre data-type="programlisting">% java -ea MyApplication</pre>&#13;
&#13;
<p>To turn on assertions for a particular class, append the class name:</p>&#13;
&#13;
<pre data-type="programlisting">% java -ea:com.oreilly.examples.Myclass MyApplication</pre>&#13;
&#13;
<p>To turn on assertions just for particular packages, append the package name with trailing ellipses (…​):</p>&#13;
&#13;
<pre data-type="programlisting">% java -ea:com.oreilly.examples... MyApplication</pre>&#13;
&#13;
<p>When you enable assertions for a package, Java also enables all subordinate package names (e.g., <code>com.oreilly.examples.text</code>). However, you can be more selective by using the corresponding <code>-da</code> or <code>-disableassertions</code> flag to negate individual packages or classes. You can combine all this to achieve arbitrary groupings, like this:</p>&#13;
&#13;
<pre data-type="programlisting">% java -ea:com.oreilly.examples... \&#13;
    -da:com.oreilly.examples.text \&#13;
    -ea:com.oreilly.examples.text.MonkeyTypewriters \&#13;
    MyApplication</pre>&#13;
&#13;
<p>This example enables assertions for the <code>com.oreilly.examples</code> package as a whole, excludes the package <code>com.oreilly.examples.text</code>, but then turns exceptions on for the <code>MonkeyTypewriters</code> class in that package.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using Assertions" data-type="sect2"><div class="sect2" id="learnjava6-CHP-6-SECT-2.2">&#13;
<h2>Using Assertions</h2>&#13;
&#13;
<p>An assertion enforces a rule about something that should be stable in your code and would otherwise go unchecked. You can use an assertion for added safety <span class="keep-together">anywhere</span> you want to verify your assumptions about program behavior that the compiler may not be able to check.</p>&#13;
&#13;
<p>A common situation that cries out for an assertion is testing for multiple conditions or values where one should always be found. In this case, a failing assertion as the default or “fall through” behavior indicates the code is broken. For example, suppose we have a value called <code>direction</code> that should always contain one of two constants, <code>LEFT</code> or <code>RIGHT</code>:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">direction</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="n">LEFT</code><code class="p">)</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">goLeft</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">else</code><code class="w"> </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">direction</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="n">RIGHT</code><code class="p">)</code><code class="w"/>&#13;
<code class="w">      </code><code class="n">goRight</code><code class="p">()</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">else</code><code class="w"/>&#13;
<code class="w">      </code><code class="k">assert</code><code class="w"> </code><code class="kc">false</code><code class="w"> </code><code class="p">:</code><code class="w"> </code><code class="s">"bad direction"</code><code class="p">;</code><code class="w"/></pre>&#13;
&#13;
<p>The same applies to the default case of a switch:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="w">    </code><code class="k">switch</code><code class="w"> </code><code class="p">(</code><code class="n">direction</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="k">case</code><code class="w"> </code><code class="n">LEFT</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">        </code><code class="n">goLeft</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">        </code><code class="k">break</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">      </code><code class="k">case</code><code class="w"> </code><code class="n">RIGHT</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">        </code><code class="n">goRight</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">        </code><code class="k">break</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">      </code><code class="k">default</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">        </code><code class="k">assert</code><code class="w"> </code><code class="kc">false</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>In general, you should not use <a data-primary="postconditions, method" data-type="indexterm" id="id1376"/><a data-primary="preconditions, method" data-type="indexterm" id="id1377"/>assertions for checking the validity of arguments to methods. You want that validating behavior to be part of your application, not just a quality control test that can be turned off. Methods require valid input as part of their <em>preconditions</em>, and you should usually throw an exception if any preconditions are not met. Using exceptions elevates the preconditions to part of the method’s “contract” with the user. However, checking the correctness of the results of your methods with assertions before returning them can be useful. These wrap-up checks are called <em>postconditions</em>.</p>&#13;
&#13;
<p>Sometimes determining what is or is not a precondition depends on your point of view. For example, when a method is used internally within a class, its preconditions may already be guaranteed by the methods that call it. Public methods of the class should probably throw exceptions when their preconditions are violated, but a private method might use assertions because its callers are always closely related code that should obey the correct behavior.<a data-primary="" data-startref="ix_assertions_ch6" data-type="indexterm" id="id1378"/><a data-primary="" data-startref="ix_error_assertions_ch6" data-type="indexterm" id="id1379"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Real-World Exceptions" data-type="sect1"><div class="sect1" id="learnjava6-CHP-6-SECT-3">&#13;
<h1>Real-World Exceptions</h1>&#13;
&#13;
<p>Java’s <a data-primary="real-world exceptions" data-type="indexterm" id="id1380"/><a data-primary="exceptions" data-secondary="real-world" data-type="indexterm" id="id1381"/><a data-primary="java.io package" data-secondary="real-world exceptions" data-type="indexterm" id="id1382"/>adoption of exceptions as an error-handling technique makes it much simpler for developers to write robust code. The compiler forces you to think about checked exceptions ahead of time. Unchecked exceptions will definitely pop up, but assertions can help you watch out for those runtime problems and hopefully prevent a crash.</p>&#13;
&#13;
<p>The try-with-resources feature makes it even simpler for developers to keep their code clean and “do the right thing” when interacting with limited system resources, such as files and network connections. As we noted at the beginning of the chapter, other languages certainly have facilities or customs for dealing with these problems. Java, as a language, works hard to help you thoughtfully consider issues that can arise in your code. The more you work through resolving those issues, the more stable your application (and the happier your users) will be.</p>&#13;
&#13;
<p>Many of our examples so far have been straightforward and have not really required any fancy error checking. Rest assured we’ll be exploring more interesting code with, many things that merit exception handling. Later chapters will cover topics like multithreaded programming and networking. Those topics are rife with situations that can go wrong at runtime, such as a big calculation running amok or a WiFi connection dropping. Pardon the pun, but you’ll be <code>try</code>ing all of these new exception tricks soon enough!</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Review Questions" data-type="sect2"><div class="sect2" id="learnjava6-CHP-6-SECT-3.1">&#13;
<h2>Review Questions</h2>&#13;
<ol>&#13;
<li>&#13;
<p>What statement should you use to manage potential exceptions in your code?</p>&#13;
</li>&#13;
<li>&#13;
<p>Which exceptions does the compiler require you to handle or throw?</p>&#13;
</li>&#13;
<li>&#13;
<p>Where do you place any cleanup code that you want to always run after using some resources in a <code>try</code> block?</p>&#13;
</li>&#13;
<li>&#13;
<p>Do assertions have much of a performance penalty when they are disabled?</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Code Exercises" data-type="sect2"><div class="sect2" id="learnjava6-CHP-6-SECT-3.2">&#13;
<h2>Code Exercises</h2>&#13;
<ol>&#13;
<li>&#13;
<p>The <em>Pause.java</em> program in the <em>ch06/exercises</em> folder will not compile. It uses a method, <code>Thread.sleep()</code>, to pause the program for five seconds. That <code>sleep()</code> method can throw a checked exception. Fix the program so it compiles and runs. (We’ll be seeing more of threads and <code>Thread.sleep()</code> in <a data-type="xref" href="ch09.html#learnjava6-CHP-9">Chapter 9</a>.)</p>&#13;
</li>&#13;
<li>&#13;
<p>The exercises include another variation of our “Hello, World” program from <a data-type="xref" href="ch02.html#learnjava6-CHP-2">Chapter 2</a> called <code>HelloZero</code>. Use an assertion to make sure that the initial x and y coordinates for the graphical message are greater than zero.</p>&#13;
&#13;
<p>Try running the program and enabling assertions. What happens if you assign a negative number to one of the coordinates? Run the program again but leave assertions disabled. (Recall that “disabled” is the default behavior, so just don’t enable them.) What happens in this case?</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="Advanced Exercises" data-type="sect2"><div class="sect2" id="learnjava6-CHP-6-SECT-3.3">&#13;
<h2>Advanced Exercises</h2>&#13;
<ol>&#13;
<li>&#13;
<p>Let’s pretend that a greatest common denominator (GCD) of 1 is an error condition that we need to flag. Create a new class, <code>Euclid3</code> , that will do the usual work of finding the GCD but will throw an exception if that common denominator is 1. (Feel free to start by copying any of your other Euclidean classes.) Create a custom exception class called <code>GCDException</code> that stores the offending pair of numbers as details of the exception.<a data-primary="" data-startref="ix_error_handling_ch6" data-type="indexterm" id="id1383"/></p>&#13;
&#13;
<p>Modify <code>Euclid3</code> to test for a GCD of 1 and throw your new <code>GCDException</code> if that is the result. (Supplying two prime numbers is a quick way to guarantee a result of 1.)</p>&#13;
&#13;
<p>Before you add any exception handling code, try compiling. Did <em>javac</em> warn you about the exception? It should! Go ahead and add a <code>try/catch</code> guard or edit the definition of <code>main()</code> to throw your exception. If you do handle the new exception, be sure to print a nice error message to the user that includes the “bad” numbers from the caught exception.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
</div></section>&#13;
</div></section>&#13;
<div data-type="footnotes"><p data-type="footnote" id="id1273"><sup><a href="ch06.html#id1273-marker">1</a></sup> The somewhat obscure <code>setjmp()</code> and <code>longjmp()</code> statements in C can save a point in the execution of code and later return to it unconditionally from a deeply buried location. In a limited sense, this is the functionality of exceptions in Java that we explore in this chapter.</p><p data-type="footnote" id="id1274"><sup><a href="ch06.html#id1274-marker">2</a></sup> For example, the <code>getHeight()</code> method of the AWT <code>Image</code> class returns <code>-1</code> if the height isn’t known yet. No error has occurred; the height will be available once the image is loaded. In this situation, throwing an exception would be excessive and could impact performance.</p><p data-type="footnote" id="id1370"><sup><a href="ch06.html#id1370-marker">3</a></sup> If you have done some programming, we hope your error messages are not this opaque! The more helpful and explanatory your messages, the better.</p></div></div></section></body></html>