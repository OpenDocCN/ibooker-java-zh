<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 5. Configuring and Inspecting &#10;Your Spring Boot App"><div class="chapter" id="sbur-05">
<h1><span class="label">Chapter 5. </span>Configuring and Inspecting 
<span class="keep-together">Your Spring Boot App</span></h1>


<p><a data-type="indexterm" data-primary="configuration" id="ix_config_ch5"/>There are many things that can go wrong with any application, and some of these many things may even have simple solutions. With the rare exception of an occasional good guess, however, one must determine the root cause of a problem before it is possible to truly solve it.</p>

<p><a data-type="indexterm" data-primary="debugging" id="idm45693962786296"/>Debugging Java or Kotlin applications—or any other applications, for that matter—is a fundamental skill that every developer should learn very early on in their career and refine and expand throughout. I don’t find that to be the case universally, so if you haven’t already become handy with the debugging capabilities of your language and tools of choice, please explore the options at your disposal as soon as possible. It really is important in everything you develop and can save you inordinate amounts of time.</p>

<p>That said, debugging code is only one level of establishing, identifying, and isolating behaviors manifested within your application. As applications become more dynamic and distributed, developers often need to do the following:</p>

<ul>
<li>
<p>Configure and reconfigure applications dynamically</p>
</li>
<li>
<p>Determine/confirm current settings and their origins</p>
</li>
<li>
<p>Inspect and monitor application environment and health indicators</p>
</li>
<li>
<p>Temporarily adjust logging levels of live apps to identify root causes</p>
</li>
</ul>

<p>This chapter demonstrates how to use Spring Boot’s built-in configuration capabilities, its Autoconfiguration Report, and Spring Boot Actuator to create, identify, and modify application environment settings flexibly and dynamically.</p>
<div data-type="tip"><h1>Code Checkout Checkup</h1>
<p>Please check out branch <em>chapter5begin</em> from the code repository to begin.</p>
</div>






<section data-type="sect1" data-pdf-bookmark="Application Configuration"><div class="sect1" id="idm45693962777688">
<h1>Application Configuration</h1>

<p>No app is an island.</p>

<p>Most times when I say that, it’s to point out the truism that in nearly every case, an application doesn’t provide all of its utility without interaction with other applications/services. But there is another meaning that is just as true: no application can be as useful without access to its environment, in one form or another. A static, unconfigurable app is rigid, inflexible, and hobbled.</p>

<p>Spring Boot applications supply a variety of powerful mechanisms for developers to dynamically configure and reconfigure their applications, even while the app is running. <a data-type="indexterm" data-primary="Spring Environment" id="idm45693962774472"/>These mechanisms leverage the Spring <code>Environment</code> to manage configuration properties from all sources, including the following:</p>

<ul>
<li>
<p>Spring Boot Developer Tools (devtools) global settings properties in the <em>$HOME/.config/spring-boot</em> directory when devtools is active.</p>
</li>
<li>
<p><code>@TestPropertySource</code> annotations on tests.</p>
</li>
<li>
<p><code>properties</code> attribute on tests, available on <code>@SpringBootTest</code> and the various test annotations for testing an application slice.</p>
</li>
<li>
<p>Command line arguments.</p>
</li>
<li>
<p>Properties from <code>SPRING_APPLICATION_JSON</code> (inline JSON embedded in an environment variable or system property).</p>
</li>
<li>
<p><code>ServletConfig</code> init parameters.</p>
</li>
<li>
<p><code>ServletContext</code> init parameters.</p>
</li>
<li>
<p>JNDI attributes from <em>java:comp/env</em>.</p>
</li>
<li>
<p>Java System properties (<code>System.getProperties()</code>).</p>
</li>
<li>
<p>OS environment variables.</p>
</li>
<li>
<p>A <code>RandomValuePropertySource</code> that has properties only in <code>random.*</code>.</p>
</li>
<li>
<p>Profile-specific application properties outside of the packaged jar (<em>application-{profile}.properties</em> and YAML variants).</p>
</li>
<li>
<p>Profile-specific application properties packaged inside the jar (<em>application-{profile}.properties</em> and YAML variants).</p>
</li>
<li>
<p>Application properties outside of the packaged jar (<em>application.properties</em> and YAML variants).</p>
</li>
<li>
<p>Application properties packaged inside the jar (<em>application.properties</em> and YAML variants).</p>
</li>
<li>
<p><code>@PropertySource</code> annotations on <code>@Configuration</code> classes; note that such property sources are not added to the Environment until the application context is refreshed, which is too late to configure certain properties read before refresh begins, such as <code>logging.*</code> and <code>spring.main.*</code>.</p>
</li>
<li>
<p>Default properties specified by setting <code>SpringApplication.setDefaultProperties</code>.
NOTE: The preceding property sources are listed in decreasing order of precedence: properties from sources higher in the list supersede identical properties from lower sources.<sup><a data-type="noteref" id="idm45693962724088-marker" href="ch05.xhtml#idm45693962724088">1</a></sup></p>
</li>
</ul>

<p>All of these can be extremely useful, but I’ll choose a few in particular for the code scenarios in this chapter:</p>

<ul>
<li>
<p>Command line arguments</p>
</li>
<li>
<p>OS environment variables</p>
</li>
<li>
<p>Application properties packaged inside the jar (<em>application.properties</em> and YAML variants)</p>
</li>
</ul>

<p>Let’s begin with properties defined in the app’s <em>application.properties</em> file and work our way up the food chain.</p>








<section data-type="sect2" data-pdf-bookmark="@Value"><div class="sect2" id="idm45693962717736">
<h2>@Value</h2>

<p><a data-type="indexterm" data-primary="@Value" id="ix_value_config"/><a data-type="indexterm" data-primary="configuration" data-secondary="@Value" id="ix_config_value"/>The <code>@Value</code> annotation is perhaps the most straightforward approach to ingesting configuration settings into your code. <a data-type="indexterm" data-primary="SpEL (Spring Expression Language)" id="idm45693962713016"/>Built around pattern-matching and the Spring Expression Language (SpEL), it’s simple and powerful.</p>

<p>I’ll start by defining a single property in our application’s <em>application.properties</em> file, as shown in <a data-type="xref" href="#defining_greetingname_in_application_properties">Figure 5-1</a>.</p>

<figure><div id="defining_greetingname_in_application_properties" class="figure">
<img src="Images/sbur_0501.png" alt="sbur 0501" width="454" height="140"/>
<h6><span class="label">Figure 5-1. </span>Defining <code>greeting-name</code> in application.properties</h6>
</div></figure>

<p><a data-type="indexterm" data-primary="@RestController" id="idm45693962707480"/>To show how to put this property to use, I create an additional <code>@RestController</code> within the application to handle tasks related to greeting application users, as demonstrated in <a data-type="xref" href="#greetings_restcontroller_class">Figure 5-2</a>.</p>

<figure><div id="greetings_restcontroller_class" class="figure">
<img src="Images/sbur_0502.png" alt="sbur 0502" width="600" height="419"/>
<h6><span class="label">Figure 5-2. </span>Greeting <code>@RestController</code> class</h6>
</div></figure>

<p>Note that the <code>@Value</code> annotation applies to the <code>name</code> member variable and accepts a single parameter of type <code>String</code> called <code>value</code>. <a data-type="indexterm" data-primary="SpEL (Spring Expression Language)" id="idm45693962700264"/>I define the <code>value</code> using SpEL, placing the variable name (as the expression to evaluate) between the delimiters <code>${</code> and <code>}</code>. One other thing of note: SpEL allows for a default value after the colon—in this example, “Mirage”—for cases in which the variable isn’t defined in the app <code>Environment</code>.</p>

<p>Upon executing the application and querying the <em>/greeting</em> endpoint, the app responds with “Dakota” as expected, shown in <a data-type="xref" href="#greeting_response_with_defined_property_value">Figure 5-3</a>.</p>

<figure><div id="greeting_response_with_defined_property_value" class="figure">
<img src="Images/sbur_0503.png" alt="sbur 0503" width="600" height="220"/>
<h6><span class="label">Figure 5-3. </span>Greeting response with defined property value</h6>
</div></figure>

<p>To verify the default value is being evaluated, I comment out the following line in <em>application.properties</em> with a <code>#</code> as follows and restart the application:</p>

<pre data-type="programlisting">#greeting-name=Dakota</pre>

<p>Querying the <em>greeting</em> endpoint now results in the response shown in <a data-type="xref" href="#greeting_repsonse_with_default_value">Figure 5-4</a>. Since <code>greeting-name</code> is no longer defined in any source for the application’s <code>Environment</code>, the default value of “Mirage” kicks in, as expected.</p>

<figure><div id="greeting_repsonse_with_default_value" class="figure">
<img src="Images/sbur_0504.png" alt="sbur 0504" width="600" height="220"/>
<h6><span class="label">Figure 5-4. </span>Greeting response with default value</h6>
</div></figure>

<p>Using <code>@Value</code> with roll-your-own properties provides another useful capability: the value of one property can be derived/built using the value of another.</p>

<p>To demonstrate how property nesting works, we’ll need at least two properties. I create a second property <code>greeting-coffee</code> in <em>application.properties</em>, as in <a data-type="xref" href="#property_value_feeding_another_property">Figure 5-5</a>.</p>

<figure><div id="property_value_feeding_another_property" class="figure">
<img src="Images/sbur_0505.png" alt="sbur 0505" width="600" height="103"/>
<h6><span class="label">Figure 5-5. </span>Property value feeding another property</h6>
</div></figure>

<p>Next, I add a bit of code to our <code>GreetingController</code> to represent a coffee-fied greeting and an endpoint we can access to see the results. Note that I provide a default value for <code>coffee</code>’s value as well, per <a data-type="xref" href="#adding_a_coffee_greeting_to_greetingcontroller">Figure 5-6</a>.</p>

<figure><div id="adding_a_coffee_greeting_to_greetingcontroller" class="figure">
<img src="Images/sbur_0506.png" alt="sbur 0506" width="600" height="389"/>
<h6><span class="label">Figure 5-6. </span>Adding a coffee greeting to <code>GreetingController</code></h6>
</div></figure>

<p>To verify the proper outcome, I restart the application and query the new <em>/greeting/coffee</em> endpoint, resulting in the output shown in <a data-type="xref" href="#querying_the_coffee_greeting_endpoint">Figure 5-7</a>. Note that since both properties in question are defined in <em>application.properties</em>, the values displayed are consistent with those values’ definitions.</p>

<figure><div id="querying_the_coffee_greeting_endpoint" class="figure">
<img src="Images/sbur_0507.png" alt="sbur 0507" width="600" height="214"/>
<h6><span class="label">Figure 5-7. </span>Querying the coffee greeting endpoint</h6>
</div></figure>

<p>As with all things in life and software development, <code>@Value</code> does have some limitations. Since we provided a default value for the <code>greeting-coffee</code> property, we can comment out its definition in <em>application.properties</em>, and the <code>@Value</code> annotation still properly processes its (default) value using the <code>coffee</code> member variable within <code>GreetingController</code>. However, commenting out both <code>greeting-name</code> and <code>greeting-coffee</code> in the properties file results in no <code>Environment</code> source actually defining them, further resulting in the following error when the application attempts to initialize the <code>GreetingController</code> bean using a reference to (now-undefined) <code>greeting-name</code> within <code>greeting-coffee</code>:</p>

<pre data-type="programlisting">org.springframework.beans.factory.BeanCreationException:
    Error creating bean with name 'greetingController':
        Injection of autowired dependencies failed; nested exception is
        java.lang.IllegalArgumentException:
            Could not resolve placeholder 'greeting-name' in value
            "greeting-coffee: ${greeting-name} is drinking Cafe Ganador"</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Full stacktrace removed for brevity and clarity.</p>
</div>

<p>Another limitation with properties defined in <em>application.properties</em> and used solely via <code>@Value</code>: they aren’t recognized by the IDE as being used by the application, as they’re only referenced in the code within quote-delimited <code>String</code> variables; as such, there is no direct tie-in to code. Of course, developers can visually check for correct spelling of property names and usage, but this is entirely manual and thus more prone to error.</p>

<p>As you might imagine, a typesafe and tool-verifiable mechanism for property use and definition would be a better all-around option.<a data-type="indexterm" data-primary="" data-startref="ix_config_value" id="idm45693962661368"/><a data-type="indexterm" data-primary="" data-startref="ix_value_config" id="idm45693962660392"/></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="@ConfigurationProperties"><div class="sect2" id="idm45693962716792">
<h2>@ConfigurationProperties</h2>

<p><a data-type="indexterm" data-primary="@ConfigurationProperties" id="ix_config_prop"/>Appreciating the flexibility of <code>@Value</code> but recognizing its shortcomings, the Spring team created <code>@ConfigurationProperties</code>. Using <code>@ConfigurationProperties</code>, a developer can define properties, group related properties, and reference/use them in a tool-verifiable and typesafe way.</p>

<p>For example, if a property is defined in an app’s <em>application.properties</em> file that isn’t used in code, the developer will see the name highlighted to flag it as a confirmed unused property. Similarly, if the property is defined as a <code>String</code> but associated with a differently typed member variable, the IDE will point out the type mismatch. These are valuable helps that catch simple, but frequent, mistakes.</p>

<p><a data-type="indexterm" data-primary="POJO (plain old Java object)" id="idm45693962653416"/>To demonstrate how to put <code>@ConfigurationProperties</code> to work, I’ll start by defining a POJO to encapsulate the desired related properties: in this case, our <code>greeting-name</code> and <code>greeting-coffee</code> properties previously referenced. As shown in the code that follows, I create a <code>Greeting</code> class to hold both:</p>

<pre data-type="programlisting" data-code-language="java"><code class="kd">class</code> <code class="nc">Greeting</code> <code class="o">{</code>
    <code class="kd">private</code> <code class="n">String</code> <code class="n">name</code><code class="o">;</code>
    <code class="kd">private</code> <code class="n">String</code> <code class="n">coffee</code><code class="o">;</code>

    <code class="kd">public</code> <code class="n">String</code> <code class="nf">getName</code><code class="o">()</code> <code class="o">{</code>
        <code class="k">return</code> <code class="n">name</code><code class="o">;</code>
    <code class="o">}</code>

    <code class="kd">public</code> <code class="kt">void</code> <code class="nf">setName</code><code class="o">(</code><code class="n">String</code> <code class="n">name</code><code class="o">)</code> <code class="o">{</code>
        <code class="k">this</code><code class="o">.</code><code class="na">name</code> <code class="o">=</code> <code class="n">name</code><code class="o">;</code>
    <code class="o">}</code>

    <code class="kd">public</code> <code class="n">String</code> <code class="nf">getCoffee</code><code class="o">()</code> <code class="o">{</code>
        <code class="k">return</code> <code class="n">coffee</code><code class="o">;</code>
    <code class="o">}</code>

    <code class="kd">public</code> <code class="kt">void</code> <code class="nf">setCoffee</code><code class="o">(</code><code class="n">String</code> <code class="n">coffee</code><code class="o">)</code> <code class="o">{</code>
        <code class="k">this</code><code class="o">.</code><code class="na">coffee</code> <code class="o">=</code> <code class="n">coffee</code><code class="o">;</code>
    <code class="o">}</code>
<code class="o">}</code></pre>

<p>In order to register <code>Greeting</code> to manage configuration properties, I add the <code>@ConfigurationProperties</code> annotation shown in <a data-type="xref" href="#annotation_and_error">Figure 5-8</a> and specify the <code>prefix</code> to use for all <code>Greeting</code> properties. This annotation prepares the class for use only with configuration properties; the application also must be told to process classes annotated in such manner for properties to include in the application <code>Environment</code>. Note the helpful error message that results:</p>

<figure><div id="annotation_and_error" class="figure">
<img src="Images/sbur_0508.png" alt="sbur 0508" width="600" height="382"/>
<h6><span class="label">Figure 5-8. </span>Annotation and error</h6>
</div></figure>

<p>Instructing the application to process <code>@ConfigurationProperties</code> classes and add their properties to the app’s <code>Environment</code> is, in most cases, best accomplished by adding the <code>@ConfigurationPropertiesScan</code> annotation to the main application class, as demonstrated here:</p>

<pre data-type="programlisting" data-code-language="java"><code class="nd">@SpringBootApplication</code>
<code class="nd">@ConfigurationPropertiesScan</code>
<code class="kd">public</code> <code class="kd">class</code> <code class="nc">SburRestDemoApplication</code> <code class="o">{</code>

    <code class="kd">public</code> <code class="kd">static</code> <code class="kt">void</code> <code class="nf">main</code><code class="o">(</code><code class="n">String</code><code class="o">[]</code> <code class="n">args</code><code class="o">)</code> <code class="o">{</code>
        <code class="n">SpringApplication</code><code class="o">.</code><code class="na">run</code><code class="o">(</code><code class="n">SburRestDemoApplication</code><code class="o">.</code><code class="na">class</code><code class="o">,</code> <code class="n">args</code><code class="o">);</code>
    <code class="o">}</code>

<code class="o">}</code></pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The exceptions to the rule of having Boot scan for <code>@ConfigurationProperties</code> classes are if you need to enable certain <code>@ConfigurationProperties</code> classes conditionally or if you are creating your own autoconfiguration. In all other cases, however, <code>@ConfigurationPropertiesScan</code> should be used to scan for and enable <code>@ConfigurationProperties</code> classes in like manner to Boot’s component scanning mechanism.</p>
</div>

<p>In order to generate metadata using the annotation processor, enabling the IDE to connect the dots between <code>@ConfigurationProperties</code> classes and related properties defined in the <em>application.properties</em> file, I add the following dependency to the project’s <em>pom.xml</em> build file:</p>

<pre data-type="programlisting">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;
    &lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt;</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>This dependency also can be selected and added automatically from the Spring Initializr at the time of project creation.</p>
</div>

<p><a data-type="indexterm" data-primary="IntelliJ IDEA" id="idm45693962559896"/>Once the configuration processor dependency is added to the build file, it’s necessary to refresh/reimport the dependencies and rebuild the project to take advantage of them. To reimport deps, I open the Maven menu in IntelliJ and click the Reimport button at the top left, as shown in <a data-type="xref" href="#reimporting_project_dependencies">Figure 5-9</a>.</p>

<figure><div id="reimporting_project_dependencies" class="figure">
<img src="Images/sbur_0509.png" alt="sbur 0509" width="600" height="275"/>
<h6><span class="label">Figure 5-9. </span>Reimporting project dependencies</h6>
</div></figure>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Unless the option is disabled, IntelliJ also presents a small button over the changed <em>pom.xml</em> to allow for a quick reimport without needing to open the Maven menu. The overlaid reimport button, a small <em>m</em> with a circular arrow on its bottom left portion, can be seen in <a data-type="xref" href="#reimporting_project_dependencies">Figure 5-9</a> hovering over the first dependency’s <code>&lt;groupid&gt;</code> entry; it disappears when reimport is complete.</p>
</div>

<p>Once dependencies are updated, I rebuild the project from the IDE to incorporate the configuration processor.</p>

<p>Now, to define some values for these properties. Returning to <em>application.properties</em>, when I begin typing <code>greeting</code>, the IDE helpfully shows property names that match, as demonstrated in <a data-type="xref" href="#full_ide_property_support_for_configurationproperties">Figure 5-10</a>.</p>

<figure><div id="full_ide_property_support_for_configurationproperties" class="figure">
<img src="Images/sbur_0510.png" alt="sbur 0510" width="600" height="130"/>
<h6><span class="label">Figure 5-10. </span>Full IDE property support for <code>@ConfigurationProperties</code></h6>
</div></figure>

<p>To use these properties instead of the ones we were using before, a bit of refactoring is required.</p>

<p><a data-type="indexterm" data-primary="configuration" data-secondary="@Value" id="idm45693962486616"/><a data-type="indexterm" data-primary="@Value" id="idm45693962485448"/>I can do away entirely with <code>GreetingController</code>’s own member variables <code>name</code> and <code>coffee</code> along with their <code>@Value</code> annotations; instead, I create a member variable for the <code>Greeting</code> bean that now manages <code>greeting.name</code> and <code>greeting.coffee</code> properties and inject it into <code>GreetingController</code> via constructor injection, as shown in the following code:</p>

<pre data-type="programlisting" data-code-language="java"><code class="nd">@RestController</code>
<code class="nd">@RequestMapping</code><code class="o">(</code><code class="s">"/greeting"</code><code class="o">)</code>
<code class="kd">class</code> <code class="nc">GreetingController</code> <code class="o">{</code>
    <code class="kd">private</code> <code class="kd">final</code> <code class="n">Greeting</code> <code class="n">greeting</code><code class="o">;</code>

    <code class="kd">public</code> <code class="nf">GreetingController</code><code class="o">(</code><code class="n">Greeting</code> <code class="n">greeting</code><code class="o">)</code> <code class="o">{</code>
        <code class="k">this</code><code class="o">.</code><code class="na">greeting</code> <code class="o">=</code> <code class="n">greeting</code><code class="o">;</code>
    <code class="o">}</code>

    <code class="nd">@GetMapping</code>
    <code class="n">String</code> <code class="nf">getGreeting</code><code class="o">()</code> <code class="o">{</code>
        <code class="k">return</code> <code class="n">greeting</code><code class="o">.</code><code class="na">getName</code><code class="o">();</code>
    <code class="o">}</code>

    <code class="nd">@GetMapping</code><code class="o">(</code><code class="s">"/coffee"</code><code class="o">)</code>
    <code class="n">String</code> <code class="nf">getNameAndCoffee</code><code class="o">()</code> <code class="o">{</code>
        <code class="k">return</code> <code class="n">greeting</code><code class="o">.</code><code class="na">getCoffee</code><code class="o">();</code>
    <code class="o">}</code>
<code class="o">}</code></pre>

<p>Running the application and querying the <em>greeting</em> and <em>greeting/coffee</em> endpoints results in the outcomes captured in <a data-type="xref" href="#retrieving_greeting_properties">Figure 5-11</a>.</p>

<figure><div id="retrieving_greeting_properties" class="figure">
<img src="Images/sbur_0511.png" alt="sbur 0511" width="600" height="470"/>
<h6><span class="label">Figure 5-11. </span>Retrieving <code>Greeting</code> properties</h6>
</div></figure>

<p><a data-type="indexterm" data-primary="configuration" data-secondary="@Value" id="idm45693962399592"/><a data-type="indexterm" data-primary="@Value" id="idm45693962398424"/>Properties managed by an <code>@ConfigurationProperties</code> bean still obtain their values from the <code>Environment</code> and all of its potential sources; the only significant thing missing in comparison to <code>@Value</code>-based properties is the ability to specify a default value at the annotated member variable. That is less of a sacrifice than it might appear to be at first glance because the app’s <em>application.properties</em> file typically serves as the place for defining sensible defaults for an application. If there is a need for different property values to accommodate different deployment environments, those environment-specific values are ingested into the application’s <code>Environment</code> via other sources, e.g., environment variables or command line parameters. In short, <code>@ConfigurationProperties</code> simply enforces the better practice for default property values.<a data-type="indexterm" data-primary="" data-startref="ix_config_prop" id="idm45693962394648"/></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Potential Third-Party Option"><div class="sect2" id="idm45693962658536">
<h2>Potential Third-Party Option</h2>

<p><a data-type="indexterm" data-primary="POJO (plain old Java object)" id="ix_pojo_ch5"/>A further extension to the already impressive usefulness of <code>@ConfigurationProperties</code> is the ability to wrap third-party components and incorporate their properties into the application’s <code>Environment</code>. To demonstrate how, I create a POJO to simulate a component that might be incorporated into the application. Note that in typical use cases where this feature is handiest, one would add an external dependency to the project and consult the component’s documentation to determine the class from which to create a Spring bean, rather than creating one by hand as I do here.</p>

<p>In the code listing that follows, I create the simulated third-party component called <code>Droid</code> with two properties—<code>id</code> and <code>description</code>—and their associated accessor and mutator methods:</p>

<pre data-type="programlisting" data-code-language="java"><code class="kd">class</code> <code class="nc">Droid</code> <code class="o">{</code>
    <code class="kd">private</code> <code class="n">String</code> <code class="n">id</code><code class="o">,</code> <code class="n">description</code><code class="o">;</code>

    <code class="kd">public</code> <code class="n">String</code> <code class="nf">getId</code><code class="o">()</code> <code class="o">{</code>
        <code class="k">return</code> <code class="n">id</code><code class="o">;</code>
    <code class="o">}</code>

    <code class="kd">public</code> <code class="kt">void</code> <code class="nf">setId</code><code class="o">(</code><code class="n">String</code> <code class="n">id</code><code class="o">)</code> <code class="o">{</code>
        <code class="k">this</code><code class="o">.</code><code class="na">id</code> <code class="o">=</code> <code class="n">id</code><code class="o">;</code>
    <code class="o">}</code>

    <code class="kd">public</code> <code class="n">String</code> <code class="nf">getDescription</code><code class="o">()</code> <code class="o">{</code>
        <code class="k">return</code> <code class="n">description</code><code class="o">;</code>
    <code class="o">}</code>

    <code class="kd">public</code> <code class="kt">void</code> <code class="nf">setDescription</code><code class="o">(</code><code class="n">String</code> <code class="n">description</code><code class="o">)</code> <code class="o">{</code>
        <code class="k">this</code><code class="o">.</code><code class="na">description</code> <code class="o">=</code> <code class="n">description</code><code class="o">;</code>
    <code class="o">}</code>
<code class="o">}</code></pre>

<p><a data-type="indexterm" data-primary="@Configuration" id="ix_at_config"/>The next step falls into place the same way a true third-party component would: instantiating the component as a Spring bean. <a data-type="indexterm" data-primary="@Bean" id="idm45693962290040"/>Spring beans can be created from defined POJOs in several ways, but the one most appropriate to this particular use case is to create an <code>@Bean</code>-annotated method within a class annotated with <code>@Configuration</code>, either directly or via a meta-annotation.</p>

<p><a data-type="indexterm" data-primary="@SpringBootApplication" id="idm45693962287960"/>One meta-annotation that incorporates <code>@Configuration</code> within its definition is <code>@SpringBootApplication</code>, which is found on the main application class. That’s why developers often place bean creation methods there.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Within IntelliJ and most other IDEs and advanced text editors with solid Spring support, it’s possible to drill into Spring meta-annotations to explore the annotations nested within. In IntelliJ, Cmd+LeftMouseClick (on MacOS) will expand the annotation. <code>@SpringBootApplication</code> includes <code>@SpringBootConfiguration</code>, which includes <code>@Configuration</code>, making only two degrees of separation from Kevin Bacon.</p>
</div>

<p><a data-type="indexterm" data-primary="@ConfigurationProperties" id="idm45693962283224"/>In the following code listing I demonstrate the bean creation method and the requisite <code>@ConfigurationProperties</code> annotation and <code>prefix</code> parameter, indicating that <code>Droid</code> properties should be incorporated within the <code>Environment</code> under the top-level property grouping <code>droid</code>:</p>

<pre data-type="programlisting" data-code-language="java"><code class="nd">@SpringBootApplication</code>
<code class="nd">@ConfigurationPropertiesScan</code>
<code class="kd">public</code> <code class="kd">class</code> <code class="nc">SburRestDemoApplication</code> <code class="o">{</code>

    <code class="kd">public</code> <code class="kd">static</code> <code class="kt">void</code> <code class="nf">main</code><code class="o">(</code><code class="n">String</code><code class="o">[]</code> <code class="n">args</code><code class="o">)</code> <code class="o">{</code>
        <code class="n">SpringApplication</code><code class="o">.</code><code class="na">run</code><code class="o">(</code><code class="n">SburRestDemoApplication</code><code class="o">.</code><code class="na">class</code><code class="o">,</code> <code class="n">args</code><code class="o">);</code>
    <code class="o">}</code>

    <code class="nd">@Bean</code>
    <code class="nd">@ConfigurationProperties</code><code class="o">(</code><code class="n">prefix</code> <code class="o">=</code> <code class="s">"droid"</code><code class="o">)</code>
    <code class="n">Droid</code> <code class="nf">createDroid</code><code class="o">()</code> <code class="o">{</code>
        <code class="k">return</code> <code class="k">new</code> <code class="nf">Droid</code><code class="o">();</code>
    <code class="o">}</code>
<code class="o">}</code></pre>

<p>As before, it is necessary to rebuild the project for the configuration processor to detect the properties exposed by this new source of configuration properties. After executing a build, we can return to <em>application.properties</em> and see that both <code>droid</code> properties have now surfaced complete with type information, as per <a data-type="xref" href="#droid_properties_and_type_information_now_visible_in_application_properties">Figure 5-12</a>.<a data-type="indexterm" data-primary="" data-startref="ix_at_config" id="idm45693962197944"/></p>

<figure><div id="droid_properties_and_type_information_now_visible_in_application_properties" class="figure">
<img src="Images/sbur_0512.png" alt="sbur 0512" width="600" height="192"/>
<h6><span class="label">Figure 5-12. </span><code>droid</code> properties and type information now visible in <em>application.properties</em></h6>
</div></figure>

<p>I assign some default values to <code>droid.id</code> and <code>droid.description</code> for use as defaults, as shown in <a data-type="xref" href="#droid_properties_with_default_values_assigned_in_application_properties">Figure 5-13</a>. This is a good habit to adopt for all <code>Environment</code> properties, even those obtained from third parties.</p>

<figure><div id="droid_properties_with_default_values_assigned_in_application_properties" class="figure">
<img src="Images/sbur_0513.png" alt="sbur 0513" width="600" height="128"/>
<h6><span class="label">Figure 5-13. </span><code>droid</code> properties with default values assigned in <em>application.properties</em></h6>
</div></figure>

<p><a data-type="indexterm" data-primary="@GetMapping" id="idm45693962189096"/><a data-type="indexterm" data-primary="@RestController" id="idm45693962188392"/>In order to verify that everything works as expected with the <code>Droid</code>’s properties, I create a very simple <code>@RestController</code> with a single <code>@GetMapping</code> method, as shown in the code that follows:</p>

<pre data-type="programlisting" data-code-language="java"><code class="nd">@RestController</code>
<code class="nd">@RequestMapping</code><code class="o">(</code><code class="s">"/droid"</code><code class="o">)</code>
<code class="kd">class</code> <code class="nc">DroidController</code> <code class="o">{</code>
    <code class="kd">private</code> <code class="kd">final</code> <code class="n">Droid</code> <code class="n">droid</code><code class="o">;</code>

    <code class="kd">public</code> <code class="nf">DroidController</code><code class="o">(</code><code class="n">Droid</code> <code class="n">droid</code><code class="o">)</code> <code class="o">{</code>
        <code class="k">this</code><code class="o">.</code><code class="na">droid</code> <code class="o">=</code> <code class="n">droid</code><code class="o">;</code>
    <code class="o">}</code>

    <code class="nd">@GetMapping</code>
    <code class="n">Droid</code> <code class="nf">getDroid</code><code class="o">()</code> <code class="o">{</code>
        <code class="k">return</code> <code class="n">droid</code><code class="o">;</code>
    <code class="o">}</code>
<code class="o">}</code></pre>

<p>After building and running the project, I query the new <em>/droid</em> endpoint and confirm the appropriate response, as indicated in <a data-type="xref" href="#querying_the_droid_endpoint_to_retrieve_properties_from_the_droid">Figure 5-14</a>.<a data-type="indexterm" data-primary="" data-startref="ix_pojo_ch5" id="idm45693962107896"/></p>

<figure><div id="querying_the_droid_endpoint_to_retrieve_properties_from_the_droid" class="figure">
<img src="Images/sbur_0514.png" alt="sbur 0514" width="600" height="193"/>
<h6><span class="label">Figure 5-14. </span>Querying the <em>/droid</em> endpoint to retrieve properties from the Droid</h6>
</div></figure>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Autoconfiguration Report"><div class="sect1" id="idm45693962777192">
<h1>Autoconfiguration Report</h1>

<p><a data-type="indexterm" data-primary="configuration" data-secondary="autoconfiguration" id="ix_config_auto_ch5"/><a data-type="indexterm" data-primary="autoconfiguration" id="ix_auto_config_ch5"/>As mentioned previously, Boot does a <em>lot</em> on behalf of developers via autoconfiguration: setting up the application with the beans it needs to fulfill the functionalities that are part and parcel to chosen capabilities, dependencies, and code. Also mentioned earlier is the ability to override any bit of autoconfiguration necessary to implement functionality in a more specific (to your use case) manner. But how can one see what beans are created, what beans aren’t created, and what conditions prompted either outcome?</p>

<p>It’s a simple matter to produce the autoconfiguration report using the <code>debug</code> flag in one of several ways, owing to the flexibility of the JVM:<a data-type="indexterm" data-primary="JAR files" id="idm45693962099192"/></p>

<ul>
<li>
<p>Executing the application’s jar file with the <code>--debug</code> option: <code>java -jar bootapplication.jar --debug</code></p>
</li>
<li>
<p>Executing the application’s jar file with a JVM parameter: <code>java -Ddebug=true</code> 
<span class="keep-together"><code>-jar bootapplication.jar</code></span></p>
</li>
<li>
<p>Adding <code>debug=true</code> to your application’s <em>application.properties</em> file</p>
</li>
<li>
<p>Executing <code>export DEBUG=true</code> in your shell (Linux or Mac) or adding it to your Windows environment, then running <code>java -jar bootapplication.jar</code></p>
</li>
</ul>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Any way to add an affirmative value for <code>debug</code> to the application’s <code>Environment</code>, as discussed earlier, will provide the same results. These are just more frequently used options.</p>
</div>

<p>The autoconfiguration report’s section listing positive matches—those conditions that evaluated to true and caused an action to take place—are listed within a section headed by “Positive matches.” I’ve copied that section header here, along with one example of a positive match and its resultant autoconfiguration action:</p>

<pre data-type="programlisting">============================
CONDITIONS EVALUATION REPORT
============================

Positive matches:
-----------------
   DataSourceAutoConfiguration matched:
      - @ConditionalOnClass found required classes 'javax.sql.DataSource',
      'org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType'
      (OnClassCondition)</pre>

<p><a data-type="indexterm" data-primary="JPA (Java Persistence API)" data-secondary="autoconfiguration report" id="idm45693962086872"/>This particular match demonstrates what we expected to happen, although it’s always good to confirm the following:</p>

<ul>
<li>
<p>JPA and H2 are application dependencies.</p>
</li>
<li>
<p>JPA works with SQL datasources.</p>
</li>
<li>
<p>H2 is an embedded database.</p>
</li>
<li>
<p>Classes were found that support embedded SQL datasources.</p>
</li>
</ul>

<p>As a result, <code>DataSourceAutoConfiguration</code> is invoked.</p>

<p>Similarly, the “Negative matches” section displays actions not taken by Spring Boot’s autoconfiguration and why, as illustrated in the following:</p>

<pre data-type="programlisting">Negative matches:
-----------------
   ActiveMQAutoConfiguration:
      Did not match:
         - @ConditionalOnClass did not find required class
          'javax.jms.ConnectionFactory' (OnClassCondition)</pre>

<p>In this case, <code>ActiveMQAutoConfiguration</code> was not performed because the application didn’t find the JMS <code>ConnectionFactory</code> class upon startup.</p>

<p>Another useful tidbit is the section listing “Unconditional classes,” which are created without having to satisfy any conditions. I’ve listed one next that is of particular interest given the previous section:</p>

<pre data-type="programlisting">Unconditional classes:
----------------------
    org.springframework.boot.autoconfigure.context
     .ConfigurationPropertiesAutoConfiguration</pre>

<p><a data-type="indexterm" data-primary="@ConfigurationProperties" id="idm45693962075992"/>As you can see, <code>ConfigurationPropertiesAutoConfiguration</code> is always instantiated to manage any <code>ConfigurationProperties</code> created and referenced within a Spring Boot application; it’s integral to every Spring Boot app.<a data-type="indexterm" data-primary="" data-startref="ix_auto_config_ch5" id="idm45693962074120"/><a data-type="indexterm" data-primary="" data-startref="ix_config_auto_ch5" id="idm45693962073144"/></p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Actuator"><div class="sect1" id="idm45693962104040">
<h1>Actuator</h1>
<dl>
<dt>actuator</dt>
<dd>
<p>n.	One that actuates specifically: a mechanical device for moving or controlling something</p>
</dd>
</dl>

<p><a data-type="indexterm" data-primary="REST API" data-secondary="inspection of (Actuator)" id="ix_rest_api_inspect_actuator"/><a data-type="indexterm" data-primary="inspection of the API (Actuator)" id="ix_inspect_actuator"/><a data-type="indexterm" data-primary="Spring Boot Actuator" id="ix_SB_actuator"/><a data-type="indexterm" data-primary="configuration" data-secondary="Actuator" id="ix_config_actuator"/>The original version of Spring Boot Actuator reached General Availability (GA) in 2014 and was hailed for providing valuable insights into production Boot applications. Providing monitoring and management capabilities of running apps via HTTP endpoints or Java Management Extensions (JMX), Actuator encompasses and exposes all of Spring Boot’s production-ready features.</p>

<p>Completely retooled with the 2.0 version of Spring Boot, Actuator now leverages the Micrometer instrumentation library to provide metrics via a consistent façade from numerous leading monitoring systems, similar to how SLF4J operates with regard to various logging mechanisms. This dramatically extends the scope of things that can be integrated, monitored, and exposed via Actuator within any given Spring Boot application.</p>

<p>To get started with Actuator, I add another dependency to the current project’s <code>pom.xml</code> dependencies section. As shown in the following snippet, the <code>spring-boot-starter-actuator</code> dependency provides the necessary capabilities; to do so, it brings with it both Actuator itself and Micrometer, along with autoconfiguration capabilities to slide into place within a Spring Boot application with nearly zero effort:</p>

<pre data-type="programlisting">&lt;dependencies&gt;
    ... (other dependencies omitted for brevity)
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</pre>

<p>After refreshing/reimporting dependencies once more, I rerun the application. With the application running, we can see what information Actuator exposes by default by accessing its primary endpoint. <a data-type="indexterm" data-primary="HTTPie" id="idm45693962034264"/>Again, I use HTTPie to accomplish this, as per <a data-type="xref" href="#accessing_actuator_endpoint_default_configuration">Figure 5-15</a>.</p>

<figure><div id="accessing_actuator_endpoint_default_configuration" class="figure">
<img src="Images/sbur_0515.png" alt="sbur 0515" width="600" height="512"/>
<h6><span class="label">Figure 5-15. </span>Accessing Actuator endpoint, default configuration</h6>
</div></figure>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>All Actuator information is grouped together under the app’s 
<span class="keep-together"><em>/actuator</em></span> endpoint by default, but this too is configurable.</p>
</div>

<p>This doesn’t seem like much information for the fanfare (and fanbase) that Actuator has created. But this terseness is intentional.</p>

<p>Actuator has access to and can expose a great deal of information about running applications. This information can be incredibly useful to developers, operational personnel, and also nefarious individuals who might desire to threaten your application’s security. <a data-type="indexterm" data-primary="Spring Security" data-seealso="authentication and authorization" id="idm45693962026792"/>Following Spring Security’s de facto goal of <em>secure by default</em>, Actuator’s autoconfiguration exposes very limited <em>health</em> and <em>info</em> responses—in fact, <em>info</em> defaults to an empty set—that provide an application heartbeat and little else out of the box (OOTB).</p>

<p>As with most things Spring, you can create some pretty sophisticated mechanisms for controlling access to various Actuator data feeds, but there are fast, consistent, and low-friction options available as well. Let’s take a look at those now.</p>

<p>It’s possible to easily configure Actuator via properties with either a set of included endpoints or a set of excluded endpoints. For simplicity’s sake, I choose the inclusion route, adding the following to <em>application.properties</em>:</p>

<pre data-type="programlisting">management.endpoints.web.exposure.include=env, info, health</pre>

<p>In this example, I direct the app (and Actuator) to expose only the <em>/actuator/env</em>, 
<span class="keep-together"><em>/actuator/info</em></span>, and <em>/actuator/health</em> endpoints (and any subordinate endpoints).</p>

<p><a data-type="xref" href="#accessing_the_actuator_after_specifying_endpoints_to_include">Figure 5-16</a> confirms the expected outcome upon rerunning the application and querying its <em>/actuator</em> endpoint.</p>

<p>In order to fully demonstrate Actuator’s OOTB capabilities, I can go a step further and disable security entirely <em>for demonstration purposes only</em> by using a wildcard with the aforementioned <em>application.properties</em> setting:</p>

<pre data-type="programlisting">management.endpoints.web.exposure.include=*</pre>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p><a data-type="indexterm" data-primary="Spring Security" id="idm45693962014392"/>This point is impossible to overstate: security mechanisms for sensitive data should be disabled only for demonstration or verification purposes. <em>NEVER DISABLE SECURITY FOR PRODUCTION APPLICATIONS</em>.</p>
</div>

<figure><div id="accessing_the_actuator_after_specifying_endpoints_to_include" class="figure">
<img src="Images/sbur_0516.png" alt="sbur 0516" width="600" height="659"/>
<h6><span class="label">Figure 5-16. </span>Accessing the Actuator after specifying endpoints to include</h6>
</div></figure>

<p>For verification when starting the application, Actuator dutifully reports the number of endpoints it is currently exposing and the root path to reach them—in this case, the default of <em>/actuator</em>—as shown in the startup report fragment that follows. This is a useful reminder/warning to provide a quick visual check that no more endpoints are being exposed than desired before advancing the application to a target deployment:</p>

<pre data-type="programlisting">INFO 22115 --- [           main] o.s.b.a.e.web.EndpointLinksResolver      :
    Exposing 13 endpoint(s) beneath base path '/actuator'</pre>

<p>To examine all mappings currently accessible via Actuator, simply query the provided Actuator root path to retrieve a full listing:</p>

<pre data-type="programlisting">mheckler-a01 :: ~/dev » http :8080/actuator
HTTP/1.1 200
Connection: keep-alive
Content-Type: application/vnd.spring-boot.actuator.v3+json
Date: Fri, 27 Nov 2020 17:43:27 GMT
Keep-Alive: timeout=60
Transfer-Encoding: chunked

{
    "_links": {
        "beans": {
            "href": "http://localhost:8080/actuator/beans",
            "templated": false
        },
        "caches": {
            "href": "http://localhost:8080/actuator/caches",
            "templated": false
        },
        "caches-cache": {
            "href": "http://localhost:8080/actuator/caches/{cache}",
            "templated": true
        },
        "conditions": {
            "href": "http://localhost:8080/actuator/conditions",
            "templated": false
        },
        "configprops": {
            "href": "http://localhost:8080/actuator/configprops",
            "templated": false
        },
        "env": {
            "href": "http://localhost:8080/actuator/env",
            "templated": false
        },
        "env-toMatch": {
            "href": "http://localhost:8080/actuator/env/{toMatch}",
            "templated": true
        },
        "health": {
            "href": "http://localhost:8080/actuator/health",
            "templated": false
        },
        "health-path": {
            "href": "http://localhost:8080/actuator/health/{*path}",
            "templated": true
        },
        "heapdump": {
            "href": "http://localhost:8080/actuator/heapdump",
            "templated": false
        },
        "info": {
            "href": "http://localhost:8080/actuator/info",
            "templated": false
        },
        "loggers": {
            "href": "http://localhost:8080/actuator/loggers",
            "templated": false
        },
        "loggers-name": {
            "href": "http://localhost:8080/actuator/loggers/{name}",
            "templated": true
        },
        "mappings": {
            "href": "http://localhost:8080/actuator/mappings",
            "templated": false
        },
        "metrics": {
            "href": "http://localhost:8080/actuator/metrics",
            "templated": false
        },
        "metrics-requiredMetricName": {
            "href": "http://localhost:8080/actuator/metrics/{requiredMetricName}",
            "templated": true
        },
        "scheduledtasks": {
            "href": "http://localhost:8080/actuator/scheduledtasks",
            "templated": false
        },
        "self": {
            "href": "http://localhost:8080/actuator",
            "templated": false
        },
        "threaddump": {
            "href": "http://localhost:8080/actuator/threaddump",
            "templated": false
        }
    }
}</pre>

<p><a data-type="indexterm" data-primary="health indicator, Actuator" id="idm45693962004376"/>The listing of Actuator endpoints provides a good idea of the scope of information captured and exposed for examination, but of particular usefulness to actors good and bad are the following:</p>
<dl>
<dt><em>/actuator/beans</em></dt>
<dd>
<p>All Spring beans created by the application</p>
</dd>
<dt><em>/actuator/conditions</em></dt>
<dd>
<p>Conditions met (or not) to create Spring beans; similar to the Conditions Evaluation Report discussed previously</p>
</dd>
<dt><em>/actuator/configprops</em></dt>
<dd>
<p>All <code>Environment</code> properties accessible by the application</p>
</dd>
<dt><em>/actuator/env</em></dt>
<dd>
<p>Myriad aspects of the environment in which the application is operating; especially useful to see where each individual <code>configprop</code> value 
<span class="keep-together">originates</span></p>
</dd>
<dt><em>/actuator/health</em></dt>
<dd>
<p>Health info (basic or expanded, depending on settings)</p>
</dd>
<dt><em>/actuator/heapdump</em></dt>
<dd>
<p>Initiates heap dump for troubleshooting and/or analysis</p>
</dd>
<dt><em>/actuator/loggers</em></dt>
<dd>
<p>Logging levels for every component</p>
</dd>
<dt><em>/actuator/mappings</em></dt>
<dd>
<p>All endpoint mappings and supporting details</p>
</dd>
<dt><em>/actuator/metrics</em></dt>
<dd>
<p>Metrics currently being captured by the application</p>
</dd>
<dt><em>/actuator/threaddump</em></dt>
<dd>
<p>Initiates thread dump for troubleshooting and/or analysis</p>
</dd>
</dl>

<p>These, and all of the remaining preconfigured Actuator endpoints, are handy when needed and easy to access for examination. Continuing to focus on the application’s environment, even among these endpoints there are firsts among peers.</p>








<section data-type="sect2" data-pdf-bookmark="Getting Actuator to Open Up"><div class="sect2" id="idm45693961985352">
<h2>Getting Actuator to Open Up</h2>

<p><a data-type="indexterm" data-primary="Spring Boot Actuator" data-secondary="opening up" id="idm45693961984040"/>As mentioned, Actuator’s default security posture intentionally exposes only very limited <em>health</em> and <em>info</em> responses. In fact, the <em>/actuator/health</em> endpoint provides a rather utilitarian “UP” or “DOWN” application status out of the box.</p>

<p>With most applications, however, there are dependencies for which Actuator tracks health information; it simply doesn’t expose that additional information unless authorized to do so. To show expanded health information for preconfigured dependencies, I add the following property to <em>application.properties</em>:</p>

<pre data-type="programlisting">management.endpoint.health.show-details=always</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>There are three possible values for the health indicator’s <code>show-details</code> property: <code>never</code> (default), <code>when_authorized</code>, and <code>always</code>. For this example, I choose <code>always</code> simply to demonstrate the possible, but for every application put into production, the correct choices would be either <code>never</code> or <code>when_authorized</code> in order to limit visibility to the application’s expanded health information.</p>
</div>

<p>Restarting the application results in the addition of health information for the application’s primary components to the overall application health summary when accessing the <em>/actuator/health</em> endpoint, per <a data-type="xref" href="#expanded_health_information">Figure 5-17</a>.</p>

<figure><div id="expanded_health_information" class="figure">
<img src="Images/sbur_0517.png" alt="sbur 0517" width="600" height="683"/>
<h6><span class="label">Figure 5-17. </span>Expanded health information</h6>
</div></figure>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Becoming More Environmentally Aware Using Actuator"><div class="sect2" id="idm45693961971032">
<h2>Becoming More Environmentally Aware Using Actuator</h2>

<p><a data-type="indexterm" data-primary="Spring Boot Actuator" data-secondary="environmental awareness" id="ix_sb_actuator_environ"/><a data-type="indexterm" data-primary="enviromental awareness (Actuator)" id="ix_environ_actuator"/>One malady that often afflicts developers—present company included—is an assumption of complete knowledge of current application environment/state when behavior doesn’t match expectations. This isn’t entirely unexpected, especially if one wrote the anomalous code oneself. A relatively quick and invaluable first step is to <em>check all assumptions</em>. Do you <em>know</em> what that value is? Or are you just really certain you know?</p>

<p>Have you checked?</p>

<p>Especially in code in which outcomes are driven by inputs, this should be a required starting point. Actuator helps make this painless. Querying the application’s 
<span class="keep-together"><em>/actuator/env</em></span> endpoint returns all environmental information; following is the portion of that result that shows only the properties set in the application to this point:</p>

<pre data-type="programlisting">{
    "name": "Config resource 'classpath:/application.properties' via location
     'optional:classpath:/'",
    "properties": {
        "droid.description": {
            "origin": "class path resource [application.properties] - 5:19",
            "value": "Small, rolling android. Probably doesn't drink coffee."
        },
        "droid.id": {
            "origin": "class path resource [application.properties] - 4:10",
            "value": "BB-8"
        },
        "greeting.coffee": {
            "origin": "class path resource [application.properties] - 2:17",
            "value": "Dakota is drinking Cafe Cereza"
        },
        "greeting.name": {
            "origin": "class path resource [application.properties] - 1:15",
            "value": "Dakota"
        },
        "management.endpoint.health.show-details": {
            "origin": "class path resource [application.properties] - 8:41",
            "value": "always"
        },
        "management.endpoints.web.exposure.include": {
            "origin": "class path resource [application.properties] - 7:43",
            "value": "*"
        }
    }
}</pre>

<p>Actuator shows not only the current value for each defined property but also its source, down to the line and column number where each value is defined. But what happens if one or more of those values is overridden by another source, e.g., an external environment variable or command line argument when executing the 
<span class="keep-together">application?</span></p>

<p>To demonstrate a typical production-bound application scenario, I run <code>mvn clean package</code> from the application’s directory at the command line, then execute the app with the following command:</p>

<pre data-type="programlisting">java -jar target/sbur-rest-demo-0.0.1-SNAPSHOT.jar --greeting.name=Sertanejo</pre>

<p>Querying <em>/actuator/env</em> once more, you can see that there is a new section for command line arguments with a single entry for <code>greeting.name</code>:</p>

<pre data-type="programlisting">{
    "name": "commandLineArgs",
    "properties": {
        "greeting.name": {
            "value": "Sertanejo"
        }
    }
}</pre>

<p><a data-type="indexterm" data-primary="SpEL (Spring Expression Language)" id="idm45693961956328"/>Following the order of precedence for <code>Environment</code> inputs that was referenced earlier, command line arguments should override the value set from within 
<span class="keep-together"><em>application.properties</em></span>. Querying the <em>/greeting</em> endpoint returns “Sertanejo” as expected; querying 
<span class="keep-together"><em>/greeting/coffee</em></span> likewise results in the overridden value being incorporated into that response via the SpEL expression as well: <code>Sertanejo is drinking Cafe Cereza</code>.</p>

<p>Trying to get to the bottom of errant, data-driven behavior just got a lot simpler thanks to Spring Boot Actuator.<a data-type="indexterm" data-primary="" data-startref="ix_environ_actuator" id="idm45693961951672"/><a data-type="indexterm" data-primary="" data-startref="ix_sb_actuator_environ" id="idm45693961950664"/></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Turning Up the Volume on Logging with Actuator"><div class="sect2" id="idm45693961970440">
<h2>Turning Up the Volume on Logging with Actuator</h2>

<p><a data-type="indexterm" data-primary="Spring Boot Actuator" data-secondary="logging levels" id="ix_SB_actuator_log"/><a data-type="indexterm" data-primary="logging levels (Actuator)" id="ix_logging_actuator"/>Like many other choices in developing and deploying software, choosing logging levels for production applications involves tradeoffs. Opting for more logging results in more system-level work and storage consumption and the capture of both more relevant and irrelevant data. This in turn can make it considerably more difficult to find an elusive issue.</p>

<p>As part of its mission of providing Boot’s production-ready features, Actuator addresses this as well, allowing developers to set a typical logging level like “INFO” for most or all components and change that level temporarily when a critical issue surfaces…all in live, production Spring Boot applications. Actuator facilitates the setting and resetting of logging levels with a simple <code>POST</code> to the applicable endpoint. For example, <a data-type="xref" href="#default_logging_level_for_orgspringframeworkdataweb">Figure 5-18</a> shows the default logging level for <code>org.springframework.data.web</code>.</p>

<figure><div id="default_logging_level_for_orgspringframeworkdataweb" class="figure">
<img src="Images/sbur_0518.png" alt="sbur 0518" width="600" height="215"/>
<h6><span class="label">Figure 5-18. </span>Default logging level for <code>org.springframework.data.web</code></h6>
</div></figure>

<p>Of particular interest is that since a logging level wasn’t configured for this component, an effective level of “INFO” is used. Again, Spring Boot provides a sensible default when specifics aren’t provided.</p>

<p><a data-type="indexterm" data-primary="JSON (JavaScript Object Notation)" data-secondary="configuration" id="idm45693961939528"/>If I’m notified of an issue with a running app and would like to increase logging to help diagnose and resolve it, all that is necessary to do so for a particular component is to <code>POST</code> a new JSON-formatted value for <code>configuredLevel</code> to its <em>/actuator/loggers</em> endpoint, as shown here:</p>

<pre data-type="programlisting">echo '{"configuredLevel": "TRACE"}'
  | http :8080/actuator/loggers/org.springframework.data.web</pre>

<p>Requerying the logging level now returns confirmation that the logger for <code>org.springframework.data.web</code> is now set to “TRACE” and will provide intensive diagnostic logging for the application, as shown in <a data-type="xref" href="#new_trace_logging_level_for_orgspringframeworkdataweb">Figure 5-19</a>.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>“TRACE” can be essential in pinning down an elusive issue, but it is a rather heavyweight level of logging, capturing even finer-grained information than “DEBUG”—use in production applications can provide essential information, but be mindful of the impact.</p>
</div>

<figure><div id="new_trace_logging_level_for_orgspringframeworkdataweb" class="figure">
<img src="Images/sbur_0519.png" alt="sbur 0519" width="600" height="213"/>
<h6><span class="label">Figure 5-19. </span>New “TRACE” Logging Level for <code>org.springframework.data.web</code></h6>
</div></figure>
<div data-type="tip"><h1>Code Checkout Checkup</h1>
<p>For complete chapter code, please check out branch <em>chapter5end</em> from the code repository.<a data-type="indexterm" data-primary="" data-startref="ix_config_ch5" id="idm45693961928600"/><a data-type="indexterm" data-primary="" data-startref="ix_config_actuator" id="idm45693961927624"/><a data-type="indexterm" data-primary="" data-startref="ix_SB_actuator" id="idm45693961926680"/><a data-type="indexterm" data-primary="" data-startref="ix_inspect_actuator" id="idm45693961925736"/><a data-type="indexterm" data-primary="" data-startref="ix_rest_api_inspect_actuator" id="idm45693961924792"/><a data-type="indexterm" data-primary="" data-startref="ix_logging_actuator" id="idm45693961923784"/><a data-type="indexterm" data-primary="" data-startref="ix_SB_actuator_log" id="idm45693961922840"/></p>
</div>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Summary"><div class="sect1" id="idm45693962071416">
<h1>Summary</h1>

<p>It’s critical for a developer to have useful tools to establish, identify, and isolate behaviors manifested within production applications. As applications become more dynamic and distributed, there is often a need to do the following:</p>

<ul>
<li>
<p>Configure and reconfigure applications dynamically</p>
</li>
<li>
<p>Determine/confirm current settings and their origins</p>
</li>
<li>
<p>Inspect and monitor application environment and health indicators</p>
</li>
<li>
<p>Temporarily adjust logging levels of live apps to identify root causes</p>
</li>
</ul>

<p>This chapter demonstrated how to use Spring Boot’s built-in configuration capabilities, its Autoconfiguration Report, and Spring Boot Actuator to create, identify, and modify application environment settings flexibly and dynamically.</p>

<p>In the next chapter, I dive deep into data: how to define its storage and retrieval using various industry standards and leading database engines and the Spring Data projects and facilities that enable their use in the most streamlined and powerful ways 
<span class="keep-together">possible</span>.</p>
</div></section>







<div data-type="footnotes"><p data-type="footnote" id="idm45693962724088"><sup><a href="ch05.xhtml#idm45693962724088-marker">1</a></sup> <a href="https://oreil.ly/OrderPredSB">Order of precedence for Spring Boot PropertySources</a>.</p></div></div></section></div></body></html>