- en: Chapter 2\. The Path to Cloud Native Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: “Πάντα ῥεῖ” (Panta rei) is a famous aphorism from philosopher Heraclitus that
    describes the mutable condition of our existence where everything flows, where
    our call is to react and adapt. This perfectly describes the right approach to
    the evolution we are experiencing in the IT world in general, and specifically
    with programming languages and frameworks, where heterogeneous, distributed, multicloud
    workloads are more common and essential for business purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Java and Jakarta EE (formely known as Java EE), are evolving as well in that
    direction, balancing the benefits that come from the consolidated experience of
    enterprise solutions, together with the need for a fast-changing cloud-aware scenario
    where our applications can run in many clouds seamlessly. In this chapter, we
    will outline the components needed for a transition to cloud native Java, walking
    you through an ecommerce store Java implementation called Coolstore.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud Native Workshop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices are an accepted and well-recognized practice nowadays. For JavaEE
    developers, this means a lift-and-shift change of the paradigm, where a single
    application server does not contain all our business logic. Instead, it gets split
    into different microservices running in their application servers, like Tomcat
    or Undertow, with a minimal footprint and optimizations to keep this coexistence
    functional and performant also in the cloud native world.
  prefs: []
  type: TYPE_NORMAL
- en: The monolithic approach today can be refactored into a heterogeneous and even
    programming language agnostic model, where each module is managed by a specific
    component running in a different application. Beyond the best practices such as
    API-driven models, the challenge here is how to maintain this diversity. However,
    Java today provides a set of tools and frameworks that help us focus on our preferred
    tools and collaborate easily. In this chapter, you will learn how to develop and
    deploy a microservices-based application split across different Java frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our ecommerce application Coolstore is a typical web app containing three components:'
  prefs: []
  type: TYPE_NORMAL
- en: Presentation layer
  prefs: []
  type: TYPE_NORMAL
- en: a frontend to show available items to acquire
  prefs: []
  type: TYPE_NORMAL
- en: Model layer
  prefs: []
  type: TYPE_NORMAL
- en: a backend providing the business logic to catalog and index all items to sell
  prefs: []
  type: TYPE_NORMAL
- en: Data layer
  prefs: []
  type: TYPE_NORMAL
- en: a database storing all records about transactions and items
  prefs: []
  type: TYPE_NORMAL
- en: The outcome of these components is an online store with a catalog of product
    items and an inventory of stock that we can organize with the architecture shown
    in [Figure 2-1](#fig2-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![Coolstore Architecture](Images/moej_0201.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-1\. Coolstore architecture
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'We map the three previously mentioned components into several microservices,
    each one responsible for its layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Catalog Service* uses a REST API to expose the content of a catalog stored
    in a relational database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Inventory Service* uses a REST API to expose the inventory of items stored
    in a relational database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Gateway Service* calls the *Catalog Service* and *Inventory Service* in an
    efficient way.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*WebUI Service* calls *Gateway Service* to retrieve all the information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Presentation and the Model layers are represented by such microservices,
    with the latter having an interface to the Data layer delegated to some DBMS.
    Our estore implementation is called Coolstore and looks like the picture in [Figure 2-2](#fig2-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![Coolstore Dashboard](Images/moej_0202.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-2\. Coolstore dashboard
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Create an Inventory Microservice with Quarkus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Quarkus](https://quarkus.io) is a full stack, Kubernetes-native Java framework
    made for Java virtual machines (JVMs) and native compilation, optimizing Java
    specifically for containers and enabling it to become an effective platform for
    serverless, cloud, and Kubernetes environments.'
  prefs: []
  type: TYPE_NORMAL
- en: It is designed to work with popular Java standards, frameworks, and libraries
    like Eclipse MicroProfile and Spring, as well as Apache Kafka, RESTEasy (JAX-RS),
    Hibernate ORM (JPA), Infinispan, Camel, and many more. It also provides the correct
    information to GraalVM (a universal virtual machine for running apps written in
    several languages, including Java and JavaScript) for a native compilation of
    your application.
  prefs: []
  type: TYPE_NORMAL
- en: Quarkus is a good choice for implementing microservices architectures, and it
    provides a set of tools that help developers debug and test at ease. For our ecommerce
    store, we will start using Quarkus for the Inventory microservice (as shown in
    [Figure 2-3](#fig2-3)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Inventory Quarkus microservice](Images/moej_0203.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-3\. Inventory Quarkus microservice
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can find all the source code for this example in the [book’s GitHub repository](https://oreil.ly/zqbWB).
  prefs: []
  type: TYPE_NORMAL
- en: Create Quarkus Maven Project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With Quarkus, you can scaffold a new project either with Maven or Gradle.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Both Maven and Gradle are popular ways to set up a Java project and manage all
    dependencies. They differ in their dependency management strategy and they have
    different configuration formats (XML versus Kotlin DSL), but they are mostly equivalent
    in terms of capabilities. In this book, we will use Maven as it has wider support
    through IDEs and tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'We set up a new Maven project using `quarkus-maven-plugin` with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can also bootstrap a Quarkus app with the online configurator available
    at [*https://code.quarkus.io*](https://code.quarkus.io).
  prefs: []
  type: TYPE_NORMAL
- en: This will create a skeleton project with an `InventoryResource` class that we
    will use for implementing our ecommerce Inventory microservice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at the generated *pom.xml* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_the_path_to_cloud_native_java_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Here we set up `groupId`, `artifactId`, and `version`. For a full list of available
    options, please see [Table 2-1](#quarkus_maven_project_options).
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_the_path_to_cloud_native_java_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Here you find the import of the Quarkus BOM, allowing you to omit the version
    on the different Quarkus dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_the_path_to_cloud_native_java_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here you find all the dependencies for the project, which we expressed as extensions
    to add. We’ve included:'
  prefs: []
  type: TYPE_NORMAL
- en: 'JSON REST Services: This allows you to [develop REST services](https://oreil.ly/hsHvV)
    to consume and produce JSON payloads.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hibernate ORM Panache: The de facto JPA implementation offers you the full
    breadth of an Object Relational Mapper. [Hibernate ORM with Panache](https://oreil.ly/zqJDh)
    focuses on simplifying the Hibernate-based Persistence layer, making your entities
    easier to write and maintain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Datasources (H2): [Datasources](https://oreil.ly/Q5nGV) are the main way of
    obtaining connections to a database; in this example, we will use H2, an in-memory
    database ready to use for Java apps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_the_path_to_cloud_native_java_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The `quarkus-maven-plugin`, which is responsible for the packaging of the application
    and also for providing the development mode.
  prefs: []
  type: TYPE_NORMAL
- en: Table 2-1\. Quarkus Maven Project Options
  prefs: []
  type: TYPE_NORMAL
- en: '| Attribute | Default Value | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `projectGroupId` | `com.redhat.cloudnative` | The group id of the created
    project. |'
  prefs: []
  type: TYPE_TB
- en: '| `projectArtifactId` | *mandatory* | The artifact id of the created project.
    Not passing it triggers the interactive mode. |'
  prefs: []
  type: TYPE_TB
- en: '| `projectVersion` | `1.0-SNAPSHOT` | The version of the created project. |'
  prefs: []
  type: TYPE_TB
- en: '| `platformGroupId` | `io.quarkus` | The group id of the target platform. Given
    that all the existing platforms are coming from io.quarkus, this one won’t be
    used explicitly. But it’s still an option. |'
  prefs: []
  type: TYPE_TB
- en: '| `platformArtifactId` | `quarkus-universe-bom` | The artifact id of the target
    platform BOM. It should be quarkus-bom in order to use the locally built Quarkus.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `platformVersion` | If it’s not specified, the latest one will be resolved.
    | The version of the platform you want the project to use. It can also accept
    a version range, in which case the latest from the specified range will be used.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `className` | *Not created if omitted* | The fully qualified name of the
    generated resource. |'
  prefs: []
  type: TYPE_TB
- en: '| `path` | `/hello` | The resource path, only relevant if className is set.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `extensions` | `[]` | The list of extensions to add to the project (comma-separated).
    |'
  prefs: []
  type: TYPE_TB
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'To check all the extensions available, use this command from project dir: `./mvnw
    quarkus:list-extensions`.'
  prefs: []
  type: TYPE_NORMAL
- en: Create a Domain Model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s time to write some code now and create a *domain model* and a RESTful endpoint
    to create the Inventory service. Domain model is a popular pattern in software
    engineering, and it also fits very well in the cloud native world. The level of
    abstraction given by the pattern makes it still valid as an object-oriented way
    of modeling microservices business logic.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the domain model definition in the `Inventory` class in this [book’s
    GitHub repository](https://oreil.ly/JE6CD).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our domain model implementation consists of an `Entity` mapped to the Persistence
    layer, representing an inventory of items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_the_path_to_cloud_native_java_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Entity` marks the class as a JPA entity.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_the_path_to_cloud_native_java_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Table` customizes the table creation process by defining a table name and
    database constraint in this case it is `INVENTORY`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_the_path_to_cloud_native_java_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Quarkus will generate `getter/setter` for you when using public attributes and
    when you extend `PanacheEntity`. Additionally, you have an `id` attribute automatically
    added.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we define the model, we can update our Properties expressed in the *application.properties*
    file in order to provide the instructions on how to populate data for our microservice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_the_path_to_cloud_native_java_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: JDBC path for the in-memory DB; this can be changed for other types of DB like
    any RDBMS.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_the_path_to_cloud_native_java_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: 'A SQL script that we’ll use to populate the Coolstore with some data:'
  prefs: []
  type: TYPE_NORMAL
- en: '`INSERT INTO INVENTORY(id, quantity) VALUES (100000, 0);`'
  prefs: []
  type: TYPE_NORMAL
- en: '`INSERT INTO INVENTORY(id, quantity) VALUES (329299, 35);`'
  prefs: []
  type: TYPE_NORMAL
- en: '`INSERT INTO INVENTORY(id, quantity) VALUES (329199, 12);`'
  prefs: []
  type: TYPE_NORMAL
- en: '`INSERT INTO INVENTORY(id, quantity) VALUES (165613, 45);`'
  prefs: []
  type: TYPE_NORMAL
- en: '`INSERT INTO INVENTORY(id, quantity) VALUES (165614, 87);`'
  prefs: []
  type: TYPE_NORMAL
- en: '`INSERT INTO INVENTORY(id, quantity) VALUES (165954, 43);`'
  prefs: []
  type: TYPE_NORMAL
- en: '`INSERT INTO INVENTORY(id, quantity) VALUES (444434, 32);`'
  prefs: []
  type: TYPE_NORMAL
- en: '`INSERT INTO INVENTORY(id, quantity) VALUES (444435, 53);`'
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_the_path_to_cloud_native_java_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: An `uber-jar` contains all the dependencies required packaged in the jar to
    enable running the application with `java -jar`. By default, in Quarkus, the generation
    of the `uber-jar` is disabled. With the `%prod` prefix, this option is only activated
    when building the jar intended for deployments.
  prefs: []
  type: TYPE_NORMAL
- en: Create a RESTful Service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Quarkus uses the JAX-RS standard for building REST services. When scaffolding
    a new project as we saw before, a *hello* example service is created in the *className*
    path we defined. Now we want to expose REST service to retrieve the number of
    available items in the store from the inventory, using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Path: */api/inventory/{itemId}*;'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'HTTP Method: `GET`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This returns the quantity for a given item id present in the inventory database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change the `InventoryResource` class definition as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_the_path_to_cloud_native_java_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: By extending `PanacheEntity`, we’re using the active record persistence pattern
    instead of a Data Access Obect (DAO). This means that all persistence methods
    are blended with our own `Entity`.
  prefs: []
  type: TYPE_NORMAL
- en: We just implemented a parametric REST endpoint for our microservice, serving
    the JSON representation of the items contained in our Coolstore. In this way we
    provided a layer to query via HTTP `GET` requests our `Inventory` Data Model we
    implemented in the previous step.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: With Quarkus, there is no need to create an `Application` class. It’s supported,
    but not required. In addition, only one instance of the resource is created and
    not one per request. You can configure this using the different Scoped annotations
    (`ApplicationScoped`, `RequestScoped`, etc).
  prefs: []
  type: TYPE_NORMAL
- en: Run the App in Dev Mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Development mode in Quarkus is one of the coolest features we have today for
    cloud native Java development. It enables hot deployment with background compilation,
    which means that when you modify your Java files or your resource files and then
    refresh your browser, the changes automatically take effect. This also works for
    resource files such as the configuration property file. In addition, refreshing
    the browser triggers a scan of the workspace, and if any changes are detected,
    the Java files are recompiled and the application is redeployed; your request
    is then serviced by the redeployed application. If there are any issues with compilation
    or deployment, an error page will let you know.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can start the app in dev mode with a built-in Maven goal named `quarkus:dev`.
    It enables hot deployment with background compilation, which means that when you
    modify your Java files or your resource files and refresh your browser, these
    changes will automatically take effect. This also works for resource files like
    the configuration property file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'After you start the app in dev mode, you should see an output like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: From the output, you can see that `Hibernate` created a database with the name
    of our domain model and populated it with some initial data defined in our Properties
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When we scaffolded the project at the beginning of this chapter, we included
    a series of dependencies like Panache and used it to map our data model as `Entity`
    into a database.
  prefs: []
  type: TYPE_NORMAL
- en: We can also see that our app is up and running, listening to port 8080\. If
    you open your browser now at [*http://localhost:8080*](http://localhost:8080),
    you will see a Quarkus welcome page (as in [Figure 2-4](#fig2-4)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Quarkus Welcome Page](Images/moej_0204.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-4\. Quarkus welcome page
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can stop the app running in Dev mode by using Ctrl-C from the same terminal
    where you launched it. When you run Quarkus 2 in Dev mode, it enables by default
    the Continuous Testing feature, where tests run immediately after code changes
    have been saved.
  prefs: []
  type: TYPE_NORMAL
- en: You can now try querying one of the items we inserted from the *import.sql*
    file to test if our microservice is running properly.
  prefs: []
  type: TYPE_NORMAL
- en: Just navigate to [*http://localhost:8080/api/inventory/329299*](http://localhost:8080/api/inventory/329299).
  prefs: []
  type: TYPE_NORMAL
- en: 'You should have the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The REST API returned a JSON object representing the inventory count for this
    product. Congratulations on your first cloud native microservice with Quarkus!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We are now going to develop the other microservices that will consume this one,
    so leave this open in order to have the Coolstore up and running at the end of
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Create a Catalog Microservice with Spring Boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Spring Boot](https://spring.io/projects/spring-boot) is an opinionated framework
    that makes it easy to create stand-alone [Spring-based](https://spring.io) applications
    with embedded web containers such as Tomcat (or JBoss Web Server), Jetty, and
    Undertow that you can run directly on the JVM using `java -jar`. Spring Boot also
    allows production of a war file that can be deployed on stand-alone web containers.'
  prefs: []
  type: TYPE_NORMAL
- en: The opinionated approach means many choices about Spring platform and third-party
    libraries are already made by Spring Boot so that you can get started with minimum
    effort and configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot is very popular for cloud native Java development because, quoting
    the official website, it makes it easy to create stand-alone, [production-grade
    Spring-based applications](https://oreil.ly/KYWe5) that you can “just run.” We
    will include Spring Boot in our architecture for a Catalog microservice (as shown
    in [Figure 2-5](#fig2-5)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Catalog Spring Boot microservice](Images/moej_0205.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-5\. Catalog Spring Boot microservice
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can find all the source code for creating the Spring Boot microservice in
    the [book’s GitHub repository](https://oreil.ly/M8ya6).
  prefs: []
  type: TYPE_NORMAL
- en: Create a Maven Project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Also in this case you can bootstrap your Spring Boot project either with Maven
    or Gradle. The easiest way to do this is with [Spring Initializr](https://start.spring.io),
    an online configurator that helps generate the project structure with all the
    dependencies needed.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we will use a Red Hat-supported Spring Boot version from [Red
    Hat Maven repositories](https://oreil.ly/mAJRs), using the Project Metadata defined
    in [Table 2-2](#spring_boot_maven_project_options).
  prefs: []
  type: TYPE_NORMAL
- en: Table 2-2\. Spring Boot Maven Project Options
  prefs: []
  type: TYPE_NORMAL
- en: '| Key | Value | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `modelVersion` | `4.0.0` | POM model version (always 4.0.0). |'
  prefs: []
  type: TYPE_TB
- en: '| `groupId` | `com.redhat.cloudnative` | Group or organization that the project
    belongs to. Often expressed as an inverted domain name. |'
  prefs: []
  type: TYPE_TB
- en: '| `artifactId` | `catalog` | Name to be given to the project’s library artifact
    (for example, the name of its JAR or WAR file). |'
  prefs: []
  type: TYPE_TB
- en: '| `version` | `1.0-SNAPSHOT` | Version of the project that is being built.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `name` | `CoolStore Catalog Service` | Name of the app. |'
  prefs: []
  type: TYPE_TB
- en: '| `description` | `CoolStore Catalog Service with Spring Boot` | A description
    for the app. |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s have a look at our *pom.xml* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_the_path_to_cloud_native_java_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Project metadata we generated by Initializr or manually
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_the_path_to_cloud_native_java_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot version used
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_the_path_to_cloud_native_java_CO5-3)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dependencies we need:'
  prefs: []
  type: TYPE_NORMAL
- en: 'JPA: Spring Data with JPA'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Spring Cloud](https://oreil.ly/n4oSG): support and tooling from Spring for
    cloud native Java apps'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'H2: an in-memory database that we will use for this purpose'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a minimal Spring Boot project with support for RESTful services and
    Spring Data with JPA for connecting to a database. Any new project contains no
    code other than the main class, in this case, the `CatalogApplication` class,
    which is there to bootstrap the Spring Boot application.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find it in this [book’s GitHub repository](https://oreil.ly/FK15g):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_the_path_to_cloud_native_java_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: A convenience annotation that adds autoconfiguration and component scan, and
    also enables defining extra configurations. It is equivalent to using `@Configuration`,
    `@EnableAutoConfiguration`, and `@ComponentScan` with their default attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Create a Domain Model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we need to provide some data to consume for our microservice representing
    the catalog of our Coolstore ecommerce website. Also here, we define a domain
    model for the high-level interaction with the Persistence layer, and an interface
    that enables the communication between a REST endpoint to expose the service and
    the data model (as shown in [Figure 2-6](#fig2-6)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Data Model flow](Images/moej_0206.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-6\. Data model flow
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The database is configured using the Spring application configuration file,
    which is located in the properties file `application.properties`. Let’s have a
    look at this file to see the database connection details.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find it in this [book’s GitHub repository](https://oreil.ly/cRnE6):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_the_path_to_cloud_native_java_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: JDBC URL for H2 DB
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_the_path_to_cloud_native_java_CO7-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Use of H2 in-memory database
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create our domain model, which is similar to the one we created for the
    Inventory microservice before.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find it in this [book’s GitHub repository](https://oreil.ly/s971w):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_the_path_to_cloud_native_java_CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Entity` marks the class as a JPA entity.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_the_path_to_cloud_native_java_CO8-2)'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Table` customizes the table creation process by defining a table name and
    database constraint, in this case a table named *CATALOG*.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_the_path_to_cloud_native_java_CO8-3)'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Id` marks the primary key for the table.'
  prefs: []
  type: TYPE_NORMAL
- en: Create a Data Repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Spring Data repository abstraction simplifies dealing with data models in Spring
    applications by reducing the amount of boilerplate code required to implement
    data access layers for various persistence stores. [Repository and its subinterfaces](https://oreil.ly/wUh7w)
    are the central concept in Spring Data, which is a marker interface to provide
    data manipulation functionality for the entity class that is being managed. When
    the application starts, Spring finds all interfaces marked as repositories and
    for each interface found, the infrastructure configures the required persistent
    technologies and provides an implementation for the repository interface.
  prefs: []
  type: TYPE_NORMAL
- en: We will now create a new Java interface named ProductRepository in the `com.redhat.cloudnative.catalog`
    package and extend the [CrudRepository interface](https://oreil.ly/gPUjj) in order
    to indicate to Spring that you want to expose a complete set of methods to manipulate
    the entity.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find it in this [book’s GitHub repository](https://oreil.ly/CIGc5):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_the_path_to_cloud_native_java_CO9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '[CrudRepository](https://oreil.ly/eRvCG): interface used to indicate to Spring
    that we want to expose a complete set of methods to manipulate the entity'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a domain model and a repository to retrieve the domain model,
    let’s create a RESTful service that returns the list of products.
  prefs: []
  type: TYPE_NORMAL
- en: Create a RESTful Service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Spring Boot uses Spring Web MVC as the default RESTful stack in Spring applications.
    We will now create a new Java class named `CatalogController` in the `com.redhat.cloudnative.catalog`
    package for that, exposing a REST endpoint. We’ll use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Path: */api/catalog/*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'HTTP Method: `GET`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This returns a catalog for all items available in the store, matching items
    from Inventory service with data from Catalog service.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find it in this [book’s GitHub repository](https://oreil.ly/SjQ4h):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_the_path_to_cloud_native_java_CO10-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`@RequestMapping` indicates the above REST service defines an endpoint that
    is accessible via HTTP `GET` at */api/catalog*.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_the_path_to_cloud_native_java_CO10-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot automatically provides an implementation for `ProductRepository`
    at runtime and injects it into the controller using the [`@Autowired` annotation](https://oreil.ly/nuvh0).
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_the_path_to_cloud_native_java_CO10-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The `repository` attribute on the controller class is used to retrieve the list
    of products from the databases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Everything is now ready to start our second microservice, which will listen
    to port 9000 to avoid conflicts with the other one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see an output like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Your app is now listening on port *9000* to the endpoint we configured; you
    can verify it by navigating to [*http://localhost:9000/api/catalog*](http://localhost:9000/api/catalog).
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see this output from the REST API returning a JSON object representing
    the product list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The output has been formatted in *pretty* mode in the book’s code listing. You’ll
    notice the combination of our items from the Quarkus Inventory microservice with
    the description and the price from the Spring Boot Catalog microservice. If you
    recall the info from the previous test with item 329299, it’s a Quarkus T-shirt.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations on creating your second microservice; now it’s time to connect
    a frontend to our backends. In order to do it, we will use a software API gateway
    with reactive Java in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Create a Gateway Service with Vert.x
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Eclipse Vert.x](https://vertx.io) is an event-driven toolkit for building
    reactive applications on the Java Virtual Machine (JVM). Vert.x does not impose
    a specific framework or packaging model; it can be used within your existing applications
    and frameworks in order to add reactive functionality by just adding the Vert.x
    jar files to the application classpath.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Eclipse Vert.x enables building reactive systems as defined by [The Reactive
    Manifesto](https://oreil.ly/jCg8t) and builds services that are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Responsive: to handle requests in a reasonable time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Resilient: to stay responsive in the face of failures'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Elastic: to stay responsive under various loads and be able to scale up and
    down'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Message-driven: components interact using asynchronous message passing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is designed to be event-driven and nonblocking. In fact, events are delivered
    into an event loop that must never be blocked. Unlike traditional applications,
    Vert.x uses a very small number of threads responsible for dispatching the events
    to event handlers. If the event loop is blocked, the events won’t be delivered
    anymore and therefore the code needs to be mindful of this execution model (as
    shown in [Figure 2-7](#fig2-7)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Vert.x Event Loop](Images/moej_0207.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-7\. Vert.x event loop
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In our architecture, this microservice will act as an asynchronous software
    API gateway, developed as a reactive Java microservice that efficiently routes
    and dispatches the traffic to the Inventory and Catalog component of our cloud
    native ecommerce website, as displayed in [Figure 2-8](#fig2-8).
  prefs: []
  type: TYPE_NORMAL
- en: '![API Gateway Vert.x microservice](Images/moej_0208.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-8\. API gateway Vert.x microservice
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can find the source code of this microservice in this [book’s GitHub repository](https://oreil.ly/6pe8n).
  prefs: []
  type: TYPE_NORMAL
- en: Create a Vert.x Maven Project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Vert.x supports both Maven and Gradle, and the easiest way to bootstrap a new
    Vert.x Maven project is through [a template project structure offered by the Vert.x
    community](https://oreil.ly/fuaVI). In our case, we are using Red Hat Maven repositories
    and added the settings shown in [Table 2-3](#vertx_maven_project_options).
  prefs: []
  type: TYPE_NORMAL
- en: Table 2-3\. Vert.x Maven Project Options
  prefs: []
  type: TYPE_NORMAL
- en: '| Key | Value | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `modelVersion` | `4.0.0` | POM model version (always 4.0.0). |'
  prefs: []
  type: TYPE_TB
- en: '| `groupId` | `com.redhat.cloudnative` | Group or organization that the project
    belongs to. Often expressed as an inverted domain name. |'
  prefs: []
  type: TYPE_TB
- en: '| `artifactId` | `gateway` | Name to be given to the project’s library artifact
    (a JAR in this case). |'
  prefs: []
  type: TYPE_TB
- en: '| `version` | `1.0-SNAPSHOT` | Version of the project that is being built.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `name` | `CoolStore Gateway Service` | Name of the app. |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s have a look at how the *pom.xml* will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_the_path_to_cloud_native_java_CO11-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Project metadata
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_the_path_to_cloud_native_java_CO11-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Vert.x version used
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_the_path_to_cloud_native_java_CO11-3)'
  prefs: []
  type: TYPE_NORMAL
- en: '`GatewayVerticle`: the name of the main verticle; it’s the entry point for
    our app'
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_the_path_to_cloud_native_java_CO11-4)'
  prefs: []
  type: TYPE_NORMAL
- en: 'A list of dependecies:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Vert.x libraries: *vertx-core*, *vertx-config*, *vertx-web*, *vertx-web-client*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Rx support for Vert.x](https://oreil.ly/ynXXu): vertx-rx-java2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create an API Gateway
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we want to create an API gateway as the entry point for the web frontend
    of our website, to access all backend services from a single place. This pattern
    is predictably called [API gateway](https://oreil.ly/6oZaE) and is a common practice
    in microservices architecture.
  prefs: []
  type: TYPE_NORMAL
- en: The unit of deployment in Vert.x is called a *verticle*. A verticle processes
    incoming events over an event loop, where events can be anything such as receiving
    network buffers, timing events, or messages sent by other verticles.
  prefs: []
  type: TYPE_NORMAL
- en: 'We define our main verticle as GatewayVerticle as we declared it previously
    in the *pom.xml*, and expose the REST endpoint that will be routed to the Catalog
    `/api/catalog`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Path: */api/catalog/*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'HTTP Method: `GET`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This routes the traffic to Catalog and returns a JSON object containing all
    items available in the store, matching items from Inventory service with data
    from Catalog service.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find it in this [book’s GitHub repository](https://oreil.ly/vkevU):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_the_path_to_cloud_native_java_CO12-1)'
  prefs: []
  type: TYPE_NORMAL
- en: A `Verticle` is created by extending from `AbstractVerticle` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_the_path_to_cloud_native_java_CO12-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The `start()` method creates an HTTP server.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_the_path_to_cloud_native_java_CO12-3)'
  prefs: []
  type: TYPE_NORMAL
- en: A `Router` is retrieved for mapping the REST endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_the_path_to_cloud_native_java_CO12-4)'
  prefs: []
  type: TYPE_NORMAL
- en: A REST endpoint is created for mapping `/api/catalog` Catalog endpoint through
    a `product()` function that will retrieve the content.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_the_path_to_cloud_native_java_CO12-5)'
  prefs: []
  type: TYPE_NORMAL
- en: An HTTP Server is created that listens on port 8090.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](Images/6.png)](#co_the_path_to_cloud_native_java_CO12-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Give `Inventory` microservice a hostname and port to connect to.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](Images/7.png)](#co_the_path_to_cloud_native_java_CO12-7)'
  prefs: []
  type: TYPE_NORMAL
- en: The microservice supports ENV vars to change its hostname and port from Properties;
    this is important for the portability of our architecture across clouds.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We use port 8090 to avoid conflict while running it in local development. The
    port number can also be changed with a property file as described in [the Vert.x
    Config doc](https://oreil.ly/OgGIP). When developing with microservices, the use
    of environment variables to map hosts and ports is highly encouraged; we use them
    to map Inventory and Catalog endpoints dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now ready to start our API gateway:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Let’s verify it is up and running and correctly routing traffic by navigating
    to [*http://localhost:8090/api/products*](http://localhost:8090/api/products).
  prefs: []
  type: TYPE_NORMAL
- en: 'You should get the JSON object from Catalog’s endpoint, in the pretty format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Our backend is now complete. We are ready to provide some data to show from
    a nice frontend.
  prefs: []
  type: TYPE_NORMAL
- en: Create a Frontend with Node.js and AngularJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Node.js](https://nodejs.org) is a popular open source framework for asynchronous
    event-driven JavaScript development. Even if this is a book about modern Java
    development, in microservices architecture it is common to have a heterogeneous
    environment with multiple programming languages and frameworks involved. The challenge
    here is how to let them communicate efficiently. One solution is having a common
    interface like API gateway exchanging messages via REST calls or queue systems.'
  prefs: []
  type: TYPE_NORMAL
- en: AngularJS is a JavaScript-based frontend web framework whose goal is to simplify
    both the development and the testing of such applications by providing a framework
    for client-side model–view–controller (MVC) and model–view–viewmodel (MVVM) architectures,
    as illustrated in [Figure 2-9](#fig2-9). When used with Node.js, it provides a
    fast way to easily bootstrap a frontend.
  prefs: []
  type: TYPE_NORMAL
- en: '![Node.js + AngularJS Dashboard](Images/moej_0209.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-9\. Node.js + AngularJS Dashboard
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can find the source code of this microservice in this [book’s GitHub repository](https://oreil.ly/fv5aa).
  prefs: []
  type: TYPE_NORMAL
- en: Run the Frontend
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All the HTML and JavaScript code has been prepared, and we are ready to link
    this frontend to our backends showing our Coolstore app up and running.
  prefs: []
  type: TYPE_NORMAL
- en: Get NPM
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[NPM](https://oreil.ly/aN4J3) is a package manager for JavaScript, similar
    to Maven, that will help us download all dependencies and start our frontend.'
  prefs: []
  type: TYPE_NORMAL
- en: Install dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can resolve all dependencies within the `web-nodejs` directory and by launching
    the `npm` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get an output like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Start the app
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are now ready to verify if our frontend can correctly consume the backend
    services through the API gateway, mapping images with the data received. Since
    we are in local development, we will use the environment variable to change the
    Node.js default port to avoid conflicts. We will also use an environment variable
    to map the API gateway REST endpoint, as shown in [Table 2-4](#frontend_environment_variables).
  prefs: []
  type: TYPE_NORMAL
- en: Table 2-4\. Frontend environment variables
  prefs: []
  type: TYPE_NORMAL
- en: '| ENV | Value | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `PORT` | 3000 | Global env for Node.js to map the port to use for starting
    the process; we use 3000 in this case. |'
  prefs: []
  type: TYPE_TB
- en: '| `COOLSTORE_GW_ENDPOINT` | `http://localhost:8090` | Enviroment variable defined
    in the frontend to map the API gateway service hostname. |'
  prefs: []
  type: TYPE_TB
- en: 'Start the app with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Navigate to the address where we exposed our Node.js app at [*http://localhost:3000*](http://localhost:3000).
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! Your cloud native Coolstore ecommerce website is up and running
    now; you can verify it in [Figure 2-10](#fig2-10).
  prefs: []
  type: TYPE_NORMAL
- en: '![Coolstore Demo complete](Images/moej_0210.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-10\. Coolstore demo complete
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we walked through a complete microservices-based architecture
    implementation, using different Java frameworks for different components. We gave
    an overview on how to split the typical monolithic approach into a more diverse
    and heterogeneous environment, lightweight and ready to run in multiple contexts
    such as local development or production systems. This is an example of what we
    call cloud native development.
  prefs: []
  type: TYPE_NORMAL
