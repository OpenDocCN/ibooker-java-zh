- en: Chapter 12\. Functions to Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we have a large Java codebase, our Java and Kotlin will have to coexist for
    some time. What can we do to support the conventions of both languages as we gradually
    translate the system to Kotlin?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: So far, we have shown the translation of code from Java to Kotlin happening
    all in one go. We have used automatic refactorings to perform the translation
    safely, but by the end, all the affected code has been converted to idiomatic
    Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: In large codebases, this is not always possible. We must continue to evolve
    features in Java while we are introducing Kotlin. Where there is a boundary between
    the two, we want to use conventional Java on one side and conventional Kotlin
    on the other. This is especially true when we convert foundational classes that
    support a lot of our system’s functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Foundational Class: Money'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every system contains some foundational classes that many parts of the codebase
    use. An example in Travelator is the `Money` class, which we first saw in [Chapter 3](ch03.html#java-to-kotlin-classes).
    Travelers need to budget for their trips. They want to compare costs of different
    travel options, see those costs converted to the their preferred currency, book
    things, pay for things, and so on. The `Money` class is so widely used that we
    cannot convert it and all the code that depends on it to idiomatic Kotlin in one
    fell swoop. We have to continue working on features that use `Money` in both Java
    and Kotlin while the conversion is ongoing.
  prefs: []
  type: TYPE_NORMAL
- en: This leaves us between Scylla and Charybdis. Do we leave `Money` as a Java class
    while we convert code that depends on it to Kotlin, but in the meantime limit
    the Kotlin features we can use in that dependent code? Or do we convert the `Money`
    class to Kotlin while we still have Java code using it, allowing us to use Kotlin
    features in dependent code but leaving the remaining Java code inconsistent and
    unconventional?
  prefs: []
  type: TYPE_NORMAL
- en: The fact that we even have these options is a testament to how well Kotlin/Java
    interop works in both directions. In practice, we don’t have to choose. With some
    cunning refactoring tactics and a few annotations to control how the Kotlin compiler
    generates code for the JVM, we can get the best of both worlds. We can define
    `Money` in Kotlin, allowing us to take advantage of Kotlin’s features, and still
    provide an idiomatic API for Java code that we are maintaining.
  prefs: []
  type: TYPE_NORMAL
- en: We converted the `Money` class to Kotlin in [Chapter 3](ch03.html#java-to-kotlin-classes).
    Since we left it at the end of that chapter, we have (without you, sorry) been
    able to make the code more concise without affecting Java code that depends on
    it. We refactored most of the methods to single-expression form ([Chapter 9](ch09.html#multi-to-single-expression-functions)),
    and we took advantage of Kotlin’s flow-sensitive type inference to simplify the
    `equals` method greatly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is `Money` now. It isn’t significantly different but has a lot less syntactic
    noise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 12.1 [operators.0:src/main/java/travelator/money/Money.kt]](https://java-to-kotlin.dev/code.html?ref=12.1&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=12.1&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: However, it still retains the grain of Java, as does the Kotlin code that uses
    it. The `Money` class follows conventions for value types that are common in [Modern
    Java](ch01.html#modern-java-style), but are not the way things are usually done
    in Kotlin. In particular, it uses methods of a companion object to create values,
    and it uses methods rather than operators for arithmetic.
  prefs: []
  type: TYPE_NORMAL
- en: In a monolingual codebase, it would be pretty straightforward to address those
    issues. However, we still have plenty of Java code that uses the `Money` class.
    We’ll continue to make changes in Java *and* Kotlin, until Kotlin has edged Java
    out altogether. In the meantime, we want to ensure that code that uses `Money`
    in either language is conventional enough not to frighten the horses.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a User-Defined Operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kotlin code that calculates with `Money` values is still rather clumsy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'It is not significantly different from the equivalent Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Using methods for arithmetic operations makes the calculation harder to read.
    It’s the best we can do in Java, but in Kotlin we can define arithmetic operators
    for our own classes, allowing us to write that calculation as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Taking addition as an example, let’s take a look at how we can give our `Money`
    class arithmetic operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'We give a class the `+` operator by writing an operator method or extension
    function called `plus`. For our `Money` class, we can rename the existing `add`
    method to `plus` and add the `operator` modifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 12.2 [operators.2:src/main/java/travelator/money/Money.kt]](https://java-to-kotlin.dev/code.html?ref=12.2&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=12.2&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: With this change, our Kotlin code can add `Money` values with the + operator,
    whereas the Java code calls `plus` as a method.
  prefs: []
  type: TYPE_NORMAL
- en: When we go to check in, though, we find that our rename has rippled across hundreds
    of files of Java code, introducing a name that doesn’t follow Java conventions.
    Java classes in the standard library with arithmetic operations, such as `BigDecimal`
    and `BigInteger`, all use the name `add`, not `plus`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can make a function appear to have different names in Java and Kotlin by
    annotating its definition with the `@JvmName` annotation. Let’s revert the change
    we just made and take another run at it, starting by annotating the method with
    `@JvmName("add")`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 12.3 [operators.3:src/main/java/travelator/money/Money.kt]](https://java-to-kotlin.dev/code.html?ref=12.3&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=12.3&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now when we rename the method to `plus`, our Java code is unchanged, and marking
    it as an operator allows both Java and Kotlin code to call the method according
    to their respective language conventions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 12.4 [operators.4:src/main/java/travelator/money/Money.kt]](https://java-to-kotlin.dev/code.html?ref=12.4&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=12.4&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: Is this desirable? It can be quite confusing to have the same method appear
    under different names in different parts of the same codebase. On the other hand,
    because it’s an operator method, the name `plus` should only appear in the definition
    of the method, and all uses of the method from Kotlin should be via the `+` operator.
    The phrase `operator fun plus` is more like a language keyword than a method name.
    IntelliJ navigates seamlessly between calls to `add` in Java and the definition
    of `operator plus` in Kotlin. On balance, your authors think it’s worth using
    the `@JvmName` annotation in this case, but in general you will need to come to
    an agreement within your team about how you use the `@JvmName` annotation to adjust
    Kotlin classes to Java clients.
  prefs: []
  type: TYPE_NORMAL
- en: Calling Our Operator from Existing Kotlin Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Looking at our Kotlin client code, we find we still have a problem. At the time
    of writing, IntelliJ does not have an automated refactoring to replace all direct
    calls to an operator method with use of the respective operator. Any of our Kotlin
    code that had been calling the `Money.add` method before we turned it into an
    operator will be left calling `Money.plus` as a method instead of using the `+`
    operator. IntelliJ can automatically refactor each of those call sites from a
    method call to an operator, but we would have to go through them one by one, invoking
    the refactoring individually.
  prefs: []
  type: TYPE_NORMAL
- en: To address this problem, we can use a sequence of refactoring steps to switch
    *all* our Kotlin code over to use the `+` operator at once, and leave in the code
    the capability to replay the steps as we convert more Java classes to Kotlin.
    So let’s re-revert our change and take yet another run at the conversion.
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, we’ll extract the entire body of the `add` method as a method called
    `plus` and make it a public, operator method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 12.5 [operators.6:src/main/java/travelator/money/Money.kt]](https://java-to-kotlin.dev/code.html?ref=12.5&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=12.5&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using IntelliJ’s automatic refactoring, we make `this` explicit in the call
    to `plus`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 12.6 [operators.7:src/main/java/travelator/money/Money.kt]](https://java-to-kotlin.dev/code.html?ref=12.6&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=12.6&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'From this form, IntelliJ lets us automatically refactor from method call to
    operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 12.7 [operators.8:src/main/java/travelator/money/Money.kt]](https://java-to-kotlin.dev/code.html?ref=12.7&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=12.7&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally we can transform the `add` method to single-expression form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 12.8 [operators.9:src/main/java/travelator/money/Money.kt]](https://java-to-kotlin.dev/code.html?ref=12.8&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=12.8&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: We now have two methods for addition. The `plus` operator implements the addition
    logic and is what we’d like all our Kotlin code to use in the future, but nothing
    calls it directly yet. The `add` method will remain for use by our Java code,
    while it exists, and its body contains the ideal syntax we would like to use in
    our Kotlin code.
  prefs: []
  type: TYPE_NORMAL
- en: We can convert all our Kotlin code that adds `Money` values to use the operator
    syntax by inlining the `Money.add` method. When we do, IntelliJ reports that it
    was unable to inline all the uses of `add`. That’s just what we want! We can’t
    inline Kotlin code into Java, so IntelliJ has inlined the body of the `add` method
    only into the Kotlin call sites and has kept its definition in the `Money` class
    because it is still called by Java. All our Kotlin code is now using the `+` operator,
    and our Java code is unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: In the future, when we translate more Java classes that add `Money` values to
    Kotlin, we can inline the `add` method again to make the converted Kotlin class
    use the `+` operator instead of method call syntax. As long as there is Java code
    in our codebase that calls it, IntelliJ will preserve the `add` method. After
    we’ve converted the last Java class that adds `Money`, IntelliJ will remove the
    now unused `add` method as part of the inline refactoring. Our codebase will then
    only use the `+` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Operators for Existing Java Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While we’re working on the `plus` method, we can also take the opportunity
    to use the `+` operator *inside* the method. The `Money` class represents its
    `amount` property as a `BigDecimal`, a class from the Java standard library. We
    can replace the call to the `Big​Deci⁠mal.add` method with the + operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 12.9 [operators.11:src/main/java/travelator/money/Money.kt]](https://java-to-kotlin.dev/code.html?ref=12.9&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=12.9&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: Our code continues to compile. How is that possible?
  prefs: []
  type: TYPE_NORMAL
- en: 'The Kotlin standard library includes extension functions that define operators
    for classes in the Java standard library: mathematical classes, such as `BigInteger`
    and `BigDecimal`, and collections, such as `List<T>` or `Set<T>`. Because these
    extension functions are defined in the `kotlin` package, they are available to
    any package automatically: we don’t need to import them.'
  prefs: []
  type: TYPE_NORMAL
- en: Conventions for Denoting Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The static `of` functions on the companion object, used to denote `Money` values,
    also break Kotlin conventions.
  prefs: []
  type: TYPE_NORMAL
- en: Java syntax distinguishes between instantiating a class with the `new` operator
    and obtaining an object as the result of a method call. A [Modern Java](ch01.html#modern-java-style)
    convention is that stateful objects, for which identity is significant, are constructed
    with the new operator, and values are denoted by calls to static factory functions.
    For example, the expression `new ArrayList<>()` constructs a new mutable list
    distinct from any other mutable list, while the expression `List.of("a","b","c")`
    denotes an immutable list value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kotlin does not draw a distinction between constructing objects and calling
    functions: the syntax for instantiating a class is the same as that for calling
    a function. Nor are there coding conventions to distinguish between constructing
    a new stateful object that has a distinct identity and denoting values that do
    not.'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Although the Kotlin code for calling a function and instantiating a class look
    the same, they are implemented by different JVM bytecode. A source-compatible
    change between calling a constructor and a function will not be binary compatible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Where a class needs multiple factory functions, as does our `Money` class,
    they are usually defined as top-level functions, not on the companion object of
    the class. IntelliJ does its bit to nudge one toward this style: it is much better
    at autosuggesting top-level functions than methods on a companion object.'
  prefs: []
  type: TYPE_NORMAL
- en: So, it would be more conventional if we created `Money` instances with expressions
    like `Money(...)` or, alternatively, `moneyOf(...)`, rather than `Money.of(...)`.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw in [Chapter 3](ch03.html#java-to-kotlin-classes), `Money` has a private
    constructor (and isn’t a data class) to preserve the relationship between its
    currency and the precision of its `amount`. So it looks like the easiest option
    would be to define top-level `moneyOf` functions in the same source file as the
    `Money` class. However, those `moneyOf` functions would have to call the `Money`
    class’s constructor. They can’t call it if it is still declared as `private`,
    but could if we change the constructor to `internal`.
  prefs: []
  type: TYPE_NORMAL
- en: Internal visibility would make the constructor visible to any Kotlin code in
    the same compilation unit (Gradle subproject or IntelliJ module) but prevent it
    from being called by Kotlin code in other compilation units. The compilation unit,
    rather than the class, would be responsible for guaranteeing the invariants of
    the `Money` class by never calling its constructor inappropriately. That would
    be safe enough if it wasn’t for those Java parts of our system that we will continue
    to maintain during our system’s transition to Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: Java and the JVM do not have the concept of internal visibility. The Kotlin
    compiler translates internal features of a class to a public feature in the JVM
    class files it generates, and records the internal visibility as additional metadata
    that is processed by the Kotlin compiler but ignored by the Java compiler. As
    a result, Kotlin features declared as internal appear to be public to the Java
    compiler and JVM, allowing us to create invalid `Money` values accidentally when
    we’re working in the Java code of our project. That makes top-level `moneyOf`
    functions an unattractive option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, we can lean on Kotlin’s operator overloading again. If we define a
    function call operator for the `Money` class’s companion object, Kotlin code can
    create `Money` values by using the same syntax as if they were directly calling
    the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'It won’t actually be a constructor call, though; in longhand it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Just as we found when renaming the `add` method to `plus`, if we try to achieve
    this by merely renaming `of` to `invoke`, we will have a knock-on effect on our
    Java code. Java code that creates `Money` values changes from reading as `Money.of(BigDecimal(100),
    EUR)` to `Money.invoke(BigDecimal(100), EUR)`. The `of` methods had *two* responsibilities:
    to enforce the class invariants when constructing `Money` values, and to provide
    syntactic sugar in the caller that conforms to Modern Java conventions for denoting
    values. Renaming from `of` to `invoke` doesn’t affect the former but messes up
    the latter.'
  prefs: []
  type: TYPE_NORMAL
- en: We can use the same combination of extract method and refactor the call to the
    extracted method and inline method to avoid any negative effects on our Java code
    as we refactor our Kotlin code to follow Kotlin conventions.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, extract the `of` method’s entire body as a method called `invoke`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 12.10 [operators.12:src/main/java/travelator/money/Money.kt]](https://java-to-kotlin.dev/code.html?ref=12.10&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=12.10&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then make `invoke` a public operator method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 12.11 [operators.13:src/main/java/travelator/money/Money.kt]](https://java-to-kotlin.dev/code.html?ref=12.11&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=12.11&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now call the `Money` companion object as a function that looks like
    a constructor. So how come the call to `Money(...)` in the body of the `invoke`
    method does not overflow the call stack? Inside the `invoke` method, the call
    to `Money(...)` is not a recursive call to `invoke` but actually calls the private
    `Money` constructor. Outside the class, a call to `Money(...)` calls the companion
    object’s `invoke` method, because the private constructor is not visible. We have
    the best of both worlds: conventional syntax for creating instances of the class,
    and an encapsulation boundary that guarantees the class’s invariants.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To make existing Kotlin code use the new syntax, we need to first make the
    companion object’s `of` method call itself as a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 12.12 [operators.14:src/main/java/travelator/money/Money.kt]](https://java-to-kotlin.dev/code.html?ref=12.12&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=12.12&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: Then, we inline the `of` method into our Kotlin code. Again, Java code will
    not be affected, and when no Java code is calling the `of` method, the IDE will
    remove it for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before the inline refactoring, Kotlin code that creates `Money` values looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 12.13 [operators.16:src/main/java/travelator/money/ExchangeRates.kt]](https://java-to-kotlin.dev/code.html?ref=12.13&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=12.13&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'After the inline refactoring, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 12.14 [operators.17:src/main/java/travelator/money/ExchangeRates.kt]](https://java-to-kotlin.dev/code.html?ref=12.14&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=12.14&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: We’re left with a class that is conventional and convenient, whether we’re using
    it from Kotlin or Java.
  prefs: []
  type: TYPE_NORMAL
- en: Moving On
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java and Kotlin have different conventions that work with the different grains
    of the two languages.
  prefs: []
  type: TYPE_NORMAL
- en: We don’t want our use of Kotlin to have a negative effect on our Java or leave
    our Kotlin code as mere Java in Kotlin syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Using annotations and delegation, we can ensure that both Kotlin and Java code
    follow their respective language conventions during the transition to Kotlin.
    The extract-and-inline refactoring combination makes this easy to add to our codebase,
    and to remove when no longer needed.
  prefs: []
  type: TYPE_NORMAL
