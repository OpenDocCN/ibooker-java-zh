- en: Chapter 8\. Reactive Programming with Project Reactor and Spring WebFlux
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduces reactive programming, discusses its origins and reasons
    for being, and demonstrates how Spring is leading the development and advancement
    of numerous tools and technologies that make it one of the best possible solutions
    for numerous use cases. More specifically, I demonstrate how to use Spring Boot
    and Project Reactor to drive database access using SQL and NoSQL databases, integrate
    reactive types with view technologies like Thymeleaf, and take interprocess communication
    to unexpected new levels with RSocket.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Code Checkout Checkup
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Please check out branch *chapter8begin* from the code repository to begin.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Reactive Programming
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While a full treatise on reactive programming could—and has, and will—consume
    an entire book, it’s critical to understand why it’s such an important concept
    in the first place.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: In a typical service, a thread is created for each request to be handled. Each
    thread requires resources, and as such, the number of threads that an application
    can manage is limited. As a somewhat simplified example, if an app can service
    200 threads, that application can accept requests from up to 200 discrete clients
    at once, but no more; any additional attempts to connect to the service must wait
    for a thread to become available.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Performance for the 200 connected clients may or may not be satisfactory, depending
    on a number of factors. What is uncontestable is that for the client application
    making concurrent request number 201 and up, response time may be dramatically
    worse due to blocking by the service while it waits for an available thread. This
    hard stop in scalability can go from nonissue to crisis without warning and with
    no simple solution, and workarounds like the traditional “throw more instances
    at the problem” introduce both pressure relief and new problems to solve. Reactive
    programming was created to address this scalability crisis.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '[The Reactive Manifesto](https://www.reactivemanifesto.org) states that reactive
    systems are:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Responsive
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resilient
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Elastic
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Message driven
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a nutshell, the four key points of reactive systems as listed combine to
    create (at the macro level) a maximally available, scalable, and performant system
    requiring the fewest resources possible to do the job effectively.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'Speaking at a systems level, i.e., several applications/services working together
    to fulfill various use cases, we might notice that most of the challenges involve
    communication between applications: one app responding to another, app/service
    availability when requests arrive, the ability of a service to scale out or in
    to adjust to demand, one service notifying other interested services of updated/available
    information, etc. Addressing the potential pitfalls of interapplication interactions
    can go a long way toward mitigating and/or solving the scalability issues referenced
    earlier.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'This very observation of communication being the greatest potential source
    of issues and consequently the greatest opportunity for their resolution led to
    the [Reactive Streams initiative](http://www.reactive-streams.org). The Reactive
    Streams (RS) initiative focuses on the interactions among services—the Streams,
    if you will—and includes four key elements:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这一观察表明，通信是问题的主要潜在来源，因此也是解决问题的最大机会，这导致了[响应式流倡议](http://www.reactive-streams.org)的发起。响应式流（RS）倡议关注服务之间的交互——即流，包括四个关键元素：
- en: The Application Programming Interface (API)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序编程接口（API）
- en: The specification
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规范
- en: Examples for implementations
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现示例
- en: The Technology Compatibility Kit (TCK)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 技术兼容性套件（TCK）
- en: 'The API consists of only four interfaces:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: API仅包含四个接口：
- en: '`Publisher`: Creator of things'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Publisher`：事物的创建者'
- en: '`Subscriber`: Consumer of things'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Subscriber`：事物的消费者'
- en: '`Subscription`: Contract between Publisher and Subscriber'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Subscription`：发布者和订阅者之间的合同'
- en: '`Processor`: Incorporates both Subscriber and Publisher in order to receive,
    transform, and dispatch things'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Processor`：同时包括Subscriber和Publisher，用于接收、转换和分发事物'
- en: This lean simplicity is key, as is the fact that the API consists solely of
    *interfaces* and not *implementations*. This allows for various interoperable
    implementations across different platforms, languages, and programming models.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这种精简的简洁性至关重要，同样重要的是API仅由*接口*而非*实现*组成。这允许在不同平台、语言和编程模型之间实现各种互操作的实现。
- en: 'The textual specification details expected and/or required behavior for API
    implementations. For example:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 文本规范详细说明了API实现的预期和/或必需行为。例如：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Examples for implementations are useful aids for implementors, providing reference
    code for use when creating a particular RS implementation.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 实现示例对于实现者是有用的辅助工具，提供了在创建特定RS实现时使用的参考代码。
- en: Perhaps the most critical piece is the Technology Compatibility Kit. The TCK
    enables implementors to verify and demonstrate the level of compatibility—and
    any current shortcomings—with their RS implementation (or someone else’s). Knowledge
    is power, and identifying anything that doesn’t work in full compliance with the
    specification can speed resolution while providing a warning to current library
    consumers until the shortcoming is resolved.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 或许最关键的部分是技术兼容性套件。 TCK使实现者能够验证和展示其RS实现（或其他人的实现）与规范的兼容性水平及当前存在的任何缺陷。知识就是力量，识别出与规范不完全兼容的任何问题可以加速解决，同时向当前库使用者提供警告，直到问题得到解决。
- en: Project Reactor
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Project Reactor
- en: Although there are several available Reactive Streams implementations for the
    JVM, Project Reactor is among the most active, advanced, and performant. Reactor
    has been adopted by and provides the essential underpinnings for numerous mission-critical
    projects worldwide, including libraries, APIs, and applications developed and
    deployed by small organizations and global tech titans alike. Adding to this impressive
    momentum of development and adoption is the fact that Reactor provides the foundation
    for Spring’s WebFlux reactive web capabilities, Spring Data’s reactive database
    access for several open source and commercial databases, and interapplication
    communication, allowing for the creation of end-to-end reactive pipelines from
    top of stack to bottom and laterally as well. It’s a 100% solution.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然JVM有几种可用的响应式流实现，但是Project Reactor是其中最活跃、最先进和性能最优的之一。 Reactor已被全球许多小型组织和全球科技巨头开发和部署的图书馆、API和应用程序采纳，并提供了许多关键项目的基础，包括Spring的WebFlux响应式Web能力和Spring
    Data的多个开源和商业数据库的响应式数据库访问。 Reactor还允许从堆栈顶部到底部以及侧面创建端到端响应式管道，增加了开发和采纳的强劲动力。这是一个百分之百的解决方案。
- en: Why is this important?
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这为什么重要？
- en: From top of stack to bottom, from end user to lowest-tier computing resource,
    each interaction provides a potential sticking point. If interactions between
    the user’s browser and the backend application are nonblocking but the app has
    to wait for a blocking interaction with the database, the result is a blocking
    system. The same goes with interapplication communication; if the user’s browser
    communicates with backend Service A but Service A blocks waiting for a response
    from Service B, what has the user gained? Probably very little, and possibly nothing
    at all.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 从堆栈的顶部到底部，从最终用户到最低层计算资源，每个交互都提供了一个潜在的粘附点。如果用户的浏览器与后端应用程序之间的交互是非阻塞的，但是应用程序必须等待与数据库的阻塞交互，那么结果就是一个阻塞系统。与应用程序之间的通信情况相同；如果用户的浏览器与后端服务A通信，但是服务A阻塞等待来自服务B的响应，用户获得了什么？可能很少，甚至可能什么都没有。
- en: Developers usually can see the vast potential a switch to Reactive Streams offers
    them and their systems. A counterweight to that is the change in mindset that,
    combined with the relative newness of reactive (vs. imperative) programming constructs
    and tooling, can require adjustment and a bit more work from developers to harness,
    at least in the short term. This is still an easy decision to make as long as
    the effort required is clearly exceeded by the scalability benefits and the breadth
    and depth of Reactive Stream’s application within overall systems. Having reactive
    pipelines throughout the entirety of a system’s applications is a force multiplier
    on both counts.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员通常可以看到切换到Reactive Streams为他们和他们的系统带来的巨大潜力。与此相对应的是，相对于命令式编程构造和工具的相对新颖性，以及这种变化所需要的思维方式的变化，可能需要开发人员进行调整和更多的工作，至少在短期内是这样。只要所需的努力明显超过了可扩展性的好处，以及在整体系统中应用反应流的广度和深度，这仍然是一个容易的决定。在系统的所有应用程序中具有反应式管道是两个方面的乘数。
- en: Project Reactor’s implementation of Reactive Streams is clean and simple, building
    on concepts with which Java and Spring developers are already well acquainted.
    Resembling Java 8+’s Stream API, Reactor is best utilized via declarative, chained
    operators, often with lambdas. Compared to more procedural, imperative code, it
    first feels somewhat different and then fairly elegant. Familiarity with `Stream`
    speeds the acclimatization and appreciation.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Project Reactor对Reactive Streams的实现简洁而简单，构建在Java和Spring开发人员已经熟悉的概念之上。类似于Java
    8+的Stream API，Reactor最好通过声明性的、链式的操作符使用，通常与lambda一起使用。与更为程序化、命令式的代码相比，它首先感觉有些不同，然后相当优雅。熟悉`Stream`会加速适应和欣赏。
- en: 'Reactor takes the concept of a Reactive Streams `Publisher` and specializes
    it, providing constructs similar to imperative Java in the process. Rather than
    using a common `Publisher` for everything in which a Reactive Stream—think of
    it as an on-demand, dynamic `Iterable`—is required, Project Reactor defines two
    types of `Publisher`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Reactor将反应流`Publisher`的概念进行了特殊化，提供了类似于命令式Java的构造。与为需要反应流的所有东西使用通用的`Publisher`不同——将其视为按需的、动态的`Iterable`——Project
    Reactor定义了两种类型的`Publisher`：
- en: '`Mono`:: emits 0 or 1 element `Flux`:: emits 0 to *n* elements, a defined number
    or boundless'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mono`:: 发出0或1个元素 `Flux`:: 发出0到*n*个元素，一个定义的数量或无限的'
- en: This aligns brilliantly with imperative constructs. For example, in standard
    Java, a method may return an object of type T or an `Iterable<T>`. Using Reactor,
    that same method would return a `Mono<T>` or a `Flux<T>`—one object or potentially
    many, or in the case of the reactive code, a `Publisher` of those objects.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这与命令式构造完美地契合。例如，在标准Java中，一个方法可以返回类型为T的对象或`Iterable<T>`。使用Reactor，同样的方法将返回一个`Mono<T>`或一个`Flux<T>`——一个对象或可能很多，或者在反应性代码的情况下，这些对象的`Publisher`。
- en: Reactor also fits very naturally into Spring’s opinions. Depending on the use
    case, converting from blocking to nonblocking code can be as simple as changing
    a project dependency and a few method return values as shown previously. This
    chapter’s examples demonstrate how to do exactly that, along with extending outward—up,
    down, and laterally—to go from a single reactive application to a reactive system,
    including reactive database access, for maximum benefit.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Reactor也非常自然地适用于Spring的观点。根据用例，从阻塞到非阻塞代码的转换可能就像改变项目依赖项和一些方法返回值一样简单，如前所示。本章的示例演示了如何做到这一点，以及向外扩展——向上、向下和横向——从单个反应性应用程序转移到反应性系统，包括反应性数据库访问，以实现最大的收益。
- en: Tomcat versus Netty
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较Tomcat和Netty
- en: In the imperative world of Spring Boot, Tomcat is the default servlet engine
    used for web applications, although even at that level, developers have options
    like Jetty and Undertow that can be used as drop-in replacements. Tomcat makes
    a great deal of sense as a default, though, as it is established, proven, and
    performant, and Spring team developers have contributed (and still do contribute)
    to refining and evolving Tomcat’s codebase. It’s a superb servlet engine for Boot
    applications.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Spring Boot 的命令式世界中，Tomcat 是默认的 Servlet 引擎，用于 Web 应用程序，尽管在这个级别上，开发人员还可以选择像
    Jetty 和 Undertow 这样的替代方案。作为默认选项，Tomcat 是一个非常合理的选择，因为它经过验证、性能优越，并且 Spring 团队的开发人员已经（仍在）为优化和演进
    Tomcat 的代码库做出贡献。它是 Boot 应用程序的出色 Servlet 引擎。
- en: That said, numerous iterations of the servlet specification have been intrinsically
    synchronous with no async capabilities. Servlet 3.0 began to address this with
    asynchronous request processing but still only supported traditional blocking
    I/O. Version 3.1 of the spec added nonblocking I/O, making it suitable for asynchronous,
    and thus also reactive, applications.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，Servlet 规范的许多迭代从根本上是同步的，没有异步能力。Servlet 3.0 开始通过异步请求处理来解决这个问题，但仍然只支持传统的阻塞
    I/O。规范的 3.1 版本增加了非阻塞 I/O，使其适用于异步，因此也适用于响应式应用程序。
- en: Spring WebFlux is the name for Spring’s reactive counterpart to Spring WebMVC
    (package name), usually referred to simply as Spring MVC. Spring WebFlux is built
    on Reactor and uses Netty as the default network engine, just as Spring MVC uses
    Tomcat to listen for and service requests. Netty is a proven and performant asynchronous
    engine, and Spring team developers also contribute to Netty to tightly integrate
    Reactor and keep Netty on the cutting edge of features and performance.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Spring WebFlux 是 Spring 对应 Spring WebMVC（包名）的响应式实现，通常简称为 Spring MVC 的对应物。Spring
    WebFlux 基于 Reactor 构建，并使用 Netty 作为默认的网络引擎，就像 Spring MVC 使用 Tomcat 监听和处理请求一样。Netty
    是一个经过验证和高性能的异步引擎，Spring 团队的开发人员也为 Netty 做出贡献，以紧密集成 Reactor 并保持 Netty 的功能和性能处于前沿。
- en: Just as with Tomcat, though, you have options. Any Servlet 3.1–compatible engine
    can be used with Spring WebFlux applications, should your mission or organization
    require it. Netty is the category leader for a reason, however, and for the vast
    majority of use cases, it is the best choice.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 Tomcat 一样，您也有选择权。任何 Servlet 3.1 兼容的引擎都可以与 Spring WebFlux 应用程序一起使用，如果您的任务或组织需要的话。然而，Netty
    凭借其领先地位和大多数用例的优势，通常是最佳选择。
- en: Reactive Data Access
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式数据访问
- en: As mentioned previously, the ultimate goal for ultimate scalability and optimal
    systemwide throughput is a fully end-to-end reactive implementation. At the lowest
    level, this rests on database access.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前提到的，最终目标是实现全面的可扩展性和最佳的系统范围吞吐量，这依赖于完全端到端的响应式实现。在最低级别，这取决于数据库访问。
- en: Years of effort have gone into designing databases in ways to minimize contention
    and system performance blockages. Even with this impressive work, there are areas
    that remain problematic in many database engines and drivers, among them means
    for performing operations without blocking the requesting application(s) and sophisticated
    flow control/backpressure mechanisms.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，设计数据库以减少争用和系统性能阻塞的工作已经付出了很多努力。即使在这项令人印象深刻的工作中，许多数据库引擎和驱动程序仍然存在问题，其中包括在没有阻塞请求应用程序的情况下执行操作以及复杂的流控制/反压机制。
- en: Paging constructs have been used to address both of these constraints, but they
    are imperfect solutions. Using an imperative model with paging typically requires
    a query to be issued for each page with a different range and/or constraints.
    This requires a new request and new response each time instead of the continuation
    that is possible with a `Flux`. An analogy is scooping up one cup of water at
    a time from a basin (imperative approach) versus simply turning on the tap to
    refill the cup. Rather than a “go get, bring back” imperative operation, the water
    is waiting to flow in the reactive scenario.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 分页构造已被用来解决这些约束，但它们并不完美。使用带分页的命令式模型通常需要为每一页发出一个不同范围和/或约束的查询。这需要每次都发出新请求和新响应，而不是像`Flux`那样的继续操作。类比是从水池中每次舀一杯水（命令式方法）与直接打开水龙头来重新灌满杯子。与“去获取，带回”的命令式操作不同，在响应式情景下，水已经等待流动。
- en: R2DBC with H2
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: R2DBC 与 H2
- en: In the existing version of PlaneFinder, I use the Java Persistence API (JPA)
    and the H2 database to store (in an in-memory instance of H2) aircraft positions
    retrieved from my local device that monitors in-range aircraft. JPA was built
    on an imperative specification and is thus inherently blocking. Seeing the need
    for a nonblocking reactive means of interacting with SQL databases, several industry
    leaders and luminaries joined forces to create and evolve the Reactive Relational
    Database Connectivity (R2DBC) project.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在现有版本的 PlaneFinder 中，我使用 Java Persistence API（JPA）和 H2 数据库来存储（在内存中的 H2 实例中）从我监视的本地设备中检索到的飞机位置。JPA
    是基于命令规范构建的，因此本质上是阻塞的。看到需要一种非阻塞的响应式方式与 SQL 数据库交互，几位行业领导者和知名人士联手创建和演进了响应式关系数据库连接（R2DBC）项目。
- en: Like JPA, R2DBC is an open specification that can be used, along with the Service
    Provider Interface (SPI) it provides, by vendors or other interested parties to
    create drivers for relational databases and client libraries for downstream developers.
    Unlike JPA, R2DBC builds on Project Reactor’s implementation of Reactive Streams
    and is fully reactive and nonblocking.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 像 JPA 一样，R2DBC 是一个开放的规范，可以与其提供的服务提供者接口（SPI）一起使用，供供应商或其他感兴趣的方进行驱动程序的开发，并为下游开发人员创建客户端库。与
    JPA 不同，R2DBC 基于 Project Reactor 的响应式流实现，并且完全响应式和非阻塞。
- en: Updating PlaneFinder
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新 PlaneFinder
- en: 'As with most complex systems, we don’t (currently) control all aspects and
    nodes of the entire distributed system. Also like most complex systems, the more
    completely a paradigm is embraced, the more can be gained from it. I start this
    “journey to reactive” as close to the point of origin of the communication chain
    as possible: in the PlaneFinder service.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数复杂系统一样，我们目前并不控制整个分布式系统的所有方面和节点。像大多数复杂系统一样，越完全地采纳一种范式，从中可以获得的收益就越多。我会从通信链的起点尽可能接近的地方开始这段“响应式之旅”：在
    PlaneFinder 服务中。
- en: 'Refactoring PlaneFinder to use Reactive Streams `Publisher` types, e.g., `Mono`
    and `Flux`, is the first step. I’ll stay with the existing H2 database, but in
    order to “reactiv-ate” it, I need to remove the JPA project dependency and replace
    it with R2DBC libraries. I update PlaneFinder’s *pom.xml* Maven build file as
    follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 重构 PlaneFinder 以使用响应式流 `Publisher` 类型，如 `Mono` 和 `Flux`，是第一步。我会继续使用现有的 H2 数据库，但为了“响应式化”它，需要删除
    JPA 项目依赖，并将其替换为 R2DBC 库。我将更新 PlaneFinder 的 *pom.xml* Maven 构建文件如下：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `PlaneRepository` interface must be updated to extend the `ReactiveCrudRepository`
    interface instead of its blocking counterpart `CrudRepository`. This simple update
    is shown here:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlaneRepository` 接口必须更新为扩展 `ReactiveCrudRepository` 接口，而不是其阻塞的对应项 `CrudRepository`。这个简单的更新如下所示：'
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The change to `PlaneRepository` ripples outward, which leads naturally to the
    next stop, the `PlaneFinderService` class, where the `getAircraft()` method returns
    the result of `PlaneRepository::saveAll` when aircraft are found and of the `saveSamplePositions()`
    method otherwise. Replacing the value returned, a blocking `Iterable<Aircraft>`,
    with `Flux<Aircraft>` for the `getAircraft()` and `saveSamplePositions()` methods
    again correctly specifies the method return value.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `PlaneRepository` 的更改会向外扩散，这自然而然地导致下一个停靠点，即 `PlaneFinderService` 类，其中 `getAircraft()`
    方法返回 `PlaneRepository::saveAll` 的结果（当找到飞机时），或者 `saveSamplePositions()` 方法的结果（否则）。将返回值从阻塞的
    `Iterable<Aircraft>` 替换为 `Flux<Aircraft>`，用于 `getAircraft()` 和 `saveSamplePositions()`
    方法再次正确指定方法返回值。
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Since the `PlaneController` class’s method `getCurrentAircraft()` calls `PlaneFinderService::getAircraft`,
    it now returns a `Flux<Aircraft>`. This necessitates a change to the signature
    for `PlaneController::getCurrentAircraft` as well:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `PlaneController` 类的方法 `getCurrentAircraft()` 调用 `PlaneFinderService::getAircraft`，现在它返回
    `Flux<Aircraft>`。这需要对 `PlaneController::getCurrentAircraft` 的签名进行更改如下：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Using H2 with JPA is a fairly mature affair; the specifications involved, along
    with the relevant APIs and libraries, have been under development for roughly
    a decade. R2DBC is a relatively recent development, and while support is expanding
    apace, a few features present in the Spring Data JPA’s support for H2 have yet
    to be implemented. This doesn’t pose much of an increased burden but is something
    to keep in mind when choosing to use a relational database—in this case, H2—reactively.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 H2 与 JPA 是一个相当成熟的事务；涉及的规范、相关的 API 和库已经开发了大约十年。R2DBC 是一个相对较新的开发，虽然支持正在迅速扩展，但在
    Spring Data JPA 对 H2 的支持中，还有一些功能尚未实现。这并不会增加太多负担，但在选择使用关系数据库（如 H2）时，需要记住这一点，要以响应式的方式进行。
- en: 'Currently, to use H2 with R2DBC, it is necessary to create and configure a
    `ConnectionFactoryInitializer` bean for use by the application. Configuration
    requires only two steps in reality:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，要使用 H2 与 R2DBC，必须为应用程序创建和配置一个`ConnectionFactoryInitializer` bean。实际上，配置只需要两个步骤：
- en: Setting the connection factory to the (already autoconfigured) `ConnectionFactory`
    bean, injected as a parameter
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将连接工厂设置为（已自动配置的）`ConnectionFactory` bean，作为参数注入
- en: Configuring the database “populator” to execute one or more scripts to initialize
    or reinitialize the database as desired/required
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置数据库“填充器”以执行一个或多个脚本，以初始化或重新初始化数据库，如所需。
- en: Recall that when using Spring Data JPA with H2, an associated `@Entity` class
    is used to create a corresponding table within the H2 database. This step is completed
    manually when using H2 with R2DBC using a standard SQL DDL (Data Definition Language)
    script.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，使用 Spring Data JPA 与 H2 时，使用相关的`@Entity`类来在 H2 数据库中创建相应的表。当使用 H2 与 R2DBC
    时，通过标准的 SQL DDL（数据定义语言）脚本手动完成此步骤。
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-68
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This is an additional step, but it isn’t without precedent. Many SQL databases
    require this step when used with Spring Data JPA as well; H2 was an exception
    to the rule.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个额外的步骤，但并非没有先例。许多 SQL 数据库在与 Spring Data JPA 结合使用时都需要这一步；H2 是个例外。
- en: 'Next up is the code for the `DbConxInit`, or Database Connection Initializer,
    class. The required bean-creation method is the first one—`initializer()`—that
    produces the needed `ConnectionFactoryInitializer` bean. The second method produces
    a `CommandLineRunner` bean that is executed once the class is configured. `CommandLineRunner`
    is a functional interface with a single abstract method, `run()`. As such, I provide
    a lambda as its implementation, populating (and then listing) the contents of
    the `PlaneRepository` with a single `Aircraft`. Currently I have the `@Bean` annotation
    for the `init()` method commented out, so the method is never called, the `CommandLineRunner`
    bean is never produced, and the sample record is never stored:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`DbConxInit`或数据库连接初始化器类的代码。需要的 bean 创建方法是第一个——`initializer()`——产生所需的`ConnectionFactoryInitializer`
    bean。第二个方法生成一个`CommandLineRunner` bean，一旦类被配置，就会被执行。`CommandLineRunner` 是一个具有单个抽象方法
    `run()` 的函数接口。因此，我提供了一个 lambda 作为其实现，用一个`Aircraft`填充（然后列出）`PlaneRepository`的内容。目前，我已经注释掉了`init()`方法的`@Bean`注解，因此该方法从未被调用，`CommandLineRunner`
    bean 从未被生成，并且示例记录从未被存储：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `CommandLineRunner` lambda merits some explanation.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`CommandLineRunner` lambda 需要一些解释。'
- en: The structure itself is a typical lambda of `x -> { <code to execute here> }`,
    but the code contained within has a couple of interesting Reactive Streams–specific
    features.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 结构本身是一个典型的 lambda 表达式，如 `x -> { <在此执行的代码> }`，但其中包含的代码具有一些有趣的 Reactive Streams
    特定特性。
- en: The first declared operation is `repo::save`, which saves the content provided—in
    this case, a new `Aircraft` object—and returns a `Mono<Aircraft>`. It’s possible
    to simply `subscribe()` to this result and log/print it for verification. But
    a good habit to adopt is to save all desired sample data, then query the repository
    to produce all records. Doing so allows for full verification of the final state
    of the table at that point in time and should result in all records being displayed.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个声明的操作是`repo::save`，它保存提供的内容——在本例中是一个新的`Aircraft`对象——并返回一个`Mono<Aircraft>`。可以简单地`subscribe()`到这个结果并打印日志/输出来验证。但是养成的一个好习惯是保存所有所需的示例数据，然后查询存储库以生成所有记录。这样做允许完全验证此时表的最终状态，并应显示所有记录。
- en: Recall, though, that reactive code doesn’t block, so how can one be certain
    that all previous operations have completed prior to proceeding? In this case,
    how can we be sure all records are saved before trying to retrieve all records?
    Within Project Reactor there are operators that await the completion signal, then
    proceed with the next function in the chain. The `then()` operator waits for a
    `Mono` as input, then accepts another `Mono` to play going forward. The `thenMany()`
    operator shown in the previous example awaits the completion of any upstream `Publisher`
    and plays a new `Flux` going forward. In the `init` method that produces the `CommandLineRunner`
    bean, `repo.findAll()` produces a `Flux<Aircraft>`, filling the bill as expected.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Finally, I subscribe to the `Flux<Aircraft>` output from `repo.findAll()` and
    print the results to the console. It isn’t necessary to log the results, and in
    fact a plain `subscribe()` fulfills the requirement to start the flow of data.
    But why is it necessary to subscribe?
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: With few exceptions, ` `Reactive Streams Publisher` `s are *cold publishers*,
    meaning they perform no work and consume no resources if they have no subscriber(s).
    This maximizes efficiency and thus scalability and makes perfect sense, but it
    also provides a common trap for those new to reactive programming. If you aren’t
    returning a `Publisher` to calling code for subscription and use there, be sure
    to add a `subscribe()` to it to activate the `Publisher` or chain of operations
    that results in one.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Finally, some changes to the domain class `Aircraft` are required due to differences
    in JPA and R2DBC and their supporting H2 code. The `@Entity` notation used by
    JPA is no longer required, and the `@GeneratedValue` annotation for the primary
    key-associated member variable `id` is now similarly unnecessary. Removing both
    of these and their associated import statements are the only required changes
    when migrating from PlaneFinder from JPA to R2DBC using H2.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'To accommodate the `CommandLineRunner` bean shown earlier (should sample data
    be desired) and its field-limited constructor call, I create an additional constructor
    in `Aircraft` to match. Note that this is required only if you wish to create
    an `Aircraft` instance without providing all parameters as required by the constructor
    Lombok based on the `@AllArgsConstructor` annotation. Note that I call the all-args
    constructor from this limited-args constructor:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With that, it’s time to verify our work.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'After starting the PlaneFinder application from within the IDE, I return to
    HTTPie in a terminal window to test the updated code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Confirming that the refactored, reactive PlaneFinder works properly, we can
    now turn our attention to the Aircraft Positions application.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Updating the Aircraft Positions application
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Currently the *aircraft-positions* project uses Spring Data JPA and H2, just
    as PlaneFinder did when it was a blocking application. While I could update Aircraft
    Positions to use R2DBC and H2 just as PlaneFinder now does, this required refactoring
    of the *aircraft-positions* project offers the perfect opportunity to explore
    other reactive database solutions.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 目前*aircraft-positions*项目使用Spring Data JPA和H2，就像当它是一个阻塞应用程序时的PlaneFinder一样。虽然我可以将Aircraft
    Positions更新为使用R2DBC和H2，就像PlaneFinder现在所做的那样，但这需要对*aircraft-positions*项目进行重构，为了探索其他反应式数据库解决方案，这是一个绝佳的机会。
- en: MongoDB is often at the forefront of database innovation, and indeed it was
    one of the first database providers of any kind to develop fully reactive drivers
    for use with its namesake database. Developing applications using Spring Data
    and MongoDB is nearly frictionless, reflecting the maturity of its reactive streams
    support. For the reactive refactoring of Aircraft Positions, MongoDB is a natural
    choice.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB经常处于数据库创新的前沿，事实上，它是第一个为其同名数据库开发完全反应式驱动程序的任何类型的数据库提供商之一。使用Spring Data和MongoDB开发应用几乎没有摩擦，这反映了其反应式流支持的成熟性。对于飞行器位置的反应式重构，MongoDB是一个自然的选择。
- en: 'Some changes to the build file, *pom.xml* in this case, are in order. First
    I remove the unnecessary dependencies for Spring MVC, Spring Data JPA, and H2:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对构建文件（在本例中为*pom.xml*）进行一些更改是有必要的。首先，我删除了Spring MVC、Spring Data JPA和H2的不必要的依赖项：
- en: '`spring-boot-starter-web`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-boot-starter-web`'
- en: '`spring-boot-starter-data-jpa`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-boot-starter-data-jpa`'
- en: '`h2`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`h2`'
- en: 'Next I add the following dependencies for the reactive version going forward:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我为未来的反应式版本添加以下依赖项：
- en: '`spring-boot-starter-data-mongodb-reactive`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-boot-starter-data-mongodb-reactive`'
- en: '`de.flapdoodle.embed.mongo`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`de.flapdoodle.embed.mongo`'
- en: '`reactor-test`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reactor-test`'
- en: Note
  id: totrans-96
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '`spring-boot-starter-webflux` was already a dependency due to `WebClient`,
    so it wasn’t necessary to add it.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`WebClient`，`spring-boot-starter-webflux`已经是一个依赖项，所以不需要额外添加。
- en: 'As in [Chapter 6](ch06.xhtml#sbur-06), I will make use of the embedded MongoDB
    for this example. Since the embedded MongoDB is typically used only for testing,
    it usually includes a scope of “test”; since I use this during application execution,
    I omit or remove that scoping qualifier from the build file. The updated Maven
    *pom.xml* dependencies look like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正如[第6章](ch06.xhtml#sbur-06)中所述，我将在此示例中使用嵌入式MongoDB。由于嵌入式MongoDB通常仅用于测试，因此通常包括一个“测试”的范围；由于我在应用程序执行期间使用此功能，因此我会从构建文件中省略或删除该范围限定符。更新后的Maven
    *pom.xml* 依赖关系如下所示：
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: A quick refresh to the dependencies either via command line or the IDE and we’re
    ready to refactor.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通过命令行或IDE快速刷新依赖项，我们就可以开始重构了。
- en: 'I begin again with the very simple change to the `AircraftRepository` interface,
    changing it to extend `ReactiveCrudRepository` instead of the blocking `CrudRepository`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我首先从对`AircraftRepository`接口的非常简单的更改开始，将其更改为扩展阻塞`CrudRepository`的`ReactiveCrudRepository`：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Updating the `PositionController` class is a fairly small chore, since `WebClient`
    already converses using Reactive Streams `Publisher` types. I define a local variable
    `Flux<Aircraft> aircraftFlux`, then chain the requisite declarative operations
    to clear the repository of previously retrieved aircraft positions, retrieve new
    positions, convert them to instances of the `Aircraft` class, filter out positions
    without a listed aircraft registration number, and save them to the embedded MongoDB
    repository. I then add the `aircraftFlux` variable to the `Model` for use in the
    user-facing web UI and return the name of the Thymeleaf template for rendering:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`PositionController`类是一个相当小的任务，因为`WebClient`已经使用反应式流`Publisher`类型进行交流。我定义了一个局部变量`Flux<Aircraft>
    aircraftFlux`，然后链式调用所需的声明操作来清除先前检索到的飞行器位置，检索新的位置，将它们转换为`Aircraft`类的实例，过滤掉没有列出飞行器注册号的位置，并将它们保存到嵌入式MongoDB存储库中。然后，我将`aircraftFlux`变量添加到`Model`中以供用户界面使用，并返回Thymeleaf模板的名称进行渲染：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, a few small changes are required for the domain class `Aircraft` itself.
    The class-level `@Entity` annotation is JPA-specific; the corresponding annotation
    used by MongoDB is `@Document`, indicating that instances of a class are to be
    stored as documents within the database. Additionally, the `@Id` annotation used
    previously referenced `javax.persistence.Id`, which disappears without the JPA
    dependency. Replacing `import javax.persistence.Id;` with `import org.springframework.data.annotation.Id;`
    retains the table identifier context for use with MongoDB. The class file in its
    entirety is shown for reference:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，需要对领域类`Aircraft`本身进行一些小的更改。类级别的`@Entity`注解是JPA特定的；MongoDB使用的相应注解是`@Document`，表示类的实例将存储为数据库中的文档。此外，先前使用的`@Id`注解引用了`javax.persistence.Id`，在没有JPA依赖项的情况下消失了。将`import
    javax.persistence.Id;`替换为`import org.springframework.data.annotation.Id;`保留了与MongoDB一起使用的表标识符上下文。完整的类文件如下所示以供参考：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Running both the PlaneFinder and Aircraft Positions applications, I return to
    a browser tab and type *http://localhost:8080* into the address bar and load it,
    resulting in the page shown in [Figure 8-1](#the_aircraft_positions_applications_landing_page_index_html).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 运行PlaneFinder和Aircraft Positions应用程序后，返回浏览器选项卡并在地址栏中输入*http://localhost:8080*，加载页面，结果如图[8-1](#the_aircraft_positions_applications_landing_page_index_html)所示。
- en: '![sbur 0801](Images/sbur_0801.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![sbur 0801](Images/sbur_0801.png)'
- en: Figure 8-1\. The Aircraft Positions application landing page, *index.html*
  id: totrans-109
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8-1\. 飞机位置应用程序登陆页面，*index.html*
- en: Clicking on the *Click here* link loads the `Aircraft Positions` report page,
    as shown in [Figure 8-2](#the_aircraft_position_report_page_8).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 点击*点击这里*链接加载`飞机位置`报告页面，如图[8-2](#the_aircraft_position_report_page_8)所示。
- en: '![sbur 0802](Images/sbur_0802.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![sbur 0802](Images/sbur_0802.png)'
- en: Figure 8-2\. The Aircraft Positions report page
  id: totrans-112
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8-2\. 飞机位置报告页面
- en: 'With each periodic refresh, the page will requery PlaneFinder and update the
    report with current data on demand as before, with one very key difference: the
    multiple aircraft positions that are supplied to the *positions.html* Thymeleaf
    template for display are no longer a fully formed, blocking `List` but rather
    a Reactive Streams `Publisher`, specifically of type `Flux`. The next section
    addresses this further, but for now, it’s important to realize that this content
    negotiation/accommodation occurs with no effort required from the developer.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 每次定期刷新时，页面将重新查询PlaneFinder，并根据需要更新报告，但有一个非常重要的区别：供显示的多个飞机位置不再是完全形成的、阻塞的`List`，而是Reactive
    Streams的`Publisher`，具体是`Flux`类型。接下来的部分将进一步讨论这一点，但现在重要的是要意识到这种内容协商/适应是无需开发人员努力的。
- en: Reactive Thymeleaf
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式Thymeleaf
- en: As mentioned in [Chapter 7](ch07.xhtml#sbur-07), the vast majority of frontend
    web applications are now being developed using HTML and JavaScript. This doesn’t
    alter the existence of a number of production applications that use view technologies/templating
    to fulfill their objectives; neither does it imply that said technologies don’t
    continue to satisfy a range of requirements simply and effectively. This being
    the case, it’s important for template engines and languages to adapt to circumstances
    in which Reactive Streams are also brought to bear on a problem.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第7章](ch07.xhtml#sbur-07)中所述，现在绝大多数前端Web应用程序都是使用HTML和JavaScript开发的。这并不改变使用视图技术/模板来实现其目标的许多生产应用程序的存在；也并不意味着这些技术不继续简单有效地满足一系列要求。在这种情况下，对模板引擎和语言进行适应以适应Reactive
    Streams的情况非常重要。
- en: Thymeleaf approaches RS support at three different levels, allowing developers
    to settle on the one that best fits their requirements. As mentioned earlier,
    it’s possible to convert backend processing to leverage Reactive Streams and let
    Reactor feed Thymeleaf values supplied by a `Publisher`—like a `Mono` or `Flux`—instead
    of `Object<T>` and `Iterable<T>`. This doesn’t result in a reactive frontend,
    but if the concern is primarily conversion of backend logic to use Reactive Streams
    to eliminate blocking and implement flow control among services, this is a frictionless
    on-ramp to deploying a supporting user-facing application with the least possible
    effort.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Thymeleaf also supports chunked and data-driven modes in support of Spring WebFlux,
    both involving the use of Server Sent Events and some JavaScript code to accomplish
    the feed of data to the browser. While both of these modalities are entirely valid,
    the increased amount of JavaScript required to achieve the desired outcome may
    tip the scales away from templating+HTML+JavaScript and toward 100% HTML+JavaScript
    frontend logic. This decision is heavily dependent on requirements, of course,
    and should be left to the developer(s) tasked with creating and supporting said
    functionality.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding section, I demonstrated how to migrate the backend functionality
    to RS constructs and how Spring Boot uses Reactor+Thymeleaf to maintain functionality
    in the front end, helping ease conversions of blocking systems of applications
    while minimizing downtime. This is sufficient to satisfy the current use case,
    allowing us to examine ways to further improve backend functionality before returning
    (in an upcoming chapter) to expanding frontend capabilities.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: RSocket for Fully Reactive Interprocess Communication
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Already in this chapter I’ve laid the groundwork for interprocess communication
    using Reactive Streams between separate applications. While the distributed system
    created does indeed use reactive constructs, the system has yet to reach its potential.
    Crossing the network boundary using higher-level HTTP-based transports imposes
    limitations due to the request-response model, and even upgrading to WebSocket
    alone doesn’t address all of them. RSocket was created to eliminate interprocess
    communication shortfalls flexibly and powerfully.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: What Is RSocket?
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The result of a collaboration among several industry leaders and cutting-edge
    innovators, RSocket is a blazing-fast binary protocol that can be used over TCP,
    WebSocket, and Aeron transport mechanisms. RSocket supports four asynchronous
    interaction models:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Request-response
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Request-stream
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fire & forget
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Request channel (bidirectional stream)
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'RSocket builds on the reactive streams paradigm and Project Reactor, enabling
    fully interconnected systems of applications while providing mechanisms that increase
    flexibility and resilience. Once a connection is made between two apps/services,
    distinctions of client versus server disappear and the two are effectively peers.
    Any of the four interaction models can be initiated by either party and accommodate
    all use cases:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: RSocket 建立在反应式流范式和 Project Reactor 之上，可以实现完全互联的应用程序系统，同时提供增加灵活性和韧性的机制。一旦两个应用程序/服务之间建立连接，客户端与服务器的区别消失了，它们实际上是对等的。任何一方都可以启动四种交互模型之一，并适应所有用例：
- en: A 1:1 interaction in which one party issues a request and receives a response
    from the other party
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 1:1 的交互，其中一方发出请求并从另一方接收响应
- en: A 1:N interaction in which one party issues a request and receives a stream
    of responses from the other party
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 1:N 的交互，其中一方发出请求并从另一方接收一系列响应
- en: A 1:0 interaction in which one party issues a request
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 1:0 的交互，其中一方发出请求
- en: A fully bidirectional channel in which both parties can send requests, responses,
    or data streams of any kind unbidden
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个完全双向的通道，双方都可以自由地发送请求、响应或任何类型的数据流
- en: As you can see, RSocket is incredibly flexible. Being a binary protocol with
    a performance focus, it is also fast. On top of that, RSocket is resilient, making
    it possible for a dropped connection to be reestablished and communications to
    automatically resume where they left off. And since RSocket is built on Reactor,
    developers who use RSocket can truly consider separate applications as a fully
    integrated system, since the network boundary no longer imposes any limitations
    on flow control.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，RSocket 非常灵活。作为一种性能重点的二进制协议，它也非常快速。此外，RSocket 具有韧性，使得可以重新建立断开的连接，并在通信中自动恢复中断的地方。而且由于
    RSocket 建立在 Reactor 之上，使用 RSocket 的开发人员可以真正将单独的应用程序视为完全集成的系统，因为网络边界不再对流量控制施加任何限制。
- en: Spring Boot, with its legendary autoconfiguration, arguably provides the fastest,
    most developer-friendly way for Java and Kotlin developers to use RSocket.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot 以其传说中的自动配置，可以说为 Java 和 Kotlin 开发人员提供了使用 RSocket 的最快、最友好的方式。
- en: Putting RSocket to Work
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 把 RSocket 投入使用
- en: Currently both the PlaneFinder and Aircraft Positions applications use HTTP-based
    transports to communicate. Converting both Spring Boot apps to use RSocket is
    the obvious next step forward.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，PlaneFinder 和 Aircraft Positions 应用都使用基于 HTTP 的传输进行通信。将这两个 Spring Boot 应用程序转换为使用
    RSocket 是明显的下一步。
- en: Migrating PlaneFinder to RSocket
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将 PlaneFinder 迁移到 RSocket
- en: 'First, I add the RSocket dependency to the PlaneFinder build file:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我将 RSocket 依赖添加到 PlaneFinder 的构建文件中：
- en: '[PRE13]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: After a quick Maven re-import, it’s off to refactor the code.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 快速进行 Maven 重新导入后，就可以开始重构代码了。
- en: 'For the time being, I’ll leave the existing endpoint of */aircraft* intact
    and add an RSocket endpoint to `PlaneController`. In order to place both REST
    endpoints and RSocket endpoints in the same class, I decouple the functionality
    built into the `@RestController` annotation into its component parts: `@Controller`
    and `@ResponseBody`.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 暂时，我会保留 */aircraft* 的现有端点，并在 `PlaneController` 中添加一个 RSocket 端点。为了将 REST 端点和
    RSocket 端点放置在同一个类中，我将 `@RestController` 注解中内置的功能解耦成其组成部分：`@Controller` 和 `@ResponseBody`。
- en: 'Replacing the class-level `@RestController` annotation with `@Controller` means
    that for any REST endpoints from which we wish to return objects directly as JSON—such
    as the existing */aircraft* endpoint associated with the `getCurrentAircraft()`
    method—it is necessary to add `@ResponseBody` to the method. The advantage to
    this seeming step back is that RSocket endpoints can then be defined in the same
    `@Controller` class as REST endpoints, keeping points of ingress and egress for
    PlaneFinder in one, and only one, location:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 将类级别的 `@RestController` 注解替换为 `@Controller` 意味着对于我们希望直接返回 JSON 对象的任何 REST 端点（例如与
    `getCurrentAircraft()` 方法关联的现有 */aircraft* 端点），需要向方法中添加 `@ResponseBody`。这种看似退步的优势在于，然后可以在同一个
    `@Controller` 类中定义 RSocket 端点，将 PlaneFinder 的入口点和出口点放在一个且仅有一个位置：
- en: '[PRE14]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To create a repeating stream of aircraft positions sent initially and at subsequent
    one-second intervals, I create the `getCurrentACStream()` method and annotate
    it as an RSocket endpoint with `@MessageMapping`. Note that since RSocket mappings
    don’t build upon a root path as HTTP addresses/endpoints do, no forward slash
    (/) is required in the mapping.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个重复发送飞行器位置的流，首先和随后每一秒的流，我创建了`getCurrentACStream()`方法，并使用`@MessageMapping`注解它作为一个RSocket端点。请注意，由于RSocket映射不像HTTP地址/端点那样建立在根路径之上，因此在映射中不需要斜杠(/)。
- en: 'With the endpoint and servicing method defined, the next step is to designate
    a port for RSocket to listen for connection requests. I do so in PlaneFinder’s
    *application.properties* file, adding a property value for `spring.rsocket.server.port`
    to the existing one for the HTTP-based `server.port`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了端点和服务方法之后，下一步是为RSocket指定一个端口来监听连接请求。我在PlaneFinder的*application.properties*文件中执行此操作，为基于HTTP的`server.port`添加了一个用于`spring.rsocket.server.port`的属性值：
- en: '[PRE15]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The presence of this single RSocket server port assignment is sufficient for
    Spring Boot to configure the containing application as an RSocket server, creating
    all necessary beans and performing all of the requisite configuration. Recall
    that while one of the two applications involved in an RSocket connection must
    act initially as a server, once the connection is established the distinction
    between client (the app that initiates a connection) and server (the app that
    listens for a connection) evaporates.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个单个的RSocket服务器端口分配，Spring Boot就足以配置包含应用程序为RSocket服务器的所有必要bean并执行所有必要的配置。请注意，虽然RSocket连接中涉及的两个应用程序中必须有一个起初充当服务器，但一旦连接建立，客户端（发起连接的应用程序）和服务器（监听连接的应用程序）之间的区别就消失了。
- en: With those few changes, PlaneFinder is now RSocket ready. Simply start the application
    to ready it for connection requests.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些少量更改，PlaneFinder现在已准备好使用RSocket。只需启动应用程序即可准备好接收连接请求。
- en: Migrating Aircraft Positions to RSocket
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将飞行器位置迁移到RSocket
- en: 'Once again, the first step in adding RSocket is to add the RSocket dependency
    to the build file—in this case, for the Aircraft Positions application:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，添加RSocket的第一步是将RSocket依赖项添加到构建文件中——在这种情况下是针对飞行器位置应用程序：
- en: '[PRE16]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Don’t forget to re-import and thus activate changes with Maven for the project
    prior to continuing. Now, on to the code.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在继续之前使用Maven重新导入并激活项目中的更改。现在，进入代码部分。
- en: Similarly to how I did with PlaneFinder, I refactor the `PositionController`
    class to create a single point for all ingress/egress. Replacing the class-level
    `@RestController` annotation with `@Controller` allows for the inclusion of RSocket
    endpoints along with the HTTP-based (but template-driven, in this case) endpoint
    that activates the *positions.html* Thymeleaf template.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于我在PlaneFinder中所做的，我重构了`PositionController`类以创建所有进出口的单一点。用`@Controller`替换类级别的`@RestController`注解允许包含RSocket端点以及基于HTTP的（但在这种情况下是模板驱动的）端点，该端点激活*positions.html*
    Thymeleaf模板。
- en: To enable Aircraft Positions to act as an RSocket client, I create an `RSocketRequester`
    by autowiring via constructor injection an `RSocketRequester.Builder` bean. The
    `RSocketRequester.Builder` bean is automatically created by Spring Boot as a result
    of adding the RSocket dependency to the project. Within the constructor, I use
    the builder to create a TCP connection (in this case) to PlaneFinder’s RSocket
    server via the builder’s `tcp()` method.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使飞行器位置能够作为RSocket客户端运行，我通过构造函数注入一个`RSocketRequester.Builder` bean来创建一个`RSocketRequester`。`RSocketRequester.Builder`
    bean是由Spring Boot自动创建的，因为将RSocket依赖项添加到项目中。在构造函数中，我使用该构建器通过`tcp()`方法创建到PlaneFinder的RSocket服务器的TCP连接（在本例中）。
- en: Note
  id: totrans-154
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Since I need to inject a bean (`RSocketRequester.Builder`) used to create an
    instance of a different object (`RSocketRequester`), I must create a constructor.
    Since I now have a constructor, I removed the class-level `@RequiredArgsConstructor`
    and member variable-level `@NonNull` Lombok annotations and simply add `AircraftRepository`
    to the constructor I wrote as well. Either way, Spring Boot autowires the bean,
    and it is assigned to the `repository` member variable.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在我需要注入一个(`RSocketRequester.Builder`)用于创建一个不同对象(`RSocketRequester`)的bean时，我必须创建一个构造函数。现在我有了构造函数，我移除了类级别的`@RequiredArgsConstructor`和成员变量级别的`@NonNull`
    Lombok注解，简单地将`AircraftRepository`添加到我编写的构造函数中。无论哪种方式，Spring Boot都会自动装配该bean，并将其分配给`repository`成员变量。
- en: 'To verify the RSocket connection is working properly and data is flowing, I
    create an HTTP-based endpoint */acstream*, specify it will return a stream of
    Server Sent Events (SSE) as a result, and with the `@ResponseBody` annotation
    indicate that the response will comprise JSON-formatted objects directly. Using
    the `RSocketRequester` member variable initialized in the constructor, I specify
    the `route` to match the RSocket endpoint defined in PlaneFinder, send some `data`
    (optional; I don’t pass any useful data in this particular request), and retrieve
    the `Flux` of `Aircraft` returned from PlaneFinder:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证 RSocket 连接是否正常工作并且数据正在流动，我创建了一个基于 HTTP 的端点 */acstream*，指定它将作为结果返回一系列服务器发送事件（SSE），并使用
    `@ResponseBody` 注解指示响应将直接包含 JSON 格式化的对象。使用在构造函数中初始化的 `RSocketRequester` 成员变量，我指定了要匹配
    PlaneFinder 中定义的 RSocket 端点的 `route`，发送了一些 `data`（可选；在这个特定请求中我没有传递任何有用的数据），并检索从
    PlaneFinder 返回的 `Aircraft` 的 `Flux`：
- en: '[PRE17]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To verify the RSocket connection is viable and PlaneFinder is feeding data
    to the Aircraft Positions application, I start Aircraft Positions and return to
    the terminal and HTTPie, adding the *-S* flag to the command to process the data
    as a stream, as it arrives, rather than wait for a response body completion. An
    example of the results follows, edited for brevity:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证 RSocket 连接是否可行，并且 PlaneFinder 是否正在向 Aircraft Positions 应用程序提供数据，我启动了 Aircraft
    Positions 并返回到终端和 HTTPie，添加了 *-S* 标志到命令中，以在数据到达时将其作为流进行处理，而不是等待响应体完成。下面是结果的一个示例，由于篇幅限制已编辑：
- en: '[PRE18]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This confirms that data is flowing from PlaneFinder to Aircraft Positions via
    Reactive Streams over an RSocket connection using the *request-stream* model.
    All systems go.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这证实了数据通过 RSocket 连接从 PlaneFinder 流向 Aircraft Positions，使用 *request-stream* 模型进行
    Reactive Streams。一切正常。
- en: Code Checkout Checkup
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码检出检查
- en: For complete chapter code, please check out branch *chapter8end* from the code
    repository.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取完整的章节代码，请从代码存储库中检出 *chapter8end* 分支。
- en: Summary
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Reactive programming gives developers a way to make better use of resources,
    and in an increasingly distributed world of interconnected systems, the master
    key to scalability involves extending scaling mechanisms beyond application boundaries
    and into the communication channels. The Reactive Streams initiative, and in particular
    Project Reactor, serves as a powerful, performant, and flexible foundation for
    maximizing system-wide scalability.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程为开发人员提供了一种更好地利用资源的方式，在一个日益分布式的互联系统世界中，扩展可伸缩性的主要关键在于将扩展机制扩展到应用程序边界之外并进入通信渠道。响应式流倡议，特别是
    Project Reactor，作为最大化系统范围可伸缩性的强大、高效和灵活的基础。
- en: In this chapter, I introduced reactive programming and demonstrated how Spring
    is leading the development and advancement of numerous tools and technologies.
    I explained blocking and nonblocking communication and the engines that provide
    those capabilities, e.g., Tomcat, Netty, and others.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我介绍了响应式编程，并演示了 Spring 如何引领众多工具和技术的发展和进步。我解释了阻塞和非阻塞通信以及提供这些功能的引擎，例如 Tomcat、Netty
    等。
- en: Next, I demonstrated how to enable reactive database access to SQL and NoSQL
    databases by refactoring the PlaneFinder and Aircraft Positions applications to
    use Spring WebFlux/Project Reactor. Reactive Relational Database Connectivity
    (R2DBC) provides a reactive replacement for the Java Persistence API (JPA) and
    works with several SQL databases; MongoDB and other NoSQL databases provide drop-in
    reactive drivers that work seamlessly with Spring Data and Spring Boot.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我演示了如何通过重构 PlaneFinder 和 Aircraft Positions 应用程序来使用 Spring WebFlux/Project
    Reactor 实现对 SQL 和 NoSQL 数据库的响应式数据库访问。Reactive Relational Database Connectivity
    (R2DBC) 提供了对 Java Persistence API (JPA) 的响应式替代，并与多个 SQL 数据库配合使用；MongoDB 和其他 NoSQL
    数据库提供了与 Spring Data 和 Spring Boot 无缝配合的响应式驱动程序。
- en: This chapter also discussed options for frontend integration of reactive types
    and demonstrated how Thymeleaf provides a limited migration path if your applications
    are still using generated view technologies. Additional options will be considered
    in future chapters.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还讨论了响应式类型的前端集成选项，并演示了如果您的应用程序仍在使用生成的视图技术，则 Thymeleaf 提供了有限的迁移路径。未来的章节将考虑其他选项。
- en: Finally, I demonstrated how to take interprocess communication to unexpected
    new levels with RSocket. Doing so via Spring Boot’s RSocket support and autoconfiguration
    provides the fast path to performance, scalability, resilience, and developer
    productivity.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我演示了如何通过RSocket将进程间通信提升到意想不到的新水平。通过Spring Boot的RSocket支持和自动配置，可以提供快速的性能、可伸缩性、弹性和开发者生产力的快捷路径。
- en: 'In the next chapter, I’ll dig into testing: how Spring Boot enables better,
    faster, and easier testing practices, how to create effective unit tests, and
    how to hone and focus testing to speed the build-and-test cycle.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我将深入探讨测试：Spring Boot如何实现更好、更快、更容易的测试实践，如何创建有效的单元测试，以及如何磨练和专注于测试以加快构建和测试周期。
