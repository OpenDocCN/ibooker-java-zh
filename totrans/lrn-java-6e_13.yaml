- en: Chapter 13\. Network Programming in Java
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 13 章\. Java 网络编程
- en: When you think about the web, you probably think of web-based applications and
    services. If you are asked to go deeper, you may consider tools such as web browsers
    and web servers that support those applications and move data around the network.
    In this chapter, we’ll look at how Java interacts with web services. We’ll also
    peek under the hood a bit and discuss some of the lower-level networking classes
    of the *java.net* package.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想到网络时，你可能会想到基于网络的应用和服务。如果你被要求深入探讨，你可能会考虑支持这些应用程序并在网络中传输数据的工具，例如网络浏览器和网络服务器。在本章中，我们将看一下
    Java 如何与网络服务交互。我们还会稍微窥探一下底层的网络类，例如 *java.net* 包中的一些低级网络类。
- en: Uniform Resource Locators
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 统一资源定位符
- en: 'A *Uniform Resource Locator* (URL) points to an object on the internet. It’s
    a text string that identifies an item, tells you where to find it, and specifies
    a method for communicating with it or retrieving it from its source. A URL can
    point to any kind of information source: static data, such as a file on a local
    filesystem, a web server, or an FTP site. It can point to a more dynamic object,
    such as an RSS news feed or a record in a database. URLs can also refer to other
    resources, such as email addresses.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*统一资源定位符*（URL）指向互联网上的一个对象。它是一个文本字符串，用于标识一个项目，告诉你在哪里找到它，并指定与之通信或从其源获取它的方法。URL
    可以指向任何类型的信息源：静态数据，例如本地文件系统上的文件、Web 服务器或 FTP 站点。它可以指向更动态的对象，例如 RSS 新闻订阅或数据库中的记录。URL
    还可以引用其他资源，例如电子邮件地址。'
- en: 'Because there are many different ways to locate an item on the internet, and
    different mediums and transports require different kinds of information, URLs
    can have many forms. The most common form has four components as shown in [Figure 13-1](#learnjava6-CHP-13-FIG-annotated-url):
    a network host or server, the name of the item, its location on that host, and
    a protocol by which the host should communicate.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在互联网上定位项目有许多不同的方法，不同的介质和传输需要不同类型的信息，URL 可以具有多种形式。最常见的形式包含如 [图 13-1](#learnjava6-CHP-13-FIG-annotated-url)
    所示的四个组件：网络主机或服务器、项目名称、其在主机上的位置以及主机应该使用的协议。
- en: '![ljv6 1301](assets/ljv6_1301.png)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 1301](assets/ljv6_1301.png)'
- en: Figure 13-1\. Common elements of a URL
  id: totrans-6
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 13-1\. URL 的常见元素
- en: '*`protocol`* (also called the “scheme”) is an identifier such as `http`, `https`,
    or `ftp`; *`hostname`* is usually an internet host and domain name; and the *`path`*
    and *`resource`* components form a unique path that identifies the object on that
    host.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*`protocol`*（也称为“方案”）是诸如 `http`、`https` 或 `ftp` 的标识符；*`hostname`* 通常是互联网主机和域名；*`path`*
    和 *`resource`* 组件形成了一个唯一的路径，用于标识该主机上的对象。'
- en: Variants of this form pack extra information into the URL. For example, you
    can specify fragment identifiers (those suffixes that start with a “#” character)
    that reference sections inside documents. Other, more specialized types of URLs
    exist as well, such as “mailto” URLs for email addresses, or URLs for addressing
    things like database components. These types of locators may not follow this format
    precisely, but they generally contain a protocol, host, and path. Some are more
    properly called *Uniform Resource Identifiers*, or URIs, which can specify more
    information about the name or the location of a resource. URLs are a subset of
    URIs.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这种形式的变体在 URL 中包含额外的信息。例如，你可以指定片段标识符（以“#”字符开头的后缀），用来引用文档内的各个部分。还有其他更专门的 URL 类型，比如用于电子邮件地址的“mailto”
    URL，或者用于定位诸如数据库组件之类的 URL。这些定位符可能不严格遵循此格式，但通常包含协议、主机和路径。一些更适当地称为 *统一资源标识符*（URI）的内容，可以指定有关资源名称或位置的更多信息。URL
    是 URI 的子集。
- en: Because most URLs have the notion of a hierarchy or path, we sometimes speak
    of a URL that is relative to another URL, called a *base URL*. In that case, we
    are using the base URL as a starting point and supplying additional information
    to target an object relative to that URL. For example, the base URL might point
    to a directory on a web server, and a relative URL might name a particular file
    in that directory or in a subdirectory.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 因为大多数 URL 具有层次结构或路径的概念，所以我们有时会说一个 URL 相对于另一个 URL，称为 *基本 URL*。在这种情况下，我们使用基本 URL
    作为起点，并提供额外的信息来相对于该 URL 定位一个对象。例如，基本 URL 可能指向 Web 服务器上的一个目录，而相对 URL 可能命名该目录中的特定文件或子目录中的文件。
- en: The URL Class
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: URL 类
- en: The Java `java.net.URL` class represents a URL address and provides a simple
    API for accessing web resources, such as documents and applications on servers.
    It can use an extensible set of protocol and content handlers to perform the necessary
    communication and, in theory, even data conversion. With the `URL` class, an application
    can open a connection to a server and retrieve content with just a few lines of
    code.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Java的`java.net.URL`类表示URL地址，并为访问服务器上的文档和应用程序等网络资源提供了一个简单的API。它可以使用可扩展的协议和内容处理程序来执行必要的通信，理论上甚至可以进行数据转换。使用`URL`类，应用程序只需几行代码就可以连接到服务器并检索内容。
- en: 'An instance of the `URL` class manages all the component information within
    a URL string and provides methods for retrieving the object it identifies. We
    can construct a `URL` object from a complete string or from component parts:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`URL`类的一个实例管理URL字符串中的所有组件信息，并提供了用于检索其标识的对象的方法。我们可以从完整字符串或组件部分构造一个`URL`对象：'
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: These two `URL` objects point to the same network resource, the *homepage.html*
    document on the server *foo.bar.com*. We can’t know whether the resource actually
    exists and is available until we try to access it. A new `URL` object contains
    only data about the object’s location and how to access it. Creating a `URL` object
    does not make any network connections.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个`URL`对象指向同一个网络资源，即服务器*foo.bar.com*上的*homepage.html*文档。我们无法知道资源是否实际存在并且可用，直到我们尝试访问它。新的`URL`对象仅包含有关对象位置及其访问方式的数据。创建`URL`对象不会建立任何网络连接。
- en: Note
  id: totrans-15
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Oracle deprecated the `URL` constructor in Java 20\. Deprecation doesn’t remove
    methods or classes, but it does mean you should consider other means of accomplishing
    your goal. The Javadoc for deprecated items often includes suggested alternatives.
    In this case, the `URI` class has better validation code, so Oracle recommends
    `new URI("http://your.url/").toURL()` as a replacement.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle在Java 20中已经废弃了`URL`构造函数。废弃并不会移除方法或类，但意味着您应该考虑其他实现您目标的方法。废弃的项目的Javadoc通常包含建议的替代方法。在这种情况下，`URI`类具有更好的验证代码，因此Oracle建议使用`new
    URI("http://your.url/").toURL()`作为替代方案。
- en: If you are using Java 20 or later, feel free to update the code examples to
    use `URI` if you want to get rid of the compiler’s deprecation warnings. As this
    is a recent deprecation, though, you will still see the `URL` constructor used
    widely in online examples.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用Java 20或更高版本，可以随意更新代码示例以使用`URI`，以摆脱编译器的过时警告。尽管如此，由于这是最近的废弃，您仍然会在在线示例中广泛看到`URL`构造函数的使用。
- en: We can examine the parts of the `URL` with the `getProtocol()`, `getHost()`,
    and `getFile()` methods. We can also compare it to another `URL` with the `sameFile()`
    method (an unfortunate name for something that may not point to a file), which
    determines whether two URLs point to the same resource. It’s not foolproof, but
    `sameFile()` does more than compare the URL strings for equality; it takes into
    account the possibility that one server may have several names, as well as other
    factors.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`getProtocol()`、`getHost()`和`getFile()`方法来检查`URL`的各个部分。我们还可以使用`sameFile()`方法（一个可能不指向文件的不幸命名的方法）将其与另一个`URL`进行比较，该方法确定两个URL是否指向相同的资源。虽然`sameFile()`并不是绝对可靠的，但它比仅比较URL字符串是否相等的方法更加智能；它考虑了一个服务器可能有多个名称以及其他因素。
- en: When you create a `URL`, Java parses the URL’s specification to identify the
    protocol component. It then tries to match what it parses from your URL with a
    *protocol handler*. A protocol handler is essentially a helper that can speak
    the given protocol and can retrieve a resource by following the protocol’s rules.
    If the URL’s protocol doesn’t make sense, or if Java can’t find a compatible protocol
    handler, the `URL` constructor throws a `MalformedURLException`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个`URL`时，Java会解析URL的规范以识别协议组件。然后，它会尝试将它从你的URL解析出来的内容与*协议处理程序*进行匹配。协议处理程序本质上是一个可以使用给定协议并根据协议规则检索资源的助手。如果URL的协议不合理，或者Java找不到兼容的协议处理程序，`URL`构造函数会抛出一个`MalformedURLException`。
- en: Java provides URL protocol handlers for `http`, `https` (secure HTTP), and `ftp`,
    as well as local `file` URLs and `jar` URLs that refer to files inside JAR archives.
    Java also provides the necessary low-level structure for third-party libraries
    to add support for other types of URLs.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Java为`http`、`https`（安全HTTP）和`ftp`提供了URL协议处理程序，以及本地`file` URL和引用JAR存档内文件的`jar`
    URL。Java还为第三方库提供了必要的低级结构，以添加对其他类型URL的支持。
- en: Stream Data
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流数据
- en: The lowest-level and most general way to get data back from a `URL` is to ask
    for an `InputStream` from the `URL` by calling `openStream()`. Getting data as
    a stream may also be useful if you want to receive continuous updates from a dynamic
    information source. Unfortunately, you have to parse the contents of this stream
    yourself. Not all types of URLs support the `openStream()` method because not
    all types of URLs refer to concrete data; you’ll get an `UnknownServiceException`
    if the URL doesn’t.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `URL` 获取数据的最低级和最通用的方式是通过调用 `openStream()` 方法来获取 `URL` 的 `InputStream`。如果您想要从动态信息源接收持续更新，作为流获取数据可能也是有用的。不幸的是，您必须自己解析这个流的内容。并非所有类型的
    URL 都支持 `openStream()` 方法，因为并非所有类型的 URL 都指向具体的数据；如果 URL 不支持，您将会得到一个 `UnknownServiceException`。
- en: 'The following code (a simplification of the *ch13/examples/Read.java* file)
    prints the contents of an HTML file from an imaginary web server:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码（对 *ch13/examples/Read.java* 文件的简化）会打印出来自虚构 Web 服务器的 HTML 文件的内容：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this snippet, we ask for an `InputStream` from our `url` with `openStream()`
    and wrap it in a `BufferedReader` to read the lines of text. Because we specify
    the `http` protocol in the URL, we enlist the services of an HTTP protocol handler.
    We haven’t talked about content handlers yet. Because we’re reading directly from
    the input stream, we don’t need a content handler to transform the content.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们使用 `openStream()` 从我们的 `url` 获取一个 `InputStream`，并将其包装在 `BufferedReader`
    中以读取文本行。因为我们在 URL 中指定了 `http` 协议，所以我们利用了 HTTP 协议处理程序的服务。我们还没有讨论内容处理程序。因为我们直接从输入流中读取，所以不需要内容处理程序来转换内容。
- en: Getting the Content as an Object
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取作为对象的内容
- en: As we said previously, `openStream()` is the most general way to access web
    content, but it leaves the data parsing up to the programmer. The `URL` class
    supports a more sophisticated, pluggable, content-handling mechanism, but the
    Java community never really standardized the actual handlers, so its usefulness
    is limited.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说，`openStream()` 是访问 Web 内容的最通用方法，但它将数据解析留给程序员。`URL` 类支持更复杂的、可插拔的内容处理机制，但是
    Java 社区从未真正标准化实际的处理程序，因此它的实用性有限。
- en: 'Many developers are curious about loading objects over the network because
    they need to load images from URLs. Java provides a few alternative approaches
    to accomplish this task. The simplest approach is to use the `javax.swing.ImageIcon`
    class which has a constructor that accepts a URL:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者对通过网络加载对象感兴趣，因为他们需要从 URL 加载图像。Java 提供了几种替代方法来完成这个任务。最简单的方法是使用 `javax.swing.ImageIcon`
    类，它有一个接受 URL 参数的构造方法：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you need to turn a network stream into some other type of object, you can
    look into the `getContent()` method of the `URL` class. You may need to write
    your own handler, though. For that advanced topic, we recommend [*Java Network
    Programming*](https://oreil.ly/1GwXT) by Elliotte Rusty-Harold (O’Reilly).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要将网络流转换为其他类型的对象，可以查看 `URL` 类的 `getContent()` 方法。不过，您可能需要自己编写处理程序。关于这个高级主题，我们推荐阅读
    [*Java 网络编程*](https://oreil.ly/1GwXT) 一书，作者是 Elliotte Rusty-Harold（O’Reilly）。
- en: Managing Connections
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理连接
- en: Upon calling `openStream()` on a `URL`, Java consults the protocol handler,
    and a connection is made to the remote server or location. Connections are represented
    by a `URLConnection` object, subtypes of which manage different protocol-specific
    communications and offer additional metadata about the source. The `HttpURLConnection`
    class, for example, handles basic web requests and also adds some HTTP-specific
    capabilities, such as interpreting “404 Not Found” messages and other web server
    errors. We’ll talk more about `HttpURLConnection` later in this chapter.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `URL` 上调用 `openStream()` 方法时，Java 会查阅协议处理程序，并建立到远程服务器或位置的连接。连接由 `URLConnection`
    对象表示，它的子类管理不同的协议特定通信，并提供有关源的额外元数据。例如，`HttpURLConnection` 类处理基本的网络请求，还添加了一些 HTTP
    特定功能，比如解释 “404 Not Found” 消息和其他 Web 服务器错误。我们稍后会详细讨论 `HttpURLConnection`。
- en: 'We can get a `URLConnection` from our `URL` directly with the `openConnection()`
    method. One of the things we can do with the `URLConnection` is ask for the object’s
    content type before reading data. For example:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 `openConnection()` 方法直接从我们的 `URL` 获取一个 `URLConnection`。我们可以在读取数据之前询问
    `URLConnection` 的对象内容类型。例如：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Despite its name, a `URLConnection` object is initially created in a raw, unconnected
    state. In this example, the network connection was not actually initiated until
    we called the `getContentType()` method. The `URLConnection` does not talk to
    the source until data is requested or its `connect()` method is explicitly invoked.
    Prior to connection, we can set up network parameters and provide protocol-specific
    details. For example, we can set timeouts on the initial connection to the server
    and on read attempts:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管其名称如此，`URLConnection`对象最初处于原始未连接状态。在本例中，直到我们调用`getContentType()`方法之前，网络连接实际上并未初始化。`URLConnection`在数据请求或显式调用其`connect()`方法之前不会与源通信。在连接之前，我们可以设置网络参数并提供协议特定的详细信息。例如，我们可以设置连接到服务器的初始连接和读取尝试的超时时间：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As we’ll see in [“Using the POST Method”](#learnjava6-CHP-13-SECT-3.2), we can
    get at the protocol-specific information by casting the `URLConnection` to its
    specific subtype.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在[“使用POST方法”](https://learnjava6-CHP-13-SECT-3.2)中看到的那样，通过将`URLConnection`转换为其特定子类型，我们可以获得协议特定的信息。
- en: Talking to Web Applications
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与Web应用程序通信
- en: Web browsers are the universal clients for web applications. They retrieve documents
    for display and serve as a user interface, primarily through the use of HTML,
    JavaScript, and linked documents such as images. In this section, we’ll write
    client-side Java code that uses HTTP through the `URL` class. This combination
    allows us to work with web applications directly using `GET` and `POST` operations
    to retrieve and send data.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Web浏览器是Web应用程序的通用客户端。它们检索文档以进行显示，并通过HTML、JavaScript和诸如图像之类的链接文档作为用户界面。在本节中，我们将编写客户端Java代码，使用`URL`类通过HTTP处理Web应用程序。这种组合允许我们直接使用`GET`和`POST`操作与Web应用程序交互。
- en: The primary task we discuss here is sending data to the server, specifically
    HTML form-encoded data. Browsers encode the name/value pairs of HTML form fields
    in a special format and send them to the server (typically) using one of two methods.
    The first method, using the HTTP `GET` command, encodes the user’s input into
    the URL itself and requests the corresponding document. The server recognizes
    that the first part of the URL refers to a program and invokes it, passing along
    the information encoded in the other part of the URL as a parameter. The second
    method uses the HTTP `POST` command to ask the server to accept the encoded data
    and pass it to a web application as a stream.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里讨论的主要任务是将数据发送到服务器，特别是HTML表单编码数据。浏览器以特殊格式对HTML表单字段的名称/值对进行编码，并使用两种方法之一将其发送到服务器（通常）。第一种方法使用HTTP
    `GET`命令，将用户输入编码到URL本身并请求相应文档。服务器识别URL的第一部分引用一个程序，并调用它，将URL的另一部分编码的信息作为参数传递给它。第二种方法使用HTTP
    `POST`命令要求服务器接受编码数据，并将其作为流传递给Web应用程序。
- en: Using the GET Method
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`GET`方法
- en: 'You can get going with network resources quite quickly using the `GET` method
    of encoding data in a URL. Just create a URL pointing to a server program and
    use a simple convention to tack on the encoded name/value pairs that make up our
    data. For example, the following code snippet opens a URL to an old-school CGI
    program called *login.cgi* on the server *myhost* and passes it two name/value
    pairs. It then prints whatever text the CGI sends back:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`GET`方法可以快速利用网络资源。只需创建指向服务器程序的URL，并使用简单的约定附加构成数据的编码名称/值对即可。例如，以下代码片段打开了一个指向服务器*myhost*上名为*login.cgi*的老式CGI程序的URL，并传递了两个名称/值对。然后，它打印出CGI发送回来的任何文本：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To form the URL with parameters, we start with the base URL of *login.cgi*.
    We add a question mark (`?`), which marks the beginning of the parameter data,
    followed by the first “name=value” pair. We can add as many pairs as we want,
    separated by ampersand (`&`) characters. The rest of our code simply opens the
    stream and reads back the response from the server. Remember that creating a URL
    doesn’t actually open the connection. In this case, the URL connection was made
    implicitly when we called `openStream()`. Although we are assuming here that our
    server sends back text, it could send anything, including images, audio, or PDFs.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用带参数的URL，我们从*login.cgi*的基本URL开始。我们添加一个问号（`?`），标志着参数数据的开始，后面跟着第一个“name=value”对。我们可以添加任意多个名称/值对，用和号（`&`）字符分隔。我们的其余代码只是简单地打开流并从服务器读回响应。请记住，创建URL并不实际打开连接。在这种情况下，当我们调用`openStream()`时，URL连接是隐式建立的。尽管我们在这里假设服务器返回文本，但它可以发送任何东西，包括图像、音频或PDF文件。
- en: We have skipped a step here. This example works because our name/value pairs
    happen to be simple text. If any “nonprintable” or special characters (including
    `?` or `&`) are in the pairs, they must be encoded first. The `java.net.URLEncoder`
    class provides a utility for encoding the data. We’ll show how to use it in the
    next example in [“Using the POST Method”](#learnjava6-CHP-13-SECT-3.2).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里跳过了一步。这个示例之所以有效，是因为我们的名称/值对恰好是简单的文本。如果任何“非可打印”或特殊字符（包括`?`或`&`）在这些对中，它们必须首先进行编码。`java.net.URLEncoder`类提供了一个编码数据的实用工具。我们将在[“使用POST方法”](#learnjava6-CHP-13-SECT-3.2)中的下一个示例中展示如何使用它。
- en: Although this small example sends a password field, you should never send sensitive
    data using this simplistic approach. The data in this example is sent in clear
    text across the network (it is not encrypted). Even using HTTPS (HTTP Secure)
    won’t obscure the URL. And in this case, the password field would appear anywhere
    the URL is printed as well, including server logs, browser history, and bookmarks.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个小示例发送了一个密码字段，但你不应该使用这种简单的方法发送敏感数据。这个示例中的数据以明文形式通过网络发送（未加密）。即使使用HTTPS（HTTP安全）也不会模糊URL。而且在这种情况下，密码字段也会出现在URL打印的任何地方，包括服务器日志、浏览器历史记录和书签中。
- en: Using the POST Method
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用POST方法
- en: For larger amounts of input data or for sensitive content, you’ll likely use
    the `POST` option. Here’s a small application that acts like an HTML form. It
    gathers data from two text fields—`name` and `password`—and posts the data to
    the Postman Echo service^([1](ch13.html#id2506)) URL using the HTTP `POST` method.
    This Swing-based client application works just like a web browser and connects
    with a web application.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更大量的输入数据或敏感内容，你可能会使用`POST`选项。这是一个小应用程序，它的行为类似于HTML表单。它从两个文本字段——`name`和`password`——收集数据，并使用HTTP
    `POST`方法将数据发送到Postman Echo服务^([1](ch13.html#id2506))的URL。这个基于Swing的客户端应用程序就像一个Web浏览器一样工作，并与Web应用程序连接。
- en: 'Here’s the key networking method that performs the request and handles the
    response:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这是执行请求并处理响应的关键网络方法：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The beginning of the application creates the form using Swing elements, like
    we did in [Chapter 12](ch12.html#learnjava6-CHP-12). All the magic happens in
    the protected `postData()` method. First, we create a `StringBuilder` and load
    it with name/value pairs, separated by ampersands. (We don’t need the initial
    question mark when we’re using the `POST` method because we’re not appending to
    the URL.) Each pair is first encoded using the static `URLEncoder.encode()` method.
    We run the name fields through the encoder as well, even though they contain no
    special characters in this example. This extra step is a best practice and simply
    a good habit. The field names may not always be so plain.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的开头使用Swing元素创建表单，就像我们在[第12章](ch12.html#learnjava6-CHP-12)中所做的那样。所有的魔法都在受保护的`postData()`方法中发生。首先，我们创建一个`StringBuilder`并用用`&`分隔的名称/值对加载它。（当我们使用`POST`方法时，我们不需要初始问号，因为我们不是在URL上追加。）每对都首先使用静态的`URLEncoder.encode()`方法进行编码。即使在这个示例中，名称字段不包含任何特殊字符，我们也会通过编码器运行名称字段。这个额外的步骤是最佳实践，只是一个好习惯。字段名称可能并不总是如此简单。
- en: Next, we set up the connection to the server. In our previous example, we weren’t
    required to do anything special to send the data because the request was made
    by the simple act of opening the URL on the server. Here, we have to carry some
    of the weight of talking to the remote web server. Fortunately, the `HttpURLConnection`
    object does most of the work for us; we just have to tell it what type of data
    we are sending and how we want to send it. We get a `URLConnection` object via
    the `openConnection()` method. We know that we are using the HTTP protocol, so
    we should be able to cast it to an `HttpURLConnection` type, which has the support
    we need. Because HTTP is one of the guaranteed protocols, we can safely make this
    assumption. (Speaking of safety, we use HTTP here only for demonstration purposes.
    So much data these days is considered sensitive. Industry guidelines have settled
    on defaulting to HTTPS; more on that soon in [“SSL and Secure Web Communications”](#learnjava6-CHP-13-SECT-3.4).)
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置与服务器的连接。在我们之前的例子中，我们不需要执行任何特殊操作来发送数据，因为请求是通过在服务器上打开URL简单完成的。在这里，我们必须承担与远程Web服务器通信的一些工作。幸运的是，`HttpURLConnection`对象为我们完成了大部分工作；我们只需告诉它我们要发送的数据类型及如何发送。我们通过`openConnection()`方法获取一个`URLConnection`对象。由于我们使用的是HTTP协议，所以可以安全地将其强制转换为`HttpURLConnection`类型，它具有我们需要的支持。因为HTTP是一种有保证的协议之一，我们可以安全地做出这个假设。（说到安全性，我们在这里仅仅出于演示目的使用HTTP。如今许多数据被视为敏感数据。行业指南已经默认使用HTTPS；稍后在[“SSL和安全Web通信”](#learnjava6-CHP-13-SECT-3.4)中详细讨论。）
- en: We use `setRequestMethod()` to tell the connection we want to do a `POST` operation.
    We also use `setRequestProperty()` to set the `Content-Type` field of our HTTP
    request to the appropriate type—in this case, the proper media type^([2](ch13.html#id2514))
    for encoded form data. (This is necessary to tell the server what kind of data
    we’re sending, `"application/x-www-form-urlencoded"` in our case.)
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`setRequestMethod()`告知连接我们要进行`POST`操作。还使用`setRequestProperty()`设置我们的HTTP请求的`Content-Type`字段为适当的类型——在这种情况下，编码表单数据的正确媒体类型^([2](ch13.html#id2514))（这是必要的，告诉服务器我们发送的数据类型，我们的情况下是`"application/x-www-form-urlencoded"`）。
- en: For the final configuration step, we use the `setDoOutput()` and `setDoInput()`
    methods to tell the connection that we want to send *and* receive stream data.
    The URL connection infers from this combination that we are going to do a `POST`
    operation and expects a response.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最后的配置步骤，我们使用`setDoOutput()`和`setDoInput()`方法告知连接我们要发送和接收流数据。URL连接从这个组合推断我们将进行`POST`操作，并期望得到一个响应。
- en: To send data, we get an output stream from the connection with `getOutputStream()`
    and create a `PrintWriter` so that we can easily write our encoded form content.
    After we post the data, our application calls `getResponseCode()` to see whether
    the HTTP response code from the server indicates that the `POST` was successful.
    Other response codes (defined as constants in `HttpURLConnection`) indicate various
    failures.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要发送数据，我们从连接中获取一个输出流使用`getOutputStream()`，并创建一个`PrintWriter`以便轻松编写我们的编码表单内容。发送数据后，我们的应用程序调用`getResponseCode()`来查看服务器的HTTP响应代码是否指示`POST`成功。其他响应代码（在`HttpURLConnection`中定义为常量）表示各种失败情况。
- en: 'Although form-encoded data (as indicated by the media type we specified for
    the `Content-Type` field) is common, other types of communications are possible.
    We could use the input and output streams to exchange arbitrary data types with
    the server program. The `POST` operation could send any kind of data; the server
    application simply has to know how to handle it. One final note: if you are writing
    an application that needs to decode form data, you can use the `java.net.URLDecoder`
    to undo the operation of the `URLEncoder`. Be sure to specify UTF-8 when calling
    `decode()`.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管表单编码数据（如我们为`Content-Type`字段指定的媒体类型所示）很常见，但也有其他类型的通信方式。我们可以使用输入和输出流与服务器程序交换任意数据类型。`POST`操作可以发送任何类型的数据；服务器应用程序只需知道如何处理即可。最后注意：如果你正在编写一个需要解码表单数据的应用程序，可以使用`java.net.URLDecoder`来撤消`URLEncoder`的操作。调用`decode()`时务必指定UTF-8。
- en: The HttpURLConnection
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HttpURLConnection
- en: Other information from the request is available from the `HttpURLConnection`
    as well. We could use `getContentType()` and `getContentEncoding()` to determine
    the MIME type and encoding of the response. We could also interrogate the HTTP
    response headers by using `getHeaderField()`. (HTTP response headers are metadata
    name/value pairs carried with the response.) Convenience methods can fetch integer-
    and date-formatted header fields, `getHeaderFieldInt()` and `getHeaderFieldDate()`,
    which return an `int` and a `long` type, respectively. The content length and
    last modification date are provided through `getContentLength()` and `getLastModified()`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `HttpURLConnection` 中还可以获取请求的其他信息。我们可以使用 `getContentType()` 和 `getContentEncoding()`
    来确定响应的 MIME 类型和编码。我们还可以通过使用 `getHeaderField()` 来查询 HTTP 响应头（HTTP 响应头是随响应一起传输的元数据名称/值对）。便捷方法可以获取整数和日期格式的头字段，`getHeaderFieldInt()`
    和 `getHeaderFieldDate()`，它们分别返回 `int` 和 `long` 类型。内容长度和上次修改日期可以通过 `getContentLength()`
    和 `getLastModified()` 获得。
- en: SSL and Secure Web Communications
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SSL 和安全的 Web 通信
- en: 'Some of the previous examples sent sensitive data to the server. Standard HTTP
    doesn’t provide encryption to hide our data. Fortunately, adding security for
    `GET` and `POST` operations like this is easy (trivial, in fact, for the client-side
    developer). Where available, you simply need to use a secure form of the HTTP
    protocol—HTTPS. Consider the testing URL from the `Post` example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的一些示例发送了敏感数据到服务器。标准的 HTTP 不提供加密来隐藏我们的数据。幸运的是，像这样为 `GET` 和 `POST` 操作添加安全性对于客户端开发者来说是很容易的（实际上是微不足道的）。在可用的情况下，你只需要使用
    HTTP 协议的安全形式 — HTTPS。考虑 `Post` 示例中的测试 URL：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: HTTPS is a version of the standard HTTP protocol run over Secure Sockets Layer
    (SSL), which uses public-key encryption techniques to encrypt the browser-to-server
    communications. Most web browsers and servers currently come with built-in support
    for HTTPS (or raw SSL sockets). Therefore, if your web server supports HTTPS and
    has it configured, you can use a browser to send and receive secure data simply
    by specifying the `https` protocol in your URLs. There is much more to learn about
    SSL and related aspects of security, such as authenticating to whom you are actually
    talking, but as far as basic data encryption goes, this is all you have to do.
    It is not something your code has to deal with directly. Java ships with both
    SSL and HTTPS support.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: HTTPS 是标准 HTTP 协议运行在安全套接字层（SSL）之上的一个版本，它使用公钥加密技术来加密浏览器与服务器之间的通信。大多数 Web 浏览器和服务器目前都内置支持
    HTTPS（或原始的 SSL 套接字）。因此，如果你的 Web 服务器支持并配置了 HTTPS，你可以通过在 URL 中指定 `https` 协议来简单地发送和接收安全数据。关于
    SSL 和安全相关方面还有很多内容需要学习，比如验证你实际在与谁通信，但是就基本数据加密而言，这就是你需要做的一切。这不是你的代码直接处理的事情。Java
    提供了 SSL 和 HTTPS 的支持。
- en: Network Programming
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络编程
- en: The web dominates developer discussions of networking, but there is more out
    there than just HTML pages! As Java’s networking APIs have matured, Java has also
    become the language of choice for implementing traditional client/server applications
    and services. In this section, we look at the `java.net` package, which contains
    the fundamental classes for communications and working with networked resources.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Web 主导了开发者对网络的讨论，但在这其中不仅仅是 HTML 页面！随着 Java 的网络 API 的成熟，Java 也成为了实现传统客户端/服务器应用程序和服务的首选语言。在本节中，我们将看看
    `java.net` 包，其中包含了用于通信和处理网络资源的基本类。
- en: 'The classes of `java.net` fall into two general categories: the Sockets API,
    for working with low-level network protocols, and higher-level, web-oriented APIs
    that work with URLs, as we saw in the previous section. [Figure 13-2](#learnjava6-CHP-13-FIG-3)
    shows most of the `java.net` package hierarchy.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.net` 包的类分为两类：Sockets API，用于处理低级网络协议，以及与 URL 一起工作的高级、面向 Web 的 API，正如我们在前一节中看到的。[图 13-2](#learnjava6-CHP-13-FIG-3)
    展示了 `java.net` 包的大部分层次结构。'
- en: '![ljv6 1302](assets/ljv6_1302.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 1302](assets/ljv6_1302.png)'
- en: Figure 13-2\. Main classes and interfaces of the `java.net` package
  id: totrans-67
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 13-2\. `java.net` 包的主要类和接口
- en: Java’s Sockets API provides access to the standard protocols used for communications
    between hosts. *Sockets* are the mechanism underlying all other kinds of portable
    networked communications. Sockets are the lowest-level tool in the general networking
    toolbox—you can use sockets for any kind of communications between client and
    server or peer applications, but you have to implement your own application-level
    protocols for handling and interpreting the data. Higher-level networking tools,
    such as remote method invocation, HTTP, and web services, are implemented on top
    of sockets.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Java 的套接字 API 提供了对主机间通信所使用的标准协议的访问。*套接字* 是所有其他种类便携式网络通信的基础机制。套接字是通用网络工具箱中的最低级工具——你可以使用套接字进行客户端和服务器或对等应用程序之间的任何类型的通信，但你必须实现自己的应用程序级协议来处理和解释数据。更高级别的网络工具，如远程方法调用、HTTP
    和 web 服务，都是在套接字之上实现的。
- en: Sockets
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 套接字
- en: Sockets are a low-level programming interface for networked communications.
    They send streams of data between applications that may or may not be on the same
    host.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字是用于网络通信的低级编程接口。它们在可能或可能不在同一主机上的应用程序之间发送数据流。
- en: Sockets originated in BSD Unix and are, in some programming languages, messy,
    complicated things with lots of small parts that can break off and cause havoc.
    The reason for this is that most socket APIs can be used with almost any kind
    of underlying network protocol. Since the protocols that transport data across
    the network can have radically different features, the socket interface can be
    quite complex.^([3](ch13.html#id2534))
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字起源于 BSD Unix，在某些编程语言中，它们是一些混乱、复杂的东西，有很多小部分可能会断开并引起混乱。这是因为大多数套接字 API 可以与几乎任何类型的底层网络协议一起使用。由于传输数据的协议可能具有根本不同的特性，套接字接口可能会非常复杂。
- en: The `java.net` package supports a simplified, object-oriented socket interface
    that makes network communications considerably easier. If you’ve done network
    programming using sockets in other languages, you should be pleasantly surprised
    at how simple things can be when objects encapsulate the gory details. If this
    is the first time you’ve come across sockets, you’ll find that talking to another
    application over the network can be as simple as reading a file or getting user
    input. Most forms of I/O in Java, including most network I/O, use the stream classes
    described in [“Streams”](ch10.html#learnjava6-CHP-10-SECT-1). Streams provide
    a unified I/O interface so that reading or writing across the internet is similar
    to reading or writing on the local system. In addition to the stream-oriented
    interfaces, the Java networking APIs can work with the Java NIO buffer-oriented
    API for highly scalable applications.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.net` 包支持一个简化的、面向对象的套接字接口，使网络通信变得更加容易。如果你以前使用其他语言的套接字进行过网络编程，你会惊讶地发现当对象封装了繁琐的细节时，事情可以变得多么简单。如果这是你第一次接触套接字，你会发现与另一个应用程序在网络上通信就像读取文件或获取用户输入一样简单。Java
    中的大多数 I/O 形式，包括大多数网络 I/O，都使用了 [“Streams”](ch10.html#learnjava6-CHP-10-SECT-1)
    中描述的流类。流提供了统一的 I/O 接口，使得在互联网上进行读取或写入类似于在本地系统上进行读取或写入。除了面向流的接口之外，Java 网络 API 还可以与用于高度可扩展应用程序的
    Java NIO 缓冲区 API 一起使用。'
- en: 'Java provides sockets to support three distinct classes of underlying protocols:
    `Socket`, `DatagramSocket`, and `MulticastSocket`. In this section, we look at
    Java’s basic `Socket` class, which uses a *connection-oriented* and *reliable*
    protocol. A connection-oriented protocol provides the equivalent of a telephone
    conversation. After establishing a connection, two applications can send streams
    of data back and forth, and the connection stays in place even when no one is
    talking. Because the protocol is reliable, it also ensures that no data is lost
    (resending data, as necessary), and that whatever you send always arrives in the
    order in which you sent it.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Java 提供套接字支持三种不同的底层协议类：`Socket`、`DatagramSocket` 和 `MulticastSocket`。在本节中，我们将介绍
    Java 的基本 `Socket` 类，它使用了 *面向连接* 和 *可靠* 的协议。面向连接的协议提供了类似于电话对话的功能。建立连接后，两个应用程序可以来回发送数据流，即使没有人在说话，连接也会保持在那里。由于协议是可靠的，它还确保没有数据丢失（必要时重新发送数据），并且你发送的任何内容都会按照你发送的顺序到达。
- en: We’ll have to leave the other two classes, which use a *connectionless*, *unreliable*
    protocol, for you to explore on your own. (Again, see [*Java Network Programming*](https://oreil.ly/RzACA)
    by Elliotte Rusty-Harold for a detailed discussion.) A connectionless protocol
    is like the postal service. Applications can send short messages to each other,
    but no end-to-end connection is set up in advance, and no attempt is made to keep
    the messages in order. It’s not even guaranteed that the messages will arrive
    at all. A `MulticastSocket` is a variation of a `DatagramSocket` that performs
    *multicasting*—simultaneously sending data to multiple recipients. Think of the
    postal service delivering flyers for the local grocery market to “Resident” addresses
    throughout a large neighborhood. Working with multicast sockets is very much like
    working with datagram sockets; there are simply more recipients.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将留下另外两个使用 *无连接*、*不可靠* 协议的类，让您自行探索。（再次参见 [*Java网络编程*](https://oreil.ly/RzACA)，由Elliotte
    Rusty-Harold详细讨论。）无连接协议类似于邮政服务。应用程序可以向彼此发送短消息，但事先不建立端到端连接，并且不尝试保持消息的顺序。甚至不能保证消息会到达。`MulticastSocket`
    是 `DatagramSocket` 的变体，执行*多播* —— 同时向多个接收者发送数据。类似于使用数据报套接字，使用多播套接字工作时只是有更多的接收者。
- en: 'In theory, just about any protocol can be used underneath the socket layer.
    In practice, there’s only one important protocol family used on the internet,
    and only one protocol family that Java supports: the Internet Protocol (IP). The
    `Socket` class speaks *TCP*, Transmission Control Protocol, over IP (often lumped
    together as TCP/IP); and the connectionless `DatagramSocket` class speaks *UDP*,
    User Datagram Protocol, over IP.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，套接字层下面几乎可以使用任何协议。实际上，互联网上只有一个重要的协议族，并且只有一个 Java 支持的协议族：互联网协议（IP）。`Socket`
    类通过 IP（通常被称为 TCP/IP）使用 *TCP*，传输控制协议；而无连接的 `DatagramSocket` 类通过 IP 使用 *UDP*，用户数据报协议。
- en: Clients and Servers
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端和服务器
- en: When writing network applications, it’s common to talk about clients and servers.
    The distinction is increasingly vague, but the *client* usually initiates the
    conversation. The *server* usually accepts incoming requests. There are many subtleties
    to these roles,^([4](ch13.html#id2546)) but for simplicity we’ll use this definition.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写网络应用程序时，通常会谈论客户端和服务器。这两者之间的区别越来越模糊，但*客户端*通常启动对话，而*服务器*通常接受传入请求。这些角色有许多微妙之处，^([4](ch13.html#id2546))
    但为简单起见，我们将使用这个定义。
- en: An important difference between a client and a server is that a client can create
    a socket to initiate a conversation with a server application at any time, while
    a server must be prepared in advance to listen for incoming conversation requests.
    The `java.net.Socket` class represents one side of an individual socket connection
    on both the client and server. In addition, the server uses the `java.net.ServerSocket`
    class to listen for new connections from clients. In most cases, an application
    acting as a server creates a `ServerSocket` object and waits, blocked in a call
    to its `accept()` method, until a request arrives. When a client attempts to connect,
    the `accept()` method creates a new `Socket` object that the server uses to communicate
    with the client. The `ServerSocket` instance hands over details on the client
    to the new `Socket`, as shown in [Figure 13-3](#learnjava6-CHP-13-FIG-4).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端和服务器之间的一个重要区别在于，客户端可以随时创建套接字以启动与服务器应用程序的对话，而服务器必须事先准备好以侦听传入的对话请求。`java.net.Socket`
    类代表客户端和服务器上单个套接字连接的一侧。此外，服务器使用 `java.net.ServerSocket` 类来侦听来自客户端的新连接。在大多数情况下，作为服务器的应用程序会创建一个
    `ServerSocket` 对象并等待，通过调用其 `accept()` 方法被阻塞，直到请求到达。当客户端尝试连接时，`accept()` 方法会创建一个新的
    `Socket` 对象，服务器用该对象与客户端进行通信。`ServerSocket` 实例会将有关客户端的详细信息传递给新的 `Socket`，如 [图 13-3](#learnjava6-CHP-13-FIG-4)
    所示。
- en: '![ljv6 1303](assets/ljv6_1303.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 1303](assets/ljv6_1303.png)'
- en: Figure 13-3\. Clients and servers using `Socket` and `ServerSocket`
  id: totrans-80
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 13-3\. 使用 `Socket` 和 `ServerSocket` 的客户端和服务器
- en: That socket continues the conversation with the client, allowing the `ServerSocket`
    to resume its listening task. In this way, a server can carry on conversations
    with multiple clients at once. There is still only a single `ServerSocket`, but
    the server has multiple `Socket` objects—one associated with each client.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 该套接字继续与客户端进行对话，使得`ServerSocket`能够恢复其监听任务。这样，服务器就可以同时与多个客户端进行对话。仍然只有一个`ServerSocket`，但服务器拥有多个`Socket`对象——每个客户端一个。
- en: Clients
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 客户端
- en: 'At the socket level, a client needs two pieces of information to locate and
    connect to a server on the internet: a *hostname* (used to find the host computer’s
    network address) and a *port number*. The port number is an identifier that differentiates
    between multiple network services or connections on the same host.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在套接字级别，客户端需要两个信息来定位和连接到互联网中的服务器：一个*主机名*（用于查找主机计算机的网络地址）和一个*端口号*。端口号是一个标识符，用于区分同一主机上的多个网络服务或连接。
- en: A server application listens on a prearranged port while waiting for connections.
    Clients make a request to that prearranged port number. If you think of the host
    computer as a hotel and the various services available as guests, the ports are
    like the guests’ room numbers. To connect to a service, you must know the hotel
    name and the right room number.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器应用程序在预先安排的端口上监听，同时等待连接。客户端向那个预先安排的端口号发送请求。如果你把主机计算机想象成一个酒店，而各种可用的服务作为客人，那么端口就像客人的房间号码。要连接到一个服务，你必须知道酒店名称和正确的房间号码。
- en: 'A client application opens a connection to a server by constructing a `Socket`
    that specifies those two bits of information:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端应用程序通过构造一个指定这两个信息的`Socket`，来打开与服务器的连接。
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This client-side code fragment attempts to connect a `Socket` to port 25 (the
    SMTP mail service) of the host *wupost.wustl.edu*. The client must handle the
    possibility that the hostname can’t be resolved (`UnknownHostException`) and that
    the server might not accept a new connection (`IOException`). Java uses DNS, the
    standard *Domain Name Service* (DNS), to resolve the hostname to an *IP address*
    for us.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这段客户端代码试图将一个`Socket`连接到主机的25号端口（SMTP邮件服务），该主机为*wupost.wustl.edu*。客户端必须处理主机名无法解析（`UnknownHostException`）和服务器可能不接受新连接（`IOException`）的情况。Java使用DNS，即标准的*域名服务*（DNS），来将主机名解析为一个*IP地址*。
- en: 'IP addresses (from the Internet Protocol) are the phone numbers of the internet,
    and DNS is the global phone book. Every machine connected to the internet has
    an IP address. If you don’t know that address, you look it up with DNS. But if
    you do know a server’s address, the `Socket` constructor can also accept a string
    containing a raw IP address:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: IP地址（来自互联网协议）是互联网的电话号码，DNS是全球电话簿。连接到互联网的每台计算机都有一个IP地址。如果你不知道那个地址，就通过DNS查询。但如果你知道服务器的地址，`Socket`构造函数也可以接受一个包含原始IP地址的字符串：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Regardless of which way you start, after `sock` connects, you can retrieve
    input and output streams with the `getInputStream()` and `getOutputStream()` methods.
    The following (rather arbitrary) code sends and receives some data with the streams:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你如何开始，一旦`sock`连接上，你就可以通过`getInputStream()`和`getOutputStream()`方法检索输入和输出流。以下（相当任意的）代码通过流发送和接收一些数据：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In this exchange, the client first creates a `Socket` for communicating with
    the server. The `Socket` constructor specifies the server’s hostname (*foo.bar.com*)
    and a prearranged port number (1234). Once the client connects, it writes a single
    byte to the server using the `OutputStream`’s `write()` method. To send a string
    of text more easily, it then wraps a `PrintWriter` around the `OutputStream`.
    Next, it performs the complementary operations: reading a byte back from the server
    using `InputStream`’s `read()` method and then creating a `BufferedReader` from
    which to get a full string of text. The client then terminates the connection
    with the `close()` method. All these operations have the potential to generate
    `IOException`s; our snippet handles these checked exceptions by wrapping the entire
    conversation in a `try/catch` block.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个交换过程中，客户端首先创建一个`Socket`，用于与服务器通信。`Socket`构造函数指定服务器的主机名（*foo.bar.com*）和一个预先安排的端口号（1234）。一旦客户端连接上，它就使用`OutputStream`的`write()`方法向服务器写入一个字节。为了更方便地发送一串文本，它随后将一个`PrintWriter`包装在`OutputStream`周围。接下来，它执行互补操作：使用`InputStream`的`read()`方法从服务器读取一个字节，然后创建一个`BufferedReader`，以便获取完整的文本字符串。客户端随后使用`close()`方法终止连接。所有这些操作都有可能生成`IOException`；我们的代码片段通过将整个对话包装在一个`try/catch`块中来处理这些检查异常。
- en: Servers
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务器
- en: 'On the other side of the conversation, after a connection is established, a
    server application uses the same kind of `Socket` object for its communication
    with a client. However, to accept a connection from a client, it must first create
    a `ServerSocket`, bound to the correct port. Let’s re-create the previous conversation
    from the server’s point of view:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在对话的另一端，在建立连接之后，服务器应用程序使用相同类型的`Socket`对象与客户端进行通信。然而，要接受来自客户端的连接，它必须首先创建绑定到正确端口的`ServerSocket`。让我们从服务器的角度重新创建以前的对话：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: First, our server creates a `ServerSocket` attached to port 1234\. On most systems,
    there are rules about which ports an application can use. Port numbers are unsigned,
    16-bit integers, which means they can range from 0 to 65,535\. Port numbers below
    1,024 are usually reserved for system processes and standard, “well-known” services,
    so we pick a port number outside of this reserved range.^([5](ch13.html#id2559))
    We need to create the `ServerSocket` only once; thereafter, it can accept as many
    connections as arrive.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们的服务器创建一个绑定到端口1234的`ServerSocket`。在大多数系统上，有关应用程序可以使用哪些端口的规则。端口号是无符号的16位整数，这意味着它们的范围可以从0到65535。低于1024的端口号通常保留给系统进程和标准的“众所周知”服务，因此我们选择一个不在此保留范围内的端口号。^([5](ch13.html#id2559))我们只需创建一次`ServerSocket`；之后，它可以接受到达的任意数量的连接。
- en: Next, we enter a loop, waiting for the `accept()` method of the `ServerSocket`
    to return an active `Socket` connection from a client. When a connection has been
    established, we perform the server side of our dialog, then close the connection
    and return to the top of the loop to wait for another connection. Finally, when
    the server application wants to stop listening for connections altogether, it
    calls the `close()` method of the `ServerSocket`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们进入一个循环，等待`ServerSocket`的`accept()`方法返回来自客户端的活动`Socket`连接。当建立连接后，我们执行对话的服务器端，然后关闭连接并返回循环顶部等待另一个连接。最后，当服务器应用程序想要完全停止监听连接时，它调用`ServerSocket`的`close()`方法。
- en: This server is single threaded; it handles one connection at a time, finishing
    a complete conversation with one client before returning to the top of the loop
    and calling `accept()` to listen for another connection. A more realistic server
    would have a loop that accepts connections concurrently and passes them off to
    their own threads for processing. Even though we don’t plan on creating a MMORPG,^([6](ch13.html#id2561))
    we do show how to conduct a conversation using the thread-per-client approach
    in [“A Distributed Game”](#learnjava6-CHP-13-SECT-5.3). If you want to do a little
    independent reading, you can also look up the nonblocking, NIO equivalent `ServerSocketChannel`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务器是单线程的；它一次处理一个连接，在完成与一个客户端的完整对话后返回循环顶部，并调用`accept()`以侦听另一个连接。一个更现实的服务器将有一个循环，同时接受连接，并将它们传递到它们自己的线程进行处理。尽管我们不打算创建一个MMORPG，^([6](ch13.html#id2561))我们确实展示了如何使用线程每客户端方法进行对话，在[“分布式游戏”](#learnjava6-CHP-13-SECT-5.3)中展示。如果您想进行一些独立阅读，您还可以查找非阻塞的NIO等效`ServerSocketChannel`。
- en: The DateAtHost Client
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`DateAtHost`客户端'
- en: In the past, many networked computers ran a simple time service that dispensed
    their clock’s local time on a well-known port. The time protocol is a precursor
    of NTP, the more general Network Time Protocol. We’ll stick with the time protocol
    for its simplicity, but if you do want to synchronize the clocks of networked
    system, NTP is a better option.^([7](ch13.html#id2568))
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，许多网络计算机运行了一个简单的时间服务，该服务在一个众所周知的端口上分发其时钟的本地时间。时间协议是NTP的前身，更一般的网络时间协议。我们将坚持使用时间协议因其简单性，但如果您想要同步网络系统的时钟，NTP是一个更好的选择。^([7](ch13.html#id2568))
- en: The next example, `DateAtHost`, includes a subclass of `java.util.Date` that
    fetches the time from a remote host instead of initializing itself from the local
    clock. (See [Chapter 8](ch08.html#learnjava6-CHP-8) for a discussion of the `Date`
    class, which is still good for some uses but has been largely replaced by its
    newer, more flexible cousins, `LocalDate` and `LocalTime`.)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例，`DateAtHost`，包括一个`java.util.Date`的子类，该子类从远程主机获取时间，而不是从本地时钟初始化自己。（参见[第8章](ch08.html#learnjava6-CHP-8)讨论`Date`类，虽然在某些用途上仍然有效，但已大部分被其更新、更灵活的衍生类`LocalDate`和`LocalTime`替代。）
- en: '`DateAtHost` connects to the time service (port 37) and reads four bytes representing
    the time on the remote host. These four bytes have a peculiar specification that
    we decode to get the time. Here’s the code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`DateAtHost`连接到时间服务（端口37），并读取表示远程主机时间的四个字节。这四个字节有一个特定的规范，我们解码以获取时间。以下是代码：'
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: That’s all there is to it. It’s not very long, even with a few frills. We have
    supplied two possible constructors for `DateAtHost`. Normally we’d expect to use
    the first, which simply takes the name of the remote host as an argument. The
    second constructor specifies the hostname and the port number of the remote time
    service. (If the time service were running on a nonstandard port, we would use
    the second constructor to specify the alternate port number.) This second constructor
    does the work of making the connection and setting the time. The first constructor
    simply invokes the second (using the `this()` construct) with the default port
    as an argument. Supplying simplified constructors that invoke their siblings with
    default arguments is a common and useful pattern in Java; that is the main reason
    we’ve shown it here.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。即使稍微有些花哨，它也不是很长。我们为`DateAtHost`提供了两个可能的构造函数。通常我们会使用第一个构造函数，它简单地将远程主机的名称作为参数。第二个构造函数指定了远程时间服务的主机名和端口号。（如果时间服务在非标准端口上运行，则使用第二个构造函数指定备用端口号。）第二个构造函数负责建立连接并设置时间。第一个构造函数只是调用第二个构造函数（使用`this()`构造）并使用默认端口作为参数。在Java中，提供简化的构造函数，这些构造函数调用带有默认参数的同级构造函数是一种常见且有用的模式；这也是我们在这里展示的主要原因。
- en: The second constructor opens a socket to the specified port on the remote host.
    It creates a `DataInputStream` to wrap the input stream and then reads a four-byte
    integer using the `readInt()` method. It’s no coincidence that the bytes are in
    the right order. Java’s `DataInputStream` and `DataOutputStream` classes work
    with the bytes of integer types in *network byte order* (most significant to least
    significant). The time protocol (and other standard network protocols that deal
    with binary data) also uses the network byte order, so we don’t need to call any
    conversion routines. Explicit data conversions would probably be necessary if
    we were using a nonstandard protocol, especially when talking to a non-Java client
    or server. In that case, we’d have to read byte by byte and do some rearranging
    to get our four-byte value. After reading the data, we’re finished with the socket,
    so we close it, terminating the connection to the server. Finally, the constructor
    initializes the rest of the object by calling `Date`’s `setTime()` method with
    the calculated time value.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个构造函数在远程主机上指定端口打开一个套接字。它创建一个`DataInputStream`来包装输入流，然后使用`readInt()`方法读取一个四字节整数。这些字节的顺序正确并非巧合。Java的`DataInputStream`和`DataOutputStream`类使用*网络字节顺序*（从最高有效位到最低有效位）处理整数类型的字节。时间协议（以及处理二进制数据的其他标准网络协议）也使用网络字节顺序，因此我们不需要调用任何转换例程。如果我们使用非标准协议，特别是与非Java客户端或服务器通信时，可能需要进行显式数据转换。在这种情况下，我们必须逐字节读取并重新排列以获取我们的四字节值。读取数据后，我们完成套接字操作，因此关闭它以终止与服务器的连接。最后，构造函数通过使用计算出的时间值调用`Date`的`setTime()`方法来初始化对象的其余部分。
- en: The four bytes of the time value are interpreted as an integer representing
    the number of seconds since the beginning of the 20th century. `DateAtHost` converts
    this to Java’s notion of absolute time—the count of milliseconds since January
    1, 1970 (an arbitrary date standardized by C and Unix). The conversion first creates
    a `long` value, which is the unsigned equivalent of the integer `time`. It subtracts
    an offset to make the time relative to the epoch (January 1, 1970) rather than
    the century, and multiplies by 1,000 to convert to milliseconds. The converted
    time is used to initialize the object.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 时间值的四个字节被解释为表示20世纪初以来的秒数的整数。`DateAtHost`将其转换为Java的绝对时间概念——自1970年1月1日起的毫秒计数（这是由C和Unix标准化的任意日期）。转换首先创建一个`long`值，它是整数`time`的无符号等效值。它减去一个偏移量以使时间相对于时代（1970年1月1日）而不是世纪，并乘以1,000以转换为毫秒。转换后的时间用于初始化对象。
- en: 'The `DateAtHost` class can work with a time retrieved from a remote host almost
    as easily as `Date` is used with the time on the local host. The only additional
    overhead is dealing with the possible `IOException` that the `DateAtHost` constructor
    can throw:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`DateAtHost`类几乎可以像`Date`与本地主机上的时间一样与从远程主机检索的时间一起工作。唯一的额外开销是处理`DateAtHost`构造函数可能抛出的可能的`IOException`异常：'
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This example fetches the time at the host *time.nist.gov* and prints its value.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例获取来自主机*time.nist.gov*的时间并打印其值。
- en: A Distributed Game
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分布式游戏
- en: We can use our newfound networking skills to extend our apple tossing game and
    go two-player. We’ll have to keep this foray simple, but you might be surprised
    by how quickly we can get a proof of concept off the ground. While there are several
    mechanisms two players could use to get connected for a shared experience, our
    example uses the basic client/server model we’ve been discussing in this chapter.
    One user will start the server, and the second user will be able to contact that
    server as the client. Once both players are connected, they’ll race to see who
    can clear the trees and hedges the fastest!
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用我们新发现的网络技能来扩展我们的苹果投掷游戏，并进行双人游戏。我们必须将这次尝试保持简单，但您可能会对我们能够多快地创建一个概念验证感到惊讶。虽然有几种机制可以让两个玩家连接以共享体验，但我们的示例使用了我们在本章中讨论过的基本客户端/服务器模型。一个用户将启动服务器，第二个用户将作为客户端联系该服务器。一旦两个玩家连接，他们将竞赛看谁能最快地清理树木和篱笆！
- en: Setting up the UI
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置用户界面
- en: 'Let’s start by adding a menu to our game. Recall from [“Menus”](ch12.html#learnjava6-CHP-12-SECT-5.1)
    that menus live in a menu bar and work with `ActionEvent` objects, much like buttons.
    We need one option for starting a server and another for joining a game at a server
    someone has already started. The core code for these menu items is straightforward;
    we can use another helper method in the `AppleToss` class:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从给我们的游戏添加一个菜单开始。回想一下[“Menus”](ch12.html#learnjava6-CHP-12-SECT-5.1)中所述的，菜单位于菜单栏中，并与`ActionEvent`对象一起工作，就像按钮一样。我们需要一个选项来启动服务器，另一个选项是加入已经启动的服务器的游戏。这些菜单项的核心代码很简单；我们可以在`AppleToss`类中使用另一个辅助方法：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The use of lambdas for each menu’s `ActionListener` should look familiar. We
    also use the `JOptionPane` discussed in [“Modals and Pop-Ups”](ch12.html#learnjava6-CHP-12-SECT-5.2)
    to ask the second player for the name or IP address of the server where the first
    player is waiting. The networking logic is handled in a separate class.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个菜单的`ActionListener`使用lambda表达式应该很熟悉。我们还使用在[“Modals and Pop-Ups”](ch12.html#learnjava6-CHP-12-SECT-5.2)中讨论过的`JOptionPane`来询问第二个玩家第一个玩家正在等待的服务器的名称或IP地址。网络逻辑由一个单独的类处理。
- en: We’ll look at the `Multiplayer` class in more detail in the coming sections,
    but you can see the methods we’ll be implementing. The code for this version of
    the game (in the *ch13/examples/game* folder) contains the `setupNetworkMenu()`
    method, but the lambda listeners just pop up an info dialog to indicate which
    menu item was selected. You get to build the `Multiplayer` class and call the
    actual multiplayer methods in the exercises at the end of the chapter. But do
    feel free to check out the completed game—including the networking parts—in the
    *ch13/solutions/game* folder.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中更详细地查看`Multiplayer`类，但您可以看到我们将要实现的方法。游戏的这个版本的代码（在*ch13/examples/game*文件夹中）包含了`setupNetworkMenu()`方法，但是lambda监听器只是弹出一个信息对话框，指示选择了哪个菜单项。您可以构建`Multiplayer`类并在章节末尾的练习中调用实际的多人游戏方法。但是，欢迎查看*ch13/solutions/game*文件夹中已完成的游戏，包括网络部分。
- en: The game server
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 游戏服务器
- en: 'As we did in [“Servers”](#learnjava6-CHP-13-SECT-5.1.2), we need to pick a
    port and set up a socket that is listening for an incoming connection. We’ll use
    port 8677—“TOSS” on a phone number pad. We can create a `Server` inner class in
    our `Multiplayer` class to drive a thread ready for network communications. The
    `reader` and `writer` variables will be used to send and receive the actual game
    data. More on that in [“The game protocol”](#learnjava6-CHP-13-SECT-5.3.4):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[“Servers”](#learnjava6-CHP-13-SECT-5.1.2)中所做的那样，我们需要选择一个端口并设置一个监听传入连接的套接字。我们将使用端口8677——在电话号码键盘上为“TOSS”。我们可以在我们的`Multiplayer`类中创建一个`Server`内部类来驱动一个准备好进行网络通信的线程。`reader`和`writer`变量将用于发送和接收实际的游戏数据。关于这一点在[“The
    game protocol”](#learnjava6-CHP-13-SECT-5.3.4)中会详细讨论：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We set up our `ServerSocket` and then wait for a new client inside a loop. While
    we plan to play only one opponent at a time, this allows us to accept subsequent
    clients without going through all the network setup again.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置我们的`ServerSocket`，然后在循环内等待一个新的客户端。虽然我们计划一次只玩一个对手，但这使我们能够接受后续的客户端而不必重新进行所有的网络设置。
- en: 'To actually start the server listening the first time, we just need a new thread
    that uses our `Server` class:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际启动服务器监听第一次，我们只需要一个使用我们的`Server`类的新线程：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We keep a reference to the instance of `Server` in our `Multiplayer` class
    so that we have ready access to shut down the connections if the user selects
    the “disconnect” option from the menu, like so:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的`Multiplayer`类中保持对`Server`实例的引用，这样我们就可以随时访问，以便在用户从菜单中选择“断开连接”选项时关闭连接，如下所示：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We mainly use the `keepPlaying` flag once we’re inside our game loop, but it
    comes in handy above, too. If we have a valid `server` reference but we’re not
    currently playing a game (`keepPlaying` is false), we know to shut down the listener
    socket.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们进入游戏循环，我们主要使用`keepPlaying`标志，但是在上面也很方便。如果我们有一个有效的`server`引用，但当前没有玩游戏（`keepPlaying`为false），则我们知道要关闭监听器套接字。
- en: 'The `stopListening()` method in the `Server` inner class is straightforward:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`Server`内部类中的`stopListening()`方法很简单：'
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We do a quick check of our server and try to close `listener` only if it exists
    and is still open.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们快速检查我们的服务器，并仅在存在并且仍然打开时尝试关闭`listener`。
- en: The game client
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 游戏客户端
- en: 'The setup and teardown of the client side is similar—without the listening
    `ServerSocket`, of course. We’ll mirror the `Server` inner class with a `Client`
    inner class and build a smart `run()` method to implement our client logic:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端的设置和拆卸与之相似——当然没有监听`ServerSocket`。我们将使用一个`Client`内部类来镜像`Server`内部类，并构建一个智能的`run()`方法来实现我们的客户端逻辑：
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We pass the name of the server to the `Client` constructor and rely on the common
    `gamePort` variable used by `Server` to set up the socket. We use the “try with
    resource” technique discussed in [“try with Resources”](ch06.html#learnjava6-CHP-6-SECT-1.9)
    to create our socket and make sure it gets cleaned up when we’re done. Inside
    that resource `try` block, we create our `reader` and `writer` instances for the
    client’s half of the conversation, as shown in [Figure 13-4](#learnjava6-CHP-13-FIG-5).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将服务器的名称传递给`Client`构造函数，并依赖于`Server`使用的公共`gamePort`变量来设置套接字。我们使用了[“try with
    Resources”](ch06.html#learnjava6-CHP-6-SECT-1.9)中讨论的“try with resource”技术来创建套接字，并确保在完成后对其进行清理。在该资源`try`块内，我们创建了客户端对话半部分的`reader`和`writer`实例，如[Figure 13-4](#learnjava6-CHP-13-FIG-5)所示。
- en: '![ljv6 1304](assets/ljv6_1304.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 1304](assets/ljv6_1304.png)'
- en: Figure 13-4\. Game client and server connections
  id: totrans-134
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图13-4。游戏客户端和服务器连接
- en: 'To get this going, we’ll add another helper method to our `Multiplayer` helper
    class:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其运行，我们将在我们的`Multiplayer`辅助类中添加另一个帮助方法：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We don’t need a separate `disconnect()` method—we can use the same state variables
    used by the server. For the client, the `server` reference will be `null`, so
    we won’t attempt to shut down a nonexistent listener.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要单独的`disconnect()`方法——我们可以使用服务器使用的相同状态变量。对于客户端，`server`引用将为`null`，因此我们不会尝试关闭不存在的监听器。
- en: The game protocol
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 游戏协议
- en: You likely noticed we left out the bulk of the `run()` method for both the `Server`
    and `Client` classes. After we build and connect our data streams, the remaining
    work is all about collaboratively sending and receiving information about the
    state of our game. This structured communication is the game’s *protocol*. Every
    network service has a protocol. Think of the “P” in HTTP. Even our `DateAtHost`
    example uses a (very simple) protocol so that clients and servers know who is
    expected to talk and who must listen at any given moment. If both sides try to
    talk at the same time, information will likely be lost. If both sides end up waiting
    for the other side to say something (for instance, both the server and the client
    are blocking on a `reader.readLine()` call), then the connection will appear to
    hang.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能注意到我们忽略了`Server`和`Client`类的`run()`方法的大部分内容。在我们构建和连接数据流之后，剩下的工作都涉及协作地发送和接收关于游戏状态的信息。这种结构化的通信就是游戏的*协议*。每个网络服务都有一个协议。想一想HTTP中的“P”。即使我们的`DateAtHost`示例也使用了（非常简单的）协议，以便客户端和服务器知道谁应该在任何给定时刻说话，谁必须听取。如果两边同时尝试交谈，信息很可能会丢失。如果两边最终都等待对方说些什么（例如，服务器和客户端都在`reader.readLine()`调用上阻塞），则连接将看起来会挂起。
- en: Managing those communication expectations is the core of any protocol, but what
    to say and how to respond are also important. This portion of a protocol often
    requires the most effort from the developer. Part of the difficulty is that you
    really need both sides to test your work as you go. You can’t test a server without
    a client, and vice versa. Building up both sides as you go can feel tedious, but
    it is worth the extra effort. As with other kinds of debugging, fixing a small
    incremental change is much simpler than figuring out what might be wrong within
    a large block of code.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 管理这些通信期望是任何协议的核心，但是该说什么以及如何响应也很重要。协议的这一部分通常需要开发人员付出最多的努力。部分困难在于，您实际上需要两边都测试您的工作。没有客户端，无法测试服务器，反之亦然。随着工作的进行，构建两侧可能会感到乏味，但是额外的努力是值得的。与其他类型的调试一样，修复小的增量变化比弄清楚可能存在的大块代码中的问题要简单得多。
- en: 'In our game, we’ll have the server steer the conversation. This choice is arbitrary—we
    could have used the client, or we could have built a fancier foundation and allowed
    both the client and the server to be in charge of certain things simultaneously.
    With the “server in charge” decision made, though, we can try a very simple first
    step in our protocol. We’ll have the server send a `"NEW_GAME"` command and then
    wait for the client to respond with an `"OK"` answer. The server-side code (after
    the connection with the client is established) looks like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏中，我们将由服务器引导对话。这个选择是任意的——我们可以使用客户端，或者我们可以构建一个更复杂的基础，并允许客户端和服务器同时负责某些事情。然而，做出了“服务器负责”的决定后，我们可以在我们的协议中尝试一个非常简单的第一步。我们将让服务器发送一个`"NEW_GAME"`命令，然后等待客户端回应一个`"OK"`答案。服务器端的代码（与客户端建立连接后）如下所示：
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If we get the expected `"OK"` response, we can proceed with setting up a new
    game and sharing the tree and hedge locations with our opponent—more on that in
    a minute. (If we don’t get an `"OK"`, we show an error and reset to wait for some
    other attempt.) The corresponding client-side code for this first step flows similarly:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们得到了预期的`"OK"`响应，我们可以继续设置一个新游戏，并与对手分享树木和树篱的位置——稍后再说。 (如果我们没有收到`"OK"`，我们会显示一个错误并重置等待其他尝试。)
    这个第一步的相应客户端代码流程类似：
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If you want to try things as they stand, you can start your server from one
    system and then join that game from a second system. (You can also just launch
    a second copy of the game from a separate terminal window. In that case, the name
    of the “other host” would be the networking keyword `localhost`.) Almost immediately
    after joining from the second game instance, you should see the “Starting a new
    game!” confirmation printed in the terminal of the first game. Congratulations!
    You’re on your way to designing a game protocol. Let’s keep going.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想尝试当前的情况，你可以从一个系统启动你的服务器，然后从第二个系统加入该游戏。（你也可以只是从一个单独的终端窗口启动游戏的第二个副本。在这种情况下，“其他主机”的名称将是网络关键词`localhost`。）几乎在从第二个游戏实例加入后不久，你应该在第一个游戏的终端中看到“开始新游戏！”的确认打印。恭喜！你正在设计一个游戏协议。让我们继续。
- en: 'We need to even the playing field—quite literally. The server will tell its
    game to build a new field, and then it can ship the coordinates of all the new
    obstacles to the client. The client, in turn, can accept all the incoming trees
    and hedges, and place them on a clean field. Once the server has sent all of the
    trees, it can send a `"START"` command and play can begin. We’ll stick to using
    strings to communicate our messages. Here’s one way we can pass our tree details
    to the client:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确保公平竞技——字面上的意思。服务器会告诉游戏建立一个新场地，然后将所有新障碍的坐标发送给客户端。客户端则可以接受所有传入的树木和树篱，并将它们放置在一个干净的场地上。一旦服务器发送了所有树木，它就可以发送一个`"START"`命令，游戏就可以开始了。我们将继续使用字符串来传递我们的消息。以下是我们可以将树木细节传递给客户端的一种方式：
- en: '[PRE23]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'On the client side, we can call `readLine()` in a loop for `"TREE"` lines until
    we see the `“START”` line, like so (with a little error handling thrown in):'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端，我们可以调用`readLine()`在一个循环中用于`"TREE"`行，直到我们看到`“START”`行，就像这样（还加入了一些错误处理）：
- en: '[PRE24]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: At this point, both games should have the same obstacles, and players can begin
    clearing them. The server will enter a polling loop and send the current score
    twice a second. The client will reply with its current score. Note that there
    are certainly other options for how to share changes in the score. While polling
    is straightforward, more advanced games, or games that require more immediate
    feedback regarding remote players, will likely use more direct communication options.
    For now, we mainly want to concentrate on a good network back-and-forth, so polling
    keeps our code simpler.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，两个游戏应该具有相同的障碍，玩家可以开始清除它们。服务器将进入轮询循环，并每秒钟发送一次当前分数。客户端将回复其当前分数。请注意，肯定还有其他选项可以共享分数变化的方法。虽然轮询很简单，但更先进的游戏，或者需要更即时反馈关于远程玩家的游戏，可能会使用更直接的通信选项。目前，我们主要想专注于良好的网络来回，所以轮询会使我们的代码更简单。
- en: 'The server should keep sending the current score until the local player has
    cleared everything or we see a game-ending response from the client. We’ll need
    to parse the client’s response to update the other player’s score and watch for
    their request to end the game. We also have to be prepared for the client to simply
    disconnect. That loop looks something like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器应该持续发送当前分数，直到本地玩家清除所有内容或我们从客户端看到游戏结束的响应为止。我们需要解析客户端的响应以更新另一位玩家的分数，并关注他们请求结束游戏的情况。我们还必须准备好客户端可能会简单断开连接。该循环看起来像这样：
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The client will mirror these actions. Fortunately for the client, it is just
    reacting to the commands coming from the server. We don’t need a separate polling
    mechanism here. We block waiting to read a line, parse it, and then build our
    response:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端将复制这些操作。幸运的是对于客户端来说，它只是对来自服务器的命令做出反应。在这里我们不需要单独的轮询机制。我们阻塞等待读取一行，解析它，然后构建我们的响应：
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'When a player has cleared all of their trees and hedges, they send (or respond
    with) an `"END"` command that includes their final score. At that point, we ask
    if the same two players want to play again. If so, we can continue using the same
    `reader` and `writer` instances for both the server and the client. If not, we’ll
    let the client disconnect and the server will go back to listening for another
    player to join:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家清除了所有的树木和篱笆时，他们发送（或回复）一个包含他们最终分数的“END”命令。此时，我们会询问是否同样的两位玩家想再玩一次。如果是，我们可以继续为服务器和客户端使用相同的“读取器”和“写入器”实例。如果不是，我们将让客户端断开连接，服务器将继续监听另一位玩家加入：
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And one last reciprocal bit of code for the client:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后客户端的一个互为对等的代码：
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[Table 13-1](#learnjava6-CHP-13-TABLE-4) summarizes our simple protocol.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[表格 13-1](#learnjava6-CHP-13-TABLE-4) 总结了我们的简单协议。'
- en: Table 13-1\. Apple tossing game protocol
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 13-1\. 苹果投掷游戏协议
- en: '| Server command | Args (optional) | Client response | Args (optional) |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 服务器命令 | 参数（可选） | 客户端响应 | 参数（可选） |'
- en: '| --- | --- | --- | --- |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| NEW_GAME |  | OK |  |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| NEW_GAME |  | OK |  |'
- en: '| TREE | x y |  |  |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| TREE | x y |  |  |'
- en: '| START |  | OK |  |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| START |  | OK |  |'
- en: '| SCORE | score |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| SCORE | 分数 |'
- en: SCORE
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 分数
- en: END
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: END
- en: DISCONNECT
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 断开连接
- en: '|'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: score
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 分数
- en: score
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 分数
- en: '|'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| END | score |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| END | 分数 |'
- en: SCORE
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 分数
- en: DISCONNECT
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 断开连接
- en: '| score |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| 分数 |'
- en: '| PLAY_AGAIN |  |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| PLAY_AGAIN |  |'
- en: 'YES'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 'YES'
- en: DISCONNECT
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 断开连接
- en: '|  |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '| DISCONNECT |  |  |  |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| DISCONNECT |  |  |  |'
- en: Much More to Explore
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多探索
- en: We could spend much more time on our game. We could expand the protocol to allow
    multiple opponents. We could change the objective to clear the obstacles and destroy
    your opponent. We could make the protocol more bidirectional, allowing the client
    to initiate some of the updates. We could use alternate lower-level protocols
    supported by Java, such as UDP rather than TCP. Indeed, there are entire books
    devoted to games, network programming, and programming networked games!
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以花费更多的时间来开发我们的游戏。我们可以扩展协议以允许多个对手。我们可以将目标更改为清除障碍物并摧毁您的对手。我们可以使协议更双向，允许客户端启动一些更新。我们可以使用Java支持的备用低级协议，如UDP而不是TCP。事实上，有整整一本书专门讨论游戏、网络编程和编程网络游戏！
- en: But whew! You made it! Saying we covered a lot of ground is quite an understatement.
    We hope you have a solid understanding of Java’s syntax and core classes. You
    can use that understanding as you go forward and learn other interesting details
    and advanced techniques. Pick an area that interests you and go a little deeper.
    If you’re still curious about Java in general, try connecting parts of this book.
    For example, you could try using regular expressions to parse our apple toss game
    protocol. Or you could build a more sophisticated protocol altogether and pass
    small chunks of binary data over the network rather than simple strings. For practice
    writing more complex programs, you could rewrite some of the inner and anonymous
    classes in the game to be separate, standalone classes, or even replace them with
    lambda expressions.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 但哇！你成功了！说我们涵盖了很多领域真是大大低估了。我们希望您对Java的语法和核心类有扎实的理解。您可以利用这种理解继续学习其他有趣的细节和高级技巧。选择一个你感兴趣的领域，深入研究一下。如果您对Java仍然感到好奇，可以尝试连接本书的各个部分。例如，您可以尝试使用正则表达式来解析我们的苹果投掷游戏协议。或者，您可以构建一个更复杂的协议，通过网络传输小块二进制数据而不是简单的字符串。为了练习编写更复杂的程序，您可以将游戏中的一些内部和匿名类重写为独立的、独立的类，甚至用lambda表达式替换它们。
- en: If you want to explore other Java libraries and packages while sticking with
    some of the examples you have already worked on, you could dig into the Java2D
    API and make nicer looking apples and trees. You could try out some of the other
    collection objects, like `TreeMap` or `Deque`. You could research the popular
    [JSON format](https://oreil.ly/oEa0E) and try rewriting the multiplayer communication
    code. Using JSON for the protocol will likely give you the opportunity to work
    with a library as well.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想继续探索其他Java库和包，同时又坚持一些已经使用过的示例，您可以深入了解Java2D API，使苹果和树木看起来更漂亮。您可以尝试一些其他集合对象，如`TreeMap`或`Deque`。您可以研究流行的[JSON格式](https://oreil.ly/oEa0E)，并尝试重新编写多人通信代码。使用JSON作为协议可能会让您有机会使用一个库。
- en: When you’re ready to branch out further, you could see how Java works off the
    desktop by trying some Android development. Or look at large networked environments
    and the Jakarta Enterprise Edition from the Eclipse Foundation. Maybe big data
    is on your radar? The Apache Foundation has several projects, such as Hadoop or
    Spark. Java has its detractors, but it remains a vibrant, vital part of the professional
    developer world.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当您准备好进一步探索时，您可以尝试一些Android开发，了解Java在桌面之外的工作方式。或者查看大型网络环境和Eclipse基金会的Jakarta企业版。也许大数据正引起您的注意？Apache基金会有几个项目，如Hadoop或Spark。Java有它的批评者，但它仍然是专业开发者世界中充满活力和重要的一部分。
- en: Now that we’ve laid out some avenues for future research, we are ready to wrap
    up the main part of our book. The [Glossary](glossary01.html#learnjava6-GLOSS)
    contains a quick reference of many useful terms and topics we’ve covered. [Appendix A](app01.html#learnjava6-APP-A)
    has some details on getting the code examples imported into IntelliJ IDEA. [Appendix B](app02.html#learnjava6-APP-B)
    includes answers to all of the review questions as well as some hints and guidance
    on the code exercises.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经列出了一些未来研究的途径，我们准备结束本书的主要部分。[术语表](glossary01.html#learnjava6-GLOSS)包含了我们涵盖的许多有用术语和主题的快速参考。[附录 A](app01.html#learnjava6-APP-A)详细说明了如何将代码示例导入到IntelliJ
    IDEA中。[附录 B](app02.html#learnjava6-APP-B)包括了所有复习问题的答案以及一些提示和指导，以及代码练习的指导。
- en: We hope that you’ve enjoyed this sixth edition of *Learning Java*. This is really
    the eighth edition of the series that began over two decades ago with *Exploring
    Java*. It has been a long and amazing trip watching Java develop in that time,
    and we thank those of you who have come along with us over the years. As always,
    we welcome your feedback to help us keep making this book better in the future.
    Ready for another decade of Java? We are!
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您享受本书的第六版*学习Java*。这实际上是该系列的第八版，始于二十多年前的*探索Java*。在这段时间里，观察Java的发展真是一段漫长而惊人的旅程，我们感谢多年来与我们同行的您们。正如往常一样，我们期待您的反馈，以帮助我们在未来使这本书变得更好。准备好迎接Java的另一个十年了吗？我们准备好了！
- en: Review Questions
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复习问题
- en: Which networking protocols does the `URL` class support by default?
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`URL`类默认支持哪些网络协议？'
- en: Can you use Java to download binary data from an online source?
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您能使用Java从在线源下载二进制数据吗？
- en: What are the high-level steps to send form data to a web server using Java?
    Which classes are involved?
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Java将表单数据发送到Web服务器的高级步骤是什么？涉及哪些类？
- en: What class do you use to listen for incoming network connections?
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您用于侦听传入网络连接的类是什么？
- en: When creating your own server like you did for the game, are there any rules
    for picking a port number?
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建类似于您为游戏创建的服务器时，是否有选择端口号的任何规则？
- en: Can a server application written in Java support multiple, simultaneous clients?
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用Java编写的服务器应用程序能支持多个同时客户端吗？
- en: How many simultaneous servers can a given client `Socket` instance connect to?
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定的客户端`Socket`实例可以连接到多少个同时服务器？
- en: Code Exercises
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码练习
- en: Create your own, human-friendly `DateAtHost` client (`FDClient`, Friendly Date
    Client, in our solutions) and server (`FDServer`). Use the classes and formatters
    from [“Dates and Times”](ch08.html#learnjava6-CHP-8-SECT-5) to produce a server
    that sends one line of nicely formatted text containing the current date and time.
    Your client should read that line after connecting and print it out. (Your client
    does not need to extend `Instant` or even store the response beyond printing it
    out.)
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建您自己的人性化`DateAtHost`客户端（在我们的解决方案中是`FDClient`，友好日期客户端）和服务器（`FDServer`）。使用[“日期和时间”](ch08.html#learnjava6-CHP-8-SECT-5)中的类和格式化程序，生成一个发送包含当前日期和时间的一行格式良好文本的服务器。您的客户端应在连接后读取该行并将其打印出来。（您的客户端不需要扩展`Instant`甚至在打印之外存储响应。）
- en: Our game protocol does not yet include support for the hedge obstacles. (Hedges
    are still in the game, but they aren’t part of the network communications yet.)
    Review [Table 13-1](#learnjava6-CHP-13-TABLE-4) and add support for a `HEDGE`
    entry similar to our `TREE` lines. It may be easier to update the client side
    first, although you will need to update both sides to have the hedges work like
    the trees for both players.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的游戏协议尚不包括对树篱障碍物的支持。（树篱仍然存在于游戏中，但它们尚未包含在网络通信中。）请查看[Table 13-1](#learnjava6-CHP-13-TABLE-4)，并添加类似于我们`TREE`行的`HEDGE`条目支持。可能首先更新客户端会更容易，尽管你需要更新两端，以使树篱对于两名玩家的功能类似于树木。
- en: Advanced Exercises
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进阶练习
- en: Upgrade your `FDServer` class to handle multiple, simultaneous clients with
    threads or virtual threads. You can put your client handling code in a lambda,
    an (anonymous) inner class, or a separate helper class. You should be able to
    use the same `FDClient` class from the first exercise without recompiling. If
    you use virtual threads, remember that they may still be a preview feature in
    your version of Java. Use the appropriate flags when compiling and running. (Our
    solution for this exercise is in `FDServer2`.)
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 升级你的`FDServer`类，以处理多个同时连接的客户端，可以使用线程或虚拟线程。你可以将客户端处理代码放入lambda表达式、匿名内部类或单独的辅助类中。你应该能够在不重新编译的情况下使用第一个练习中的`FDClient`类。如果使用虚拟线程，请记住它们可能仍然是Java版本中的预览功能。编译和运行时请使用适当的标志。（我们对这个练习的解决方案在`FDServer2`中。）
- en: This exercise is more of a nudge to go explore the world of web services now
    that you have seen some examples of using Java to interact with online APIs. Search
    online for a service with a free developer account option (signing up may still
    be necessary), and write a Java client for that service. Many of the services
    available online require some type of authentication, such as an *API token* or
    *API key* (usually long strings that work like unique usernames). Sites like [random.org](https://oreil.ly/moEyN)
    or [openweathermap.org](https://oreil.ly/8B4rl) could be fun places to start.
    (We do provide a completed client, `NetworkInt`, for getting random integers from
    *random.org* in the solutions. You’ll need to provide your own API key in the
    source for the client to work.)
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个练习更像是一个推动，去探索Web服务的世界，现在你已经看过使用Java与在线API交互的一些示例。在线搜索一个具有免费开发者账户选项的服务（可能仍需注册），并编写一个Java客户端来访问该服务。许多在线服务都需要某种形式的身份验证，比如*API令牌*或*API密钥*（通常是长字符串，类似于唯一的用户名）。像[random.org](https://oreil.ly/moEyN)或[openweathermap.org](https://oreil.ly/8B4rl)这样的网站可能是开始的有趣地方。（我们在解决方案中提供了一个完整的客户端`NetworkInt`，用于从*random.org*获取随机整数。为使客户端正常工作，你需要在源代码中提供自己的API密钥。）
- en: ^([1](ch13.html#id2506-marker)) Postman is a fantastic tool for web developers.
    You can learn more at the [Postman site](https://oreil.ly/3LKc6). The testing
    service they host at [postman-echo.com](https://oreil.ly/hzZpS) accepts both GET
    and POST requests, and echoes back the request and any form or URL parameters.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch13.html#id2506-marker)) Postman是Web开发人员的绝佳工具。你可以在[Postman网站](https://oreil.ly/3LKc6)了解更多。它们托管的测试服务位于[postman-echo.com](https://oreil.ly/hzZpS)，接受GET和POST请求，并回显请求及任何表单或URL参数。
- en: ^([2](ch13.html#id2514-marker)) You may have heard the phrase “MIME type” before.
    MIME has its roots in email, and the term “media” is meant to be more generic.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch13.html#id2514-marker)) 你可能之前听过“MIME类型”的短语。MIME起源于电子邮件，术语“媒体”意图更为通用。
- en: ^([3](ch13.html#id2534-marker)) For a detailed discussion of these low-level
    sockets, see *Unix Network Programming* by W. Richard Stevens et al. (Prentice-Hall).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch13.html#id2534-marker)) 详细讨论这些低级套接字，请参阅*Unix网络编程*，作者为W. Richard Stevens等人（Prentice-Hall）。
- en: ^([4](ch13.html#id2546-marker)) A peer-to-peer environment, for example, has
    machines that simultaneously perform both roles.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch13.html#id2546-marker)) 例如，点对点环境具有同时执行两种角色的机器。
- en: ^([5](ch13.html#id2559-marker)) For more on well-known services and their standard
    port numbers, see the [official list](https://oreil.ly/4WCON) hosted by the Internet
    Assigned Numbers Authority.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch13.html#id2559-marker)) 欲了解更多著名服务及其标准端口号，请参阅由互联网编号分配机构（Internet Assigned
    Numbers Authority）托管的[官方列表](https://oreil.ly/4WCON)。
- en: ^([6](ch13.html#id2561-marker)) Massively Multiplayer Online Role-Playing Game,
    if, like the authors, you’re too old to recognize the acronym. Sigh.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch13.html#id2561-marker)) 大型多人在线角色扮演游戏，如果像作者一样，你也对这个缩写感到陌生。叹息。
- en: ^([7](ch13.html#id2568-marker)) Indeed, the publicly available site we use from
    NIST strongly encourages users to upgrade. See the [introductory notes](https://oreil.ly/hYBSO)
    for the NIST Internet Time Servers for more information.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch13.html#id2568-marker)) 实际上，我们使用的来自NIST的公开网站强烈建议用户升级。有关NIST互联网时间服务器的详细信息，请参阅[介绍性说明](https://oreil.ly/hYBSO)。
