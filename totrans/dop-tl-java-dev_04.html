<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 4. Dissecting the Monolith"><div class="chapter" id="dissecting_the_monolith">
<h1><span class="label">Chapter 4. </span>Dissecting the Monolith</h1>


<p class="byline">Ixchel Ruiz</p>
  <blockquote data-type="epigraph" epub:type="epigraph">
    <p>The ultimate goal should be to improve the quality of human life through digital innovation.</p>
    <p data-type="attribution">Pony Ma Huateng</p>
  </blockquote>

<p>Throughout history, humans have been obsessed with deconstructing ideas and concepts into simple or composite parts.<a data-type="indexterm" data-primary="microservices" data-secondary="about" id="idm45310224105312"/>
It is by combining analysis and synthesis that we can achieve a higher level of understanding.</p>

<p>Aristotle called analytics “the resolution of every compound into those things out of which the synthesis is made.
For analysis is the converse of synthesis.
<em>Synthesis</em> is the road from the principles to those things that derive from the principles, and analysis is the return from the end to the principles.”</p>

<p>Software development follows a similar approach: analyze a system into its composite parts, identifying inputs, desired outputs, and detail functions.
During the analytic process of software development, we have realized that non-business-specific functionality is always required to process inputs and to communicate or persist outputs.
This makes it obvious that we could benefit from reusable, well-defined, context-bound, atomic functionality that can be shared, consumed, or interconnected to simplify building software.</p>

<p>Allowing developers to focus primarily on implementing business logic to fulfill purposes—like meeting well-defined needs of a client/business, meeting a perceived need of some set of potential users, or using the functionality for personal needs (to automate tasks)—has been a long-held desire.
Too much time is wasted every day reinventing one of the most reinvented wheels: reliable boilerplate code.</p>

<p>The microservices pattern has gained notoriety and momentum in recent years because the promised benefits are outstanding.
Avoiding known antipatterns, adopting best practices, and understanding core concepts and definitions are paramount in achieving the benefits of this architectural pattern while reducing the drawbacks of adopting it. This chapter covers antipatterns and contains code examples of microservices written with popular microservice frameworks such as Spring Boot, Micronaut, Quarkus, and Helidon.</p>

<p>Traditionally a monolithic architecture delivers<a data-type="indexterm" data-primary="monolithic architecture" id="idm45310224100464"/><a data-type="indexterm" data-primary="monolith applications" id="idm45310224099760"/> or deploys single units or systems, addressing all requirements from a single source application, and two concepts can be identified: the <em>monolith application</em> and the <em>monolithic architecture</em>.</p>

<p>A <em>monolith application</em> has <em>only one</em> deployed instance, responsible for performing all steps needed for a specific function.
One characteristic of such an application is a unique interface point of execution.</p>

<p>A <em>monolithic architecture</em> refers to an application for which all requirements are addressed from a single source and all parts are delivered as one unit.
Components may have been designed to restrict interaction with external clients in order to explicitly limit access of <em>private</em> functionality.
Components in the monolith may be interconnected or interdependent rather than loosely coupled.
In other words, from the outside or user perspective, there is little knowledge of the definitions, interfaces, data, and services of other separate components.</p>

<p><em>Granularity</em> is the aggregation level exposed<a data-type="indexterm" data-primary="granularity" id="idm45310224093840"/><a data-type="indexterm" data-primary="microservices" data-secondary="about" data-tertiary="granularity" id="idm45310224093136"/> by a component to other external cooperating or collaborating parts of software.
The level of granularity in software depends on several factors, such as the level of confidentiality that must be maintained within a series of components and not be exposed or available to other consumers.</p>

<p>Modern software architectures are increasingly focused on delivering functionality by bundling or combining software components from different sources, resulting in or emphasizing a finer granularity in level of detail.
The functionality exposed then to different components, customers, or consumers is greater than in a monolithic application.</p>

<p>To qualify how independent or interchangeable<a data-type="indexterm" data-primary="dependencies" data-secondary="module independence" id="idm45310224090256"/> a module is, we should look closely at the following characteristics:</p>

<ul>
<li>
<p>Number of dependencies</p>
</li>
<li>
<p>Strength of these dependencies</p>
</li>
<li>
<p>Stability of the modules it depends on</p>
</li>
</ul>

<p>Any high score assigned to the previous characteristics should trigger a second review of the modeling and definition of the module.</p>






<section data-type="sect1" data-pdf-bookmark="Cloud Computing"><div class="sect1" id="idm45310224085248">
<h1>Cloud Computing</h1>

<p><em>Cloud computing</em> has several definitions.<a data-type="indexterm" data-primary="cloud computing" data-secondary="about" id="idm45310224083232"/><a data-type="indexterm" data-primary="Grance, Tim" id="idm45310224082256"/><a data-type="indexterm" data-primary="Mell, Peter" id="idm45310224081584"/> Peter Mell and Tim Grance define it as a model for enabling ubiquitous, convenient, on-demand network access to a shared pool of configurable computing resources (such as networks, servers, storage, applications, and services) that can be rapidly provisioned and released with minimal management effort or service provider interaction.</p>

<p>In recent years, cloud computing has increased considerably.<a data-type="indexterm" data-primary="cloud computing" data-secondary="about" data-tertiary="growth of" id="idm45310224080048"/>
For example, cloud infrastructure services spending increased 32% to $39.9 billion in the last quarter of 2020. Total expenditure was more than $3 billion higher than the previous quarter and nearly $10 billion more than Q4 2019, according to <a href="https://oreil.ly/uZdZa">Canalys data</a>.</p>

<p>Several providers exist, but the market share is not evenly distributed.<a data-type="indexterm" data-primary="Amazon Web Services (AWS)" data-secondary="cloud computing provider" id="idm45310224077232"/><a data-type="indexterm" data-primary="Microsoft Azure" id="idm45310224076176"/><a data-type="indexterm" data-primary="Google Cloud" id="idm45310224075504"/> The three leading service providers are Amazon Web Services (AWS), Microsoft Azure, and Google Cloud.
AWS is the leading cloud service provider, accounting for 31% of total spending in Q4 2020. Azure’s growth rate accelerated, up by 50%, with a share close to 20%, whereas Google Cloud accounts for a 7% share of the total market.</p>

<p>Utilization of cloud computing services has been lagging.
Cinar Kilcioglu and Aadharsh Kannan reported in 2017 in “Proceedings of the 26th International World Wide Web Conference” that usage of cloud resources in data centers shows a substantial gap between the resources that cloud customers allocate and pay for (leasing VMs), and actual resource utilization (CPU, memory, and so on).
Perhaps customers are just leaving their VMs on but not actually using them.</p>

<p>Cloud services are divided into categories used for different types of computing:<a data-type="indexterm" data-primary="cloud computing" data-secondary="cloud services" id="idm45310224073552"/></p>
<dl>
<dt>Software as a service (SaaS)</dt>
<dd>
<p><a data-type="indexterm" data-primary="software as a service (SaaS)" data-secondary="about" id="idm45310224070944"/>The client can use the provider’s applications running on a cloud infrastructure.
The applications are accessible from various client devices through either a thin client interface, such as a web browser, or a program interface.
The client does not manage or control the underlying cloud infrastructure, including network, servers, operating systems, storage, or even individual application capabilities, with the possible exception of limited user-specific application configuration settings.</p>
</dd>
<dt>Platform as a service (PaaS)</dt>
<dd>
<p><a data-type="indexterm" data-primary="platform as a service (PaaS)" id="idm45310224068192"/><a data-type="indexterm" data-primary="PaaS (platform as a service)" id="idm45310224019744"/>The client can deploy onto the cloud infrastructure client-made or acquired applications created using programming languages, libraries, services, and tools supported by the provider.
The consumer does not manage or control the underlying cloud infrastructure, including network, servers, operating systems, or storage, but does have control over the deployed applications and possibly configuration settings for the application-hosting environment.</p>
</dd>
<dt>Infrastructure as a service (IaaS)</dt>
<dd>
<p><a data-type="indexterm" data-primary="infrastructure as a service (IaaS)" id="idm45310224017344"/><a data-type="indexterm" data-primary="IaaS (infrastructure as a service)" id="idm45310224016576"/><a data-type="indexterm" data-primary="OS" data-secondary="infrastructure as a service" id="idm45310224015888"/>The client is able to provision processing, storage, networks, and other fundamental computing resources.
They can deploy and run arbitrary software, which can <em>include operating systems and applications</em>.
The client does not manage or control the underlying cloud infrastructure but has control over operating systems, storage, and deployed applications—and possibly limited control of select networking components.</p>
</dd>
</dl>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Microservices"><div class="sect1" id="idm45310224013648">
<h1>Microservices</h1>

<p>The term <em>microservice</em> is not a recent one.<a data-type="indexterm" data-primary="microservices" data-secondary="about" id="idm45310224011008"/><a data-type="indexterm" data-primary="Rodgers, Peter" id="idm45310224010000"/><a data-type="indexterm" data-primary="microservices" data-secondary="about" data-tertiary="microservice architecture" id="idm45310224009328"/><a data-type="indexterm" data-primary="service-oriented architecture (SOA)" id="idm45310224008144"/> Peter Rodgers introduced the term <em>micro-web services</em> in 2005 while championing the idea of <em>software as micro-web-services</em>. <em>Microservice_architecture</em>—an evolution of service-oriented architecture (SOA)—arranges an application as a collection of relatively lightweight modular services.
Technically, microservices is a specialization of an implementation approach for SOA.</p>

<p><em>Microservices</em> are small and loosely coupled components.<a data-type="indexterm" data-primary="microservices" data-secondary="about" data-tertiary="monoliths versus" id="idm45310224005168"/><a data-type="indexterm" data-primary="monolith applications" data-secondary="microservices versus" id="idm45310224003920"/>
In contrast to monoliths, they can be deployed, scaled, and tested independently, and they have a single responsibility, bounded by context, and are autonomous and decentralized. They are usually built around business capabilities, are easy to understand, and may be developed using different technology stacks.</p>

<p>How small should a microservice be? It should be <em>micro</em> enough to allow small, self-contained, and rigidly enforced atoms of functionality that can coexist, evolve, or replace the previous ones according to business needs.</p>

<p>Each component or service has little or no knowledge of the definitions of other separate components,<a data-type="indexterm" data-primary="microservices" data-secondary="about" data-tertiary="APIs for interaction" id="idm45310224001456"/><a data-type="indexterm" data-primary="APIs" data-secondary="microservice interaction" id="idm45310224000208"/> and all interaction with a service is via its API, which encapsulates its implementation details. The messaging between these microservices uses simple protocols and usually is not data intensive.</p>








<section data-type="sect2" data-pdf-bookmark="Antipatterns"><div class="sect2" id="idm45310223998784">
<h2>Antipatterns</h2>

<p>The microservice pattern results in significant complexity and is not ideal in all situations.<a data-type="indexterm" data-primary="microservices" data-secondary="antipatterns" id="ch04-antip"/>
The system is made up of many parts that work independently, and its very nature makes it harder to predict how it will perform in the real world.</p>

<p>This increased complexity is mainly due to the (potentially) thousands of microservices running asynchronously in the distributed computer network.
Keep in mind that programs that are difficult to understand are also difficult to write, modify, test, and measure.
All these concerns will increase the time teams need to spend on understanding, discussing, tracking, and testing interfaces and message formats.</p>

<p>Several books, articles, and papers are available on this particular topic.<a data-type="indexterm" data-primary="microservices" data-secondary="antipatterns" data-tertiary="resources for learning" id="idm45310223994032"/><a data-type="indexterm" data-primary="resources for learning" data-secondary="microservice antipatterns" id="idm45310223992784"/><a data-type="indexterm" data-primary="Richards, Mark" id="idm45310223991872"/><a data-type="indexterm" data-primary="Microservices AntiPatterns and Pitfalls (Richards)" id="idm45310223991200"/><a data-type="indexterm" data-primary="Taibi, Davide" id="idm45310223990432"/><a data-type="indexterm" data-primary="Lenarduzz, Valentina" id="idm45310223989760"/><a data-type="indexterm" data-primary="“On the Definition of Microservice Bad Smells” (Taibi and Lenarduzz)" data-primary-sortas="On the Definition of Microservice" id="idm45310223989088"/>
I recommend a visit to <a href="https://microservices.io">Microservices.io</a>, Mark Richards’s report <a href="https://oreil.ly/KpzyW"><em>Microservices AntiPatterns and Pitfalls</em></a> (O’Reilly), and “On the Definition of Microservice Bad Smells” by Davide Taibi and Valentina Lenarduzz (published in <em>IEEE Software</em> in 2018).</p>

<p>Some of the most common antipatterns include the following:</p>
<dl>
<dt>API versioning (<em>static contract pitfall</em>)</dt>
<dd>
<p>APIs need to be semantically versioned to allow services to know whether they are communicating with the right version of the service or whether they need to adapt their communication to a new contract.<a data-type="indexterm" data-primary="APIs" data-secondary="API versioning antipattern" id="idm45310223982576"/><a data-type="indexterm" data-primary="static contract pitfall" id="idm45310223981584"/></p>
</dd>
<dt>Inappropriate service privacy interdependency</dt>
<dd>
<p>The microservice requires private data from other services instead of dealing with its own data, a problem that usually is related to a modeling-the-data issue.
One solution to consider is merging the microservices.<a data-type="indexterm" data-primary="data" data-secondary="service privacy interdependency antipattern" id="idm45310223979440"/><a data-type="indexterm" data-primary="dependencies" data-secondary="microservice antipatterns" id="idm45310223978368"/></p>
</dd>
<dt>Multipurpose megaservice</dt>
<dd>
<p>Several business functions are implemented in the same service.<a data-type="indexterm" data-primary="megaservice antipattern" id="idm45310223976160"/></p>
</dd>
<dt>Logging</dt>
<dd>
<p>Errors and microservice information are hidden inside each microservice container.
The adoption of a distributed logging system should be a priority as issues are found in all stages of the software lifecycle.<a data-type="indexterm" data-primary="logging" data-secondary="antipattern" id="idm45310223973872"/></p>
</dd>
<dt>Complex interservice or circular dependencies</dt>
<dd>
<p>A <em>circular service relationship</em> is defined as a relationship between two or more services that are interdependent.<a data-type="indexterm" data-primary="circular service relationships" id="idm45310223971056"/>
Circular dependencies can harm the ability of services to scale or deploy independently, <a data-type="indexterm" data-primary="dependencies" data-secondary="acyclic dependencies principle" id="idm45310223970080"/><a data-type="indexterm" data-primary="acyclic dependencies principle (ADP)" id="idm45310223969120"/>as well as violate the acyclic dependencies principle (ADP).</p>
</dd>
<dt>Missing API gateway</dt>
<dd>
<p>When microservices communicate directly with each other, or when the service consumers communicate directly with each microservice, complexity increases and maintenance decreases in the system.<a data-type="indexterm" data-primary="APIs" data-secondary="API gateways" id="idm45310223966736"/><a data-type="indexterm" data-primary="API gateways" id="idm45310223965760"/><a data-type="indexterm" data-primary="microservices" data-secondary="API gateways" id="idm45310223965088"/>
The best practice in this case is to use an API gateway.</p>

<p>An <em>API gateway</em> receives all API calls from clients and then directs them to the appropriate microservice by request routing, composition, and protocol translation.
The gateway usually handles the request by calling multiple microservices and aggregating the results to determine the best route.
It is also able to translate between web protocols and web-friendly protocols for internal use.</p>

<p>An application may use an API gateway to provide a single endpoint for mobile customers to query all product data with a single request.
The API gateway consolidates various services, such as product information and reviews, and combines and exposes the results.</p>

<p>The API gateway is the gatekeeper for applications to access data, business logic, or functions (RESTful APIs or WebSocket APIs) that allow real-time two-way communication applications.
The API gateway typically handles all the tasks involved in accepting and processing up to hundreds of thousands of concurrent API calls, including traffic management, cross-origin resource sharing (CORS) support, authorization and access control, choking, management, and API version control.</p>
</dd>
<dt>Sharing too much</dt>
<dd>
<p>A thin line lies between sharing enough functionality to not repeat yourself and creating a tangled mess of dependencies that prevents service changes from being separated.
If an overshared service needs to be changed, evaluating proposed changes in the interfaces will eventually lead to an organizational task involving more development teams.</p>

<p>At some point, the choice of redundancy or library extraction into a new shared service that related microservices can install and develop independently of each other needs to be analyzed.<a data-type="indexterm" data-startref="ch04-antip" id="idm45310223958704"/></p>
</dd>
</dl>
</div></section>













<section data-type="sect2" data-pdf-bookmark="DevOps and Microservices"><div class="sect2" id="idm45310223984672">
<h2>DevOps and Microservices</h2>

<p>Microservices fit perfectly into the <a data-type="indexterm" data-primary="microservices" data-secondary="DevOps and" id="idm45310223956608"/><a data-type="indexterm" data-primary="DevOps" data-secondary="microservices and" id="idm45310223955632"/>DevOps ideal of utilizing small teams to create functional changes to the enterprise’s services one step at a time—the idea of breaking large problems into smaller pieces and tackling them systematically.
To reduce the friction between development, testing, and deployment of smaller independent services, a series of continuous delivery pipelines to maintain a steady flow of these stages has to be present.</p>

<p>DevOps is a key factor in the success of this architectural style, providing the necessary organizational changes to minimize coordination between teams responsible for each component and to remove barriers to effective, reciprocal interaction between development and operations teams.</p>
<div data-type="caution"><h6>Caution</h6>
<p>I strongly dissuade any team from adopting<a data-type="indexterm" data-primary="CI/CD (continuous integration and deployment)" data-secondary="microservices requiring" id="idm45310223952368"/><a data-type="indexterm" data-primary="continuous integration and deployment" data-see="CI/CD" id="idm45310223951296"/> the microservices pattern without a robust CI/CD infrastructure in place or without a widespread understanding of the basic concepts of pipelines.</p>
</div>
</div></section>













<section data-type="sect2" class="less_space pagebreak-before" data-pdf-bookmark="Microservice Frameworks"><div class="sect2" id="idm45310223949616">
<h2>Microservice Frameworks</h2>

<p>The JVM ecosystem is vast and provides<a data-type="indexterm" data-primary="microservices" data-secondary="frameworks" data-tertiary="about implementation" id="idm45310223947792"/><a data-type="indexterm" data-primary="Spring Boot" data-secondary="about implementation" id="idm45310223946544"/><a data-type="indexterm" data-primary="Micronaut" data-secondary="about implementation" id="idm45310223945600"/><a data-type="indexterm" data-primary="Quarkus" data-secondary="about implementation" id="idm45310223944656"/><a data-type="indexterm" data-primary="Helidon" data-secondary="about implementation" id="idm45310223943712"/><a data-type="indexterm" data-primary="Native Image" data-secondary="about" data-tertiary="implementation" id="idm45310223942768"/> plenty of alternatives for a particular use case. Dozens of microservice frameworks and libraries are available, to the point that it can be tricky to pick a winner among candidates.</p>

<p>That said, certain candidate frameworks have gained popularity for several reasons: developer experience, time to market, extensibility, resource (CPU, memory) consumption, startup speed, failure recovery, documentation, third-party integrations, and more.
These frameworks—Spring Boot, Micronaut, Quarkus, and Helidon—are covered in the following sections.
Take into account that some of the instructions may require additional tweaks based on newer versions, as some of these technologies evolve quite rapidly.
I strongly recommend reviewing the documentation of each framework.</p>

<p>Additionally, these examples require Java 11 as a minimum, <a data-type="indexterm" data-primary="GraalVM" data-secondary="Native Image" data-tertiary="requiring GraalVM" id="idm45310223940432"/><a data-type="indexterm" data-primary="Native Image" data-secondary="GraalVM required" id="idm45310223939184"/>and trying out Native Image also requires an installation of GraalVM.
There are many ways to get these versions installed in your environment.<a data-type="indexterm" data-primary="SDKMAN!" id="idm45310223937952"/>
I recommend using <a href="https://sdkman.io">SDKMAN!</a> to install and manage them.
For brevity, I concentrate on production code alone—a single framework could fill a whole book!
It goes without saying that you should take care of tests as well.
The goal for each example is to build a trivial “Hello World” REST service that can take an optional name parameter and reply with a greeting.</p>

<p>If you have not worked with GraalVM before,<a data-type="indexterm" data-primary="GraalVM" id="idm45310223935696"/> it’s an umbrella project for a handful of technologies that enable the following features:</p>

<ul>
<li>
<p>A just-in-time (JIT) compiler written in Java, which compiles code on the fly, transforming interpreted code into executable code.
The Java platform has had a handful of JITs, most written using a combination of C and C++.
Graal happens to be the most modern one, written in Java.</p>
</li>
<li>
<p>A virtual machine named <em>Substrate VM</em> that’s capable of running hosted languages such as Python, JavaScript, and R on top of the JVM in such a way that the hosted language benefits from tighter integration with JVM capabilities and features.</p>
</li>
<li>
<p>Native Image, a utility<a data-type="indexterm" data-primary="Native Image" data-secondary="about" id="idm45310223930912"/><a data-type="indexterm" data-primary="GraalVM" data-secondary="Native Image" id="idm45310223929904"/> that relies on ahead-of-time (AOT) compilation, which transforms bytecode into machine-executable code.
The resulting transformation produces a platform-specific binary executable.</p>
</li>
</ul>

<p>All four candidate frameworks covered here<a data-type="indexterm" data-primary="GraalVM" data-secondary="frameworks supporting" id="idm45310223927776"/><a data-type="indexterm" data-primary="GraalVM" data-secondary="Native Image" data-tertiary="platform-specific binaries" id="idm45310223926800"/><a data-type="indexterm" data-primary="Native Image" data-secondary="GraalVM required" data-tertiary="platform-specific binaries" id="idm45310223925568"/> provide support for GraalVM in one way or another, chiefly relying on GraalVM Native Image to produce platform-specific binaries with the goal of reducing deployment size and memory consumption.
Be aware that there’s a trade-off between<a data-type="indexterm" data-primary="Spring Boot" data-secondary="about implementation" data-tertiary="Java versus GraalVM Native Image" id="idm45310223923952"/><a data-type="indexterm" data-primary="Micronaut" data-secondary="about implementation" data-tertiary="Java versus GraalVM Native Image" id="idm45310223922720"/><a data-type="indexterm" data-primary="Helidon" data-secondary="about implementation" data-tertiary="Java versus GraalVM Native Image" id="idm45310223921488"/><a data-type="indexterm" data-primary="Quarkus" data-secondary="about implementation" data-tertiary="Java versus GraalVM Native Image" id="idm45310223920256"/><a data-type="indexterm" data-primary="GraalVM" data-secondary="Native Image" data-tertiary="Java mode versus" id="idm45310223919024"/><a data-type="indexterm" data-primary="Native Image" data-secondary="GraalVM required" data-tertiary="Java mode versus" id="idm45310223917808"/><a data-type="indexterm" data-primary="microservices" data-secondary="frameworks" data-tertiary="Java versus GraalVM Native Image" id="idm45310223916592"/> using the Java mode and the GraalVM Native Image mode. The latter can produce binaries with a smaller memory footprint and faster startup time but requires longer compilation time; long-running Java code will eventually become more optimized (that’s one of the key features of the JVM), whereas native binaries cannot be optimized while running. Development experience also varies, as you may need to use additional tools for debugging, monitoring, measuring, and so forth.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Spring Boot"><div class="sect2" id="idm45310223914736">
<h2>Spring Boot</h2>

<p><em>Spring Boot</em> is perhaps the most well-known<a data-type="indexterm" data-primary="Spring Boot" id="ch04-SB"/><a data-type="indexterm" data-primary="microservices" data-secondary="frameworks" data-tertiary="Spring Boot" id="ch04-SB2"/><a data-type="indexterm" data-primary="Spring Framework" id="idm45310223909968"/> among the four candidates, as it builds on top of the legacy laid out by the Spring Framework.
If developer surveys are to be taken at face value, more than 60% of Java developers have some sort of experience interacting with Spring-related projects, making Spring Boot the most popular choice.</p>

<p>The Spring way lets you assemble applications (or microservices, in our case) by composing existing components, customizing their configuration, and promising low-cost code ownership, as your custom logic is supposedly smaller in size than what the framework brings to the table, and for most organizations that’s true.
The trick is to find an existing component that can be tweaked and configured before writing your own.
The Spring Boot team makes a point of adding as many useful integrations as needed, from database drivers to monitoring services, logging, journaling, batch processing, report generation, and more.</p>

<p>The typical way to bootstrap a Spring Boot project<a data-type="indexterm" data-primary="Spring Boot" data-secondary="Spring Initializr" id="idm45310223908064"/> is by browsing to the <a href="https://start.spring.io">Spring Initializr</a>, selecting the features you require in your application, and clicking the Generate button.
This action creates a ZIP file that you can download to your local environment to get started.
In <a data-type="xref" href="#spring_initializr">Figure 4-1</a>, I’ve selected the Web and Spring Native features.
The first feature adds components that let you expose data via REST APIs; the second enhances the build with an extra packaging mechanism that can create Native Images with Graal.</p>

<p>Unpacking the ZIP file and running the <code>./mvnw verify</code> command at the root directory of the project ensures a sound starting point.
You’ll notice the command will download<a data-type="indexterm" data-primary="dependencies" data-secondary="Spring Initializr" id="idm45310223309504"/> a set of dependencies if you’ve not built a Spring Boot application before on your target environment.
This is normal Apache Maven behavior.
These dependencies won’t be downloaded again the next time you invoke a Maven command—unless dependency versions are updated in the <em>pom.xml</em> file.</p>

<figure><div id="spring_initializr" class="figure">
<img src="Images/dtjd_0401.png" alt="dtjd 0401" width="600" height="441"/>
<h6><span class="label">Figure 4-1. </span>Spring Initializr</h6>
</div></figure>

<p>The project structure should look like this:</p>

<pre data-type="programlisting">.
├── HELP.md
├── mvnw
├── mvnw.cmd
├── pom.xml
└── src
    ├── main
    │   ├── java
    │   │   └── com
    │   │       └── example
    │   │           └── demo
    │   │               ├── DemoApplication.java
    │   │               ├── Greeting.java
    │   │               └── GreetingController.java
    │   └── resources
    │       ├── application.properties
    │       ├── static
    │       └── templates
    └── test
        └── java</pre>

<p>Our current task requires two additional sources<a data-type="indexterm" data-primary="Spring Boot" data-secondary="Greeting.java" id="idm45310223304032"/><a data-type="indexterm" data-primary="Spring Boot" data-secondary="GreetingController.java" id="idm45310223303056"/> that were not created by the Spring Initializr website: <em>Greeting.java</em> and <em>GreetingController.java</em>.
These two files can be created using your text editor or IDE of choice.
The first, <em>Greeting.java</em>, defines a data object that will be used to render content as JavaScript Object Notation (JSON), a typical format used to expose data via REST.
Additional formats are also supported, but JSON support comes out of the box without any additional dependencies required.
This file should look like this:</p>

<pre data-type="programlisting" data-code-language="java"><code class="kn">package</code> <code class="n">com</code><code class="o">.</code><code class="na">example</code><code class="o">.</code><code class="na">demo</code><code class="o">;</code>

<code class="kd">public</code> <code class="kd">class</code> <code class="nc">Greeting</code> <code class="o">{</code>
    <code class="kd">private</code> <code class="kd">final</code> <code class="n">String</code> <code class="n">content</code><code class="o">;</code>

    <code class="kd">public</code> <code class="nf">Greeting</code><code class="o">(</code><code class="n">String</code> <code class="n">content</code><code class="o">)</code> <code class="o">{</code>
        <code class="k">this</code><code class="o">.</code><code class="na">content</code> <code class="o">=</code> <code class="n">content</code><code class="o">;</code>
    <code class="o">}</code>

    <code class="kd">public</code> <code class="n">String</code> <code class="nf">getContent</code><code class="o">()</code> <code class="o">{</code>
        <code class="k">return</code> <code class="n">content</code><code class="o">;</code>
    <code class="o">}</code>
<code class="o">}</code></pre>

<p>There’s nothing special about this data holder except that it’s immutable; depending on your use case, you might want to switch to a mutable implementation, but for now this will suffice.
Next is the REST endpoint itself, defined as a <code>GET</code> call on a <em>/greeting</em> path.
Spring Boot prefers the <em>controller</em> stereotype for this kind of component, no doubt harkening back to the days when Spring MVC (yes, that’s model-view-controller) was the preferred option to create web applications.
Feel free to use a different filename, but the component annotation must remain untouched:</p>

<pre data-type="programlisting" data-code-language="java"><code class="kn">package</code> <code class="n">com</code><code class="o">.</code><code class="na">example</code><code class="o">.</code><code class="na">demo</code><code class="o">;</code>

<code class="kn">import</code> <code class="nn">org.springframework.web.bind.annotation.GetMapping</code><code class="o">;</code>
<code class="kn">import</code> <code class="nn">org.springframework.web.bind.annotation.RequestParam</code><code class="o">;</code>
<code class="kn">import</code> <code class="nn">org.springframework.web.bind.annotation.RestController</code><code class="o">;</code>

<code class="nd">@RestController</code>
<code class="kd">public</code> <code class="kd">class</code> <code class="nc">GreetingController</code> <code class="o">{</code>
    <code class="kd">private</code> <code class="kd">static</code> <code class="kd">final</code> <code class="n">String</code> <code class="n">template</code> <code class="o">=</code> <code class="s">"Hello, %s!"</code><code class="o">;</code>

    <code class="nd">@GetMapping</code><code class="o">(</code><code class="s">"/greeting"</code><code class="o">)</code>
    <code class="kd">public</code> <code class="n">Greeting</code> <code class="nf">greeting</code><code class="o">(</code><code class="nd">@RequestParam</code><code class="o">(</code><code class="n">value</code> <code class="o">=</code> <code class="s">"name"</code><code class="o">,</code>
        <code class="n">defaultValue</code> <code class="o">=</code> <code class="s">"World"</code><code class="o">)</code> <code class="n">String</code> <code class="n">name</code><code class="o">)</code> <code class="o">{</code>
        <code class="k">return</code> <code class="k">new</code> <code class="nf">Greeting</code><code class="o">(</code><code class="n">String</code><code class="o">.</code><code class="na">format</code><code class="o">(</code><code class="n">template</code><code class="o">,</code> <code class="n">name</code><code class="o">));</code>
    <code class="o">}</code>
<code class="o">}</code></pre>

<p class="pagebreak-before">The controller may take a <code>name</code> parameter as input and will use the value <code>World</code> when this parameter is not supplied.
Notice that the return type of the mapped method is a plain Java type; it’s the data type we just defined in the previous step.
Spring Boot will automatically marshal data from and to JSON based on the annotations applied to the controller and its methods, as well as sensible defaults put in place.
If we leave the code as is, the return value of the <code>greeting()</code> method will be automatically transformed into a JSON payload.
This is the power of Spring Boot’s developer experience, relying on defaults and predefined configuration that may be tweaked as needed.</p>

<p>You can run the application by <a data-type="indexterm" data-primary="Spring Boot" data-secondary="Java mode" id="idm45310220068832"/>either invoking the <code>/.mvnw spring-boot:run</code> command, which runs the application as part of the build process, or by generating the application JAR and running it manually—that is, <code>./mvnw package</code> followed by <code>java -jar target/demo-0.0.1.SNAPSHOT.jar</code>.
Either way, an embedded web server will be started listening on port 8080; the <em>/greeting</em> path will be mapped to an instance of  <em>GreetingController</em>.
All that’s left is to issue a couple of queries, such as the following:</p>

<pre data-type="programlisting">// using the default name parameter
$ curl http://localhost:8080/greeting
{"content":"Hello, World!"}

// using an explicit value for the name parameter
$ curl http://localhost:8080/greeting?name=Microservices
{"content":"Hello, Microservices!"}</pre>

<p>Take note of the output generated by the application while running.
On my local environment, it shows (on average) that the JVM takes 1.6 seconds to start up, while the application takes 600 milliseconds to initialize.
The size of the generated JAR is roughly 17 MB.
You may also want to take notes on the CPU and memory consumption of this trivial application.
For some time now, it’s been suggested<a data-type="indexterm" data-primary="Spring Boot" data-secondary="GraalVM Native Image mode" id="ch04-SBGNI"/><a data-type="indexterm" data-primary="GraalVM" data-secondary="Native Image" data-tertiary="Spring Boot framework" id="ch04-SBGNI2"/><a data-type="indexterm" data-primary="Native Image" data-secondary="GraalVM required" data-tertiary="Spring Boot framework" id="ch04-SBGNI3"/> that the use of GraalVM Native Image can reduce startup time and binary size.
Let’s see how we can make that happen with Spring Boot.</p>

<p>Remember how we selected the Spring Native feature when the project was created?
Unfortunately, by version 2.5.0 the generated project does not include all required instructions in the <em>pom.xml</em> file.
We must make a few tweaks.
To begin with, the JAR created by <code>spring-boot-maven-plugin</code> requires a classifier; otherwise, the resulting Native Image may not be properly created.
That’s because the application JAR already contains all dependencies inside a Spring Boot—specific path that’s not handled by <code>native-image-maven-plugin</code>, which we also have to configure.
The updated <em>pom.xml</em> file should look like this:</p>

<pre data-type="programlisting" data-code-language="xml" class="pagebreak-before"><code class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</code>
<code class="nt">&lt;project</code> <code class="na">xmlns=</code><code class="s">"http://maven.apache.org/POM/4.0.0"</code>
    <code class="na">xmlns:xsi=</code><code class="s">"http://www.w3.org/2001/XMLSchema-instance"</code>
    <code class="na">xsi:schemaLocation=</code><code class="s">"http://maven.apache.org/POM/4.0.0</code>
<code class="s">    https://maven.apache.org/xsd/maven-4.0.0.xsd"</code><code class="nt">&gt;</code>
    <code class="nt">&lt;modelVersion&gt;</code>4.0.0<code class="nt">&lt;/modelVersion&gt;</code>
    <code class="nt">&lt;parent&gt;</code>
        <code class="nt">&lt;groupId&gt;</code>org.springframework.boot<code class="nt">&lt;/groupId&gt;</code>
        <code class="nt">&lt;artifactId&gt;</code>spring-boot-starter-parent<code class="nt">&lt;/artifactId&gt;</code>
        <code class="nt">&lt;version&gt;</code>2.5.0<code class="nt">&lt;/version&gt;</code>
    <code class="nt">&lt;/parent&gt;</code>
    <code class="nt">&lt;groupId&gt;</code>com.example<code class="nt">&lt;/groupId&gt;</code>
    <code class="nt">&lt;artifactId&gt;</code>demo<code class="nt">&lt;/artifactId&gt;</code>
    <code class="nt">&lt;version&gt;</code>0.0.1-SNAPSHOT<code class="nt">&lt;/version&gt;</code>
    <code class="nt">&lt;name&gt;</code>demo<code class="nt">&lt;/name&gt;</code>
    <code class="nt">&lt;description&gt;</code>Demo project for Spring Boot<code class="nt">&lt;/description&gt;</code>
    <code class="nt">&lt;properties&gt;</code>
        <code class="nt">&lt;java.version&gt;</code>11<code class="nt">&lt;/java.version&gt;</code>
        <code class="nt">&lt;spring-native.version&gt;</code>0.10.0-SNAPSHOT<code class="nt">&lt;/spring-native.version&gt;</code>
    <code class="nt">&lt;/properties&gt;</code>
    <code class="nt">&lt;dependencies&gt;</code>
        <code class="nt">&lt;dependency&gt;</code>
            <code class="nt">&lt;groupId&gt;</code>org.springframework.boot<code class="nt">&lt;/groupId&gt;</code>
            <code class="nt">&lt;artifactId&gt;</code>spring-boot-starter-web<code class="nt">&lt;/artifactId&gt;</code>
        <code class="nt">&lt;/dependency&gt;</code>
        <code class="nt">&lt;dependency&gt;</code>
            <code class="nt">&lt;groupId&gt;</code>org.springframework.experimental<code class="nt">&lt;/groupId&gt;</code>
            <code class="nt">&lt;artifactId&gt;</code>spring-native<code class="nt">&lt;/artifactId&gt;</code>
            <code class="nt">&lt;version&gt;</code>${spring-native.version}<code class="nt">&lt;/version&gt;</code>
        <code class="nt">&lt;/dependency&gt;</code>
        <code class="nt">&lt;dependency&gt;</code>
            <code class="nt">&lt;groupId&gt;</code>org.springframework.boot<code class="nt">&lt;/groupId&gt;</code>
            <code class="nt">&lt;artifactId&gt;</code>spring-boot-starter-test<code class="nt">&lt;/artifactId&gt;</code>
            <code class="nt">&lt;scope&gt;</code>test<code class="nt">&lt;/scope&gt;</code>
        <code class="nt">&lt;/dependency&gt;</code>
    <code class="nt">&lt;/dependencies&gt;</code>

    <code class="nt">&lt;build&gt;</code>
        <code class="nt">&lt;plugins&gt;</code>
            <code class="nt">&lt;plugin&gt;</code>
                <code class="nt">&lt;groupId&gt;</code>org.springframework.boot<code class="nt">&lt;/groupId&gt;</code>
                <code class="nt">&lt;artifactId&gt;</code>spring-boot-maven-plugin<code class="nt">&lt;/artifactId&gt;</code>
                <code class="nt">&lt;configuration&gt;</code>
                    <code class="nt">&lt;classifier&gt;</code>exec<code class="nt">&lt;/classifier&gt;</code>
                <code class="nt">&lt;/configuration&gt;</code>
            <code class="nt">&lt;/plugin&gt;</code>
            <code class="nt">&lt;plugin&gt;</code>
                <code class="nt">&lt;groupId&gt;</code>org.springframework.experimental<code class="nt">&lt;/groupId&gt;</code>
                <code class="nt">&lt;artifactId&gt;</code>spring-aot-maven-plugin<code class="nt">&lt;/artifactId&gt;</code>
                <code class="nt">&lt;version&gt;</code>${spring-native.version}<code class="nt">&lt;/version&gt;</code>
                <code class="nt">&lt;executions&gt;</code>
                    <code class="nt">&lt;execution&gt;</code>
                        <code class="nt">&lt;id&gt;</code>test-generate<code class="nt">&lt;/id&gt;</code>
                        <code class="nt">&lt;goals&gt;</code>
                            <code class="nt">&lt;goal&gt;</code>test-generate<code class="nt">&lt;/goal&gt;</code>
                        <code class="nt">&lt;/goals&gt;</code>
                    <code class="nt">&lt;/execution&gt;</code>
                    <code class="nt">&lt;execution&gt;</code>
                        <code class="nt">&lt;id&gt;</code>generate<code class="nt">&lt;/id&gt;</code>
                        <code class="nt">&lt;goals&gt;</code>
                            <code class="nt">&lt;goal&gt;</code>generate<code class="nt">&lt;/goal&gt;</code>
                        <code class="nt">&lt;/goals&gt;</code>
                    <code class="nt">&lt;/execution&gt;</code>
                <code class="nt">&lt;/executions&gt;</code>
            <code class="nt">&lt;/plugin&gt;</code>
        <code class="nt">&lt;/plugins&gt;</code>
    <code class="nt">&lt;/build&gt;</code>
    <code class="nt">&lt;repositories&gt;</code>
        <code class="nt">&lt;repository&gt;</code>
            <code class="nt">&lt;id&gt;</code>spring-release<code class="nt">&lt;/id&gt;</code>
            <code class="nt">&lt;name&gt;</code>Spring release<code class="nt">&lt;/name&gt;</code>
            <code class="nt">&lt;url&gt;</code>https://repo.spring.io/release<code class="nt">&lt;/url&gt;</code>
        <code class="nt">&lt;/repository&gt;</code>
    <code class="nt">&lt;/repositories&gt;</code>
    <code class="nt">&lt;pluginRepositories&gt;</code>
        <code class="nt">&lt;pluginRepository&gt;</code>
            <code class="nt">&lt;id&gt;</code>spring-release<code class="nt">&lt;/id&gt;</code>
            <code class="nt">&lt;name&gt;</code>Spring release<code class="nt">&lt;/name&gt;</code>
            <code class="nt">&lt;url&gt;</code>https://repo.spring.io/release<code class="nt">&lt;/url&gt;</code>
        <code class="nt">&lt;/pluginRepository&gt;</code>
    <code class="nt">&lt;/pluginRepositories&gt;</code>

    <code class="nt">&lt;profiles&gt;</code>
        <code class="nt">&lt;profile&gt;</code>
            <code class="nt">&lt;id&gt;</code>native-image<code class="nt">&lt;/id&gt;</code>
            <code class="nt">&lt;build&gt;</code>
                <code class="nt">&lt;plugins&gt;</code>
                    <code class="nt">&lt;plugin&gt;</code>
                        <code class="nt">&lt;groupId&gt;</code>org.graalvm.nativeimage<code class="nt">&lt;/groupId&gt;</code>
                        <code class="nt">&lt;artifactId&gt;</code>native-image-maven-plugin<code class="nt">&lt;/artifactId&gt;</code>
                        <code class="nt">&lt;version&gt;</code>21.1.0<code class="nt">&lt;/version&gt;</code>
                        <code class="nt">&lt;configuration&gt;</code>
                            <code class="nt">&lt;mainClass&gt;</code>
                                com.example.demo.DemoApplication
                            <code class="nt">&lt;/mainClass&gt;</code>
                        <code class="nt">&lt;/configuration&gt;</code>
                        <code class="nt">&lt;executions&gt;</code>
                            <code class="nt">&lt;execution&gt;</code>
                                <code class="nt">&lt;goals&gt;</code>
                                    <code class="nt">&lt;goal&gt;</code>native-image<code class="nt">&lt;/goal&gt;</code>
                                <code class="nt">&lt;/goals&gt;</code>
                                <code class="nt">&lt;phase&gt;</code>package<code class="nt">&lt;/phase&gt;</code>
                            <code class="nt">&lt;/execution&gt;</code>
                        <code class="nt">&lt;/executions&gt;</code>
                    <code class="nt">&lt;/plugin&gt;</code>
                <code class="nt">&lt;/plugins&gt;</code>
            <code class="nt">&lt;/build&gt;</code>
        <code class="nt">&lt;/profile&gt;</code>
    <code class="nt">&lt;/profiles&gt;</code>
<code class="nt">&lt;/project&gt;</code></pre>

<p>One more step before we can give it a try: make sure to have a version of GraalVM installed as your current JDK.
The selected version should closely match the version of <code>native-image-maven-plugin</code> found in the <em>pom.xml</em> file.
The <code>native-image</code> executable must also be installed in your system; you can do that by invoking <code>gu install native-image</code>. The <code>gu</code> command is provided by the GraalVM installation.</p>

<p>With all settings in place, we can generate a native executable by invoking <code>./mvnw -Pnative-image package</code>.
You’ll notice a flurry of text going through the screen as new dependencies may be downloaded, and perhaps a few warnings related to missing classes—that’s normal.
The build also takes longer than usual, and here lies the trade-off of this packaging solution: we are increasing development time to speed up execution time at production.
Once the command finishes, you’ll notice a new file <em>com.example.demo.demoapplication</em> inside the <em>target</em> directory.
This is the native executable.
Go ahead and run it.</p>

<p>Did you notice how fast the startup was?
On my environment, I get on average a startup time of 0.06 seconds, while the application takes 30 milliseconds to initialize itself.
You may recall these numbers were 1.6 seconds and 600 milliseconds when running in Java mode.
That’s a serious speed boost!
Now have a look at the size of the executable; in my case, it’s around 78 MB.
Oh well, looks like some things have grown for the worse—or have they?
This executable is a single binary that provides everything needed to run the application, <a data-type="indexterm" data-primary="Spring Boot" data-secondary="Java mode" id="idm45310210462944"/>whereas the JAR we used earlier requires a Java runtime to run.
The size of a Java runtime is typically in the 200 MB range and is composed of multiple files and directories.
Of course, smaller Java runtimes may be created with <a href="https://oreil.ly/agfRB">jlink</a>, in which case that adds another step during the build process.
There’s no free lunch.</p>

<p>Let’s stop with Spring Boot for now, keeping in mind that there’s a whole lot more to it than what has been shown here.<a data-type="indexterm" data-startref="ch04-SB" id="idm45310210460656"/><a data-type="indexterm" data-startref="ch04-SB2" id="idm45310210459952"/><a data-type="indexterm" data-startref="ch04-SBGNI" id="idm45310210459280"/><a data-type="indexterm" data-startref="ch04-SBGNI2" id="idm45310210458608"/><a data-type="indexterm" data-startref="ch04-SBGNI3" id="idm45310210457936"/>
On to the next framework.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Micronaut"><div class="sect2" id="idm45310210456832">
<h2>Micronaut</h2>

<p><em>Micronaut</em> began life in 2017 as a reimagination<a data-type="indexterm" data-primary="Micronaut" id="ch04-micro"/><a data-type="indexterm" data-primary="microservices" data-secondary="frameworks" data-tertiary="Micronaut" id="ch04-micro2"/><a data-type="indexterm" data-primary="Grails framework" id="idm45310210452400"/> of the Grails framework but with a modern look.
Grails is one of the few successful<a data-type="indexterm" data-primary="Ruby on Rails (RoR) framework" id="idm45310210451600"/> “clones” of the Ruby on Rails (RoR) framework, <a data-type="indexterm" data-primary="Apache Groovy" id="idm45310210450672"/>leveraging the Groovy programming language.
Grails made quite the splash for a few years, until the rise of Spring Boot took it out of the spotlight, prompting the Grails team to find alternatives, which resulted in Micronaut.
On the surface, Micronaut provides a similar user experience to Spring Boot, as it also allows developers to compose applications based on existing components and sensible defaults.</p>

<p>One of Micronaut’s key differentiators is the use of compile-time dependency injection for assembling the application, as opposed to runtime dependency injection, which is the preferred way of assembling applications with Spring Boot so far.
This seemingly trivial change lets Micronaut exchange a bit of development time for a speed boost at runtime as the application spends less time bootstrapping itself; this can also lead to less memory consumption and less reliance on Java reflection, which historically has been slower than direct method invocations.</p>

<p>There are a handful of ways to bootstrap<a data-type="indexterm" data-primary="Micronaut" data-secondary="Micronaut Launch" id="idm45310210449008"/> a Micronaut project, but the preferred one is to browse to <a href="https://oreil.ly/QAdrG">Micronaut Launch</a> and select the settings and features you’d like to see added to the project.
The default application type defines the minimum settings to build a REST-based application such as the one we’ll go through in a few minutes.
Once satisfied with your selection, click the Generate Project button, as shown in <a data-type="xref" href="#micronaut_launch">Figure 4-2</a>, which results in a ZIP file that can be downloaded to your local development environment.</p>

<figure><div id="micronaut_launch" class="figure">
<img src="Images/dtjd_0402.png" alt="dtjd 0402" width="600" height="327"/>
<h6><span class="label">Figure 4-2. </span>Micronaut Launch</h6>
</div></figure>

<p>Similarly as we did for Spring boot, unpacking the ZIP file and running the <code>./mvnw verify</code> command at the root directory of the project ensures a sound starting point.
This command invocation will download plug-ins and dependencies as needed; the build should succeed after a few seconds if everything goes right.
The project structure should look like the following one after adding a pair of additional source files:</p>

<pre data-type="programlisting" class="pagebreak-before">.
├── README.md
├── micronaut-cli.yml
├── mvnw
├── mvnw.bat
├── pom.xml
└── src
    └── main
        ├── java
        │   └── com
        │       └── example
        │           └── demo
        │               ├── Application.java
        │               ├── Greeting.java
        │               └── GreetingController.java
        └── resources
            ├── application.yml
            └── logback.xml</pre>

<p>The <em>Application.java</em> source file defines the entry point, which we’ll leave untouched for now as there’s no need to make any updates.
Similarly, we’ll leave the <em>application.yml</em> resource file unchanged as well; this resource supplies configuration properties that don’t require changes at this point.</p>

<p>We need two additional source files: the data object<a data-type="indexterm" data-primary="Micronaut" data-secondary="Greeting.java" id="idm45310210440784"/><a data-type="indexterm" data-primary="Micronaut" data-secondary="GreetingController.java" id="idm45310210439808"/> defined by <em>Greeting.java</em>, whose responsibility is to contain a message sent back to the consumer, and the actual REST endpoint defined by <em>GreetingController.java</em>.
The controller stereotype goes all the way back to the conventions laid out by Grails, also followed by pretty much every RoR clone.
You can certainly change the filename to anything that suits your domain, though you must leave the <code>@Controller</code> annotation in place.
The source for the data object should look like this:</p>

<pre data-type="programlisting" data-code-language="java"><code class="kn">package</code> <code class="n">com</code><code class="o">.</code><code class="na">example</code><code class="o">.</code><code class="na">demo</code><code class="o">;</code>

<code class="kn">import</code> <code class="nn">io.micronaut.core.annotation.Introspected</code><code class="o">;</code>

<code class="nd">@Introspected</code>
<code class="kd">public</code> <code class="kd">class</code> <code class="nc">Greeting</code> <code class="o">{</code>
    <code class="kd">private</code> <code class="kd">final</code> <code class="n">String</code> <code class="n">content</code><code class="o">;</code>

    <code class="kd">public</code> <code class="nf">Greeting</code><code class="o">(</code><code class="n">String</code> <code class="n">content</code><code class="o">)</code> <code class="o">{</code>
        <code class="k">this</code><code class="o">.</code><code class="na">content</code> <code class="o">=</code> <code class="n">content</code><code class="o">;</code>
    <code class="o">}</code>

    <code class="kd">public</code> <code class="n">String</code> <code class="nf">getContent</code><code class="o">()</code> <code class="o">{</code>
        <code class="k">return</code> <code class="n">content</code><code class="o">;</code>
    <code class="o">}</code>
<code class="o">}</code></pre>

<p class="pagebreak-before">Once more we rely on an immutable design for this class.
Note the use of the ​<code>@Intro⁠spected</code> annotation, which signals Micronaut to inspect the type at compile time and include it as part of the dependency-injection procedure.
Usually, the annotation can be left out, as Micronaut will figure out that the class is required. But its use is paramount when it comes to generating the native executable with GraalVM Native Image; otherwise, the executable won’t be complete.
The second file should look like this:</p>

<pre data-type="programlisting" data-code-language="java"><code class="kn">package</code> <code class="n">com</code><code class="o">.</code><code class="na">example</code><code class="o">.</code><code class="na">demo</code><code class="o">;</code>

<code class="kn">import</code> <code class="nn">io.micronaut.http.annotation.Controller</code><code class="o">;</code>
<code class="kn">import</code> <code class="nn">io.micronaut.http.annotation.Get</code><code class="o">;</code>
<code class="kn">import</code> <code class="nn">io.micronaut.http.annotation.QueryValue</code><code class="o">;</code>

<code class="nd">@Controller</code><code class="o">(</code><code class="s">"/"</code><code class="o">)</code>
<code class="kd">public</code> <code class="kd">class</code> <code class="nc">GreetingController</code> <code class="o">{</code>
    <code class="kd">private</code> <code class="kd">static</code> <code class="kd">final</code> <code class="n">String</code> <code class="n">template</code> <code class="o">=</code> <code class="s">"Hello, %s!"</code><code class="o">;</code>

    <code class="nd">@Get</code><code class="o">(</code><code class="n">uri</code> <code class="o">=</code> <code class="s">"/greeting"</code><code class="o">)</code>
    <code class="kd">public</code> <code class="n">Greeting</code> <code class="nf">greeting</code><code class="o">(</code><code class="nd">@QueryValue</code><code class="o">(</code><code class="n">value</code> <code class="o">=</code> <code class="s">"name"</code><code class="o">,</code>
        <code class="n">defaultValue</code> <code class="o">=</code> <code class="s">"World"</code><code class="o">)</code> <code class="n">String</code> <code class="n">name</code><code class="o">)</code> <code class="o">{</code>
        <code class="k">return</code> <code class="k">new</code> <code class="nf">Greeting</code><code class="o">(</code><code class="n">String</code><code class="o">.</code><code class="na">format</code><code class="o">(</code><code class="n">template</code><code class="o">,</code> <code class="n">name</code><code class="o">));</code>
    <code class="o">}</code>
<code class="o">}</code></pre>

<p>We can appreciate that the controller defines a single endpoint mapped to <code>/greeting</code>, takes an optional parameter named <code>name</code>, and returns an instance of the data object.
By default, Micronaut will marshal the return value as JSON, so no extra configuration is required to make it happen.
Running the application can be done in a couple of ways.<a data-type="indexterm" data-primary="Micronaut" data-secondary="Java mode" id="idm45310210233264"/>
You can either invoke <code>./mvnw mn:run</code>, which runs the application as part of the build process, or invoke <code>./mvnw package</code>, which creates a <em>demo-0.1.jar</em> in the <em>target</em> directory that can be launched in the conventional way—that is, with <code>java -jar target/demo-0.1.jar</code>.
Invoking a couple of queries to the REST endpoint may result in output similar to this:</p>

<pre data-type="programlisting">// using the default name parameter
$ curl http://localhost:8080/greeting
{"content":"Hello, World!"}

// using an explicit value for the name parameter
$ curl http://localhost:8080/greeting?name=Microservices
{"content":"Hello, Microservices!"}</pre>

<p>Either command launches the application quite quickly.
On my local environment, the application is ready to process requests by 500 milliseconds on average, or three times the speed of Spring Boot for equivalent behavior.
The size of the JAR file is also a bit smaller, at 14 MB in total.
As impressive as these numbers may be,<a data-type="indexterm" data-primary="Micronaut" data-secondary="GraalVM Native Image mode" id="idm45310210229248"/><a data-type="indexterm" data-primary="GraalVM" data-secondary="Native Image" data-tertiary="Micronaut" id="idm45310210228304"/><a data-type="indexterm" data-primary="Native Image" data-secondary="GraalVM required" data-tertiary="Micronaut" id="idm45310210227088"/> we can get a speed boost if the application were to be transformed using GraalVM Native Image into a native executable.
Fortunately for us, the Micronaut way is friendlier with this kind of setup, resulting in everything we require already configured in the generated project.
That’s it.
No need to update the build file with additional settings—it’s all there.</p>

<p>You do require an installation of GraalVM and its <code>native-image</code> executable, though, as we did before.
Creating a native executable is as simple as invoking <code>./mvnw -Dpackaging=native-image package</code>, and after a few minutes we should get an executable named <code>demo</code> (as a matter of fact, it’s the project’s <code>artifactId</code> if you were wondering) inside the <em>target</em> directory.
Launching the application with the native executable results in a 20–millisecond startup time on average, which is a one-third gain in speed compared to Spring Boot.
The executable size is 60 MB, which correlates to the reduced size of the JAR file.</p>

<p>Let’s stop exploring Micronaut and move to the next framework: Quarkus.<a data-type="indexterm" data-startref="ch04-micro" id="idm45310210222720"/><a data-type="indexterm" data-startref="ch04-micro2" id="idm45310210221984"/></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Quarkus"><div class="sect2" id="idm45310210221056">
<h2>Quarkus</h2>

<p>Although <em>Quarkus</em> was announced in early 2019, <a data-type="indexterm" data-primary="Quarkus" id="ch04-quarkus"/><a data-type="indexterm" data-primary="microservices" data-secondary="frameworks" data-tertiary="Quarkus" id="ch04-quarkus2"/>work on it began much earlier.
Quarkus has a lot of similarities with the two candidates we’ve seen so far.
It offers great development experience based on components, convention over configuration, and productivity tools.
Even more, Quarkus decided to also use compile-time dependency injection like Micronaut, allowing it to reap the same benefits, such as smaller binaries, faster startup, and less runtime magic.
At the same time, Quarkus adds its own flavor and distinctiveness, and perhaps most important for some developers, Quarkus relies more on standards than the other two candidates.
Quarkus implements the MicroProfile specifications, which are standards that come from JakartaEE (previously known as JavaEE), and additional standards developed under the MicroProfile project umbrella.</p>

<p>You can get started with Quarkus by browsing to the<a data-type="indexterm" data-primary="Quarkus" data-secondary="Configure Your Application page" id="idm45310210216000"/> <a href="https://code.quarkus.io">Quarkus Configure Your Application page</a> to configure values and download a ZIP file.
This page is loaded with plenty of goodies, including many extensions to choose from to configure specific integrations such as databases, REST capabilities, monitoring, and more.
The RESTEasy Jackson extension must be selected, allowing Quarkus to seamlessly marshal values to and from JSON.
Clicking the “Generate your application” button should prompt you to save a ZIP file into your local system, the contents of which should look similar to this:</p>

<pre data-type="programlisting" data-code-language="java" class="pagebreak-before"><code class="o">.</code>
<code class="err">├──</code> <code class="n">README</code><code class="o">.</code><code class="na">md</code>
<code class="err">├──</code> <code class="n">mvnw</code>
<code class="err">├──</code> <code class="n">mvnw</code><code class="o">.</code><code class="na">cmd</code>
<code class="err">├──</code> <code class="n">pom</code><code class="o">.</code><code class="na">xml</code>
<code class="err">└──</code> <code class="n">src</code>
    <code class="err">├──</code> <code class="n">main</code>
    <code class="err">│</code>   <code class="err">├──</code> <code class="n">docker</code>
    <code class="err">│</code>   <code class="err">│</code>   <code class="err">├──</code> <code class="n">Dockerfile</code><code class="o">.</code><code class="na">jvm</code>
    <code class="err">│</code>   <code class="err">│</code>   <code class="err">├──</code> <code class="n">Dockerfile</code><code class="o">.</code><code class="na">legacy</code><code class="o">-</code><code class="n">jar</code>
    <code class="err">│</code>   <code class="err">│</code>   <code class="err">├──</code> <code class="n">Dockerfile</code><code class="o">.</code><code class="na">native</code>
    <code class="err">│</code>   <code class="err">│</code>   <code class="err">└──</code> <code class="n">Dockerfile</code><code class="o">.</code><code class="na">native</code><code class="o">-</code><code class="n">distroless</code>
    <code class="err">│</code>   <code class="err">├──</code> <code class="n">java</code>
    <code class="err">│</code>   <code class="err">│</code>   <code class="err">└──</code> <code class="n">com</code>
    <code class="err">│</code>   <code class="err">│</code>       <code class="err">└──</code> <code class="n">example</code>
    <code class="err">│</code>   <code class="err">│</code>           <code class="err">└──</code> <code class="n">demo</code>
    <code class="err">│</code>   <code class="err">│</code>               <code class="err">├──</code> <code class="n">Greeting</code><code class="o">.</code><code class="na">java</code>
    <code class="err">│</code>   <code class="err">│</code>               <code class="err">└──</code> <code class="n">GreetingResource</code><code class="o">.</code><code class="na">java</code>
    <code class="err">│</code>   <code class="err">└──</code> <code class="n">resources</code>
    <code class="err">│</code>       <code class="err">├──</code> <code class="n">META</code><code class="o">-</code><code class="n">INF</code>
    <code class="err">│</code>       <code class="err">│</code>   <code class="err">└──</code> <code class="n">resources</code>
    <code class="err">│</code>       <code class="err">│</code>       <code class="err">└──</code> <code class="n">index</code><code class="o">.</code><code class="na">html</code>
    <code class="err">│</code>       <code class="err">└──</code> <code class="n">application</code><code class="o">.</code><code class="na">properties</code>
    <code class="err">└──</code> <code class="n">test</code>
        <code class="err">└──</code> <code class="n">java</code></pre>

<p>We can appreciate that Quarkus adds<a data-type="indexterm" data-primary="Quarkus" data-secondary="Docker configuration files" id="idm45310210206848"/><a data-type="indexterm" data-primary="Docker" data-secondary="Quarkus framework including" id="idm45310210206000"/> Docker configuration files out of the box, as it was designed to tackle microservice architectures in the cloud via containers and Kubernetes.
But as time has passed, its range has grown wider by supporting additional application types and architectures.
The <em>GreetingResource.java</em> file<a data-type="indexterm" data-primary="Quarkus" data-secondary="GreetingResource.java" id="idm45310210124448"/> is also created by default, and it’s a typical Jakarta RESTful Web Services (JAX-RS) resource.
We’ll have to make some adjustments<a data-type="indexterm" data-primary="Quarkus" data-secondary="Greeting.java" id="idm45310210123312"/> to that resource to enable it to handle the <em>Greeting.java</em> data object.
Here’s the source for that:</p>

<pre data-type="programlisting" data-code-language="java"><code class="kn">package</code> <code class="n">com</code><code class="o">.</code><code class="na">example</code><code class="o">.</code><code class="na">demo</code><code class="o">;</code>

<code class="kd">public</code> <code class="kd">class</code> <code class="nc">Greeting</code> <code class="o">{</code>
    <code class="kd">private</code> <code class="kd">final</code> <code class="n">String</code> <code class="n">content</code><code class="o">;</code>

    <code class="kd">public</code> <code class="nf">Greeting</code><code class="o">(</code><code class="n">String</code> <code class="n">content</code><code class="o">)</code> <code class="o">{</code>
        <code class="k">this</code><code class="o">.</code><code class="na">content</code> <code class="o">=</code> <code class="n">content</code><code class="o">;</code>
    <code class="o">}</code>

    <code class="kd">public</code> <code class="n">String</code> <code class="nf">getContent</code><code class="o">()</code> <code class="o">{</code>
        <code class="k">return</code> <code class="n">content</code><code class="o">;</code>
    <code class="o">}</code>
<code class="o">}</code></pre>

<p>The code is pretty much identical to what we’ve seen before in this chapter.
There’s nothing new or surprising about this immutable data object.
Now, in the case of the JAX-RS resource, things will look similar yet different, as the behavior we seek is the same as before, though the way we instruct the framework to perform its magic is via JAX-RS annotations.
Thus the code looks like this:</p>

<pre data-type="programlisting" data-code-language="java"><code class="kn">package</code> <code class="n">com</code><code class="o">.</code><code class="na">example</code><code class="o">.</code><code class="na">demo</code><code class="o">;</code>

<code class="kn">import</code> <code class="nn">javax.ws.rs.DefaultValue</code><code class="o">;</code>
<code class="kn">import</code> <code class="nn">javax.ws.rs.GET</code><code class="o">;</code>
<code class="kn">import</code> <code class="nn">javax.ws.rs.Path</code><code class="o">;</code>
<code class="kn">import</code> <code class="nn">javax.ws.rs.QueryParam</code><code class="o">;</code>

<code class="nd">@Path</code><code class="o">(</code><code class="s">"/greeting"</code><code class="o">)</code>
<code class="kd">public</code> <code class="kd">class</code> <code class="nc">GreetingResource</code> <code class="o">{</code>
    <code class="kd">private</code> <code class="kd">static</code> <code class="kd">final</code> <code class="n">String</code> <code class="n">template</code> <code class="o">=</code> <code class="s">"Hello, %s!"</code><code class="o">;</code>

    <code class="nd">@GET</code>
    <code class="kd">public</code> <code class="n">Greeting</code> <code class="nf">greeting</code><code class="o">(</code><code class="nd">@QueryParam</code><code class="o">(</code><code class="s">"name"</code><code class="o">)</code>
        <code class="nd">@DefaultValue</code><code class="o">(</code><code class="s">"World"</code><code class="o">)</code> <code class="n">String</code> <code class="n">name</code><code class="o">)</code> <code class="o">{</code>
        <code class="k">return</code> <code class="k">new</code> <code class="nf">Greeting</code><code class="o">(</code><code class="n">String</code><code class="o">.</code><code class="na">format</code><code class="o">(</code><code class="n">template</code><code class="o">,</code> <code class="n">name</code><code class="o">));</code>
    <code class="o">}</code>
<code class="o">}</code></pre>

<p>If you’re familiar with JAX-RS, this code should be no surprise to you.
But if you’re not familiar with the JAX-RS annotations, what we do here is mark the resource with the REST path we’d like to react to; we also indicate that the <code>greeting()</code> method will handle a <code>GET</code> call, and that its <code>name</code> parameter has a default value.
Nothing more needs to be done to instruct Quarkus to marshal the return value into JSON, as that will happen by default.</p>

<p>Running the application can be done in a couple of ways as well, using the developer mode as part of the build.
This is one of the features that has a unique Quarkus flavor, as it lets you run the application and pick up any changes you made automatically without having to manually restart the application. You can activate this mode by invoking  <code>/.mvnw compile quarkus:dev</code>.
If you make any changes to the source files, you’ll notice that the build will automatically recompile and load the application.</p>

<p>You may also run the application<a data-type="indexterm" data-primary="Quarkus" data-secondary="Java mode" id="idm45310209846064"/> using the <code>java</code> interpreter as we’ve seen before, which results in a command such as <code>java -jar target/quarkus-app/quarkus-run.jar</code>.
Note that we’re using a different JAR, although the <em>demo-1.0.0-SNAPSHOT.jar</em> does exist in the <em>target</em> directory; the reason to do it this way is that Quarkus applies custom logic to speed up the boot process even in the Java mode.</p>

<p>Running the application should result in startup times with 600 milliseconds on average, which is pretty close to what Micronaut does.
Also, the size of the full application is in the 13 MB range.
Sending a couple of <code>GET</code> requests to the application without and with a <code>name</code> parameter results in output similar to the following:</p>

<pre data-type="programlisting">// using the default name parameter
$ curl http://localhost:8080/greeting
{"content":"Hello, World!"}

// using an explicit value for the name parameter
$ curl http://localhost:8080/greeting?name=Microservices
{"content":"Hello, Microservices!"}</pre>

<p>It should be no surprise that Quarkus also<a data-type="indexterm" data-primary="Quarkus" data-secondary="GraalVM Native Image mode" id="idm45310209841024"/><a data-type="indexterm" data-primary="GraalVM" data-secondary="Native Image" data-tertiary="Quarkus" id="idm45310209840080"/><a data-type="indexterm" data-primary="Native Image" data-secondary="GraalVM required" data-tertiary="Quarkus" id="idm45310209838864"/> supports generating native executables via GraalVM Native Image, given that it targets cloud environments where small binary size is recommended.
Because of this, Quarkus comes with batteries included, just like Micronaut, and generates everything you need from the get-go.
There’s no need to update the build configuration to get started with native executables.
As with the other examples, you must ensure that the current JDK points to a GraalVM distribution and that the <code>native-image</code> executable is found in your path.
Once this step has been cleared, all that’s left is to package the application as a native executable by invoking <code>./mvnw -Pnative package</code>.
This activates the <code>native</code> profile, which instructs the Quarkus build tools to generate the native executable.</p>

<p>After a couple of minutes, the build should have produced an executable named <em>demo-1.0.0-SNAPSHOT-runner</em> inside the <em>target</em> directory.
Running this executable shows that the application starts up in 15 milliseconds on average.
The size of the executable is close to 47 MB, which makes Quarkus the framework that yields the fastest startup and smallest executable size so far when compared to previous candidate frameworks.<a data-type="indexterm" data-startref="ch04-quarkus" id="idm45310209835152"/><a data-type="indexterm" data-startref="ch04-quarkus2" id="idm45310209834448"/></p>

<p>We’re done with Quarkus for the time being, leaving us with the fourth candidate framework: Helidon.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Helidon"><div class="sect2" id="idm45310210220464">
<h2>Helidon</h2>

<p>Last but not least, <em>Helidon</em> is a framework<a data-type="indexterm" data-primary="Helidon" id="ch04-helidon"/><a data-type="indexterm" data-primary="microservices" data-secondary="frameworks" data-tertiary="Helidon" id="ch04-helidon2"/><a data-type="indexterm" data-primary="Helidon" data-secondary="MP MicroProfile implementation" id="idm45310209828480"/><a data-type="indexterm" data-primary="Helidon" data-secondary="SE implementation" id="idm45310209827568"/> specifically crafted for building microservices with two flavors: SE and MP.
The MP flavor stands for <em>MicroProfile</em> and<a data-type="indexterm" data-primary="MicroProfile" data-secondary="Helidon framework MP flavor" id="idm45310209826000"/> lets you build applications by harnessing the power of standards; this flavor is a full implementation of the MicroProfile specifications.
The SE flavor, on the other hand, does not implement MicroProfile, yet delivers similar functionality using a different set of APIs.
Pick a flavor based on the APIs you’d like to interact with and your preference for standards; either way, Helidon gets the job done.</p>

<p>Given that Helidon implements MicroProfile, we can use yet another site to bootstrap a Helidon project.<a data-type="indexterm" data-primary="Helidon" data-secondary="MicroProfile Starter site" id="idm45310209824528"/><a data-type="indexterm" data-primary="MicroProfile" data-secondary="Helidon MicroProfile Starter site" id="idm45310209823584"/>
The <a href="https://oreil.ly/3U7RG">MicroProfile Starter site</a> (<a data-type="xref" href="#microprofile_starter">Figure 4-3</a>) can be used to create projects for all supported implementations of the MicroProfile specification by <span class="keep-together">versions</span>.</p>

<figure><div id="microprofile_starter" class="figure">
<img src="Images/dtjd_0403.png" alt="dtjd 0403" width="600" height="441"/>
<h6><span class="label">Figure 4-3. </span>MicroProfile Starter</h6>
</div></figure>

<p>Browse to the site, select which MP version you’re interested in, choose the MP implementation (in our case, Helidon), and perhaps customize some of the available features.
Then click the Download button to download a ZIP file containing the generated project.
The ZIP file contains a project structure similar to the following, except of course I’ve already updated the sources with the two files required to make the application work as we want it:</p>

<pre data-type="programlisting">.
├── pom.xml
├── readme.md
└── src
    └── main
        ├── java
        │   └── com
        │       └── example
        │           └── demo
        │               ├── Greeting.java
        │               └── GreetingResource.java
        └── resources
            ├── META-INF
            │   ├── beans.xml
            │   └── microprofile-config.properties
            ├── WEB
            │   └── index.html
            ├── logging.properties
            └── privateKey.pem</pre>

<p>As it happens, the source<a data-type="indexterm" data-primary="Helidon" data-secondary="Greeting.java" id="idm45310209816464"/><a data-type="indexterm" data-primary="Helidon" data-secondary="GreetingResource.java" id="idm45310209815488"/> files <em>Greeting.java</em> and <em>GreetingResource.java</em> are identical to the sources we saw in the Quarkus example.
How is that possible?
First because the code is definitely trivial, but also (and more important) because both frameworks rely on the power of standards.
As a matter of fact, <a data-type="indexterm" data-primary="Micronaut" data-secondary="Greeting.java" id="idm45310209813552"/><a data-type="indexterm" data-primary="Quarkus" data-secondary="Greeting.java" id="idm45310209812576"/><a data-type="indexterm" data-primary="Spring Boot" data-secondary="Greeting.java" id="idm45310209811632"/>the <em>Greeting.java</em> file is pretty much identical across all frameworks—except for Micronaut, which requires an additional annotation, but only if you’re interested in generating native executables; otherwise, it’s 100% identical.
If you decided to jump ahead to this section before browsing the others, here’s what the <em>Greeting.java</em> file looks like:</p>

<pre data-type="programlisting" data-code-language="java"><code class="kn">package</code> <code class="n">com</code><code class="o">.</code><code class="na">example</code><code class="o">.</code><code class="na">demo</code><code class="o">;</code>

<code class="kn">import</code> <code class="nn">io.helidon.common.Reflected</code><code class="o">;</code>

<code class="nd">@Reflected</code>
<code class="kd">public</code> <code class="kd">class</code> <code class="nc">Greeting</code> <code class="o">{</code>
    <code class="kd">private</code> <code class="kd">final</code> <code class="n">String</code> <code class="n">content</code><code class="o">;</code>

    <code class="kd">public</code> <code class="nf">Greeting</code><code class="o">(</code><code class="n">String</code> <code class="n">content</code><code class="o">)</code> <code class="o">{</code>
        <code class="k">this</code><code class="o">.</code><code class="na">content</code> <code class="o">=</code> <code class="n">content</code><code class="o">;</code>
    <code class="o">}</code>

    <code class="kd">public</code> <code class="n">String</code> <code class="nf">getContent</code><code class="o">()</code> <code class="o">{</code>
        <code class="k">return</code> <code class="n">content</code><code class="o">;</code>
    <code class="o">}</code>
<code class="o">}</code></pre>

<p>It’s just a regular immutable data object with a single accessor.
The <em>Greeting​Re⁠source.java</em> file, which defines the REST mappings needed for the application, follows:</p>

<pre data-type="programlisting" data-code-language="java"><code class="kn">package</code> <code class="n">com</code><code class="o">.</code><code class="na">example</code><code class="o">.</code><code class="na">demo</code><code class="o">;</code>

<code class="kn">import</code> <code class="nn">javax.ws.rs.DefaultValue</code><code class="o">;</code>
<code class="kn">import</code> <code class="nn">javax.ws.rs.GET</code><code class="o">;</code>
<code class="kn">import</code> <code class="nn">javax.ws.rs.Path</code><code class="o">;</code>
<code class="kn">import</code> <code class="nn">javax.ws.rs.QueryParam</code><code class="o">;</code>

<code class="nd">@Path</code><code class="o">(</code><code class="s">"/greeting"</code><code class="o">)</code>
<code class="kd">public</code> <code class="kd">class</code> <code class="nc">GreetingResource</code> <code class="o">{</code>
    <code class="kd">private</code> <code class="kd">static</code> <code class="kd">final</code> <code class="n">String</code> <code class="n">template</code> <code class="o">=</code> <code class="s">"Hello, %s!"</code><code class="o">;</code>

    <code class="nd">@GET</code>
    <code class="kd">public</code> <code class="n">Greeting</code> <code class="nf">greeting</code><code class="o">(</code><code class="nd">@QueryParam</code><code class="o">(</code><code class="s">"name"</code><code class="o">)</code>
        <code class="nd">@DefaultValue</code><code class="o">(</code><code class="s">"World"</code><code class="o">)</code> <code class="n">String</code> <code class="n">name</code><code class="o">)</code> <code class="o">{</code>
        <code class="k">return</code> <code class="k">new</code> <code class="nf">Greeting</code><code class="o">(</code><code class="n">String</code><code class="o">.</code><code class="na">format</code><code class="o">(</code><code class="n">template</code><code class="o">,</code> <code class="n">name</code><code class="o">));</code>
    <code class="o">}</code>
<code class="o">}</code></pre>

<p>We can appreciate the use of JAX-RS annotations, as we can see there’s no need for Helidon-specific APIs at this point.
The preferred way to run a<a data-type="indexterm" data-primary="Helidon" data-secondary="java interpreter" id="idm45310209736352"/> Helidon application is to package the binaries and run them with the <code>java</code> interpreter.
That is, we lose a bit of build tool integration (for now), yet we can still use the command line to perform iterative development.
Thus invoking <code>mvn package</code> followed by <code>java -jar/demo.jar</code> compiles, packages, and runs the application with an embedded web server listening on port 8080. We can send a couple of queries to it, such as this one:</p>

<pre data-type="programlisting">// using the default name parameter
$ curl http://localhost:8080/greeting
{"content":"Hello, World!"}

// using an explicit value for the name parameter
$ curl http://localhost:8080/greeting?name=Microservices
{"content":"Hello, Microservices!"}</pre>

<p>If you look at the output where the application process is running, you’ll see that the application starts with 2.3 seconds on average, which makes it the slowest candidate we have seen so far, while the binaries’ size is close to 15 MB, putting it in the middle of all measurements.
But as the adage goes, you can’t judge a book by its cover.
Helidon provides more features out of the box automatically configured, which would account for the extra startup time and the larger deployment size.</p>

<p>If startup speed and deployment size were issues, you could reconfigure the build to remove those features that may not be needed, as well as switch to native executable mode.
Fortunately, the Helidon team has<a data-type="indexterm" data-primary="Helidon" data-secondary="GraalVM Native Image mode" id="idm45310209678336"/><a data-type="indexterm" data-primary="GraalVM" data-secondary="Native Image" data-tertiary="Helidon" id="idm45310209677392"/><a data-type="indexterm" data-primary="Native Image" data-secondary="GraalVM required" data-tertiary="Helidon" id="idm45310209676176"/> embraced GraalVM Native Image as well, and every Helidon project, bootstrapped as we’ve done ourselves, comes with the required configuration to create native binaries.
There’s no need to tweak the <em>pom.xml</em> file if you follow the conventions.
Execute the <code>mvn -Pnative-image package</code> command, and you’ll find a binary executable named <em>demo</em> inside the <em>target</em> directory.
This executable weighs about 94 MB, the largest so far, while its startup time is 50 milliseconds on average, in the same range as the previous frameworks.<a data-type="indexterm" data-startref="ch04-helidon" id="idm45310209610512"/><a data-type="indexterm" data-startref="ch04-helidon2" id="idm45310209609840"/></p>

<p>Up to now, we’ve caught a glimpse of what each framework has to offer, from base features to build tool integration.
As a reminder, there are several reasons to pick one candidate framework over another.
I encourage you to write down a matrix for each relevant feature/aspect that affects your development requirements and assess each one of those items with every candidate.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Serverless"><div class="sect1" id="idm45310224013184">
<h1>Serverless</h1>

<p>This chapter began by looking at<a data-type="indexterm" data-primary="monolith applications" id="idm45310209607344"/><a data-type="indexterm" data-primary="monolithic architecture" id="idm45310209606640"/><a data-type="indexterm" data-primary="microservices" data-secondary="about" data-tertiary="monoliths versus" id="idm45310209605968"/> monolithic applications and architectures, usually pieced together by components and tiers clumped together into a single, cohesive unit.
Changes or updates to a particular piece require updating and deploying the whole.
Failure at one particular place could bring down the whole as well.
Then we moved on to microservices.
Breaking the monolith into smaller chunks that can be updated and deployed individually and independently of one another should take care of the previously mentioned issues, but microservices bring a host of other issues.</p>

<p>Before, it was enough to run the<a data-type="indexterm" data-primary="scalability" data-secondary="microservices versus monoliths" id="idm45310209604240"/> monolith inside an application server hosted on big iron, with a handful of replicas and a load balancer for good measure.
This setup has scalability issues.
With the microservices approach, we can grow or collapse the mesh of services depending on the load.
That boosts elasticity, but now we have to coordinate multiple instances and provision runtime environments, load balancers become a must, API gateways are needed, network latency rears its ugly head, and did I mention distributed tracing?
Yes, those are a lot of things to be aware of and manage.
But what if you didn’t have to?
What if someone else <a data-type="indexterm" data-primary="scalability" data-secondary="serverless approach" id="idm45310209603168"/><a data-type="indexterm" data-primary="microservices" data-secondary="serverless approach" id="idm45310209602224"/><a data-type="indexterm" data-primary="serverless approach to microservices" id="idm45310209601280"/>took care of the infrastructure, monitoring, and other “minutiae” required to run applications at scale?
This is where the serverless approach comes in: where you concentrate on the business logic at hand and let the serverless provider deal with everything else.</p>

<p>While distilling a component into<a data-type="indexterm" data-primary="microservices" data-secondary="serverless approach" data-tertiary="function as a service" id="ch04-faas"/><a data-type="indexterm" data-primary="FaaS (function as a service)" id="ch04-faas2"/><a data-type="indexterm" data-primary="serverless approach to microservices" data-secondary="function as a service" id="ch04-faas3"/> smaller pieces, one thought should come to mind: “What’s the smallest reusable piece of code I can turn this component into?” If your answer is a Java class with a handful of methods and perhaps a couple of injected collaborators/services, you’re close, but you’re not there yet.
The smallest piece of reusable code is, as a matter of fact, a single method.
Picture a microservice defined as a single class that performs the following steps:</p>
<ol>
<li>
<p>Reads the input arguments and transforms them into a consumable format as required by the next step</p>
</li>
<li>
<p>Performs the actual behavior required by the service, such as issuing a query to a database, indexing, or logging</p>
</li>
<li>
<p>Transforms the processed data into an output format</p>
</li>

</ol>

<p>Now, each of these steps may be organized in separate methods.
You may soon realize that some of these methods are reusable as is or parameterized.
A typical way to solve this would be to provide a common <em>super type</em> among microservices.
This creates a strong dependency among types, and for some use cases, that’s all right.
But for others, updates to the common code have to happen as soon as possible, in a versioned fashion, without disrupting currently running code, so I’m afraid we may need an alternative.</p>

<p>With this scenario in mind, if the common code were to be provided instead as a set of methods that can be invoked independently of one another, with their inputs and outputs composed in such a way that you establish a pipeline of data transformations, then we arrive at what are now known as <em>functions</em>. Offerings such as <em>function as a service</em> (FaaS) are a common subject among serverless providers.</p>

<p>In summary, FaaS is a fancy way to say<a data-type="indexterm" data-primary="FaaS (function as a service)" data-secondary="about" id="idm45310209590512"/> that you compose applications based on the smallest deployment unit possible and let the provider figure out all the infrastructure details for you.
In the following sections, we’ll build and deploy a simple function to the cloud.</p>








<section data-type="sect2" data-pdf-bookmark="Setting Up"><div class="sect2" id="idm45310209589216">
<h2>Setting Up</h2>

<p>Nowadays every major cloud provider has<a data-type="indexterm" data-primary="FaaS (function as a service)" data-secondary="setting up" id="ch04-faasetup"/><a data-type="indexterm" data-primary="microservices" data-secondary="serverless approach" data-tertiary="setting up FaaS" id="ch04-faasetup2"/><a data-type="indexterm" data-primary="Amazon Web Services (AWS)" data-secondary="FaaS setup example" id="ch04-faasetup3"/><a data-type="indexterm" data-primary="Quarkus" data-secondary="FaaS setup example" id="ch04-faasetup4"/><a data-type="indexterm" data-primary="tutorials" data-secondary="function as a service setup" id="ch04-faasetup5"/><a data-type="indexterm" data-primary="AWS Lambda" data-secondary="FaaS setup example" id="ch04-faasetup6"/><a data-type="indexterm" data-primary="microservices" data-secondary="frameworks" data-tertiary="Quarkus" id="ch04-faasetup7"/><a data-type="indexterm" data-primary="serverless approach to microservices" data-secondary="setting up FaaS" id="ch04-faasetup8"/><a data-type="indexterm" data-primary="function as a service" data-see="FaaS" id="idm45310209576672"/> an FaaS offering at your disposal, with add-ons that hook into other tools for monitoring, logging, disaster recovery, and more; just pick the one that meets your needs.
For the sake of this chapter, we’ll pick AWS Lambda, which was, after all, the originator of the FaaS idea.
We’ll also pick Quarkus as the implementation framework, as it’s the one that currently provides the smallest deployment size.
Be aware that the configuration shown here may need some tweaks or might be totally outdated; always review the latest versions of the tools required to build and run the code.
We’ll use Quarkus 1.13.7 for now.</p>

<p>Setting up a function with Quarkus and AWS Lambda requires having<a data-type="indexterm" data-primary="Amazon Web Services (AWS)" data-secondary="FaaS setup example" data-tertiary="AWS account" id="idm45310209575120"/><a data-type="indexterm" data-primary="AWS Lambda" data-secondary="FaaS setup example" data-tertiary="AWS account" id="idm45310209573904"/><a data-type="indexterm" data-primary="Amazon Web Services (AWS)" data-secondary="FaaS setup example" data-tertiary="AWS CLI" id="idm45310209572688"/><a data-type="indexterm" data-primary="AWS Lambda" data-secondary="FaaS setup example" data-tertiary="AWS CLI" id="idm45310209571504"/><a data-type="indexterm" data-primary="AWS CLI for FaaS setup" id="idm45310209570288"/><a data-type="indexterm" data-primary="AWS Lambda" data-secondary="FaaS setup example" data-tertiary="AWS SAM CLI" id="idm45310209569616"/><a data-type="indexterm" data-primary="Amazon Web Services (AWS)" data-secondary="FaaS setup example" data-tertiary="AWS SAM CLI" id="idm45310209568400"/><a data-type="indexterm" data-primary="AWS SAM CLI for FaaS setup" id="idm45310209567168"/><a data-type="indexterm" data-primary="testing" data-secondary="AWS SAM CLI for FaaS setup" id="idm45310209566480"/> an <a href="https://aws.amazon.com">AWS account</a>, the <a href="https://oreil.ly/0dYrb">AWS CLI</a> installed on your system, and the <a href="https://oreil.ly/h7gdD">AWS Serverless Application Model (SAM) CLI</a> if you’d like to run local tests.</p>

<p>Once you have that covered, the next step is to bootstrap the project, for which we would be inclined to use <a href="https://code.quarkus.io">Quarkus</a> as before except that a function project requires a different setup.<a data-type="indexterm" data-primary="Maven (Apache)" data-secondary="archetype for FaaS setup" id="idm45310209562112"/><a data-type="indexterm" data-primary="Apache Maven" data-secondary="archetype for FaaS setup" id="idm45310209561120"/>
So it’s better to switch to using a Maven archetype:</p>

<pre data-type="programlisting">mvn archetype:generate \
    -DarchetypeGroupId=io.quarkus \
    -DarchetypeArtifactId=quarkus-amazon-lambda-archetype \
    -DarchetypeVersion=1.13.7.Final</pre>

<p>Invoking this command in interactive mode will ask you a few questions, such as the group, artifact, version (GAV) coordinates for the project, and the base package.
For this demo, let’s go with these:</p>

<ul>
<li>
<p><code>groupId</code>: com.example.demo</p>
</li>
<li>
<p><code>artifactId</code>: demo</p>
</li>
<li>
<p><code>version</code>: 1.0-SNAPSHOT (the default)</p>
</li>
<li>
<p><code>package</code>: com.example.demo (same as <code>groupId</code>)</p>
</li>
</ul>

<p>This results in a project structure suitable to build, test, and deploy a Quarkus project as a function deployable to AWS Lambda.
The archetype creates build files for both Maven and Gradle, but we don’t need the latter for now; it also creates three function classes, but we need only one.
Our aim is to have a file structure similar to this one:</p>

<pre data-type="programlisting" class="pagebreak-before">.
├── payload.json
├── pom.xml
└── src
    ├── main
    │   ├── java
    │   │   └── com
    │   │       └── example
    │   │           └── demo
    │   │               ├── GreetingLambda.java
    │   │               ├── InputObject.java
    │   │               ├── OutputObject.java
    │   │               └── ProcessingService.java
    │   └── resources
    │       └── application.properties
    └── test
        ├── java
        │   └── com
        │       └── example
        │           └── demo
        │               └── LambdaHandlerTest.java
        └── resources
            └── application.properties</pre>

<p>The gist of the function is to capture inputs with the <code>InputObject</code> type, process them with the <code>ProcessingService</code> type, and then transform the results into another type (<code>OutputObject</code>).
The <code>GreetingLambda</code> type puts everything together.
Let’s have a look at both input and output types first—after all, they are simple types that are concerned with only containing data, with no logic whatsoever:</p>

<pre data-type="programlisting" data-code-language="java"><code class="kn">package</code> <code class="n">com</code><code class="o">.</code><code class="na">example</code><code class="o">.</code><code class="na">demo</code><code class="o">;</code>

<code class="kd">public</code> <code class="kd">class</code> <code class="nc">InputObject</code> <code class="o">{</code>
    <code class="kd">private</code> <code class="n">String</code> <code class="n">name</code><code class="o">;</code>
    <code class="kd">private</code> <code class="n">String</code> <code class="n">greeting</code><code class="o">;</code>

    <code class="kd">public</code> <code class="n">String</code> <code class="nf">getName</code><code class="o">()</code> <code class="o">{</code>
        <code class="k">return</code> <code class="n">name</code><code class="o">;</code>
    <code class="o">}</code>

    <code class="kd">public</code> <code class="kt">void</code> <code class="nf">setName</code><code class="o">(</code><code class="n">String</code> <code class="n">name</code><code class="o">)</code> <code class="o">{</code>
        <code class="k">this</code><code class="o">.</code><code class="na">name</code> <code class="o">=</code> <code class="n">name</code><code class="o">;</code>
    <code class="o">}</code>

    <code class="kd">public</code> <code class="n">String</code> <code class="nf">getGreeting</code><code class="o">()</code> <code class="o">{</code>
        <code class="k">return</code> <code class="n">greeting</code><code class="o">;</code>
    <code class="o">}</code>

    <code class="kd">public</code> <code class="kt">void</code> <code class="nf">setGreeting</code><code class="o">(</code><code class="n">String</code> <code class="n">greeting</code><code class="o">)</code> <code class="o">{</code>
        <code class="k">this</code><code class="o">.</code><code class="na">greeting</code> <code class="o">=</code> <code class="n">greeting</code><code class="o">;</code>
    <code class="o">}</code>
<code class="o">}</code></pre>

<p>The lambda expects two input values: a greeting and a name.
We’ll see how they get transformed by the processing service in a moment:</p>

<pre data-type="programlisting" data-code-language="java"><code class="kn">package</code> <code class="n">com</code><code class="o">.</code><code class="na">example</code><code class="o">.</code><code class="na">demo</code><code class="o">;</code>

<code class="kd">public</code> <code class="kd">class</code> <code class="nc">OutputObject</code> <code class="o">{</code>
    <code class="kd">private</code> <code class="n">String</code> <code class="n">result</code><code class="o">;</code>
    <code class="kd">private</code> <code class="n">String</code> <code class="n">requestId</code><code class="o">;</code>

    <code class="kd">public</code> <code class="n">String</code> <code class="nf">getResult</code><code class="o">()</code> <code class="o">{</code>
        <code class="k">return</code> <code class="n">result</code><code class="o">;</code>
    <code class="o">}</code>

    <code class="kd">public</code> <code class="kt">void</code> <code class="nf">setResult</code><code class="o">(</code><code class="n">String</code> <code class="n">result</code><code class="o">)</code> <code class="o">{</code>
        <code class="k">this</code><code class="o">.</code><code class="na">result</code> <code class="o">=</code> <code class="n">result</code><code class="o">;</code>
    <code class="o">}</code>

    <code class="kd">public</code> <code class="n">String</code> <code class="nf">getRequestId</code><code class="o">()</code> <code class="o">{</code>
        <code class="k">return</code> <code class="n">requestId</code><code class="o">;</code>
    <code class="o">}</code>

    <code class="kd">public</code> <code class="kt">void</code> <code class="nf">setRequestId</code><code class="o">(</code><code class="n">String</code> <code class="n">requestId</code><code class="o">)</code> <code class="o">{</code>
        <code class="k">this</code><code class="o">.</code><code class="na">requestId</code> <code class="o">=</code> <code class="n">requestId</code><code class="o">;</code>
    <code class="o">}</code>
<code class="o">}</code></pre>

<p>The output object holds the transformed data and a reference to the requestID.
We’ll use this field to show how we can get data from the running context.</p>

<p>All right, the processing service is next; this class is responsible for transforming the inputs into outputs.
In our case, it concatenates both input values into a single string, as shown here:</p>

<pre data-type="programlisting" data-code-language="java"><code class="kn">package</code> <code class="n">com</code><code class="o">.</code><code class="na">example</code><code class="o">.</code><code class="na">demo</code><code class="o">;</code>

<code class="kn">import</code> <code class="nn">javax.enterprise.context.ApplicationScoped</code><code class="o">;</code>

<code class="nd">@ApplicationScoped</code>
<code class="kd">public</code> <code class="kd">class</code> <code class="nc">ProcessingService</code> <code class="o">{</code>
    <code class="kd">public</code> <code class="n">OutputObject</code> <code class="nf">process</code><code class="o">(</code><code class="n">InputObject</code> <code class="n">input</code><code class="o">)</code> <code class="o">{</code>
        <code class="n">OutputObject</code> <code class="n">output</code> <code class="o">=</code> <code class="k">new</code> <code class="n">OutputObject</code><code class="o">();</code>
        <code class="n">output</code><code class="o">.</code><code class="na">setResult</code><code class="o">(</code><code class="n">input</code><code class="o">.</code><code class="na">getGreeting</code><code class="o">()</code> <code class="o">+</code> <code class="s">" "</code> <code class="o">+</code> <code class="n">input</code><code class="o">.</code><code class="na">getName</code><code class="o">());</code>
        <code class="k">return</code> <code class="n">output</code><code class="o">;</code>
    <code class="o">}</code>
<code class="o">}</code></pre>

<p>What’s left is to have a look at <code>GreetingLambda</code>, the type used to assemble the function itself.
This class requires implementing a known interface supplied by Quarkus, whose dependency should be already configured in the <em>pom.xml</em> file created with the archetype.
This interface is parameterized with input and output types.
Luckily, we have those already.
Every lambda must have a unique name and may access its running context, as shown next:</p>

<pre data-type="programlisting" data-code-language="java"><code class="kn">package</code> <code class="n">com</code><code class="o">.</code><code class="na">example</code><code class="o">.</code><code class="na">demo</code><code class="o">;</code>

<code class="kn">import</code> <code class="nn">com.amazonaws.services.lambda.runtime.Context</code><code class="o">;</code>
<code class="kn">import</code> <code class="nn">com.amazonaws.services.lambda.runtime.RequestHandler</code><code class="o">;</code>

<code class="kn">import</code> <code class="nn">javax.inject.Inject</code><code class="o">;</code>
<code class="kn">import</code> <code class="nn">javax.inject.Named</code><code class="o">;</code>

<code class="nd">@Named</code><code class="o">(</code><code class="s">"greeting"</code><code class="o">)</code>
<code class="kd">public</code> <code class="kd">class</code> <code class="nc">GreetingLambda</code>
    <code class="kd">implements</code> <code class="n">RequestHandler</code><code class="o">&lt;</code><code class="n">InputObject</code><code class="o">,</code> <code class="n">OutputObject</code><code class="o">&gt;</code> <code class="o">{</code>
    <code class="nd">@Inject</code>
    <code class="n">ProcessingService</code> <code class="n">service</code><code class="o">;</code>

    <code class="nd">@Override</code>
    <code class="kd">public</code> <code class="n">OutputObject</code> <code class="nf">handleRequest</code><code class="o">(</code><code class="n">InputObject</code> <code class="n">input</code><code class="o">,</code> <code class="n">Context</code> <code class="n">context</code><code class="o">)</code> <code class="o">{</code>
        <code class="n">OutputObject</code> <code class="n">output</code> <code class="o">=</code> <code class="n">service</code><code class="o">.</code><code class="na">process</code><code class="o">(</code><code class="n">input</code><code class="o">);</code>
        <code class="n">output</code><code class="o">.</code><code class="na">setRequestId</code><code class="o">(</code><code class="n">context</code><code class="o">.</code><code class="na">getAwsRequestId</code><code class="o">());</code>
        <code class="k">return</code> <code class="n">output</code><code class="o">;</code>
    <code class="o">}</code>
<code class="o">}</code></pre>

<p>All the pieces fall into place.
The lambda defines input and output types and invokes the data processiong service.
For the purpose of demonstration, this example shows the use of dependency injection, but you could reduce the code by moving the behavior of <code>ProcessingService</code> into <code>GreetingLambda</code>.
We can quickly verify the code by running local tests with <code>mvn test</code>, or if you prefer <code>mvn verify</code>, as that will also package the function.</p>

<p>Note that additional files are placed in the <em>target</em> directory when the function is packaged, specifically a script named <em>manage.sh</em>, which relies on the AWS CLI tool to create, update, and delete the function at the target destination associated with your AWS account.
Additional files are required to support these operations:</p>
<dl>
<dt>function.zip</dt>
<dd>
<p>The deployment file containing the binary bits</p>
</dd>
<dt>sam.jvm.yaml</dt>
<dd>
<p>Local test with AWS SAM CLI (Java mode)</p>
</dd>
<dt>sam.native.yaml</dt>
<dd>
<p>Local test with AWS SAM CLI (native mode)</p>
</dd>
</dl>

<p>The next step requires you to have<a data-type="indexterm" data-primary="FaaS (function as a service)" data-secondary="setting up" data-tertiary="execution role" id="idm45310209179360"/><a data-type="indexterm" data-primary="AWS Lambda" data-secondary="Developer Guide link" id="idm45310209106704"/><a data-type="indexterm" data-primary="resources for learning" data-secondary="AWS Lambda Developer Guide" id="idm45310209105856"/><a data-type="indexterm" data-primary="AWS CLI for FaaS setup" data-secondary="AWS Lambda Developer Guide" id="idm45310209105008"/><a data-type="indexterm" data-primary="Amazon Web Services (AWS)" data-secondary="FaaS setup example" data-tertiary="AWS Lambda Developer Guide" id="idm45310209104128"/> an <em>execution role</em> configured, for which it’s best to refer to the <a href="https://oreil.ly/97ACL">AWS Lambda Developer Guide</a> in case the procedure has been updated.
The guide shows you how to get the AWS CLI configured (if you have not done so already) and create an execution role that must be added as an environment variable to your running shell.
For example:</p>

<pre data-type="programlisting">LAMBDA_ROLE_ARN="arn:aws:iam::1234567890:role/lambda-ex"</pre>

<p>In this case, <code>1234567890</code> stands for your AWS account ID, and <code>lambda-ex</code> is the name of the role of your choosing.
We can proceed with executing the function, for which we have two modes (Java, native) and two execution environments (local, production); let’s tackle the Java mode first for both environments and then follow it up with native mode.</p>

<p>Running the function on a local environment requires the use of a Docker daemon, which by now should be commonplace in a developer’s toolbox; we also require using the AWS SAM CLI to drive the execution.
Remember the set of additional files found inside the <em>target</em> directory?
We’ll use the <em>sam.jvm.yaml</em> file alongside another file that was created by the archetype when the project was bootstrapped, called <em>payload.json</em>.
Located at the root of the directory, its contents should look like this:</p>

<pre data-type="programlisting" data-code-language="json"><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="nt">"name"</code><code class="p">:</code><code class="w"> </code><code class="s2">"Bill"</code><code class="p">,</code><code class="w"/>
<code class="w">  </code><code class="nt">"greeting"</code><code class="p">:</code><code class="w"> </code><code class="s2">"hello"</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>This file defines values for the inputs accepted by the function.
Given that the function is already packaged, we just have to invoke it, like so:</p>

<pre data-type="programlisting">$ sam local invoke --template target/sam.jvm.yaml --event payload.json
Invoking io.quarkus.amazon.lambda.runtime.QuarkusStreamHandler::handleRequest
(java11)
Decompressing /work/demo/target/function.zip
Skip pulling image and use local one:
amazon/aws-sam-cli-emulation-image-java11:rapid-1.24.1.

Mounting /private/var/folders/p_/3h19jd792gq0zr1ckqn9jb0m0000gn/T/tmppesjj0c8 as
/var/task:ro,delegated inside runtime container
START RequestId: 0b8cf3de-6d0a-4e72-bf36-232af46145fa Version: $LATEST
__  ____  __  _____   ___  __ ____  ______
 --/ __ \/ / / / _ | / _ \/ //_/ / / / __/
 -/ /_/ / /_/ / __ |/ , _/ ,&lt; / /_/ /\ \
--\___\_\____/_/ |_/_/|_/_/|_|\____/___/
[io.quarkus] (main) quarkus-lambda 1.0-SNAPSHOT on
JVM (powered by Quarkus 1.13.7.Final) started in 2.680s.
[io.quarkus] (main) Profile prod activated.
[io.quarkus] (main) Installed features: [amazon-lambda, cdi]
END RequestId: 0b8cf3de-6d0a-4e72-bf36-232af46145fa
REPORT RequestId: 0b8cf3de-6d0a-4e72-bf36-232af46145fa	Init Duration: 1.79 ms
Duration: 3262.01 ms Billed Duration: 3300 ms
Memory Size: 256 MB	Max Memory Used: 256 MB
{"result":"hello Bill","requestId":"0b8cf3de-6d0a-4e72-bf36-232af46145fa"}</pre>

<p>The command will pull a Docker image suitable for running the function.<a data-type="indexterm" data-primary="FaaS (function as a service)" data-secondary="setting up" data-tertiary="billing information" id="idm45310209080800"/><a data-type="indexterm" data-primary="microservices" data-secondary="serverless approach" data-tertiary="billing information for FaaS" id="idm45310209093616"/><a data-type="indexterm" data-primary="serverless approach to microservices" data-secondary="billing information for FaaS" id="idm45310209092432"/>
Take note of the reported values, which may differ depending on your setup.
On my local environment, this function would cost me 3.3 seconds, and 256 MB for its execution.
This can give you an idea of how much you’ll be billed when running your system as a set of functions.
However, local is not the same as production, so let’s deploy the function to the real deal.
We’ll use the <em>manage.sh</em> script to accomplish this feat, by invoking the following commands:</p>

<pre data-type="programlisting">$ sh target/manage.sh create
$ sh target/manage.sh invoke
Invoking function
++ aws lambda invoke response.txt --cli-binary-format raw-in-base64-out
++ --function-name QuarkusLambda --payload file://payload.json
++ --log-type Tail --query LogResult
++ --output text base64 --decode
START RequestId: df8d19ad-1e94-4bce-a54c-93b8c09361c7 Version: $LATEST
END RequestId: df8d19ad-1e94-4bce-a54c-93b8c09361c7
REPORT RequestId: df8d19ad-1e94-4bce-a54c-93b8c09361c7	Duration: 273.47 ms
Billed Duration: 274 ms	Memory Size: 256 MB
Max Memory Used: 123 MB	Init Duration: 1635.69 ms
{"result":"hello Bill","requestId":"df8d19ad-1e94-4bce-a54c-93b8c09361c7"}</pre>

<p>As you can see, the billed duration and memory usage decreased, which is good for our wallet, although the init duration went up to 1.6, which would delay the response, increasing the total execution time across the system.
Let’s see how these numbers change when we switch from Java mode to native mode.
As you may recall, Quarkus lets you package projects as native executables out of the box, <a data-type="indexterm" data-primary="AWS Lambda" data-secondary="Linux executables" id="idm45310209075152"/><a data-type="indexterm" data-primary="Amazon Web Services (AWS)" data-secondary="FaaS setup example" data-tertiary="Linux executables" id="idm45310209074176"/>but remember that Lambda requires Linux executables, so if you happen to be running on a non-Linux environment, you’ll need to tweak the packaging command.
Here’s what needs to be done:</p>

<pre data-type="programlisting"># for linux
$ mvn -Pnative package

# for non-linux
$ mvn package -Pnative -Dquarkus.native.container-build=true \
 -Dquarkus.native.container-runtime=docker</pre>

<p>The second command invokes the build inside a Docker container and places the generated executable on your system at the expected location, whereas the first command executes the build as is.
With the native executable now in place, we can execute the new function both in local and production environments.
Let’s see the local environment first:</p>

<pre data-type="programlisting">$ sam local invoke --template target/sam.native.yaml --event payload.json
Invoking not.used.in.provided.runtime (provided)
Decompressing /work/demo/target/function.zip
Skip pulling image and use local one:
amazon/aws-sam-cli-emulation-image-provided:rapid-1.24.1.

Mounting /private/var/folders/p_/3h19jd792gq0zr1ckqn9jb0m0000gn/T/tmp1zgzkuhy as
/var/task:ro,delegated inside runtime container
START RequestId: 27531d6c-461b-45e6-92d3-644db6ec8df4 Version: $LATEST
__  ____  __  _____   ___  __ ____  ______
 --/ __ \/ / / / _ | / _ \/ //_/ / / / __/
 -/ /_/ / /_/ / __ |/ , _/ ,&lt; / /_/ /\ \
--\___\_\____/_/ |_/_/|_/_/|_|\____/___/
[io.quarkus] (main) quarkus-lambda 1.0-SNAPSHOT native
(powered by Quarkus 1.13.7.Final) started in 0.115s.
[io.quarkus] (main) Profile prod activated.
[io.quarkus] (main) Installed features: [amazon-lambda, cdi]
END RequestId: 27531d6c-461b-45e6-92d3-644db6ec8df4
REPORT RequestId: 27531d6c-461b-45e6-92d3-644db6ec8df4	Init Duration: 0.13 ms
Duration: 218.76 ms	Billed Duration: 300 ms Memory Size: 128 MB
Max Memory Used: 128 MB
{"result":"hello Bill","requestId":"27531d6c-461b-45e6-92d3-644db6ec8df4"}</pre>

<p>The billed duration decreased by one order of magnitude, going from 3300 ms to just 300 ms, and the used memory was halved; this looks promising compared to its Java counterpart.
Will we get better numbers when running on production?
Let’s look:</p>

<pre data-type="programlisting">$ sh target/manage.sh native create
$ sh target/manage.sh native invoke
Invoking function
++ aws lambda invoke response.txt --cli-binary-format raw-in-base64-out
++ --function-name QuarkusLambdaNative
++ --payload file://payload.json --log-type Tail --query LogResult --output text
++ base64 --decode
START RequestId: 19575cd3-3220-405b-afa0-76aa52e7a8b5 Version: $LATEST
END RequestId: 19575cd3-3220-405b-afa0-76aa52e7a8b5
REPORT RequestId: 19575cd3-3220-405b-afa0-76aa52e7a8b5	Duration: 2.55 ms
Billed Duration: 187 ms Memory Size: 256 MB	Max Memory Used: 54 MB
Init Duration: 183.91 ms
{"result":"hello Bill","requestId":"19575cd3-3220-405b-afa0-76aa52e7a8b5"}</pre>

<p>The total billed duration results in 30% speedup, and the memory usage is less than half of that before; but the real winner is the initialization time, which takes roughly 10% of the previous time.
Running your function in native mode results in faster startup and better numbers across the board.</p>

<p>Now it’s up to you to decide the combination of options that will give you the best results.
Sometimes staying in Java mode is good enough even for production, or going native all the way may give you the edge.
Whichever way it may be, measurements are key—don’t guess!<a data-type="indexterm" data-startref="ch04-faas" id="idm45310209067664"/><a data-type="indexterm" data-startref="ch04-faas2" id="idm45310209066960"/><a data-type="indexterm" data-startref="ch04-faas3" id="idm45310209066288"/><a data-type="indexterm" data-startref="ch04-faasetup" id="idm45310209065616"/><a data-type="indexterm" data-startref="ch04-faasetup2" id="idm45310209064944"/><a data-type="indexterm" data-startref="ch04-faasetup3" id="idm45310209064272"/><a data-type="indexterm" data-startref="ch04-faasetup4" id="idm45310209063600"/><a data-type="indexterm" data-startref="ch04-faasetup5" id="idm45310209062928"/><a data-type="indexterm" data-startref="ch04-faasetup6" id="idm45310209062256"/><a data-type="indexterm" data-startref="ch04-faasetup7" id="idm45310209061584"/><a data-type="indexterm" data-startref="ch04-faasetup8" id="idm45310209060912"/></p>
</div></section>





</div></section>













<section data-type="sect1" class="less_space pagebreak-before" data-pdf-bookmark="Summary"><div class="sect1" id="idm45310209060112">
<h1>Summary</h1>

<p>We covered a lot of ground in this chapter, starting with a traditional monolith, breaking it into smaller parts with reusable components that can be deployed independently, known as microservices, and going all the way to the smallest deployment unit possible: a function.
Trade-offs occur along the way, as microservice architectures are inherently more complex, composed as they are of more moving parts.
Network latency becomes a real issue and must be tackled accordingly.
Other aspects such as data transactions become more complex as their span may cross service boundaries, depending on the case.
The use of Java and native executable mode <a data-type="indexterm" data-primary="microservices" data-secondary="frameworks" data-tertiary="Java versus GraalVM Native Image" id="idm45310209033184"/><a data-type="indexterm" data-primary="GraalVM" data-secondary="Native Image" data-tertiary="Java mode versus" id="idm45310209032096"/><a data-type="indexterm" data-primary="Native Image" data-secondary="GraalVM required" data-tertiary="Java mode versus" id="idm45310209031008"/>yields different results and requires to be customized setup, each with its own pros and cons.
My recommendation, dear reader, is to evaluate, measure, and then select a combination; keep tabs on numbers and service level agreements (SLAs), because you may need to reevaluate decisions along the road and make adjustments.</p>

<p><a data-type="xref" href="#Java_and_native_image_modes">Table 4-1</a> summarizes the measurements obtained by running the sample application on both Java and native image modes, on my local environment and remote, for each one of the candidate frameworks.
The size columns show the deployment unit size, while the time columns depict the time from startup up to the first request.</p>
<table id="Java_and_native_image_modes" style="width: 100%">
<caption><span class="label">Table 4-1. </span>Measurement summary</caption>
<thead>
<tr>
<th>Framework</th>
<th>Java - size</th>
<th>Java - time</th>
<th>Native - size</th>
<th>Native - time</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Spring Boot</p></td>
<td><p>17 MB</p></td>
<td><p>2200 ms</p></td>
<td><p>78 MB</p></td>
<td><p>90 ms</p></td>
</tr>
<tr>
<td><p>Micronaut</p></td>
<td><p>14 MB</p></td>
<td><p>500 ms</p></td>
<td><p>60 MB</p></td>
<td><p>20 ms</p></td>
</tr>
<tr>
<td><p>Quarkus</p></td>
<td><p>13 MB</p></td>
<td><p>600 ms</p></td>
<td><p>47 MB</p></td>
<td><p>13 ms</p></td>
</tr>
<tr>
<td><p>Helidon</p></td>
<td><p>15 MB</p></td>
<td><p>2300 ms</p></td>
<td><p>94 MB</p></td>
<td><p>50 ms</p></td>
</tr>
</tbody>
</table>

<p>As a reminder, you are encouraged to take your own measurements.
Changes to the hosting environment, JVM version and settings, framework version, network conditions, and other environment characteristics will yield different results.
The numbers shown should be taken with a grain of salt, never as authoritative values.</p>
</div></section>







</div></section></div></body></html>