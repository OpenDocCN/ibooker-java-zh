- en: Chapter 8\. Static Methods to Top-Level Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章。从静态方法到顶级函数
- en: Standalone functions are one of the fundamental building blocks of software.
    They have to be declared as methods on a class in Java, but in Kotlin we can declare
    them as top-level entities. When should we prefer top-level functions, and how
    do we refactor our way there from Java?
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 独立函数是软件的基本构建块之一。在 Java 中，它们必须声明为类的方法，但在 Kotlin 中，我们可以将它们声明为顶级实体。我们何时应该优先使用顶级函数，以及如何从
    Java 重构到那里呢？
- en: Java Statics
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 的静态
- en: 'All values and functions in a Java program have to belong to a class: they
    are *members* of that class. Java calls member-values *fields*, and member-functions
    *methods*. By default, fields values are per-instance of the class: different
    instances have different values. Methods are also per-instance in that they have
    access to the state of the instance that they are invoked on. If we mark fields
    as `static`, though, they are shared between all instances of the class. Static
    methods only have access to this shared state (and visible static fields in other
    classes), but in return for this restriction, we can invoke them without needing
    an instance of the class.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Java 程序中的所有值和函数都必须属于一个类：它们是该类的 *成员*。Java 将成员值称为 *字段*，成员函数称为 *方法*。默认情况下，字段值是每个类的实例独有的：不同的实例具有不同的值。方法也是每个实例的，因为它们可以访问调用它们的实例的状态。但是，如果我们将字段标记为
    `static`，它们将在类的所有实例之间共享。静态方法只能访问这个共享状态（以及其他类中可见的静态字段），但作为对此限制的回报，我们可以在不需要类的实例的情况下调用它们。
- en: To simplify Java, the language designers tied all code and data to classes.
    We have class-scoped static state, so we need class-scoped static methods. They
    could have added freestanding data and functions, but static fields and methods
    will do. If the language had options, then developers would have to choose between
    them, and less choice is often better. The designers then carried this language
    design decision forward to the Java Virtual Machine, which in turn has no way
    to express top-level code or data.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化 Java，语言设计者将所有代码和数据都与类绑定在一起。我们有类范围的静态状态，所以我们需要类范围的静态方法。他们本可以添加独立的数据和函数，但是静态字段和方法足够了。如果语言有选项，开发人员就必须在它们之间进行选择，而较少的选择通常更好。然后，设计者将这种语言设计决策延续到了
    Java 虚拟机，而 Java 虚拟机又没有办法表达顶级代码或数据。
- en: 'Sometimes we have a class with both nonstatic and static methods acting on
    the same type—for example, the email class with a static parsing method we saw
    in [Chapter 3](ch03.html#java-to-kotlin-classes). Often, though, we end up with
    a class composed of only static methods. When there is no static state for them
    to share, these methods are really just stand-alone functions grouped together
    and called via their class name, like the methods from the `java.util.Collections`
    class, for example:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们有一个类，其中既有非静态方法又有静态方法作用于相同的类型——例如，在[第 3 章](ch03.html#java-to-kotlin-classes)中看到的具有静态解析方法的电子邮件类。然而，通常情况下，我们最终得到的是一个只包含静态方法的类。当没有静态状态可供它们共享时，这些方法实际上只是一组独立的函数，通过它们的类名组合在一起并调用，就像
    `java.util.Collections` 类的方法一样：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Amazingly, the industry didn’t really notice how much of a pain that `Collections.`
    prefix was for a while. This was because we wrote our programs by adding more
    and more methods to types that we owned, so we rarely needed static functions.
    Static functions are useful when we want to add functionality *without* adding
    a method to the type that they act on. This might be because our classes are already
    sagging under the weight of all the methods that we have already added to them,
    or because we don’t own the class and so can’t add the method to it. Another reason
    for using static functions rather than methods is because the functionality only
    applies to some instantiations of a generic type, so it cannot be declared as
    a member of the generic. That `Collections.max`, for example, only applies to
    a collection with comparable elements.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，行业并没有真正注意到 `Collections.` 前缀有多么烦人一段时间。这是因为我们通过向我们拥有的类型添加越来越多的方法来编写我们的程序，所以我们很少需要静态函数。当我们想要添加功能而不是向类型添加方法时，静态函数是有用的。这可能是因为我们的类已经承受了我们已经添加到它们的所有方法的重量，或者因为我们不拥有该类，因此无法将方法添加到其中。使用静态函数而不是方法的另一个原因是因为功能仅适用于泛型类型的某些实例化，因此无法将其声明为泛型的成员。例如，`Collections.max`
    仅适用于具有可比较元素的集合。
- en: 'Over time, we began to appreciate the advantages of using standard interfaces,
    like the Java collections, instead of working with our own abstractions. Java
    5 (with its generics) was the first release that allowed us to use collections
    directly rather than wrapping them with our own classes. It’s no accident then
    that Java 5 also brought the ability to `import static java.util.Collections.max`
    so that we could then write:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that this is really only a convenience provided by the compiler, because
    the JVM still only actually supports static methods rather than true top-level
    functions.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin Top-Level Functions, Objects, and Companions
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kotlin allows functions (and properties and constants) to be declared outside
    of classes. In this case, because the JVM has nowhere else for them to go, the
    compiler generates a class with static members for these top-level declarations.
    By default, it derives the name of the class from the name of the file defining
    the functions. For example, functions defined in `top-level.kt` end up as static
    methods on a class called `Top_levelKt`. If we know the name of the class, we
    can reference it from Java by either static importing `Top_LevelKt.foo` or directly
    invoking `Top_levelKt.foo()`. If we don’t like the ugliness of `Top_LevelKt`,
    we can explicitly name the generated class by adding an annotation, `@file:JvmName`,
    to the top of the file, as we’ll see later in this chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'As well as these top-level functions, Kotlin also allows us to define properties
    and functions scoped, like Java statics, to a class rather than an instance. Instead
    of just marking these as `static`, Kotlin borrows from Scala and collects them
    into `object` declarations. This type of `object` declaration (as opposed to the
    `object` expression that creates anonymous types) defines a singleton: a type
    with only one instance that provides a global point of access to that instance.
    All the members of an `object` will be compiled to members of a class with the
    name of the object. They won’t actually be static methods unless specifically
    marked with `@JvmStatic`, though. This is because Kotlin allows these objects
    to extend classes and implement interfaces, and that is incompatible with static
    declarations.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: When we need to group static and nonstatic members in the same class, we can
    declare the static parts in a `companion object` inside the (otherwise nonstatic)
    class declaration. This groups them in the file, and code in a companion object
    can access private state in instances of its containing class. Companion objects
    can also extend another class and implement interfaces—something that Java statics
    cannot do. Compared to Java statics though, companion objects are cumbersome if
    we just want to define one or two static methods.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: In Kotlin, then, we can write non-instance-scoped functions as either top-level
    functions or methods on a singleton object, and this object may be a companion
    object or not scoped to a type.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Of these, all things being equal, we should default to top-level functions.
    They are the simplest to declare and reference, and can be moved from file to
    file within a package without affecting Kotlin client code (but see the caveat
    in [“Moving Top-Level Functions”](#moving-top-level-functions)). We reserve declaring
    functions as methods on a singleton object instead of top-level functions for
    when we need the ability to implement an interface, or otherwise group functions
    more tightly. We use a companion object when we need to mix static and nonstatic
    behavior within a class, or to write factory methods with names like `MyType.of(...)`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: As with many aspects of programming, we start with the simplest thing that could
    work, which is usually a top-level function, and refactor to a more complicated
    solution only when it brings benefits, such as a more expressive API for our clients,
    or better maintainability for us.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring from Static Methods to Top-Level Functions
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we prefer to use top-level declarations, the Java to Kotlin conversion
    built into IntelliJ doesn’t. It converts our Java statics into object methods.
    Let’s see how to refactor from Java, through object declarations, to top-level
    functions.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'At Travelator, we allow our customers to build shortlists, such as a shortlist
    of routes when planning their trip, or a shortlist of hotel rooms on those routes.
    The user can rank items in a shortlist by different criteria and discard items
    to narrow down the results to a final choice. Following the guidance in [“Don’t
    Mutate Shared Collections”](ch06.html#dont-mutate-shared-collections), a shortlist
    is stored as an immutable list. The functions for manipulating a shortlist (returning
    a modified copy rather than mutating the list) are implemented as static methods
    of the `Shortlists` class:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[Example 8.1 [static-to-top-level.0:src/main/java/travelator/Shortlists.java]](https://java-to-kotlin.dev/code.html?ref=8.1&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=8.1&show=diff)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'The functions in `Shortlists` are static methods, and have to be referenced
    as such. Spelled out longhand, this looks like:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[Example 8.2 [static-to-top-level.5:src/test/java/travelator/ShortlistsTest.java]](https://java-to-kotlin.dev/code.html?ref=8.2&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=8.2&show=diff)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'We usually `static import` the methods though, and they are named to read better
    that way:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[Example 8.3 [static-to-top-level.5:src/test/java/travelator/ShortlistsTest.java]](https://java-to-kotlin.dev/code.html?ref=8.3&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=8.3&show=diff)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'Converting the Java to Kotlin with IntelliJ we get:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[Example 8.4 [static-to-top-level.5:src/main/java/travelator/Shortlists.kt]](https://java-to-kotlin.dev/code.html?ref=8.4&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=8.4&show=diff)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Actually, that isn’t quite true. At the time of writing, the converter added
    some spurious nullability to types, undid static imports (leaving us with `Collectors.to​Un⁠modi⁠fiableList()`,
    for example), and managed to create an imports list that didn’t compile. Fixing
    up the file manually gives us confidence that the machines won’t take our jobs
    for a few years yet.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](ch03.html#java-to-kotlin-classes), we saw that converting a Java
    class with static *and* nonstatic methods produced a Kotlin class with a companion
    object. Here the conversion has produced only a top-level object. Because this
    Java class had no nonstatic methods or state, there is no need for the Kotlin
    translation to include an instantiable class. Classes with both static and nonstatic
    methods are less suitable for conversion to top-level functions.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: While the conversion didn’t go completely smoothly at the Kotlin level, on the
    plus side, no Java code was harmed in the process. The client code remains unchanged,
    because the `@JvmStatic` annotations allow Java code to see the methods as static
    methods on a `Shortlists` class, as they were before the conversion.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to convert the methods to be top-level functions, but we can’t just
    move them, because Java only understands methods, not functions. If these functions
    were compiled to methods on a class called `Shortlists`, Java would be happy,
    and that is the job of the `@file:JvmName` annotation we mentioned earlier. We
    can manually add the annotation at the top of the file, and remove the `object`
    scope and `@JvmStatic` annotations to get:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[Example 8.5 [static-to-top-level.6:src/main/java/travelator/Shortlists.kt]](https://java-to-kotlin.dev/code.html?ref=8.5&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=8.5&show=diff)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'This keeps our Java happy, but irritatingly, it breaks some Kotlin code that
    was calling the methods. Here, for example, are the imports for a test:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[Example 8.6 [static-to-top-level.6:src/test/java/travelator/hotels/ShortlistScenarioTest.kt]](https://java-to-kotlin.dev/code.html?ref=8.6&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=8.6&show=diff)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'These were importing the static Java methods, but Kotlin can’t import its own
    top-level functions in the same way, so these lines fail with `Unresolved reference:
    Shortlists`. As far as Kotlin is concerned, the functions are defined in the scope
    of the package, not in a class in that package. The compiler may compile them
    to static methods of a JVM class called `ShortlistsKt`, but that class is an implementation
    detail of how the compiler maps Kotlin language concepts to the JVM platform and
    is not visible to our Kotlin code at compile time.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: We could go through all the compilation errors and manually fix the imports
    to refer to the function at package scope. For example, we would have to change
    `import` `travelator.Shortlists.sorted` to `import travelator.sorted`. This is
    easy enough if the change affects a few files, but if the change has had a wide
    impact, fixing all the imports is a tedious job, albeit one that *might* be achieved
    with a single global search and replace.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, while we were writing this book, IntelliJ gained a “Move to top level”
    refactoring. Let’s revert the last Kotlin change, back to the object declaration,
    and try again.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Move to Top Level
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we write this, the refactoring is so new that it isn’t available on the
    refactoring menu, but Alt-Enter on an object method name gives the option “Move
    to top level”. We’ll do `sorted` first. IntelliJ moves the method out of the object
    scope to the file level:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[Example 8.7 [static-to-top-level.7:src/main/java/travelator/Shortlists.kt]](https://java-to-kotlin.dev/code.html?ref=8.7&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=8.7&show=diff)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, it failed to remove the `@JvmStatic` annotation, so we have
    to delete that ourselves to get the code to compile. Once we do, we find that
    it has at least fixed up the callers, which was the problem we had when we just
    moved the method ourselves. Where we explicitly referenced the method in Java
    as `ShortLists.sorted`, we now have:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[Example 8.8 [static-to-top-level.8:src/test/java/travelator/ShortlistsTest.java]](https://java-to-kotlin.dev/code.html?ref=8.8&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=8.8&show=diff)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'For some reason, where we had a static import, things have become worse:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[Example 8.9 [static-to-top-level.8:src/test/java/travelator/ShortlistsTest.java]](https://java-to-kotlin.dev/code.html?ref=8.9&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=8.9&show=diff)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'We can fix that with Alt-Enter and “Add on demand static import…”. We have
    to do that once in each affected file; we should have checked in before the refactor
    so that we could easily see which files it changed:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[Example 8.10 [static-to-top-level.9:src/test/java/travelator/ShortlistsTest.java]](https://java-to-kotlin.dev/code.html?ref=8.10&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=8.10&show=diff)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Compared to our previous manual approach of adding an `@file:JvmName("Shortlists")`
    annotation, our Java clients are now exposed to that icky `ShortlistsKt` name.
    Because the methods names were designed to be used with static imports though,
    it is almost always hidden in the imports block where no one ever looks, so we’re
    prepared to put up with this. In return for this sacrifice, the conversion has
    also fixed up the Kotlin callers of `sorted`. It is now referenced in Kotlin as
    `travelator.sorted` rather than `travalator.Shortlists.sorted`, which was the
    point.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now move the rest of the methods on `Shortlists` in the same way. It’s
    a little tedious, but at least when it moves the last method, IntelliJ deletes
    the empty object, leaving us:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[Example 8.11 [static-to-top-level.10:src/main/java/travelator/Shortlists.kt]](https://java-to-kotlin.dev/code.html?ref=8.11&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=8.11&show=diff)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: As we write this, the “Move to top level” refactor is limited to a single method
    at a time. If methods depend on each other, this can lead to some problems, as
    we will see in [Chapter 10](ch10.html#functions-to-extension-functions).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Kotlinify
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Of course, we didn’t move our methods to top-level functions just for the sake
    of it. Well, not *just* for the sake of it anyway. Now that our functions are
    in the idiomatic Kotlin place, let’s finish the idiomatic Kotlin job.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 13](ch13.html#streams-to-sequences) gives guidance on converting Java
    streams to Kotlin; in the case of `sorted`, we can just use the Kotlin `sortedWith`
    extension function:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[Example 8.12 [static-to-top-level.11:src/main/java/travelator/Shortlists.kt]](https://java-to-kotlin.dev/code.html?ref=8.12&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=8.12&show=diff)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'This makes a very logical extension function ([Chapter 10](ch10.html#functions-to-extension-functions)):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[Example 8.13 [static-to-top-level.12:src/main/java/travelator/Shortlists.kt]](https://java-to-kotlin.dev/code.html?ref=8.13&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=8.13&show=diff)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'Java still calls this as a static method:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[Example 8.14 [static-to-top-level.12:src/test/java/travelator/ShortlistsTest.java]](https://java-to-kotlin.dev/code.html?ref=8.14&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=8.14&show=diff)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'Calling from Kotlin reads nicely too:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[Example 8.15 [static-to-top-level.12:src/test/java/travelator/hotels/ShortlistScenarioTest.kt]](https://java-to-kotlin.dev/code.html?ref=8.15&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=8.15&show=diff)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'These Kotlin usages really aren’t gaining us anything over the raw Kotlin API,
    so we can just inline them:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[Example 8.16 [static-to-top-level.13:src/test/java/travelator/hotels/ShortlistScenarioTest.kt]](https://java-to-kotlin.dev/code.html?ref=8.16&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=8.16&show=diff)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'This leaves the `sorted` function for Java to call. Looking at it, it really
    has nothing to do with shortlists anymore. Should we move it to a more generic
    namespace? Maybe later; for now we’ll just follow through on the rest of the file
    to give:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[Example 8.17 [static-to-top-level.14:src/main/java/travelator/Shortlists.kt]](https://java-to-kotlin.dev/code.html?ref=8.17&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=8.17&show=diff)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that we have renamed `removeItemAt` to `withoutItemAt`.
    Prepositions like *with* and *without* are a useful device to let the reader know
    that we are not mutating an object but returning a copy.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们将 `removeItemAt` 重命名为 `withoutItemAt`。像 *with* 和 *without* 这样的介词是一个有用的工具，可以让读者知道我们不是在改变一个对象，而是返回一个副本。
- en: Moving On
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继续前进
- en: Static functions are the bread and butter of our programs. In Java these have
    to be static methods on a class, but in Kotlin we can and should default to defining
    them as top-level functions.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 静态函数是我们程序的核心。在 Java 中，这些必须是类上的静态方法，但在 Kotlin 中，我们可以并且应该将其定义为顶级函数。
- en: Automatically converting a Java class of static methods to Kotlin will create
    an `object` declaration, accessible from both Java and Kotlin. We can then move
    the methods on the object to the top level individually, remaining accessible
    to both languages, before applying other refactorings to take advantage of more
    Kotliny goodness.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个 Java 类的静态方法自动转换为 Kotlin 会创建一个 `object` 声明，可从 Java 和 Kotlin 都访问。然后我们可以逐个将对象上的方法移到顶层，仍然可以被两种语言访问，在利用更多
    Kotlin 特性的其他重构之前。
- en: The most likely next refactor is to refactor our top-level functions into extension
    functions, the subject of [Chapter 10, *Functions to Extension Functions*](ch10.html#functions-to-extension-functions).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个最可能的重构是将我们的顶级函数重构为扩展函数，这是[第 10 章，“从函数到扩展函数”](ch10.html#functions-to-extension-functions)的主题。
