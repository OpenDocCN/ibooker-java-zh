- en: Chapter 8\. Static Methods to Top-Level Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Standalone functions are one of the fundamental building blocks of software.
    They have to be declared as methods on a class in Java, but in Kotlin we can declare
    them as top-level entities. When should we prefer top-level functions, and how
    do we refactor our way there from Java?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Java Statics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All values and functions in a Java program have to belong to a class: they
    are *members* of that class. Java calls member-values *fields*, and member-functions
    *methods*. By default, fields values are per-instance of the class: different
    instances have different values. Methods are also per-instance in that they have
    access to the state of the instance that they are invoked on. If we mark fields
    as `static`, though, they are shared between all instances of the class. Static
    methods only have access to this shared state (and visible static fields in other
    classes), but in return for this restriction, we can invoke them without needing
    an instance of the class.'
  prefs: []
  type: TYPE_NORMAL
- en: To simplify Java, the language designers tied all code and data to classes.
    We have class-scoped static state, so we need class-scoped static methods. They
    could have added freestanding data and functions, but static fields and methods
    will do. If the language had options, then developers would have to choose between
    them, and less choice is often better. The designers then carried this language
    design decision forward to the Java Virtual Machine, which in turn has no way
    to express top-level code or data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes we have a class with both nonstatic and static methods acting on
    the same type—for example, the email class with a static parsing method we saw
    in [Chapter 3](ch03.html#java-to-kotlin-classes). Often, though, we end up with
    a class composed of only static methods. When there is no static state for them
    to share, these methods are really just stand-alone functions grouped together
    and called via their class name, like the methods from the `java.util.Collections`
    class, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Amazingly, the industry didn’t really notice how much of a pain that `Collections.`
    prefix was for a while. This was because we wrote our programs by adding more
    and more methods to types that we owned, so we rarely needed static functions.
    Static functions are useful when we want to add functionality *without* adding
    a method to the type that they act on. This might be because our classes are already
    sagging under the weight of all the methods that we have already added to them,
    or because we don’t own the class and so can’t add the method to it. Another reason
    for using static functions rather than methods is because the functionality only
    applies to some instantiations of a generic type, so it cannot be declared as
    a member of the generic. That `Collections.max`, for example, only applies to
    a collection with comparable elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Over time, we began to appreciate the advantages of using standard interfaces,
    like the Java collections, instead of working with our own abstractions. Java
    5 (with its generics) was the first release that allowed us to use collections
    directly rather than wrapping them with our own classes. It’s no accident then
    that Java 5 also brought the ability to `import static java.util.Collections.max`
    so that we could then write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note that this is really only a convenience provided by the compiler, because
    the JVM still only actually supports static methods rather than true top-level
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin Top-Level Functions, Objects, and Companions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kotlin allows functions (and properties and constants) to be declared outside
    of classes. In this case, because the JVM has nowhere else for them to go, the
    compiler generates a class with static members for these top-level declarations.
    By default, it derives the name of the class from the name of the file defining
    the functions. For example, functions defined in `top-level.kt` end up as static
    methods on a class called `Top_levelKt`. If we know the name of the class, we
    can reference it from Java by either static importing `Top_LevelKt.foo` or directly
    invoking `Top_levelKt.foo()`. If we don’t like the ugliness of `Top_LevelKt`,
    we can explicitly name the generated class by adding an annotation, `@file:JvmName`,
    to the top of the file, as we’ll see later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'As well as these top-level functions, Kotlin also allows us to define properties
    and functions scoped, like Java statics, to a class rather than an instance. Instead
    of just marking these as `static`, Kotlin borrows from Scala and collects them
    into `object` declarations. This type of `object` declaration (as opposed to the
    `object` expression that creates anonymous types) defines a singleton: a type
    with only one instance that provides a global point of access to that instance.
    All the members of an `object` will be compiled to members of a class with the
    name of the object. They won’t actually be static methods unless specifically
    marked with `@JvmStatic`, though. This is because Kotlin allows these objects
    to extend classes and implement interfaces, and that is incompatible with static
    declarations.'
  prefs: []
  type: TYPE_NORMAL
- en: When we need to group static and nonstatic members in the same class, we can
    declare the static parts in a `companion object` inside the (otherwise nonstatic)
    class declaration. This groups them in the file, and code in a companion object
    can access private state in instances of its containing class. Companion objects
    can also extend another class and implement interfaces—something that Java statics
    cannot do. Compared to Java statics though, companion objects are cumbersome if
    we just want to define one or two static methods.
  prefs: []
  type: TYPE_NORMAL
- en: In Kotlin, then, we can write non-instance-scoped functions as either top-level
    functions or methods on a singleton object, and this object may be a companion
    object or not scoped to a type.
  prefs: []
  type: TYPE_NORMAL
- en: Of these, all things being equal, we should default to top-level functions.
    They are the simplest to declare and reference, and can be moved from file to
    file within a package without affecting Kotlin client code (but see the caveat
    in [“Moving Top-Level Functions”](#moving-top-level-functions)). We reserve declaring
    functions as methods on a singleton object instead of top-level functions for
    when we need the ability to implement an interface, or otherwise group functions
    more tightly. We use a companion object when we need to mix static and nonstatic
    behavior within a class, or to write factory methods with names like `MyType.of(...)`.
  prefs: []
  type: TYPE_NORMAL
- en: As with many aspects of programming, we start with the simplest thing that could
    work, which is usually a top-level function, and refactor to a more complicated
    solution only when it brings benefits, such as a more expressive API for our clients,
    or better maintainability for us.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring from Static Methods to Top-Level Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we prefer to use top-level declarations, the Java to Kotlin conversion
    built into IntelliJ doesn’t. It converts our Java statics into object methods.
    Let’s see how to refactor from Java, through object declarations, to top-level
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'At Travelator, we allow our customers to build shortlists, such as a shortlist
    of routes when planning their trip, or a shortlist of hotel rooms on those routes.
    The user can rank items in a shortlist by different criteria and discard items
    to narrow down the results to a final choice. Following the guidance in [“Don’t
    Mutate Shared Collections”](ch06.html#dont-mutate-shared-collections), a shortlist
    is stored as an immutable list. The functions for manipulating a shortlist (returning
    a modified copy rather than mutating the list) are implemented as static methods
    of the `Shortlists` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 8.1 [static-to-top-level.0:src/main/java/travelator/Shortlists.java]](https://java-to-kotlin.dev/code.html?ref=8.1&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=8.1&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The functions in `Shortlists` are static methods, and have to be referenced
    as such. Spelled out longhand, this looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 8.2 [static-to-top-level.5:src/test/java/travelator/ShortlistsTest.java]](https://java-to-kotlin.dev/code.html?ref=8.2&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=8.2&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We usually `static import` the methods though, and they are named to read better
    that way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 8.3 [static-to-top-level.5:src/test/java/travelator/ShortlistsTest.java]](https://java-to-kotlin.dev/code.html?ref=8.3&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=8.3&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Converting the Java to Kotlin with IntelliJ we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 8.4 [static-to-top-level.5:src/main/java/travelator/Shortlists.kt]](https://java-to-kotlin.dev/code.html?ref=8.4&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=8.4&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: Actually, that isn’t quite true. At the time of writing, the converter added
    some spurious nullability to types, undid static imports (leaving us with `Collectors.to​Un⁠modi⁠fiableList()`,
    for example), and managed to create an imports list that didn’t compile. Fixing
    up the file manually gives us confidence that the machines won’t take our jobs
    for a few years yet.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](ch03.html#java-to-kotlin-classes), we saw that converting a Java
    class with static *and* nonstatic methods produced a Kotlin class with a companion
    object. Here the conversion has produced only a top-level object. Because this
    Java class had no nonstatic methods or state, there is no need for the Kotlin
    translation to include an instantiable class. Classes with both static and nonstatic
    methods are less suitable for conversion to top-level functions.
  prefs: []
  type: TYPE_NORMAL
- en: While the conversion didn’t go completely smoothly at the Kotlin level, on the
    plus side, no Java code was harmed in the process. The client code remains unchanged,
    because the `@JvmStatic` annotations allow Java code to see the methods as static
    methods on a `Shortlists` class, as they were before the conversion.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to convert the methods to be top-level functions, but we can’t just
    move them, because Java only understands methods, not functions. If these functions
    were compiled to methods on a class called `Shortlists`, Java would be happy,
    and that is the job of the `@file:JvmName` annotation we mentioned earlier. We
    can manually add the annotation at the top of the file, and remove the `object`
    scope and `@JvmStatic` annotations to get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 8.5 [static-to-top-level.6:src/main/java/travelator/Shortlists.kt]](https://java-to-kotlin.dev/code.html?ref=8.5&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=8.5&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This keeps our Java happy, but irritatingly, it breaks some Kotlin code that
    was calling the methods. Here, for example, are the imports for a test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 8.6 [static-to-top-level.6:src/test/java/travelator/hotels/ShortlistScenarioTest.kt]](https://java-to-kotlin.dev/code.html?ref=8.6&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=8.6&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'These were importing the static Java methods, but Kotlin can’t import its own
    top-level functions in the same way, so these lines fail with `Unresolved reference:
    Shortlists`. As far as Kotlin is concerned, the functions are defined in the scope
    of the package, not in a class in that package. The compiler may compile them
    to static methods of a JVM class called `ShortlistsKt`, but that class is an implementation
    detail of how the compiler maps Kotlin language concepts to the JVM platform and
    is not visible to our Kotlin code at compile time.'
  prefs: []
  type: TYPE_NORMAL
- en: We could go through all the compilation errors and manually fix the imports
    to refer to the function at package scope. For example, we would have to change
    `import` `travelator.Shortlists.sorted` to `import travelator.sorted`. This is
    easy enough if the change affects a few files, but if the change has had a wide
    impact, fixing all the imports is a tedious job, albeit one that *might* be achieved
    with a single global search and replace.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, while we were writing this book, IntelliJ gained a “Move to top level”
    refactoring. Let’s revert the last Kotlin change, back to the object declaration,
    and try again.
  prefs: []
  type: TYPE_NORMAL
- en: Move to Top Level
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we write this, the refactoring is so new that it isn’t available on the
    refactoring menu, but Alt-Enter on an object method name gives the option “Move
    to top level”. We’ll do `sorted` first. IntelliJ moves the method out of the object
    scope to the file level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 8.7 [static-to-top-level.7:src/main/java/travelator/Shortlists.kt]](https://java-to-kotlin.dev/code.html?ref=8.7&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=8.7&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, it failed to remove the `@JvmStatic` annotation, so we have
    to delete that ourselves to get the code to compile. Once we do, we find that
    it has at least fixed up the callers, which was the problem we had when we just
    moved the method ourselves. Where we explicitly referenced the method in Java
    as `ShortLists.sorted`, we now have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 8.8 [static-to-top-level.8:src/test/java/travelator/ShortlistsTest.java]](https://java-to-kotlin.dev/code.html?ref=8.8&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=8.8&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'For some reason, where we had a static import, things have become worse:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 8.9 [static-to-top-level.8:src/test/java/travelator/ShortlistsTest.java]](https://java-to-kotlin.dev/code.html?ref=8.9&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=8.9&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can fix that with Alt-Enter and “Add on demand static import…”. We have
    to do that once in each affected file; we should have checked in before the refactor
    so that we could easily see which files it changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 8.10 [static-to-top-level.9:src/test/java/travelator/ShortlistsTest.java]](https://java-to-kotlin.dev/code.html?ref=8.10&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=8.10&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: Compared to our previous manual approach of adding an `@file:JvmName("Shortlists")`
    annotation, our Java clients are now exposed to that icky `ShortlistsKt` name.
    Because the methods names were designed to be used with static imports though,
    it is almost always hidden in the imports block where no one ever looks, so we’re
    prepared to put up with this. In return for this sacrifice, the conversion has
    also fixed up the Kotlin callers of `sorted`. It is now referenced in Kotlin as
    `travelator.sorted` rather than `travalator.Shortlists.sorted`, which was the
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now move the rest of the methods on `Shortlists` in the same way. It’s
    a little tedious, but at least when it moves the last method, IntelliJ deletes
    the empty object, leaving us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 8.11 [static-to-top-level.10:src/main/java/travelator/Shortlists.kt]](https://java-to-kotlin.dev/code.html?ref=8.11&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=8.11&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: As we write this, the “Move to top level” refactor is limited to a single method
    at a time. If methods depend on each other, this can lead to some problems, as
    we will see in [Chapter 10](ch10.html#functions-to-extension-functions).
  prefs: []
  type: TYPE_NORMAL
- en: Kotlinify
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Of course, we didn’t move our methods to top-level functions just for the sake
    of it. Well, not *just* for the sake of it anyway. Now that our functions are
    in the idiomatic Kotlin place, let’s finish the idiomatic Kotlin job.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 13](ch13.html#streams-to-sequences) gives guidance on converting Java
    streams to Kotlin; in the case of `sorted`, we can just use the Kotlin `sortedWith`
    extension function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 8.12 [static-to-top-level.11:src/main/java/travelator/Shortlists.kt]](https://java-to-kotlin.dev/code.html?ref=8.12&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=8.12&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This makes a very logical extension function ([Chapter 10](ch10.html#functions-to-extension-functions)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 8.13 [static-to-top-level.12:src/main/java/travelator/Shortlists.kt]](https://java-to-kotlin.dev/code.html?ref=8.13&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=8.13&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Java still calls this as a static method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 8.14 [static-to-top-level.12:src/test/java/travelator/ShortlistsTest.java]](https://java-to-kotlin.dev/code.html?ref=8.14&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=8.14&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Calling from Kotlin reads nicely too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 8.15 [static-to-top-level.12:src/test/java/travelator/hotels/ShortlistScenarioTest.kt]](https://java-to-kotlin.dev/code.html?ref=8.15&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=8.15&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'These Kotlin usages really aren’t gaining us anything over the raw Kotlin API,
    so we can just inline them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 8.16 [static-to-top-level.13:src/test/java/travelator/hotels/ShortlistScenarioTest.kt]](https://java-to-kotlin.dev/code.html?ref=8.16&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=8.16&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This leaves the `sorted` function for Java to call. Looking at it, it really
    has nothing to do with shortlists anymore. Should we move it to a more generic
    namespace? Maybe later; for now we’ll just follow through on the rest of the file
    to give:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 8.17 [static-to-top-level.14:src/main/java/travelator/Shortlists.kt]](https://java-to-kotlin.dev/code.html?ref=8.17&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=8.17&show=diff)'
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that we have renamed `removeItemAt` to `withoutItemAt`.
    Prepositions like *with* and *without* are a useful device to let the reader know
    that we are not mutating an object but returning a copy.
  prefs: []
  type: TYPE_NORMAL
- en: Moving On
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Static functions are the bread and butter of our programs. In Java these have
    to be static methods on a class, but in Kotlin we can and should default to defining
    them as top-level functions.
  prefs: []
  type: TYPE_NORMAL
- en: Automatically converting a Java class of static methods to Kotlin will create
    an `object` declaration, accessible from both Java and Kotlin. We can then move
    the methods on the object to the top level individually, remaining accessible
    to both languages, before applying other refactorings to take advantage of more
    Kotliny goodness.
  prefs: []
  type: TYPE_NORMAL
- en: The most likely next refactor is to refactor our top-level functions into extension
    functions, the subject of [Chapter 10, *Functions to Extension Functions*](ch10.html#functions-to-extension-functions).
  prefs: []
  type: TYPE_NORMAL
