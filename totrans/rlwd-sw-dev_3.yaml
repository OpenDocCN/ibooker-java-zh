- en: Chapter 3\. Extending the Bank Statements Analyzer
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章 扩展银行对账单分析器
- en: The Challenge
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挑战
- en: Mark Erbergzuck was very happy with the work you did in the previous chapter.
    You built a basic Bank Statements Analyzer as a minimum viable product. Because
    of this success Mark Erbergzuck thinks that your product can be taken further
    and asks you to build a new version that support multiple features.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Mark Erbergzuck 对你在前一章的工作非常满意。你建立了一个基本的银行对账单分析器作为最小可行产品。基于这个成功，Mark Erbergzuck
    认为你的产品可以进一步发展，并要求你构建一个支持多种功能的新版本。
- en: The Goal
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 目标
- en: In the previous chapter, you learned how to create an application to analyze
    bank statements in a CSV format. Along this journey you learned about core design
    principles that help you write maintainable code, the Single Responsibility Principle,
    and anti-patterns you should avoid, such as God Class and code duplication. While
    you were incrementally refactoring your code you also learned about coupling (how
    dependent you are on other classes) and cohesion (how related things are in a
    class).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了如何创建一个分析CSV格式银行对账单的应用程序。在这段旅程中，你学习了有助于编写可维护代码的核心设计原则，如单一职责原则，以及应避免的反模式，如上帝类和代码重复。在逐步重构代码的过程中，你还学习了耦合性（你对其他类的依赖程度）和内聚性（类中相关事物的程度）。
- en: Nonetheless, the application is currently pretty limited. How about providing
    functionality for searching for different kinds of transactions, supporting multiple
    formats, processors, and exporting the results into a nice report with different
    formats such as text and HTML?
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，该应用目前相当有限。怎么样提供搜索不同类型交易的功能，支持多种格式、处理器，并将结果导出成漂亮的报告，如文本和HTML？
- en: In this chapter, you will go deeper in your software development quest. First,
    you will learn about the Open/Closed principle, which is essential for adding
    flexibility to your codebase and improving code maintenance. You will also learn
    general guidelines for when it makes sense to introduce interfaces, as well as
    other gotchas to avoid high coupling. You will also learn about the use of exceptions
    in Java—when it makes sense to include them as part of the APIs you define and
    when it doesn’t. Finally, you will learn how to systematically build a Java project
    using an established build tool like Maven and Gradle.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将深入探索软件开发的路径。首先，你将学习开闭原则，这是为了增加代码灵活性和改善代码维护而必不可少的。你还将学习引入接口的一般准则，以及避免高耦合的其他注意事项。你还将了解在Java中使用异常的情况——在定义API时包含它们是合适的情况，以及不合适的情况。最后，你将学会如何系统化地使用像Maven和Gradle这样的成熟构建工具来构建Java项目。
- en: Note
  id: totrans-7
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If at any point you want to look at the source code for this chapter, you can
    look at the package `com.iteratrlearning.shu_book.chapter_03` in the book’s code
    repository.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看本章节的源代码，可以访问本书代码仓库中的`com.iteratrlearning.shu_book.chapter_03`包。
- en: Extended Bank Statements Analyzer Requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展银行对账单分析器的需求
- en: 'You had a friendly chat with Mark Erbergzuck to collect new requirements for
    the second iteration of the Bank Statements Analyzer. He would like to extend
    the functionality of the kind of operations you can perform. At the moment the
    application is limited, as it can only query for the revenue in a particular month
    or category. Mark has requested two new functionalities:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你与Mark Erbergzuck 友好交谈，收集了对银行对账单分析器第二次迭代功能的新要求。他希望扩展你可以执行的操作类型。目前应用程序的功能有限，只能查询特定月份或类别的收入。Mark
    提出了两个新功能需求：
- en: He’d like to also be able to search for specific transactions. For example,
    you should be able to return all the bank transactions in a given date range or
    for a specific category.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 他还希望能够搜索特定的交易。例如，你应该能够返回在特定日期范围内或特定类别中的所有银行交易。
- en: Mark would like to be able to generate a report of summary statistics for his
    search into different formats such as text and HTML.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Mark 希望能够生成搜索结果的摘要统计报告，并支持文本和HTML等不同格式。
- en: You will work through these requirements in order.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你将按顺序完成这些需求。
- en: Open/Closed Principle
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开闭原则
- en: Let’s start simple. You will implement a method that can find all the transactions
    over a certain amount. The first question is where should you declare this method?
    You could create a separate `BankTransactionFinder` class that will contain a
    simple `findTransactions()` method. However, you also declared a class `BankTransactionProcessor`
    in the previous chapter. So what should you do? In this case, there aren’t a lot
    of benefits in declaring a new class every time you need to add one single method.
    This actually adds complexity to your whole project, as it introduces a pollution
    of names that makes it harder to understand the relationships between these different
    behaviors. Declaring the method inside `BankTransactionProcessor` helps with discoverability
    as you immediately know that this is the class that groups all methods that do
    some form of processing. Now that you’ve decided where to declare it, you can
    implement it as shown in [Example 3-1](#transactions_greater).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的开始。您将实现一个方法，可以找到所有金额超过一定数额的交易。第一个问题是，您应该在哪里声明这个方法？您可以创建一个单独的`BankTransactionFinder`类，其中包含一个简单的`findTransactions()`方法。但是，在上一章中，您还声明了一个名为`BankTransactionProcessor`的类。那么，您应该怎么做呢？在这种情况下，每次需要添加一个单一方法时声明一个新类并没有太多好处。实际上，这会增加整个项目的复杂性，因为它引入了名称的污染，使得理解这些不同行为之间的关系变得更加困难。在`BankTransactionProcessor`内声明该方法有助于发现性，因为您立即知道这是一类分组所有执行某种形式处理的方法。既然您已经决定在哪里声明它，您可以按照[示例
    3-1](#transactions_greater)中显示的方式实现它。
- en: Example 3-1\. Find bank transactions over a certain amount
  id: totrans-16
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-1. 查找金额超过一定数额的银行交易
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This code is reasonable. However, what if you want to also search in a certain
    month? You need to duplicate this method as shown in [Example 3-2](#transactions_in_month).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是合理的。但是，如果您还希望在特定月份进行搜索怎么办呢？您需要像[示例 3-2](#transactions_in_month)中显示的那样复制此方法。
- en: Example 3-2\. Find bank transactions in a certain month
  id: totrans-19
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-2. 在特定月份查找银行交易
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the previous chapter, you already came across code duplication. It is a code
    smell which leads to code that is brittle, especially if requirements change frequently.
    For example, if the iteration logic needs to change, you will need to repeat the
    modifications in several places.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，您已经遇到了代码重复的情况。这是一种代码异味，会导致代码脆弱，特别是如果需求经常变化的情况下。例如，如果迭代逻辑需要更改，您将需要在多个地方重复修改。
- en: This approach also doesn’t work well for more complicated requirements. What
    if we wish to search transactions in a specific month and also over a certain
    amount? You could implement this new requirement as shown in [Example 3-3](#transactions_in_month_and_greater).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法对于更复杂的需求也不起作用。如果我们希望搜索特定月份的交易，并且金额超过一定数额怎么办？您可以按照[示例 3-3](#transactions_in_month_and_greater)中显示的方式实现这个新需求。
- en: Example 3-3\. Find bank transactions in a certain month and over a certain amount
  id: totrans-23
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-3. 在特定月份和金额超过一定数额的银行交易
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Clearly this approach exhibits several downsides:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这种方法表现出了几个缺点：
- en: Your code will become increasingly complicated as you have to combine multiple
    properties of a bank transaction.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着必须结合银行交易的多个属性，您的代码会变得越来越复杂。
- en: The selection logic is coupled to the iteration logic, making it harder to separate
    them out.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择逻辑与迭代逻辑耦合在一起，使得更难将它们分开。
- en: You keep on duplicating code.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您继续重复代码。
- en: This is where the Open/Closed principle comes in. It promotes the idea of being
    able to change the behavior of a method or class without having to modify the
    code. In our example, it would mean the ability to extend the behavior of a `findTransactions()`
    method without having to duplicate the code or change it to introduce a new parameter.
    How is this possible? As discussed earlier, the concepts of iterating and the
    business logic are coupled together. In the previous chapter, you learned about
    interfaces as a useful tool to decouple concepts from one another. In this case,
    you will introduce a `BankTransactionFilter` interface that will be responsible
    for the selection logic, as shown in [Example 3-4](#transactionfilter_interface).
    It contains a single method `test()` that returns a boolean and takes the complete
    `BankTransaction` object as an argument. This way the method `test()` has access
    to all the properties of a `BankTransaction` to specify any appropriate selection
    criteria.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是开闭原则的应用场景。它提倡能够在不修改代码的情况下更改方法或类的行为。在我们的例子中，这意味着可以扩展`findTransactions()`方法的行为，而无需复制代码或更改它以引入新的参数。这是如何可能的呢？正如前文所讨论的，迭代和业务逻辑的概念是耦合在一起的。在前一章中，您了解了接口作为一种有用的工具来将概念解耦。在本例中，您将引入一个`BankTransactionFilter`接口，它将负责选择逻辑，如[示例 3-4](#transactionfilter_interface)所示。它包含一个名为`test()`的方法，返回一个布尔值，并以`BankTransaction`对象作为参数。这样，`test()`方法就可以访问`BankTransaction`的所有属性，以指定任何适当的选择标准。
- en: Note
  id: totrans-30
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: An interface that only contains a single abstract method is called a *functional
    interface* since Java 8\. You can annotate it using the `@FunctionalInterface`
    annotation to make the intent of the interface clearer.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一个仅包含单个抽象方法的接口自Java 8以来被称为*函数式接口*。你可以使用`@FunctionalInterface`注解对其进行注释，以使接口的意图更加明确。
- en: Example 3-4\. The BankTransactionFilter interface
  id: totrans-32
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-4\. BankTransactionFilter接口
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-34
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Java 8 introduced a generic `java.util.function.Predicate<T>` inferface, which
    would be a great fit for the problem at hand. However, this chapter introduces
    a new named interface to avoid introducing too much complexity early on in the
    book.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8引入了一个泛型`java.util.function.Predicate<T>`接口，它非常适合手头的问题。然而，本章介绍了一个新命名的接口，以避免在书中早期引入过多复杂性。
- en: The interface `BankTransactionFilter` models the concept of a selection criteria
    for a `BankTransaction`. You can now refactor the method `findTransactions()`
    to make use of it as shown in [Example 3-5](#findTransactions_ocp). This refactoring
    is very important because you now have introduced a way to decouple the iteration
    logic from the business logic through this interface. Your method no longer depends
    on one specific implementation of a filter. You can introduce new implementations
    by passing them as an argument without modifying the body of this method. Hence,
    it is now open for extension and closed for modification. This reduces the scope
    for introducing new bugs because it minimizes cascading changes required to parts
    of code that have already been implemented and tested. In other words, old code
    still works and is untouched.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`BankTransactionFilter`接口模拟了`BankTransaction`的选择标准概念。现在你可以重构`findTransactions()`方法来使用它，如[示例 3-5](#findTransactions_ocp)所示。这种重构非常重要，因为现在你已经通过这个接口引入了一种将迭代逻辑与业务逻辑解耦的方式。你的方法不再依赖于一个特定的过滤器实现。你可以通过将它们作为参数传递来引入新的实现，而无需修改此方法的主体。因此，它现在可以进行扩展而关闭修改。这减少了引入新错误的可能性，因为它最小化了对已实施和测试代码部分所需的级联更改。换句话说，旧代码仍然可以正常工作且未被改动。'
- en: Example 3-5\. Flexible findTransactions() method using Open/Closed Principle
  id: totrans-37
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-5\. 使用开闭原则灵活的findTransactions()方法
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Creating an Instance of a Functional Interface
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建函数式接口的实例
- en: Mark Erbergzuck is now happy as you can implement any new requirements by calling
    the method `findTransactions()` declared in the `BankTransactionProcessor` with
    appropriate implementations of a `BankTransactionFilter`. You can achieve this
    by implementing a class as shown in [Example 3-6](#transaction_filter_class) and
    then passing an instance as argument to the `findTransactions()` method as shown
    in [Example 3-7](#findTransactions_impl_class).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Mark Erbergzuck很高兴，因为您可以通过调用`BankTransactionProcessor`中声明的`findTransactions()`方法来实现任何新的需求，并使用`BankTransactionFilter`的适当实现。您可以通过实现一个类来实现这一点，如[示例 3-6](#transaction_filter_class)所示，然后将一个实例作为参数传递给`findTransactions()`方法，如[示例 3-7](#findTransactions_impl_class)所示。
- en: Example 3-6\. Declaring a class that implements the BankTransactionFilter
  id: totrans-41
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-6\. 声明实现 BankTransactionFilter 的类
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Example 3-7\. Calling findTransactions() with a specific implementation of BankTransactionFilter
  id: totrans-43
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-7\. 使用特定的 BankTransactionFilter 实现调用 findTransactions()
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Lambda Expressions
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lambda 表达式
- en: However, you’d need to create special classes every time you have a new requirement.
    This process can add unnecessary boilerplate and can rapidly become cumbersome.
    Since Java 8, you can use a feature called *lambda expressions* as shown in [Example 3-8](#findTransactions_impl_lambda).
    Don’t worry about this syntax and language feature for the time being. We will
    learn about lambda expressions and a companion language feature called *method
    references* in more detail in [Chapter 7](ch07.xhtml#chapter_07). For now, you
    can think of it as instead of passing in an object that implements an interface,
    we’re passing in a block of code—a function without a name. `bankTransaction`
    is the name of a parameter and the arrow `->` separates the parameter from the
    body of the lambda expression, which is just some code that is run to test whether
    or not the bank transaction should be selected.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，每当有新需求时，你需要创建特殊的类。这个过程可能会增加不必要的样板代码，并且可能会迅速变得繁琐。自 Java 8 以来，你可以使用一个称为 *lambda
    表达式* 的功能，如 [示例 3-8](#findTransactions_impl_lambda) 所示。暂时不要担心这个语法和语言特性。我们将在第 7
    章更详细地学习 lambda 表达式以及一个称为 *方法引用* 的伴随语言特性。现在，你可以将它看作是，我们不是传递实现接口的对象，而是传递一个代码块——一个没有名称的函数。`bankTransaction`
    是一个参数的名称，箭头 `->` 分隔参数和 lambda 表达式的主体，这只是一些代码，用于测试是否应选择银行交易。
- en: Example 3-8\. Implementing BankTransactionFilter using a lambda expression
  id: totrans-47
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-8\. 使用 lambda 表达式实现 BankTransactionFilter
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To summarize, the Open/Closed Principle is a useful principle to follow because
    it:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，开闭原则是一个有用的原则，因为它：
- en: Reduces fragility of code by not changing existing code
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过不更改现有代码来减少代码的脆弱性
- en: Promotes reusability of existing code and as a result avoids code duplication
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 促进现有代码的重复使用，从而避免代码重复
- en: Promotes decoupling, which leads to better code maintenance
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 促进解耦，从而实现更好的代码维护
- en: Interfaces Gotchas
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口的注意事项
- en: 'So far you introduced a flexible method to search for transactions given a
    selection criterion. The refactoring you went through raises questions about what
    should happen to the other methods declared inside the `BankTransactionProcessor`
    class. Should they be part of an interface? Should they be included in a separate
    class? After all, there are three other related methods you implemented in the
    previous chapter:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你引入了一种灵活的方法来搜索给定选择条件的交易。你经历的重构引发了一个问题，即应该发生什么事情，关于在 `BankTransactionProcessor`
    类中声明的其他方法。它们应该是接口的一部分吗？它们应该包含在一个单独的类中吗？毕竟，在前一章中你实现了另外三个相关方法：
- en: '`calculateTotalAmount()`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calculateTotalAmount()`'
- en: '`calculateTotalInMonth()`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calculateTotalInMonth()`'
- en: '`calculateTotalForCategory()`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calculateTotalForCategory()`'
- en: 'One approach that we discourage you to put in practice is to put everything
    into one single interface: the God Interface.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不建议你采用的一种方法是将所有东西放入一个单一的接口：上帝接口。
- en: God Interface
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上帝接口
- en: One extreme view you could take is that the class `BankTransactionProcessor`
    acts as an API. As a result, you may wish to define an interface that lets you
    decouple from multiple implementations of a bank transaction processor as shown
    in [Example 3-9](#giant_interface_processor). This interface contains all the
    operations that the bank transaction processor needs to implement.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以采取的一个极端观点是，`BankTransactionProcessor` 类充当 API。因此，你可能希望定义一个接口，让你能够解耦来自银行交易处理器的多个实现，如
    [示例 3-9](#giant_interface_processor) 所示。这个接口包含了银行交易处理器需要实现的所有操作。
- en: Example 3-9\. God Interface
  id: totrans-61
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-9\. 上帝接口
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'However, this approach displays several downsides. First, this interface becomes
    increasingly complex as every single helper operation is an integral part of the
    explicit API definition. Second, this interface acts more like a “God Class” as
    you saw in the previous chapter. In fact, the interface has now become a bag for
    all possible operations. Worse, you are actually introducing two forms of additional
    coupling:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法显示了几个缺点。首先，随着每一个帮助操作成为显式 API 定义的一个组成部分，这个接口变得越来越复杂。其次，正如你在前一章中看到的，这个接口更像是一个“上帝类”。事实上，这个接口现在已经变成了一个包含所有可能操作的容器。更糟糕的是，你实际上引入了两种额外的耦合形式：
- en: An interface in Java defines a contract that every single implementation has
    to adhere by. In other words, concrete implementations of this interface have
    to provide an implementation for each operation. This means that changing the
    interface means all concrete implementations have to be updated as well to support
    the change. The more operations you add, the more likely changes will happen,
    increasing the scope for potential problems down the line.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Java中，接口定义了每个单独实现必须遵守的契约。换句话说，这个接口的具体实现必须为每个操作提供实现。这意味着改变接口意味着所有具体实现也必须更新以支持这种变化。您添加的操作越多，可能发生的更改就越多，从而增加潜在问题的范围。
- en: Concrete properties of a `BankTransaction` such as the month and the category
    have cropped up as part of method names; e.g., `calculateAverageForCategory()`
    and `calculateTotalInJanuary()`. This is more problematic with interfaces as they
    now depend on specific accessors of a domain object. If the internals of that
    domain object change, then this may cause changes to the interface as well and,
    as a consequence, to all its concrete implementations, too.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BankTransaction`的具体属性，如月份和类别，已经成为方法名的一部分；例如，`calculateAverageForCategory()`和`calculateTotalInJanuary()`。这在接口中更加棘手，因为它们现在依赖于域对象的特定访问器。如果域对象的内部发生变化，那么这也可能导致接口以及所有具体实现的更改。'
- en: All these reasons are why it is generally recommended to define smaller interfaces.
    The idea is to minimize dependency to multiple operations or internals of a domain
    object.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些原因都是为什么通常建议定义更小的接口。其思想是最小化对域对象多个操作或内部的依赖。
- en: Too Granular
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过于细粒度
- en: Since we’ve just argued that smaller is better, the other extreme view you could
    take is to define one interface for each operation, as shown in [Example 3-10](#too_granular_interfaces).
    Your `BankTransactionProcessor` class would implement all these interfaces.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们刚刚论证过越小越好，您可以采取的另一个极端观点是为每个操作定义一个接口，如[示例 3-10](#too_granular_interfaces)所示。您的`BankTransactionProcessor`类将实现所有这些接口。
- en: Example 3-10\. Interfaces that are too granular
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-10\. 接口过于细粒度
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This approach is also not useful for improving code maintenance. In fact, it
    introduces “anti-cohesion.” In other words, it becomes harder to discover the
    operations of interest as they are hiding in multiple separate interfaces. Part
    of promoting good maintenance is to help discoverability of common operations.
    In addition, because the interfaces are too granular it adds overall complexity,
    as well as a lot of different new types introduced by the new interfaces to keep
    track of in your project.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法也不利于改善代码的维护性。实际上，它引入了“反凝聚性”。换句话说，很难发现感兴趣的操作，因为它们隐藏在多个单独的接口中。促进良好的维护的一部分是帮助发现常见操作的可发现性。此外，由于接口过于细粒度，它增加了总体复杂性，并且在项目中引入了许多不同的新类型，需要跟踪。
- en: Explicit Versus Implicit API
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显式与隐式API
- en: So what is the pragmatic approach to take? We recommend following the Open/Closed
    Principle to add flexibility to your operations and define the most common cases
    as part of the class. They can be implemented with the more general methods. In
    this scenario, an interface is not particularly warranted as we don’t expect different
    implementations of a `BankTransactionProcessor`. There aren’t specializations
    of each of these methods that will benefit your overall application. As a result,
    there’s no need to over-engineer and add unnecessary abstractions in your codebase.
    The `BankTransactionProcessor` is simply a class that lets you perform statistical
    operations on bank transactions.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 那么采取实用主义的方法是什么？我们建议遵循开闭原则以增加操作的灵活性，并将最常见的情况定义为类的一部分。它们可以用更一般的方法实现。在这种情况下，接口并不特别适用，因为我们不期望`BankTransactionProcessor`有不同的实现。每个这些方法的特殊化并不会使您的整体应用程序受益。因此，在代码库中不需要过度工程化和添加不必要的抽象。`BankTransactionProcessor`只是一个允许您对银行交易执行统计操作的类。
- en: This also raises the question of whether methods such as `findTransactionsGreaterThanEqual()`
    should be declared given that they can easily be implemented by the more general
    `findTransactions()` method. This dilemma is often referred to as the problem
    of providing an explicit versus implicit API.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这也引发了一个问题，即是否应该声明诸如`findTransactionsGreaterThanEqual()`这样的方法，因为这些方法可以很容易地由更通用的`findTransactions()`方法实现。这种困境通常被称为显式与隐式API的问题。
- en: In fact, there are two sides of the coin to consider. On one side a method like
    `findTransactionsGreaterThanEqual()` is self-explanatory and easy to use. You
    should not be worried about adding descriptive method names to help readability
    and comprehension of your API. However, this method is restricted to a particular
    case and you can easily have an explosion of new methods to cater for various
    multiple requirements. On the other side, a method like `findTransactions()` is
    initially more difficult to use and it needs to be well-documented. However, it
    provides a unified API for all cases where you need to look up transactions. There
    isn’t a rule of what is best; it depends on what kind of queries you expect. If
    `findTransactionsGreaterThanEqual()` is a very common operation, it makes sense
    to extract it into an explicit API to make it easier for users to understand and
    use.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，有两面考虑的硬币。一方面，像`findTransactionsGreaterThanEqual()`这样的方法是不言自明且易于使用的。你不应该担心添加描述性方法名称以帮助提高API的可读性和理解性。然而，这种方法限制于特定情况，你很容易会出现为多种需求而创建大量新方法的情况。另一方面，像`findTransactions()`这样的方法起初更难使用，需要有良好的文档支持。但它为所有需要查找交易的情况提供了统一的API。没有一种最佳规则；这取决于你期望的查询类型。如果`findTransactionsGreaterThanEqual()`是一个非常常见的操作，将其提取为显式API可以让用户更容易理解和使用。
- en: The final implementation of the `BankTransactionProcessor` is shown in [Example 3-11](#final_bank_transaction_processor).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的`BankTransactionProcessor`的实现如[示例 3-11](#final_bank_transaction_processor)所示。
- en: Example 3-11\. Key operations for the BankTransactionProcessor class
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-11\. `BankTransactionProcessor`类的关键操作
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-79
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'A lot of the aggregation patterns that you have seen so far could be implemented
    using the Streams API introduced in Java 8 if you are familiar with it. For example,
    searching for transactions can be easily specified as shown here:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你所见过的许多聚合模式都可以利用Java 8引入的Streams API来实现，如果你对此熟悉的话。例如，搜索交易可以轻松地指定如下所示：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Nonetheless, the Streams API is implemented using the same foundation and principles
    that you’ve learned in this section.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，Streams API是使用本节中学到的相同基础和原则实现的。
- en: Domain Class or Primitive Value?
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 域类还是原始值？
- en: While we kept the interface definition of `BankTransactionSummarizer` simple,
    it is often preferable to not return a primitive value like a `double` if you
    are looking at returning a result from an aggregation. This is because it doesn’t
    give you the flexibility to later return multiple results. For example, the method
    `summarizeTransaction()` returns a `double`. If you were to change the signature
    of the result to include more results, you would need to change every single implementation
    of the `BankTransactionProcessor`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们保持了`BankTransactionSummarizer`接口定义的简单性，但如果你希望从聚合中返回结果，最好不要返回像`double`这样的原始值。这是因为它不能灵活地在以后返回多个结果。例如，`summarizeTransaction()`方法返回一个`double`。如果你要修改结果签名以包含更多结果，你需要修改每一个`BankTransactionProcessor`的实现。
- en: A solution to this problem is to introduce a new domain class such as `Summary`
    that wraps the `double` value. This means that in the future you can add other
    fields and results to this class. This technique helps further decouple the various
    concepts in your domain and also helps minimize cascading changes when requirements
    change.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一个方法是引入一个新的域类，比如`Summary`，它包装了`double`值。这意味着将来你可以向这个类添加其他字段和结果。这种技术有助于进一步解耦你域中的各种概念，并在需求变化时帮助最小化级联变化。
- en: Note
  id: totrans-86
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A primitive `double` value has a limited number of bits, and as a result it
    has limited precision when storing decimal numbers. An alternative to consider
    is `java.math.BigDecimal`, which has arbitrary precision. However, this precision
    comes at the cost of increased CPU and memory overhead.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的`double`值在存储小数时具有有限的精度。因为有限的位数限制了其精度。考虑的替代方案是`java.math.BigDecimal`，它具有任意精度。然而，这种精度是以增加的CPU和内存开销为代价的。
- en: Multiple Exporters
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多个导出器
- en: In the previous section you learned about the Open/Closed Principle and delved
    further into the usage of interfaces in Java. This knowledge is going to come
    handy as Mark Erbergzuck has a new requirement! You need to export summary statistics
    about a selected list of transactions into different formats including text, HTML,
    JSON, and so on. Where to start?
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，你了解了开闭原则以及在Java中接口的使用。随着Mark Erbergzuck有了新的需求，这些知识将会派上用场！你需要导出所选交易列表的摘要统计信息，包括文本、HTML、JSON等不同格式。从哪里开始？
- en: Introducing a Domain Object
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引入一个领域对象
- en: 'First, you need to define exactly what is it the user wants to export. There
    are various possibilities, which we explore together with their trade-offs:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要明确用户想要导出的内容。我们一起探讨各种可能性及其权衡：
- en: A number
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一个数字
- en: Perhaps the user is just interested in returning the result of an operation
    like `calculateAverageInMonth`. This means the result would be a `double`. While
    this is the most simple approach, as we noted earlier, this approach is somewhat
    inflexible as it doesn’t cope well with changing requirements. Imagine you create
    an exporter which takes the `double` as an input, this means that every places
    in your code that calls this exporter will need to be updated if you need to change
    the result type, possibly introducing new bugs.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 也许用户只对返回操作结果感兴趣，例如`calculateAverageInMonth`。这意味着结果将是一个`double`。虽然这是最简单的方法，但正如我们之前提到的，这种方法在应对变化的需求时有些不灵活。假设你创建了一个接受`double`作为输入的导出器，这意味着你代码中调用此导出器的每个地方都需要更新，可能会引入新的错误。
- en: A collection
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一个集合
- en: Perhaps the user wishes to return a list of transactions, for example, returned
    by `findTransaction()`. You could even return an `Iterable` to provide further
    flexibility in what specific implementation is returned. While this gives you
    more flexibility it also ties you to only being able to return a collection. What
    if you need to return multiple results such as a list and other summary information?
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 也许用户希望返回一个交易列表，例如，由`findTransaction()`返回的。甚至可以返回一个`Iterable`，以提供更多灵活性，指定返回的具体实现。虽然这给了你更多的灵活性，但也将你限制在只能返回一个集合上。如果需要返回多个结果，例如列表和其他摘要信息，该怎么办？
- en: A specialized domain object
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一个专门的领域对象
- en: You could introduce a new concept such as `SummaryStatistics` which represents
    summary information that the user is interested in exporting. A *domain object*
    is simply an instance of a class that is related to your domain. By introducing
    a domain object, you introduce a form of decoupling. In fact, if there are new
    requirements where you need to export additional information, you can just include
    it as part of this new class without having to introduce cascading changes.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以引入一个新概念，例如`SummaryStatistics`，它代表用户有兴趣导出的摘要信息。*领域对象*只是与你的领域相关的类的实例。通过引入领域对象，你引入了一种解耦形式。实际上，如果有新的需求需要导出额外信息，你可以将其包含为此新类的一部分，而无需引入级联更改。
- en: A more complex domain object
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更复杂的领域对象
- en: You could introduce a concept such as `Report` which is more generic and could
    contain different kinds of fields storing various results including collection
    of transactions. Whether you need this or not depends on the user requirements
    and whether you are expecting more complex information. The benefit again is that
    you are able to decouple different parts of your applications that produce `Report`
    objects and other parts that consume `Report` objects.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以引入一个称为`Report`的概念，它更通用，可以包含各种字段，存储各种结果，包括交易集合。是否需要这样做取决于用户的需求以及是否预期更复杂的信息。再次的好处在于，你能够将生成`Report`对象的应用程序的不同部分与消费`Report`对象的其他部分解耦。
- en: For the purpose of our application, let’s introduce a domain object that stores
    summary statistics about a list of transactions. The code in [Example 3-12](#summmary_statistics_object)
    shows its declaration.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用程序而言，让我们引入一个领域对象，该对象存储关于交易列表的摘要统计信息。[示例 3-12](#summmary_statistics_object)
    中的代码显示了其声明。
- en: Example 3-12\. A domain object storing statistical information
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-12\. 存储统计信息的领域对象
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Defining and Implementing the Appropriate Interface
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义和实现适当的接口
- en: Now that you know what you need to export, you will come up with an API to do
    it. You will need to define an interface called `Exporter`. The reason you introduce
    an interface is to let you decouple from multiple implementations of exporters.
    This goes in line with the Open/Closed Principle you learned in the previous section.
    In fact, if you need to substitute the implementation of an exporter to JSON with
    an exporter to XML this will be straightforward given they will both implement
    the same interface. Your first attempt at defining the interface may be as shown
    in [Example 3-13](#exporter_void). The method `export()` takes a `SummaryStatistics`
    object and returns `void`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道需要导出什么，你将会设计一个API来完成它。你需要定义一个名为`Exporter`的接口。引入接口的原因是让你能够与多个导出器实现解耦。这符合你在前一节学到的开闭原则。事实上，如果你需要将导出器的实现从JSON替换为XML，这将非常简单，因为它们都将实现相同的接口。你首次尝试定义接口的方法可能如[示例 3-13](#exporter_void)所示。方法`export()`接受一个`SummaryStatistics`对象并返回`void`。
- en: Example 3-13\. Bad Exporter interface
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-13\. 不良的导出器接口
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This approach is to be avoided for several reasons:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 几个原因应避免这种方法：
- en: The return type `void` is not useful and is difficult to reason about. You don’t
    know what is returned. The signature of the `export()` method implies that some
    state change is happening somewhere or that this method will log or print information
    back to the screen. We don’t know!
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回类型`void`毫无用处，也很难理解。我们不知道返回了什么。`export()`方法的签名暗示着在某个地方发生了状态改变，或者这个方法将日志记录或信息打印回屏幕。我们不知道！
- en: Returning `void` makes it very hard to test the result with assertions. What
    is the actual result to compare with the expected result? Unfortunately, you can’t
    get a result with `void`.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回`void`使得使用断言来测试结果非常困难。实际的结果是什么可以与预期结果进行比较？不幸的是，你无法获取`void`的结果。
- en: With this in mind, you come up with an alternative API that returns a `String`,
    as shown in [Example 3-14](#exporter_string). It is now clear that the `Exporter`
    will return text and it’s then up to a separate part of the program to decide
    whether to print it, save it to a file, or even send it electronically. Text strings
    are also very useful for testing as you can directly compare them with assertions.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个基础上，你提出了一个返回`String`的替代API，如[示例 3-14](#exporter_string)所示。现在很明确，`Exporter`将返回文本，然后由程序的另一部分决定是否打印、保存到文件，甚至电子发送。文本字符串在测试中也非常有用，因为你可以直接与断言进行比较。
- en: Example 3-14\. Good Exporter interface
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-14\. 良好的导出器接口
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now that you have defined an API to export information, you can implement various
    kinds of exporters that respect the contract of the `Exporter` interface. You
    can see an example of implementing a basic HTML exporter in [Example 3-15](#exporter_impl).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经定义了一个导出信息的API，你可以实现各种遵循`Exporter`接口契约的导出器。你可以看到在[示例 3-15](#exporter_impl)中实现了一个基本的HTML导出器的示例。
- en: Example 3-15\. Implementing the Exporter interface
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-15\. 实现导出器接口
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Exception Handling
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常处理
- en: 'So far we’ve not talked about what happens when things go wrong. Can you think
    of situations where the bank analyzer software might fail? For example:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有讨论当事情出错时会发生什么。你能想到银行分析软件可能失败的情况吗？例如：
- en: What if the data cannot be parsed properly?
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果数据无法正确解析会怎么样？
- en: What if the CSV file containing the bank transctions to import can’t be read?
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果无法读取包含要导入的银行交易的CSV文件会怎么样？
- en: What if the hardware running your applications runs out of resources such as
    RAM or disk space?
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果运行应用程序的硬件资源，如RAM或磁盘空间，不足会怎么样？
- en: In these scenarios you will be welcomed with a scary error message that includes
    a stack trace showing the origin of the problem. The snippets in [Example 3-16](#unexpected_problems)
    show examples of these unexpected errors.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些场景中，你将会收到一个包含堆栈跟踪显示问题来源的可怕错误消息。[示例 3-16](#unexpected_problems)中的片段展示了这些意外错误的示例。
- en: Example 3-16\. Unexpected problems
  id: totrans-122
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-16\. 意外问题
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Why Use Exceptions?
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么要使用异常？
- en: 'Let’s focus on the `BankStatementCSVParser` for the moment. How do we handle
    parsing problems? For example, a CSV line in the file might not be written in
    the expected format:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时专注于`BankStatementCSVParser`。我们如何处理解析问题？例如，文件中的CSV行可能没有按预期格式编写：
- en: A CSV line may have more than the expected three columns.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSV行可能比预期的三列多。
- en: A CSV line may have fewer than the expected three columns.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSV行可能少于预期的三列。
- en: The data format of some of the columns may not be correct, e.g., the date may
    be incorrect.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些列的数据格式可能不正确，例如，日期可能是不正确的。
- en: Back in the frightening days of the C programming language, you would add a
    lot of if-condition checks that would return a cryptic error code. This approach
    had several drawbacks. First, it relied on global shared mutable state to look
    up the most recent error. This made it harder to understand individual parts of
    your code in isolation. As a result, your code became harder to maintain. Second,
    this approach was error prone as you needed to distinguish between real values
    and errors encoded as values. The type system in this case was weak and could
    be more helpful to the programmer. Finally, the control flow was mixed with the
    business logic, which contributed to making the code harder to maintain and test
    in isolation.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 回到C编程语言令人恐惧的日子，您将添加许多if条件检查，这些检查将返回一个神秘的错误代码。这种方法有几个缺点。首先，它依赖全局共享的可变状态来查找最近的错误。这使得更难以理解代码中单独的部分。因此，您的代码变得更难维护。其次，这种方法容易出错，因为您需要区分作为值编码的真实值和错误。在这种情况下，类型系统是薄弱的，对程序员不够友好。最后，控制流与业务逻辑混合在一起，这导致代码更难维护和独立测试。
- en: 'To solve these issues, Java incorporated exceptions as a first-class language
    feature that introduced many benefits:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些问题，Java将异常作为一流语言特性引入，带来了许多好处：
- en: Documentation
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 文档
- en: The language supports exceptions as part of method signatures.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 语言支持异常作为方法签名的一部分。
- en: Type safety
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 类型安全性
- en: The type system figures out whether you are handling the exceptional flow.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 类型系统确定您是否处理了异常流。
- en: Separation of concern
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 关注点分离
- en: Business logic and exception recovery are separated out with a try/catch block.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 业务逻辑和异常恢复通过try/catch块分开。
- en: 'The problem is that exceptions as a language feature also add more complexity.
    You may be familiar with the fact that Java distinguishes between two kinds of
    exceptions:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于作为语言特性的异常也增加了更多的复杂性。您可能熟悉Java区分两种异常的事实：
- en: Checked exceptions
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 已检查的异常
- en: These are errors that you are expected to be able to recover from. In Java,
    you have to declare a method with a list of checked exceptions it can throw. If
    not, you have to provide a suitable try/catch block for that particular exception.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是预期能够从中恢复的错误。在Java中，您必须声明一个方法及其可以抛出的已检查异常列表。如果没有，您必须为该特定异常提供合适的try/catch块。
- en: Unchecked exceptions
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 未检查的异常
- en: These are errors that can be thrown at any time during the program execution.
    Methods don’t have to explicitly declare these exceptions in their signature and
    the caller doesn’t have to handle them explicitly, as it would with a checked
    exception.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是在程序执行期间可以随时抛出的错误。方法不必在其签名中显式声明这些异常，并且调用者不必像处理已检查异常那样显式处理它们。
- en: Java exception classes are organized in a well-defined hierarchy. [Figure 3-1](#exceptions_hiearchy)
    depicts that hierarchy in Java. The `Error` and `RuntimeException` classes are
    unchecked exceptions and are subclasses of `Throwable`. You shouldn’t expect to
    catch and recover from them. The class `Exception` typically represents errors
    that a program should be able to recover from.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Java异常类按照明确定义的层次结构进行组织。 [图 3-1](#exceptions_hiearchy) 描绘了Java中的这种层次结构。 `Error`
    和 `RuntimeException` 类是未经检查的异常，并且是 `Throwable` 的子类。您不应该期望捕获并从中恢复。类 `Exception`
    通常表示程序应该能够从中恢复的错误。
- en: '![Exceptions Hiearchy in Java](Images/rwsd_0301.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![Java中的异常层次结构](Images/rwsd_0301.png)'
- en: Figure 3-1\. Exceptions hierarchy in Java
  id: totrans-144
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-1\. Java中的异常层次结构
- en: Patterns and Anti-Patterns with Exceptions
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常的模式和反模式
- en: Which category of exceptions should you use under what scenario? You may also
    wonder how should you update the `BankStatementParser` API to support exceptions.
    Unfortunately, there isn’t a simple answer. It requires a bit of pragmatism when
    deciding what is the right approach for you.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在什么场景下应该使用哪类异常？您可能还想知道应该如何更新`BankStatementParser` API以支持异常。不幸的是，这并没有简单的答案。在决定适合您的正确方法时，需要一些实用主义。
- en: 'There are two separate concerns when thinking about parsing the CSV file:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在解析CSV文件时，有两个独立的关注点：
- en: Parsing the right syntax (e.g., CSV, JSON)
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析正确的语法（例如，CSV，JSON）
- en: Validation of the data (e.g., text description should be less than 100 characters)
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据的验证（例如，文本描述应少于100个字符）
- en: You will focus on the syntax error first and then the validation of the data.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 首先关注语法错误，然后是数据的验证。
- en: Deciding between unchecked and checked
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在未检查和已检查之间做出决定
- en: There are situations when the CSV file may not follow the correct syntax (for
    example, if separating commas are missing). Ignoring this problem will lead to
    confusing errors when the application runs. Part of the benefit of supporting
    exceptions in your code is to provide a clearer diagnosis to the user of your
    API in the event that a problem arises. Accordingly, you decide to add a simple
    check as shown in the code in [Example 3-17](#csv_exception), which throws a `CSVSyntaxException`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 有些情况下，CSV 文件可能不符合正确的语法（例如，缺少分隔逗号）。忽略这个问题将导致应用程序运行时出现混乱的错误。支持在代码中使用异常的部分好处之一是在问题出现时为
    API 用户提供更清晰的诊断。因此，您决定添加如下示例代码中所示的简单检查，在 [示例 3-17](#csv_exception) 中抛出 `CSVSyntaxException`
    异常。
- en: Example 3-17\. Throwing a syntax exception
  id: totrans-153
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-17\. 抛出语法异常
- en: '[PRE17]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Should `CSVSyntaxException` be a checked or an unchecked exception? To answer
    this question you need to ask yourself whether you require the user of your API
    to take a compulsory recovery action. For example, the user may implement a retry
    mechanism if it is a transient error or she may display a message back on the
    screen to add graceful responsiveness to the application. Typically, errors due
    to business logic validation (e.g., wrong format or arithmetic) should be unchecked
    exceptions, as they would add a lot of try/catch clutter in your code. It may
    also not be obvious what the right recovery mechanism is. Consequently, there’s
    no point enforcing it on the user of your API. In addition, system errors (e.g.,
    disk ran out of space) should also be unchecked exceptions as there’s nothing
    the client can do. In a nutshell, the recommendation is to use unchecked exceptions
    and only use checked exceptions sparingly to avoid significant clutter in the
    code.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`CSVSyntaxException` 应该是已检查异常还是未检查异常？要回答这个问题，您需要问自己是否需要用户采取强制性的恢复操作。例如，如果是瞬态错误，用户可以实现重试机制；或者在屏幕上显示消息以增加应用程序的响应性。通常，由于业务逻辑验证错误（例如，错误格式或算术错误），应该使用未检查异常，因为它们会在代码中增加大量的
    try/catch 代码。恢复机制也可能不明显。因此，在您的 API 用户身上施加这些是没有意义的。此外，系统错误（例如，磁盘空间不足）也应该是未检查异常，因为客户端无能为力。简而言之，建议是尽量使用未检查异常，仅在必要时使用已检查异常，以避免代码中的显著混乱。'
- en: Let’s now tackle the problem of validating the data once you know it follows
    the correct CSV format. You will learn about two common anti-patterns with using
    exceptions for validation. Then, you will learn about the Notification pattern,
    which provides a maintainable solution to the problem.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们解决一下当你知道数据遵循正确的 CSV 格式后如何验证数据的问题。你将学习使用异常进行验证时的两种常见反模式。然后，你将学习通知模式，它为这个问题提供了一个可维护的解决方案。
- en: Overly specific
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 过于具体
- en: 'The first question going through your mind is where should you add validation
    logic? You could have it right at the construction time of the `BankStatement`
    object. However, we recommend creating a dedicated `Validator` class for several
    reasons:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个浮现在你脑海中的问题是在哪里添加验证逻辑？你可以在 `BankStatement` 对象的构建时直接添加。然而，我们建议为此创建一个专门的 `Validator`
    类，有几个理由：
- en: You don’t have to duplicate the validation logic when you need to reuse it.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当需要重用验证逻辑时，您无需重复编写它。
- en: You get confidence that different parts of your system validate the same way.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以确信系统的不同部分以相同的方式进行验证。
- en: You can easily unit test this logic separately.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以轻松地单独对这个逻辑进行单元测试。
- en: It follows the SRP, which leads to simpler maintenance and program comprehension.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它遵循 SRP 原则，这导致了更简单的维护和程序理解。
- en: The are various approaches to implementing your validator using exceptions.
    One overly specific approach is shown in [Example 3-18](#overlyspecific_exception).
    You have thought of every single edge case to validate the input and converted
    each edge case into a checked exception. The exceptions `DescriptionTooLongException`,
    `InvalidDateFormat`, `DateInTheFutureException`, and `InvalidAmountException`
    are all user-defined checked exceptions (i.e., they extend the class `Exception`).
    While this approach lets you specify precise recovery mechanisms for each exception,
    it is clearly unproductive as it requires a lot of setup, declares multiple exceptions,
    and forces the user to explicitly deal with each of these exceptions. This is
    doing the opposite of helping the user understand and simply use your API. In
    addition, you can’t collect all the errors as a whole in case you want to provide
    a list to the user.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法来使用异常来实现您的验证器。一个过于具体的方法示例在[示例 3-18](#overlyspecific_exception)中展示。您已经考虑了每一个边缘情况来验证输入，并将每个边缘情况转换为一个已检查的异常。异常`DescriptionTooLongException`、`InvalidDateFormat`、`DateInTheFutureException`和`InvalidAmountException`都是用户定义的已检查异常（即它们扩展了类`Exception`）。尽管这种方法允许您为每个异常指定精确的恢复机制，但显然这是低效的，因为它需要大量设置，声明多个异常，并强制用户明确处理每一个异常。这与帮助用户理解和简单使用您的
    API 的初衷背道而驰。此外，您不能将所有错误作为整体收集起来以便向用户提供列表。
- en: Example 3-18\. Overly specific exceptions
  id: totrans-164
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-18\. 过于具体的异常
- en: '[PRE18]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Overly apathetic
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 过于冷漠
- en: The other end of the spectrum is making everything an unchecked exception; for
    example, by using `IllegalArgumentException`. The code in [Example 3-19](#illegal_exception)
    shows the implementation of the `validate()` method following this approach. The
    problem with this approach is that you can’t have specific recovery logic because
    all the exceptions are the same! In addition, you still can’t collect all the
    errors as a whole.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种极端是将所有东西作为未检查异常处理；例如，通过使用`IllegalArgumentException`。[示例 3-19](#illegal_exception)中的代码展示了遵循此方法实现的`validate()`方法。这种方法的问题在于您无法有特定的恢复逻辑，因为所有异常都是相同的！此外，您仍然无法将所有错误作为整体收集起来。
- en: Example 3-19\. IllegalArgument exceptions everywhere
  id: totrans-168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-19\. 到处都是 IllegalArgumentException 异常
- en: '[PRE19]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Next, you will learn about the Notification pattern, which provides a solution
    to the downsides highlighted with the overly specific and overly apathetic anti-patterns.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将学习通知模式，该模式提供了解决过于具体和过于冷漠反模式所突出的缺点的解决方案。
- en: Notification Pattern
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通知模式
- en: The Notification pattern aims to provide a solution for the situation in which
    you are using too many unchecked exceptions. The solution is to introduce a domain
    class to collect errors.^([1](ch03.xhtml#idm45816831226440))
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 通知模式旨在为您使用过多未检查异常的情况提供解决方案。解决方案是引入一个域类来收集错误。^([1](ch03.xhtml#idm45816831226440))
- en: The first thing you need is a `Notification` class whose responsibility is to
    collect errors. The code in [Example 3-20](#notification_declaration) shows its
    declaration.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 您首先需要一个`Notification`类，其责任是收集错误。[示例 3-20](#notification_declaration)中的代码展示了其声明。
- en: Example 3-20\. Introducing the domain class Notification to collect errors
  id: totrans-174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-20\. 引入域类 Notification 来收集错误
- en: '[PRE20]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The benefit of introducing such a class is that you can now declare a validator
    that is able to collect multiple errors in one pass. This wasn’t possible in the
    two previous approaches you explored. Instead of throwing exceptions, you can
    now simply add messages into the `Notification` object as shown in [Example 3-21](#validator_notification).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 引入这样一个类的好处是，现在您可以声明一个能够在一次通过中收集多个错误的验证器。这在您之前探索的两种方法中是不可能的。现在，您可以简单地将消息添加到`Notification`对象中，如[示例 3-21](#validator_notification)所示。
- en: Example 3-21\. Notification pattern
  id: totrans-177
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-21\. 通知模式
- en: '[PRE21]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Guidelines for Using Exceptions
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用异常的指南
- en: Now that you’ve learned the situations for which you may use exceptions, let’s
    discuss some general guidelines to use them effectively in your application.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了可能使用异常的情况，让我们讨论一些通用准则，有效地在您的应用程序中使用它们。
- en: Do not ignore an exception
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不   不要忽略异常
- en: It’s never a good idea to ignore an exception as you won’t be able to diagnose
    the root of the problem. If there isn’t an obvious handling mechanism, then throw
    an unchecked exception instead. This way if you really need to handle the checked
    exception, you’ll be forced to come back and deal with it after seeing the problem
    at runtime.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略异常永远不是一个好主意，因为你将无法诊断问题的根源。 如果没有明显的处理机制，那么抛出未检查的异常。 这样，如果您确实需要处理已检查的异常，那么在运行时看到问题后，您将被迫返回并处理它。
- en: Do not catch the generic Exception
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不要捕获通用的 Exception
- en: Catch a specific exception as much as you can to improve readability and support
    more specific exception handling. If you catch the generic `Exception`, it also
    includes a `RuntimeException`. Some IDEs can generate a catch clause that is too
    general, so you may need to think about making the catch clause more specific.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能捕获特定的异常以提高可读性和支持更具体的异常处理。 如果捕获通用的`Exception`，它还包括`RuntimeException`。 一些 IDE
    可以生成过于一般化的捕获子句，因此您可能需要考虑使捕获子句更具体。
- en: Document exceptions
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 记录异常
- en: Document exceptions at your API-level including unchecked exceptions to facilitate
    troubleshooting. In fact, unchecked exceptions report the root of an issue that
    should be addressed. The code in [Example 3-22](#document_exception) shows an
    example of documenting exceptions using the `@throws` Javadoc syntax.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在 API 级别记录异常，包括未检查的异常，以便于故障排除。 实际上，未检查的异常报告应解决的问题的根本。 [示例 3-22](#document_exception)
    中的代码显示了使用`@throws` Javadoc 语法记录异常的示例。
- en: Example 3-22\. Documenting exceptions
  id: totrans-187
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-22\. 记录异常
- en: '[PRE22]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Watch out for implementation-specific exceptions
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意特定于实现的异常
- en: Do not throw implementation-specific exceptions as it breaks encapsulation of
    your API. For example, the definition of `read()` in [Example 3-23](#implementation_specific_exception)
    forces any future implementations to throw an `OracleException`, when clearly
    `read()` could support sources that are completely unrelated to Oracle!
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 不要抛出特定于实现的异常，因为它会破坏您 API 的封装性。 例如，在 [示例 3-23](#implementation_specific_exception)
    中的 `read()` 的定义迫使任何未来的实现在显然与 Oracle 完全无关的情况下抛出一个 `OracleException`！
- en: Example 3-23\. Avoid implementation-specific exceptions
  id: totrans-191
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-23\. 避免特定于实现的异常
- en: '[PRE23]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Exceptions versus Control flow
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异常与控制流的比较
- en: Do not use exceptions for control flow. The code in [Example 3-24](#flow_exception)
    exemplifies a bad use of exceptions in Java. The code relies on an exception to
    exit the reading loop.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 不要为控制流使用异常。 Java 中的 [示例 3-24](#flow_exception) 中的代码展示了异常的错误使用。 该代码依赖异常来退出读取循环。
- en: Example 3-24\. Using exceptions for control flow
  id: totrans-195
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-24\. 用于控制流的异常使用
- en: '[PRE24]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You should avoid this type of code for several reasons. First, it leads to poor
    code readability because the exception try/catch syntax adds unnecessary clutter.
    Second, it makes the intent of your code less comprehensible. Exceptions are meant
    as a feature to deal with errors and exceptional scenarios. Consequently, it’s
    good not to create an exception until you are sure that you need to throw it.
    Finally, there’s overhead associated with holding a stack trace in the event that
    an exception is thrown.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 几个理由应该避免此类代码。 首先，它会导致代码可读性差，因为异常 try/catch 语法会增加不必要的混乱。 其次，它使您代码的意图不太容易理解。 异常被设计为处理错误和异常情况的功能。
    因此，在确实需要抛出异常之前最好不要创建异常。 最后，与抛出异常相关的堆栈跟踪会带来额外开销。
- en: Alternatives to Exceptions
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常的替代方案
- en: You’ve learned about using exceptions in Java for the purpose of making your
    Bank Statements Analyzer more robust and comprehensible for your users. What are
    alternatives to exceptions, though? We briefly describe four alternative approaches
    together with their pros and cons.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经学习了在 Java 中使用异常以使您的银行对账单分析器更健壮和易理解。 然而，除了异常，有哪些替代方案呢？ 我们简要描述了四种替代方法及其优缺点。
- en: Using null
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 null
- en: Instead of throwing a specific exception, you may ask why you can’t just return
    `null` as shown in [Example 3-25](#exception_null).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 不要像抛出具体异常那样，你可以问为什么不能像在 [示例 3-25](#exception_null) 中显示的那样返回`null`。
- en: Example 3-25\. Returning null instead of an exception
  id: totrans-202
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-25\. 返回 null 而不是异常
- en: '[PRE25]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This approach is to be absolutely avoided. In fact, `null` provides no useful
    information to the caller. It is also error prone as you have to explicitly remember
    to check for `null` as a result of your API. In practice, this leads to many `NullPointerException`s
    and a lot of unnecessary debugging!
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 绝对要避免这种方法。事实上，`null` 对调用者毫无用处的信息。而且，由于 API 返回 `null`，这也很容易出错。实际上，这会导致许多 `NullPointerException`
    和大量不必要的调试！
- en: The Null Object pattern
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 空对象模式
- en: An approach you sometimes see adopted in Java is the *Null Object pattern*.
    In a nutshell, instead of returning a `null` reference to convey the absence of
    an object, you return an object that implements the expected interface but whose
    method bodies are empty. The advantage of this tactic is that you won’t deal with
    unexpected `NullPointer` exceptions and a long list of `null` checks. In fact,
    this empty object is very predictable because it does nothing functionally! Nonetheless,
    this pattern can also be problematic because you may hide potential issues in
    the data with an object that simply ignores the real problem, and as a result
    make troubleshooting more difficult.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，有时你会看到采用的一种 *空对象模式*。简而言之，与其返回一个 `null` 引用来表示对象的缺失，你可以返回一个实现了期望接口但方法体为空的对象。这种策略的优势在于，你不会遇到意外的
    `NullPointer` 异常以及一长串的 `null` 检查。事实上，这个空对象非常可预测，因为它在功能上什么也不做！然而，这种模式也可能存在问题，因为你可能会用一个简单忽略真正问题的对象隐藏数据潜在的问题，从而导致故障排除更加困难。
- en: Optional<T>
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Optional<T>
- en: Java 8 introduced a built-in data type `java.util.Optional<T>`, which is dedicated
    to representing the presence or absence of a value. The `Optional<T>` comes with
    a set of methods to explicitly deal with the absence of a value, which is useful
    to reduce the scope for bugs. It also allows you to compose various `Optional`
    objects together, which may be returned as a return type from different APIs you
    use. An example of that is the method `findAny()` in the Streams API. You will
    learn more about how you can use `Optional<T>` in [Chapter 7](ch07.xhtml#chapter_07).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8 引入了一个内置数据类型 `java.util.Optional<T>`，专门用于表示值的存在或缺失。`Optional<T>` 提供了一组方法来显式处理值的缺失，这对于减少错误的范围非常有用。它还允许你将各种
    `Optional` 对象组合在一起，这些对象可能作为不同 API 的返回类型返回。例如，在流 API 中的 `findAny()` 方法。你将在第 7 章学习如何在你的代码中使用
    `Optional<T>`。
- en: Try<T>
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Try<T>
- en: There’s another data type called `Try<T>`, which represents an operation that
    may succeed or fail. In a way it is analogous to `Optional<T>`, but instead of
    values you work with operations. In other words, the `Try<T>` data type brings
    similar code composability benefits and also helps reduce the scope for errors
    in your code. Unfortunately, the `Try<T>` data type is not built in to the JDK
    but is supported by external libraries that you can look at.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种数据类型叫做 `Try<T>`，它表示可能成功或失败的操作。在某种程度上，它类似于 `Optional<T>`，但不是处理值，而是处理操作。换句话说，`Try<T>`
    数据类型带来了类似的代码组合性好处，并且帮助减少代码中的错误。不幸的是，`Try<T>` 数据类型并没有内置到 JDK 中，而是由你可以查看的外部库支持。
- en: Using a Build Tool
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用构建工具
- en: So far you’ve learned good programming practices and principles. But what about
    structuring, building, and running your application? This section focuses on why
    using a build tool for your project is a necessity and how you can use a build
    tool such as Maven and Gradle to build and run your application in a predictable
    manner. In [Chapter 5](ch05.xhtml#chapter_05), you will learn more about a related
    topic of how to structure the application effectively using Java packages.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经学习了良好的编程实践和原则。但是关于如何构建、构造和运行你的应用程序呢？本节重点介绍为什么使用构建工具来管理你的项目是必要的，以及如何使用
    Maven 和 Gradle 等构建工具以可预测的方式构建和运行你的应用程序。在第 5 章，你将更多地了解如何有效地使用 Java 包来组织应用程序。
- en: Why Use a Build Tool?
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么使用构建工具？
- en: Let’s consider the problem of executing your application. There are several
    elements you need to take care of. First, once you have written the code for your
    project, you will need to compile it. To do this, you will have to use the Java
    compiler (javac). Do you remember all the commands required to compile multiple
    files? What about with multiple packages? What about managing dependencies if
    you were to import other Java libraries? What about if the project needs to be
    packaged in a specific format such as WAR or JAR? Suddenly things get messy, and
    more and more pressure is put on the developer.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑执行应用程序的问题。您需要注意几个要素。首先，一旦编写了项目的代码，您将需要编译它。为此，您将必须使用Java编译器（javac）。您记得编译多个文件所需的所有命令吗？对于多个包怎么办？如果需要导入其他Java库，如何管理依赖关系？如果项目需要以特定格式（如WAR或JAR）打包怎么办？突然间事情变得混乱起来，开发者面临越来越大的压力。
- en: To automate all the commands required, you will need to create a script so you
    don’t have to repeat the commands every time. Introducing a new script means that
    all your current and future teammates will need to be familiar with your way of
    thinking to be able to maintain and change the script as requirements evolve.
    Second, the software development life cycle needs to be taken into consideration.
    It’s not just about developing and compiling the code. What about testing and
    deploying it?
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为了自动化所有需要的命令，您需要创建一个脚本，这样您就不必每次重复命令。引入新脚本意味着所有当前和未来的队友都需要熟悉您的思维方式，以便在需求变化时维护和更改脚本。其次，需要考虑软件开发生命周期。这不仅仅是开发和编译代码。测试和部署如何处理呢？
- en: 'The solution to these problems is using a build tool. You can think of a build
    tool as an assistant that can automate the repetitive tasks in the software development
    life cycle, including building, testing, and deploying your application. A build
    tool has many benefits:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这些问题的方法是使用构建工具。您可以将构建工具视为助手，可以自动化软件开发生命周期中的重复任务，包括构建、测试和部署应用程序。构建工具有许多好处：
- en: It provides you with a common structure to think about a project so your colleagues
    feel immediately at home with the project.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它为您提供了一个通用的项目结构，使您的同事立即感到熟悉和舒适。
- en: It sets you up with a repeatable and standardized process to build and run an
    application.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它为您提供了一个可重复和标准化的过程来构建和运行应用程序。
- en: You spend more time on development, and less time on low-level configurations
    and setup.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您花费更多时间在开发上，而不是在低级配置和设置上。
- en: You are reducing the scope for introducing errors due to bad configurations
    or missing steps in the build.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您通过减少由于错误配置或缺少步骤而引入错误的范围。
- en: You save time by reusing common build tasks instead of reimplementing them.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过重用常见的构建任务而不是重新实现它们来节省时间。
- en: 'You will now explore two popular build tools used in the Java community: Maven
    and Gradle.^([2](ch03.xhtml#idm45816830413256))'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在将探索Java社区中使用的两个流行构建工具：Maven和Gradle。^([2](ch03.xhtml#idm45816830413256))
- en: Using Maven
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Maven
- en: Maven is highly popular in the Java community. It allows you to describe the
    build process for your software together with its dependencies. In addition, there’s
    a large community maintaining repositories that Maven can use to automatically
    download the libraries and dependencies used by your application. Maven was initially
    released in 2004 and as you might expect, XML was very popular back then! Consequently,
    the declaration of the build process in Maven is XML based.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Maven在Java社区中非常流行。它允许您描述软件的构建过程以及其依赖关系。此外，有一个大型社区在维护仓库，Maven可以使用这些仓库自动下载应用程序使用的库和依赖项。Maven最初发布于2004年，您可能会想到，那时候XML非常流行！因此，Maven中的构建过程声明是基于XML的。
- en: Project structure
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目结构
- en: 'The great thing about Maven is that from the get-go it comes with structure
    to help maintenance. A Maven project starts with two main folders:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Maven的伟大之处在于，从一开始它就带有帮助维护的结构。一个Maven项目始于两个主要文件夹：
- en: '`/src/main/java`'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`/src/main/java`'
- en: This is where you will develop and find all the Java classes required for your
    project.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您将开发和查找项目所需的所有Java类的地方。
- en: '`src/test/java`'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/test/java`'
- en: This where you will develop and find all the tests for your project.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您将开发和查找项目所有测试的地方。
- en: 'There are two additional folders that are useful but not required:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 还有两个有用但不是必需的附加文件夹：
- en: '`src/main/resources`'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/resources`'
- en: This is where you can include extra resources such as text files needed by your
    application.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这里您可以包含应用程序需要的额外资源，例如文本文件。
- en: '`src/test/resources`'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/test/resources`'
- en: This is where you can include extra resources used by your tests.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是您可以包含测试中使用的额外资源的地方。
- en: Having this common directory layout allows anyone familiar with Maven to be
    immediately able to locate important files. To specify the build process you will
    need to create a *pom.xml* file where you specify various XML declarations to
    document the steps required to build your application. [Figure 3-2](#maven_layout)
    summarizes the common Maven project layout.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有这种常见的目录布局使得任何熟悉 Maven 的人都能立即找到重要文件。为了指定构建过程，您需要创建一个 *pom.xml* 文件，在其中指定各种 XML
    声明以记录构建应用程序所需的步骤。[图 3-2](#maven_layout) 总结了常见的 Maven 项目布局。
- en: '![Maven Standard Directory Layout](Images/rwsd_0302.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![Maven 标准目录布局](Images/rwsd_0302.png)'
- en: Figure 3-2\. Maven standard directory layout
  id: totrans-238
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-2\. Maven 标准目录布局
- en: Example build file
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例构建文件
- en: 'The next step is to create the *pom.xml* that will dictate the build process.
    The code snippet in [Example 3-26](#maven_pom_simple) shows a basic example that
    you can use for building the Bank Statements Analyzer project. You will see several
    elements in this file:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建 *pom.xml* 文件，该文件将指导构建过程。[示例 3-26](#maven_pom_simple) 中的代码片段展示了用于构建银行对账单分析器项目的基本示例。在这个文件中，你将看到几个元素：
- en: '`project`'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`project`'
- en: This is the top-level element in all *pom.xml* files.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这是所有 *pom.xml* 文件的顶级元素。
- en: '`groupId`'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`groupId`'
- en: This element indicates the unique identifier of the organization that created
    the project.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 此元素指示创建项目的组织的唯一标识符。
- en: '`artifactId`'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`artifactId`'
- en: This element specifies a unique base name for the artifact generated by the
    build process.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 此元素为构建过程中生成的构件指定一个唯一的基本名称。
- en: '`packaging`'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`packaging`'
- en: This element indicates the package type to be used by this artifact (e.g., JAR,
    WAR, EAR, etc.). The default is JAR if the XML element `packaging` is omitted.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 此元素指示要由此构件使用的包类型（例如 JAR、WAR、EAR 等）。如果 XML 元素 `packaging` 被省略，则默认为 JAR。
- en: '`version`'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`version`'
- en: The version of the artifact generated by the project.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 项目生成的构件的版本。
- en: '`build`'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`build`'
- en: This element specifies various configurations to guide the build process such
    as plug-ins and resources.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 此元素指定各种配置，以指导构建过程，如插件和资源。
- en: '`dependencies`'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`dependencies`'
- en: This element specifies a dependency list for the project.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 此元素为项目指定一个依赖项列表。
- en: Example 3-26\. Build file pom.xml in Maven
  id: totrans-255
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-26\. Maven 中的构建文件 pom.xml
- en: '[PRE26]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Maven commands
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Maven 命令
- en: 'Once you’ve set up a *pom.xml*, the next step is to use Maven to build and
    package your project! There are various commands available. We only cover the
    fundamentals:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了 *pom.xml*，下一步是使用 Maven 构建和打包您的项目！有各种可用的命令。我们只涵盖基础知识：
- en: '`mvn clean`'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`mvn clean`'
- en: Cleans up any previously generated artifacts from a prior build
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 清理先前构建的任何生成构件
- en: '`mvn compile`'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`mvn compile`'
- en: Compiles the source code of the project (by default in a generated *target*
    folder)
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 编译项目的源代码（默认情况下生成到 *target* 文件夹）
- en: '`mvn test`'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`mvn test`'
- en: Tests the compiled source code
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 测试编译后的源代码
- en: '`mvn package`'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`mvn package`'
- en: Packages the compiled code in a suitable format such as JAR
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 将编译后的代码打包成适当的格式，如 JAR
- en: 'For example, running the command `mvn package` from the directory where the
    *pom.xml* file is located will produce an output similar to this:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在存放 *pom.xml* 文件的目录中运行命令 `mvn package` 将产生类似以下的输出：
- en: '[PRE27]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You will see the generated JAR *bankstatement_analyzer-1.0-SNAPSHOT.jar* in
    the *target* folder.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在 *target* 文件夹中看到生成的 JAR *bankstatement_analyzer-1.0-SNAPSHOT.jar*。
- en: Note
  id: totrans-270
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to run a main class in the generated artifact using the `mvn` command,
    you will need to take a look at the [exec plug-in](https://oreil.ly/uoPbv).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要使用 `mvn` 命令运行生成构件中的主类，您需要查看 [exec 插件](https://oreil.ly/uoPbv)。
- en: Using Gradle
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Gradle
- en: Maven is not the only build tool solution available in the Java space. Gradle
    is an alternative popular build tool to Maven. But you may wonder why use yet
    another build tool? Isn’t Maven the most widely adopted? One of Maven’s deficiencies
    is that the use of XML can make things less readable and more cumbersome to work
    with. For example, it is often necessary as part of the build process to provide
    various custom system commands, such as copying and moving files around. Specifying
    such commands using an XML syntax isn’t natural. In addition, XML is generally
    considered as a verbose language, which can increase the maintenance overhead.
    However, Maven introduced lots of good ideas such as standardization of project
    structure, which Gradle gets inspiration from. One of Gradle’s biggest advantages
    is that it uses a friendly Domain Specific Language (DSL) using the Groovy or
    Kotlin programming languages to specify the build process. As a result, specifying
    the build is more natural, easier to customize, and simpler to understand. In
    addition, Gradle supports features such as cache and incremental compilation,
    which contribute to faster build time.^([3](ch03.xhtml#idm45816826896504))
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 领域，Maven 并不是唯一的构建工具解决方案。Gradle 是 Maven 的一个备受欢迎的替代构建工具。但是你可能会想为什么要使用另一个构建工具？难道
    Maven 不是被广泛采用吗？Maven 的一个缺点是使用 XML 可能会使事情变得不太可读，且操作起来更加繁琐。例如，作为构建过程的一部分，通常需要提供各种自定义系统命令，如复制和移动文件。使用
    XML 语法指定此类命令并不自然。此外，XML 通常被认为是一种冗长的语言，这可能增加维护成本。然而，Maven 提出了很多好的想法，如项目结构的标准化，这些都是
    Gradle 的灵感来源之一。Gradle 最大的优势之一是它使用友好的领域特定语言（DSL），使用 Groovy 或 Kotlin 编程语言来指定构建过程。因此，指定构建更加自然，更容易定制，更简单理解。此外，Gradle
    支持缓存和增量编译等功能，有助于缩短构建时间。^([3](ch03.xhtml#idm45816826896504))
- en: Example build file
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例构建文件
- en: Gradle follows a similar project structure to Maven. However, instead of a *pom.xml*
    file, you will declare a *build.gradle* file. There’s also a *settings.gradle*
    file that includes configuration variables and setup for a multiproject build.
    In the code snippet in [Example 3-27](#gradle_simple) you can find a small build
    file written in Gradle that is equivalent to the Maven example you saw in [Example 3-26](#maven_pom_simple).
    You have to admit it’s a lot more concise!
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle 与 Maven 遵循类似的项目结构。但是，与 *pom.xml* 文件不同，你将声明一个 *build.gradle* 文件。还有一个 *settings.gradle*
    文件，包含多项目构建的配置变量和设置。在 [示例 3-27](#gradle_simple) 的代码片段中，你可以找到一个用 Gradle 编写的小型构建文件，与你在
    [示例 3-26](#maven_pom_simple) 中看到的 Maven 示例等价。你必须承认，这要简洁得多！
- en: Example 3-27\. Build file build.gradle in Gradle
  id: totrans-276
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-27. Gradle 中的构建文件 build.gradle
- en: '[PRE28]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Gradle commands
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Gradle 命令
- en: 'Finally, you can now run the build process by running similar commands to what
    you learned with Maven. Each command in Gradle is a task. You can define your
    own tasks and execute them or use built-in tasks such as `test`, `build`, and
    `clean`:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，现在你可以通过运行与 Maven 学到的类似命令来运行构建过程。Gradle 中的每个命令都是一个任务。你可以定义自己的任务并执行它们，或者使用诸如
    `test`、`build` 和 `clean` 等内置任务：
- en: '`gradle clean`'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`gradle clean`'
- en: Cleans up generated files during a previous build
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 清理上一个构建过程期间生成的文件
- en: '`gradle build`'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`gradle build`'
- en: Packages the application
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 打包应用程序
- en: '`gradle test`'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`gradle test`'
- en: Runs the tests
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试
- en: '`gradle run`'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`gradle run`'
- en: Runs the main class specified in `mainClassName` provided the `application`
    plug-in is applied
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 运行指定的 `mainClassName` 中的主类，前提是应用了 `application` 插件。
- en: 'For example, running `gradle build` will produce an output similar to this:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，运行 `gradle build` 将会产生类似于以下输出：
- en: '[PRE29]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You will find the generated JAR in the `build` folder that is created by Gradle
    during the build process.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 你将会在由 Gradle 在构建过程中创建的 `build` 文件夹中找到生成的 JAR 文件。
- en: Takeaways
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主要内容
- en: The Open/Closed Principle promotes the idea of being able to change the behavior
    of a method or class without having to modify the code.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开闭原则促进了能够在不修改代码的情况下改变方法或类的行为的理念。
- en: The Open/Closed Principle reduces fragility of code by not changing existing
    code, promotes reusability of existing code, and promotes decoupling, which leads
    to better code maintenance.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开闭原则通过不改变现有代码减少了代码的脆弱性，促进了现有代码的重用性，并推动了解耦，从而有助于更好地维护代码。
- en: God interfaces with many specific methods introduce complexity and coupling.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 太多具体方法的接口会引入复杂性和耦合。
- en: An interface that is too granular with single methods can introduce the opposite
    of cohesion.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个接口过于细粒化，只有单个方法，可能会引入与内聚相反的情况。
- en: You should not be worried about adding descriptive method names to help readability
    and comprehension of your API .
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不应该担心为提升API的可读性和理解性而添加描述性方法名。
- en: Returning `void` as a result of an operation makes it difficult to test its
    behavior.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回`void`作为操作结果会使其行为难以测试。
- en: Exceptions in Java contribute to documentation, type safety, and separation
    of concerns.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java中的异常有助于文档编写、类型安全和关注点分离。
- en: Use checked exceptions sparingly rather than the default as they can cause significant
    clutter.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽量少用已检查异常，而不是默认的，因为它们会导致显著的混乱。
- en: Overly specific exceptions can make software development unproductive.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过于具体的异常会使软件开发效率降低。
- en: The Notification Pattern introduces a domain class to collect errors.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通知模式引入了一个领域类来收集错误。
- en: Do not ignore an exception or catch the generic `Exception` as you will lose
    the benefits of diagnosing the root of the problem.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要忽略异常或捕获通用的`Exception`，否则将失去诊断问题根源的好处。
- en: A build tool automates the repetitive tasks in the software development life
    cycle including building, testing, and deploying your application.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建工具自动化软件开发生命周期中的重复任务，包括构建、测试和部署应用程序。
- en: Maven and Gradle are two popular build tools used in the Java community.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Maven和Gradle是Java社区中使用的两种流行的构建工具。
- en: Iterating on You
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在你的迭代过程中
- en: 'If you want to extend and solidify the knowledge from this section you could
    try one of these activities:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想扩展和巩固本节的知识，你可以尝试以下活动之一：
- en: Add support for exporting in different data formats including JSON and XML
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加支持以不同数据格式（包括JSON和XML）导出的功能。
- en: Develop a basic GUI around the Bank Statements Analyzer
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发围绕银行对账单分析器的基本GUI。
- en: Completing the Challenge
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成挑战
- en: Mark Erbergzuck is very happy with your final iteration of the Bank Statements
    Analyzer. A few days later, the world hit a new financial crisis and your application
    is going viral. Time to work on a new exciting project in the next chapter!
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: Mark Erbergzuck对你的银行对账单分析器的最终迭代非常满意。几天后，世界迎来了新的金融危机，你的应用程序开始走红。是时候在下一章节上着手新的激动人心的项目了！
- en: ^([1](ch03.xhtml#idm45816831226440-marker)) This pattern was first put forward
    by Martin Fowler.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch03.xhtml#idm45816831226440-marker)) 这种模式最初由马丁·福勒提出。
- en: ^([2](ch03.xhtml#idm45816830413256-marker)) Earlier in Java’s life there was
    another popular build tool, called Ant, but it is now considered end-of-life and
    should not be used anymore.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch03.xhtml#idm45816830413256-marker)) 在Java早期有另一种流行的构建工具，叫做Ant，但现在被视为终止生命周期，不应再使用。
- en: ^([3](ch03.xhtml#idm45816826896504-marker)) For more information on Maven versus
    Gradle, see [*https://gradle.org/maven-vs-gradle/*](https://gradle.org/maven-vs-gradle/).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch03.xhtml#idm45816826896504-marker)) 欲了解更多有关Maven与Gradle的信息，请参见[*https://gradle.org/maven-vs-gradle/*](https://gradle.org/maven-vs-gradle/)。
