<html><head></head><body>
<div id="sbo-rt-content" class="calibre2"><section data-type="chapter" type="chapter" data-pdf-bookmark="Chapter 6. Source Code Observability" class="calibre3"><div class="preface" id="ch_source_code_observability">
<h1 class="calibre17" id="AFM64-2d714b853a094e9a910510217e0e3d73"><span class="keep-together">Chapter 6. </span>Source Code Observability</h1>


<p class="author1"><a data-type="indexterm" data-primary="source code observability" id="ix_ch06-asciidoc0" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/>Achieving safe delivery via pipelines or some other repeatable process is a step forward. It helps, though, to look forward to how you can observe the state of the running system beginning with deployed assets. Too much of a focus on just the pipeline itself could leave you without a means to inventory your suite of deployed assets later.</p>

<p class="author1">Source code is just as important to monitor as live processes. In an organization’s source code, dependencies between internal components and third-party libraries are specified. Small changes in dependencies can render an application unusable. Patterns are found to repeat across an organization as developers emulate the work they see done elsewhere. Even patterns that expose attack vectors into your organization are emulated until an awareness of a vulnerability is developed. In codebases of a significant enough size, even the smallest API change can seem like an insurmountable task.</p>

<p class="author1">In the Netflix codebase, we found Guava version drift across deep dependency trees to be almost crippling at times. An attempt to make a shift from one logging library to another across the whole codebase had taken years and was still not achieved until an organization-wide refactoring solution was developed.</p>

<p class="author1">Another significant challenge is identifying what code is actually deployed where across a myriad of environments. As your organization makes advances in continuous delivery, for example, the possibility of rollbacks means that the latest release version available in your artifact repository for a given microservice may not be the version that is running in production. Or in the case of a canary test, or a blue/green deployment with greater than one active cluster, you won’t even have one particular version running exclusively in production!</p>

<p class="author1">The need to map deployed assets to source code is particularly important for organizations that aren’t monorepo-based (and most aren’t). Any pressures present that limit the adoption of new internal dependencies in your organization effectively place a ceiling on how effectively you <em class="calibre12">continuously integrate</em> as well.</p>

<p class="author1">This chapter is all about build tools. Examples given here are for the <a href="https://gradle.org" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">Gradle</a> build tool. The patterns described here could be implemented in Maven or any other Java build tool, but the Gradle ecosystem provides the most readily available concrete examples, especially with its recent advances in binary dependency management and the Netflix Nebula plug-in ecosystem that was developed for an organization skilled at delivering microservices at scale. We’ll also assume that binary artifacts for microservices, along with any core platform dependencies that they include, are published to a Maven-style artifact repository like <a href="https://oreil.ly/3l06u" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">JFrog Artifactory</a> or <a href="https://oreil.ly/R7wOr" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">Sonatype Nexus</a>.</p>

<p class="author1">The focus on build tools may seem strange, given that in the software delivery life cycle, build tools come much earlier than continuous delivery, which has just been covered in <a data-type="xref" href="part0010_split_000.html#9H5K4-2d714b853a094e9a910510217e0e3d73" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">Chapter 5</a>. A sense of what a stateful continuous delivery tool can do for you in terms of inventorying production assets, however, is an important prerequisite to a consideration of versioning strategies and the kinds of metadata we need to include as a microservice’s artifacts are produced. Given the right data, the production asset inventory presented by your delivery solution should be the first step in a provenance chain. We’re going to cover a few pieces that need to be injected into a conventional software delivery life cycle in order for you to ultimately be able to map deployed assets back to the source code that is running in them, as shown in <a data-type="xref" href="part0011_split_000.html#from_change_to_production" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">Figure 6-1</a>. The provenance chain should lead at least down to an immutable artifact version and commit hash, and possibly all the way down to source code method-level references.</p>

<figure class="calibre32"><div id="from_change_to_production" class="figure">
<img src="../images/00057.png" alt="srej 0601" class="calibre157"/>
<h6 class="calibre34"><span class="keep-together">Figure 6-1. </span>The provenance chain leading from a code change to production</h6>
</div></figure>

<p class="author1">Suppose we start with a continuous delivery tool like Spinnaker (introduced in <a data-type="xref" href="part0010_split_000.html#9H5K4-2d714b853a094e9a910510217e0e3d73" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">Chapter 5</a>) telling us that an application representing a microservice is spread over multiple cloud platforms, with multiple versions of the code running in different clusters. If the deployed resources are tagged with the artifact information that went into them, we consider what we can do to ensure that this artifact information leads us to a uniquely identifiable place in the history of this microservice’s code.</p>

<p class="author1">It begins with the characteristics we need from our delivery system.</p>
</div></section></div>



  

<div id="sbo-rt-content" class="calibre2">
<section data-type="chapter" type="chapter" data-pdf-bookmark="Chapter 6. Source Code Observability" class="calibre3">
<div class="preface" id="ch_source_code_observability">
<div data-type="note" type="note" class="calibre28"><h1 class="calibre54" id="calibre_pb_1">Meaning of Terms Used in This Chapter</h1>
<p class="author1">This chapter will use terms like <em class="calibre12">instance</em>, <em class="calibre12">server group</em>, and <em class="calibre12">cluster</em> as defined in <a data-type="xref" href="part0010_split_002.html#resource_types" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">“Resource Types”</a> at the start of <a data-type="xref" href="part0010_split_000.html#9H5K4-2d714b853a094e9a910510217e0e3d73" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">Chapter 5</a>.</p>
</div>






</div></section></div>



  

<div id="sbo-rt-content" class="calibre2">
<section data-type="chapter" type="chapter" data-pdf-bookmark="Chapter 6. Source Code Observability" class="calibre3">
<div class="preface" id="ch_source_code_observability">
<section data-type="sect1" data-pdf-bookmark="The Stateful Asset Inventory" class="calibre3"><div class="preface" id="idm45139264604360">
<h1 class="calibre19" id="AFM75-2d714b853a094e9a910510217e0e3d73">The Stateful Asset Inventory</h1>

<p class="author1"><a data-type="indexterm" data-primary="source code observability" data-secondary="stateful asset inventory" id="ix_ch06-asciidoc1" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/><a data-type="indexterm" data-primary="stateful asset inventory" id="ix_ch06-asciidoc2" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/>A queryable stateful asset inventory of code all the way to deployed assets allows you to answer questions about the current state of your systems.</p>

<p class="author1">The first objective in building this inventory is to have some system of record that we can query to itemize our deployed resources (in both production and lower-level nonproduction testing environments). How difficult this is depends on how many and what types of places your code can be deployed. Some organizations, even with virtualized hardware in the datacenter, have a fixed set of virtual machine names that don’t change much (numbered in the dozens or hundreds), each dedicated to a particular application. You could quite reasonably maintain a static list of application names and the virtual machines that host them. In an IaaS or CaaS where resources are provisioned more elastically, we really need to query the cloud provider for the list of currently deployed assets.</p>
</div></section>













</div></section></div>



  

<div id="sbo-rt-content" class="calibre2">
<section data-type="chapter" type="chapter" data-pdf-bookmark="Chapter 6. Source Code Observability" class="calibre3">
<div class="preface" id="ch_source_code_observability">
<section data-type="sect1" data-pdf-bookmark="The Stateful Asset Inventory" class="calibre3">
<div class="preface" id="idm45139264604360">
<div data-type="warning" type="warning" class="calibre30"><h1 class="calibre69" id="calibre_pb_3">GitOps Doesn’t Achieve a Deployed Asset Inventory</h1>
<p class="author1"><a data-type="indexterm" data-primary="deployed asset inventory" id="idm45139264597896" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/><a data-type="indexterm" data-primary="GitOps" id="idm45139264597176" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/>With GitOps, you store the state of what you <em class="calibre12">want</em> to happen in Git. What materializes in the environment can be something very different. The easiest example of this divergence comes from Kubernetes. When you commit a manifest in Git, and this causes a deployment action, that manifest is mutated by Kubernetes controllers in the target cluster into something potentially different. The scope and number of mutations is only growing as vendors and projects layer more and more CRDs on top of Kubernetes. What you get with a <code class="calibre24">kubectl get pod -o yaml</code> is not the same manifest as what you committed in Git. And in fact, it can be different from one Kubernetes cluster to another! The point is, even if you successfully gate all <em class="calibre12">intention actions</em> through Git, you still don’t really have a true picture of the deployed environment in Git.</p>
</div>

<p class="author1">A key benefit of a system like Spinnaker is its model of polling live environments for the state of deployed infrastructure, spanning every cloud provider that Spinnaker supports. In other words, you can retrieve in one API call a consistent representation (in terms of application/cluster/server group/instance) of deployed infrastructure across many cloud platforms. It is a single-pane-of-glass experience for asset inventorying. There are two levels to this benefit:</p>
<dl class="calibre20">
<dt class="calibre21">No need to coordinate through one system</dt>
<dd class="calibre22">
<p class="calibre23">By actively polling, we don’t need to centralize all possible mutations of the state of the deployed environment through one system that can maintain state separately. In theory you could require this, for example, by enforcing “gitops,” i.e., a management update to the application requires an update in Git. In such a setup, there can be no rollback, load balancer changes, manual launching of server groups, or any other mutation that would result in Git not having a full picture of the state of the deployed environment.</p>
</dd>
<dt class="calibre21">Real-time instance-level status</dt>
<dd class="calibre22">
<p class="calibre23">What a GitOps or similar system cannot do is track the state of individual instances in a server group. AWS EC2, for example, makes no guarantees about an individual virtual machine’s survivability, just that the Auto Scaling Group will do its best to maintain the specified number of instances in the ASG at any given time. The same is true in Kubernetes, where an individual pod’s survivability is not guaranteed. If metrics telemetry is tagged instance ID, instance ordinal, or pod ID, it is convenient to be able to receive an alert on the violation of some service level objective, be able to drill down to a particular failing instance(s), and navigate to a real-time view of the cluster at an instance level to take some remediating action. For example, you could take a failing instance out of the load balancer, allowing the “server group” mechanism to launch another instance and addressing immediate user impact while allowing you time to investigate root cause on the failing instance before eventually terminating it.</p>
</dd>
</dl>

<p class="author1">As beneficial as it is to operations, real-time instance-level status is not immediately relevant to our discussion of artifact provenance. We really just need <em class="calibre12">some</em> source we can interrogate to list running server groups, clusters, and applications (see <a data-type="xref" href="part0011_split_003.html#mapping_deployed_resources_1" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">Example 6-1</a>). For the remainder of this chapter, we’ll use a Java pseudocode that describes the kinds of insights you should be able to derive by achieving a certain level of provenance information. The first part of the model encapsulates the resource types (see <a data-type="xref" href="part0010_split_002.html#resource_types" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">“Resource Types”</a>) whose definitions were given earlier. The implementation of the methods, like <code class="calibre24">getApplications()</code>, is dependent on the deployment automation you use. For example, <code class="calibre24">getApplications()</code> is an API call to Spinnaker’s Gate service to the endpoint <code class="calibre24">/applications</code>.</p>
<div id="mapping_deployed_resources_1" data-type="example" class="calibre61">
<h5 class="calibre62"><span class="keep-together">Example 6-1. </span>Listing running deployed assets</h5>

<pre data-type="programlisting" data-code-language="java" class="calibre63"><code class="n">delivery</code><code class="calibre24">
</code><code class="calibre24">  </code><code class="o">.</code><code class="na">getApplications</code><code class="o">(</code><code class="o">)</code><code class="calibre24">
</code><code class="calibre24">  </code><code class="o">.</code><code class="na">flatMap</code><code class="o">(</code><code class="n">application</code><code class="calibre24"> </code><code class="o">-</code><code class="o">&gt;</code><code class="calibre24"> </code><code class="n">application</code><code class="o">.</code><code class="na">getClusters</code><code class="o">(</code><code class="o">)</code><code class="o">)</code><code class="calibre24">
</code><code class="calibre24">  </code><code class="o">.</code><code class="na">flatMap</code><code class="o">(</code><code class="n">cluster</code><code class="calibre24"> </code><code class="o">-</code><code class="o">&gt;</code><code class="calibre24"> </code><code class="n">cluster</code><code class="o">.</code><code class="na">getServerGroups</code><code class="o">(</code><code class="o">)</code><code class="o">)</code><code class="calibre24">
</code><code class="calibre24">
</code><code class="c">// Where...
</code><code class="k">class</code><code class="calibre24"> </code><code class="nc">Application</code><code class="calibre24"> </code><code class="o">{</code><code class="calibre24">
</code><code class="calibre24">  </code><code class="n">String</code><code class="calibre24"> </code><code class="n">name</code><code class="o">;</code><code class="calibre24">
</code><code class="calibre24">  </code><code class="n">Team</code><code class="calibre24"> </code><code class="n">owner</code><code class="o">;</code><code class="calibre24">
</code><code class="calibre24">  </code><code class="n">Stream</code><code class="o">&lt;</code><code class="n">Cluster</code><code class="o">&gt;</code><code class="calibre24"> </code><code class="n">clusters</code><code class="o">;</code><code class="calibre24">
</code><code class="o">}</code><code class="calibre24">
</code><code class="calibre24">
</code><code class="k">class</code><code class="calibre24"> </code><code class="nc">Cluster</code><code class="calibre24"> </code><code class="o">{</code><code class="calibre24">
</code><code class="calibre24">  </code><code class="n">String</code><code class="calibre24"> </code><code class="n">cloudProvider</code><code class="o">;</code><code class="calibre24">
</code><code class="calibre24">  </code><code class="n">String</code><code class="calibre24"> </code><code class="n">name</code><code class="o">;</code><code class="calibre24">
</code><code class="calibre24">  </code><code class="n">Stream</code><code class="o">&lt;</code><code class="n">ServerGroup</code><code class="o">&gt;</code><code class="calibre24"> </code><code class="n">clusters</code><code class="o">;</code><code class="calibre24">
</code><code class="o">}</code><code class="calibre24">
</code><code class="calibre24">
</code><code class="k">class</code><code class="calibre24"> </code><code class="nc">ServerGroup</code><code class="calibre24"> </code><code class="o">{</code><code class="calibre24">
</code><code class="calibre24">  </code><code class="n">String</code><code class="calibre24"> </code><code class="n">name</code><code class="o">;</code><code class="calibre24">
</code><code class="calibre24">  </code><code class="n">String</code><code class="calibre24"> </code><code class="n">region</code><code class="o">;</code><code class="calibre24"> </code><a class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre" id="co_source_code_observability_CO1-1" href="part0011_split_003.html#callout_source_code_observability_CO1-1"><img src="../images/00112.png" alt="1" class="calibre66"/></a><code class="calibre24">
</code><code class="calibre24">  </code><code class="n">String</code><code class="calibre24"> </code><code class="n">stack</code><code class="o">;</code><code class="calibre24"> </code><a class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre" id="co_source_code_observability_CO1-2" href="part0011_split_003.html#callout_source_code_observability_CO1-2"><img src="../images/00059.png" alt="2" class="calibre66"/></a><code class="calibre24">
</code><code class="calibre24">  </code><code class="n">String</code><code class="calibre24"> </code><code class="n">version</code><code class="o">;</code><code class="calibre24">
</code><code class="calibre24">  </code><code class="kt">boolean</code><code class="calibre24"> </code><code class="n">enabled</code><code class="o">;</code><code class="calibre24">
</code><code class="calibre24">  </code><code class="n">Artifact</code><code class="calibre24"> </code><code class="n">artifact</code><code class="o">;</code><code class="calibre24">
</code><code class="o">}</code></pre></div>
<dl class="calibre20">
<dt class="calibre21"><a class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre" id="callout_source_code_observability_CO1-1" href="part0011_split_003.html#co_source_code_observability_CO1-1"><img src="../images/00112.png" alt="1" class="calibre66"/></a></dt>
<dd class="calibre67"><p class="calibre68">For example, <code class="calibre24">us-east-1</code> in AWS or namespace in K8S.</p></dd>
<dt class="calibre21"><a class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre" id="callout_source_code_observability_CO1-2" href="part0011_split_003.html#co_source_code_observability_CO1-2"><img src="../images/00059.png" alt="2" class="calibre66"/></a></dt>
<dd class="calibre67"><p class="calibre68">The promotion level of the environment, like <code class="calibre24">test</code> or <code class="calibre24">production</code>.</p></dd>
</dl>

<p class="author1">For a GitOps system, <code class="calibre24">getApplications()</code> would interrogate the status of one or more Git repositories. For the private datacenter with a set of named virtual machines that rarely changes, this could be a manually maintained static list.</p>

<p class="author1">Notice how at various stages, you should be able to drill down on various characteristics of the data in a stateful delivery system. For example, see <a data-type="xref" href="part0011_split_003.html#mapping_deployed_resources_2" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">Example 6-2</a> to get a list of teams that have applications that have some running footprint in Kubernetes:</p>
<div id="mapping_deployed_resources_2" data-type="example" class="calibre61">
<h5 class="calibre62"><span class="keep-together">Example 6-2. </span>Discovering teams that have applications running in Kubernetes</h5>

<pre data-type="programlisting" data-code-language="java" class="calibre63"><code class="n">delivery</code>
  <code class="o">.</code><code class="na">getApplications</code><code class="o">()</code>
  <code class="o">.</code><code class="na">filter</code><code class="o">(</code><code class="n">application</code> <code class="o">-&gt;</code> <code class="n">application</code><code class="o">.</code><code class="na">getClusters</code><code class="o">()</code>
    <code class="o">.</code><code class="na">anyMatch</code><code class="o">(</code><code class="n">cluster</code> <code class="o">-&gt;</code> <code class="n">cluster</code><code class="o">.</code><code class="na">getCloudProvider</code><code class="o">().</code><code class="na">equals</code><code class="o">(</code><code class="s">"kubernetes"</code><code class="o">)))</code>
  <code class="o">.</code><code class="na">map</code><code class="o">(</code><code class="n">application</code> <code class="o">-&gt;</code> <code class="n">application</code><code class="o">.</code><code class="na">getTeam</code><code class="o">())</code>
  <code class="o">.</code><code class="na">collect</code><code class="o">(</code><code class="n">Collectors</code><code class="o">.</code><code class="na">toSet</code><code class="o">())</code></pre></div>

<p class="author1">This ability to drill down leads to better actionability. When a full provenance chain is established, we should be able to, for example, look for a recently revealed method-level security vulnerability. For a critical vulnerability, it might be desirable to first address the production stack and later follow up on the lower-level environments that contain code on a path to production eventually.</p>

<p class="author1">In order to be able to determine which <code class="calibre24">Artifact</code> a server group contains, we need proper immutable release versioning.<a data-type="indexterm" data-startref="ix_ch06-asciidoc2" id="idm45139264516280" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/><a data-type="indexterm" data-startref="ix_ch06-asciidoc1" id="idm45139264515784" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/></p>
</div></section>













</div></section></div>



  

<div id="sbo-rt-content" class="calibre2">
<section data-type="chapter" type="chapter" data-pdf-bookmark="Chapter 6. Source Code Observability" class="calibre3">
<div class="preface" id="ch_source_code_observability">
<section data-type="sect1" data-pdf-bookmark="Release Versioning" class="calibre3"><div class="preface" id="idm45139264603736">
<h1 class="calibre19" id="AFMEV-2d714b853a094e9a910510217e0e3d73">Release Versioning</h1>

<p class="author1"><a data-type="indexterm" data-primary="release versioning" id="ix_ch06-asciidoc3" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/><a data-type="indexterm" data-primary="source code observability" data-secondary="release versioning" id="ix_ch06-asciidoc4" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/>Since the artifact repository is the part of the software delivery life cycle immediately preceding continuous delivery, a unique binary artifact version is the first step in the artifact provenance chain. For a given pipeline run, Spinnaker keeps track of the artifact inputs to that pipeline. Any resulting deployed assets will also be tagged with this provenance information. <a data-type="xref" href="part0011_split_004.html#spinnaker_resolved_artifact" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">Figure 6-2</a> shows how Spinnaker has kept track of the docker image tag and digest that was an input to a pipeline.</p>

<figure class="calibre32"><div id="spinnaker_resolved_artifact" class="figure">
<img src="../images/00003.png" alt="srej 0602" class="calibre158"/>
<h6 class="calibre34"><span class="keep-together">Figure 6-2. </span>Spinnaker resolved expected artifact (notice the artifact is identified by digest instead of tag)</h6>
</div></figure>

<p class="author1">For this image version tag to uniquely identify a piece of code, the tag has to be unique for each unique combination of source code and dependencies. That is, if <em class="calibre12">either</em> the source code or dependencies that make up an application change, the version needs to change, and it is this unique version number that needs to be used to retrieve the artifact.</p>
</div></section>













</div></section></div>



  

<div id="sbo-rt-content" class="calibre2">
<section data-type="chapter" type="chapter" data-pdf-bookmark="Chapter 6. Source Code Observability" class="calibre3">
<div class="preface" id="ch_source_code_observability">
<section data-type="sect1" data-pdf-bookmark="Release Versioning" class="calibre3">
<div class="preface" id="idm45139264603736">
<div data-type="warning" type="warning" class="calibre30"><h1 class="calibre69" id="calibre_pb_5">Docker Image Tags Are Mutable</h1>
<p class="author1"><a data-type="indexterm" data-primary="Docker registries" id="idm45139264534344" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/>Docker registries don’t make any guarantee about tag immutability. And digests are not necessarily 1:1 with tags, though they are immutable. A common convention when publishing a new version of a Docker container to a container registry is to publish the image with the tag “latest” and some fixed version like “1.2.0.” The “latest” tag effectively gets overriden, and it shares the same digest as “1.2.0” until the next published version. Despite the fact that image tags are mutable from the registry’s perspective, you can build a release process that never actually mutates fixed version numbers so that this more human-readable tag can be used to associate an image with the code that is in it.</p>
</div>

<p class="author1">The type of artifact that becomes the input to a deployment depends on the target cloud platform. For a PaaS like Cloud Foundry it is a JAR or WAR; for Kubernetes, it is a container image, and for an IaaS like AWS EC2, an Amazon Machine Image is “baked” (see <a data-type="xref" href="part0010_split_005.html#packaging_iaas" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">“Packaging for IaaS Platforms”</a>) from a system package like a Debian or RPM.</p>

<p class="author1">Regardless of whether we are producing a JAR, a container image, or a Debian/RPM, the same versioning scheme considerations apply.</p>

<p class="author1">We’ll narrow this discussion to JARs published to a Maven repository (the discussion applies equally to Debians published to a Maven repository), but the end goal of producing an immutable version would be the same for publishing container images to a container registry.</p>








</div></section>













</div></section></div>



  

<div id="sbo-rt-content" class="calibre2">
<section data-type="chapter" type="chapter" data-pdf-bookmark="Chapter 6. Source Code Observability" class="calibre3">
<div class="preface" id="ch_source_code_observability">
<section data-type="sect1" data-pdf-bookmark="Release Versioning" class="calibre3">
<div class="preface" id="idm45139264603736">
<section data-type="sect2" data-pdf-bookmark="Maven Repositories" class="calibre3"><div class="preface" id="idm45139264541432">
<h2 class="calibre37" id="AFMFK-2d714b853a094e9a910510217e0e3d73">Maven Repositories</h2>

<p class="author1"><a data-type="indexterm" data-primary="Maven repositories" id="ix_ch06-asciidoc5" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/><a data-type="indexterm" data-primary="release versioning" data-secondary="Maven repositories" id="ix_ch06-asciidoc6" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/>In artifact repositories, there are generally two types of Maven repositories: release repositories and snapshot repositories. <a data-type="indexterm" data-primary="release repositories" id="idm45139264537240" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/>The structure of the release repository is the repository’s base URL plus the artifact’s group, artifact, and version. Any dots in the group name are separated by <code class="calibre24">/</code> in the path to arrive at the location of an artifact. In Gradle, a dependency on Micrometer core 1.4.1 can be defined as <code class="calibre24">implementation io.micrometer:micrometer-core:1.4.1</code>.</p>

<p class="author1">The artifacts for this dependency in Maven Central look like <a data-type="xref" href="part0011_split_006.html#maven_repo_path" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">Figure 6-3</a>.</p>

<figure class="calibre32"><div id="maven_repo_path" class="figure">
<img src="../images/00013.png" alt="srej 0603" class="calibre159"/>
<h6 class="calibre34"><span class="keep-together">Figure 6-3. </span>Maven Central directory listing for micrometer-core 1.4.1</h6>
</div></figure>

<p class="author1">The directory listing contains the binary JAR (micrometer-core-1.4.1.jar), checksums, a Maven POM file describing the module, a set of checksums, and optionally sources and javadoc JARs.</p>
</div></section>













</div></section>













</div></section></div>



  

<div id="sbo-rt-content" class="calibre2">
<section data-type="chapter" type="chapter" data-pdf-bookmark="Chapter 6. Source Code Observability" class="calibre3">
<div class="preface" id="ch_source_code_observability">
<section data-type="sect1" data-pdf-bookmark="Release Versioning" class="calibre3">
<div class="preface" id="idm45139264603736">
<section data-type="sect2" data-pdf-bookmark="Maven Repositories" class="calibre3">
<div class="preface" id="idm45139264541432">
<div data-type="tip" class="calibre28"><h1 class="calibre54" id="calibre_pb_7">Maven Release Versions Are Immutable</h1>
<p class="author1">Generally an artifact version like 1.4.1 in a Maven repository is immutable. No other code should ever be published over this <span class="keep-together">version.</span></p>
</div>

<p class="author1"><a data-type="indexterm" data-primary="snapshot repositories" id="idm45139264552984" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/>Maven snapshot repositories are structured a little differently. <a data-type="xref" href="part0011_split_007.html#maven_snapshot_repo_path" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">Figure 6-4</a> shows how RSocket’s snapshots are structured in a Maven repository for the dependency <code class="calibre24">implementation io.rsocket:rsocket-core:1.0.0-RC7-SNAPSHOT</code>.</p>

<figure class="calibre32"><div id="maven_snapshot_repo_path" class="figure">
<img src="../images/00014.png" alt="srej 0604" class="calibre160"/>
<h6 class="calibre34"><span class="keep-together">Figure 6-4. </span>Spring Artifactory snapshot repository for RSocket 1.0.0-RC7-SNAPSHOT</h6>
</div></figure>

<p class="author1">The path to this directory listing has the path segment <code class="calibre24">1.0.0-RC7-SNAPSHOT</code>, but notice that none of the actual artifacts do. Instead they replace <code class="calibre24">SNAPSHOT</code> with a timestamp when they were published. If we look in <code class="calibre24">maven-metadata.xml</code>, we’ll see that it maintains a record of the last timestamp that was published to this snapshot repository, as shown in <a data-type="xref" href="part0011_split_007.html#maven_metadata_snapshot" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">Example 6-3</a>.</p>
<div id="maven_metadata_snapshot" data-type="example" class="calibre61">
<h5 class="calibre62"><span class="keep-together">Example 6-3. </span>Maven metadata for RSocket 1.0.0-RC7-SNAPSHOT</h5>

<pre data-type="programlisting" data-code-language="xml" class="calibre63"><code class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</code>
<code class="nt">&lt;metadata</code> <code class="na">modelVersion=</code><code class="s">"1.1.0"</code><code class="nt">&gt;</code>
  <code class="nt">&lt;groupId&gt;</code>io.rsocket<code class="nt">&lt;/groupId&gt;</code>
  <code class="nt">&lt;artifactId&gt;</code>rsocket-core<code class="nt">&lt;/artifactId&gt;</code>
  <code class="nt">&lt;version&gt;</code>1.0.0-SNAPSHOT<code class="nt">&lt;/version&gt;</code>
  <code class="nt">&lt;versioning&gt;</code>
    <code class="nt">&lt;snapshot&gt;</code>
      <code class="nt">&lt;timestamp&gt;</code>20200423.184223<code class="nt">&lt;/timestamp&gt;</code>
      <code class="nt">&lt;buildNumber&gt;</code>24<code class="nt">&lt;/buildNumber&gt;</code>
    <code class="nt">&lt;/snapshot&gt;</code>
    <code class="nt">&lt;lastUpdated&gt;</code>20200423185021<code class="nt">&lt;/lastUpdated&gt;</code>
    <code class="nt">&lt;snapshotVersions&gt;</code>
      <code class="nt">&lt;snapshotVersion&gt;</code>
        <code class="nt">&lt;extension&gt;</code>jar<code class="nt">&lt;/extension&gt;</code>
        <code class="nt">&lt;value&gt;</code>1.0.0-RC7-20200423.184223-24<code class="nt">&lt;/value&gt;</code>
        <code class="nt">&lt;updated&gt;</code>20200423184223<code class="nt">&lt;/updated&gt;</code>
      <code class="nt">&lt;/snapshotVersion&gt;</code>
      <code class="nt">&lt;snapshotVersion&gt;</code>
        <code class="nt">&lt;extension&gt;</code>pom<code class="nt">&lt;/extension&gt;</code>
        <code class="nt">&lt;value&gt;</code>1.0.0-RC7-20200423.184223-24<code class="nt">&lt;/value&gt;</code>
        <code class="nt">&lt;updated&gt;</code>20200423184223<code class="nt">&lt;/updated&gt;</code>
      <code class="nt">&lt;/snapshotVersion&gt;</code>
      ...
    <code class="nt">&lt;/snapshotVersions&gt;</code>
  <code class="nt">&lt;/versioning&gt;</code>
<code class="nt">&lt;/metadata&gt;</code></pre></div>

<p class="author1">Each time a new snapshot is published, this <code class="calibre24">maven-metadata.xml</code> is updated by the artifact repository. This means that the dependency <code class="calibre24">implementation io.rsocket:rsocket-core:1.0.0-RC7-SNAPSHOT</code> is <em class="calibre12">not</em> immutable. If we tagged some deployed asset with the version <code class="calibre24">1.0.0-RC7-SNAPSHOT</code>, we don’t have enough specific information to tie this snapshot back to the particular snapshot timestamp that was latest at the time that the deployment happened.</p>

<p class="author1">In other words, Maven snapshot versioning is a problem for artifact provenance because it doesn’t uniquely identify a binary dependency in the artifact repository.</p>

<p class="author1">Microservice versioning is different than library versioning as well in that at any time a candidate version that is being tested in a lower environment could be <em class="calibre12">promoted</em> to production. It’s safest if we don’t examine a candidate binary with a snapshot-like version in a lower-level environment and, deciding that it is fit for promotion to production, <em class="calibre12">rebuild</em> the binary with a “release” version number. Rebuilding the binary is wasteful in both time and artifact repository storage. More significantly, it introduces the possibility that any part of the build (or the conditions of the machine on which the build is occurring, which might influence the resulting binary) is not repeatable.</p>

<p class="author1">To summarize everything we’ve discussed about versioning into two principles for microservice versioning, we need the following:</p>
<dl class="calibre20">
<dt class="calibre21">Uniqueness</dt>
<dd class="calibre22">
<p class="calibre23">A version number for each unique combination of source code and dependencies</p>
</dd>
<dt class="calibre21">Immutability</dt>
<dd class="calibre22">
<p class="calibre23">A guarantee that artifact versions are never overwritten in the artifact repository</p>
</dd>
</dl>

<p class="author1">Maven snapshots fail the uniqueness test.</p>

<p class="author1">While there are a variety of release versioning schemes that could work, there is a relatively simple approach using open source build tooling that takes quite a bit of the toil out of microservice versioning while meeting both of these tests.<a data-type="indexterm" data-startref="ix_ch06-asciidoc6" id="idm45139264245128" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/><a data-type="indexterm" data-startref="ix_ch06-asciidoc5" id="idm45139264244424" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/></p>
</div></section>













</div></section>













</div></section></div>



  

<div id="sbo-rt-content" class="calibre2">
<section data-type="chapter" type="chapter" data-pdf-bookmark="Chapter 6. Source Code Observability" class="calibre3">
<div class="preface" id="ch_source_code_observability">
<section data-type="sect1" data-pdf-bookmark="Release Versioning" class="calibre3">
<div class="preface" id="idm45139264603736">
<section data-type="sect2" data-pdf-bookmark="Build Tools for Release Versioning" class="calibre3"><div class="preface" id="idm45139264303080">
<h2 class="calibre37" id="AFMIM-2d714b853a094e9a910510217e0e3d73">Build Tools for Release Versioning</h2>

<p class="author1"><a data-type="indexterm" data-primary="Netflix Nebula" id="ix_ch06-asciidoc7" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/><a data-type="indexterm" data-primary="release versioning" data-secondary="build tools for" id="ix_ch06-asciidoc8" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/>The Netflix Nebula suite of plug-ins contains a release plug-in that provides a convenient workflow for calculating a version number that meets both of these tests. It contains a set of Gradle tasks for versioning your project: <code class="calibre24">final</code>, <code class="calibre24">candidate</code>, and <code class="calibre24">devSnapshot</code>. When working on libraries, it is typical to build snapshots until you are close to a release, then maybe do one or more release candidates, and finally produce a final release. For microservice versioning, the situation is a bit different, again because at any time a particular iteration of code running in a lower-level environment could be promoted to production. An iteration cycle is shown in <a data-type="xref" href="part0011_split_008.html#microservice_versioning_cycle" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">Figure 6-5</a>. In this example workflow, tagging at the end of the deployment pipeline advances the minor release number <em class="calibre12">N</em> for the next development iteration.</p>

<figure class="calibre32"><div id="microservice_versioning_cycle" class="figure">
<img src="../images/00063.png" alt="srej 0605" class="calibre161"/>
<h6 class="calibre34"><span class="keep-together">Figure 6-5. </span>Microservice release versioning cycle</h6>
</div></figure>

<p class="author1">This cycle of code change, continuous integration building and producing an artifact and storing it in an artifact repository, and delivery automation provisioning the new artifact in a lower-level environment can be performed potentially many times before finally promoting a deployment to production. The specialized case where there is only one loop is the idealized continuous deployment model. This is the case when any successful deployment to a lower-level environment (and maybe some automated tests against that lower-level environment) results in a production promotion. Whether you get to this level of comfort with immediately shipping changes or not is not important to the versioning scheme.</p>

<p class="author1">Whenever the build is run, Nebula release looks at the latest tag on the repository, say, <code class="calibre24">v0.1.0</code>, and selects (by default) to generate snapshots (and candidates, and final builds for libraries) for the <em class="calibre12">next</em> minor version. In this case, that would be the minor release 0.2.0.</p>

<p class="author1">In the proposed versioning cycle, CI will execute a Gradle build for a repository that uses Nebula release to generate immutable snapshots. The minor revision remains consistent until a deployment is eventually promoted to production, at which point your delivery automation, like a Spinnaker pipeline stage, tags the repository (e.g., a Spinnaker job stage specifically executes <code class="calibre24">./gradlew final</code> on the repository, pushing a tag to the Git remote for the current minor release iteration).</p>
</div></section>





</div></section>













</div></section></div>



  

<div id="sbo-rt-content" class="calibre2">
<section data-type="chapter" type="chapter" data-pdf-bookmark="Chapter 6. Source Code Observability" class="calibre3">
<div class="preface" id="ch_source_code_observability">
<section data-type="sect1" data-pdf-bookmark="Release Versioning" class="calibre3">
<div class="preface" id="idm45139264603736">
<section data-type="sect2" data-pdf-bookmark="Build Tools for Release Versioning" class="calibre3">
<div class="preface" id="idm45139264303080">
<div data-type="note" type="note" class="calibre28"><h1 class="calibre54" id="calibre_pb_9">Releasing SaaS Versus Packaged Software</h1>
<p class="author1"><a data-type="indexterm" data-primary="release versioning" data-secondary="releasing SaaS versus packaged software" id="idm45139264200280" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/><a data-type="indexterm" data-primary="SaaS (software as a service)" id="idm45139264199240" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/><a data-type="indexterm" data-primary="software as a service (SaaS)" id="idm45139264198552" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/>Even packaged software can consist of a series of microservices. For example, Spinnaker itself is a suite of microservices that are intended to be deployed together. Generally there is an extra step for packaged software: producing some sort of bill of materials that itself is revisioned containing versions for each individual microservice. These versions are included in the bill of materials to indicate that they are tested <em class="calibre12">together</em> and known to work as a group. Bills of materials help to create potentially many running copies of a set of microservices. When running SaaS, the production environment tends to be the only running copy, and the bill of materials isn’t necessary.</p>
</div>

<p class="author1">The Nebula release plug-in is applied to the root project of a Gradle project, as shown in <a data-type="xref" href="part0011_split_009.html#AFMJJ-2d714b853a094e9a910510217e0e3d73" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">Example 6-4</a>.</p>
<div id="apply_nebula_release" data-type="example" class="calibre61">
<h5 class="calibre62" id="AFMJJ-2d714b853a094e9a910510217e0e3d73"><span class="keep-together">Example 6-4. </span>The Nebula release plug-in applied to the root project of a Gradle project</h5>

<pre data-type="programlisting" data-code-language="kotlin" class="calibre63"><code class="n">plugins</code><code class="calibre24"> </code><code class="p">{</code><code class="calibre24">
</code><code class="calibre24">  </code><code class="n">java</code><code class="calibre24">
</code><code class="calibre24">  </code><code class="n">id</code><code class="p">(</code><code class="s">"nebula.release"</code><code class="p">)</code><code class="calibre24"> </code><code class="n">version</code><code class="calibre24"> </code><code class="s">"LATEST"</code><code class="calibre24"> </code><a class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre" id="co_source_code_observability_CO2-1" href="part0011_split_009.html#callout_source_code_observability_CO2-1"><img src="../images/00112.png" alt="1" class="calibre66"/></a><code class="calibre24">
</code><code class="calibre24">  </code><code class="n">id</code><code class="p">(</code><code class="s">"nebula.maven-publish"</code><code class="p">)</code><code class="calibre24"> </code><code class="n">version</code><code class="calibre24"> </code><code class="s">"LATEST"</code><code class="calibre24">
</code><code class="calibre24">  </code><code class="n">id</code><code class="p">(</code><code class="s">"nebula.maven-resolved-dependencies"</code><code class="p">)</code><code class="calibre24"> </code><code class="n">version</code><code class="calibre24"> </code><code class="s">"LATEST"</code><code class="calibre24">
</code><code class="p">}</code><code class="calibre24">
</code><code class="calibre24">
</code><code class="n">project</code><code class="calibre24">
</code><code class="calibre24">  </code><code class="p">.</code><code class="n">rootProject</code><code class="calibre24">
</code><code class="calibre24">  </code><code class="p">.</code><code class="n">tasks</code><code class="calibre24">
</code><code class="calibre24">  </code><code class="p">.</code><code class="n">getByName</code><code class="p">(</code><code class="s">"devSnapshot"</code><code class="p">)</code><code class="calibre24">
</code><code class="calibre24">  </code><code class="p">.</code><code class="n">dependsOn</code><code class="p">(</code><code class="n">project</code><code class="calibre24">
</code><code class="calibre24">    </code><code class="p">.</code><code class="n">tasks</code><code class="calibre24">
</code><code class="calibre24">    </code><code class="p">.</code><code class="n">getByName</code><code class="p">(</code><code class="s">"publishNebulaPublicationToArtifactory"</code><code class="p">)</code><code class="p">)</code><code class="calibre24"> </code><a class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre" id="co_source_code_observability_CO2-2" href="part0011_split_009.html#callout_source_code_observability_CO2-2"><img src="../images/00059.png" alt="2" class="calibre66"/></a><code class="calibre24">
</code><code class="calibre24">
</code><code class="n">project</code><code class="calibre24">
</code><code class="calibre24">  </code><code class="p">.</code><code class="n">gradle</code><code class="calibre24">
</code><code class="calibre24">  </code><code class="p">.</code><code class="n">taskGraph</code><code class="calibre24">
</code><code class="calibre24">  </code><code class="p">.</code><code class="n">whenReady</code><code class="p">(</code><code class="k">object</code><code class="p">:</code><code class="calibre24"> </code><code class="n">Action</code><code class="p">&lt;</code><code class="n">TaskExecutionGraph</code><code class="p">&gt;</code><code class="calibre24"> </code><code class="p">{</code><code class="calibre24"> </code><a class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre" id="co_source_code_observability_CO2-3" href="part0011_split_009.html#callout_source_code_observability_CO2-3"><img src="../images/00067.png" alt="3" class="calibre66"/></a><code class="calibre24">
</code><code class="calibre24">    </code><code class="k">override</code><code class="calibre24"> </code><code class="k">fun</code><code class="calibre24"> </code><code class="nf">execute</code><code class="p">(</code><code class="n">graph</code><code class="p">:</code><code class="calibre24"> </code><code class="n">TaskExecutionGraph</code><code class="p">)</code><code class="calibre24"> </code><code class="p">{</code><code class="calibre24">
</code><code class="calibre24">      </code><code class="k">if</code><code class="calibre24"> </code><code class="p">(</code><code class="n">graph</code><code class="p">.</code><code class="n">hasTask</code><code class="p">(</code><code class="s">":snapshot"</code><code class="p">)</code><code class="calibre24"> </code><code class="p">|</code><code class="p">|</code><code class="calibre24">
</code><code class="calibre24">        </code><code class="n">graph</code><code class="p">.</code><code class="n">hasTask</code><code class="p">(</code><code class="s">":immutableSnapshot"</code><code class="p">)</code><code class="p">)</code><code class="calibre24"> </code><code class="p">{</code><code class="calibre24">
</code><code class="calibre24">
</code><code class="calibre24">        </code><code class="k">throw</code><code class="calibre24"> </code><code class="n">GradleException</code><code class="p">(</code><code class="s">"You cannot use the snapshot or"</code><code class="calibre24"> </code><code class="p">+</code><code class="calibre24">
</code><code class="calibre24">          </code><code class="s">"immutableSnapshot task from the release plugin. "</code><code class="calibre24"> </code><code class="p">+</code><code class="calibre24">
</code><code class="calibre24">          </code><code class="s">"Please use the devSnapshot task."</code><code class="p">)</code><code class="calibre24">
</code><code class="calibre24">      </code><code class="p">}</code><code class="calibre24">
</code><code class="calibre24">    </code><code class="p">}</code><code class="calibre24">
</code><code class="calibre24">  </code><code class="p">}</code><code class="p">)</code><code class="calibre24">
</code><code class="calibre24">
</code><code class="n">publishing</code><code class="calibre24"> </code><code class="p">{</code><code class="calibre24">
</code><code class="calibre24">  </code><code class="n">repositories</code><code class="calibre24"> </code><code class="p">{</code><code class="calibre24">
</code><code class="calibre24">    </code><code class="n">maven</code><code class="calibre24"> </code><code class="p">{</code><code class="calibre24">
</code><code class="calibre24">      </code><code class="n">name</code><code class="calibre24"> </code><code class="p">=</code><code class="calibre24"> </code><code class="s">"Artifactory"</code><code class="calibre24"> </code><a class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre" id="co_source_code_observability_CO2-4" href="part0011_split_009.html#callout_source_code_observability_CO2-4"><img src="../images/00016.png" alt="4" class="calibre66"/></a><code class="calibre24">
</code><code class="calibre24">      </code><code class="n">url</code><code class="calibre24"> </code><code class="p">=</code><code class="calibre24"> </code><code class="n">URI</code><code class="p">.</code><code class="n">create</code><code class="p">(</code><code class="s">"https://repo.myorg.com/libs-services-local"</code><code class="p">)</code><code class="calibre24">
</code><code class="calibre24">    </code><code class="p">}</code><code class="calibre24">
</code><code class="calibre24">  </code><code class="p">}</code><code class="calibre24">
</code><code class="p">}</code></pre></div>
<dl class="calibre20">
<dt class="calibre21"><a class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre" id="callout_source_code_observability_CO2-1" href="part0011_split_009.html#co_source_code_observability_CO2-1"><img src="../images/00112.png" alt="1" class="calibre66"/></a></dt>
<dd class="calibre67"><p class="calibre68">Replace <code class="calibre24">LATEST</code> with the version listed on the <a href="https://oreil.ly/_MRA2" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">Gradle plug-in portal</a>.</p></dd>
<dt class="calibre21"><a class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre" id="callout_source_code_observability_CO2-2" href="part0011_split_009.html#co_source_code_observability_CO2-2"><img src="../images/00059.png" alt="2" class="calibre66"/></a></dt>
<dd class="calibre67"><p class="calibre68">Whenever the CI build executes <code class="calibre24">devSnapshot</code>, build and publish an artifact to Artifactory. Because we <em class="calibre12">haven’t</em> attached <code class="calibre24">final</code> to publishing, running <code class="calibre24">./gradlew final</code> in a stage after promotion to production will tag the repository with the current minor release (e.g., v0.1.0) and push the tag to the repository, but not unnecessarily upload another artifact to the artifact repository. The existence of this tag completes the development cycle. Any subsequent code pushes, and therefore runs of <code class="calibre24">./gradlew devSnapshot</code>, then generate snapshots for the next minor release (e.g., <code class="calibre24">0.2.0-snapshot.&lt;timestamp&gt;+&lt;commit_hash&gt;</code>).</p></dd>
<dt class="calibre21"><a class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre" id="callout_source_code_observability_CO2-3" href="part0011_split_009.html#co_source_code_observability_CO2-3"><img src="../images/00067.png" alt="3" class="calibre66"/></a></dt>
<dd class="calibre67"><p class="calibre68">Optionally, ensure that developers don’t accidentally use the other types of snapshot tasks made available by Nebula release that would generate snapshots with different version number semantics.</p></dd>
<dt class="calibre21"><a class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre" id="callout_source_code_observability_CO2-4" href="part0011_split_009.html#co_source_code_observability_CO2-4"><img src="../images/00016.png" alt="4" class="calibre66"/></a></dt>
<dd class="calibre67"><p class="calibre68">Define the repository that is referenced in the <code class="calibre24">dependsOn</code> clause of <code class="calibre24">devSnapshot</code>.</p></dd>
</dl>

<p class="author1">For the continuous deployment model of every commit (that passes automated tests) resulting in a production deployment, provided that there is no need for an automated test suite in a lower environment, there will be precisely one snapshot per minor release. If all your checks were run prior to artifact publishing, and you trust the outcome enough to promote to production immediately, you could easily use <code class="calibre24">./gradlew final</code> and avoid immutable snapshots altogether. Few enterprises are going to be comfortable with this, and there is no pressure to ever reach this level of automation. As mentioned in <a data-type="xref" href="part0007_split_021.html#6LM03-2d714b853a094e9a910510217e0e3d73" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">“Separating Platform and Application Metrics”</a>, you “ship your org chart” to some extent.</p>

<p class="author1">Associating every deployment with an immutable release version is the first phase in the artifact provenance chain. When you have a combination of the ability to interrogate your delivery service for all current deployments <em class="calibre12">and</em> your delivery automation somehow tags each deployment with an immutable release version (whether this is stored in the Auto Scaling Group name in EC2, a Kubernetes tag, etc.), you unlock the ability to iterate over all production deployment resources and map to artifact coordinates that are retrievable from your artifact repository.</p>

<p class="author1">The pseudocode showing the extent of the artifact provenance chain to this point is in <a data-type="xref" href="part0011_split_009.html#mapping_to_artifact" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">Example 6-5</a>.</p>
<div id="mapping_to_artifact" data-type="example" class="calibre61">
<h5 class="calibre62"><span class="keep-together">Example 6-5. </span>Mapping deployed resources to artifact versions</h5>

<pre data-type="programlisting" data-code-language="java" class="calibre63"><code class="n">delivery</code><code class="calibre24">
</code><code class="calibre24">  </code><code class="o">.</code><code class="na">getApplications</code><code class="o">(</code><code class="o">)</code><code class="calibre24">
</code><code class="calibre24">  </code><code class="o">.</code><code class="na">flatMap</code><code class="o">(</code><code class="n">application</code><code class="calibre24"> </code><code class="o">-</code><code class="o">&gt;</code><code class="calibre24"> </code><code class="n">application</code><code class="o">.</code><code class="na">getClusters</code><code class="o">(</code><code class="o">)</code><code class="o">)</code><code class="calibre24">
</code><code class="calibre24">  </code><code class="o">.</code><code class="na">flatMap</code><code class="o">(</code><code class="n">cluster</code><code class="calibre24"> </code><code class="o">-</code><code class="o">&gt;</code><code class="calibre24"> </code><code class="n">cluster</code><code class="o">.</code><code class="na">getServerGroups</code><code class="o">(</code><code class="o">)</code><code class="o">)</code><code class="calibre24">
</code><code class="calibre24">  </code><code class="o">.</code><code class="na">map</code><code class="o">(</code><code class="n">serverGroup</code><code class="calibre24"> </code><code class="o">-</code><code class="o">&gt;</code><code class="calibre24"> </code><code class="n">serverGroup</code><code class="o">.</code><code class="na">getArtifact</code><code class="o">(</code><code class="o">)</code><code class="o">)</code><code class="calibre24"> </code><a class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre" id="co_source_code_observability_CO3-1" href="part0011_split_009.html#callout_source_code_observability_CO3-1"><img src="../images/00112.png" alt="1" class="calibre66"/></a><code class="calibre24">
</code><code class="calibre24">
</code><code class="c">// Where...
</code><code class="nd">@EqualsAndHashCode</code><code class="o">(</code><code class="n">includes</code><code class="calibre24"> </code><code class="o">=</code><code class="calibre24"> </code><code class="o">{</code><code class="s">"group"</code><code class="o">,</code><code class="calibre24"> </code><code class="s">"artifact"</code><code class="o">,</code><code class="calibre24"> </code><code class="s">"version"</code><code class="o">}</code><code class="o">)</code><code class="calibre24"> </code><a class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre" id="co_source_code_observability_CO3-2" href="part0011_split_009.html#callout_source_code_observability_CO3-2"><img src="../images/00059.png" alt="2" class="calibre66"/></a><code class="calibre24">
</code><code class="k">class</code><code class="calibre24"> </code><code class="nc">Artifact</code><code class="calibre24"> </code><code class="o">{</code><code class="calibre24">
</code><code class="calibre24">  </code><code class="n">String</code><code class="calibre24"> </code><code class="n">group</code><code class="o">;</code><code class="calibre24">
</code><code class="calibre24">  </code><code class="n">String</code><code class="calibre24"> </code><code class="n">artifact</code><code class="o">;</code><code class="calibre24">
</code><code class="calibre24">  </code><code class="n">String</code><code class="calibre24"> </code><code class="n">version</code><code class="o">;</code><code class="calibre24">
</code><code class="calibre24">  </code><code class="n">Set</code><code class="o">&lt;</code><code class="n">Artifact</code><code class="o">&gt;</code><code class="calibre24"> </code><code class="n">dependencies</code><code class="o">;</code><code class="calibre24"> </code><a class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre" id="co_source_code_observability_CO3-3" href="part0011_split_009.html#callout_source_code_observability_CO3-3"><img src="../images/00067.png" alt="3" class="calibre66"/></a><code class="calibre24">
</code><code class="o">}</code></pre></div>
<dl class="calibre20">
<dt class="calibre21"><a class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre" id="callout_source_code_observability_CO3-1" href="part0011_split_009.html#co_source_code_observability_CO3-1"><img src="../images/00112.png" alt="1" class="calibre66"/></a></dt>
<dd class="calibre67"><p class="calibre68">Type is <code class="calibre24">Stream&lt;Artifact&gt;</code> because there is a 1:1 correspondence between a deployment and an artifact.</p></dd>
<dt class="calibre21"><a class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre" id="callout_source_code_observability_CO3-2" href="part0011_split_009.html#co_source_code_observability_CO3-2"><img src="../images/00059.png" alt="2" class="calibre66"/></a></dt>
<dd class="calibre67"><p class="calibre68">Because <code class="calibre24">devSnapshot</code> produces immutable artifact versions that are unique for every unique combination of source code and dependencies, two artifacts with the same group/artifact/version coordinates are guaranteed to have the same dependencies as well.</p></dd>
<dt class="calibre21"><a class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre" id="callout_source_code_observability_CO3-3" href="part0011_split_009.html#co_source_code_observability_CO3-3"><img src="../images/00067.png" alt="3" class="calibre66"/></a></dt>
<dd class="calibre67"><p class="calibre68">At this stage, we don’t yet have the ability to determine dependencies.</p></dd>
</dl>

<p class="author1">We need more configuration up front to provide artifact provenance that includes dependencies as well<a data-type="indexterm" data-startref="ix_ch06-asciidoc8" id="idm45139263630792" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/><a data-type="indexterm" data-startref="ix_ch06-asciidoc7" id="idm45139263630088" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/>.<a data-type="indexterm" data-startref="ix_ch06-asciidoc4" id="idm45139263629288" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/><a data-type="indexterm" data-startref="ix_ch06-asciidoc3" id="idm45139263592264" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/></p>
</div></section>





</div></section>













</div></section></div>



  

<div id="sbo-rt-content" class="calibre2">
<section data-type="chapter" type="chapter" data-pdf-bookmark="Chapter 6. Source Code Observability" class="calibre3">
<div class="preface" id="ch_source_code_observability">
<section data-type="sect1" data-pdf-bookmark="Capturing Resolved Dependencies in Metadata" class="calibre3"><div class="preface" id="idm45139264520008">
<h1 class="calibre19" id="AFMVV-2d714b853a094e9a910510217e0e3d73">Capturing Resolved Dependencies in Metadata</h1>

<p class="author1"><a data-type="indexterm" data-primary="dependency management" data-secondary="capturing resolved dependencies in metadata" id="ix_ch06-asciidoc9" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/><a data-type="indexterm" data-primary="metadata, capturing resolved dependencies in" id="ix_ch06-asciidoc10" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/><a data-type="indexterm" data-primary="source code observability" data-secondary="capturing resolved dependencies in metadata" id="ix_ch06-asciidoc11" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/>Extending the provenance chain deeper to include the dependencies of applications allows us to quickly find which deployed assets contain a version of a <em class="calibre12">library</em> that may be problematic, for example, because of an identified security vulnerability.</p>

<p class="author1">Generally, when we publish a Maven POM file along with the application, it contains a <code class="calibre24">&lt;dependencies&gt;</code> block that only lists the first-level dependencies. These are the dependencies that are directly listed in the <code class="calibre24">dependencies { }</code> section of the Gradle build as well. For example, for a sample Spring Boot application generated from <a href="https://start.spring.io" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">start.spring.io</a>, the first-level dependencies would be something like <a data-type="xref" href="part0011_split_010.html#first_level_dependencies" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">Example 6-6</a>. Specifically, <code class="calibre24">spring-boot-starter-actuator</code> and <code class="calibre24">spring-boot-starter-webflux</code> are the two first-level dependencies.</p>
<div id="first_level_dependencies" data-type="example" class="calibre61">
<h5 class="calibre62"><span class="keep-together">Example 6-6. </span>First-level dependencies of a sample Spring Boot application</h5>

<pre data-type="programlisting" data-code-language="kotlin" class="calibre63"><code class="n">dependencies</code> <code class="p">{</code>
  <code class="n">implementation</code><code class="p">(</code><code class="s">"org.springframework.boot:spring-boot-starter-actuator"</code><code class="p">)</code>
  <code class="n">implementation</code><code class="p">(</code><code class="s">"org.springframework.boot:spring-boot-starter-webflux"</code><code class="p">)</code>
  <code class="n">testImplementation</code><code class="p">(</code><code class="s">"org.springframework.boot:spring-boot-starter-test"</code><code class="p">)</code>
  <code class="n">testImplementation</code><code class="p">(</code><code class="s">"io.projectreactor:reactor-test"</code><code class="p">)</code>
<code class="p">}</code></pre></div>

<p class="author1">For the sake of establishing a provenance chain, test dependencies are not really important. They are only on the classpath during test execution on local developer machines and on continuous integration builds, and they aren’t packed in the final application that is running in the deployed environment. Any problem or vulnerability in test dependencies is safely confined to the continuous integration environment and doesn’t cause problems in running deployed applications.</p>

<p class="author1">When this application is published to an artifact repository like Artifactory, a Maven POM file is published alongside the binary artifact which contains a <code class="calibre24">dependencies</code> section like in <a data-type="xref" href="part0011_split_010.html#first_level_dependencies_pom" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">Example 6-7</a>.</p>
<div id="first_level_dependencies_pom" data-type="example" class="calibre61">
<h5 class="calibre62"><span class="keep-together">Example 6-7. </span>First-level dependencies as they appear in the Maven POM</h5>

<pre data-type="programlisting" data-code-language="xml" class="calibre63"><code class="nt">&lt;dependencies&gt;</code>
  <code class="nt">&lt;dependency&gt;</code>
    <code class="nt">&lt;groupId&gt;</code>org.springframework.boot<code class="nt">&lt;/groupId&gt;</code>
    <code class="nt">&lt;artifactId&gt;</code>spring-boot-starter-actuator<code class="nt">&lt;/artifactId&gt;</code>
    <code class="nt">&lt;version&gt;</code>2.3.0.M4<code class="nt">&lt;/version&gt;</code>
    <code class="nt">&lt;scope&gt;</code>runtime<code class="nt">&lt;/scope&gt;</code>
  <code class="nt">&lt;/dependency&gt;</code>
  <code class="nt">&lt;dependency&gt;</code>
    <code class="nt">&lt;groupId&gt;</code>org.springframework.boot<code class="nt">&lt;/groupId&gt;</code>
    <code class="nt">&lt;artifactId&gt;</code>spring-boot-starter-webflux<code class="nt">&lt;/artifactId&gt;</code>
    <code class="nt">&lt;version&gt;</code>2.3.0.M4<code class="nt">&lt;/version&gt;</code>
    <code class="nt">&lt;scope&gt;</code>runtime<code class="nt">&lt;/scope&gt;</code>
  <code class="nt">&lt;/dependency&gt;</code>
<code class="nt">&lt;/dependencies&gt;</code></pre></div>

<p class="author1">First-level dependencies of course bring in <em class="calibre12">other</em> dependencies. The set of all other dependencies, resolved recursively from the first level down, is called the transitive closure of dependencies.</p>

<p class="author1">It may be tempting to think that the transitive closure of dependencies in this sample application could be determined simply by recursively fetching the POM files of each dependency from the artifact repository. This is unfortunately not the case. Commonly enough, additional constraints are present in the build that influence in some way the transitive dependencies that were resolved and packaged with the application. For example, a particular version could be denied with a replacement because some critical bug is fixed by a later version, as in <a data-type="xref" href="part0011_split_010.html#dependency_denied_replacement" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">Example 6-8</a>.</p>
<div id="dependency_denied_replacement" data-type="example" class="calibre61">
<h5 class="calibre62"><span class="keep-together">Example 6-8. </span>Denying a version with a replacement</h5>

<pre data-type="programlisting" data-code-language="kotlin" class="calibre63"><code class="n">configurations</code><code class="p">.</code><code class="n">all</code> <code class="p">{</code>
  <code class="n">resolutionStrategy</code><code class="p">.</code><code class="n">eachDependency</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="n">requested</code><code class="p">.</code><code class="n">group</code> <code class="p">==</code> <code class="s">"org.software"</code> <code class="p">&amp;&amp;</code>
      <code class="n">requested</code><code class="p">.</code><code class="n">name</code> <code class="p">==</code> <code class="s">"some-library"</code><code class="p">)</code> <code class="p">{</code>

      <code class="n">useVersion</code><code class="p">(</code><code class="s">"1.2.1"</code><code class="p">)</code>
      <code class="n">because</code><code class="p">(</code><code class="s">"fixes critical bug in 1.2"</code><code class="p">)</code>
    <code class="p">}</code>
  <code class="p">}</code>
<code class="p">}</code></pre></div>
</div></section>













</div></section></div>



  

<div id="sbo-rt-content" class="calibre2">
<section data-type="chapter" type="chapter" data-pdf-bookmark="Chapter 6. Source Code Observability" class="calibre3">
<div class="preface" id="ch_source_code_observability">
<section data-type="sect1" data-pdf-bookmark="Capturing Resolved Dependencies in Metadata" class="calibre3">
<div class="preface" id="idm45139264520008">
<div data-type="warning" type="warning" class="calibre30"><h1 class="calibre69" id="calibre_pb_11">No Process That Determines Dependencies from the Artifact Repository Alone Is Correct</h1>
<p class="author1">The consequence of build-time features like resolution strategies is that no process that tries to determine the transitive closure of dependencies from standard artifact metadata alone (such as the POM <code class="calibre24">&lt;dependencies&gt;</code> block) will be correct.</p>

<p class="author1">Vendors trying to build universal component analysis tools strictly from standard metadata can only give you an <em class="calibre12">approximation</em> of what dependencies are in use. And this approximation is often not trivially divergent from reality.</p>
</div>

<p class="author1">As a result of resolution strategies, forced versions, etc., the transitive closure must be persisted somehow as the application binary is published. One easy way to do this is to include the resolved transitive closure in a POM <code class="calibre24">&lt;properties&gt;</code> element for later consumption by any tooling you build to examine the dependencies in use across your organization.</p>

<p class="author1">The <a href="https://oreil.ly/ASOpi" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">Nebula Info</a> plug-in specializes in just this, attaching build-time metadata to the <code class="calibre24">&lt;properties&gt;</code> section of a POM. Out of the box, Nebula Info adds properties for things like Git commit hash and branch, the source and target Java version, and build host.</p>

<p class="author1">The <code class="calibre24">InfoBrokerPlugin</code> allows us to add new properties at will by key-value pair. <a data-type="xref" href="part0011_split_011.html#AFN3T-2d714b853a094e9a910510217e0e3d73" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">Example 6-9</a> shows how to traverse the transitive dependency closure of the runtime classpath and add the list of dependencies as a property. <a href="https://oreil.ly/Bb-hM" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"><code class="calibre24">nebula.maven-manifest</code></a>, included automatically by <code class="calibre24">nebula.maven-publish</code>, reads all the properties managed by the info broker and adds them as POM properties.</p>
<div id="nebula_info_dependencies_flat" data-type="example" class="calibre61">
<h5 class="calibre62" id="AFN3T-2d714b853a094e9a910510217e0e3d73"><span class="keep-together">Example 6-9. </span>List all transitive dependencies sorted in a flat list</h5>

<pre data-type="programlisting" data-code-language="java" class="calibre63"><code class="n">plugins</code><code class="calibre24"> </code><code class="o">{</code><code class="calibre24">
</code><code class="calibre24">  </code><code class="n">id</code><code class="o">(</code><code class="s">"nebula.maven-publish"</code><code class="o">)</code><code class="calibre24"> </code><code class="n">version</code><code class="calibre24"> </code><code class="s">"LATEST"</code><code class="calibre24"> </code><a class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre" id="co_source_code_observability_CO4-1" href="part0011_split_011.html#callout_source_code_observability_CO4-1"><img src="../images/00112.png" alt="1" class="calibre66"/></a><code class="calibre24">
</code><code class="calibre24">  </code><code class="n">id</code><code class="o">(</code><code class="s">"nebula.info"</code><code class="o">)</code><code class="calibre24"> </code><code class="n">version</code><code class="calibre24"> </code><code class="s">"LATEST"</code><code class="calibre24">
</code><code class="o">}</code><code class="calibre24">
</code><code class="calibre24">
</code><code class="n">tasks</code><code class="o">.</code><code class="na">withType</code><code class="o">&lt;</code><code class="n">GenerateMavenPom</code><code class="o">&gt;</code><code class="calibre24"> </code><code class="o">{</code><code class="calibre24">
</code><code class="calibre24">  </code><code class="n">doFirst</code><code class="calibre24"> </code><code class="o">{</code><code class="calibre24">
</code><code class="calibre24">    </code><code class="n">val</code><code class="calibre24"> </code><code class="n">runtimeClasspath</code><code class="calibre24"> </code><code class="o">=</code><code class="calibre24"> </code><code class="n">configurations</code><code class="calibre24">
</code><code class="calibre24">      </code><code class="o">.</code><code class="na">getByName</code><code class="o">(</code><code class="s">"runtimeClasspath"</code><code class="o">)</code><code class="calibre24">
</code><code class="calibre24">    </code><code class="n">val</code><code class="calibre24"> </code><code class="n">gav</code><code class="calibre24"> </code><code class="o">=</code><code class="calibre24"> </code><code class="o">{</code><code class="calibre24"> </code><code class="nd">d:</code><code class="calibre24"> </code><code class="n">ResolvedDependency</code><code class="calibre24"> </code><code class="o">-</code><code class="o">&gt;</code><code class="calibre24">
</code><code class="calibre24">      </code><code class="s">"${d.moduleGroup}:${d.moduleName}:${d.moduleVersion}"</code><code class="calibre24">
</code><code class="calibre24">    </code><code class="o">}</code><code class="calibre24">
</code><code class="calibre24">    </code><code class="n">val</code><code class="calibre24"> </code><code class="n">indented</code><code class="calibre24"> </code><code class="o">=</code><code class="calibre24"> </code><code class="s">"\n"</code><code class="calibre24"> </code><code class="o">+</code><code class="calibre24"> </code><code class="s">" "</code><code class="o">.</code><code class="na">repeat</code><code class="o">(</code><code class="mi">6</code><code class="o">)</code><code class="calibre24">
</code><code class="calibre24">
</code><code class="calibre24">    </code><code class="n">project</code><code class="o">.</code><code class="na">plugins</code><code class="o">.</code><code class="na">withType</code><code class="o">&lt;</code><code class="n">InfoBrokerPlugin</code><code class="o">&gt;</code><code class="calibre24"> </code><code class="o">{</code><code class="calibre24">
</code><code class="calibre24">      </code><code class="n">add</code><code class="o">(</code><code class="s">"Resolved-Dependencies"</code><code class="o">,</code><code class="calibre24"> </code><code class="n">runtimeClasspath</code><code class="calibre24">
</code><code class="calibre24">        </code><code class="o">.</code><code class="na">resolvedConfiguration</code><code class="calibre24">
</code><code class="calibre24">        </code><code class="o">.</code><code class="na">lenientConfiguration</code><code class="calibre24">
</code><code class="calibre24">        </code><code class="o">.</code><code class="na">allModuleDependencies</code><code class="calibre24">
</code><code class="calibre24">        </code><code class="o">.</code><code class="na">sortedBy</code><code class="o">(</code><code class="n">gav</code><code class="o">)</code><code class="calibre24">
</code><code class="calibre24">        </code><code class="o">.</code><code class="na">joinToString</code><code class="o">(</code><code class="calibre24">
</code><code class="calibre24">          </code><code class="n">indented</code><code class="o">,</code><code class="calibre24">
</code><code class="calibre24">          </code><code class="n">indented</code><code class="o">,</code><code class="calibre24">
</code><code class="calibre24">          </code><code class="s">"\n"</code><code class="calibre24"> </code><code class="o">+</code><code class="calibre24"> </code><code class="s">" "</code><code class="o">.</code><code class="na">repeat</code><code class="o">(</code><code class="mi">4</code><code class="o">)</code><code class="o">,</code><code class="calibre24"> </code><code class="n">transform</code><code class="calibre24"> </code><code class="o">=</code><code class="calibre24"> </code><code class="n">gav</code><code class="calibre24">
</code><code class="calibre24">        </code><code class="o">)</code><code class="calibre24">
</code><code class="calibre24">      </code><code class="o">)</code><code class="calibre24">
</code><code class="calibre24">    </code><code class="o">}</code><code class="calibre24">
</code><code class="calibre24">  </code><code class="o">}</code><code class="calibre24">
</code><code class="o">}</code></pre></div>
<dl class="calibre20">
<dt class="calibre21"><a class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre" id="callout_source_code_observability_CO4-1" href="part0011_split_011.html#co_source_code_observability_CO4-1"><img src="../images/00112.png" alt="1" class="calibre66"/></a></dt>
<dd class="calibre67"><p class="calibre68">Replace <code class="calibre24">LATEST</code> with whatever the latest version is on the <a href="https://oreil.ly/TNrDy" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">Gradle Plug-in Portal</a>.</p></dd>
</dl>

<p class="author1">This results in a properties listing in the POM that looks something like <a data-type="xref" href="part0011_split_011.html#nebula_info_dependencies_flat_pom" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">Example 6-10</a>.</p>
<div id="nebula_info_dependencies_flat_pom" data-type="example" class="calibre61">
<h5 class="calibre62"><span class="keep-together">Example 6-10. </span>A flattened transitive dependency closure listed, sorted, and added as a POM property</h5>

<pre data-type="programlisting" data-code-language="xml" class="calibre63"><code class="nt">&lt;project</code> <code class="err">...</code><code class="nt">&gt;</code>
  <code class="nt">&lt;groupId&gt;</code>com.example<code class="nt">&lt;/groupId&gt;</code>
  <code class="nt">&lt;artifactId&gt;</code>demo<code class="nt">&lt;/artifactId&gt;</code>
  <code class="nt">&lt;version&gt;</code>0.1.0<code class="nt">&lt;/version&gt;</code>
  <code class="nt">&lt;name&gt;</code>demo<code class="nt">&lt;/name&gt;</code>
  ...
  <code class="nt">&lt;properties&gt;</code>
    <code class="nt">&lt;nebula_Change&gt;</code>1b0f8d9<code class="nt">&lt;/nebula_Change&gt;</code>
    <code class="nt">&lt;nebula_Branch&gt;</code>master<code class="nt">&lt;/nebula_Branch&gt;</code>
    <code class="nt">&lt;nebula_X_Compile_Target_JDK&gt;</code>11<code class="nt">&lt;/nebula_X_Compile_Target_JDK&gt;</code>
    <code class="nt">&lt;nebula_Resolved_Dependencies&gt;</code>
      ch.qos.logback:logback-classic:1.2.3
      ch.qos.logback:logback-core:1.2.3
      com.datastax.oss:java-driver-bom:4.5.1
      com.fasterxml.jackson.core:jackson-annotations:2.11.0.rc1
      com.fasterxml.jackson.core:jackson-core:2.11.0.rc1
      com.fasterxml.jackson.core:jackson-databind:2.11.0.rc1
    <code class="nt">&lt;/nebula_Resolved_Dependencies&gt;</code>
  <code class="nt">&lt;/properties&gt;</code>
<code class="nt">&lt;/project&gt;</code></pre></div>

<p class="author1">Now, to build tooling to find all deployments that contain <code class="calibre24">logback-core</code> version 1.2.3, we can use something like the pseudocode in <a data-type="xref" href="part0011_split_011.html#mapping_to_artifact_dependencies" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">Example 6-11</a> to list all the server groups containing a particular <code class="calibre24">logback-core</code> dependency. The population of <code class="calibre24">dependencies</code> on the <code class="calibre24">Artifact</code> type consists of downloading the POM from the artifact repository, given the Artifact’s group/artifact/version coordinates, and parsing the contents of the <code class="calibre24">&lt;nebula_Resolved_Dependencies&gt;</code> POM property.</p>
<div id="mapping_to_artifact_dependencies" data-type="example" class="calibre61">
<h5 class="calibre62"><span class="keep-together">Example 6-11. </span>Mapping deployed resources to the set of all dependencies included in them</h5>

<pre data-type="programlisting" data-code-language="java" class="calibre63"><code class="n">delivery</code>
  <code class="o">.</code><code class="na">getApplications</code><code class="o">()</code>
  <code class="o">.</code><code class="na">flatMap</code><code class="o">(</code><code class="n">application</code> <code class="o">-&gt;</code> <code class="n">application</code><code class="o">.</code><code class="na">getClusters</code><code class="o">())</code>
  <code class="o">.</code><code class="na">flatMap</code><code class="o">(</code><code class="n">cluster</code> <code class="o">-&gt;</code> <code class="n">cluster</code><code class="o">.</code><code class="na">getServerGroups</code><code class="o">())</code>
  <code class="o">.</code><code class="na">filter</code><code class="o">(</code><code class="n">artifact</code> <code class="o">-&gt;</code> <code class="n">serverGroup</code>
    <code class="o">.</code><code class="na">getArtifact</code><code class="o">()</code>
    <code class="o">.</code><code class="na">getDependencies</code><code class="o">()</code>
    <code class="o">.</code><code class="na">stream</code><code class="o">()</code>
    <code class="o">.</code><code class="na">anyMatch</code><code class="o">(</code><code class="n">d</code> <code class="o">-&gt;</code> <code class="n">d</code><code class="o">.</code><code class="na">getArtifact</code><code class="o">().</code><code class="na">equals</code><code class="o">(</code><code class="s">"logback-core"</code><code class="o">)</code> <code class="o">&amp;&amp;</code>
      <code class="n">d</code><code class="o">.</code><code class="na">getVersion</code><code class="o">().</code><code class="na">equals</code><code class="o">(</code><code class="s">"1.2.3"</code><code class="o">))</code>
  <code class="o">)</code></pre></div>

<p class="author1">The flattened list representation can be improved upon a little for readability when glancing at an individual POM file without really affecting how we parse the transitive closure for a given artifact. <a data-type="xref" href="part0011_split_011.html#AFND5-2d714b853a094e9a910510217e0e3d73" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">Example 6-12</a> shows how to instead create a pretty-printed minimum spanning tree of the transitive closure of dependencies.</p>
<div id="nebula_info_dependencies_tree" data-type="example" class="calibre61">
<h5 class="calibre62" id="AFND5-2d714b853a094e9a910510217e0e3d73"><span class="keep-together">Example 6-12. </span>A tree view of the transitive dependency closure added as a POM property</h5>

<pre data-type="programlisting" data-code-language="kotlin" class="calibre63"><code class="n">tasks</code><code class="p">.</code><code class="n">withType</code><code class="p">&lt;</code><code class="n">GenerateMavenPom</code><code class="p">&gt;</code> <code class="p">{</code>
  <code class="n">doFirst</code> <code class="p">{</code>
    <code class="k">val</code> <code class="py">runtimeClasspath</code> <code class="p">=</code> <code class="n">configurations</code><code class="p">.</code><code class="n">getByName</code><code class="p">(</code><code class="s">"runtimeClasspath"</code><code class="p">)</code>

    <code class="k">val</code> <code class="py">gav</code> <code class="p">=</code> <code class="p">{</code> <code class="n">d</code><code class="p">:</code> <code class="n">ResolvedDependency</code> <code class="p">-&gt;</code>
      <code class="s">"${d.moduleGroup}:${d.moduleName}:${d.moduleVersion}"</code>
    <code class="p">}</code>

    <code class="k">val</code> <code class="py">observedDependencies</code> <code class="p">=</code> <code class="n">TreeSet</code><code class="p">&lt;</code><code class="n">ResolvedDependency</code><code class="p">&gt;</code> <code class="p">{</code> <code class="n">d1</code><code class="p">,</code> <code class="n">d2</code> <code class="p">-&gt;</code>
      <code class="n">gav</code><code class="p">(</code><code class="n">d1</code><code class="p">).</code><code class="n">compareTo</code><code class="p">(</code><code class="n">gav</code><code class="p">(</code><code class="n">d2</code><code class="p">))</code>
    <code class="p">}</code>

    <code class="k">fun</code> <code class="nf">reduceDependenciesAtIndent</code><code class="p">(</code><code class="n">indent</code><code class="p">:</code> <code class="n">Int</code><code class="p">):</code>
      <code class="p">(</code><code class="n">List</code><code class="p">&lt;</code><code class="n">String</code><code class="p">&gt;,</code> <code class="n">ResolvedDependency</code><code class="p">)</code> <code class="p">-&gt;</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">String</code><code class="p">&gt;</code> <code class="p">=</code>
      <code class="p">{</code> <code class="n">dependenciesAsList</code><code class="p">:</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">String</code><code class="p">&gt;,</code> <code class="n">dep</code><code class="p">:</code> <code class="n">ResolvedDependency</code> <code class="p">-&gt;</code>

        <code class="n">dependenciesAsList</code> <code class="p">+</code> <code class="n">listOf</code><code class="p">(</code><code class="s">" "</code><code class="p">.</code><code class="n">repeat</code><code class="p">(</code><code class="n">indent</code><code class="p">)</code> <code class="p">+</code>
          <code class="n">dep</code><code class="p">.</code><code class="n">module</code><code class="p">.</code><code class="n">id</code><code class="p">.</code><code class="n">toString</code><code class="p">())</code> <code class="p">+</code> <code class="p">(</code>
            <code class="k">if</code> <code class="p">(</code><code class="n">observedDependencies</code><code class="p">.</code><code class="n">add</code><code class="p">(</code><code class="n">dep</code><code class="p">))</code> <code class="p">{</code>
              <code class="n">dep</code><code class="p">.</code><code class="n">children</code>
                <code class="p">.</code><code class="n">sortedBy</code><code class="p">(</code><code class="n">gav</code><code class="p">)</code>
                <code class="p">.</code><code class="n">fold</code><code class="p">(</code><code class="n">emptyList</code><code class="p">(),</code> <code class="n">reduceDependenciesAtIndent</code><code class="p">(</code><code class="n">indent</code> <code class="p">+</code> <code class="mi">2</code><code class="p">))</code>
            <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
              <code class="c">// This dependency subtree has already been printed, so skip</code>
              <code class="n">emptyList</code><code class="p">()</code>
            <code class="p">}</code>
          <code class="p">)</code>
      <code class="p">}</code>

    <code class="n">project</code><code class="p">.</code><code class="n">plugins</code><code class="p">.</code><code class="n">withType</code><code class="p">&lt;</code><code class="n">InfoBrokerPlugin</code><code class="p">&gt;</code> <code class="p">{</code>
      <code class="n">add</code><code class="p">(</code><code class="s">"Resolved-Dependencies"</code><code class="p">,</code> <code class="n">runtimeClasspath</code>
        <code class="p">.</code><code class="n">resolvedConfiguration</code>
        <code class="p">.</code><code class="n">lenientConfiguration</code>
        <code class="p">.</code><code class="n">firstLevelModuleDependencies</code>
        <code class="p">.</code><code class="n">sortedBy</code><code class="p">(</code><code class="n">gav</code><code class="p">)</code>
        <code class="p">.</code><code class="n">fold</code><code class="p">(</code><code class="n">emptyList</code><code class="p">(),</code> <code class="n">reduceDependenciesAtIndent</code><code class="p">(</code><code class="mi">6</code><code class="p">))</code>
        <code class="p">.</code><code class="n">joinToString</code><code class="p">(</code><code class="s">"\n"</code><code class="p">,</code> <code class="s">"\n"</code><code class="p">,</code> <code class="s">"\n"</code> <code class="p">+</code> <code class="s">" "</code><code class="p">.</code><code class="n">repeat</code><code class="p">(</code><code class="mi">4</code><code class="p">)))</code>
    <code class="p">}</code>
  <code class="p">}</code>
<code class="p">}</code></pre></div>

<p class="author1">This generates a resolved dependencies property that looks something like <a data-type="xref" href="part0011_split_011.html#nebula_info_dependencies_tree_pom" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">Example 6-13</a>. This looks a bit more readable individually, and consuming such a property from tooling is equivalent to the flattened representation—simply strip the whitespace off the front of each line no matter how much whitespace there is.</p>
<div id="nebula_info_dependencies_tree_pom" data-type="example" class="calibre61">
<h5 class="calibre62"><span class="keep-together">Example 6-13. </span>A tree view of the transitive dependency closure shown as a POM property</h5>

<pre data-type="programlisting" data-code-language="xml" class="calibre63"><code class="nt">&lt;project</code> <code class="err">...</code><code class="nt">&gt;</code>
  <code class="nt">&lt;groupId&gt;</code>com.example<code class="nt">&lt;/groupId&gt;</code>
  <code class="nt">&lt;artifactId&gt;</code>demo<code class="nt">&lt;/artifactId&gt;</code>
  <code class="nt">&lt;version&gt;</code>0.1.0<code class="nt">&lt;/version&gt;</code>
  <code class="nt">&lt;name&gt;</code>demo<code class="nt">&lt;/name&gt;</code>
  ...
  <code class="nt">&lt;properties&gt;</code>
    <code class="nt">&lt;nebula_Change&gt;</code>1b0f8d9<code class="nt">&lt;/nebula_Change&gt;</code>
    <code class="nt">&lt;nebula_Branch&gt;</code>master<code class="nt">&lt;/nebula_Branch&gt;</code>
    <code class="nt">&lt;nebula_X_Compile_Target_JDK&gt;</code>11<code class="nt">&lt;/nebula_X_Compile_Target_JDK&gt;</code>
    <code class="nt">&lt;nebula_Resolved_Dependencies&gt;</code>
      org.springframework.boot:spring-boot-starter-actuator:2.3.0.M4
        io.micrometer:micrometer-core:1.3.7
          org.hdrhistogram:HdrHistogram:2.1.11
          org.latencyutils:LatencyUtils:2.0.3
        org.springframework.boot:spring-boot-actuator-autoconfigure:2.3.0.M4
          com.fasterxml.jackson.core:jackson-databind:2.11.0.rc1
          com.fasterxml.jackson.datatype:jackson-datatype-jsr310:2.11.0.rc1
            com.fasterxml.jackson.core:jackson-annotations:2.11.0.rc1
            com.fasterxml.jackson.core:jackson-core:2.11.0.rc1
            com.fasterxml.jackson.core:jackson-databind:2.11.0.rc1
    <code class="nt">&lt;/nebula_Resolved_Dependencies&gt;</code>
  <code class="nt">&lt;/properties&gt;</code>
<code class="nt">&lt;/project&gt;</code></pre></div>

<p class="author1">You can see a hint in this Nebula info output of how we can go further to the commit (<code class="calibre24">&lt;nebula_Change&gt;</code>).<a data-type="indexterm" data-startref="ix_ch06-asciidoc11" id="idm45139262773784" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/><a data-type="indexterm" data-startref="ix_ch06-asciidoc10" id="idm45139262773176" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/><a data-type="indexterm" data-startref="ix_ch06-asciidoc9" id="idm45139262772504" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/></p>
</div></section>













</div></section></div>



  

<div id="sbo-rt-content" class="calibre2">
<section data-type="chapter" type="chapter" data-pdf-bookmark="Chapter 6. Source Code Observability" class="calibre3">
<div class="preface" id="ch_source_code_observability">
<section data-type="sect1" data-pdf-bookmark="Capturing Method-Level Utilization of the Source Code" class="calibre3"><div class="preface" id="idm45139263590680">
<h1 class="calibre19" id="AFNKB-2d714b853a094e9a910510217e0e3d73">Capturing Method-Level Utilization of the Source Code</h1>

<p class="author1"><a data-type="indexterm" data-primary="source code observability" data-secondary="capturing method-level utilization of source code" id="ix_ch06-asciidoc12" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/>Going a step further, we can capture the source code level for a given artifact version. This is the last phase in the provenance chain. Once complete, the chain leads from a conceptual “application,” consisting of clusters spread across potentially multiple cloud providers, all the way down to the method declarations and invocations of the source code in these applications. For example, for an AWS EC2 IaaS-based deployment footprint, the provenance chain now looks like <a data-type="xref" href="part0011_split_012.html#full_provenance_chain" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">Example 6-14</a>.</p>
<div id="full_provenance_chain" data-type="example" class="calibre61">
<h5 class="calibre62"><span class="keep-together">Example 6-14. </span>An AWS EC2 full provenance chain from application to method-level source code</h5>

<pre data-type="programlisting" class="calibre63">Application
  -&gt; Owner (team)
  -&gt; Clusters
    -&gt; Server groups
      -&gt; Instances
      -&gt; Amazon Machine Image (AMI)
        -&gt; Debian
          -&gt; JAR (or WAR)
            -&gt; Git commit
              -&gt; Source abstract syntax tree <a class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre" id="co_source_code_observability_CO5-1" href="part0011_split_012.html#callout_source_code_observability_CO5-1"><img src="../images/00112.png" alt="1" class="calibre66"/></a>
                -&gt; Classes
                  -&gt; Method declarations
                    -&gt; Method invocations
            -&gt; Dependencies
               -&gt; Git commit
                 -&gt; Source abstract syntax tree
                   -&gt; Classes
                     -&gt; Method declarations
                       -&gt; Method invocations</pre></div>
<dl class="calibre20">
<dt class="calibre21"><a class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre" id="callout_source_code_observability_CO5-1" href="part0011_split_012.html#co_source_code_observability_CO5-1"><img src="../images/00112.png" alt="1" class="calibre66"/></a></dt>
<dd class="calibre67"><p class="calibre68">How this is constructed is the topic of this section.</p></dd>
</dl>

<p class="author1">Since this chain is linked top-to-bottom with just enough uniquely identifying metadata, we can answer almost any question about our running production environment. Each of these scenarios now has an exact answer that can be updated at will against the current state of a deployed footprint:</p>
<dl class="calibre20">
<dt class="calibre21">Zero-day exploit in an open source third-party library</dt>
<dd class="calibre22">
<p class="calibre23"><a data-type="indexterm" data-primary="security issues" data-secondary="zero-day exploits" id="idm45139262758296" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/><a data-type="indexterm" data-primary="zero-day exploits" id="idm45139262757320" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/>The security team learns of a vulnerability in a method in an open source third-party library that might be used in the company. This exposure could lead to sensitive personally identifiable customer information leaking if exploited and have significant legal liability and brand implications for the company. Because this vulnerability is widespread, the security team wants to address this problem in two phases, first focusing on production public-facing assets invoking the vulnerable method, and then later addressing internal tools and application code in lower environments on a path to eventual production deployment. Which teams does the security team need to communicate with in the first phase that have potential execution paths leading to the vulnerable method?</p>
</dd>
<dt class="calibre21">Platform team wants to deprecate or change an API</dt>
<dd class="calibre22">
<p class="calibre23">A centralized tools team, responsible for providing a library that every microservice team uses to check whether a given request is subject to a running A/B experiment, would like to make an API change in the way its library is used. The tools team used the source code search mechanism on its Github Enterprise instance to see where the existing API was used and noticed that some of the results pointed to dead code. If the team was to go ahead with the API change, which actively developed and deployed code would be affected? What is the set of teams affected by this potential change? If it is a small number of teams, the tools team can likely meet individually with its affected users or hold a small meeting and feedback session and proceed with the change. If it affects a much broader swath of the organization, perhaps the change is approached more incrementally or reconsidered altogether.</p>
</dd>
</dl>

<p class="author1">When it comes to identifying which methods are being used in the execution paths of running microservices, there are two approaches:</p>
<dl class="calibre20">
<dt class="calibre21">Live monitoring of execution paths</dt>
<dd class="calibre22">
<p class="calibre23">An agent can be attached to a running Java process to monitor which methods are actually executed. The set of all observed method signatures over a period of time approximates the reachable execution paths. For example, <a href="https://snyk.io" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">Snyk</a>, which specializes in security vulnerability analysis, provides a Java agent that monitors demonstrable execution paths to match against its method-level vulnerability research and alert organizations to known vulnerabilities. Live monitoring like this naturally <em class="calibre12">underreports</em> the real set of execution paths to a point, since some execution paths may be rarely exercised (e.g., exception-handling paths).</p>
</dd>
<dt class="calibre21">Statically analyzing potential execution paths from the source code</dt>
<dd class="calibre22">
<p class="calibre23">Several Java tools exist to construct an <a href="https://oreil.ly/f0r4M" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">abstract syntax tree</a> (an intermediate representation of the source code). This tree can be walked to look for method invocations. The set of all method invocations across the abstract syntax trees for every class in a source repository represents the set of all potential executions. This naturally <em class="calibre12">overreports</em> the real set of execution paths, since some method invocations are going to exist buried in a set of conditionals that never evaluate to true or request mappings that are never exercised. An example of one of these tools available in the open is given in <a data-type="xref" href="part0011_split_013.html#AFNN3-2d714b853a094e9a910510217e0e3d73" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">“Structured Code Search with OpenRewrite”</a>.</p>
</dd>
</dl>

<p class="author1">Because of the under/overreporting nature of these approaches, it can be useful to combine them. Any applications which are reporting the use of a method through live monitoring are certain to require a change. Potential execution paths can be evaluated on a second pass.</p>

<p class="author1">Static analysis tools need to evaluate source code. The combination of <code class="calibre24">nebula.info</code> and <code class="calibre24">nebula.maven-publish</code>, shown again in <a data-type="xref" href="part0011_split_012.html#nebula_info_commit_branch" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">Example 6-15</a>, gives us a Git commit hash and branch, the right amount of detail to connect an artifact version known to be running in a given server group to the source code that is included in it. Also, you can follow the application artifact’s transitive dependency closure, looking at a POM file for each dependency and peeking at what commit hash and branch each dependency used to examine their source code in turn.</p>
<div id="nebula_info_commit_branch" data-type="example" class="calibre61">
<h5 class="calibre62"><span class="keep-together">Example 6-15. </span>Gradle plug-ins that generate POM properties for Git commit hash and branch</h5>

<pre data-type="programlisting" data-code-language="java" class="calibre63"><code class="n">plugins</code> <code class="o">{</code>
  <code class="n">id</code><code class="o">(</code><code class="s">"nebula.maven-publish"</code><code class="o">)</code> <code class="n">version</code> <code class="s">"LATEST"</code>
  <code class="n">id</code><code class="o">(</code><code class="s">"nebula.info"</code><code class="o">)</code> <code class="n">version</code> <code class="s">"LATEST"</code>
<code class="o">}</code></pre></div>

<p class="author1">The POM properties this generates, shown in <a data-type="xref" href="part0011_split_012.html#nebula_info_commit_branch_pom" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">Example 6-16</a>, are easily scraped by tools.</p>
<div id="nebula_info_commit_branch_pom" data-type="example" class="calibre61">
<h5 class="calibre62"><span class="keep-together">Example 6-16. </span>Maven POM properties for Git commit hash and branch</h5>

<pre data-type="programlisting" data-code-language="xml" class="calibre63"><code class="nt">&lt;project</code> <code class="err">...</code><code class="nt">&gt;</code>
  <code class="nt">&lt;groupId&gt;</code>com.example<code class="nt">&lt;/groupId&gt;</code>
  <code class="nt">&lt;artifactId&gt;</code>demo<code class="nt">&lt;/artifactId&gt;</code>
  <code class="nt">&lt;version&gt;</code>0.1.0<code class="nt">&lt;/version&gt;</code>
  <code class="nt">&lt;name&gt;</code>demo<code class="nt">&lt;/name&gt;</code>
  ...
  <code class="nt">&lt;properties&gt;</code>
    <code class="nt">&lt;nebula_Change&gt;</code>1b0f8d9<code class="nt">&lt;/nebula_Change&gt;</code>
    <code class="nt">&lt;nebula_Branch&gt;</code>master<code class="nt">&lt;/nebula_Branch&gt;</code>
  <code class="nt">&lt;/properties&gt;</code>
<code class="nt">&lt;/project&gt;</code></pre></div>

<p class="author1">To set expectations about what kinds of capabilities a structured code search tool should have that could analyze execution paths, consider OpenRewrite.</p>








</div></section>













</div></section></div>



  

<div id="sbo-rt-content" class="calibre2">
<section data-type="chapter" type="chapter" data-pdf-bookmark="Chapter 6. Source Code Observability" class="calibre3">
<div class="preface" id="ch_source_code_observability">
<section data-type="sect1" data-pdf-bookmark="Capturing Method-Level Utilization of the Source Code" class="calibre3">
<div class="preface" id="idm45139263590680">
<section data-type="sect2" data-pdf-bookmark="Structured Code Search with OpenRewrite" class="calibre3"><div class="preface" id="openrewrite">
<h2 class="calibre37" id="AFNN3-2d714b853a094e9a910510217e0e3d73">Structured Code Search with OpenRewrite</h2>

<p class="author1"><a data-type="indexterm" data-primary="OpenRewrite" data-seealso="Rewrite" id="idm45139262843272" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/><a data-type="indexterm" data-primary="Rewrite" data-secondary="structured code search with OpenRewrite" id="idm45139262637880" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/><a data-type="indexterm" data-primary="source code observability" data-secondary="structured code search with OpenRewrite" id="idm45139262636968" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/>The <a href="http://github.com/openrewrite" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">OpenRewrite</a> project is a mass refactoring ecosystem for Java and other source code, designed to eliminate technical debt across an engineering organization. Rewrite is designed to be plugged into various workflows, including the following:</p>

<ul class="printings">
<li class="calibre15">
<p class="calibre18">Discover and fix code as a build tool task (e.g., Gradle and Maven).</p>
</li>
<li class="calibre15">
<p class="calibre18">Subsecond organization-wide code search for a pattern of arbitrary complexity.</p>
</li>
<li class="calibre15">
<p class="calibre18">Mass pull-request issuance to fix a security vulnerability, eliminate the use of a deprecated API, migrate from one technology to another (e.g., JUnit asserts to AssertJ), etc.</p>
</li>
<li class="calibre15">
<p class="calibre18">Mass organization-wide Git commits to do the same.</p>
</li>
</ul>

<p class="author1"><a data-type="indexterm" data-primary="abstract syntax tree (AST)" id="ix_ch06-asciidoc13" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/><a data-type="indexterm" data-primary="AST (abstract syntax tree)" id="ix_ch06-asciidoc14" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/>It builds on a custom abstract syntax tree (AST) that encodes the structure and formatting of source code. The AST is printable to reconstitute the source code, including its original formatting. Rewrite provides high-level search and refactoring functions that can transform the AST, as well as utilities for unit testing refactoring logic.</p>

<p class="author1">Two key capabilities of the Rewrite AST make it suited for the purpose of the provenance chain:</p>
<dl class="calibre20">
<dt class="calibre21">Type-attributed</dt>
<dd class="calibre22">
<p class="calibre23">Each AST element is imbued with type information. For a field reference, for example, the source code may just refer to myField. The Rewrite AST element for <code class="calibre24">myField</code> would also contain information about what the type of <code class="calibre24">myField</code> is, even if it isn’t defined in the same source file or even the same project.</p>
</dd>
<dt class="calibre21">Acyclic and serializable</dt>
<dd class="calibre22">
<p class="calibre23">Most ASTs containing type information are potentially cyclic. Cycles usually come from generic type signatures like class <code class="calibre24">A&lt;T extends A&lt;T&gt;&gt;</code>. This kind of pattern is generally found in things like abstract builder types in Java. Rewrite cuts these cycles off and adds serialization annotations to its types so the AST can be serialized/deserialized with libraries like Jackson.</p>
</dd>
</dl>

<p class="author1">Type attribution is necessary for accurate matching of patterns. How do we know if <code class="calibre24">logger</code> is an SLF4J or a Logback logger when looking at a statement like <a data-type="xref" href="part0011_split_013.html#logging_statement_type_attribution" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">Example 6-17</a>? The class type of the instance that a method is invoked against is called the receiver type.</p>
<div id="logging_statement_type_attribution" data-type="example" class="calibre61">
<h5 class="calibre62"><span class="keep-together">Example 6-17. </span>A logging statement with an ambiguous receiver type</h5>

<pre data-type="programlisting" data-code-language="java" class="calibre63"><code class="n">logger</code><code class="o">.</code><code class="na">info</code><code class="o">(</code><code class="s">"Hi"</code><code class="o">);</code></pre></div>

<p class="author1">The production of type-attributed ASTs for a whole organization is arbitrarily computationally complex, since it requires dependency resolution, parsing of the source code, and type attribution (basically Java compilation up to the point of bytecode generation). Since Rewrite ASTs are serializable, we can store them off centrally as a byproduct of compilation in continuous integration environments and then operate on them en masse later.</p>

<p class="author1">Once we have a serialized AST for a particular source file, and because it also contains type information, it can be refactored/searched completely independently of other source files in the same source package or repository. This makes mass search and refactoring a truly linearly scalable operation.</p>










<section data-type="sect3" data-pdf-bookmark="Creating a Rewrite AST from Java source code" class="calibre3"><div class="preface" id="idm45139262615080">
<h3 class="calibre51">Creating a Rewrite AST from Java source code</h3>

<p class="author1"><a data-type="indexterm" data-primary="Rewrite" data-secondary="creating a Rewrite AST from Java source code" id="ix_ch06-asciidoc15" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/>To build a Rewrite AST for Java source code, construct a <code class="calibre24">JavaParser</code> either with or without the runtime classpath using one of the constructor signatures shown in <a data-type="xref" href="part0011_split_013.html#constructing_java_parser" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">Example 6-18</a>.</p>
<div id="constructing_java_parser" data-type="example" class="calibre61">
<h5 class="calibre62"><span class="keep-together">Example 6-18. </span>Constructing a JavaParser instance</h5>

<pre data-type="programlisting" data-code-language="java" class="calibre63"><code class="n">JavaParser</code><code class="o">();</code>
<code class="n">JavaParser</code><code class="o">(</code><code class="n">List</code><code class="o">&lt;</code><code class="n">Path</code><code class="o">&gt;</code> <code class="n">classpath</code><code class="o">);</code></pre></div>

<p class="author1">Providing a classpath is optional, because type attribution is a <em class="calibre12">best effort</em> for each element. If we are storing ASTs in a datastore for organization-wide search, ideally they are stored fully type-attributed, because you don’t know what kinds of searches will be made in advance. The kinds of searches include the following:</p>
<dl class="calibre20">
<dt class="calibre21">No types needed at all</dt>
<dd class="calibre22">
<p class="calibre23">If you are applying a refactoring rule like autoremediation for Checkstyle’s <code class="calibre24">WhitespaceBefore</code> rule, we’re strictly looking at source formatting, and it’s OK if none of the AST elements have types on them, as it doesn’t influence the outcome.</p>
</dd>
<dt class="calibre21">Partial types needed</dt>
<dd class="calibre22">
<p class="calibre23">If searching for occurrences of deprecated Guava methods, it is OK to construct a <code class="calibre24">JavaParser</code> with a path to a Guava binary. It doesn’t even have to be the Guava version that the project is using! The resulting ASTs will have limited type information, but just enough to search for what we want.</p>
</dd>
<dt class="calibre21">Full types needed</dt>
<dd class="calibre22">
<p class="calibre23">When ASTs are emitted as a side effect of compilation to a central datastore for later arbitrary code search, they need to have full type information, because we can’t be sure in advance what kinds of searches people will attempt.</p>
</dd>
</dl>

<p class="author1"><code class="calibre24">JavaParser</code> contains a convenience method for building a <code class="calibre24">JavaParser</code> from the runtime classpath of the Java process that is constructing the parser, shown in <a data-type="xref" href="part0011_split_013.html#parser_with_classpath" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">Example 6-19</a>.</p>
<div id="parser_with_classpath" data-type="example" class="calibre61">
<h5 class="calibre62"><span class="keep-together">Example 6-19. </span>Giving the parser the compile dependencies necessary to do type attribution</h5>

<pre data-type="programlisting" data-code-language="java" class="calibre63"><code class="k">new</code> <code class="nf">JavaParser</code><code class="o">(</code><code class="n">JavaParser</code><code class="o">.</code><code class="na">dependenciesFromClasspath</code><code class="o">(</code><code class="s">"guava"</code><code class="o">));</code></pre></div>

<p class="author1">This utility takes the “artifact name” of the dependency to look for. The artifact name is the artifact portion of <code class="calibre24">group:artifact:version</code> coordinates. For example, for Google’s Guava (<code class="calibre24">com.google.guava:guava:VERSION</code>), the artifact name is <code class="calibre24">guava</code>.</p>

<p class="author1">Once you have a <code class="calibre24">JavaParser</code> instance, you can parse all the source files in a project with the <code class="calibre24">parse</code> method, which takes a <code class="calibre24">List&lt;Path&gt;</code>. <a data-type="xref" href="part0011_split_013.html#parsing_source_paths" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">Example 6-20</a> shows the process.</p>
<div id="parsing_source_paths" data-type="example" class="calibre61">
<h5 class="calibre62"><span class="keep-together">Example 6-20. </span>Parsing a list of Java source paths</h5>

<pre data-type="programlisting" data-code-language="java" class="calibre63"><code class="n">JavaParser</code> <code class="n">parser</code> <code class="o">=</code> <code class="o">...;</code>
<code class="n">List</code><code class="o">&lt;</code><code class="n">J</code><code class="o">.</code><code class="na">CompilationUnit</code><code class="o">&gt;</code> <code class="n">cus</code> <code class="o">=</code> <code class="n">parser</code><code class="o">.</code><code class="na">parse</code><code class="o">(</code><code class="n">pathsToSourceFiles</code><code class="o">);</code></pre></div>
<dl class="calibre20">
<dt class="calibre21"><code class="calibre24">J.CompilationUnit</code></dt>
<dd class="calibre22">
<p class="calibre23">This is the top-level AST element for Java source files, which contains information about the package, imports, and any class/enum/interface definitions contained in the source file. <code class="calibre24">J.CompilationUnit</code> is the basic building block upon which we’ll build refactoring and search operations for Java source code.</p>
</dd>
<dt class="calibre21"><code class="calibre24">JavaParser</code></dt>
<dd class="calibre22">
<p class="calibre23">This contains <code class="calibre24">parse</code> method overloads for constructing an AST from a string, which is useful for quickly constructing unit tests for different search and refactoring operations.</p>
</dd>
</dl>

<p class="author1">For JVM languages like Kotlin that support multiline strings, this can be especially convenient, as shown in <a data-type="xref" href="part0011_split_013.html#parsing_java_source" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">Example 6-21</a>.</p>
<div id="parsing_java_source" data-type="example" class="calibre61">
<h5 class="calibre62"><span class="keep-together">Example 6-21. </span>Parsing Java source</h5>

<pre data-type="programlisting" data-code-language="kotlin" class="calibre63"><code class="k">val</code> <code class="py">cu</code><code class="p">:</code> <code class="n">J</code><code class="p">.</code><code class="n">CompilationUnit</code> <code class="p">=</code> <code class="n">JavaParser</code><code class="p">().</code><code class="n">parse</code><code class="p">(</code><code class="s">"""</code>
    <code class="k">import</code> <code class="nn">java.util.Collections;</code>
    <code class="k">public</code> <code class="k">class</code> <code class="nc">A</code> <code class="p">{</code>
        <code class="n">Object</code> <code class="n">o</code> <code class="p">=</code> <code class="n">Collections</code><code class="p">.</code><code class="n">emptyList</code><code class="p">();</code>
    <code class="p">}</code>
<code class="s">""")</code></pre></div>

<p class="author1">Notice how this returns a single <code class="calibre24">J.CompilationUnit</code>, which can be immediately acted upon. Ultimately, <a href="https://oreil.ly/9p7X8" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">JEP-355</a> will bring multiline strings to Java as well, so beautiful unit tests for Rewrite operations will be possible to write in plain Java code.</p>

<p class="author1">The <code class="calibre24">dependenciesFromClasspath</code> method demonstrated in <a data-type="xref" href="part0011_split_013.html#parsing_source_with_classpath" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">Example 6-22</a> is especially useful for building unit tests, as you can place a module for which you are affecting some transformation on the test runtime classpath and bind it to the parser. In this way, any references to classes, methods, etc., in that dependency are type-attributed in ASTs produced for unit tests.<a data-type="indexterm" data-startref="ix_ch06-asciidoc15" id="idm45139262400264" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/></p>
<div id="parsing_source_with_classpath" data-type="example" class="calibre61">
<h5 class="calibre62"><span class="keep-together">Example 6-22. </span>Parsing source with a classpath for type attribution</h5>

<pre data-type="programlisting" data-code-language="kotlin" class="calibre63"><code class="k">val</code> <code class="py">cu</code><code class="p">:</code> <code class="n">J</code><code class="p">.</code><code class="n">CompilationUnit</code> <code class="p">=</code> <code class="n">JavaParser</code><code class="p">(</code><code class="n">JavaParser</code><code class="p">.</code><code class="n">dependenciesFromClasspath</code><code class="p">(</code><code class="s">"guava"</code><code class="p">))</code>
    <code class="p">.</code><code class="n">parse</code><code class="p">(</code><code class="s">"""</code>
        <code class="k">import</code> <code class="nn">com.google.common.io.Files;</code>
        <code class="k">public</code> <code class="k">class</code> <code class="nc">A</code> <code class="p">{</code>
            <code class="n">File</code> <code class="n">temp</code> <code class="p">=</code> <code class="n">Files</code><code class="p">.</code><code class="n">createTempDir</code><code class="p">();</code>
        <code class="p">}</code>
    <code class="s">""")</code></pre></div>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Performing a search with Rewrite" class="calibre3"><div class="preface" id="idm45139262614488">
<h3 class="calibre51">Performing a search with Rewrite</h3>

<p class="author1"><a data-type="indexterm" data-primary="Rewrite" data-secondary="performing a search with" id="ix_ch06-asciidoc16" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/><a data-type="indexterm" data-primary="search, with Rewrite" id="ix_ch06-asciidoc17" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/>Extending on the previous example, we can search for uses of Guava’s <code class="calibre24">Files#createTempDir()</code>, shown in <a data-type="xref" href="part0011_split_013.html#search_with_rewrite" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">Example 6-23</a>. The argument for <code class="calibre24">findMethodCalls</code> takes the <a href="https://oreil.ly/4UaEQ" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">AspectJ syntax</a> for pointcut matching on methods.</p>
<div id="search_with_rewrite" data-type="example" class="calibre61">
<h5 class="calibre62"><span class="keep-together">Example 6-23. </span>Performing a search with Rewrite</h5>

<pre data-type="programlisting" data-code-language="kotlin" class="calibre63"><code class="k">val</code> <code class="py">cu</code><code class="p">:</code> <code class="n">J</code><code class="p">.</code><code class="n">CompilationUnit</code> <code class="p">=</code> <code class="n">JavaParser</code><code class="p">(</code><code class="n">JavaParser</code><code class="p">.</code><code class="n">dependenciesFromClasspath</code><code class="p">(</code><code class="s">"guava"</code><code class="p">))</code>
    <code class="p">.</code><code class="n">parse</code><code class="p">(</code><code class="s">"""</code>
        <code class="k">import</code> <code class="nn">com.google.common.io.Files;</code>
        <code class="k">public</code> <code class="k">class</code> <code class="nc">A</code> <code class="p">{</code>
            <code class="n">File</code> <code class="n">temp</code> <code class="p">=</code> <code class="n">Files</code><code class="p">.</code><code class="n">createTempDir</code><code class="p">();</code>
        <code class="p">}</code>
    <code class="s">""")</code>

<code class="k">val</code> <code class="py">calls</code><code class="p">:</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">J</code><code class="p">.</code><code class="n">MethodInvocation</code><code class="p">&gt;</code> <code class="p">=</code> <code class="n">cu</code><code class="p">.</code><code class="n">findMethodCalls</code><code class="p">(</code>
    <code class="s">"java.io.File com.google.common.io.Files.createTempDir()"</code><code class="p">);</code></pre></div>

<p class="author1">Many other search methods exist on <code class="calibre24">J.CompilationUnit</code>, among them the following:</p>
<dl class="calibre20">
<dt class="calibre21"><code class="calibre24">boolean hasImport(String clazz)</code></dt>
<dd class="calibre22">
<p class="calibre23">Looks for imports</p>
</dd>
<dt class="calibre21"><code class="calibre24">boolean hasType(String clazz)</code></dt>
<dd class="calibre22">
<p class="calibre23">Checks whether a source file has a reference to a type</p>
</dd>
<dt class="calibre21"><code class="calibre24">Set&lt;NameTree&gt; findType(String clazz)</code></dt>
<dd class="calibre22">
<p class="calibre23">Returns all the AST elements that are type-attributed with a particular type</p>
</dd>
</dl>

<p class="author1">You can also move down a level to individual classes (<code class="calibre24">cu.getClasses()</code>) inside a source file and perform additional operations:</p>
<dl class="calibre20">
<dt class="calibre21"><code class="calibre24">List&lt;VariableDecls&gt; findFields(String clazz)</code></dt>
<dd class="calibre22">
<p class="calibre23">Finds fields declared in this class that refer to a specific type.</p>
</dd>
<dt class="calibre21"><code class="calibre24">List&lt;JavaType.Var&gt; findInheritedFields(String clazz)</code></dt>
<dd class="calibre22">
<p class="calibre23">Finds fields that are inherited from a base class. Note that since they are inherited, there is no AST element to match on, but you’ll be able to determine if a class has a field of a particular type coming from a base class and then look for uses of this field.</p>
</dd>
<dt class="calibre21"><code class="calibre24">Set&lt;NameTree&gt; findType(String clazz)</code></dt>
<dd class="calibre22">
<p class="calibre23">Returns all AST elements inside this class referring to a type.</p>
</dd>
<dt class="calibre21"><code class="calibre24">List&lt;Annotation&gt; findAnnotations(String signature)</code> </dt>
<dd class="calibre22">
<p class="calibre23">Finds all annotations matching a signature as defined in the AspectJ pointcut definition for annotation matching.</p>
</dd>
<dt class="calibre21"><code class="calibre24">boolean hasType(String clazz)</code></dt>
<dd class="calibre22">
<p class="calibre23">Checks whether a class refers to a type.</p>
</dd>
<dt class="calibre21"><code class="calibre24">hasModifier(String modifier)</code></dt>
<dd class="calibre22">
<p class="calibre23">Checks for modifiers on the class definition (e.g., public, private, static).</p>
</dd>
<dt class="calibre21"><code class="calibre24">isClass()/isEnum()/isInterface()/isAnnotation()</code></dt>
<dd class="calibre22">
<p class="calibre23">Checks the type of declaration.</p>
</dd>
</dl>

<p class="author1">More search methods are available further down the AST.</p>

<p class="author1">You can build custom search visitors by extending <code class="calibre24">JavaSourceVisitor</code> and implementing any <code class="calibre24">visitXXX</code> methods that you need to perform your search. These don’t have to be complex. <code class="calibre24">FindMethods</code> only extends <code class="calibre24">visitMethodInvocation</code> to check whether a given invocation matches the signature we are looking for, as shown in <a data-type="xref" href="part0011_split_013.html#find_methods_visitor" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">Example 6-24</a>.</p>
<div id="find_methods_visitor" data-type="example" class="calibre61">
<h5 class="calibre62"><span class="keep-together">Example 6-24. </span>The implementation of the FindMethods operation in Rewrite</h5>

<pre data-type="programlisting" data-code-language="java" class="calibre63"><code class="k">public</code> <code class="k">class</code> <code class="nc">FindMethods</code> <code class="k">extends</code> <code class="n">JavaSourceVisitor</code><code class="o">&lt;</code><code class="n">List</code><code class="o">&lt;</code><code class="n">J</code><code class="o">.</code><code class="na">MethodInvocation</code><code class="o">&gt;&gt;</code> <code class="o">{</code>
    <code class="k">private</code> <code class="k">final</code> <code class="n">MethodMatcher</code> <code class="n">matcher</code><code class="o">;</code>

    <code class="k">public</code> <code class="nf">FindMethods</code><code class="o">(</code><code class="n">String</code> <code class="n">signature</code><code class="o">)</code> <code class="o">{</code>
        <code class="k">this</code><code class="o">.</code><code class="na">matcher</code> <code class="o">=</code> <code class="k">new</code> <code class="n">MethodMatcher</code><code class="o">(</code><code class="n">signature</code><code class="o">);</code>
    <code class="o">}</code>

    <code class="nd">@Override</code>
    <code class="k">public</code> <code class="n">List</code><code class="o">&lt;</code><code class="n">J</code><code class="o">.</code><code class="na">MethodInvocation</code><code class="o">&gt;</code> <code class="nf">defaultTo</code><code class="o">(</code><code class="n">Tree</code> <code class="n">t</code><code class="o">)</code> <code class="o">{</code>
        <code class="k">return</code> <code class="nf">emptyList</code><code class="o">();</code>
    <code class="o">}</code>

    <code class="nd">@Override</code>
    <code class="k">public</code> <code class="n">List</code><code class="o">&lt;</code><code class="n">J</code><code class="o">.</code><code class="na">MethodInvocation</code><code class="o">&gt;</code> <code class="nf">visitMethodInvocation</code><code class="o">(</code><code class="n">J</code><code class="o">.</code><code class="na">MethodInvocation</code> <code class="n">method</code><code class="o">)</code> <code class="o">{</code>
        <code class="k">return</code> <code class="n">matcher</code><code class="o">.</code><code class="na">matches</code><code class="o">(</code><code class="n">method</code><code class="o">)</code> <code class="o">?</code>
          <code class="n">singletonList</code><code class="o">(</code><code class="n">method</code><code class="o">)</code> <code class="o">:</code>
          <code class="k">super</code><code class="o">.</code><code class="na">visitMethodInvocation</code><code class="o">(</code><code class="n">method</code><code class="o">);</code>
    <code class="o">}</code>
<code class="o">}</code></pre></div>

<p class="author1">Invoke a custom visitor by instantiating the visitor and calling <code class="calibre24">visit</code> on the root AST node, as shown in <a data-type="xref" href="part0011_split_013.html#invoke_custom_visitor" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">Example 6-25</a>. <code class="calibre24">JavaSourceVisitor</code> can return any type. You define a default return with <code class="calibre24">defaultTo</code> and can provide a custom reduction operation by overriding <code class="calibre24">reduce</code> on the visitor.<a data-type="indexterm" data-startref="ix_ch06-asciidoc17" id="idm45139262091352" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/><a data-type="indexterm" data-startref="ix_ch06-asciidoc16" id="idm45139262090616" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/></p>
<div id="invoke_custom_visitor" data-type="example" class="calibre61">
<h5 class="calibre62"><span class="keep-together">Example 6-25. </span>Invoking a custom Rewrite visitor</h5>

<pre data-type="programlisting" data-code-language="java" class="calibre63"><code class="n">J</code><code class="o">.</code><code class="na">CompilationUnit</code> <code class="n">cu</code> <code class="o">=</code> <code class="o">...;</code>

<code class="c">// This visitor can return any type you wish, ultimately</code>
<code class="c">// being a reduction of visiting every AST element</code>
<code class="k">new</code> <code class="nf">MyCustomVisitor</code><code class="o">().</code><code class="na">visit</code><code class="o">(</code><code class="n">cu</code><code class="o">);</code></pre></div>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Refactoring Java source" class="calibre3"><div class="preface" id="idm45139262024024">
<h3 class="calibre51">Refactoring Java source</h3>

<p class="author1"><a data-type="indexterm" data-primary="refactoring, Java source" id="ix_ch06-asciidoc18" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/><a data-type="indexterm" data-primary="Rewrite" data-secondary="refactoring Java source" id="ix_ch06-asciidoc19" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/>One of the benefits of establishing this artifact provenance chain all the way down to the method invocation level on source code is you can actually perform some <em class="calibre12">remediating</em> action on the source code in a targeted way: first iterating over deployed assets and mapping them to binaries, then mapping to a commit, then to the ASTs built from that commit.</p>

<p class="author1">Refactoring code starts at the root of the AST, which for Java is <code class="calibre24">J.CompilationUnit</code>. Call <code class="calibre24">refactor()</code> to begin a refactoring operation. We’ll detail the kinds of refactoring operations that you can do in a moment, but at the end of this process you can call <code class="calibre24">fix()</code>, which generates a <code class="calibre24">Change</code> instance that allows you to generate git diffs and print out the original and transformed source. <a data-type="xref" href="part0011_split_013.html#parsing_to_printing" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">Example 6-26</a> shows the whole process end-to-end.</p>
<div id="parsing_to_printing" data-type="example" class="calibre61">
<h5 class="calibre62"><span class="keep-together">Example 6-26. </span>End to end: parsing Java source code to printing a fix</h5>

<pre data-type="programlisting" data-code-language="java" class="calibre63"><code class="n">JavaParser</code> <code class="n">parser</code> <code class="o">=</code> <code class="o">...;</code>
<code class="n">List</code><code class="o">&lt;</code><code class="n">J</code><code class="o">.</code><code class="na">CompilationUnit</code><code class="o">&gt;</code> <code class="n">cus</code> <code class="o">=</code> <code class="n">parser</code><code class="o">.</code><code class="na">parse</code><code class="o">(</code><code class="n">sourceFiles</code><code class="o">);</code>

<code class="k">for</code><code class="o">(</code><code class="n">J</code><code class="o">.</code><code class="na">CompilationUnit</code> <code class="n">cu</code> <code class="o">:</code> <code class="n">cus</code><code class="o">)</code> <code class="o">{</code>
    <code class="n">Refactor</code><code class="o">&lt;</code><code class="n">J</code><code class="o">.</code><code class="na">CompilationUnit</code><code class="o">,</code> <code class="n">J</code><code class="o">&gt;</code> <code class="n">refactor</code> <code class="o">=</code> <code class="n">cu</code><code class="o">.</code><code class="na">refactor</code><code class="o">();</code>

    <code class="c">// ... Do some refactoring</code>

    <code class="n">Change</code><code class="o">&lt;</code><code class="n">J</code><code class="o">.</code><code class="na">CompilationUnit</code><code class="o">&gt;</code> <code class="n">change</code> <code class="o">=</code> <code class="n">refactor</code><code class="o">.</code><code class="na">fix</code><code class="o">();</code>

    <code class="n">change</code><code class="o">.</code><code class="na">diff</code><code class="o">();</code> <code class="c">// A string representing a git-style patch</code>
    <code class="c">// Relativize the patch's file reference to some other path</code>
    <code class="n">change</code><code class="o">.</code><code class="na">diff</code><code class="o">(</code><code class="n">relativeToPath</code><code class="o">);</code>

    <code class="c">// Print out the transformed source, which could be used</code>
    <code class="c">// to overwrite the original source file</code>
    <code class="n">J</code><code class="o">.</code><code class="na">CompilationUnit</code> <code class="n">fixed</code> <code class="o">=</code> <code class="n">change</code><code class="o">.</code><code class="na">getFixed</code><code class="o">();</code>
    <code class="n">fixed</code><code class="o">.</code><code class="na">print</code><code class="o">();</code>

    <code class="c">// Useful for unit tests to trim the output of common whitespace</code>
    <code class="n">fixed</code><code class="o">.</code><code class="na">printTrimmed</code><code class="o">();</code>

    <code class="c">// This is null when we synthesize a new compilation unit</code>
    <code class="c">// where one didn't exist before</code>
    <code class="nd">@Nullable</code> <code class="n">J</code><code class="o">.</code><code class="na">CompilationUnit</code> <code class="n">original</code> <code class="o">=</code> <code class="n">change</code><code class="o">.</code><code class="na">getOriginal</code><code class="o">();</code>
<code class="o">}</code></pre></div>

<p class="author1"><code class="calibre24">rewrite-java</code> packs with a series of refactoring building blocks that can be used to perform low-level refactoring operations. For example, to change all fields from <code class="calibre24">java.util.List</code> to <code class="calibre24">java.util.Collection</code>, we could use the <code class="calibre24">ChangeFieldType</code> operation, as shown in test form in <a data-type="xref" href="part0011_split_013.html#testing_change_field_type" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">Example 6-27</a>.</p>
<div id="testing_change_field_type" data-type="example" class="calibre61">
<h5 class="calibre62"><span class="keep-together">Example 6-27. </span>A unit test for changing a field type</h5>

<pre data-type="programlisting" data-code-language="kotlin" class="calibre63"><code class="n">@Test</code>
<code class="k">fun</code> <code class="nf">changeFieldType</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">val</code> <code class="py">a</code> <code class="p">=</code> <code class="n">parse</code><code class="p">(</code><code class="s">"""</code>
        <code class="k">import</code> <code class="nn">java.util.List;</code>
        <code class="k">public</code> <code class="k">class</code> <code class="nc">A</code> <code class="p">{</code>
           <code class="n">List</code> <code class="n">collection</code><code class="p">;</code>
        <code class="p">}</code>
    <code class="s">""".trimIndent())</code>

    <code class="k">val</code> <code class="py">fixed</code> <code class="p">=</code> <code class="n">a</code><code class="p">.</code><code class="n">refactor</code><code class="p">()</code>
            <code class="p">.</code><code class="n">visit</code><code class="p">(</code><code class="n">ChangeFieldType</code><code class="p">(</code>
                    <code class="n">a</code><code class="p">.</code><code class="n">classes</code><code class="p">[</code><code class="mi">0</code><code class="p">].</code><code class="n">findFields</code><code class="p">(</code><code class="s">"java.util.List"</code><code class="p">)[</code><code class="mi">0</code><code class="p">],</code>
                    <code class="s">"java.util.Collection"</code><code class="p">))</code>
            <code class="p">.</code><code class="n">fix</code><code class="p">().</code><code class="n">fixed</code>

    <code class="n">assertRefactored</code><code class="p">(</code><code class="n">fixed</code><code class="p">,</code> <code class="s">"""</code>
        <code class="k">import</code> <code class="nn">java.util.Collection;</code>

        <code class="k">public</code> <code class="k">class</code> <code class="nc">A</code> <code class="p">{</code>
           <code class="n">Collection</code> <code class="n">collection</code><code class="p">;</code>
        <code class="p">}</code>
    <code class="s">""")</code>
<code class="p">}</code></pre></div>

<p class="author1">The <code class="calibre24">rewrite-java</code> module comes with basic refactoring building blocks that resemble many of the individual refactoring tools you would find in an IDE:</p>

<ul class="printings">
<li class="calibre15">
<p class="calibre18">Add annotation to a class, method, or variable.</p>
</li>
<li class="calibre15">
<p class="calibre18">Add a field to a class.</p>
</li>
<li class="calibre15">
<p class="calibre18">Add/remove an import, which can be configured to expand/collapse star imports.</p>
</li>
<li class="calibre15">
<p class="calibre18">Change field name (including its references, even across other source files that <em class="calibre12">use</em> this field, not just where the field is defined).</p>
</li>
<li class="calibre15">
<p class="calibre18">Change a field type.</p>
</li>
<li class="calibre15">
<p class="calibre18">Change a literal expression.</p>
</li>
<li class="calibre15">
<p class="calibre18">Change a method name, including anywhere that method is referenced.</p>
</li>
<li class="calibre15">
<p class="calibre18">Change a method target to a static from an instance method.</p>
</li>
<li class="calibre15">
<p class="calibre18">Change a method target to an instance method from a static.</p>
</li>
<li class="calibre15">
<p class="calibre18">Change a type reference anywhere it is found in the tree.</p>
</li>
<li class="calibre15">
<p class="calibre18">Insert/delete method arguments.</p>
</li>
<li class="calibre15">
<p class="calibre18">Delete any statement.</p>
</li>
<li class="calibre15">
<p class="calibre18">Generate constructors using fields.</p>
</li>
<li class="calibre15">
<p class="calibre18">Rename a variable.</p>
</li>
<li class="calibre15">
<p class="calibre18">Reorder method arguments.</p>
</li>
<li class="calibre15">
<p class="calibre18">Unwrap parentheses.</p>
</li>
<li class="calibre15">
<p class="calibre18">Implement an interface.</p>
</li>
</ul>

<p class="author1">Each one of these operations is defined as a <code class="calibre24">JavaRefactorVisitor</code>, which is an extension of <code class="calibre24">JavaSourceVisitor</code> designed for mutating the AST, ultimately leading to a <code class="calibre24">Change</code> object at the end of the refactoring operation.</p>

<p class="author1">Visitors can be cursored or not. Cursored visitors maintain a stack of AST elements that have been traversed in the tree thus far. In exchange for the extra memory footprint, such visitors can operate based on the location of AST elements in the tree. Many refactoring operations don’t require this state. <a data-type="xref" href="part0011_split_013.html#make_classes_final" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">Example 6-28</a> provides an example of a refactoring operation that makes each top-level class final. Since class declarations can be nested (e.g., inner classes), we use the cursor to determine if the class is top level or not. Refactoring operations should also be given a fully qualified name with a package representing the group of operations and a name signifying what it does.</p>
<div id="make_classes_final" data-type="example" class="calibre61">
<h5 class="calibre62"><span class="keep-together">Example 6-28. </span>An example of a refactoring operation that makes each top-level class final</h5>

<pre data-type="programlisting" data-code-language="java" class="calibre63"><code class="k">public</code> <code class="k">class</code> <code class="nc">MakeClassesFinal</code> <code class="k">extends</code> <code class="n">JavaRefactorVisitor</code> <code class="o">{</code>
    <code class="k">public</code> <code class="n">MakeClassesFinal</code> <code class="o">{</code>
        <code class="k">super</code><code class="o">(</code><code class="s">"my.MakeClassesFinal"</code><code class="o">);</code>
        <code class="n">setCursoringOn</code><code class="o">();</code>
    <code class="o">}</code>

    <code class="nd">@Override</code>
    <code class="k">public</code> <code class="n">J</code> <code class="nf">visitClassDecl</code><code class="o">(</code><code class="n">J</code><code class="o">.</code><code class="na">ClassDecl</code> <code class="n">classDecl</code><code class="o">)</code> <code class="o">{</code>
        <code class="n">J</code><code class="o">.</code><code class="na">ClassDecl</code> <code class="n">c</code> <code class="o">=</code> <code class="n">refactor</code><code class="o">(</code><code class="n">classDecl</code><code class="o">,</code> <code class="k">super</code><code class="o">::</code><code class="n">visitClassDecl</code><code class="o">);</code>

        <code class="c">// Only make top-level classes final</code>
        <code class="k">if</code><code class="o">(</code><code class="n">getCursor</code><code class="o">().</code><code class="na">firstEnclosing</code><code class="o">(</code><code class="n">J</code><code class="o">.</code><code class="na">ClassDecl</code><code class="o">.</code><code class="na">class</code><code class="o">)</code> <code class="o">==</code> <code class="k">null</code><code class="o">)</code> <code class="o">{</code>
            <code class="n">c</code> <code class="o">=</code> <code class="n">c</code><code class="o">.</code><code class="na">withModifiers</code><code class="o">(</code><code class="s">"final"</code><code class="o">);</code>
        <code class="o">}</code>

        <code class="k">return</code> <code class="n">c</code><code class="o">;</code>
    <code class="o">}</code>
<code class="o">}</code></pre></div>

<p class="author1">Visitors can be chained together by calling <code class="calibre24">andThen(anotherVisitor)</code>. This is useful for building up pipelines of refactoring operations made of lower-level components. For example, when <code class="calibre24">ChangeFieldType</code> finds a matching field that it is going to <span class="keep-together">transform,</span> it chains together an <code class="calibre24">AddImport</code> visitor to add the new import if necessary, and a <code class="calibre24">RemoveImport</code> to remove the old import if there are no longer any references to it.</p>

<p class="author1">A platform of open source out-of-the-box remediations continues to grow in open source.</p>

<p class="author1">At this point, the provenance chain is complete. Connecting the dots down to source code method-level detail allows you to observe your deployed footprint in a fine-grained way, answering a wide array of questions in real time.<a data-type="indexterm" data-startref="ix_ch06-asciidoc19" id="idm45139261679304" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/><a data-type="indexterm" data-startref="ix_ch06-asciidoc18" id="idm45139261678600" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/></p>

<p class="author1">Let’s switch focus now to a different aspect of building reliability in your source: managing binary dependencies<a data-type="indexterm" data-startref="ix_ch06-asciidoc14" id="idm45139261677416" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/><a data-type="indexterm" data-startref="ix_ch06-asciidoc13" id="idm45139261676712" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/>.<a data-type="indexterm" data-startref="ix_ch06-asciidoc12" id="idm45139261675912" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/></p>
</div></section>



</div></section>





</div></section>













</div></section></div>



  

<div id="sbo-rt-content" class="calibre2">
<section data-type="chapter" type="chapter" data-pdf-bookmark="Chapter 6. Source Code Observability" class="calibre3">
<div class="preface" id="ch_source_code_observability">
<section data-type="sect1" data-pdf-bookmark="Dependency Management" class="calibre3"><div class="preface" id="idm45139262771576">
<h1 class="calibre19" id="AFOFK-2d714b853a094e9a910510217e0e3d73">Dependency Management</h1>

<p class="author1"><a data-type="indexterm" data-primary="binary dependency management" id="ix_ch06-asciidoc20" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/><a data-type="indexterm" data-primary="dependency management" data-secondary="source code and" id="ix_ch06-asciidoc21" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/><a data-type="indexterm" data-primary="source code observability" data-secondary="dependency management" id="ix_ch06-asciidoc22" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/>Binary dependencies (those defined in Gradle build files or Maven POMs) present a series of systemic challenges. We’ll go over several of these issues and present strategies for how to solve them. You’ll notice that in each case the remediation is something that is applied at the build tool layer.</p>

<p class="author1"><a data-type="indexterm" data-primary="curation of dependencies" id="idm45139261670104" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/>Some organizations attempt to limit the impact of dependency problems through <em class="calibre12">curation</em>, i.e., barring the use of dependencies from public artifact repository sources like Maven Central or JCenter in favor of an approved and curated set of dependencies. Curation of dependencies presents its own series of challenges. Specifically, given how interconnected libraries are, deciding to add another library to the curated set involves adding its entire transitive closure. There also is a natural tendency to avoid the toil necessary to get new artifacts added, which means your organization will skew toward slightly older versions of libraries, increasing the security vulnerability and bug footprint. Ironically, the goal of curation is usually to <em class="calibre12">improve</em> security. At the very least, this trade-off is worth evaluating against your stated goal.</p>








</div></section>













</div></section></div>



  

<div id="sbo-rt-content" class="calibre2">
<section data-type="chapter" type="chapter" data-pdf-bookmark="Chapter 6. Source Code Observability" class="calibre3">
<div class="preface" id="ch_source_code_observability">
<section data-type="sect1" data-pdf-bookmark="Dependency Management" class="calibre3">
<div class="preface" id="idm45139262771576">
<section data-type="sect2" data-pdf-bookmark="Version Misalignments" class="calibre3"><div class="preface" id="idm45139261667592">
<h2 class="calibre37" id="calibre_pb_15">Version Misalignments</h2>

<p class="author1"><a data-type="indexterm" data-primary="dependency management" data-secondary="version misalignments" id="idm45139261666152" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/><a data-type="indexterm" data-primary="version misalignments" id="idm45139261665176" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/>Version misalignments caused by conflict resolution of dependency families like Jackson cause the family to not function correctly. Curated artifact repositories increase the likelihood of version misalignments.</p>

<p class="author1">Jackson is a great example of this. Suppose we brought a new version of Spring Boot and its transitive dependencies into our curated repository. <a data-type="xref" href="part0011_split_015.html#spring_transitive_jackson_dependencies" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">Figure 6-6</a> uses the Gradle <code class="calibre24">dependencyInsight</code> task to show the Jackson dependencies that are included in Spring Boot’s transitive dependency closure and the paths by which they are included.</p>

<p class="author1">Notably absent from this list are all the other Jackson modules that aren’t directly required by the framework, e.g., <code class="calibre24">jackson-module-kotlin</code>, <code class="calibre24">jackson-module-afterburner</code>, and <code class="calibre24">jackson-modules-java8</code>. Any microservice using one of these other modules that updates to the new version of Spring Boot included in the curated repository now has an unresolvable version misalignment (which may or may not create runtime issues) until the new versions of those modules are also added to the curated set.</p>

<figure class="calibre32"><div id="spring_transitive_jackson_dependencies" class="figure">
<img src="../images/00007.png" alt="srej 0606" class="calibre162"/>
<h6 class="calibre34"><span class="keep-together">Figure 6-6. </span>Spring Boot transitive Jackson dependencies</h6>
</div></figure>

<p class="author1">Dynamic versions create a different set of problems.</p>
</div></section>













</div></section>













</div></section></div>



  

<div id="sbo-rt-content" class="calibre2">
<section data-type="chapter" type="chapter" data-pdf-bookmark="Chapter 6. Source Code Observability" class="calibre3">
<div class="preface" id="ch_source_code_observability">
<section data-type="sect1" data-pdf-bookmark="Dependency Management" class="calibre3">
<div class="preface" id="idm45139262771576">
<section data-type="sect2" data-pdf-bookmark="Dynamic Version Constraints" class="calibre3"><div class="preface" id="idm45139261657496">
<h2 class="calibre37" id="calibre_pb_16">Dynamic Version Constraints</h2>

<p class="author1"><a data-type="indexterm" data-primary="dependency management" data-secondary="dynamic version constraints" id="idm45139261656088" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/><a data-type="indexterm" data-primary="dynamic version constraints" id="idm45139261654920" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/>Java build tooling unfortunately still lacks advanced range selectors for semantic versioning like <a href="https://oreil.ly/17iNf" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">NPM’s selector</a>. Instead, we are left with coarser selectors like <code class="calibre24">latest.release</code> and <code class="calibre24">2.10.+</code> in Gradle and <code class="calibre24">RELEASE</code> and <code class="calibre24">(,2.11.0]</code> (range selection) in Maven.</p>

<p class="author1">Whenever possible, it is best to avoid <code class="calibre24">+</code> type selectors, because they <em class="calibre12">lexicographically</em> sort versions. So <code class="calibre24">2.10.9</code> is considered later than <code class="calibre24">2.10.10</code>.</p>

<p class="author1">The Maven-style range selector unfortunately pins you to an upper bound that isn’t static. When a further release comes out, the upper bounds need to be updated everywhere they are defined.</p>

<p class="author1">While for the most part, common open source libraries are cautious to only publish releases to public repositories, periodically we still see even heavily used libraries publish release candidates. Unfortunately, the <code class="calibre24">latest.release</code> (Gradle) and <code class="calibre24">RELEASE</code> (Maven) selectors don’t know how to distinguish between release version numbers and version numbers that to a human are clearly release candidates. For example, in March 2020, Jackson published a <code class="calibre24">2.11.0.rc1</code>, which would be selected by <code class="calibre24">latest.release</code>. Less than a year earlier, in September 2019, Jackson published a <code class="calibre24">2.10.0.pr1</code> version (the unconventional “pr” suffix apparently meaning “pre-release”). Neither one of these versions semantically matches the intent behind “latest release.”</p>

<p class="author1">We can bar known patterns for release candidates by adding two Maven repositories to the Gradle build that together form a disjoint subset of resolvable artifacts, in the case of <a data-type="xref" href="part0011_split_016.html#bar_jackson_rcs" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">Example 6-29</a>, the set of all nonrelease candidate Jackson modules, and everything other than Jackson modules.</p>
<div id="bar_jackson_rcs" data-type="example" class="calibre61">
<h5 class="calibre62"><span class="keep-together">Example 6-29. </span>Barring the use of Jackson release candidates in Gradle</h5>

<pre data-type="programlisting" data-code-language="kotlin" class="calibre63"><code class="n">repositories</code> <code class="p">{</code>
  <code class="n">mavenCentral</code> <code class="p">{</code>
    <code class="n">content</code> <code class="p">{</code>
      <code class="n">excludeVersionByRegex</code><code class="p">(</code><code class="s">"com\\.fasterxml\\.jackson\\..*"</code><code class="p">,</code> <code class="s">".*"</code><code class="p">,</code>
        <code class="s">".*rc.*"</code><code class="p">)</code>
    <code class="p">}</code>
  <code class="p">}</code>
  <code class="n">mavenCentral</code> <code class="p">{</code>
    <code class="n">content</code> <code class="p">{</code>
      <code class="n">includeVersionByRegex</code><code class="p">(</code><code class="s">"com\\.fasterxml\\.jackson\\..*"</code><code class="p">,</code> <code class="s">".*"</code><code class="p">,</code>
        <code class="s">"(\\d+\\.)*\\d+"</code><code class="p">)</code>
    <code class="p">}</code>
  <code class="p">}</code>
<code class="p">}</code></pre></div>

<p class="author1">Unused dependencies pose a different sort of problem.</p>
</div></section>













</div></section>













</div></section></div>



  

<div id="sbo-rt-content" class="calibre2">
<section data-type="chapter" type="chapter" data-pdf-bookmark="Chapter 6. Source Code Observability" class="calibre3">
<div class="preface" id="ch_source_code_observability">
<section data-type="sect1" data-pdf-bookmark="Dependency Management" class="calibre3">
<div class="preface" id="idm45139262771576">
<section data-type="sect2" data-pdf-bookmark="Unused Dependencies" class="calibre3"><div class="preface" id="unused_dependencies">
<h2 class="calibre37" id="calibre_pb_17">Unused Dependencies</h2>

<p class="author1"><a data-type="indexterm" data-primary="dependency management" data-secondary="unused dependencies" id="idm45139261542344" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/><a data-type="indexterm" data-primary="unused dependencies" id="idm45139261541368" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/>In addition to bloating the size of a packaged microservice (which is rarely a major issue), unused dependencies can result in implicit autoconfiguration of features, with serious consequences.</p>

<p class="author1">A Spring Data REST <a href="https://oreil.ly/m6n_W" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">vulnerability</a> caught by surprise many who weren’t even using the library but, being present in the runtime classpath, caused Spring to the autoconfigure a series of REST endpoints that exposed an attack vector.</p>

<p class="author1">Guice-based <a href="https://oreil.ly/yrGcx" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">Governator</a> autoconfigures any Guice module in the classpath. Governator’s scanning mechanism is not constrained by package name. Modules located in the classpath could have dependencies on other modules, but these dependencies weren’t necessarily reliably in the classpath. Frequently, unused but autoconfigured Guice modules caused application failure because dependencies that were previously accidentally on the classpath were removed.</p>

<p class="author1">Unused dependencies can be detected and removed automatically by the <a href="https://oreil.ly/4YFe8" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">Nebula Lint</a> Gradle plug-in. It can be configured in a Gradle project, as shown in <a data-type="xref" href="part0011_split_017.html#nebula_lint_unused_dependencies" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">Example 6-30</a>.</p>
<div id="nebula_lint_unused_dependencies" data-type="example" class="calibre61">
<h5 class="calibre62"><span class="keep-together">Example 6-30. </span>Nebula Lint configuration for unused dependencies</h5>

<pre data-type="programlisting" data-code-language="groovy" class="calibre63"><code class="n">plugins</code> <code class="o">{</code>
  <code class="n">id</code> <code class="s">"nebula.lint"</code> <code class="n">version</code> <code class="s">"LATEST"</code>
<code class="o">}</code>

<code class="n">gradleLint</code><code class="o">.</code><code class="na">rules</code> <code class="o">=</code> <code class="o">[</code><code class="s">'unused-dependency'</code><code class="o">]</code></pre></div>

<p class="author1">When <code class="calibre24">nebula.lint</code> is applied, build scripts will be automatically linted by a task called <code class="calibre24">lintGradle</code> after the last task in the task graph executes. Results are reported in the console, as shown in <a data-type="xref" href="part0011_split_017.html#lint_output" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">Figure 6-7</a>.</p>

<figure class="calibre32"><div id="lint_output" class="figure">
<img src="../images/00030.png" alt="srej 0607" class="calibre163"/>
<h6 class="calibre34"><span class="keep-together">Figure 6-7. </span>Nebula Lint warning about dependency formatting</h6>
</div></figure>

<p class="author1">Run <code class="calibre24">./gradlew fixGradleLint</code> to automatically fix your build scripts. The autofix process lists all violations and how they were fixed, as shown in <a data-type="xref" href="part0011_split_017.html#lint_autofix" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">Figure 6-8</a>.</p>

<figure class="calibre32"><div id="lint_autofix" class="figure">
<img src="../images/00048.png" alt="srej 0608" class="calibre164"/>
<h6 class="calibre34"><span class="keep-together">Figure 6-8. </span>Nebula Lint automatically fixing dependency formatting</h6>
</div></figure>

<p class="author1">The last problem represents the mirror opposite of unused dependencies.</p>
</div></section>













</div></section>













</div></section></div>



  

<div id="sbo-rt-content" class="calibre2">
<section data-type="chapter" type="chapter" data-pdf-bookmark="Chapter 6. Source Code Observability" class="calibre3">
<div class="preface" id="ch_source_code_observability">
<section data-type="sect1" data-pdf-bookmark="Dependency Management" class="calibre3">
<div class="preface" id="idm45139262771576">
<section data-type="sect2" data-pdf-bookmark="Undeclared Explicitly Used Dependencies" class="calibre3"><div class="preface" id="idm45139261543544">
<h2 class="calibre37" id="calibre_pb_18">Undeclared Explicitly Used Dependencies</h2>

<p class="author1"><a data-type="indexterm" data-primary="dependency management" data-secondary="undeclared explicitly used dependencies" id="idm45139261477352" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/><a data-type="indexterm" data-primary="undeclared dependencies" id="idm45139261476408" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/>An application class imports a class from a dependency that is defined transitively. The first-order dependency that effectively brought the transitive dependency onto the classpath is either removed or its tree changes such that the transitive dependency is no longer on the classpath.</p>

<p class="author1">Undeclared dependencies can also be detected and added automatically by Nebula Lint. It can be configured in a Gradle project, as shown in <a data-type="xref" href="part0011_split_018.html#nebula_lint_undeclared_dependencies" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre">Example 6-31</a>.</p>
<div id="nebula_lint_undeclared_dependencies" data-type="example" class="calibre61">
<h5 class="calibre62"><span class="keep-together">Example 6-31. </span>Nebula Lint configuration for undeclared dependencies</h5>

<pre data-type="programlisting" data-code-language="groovy" class="calibre63"><code class="n">plugins</code> <code class="o">{</code>
  <code class="n">id</code> <code class="s">"nebula.lint"</code> <code class="n">version</code> <code class="s">"LATEST"</code>
<code class="o">}</code>

<code class="n">gradleLint</code><code class="o">.</code><code class="na">rules</code> <code class="o">=</code> <code class="o">[</code><code class="s">'undeclared-dependency'</code><code class="o">]</code></pre></div>

<p class="author1">Once added as a first-order dependency, its visibility as a dependency whose version matters to this application is more important.<a data-type="indexterm" data-startref="ix_ch06-asciidoc22" id="idm45139261469048" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/><a data-type="indexterm" data-startref="ix_ch06-asciidoc21" id="idm45139261468440" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/><a data-type="indexterm" data-startref="ix_ch06-asciidoc20" id="idm45139261438296" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/></p>
</div></section>





</div></section>













</div></section></div>



  

<div id="sbo-rt-content" class="calibre2">
<section data-type="chapter" type="chapter" data-pdf-bookmark="Chapter 6. Source Code Observability" class="calibre3">
<div class="preface" id="ch_source_code_observability">
<section data-type="sect1" data-pdf-bookmark="Summary" class="calibre3"><div class="preface" id="idm45139261437560">
<h1 class="calibre19" id="calibre_pb_19">Summary</h1>

<p class="author1">This chapter introduced some of the basic requirements to set up your software delivery life cycle in such a way that you can map deployed assets back to the source code that was included inside of them. With an increase in the number of deployed assets (smaller microservices), the existence of some queryable system of record to determine where particular code patterns are present in production-executable code becomes more important.</p>

<p class="author1">In the next chapter, we will discuss traffic management and call resiliency patterns that can be used to compensate for and limit the extent of failure, which will naturally be present in any microservice architecture.<a data-type="indexterm" data-startref="ix_ch06-asciidoc0" id="idm45139261435160" class="pcalibre2 pcalibre3 pcalibre1 pcalibre4 pcalibre"/></p>
</div></section>







</div></section></div>



  </body></html>