- en: Chapter 18\. Using Java with Other Languages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 18.0 Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Java has several methods of running programs written in other languages. You
    can invoke a compiled program or executable script using `Runtime.exec()`, as
    I’ll describe in [Recipe 18.1](#javacook-otherlang-SECT-1). There is an element
    of system dependency here, because you can only run external applications under
    the operating system they are compiled for. Alternatively, you can invoke one
    of a number of scripting languages (or *dynamic languages*)—running the gamut:
    awk, bsh, Clojure, Ruby, Perl, Python, Scala—using `javax.script`, as illustrated
    in [Recipe 18.3](#javacook-otherlang-scripting). Or you can drop down to C level
    with Java’s *native code* mechanism and call compiled functions written in C/C++;
    see [Recipe 18.6](#javacook-otherlang-SECT-5). From native code, you can call
    to functions written in just about any language. Not to mention that you can contact
    programs written in any language over a socket (see [Chapter 13](ch13.html#javacook-netserver)),
    with HTTP services (see [Chapter 13](ch13.html#javacook-netserver)), or with Java
    clients in RMI or CORBA clients in a variety of languages.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a wide range of other JVM languages, including these:'
  prefs: []
  type: TYPE_NORMAL
- en: BeanShell, a general scripting language for Java.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Groovy](https://groovy-lang.org) is a Java-based scripting language that pioneered
    the use of closures in the Java language ecosystem. It also has a rapid-development
    web package called [Grails](http://grails.org) and a build tool called Gradle
    (see [Recipe 1.8](ch01.html#javacook-getstarted-gradle)). Gradle is also used
    as the build tool in modern Android development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Jython](http://jython.org), a full Java implementation of Python.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[JRuby](http://jruby.org), a full Java implementation of the Ruby language.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Scala](http://scala-lang.org), a JVM language that claims to offer the “best
    of functional and OO” languages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Clojure](http://clojure.org), a predominantly functional [Lisp-1](https://en.wikipedia.org/wiki/Common_Lisp#The_function_namespace)
    dialect for the JVM.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Renjin](http://renjin.org) (pronounced “R engine”), a fairly complete open
    source clone of the R statistics package with the ability to scale to the cloud.
    See [Recipe 11.5](ch11.html#javacook-ds-r-within-java) for an example using Renjin.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are JVM-centric, and some can be called directly from Java to script,
    or vice versa, without using `javax.script`. A list of these languages can be
    found on [Wikipedia](http://en.wikipedia.org/wiki/List_of_JVM_languages).
  prefs: []
  type: TYPE_NORMAL
- en: 18.1 Running an External Program from Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to run an external program from within a Java program.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use one of the `exec()` methods in the `java.lang.Runtime` class. Or set up
    a `ProcessBuilder` and call its `start()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `exec()` method in the `Runtime` class lets you run an external program.
    The command line you give is broken into strings by a simple `StringTokenizer`
    (see [Recipe 3.1](ch03.html#javacook-strings-SECT-1)) and passed on to the operating
    system’s “execute a program” system call. As an example, here is a simple program
    that uses `exec()` to run *kwrite*, a windowed text editor program.^([1](ch18.html#idm45290622339272))
    On Windows, you’d have to change the name to `notepad` or `wordpad`, possibly
    including the full pathname, for example, *c:/windows/notepad.exe* (you can also
    use backslashes, but be careful to double them because the backslash is special
    in Java strings):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When you compile and run it, the appropriate editor window appears:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This version of `exec()` assumes that the pathname contains no blanks because
    these break proper operation of the `StringTokenizer`. To overcome this potential
    problem, use an overloaded form of `exec()`, taking an array of strings as arguments.
    [Example 18-1](#javacook-otherlang-EX-1) runs the Windows or Unix version of the
    Firefox web browser, assuming that Firefox was installed in the default directory
    (or another directory that is on your `PATH`). It passes the name of a help file
    as an argument, offering a kind of primitive help mechanism, as displayed in [Figure 18-1](#javacook-otherlang-FIG-1).
  prefs: []
  type: TYPE_NORMAL
- en: Example 18-1\. main/src/main/java/otherlang/ExecDemoNS.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![jcb4 1801](assets/jcb4_1801.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18-1\. ExecDemoNS in action
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A newer class, `ProcessBuilder`, replaces most nontrivial uses of `Runtime.exec()`.
    This `ProcessBuilder` uses generic collections to let you modify or replace the
    environment, as shown in [Example 18-2](#javacook-otherlang-EX-2).
  prefs: []
  type: TYPE_NORMAL
- en: Example 18-2\. main/src/main/java/otherlang/ProcessBuilderDemo.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_using_java_with_other_languages_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set up the command-line argument list: editor program name and filename.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_using_java_with_other_languages_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Use that to start configuring the `ProcessBuilder`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_using_java_with_other_languages_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Configure the builder’s environment to a list of common MS Windows directories.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_using_java_with_other_languages_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Set the initial directory to the user’s home, and start the process!
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_using_java_with_other_languages_CO1-5)'
  prefs: []
  type: TYPE_NORMAL
- en: I always wanted to be able to use this line in code.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_using_java_with_other_languages_CO1-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Wait for the end of our little play.
  prefs: []
  type: TYPE_NORMAL
- en: For more on `ProcessBuilder`, see the javadoc for `java.lang.ProcessBuilder`.
  prefs: []
  type: TYPE_NORMAL
- en: 18.2 Running a Program and Capturing Its Output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to run a program but also capture its output.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `Process` object’s `getInputStream()`; read and copy the contents to
    `System.out` or wherever you want them.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The original notion of standard output and standard error was that they would
    always be connected to the terminal; this notion dates from an earlier time when
    almost all computer users worked at the command line. Today, a program’s standard
    output and error output do not always automatically appear anywhere. Arguably
    there should be an automatic way to make this happen. But for now, you need to
    add a few lines of code to grab the program’s output and print it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is such a common occurrence that I’ve packaged it up into a class called
    `ExecAndPrint`, which is part of my `com.darwinsys.lang` package. `ExecAndPrint`
    has several overloaded forms of its `run()` method (see the documentation for
    details), but they all take at least a command and optionally an output file to
    which the command’s output is written. [Example 18-3](#javacook-otherlang-EX-2ch24)
    shows the code for some of these methods.
  prefs: []
  type: TYPE_NORMAL
- en: Example 18-3\. darwinsys-api/src/main/java/com/darwinsys/lang/ExecAndPrint.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As a simple example of using `exec()` directly along with `ExecAndPrint`, I’ll
    create three temporary files, list them (directory listing), and then delete them.
    When I run the `ExecDemoFiles` program, it lists the three files it has created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Its source code is in [Example 18-4](#javacook-otherlang-EX-3).
  prefs: []
  type: TYPE_NORMAL
- en: Example 18-4\. main/src/main/java/otherlang/ExecDemoFiles.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: A process isn’t necessarily destroyed when the Java program that created it
    exits or bombs out. Simple text-based programs will be, but window-based programs
    like *kwrite* Netscape, or even a Java-based `JFrame` application, will not. For
    example, our `ExecDemoNS` program started Netscape, and when `ExecDemoNS`’s Exit
    button is clicked, `ExecDemoNS` exits but Netscape stays running. What if you
    want to be sure a process has completed? The `Process` object has a `waitFor()`
    method that lets you do so, and an `exitValue()` method that tells you the return
    code from the process. Finally, should you wish to forcibly terminate the other
    process, you can do so with the `Process` object’s `destroy()` method, which takes
    no argument and returns no value. [Example 18-5](#javacook-otherlang-EX-4) is
    `ExecDemoWait`, a program that runs whatever program you name on the command line
    (along with arguments), captures the program’s standard output, and waits for
    the program to terminate.
  prefs: []
  type: TYPE_NORMAL
- en: Example 18-5\. main/src/main/java/otherlang/ExecDemoWait.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You wouldn’t normally use any form of `exec()` to run one Java program from
    another in this way; instead, you’d probably create it as a thread within the
    same process, because this is generally quite a bit faster (the Java interpreter
    is already up and running, so why wait for another copy of it to start up?). See
    [Chapter 16](ch16.html#javacook-threads).
  prefs: []
  type: TYPE_NORMAL
- en: When building industrial-strength applications, note the cautionary remarks
    in the Java API docs for the `Process` class concerning the danger of losing some
    of the I/O due to insufficient buffering by the operating system.
  prefs: []
  type: TYPE_NORMAL
- en: 18.3 Calling Other Languages via javax.script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to invoke a script written in some other language from within your
    Java program, running in the JVM, with the ability to pass variables directly
    to/from the other language.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the script you want is written in any of the two-dozen-plus supported languages,
    use `javax.script`. Those languages include awk, Perl, Python, Ruby, BeanShell,
    PNuts, Ksh/Bash, R (Renjin), and several implementations of JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the first tasks when using this API is to find out the installed scripting
    engines, and then pick one that is available. The `ScriptEnginesDemo` program
    in [Example 18-6](#javacook-otherlang-scriptenginesdemo) lists the installed engines
    and runs a simple script in the default language, ECMAScript (aka JavaScript).
  prefs: []
  type: TYPE_NORMAL
- en: Example 18-6\. main/src/main/java/otherlang/ScriptEnginesDemo.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 18-7](#javacook-otherlang-pythonfromjava) is a very simple demo of
    calling Python from Java using `javax.scripting`. We know the name of the scripting
    engine we want to use: Python. We’ll use the in-vm implementation known as `jython`,
    which was originally called JPython but was changed due to a trademark issue.
    Once we put the *jython-standalone-2.nnn.jar* onto our `CLASSPATH`, the script
    engine is automatically detected. Just in case it fails, we print a verbose message
    including a list of the engines that are available.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 18-7\. main/src/main/java/otherlang/PythonFromJava.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before Oracle dismantled java.net, there used to be a list of many languages
    (see [this archived list](https://web.archive.org/web/20140909141915/https://java.net/projects/scripting/sources/svn/show/trunk/engines);
    the links don’t work, but it shows the extent of the languages that were available).
    Back then, you could download the script engines from that site. I am not aware
    of a current official list of engines, unfortunately. However, the list maintained
    as part of the scripting project per se can be found in an unofficial source code
    repository, by viewing [*https://github.com/scijava/javax-scripting*](https://github.com/scijava/javax-scripting),
    from which it should in theory be possible to build the one you want. A dozen
    or so other engines are maintained by others outside this project; for example,
    there is a `Perl5` script engine from [Google Code](https://code.google.com/archive/p/javaperlscripting).
  prefs: []
  type: TYPE_NORMAL
- en: There is a also a [list of Java-compatible scripting languages](http://java-source.net/open-source/scripting-languages)
    (not necessarily all using `javax.script`).
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to roll your own scripting engine; see my write-up at [*https://darwinsys.com/java/scriptengines.html*](https://darwinsys.com/java/scriptengines.html).
  prefs: []
  type: TYPE_NORMAL
- en: 18.4 Mixing Languages with GraalVM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GraalVM aims to be multilanguage, and you’d like to use different languages
    in the VM.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use *gu* (graal utility) to install additional language packs and call other
    languages.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While GraalVM positions itself as able to support a wide variety of programming
    languages, the number currently supported is small but growing. Let’s try invoking
    Python code from within Java. Assuming you’ve installed Graal itself as per [Recipe
    1.2](ch01.html#jcb-getstarted-graal), you should have *gu* on your executable
    path, so try the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Then the code in [Example 18-8](#javacook-otherlang-graalpy) can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Example 18-8\. graal/src/JavaCallPython.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 18.5 Marrying Java and Perl
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to call Java from Perl, or vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To call Java from Perl, use the Perl `Inline::Java` module. To go the other
    way—calling Perl from Java—use `javax.script`, as in [Recipe 18.3](#javacook-otherlang-scripting).
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Perl is often called a glue language that can be used to bring together diverse
    parts of the software world. But, in addition, it is a full-blown language for
    creating software. A wealth of extension modules provide ready-to-run solutions
    for quite diverse problems, and most of these modules are available free from
    CPAN, the [Comprehensive Perl Archive Network](http://www.cpan.org). Also, as
    a scripting language, it is ideally suited for rapid prototyping. On the other
    hand, although building graphical user interfaces is definitely possible in Perl,
    it is not exactly one of the language’s strengths. So you might want to construct
    your GUI using Java Swing, and, at the same time, reuse business logic implemented
    in Perl.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, among the many CPAN modules, `Inline::Java` makes the integration
    of Perl and Java a breeze. Let’s assume first that you want to call into Java
    from Perl. For business logic, I have picked a CPAN module that measures the similarity
    of two strings (the so-called *Levenshtein edit distance*). [Example 18-9](#javacook-otherlang-EX-7)
    shows the complete source. You need at least version 0.44 of the module `Inline::Java`;
    previous versions did not support threaded applications properly, so use of Swing
    wasn’t possible.
  prefs: []
  type: TYPE_NORMAL
- en: Using the module this way requires that the Java source be included in the Perl
    script with special delimiters, as shown in [Example 18-9](#javacook-otherlang-EX-7).
  prefs: []
  type: TYPE_NORMAL
- en: Example 18-9\. Swinging.pl
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Since this uses the `Text::Levenshtein` and the `Inline::Java` modules, you
    will have to install that. Here’s the standard way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'On some systems there may be an OS-specific module; for example, on OpenBSD
    Unix, it’s this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In a simple Perl+Java program like this, you don’t even need to write a separate
    Java source file: you combine all the code, Perl and Java alike, in one single
    file. You do not need to compile anything, either; just execute it by typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '(You can also add a string argument.) After a little churning, a Java message
    box pops up, telling you that the distance between `Japh` and `Java` is 2\. At
    the same time, your console shows the string “Just another Perl hacker inside
    Java.” When you close the message box, you get the final result “matcher: 2 (displayed
    from Perl).”'
  prefs: []
  type: TYPE_NORMAL
- en: 'In between, your Perl program has created an instance of the Java class `Showit`
    by calling its constructor. It then called that object’s `show()` method to display
    a string from within Java. It then proceeded to call the `match()` method, but
    this time, something more complicated happens: the Java code calls back into Perl,
    accessing method `distance` of module `Text::Levenshtein` and passing it two strings
    as arguments. It receives the result, displays it in a message box, and finally,
    for good measure, returns it to the Perl main program that it had been called
    from.'
  prefs: []
  type: TYPE_NORMAL
- en: Incidentally, the `eval { }` block around the method call is the Perlish way
    of catching exceptions. In this case, the exception is thrown from within Java.
  prefs: []
  type: TYPE_NORMAL
- en: If you restart the program, you will notice that startup time is much shorter,
    which is always good news. Why is that so? On the first call, `Inline::Java` took
    the input apart, precompiled the Java part, and saved it to disk (usually, in
    a subdirectory called *_Inline*). On subsequent calls, it just makes sure that
    the Java source has not changed and then calls the class file that is already
    on disk. (Of course, if you surreptitiously changed the Java code, it is recompiled
    just as automagically.) Behind the scenes, even stranger things are going on,
    however. When the Perl script is executed, a Java server is constructed and started
    unbeknownst to the user, and the Perl part and the Java bits communicate through
    a TCP socket (see [Chapter 13](ch13.html#javacook-netserver)).
  prefs: []
  type: TYPE_NORMAL
- en: Marrying two platform-independent languages, like Perl and Java, in a portable
    way skirts many portability problems. When distributing inlined applications,
    be sure to supply not just the source files but also the contents of the *_Inline*
    directory. (It is advisable to purge that directory and to rebuild everything
    just before distribution time; otherwise, old compiled versions left lying around
    might make it into the distribution.) Each target machine needs to repeat the
    magic steps of `Inline::Java`, which requires a Java compiler. In any case, the
    `Inline::Java` module must be installed.
  prefs: []
  type: TYPE_NORMAL
- en: Because Perl has `Inline` modules for a number of other languages (ordinary
    languages like C, but others as exotic as Befunge), one might even consider using
    Perl as glue for interoperation between those other languages, jointly or separately,
    and Java. I am sure many happy hours can be spent working out the intricacies
    of such interactions.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can find full information on `Inline::Java` on [CPAN](http://search.cpan.org)
    or in the POD (Plain Old Documentation) that is installed along with the module
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: 18.6 Calling Other Languages via Native Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You wish to call native C/C++ functions from Java, either for efficiency or
    to access hardware- or system-specific features.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use JNI, the Java Native Interface. Or, use GraalVM.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Java lets you load native or compiled code into your Java program. Why would
    you want to do such a thing? The best reason would probably be to access OS-dependent
    functionality, or existing code written in another language. A less good reason
    would be speed: native code can sometimes run faster than Java, though this is
    becoming less important as computers get faster and more multicore. Like everything
    else in Java, the native code mechanism is subject to security restrictions; for
    example, applets were not allowed to access native code.'
  prefs: []
  type: TYPE_NORMAL
- en: The native code language bindings are defined for code written in C or C++.
    If you need to access a language other than C/C++, write a bit of C/C++ and have
    it pass control to other functions or applications, using any mechanism defined
    by your operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Due to such system-dependent features as the interpretation of header files
    and the allocation of the processor’s general-purpose registers, your native code
    may need to be compiled by the same C compiler used to compile the Java runtime
    for your platform. For example, on Solaris you can use SunPro C or maybe gcc.
    On Win32 platforms, use Microsoft visual C++ Version 4.x or higher (32 bit). For
    Linux and macOS, you should be able to use the provided gcc-based compiler. For
    other platforms, see your Java vendor’s documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that the details in this section are for the Java Native Interface
    (JNI) of Java 1.1 and later, which differs in some details from 1.0 and from Microsoft’s
    native interface.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to write Java code that calls a native method. To do this,
    use the keyword `native` to indicate that the method is native, and provide a
    static code block that loads your native method using `System.loadLibrary()`.
    (The dynamically loadable module is created in step 5.) Static blocks are executed
    when the class containing them is loaded; loading the native code here ensures
    it is in memory when needed!
  prefs: []
  type: TYPE_NORMAL
- en: Object variables that your native code may modify should carry the `volatile`
    modifier. The file *HelloJni.java*, shown in [Example 18-10](#javacook-otherlang-EX-10),
    is a good starting point.
  prefs: []
  type: TYPE_NORMAL
- en: Example 18-10\. main/src/main/java/jni/HelloJni.java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The second step is simple; just use *javac HelloJni.java* as you normally would.
    You probably won’t get any compilation errors on a simple program like this; if
    you do, correct them and try the compilation again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you need to create an *.h* file. Use *javah* to produce this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The *.h* file produced is a glue file, not really meant for human consumption
    and particularly not for editing. But by inspecting the resulting *.h* file, you’ll
    see that the C method’s name is composed of the name `Java`, the package name
    (if any), the class name, and the method name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Then create a C function that does the work. You must use the same function
    signature as is used in the *.h* file.
  prefs: []
  type: TYPE_NORMAL
- en: 'This function can do whatever it wants. Note that it is passed two arguments:
    a JVM environment variable and a handle for the `this` object. [Table 18-1](#javacook-otherlang-TABLE-2)
    shows the correspondence between Java types and the C types (JNI types) used in
    the C code.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 18-1\. Java and JNI types
  prefs: []
  type: TYPE_NORMAL
- en: '| Java type | JNI | Java array type | JNI |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `byte` | `jbyte` | `byte[]` | `jbyteArray` |'
  prefs: []
  type: TYPE_TB
- en: '| `short` | `jshort` | `short[]` | `jshortArray` |'
  prefs: []
  type: TYPE_TB
- en: '| `int` | `jint` | `int[]` | `jintArray` |'
  prefs: []
  type: TYPE_TB
- en: '| `long` | `jlong` | `long[]` | `jlongArray` |'
  prefs: []
  type: TYPE_TB
- en: '| float | jfloat | float[] | jfloatArray |'
  prefs: []
  type: TYPE_TB
- en: '| `double` | `jdouble` | `double[]` | `jdoubleArray` |'
  prefs: []
  type: TYPE_TB
- en: '| `char` | `jchar` | `char[]` | `jcharArray` |'
  prefs: []
  type: TYPE_TB
- en: '| `boolean` | `jboolean` | `boolean[]` | `jbooleanArray` |'
  prefs: []
  type: TYPE_TB
- en: '| `void` | `jvoid` |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| `Object` | `jobject` | `Object[]` | `jobjectArray` |'
  prefs: []
  type: TYPE_TB
- en: '| `Class` | `jclass` |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| `String` | `jstring` |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| `array` | `jarray` |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| `Throwable` | `jthrowable` |  |  |'
  prefs: []
  type: TYPE_TB
- en: '[Example 18-11](#javacook-otherlang-EX-11) is a complete C native implementation.
    Passed an object of type `Hel⁠lo​Jni.java`, it increments the integer `myNumber`
    contained in the object.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 18-11\. main/src/main/java/jni/HelloJni.c
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you compile the C code into a loadable object. Naturally, the details
    depend on platform, compiler, etc. For example, on Windows, you could use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'And on Unix, you could use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 18-12](#javacook-otherlang-EX-12) is a makefile for Unix.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 18-12\. main/src/main/java/jni/Makefile (Unix version)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'And you’re done! Just run the Java interpreter on the class file containing
    the main program. Assuming that you’ve set whatever system-dependent settings
    are necessary (possibly including both `CLASSPATH` and `LD_LIBRARY_PATH` or its
    equivalent), the program should run as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations! You’ve called a native method. However, you’ve given up portability;
    the Java class file now requires you to build a loadable object for each operating
    system and hardware platform. Multiply {Windows, Mac OS X, Sun Solaris, HP/UX,
    Linux, OpenBSD, NetBSD, FreeBSD} times {Intel-32, Intel-64/AMD64, Arm, Arm-64,
    and maybe SPARC64, PowerPC, and HP-PA}, and you begin to see the portability issues.
  prefs: []
  type: TYPE_NORMAL
- en: Beware that problems with your native code can and will crash the runtime process
    right out from underneath the Java Virtual Machine. The JVM can do nothing to
    protect itself from poorly written C/C++ code. Memory must be managed by the programmer;
    there is no automatic garbage collection of memory obtained by the system runtime
    allocator. You’re dealing directly with the operating system and sometimes even
    the hardware, so, be careful. Be very careful.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you need more information on Java native methods, you might be interested
    in the comprehensive treatment found in *Essential JNI: Java Native Interface*
    by Rob Gordon (Prentice Hall).'
  prefs: []
  type: TYPE_NORMAL
- en: 18.7 Calling Java from Native Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to go the other way, calling Java from C/C++ code.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use JNI again.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JNI (Java Native Interface) provides an interface for calling Java from C,
    with calls to:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a JVM.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load a class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find and call a method from that class (e.g., main).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: JNI lets you add Java to legacy code. That can be useful for a variety of purposes
    and lets you treat Java code as an extension language.
  prefs: []
  type: TYPE_NORMAL
- en: The code in [Example 18-13](#javacook-otherlang-javaFromC) takes a class name
    from the command line, starts up the JVM, and calls the `main()` method in the
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Example 18-13\. main/src/main/java/jni/javafromc.c (Calling Java from C)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: ====
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch18.html#idm45290622339272-marker)) *kwrite* is Unix-specific; it’s a
    part of the [K Desktop Environment (KDE)](http://www.kde.org).
  prefs: []
  type: TYPE_NORMAL
