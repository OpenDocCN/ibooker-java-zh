["```java\n% jcmd 8998 GC.class_histogram\n8898:\n\n num     #instances         #bytes  class name\n----------------------------------------------\n   1:        789087       31563480  java.math.BigDecimal\n   2:        172361       14548968  [C\n   3:         13224       13857704  [B\n   4:        184570        5906240  java.util.HashMap$Node\n   5:         14848        4188296  [I\n   6:        172720        4145280  java.lang.String\n   7:         34217        3127184  [Ljava.util.HashMap$Node;\n   8:         38555        2131640  [Ljava.lang.Object;\n   9:         41753        2004144  java.util.HashMap\n  10:         16213        1816472  java.lang.Class\n\n```", "```java\n% jmap -histo process_id\n\n```", "```java\n% jmap -histo:live process_id\n\n```", "```java\n% jcmd process_id GC.heap_dump /path/to/heap_dump.hprof\n\n```", "```java\n% jmap -dump:live,file=/path/to/heap_dump.hprof process_id\n\n```", "```java\nException in thread \"main\" java.lang.OutOfMemoryError:\nunable to create new native thread\n```", "```java\nException in thread \"main\" java.lang.OutOfMemoryError: Metaspace\n```", "```java\nException in thread \"main\" java.lang.OutOfMemoryError: Java heap space\n```", "```java\nException in thread \"main\" java.lang.OutOfMemoryError: GC overhead limit exceeded\n```", "```java\npublic class A {\n    private int i;\n}\n\npublic class B {\n    private int i;\n    private Locale l = Locale.US;\n}\n\npublic class C {\n    private int i;\n    private ConcurrentHashMap chm = new ConcurrentHashMap();\n}\n```", "```java\npublic class CalDateInitialization {\n    private Calendar calendar = Calendar.getInstance();\n    private DateFormat df = DateFormat.getDateInstance();\n\n    private void report(Writer w) {\n        w.write(\"On \" + df.format(calendar.getTime()) + \": \" + this);\n    }\n}\n```", "```java\npublic class CalDateInitialization {\n    private Calendar calendar;\n    private DateFormat df;\n\n    private void report(Writer w) {\n        if (calendar == null) {\n            calendar = Calendar.getInstance();\n            df = DateFormat.getDateInstance();\n        }\n        w.write(\"On \" + df.format(calendar.getTime()) + \": \" + this);\n    }\n}\n```", "```java\npublic class CalDateInitialization {\n    private Calendar calendar;\n    private DateFormat df;\n\n    private synchronized void report(Writer w) {\n        if (calendar == null) {\n            calendar = Calendar.getInstance();\n            df = DateFormat.getDateInstance();\n        }\n        w.write(\"On \" + df.format(calendar.getTime()) + \": \" + this);\n    }\n}\n```", "```java\npublic class CalDateInitialization {\n    private Calendar calendar;\n    private DateFormat df;\n\n    private void report(Writer w) {\n        unsychronizedCalendarInit();\n        synchronized(df) {\n            w.write(\"On \" + df.format(calendar.getTime()) + \": \" + this);\n        }\n    }\n}\n```", "```java\npublic class CHMInitialization {\n    private ConcurrentHashMap chm;\n\n    public void doOperation() {\n        synchronized(this) {\n            if (chm == null) {\n                chm = new ConcurrentHashMap();\n                ... code to populate the map ...\n            }\n        }\n        ...use the chm...\n    }\n}\n```", "```java\npublic class CHMInitialization {\n    private volatile ConcurrentHashMap instanceChm;\n\n    public void doOperation() {\n        ConcurrentHashMap chm = instanceChm;\n        if (chm == null) {\n            synchronized(this) {\n                chm = instanceChm;\n                if (chm == null) {\n                    chm = new ConcurrentHashMap();\n                    ... code to populate the map\n                    instanceChm = chm;\n                }\n            }\n            ...use the chm...\n        }\n    }\n}\n```", "```java\npublic E remove(int index) {\n    E oldValue = elementData(index);\n    int numMoved = size - index - 1;\n    if (numMoved > 0)\n        System.arraycopy(elementData, index+1,\n                         elementData, index, numMoved);\n    elementData[--size] = null; // clear to let GC do its work\n    return oldValue;\n}\n```", "```java\npublic class ImmutableObject {\n    private static WeakHashMap<ImmutableObject, ImmutableObject>\n        map = new WeakHashMap();\n\n    public ImmutableObject canonicalVersion(ImmutableObject io) {\n        synchronized(map) {\n            ImmutableObject canonicalVersion = map.get(io);\n            if (canonicalVersion == null) {\n                map.put(io, new WeakReference(io));\n                canonicalVersion = io;\n            }\n            return canonicalVersion;\n        }\n    }\n}\n```", "```java\nlong ms = SoftRefLRUPolicyMSPerMB * AmountOfFreeMemoryInMB;\nif (now - last_access_to_reference > ms)\n   free the reference\n```", "```java\n   long ms = 2048000; // 1000 * 2048\n   if (System.currentTimeMillis() - last_access_to_reference_in_ms > ms)\n       free the reference\n```", "```java\nprivate static class CleanupFinalizer extends WeakReference {\n\n    private static ReferenceQueue<CleanupFinalizer> finRefQueue;\n    private static HashSet<CleanupFinalizer> pendingRefs = new HashSet<>();\n\n    private boolean closed = false;\n\n    public CleanupFinalizer(Object o) {\n        super(o, finRefQueue);\n        allocateNative();\n        pendingRefs.add(this);\n    }\n\n    public void setClosed() {\n        closed = true;\n        doNativeCleanup();\n    }\n\n    public void cleanup() {\n        if (!closed) {\n            doNativeCleanup();\n        }\n    }\n\n    private native void allocateNative();\n    private native void doNativeCleanup();\n}\n```", "```java\nstatic {\n    finRefQueue = new ReferenceQueue<>();\n    Runnable r = new Runnable() {\n        public void run() {\n            CleanupFinalizer fr;\n            while (true) {\n                try {\n                    fr = (CleanupFinalizer) finRefQueue.remove();\n                    fr.cleanup();\n                    pendingRefs.remove(fr);\n                } catch (Exception ex) {\n                    Logger.getLogger(\n                           CleanupFinalizer.class.getName()).\n                           log(Level.SEVERE, null, ex);\n                }\n            }\n        }\n    };\n    Thread t = new Thread(r);\n    t.setDaemon(true);\n    t.start();\n}\n```", "```java\npublic class CleanupExample {\n    private CleanupFinalizer cf;\n    private HashMap data = new HashMap();\n\n    public CleanupExample() {\n        cf = new CleanupFinalizer(this);\n    }\n\n    ...methods to put things into the hashmap...\n\n    public void close() {\n        data = null;\n        cf.setClosed();\n    }\n}\n```", "```java\npublic class java.util.zip.Inflater {\n    private static class InflaterZStreamRef implements Runnable {\n        private long addr;\n        private final Cleanable cleanable;\n        InflaterZStreamRef(Inflater owner, long addr) {\n            this.addr = addr;\n            cleanable = CleanerFactory.cleaner().register(owner, this);\n        }\n\n        void clean() {\n            cleanable.clean();\n        }\n\n        private static native void freeNativeMemory(long addr);\n        public synchronized void run() {\n            freeNativeMemory(addr);\n        }\n    }\n\n    private InflaterZStreamRef zsRef;\n\n    public Inflater() {\n        this.zsRef = new InflaterZStreamRef(this, allocateNativeMemory());\n    }\n\n    public void end() {\n        synchronized(zsRef) {\n            zsRef.clean();\n        }\n    }\n}\n```"]