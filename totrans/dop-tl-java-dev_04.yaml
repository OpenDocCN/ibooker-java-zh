- en: Chapter 4\. Dissecting the Monolith
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章。解构单体架构
- en: Ixchel Ruiz
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 伊什切尔·鲁伊兹
- en: The ultimate goal should be to improve the quality of human life through digital
    innovation.
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 终极目标应该是通过数字创新改善人类生活的质量。
- en: ''
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Pony Ma Huateng
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 马化腾
- en: Throughout history, humans have been obsessed with deconstructing ideas and
    concepts into simple or composite parts. It is by combining analysis and synthesis
    that we can achieve a higher level of understanding.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 通过历史，人类一直着迷于将想法和概念分解为简单或复合部分。通过分析和综合的结合，我们可以达到更高层次的理解。
- en: Aristotle called analytics “the resolution of every compound into those things
    out of which the synthesis is made. For analysis is the converse of synthesis.
    *Synthesis* is the road from the principles to those things that derive from the
    principles, and analysis is the return from the end to the principles.”
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 亚里士多德称分析为“将每个复合物分解成组成这些合成物的要素。因为分析是综合的反面。*综合*是从原则到由原则派生的事物的道路，而分析是从终点返回到原则。”
- en: 'Software development follows a similar approach: analyze a system into its
    composite parts, identifying inputs, desired outputs, and detail functions. During
    the analytic process of software development, we have realized that non-business-specific
    functionality is always required to process inputs and to communicate or persist
    outputs. This makes it obvious that we could benefit from reusable, well-defined,
    context-bound, atomic functionality that can be shared, consumed, or interconnected
    to simplify building software.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发遵循类似的方法：将系统分析为其组成部分，识别输入、期望输出和详细功能。在软件开发的分析过程中，我们意识到，非特定于业务的功能总是需要来处理输入，并通信或持久化输出。这使得明显的是，我们可以从可重复使用的、明确定义的、上下文绑定的原子功能中受益，这些功能可以被共享、消费或互连，以简化软件构建。
- en: 'Allowing developers to focus primarily on implementing business logic to fulfill
    purposes—like meeting well-defined needs of a client/business, meeting a perceived
    need of some set of potential users, or using the functionality for personal needs
    (to automate tasks)—has been a long-held desire. Too much time is wasted every
    day reinventing one of the most reinvented wheels: reliable boilerplate code.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 允许开发人员主要专注于实现业务逻辑，以满足客户/企业的明确定义的需求，满足一些潜在用户集的感知需求，或者使用功能来满足个人需求（自动化任务）一直是长期以来的愿望。每天都浪费太多时间在重新发明最常见的可靠样板代码。
- en: The microservices pattern has gained notoriety and momentum in recent years
    because the promised benefits are outstanding. Avoiding known antipatterns, adopting
    best practices, and understanding core concepts and definitions are paramount
    in achieving the benefits of this architectural pattern while reducing the drawbacks
    of adopting it. This chapter covers antipatterns and contains code examples of
    microservices written with popular microservice frameworks such as Spring Boot,
    Micronaut, Quarkus, and Helidon.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，微服务模式因承诺的优势而声名鹊起并获得动力。在实现这种架构模式的好处的同时，减少采用它的缺点，避免已知的反模式，采用最佳实践，并理解核心概念和定义至关重要。本章涵盖了微服务的反模式，并包含了使用Spring
    Boot、Micronaut、Quarkus和Helidon等流行微服务框架编写的代码示例。
- en: 'Traditionally a monolithic architecture delivers or deploys single units or
    systems, addressing all requirements from a single source application, and two
    concepts can be identified: the *monolith application* and the *monolithic architecture*.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，单体架构提供或部署单个单元或系统，从单一源应用程序满足所有需求，可以识别出两个概念：*单体应用程序* 和 *单体架构*。
- en: A *monolith application* has *only one* deployed instance, responsible for performing
    all steps needed for a specific function. One characteristic of such an application
    is a unique interface point of execution.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*单体应用程序* 有 *唯一的* 部署实例，负责执行特定功能所需的所有步骤。这种应用程序的一个特征是独特的执行接口点。'
- en: A *monolithic architecture* refers to an application for which all requirements
    are addressed from a single source and all parts are delivered as one unit. Components
    may have been designed to restrict interaction with external clients in order
    to explicitly limit access of *private* functionality. Components in the monolith
    may be interconnected or interdependent rather than loosely coupled. In other
    words, from the outside or user perspective, there is little knowledge of the
    definitions, interfaces, data, and services of other separate components.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*单块架构*指的是所有需求均由单一来源处理，并且所有部分作为一个单元交付的应用程序。组件可能被设计为限制与外部客户的交互，以显式限制*私有*功能的访问。单块中的组件可能是相互连接或相互依赖的，而不是松散耦合的。换句话说，从外部或用户的视角来看，对其他独立组件的定义、接口、数据和服务知之甚少。'
- en: '*Granularity* is the aggregation level exposed by a component to other external
    cooperating or collaborating parts of software. The level of granularity in software
    depends on several factors, such as the level of confidentiality that must be
    maintained within a series of components and not be exposed or available to other
    consumers.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*粒度*是一个组件向软件的其他外部合作或协作部分公开的聚合级别。软件的粒度水平取决于几个因素，例如必须在一系列组件内保持的机密级别，不可暴露或对其他消费者可用。'
- en: Modern software architectures are increasingly focused on delivering functionality
    by bundling or combining software components from different sources, resulting
    in or emphasizing a finer granularity in level of detail. The functionality exposed
    then to different components, customers, or consumers is greater than in a monolithic
    application.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现代软件架构越来越专注于通过捆绑或组合来自不同来源的软件组件来提供功能，这导致或强调了详细级别上的更细粒度。因此，向不同组件、客户或消费者公开的功能要比单块应用程序更多。
- en: 'To qualify how independent or interchangeable a module is, we should look closely
    at the following characteristics:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定一个模块有多独立或可互换，我们应该仔细看以下特征：
- en: Number of dependencies
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖的数量
- en: Strength of these dependencies
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些依赖的强度
- en: Stability of the modules it depends on
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它所依赖的模块的稳定性
- en: Any high score assigned to the previous characteristics should trigger a second
    review of the modeling and definition of the module.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对前述特征赋予的任何高分应触发对模块建模和定义的第二次审查。
- en: Cloud Computing
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云计算
- en: '*Cloud computing* has several definitions. Peter Mell and Tim Grance define
    it as a model for enabling ubiquitous, convenient, on-demand network access to
    a shared pool of configurable computing resources (such as networks, servers,
    storage, applications, and services) that can be rapidly provisioned and released
    with minimal management effort or service provider interaction.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*云计算*有多个定义。彼得·梅尔（Peter Mell）和蒂姆·格兰斯（Tim Grance）将其定义为一种模型，用于实现对共享可配置计算资源池（如网络、服务器、存储、应用程序和服务）的无处不在、方便、按需网络访问，可以快速配置和释放，几乎不需要管理工作或与服务提供商的互动。'
- en: In recent years, cloud computing has increased considerably. For example, cloud
    infrastructure services spending increased 32% to $39.9 billion in the last quarter
    of 2020\. Total expenditure was more than $3 billion higher than the previous
    quarter and nearly $10 billion more than Q4 2019, according to [Canalys data](https://oreil.ly/uZdZa).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，云计算有了显著增长。例如，2020年第四季度云基础设施服务支出增长了32%，达到了399亿美元。总支出比上一季度高出30亿美元，比2019年第四季度高出近100亿美元，据[Canalys数据](https://oreil.ly/uZdZa)显示。
- en: Several providers exist, but the market share is not evenly distributed. The
    three leading service providers are Amazon Web Services (AWS), Microsoft Azure,
    and Google Cloud. AWS is the leading cloud service provider, accounting for 31%
    of total spending in Q4 2020\. Azure’s growth rate accelerated, up by 50%, with
    a share close to 20%, whereas Google Cloud accounts for a 7% share of the total
    market.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 存在多家提供商，但市场份额并不均匀分布。三家领先的服务提供商是亚马逊网络服务（AWS）、微软Azure和谷歌云。AWS是领先的云服务提供商，在2020年第四季度占据了总支出的31%。Azure的增长率加快，增长了50%，市场份额接近20%，而谷歌云占据了总市场的7%。
- en: Utilization of cloud computing services has been lagging. Cinar Kilcioglu and
    Aadharsh Kannan reported in 2017 in “Proceedings of the 26th International World
    Wide Web Conference” that usage of cloud resources in data centers shows a substantial
    gap between the resources that cloud customers allocate and pay for (leasing VMs),
    and actual resource utilization (CPU, memory, and so on). Perhaps customers are
    just leaving their VMs on but not actually using them.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 云计算服务的利用一直存在滞后。Cinar Kilcioglu 和 Aadharsh Kannan 在2017年在“第26届国际万维网会议”上报告，数据中心中云资源的使用显示出租户配置和支付的资源（租用VM）与实际资源利用（CPU、内存等）之间存在显著差距。也许客户只是将他们的VM保持开启，但实际上并没有使用它们。
- en: 'Cloud services are divided into categories used for different types of computing:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 云服务根据用于不同类型计算的类别进行划分：
- en: Software as a service (SaaS)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**软件即服务（SaaS）**'
- en: The client can use the provider’s applications running on a cloud infrastructure.
    The applications are accessible from various client devices through either a thin
    client interface, such as a web browser, or a program interface. The client does
    not manage or control the underlying cloud infrastructure, including network,
    servers, operating systems, storage, or even individual application capabilities,
    with the possible exception of limited user-specific application configuration
    settings.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 客户可以使用提供者在云基础设施上运行的应用程序。这些应用程序可以通过薄客户端接口（如Web浏览器）或程序接口从各种客户端设备访问。客户不管理或控制底层云基础设施，包括网络、服务器、操作系统、存储甚至单个应用程序功能，但可能有限制的特定于用户的应用程序配置设置。
- en: Platform as a service (PaaS)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**平台即服务（PaaS）**'
- en: The client can deploy onto the cloud infrastructure client-made or acquired
    applications created using programming languages, libraries, services, and tools
    supported by the provider. The consumer does not manage or control the underlying
    cloud infrastructure, including network, servers, operating systems, or storage,
    but does have control over the deployed applications and possibly configuration
    settings for the application-hosting environment.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 客户可以将使用由提供者支持的编程语言、库、服务和工具创建的客户制作或购买的应用程序部署到云基础设施。消费者不管理或控制底层云基础设施，包括网络、服务器、操作系统或存储，但可以控制已部署的应用程序，可能还可以配置应用程序托管环境的设置。
- en: Infrastructure as a service (IaaS)
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**基础设施即服务（IaaS）**'
- en: The client is able to provision processing, storage, networks, and other fundamental
    computing resources. They can deploy and run arbitrary software, which can *include
    operating systems and applications*. The client does not manage or control the
    underlying cloud infrastructure but has control over operating systems, storage,
    and deployed applications—and possibly limited control of select networking components.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 客户能够配置处理、存储、网络和其他基本计算资源。他们可以部署和运行任意软件，其中*包括操作系统和应用程序*。客户不管理或控制底层云基础设施，但可以控制操作系统、存储和部署的应用程序，并可能对某些网络组件有限的控制。
- en: Microservices
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**微服务**'
- en: The term *microservice* is not a recent one. Peter Rodgers introduced the term
    *micro-web services* in 2005 while championing the idea of *software as micro-web-services*.
    *Microservice_architecture*—an evolution of service-oriented architecture (SOA)—arranges
    an application as a collection of relatively lightweight modular services. Technically,
    microservices is a specialization of an implementation approach for SOA.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*微服务* 这个术语并不是最近才出现的。彼得·罗杰斯在2005年提出了*微网络服务* 这个术语，同时倡导*软件即微网络服务* 这一概念。*微服务架构*
    ——作为面向服务架构（SOA）的一种演变——将应用程序组织为一组相对轻量级的模块化服务。从技术上讲，微服务是SOA实现方法的一种特殊化。'
- en: '*Microservices* are small and loosely coupled components. In contrast to monoliths,
    they can be deployed, scaled, and tested independently, and they have a single
    responsibility, bounded by context, and are autonomous and decentralized. They
    are usually built around business capabilities, are easy to understand, and may
    be developed using different technology stacks.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*微服务* 是小型且松散耦合的组件。与单体应用程序相比，它们可以独立部署、扩展和测试，具有单一职责，由上下文界定，是自治的和分散的。它们通常围绕业务能力构建，易于理解，并可以使用不同的技术栈进行开发。'
- en: How small should a microservice be? It should be *micro* enough to allow small,
    self-contained, and rigidly enforced atoms of functionality that can coexist,
    evolve, or replace the previous ones according to business needs.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一个微服务应该有多小？它应该足够*微小*，以允许小型、自包含和严格执行的功能原子共存、发展或替换前一个版本，以适应业务需求。
- en: Each component or service has little or no knowledge of the definitions of other
    separate components, and all interaction with a service is via its API, which
    encapsulates its implementation details. The messaging between these microservices
    uses simple protocols and usually is not data intensive.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 每个组件或服务几乎不了解其他独立组件的定义，与服务的所有交互都通过其 API 进行，该 API 封装了其实现细节。这些微服务之间的消息传递使用简单的协议，通常不需要大量数据。
- en: Antipatterns
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反模式
- en: The microservice pattern results in significant complexity and is not ideal
    in all situations. The system is made up of many parts that work independently,
    and its very nature makes it harder to predict how it will perform in the real
    world.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务模式导致了显著的复杂性，并非在所有情况下都是理想的。该系统由许多独立工作的部分组成，其本质使其更难以预测在现实世界中的表现如何。
- en: This increased complexity is mainly due to the (potentially) thousands of microservices
    running asynchronously in the distributed computer network. Keep in mind that
    programs that are difficult to understand are also difficult to write, modify,
    test, and measure. All these concerns will increase the time teams need to spend
    on understanding, discussing, tracking, and testing interfaces and message formats.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这种增加的复杂性主要是由于（潜在的）成千上万的微服务在分布式计算机网络中异步运行。请记住，难以理解的程序也难以编写、修改、测试和衡量。所有这些问题都将增加团队理解、讨论、跟踪和测试接口和消息格式所需的时间。
- en: Several books, articles, and papers are available on this particular topic.
    I recommend a visit to [Microservices.io](https://microservices.io), Mark Richards’s
    report [*Microservices AntiPatterns and Pitfalls*](https://oreil.ly/KpzyW) (O’Reilly),
    and “On the Definition of Microservice Bad Smells” by Davide Taibi and Valentina
    Lenarduzz (published in *IEEE Software* in 2018).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个特定主题有几本书籍、文章和论文可供参考。我推荐访问[Microservices.io](https://microservices.io)、马克·理查兹（Mark
    Richards）的报告[*Microservices AntiPatterns and Pitfalls*](https://oreil.ly/KpzyW)（O’Reilly）以及
    2018 年大卫德比（Davide Taibi）和瓦伦蒂娜·莱纳杜茨（Valentina Lenarduzz）在《IEEE 软件》上发表的“关于微服务坏味道定义”的论文。
- en: 'Some of the most common antipatterns include the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一些最常见的反模式包括以下内容：
- en: API versioning (*static contract pitfall*)
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: API 版本控制（*静态协议陷阱*）
- en: APIs need to be semantically versioned to allow services to know whether they
    are communicating with the right version of the service or whether they need to
    adapt their communication to a new contract.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: API 需要进行语义版本控制，以允许服务知道它们是否正在与正确版本的服务通信，或者是否需要调整其通信以适应新的协议。
- en: Inappropriate service privacy interdependency
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 不当的服务隐私依赖性
- en: The microservice requires private data from other services instead of dealing
    with its own data, a problem that usually is related to a modeling-the-data issue.
    One solution to consider is merging the microservices.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务需要其他服务的私密数据而不是处理自己的数据，这通常与数据建模问题有关。可以考虑的解决方案之一是合并这些微服务。
- en: Multipurpose megaservice
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 多用途巨型服务
- en: Several business functions are implemented in the same service.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 几个业务功能被实现在同一个服务中。
- en: Logging
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 记录
- en: Errors and microservice information are hidden inside each microservice container.
    The adoption of a distributed logging system should be a priority as issues are
    found in all stages of the software lifecycle.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 错误和微服务信息被隐藏在每个微服务容器内。在软件生命周期的各个阶段发现问题时，应优先采用分布式日志记录系统。
- en: Complex interservice or circular dependencies
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂的服务间或循环依赖
- en: A *circular service relationship* is defined as a relationship between two or
    more services that are interdependent. Circular dependencies can harm the ability
    of services to scale or deploy independently, as well as violate the acyclic dependencies
    principle (ADP).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*循环服务关系* 被定义为两个或多个相互依赖的服务之间的关系。循环依赖可能会损害服务扩展或独立部署的能力，并违反无环依赖原则（ADP）。'
- en: Missing API gateway
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 缺失的 API 网关
- en: When microservices communicate directly with each other, or when the service
    consumers communicate directly with each microservice, complexity increases and
    maintenance decreases in the system. The best practice in this case is to use
    an API gateway.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当微服务直接相互通信，或者当服务消费者直接与每个微服务通信时，系统的复杂性增加，维护减少。在这种情况下的最佳实践是使用 API 网关。
- en: An *API gateway* receives all API calls from clients and then directs them to
    the appropriate microservice by request routing, composition, and protocol translation.
    The gateway usually handles the request by calling multiple microservices and
    aggregating the results to determine the best route. It is also able to translate
    between web protocols and web-friendly protocols for internal use.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *API 网关* 接收来自客户端的所有 API 调用，然后通过请求路由、组合和协议转换将它们引导到适当的微服务。网关通常通过调用多个微服务并聚合结果来处理请求，以确定最佳路由。它还能够在内部使用之间进行
    Web 协议和 Web 友好协议之间的转换。
- en: An application may use an API gateway to provide a single endpoint for mobile
    customers to query all product data with a single request. The API gateway consolidates
    various services, such as product information and reviews, and combines and exposes
    the results.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以使用 API 网关为移动客户端提供一个单一的端点，通过单个请求查询所有产品数据。API 网关整合了各种服务，如产品信息和评论，并将结果合并和公开。
- en: The API gateway is the gatekeeper for applications to access data, business
    logic, or functions (RESTful APIs or WebSocket APIs) that allow real-time two-way
    communication applications. The API gateway typically handles all the tasks involved
    in accepting and processing up to hundreds of thousands of concurrent API calls,
    including traffic management, cross-origin resource sharing (CORS) support, authorization
    and access control, choking, management, and API version control.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: API 网关是应用程序访问数据、业务逻辑或功能（RESTful API 或 WebSocket API）的门卫，允许实时双向通信应用程序。API 网关通常处理接受和处理多达数十万个并发
    API 调用的所有任务，包括流量管理、跨源资源共享（CORS）支持、授权和访问控制、阻塞、管理和 API 版本控制。
- en: Sharing too much
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 过度共享
- en: A thin line lies between sharing enough functionality to not repeat yourself
    and creating a tangled mess of dependencies that prevents service changes from
    being separated. If an overshared service needs to be changed, evaluating proposed
    changes in the interfaces will eventually lead to an organizational task involving
    more development teams.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在分享足够的功能以避免重复自己与创建依赖混乱的纠结之间，有一条薄线阻止了服务变更分离。如果需要更改过度共享的服务，评估接口的建议变更最终会导致一个涉及更多开发团队的组织任务。
- en: At some point, the choice of redundancy or library extraction into a new shared
    service that related microservices can install and develop independently of each
    other needs to be analyzed.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些时候，需要分析是否将冗余或库提取到新的共享服务中，这些相关的微服务可以独立安装和开发。
- en: DevOps and Microservices
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DevOps 和 微服务
- en: Microservices fit perfectly into the DevOps ideal of utilizing small teams to
    create functional changes to the enterprise’s services one step at a time—the
    idea of breaking large problems into smaller pieces and tackling them systematically.
    To reduce the friction between development, testing, and deployment of smaller
    independent services, a series of continuous delivery pipelines to maintain a
    steady flow of these stages has to be present.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务完美地符合 DevOps 理念，利用小团队逐步对企业服务进行功能更改——将大问题分解成小片段并系统化处理的理念。为了减少开发、测试和部署之间的摩擦，必须存在一系列持续交付管道，以保持这些阶段的稳定流动。
- en: DevOps is a key factor in the success of this architectural style, providing
    the necessary organizational changes to minimize coordination between teams responsible
    for each component and to remove barriers to effective, reciprocal interaction
    between development and operations teams.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps 是这种架构风格成功的关键因素，提供必要的组织变更，以最小化负责每个组件的团队之间的协调，并消除开发和运营团队之间有效互动的障碍。
- en: Caution
  id: totrans-63
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: I strongly dissuade any team from adopting the microservices pattern without
    a robust CI/CD infrastructure in place or without a widespread understanding of
    the basic concepts of pipelines.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈反对任何团队在没有健全的 CI/CD 基础设施或对流水线基本概念没有广泛理解的情况下采用微服务模式。
- en: Microservice Frameworks
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务框架
- en: The JVM ecosystem is vast and provides plenty of alternatives for a particular
    use case. Dozens of microservice frameworks and libraries are available, to the
    point that it can be tricky to pick a winner among candidates.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: JVM 生态系统庞大且提供了许多特定用例的替代方案。提供了几十种微服务框架和库，以至于在候选项中选择优胜者可能有些棘手。
- en: 'That said, certain candidate frameworks have gained popularity for several
    reasons: developer experience, time to market, extensibility, resource (CPU, memory)
    consumption, startup speed, failure recovery, documentation, third-party integrations,
    and more. These frameworks—Spring Boot, Micronaut, Quarkus, and Helidon—are covered
    in the following sections. Take into account that some of the instructions may
    require additional tweaks based on newer versions, as some of these technologies
    evolve quite rapidly. I strongly recommend reviewing the documentation of each
    framework.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，由于几个原因，某些候选框架已经获得了流行：开发者体验、上市时间、可扩展性、资源（CPU、内存）消耗、启动速度、故障恢复、文档、第三方集成等等。这些框架——Spring
    Boot、Micronaut、Quarkus和Helidon——在接下来的章节中进行了介绍。请注意，一些说明可能需要根据更新版本进行额外调整，因为其中一些技术正在快速发展。我强烈建议查阅每个框架的文档。
- en: Additionally, these examples require Java 11 as a minimum, and trying out Native
    Image also requires an installation of GraalVM. There are many ways to get these
    versions installed in your environment. I recommend using [SDKMAN!](https://sdkman.io)
    to install and manage them. For brevity, I concentrate on production code alone—a
    single framework could fill a whole book! It goes without saying that you should
    take care of tests as well. The goal for each example is to build a trivial “Hello
    World” REST service that can take an optional name parameter and reply with a
    greeting.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这些示例需要至少Java 11，并且尝试使用本地镜像还需要安装GraalVM。有许多方法可以在您的环境中安装这些版本。我建议使用[SDKMAN!](https://sdkman.io)来安装和管理它们。为简洁起见，我专注于生产代码——一个单一框架可以填写整本书！毫无疑问，您还应该关注测试。每个示例的目标是构建一个简单的“Hello
    World” REST服务，该服务可以接受一个可选的名称参数并回复问候语。
- en: 'If you have not worked with GraalVM before, it’s an umbrella project for a
    handful of technologies that enable the following features:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您以前没有使用过GraalVM，它是一个涵盖几种技术的综合项目，使以下功能成为可能：
- en: A just-in-time (JIT) compiler written in Java, which compiles code on the fly,
    transforming interpreted code into executable code. The Java platform has had
    a handful of JITs, most written using a combination of C and C++. Graal happens
    to be the most modern one, written in Java.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用Java编写的即时编译器（JIT），可以在运行时编译代码，将解释代码转换为可执行代码。Java平台已经有过几个JIT，大多数是用C和C++组合编写的。Graal碰巧是最现代的一个，用Java编写。
- en: A virtual machine named *Substrate VM* that’s capable of running hosted languages
    such as Python, JavaScript, and R on top of the JVM in such a way that the hosted
    language benefits from tighter integration with JVM capabilities and features.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Substrate VM* 是一个虚拟机，能够在JVM之上运行托管语言，如Python、JavaScript和R，使得托管语言能够更紧密地集成JVM的能力和特性。'
- en: Native Image, a utility that relies on ahead-of-time (AOT) compilation, which
    transforms bytecode into machine-executable code. The resulting transformation
    produces a platform-specific binary executable.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[本地镜像](https://sdkman.io)是一种依赖预编译（AOT）的实用工具，将字节码转换为机器可执行代码。所得的转换产生一个特定于平台的二进制可执行文件。'
- en: All four candidate frameworks covered here provide support for GraalVM in one
    way or another, chiefly relying on GraalVM Native Image to produce platform-specific
    binaries with the goal of reducing deployment size and memory consumption. Be
    aware that there’s a trade-off between using the Java mode and the GraalVM Native
    Image mode. The latter can produce binaries with a smaller memory footprint and
    faster startup time but requires longer compilation time; long-running Java code
    will eventually become more optimized (that’s one of the key features of the JVM),
    whereas native binaries cannot be optimized while running. Development experience
    also varies, as you may need to use additional tools for debugging, monitoring,
    measuring, and so forth.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这里介绍的四个候选框架都以某种方式支持 GraalVM，主要依赖于 GraalVM Native Image 来生成特定于平台的二进制文件，旨在减少部署大小和内存消耗。请注意，在使用
    Java 模式和 GraalVM Native Image 模式之间存在权衡。后者可以生成具有较小内存占用和更快启动时间的二进制文件，但需要较长的编译时间；长时间运行的
    Java 代码最终会变得更加优化（这是 JVM 的关键特性之一），而原生二进制文件在运行时无法进行优化。开发体验也各不相同，您可能需要使用额外的工具进行调试、监控、测量等。
- en: Spring Boot
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Spring Boot
- en: '*Spring Boot* is perhaps the most well-known among the four candidates, as
    it builds on top of the legacy laid out by the Spring Framework. If developer
    surveys are to be taken at face value, more than 60% of Java developers have some
    sort of experience interacting with Spring-related projects, making Spring Boot
    the most popular choice.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*Spring Boot* 可能是这四个候选框架中最为人熟知的，因为它建立在 Spring Framework 所奠定的遗产之上。如果开发者调查结果可信，超过
    60% 的 Java 开发者在与 Spring 相关的项目中有一定的经验，使 Spring Boot 成为最受欢迎的选择。'
- en: The Spring way lets you assemble applications (or microservices, in our case)
    by composing existing components, customizing their configuration, and promising
    low-cost code ownership, as your custom logic is supposedly smaller in size than
    what the framework brings to the table, and for most organizations that’s true.
    The trick is to find an existing component that can be tweaked and configured
    before writing your own. The Spring Boot team makes a point of adding as many
    useful integrations as needed, from database drivers to monitoring services, logging,
    journaling, batch processing, report generation, and more.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 的方式允许您通过组合现有组件、定制其配置并承诺低成本的代码拥有权来组装应用程序（或在我们的情况下是微服务），因为您的自定义逻辑理论上应比框架提供的内容更小，对于大多数组织来说这是正确的。关键是找到一个可以在编写自己的组件之前进行调整和配置的现有组件。Spring
    Boot 团队着重于添加所需的多个有用集成，从数据库驱动程序到监控服务、日志记录、日志处理、批处理、报告生成等等。
- en: The typical way to bootstrap a Spring Boot project is by browsing to the [Spring
    Initializr](https://start.spring.io), selecting the features you require in your
    application, and clicking the Generate button. This action creates a ZIP file
    that you can download to your local environment to get started. In [Figure 4-1](#spring_initializr),
    I’ve selected the Web and Spring Native features. The first feature adds components
    that let you expose data via REST APIs; the second enhances the build with an
    extra packaging mechanism that can create Native Images with Graal.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 启动 Spring Boot 项目的典型方式是浏览至 [Spring Initializr](https://start.spring.io)，选择您在应用程序中需要的功能，然后单击生成按钮。此操作将创建一个
    ZIP 文件，您可以将其下载到本地环境以开始使用。在 [图 4-1](#spring_initializr) 中，我选择了 Web 和 Spring Native
    功能。第一个功能添加了组件，使您可以通过 REST API 公开数据；第二个功能增强了构建，使用 Graal 可以创建额外的打包机制，生成原生镜像。
- en: Unpacking the ZIP file and running the `./mvnw verify` command at the root directory
    of the project ensures a sound starting point. You’ll notice the command will
    download a set of dependencies if you’ve not built a Spring Boot application before
    on your target environment. This is normal Apache Maven behavior. These dependencies
    won’t be downloaded again the next time you invoke a Maven command—unless dependency
    versions are updated in the *pom.xml* file.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目的根目录解压 ZIP 文件并运行`./mvnw verify`命令，确保一个健康的起点。如果您之前没有在目标环境上构建过 Spring Boot
    应用程序，您会注意到该命令会下载一组依赖。这是正常的 Apache Maven 行为。除非在 *pom.xml* 文件中更新了依赖版本，否则下次调用 Maven
    命令时不会再次下载这些依赖。
- en: '![dtjd 0401](Images/dtjd_0401.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![dtjd 0401](Images/dtjd_0401.png)'
- en: Figure 4-1\. Spring Initializr
  id: totrans-80
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-1\. Spring Initializr
- en: 'The project structure should look like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 项目结构应该是这样的：
- en: '[PRE0]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Our current task requires two additional sources that were not created by the
    Spring Initializr website: *Greeting.java* and *GreetingController.java*. These
    two files can be created using your text editor or IDE of choice. The first, *Greeting.java*,
    defines a data object that will be used to render content as JavaScript Object
    Notation (JSON), a typical format used to expose data via REST. Additional formats
    are also supported, but JSON support comes out of the box without any additional
    dependencies required. This file should look like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前的任务需要两个未由Spring Initializr网站创建的附加源：*Greeting.java* 和 *GreetingController.java*。这两个文件可以使用您选择的文本编辑器或IDE创建。首先，*Greeting.java*
    定义了一个数据对象，将用于将内容呈现为JavaScript对象表示法（JSON），这是一种通过REST公开数据的典型格式。还支持其他格式，但是JSON支持无需任何额外的依赖项即可直接使用。此文件应如下所示：
- en: '[PRE1]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'There’s nothing special about this data holder except that it’s immutable;
    depending on your use case, you might want to switch to a mutable implementation,
    but for now this will suffice. Next is the REST endpoint itself, defined as a
    `GET` call on a */greeting* path. Spring Boot prefers the *controller* stereotype
    for this kind of component, no doubt harkening back to the days when Spring MVC
    (yes, that’s model-view-controller) was the preferred option to create web applications.
    Feel free to use a different filename, but the component annotation must remain
    untouched:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 除了它是不可变的数据持有者之外，这个数据持有者没有什么特别之处；根据您的用例，您可能希望切换到可变的实现，但目前这样就足够了。接下来是REST端点本身，定义为
    */greeting* 路径上的一个`GET`调用。Spring Boot 更偏爱 *controller* 的原型来创建这种组件，毫无疑问是在回顾Spring
    MVC（是的，那就是模型-视图-控制器）作为首选选项来创建Web应用程序的日子里。可以随意使用不同的文件名，但是组件的注解必须保持不变：
- en: '[PRE2]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The controller may take a `name` parameter as input and will use the value `World`
    when this parameter is not supplied. Notice that the return type of the mapped
    method is a plain Java type; it’s the data type we just defined in the previous
    step. Spring Boot will automatically marshal data from and to JSON based on the
    annotations applied to the controller and its methods, as well as sensible defaults
    put in place. If we leave the code as is, the return value of the `greeting()`
    method will be automatically transformed into a JSON payload. This is the power
    of Spring Boot’s developer experience, relying on defaults and predefined configuration
    that may be tweaked as needed.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器可以接受 `name` 参数作为输入，并在未提供此参数时使用值 `World`。请注意，映射方法的返回类型是一个普通的Java类型；这是我们在前一步中定义的数据类型。Spring
    Boot将根据应用于控制器及其方法的注解和设置的合理默认值，自动将数据从JSON格式转换为JSON格式。如果我们保持代码不变，`greeting()` 方法的返回值将自动转换为JSON负载。这是Spring
    Boot开发经验的威力，依赖于可以根据需要进行微调的默认值和预定义的配置。
- en: 'You can run the application by either invoking the `/.mvnw spring-boot:run`
    command, which runs the application as part of the build process, or by generating
    the application JAR and running it manually—that is, `./mvnw package` followed
    by `java -jar target/demo-0.0.1.SNAPSHOT.jar`. Either way, an embedded web server
    will be started listening on port 8080; the */greeting* path will be mapped to
    an instance of *GreetingController*. All that’s left is to issue a couple of queries,
    such as the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过调用 `/.mvnw spring-boot:run` 命令来运行应用程序，该命令将在构建过程中运行应用程序，也可以通过生成应用程序 JAR
    并手动运行它来运行应用程序，即 `./mvnw package` 后跟 `java -jar target/demo-0.0.1.SNAPSHOT.jar`。无论哪种方式，都会启动一个内嵌的Web服务器，监听8080端口；
    */greeting* 路径将映射到 *GreetingController* 的一个实例。现在只剩下发出一些查询，比如以下内容：
- en: '[PRE3]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Take note of the output generated by the application while running. On my local
    environment, it shows (on average) that the JVM takes 1.6 seconds to start up,
    while the application takes 600 milliseconds to initialize. The size of the generated
    JAR is roughly 17 MB. You may also want to take notes on the CPU and memory consumption
    of this trivial application. For some time now, it’s been suggested that the use
    of GraalVM Native Image can reduce startup time and binary size. Let’s see how
    we can make that happen with Spring Boot.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行应用程序时，请注意应用程序生成的输出。在我的本地环境中，它显示（平均）JVM启动需要1.6秒，而应用程序初始化需要600毫秒。生成的JAR文件大小大约为17
    MB。您可能还想记录这个微不足道的应用程序的CPU和内存消耗。有人建议使用GraalVM Native Image可以减少启动时间和二进制文件大小。让我们看看如何在Spring
    Boot中实现这一点。
- en: 'Remember how we selected the Spring Native feature when the project was created?
    Unfortunately, by version 2.5.0 the generated project does not include all required
    instructions in the *pom.xml* file. We must make a few tweaks. To begin with,
    the JAR created by `spring-boot-maven-plugin` requires a classifier; otherwise,
    the resulting Native Image may not be properly created. That’s because the application
    JAR already contains all dependencies inside a Spring Boot—specific path that’s
    not handled by `native-image-maven-plugin`, which we also have to configure. The
    updated *pom.xml* file should look like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 记得当项目创建时我们选择了Spring Native特性吗？不幸的是，到了2.5.0版本，生成的项目在*pom.xml*文件中并未包含所有必需的指令。我们需要进行一些调整。首先，由`spring-boot-maven-plugin`创建的JAR文件需要一个分类器；否则，生成的本地镜像可能无法正确创建。这是因为应用程序JAR文件已经包含了所有依赖项，位于Spring
    Boot特定路径下，这个路径并不被`native-image-maven-plugin`处理，我们也需要进行配置。更新后的*pom.xml*文件应该如下所示：
- en: '[PRE4]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'One more step before we can give it a try: make sure to have a version of GraalVM
    installed as your current JDK. The selected version should closely match the version
    of `native-image-maven-plugin` found in the *pom.xml* file. The `native-image`
    executable must also be installed in your system; you can do that by invoking
    `gu install native-image`. The `gu` command is provided by the GraalVM installation.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们尝试之前还有一步：确保安装了与*pom.xml*文件中找到的`native-image-maven-plugin`版本接近的GraalVM版本作为您当前的JDK。还必须在系统中安装`native-image`可执行文件；您可以通过调用`gu
    install native-image`来完成。`gu`命令由GraalVM安装提供。
- en: 'With all settings in place, we can generate a native executable by invoking
    `./mvnw -Pnative-image package`. You’ll notice a flurry of text going through
    the screen as new dependencies may be downloaded, and perhaps a few warnings related
    to missing classes—that’s normal. The build also takes longer than usual, and
    here lies the trade-off of this packaging solution: we are increasing development
    time to speed up execution time at production. Once the command finishes, you’ll
    notice a new file *com.example.demo.demoapplication* inside the *target* directory.
    This is the native executable. Go ahead and run it.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有设置就绪后，我们可以通过调用`./mvnw -Pnative-image package`生成一个本地可执行文件。你会注意到屏幕上会有大量的文本输出，可能会下载新的依赖项，并且可能会有一些关于缺少类的警告——这是正常的。构建时间也比平时长，这就是这种打包解决方案的权衡所在：我们增加了开发时间以加快生产环境中的执行时间。一旦命令完成，您会注意到在*target*目录中出现了一个名为*com.example.demo.demoapplication*的新文件。这就是本地可执行文件。继续运行它吧。
- en: Did you notice how fast the startup was? On my environment, I get on average
    a startup time of 0.06 seconds, while the application takes 30 milliseconds to
    initialize itself. You may recall these numbers were 1.6 seconds and 600 milliseconds
    when running in Java mode. That’s a serious speed boost! Now have a look at the
    size of the executable; in my case, it’s around 78 MB. Oh well, looks like some
    things have grown for the worse—or have they? This executable is a single binary
    that provides everything needed to run the application, whereas the JAR we used
    earlier requires a Java runtime to run. The size of a Java runtime is typically
    in the 200 MB range and is composed of multiple files and directories. Of course,
    smaller Java runtimes may be created with [jlink](https://oreil.ly/agfRB), in
    which case that adds another step during the build process. There’s no free lunch.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到启动速度有多快了吗？在我的环境中，平均启动时间为0.06秒，而应用程序初始化需要30毫秒。你可能还记得在Java模式下运行时，这些数字分别为1.6秒和600毫秒。这真是一个严重的速度提升！现在看看可执行文件的大小；在我的情况下，大约是78
    MB。哦，看起来有些事情变得更糟了，或者说没有？这个可执行文件是一个单一的二进制文件，包含了运行应用程序所需的一切，而我们之前使用的JAR文件则需要Java运行时才能运行。Java运行时的大小通常在200
    MB左右，并由多个文件和目录组成。当然，可以使用[jlink](https://oreil.ly/agfRB)创建较小的Java运行时，这样在构建过程中会增加另一个步骤。没有免费的午餐。
- en: Let’s stop with Spring Boot for now, keeping in mind that there’s a whole lot
    more to it than what has been shown here. On to the next framework.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们暂停使用Spring Boot，记住，它的功能远不止这里展示的。接下来我们看看下一个框架。
- en: Micronaut
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Micronaut
- en: '*Micronaut* began life in 2017 as a reimagination of the Grails framework but
    with a modern look. Grails is one of the few successful “clones” of the Ruby on
    Rails (RoR) framework, leveraging the Groovy programming language. Grails made
    quite the splash for a few years, until the rise of Spring Boot took it out of
    the spotlight, prompting the Grails team to find alternatives, which resulted
    in Micronaut. On the surface, Micronaut provides a similar user experience to
    Spring Boot, as it also allows developers to compose applications based on existing
    components and sensible defaults.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*Micronaut* 于 2017 年诞生，是对 Grails 框架的一次现代化重新构想。Grails 是少数成功的 Ruby on Rails（RoR）框架“克隆”之一，利用
    Groovy 编程语言。Grails 在几年间引起了轰动，直到 Spring Boot 的兴起使其失去了关注，促使 Grails 团队寻找替代方案，最终推出了
    Micronaut。从表面上看，Micronaut 提供了与 Spring Boot 类似的用户体验，因为它也允许开发人员基于现有组件和合理的默认设置来构建应用程序。'
- en: One of Micronaut’s key differentiators is the use of compile-time dependency
    injection for assembling the application, as opposed to runtime dependency injection,
    which is the preferred way of assembling applications with Spring Boot so far.
    This seemingly trivial change lets Micronaut exchange a bit of development time
    for a speed boost at runtime as the application spends less time bootstrapping
    itself; this can also lead to less memory consumption and less reliance on Java
    reflection, which historically has been slower than direct method invocations.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Micronaut 的一个关键区别在于使用编译时依赖注入来组装应用程序，而不是运行时依赖注入，这与目前使用 Spring Boot 组装应用程序的首选方式不同。这一看似微不足道的改变让
    Micronaut 在运行时提升了速度，因为应用程序在启动时花费的时间更少；这也可以减少内存消耗，并且减少对 Java 反射的依赖，后者在直接方法调用之前的历史上速度较慢。
- en: There are a handful of ways to bootstrap a Micronaut project, but the preferred
    one is to browse to [Micronaut Launch](https://oreil.ly/QAdrG) and select the
    settings and features you’d like to see added to the project. The default application
    type defines the minimum settings to build a REST-based application such as the
    one we’ll go through in a few minutes. Once satisfied with your selection, click
    the Generate Project button, as shown in [Figure 4-2](#micronaut_launch), which
    results in a ZIP file that can be downloaded to your local development environment.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种启动 Micronaut 项目的方式，但首选的方法是浏览到 [Micronaut Launch](https://oreil.ly/QAdrG)，选择您想要添加到项目中的设置和功能。默认的应用程序类型定义了构建基于
    REST 的应用程序所需的最小设置，例如我们将在几分钟内讲解的内容。一旦满意您的选择，请点击“生成项目”按钮，如 [图 4-2](#micronaut_launch)
    所示，这将生成一个 ZIP 文件，可以下载到您的本地开发环境中。
- en: '![dtjd 0402](Images/dtjd_0402.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![dtjd 0402](Images/dtjd_0402.png)'
- en: Figure 4-2\. Micronaut Launch
  id: totrans-102
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-2\. Micronaut 启动
- en: 'Similarly as we did for Spring boot, unpacking the ZIP file and running the
    `./mvnw verify` command at the root directory of the project ensures a sound starting
    point. This command invocation will download plug-ins and dependencies as needed;
    the build should succeed after a few seconds if everything goes right. The project
    structure should look like the following one after adding a pair of additional
    source files:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们为 Spring Boot 所做的类似，解压 ZIP 文件并在项目根目录运行`./mvnw verify`命令会确保一个良好的起点。如果一切顺利，此命令会根据需要下载插件和依赖项；如果构建成功，几秒钟后应该看到这样的输出。添加一对额外的源文件后，项目结构应如下所示：
- en: '[PRE5]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The *Application.java* source file defines the entry point, which we’ll leave
    untouched for now as there’s no need to make any updates. Similarly, we’ll leave
    the *application.yml* resource file unchanged as well; this resource supplies
    configuration properties that don’t require changes at this point.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*Application.java* 源文件定义了入口点，暂时不需要更新。同样，我们也不需要更改 *application.yml* 资源文件；该资源提供的配置属性目前不需要更改。'
- en: 'We need two additional source files: the data object defined by *Greeting.java*,
    whose responsibility is to contain a message sent back to the consumer, and the
    actual REST endpoint defined by *GreetingController.java*. The controller stereotype
    goes all the way back to the conventions laid out by Grails, also followed by
    pretty much every RoR clone. You can certainly change the filename to anything
    that suits your domain, though you must leave the `@Controller` annotation in
    place. The source for the data object should look like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要另外两个源文件：由*Greeting.java*定义的数据对象，其责任是包含发送给消费者的消息，以及由*GreetingController.java*定义的实际REST端点。控制器原型追溯到Grails规范所制定的约定，并几乎被所有RoR克隆框架所遵循。您可以根据您的领域需求更改文件名，但必须保留`@Controller`注解。数据对象的源代码应如下所示：
- en: '[PRE6]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once more we rely on an immutable design for this class. Note the use of the
    ​`@Intro⁠spected` annotation, which signals Micronaut to inspect the type at compile
    time and include it as part of the dependency-injection procedure. Usually, the
    annotation can be left out, as Micronaut will figure out that the class is required.
    But its use is paramount when it comes to generating the native executable with
    GraalVM Native Image; otherwise, the executable won’t be complete. The second
    file should look like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个类，我们再次依赖于不可变设计。请注意使用的`@Introspected`注解，这会告诉Micronaut在编译时检查类型并将其包含为依赖注入过程的一部分。通常情况下，可以省略此注解，因为Micronaut会自动识别出需要的类。但是，在使用GraalVM
    Native Image生成本地可执行文件时，它的使用是至关重要的；否则，可执行文件将无法完整生成。第二个文件应该是这样的：
- en: '[PRE7]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can appreciate that the controller defines a single endpoint mapped to `/greeting`,
    takes an optional parameter named `name`, and returns an instance of the data
    object. By default, Micronaut will marshal the return value as JSON, so no extra
    configuration is required to make it happen. Running the application can be done
    in a couple of ways. You can either invoke `./mvnw mn:run`, which runs the application
    as part of the build process, or invoke `./mvnw package`, which creates a *demo-0.1.jar*
    in the *target* directory that can be launched in the conventional way—that is,
    with `java -jar target/demo-0.1.jar`. Invoking a couple of queries to the REST
    endpoint may result in output similar to this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到控制器定义了一个映射到`/greeting`的单个端点，接受一个名为`name`的可选参数，并返回数据对象的一个实例。默认情况下，Micronaut会将返回值解析为JSON，因此无需额外配置。应用程序的运行可以通过两种方式完成。您可以调用`./mvnw
    mn:run`，将其作为构建过程的一部分运行应用程序，或者调用`./mvnw package`，它会在*target*目录中创建一个名为*demo-0.1.jar*的文件，可以像传统方式一样启动它，即`java
    -jar target/demo-0.1.jar`。调用REST端点进行一些查询可能会产生类似于以下输出：
- en: '[PRE8]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Either command launches the application quite quickly. On my local environment,
    the application is ready to process requests by 500 milliseconds on average, or
    three times the speed of Spring Boot for equivalent behavior. The size of the
    JAR file is also a bit smaller, at 14 MB in total. As impressive as these numbers
    may be, we can get a speed boost if the application were to be transformed using
    GraalVM Native Image into a native executable. Fortunately for us, the Micronaut
    way is friendlier with this kind of setup, resulting in everything we require
    already configured in the generated project. That’s it. No need to update the
    build file with additional settings—it’s all there.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 任何一个命令都能快速启动应用程序。在我的本地环境中，应用程序平均在500毫秒内准备好处理请求，这比Spring Boot的相同行为速度快三倍。JAR文件的大小也小了一点，总共为14
    MB。尽管这些数字可能令人印象深刻，但如果使用GraalVM Native Image将应用程序转换为本地可执行文件，我们可以获得速度提升。幸运的是，Micronaut的方式对这种设置更友好，生成的项目中已经配置了我们需要的一切。就这样。无需更新构建文件的其他设置，一切都已准备就绪。
- en: You do require an installation of GraalVM and its `native-image` executable,
    though, as we did before. Creating a native executable is as simple as invoking
    `./mvnw -Dpackaging=native-image package`, and after a few minutes we should get
    an executable named `demo` (as a matter of fact, it’s the project’s `artifactId`
    if you were wondering) inside the *target* directory. Launching the application
    with the native executable results in a 20–millisecond startup time on average,
    which is a one-third gain in speed compared to Spring Boot. The executable size
    is 60 MB, which correlates to the reduced size of the JAR file.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 您确实需要安装GraalVM及其`native-image`可执行文件，就像我们以前做的那样。创建本地可执行文件只需调用`./mvnw -Dpackaging=native-image
    package`，几分钟后，我们应该能得到一个名为`demo`的可执行文件（事实上，这是项目的`artifactId`，如果您想知道的话），位于*target*目录下。使用本地可执行文件启动应用程序平均启动时间为20毫秒，比Spring
    Boot快三分之一。可执行文件大小为60 MB，与JAR文件的减小大小相对应。
- en: 'Let’s stop exploring Micronaut and move to the next framework: Quarkus.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们停止探索Micronaut，并转向下一个框架：Quarkus。
- en: Quarkus
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Quarkus
- en: Although *Quarkus* was announced in early 2019, work on it began much earlier.
    Quarkus has a lot of similarities with the two candidates we’ve seen so far. It
    offers great development experience based on components, convention over configuration,
    and productivity tools. Even more, Quarkus decided to also use compile-time dependency
    injection like Micronaut, allowing it to reap the same benefits, such as smaller
    binaries, faster startup, and less runtime magic. At the same time, Quarkus adds
    its own flavor and distinctiveness, and perhaps most important for some developers,
    Quarkus relies more on standards than the other two candidates. Quarkus implements
    the MicroProfile specifications, which are standards that come from JakartaEE
    (previously known as JavaEE), and additional standards developed under the MicroProfile
    project umbrella.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管*Quarkus*在2019年初宣布，但其工作开始得早得多。Quarkus与我们迄今看到的两个候选者有很多相似之处。它提供基于组件、约定大于配置和生产力工具的优秀开发体验。更重要的是，Quarkus决定也采用像Micronaut一样的编译时依赖注入，使其能够获得同样的好处，如更小的二进制文件、更快的启动时间和更少的运行时魔法。同时，Quarkus还添加了自己的风格和独特性，对某些开发人员来说可能最重要的是，Quarkus更多地依赖于标准而不是其他两个候选者。Quarkus实现了MicroProfile规范，这些规范来自于JakartaEE（以前称为JavaEE），并在MicroProfile项目的保护伞下开发了其他标准。
- en: 'You can get started with Quarkus by browsing to the [Quarkus Configure Your
    Application page](https://code.quarkus.io) to configure values and download a
    ZIP file. This page is loaded with plenty of goodies, including many extensions
    to choose from to configure specific integrations such as databases, REST capabilities,
    monitoring, and more. The RESTEasy Jackson extension must be selected, allowing
    Quarkus to seamlessly marshal values to and from JSON. Clicking the “Generate
    your application” button should prompt you to save a ZIP file into your local
    system, the contents of which should look similar to this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以访问[Quarkus配置您的应用程序页面](https://code.quarkus.io)开始使用Quarkus，配置值并下载ZIP文件。此页面包含许多好东西，包括许多扩展选项，可用于配置特定的集成，如数据库、REST能力、监控等。必须选择RESTEasy
    Jackson扩展，以便Quarkus能够无缝地将值编组为JSON并从JSON解组。单击“生成您的应用程序”按钮应提示您将ZIP文件保存到本地系统，其内容应与以下内容类似：
- en: '[PRE9]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can appreciate that Quarkus adds Docker configuration files out of the box,
    as it was designed to tackle microservice architectures in the cloud via containers
    and Kubernetes. But as time has passed, its range has grown wider by supporting
    additional application types and architectures. The *GreetingResource.java* file
    is also created by default, and it’s a typical Jakarta RESTful Web Services (JAX-RS)
    resource. We’ll have to make some adjustments to that resource to enable it to
    handle the *Greeting.java* data object. Here’s the source for that:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，Quarkus默认添加Docker配置文件，因为它旨在通过容器和Kubernetes解决云中的微服务架构问题。但随着时间的推移，它的范围已经扩展，通过支持额外的应用程序类型和架构。*GreetingResource.java*文件也是默认创建的，它是一个典型的Jakarta
    RESTful Web Services（JAX-RS）资源。我们需要对该资源进行一些调整，以使其能够处理*Greeting.java*数据对象。以下是该资源的源代码：
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The code is pretty much identical to what we’ve seen before in this chapter.
    There’s nothing new or surprising about this immutable data object. Now, in the
    case of the JAX-RS resource, things will look similar yet different, as the behavior
    we seek is the same as before, though the way we instruct the framework to perform
    its magic is via JAX-RS annotations. Thus the code looks like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 代码与本章前面所见的基本相同。关于这个不可变数据对象没有什么新鲜或意外的。现在，在JAX-RS资源的情况下，事情看起来相似但又有所不同，因为我们寻求的行为与以前相同，只是我们指示框架执行其魔术的方式是通过JAX-RS注解。因此，代码如下：
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If you’re familiar with JAX-RS, this code should be no surprise to you. But
    if you’re not familiar with the JAX-RS annotations, what we do here is mark the
    resource with the REST path we’d like to react to; we also indicate that the `greeting()`
    method will handle a `GET` call, and that its `name` parameter has a default value.
    Nothing more needs to be done to instruct Quarkus to marshal the return value
    into JSON, as that will happen by default.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您熟悉JAX-RS，这段代码对您来说应该不会感到意外。但是如果您不熟悉JAX-RS注解，我们在这里所做的是用我们想要响应的REST路径标记资源；我们还指示`greeting()`方法将处理`GET`调用，并且其`name`参数具有默认值。要指示Quarkus将返回值转换为JSON，无需做任何其他操作，因为这将默认发生。
- en: Running the application can be done in a couple of ways as well, using the developer
    mode as part of the build. This is one of the features that has a unique Quarkus
    flavor, as it lets you run the application and pick up any changes you made automatically
    without having to manually restart the application. You can activate this mode
    by invoking `/.mvnw compile quarkus:dev`. If you make any changes to the source
    files, you’ll notice that the build will automatically recompile and load the
    application.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序可以通过几种方式完成，其中一种是使用开发者模式作为构建的一部分。这是具有独特Quarkus风味的功能之一，它允许您在不手动重启应用程序的情况下自动运行应用程序并获取您所做的任何更改。您可以通过调用`/.mvnw
    compile quarkus:dev`来激活此模式。如果您对源文件进行任何更改，您会注意到构建将自动重新编译和加载应用程序。
- en: You may also run the application using the `java` interpreter as we’ve seen
    before, which results in a command such as `java -jar target/quarkus-app/quarkus-run.jar`.
    Note that we’re using a different JAR, although the *demo-1.0.0-SNAPSHOT.jar*
    does exist in the *target* directory; the reason to do it this way is that Quarkus
    applies custom logic to speed up the boot process even in the Java mode.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以像之前看到的那样使用`java`解释器运行应用程序，结果是一个命令，例如`java -jar target/quarkus-app/quarkus-run.jar`。请注意，我们使用了一个不同的JAR，尽管*demo-1.0.0-SNAPSHOT.jar*确实存在于*target*目录中；之所以这样做是因为Quarkus应用了自定义逻辑以加速启动过程，即使在Java模式下也是如此。
- en: 'Running the application should result in startup times with 600 milliseconds
    on average, which is pretty close to what Micronaut does. Also, the size of the
    full application is in the 13 MB range. Sending a couple of `GET` requests to
    the application without and with a `name` parameter results in output similar
    to the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序应该会导致平均启动时间为600毫秒，这几乎接近Micronaut的情况。此外，完整应用程序的大小在13 MB左右。向应用程序发送一对`GET`请求，无论是否带有`name`参数，都会产生类似以下输出的结果：
- en: '[PRE12]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It should be no surprise that Quarkus also supports generating native executables
    via GraalVM Native Image, given that it targets cloud environments where small
    binary size is recommended. Because of this, Quarkus comes with batteries included,
    just like Micronaut, and generates everything you need from the get-go. There’s
    no need to update the build configuration to get started with native executables.
    As with the other examples, you must ensure that the current JDK points to a GraalVM
    distribution and that the `native-image` executable is found in your path. Once
    this step has been cleared, all that’s left is to package the application as a
    native executable by invoking `./mvnw -Pnative package`. This activates the `native`
    profile, which instructs the Quarkus build tools to generate the native executable.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，Quarkus也支持通过GraalVM Native Image生成本机可执行文件，因为它面向推荐使用小二进制大小的云环境。由于这个原因，Quarkus自带电池，就像Micronaut一样，并且从一开始就生成您所需的一切。无需更新构建配置即可开始使用本机可执行文件。与其他示例一样，您必须确保当前JDK指向GraalVM分发，并且`native-image`可执行文件位于您的路径中。完成这一步后，剩下的就是通过调用`./mvnw
    -Pnative package`将应用程序打包为本机可执行文件。这会激活`native`配置文件，该配置文件指示Quarkus构建工具生成本机可执行文件。
- en: After a couple of minutes, the build should have produced an executable named
    *demo-1.0.0-SNAPSHOT-runner* inside the *target* directory. Running this executable
    shows that the application starts up in 15 milliseconds on average. The size of
    the executable is close to 47 MB, which makes Quarkus the framework that yields
    the fastest startup and smallest executable size so far when compared to previous
    candidate frameworks.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 几分钟后，构建应该已经生成了一个名为*demo-1.0.0-SNAPSHOT-runner*的可执行文件，该文件位于*target*目录内。运行这个可执行文件显示应用程序平均启动时间为15毫秒。可执行文件的大小接近47
    MB，这使得Quarkus在与以前的候选框架相比的启动速度和最小可执行文件大小方面表现最佳。
- en: 'We’re done with Quarkus for the time being, leaving us with the fourth candidate
    framework: Helidon.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们告别了Quarkus，留下了第四个候选框架：Helidon。
- en: Helidon
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Helidon
- en: 'Last but not least, *Helidon* is a framework specifically crafted for building
    microservices with two flavors: SE and MP. The MP flavor stands for *MicroProfile*
    and lets you build applications by harnessing the power of standards; this flavor
    is a full implementation of the MicroProfile specifications. The SE flavor, on
    the other hand, does not implement MicroProfile, yet delivers similar functionality
    using a different set of APIs. Pick a flavor based on the APIs you’d like to interact
    with and your preference for standards; either way, Helidon gets the job done.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但并非最不重要的是，*Helidon* 是一个专门用于构建微服务的框架，有两种版本：SE 和 MP。MP 版本代表*MicroProfile*，通过利用标准的力量来构建应用程序；这个版本是MicroProfile规范的完整实现。另一方面，SE
    版本虽然没有实现MicroProfile，但使用不同的一组API提供了类似的功能。根据你想要与之交互的API和你对标准的偏好，选择一个版本；无论如何，Helidon都能完成工作。
- en: Given that Helidon implements MicroProfile, we can use yet another site to bootstrap
    a Helidon project. The [MicroProfile Starter site](https://oreil.ly/3U7RG) ([Figure 4-3](#microprofile_starter))
    can be used to create projects for all supported implementations of the MicroProfile
    specification by versions.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于Helidon实现了MicroProfile，我们可以使用另一个站点来启动Helidon项目。可以使用[MicroProfile Starter site](https://oreil.ly/3U7RG)（见图4-3）来为MicroProfile规范的所有支持实现创建项目版本。
- en: '![dtjd 0403](Images/dtjd_0403.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![dtjd 0403](Images/dtjd_0403.png)'
- en: Figure 4-3\. MicroProfile Starter
  id: totrans-135
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-3\. MicroProfile Starter
- en: 'Browse to the site, select which MP version you’re interested in, choose the
    MP implementation (in our case, Helidon), and perhaps customize some of the available
    features. Then click the Download button to download a ZIP file containing the
    generated project. The ZIP file contains a project structure similar to the following,
    except of course I’ve already updated the sources with the two files required
    to make the application work as we want it:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览到该站点，选择您感兴趣的MP版本，选择MP实现（在我们的例子中是Helidon），并可能定制一些可用的功能。然后点击下载按钮以下载包含生成项目的ZIP文件。ZIP文件包含类似于以下结构的项目结构，当然，我已经使用两个文件更新了源文件，以使应用程序按照我们想要的方式工作：
- en: '[PRE13]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As it happens, the source files *Greeting.java* and *GreetingResource.java*
    are identical to the sources we saw in the Quarkus example. How is that possible?
    First because the code is definitely trivial, but also (and more important) because
    both frameworks rely on the power of standards. As a matter of fact, the *Greeting.java*
    file is pretty much identical across all frameworks—except for Micronaut, which
    requires an additional annotation, but only if you’re interested in generating
    native executables; otherwise, it’s 100% identical. If you decided to jump ahead
    to this section before browsing the others, here’s what the *Greeting.java* file
    looks like:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 碰巧的是，源文件*Greeting.java*和*GreetingResource.java*与我们在Quarkus示例中看到的源文件完全相同。这是怎么可能的呢？首先因为代码显然是微不足道的，但更重要的是因为这两个框架都依赖于标准的力量。事实上，*Greeting.java*文件在所有框架中几乎完全相同，只有Micronaut需要额外的注解，但仅在您有兴趣生成本地可执行文件时才需要；否则，它是完全相同的。如果您决定在浏览其他内容之前直接跳到这部分，这是*Greeting.java*文件的样子：
- en: '[PRE14]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'It’s just a regular immutable data object with a single accessor. The *Greeting​Re⁠source.java*
    file, which defines the REST mappings needed for the application, follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 它只是一个普通的不可变数据对象，只有一个访问器。定义应用程序所需的REST映射的*Greeting​Re⁠source.java*文件如下：
- en: '[PRE15]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can appreciate the use of JAX-RS annotations, as we can see there’s no need
    for Helidon-specific APIs at this point. The preferred way to run a Helidon application
    is to package the binaries and run them with the `java` interpreter. That is,
    we lose a bit of build tool integration (for now), yet we can still use the command
    line to perform iterative development. Thus invoking `mvn package` followed by
    `java -jar/demo.jar` compiles, packages, and runs the application with an embedded
    web server listening on port 8080\. We can send a couple of queries to it, such
    as this one:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很欣赏JAX-RS注解的使用，因为我们可以看到此时无需特定于Helidon的API。运行Helidon应用程序的首选方法是将二进制文件打包并使用`java`解释器运行它们。也就是说，虽然我们在构建工具集成方面稍有损失（目前如此），但我们仍然可以使用命令行进行迭代开发。因此，调用`mvn
    package`后接着是`java -jar/demo.jar`编译、打包并运行应用程序，嵌入式Web服务器监听8080端口。我们可以向其发送一些查询，例如：
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If you look at the output where the application process is running, you’ll see
    that the application starts with 2.3 seconds on average, which makes it the slowest
    candidate we have seen so far, while the binaries’ size is close to 15 MB, putting
    it in the middle of all measurements. But as the adage goes, you can’t judge a
    book by its cover. Helidon provides more features out of the box automatically
    configured, which would account for the extra startup time and the larger deployment
    size.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看应用程序进程运行的输出，你会看到应用程序的平均启动时间为2.3秒，这使其成为迄今为止最慢的候选框架，而二进制文件的大小接近15 MB，属于所有测量值的中间位置。但正如谚语所说，不能以貌取人。Helidon提供了更多自动配置的开箱即用功能，这解释了额外的启动时间和更大的部署大小。
- en: If startup speed and deployment size were issues, you could reconfigure the
    build to remove those features that may not be needed, as well as switch to native
    executable mode. Fortunately, the Helidon team has embraced GraalVM Native Image
    as well, and every Helidon project, bootstrapped as we’ve done ourselves, comes
    with the required configuration to create native binaries. There’s no need to
    tweak the *pom.xml* file if you follow the conventions. Execute the `mvn -Pnative-image
    package` command, and you’ll find a binary executable named *demo* inside the
    *target* directory. This executable weighs about 94 MB, the largest so far, while
    its startup time is 50 milliseconds on average, in the same range as the previous
    frameworks.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果启动速度和部署大小是问题，你可以重新配置构建，移除可能不需要的功能，并切换到本地可执行模式。幸运的是，Helidon团队也接受了GraalVM Native
    Image，并且每个像我们自己一样启动的Helidon项目都配备了创建本地二进制文件所需的配置。如果遵循惯例，无需调整*pom.xml*文件。执行`mvn
    -Pnative-image package`命令，你会在*target*目录中找到一个名为*demo*的可执行二进制文件。这个可执行文件大约有94 MB，迄今为止最大，平均启动时间为50毫秒，与之前的框架处于相同范围内。
- en: Up to now, we’ve caught a glimpse of what each framework has to offer, from
    base features to build tool integration. As a reminder, there are several reasons
    to pick one candidate framework over another. I encourage you to write down a
    matrix for each relevant feature/aspect that affects your development requirements
    and assess each one of those items with every candidate.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经初步了解了每个框架提供的功能，从基本特性到构建工具的集成。作为提醒，有几个理由可以选择一个候选框架而不是另一个。我鼓励你为每个影响你的开发需求的相关功能/方面编写一个矩阵，并对每个候选项进行评估。
- en: Serverless
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无服务器
- en: This chapter began by looking at monolithic applications and architectures,
    usually pieced together by components and tiers clumped together into a single,
    cohesive unit. Changes or updates to a particular piece require updating and deploying
    the whole. Failure at one particular place could bring down the whole as well.
    Then we moved on to microservices. Breaking the monolith into smaller chunks that
    can be updated and deployed individually and independently of one another should
    take care of the previously mentioned issues, but microservices bring a host of
    other issues.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 本章开始时讨论了通常由组件和层组合成的单片应用程序和架构。对特定部分的更改或更新需要更新和部署整个单体。某个特定位置的故障也可能导致整体崩溃。然后我们转向了微服务。将单体应用程序拆分为可以单独和独立更新和部署的更小块应该解决之前提到的问题，但微服务也带来了一系列其他问题。
- en: 'Before, it was enough to run the monolith inside an application server hosted
    on big iron, with a handful of replicas and a load balancer for good measure.
    This setup has scalability issues. With the microservices approach, we can grow
    or collapse the mesh of services depending on the load. That boosts elasticity,
    but now we have to coordinate multiple instances and provision runtime environments,
    load balancers become a must, API gateways are needed, network latency rears its
    ugly head, and did I mention distributed tracing? Yes, those are a lot of things
    to be aware of and manage. But what if you didn’t have to? What if someone else
    took care of the infrastructure, monitoring, and other “minutiae” required to
    run applications at scale? This is where the serverless approach comes in: where
    you concentrate on the business logic at hand and let the serverless provider
    deal with everything else.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，在大型服务器上托管的应用服务器内运行单体已经足够了，配备了少数副本和负载均衡器以作为补充。但这种设置存在可伸缩性问题。采用微服务的方法，我们可以根据负载的大小扩展或折叠服务的网格。这增强了弹性，但现在我们必须协调多个实例并提供运行时环境，负载均衡器变得必不可少，API网关也是必需的，网络延迟也开始显现，我有提到分布式追踪吗？是的，这些都是需要注意和管理的许多事情。但如果不需要这些怎么办？如果有人可以处理基础设施、监控和其他运行大规模应用所需的“琐事”，那就是无服务器方法的用武之地：你可以专注于手头的业务逻辑，让无服务器提供者处理其他所有事务。
- en: 'While distilling a component into smaller pieces, one thought should come to
    mind: “What’s the smallest reusable piece of code I can turn this component into?”
    If your answer is a Java class with a handful of methods and perhaps a couple
    of injected collaborators/services, you’re close, but you’re not there yet. The
    smallest piece of reusable code is, as a matter of fact, a single method. Picture
    a microservice defined as a single class that performs the following steps:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当将组件分解为较小的部分时，应该思考一件事：“我可以将这个组件转化为什么样的最小可重复使用的代码片段？” 如果你的答案是一个带有少量方法和一两个注入的协作者/服务的Java类，那么你已经接近了，但还不够。事实上，最小的可重复使用代码片段是一个单一的方法。想象一下，一个微服务定义为一个执行以下步骤的单一类：
- en: Reads the input arguments and transforms them into a consumable format as required
    by the next step
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取输入参数并按照下一步所需的格式转换为可消耗的格式
- en: Performs the actual behavior required by the service, such as issuing a query
    to a database, indexing, or logging
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行服务所需的实际行为，例如向数据库发出查询、索引或记录日志
- en: Transforms the processed data into an output format
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将处理后的数据转换为输出格式
- en: Now, each of these steps may be organized in separate methods. You may soon
    realize that some of these methods are reusable as is or parameterized. A typical
    way to solve this would be to provide a common *super type* among microservices.
    This creates a strong dependency among types, and for some use cases, that’s all
    right. But for others, updates to the common code have to happen as soon as possible,
    in a versioned fashion, without disrupting currently running code, so I’m afraid
    we may need an alternative.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这些步骤中的每一个可能会被组织成单独的方法。你可能很快意识到，其中一些方法是可重复使用的或者可以参数化的。解决这个问题的典型方法是为微服务提供一个公共*超类型*。这会在类型之间创建强依赖关系，在某些使用情况下是可以接受的。但对于其他情况，共同代码的更新必须尽快进行，以版本化的方式进行，而不会中断当前正在运行的代码，所以我恐怕我们可能需要另一种方法。
- en: With this scenario in mind, if the common code were to be provided instead as
    a set of methods that can be invoked independently of one another, with their
    inputs and outputs composed in such a way that you establish a pipeline of data
    transformations, then we arrive at what are now known as *functions*. Offerings
    such as *function as a service* (FaaS) are a common subject among serverless providers.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这种情况，如果通用代码被提供为一组可以独立调用的方法，它们的输入和输出以这样一种方式组合，即您建立了一个数据转换的管道，则我们现在所知道的称为*函数*。像*函数即服务*（FaaS）这样的服务是无服务器提供者的一个常见主题。
- en: In summary, FaaS is a fancy way to say that you compose applications based on
    the smallest deployment unit possible and let the provider figure out all the
    infrastructure details for you. In the following sections, we’ll build and deploy
    a simple function to the cloud.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，FaaS是一种精致的方式，即您根据可能的最小部署单元组合应用程序，并让提供者为您解决所有基础设施细节。在接下来的章节中，我们将构建并部署一个简单的函数到云端。
- en: Setting Up
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置中
- en: Nowadays every major cloud provider has an FaaS offering at your disposal, with
    add-ons that hook into other tools for monitoring, logging, disaster recovery,
    and more; just pick the one that meets your needs. For the sake of this chapter,
    we’ll pick AWS Lambda, which was, after all, the originator of the FaaS idea.
    We’ll also pick Quarkus as the implementation framework, as it’s the one that
    currently provides the smallest deployment size. Be aware that the configuration
    shown here may need some tweaks or might be totally outdated; always review the
    latest versions of the tools required to build and run the code. We’ll use Quarkus
    1.13.7 for now.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，每个主要的云提供商都有一个可供使用的FaaS提供，其附加组件可以连接其他工具，用于监控、日志记录、灾难恢复等等；只需选择满足您需求的一个。在本章中，我们将选择
    AWS Lambda，毕竟它是FaaS理念的发起者。我们还会选择 Quarkus 作为实现框架，因为它目前提供了最小的部署大小。请注意，这里展示的配置可能需要一些调整或可能完全过时；始终审查构建和运行代码所需工具的最新版本。目前我们将使用
    Quarkus 1.13.7。
- en: Setting up a function with Quarkus and AWS Lambda requires having an [AWS account](https://aws.amazon.com),
    the [AWS CLI](https://oreil.ly/0dYrb) installed on your system, and the [AWS Serverless
    Application Model (SAM) CLI](https://oreil.ly/h7gdD) if you’d like to run local
    tests.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Quarkus 和 AWS Lambda 设置函数需要一个 [AWS 账号](https://aws.amazon.com)，在您的系统上安装 [AWS
    CLI](https://oreil.ly/0dYrb)，以及如果您想要运行本地测试，还需要安装 [AWS Serverless Application Model
    (SAM) CLI](https://oreil.ly/h7gdD)。
- en: 'Once you have that covered, the next step is to bootstrap the project, for
    which we would be inclined to use [Quarkus](https://code.quarkus.io) as before
    except that a function project requires a different setup. So it’s better to switch
    to using a Maven archetype:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你搞定了这些，下一步就是启动项目，我们会倾向于像以前一样使用 [Quarkus](https://code.quarkus.io)，但是函数项目需要不同的设置。所以最好切换到使用
    Maven 原型：
- en: '[PRE17]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Invoking this command in interactive mode will ask you a few questions, such
    as the group, artifact, version (GAV) coordinates for the project, and the base
    package. For this demo, let’s go with these:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在交互模式下调用此命令将询问您一些问题，例如项目的组、artifact、版本（GAV）坐标和基础包。对于这个演示，让我们使用以下配置：
- en: '`groupId`: com.example.demo'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`groupId`: com.example.demo'
- en: '`artifactId`: demo'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`artifactId`: demo'
- en: '`version`: 1.0-SNAPSHOT (the default)'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`version`: 1.0-SNAPSHOT（默认值）'
- en: '`package`: com.example.demo (same as `groupId`)'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package`: com.example.demo（与 `groupId` 相同）'
- en: 'This results in a project structure suitable to build, test, and deploy a Quarkus
    project as a function deployable to AWS Lambda. The archetype creates build files
    for both Maven and Gradle, but we don’t need the latter for now; it also creates
    three function classes, but we need only one. Our aim is to have a file structure
    similar to this one:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致一个适合构建、测试和部署到 AWS Lambda 的 Quarkus 项目的项目结构。原型创建了 Maven 和 Gradle 的构建文件，但是我们现在不需要后者；它还创建了三个函数类，但我们只需要一个。我们的目标是拥有类似于这个的文件结构：
- en: '[PRE18]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The gist of the function is to capture inputs with the `InputObject` type,
    process them with the `ProcessingService` type, and then transform the results
    into another type (`OutputObject`). The `GreetingLambda` type puts everything
    together. Let’s have a look at both input and output types first—after all, they
    are simple types that are concerned with only containing data, with no logic whatsoever:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的要点是使用 `InputObject` 类型捕获输入，使用 `ProcessingService` 类型处理它们，然后将结果转换为另一种类型（`OutputObject`）。`GreetingLambda`
    类型将所有内容整合在一起。首先让我们先看一下输入和输出类型——毕竟，它们只是简单的数据类型，没有任何逻辑：
- en: '[PRE19]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The lambda expects two input values: a greeting and a name. We’ll see how they
    get transformed by the processing service in a moment:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 函数期望接收两个输入值：问候语和姓名。我们马上会看到它们如何被处理服务转换：
- en: '[PRE20]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The output object holds the transformed data and a reference to the requestID.
    We’ll use this field to show how we can get data from the running context.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 输出对象包含转换后的数据和请求ID的引用。我们将使用这个字段来展示如何从运行上下文获取数据。
- en: 'All right, the processing service is next; this class is responsible for transforming
    the inputs into outputs. In our case, it concatenates both input values into a
    single string, as shown here:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，接下来是处理服务；这个类负责将输入转换为输出。在我们的情况下，它将两个输入值连接成一个字符串，如下所示：
- en: '[PRE21]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'What’s left is to have a look at `GreetingLambda`, the type used to assemble
    the function itself. This class requires implementing a known interface supplied
    by Quarkus, whose dependency should be already configured in the *pom.xml* file
    created with the archetype. This interface is parameterized with input and output
    types. Luckily, we have those already. Every lambda must have a unique name and
    may access its running context, as shown next:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是查看`GreetingLambda`，用于组装函数本身的类型。这个类需要实现由 Quarkus 提供的已知接口，其依赖应该已经在使用原型创建的*pom.xml*文件中配置好了。这个接口使用输入和输出类型参数化。幸运的是，我们已经有了这些。每个
    Lambda 必须有一个唯一的名称，并且可以访问其运行上下文，如下所示：
- en: '[PRE22]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: All the pieces fall into place. The lambda defines input and output types and
    invokes the data processiong service. For the purpose of demonstration, this example
    shows the use of dependency injection, but you could reduce the code by moving
    the behavior of `ProcessingService` into `GreetingLambda`. We can quickly verify
    the code by running local tests with `mvn test`, or if you prefer `mvn verify`,
    as that will also package the function.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的部分都应该得到合理安排。Lambda 定义输入和输出类型并调用数据处理服务。为了演示目的，此示例展示了依赖注入的使用，但您可以通过将`ProcessingService`的行为移到`GreetingLambda`中来减少代码量。我们可以通过运行本地测试命令`mvn
    test`快速验证代码，或者如果您喜欢`mvn verify`，因为它还会打包函数。
- en: 'Note that additional files are placed in the *target* directory when the function
    is packaged, specifically a script named *manage.sh*, which relies on the AWS
    CLI tool to create, update, and delete the function at the target destination
    associated with your AWS account. Additional files are required to support these
    operations:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当函数被打包时，附加文件被放置在*target*目录中，特别是一个名为*manage.sh*的脚本，该脚本依赖于 AWS CLI 工具，用于在与您的
    AWS 帐户关联的目标位置创建、更新和删除函数。支持这些操作需要其他文件：
- en: function.zip
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: function.zip
- en: The deployment file containing the binary bits
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 包含二进制位的部署文件
- en: sam.jvm.yaml
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: sam.jvm.yaml
- en: Local test with AWS SAM CLI (Java mode)
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 AWS SAM CLI 进行本地测试（Java 模式）
- en: sam.native.yaml
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: sam.native.yaml
- en: Local test with AWS SAM CLI (native mode)
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 AWS SAM CLI 进行本地测试（本地模式）
- en: 'The next step requires you to have an *execution role* configured, for which
    it’s best to refer to the [AWS Lambda Developer Guide](https://oreil.ly/97ACL)
    in case the procedure has been updated. The guide shows you how to get the AWS
    CLI configured (if you have not done so already) and create an execution role
    that must be added as an environment variable to your running shell. For example:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步需要您配置一个*执行角色*，最好参考 [AWS Lambda 开发指南](https://oreil.ly/97ACL)，以防流程已经更新。该指南将向您展示如何配置
    AWS CLI（如果您尚未执行此操作）并创建一个必须添加为运行 shell 的环境变量的执行角色。例如：
- en: '[PRE23]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this case, `1234567890` stands for your AWS account ID, and `lambda-ex` is
    the name of the role of your choosing. We can proceed with executing the function,
    for which we have two modes (Java, native) and two execution environments (local,
    production); let’s tackle the Java mode first for both environments and then follow
    it up with native mode.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`1234567890`代表您的 AWS 帐户 ID，`lambda-ex`是您选择的角色名称。我们可以继续执行函数，对于这个函数，我们有两种模式（Java、本地）和两种执行环境（本地、生产）；让我们首先处理两种环境的
    Java 模式，然后再处理本地模式。
- en: 'Running the function on a local environment requires the use of a Docker daemon,
    which by now should be commonplace in a developer’s toolbox; we also require using
    the AWS SAM CLI to drive the execution. Remember the set of additional files found
    inside the *target* directory? We’ll use the *sam.jvm.yaml* file alongside another
    file that was created by the archetype when the project was bootstrapped, called
    *payload.json*. Located at the root of the directory, its contents should look
    like this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地环境中运行函数需要使用 Docker 守护程序，现在应该是开发人员工具箱中的常见组成部分；我们还需要使用 AWS SAM CLI 来驱动执行。记住在*target*目录中找到的附加文件集合吗？我们将使用*sam.jvm.yaml*文件以及在项目启动时由原型创建的另一个文件*payload.json*。位于目录根目录，其内容应如下所示：
- en: '[PRE24]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This file defines values for the inputs accepted by the function. Given that
    the function is already packaged, we just have to invoke it, like so:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件为函数接受的输入定义了值。鉴于函数已经打包，我们只需调用它，如下所示：
- en: '[PRE25]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The command will pull a Docker image suitable for running the function. Take
    note of the reported values, which may differ depending on your setup. On my local
    environment, this function would cost me 3.3 seconds, and 256 MB for its execution.
    This can give you an idea of how much you’ll be billed when running your system
    as a set of functions. However, local is not the same as production, so let’s
    deploy the function to the real deal. We’ll use the *manage.sh* script to accomplish
    this feat, by invoking the following commands:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将拉取一个适合运行该函数的 Docker 镜像。请注意报告的值，这可能会因您的设置而异。在我的本地环境中，此函数的执行将花费我 3.3 秒，并占用
    256 MB 的内存。这可以让您了解在运行系统作为一组函数时，您将被计费多少。然而，本地环境与生产环境不同，因此让我们将该函数部署到真实环境中。我们将使用
    *manage.sh* 脚本来完成这一壮举，通过调用以下命令：
- en: '[PRE26]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As you can see, the billed duration and memory usage decreased, which is good
    for our wallet, although the init duration went up to 1.6, which would delay the
    response, increasing the total execution time across the system. Let’s see how
    these numbers change when we switch from Java mode to native mode. As you may
    recall, Quarkus lets you package projects as native executables out of the box,
    but remember that Lambda requires Linux executables, so if you happen to be running
    on a non-Linux environment, you’ll need to tweak the packaging command. Here’s
    what needs to be done:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，计费时长和内存使用量都减少了，这对我们的钱包来说是好事，尽管初始化时长增加到了 1.6，这会延迟响应，增加整个系统的总执行时间。让我们看看当我们从
    Java 模式切换到本机模式时，这些数字会如何变化。您可能还记得，Quarkus 允许您将项目打包为本机可执行文件，但请记住 Lambda 需要 Linux
    可执行文件，因此如果您恰好在非 Linux 环境上运行，则需要调整打包命令。以下是需要完成的操作：
- en: '[PRE27]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The second command invokes the build inside a Docker container and places the
    generated executable on your system at the expected location, whereas the first
    command executes the build as is. With the native executable now in place, we
    can execute the new function both in local and production environments. Let’s
    see the local environment first:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个命令在 Docker 容器内调用构建，并将生成的可执行文件放置在预期位置，而第一个命令则按原样执行构建。现在，有了本地可执行文件，我们可以在本地和生产环境中执行新函数。先看看本地环境：
- en: '[PRE28]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The billed duration decreased by one order of magnitude, going from 3300 ms
    to just 300 ms, and the used memory was halved; this looks promising compared
    to its Java counterpart. Will we get better numbers when running on production?
    Let’s look:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 计费时长降低了一个数量级，从 3300 毫秒降至仅 300 毫秒，并且使用的内存减半；与其 Java 对应物相比，这看起来很有希望。在生产环境中运行时，我们会得到更好的数据吗？让我们来看看：
- en: '[PRE29]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The total billed duration results in 30% speedup, and the memory usage is less
    than half of that before; but the real winner is the initialization time, which
    takes roughly 10% of the previous time. Running your function in native mode results
    in faster startup and better numbers across the board.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 总计的计费时长结果提高了 30%，内存使用量不到以前的一半；但真正的赢家是初始化时间，大约是以前时间的 10%。在本机模式下运行您的函数会导致启动更快，各方面的数据更好。
- en: Now it’s up to you to decide the combination of options that will give you the
    best results. Sometimes staying in Java mode is good enough even for production,
    or going native all the way may give you the edge. Whichever way it may be, measurements
    are key—don’t guess!
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在轮到您决定哪种组合选项会给您带来最佳结果了。有时，即使是在生产环境中保持 Java 模式也足够好，或者一直采用本机模式可能会为您带来优势。无论哪种方式，测量都很关键—不要猜测！
- en: Summary
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'We covered a lot of ground in this chapter, starting with a traditional monolith,
    breaking it into smaller parts with reusable components that can be deployed independently,
    known as microservices, and going all the way to the smallest deployment unit
    possible: a function. Trade-offs occur along the way, as microservice architectures
    are inherently more complex, composed as they are of more moving parts. Network
    latency becomes a real issue and must be tackled accordingly. Other aspects such
    as data transactions become more complex as their span may cross service boundaries,
    depending on the case. The use of Java and native executable mode yields different
    results and requires to be customized setup, each with its own pros and cons.
    My recommendation, dear reader, is to evaluate, measure, and then select a combination;
    keep tabs on numbers and service level agreements (SLAs), because you may need
    to reevaluate decisions along the road and make adjustments.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了很多内容，从传统的单体架构开始，将其分解为具有可重用组件的较小部分，这些部分可以独立部署，称为微服务，一直到最小的部署单元：函数。沿途会出现权衡，因为微服务架构本质上更复杂，由于其由更多运动部分组成。网络延迟成为一个真正的问题，必须相应地加以解决。其他方面，如数据事务，由于其跨服务边界的跨度可能不同，取决于情况，会变得更加复杂。使用Java和本地可执行模式产生不同的结果，并且需要定制设置，每种都有其优缺点。我亲爱的读者，我的建议是评估、测量，然后选择一种组合；随时注意数字和服务级别协议（SLAs），因为您可能需要重新评估决策并进行调整。
- en: '[Table 4-1](#Java_and_native_image_modes) summarizes the measurements obtained
    by running the sample application on both Java and native image modes, on my local
    environment and remote, for each one of the candidate frameworks. The size columns
    show the deployment unit size, while the time columns depict the time from startup
    up to the first request.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 4-1](#Java_and_native_image_modes) 总结了在我的本地环境和远程环境中以Java和本地映像模式运行示例应用程序时，每个候选框架的测量结果。大小列显示部署单元大小，而时间列描绘了从启动到第一个请求的时间。'
- en: Table 4-1\. Measurement summary
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-1\. 测量摘要
- en: '| Framework | Java - size | Java - time | Native - size | Native - time |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| 框架 | Java - 大小 | Java - 时间 | 本地 - 大小 | 本地 - 时间 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| Spring Boot | 17 MB | 2200 ms | 78 MB | 90 ms |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| Spring Boot | 17 MB | 2200 ms | 78 MB | 90 ms |'
- en: '| Micronaut | 14 MB | 500 ms | 60 MB | 20 ms |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| Micronaut | 14 MB | 500 ms | 60 MB | 20 ms |'
- en: '| Quarkus | 13 MB | 600 ms | 47 MB | 13 ms |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| Quarkus | 13 MB | 600 ms | 47 MB | 13 ms |'
- en: '| Helidon | 15 MB | 2300 ms | 94 MB | 50 ms |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| Helidon | 15 MB | 2300 ms | 94 MB | 50 ms |'
- en: As a reminder, you are encouraged to take your own measurements. Changes to
    the hosting environment, JVM version and settings, framework version, network
    conditions, and other environment characteristics will yield different results.
    The numbers shown should be taken with a grain of salt, never as authoritative
    values.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，鼓励您进行自己的测量。对于托管环境、JVM版本和设置、框架版本、网络条件和其他环境特征的更改将产生不同的结果。显示的数字应该持保留态度，永远不要视为权威值。
