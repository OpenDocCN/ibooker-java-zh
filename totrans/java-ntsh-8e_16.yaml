- en: Appendix. Beyond Java 17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This appendix discusses versions of Java beyond Java 17. In previous editions
    of *Java in a Nutshell*, we have resisted adding forward-looking material, but
    recent changes in the Java release model (which we discussed in [Chapter 1](ch01.xhtml#javanut8-CHP-1)),
    as well as ongoing and forthcoming Java developments, have prompted a change of
    tack in this new edition.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the current model, a new version of Java is released every six months, but
    only certain releases are LTS. As it stands, Java 11 and 17 are regarded as LTS
    (with 8 retrospectively added). Note that LTS has a dual meaning: for Oracle customers
    it means that paid support is available for a multiyear period, while other JDK
    providers (including Red Hat, Microsoft, Amazon, etc.) have de facto adopted the
    same versions as those for which backported security and other fixes will be made
    publicly available—free of charge—as certified OpenJDK binaries.'
  prefs: []
  type: TYPE_NORMAL
- en: The industry, as a whole, has not chosen to adopt a six-month Java upgrade cycle
    for various reasons, and so in practice, the LTS versions are the only ones that
    are likely to be deployed into production. However, most of the OpenJDK providers
    do diligently publish binaries for all Java releases, even those that will not
    be supported beyond the six-month window.
  prefs: []
  type: TYPE_NORMAL
- en: 'This creates a dichotomy: new features arrive every six months but are not
    widely deployed by teams until the next LTS, which complicates writing about specific
    Java versions. This is further complicated by the concept of *Incubating* and
    *Preview* features, which are used to experiment with new APIs and new language
    features, respectively, before they are finalized and become a standard part of
    the language.'
  prefs: []
  type: TYPE_NORMAL
- en: The solution we have chosen is to target new editions of this book at LTS versions
    and include an appendix that covers any new features that have arrived (or are
    expected to arrive) since the last LTS. We have also chosen to cover only final
    features in the main part of the book; all discussion of Incubating and Preview
    features will be confined to appendices.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by covering how major development efforts are arranged within OpenJDK,
    then discuss Java 18 and 19, and then conclude with a look at the future beyond
    that release.
  prefs: []
  type: TYPE_NORMAL
- en: Long-Term JDK Projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenJDK is organized into projects that cover specific major areas of ongoing
    work. This includes projects that are centered on the development of future language
    or JVM features that can take multiyear efforts to deliver.
  prefs: []
  type: TYPE_NORMAL
- en: 'Four projects currently focus on the delivery of major future aspects of Java.
    They are usually known by their project codenames:'
  prefs: []
  type: TYPE_NORMAL
- en: Panama
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loom
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Valhalla
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amber
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Of these, Project Panama provides two major improvements: a modern foreign-function
    interface for Java and support for vector CPU instructions.'
  prefs: []
  type: TYPE_NORMAL
- en: It has been incubating for some time now, but Java 18 contains an interesting
    milestone iteration of the functionality, and so we will cover the project in
    the Java 18 section.
  prefs: []
  type: TYPE_NORMAL
- en: Project Loom is a new concurrency model for Java. A first preview of some of
    Loom’s functionality will be available for the first time in Java 19, so we will
    discuss Loom in that section.
  prefs: []
  type: TYPE_NORMAL
- en: Project Valhalla is the most ambitious, wide-ranging, and highest-impact of
    all of the projects. It is also the most complex and the farthest from delivery
    as a shipping product. We discuss it toward the end of the appendix.
  prefs: []
  type: TYPE_NORMAL
- en: Project Amber’s remit is incremental language improvements. It is probably the
    most familiar and easiest-to-understand of the four projects, so we’ll discuss
    it here as our next topic.
  prefs: []
  type: TYPE_NORMAL
- en: Amber
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Amber has been running since Java 9 was delivered. It aims to deliver small
    chunks of useful language functionality, an approach that fits well with the new
    delivery schedule for Java releases. The features that have formed part of Amber
    and delivered so far include:'
  prefs: []
  type: TYPE_NORMAL
- en: Local Variable Type Inference (`var`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Switch Expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhanced `instanceof`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Text Blocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Records
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sealed Types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pattern Matching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Most of these features have already been completed, but the last of these,
    Pattern Matching, has not been fully delivered as of Java 17. Only the simplest
    case, the `instanceof` pattern, has arrived as a final feature so far. Java 17
    does have a Preview version of a more advanced form (as we mentioned in [Chapter 5](ch05.xhtml#javanut8-CHP-5))
    that can be used as part of a switch expression, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note the lack of need for a `default` case. All `Pet` objects are either a `Cat`
    or a `Dog`, because the `Pet` interface is declared as sealed.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching will truly come into its full power when further future cases
    arrive and are standardized as final features. In particular, the combination
    of pattern matching and *algebraic data types* (one of the names given to the
    combination of records and sealed types) is especially powerful.
  prefs: []
  type: TYPE_NORMAL
- en: We can see how Amber’s approach fits with the model of biannual releases of
    Java; switch expressions and enhanced `instanceof` are extended and combined into
    the basics of pattern matching, which is then further enhanced by algebraic data
    types and further cases of patterns tailored to them.
  prefs: []
  type: TYPE_NORMAL
- en: Java 18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'New Java releases are made up of Java Enhancement Proposals (JEPs): a complete
    list of current, past, and future JEPs can be found at [*https://oreil.ly/BE1r1*](https://oreil.ly/BE1r1).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Java 18 was released in March 2022 and includes the following JEPs:'
  prefs: []
  type: TYPE_NORMAL
- en: '400: UTF-8 by Default'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '408: Simple Web Server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '413: Code Snippets in Java API Documentation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '416: Reimplement Core Reflection with Method Handles'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '417: Vector API (Third Incubator)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '418: Internet-Address Resolution SPI'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '419: Foreign Function & Memory API (Second Incubator)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '420: Pattern Matching for switch (Second Preview)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of these are very minor or internal implementation changes. The two JEPs
    related to Panama (417 and 419) are significant steps forward for the project,
    which we’ll discuss in detail here.
  prefs: []
  type: TYPE_NORMAL
- en: Panama
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Project Panama aims to provide a modern Foreign (i.e., non-Java) interface for
    connecting to native code. The codename comes from the isthmus of Panama, a narrow
    strip connecting two larger “landmasses,” understood to be the JVM and native
    memory (aka “off-heap”).
  prefs: []
  type: TYPE_NORMAL
- en: The overall aim is to replace Java Native Interface (JNI), which is well-known
    to have major problems such as an excess of ceremony, extra artifacts, and a lack
    of interoperability with libraries written in anything other than C / C++. In
    fact, even for the C case, JNI does not do anything automatic to map type systems
    and the portions of Java and C code have to be mapped semimanually.
  prefs: []
  type: TYPE_NORMAL
- en: 'Panama provides two main components to assist in the interoperation of Java
    and native code:'
  prefs: []
  type: TYPE_NORMAL
- en: Foreign Memory and Functions API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vector API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Foreign Memory API is concerned with the allocation, manipulation, and freeing
    of structured foreign memory, and the lifecycle management of foreign resources.
    This goes beyond the existing capabilities of the `ByteBuffer` class, and for
    example can address more than 2 GB of memory as a single segment. The issue of
    how foreign memory is managed is complex, as it is outside the scope of the JVM’s
    garbage collector, and existing mechanisms such as finalization are known to be
    fatally flawed.
  prefs: []
  type: TYPE_NORMAL
- en: Calling foreign functions is also possible using Panama. A new command-line
    tool, called `jextract`, creates a Java bridge from a C header file. This bridge
    is built using method and var handles to provide a set of (static) Java methods
    that look as close as possible to the original C API.
  prefs: []
  type: TYPE_NORMAL
- en: The runtime support for this is contained in the module `jdk.incubator.foreign`,
    which is, unsurprisingly, an Incubating API and may well change in future versions
    before it ships as final. As it stands, C and C++ are the initially supported
    foreign languages, but other possibilities (notably Rust) are expected to be added
    as the project develops.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the Foreign API, Panama also provides support for vector computations
    by shipping an API that has these main goals:'
  prefs: []
  type: TYPE_NORMAL
- en: Clear and concise API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Platform agnostic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reliable JIT compilation and performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graceful degradation of vector mode back to linear instructions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Panama is initially shipping an implementation for the x64 and AArch64 CPU architectures.
    However, as expressed in the goals, the API does not—and must not—rule out possible
    implementations for other CPUs.
  prefs: []
  type: TYPE_NORMAL
- en: Java 19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Java 19 was released in September 2022 and includes a preview of a new major
    feature (Loom) as well as the following selection of JEPs:'
  prefs: []
  type: TYPE_NORMAL
- en: '405: Record Patterns (Preview)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '422: Linux/RISC-V Port'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '424: Foreign Function and Memory API (Preview)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '426: Vector API (Fourth Incubator)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '427: Pattern Matching for switch (Third Preview)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These JEPs are mostly continuations of the development of existing preview
    and incubating features, so rather than spend more time on them, we’ll focus on:'
  prefs: []
  type: TYPE_NORMAL
- en: '425: Virtual Threads (Preview)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '428: Structured Concurrency (Incubator)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These two JEPs provide the basis of the first preview delivery of Project Loom.
  prefs: []
  type: TYPE_NORMAL
- en: Loom
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Java 17, every executing Java language thread is an OS thread because calling
    `Thread.start()` triggers a system call that creates an OS thread. This therefore
    creates a constraint between the number of available Java execution contexts and
    the limits of the operating system. As programming languages have evolved, this
    constraint has become more problematic. The OS has data structures (e.g., stack)
    that it creates for each thread, and it individually schedules execution of each
    thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'This naturally leads to the question: how many OS threads can an application
    start? 1,000? Perhaps 10,000? Regardless of the exact number, there is definitely
    a hard limit in this approach. Project Loom is a reimagining of Java’s concurrency
    model that is designed to transcend this limitation.'
  prefs: []
  type: TYPE_NORMAL
- en: The key is *virtual threads*, a new construct that is not 1-1 with OS threads.
    From a Java programming perspective, virtual threads look like instances of `Thread`,
    but they are managed by the JVM, not the OS. This means that no OS-level data
    structures (e.g., for the thread’s stack frames) are created, and all the management
    metadata is handled by the JVM. This includes the scheduling behavior; rather
    than the OS scheduler, a Java execution scheduler (a threadpool) is used.
  prefs: []
  type: TYPE_NORMAL
- en: When a virtual thread wants to execute, it does so on an OS *carrier thread*
    and runs until a blocking call (e.g., I/O) is made. The carrier thread is *yielded*
    to another virtual thread, and so a virtual thread may execute on several different
    carriers over its lifetime. The connection to blocking calls means that virtual
    threads are not suitable for pure CPU-bound tasks, and in general, the use of
    Loom is very different from approaches such as `async` / `await` that developers
    may have used in other languages.
  prefs: []
  type: TYPE_NORMAL
- en: It remains to be seen how much Loom will impact end-user devs, although there
    is a lot of interest from framework and library authors. An initial version is
    arriving as a preview in JDK 19, but it is still unclear when it’ll arrive as
    a standard feature. Overall, the expectation in the community is that it will
    be finalized in the next LTS, which is expected to be Java 21.
  prefs: []
  type: TYPE_NORMAL
- en: Future Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Along with the completion of the projects already mentioned, longer-term efforts
    to evolve Java are underway: Project Valhalla and the rise of Cloud-Native Java.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at each in turn.
  prefs: []
  type: TYPE_NORMAL
- en: Valhalla
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Project Valhalla is a very ambitious OpenJDK project that has been running since
    2014. The goal, “To align JVM memory layout behavior with the cost model of modern
    hardware,” seems simple and innocuous enough.
  prefs: []
  type: TYPE_NORMAL
- en: However, this is deeply deceptive.
  prefs: []
  type: TYPE_NORMAL
- en: 'For starters, this divides the existing Java objects into two cases: the identity
    objects we’re used to using and a new kind of value object whose main difference
    is that it doesn’t have a unique identity. From these value objects, a further
    step is taken to allow the reference-ness, or indirection, to be removed and for
    the value to be directly represented by its bit patterns.'
  prefs: []
  type: TYPE_NORMAL
- en: The intended use case for this new data value is small, immutable, final, identity-less
    types. This allows these new identity-less values to fit with both the existing
    object reference and primitive worlds, getting the best of each world, and it
    also alludes to one possible use case as “user-defined primitives.”
  prefs: []
  type: TYPE_NORMAL
- en: Users should think of values as objects without identity, and then they will
    get guaranteed performance benefits from the JIT (such as enhanced *escape analysis*).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Valhalla also provides a mechanism for low-level libraries (such as complex
    numbers, half-floats for machine learning, etc.) to use the primitive value type
    directly, but most developers should not need to use this aspect.
  prefs: []
  type: TYPE_NORMAL
- en: The fact that these new data values lack object identity implies that they disrupt
    the traditional inheritance hierarchy—without identity there is no object monitor,
    so `wait()`, `notify()`, and `synchronized` are not possible for these types.
  prefs: []
  type: TYPE_NORMAL
- en: In turn, this creates a potentially surprising connection to Java generics because
    only reference types are permissible as the value for a type parameter. Valhalla
    therefore proposes to extend generics to allow abstraction over all types including
    these new data values and even the existing primitives.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the extensive work to plumb these new forms of data through the
    JVM, it is also necessary to create a usage model in the Java language that seems
    natural to Java programmers. Valhalla must also enable existing libraries (including,
    but not limited to, the JDK) to compatibly evolve as these changes are delivered.
  prefs: []
  type: TYPE_NORMAL
- en: Some new bytecode instructions will be needed, as Valhalla’s new types are immutable,
    so the `putfield` instruction (which modifies object fields) will not work.
  prefs: []
  type: TYPE_NORMAL
- en: Valhalla’s new types have been known by several names during the project’s history,
    including *value types*, *inline types*, and *primitive classes*. The JEPs that
    cover the implementation of Valhalla are not, at the time of writing, targeted
    at any specific Java version, and it may be some time before most Java programmers
    encounter them in day-to-day work.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud-Native Java
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the ongoing mega trends in the software industry is the transition to
    workloads that run “in the cloud,” which means on time-leased servers owned by
    infrastructure providers such as Amazon, Microsoft, and Google.
  prefs: []
  type: TYPE_NORMAL
- en: Modern programming environments increasingly need to ensure that they are economic
    and easy to use in cloud deployments, and Java is no exception. However, Java’s
    design does have certain aspects that are potentially less friendly to cloud applications
    than we would like. These largely stem from the classloading and JIT compilation
    aspects of the runtime, which are designed for flexibility and high performance
    over the lifetime of a single JVM process.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the cloud, this can have side effects such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Slow application startup time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Long time to peak performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Potentially high memory overhead
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In particular, the lifetime of cloud processes (especially for “Serverless”
    and *Function-as-a-Service* deployments) may be too short for the performance
    benefits of Java to pay off. This can be seen as the costs required to get the
    gains not being fully amortized by the time the process exits.
  prefs: []
  type: TYPE_NORMAL
- en: There are ongoing attempts to solve these long-term pain points and ensure that
    Java remains a competitive and attractive programming environment as Cloud-First
    becomes the dominant mode of delivery for serverside applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the major approaches is *native compilation*: the conversion of a Java
    program from bytecode into compiled machine code. As this compilation occurs before
    program execution starts (as for languages like Rust and C++), it is known as
    *ahead-of-time compilation*, or just AOT. This technique is unusual in the Java
    space, but it aims to provide a faster startup time as programs do not need to
    be classloaded or JIT compiled. However, it does not generally give better peak
    performance than the same application would have when running in dynamic VM mode.
    This is because peak performance isn’t the point here. AOT and JIT represent different
    strategies and different tradeoffs.'
  prefs: []
  type: TYPE_NORMAL
- en: The current main effort to support native compiled Java is [Oracle’s GraalVM](https://oreil.ly/o9jNp).
    This was developed as a separate research project in Oracle Labs, but as of late
    2022, Oracle has announced plans to contribute parts of it to OpenJDK. It is available
    in two editions, an open-source edition and a proprietary Enterprise Edition,
    which has a licensing and support cost.
  prefs: []
  type: TYPE_NORMAL
- en: GraalVM contains a compiler called Graal that can operate in either JIT or AOT
    mode. The AOT mode of Graal is the basis of GraalVM’s Native Image technology
    that can produce a standalone, compiled machine code binary from a Java application.
    One interesting aspect of the Graal compiler is that it is written in Java, unlike
    the JIT compilers in OpenJDK, which are implemented in native code.
  prefs: []
  type: TYPE_NORMAL
- en: GraalVM also includes Truffle, an interpreter generating framework for languages
    on the JVM. Interpreters for supported languages, written on top of Truffle, are
    themselves Java programs that run on the JVM. Many non-Java languages are already
    available such as JavaScript, Python, Ruby, and R.
  prefs: []
  type: TYPE_NORMAL
- en: Another of the projects working on improving cloud-native support is [Quarkus](https://quarkus.io),
    a Java microservices framework designed for the Kubernetes cloud orchestration
    and deployment stack.1411.200 Quarkus attempts to reduce the impact of the cloud-native
    pain points by extensively using build-time processing. Expensive computations
    and startup that would normally be handled reflectively during startup are instead
    performed ahead of time wherever possible.
  prefs: []
  type: TYPE_NORMAL
- en: Quarkus also emphasizes developer experience and provides both reactive and
    imperative styles of programming microservices.
  prefs: []
  type: TYPE_NORMAL
- en: The framework is open source and production ready, and it has support available
    from Red Hat, which is the primary maintainer of the project. It also includes
    support for native compilation, based on the open-source edition of GraalVM. However,
    Quarkus can also be run in dynamic VM mode on top of an OpenJDK runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we should also mention Project Leyden. This is a new (May 2022) OpenJDK
    project that seeks to introduce *static runtime images* to the Java platform.
    The project name comes from a “Leyden jar,” a device from the 1700s used for storing
    static electrical charge. A key aspect of this is known as the *closed world*
    assumption that removes dynamic runtime behavior such as reflection.
  prefs: []
  type: TYPE_NORMAL
- en: The project is still in its early stages but is adopting a different (and more
    cautious) approach than GraalVM; a key goal of Leyden is to be able to selectively
    and flexibly constrain and shift dynamism. The intent is to evolve toward similar
    targets as the AOT-compiled native image binaries created by GraalVM, but as yet
    there are no indications when these techniques might appear in a production form
    of Java.
  prefs: []
  type: TYPE_NORMAL
