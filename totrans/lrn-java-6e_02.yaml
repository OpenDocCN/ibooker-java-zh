- en: Chapter 2\. A First Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before diving into our full discussion of the Java language, let’s get our feet
    wet with some working code and splash around a bit. In this chapter, we’ll build
    a friendly little application that illustrates many of the concepts used throughout
    the book. We’ll take this opportunity to introduce general features of the Java
    language and applications.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter also serves as a brief introduction to the object-oriented and
    multithreaded aspects of Java. If these concepts are new to you, we hope that
    encountering them here in Java for the first time will be a straightforward and
    pleasant experience. If you have worked with another object-oriented or multithreaded
    programming environment, you should especially appreciate Java’s simplicity and
    elegance. This chapter is intended only to give you a bird’s eye view of the Java
    language and a feel for how it is used. If you have trouble with any of the concepts
    introduced here, rest assured they will be covered in greater detail later in
    the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can’t stress enough the importance of experimentation as you learn new concepts
    here and throughout the book. Don’t just read the examples—run them. Where we
    can, we’ll show you how to use *jshell* (more on that in [“Trying Java”](ch03.html#learnjava6-CHP-3-SECT-6))
    to try things in real time. The source code for the examples in this book can
    be found on [GitHub](https://github.com/l0y/learnjava6e). Compile the programs
    and try them. Then, turn our examples into your examples: play with them, change
    their behavior, break them, fix them, and hopefully have some fun along the way.'
  prefs: []
  type: TYPE_NORMAL
- en: Java Tools and Environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although it’s possible to write, compile, and run Java applications with nothing
    more than Oracle’s open source Java Development Kit (OpenJDK) and a simple text
    editor (such as vi or Notepad), today the vast majority of Java code is written
    with the benefit of an Integrated Development Environment (IDE). The benefits
    of using an IDE include an all-in-one view of Java source code with syntax highlighting,
    navigation help, source control, integrated documentation, building, refactoring,
    and deployment all at your fingertips. Therefore, we are going to skip an academic
    command-line treatment and start with a popular, free IDE—IntelliJ IDEA CE (Community
    Edition). If you are adverse to using an IDE, feel free to use the command-line
    commands **`javac HelloJava.java`** for compilation and **`java HelloJava`** to
    run the upcoming examples.
  prefs: []
  type: TYPE_NORMAL
- en: IntelliJ IDEA requires Java to be installed. This book covers Java 21 language
    features, so although the examples in this chapter will work with older versions,
    it’s best to have JDK 21 installed to ensure that all examples in the book compile.
    (Java 19 does have all of the most important features available as well, although
    many are technically in “preview” mode.) The JDK includes several developer tools
    that we’ll discuss in [Chapter 3](ch03.html#learnjava6-CHP-3). You can check to
    see which version, if any, you have installed by typing **`java -version`** at
    the command line. If Java isn’t present, or if it’s a version older than JDK 19,
    you will want to install a newer version, as discussed in [“Installing the JDK”](#learnjava6-CHP-2-SECT-1.1).
    All you’ll need for the examples in this book is the basic JDK.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the JDK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It should be said at the outset that you are free to download and use the official,
    commercial [JDK from Oracle](https://oreil.ly/sYaZm) for personal use. The versions
    available on Oracle’s download page include the latest version and the most recent
    long-term support version (both are version 21 at the time of this writing), with
    links to older versions if legacy compatibility is something you must manage.
    Both Java 8 and Java 11, for example, remain workhorses on the backends of large
    organizations.
  prefs: []
  type: TYPE_NORMAL
- en: If you plan to use Java in any commercial or shared capacity, however, the Oracle
    JDK now comes with strict (and paid) licensing terms. For this and other more
    philosophical reasons, we primarily use the OpenJDK mentioned previously in [“Growing
    Up”](ch01.html#learnjava6-CHP-1-SECT-1.2). Regrettably, this open source version
    does not include installers for all the different platforms. Being open source,
    however, means other groups are welcome to step in and provide any missing pieces,
    and several OpenJDK installer-based packages do exist. Amazon has consistently
    released timely installers under the [Corretto](https://oreil.ly/W7noE) moniker.
    We’ll go through Corretto’s basic installation steps on Windows, Mac, and Linux
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: For those who want the latest release and don’t mind a little configuration
    work, you should take a look at installing the OpenJDK. While not as simple as
    using typical native installers, installing the OpenJDK on your chosen operating
    system is usually just a matter of uncompressing the downloaded file into a folder
    and making sure a few environment variables (`JAVA_HOME` and `PATH`) are correctly
    set. Regardless of which operating system you use, if you are going to use the
    OpenJDK, you’ll head to [Oracle’s OpenJDK download page](http://jdk.java.net).
    There they list the current releases as well as any early access versions that
    are available.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Corretto on Linux
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the popular Debain and Red Hat distros, you can download the appropriate
    file (*.deb* or *.rpm*, respectively) and use your usual package manager to install
    the JDK. The file for generic Linux systems is a compressed tar file (*tar.gz*)
    that can be unpacked in any shared directory of your choice. We’ll go through
    the steps to unpack and configure this compressed `tar` file since it works on
    most Linux distros. These steps use version 17 of Java, but they apply to all
    of the current and LTS Corretto downloads.
  prefs: []
  type: TYPE_NORMAL
- en: 'Decide where you want to install the JDK. We’ll store ours in */usr/lib/jvm*,
    but other distros might use other locations, such as */opt*, */usr/share*, or
    */usr/local*. If you will be the only one using Java on your system, you can even
    unpack the file under your home directory. Using your favorite terminal app, change
    to the directory where you downloaded the file and run the following commands
    to install Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that the first line of the version information ends with the `LTS`
    initials. This is an easy way to determine if you are using a long-term support
    version. With Java successfully unpacked, you can configure your terminal to use
    this version by setting the `JAVA_HOME` and `PATH` environment variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can test that this setup is working by checking the version of the Java
    using the `-version` flag, as shown in [Figure 2-1](#learnjava6-CHP-2-FIG-linux-java-version).
  prefs: []
  type: TYPE_NORMAL
- en: You’ll want to make those `JAVA_HOME` and `PATH` changes permanent by updating
    the startup or rc scripts for your shell. For example, if you use `bash` as your
    shell, you could add both of the `export` lines in [Figure 2-1](#learnjava6-CHP-2-FIG-linux-java-version)
    to your *.bashrc* file.
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 0201](assets/ljv6_0201.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-1\. Verifying your Java version in Linux
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Installing Corretto on macOS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For users on macOS systems, the [Corretto download](https://oreil.ly/W7noE)
    and installation process is straightforward. Select the version of the JDK you
    want to use, then select the *.pkg* link from the subsequent download page. Double-click
    the downloaded file to start the wizard.
  prefs: []
  type: TYPE_NORMAL
- en: The installation wizard shown in [Figure 2-2](#learnjava6-CHP-2-FIG-mac-corretto)
    does not allow much real customization. The JDK will be installed on the disk
    running macOS in its own folder under the */Library/Java/JavaVirtualMachines*
    directory. It will be symbolically linked to */usr/bin/java*. While you can select
    an alternate installation location if you have separate hard disks with macOS,
    the defaults work well for the purposes of this book.
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 0202](assets/ljv6_0202.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-2\. Corretto installation wizard in macOS
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: After you complete the installation, you can test Java by opening the *Terminal*
    app typically found in the *Utilities* folder under the global *Applications*
    folder. Type **`java -version`** and you should see output similar to [Figure 2-3](#learnjava6-CHP-2-FIG-mac-java-version).
    We installed version 19 on this system, but you should see whatever version you
    downloaded reflected in the output.
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 0203](assets/ljv6_0203.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-3\. Verifying your Java version in macOS
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Installing Corretto on Windows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Corretto installer for Windows (download the *.msi* file from [Amazon’s
    site](https://oreil.ly/W7noE)) follows typical Windows install wizards, as seen
    in [Figure 2-4](#learnjava6-CHP-2-FIG-corretto-win). You can accept the defaults
    as you go through the short prompts, or tweak things if you are familiar with
    administrative tasks, such as configuring environment variables and registry entries.
    If you are prompted to allow the installer to make changes to your system, go
    ahead and say yes.
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 0204](assets/ljv6_0204.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-4\. Corretto installation wizard in Windows
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Perhaps you don’t use a command line regularly in Windows, but the *Terminal*
    application in new versions of Windows (or *Command Prompt* application in older
    versions) serves the same purpose as similar apps in macOS or Linux. From your
    Windows menu, you can search for `term` or `cmd`, as shown in [Figure 2-5](#learnjava6-CHP-2-FIG-terminal-win).
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 0205](assets/ljv6_0205.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-5\. Locating a terminal application in Windows
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Click the appropriate result to start your terminal, and check for the version
    of Java by typing **`java -version`**. In our example, we were running version
    19; you should see something similar to [Figure 2-6](#learnjava6-CHP-2-FIG-java-version)
    but with your version number.
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 0206](assets/ljv6_0206.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-6\. Checking the Java version in Windows
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can continue using the terminal, of course, but now you are also free to
    point other applications such as IntelliJ IDEA at your installed JDK and simply
    work with those tools. And speaking of IntelliJ IDEA, let’s look at its installation
    steps in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Installing IntelliJ IDEA and Creating a Project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'IntelliJ IDEA is an IDE available at the [JetBrains website](https://oreil.ly/Lo9Xk).
    For the purposes of this book, and getting started with Java in general, the Community
    Edition is sufficient. The download is an executable installer or compressed archive:
    *.exe* for Windows, *.dmg* for macOS, and *.tar.gz* on Linux. The installers (and
    archives) all follow standard procedures and should feel familiar. If you want
    a little extra guidance, the [installation guide](https://oreil.ly/wjooh) on the
    JetBrains site is a great resource.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create a new project. Select File → New → Project from the application
    menu, and type **`Learning Java`** in the “Name” field at the top of the dialog,
    as shown in [Figure 2-7](#learnjava6-CHP-2-FIG-6). Select a JDK (version 19 or
    later will suffice) and make sure the “Add sample code” checkbox is selected.
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 0207](assets/ljv6_0207.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-7\. New Java project dialog
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You may notice the list of generators on the left side of the dialog. The default
    “New Project” is perfect for our needs. But you can start other projects with
    templates for things like Kotlin or Android. The default includes a minimal Java
    class with a `main()` method that can be executed. The coming chapters will go
    into much more detail about the structure of Java programs and the commands and
    statements you can place in those programs. With the default option selected on
    the left, go ahead and click the Create button. (If you notice a prompt to download
    shared indexes, go ahead and say yes. The shared indexes are not critical, but
    they will make IDEA run a little faster.) You should end up with a simple project
    that includes a *Main.java* file, as shown in [Figure 2-8](#learnjava6-CHP-2-FIG-7).
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 0208](assets/ljv6_0208.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-8\. The `Main` class in IDEA
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Congratulations! You now have a Java program. You’ll run this example and then
    expand on it to give it a little more flair. The coming chapters will present
    more interesting examples piecing together more and more elements of Java. We’ll
    always build these examples in a similar setup, though. These starting steps are
    good ones to get under your belt.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Starting from the simple template provided by IDEA should leave you in good
    shape to run your first program. Glance back at [Figure 2-8](#learnjava6-CHP-2-FIG-7).
    Notice the green triangles at lines 1 and 2 along the left side of the code editor,
    next to both the `Main` class as well as the `main()` method. IDEA understands
    that `Main` can be executed. You can click either of those buttons to run your
    code. (The `Main` class listed under the *src* folder in the project outline on
    the left has a tiny green “play” button as well.) You can right-click that class
    entry and select the `Run ‘Main.main()’` option, as shown in [Figure 2-9](#learnjava6-CHP-2-FIG-8).
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 0209](assets/ljv6_0209.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-9\. Running your Java project
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Whether you use the editor margin buttons or the context menu, go ahead and
    run your code now. You should see your “Hello World!” message show up in the Run
    tab along the bottom of the editor, similar to [Figure 2-10](#learnjava6-CHP-2-FIG-9).
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 0210](assets/ljv6_0210.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-10\. Our first output from a Java program
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: IDEs also include a handy terminal option. This allows you to open a tab or
    window that has a command prompt available. You may not need this option very
    often, but it can definitely come in handy. In IDEA, for example, you can open
    the terminal tab from the View → Tool Windows → Terminal menu option or by clicking
    the Terminal shortcut along the bottom of the main window, as shown in [Figure 2-11](#learnjava6-CHP-2-FIG-terminal-IDEA).
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 0211](assets/ljv6_0211.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-11\. The Terminal tab in IntelliJ IDEA
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In VS Code, you can use the Terminal → New Terminal menu option to pull up a
    similar portion of the IDE, as shown in [Figure 2-12](#learnjava6-CHP-2-FIG-terminal-VS).
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 0212](assets/ljv6_0212.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-12\. The Terminal tab in Microsoft’s VS Code
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Feel free to try out the terminal yourself. With a terminal window open in your
    IDE, navigate to the *Learning Java* folder. (Most IDEs will open the terminal
    at the base directory for your project automatically.) Use the *java* command
    to run our `Main` program, as shown in [Figure 2-13](#learnjava6-CHP-2-FIG-terminal-run).
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 0213](assets/ljv6_0213.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-13\. Running a Java program in a terminal tab
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Whichever route you chose, congratulations are due again—you have now run your
    first Java program!
  prefs: []
  type: TYPE_NORMAL
- en: Grabbing the Examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code examples and exercise solutions are available online at the book’s
    [GitHub repository](https://github.com/l0y/learnjava6e). GitHub has become the
    de facto cloud repository site for open source projects available to the public,
    as well as private, closed source projects. GitHub has many helpful tools beyond
    simple source-code storage and versioning. If you go on to develop an application
    or library that you want to share with others, it is worth setting up an account
    with GitHub and exploring it deeper. Happily, you can also just grab ZIP files
    of public projects without logging in, as shown in [Figure 2-14](#learnjava6-CHP-2-FIG-10).
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 0214](assets/ljv6_0214.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-14\. Downloading a ZIP file from GitHub
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You should get a file called *learnjava6e-main.zip* (since you are grabbing
    an archive of the “main” branch of this repository). If you’re familiar with GitHub
    from other projects, please feel free to clone the repository, but the static
    ZIP file contains everything you need to try the examples as you read through
    the rest of this book. When you unzip the download, you’ll find folders for all
    of the chapters that have examples as well as a completed *game* folder that contains
    a fun, lighthearted apple tossing game to help illustrate many of the programming
    concepts presented throughout the book in one cohesive application. We’ll go into
    more details on the examples and the game in coming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, you can compile and run the examples from the ZIP file
    right from the command line. You can also import the code into your favorite IDE.
    [Appendix A](app01.html#learnjava6-APP-A) contains detailed information on how
    to best import these examples into IntelliJ IDEA, but other popular IDEs such
    as Microsoft’s VS Code will also work.
  prefs: []
  type: TYPE_NORMAL
- en: HelloJava
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the tradition of introductory programming texts, we will begin with Java’s
    equivalent of the archetypal “Hello World” application, `HelloJava`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll end up taking a few passes at this example before we’re done (`HelloJava`,
    `HelloJava2`, etc.), adding features and introducing new concepts along the way.
    But let’s start with the minimalist version. Create a new file named *HelloJava.java*
    in your workspace. (If you are using IDEA, you can do this from the menus: File
    → New → Java Class. Then give it the name *HelloJava* with no suffix—the *.java*
    extension will be added to the filename automatically.) Go ahead and fill in the
    same `main()` method from the `Main` demo provided when creating the new project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This five-line program declares a class called `HelloJava` and that all-important
    `main()` method. It uses a predefined method called `println()` to write some
    text as output. This is a *command-line program*, which means that it runs in
    a terminal or DOS window and prints its output there. This approach is a bit old-school,
    so before we go any further, we’re going to give `HelloJava` a graphical user
    interface (GUI). Don’t worry about the code yet; just follow along with the progression
    here, and we’ll come back for explanations in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'In place of the line containing the `println()` method, we’re going to use
    a `JFrame` object to put a window on the screen. We can start by replacing the
    `println` line with the following three lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This snippet creates a `JFrame` object with the title “Hello, Java!” `JFrame`
    represents a graphical window. To display it, we simply configure its size on
    the screen using the `setSize()` method and make it visible by calling the `setVisible()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we stopped here, we would see an empty window on the screen with our “Hello,
    Java!” banner as its title. But we’d like our message inside the window, not just
    at the top. To put something in the window, we need a couple more lines. The following
    complete example adds a `JLabel` object to display the text centered in our window.
    The additional `import` line at the top is necessary to tell the Java compiler
    where to find the definitions of the `JFrame` and `JLabel` objects that we’re
    using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now, to compile and run this source, either right-click your *HelloJava.java*
    class from the package explorer along the left and use the context menu, or click
    one of the green arrows in the left margin of the editor. See [Figure 2-15](#learnjava6-CHP-2-FIG-11).
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 0215](assets/ljv6_0215.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-15\. Running the HelloJava application
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You should see the proclamation shown in [Figure 2-16](#learnjava6-CHP-2-FIG-12).
    Congratulations again, you have now run your second Java application! Take a moment
    to bask in the glow of your monitor.
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 0216](assets/ljv6_0216.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-16\. The output of the HelloJava application
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Be aware that when you click on the window’s close box, the window goes away,
    but your program is still running. (We’ll fix this shutdown behavior soon.) To
    stop the Java application in IDEA, click the red square “stop” button to the right
    of the green play button we used to run the program. If you are running the example
    on the command line, type Ctrl-C.
  prefs: []
  type: TYPE_NORMAL
- en: '`HelloJava` may be a small program, but there is quite a bit going on behind
    the scenes. Those few lines represent the tip of an impressive iceberg. What lies
    under the surface are the layers of functionality provided by the Java language
    and its Swing libraries. Remember that in this chapter, we’re going to cover a
    lot of ground quickly in an effort to show you the big picture. We’ll try to offer
    enough detail for a good understanding of what is happening in each example, but
    we’ll defer detailed explanations until the appropriate chapters. This holds for
    both elements of the Java language and the object-oriented concepts that apply
    to them. With that said, let’s take a look now at what’s going on in our first
    example.'
  prefs: []
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first example defines a class named `HelloJava`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Classes are the fundamental building blocks of most object-oriented languages.
    A *class* is a group of data items with associated functions that can perform
    operations on that data. The data items in a class are called *variables*, or
    sometimes *fields*; in Java, functions are called *methods*. The primary benefits
    of an object-oriented language are this association between data and functionality
    in class units and the ability of classes to *encapsulate* or hide details, freeing
    the developer from worrying about low-level details. We’ll expand on these benefits
    in [Chapter 5](ch05.html#learnjava6-CHP-5) where we fill out the structure of
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: In an application, a class might represent something concrete, such as a button
    on a screen or the information in a spreadsheet, or something more abstract, such
    as a sorting algorithm or perhaps the sense of ennui in a video game character.
    A class representing a spreadsheet might, for example, have variables that represent
    the values of its individual cells and methods that perform operations on those
    cells, such as “clear a row” or “compute values.”
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `HelloJava` class is an entire Java application in a single class. It defines
    just one method, `main()` , which holds the body of our program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It is this `main()` method that is called first when the application is started.
    The bit labeled `String [] args` allows us to pass *command-line arguments* to
    the application. We’ll walk through the `main()` method in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, although this version of `HelloJava` does not define any variables
    as part of its class, it does use two variables, `frame` and `label`, inside its
    `main()` method. We’ll have more to say about variables soon as well.
  prefs: []
  type: TYPE_NORMAL
- en: The main() Method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you saw when we ran our example, running a Java application means picking
    a particular class and passing its name as an argument to the Java virtual machine.
    When we did this, the `java` command looked in our `HelloJava` class to see if
    it contained the special method named `main()` with just the right form. It did,
    and the method was executed. If `main()` had not been there, we would have received
    an error message. The `main()` method is the entry point for applications. Every
    standalone Java application includes at least one class with a `main()` method
    that performs the necessary actions to start the rest of the program.
  prefs: []
  type: TYPE_NORMAL
- en: Our `main()` method sets up a window (a `JFrame`) to hold the visual output
    of the `HelloJava` class. Right now, `main()` is doing all the work in the application.
    But in an object-oriented application, we normally delegate responsibilities to
    many different classes. In the next incarnation of our example, we’re going to
    perform just such a split—creating a second class—and we’ll see that as the example
    subsequently evolves, the `main()` method remains more or less the same, simply
    holding the startup procedure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s quickly walk through our `main()` method, just so you know what it does.
    First, `main()` creates a `JFrame`, the window that will hold our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The word `new` in this line of code is very important. `JFrame` is the name
    of a class that represents a window on the screen, but the class itself is just
    a template, like a building plan. The `new` keyword tells Java to allocate memory
    and actually create a particular `JFrame` object. In this case, the argument inside
    the parentheses tells the `JFrame` what to display in its title bar. We could
    have left out the “Hello, Java!” text and used empty parentheses to create a `JFrame`
    with no title, but only because the `JFrame` specifically allows us to do that.
  prefs: []
  type: TYPE_NORMAL
- en: 'When frame windows are first created, they are very small. Before we show the
    `JFrame`, let’s set its size to something reasonable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an example of invoking a method on a particular object. In this case,
    the `setSize()` method is defined by the `JFrame` class, and it affects the particular
    `JFrame` object we’ve placed in the variable `frame`. Like the frame, we also
    create an instance of `JLabel` to hold our text inside the window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`JLabel` is much like a physical label. It holds some text at a particular
    position—in this case, on our frame. This is a very object-oriented concept: using
    an object to hold some text, instead of simply invoking a method to “draw” the
    text and moving on. The rationale for this will become clearer later.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have to place the label into the frame we created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we’re calling a method named `add()` to place our label inside the `JFrame`.
    The `JFrame` is a kind of container that can hold things. We’ll talk more about
    that later. `main()`’s final task is to show the frame window and its contents,
    which otherwise would be invisible. An invisible window makes for a pretty boring
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: That’s the whole `main()` method. As we progress through the examples in this
    chapter, it will remain mostly unchanged as the `HelloJava` class evolves around
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Classes and Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A class is a blueprint for a part of an application; it holds methods and variables
    that make up that component. Many individual working copies of a given class can
    exist while an application is active. These individual incarnations are called
    *instances* of the class, or *objects*. Two instances of a given class may contain
    different data, but they always have the same methods.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, consider a `Button` class. There is only one `Button` class,
    but an application can create many different `Button` objects, each one an instance
    of the same class. Furthermore, two `Button` instances might contain different
    data, perhaps giving each a different appearance and performing a different action.
    In this sense, a class can be considered a mold for making the object it represents,
    something like a cookie cutter stamping out working instances of itself in the
    memory of the computer. As you’ll see later, there’s a bit more to it than that—a
    class can in fact share information among its instances—but this explanation suffices
    for now. [Chapter 5](ch05.html#learnjava6-CHP-5) has the whole story on classes
    and objects.
  prefs: []
  type: TYPE_NORMAL
- en: The term *object* in Java is very general and is sometimes used almost interchangeably
    with *class*. Objects are the abstract entities that all object-oriented languages
    refer to in one form or another. We will use *object* as a generic term for an
    instance of a class. We might, therefore, refer to an instance of the `Button`
    class as a button, a `Button` object, or, indiscriminately, as an object. You
    will see the term used frequently in the coming chapters, and [Chapter 5](ch05.html#learnjava6-CHP-5)
    will go into much more detail on both classes and objects.
  prefs: []
  type: TYPE_NORMAL
- en: The `main()` method in the previous example creates a single instance of the
    `JLabel` class and shows it in an instance of the `JFrame` class. You could modify
    `main()` to create many instances of `JLabel`, perhaps each in a separate window.
  prefs: []
  type: TYPE_NORMAL
- en: Variables and Class Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Java, every class defines a new *type* (data type). You can declare a variable
    of this type and then it can hold instances of that class. A variable could, for
    example, be of type `Button` and hold an instance of the `Button` class, or of
    type `SpreadSheetCell` and hold a `SpreadSheetCell` object, just as it could be
    any of the simpler types, such as `int` or `char`. The fact that variables have
    types and cannot simply hold any kind of object is another important feature of
    Java that ensures the safety and correctness of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting aside the variables used inside the `main()` method for the moment,
    only one other variable is declared in our simple `HelloJava` example. It’s found
    in the declaration of the `main()` method itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Just like functions in other languages, a method in Java declares a list of
    *parameters* (variables) that it accepts as *arguments*, and it specifies the
    types of those parameters. In this case, the main `method` is requiring that when
    it is invoked, it be passed an array of `String` objects in the variable named
    `args`. The `String` is the fundamental object representing text in Java. As we
    hinted at earlier, Java uses the `args` parameter to pass any command-line arguments
    supplied to the Java virtual machine into your application. (We don’t use them
    here, but we will later.)
  prefs: []
  type: TYPE_NORMAL
- en: Up to this point, we have loosely talked about variables as holding objects.
    In reality, variables that have class types don’t hold objects—they refer to them.
    A *reference* is a pointer to or a handle for an object. If you declare a class-type
    variable without assigning it an object, it doesn’t point to anything. It’s assigned
    the default value of `null`, meaning “no value.” If you try to use a variable
    with a null value as if it were pointing to a real object, a runtime error, `NullPointerException`,
    occurs.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, object references have to come from somewhere. In our example, we
    created two objects using the `new` operator. We’ll examine object creation in
    more detail a little later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: HelloComponent
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Thus far, our `HelloJava` example has contained itself in a single class. In
    fact, because of its simple nature, it has really just served as a single, large
    method. Although we have used a couple of objects to display our GUI message,
    our own code does not illustrate any object-oriented structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, we’re going to correct that right now by adding a second class. To give
    us something to build on throughout this chapter, we’re going to take over the
    job of the `JLabel` class (bye-bye, `JLabel`!) and replace it with our own graphical
    class: `HelloComponent`. Our `HelloComponent` class will start simple, just displaying
    our “Hello, Java!” message at a fixed position. We’ll add capabilities later.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for our new class is simple; we only need a few more lines. First
    we need another `import` statement at the top of the *HelloJava.java* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This line tells the compiler where to find the extra classes we need to fill
    out the logic of `HelloComponent`. And here’s that logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `HelloComponent` class definition can go either above or below our `HelloJava`
    class. Then, to use our new class in place of the `JLabel`, simply replace the
    two lines referencing the label in the `main()` method with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This time when you compile *HelloJava.java*, take a look at the generated *.class*
    files. (These files will be located in either your current directory if you are
    using a terminal or in the *Learn Java/out/production/Learn Java* folder where
    you chose to put IDEA projects. In IDEA itself, you can also expand the *out*
    folder in the project navigation pane on the left side.) Regardless of how you
    arranged the classes in your source, you should see two binary class files: *HelloJava.class*
    and *HelloComponent.class*. Running the code should look much like the `JLabel`
    version, but if you resize the window, you’ll notice that our new component does
    not automatically adjust to center the text.'
  prefs: []
  type: TYPE_NORMAL
- en: So what have we done, and why have we gone to such lengths to insult the perfectly
    good `JLabel` component? We’ve created our new `HelloComponent` class, extending
    a generic graphical class called `JComponent`. To *extend* a class simply means
    to add functionality to an existing class, creating a new one. We’ll get into
    that process more in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: In our current example, we have created a new kind of `JComponent` that contains
    a method called `paintComponent()`, which is responsible for drawing our message.
    The `paintComponent()` method takes one argument named (somewhat tersely) `g`,
    which is of type `Graphics`. When the `paintComponent()` method is invoked, a
    `Graphics` object is assigned to `g`, which we use in the body of the method.
    We’ll say more about `paintComponent()` and the `Graphics` class in a moment.
    As for why, you’ll understand when we add all sorts of new features to our new
    component later on.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Java classes are arranged in a parent-child hierarchy in which the parent and
    child are known as the *superclass* and *subclass*, respectively. We’ll explore
    these concepts more in [Chapter 5](ch05.html#learnjava6-CHP-5). In Java, every
    class has exactly one superclass (a single parent), but possibly many subclasses.
    The only exception to this rule is the `Object` class, which sits atop the entire
    class hierarchy; it has no superclass. (Feel free to peek ahead at the tiny slice
    of the Java class hierarchy shown in [Figure 2-17](#learnjava6-CHP-2-FIG-class-hierarchy).)
  prefs: []
  type: TYPE_NORMAL
- en: 'The declaration of our class in the previous example uses the keyword `extends`
    to specify that `HelloComponent` is a subclass of the `JComponent` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: A subclass may *inherit* some or all of the variables and methods of its superclass.
    Inheritance provides the subclass access to the variables and methods of its superclass
    as if it has declared them itself. A subclass can add variables and methods of
    its own, and it can also *override* or change the meaning of inherited methods.
    When we use a subclass, overridden methods are hidden (replaced) by the subclass’s
    own versions of them. In this way, inheritance provides a powerful mechanism whereby
    a subclass can refine or extend the functionality of its superclass.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the hypothetical spreadsheet class might be subclassed to produce
    a new scientific spreadsheet class with special built-in constants. In this case,
    the source code for the scientific spreadsheet might declare variables for the
    special constants, but the new scientific class still has all of the variables
    (and methods) that constitute the normal functionality of a spreadsheet. Again,
    those standard elements are inherited from the parent spreadsheet class. This
    also means that the scientific spreadsheet maintains its identity as a spreadsheet;
    it can still do everything the simpler spreadsheet could do. That idea, that a
    more specific class can still perform all of the duties of a more general parent
    or ancestor, has profound implications. We call this idea *polymorphism*, and
    we’ll continue to explore it throughout the book. Polymorphism is one of the foundations
    of object-oriented programming.
  prefs: []
  type: TYPE_NORMAL
- en: Our `HelloComponent` class is a subclass of the `JComponent` class and inherits
    many variables and methods not explicitly declared in our source code. This is
    what allows our tiny class to serve as a component in a `JFrame`, with just a
    few customizations.
  prefs: []
  type: TYPE_NORMAL
- en: The JComponent Class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `JComponent` class provides the framework for building all kinds of UI components.
    Particular components—such as buttons, labels, and list boxes—are implemented
    as subclasses of `JComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: We mentioned that subclasses can take an inherited method and override it to
    implement some particular behavior. But why would we want to change the behavior
    of something that presumably already works for the superclass? Many classes start
    with minimal functionality. The original programmers expect someone else to come
    along and add the interesting parts. `JComponent` is just such a class. It handles
    a great deal of the communication with the computer’s windowing system for you,
    but it leaves room for you to add the specific details of presentation and behavior.
  prefs: []
  type: TYPE_NORMAL
- en: The `paintComponent()` method is an important method of the `JComponent` class;
    we override it to implement the way our particular component displays itself on
    the screen. The default behavior of `paintComponent()` doesn’t do any drawing
    at all. If we hadn’t overridden it in our subclass, our component would simply
    have been empty. Here, we’re overriding `paintComponent()` to do something only
    slightly more interesting. We don’t override any of the other inherited members
    of `JComponent` because they provide basic functionality and reasonable defaults
    for this (trivial) example. As `HelloJava` grows, we’ll delve deeper into the
    inherited members and use additional methods. We will also add some application-specific
    methods and variables specifically for the needs of `HelloComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: '`JComponent` is really the tip of another iceberg called Swing. Swing is Java’s
    UI toolkit, represented in our example by the `import` statement at the top; we’ll
    discuss Swing in more detail in [Chapter 12](ch12.html#learnjava6-CHP-12).'
  prefs: []
  type: TYPE_NORMAL
- en: Relationships and Finger-Pointing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can think of subclassing as creating an “is a” relationship, in which the
    subclass “is a” kind of its superclass. `HelloComponent` is therefore a kind of
    `JComponent`. When we refer to a kind of object, we mean *any instance of that
    object’s class or any of its subclasses*. Later, we will look more closely at
    the Java class hierarchy and see that `JComponent` is itself a subclass of the
    `Container` class, which is further derived from a class called `Component`, and
    so on, as shown in [Figure 2-17](#learnjava6-CHP-2-FIG-class-hierarchy).
  prefs: []
  type: TYPE_NORMAL
- en: In this sense, a `HelloComponent` object is a kind of `JComponent`, which is
    a kind of `Container`, and all of these can ultimately be considered to be a kind
    of `Component`. It’s from these classes that `HelloComponent` inherits its basic
    GUI functionality and (as we’ll discuss later) the ability to have other graphical
    components embedded within it as well.
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 0217](assets/ljv6_0217.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-17\. Part of the Java class hierarchy
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`Component` is a subclass of the top-level `Object` class, so all these classes
    are types of `Object`. Every other class in the Java API inherits behavior from
    `Object`, which defines a few basic methods, as you’ll see in [Chapter 5](ch05.html#learnjava6-CHP-5).
    We’ll continue to use the word *object* (lowercase *o*) in a generic way to refer
    to an instance of any class; we’ll use `Object` to refer specifically to the type
    of that class.'
  prefs: []
  type: TYPE_NORMAL
- en: Packages and Imports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We mentioned earlier that the first line of our example tells Java where to
    find some of the classes that we’ve been using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Specifically, it tells the compiler that we are going to be using classes from
    the Swing GUI toolkit (in this case, `JFrame`, `JLabel`, and `JComponent`). These
    classes are organized into a Java *package* called `javax.swing`. In Java, a package
    is a group of classes that are related by purpose or by application. Classes in
    the same package have special access privileges with respect to one another and
    may be designed to work together closely.
  prefs: []
  type: TYPE_NORMAL
- en: 'Packages are named in a hierarchical fashion with dot-separated components,
    such as `java.util` and `java.util.zip`. Classes in a package typically live in
    nested folders matching their package name. They also take on the name of the
    package as part of their “full name” or, to use the proper terminology, their
    *fully qualified name*. For example, the fully qualified name of the `JComponent`
    class is `javax.swing.JComponent`. We could have referred to it by that name directly,
    in lieu of using the `import` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Using fully qualified names can get tiresome. The statement `import javax.swing.*`
    enables us to refer to all the classes in the `javax.swing` package by their simple
    names. We don’t have to use fully qualified names to refer to the `JComponent`,
    `JLabel`, and `JFrame` classes.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw when we added our second example class, there may be one or more `import`
    statements in a given Java source file. The `import`s effectively create a “search
    path” that tells Java where to look for classes that we refer to by their simple,
    unqualified names. (It’s not really a path, but it avoids ambiguous names that
    can create errors.) The `import`s we’ve seen use the dot star (`.*`) notation
    to indicate that the entire package should be imported. But you can also specify
    just a single class. For example, our current example uses only the `Graphics`
    class from the `java.awt` package. We could have used `import java.awt.Graphics`
    instead of using the wildcard `*` to import all the Abstract Window Toolkit (AWT)
    package’s classes. However, we are anticipating using several more classes from
    this package later.
  prefs: []
  type: TYPE_NORMAL
- en: The `java.` and `javax.` package hierarchies are special. Any package that begins
    with `java.` is part of the core Java API and is available on any platform that
    supports Java. The `javax.` package normally denotes a standard extension to the
    core platform, which may or may not be installed. However, in recent years, many
    standard extensions have been added to the core Java API without renaming them.
    The `javax.swing` package is an example; it is part of the core API in spite of
    its name. [Figure 2-18](#learnjava6-CHP-2-FIG-core-packages) illustrates some
    of the core Java packages, showing a representative class or two from each.
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 0218](assets/ljv6_0218.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-18\. Some core Java packages
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`java.lang` contains fundamental classes needed by the Java language itself;
    this package is imported automatically, and that is why we didn’t need an `import`
    statement to use class names such as `String` or `System` in our examples. The
    `java.awt` package contains classes of the older, graphical windowing system;
    `java.net` contains the networking classes; and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: As you gain more experience with Java, you will realize that having a command
    of the packages available to you, what they do, and when and how to use them is
    a critical part of becoming a successful Java developer.
  prefs: []
  type: TYPE_NORMAL
- en: The paintComponent() Method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The source for our `HelloComponent` class defines a method, `paintComponent()`,
    that overrides the `paintComponent()` method of the `JComponent` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `paintComponent()` method is called when it’s time for our example to draw
    itself on the screen. It takes a single argument, a `Graphics` object, and doesn’t
    return any type of value (`void`) to its caller.
  prefs: []
  type: TYPE_NORMAL
- en: '*Modifiers* are keywords placed before classes, variables, and methods to alter
    their accessibility, behavior, or semantics. Here `paintComponent()` is declared
    as `public`, which means it can be invoked (called) by methods in classes other
    than `HelloComponent`. In this case, it’s the Java windowing environment that
    is calling our `paintComponent()` method. A method or variable declared as `private`,
    by contrast, is accessible only from its own class.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Graphics` object, an instance of the `Graphics` class, represents a particular
    graphical drawing area. (It is also called a *graphics context*.) It contains
    methods that can be used to draw in this area, and variables that represent characteristics
    such as clipping or drawing modes. The particular `Graphics` object we are passed
    in the `paintComponent()` method corresponds to our `HelloComponent`’s area of
    the screen, inside our frame.
  prefs: []
  type: TYPE_NORMAL
- en: The `Graphics` class provides methods for rendering shapes, images, and text.
    In `HelloComponent`, we invoke the `drawString()` method of our `Graphics` object
    to scrawl our message at the specified coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we’ve seen earlier, we access a method of an object by appending a dot (`.`)
    and its name to the object that holds it. We invoked the `drawString()` method
    of the `Graphics` object (referenced by our `g` variable) in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we can see how overriding an inherited method provides new functionality.
    On its own, an instance of `JComponent` has no idea what information to show the
    user or how to respond to things like mouse clicks. We extended `JComponent` and
    added a tiny bit of custom logic: we show a bit of text on the screen. But we
    can do much more!'
  prefs: []
  type: TYPE_NORMAL
- en: 'HelloJava2: The Sequel'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we’ve got some basics down, let’s make our application a little more
    interactive. The following minor upgrade allows us to drag the message text around
    with the mouse. If you’re new to programming, though, the upgrade may not seem
    so minor. Fear not! We will look closely at all of the topics covered in this
    example in later chapters. For now, enjoy playing with the example and use it
    as an opportunity to get more comfortable creating and running Java programs,
    even if you don’t feel as comfortable with the code inside.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll call this example `HelloJava2` rather than cause confusion by continuing
    to expand the old one, but the primary changes here and further on lie in adding
    capabilities to the `HelloComponent` class and simply making the corresponding
    changes to the names to keep them straight (e.g., `HelloComponent2`, `HelloComponent3`,
    and so on). Having just seen inheritance at work, you might wonder why we aren’t
    creating a subclass of `HelloComponent` and exploiting inheritance to build upon
    our previous example and extend its functionality. Well, in this case, that would
    not provide much advantage, so for clarity we simply start over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two slashes in a row indicate that the rest of the line is a comment. We’ve
    added a few comments to `HelloJava2` to help you keep track of everything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If you are using IDEA, create a new Java class named *HelloJava2* and copy the
    code above. If you are sticking with the terminal, place the text of this example
    in a new file called *HelloJava2.java*. Either way, you want to compile it as
    before. You should get new class files, *HelloJava2.class* and *HelloComponent2.class*,
    as a result.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are following in IDEA, click the Run button next to `HelloJava2`. If
    you are using a terminal, run the example using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Feel free to substitute your own victorious comment for the “Hello, Java!” message
    and enjoy many hours of fun, dragging the text around with your mouse. Notice
    that now when you click the window’s close button, the application exits properly;
    we’ll explain that later when we talk about events. Let’s dive in and see what
    has changed.
  prefs: []
  type: TYPE_NORMAL
- en: Instance Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have added some variables to the `HelloComponent2` class in our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '`messageX` and `messageY` are integers that hold the current coordinates of
    our movable message. We have set them to default values that should place the
    message roughly near the center of the window. Java integers are 32-bit signed
    numbers, so they can easily hold our coordinate values. The variable `theMessage`
    is of type `String` and can hold instances of the `String` class.'
  prefs: []
  type: TYPE_NORMAL
- en: You should note that these three variables are declared inside the braces of
    the class definition but not inside any particular method in that class. These
    variables are called *instance* variables, and they belong to the object as a
    whole. Specifically, separate copies of them appear in each separate instance
    of the class. Instance variables are always visible to (and usable by) all the
    methods inside their class. Depending on their modifiers, they may also be accessible
    from outside the class.
  prefs: []
  type: TYPE_NORMAL
- en: Unless otherwise initialized (programmer jargon for setting the first value
    on something), instance variables are set to a default value of `0`, `false`,
    or `null`, depending on their type. Numeric types are set to `0`, Boolean variables
    are set to `false`, and class type variables always have their value set to `null`.
  prefs: []
  type: TYPE_NORMAL
- en: Instance variables differ from method arguments and other variables that are
    declared inside the scope of a particular method. The latter are called *local*
    variables. They are effectively private variables that can be seen only by code
    inside a method or other code block. Java doesn’t initialize local variables,
    so you must assign values yourself. If you try to use a local variable that has
    not yet been assigned a value, your code generates a compile-time error. Local
    variables live only as long as the method is executing and then disappear, unless
    something else saves their value. Each time the method is invoked, its local variables
    are recreated and must be assigned values.
  prefs: []
  type: TYPE_NORMAL
- en: We have used the new variables to make our previously stodgy `paintComponent()`
    method more dynamic. Now all the arguments in the call to `drawString()` are determined
    by these variables.
  prefs: []
  type: TYPE_NORMAL
- en: Constructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `HelloComponent2` class includes a special kind of a method called a *constructor*.
    A constructor is called to set up a new instance of a class. When a new object
    is created, Java allocates storage for it, sets instance variables to their default
    values, and calls the constructor method for the class to do whatever application-level
    setup is required.
  prefs: []
  type: TYPE_NORMAL
- en: A constructor always has the same name as its class. For example, the constructor
    for the `HelloComponent2` class is called `HelloComponent2()`. Constructors don’t
    have a return type, but you can think of them as creating an object of their class’s
    type. Like other methods, constructors can have parameters. Their sole mission
    in life is to configure and initialize newly born class instances, possibly using
    information passed to them in these parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'An object is created with the `new` operator specifying the constructor for
    the class and any necessary arguments.^([1](ch02.html#id787)) The resulting object
    instance is returned as a value. In our example, a new `HelloComponent2` instance
    is created in the `main()` method by this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This line actually does two things. To make that clearer, we could write them
    as two separate lines that are a little easier to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The first line is the important one, where a new `HelloComponent2` object is
    created. The `HelloComponent2` constructor takes a `String` as an argument and,
    as we have arranged things, uses that argument to set the message that is displayed
    in the window. With a little magic from the Java compiler, quoted text in Java
    source code is turned into a `String` object. (See [Chapter 8](ch08.html#learnjava6-CHP-8)
    for a deeper discussion of the `String` class.) The second line simply adds our
    new component to the frame to make it visible, as we did in the previous examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'While we’re on the topic, if you’d like to make our message configurable, you
    can change the constructor call to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can pass the text on the command line when you run the application
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '`args[0]` refers to the first command-line parameter. Its meaning will become
    clearer when we discuss arrays in [Chapter 4](ch04.html#learnjava6-CHP-4). If
    you are using an IDE, you will need to configure it to accept your parameters
    before running it. IntelliJ IDEA has something called a *run configuration* that
    you can edit from the same menus that pop up when you click the green play buttons.
    The run configuration has a number of options, but our interest is in the text
    field for “Program Arguments,” as shown in [Figure 2-19](#learnjava6-CHP-2-FIG-15).
    Note that on both the command line and in the IDE, you must enclose your phrase
    in double quotes to make sure the text is considered one argument. If you leave
    off the quotes, `Hello,` and `Java!` would be two separate arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 0219](assets/ljv6_0219.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-19\. IDEA dialog for giving command-line parameters
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`HelloComponent2`’s constructor then does two things: it sets the text of `theMessage`
    instance variable and calls `addMouseMotionListener()`. This method is part of
    the event mechanism, which we’ll discuss next. It tells the system, “Hey, I’m
    interested in anything that happens involving mouse motion”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The special, read-only variable called `this` is used to explicitly refer to
    our object (the “current” object context) in the call to `addMouseMotionListener()`.
    A method can use `this` to refer to the instance of the object that holds it.
    The following two statements are therefore equivalent ways of assigning the value
    to `theMessage` instance variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We’ll normally use the shorter, implicit form to refer to instance variables,
    but we’ll need `this` when we have to explicitly pass a reference to our object
    to a method in another class. We often pass such references so that methods in
    other classes can invoke our public methods or use our public variables.
  prefs: []
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last two methods of `HelloComponent2`, `mouseDragged()` and `mouseMoved()`,
    tell Java to pass along any information it might get from the mouse. Each time
    the user performs an action, such as pressing a key on the keyboard, moving the
    mouse, or perhaps banging their head against a touch screen, Java generates an
    *event*. An event represents an action that has occurred; it contains information
    about the action, such as its time and location. Most events are associated with
    a particular GUI component in an application. A keystroke, for instance, can correspond
    to a character being typed into a particular text entry field. Clicking a mouse
    button can activate a particular button on the screen. Even just moving the mouse
    within a certain area of the screen can trigger effects such as highlighting text
    or changing the cursor’s shape.
  prefs: []
  type: TYPE_NORMAL
- en: To work with these events, we’ve imported a new package, `java.awt.event`, which
    provides specific `Event` objects that we use to get information from the user.
    (Notice that importing `java.awt.*` doesn’t automatically import the `event` package.
    Imports are not recursive. Packages don’t really contain other packages, even
    if the hierarchical naming scheme would imply that they do.)
  prefs: []
  type: TYPE_NORMAL
- en: There are dozens of event classes, including `MouseEvent`, `KeyEvent`, and `Action​E⁠vent`.
    For the most part, the meaning of these events is fairly intuitive. A `MouseEvent`
    occurs when the user does something with the mouse, a `KeyEvent` occurs when the
    user presses or releases a key, and so on. `ActionEvent` is a little special;
    we’ll see it at work in [Chapter 12](ch12.html#learnjava6-CHP-12). For now, we’ll
    focus on dealing with `MouseEvent`s.
  prefs: []
  type: TYPE_NORMAL
- en: GUI components in Java generate events for specific kinds of user actions. For
    example, if you click the mouse inside a component, the component generates a
    mouse event. Objects can ask to receive the events from one or more components
    by registering a *listener* with the event source. For example, to declare that
    a listener wants to receive a component’s mouse-motion events, you invoke that
    component’s `addMouseMotionListener()` method, specifying the listener object
    as an argument. That’s what our example is doing in its constructor. In this case,
    the component is calling its own `addMouseMotionListener()` method, with the argument
    `this`, meaning “I want to receive my own mouse-motion events.”
  prefs: []
  type: TYPE_NORMAL
- en: That’s how we register to receive events. But how do we actually get them? That’s
    what the two mouse-related methods in our class are for. The `mouseDragged()`
    method is called automatically on a listener to receive the events generated when
    the user drags the mouse—that is, moves the mouse with any button clicked. The
    `mouseMoved()` method is called whenever the user moves the mouse over the area
    without clicking a button.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we’ve placed these methods in our `HelloComponent2` class and
    had it register itself as the listener. This is entirely appropriate for our new
    text-dragging component. More generally, good design usually dictates that event
    listeners be implemented as *adapter classes* that provide better separation of
    GUI and “business logic.” An adapter class is a convenient intermediate class
    that implements all of the methods of an interface with some default behavior.
    We’ll discuss events, listeners, and adapters in detail in [Chapter 12](ch12.html#learnjava6-CHP-12).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `mouseMoved()` method is boring: it doesn’t do anything. We ignore simple
    mouse motions and reserve our attention for dragging. But we have to supply some
    kind of implementation—even an empty one—since the `MouseMotionListener` interface
    includes it. Our `mouseDragged()` method, on the other hand, has some meat to
    it. This method is called repeatedly by the windowing system to give us updates
    on the position of the mouse as the user drags it around. Here it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The lone parameter to `mouseDragged()` is a `MouseEvent` object, `e`, that contains
    all the information we need to know about this event. We ask the `MouseEvent`
    to tell us the `x` and `y` coordinates of the mouse’s current position by calling
    its `getX()` and `getY()` methods. We save these in the `messageX` and `messageY`
    instance variables for use elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: The beauty of the event model is that you have to handle only the kinds of events
    you want. If you don’t care about keyboard events, you just don’t register a listener
    for them; the user can type all they want and you won’t be bothered. If there
    are no listeners for a particular kind of event, Java won’t even generate it.
    The result is that event handling is quite efficient.^([2](ch02.html#id805))
  prefs: []
  type: TYPE_NORMAL
- en: 'While we’re discussing events, we should mention another small addition we
    slipped into `HelloJava2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This line tells the frame to exit the application when its Close button is clicked.
    It’s called the “default” close operation because this operation, like almost
    every other GUI interaction, is governed by events. We could register a window
    listener to be notified when the user clicks on the Close button and take whatever
    action we like, but this convenience method handles the common cases.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we’ve danced around a couple of other questions here. How does the
    system know that our class contains the necessary `mouseDragged()` and `mouseMoved()`
    methods? Where do these names come from? And why do we have to supply a `mouseMoved()`
    method that doesn’t do anything? The answer to these questions has to do with
    interfaces. We’ll touch on interfaces after clearing up some unfinished business
    with `repaint()`.
  prefs: []
  type: TYPE_NORMAL
- en: The repaint() Method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because we change the coordinates for the message when we drag the mouse, we
    would like `HelloComponent2` to redraw itself. We do this by calling `repaint()`,
    which asks the system to redraw the screen at a later time. We can’t call `paintComponent()`
    directly, even if we wanted to, because we don’t have a graphics context to pass
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the `repaint()` method of the `JComponent` class to request that
    our component be redrawn. `repaint()` causes the Java windowing system to schedule
    a call to our `paintComponent()` method at the next possible time; Java supplies
    the necessary `Graphics` object, as shown in [Figure 2-20](#learnjava6-CHP-2-FIG-16).
  prefs: []
  type: TYPE_NORMAL
- en: '![ljv6 0220](assets/ljv6_0220.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-20\. Invoking the `repaint()` method
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This mode of operation isn’t just an inconvenience brought about by not having
    the right graphics context handy. Its biggest advantage is that the repainting
    behavior is handled by something else, while we are free to go about our business.
    The Java system has a separate, dedicated thread of execution that handles all
    `repaint()` requests. It can schedule and consolidate `repaint()` requests as
    necessary, which helps to prevent the windowing system from being overwhelmed
    during painting-intensive situations like scrolling. Another advantage is that
    all the painting functionality must be encapsulated through our `paintComponent()`
    method; we aren’t tempted to spread it throughout the application (which could
    make maintenance difficult).
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now it’s time to tackle some of the questions we avoided earlier: how does
    the system know to call `mouseDragged()` when a mouse event occurs? Is it simply
    a matter of knowing that `mouseDragged()` is some magic name that our event-handling
    method must have? Not quite; the answer touches on the discussion of interfaces,
    which are one of the most important features of the Java language.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first sign of an interface comes on the line of code that introduces the
    `HelloComponent2` class. We say that the class *implements* the `MouseMotionListener`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Essentially, an *interface* is a list of methods that the class must have; this
    particular interface requires our class to have methods called `mouseDragged()`
    and `mouseMoved()`. The interface doesn’t say what these methods have to do; indeed,
    our `mouseMoved()` doesn’t do anything at all. It does say that the methods must
    take a `MouseEvent` as an argument and return no value (that’s what `void` means).
  prefs: []
  type: TYPE_NORMAL
- en: An interface is a contract between you, the code developer, and the compiler.
    By saying that your class implements the `MouseMotionListener` interface, you’re
    saying that these methods will be available for other parts of the system to call.
    If you don’t provide them, a compilation error will occur. That’s why we need
    a `mouseMoved()` method; even though the one we supplied doesn’t do anything,
    the `MouseMotionListener` interface says we must have one.
  prefs: []
  type: TYPE_NORMAL
- en: The Java distribution comes with many interfaces that define what classes have
    to do. This idea of a contract between the compiler and a class is very important.
    There are many situations like the one we just saw where you don’t care what class
    something is; you just care that it has some capability, such as listening for
    mouse events. Interfaces give us a way of acting on objects based on their capabilities
    without knowing or caring about their actual type. They are a tremendously important
    concept in how we use Java as an object-oriented language. We’ll talk about them
    in detail in [Chapter 5](ch05.html#learnjava6-CHP-5).
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 5](ch05.html#learnjava6-CHP-5) also discusses how interfaces provide
    a sort of escape clause to the Java rule that any new class can extend only a
    single class (“single inheritance”). A class in Java can extend only one class
    but can implement as many interfaces as it wants. Interfaces can be used as data
    types, can extend other interfaces (but not classes), and can be inherited by
    classes (if class A implements interface B, subclasses of A also implement B).
    The crucial difference is that classes don’t actually inherit methods from interfaces;
    the interfaces merely specify the methods the class must have.'
  prefs: []
  type: TYPE_NORMAL
- en: Goodbye and Hello Again
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well, it’s time to say goodbye to `HelloJava`. We hope that you have developed
    a feel for some of the features of the Java language and the basics of writing
    and running a Java program. This brief introduction should help you as you explore
    the details of programming with Java. If you are a bit bewildered by some of the
    material presented here, take heart. We’ll be covering all the major topics presented
    here again in their own chapters throughout the book. This tutorial was meant
    to be something of a “trial by fire” to get the important concepts and terminology
    into your brain so that the next time you hear them you’ll have a head start.
  prefs: []
  type: TYPE_NORMAL
- en: We will be getting to know the tools of the Java world better in the next chapter.
    We’ll see details on the commands we have already introduced, such as *javac*,
    as well as go over other important utilities. Read on to say hello to several
    of your new best friends as a Java developer!
  prefs: []
  type: TYPE_NORMAL
- en: Review Questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are a few review questions to make sure you caught the key topics in this
    chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What command do you use to compile a Java source file?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does the JVM know where to start when you run a Java class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you extend more than one class when creating a new class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you implement more than one interface when creating a new class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which class represents the main window in a graphical application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Code Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: And for your first programming exercise,^([3](ch02.html#id817)) create a `GoodbyeJava`
    class that works just like the first HelloJava program from [“Running the Project”](#learnjava6-CHP-2-SECT-1.3),
    but displays the message “Goodbye, Java!” instead. Try either the command-line
    version or the graphical version—or both! Feel free to copy as much of the original
    program as you like. Be sure to compile and run your `GoodbyeJava` class to help
    practice the process of executing a Java application. You will certainly get more
    practice along the way, but gathering a little more familiarity with either your
    IDE or the *javac* and *java* commands now will help as you read the next several
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch02.html#id787-marker)) The terms *parameter* and *argument* often get
    used interchangeably. That’s mostly fine, but technically you provide parameters
    with a type and a name when defining methods or constructors. You supply arguments
    to fill those parameters when you call the method or constructor.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch02.html#id805-marker)) Event handling in Java 1.0 was a very different
    story. Early on, Java did not have a notion of event listeners, and all event
    handling happened by overriding methods in base GUI classes. This was inefficient
    and led to poor design, with a proliferation of highly specialized components.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch02.html#id817-marker)) You can find the solutions to the programming
    challenges from each chapter in the *exercises* folder of the source code. [Appendix A](app01.html#learnjava6-APP-A)
    contains details on downloading and using the source code. [Appendix B](app02.html#learnjava6-APP-B)
    contains answers to the end-of-chapter questions as well as hints on code solutions
    for each chapter.
  prefs: []
  type: TYPE_NORMAL
