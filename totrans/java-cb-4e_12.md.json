["```java\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <netdb.h>\n#include <stdio.h>\n#include <string.h>\n#include <fcntl.h>\n\nint\nmain(int argc, char *argv[])\n{\n    char* server_name = \"localhost\";\n    struct hostent *host_info;\n    int sock;\n    struct sockaddr_in server;\n\n    /* Look up the remote host's IP address */\n    host_info = gethostbyname(server_name);\n    if (host_info == NULL) {\n        fprintf(stderr, \"%s: unknown host: %s\\n\", argv[0], server_name);\n        exit(1);\n    }\n\n    /* Create the socket */\n    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        perror(\"creating client socket\");\n        exit(2);\n    }\n\n    /* Set up the server's socket address */\n    server.sin_family = AF_INET;\n    memcpy((char *)&server.sin_addr, host_info->h_addr,\n                     host_info->h_length);\n    server.sin_port = htons(80);\n\n    /* Connect to the server */\n    if (connect(sock,(struct sockaddr *)&server,sizeof server) < 0) {\n        perror(\"connecting to server\");\n        exit(4);\n    }\n\n    /* Finally, we can read and write on the socket. */\n    /* ... */\n\n    (void) close(sock);\n}\n```", "```java\nhttps://suggestqueries.google.com/complete/search?client=firefox&q=\n```", "```java\n        // This object would be kept for the life of an application\n        HttpClient client = HttpClient.newBuilder()\n            .followRedirects(Redirect.NORMAL)\n            .version(Version.HTTP_1_1)\n            .build();\n\n        // Build the HttpRequest object to \"GET\" the urlString\n        HttpRequest req =\n            HttpRequest.newBuilder(URI.create(urlString +\n                URLEncoder.encode(keyword)))\n            .header(\"User-Agent\", \"Dept of Silly Walks\")\n            .GET()\n            .build();\n```", "```java\n        // Send the request - synchronously\n        HttpResponse<String> resp =\n            client.send(req, BodyHandlers.ofString());\n\n        // Collect the results\n        if (resp.statusCode() == 200) {\n            String response = resp.body();\n            System.out.println(response);\n        } else {\n            System.out.printf(\"ERROR: Status %d on request %s\\n\",\n                resp.statusCode(), urlString);\n        }\n```", "```java\n        // Send the request - asynchronously\n        client.sendAsync(req, BodyHandlers.ofString())\n            .thenApply(HttpResponse::body)\n            .thenAccept(System.out::println)\n            .join();\n```", "```java\n$ java HttpClientDemo.java\n[\"darwin\",[\"darwin thompson\",\"darwin\",\"darwin awards\",\"darwinism\",\n \"darwin australia\",\"darwin thompson fantasy\",\"darwin barney\",\n \"darwin theory\",\"darwinai\",\"darwin dormitorio\"]]\n```", "```java\npublic class RestClientURLDemo {\n    public static void main(String[] args) throws Exception {\n        URLConnection conn = new URL(\n            HttpClientDemo.urlString + HttpClientDemo.keyword)\n            .openConnection();\n        try (BufferedReader is =\n            new BufferedReader(new InputStreamReader(conn.getInputStream()))) {\n\n            String line;\n            while ((line = is.readLine()) != null) {\n                System.out.println(line);\n            }\n        }\n    }\n}\n```", "```java\nimport java.net.Socket;\n\n/* Client with NO error handling */\npublic class ConnectSimple {\n\n    public static void main(String[] argv) throws Exception {\n\n        try (Socket sock = new Socket(\"localhost\", 8080)) {\n\n            /* If we get here, we can read and write on the socket \"sock\" */\n            System.out.println(\" *** Connected OK ***\");\n\n            /* Do some I/O here... */\n\n        }\n    }\n}\n```", "```java\npublic class InetAddrDemo {\n    public static void main(String[] args) throws IOException {\n        String hostName = \"darwinsys.com\";\n        String ipNumber = \"8.8.8.8\"; // currently a well-known Google DNS server\n\n        // Show getting the InetAddress (looking up a host) by host name\n        System.out.println(hostName + \"'s address is \" +\n            InetAddress.getByName(hostName).getHostAddress());\n\n        // Look up a host by address\n        System.out.println(ipNumber + \"'s name is \" +\n            InetAddress.getByName(ipNumber).getHostName());\n\n        // Look up my localhost addresss\n        final InetAddress localHost = InetAddress.getLocalHost();\n        System.out.println(\"My localhost address is \" + localHost);\n\n        // Show getting the InetAddress from an open Socket\n        String someServerName = \"google.com\";\n        // assuming there's a web server on the named server:\n        try (Socket theSocket = new Socket(someServerName, 80)) {\n            InetAddress remote = theSocket.getInetAddress();\n            System.out.printf(\"The InetAddress for %s is %s%n\",\n                someServerName, remote);\n        }\n    }\n}\n```", "```java\nInetAddress remote = theSocket.getInetAddress( );\nSocket anotherSocket = new Socket(remote, myPortNumber);\n```", "```java\npublic class ConnectFriendly {\n    public static void main(String[] argv) {\n        String server_name = argv.length == 1 ? argv[0] : \"localhost\";\n        int tcp_port = 80;\n        try (Socket sock = new Socket(server_name, tcp_port)) {\n\n            /* If we get here, we can read and write on the socket. */\n            System.out.println(\" *** Connected to \" + server_name  + \" ***\");\n\n            /* Do some I/O here... */\n\n        } catch (UnknownHostException e) {\n            System.err.println(server_name + \" Unknown host\");\n            return;\n        } catch (NoRouteToHostException e) {\n            System.err.println(server_name + \" Unreachable\" );\n            return;\n        } catch (ConnectException e) {\n            System.err.println(server_name + \" connect refused\");\n            return;\n        } catch (java.io.IOException e) {\n            System.err.println(server_name + ' ' + e.getMessage());\n            return;\n        }\n    }\n}\n```", "```java\nBufferedReader is = new BufferedReader(\n    new InputStreamReader(sock.getInputStream( )));\nPrintWriter os = new PrintWriter(sock.getOutputStream( ), true);\n```", "```java\nC:\\javasrc\\network>date \nCurrent date is Sun 01-23-2000\nEnter new date (mm-dd-yy):\nC:\\javasrc\\network>time\nCurrent time is  1:13:18.70p\nEnter new time:\nC:\\javasrc\\network>java network.DaytimeText darian\nTime on darian is Sun Jan 23 13:14:34 2000\n```", "```java\npublic class DaytimeText {\n    public static final short TIME_PORT = 13;\n\n    public static void main(String[] argv) {\n        String server_name = argv.length == 1 ? argv[0] : \"localhost\";\n\n        try (Socket sock = new Socket(server_name,TIME_PORT);\n            BufferedReader is = new BufferedReader(new\n                InputStreamReader(sock.getInputStream()));) {\n            String remoteTime = is.readLine();\n            System.out.println(\"Time on \" + server_name + \" is \" + remoteTime);\n        } catch (IOException e) {\n            System.err.println(e);\n        }\n    }\n}\n```", "```java\npublic class EchoClientOneLine {\n    /** What we send across the net */\n    String mesg = \"Hello across the net\";\n\n    public static void main(String[] argv) {\n        if (argv.length == 0)\n            new EchoClientOneLine().converse(\"localhost\");\n        else\n            new EchoClientOneLine().converse(argv[0]);\n    }\n\n    /** Hold one conversation across the net */\n    protected void converse(String hostName) {\n        try (Socket sock = new Socket(hostName, 7);) { // echo server.\n            BufferedReader is = new BufferedReader(new\n                InputStreamReader(sock.getInputStream()));\n            PrintWriter os = new PrintWriter(sock.getOutputStream(), true);\n            // Do the CRLF ourself since println appends only a \\r on\n            // platforms where that is the native line ending.\n            os.print(mesg + \"\\r\\n\"); os.flush();\n            String reply = is.readLine();\n            System.out.println(\"Sent \\\"\" + mesg  + \"\\\"\");\n            System.out.println(\"Got  \\\"\" + reply + \"\\\"\");\n        } catch (IOException e) {\n            System.err.println(e);\n        }\n    }\n}\n```", "```java\nDataInputStream is = new DataInputStream(sock.getInputStream());\nDataOutputStream is = new DataOutputStream(sock.getOutputStream( ));\n```", "```java\nDataInputStream is = new DataInputStream(\n    new BufferedInputStream(sock.getInputStream( )));\nDataOutputStream is = new DataOutputStream(\n    new BufferedOutputStream(sock.getOutputStream( )));\n```", "```java\n$ date\nThu Dec 26 09:48:36 EST 2019\njava network.RDateClient aragorn\nRemote time is 3786360519\nBASE_DIFF is 2208988800\nTime diff == 1577371719\nTime on aragorn is 2019-12-26T09:48:39\nLocal date/time = 2019-12-26T09:48:41.208180\n$\n```", "```java\npublic class RDateClient {\n    /** The TCP port for the binary time service. */\n    public static final short TIME_PORT = 37;\n    /** Seconds between 1970, the time base for dates and times\n * Factors in leap years (up to 2100), hours, minutes, and seconds.\n * Subtract 1 day for 1900, add in 1/2 day for 1969/1970.\n */\n    protected static final long BASE_DAYS =\n        (long)((1970-1900)*365 + (1970-1900-1)/4);\n\n    /* Seconds since 1970 */\n    public static final long BASE_DIFF = (BASE_DAYS * 24 * 60 * 60);\n\n    public static void main(String[] argv) {\n        String hostName;\n        if (argv.length == 0)\n            hostName = \"localhost\";\n        else\n            hostName = argv[0];\n\n        try (Socket sock = new Socket(hostName,TIME_PORT);) {\n            DataInputStream is = new DataInputStream(new\n                BufferedInputStream(sock.getInputStream()));\n            // Read 4 bytes from the network, unsigned.\n            // Do it yourself; there is no readUnsignedInt().\n            // Long is 8 bytes on Java, but we are using the\n            // existing time protocol, which uses 4-byte ints.\n            long remoteTime = (\n                ((long)(is.readUnsignedByte()) << 24) |\n                ((long)(is.readUnsignedByte()) << 16) |\n                ((long)(is.readUnsignedByte()) <<  8) |\n                ((long)(is.readUnsignedByte()) <<  0));\n            System.out.println(\"Remote time is \" + remoteTime);\n            System.out.println(\"BASE_DIFF is \" + BASE_DIFF);\n            System.out.println(\"Time diff == \" + (remoteTime - BASE_DIFF));\n            Instant time = Instant.ofEpochSecond(remoteTime - BASE_DIFF);\n            LocalDateTime d = LocalDateTime.ofInstant(time, ZoneId.systemDefault());\n            System.out.println(\"Time on \" + hostName + \" is \" + d.toString());\n            System.out.println(\"Local date/time = \" + LocalDateTime.now());\n        } catch (IOException e) {\n            System.err.println(e);\n        }\n    }\n}\n```", "```java\n        try (Socket sock = new Socket(hostName, TIME_PORT);) {\n            ObjectInputStream is = new ObjectInputStream(new\n                BufferedInputStream(sock.getInputStream()));\n\n            // Read and validate the Object\n            Object o = is.readObject();\n            if (o == null) {\n                System.err.println(\"Read null from server!\");\n            } else if ((o instanceof LocalDateTime)) {\n\n                // Valid, so cast to LocalDateTime, and print\n                LocalDateTime d = (LocalDateTime) o;\n                System.out.println(\"Time on \" + hostName + \" is \" + d);\n            } else {\n                throw new IllegalArgumentException(\n                    String.format(\"Wanted LocalDateTime, got %s, a %s\",\n                        o, o.getClass()));\n            }\n```", "```java\n$ date\nThu Dec 26 09:29:02 EST 2019\nC:\\javasrc\\network>java network.DaytimeObject aragorn\nTime on aragorn is 2019-12-26T09:29:05.227397\nC:\\javasrc\\network>\n```", "```java\npublic class DaytimeUDP {\n    /** The UDP port number */\n    public final static int DAYTIME_PORT = 13;\n\n    /** A buffer plenty big enough for the date string */\n    protected final static int PACKET_SIZE = 100;\n\n    /** The main program that drives this network client.\n * @param argv[0] hostname, running daytime/udp server\n */\n    public static void main(String[] argv) throws IOException {\n        if (argv.length < 1) {\n            System.err.println(\"usage: java DayTimeUDP host\");\n            System.exit(1);\n        }\n        String host = argv[0];\n        InetAddress servAddr = InetAddress.getByName(host);\n        DatagramSocket sock = new DatagramSocket();\n        //sock.connect(servAddr, DAYTIME_PORT);\n        byte[] buffer = new byte[PACKET_SIZE];\n\n        // The udp packet we will send and receive\n        DatagramPacket packet = new DatagramPacket(\n            buffer, PACKET_SIZE, servAddr, DAYTIME_PORT);\n\n        /* Send empty max-length (-1 for null byte) packet to server */\n        packet.setLength(PACKET_SIZE-1);\n        sock.send(packet);\n        System.out.println(\"Sent request\");\n\n        // Receive a packet and print it.\n        sock.receive(packet);\n        System.out.println(\"Got packet of size \" + packet.getLength());\n        System.out.print(\"Date on \" + host + \" is \" +\n            new String(buffer, 0, packet.getLength()));\n\n        sock.close();\n    }\n}\n```", "```java\n$\n$ java network.DaytimeUDP aragorn\nSent request\nGot packet of size 26\nDate on aragorn is Sat Feb  8 20:22:12 2014\n$\n```", "```java\nURL x = new URL(theURI.toString( ));\n```", "```java\npublic class URIDemo {\n    public static void main(String[] args)\n    throws URISyntaxException, MalformedURLException {\n\n        URI u = new URI(\"https://darwinsys.com/java/../openbsd/../index.jsp\");\n        System.out.println(\"Raw: \" + u);\n        URI normalized = u.normalize();\n        System.out.println(\"Normalized: \" + normalized);\n        final URI BASE = new URI(\"https://darwinsys.com\");\n        System.out.println(\"Relativized to \" + BASE + \": \" + BASE.relativize(u));\n\n        // A URL is a type of URI\n        URL url = new URL(normalized.toString());\n        System.out.println(\"URL: \" + url);\n\n        // Demo of non-URL but valid URI\n        URI uri = new URI(\"bean:WonderBean\");\n        System.out.println(uri);\n    }\n}\n```", "```java\npublic class RemCat {\n    /** The UDP port number */\n    public final static int TFTP_PORT = 69;\n    /** The mode we will use - octet for everything. */\n    protected final String MODE = \"octet\";\n\n    /** The offset for the code/response as a byte */\n    protected final int OFFSET_REQUEST = 1;\n    /** The offset for the packet number as a byte */\n    protected final int OFFSET_PACKETNUM = 3;\n\n    /** Debugging flag */\n    protected static boolean debug = false;\n\n    /** TFTP op-code for a read request */\n    public final int OP_RRQ = 1;\n    /** TFTP op-code for a read request */\n    public final int OP_WRQ = 2;\n    /** TFTP op-code for a read request */\n    public final int OP_DATA = 3;\n    /** TFTP op-code for a read request */\n    public final int OP_ACK    = 4;\n    /** TFTP op-code for a read request */\n    public final int OP_ERROR = 5;\n\n    protected final static int PACKET_SIZE = 516;    // == 2 + 2 + 512\n    protected String host;\n    protected InetAddress servAddr;\n    protected DatagramSocket sock;\n    protected byte buffer[];\n    protected DatagramPacket inp, outp;\n\n    /** The main program that drives this network client.\n * @param argv[0] hostname, running TFTP server\n * @param argv[1..n] filename(s), must be at least one\n */\n    public static void main(String[] argv) throws IOException {\n        if (argv.length < 2) {\n            System.err.println(\"usage: rcat host filename[...]\");\n            System.exit(1);\n        }\n        if (debug)\n            System.err.println(\"Java RemCat starting\");\n        RemCat rc = new RemCat(argv[0]);\n        for (int i = 1; i<argv.length; i++) {\n            if (debug)\n                System.err.println(\"-- Starting file \" +\n                    argv[0] + \":\" + argv[i] + \"---\");\n            rc.readFile(argv[i]);\n        }\n    }\n\n    RemCat(String host) throws IOException {\n        super();\n        this.host = host;\n        servAddr = InetAddress.getByName(host);\n        sock = new DatagramSocket();\n        buffer = new byte[PACKET_SIZE];\n        outp = new DatagramPacket(buffer, PACKET_SIZE, servAddr, TFTP_PORT);\n        inp = new DatagramPacket(buffer, PACKET_SIZE);\n    }\n\n    /* Build a TFTP Read Request packet. This is messy because the\n * fields have variable length. Numbers must be in\n * network order, too; fortunately Java just seems\n * naturally smart enough :-) to use network byte order.\n */\n    void readFile(String path) throws IOException {\n        buffer[0] = 0;\n        buffer[OFFSET_REQUEST] = OP_RRQ;        // read request\n        int p = 2;            // number of chars into buffer\n\n        // Convert filename String to bytes in buffer , using \"p\" as an\n        // offset indicator to get all the bits of this request\n        // in exactly the right spot.\n        byte[] bTemp = path.getBytes();    // i.e., ASCII\n        System.arraycopy(bTemp, 0, buffer, p, path.length());\n        p += path.length();\n        buffer[p++] = 0;        // null byte terminates string\n\n        // Similarly, convert MODE (\"stream\" or \"octet\") to bytes in buffer\n        bTemp = MODE.getBytes();    // i.e., ASCII\n        System.arraycopy(bTemp, 0, buffer, p, MODE.length());\n        p += MODE.length();\n        buffer[p++] = 0;        // null terminate\n\n        /* Send Read Request to tftp server */\n        outp.setLength(p);\n        sock.send(outp);\n\n        /* Loop reading data packets from the server until a short\n * packet arrives; this indicates the end of the file.\n */\n        do {\n            sock.receive(inp);\n            if (debug)\n                System.err.println(\n                    \"Packet # \" + Byte.toString(buffer[OFFSET_PACKETNUM])+\n                    \"RESPONSE CODE \" + Byte.toString(buffer[OFFSET_REQUEST]));\n            if (buffer[OFFSET_REQUEST] == OP_ERROR) {\n                System.err.println(\"rcat ERROR: \" +\n                    new String(buffer, 4, inp.getLength()-4));\n                return;\n            }\n            if (debug)\n                System.err.println(\"Got packet of size \" +\n                    inp.getLength());\n\n            /* Print the data from the packet */\n            System.out.write(buffer, 4, inp.getLength()-4);\n\n            /* Ack the packet. The block number we\n * want to ack is already in buffer so\n * we just change the opcode. The ACK is\n * sent to the port number which the server\n * just sent the data from, NOT to port\n * TFTP_PORT.\n */\n            buffer[OFFSET_REQUEST] = OP_ACK;\n            outp.setLength(4);\n            outp.setPort(inp.getPort());\n            sock.send(outp);\n        } while (inp.getLength() == PACKET_SIZE);\n\n        if (debug)\n            System.err.println(\"** ALL DONE** Leaving loop, last size \" +\n                inp.getLength());\n    }\n}\n```", "```java\ntftp dgram udp wait root /usr/libexec/tftpd tftpd -s /tftpboot\n```", "```java\n$ java network.RemCat localhost foo\n```", "```java\n$ java network.RemCat localhost foo | diff - /tftpboot/foo\n```", "```java\n$ java network.RemCat localhost nosuchfile \nremcat ERROR: File not found\n$\n```", "```java\npublic class ChatClient extends JFrame {\n\n    private static final long serialVersionUID = -3686334002367908392L;\n    private static final String userName =\n        System.getProperty(\"user.name\", \"User With No Name\");\n    /** The state of logged-in-ness */\n    protected boolean loggedIn;\n    /* The main Frame. */\n    protected JFrame cp;\n    /** The default port number */\n    protected static final int PORTNUM = ChatProtocol.PORTNUM;\n    /** The actual port number */\n    protected int port;\n    /** The network socket */\n    protected Socket sock;\n    /** PrintWriter for sending lines on socket */\n    protected PrintWriter pw;\n    /** TextField for input */\n    protected JTextField tf;\n    /** TextArea to display conversations */\n    protected JTextArea ta;\n    /** The Login Button */\n    protected JButton loginButton;\n    /** The LogOUT button */\n    protected JButton logoutButton;\n    /** The TitleBar title */\n    final static String TITLE = \"ChatClient: Ian Darwin's Chat Room Client\";\n\n    final Executor threadPool = Executors.newSingleThreadExecutor();\n\n    /** set up the GUI */\n    public ChatClient() {\n        cp = this;\n        cp.setTitle(TITLE);\n        cp.setLayout(new BorderLayout());\n        port = PORTNUM;\n\n        // The GUI\n        ta = new JTextArea(14, 80);\n        ta.setEditable(false);        // readonly\n        ta.setFont(new Font(\"Monospaced\", Font.PLAIN, 11));\n        cp.add(BorderLayout.NORTH, ta);\n\n        JPanel p = new JPanel();\n\n        // The login button\n        p.add(loginButton = new JButton(\"Login\"));\n        loginButton.setEnabled(true);\n        loginButton.requestFocus();\n        loginButton.addActionListener(e -> {\n                login();\n                loginButton.setEnabled(false);\n                logoutButton.setEnabled(true);\n                tf.requestFocus();    // set keyboard focus in right place!\n        });\n\n        // The logout button\n        p.add(logoutButton = new JButton(\"Logout\"));\n        logoutButton.setEnabled(false);\n        logoutButton.addActionListener(e -> {\n                logout();\n                loginButton.setEnabled(true);\n                logoutButton.setEnabled(false);\n                loginButton.requestFocus();\n        });\n\n        p.add(new JLabel(\"Message here:\"));\n        tf = new JTextField(40);\n        tf.addActionListener(e -> {\n                if (loggedIn) {\n                    pw.println(ChatProtocol.CMD_BCAST+tf.getText());\n                    tf.setText(\"\");\n                }\n        });\n        p.add(tf);\n\n        cp.add(BorderLayout.SOUTH, p);\n\n        cp.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        cp.pack();\n    }\n\n    protected String serverHost = \"localhost\";\n\n    /** LOG ME IN TO THE CHAT */\n    public void login() {\n        /** BufferedReader for reading from socket */\n        BufferedReader is;\n\n        showStatus(\"In login!\");\n        if (loggedIn)\n            return;\n        try {\n            sock = new Socket(serverHost, port);\n            is = new BufferedReader(new InputStreamReader(sock.getInputStream()));\n            pw = new PrintWriter(sock.getOutputStream(), true);\n            showStatus(\"Got socket\");\n\n            // FAKE LOGIN FOR NOW - no password needed\n            pw.println(ChatProtocol.CMD_LOGIN + userName);\n\n            loggedIn = true;\n\n        } catch(IOException e) {\n            warn(\"Can't get socket to \" +\n                serverHost + \"/\" + port + \": \" + e);\n            cp.add(new JLabel(\"Can't get socket: \" + e));\n            return;\n        }\n\n        // Construct and start the reader: from server to textarea.\n        // Make a Thread to avoid lockups.\n        Runnable readerThread = new Runnable() {\n            public void run() {\n                String line;\n                try {\n                    while (loggedIn && ((line = is.readLine()) != null))\n                        ta.append(line + \"\\n\");\n                } catch(IOException e) {\n                    showStatus(\"Lost another client!\\n\" + e);\n                    return;\n                }\n            }\n        };\n        threadPool.execute(readerThread);\n    }\n\n    /** Log me out, Scotty, there's no intelligent life here! */\n    public void logout() {\n        if (!loggedIn)\n            return;\n        loggedIn = false;\n        try {\n            if (sock != null)\n                sock.close();\n        } catch (IOException ign) {\n            // so what?\n        }\n    }\n\n    public void showStatus(String message) {\n        System.out.println(message);\n    }\n\n    private void warn(String message) {\n        JOptionPane.showMessageDialog(this, message);\n    }\n\n    /** A main method to allow the client to be run as an Application */\n    public static void main(String[] args) {\n        ChatClient room101 = new ChatClient();\n        room101.pack();\n        room101.setVisible(true);\n    }\n}\n```", "```java\n    /**\n * Check one HTTP link; not recursive. Returns a LinkStatus with\n * boolean success, and the filename or an error message in the\n * message part of the LinkStatus.  The end of this method is one of\n * the few places where a whole raft of different \"catch\" clauses is\n * actually needed for the intent of the program.\n * @param urlString the link to check\n * @return the link's status\n */\n    @SuppressWarnings(\"exports\")\n    public LinkStatus check(String urlString) {\n        try {\n            HttpResponse<String> resp = client.send(\n                HttpRequest.newBuilder(URI.create(urlString))\n                .header(\"User-Agent\", getClass().getName())\n                .GET()\n                .build(),\n                BodyHandlers.ofString());\n\n            // Collect the results\n            if (resp.statusCode() == 200) {\n                System.out.println(resp.body());\n            } else {\n                System.out.printf(\"ERROR: Status %d on request %s\\n\",\n                    resp.statusCode(), urlString);\n            }\n\n            switch (resp.statusCode()) {\n            case 200:\n                return new LinkStatus(true, urlString);\n            case 403:\n                return new LinkStatus(false,\"403: \" + urlString );\n            case 404:\n                return new LinkStatus(false,\"404: \" + urlString );\n            }\n            return new LinkStatus(true, urlString);\n        } catch (IllegalArgumentException | MalformedURLException e) {\n            // JDK throws IAE if host can't be determined from URL string\n            return new LinkStatus(false, \"Malformed URL: \" + urlString);\n        } catch (UnknownHostException e) {\n            return new LinkStatus(false, \"Host invalid/dead: \" + urlString);\n        } catch (FileNotFoundException e) {\n            return new LinkStatus(false,\"NOT FOUND (404) \" + urlString);\n        } catch (ConnectException e) {\n            return new LinkStatus(false, \"Server not listening: \" + urlString);\n        } catch (SocketException e) {\n            return new LinkStatus(false, e + \": \" + urlString);\n        } catch (IOException e) {\n            return new LinkStatus(false, e.toString()); // includes failing URL\n        } catch (Exception e) {\n            return new LinkStatus(false, urlString + \": \" + e);\n        }\n    }\n```"]