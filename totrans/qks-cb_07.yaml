- en: Chapter 7\. Persistence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The underlying persistence strategies used by Quarkus should already be familiar
    to you. Transactions, datasources, Java Persistence API (JPA), and so on are all
    standards that have existed for many years. Quarkus uses these and, in some cases,
    builds on top of them to make working with persistent stores easier. In this chapter,
    you will learn about working with persistent stores in Quarkus. We cover both
    traditional relational database management systems (RDBMS) and NoSQL databases.
  prefs: []
  type: TYPE_NORMAL
- en: Quarkus has some additional gems if you’re using a traditional RDBMS or MongoDB
    in the form a Panache, an opinionated, entity or active record type API. Panache
    simplifies much of the standard JPA syntax, making your application easier to
    read and maintain—again, helping you to be more productive!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you’ll learn how to accomplish the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Configure datasources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deal with transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage database schema migrations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make use of the Panache API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interact with NoSQL data stores
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.1 Defining a Datasource
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to define and use a datasource.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the Agroal extension and *application.properties*.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Agroal is the preferred datasource and connection pooling implementation in
    Quarkus. The Agroal extension has integrations with security, transaction management,
    and health metrics. While it does have its own extension, if you are using Hibernate
    ORM or Panache, the Agroal extension is pulled in transitively. You will also
    need a database driver extension. Currently, H2, PostgreSQL, MariaDB, MySQL, Microsoft
    SQL Server, and Derby all have supported extensions. You can add the correct database
    driver with the Maven `add-extension`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Configuration for the datasource, just like all the other configurations for
    Quarkus, is done in the *src/main/resources/application.properties* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Sensitive data can be passed via system properties, environment properties,
    Kubernetes Secrets, or Vault, as you will see in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Should you need access to the datasource, you can inject it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can also use the `AgroalDataSource` type, which is a subtype of `DataSource`.
  prefs: []
  type: TYPE_NORMAL
- en: 7.2 Using Multiple Datasources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to use multiple datasources when more than one datasource is necessary
    for your application.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use named datasources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Agroal allows for multiple datasources. They are configured exactly the same
    as the default, with one noteable exception—a name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The format is as follows: `quarkus.*datasource*.[*optional name*.][*datasource
    property*]`.'
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Injection works identically; however, you will need a qualifier (please see
    [Recipe 5.10](ch05.xhtml#named_qualifier) for more information about qualifiers):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 7.3 Adding Datasource Health Check
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to add a health check entry for the datasource(s).
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use both the `quarkus-agroal` and `quarkus-smallrye-health` extensions.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The health check for datasources is automatically added when the `quarkus-smallrye-health`
    extension is in use. It can be disabled, if desired, with the `quarkus.datasource.health.enabled`
    (default to `true`) property in *application.properties*. To view the status,
    access the */health/ready* endpoint of your application. That endpoint is created
    from the `quarkus-smallrye-health` extension.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information, visit the following page on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[MicroProfile Health](https://oreil.ly/CDLOd)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.4 Defining Transaction Boundaries Declaratively
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to define a transaction boundary using annotations.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `@javax.transaction.Transactional` annotation from the `quarkus-narayana-jta`
    extension.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `quarkus-narayana-jta` extension adds in the `@javax.transaction.Transactional`
    annotations, as well as the `TransactionManager` and `UserTransaction` classes.
    This extension is automatically added by any persistence extensions. Of course,
    this can be added manually if needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@Transactional` annotation can be added to any CDI bean at the method
    or class level to make those methods transactional—this also includes REST endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 7.5 Setting a Transaction Context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want a different transaction context.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `value` attribute on `@Transactional` allows the scope to be set for the
    transaction.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The transaction context specified is propagated to all nested calls within
    the method that has been annotated. Unless a runtime exception is thrown in the
    stack, the transaction will commit at the end of the method call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is overridable with the `dontRollbackOn` or `rollbackOn` attributes of
    `@⁠T⁠r⁠a⁠n⁠s​a⁠c⁠t⁠i⁠o⁠n⁠a⁠l`. You can also inject the `TransactionManager` if
    you need to manually roll back a transaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of available transactional contexts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Transactional(REQUIRED)` (default)'
  prefs: []
  type: TYPE_NORMAL
- en: Starts a transaction if none was started; otherwise, stays with the existing
    one
  prefs: []
  type: TYPE_NORMAL
- en: '`@Transactional(REQUIRES_NEW)`'
  prefs: []
  type: TYPE_NORMAL
- en: Starts a transaction if none was started; if an existing one was started, suspends
    it and starts a new one for the boundary of that method
  prefs: []
  type: TYPE_NORMAL
- en: '`@Transactional(MANDATORY)`'
  prefs: []
  type: TYPE_NORMAL
- en: Fails if no transaction was started; otherwise, works within the existing transaction
  prefs: []
  type: TYPE_NORMAL
- en: '`@Transactional(SUPPORTS)`'
  prefs: []
  type: TYPE_NORMAL
- en: If a transaction was started, joins it; otherwise, works with no transaction
  prefs: []
  type: TYPE_NORMAL
- en: '`@Transactional(NOT_SUPPORTED)`'
  prefs: []
  type: TYPE_NORMAL
- en: If a transaction was started, suspends it and works with no transaction for
    the boundary of the method; otherwise, works with no transaction
  prefs: []
  type: TYPE_NORMAL
- en: '`@Transactional(NEVER)`'
  prefs: []
  type: TYPE_NORMAL
- en: If a transaction was started, raises an exception; otherwise, works with no
    transaction
  prefs: []
  type: TYPE_NORMAL
- en: 7.6 Programmatic Transaction Control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want more fine-grained control over transactions.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Inject the `UserTransaction` and use the methods of that class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `UserTransaction` class has a very simple API:'
  prefs: []
  type: TYPE_NORMAL
- en: '`begin()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`commit()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rollback()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setRollbackOnly()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getStatus()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setTransactionTimeout(int)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first three methods will be the main methods used. `getStatus()` is useful
    in determining where the transaction is in its life cycle. Lastly, you are able
    to set the timeout for a transaction.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If needed, you can also use the `javax.transaction.TransactionManager` by injecting
    it.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information, visit the following web page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Jakarta EE 8 Specification APIs: Interface UserTransaction](https://oreil.ly/lmjR_)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.7 Setting and Modifying a Transaction Timeout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want a transaction to time out and roll back after a certain amount of time.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `@io.quarkus.narayana.jta.runtime.TransactionConfiguration` annotation
    if using declarative transactions; otherwise, the transaction API can be used
    for programmatic transaction control. You can also change the global timeout for
    transactions with the `quarkus.transaction-manager.default-transaction-timeout`
    property, specified as a `java.time.Duration`.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the timeout of a transaction for a one-off is very easy with the `@TransactionConfiguration`
    annotation. Use the `timeout` attribute to set the number of seconds for the timeout.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Should every transaction in the application need a longer or shorter time, use
    the `quarkus.transaction-manager.default-transaction-timeout` property in *application.properties*.
    That property takes a `java.time.Duration`, which can be specified as a string
    parsable via `Duration#parse()`. You may also start the duration with an integer.
    Quarkus will then automatically prepend `PT` to the value to create the correct
    formatting.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information, visit the following website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Oracle: Java Platform, Standard Edition 8 API Specification: `parse`](https://oreil.ly/8gvMZ)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.8 Setup with Persistence.xml
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to use JPA with a *persistence.xml* file.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use JPA like you normally would; just set up the datasource in *application.properties*.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JPA in Quarkus works exactly as it does in other settings, so there no changes
    are necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You cannot use the `quarkus.hibernate-orm.*` properties if you are using *persistence.xml*.
    If you are, only the persistence units defined in the *persistence.xml* file will
    be available.
  prefs: []
  type: TYPE_NORMAL
- en: 7.9 Setup Without persistence.xml
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to use JPA, but without a *persistence.xml* file.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Add the `quarkus-hibernate-orm` extension, the JDBC driver for your RDBMS, configuration
    via *application.properties*, and finally annotate your entities with `@Entity`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There isn’t anything special to set up using Quarkus and JPA beyond database
    connectivity. Quarkus will make some opinionated choices, but don’t worry—they’re
    probably the choices you would have made anyway—and continue on with your entities.
    You will be able to inject and utilize an `EntityManager` just as your normally
    would.
  prefs: []
  type: TYPE_NORMAL
- en: In a nutshell, you continue as you usually would with standard JPA, but without
    all the additional configuration of a *persistence.xml*. This is the preferred
    way to use JPA in Quarkus.
  prefs: []
  type: TYPE_NORMAL
- en: 7.10 Using Entities from a Different JAR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to include entities from a different jar.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Include an empty *META-INF/beans.xml* file in the jar containing the entities.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Quarkus relies on compile-type bytecode enhancements to entities. If these entities
    are defined in the same project (jar) as the rest of the application, everything
    works as it should.
  prefs: []
  type: TYPE_NORMAL
- en: However, if other classes such as entities or other CDI beans are defined in
    an external library, that library must contain an empty *META-INF/beans.xml* file
    to be properly indexed and enhanced.
  prefs: []
  type: TYPE_NORMAL
- en: 7.11 Persisting Data with Panache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to persist data with Hibernate and Panache.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Call the `persist` method on a `PanacheEntity`.
  prefs: []
  type: TYPE_NORMAL
- en: Naturally, you’ll need to add the `quarkus-hibernate-orm-panache` extension,
    and the corresponding JDBC extension for your data store. Next, you’ll need to
    define an entity. All that entails is creating a class, annotating it with `@javax.persistence.Entity`,
    and extending from `PanacheEntity`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Panache is an opinionated API built on top of a traditional JPA. It follows
    more of an active record approach to data entities; however, under the hood, it
    is done using traditional JPA.
  prefs: []
  type: TYPE_NORMAL
- en: As you will find throughout the exploration of Panache, much of the functionality
    is passed on to your entities through the `PanacheEntity` or `PanacheEntityBase`
    parent class—`persist` is no exception to this. `PanacheEntityBase` contains both
    the `persist()` and `persistAndFlush()` methods. While the flush option will immediately
    send the data to the database, it is not the recommended way of persisting the
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Persisting is very simple, as you can see in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'For completion, here is the `Library` entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 7.12 Finding All Entity Instances with Panache listAll Method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to find all entries of an entity.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `listAll()` method from the `PanacheEntityBase` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like the `persist()` method covered in the previous recipe, `listAll()`
    is a method from the `PanacheEntityBase` class. There isn’t anything special about
    it; it queries the database for all the entries of the given entity. It returns
    those entities in a `List`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This method is actually a shortcut for the `findAll().list()` chain. More info
    can be found in the `hibernate-orm-panache` code base.
  prefs: []
  type: TYPE_NORMAL
- en: 7.13 Finding Individual Entities with Panache findById Method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I want to find and load an entity from the database based on its ID.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use `PanacheEntityBase.findById(Object)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Panache simplifies finding an entity by using the `findById(Object)` method.
    All you need to do is pass the ID of the object and you will be returned the correct
    instance from the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 7.14 Finding Entities Using Panache Find and List Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to query the database for a specific entity based on its properties.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the various instances of the `find` and `list` methods from `PanacheEntityBase`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on how you need the result returned, you will use either `list` or
    `find` from the `PanacheEntityBase`. Internally, `list` uses `find`, so they are
    essentially the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'There are multiple overrides for both methods—they change based on the necessity
    of sorting and how you wish to send parameters. The following code is an example
    of using Hibernate Query Language (HQL) (or Java Persistence Query Language [JPQL])
    and using the `Parameters` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `Parameters` class override is available for both `find` and `list` methods.
    Consult the API for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You may be wondering, Why the full JPQL query? Put simply, it is to avoid serialization
    issues with the list. Using the left join, we are able to fetch the library and
    all the inventory for that library.
  prefs: []
  type: TYPE_NORMAL
- en: 7.15 Obtaining a Count of Entities Using the Panache count Method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to get a count of items for a resource.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the various `count` methods from `PanacheEntityBase`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like the `find` methods discussed earlier, Panache has various `count`
    method overrides available to obtain the number of entities of a given type in
    the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 7.16 Paginating Through Entity Lists Using the Panache page Method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to use pagination.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Quarkus, specifically Panache, has pagination built in. There are a number of
    methods on the `PanacheQuery` object that support pagination.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Pagination is very easy to get going. The first step is to get an instance
    of a `PanacheQuery`. This is as easy as using the `find` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_persistence_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Pages of 25 items, starting on page 3
  prefs: []
  type: TYPE_NORMAL
- en: 'There are, of course, other methods such as `firstPage()`, `lastPage()`, `nextPage()`,
    and `previousPage()`. Boolean supporting methods exist as well: `hasNextPage()`,
    `hasPreviousPage()`, and `pageCount()`.'
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information, see the following pages on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Page` object](https://oreil.ly/KYlsJ)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`PanacheQuery` interface](https://oreil.ly/BtgHK)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.17 Streaming Results via the Panache Stream Method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to use streams for data.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All `list` methods have corresponding `stream` methods when using Panache.
    Below you will see how these are used, which isn’t any different than how `list`
    methods are used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Each of the `stream` and `streamAll` methods return a `java.util.Stream` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`stream` methods require a transaction to work correctly.'
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information, visit the following website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[io.quarkus: `PanacheEntityBase`](https://oreil.ly/OW2fV)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.18 Testing Panache Entities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to use an embedded database for testing.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Quarkus comes with helpers for the in-memory databases H2 and Derby to properly
    boot the database as a separate process.
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to add either the `io.quarkus:quarkus-test-h2:1.4.1.Final` or the `i⁠o​.⁠q⁠u⁠a⁠r⁠k⁠u⁠s⁠:⁠q⁠u⁠a⁠r⁠k⁠u⁠s⁠-⁠t⁠e⁠s⁠t⁠-⁠d⁠e⁠r⁠b⁠y⁠:⁠1⁠.⁠4⁠.⁠1⁠.⁠F⁠i⁠n⁠a⁠l`
    artifacts to your build file.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to annotate any test using the embedded database with `@⁠Q⁠u⁠a⁠r⁠k⁠u⁠s​T⁠e⁠s⁠t⁠R⁠e⁠s⁠o⁠u⁠r⁠c⁠e⁠(⁠H⁠2⁠D⁠a⁠t⁠a⁠b⁠a⁠s⁠e⁠T⁠e⁠s⁠t⁠R⁠e⁠s⁠o⁠u⁠r⁠c⁠e⁠.⁠c⁠l⁠a⁠s⁠s⁠)`
    or `@QuarkusTestResource(DerbyDatabaseTestResource.class)`. Lastly, be sure to
    set the correct database URL and driver for the chosen database in *src/test/resources/META-INF/application.properties*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example for H2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This helper does not add the database into the native image, only the client
    code. However, feel free to use this for tests against your application in JVM
    mode or native image mode.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information, visit the following websites:'
  prefs: []
  type: TYPE_NORMAL
- en: '[H2 Database Engine](https://oreil.ly/_MMus)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Apache Derby](https://oreil.ly/FUFeH)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.19 Using a Data Access Object (DAO) or Repository Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to use the DAO or the repository pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Quarkus doesn’t limit with Panache; you can use the Entity pattern as previously
    described, a DAO, or a repository pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two interfaces you’ll need to understand to use a repository are `PanacheRepository`
    and `PanacheRepositoryBase`. The base interface is necessary only if you have
    a primary key that isn’t a `Long`. All of the same operations available on `PanacheEntity`
    are available on `PanacheRepository`. A repository is a CDI bean, so it must be
    injected when it is being used. Here are some basic examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: A DAO would work exactly as you would expect. You would need to inject an `EntityManager`
    and query as normal. There are a myriad of solutions and examples for using a
    DAO with Java that are available both online and in other books. Those examples
    will all function the same with Quarkus.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information, visit the following website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[io.quarkus: `PanacheRepositoryBase`](https://oreil.ly/H6kTU)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.20 Using Amazon DynamoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to use DynamoDB with a Quarkus application.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the DynamoDB extension and setup configuration. The DynamoDB extension
    allows both sync and async clients to make use of the Apache Amazon Web Service
    Software Development Kit (AWS SDK) client. There are a few things necessary to
    set up and enable in your project to get this running. The first is, of course,
    the dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There is no Quarkus extension for the AWS connection client.
  prefs: []
  type: TYPE_NORMAL
- en: 'The extension uses the URLConnection HTTP client by default. You need to add
    the correct client (URLConnection, Apache, or Netty NIO) to your build script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_persistence_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: You must exclude `commons-logging` to force the client to use the Quarkus logger
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using the Apache client, you will also need to make an adjustment
    to the *application.properties* file because `url` is the default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'There are also configurations for the client in *application.properties* (please
    see the [properties references](https://oreil.ly/HZ4A-) for more):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_persistence_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Useful if using a nonstandard endpoint, such as a local DynamoDB instance
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_persistence_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Correct, and valid, region
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_persistence_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: '`static` or `default`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `default` credential type will look for credentials in order:'
  prefs: []
  type: TYPE_NORMAL
- en: System properties `aws.accessKeyId` and `aws.secretKey`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Environment variables `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Credential profiles at the default location (*$HOME/.aws/credentials*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Credentials delivered through the Amazon EC2 container service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instance profile credentials delivered through Amazon EC2 metadata service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following example is from [Recipe 7.11](#persisting_data_panache), but with
    DynamoDB as the persistence store.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the two classes used to talk to DynamoDB and create an injectable
    service to be used in the REST endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The following abstract class contains boilerplate code needed to talk to DynamoDB
    and persist and query `Book` instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This last class is the class representing the `Book` entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_persistence_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Necessary to have reflection in a native application
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_persistence_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Required by DynamoDB client
  prefs: []
  type: TYPE_NORMAL
- en: Most of this is standard DynamoDB code, with the exception of the Quarkus annotation
    registering the `Book` class for reflection, which is necessary only if you are
    creating a native image.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the skills you have already acquired while working previously
    with DynamoDB are still usable without much modification when working with Quarkus,
    which helps you be more productive.
  prefs: []
  type: TYPE_NORMAL
- en: 7.21 Working with MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to use MongoDB as a persistent store.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Quarkus MongoDB extension makes use of the MongoDB Driver and Client.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By now you should be familiar with the basics of a RESTful resource and Quarkus
    configuration. Here we’ll show the code and example configuration used to talk
    to a local MongoDB instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Naturally, you’ll need to add the connection information to your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Book` class is a representation of the document within MongoDB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This service class acts as a DAO, a way into the MongoDB instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, a RESTful resource makes use of the previous two classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We’ll leave it as an exercise for the reader to create and use a BSON Codec.
    One of the other handy features of the MongoDB extension is an automatic health
    check that runs when using the `quarkus-smallrye-health` extension. The `quarkus-smallrye-health`
    extension will automatically create a readiness health check for your MongoDB
    connection. The readiness check, of course, is configurable.
  prefs: []
  type: TYPE_NORMAL
- en: The Quarkus MongoDB extension also includes a reactive client, which will be
    detailed in [Recipe 15.12](ch15.xhtml#using-reactive-mongodb-client-recipe).
  prefs: []
  type: TYPE_NORMAL
- en: 7.22 Using Panache with MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to use Panache with MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Add the `mongodb-panache` extension and use all the Panache abilities with `PanacheMongoEntity`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Panache for MongoDB works the same as Panache for Hibernate, which we saw in
    recipes [7.7](#setting-and-modifying-a-transaction-timeout) through [7.17](#streaming-results-via-panache-stream).
    It significantly simplifies your entity code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_persistence_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The optional `@MongoEntity` annotation allows you to customize the database
    and/or collection used
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_persistence_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The required part—add your fields as public fields
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_persistence_CO5-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Customize the serialized field name with `@BsonProperty`
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_persistence_CO5-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Query using PanacheQL (subset of JPQL), just like with JPA
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Panache MongoDB extension uses the `PojoCodecProvider` to map entites to
    a MongoDB `Document`. Besides `@BsonProperty`, you can also ignore fields with
    `@BsonIgnore`. You are also able to set up custom IDs with `@BsonId` and extend
    `PanacheMongoEntityBase`.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, if you need to write accessor methods, Panache doesn’t stop you from
    doing that; in fact, at build time all the field calls are replaced with the corresponding
    accessor/mutator calls. Just like Panache for Hibernate, the MongoDB version supports
    pagination, sorting, streams, and the rest of the Panache API.
  prefs: []
  type: TYPE_NORMAL
- en: The PanacheQL query you see in the previous example is easy to use and understand;
    but if you prefer to use regular MongoDB queries, those are also supported, provided
    that the query starts with `{`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A slight difference between the Hibernate and MongoDB Panache varieties is
    MongoDB’s ability to use Query Projection on the return of a `find()` method.
    This allows you to restrict which fields are returned from the database. Here
    is a very basic example with our `Book` entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: If you have a hierarchy of projection classes, the parent class(es) will also
    need to be annotated with `@ProjectionFor`.
  prefs: []
  type: TYPE_NORMAL
- en: 7.23 Using Neo4j with Quarkus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to connect to and use Neo4j.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the Quarkus Neo4j extension based on the Neo4j Java Driver.
  prefs: []
  type: TYPE_NORMAL
- en: The following examples make use of the asynchronous programming model (based
    on JDK’s completable futures). The driver also makes use of a blocking model,
    similar to JDBC, and a reactive model. The reactive model is available only to
    Neo4j 4+ versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'By now you’ve seen how to add additional extensions to your project, so we
    won’t cover that here. The following example also manages books, like others before
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Naturally, you will need to configure the client. This can be as easy as setting
    the `quarkus.neo4j.uri`, `quarkus.neo4j.authentication.username`, and `q⁠u⁠a⁠r⁠k⁠u⁠s​.⁠n⁠e⁠o⁠4⁠j⁠.⁠a⁠u⁠t⁠h⁠e⁠n⁠t⁠i⁠c⁠a⁠t⁠i⁠o⁠n⁠.⁠p⁠a⁠s⁠s⁠w⁠o⁠r⁠d`
    properties. You can consult the extension for more properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing you will need to configure the client is the Neo4j Driver.
    The extension provides an injectable instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a new REST resource and add the Driver injection point, then add
    the basic CRUD operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_persistence_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Gets an `AsyncSession` from the driver
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_persistence_CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Executes Cypher (Neo4j’s query language) to fetch the data
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_persistence_CO6-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Retrieves a cursor, creating `Book` instances from the nodes
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_persistence_CO6-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Closes the session once we’re done
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_persistence_CO6-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Builds a JAX-RS response
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of the class/code follow the same pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This last one is a little different, in that it handles errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The [Neo4j Cypher Manual](https://oreil.ly/ITHPx) will come in handy as you
    learn and try new things with Cypher.
  prefs: []
  type: TYPE_NORMAL
- en: 7.24 Flyway at Startup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to use Flyway to migrate my database schema.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `quarkus-flyway` integration extension.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Quarkus has first-class support for schema migrations using Flyway. There are
    five things you need to do to use Flyway with Quarkus at application start:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the Flyway extension.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the JDBC driver for your database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Setup the datasource(s).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add migrations to *src/main/resources/db/migration*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `quarkus.flyway.migrate-at-start` to `true`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The default naming schema for Flyway migrations is `V.<version>__<description>.sql`.
    Everything else is taken care of.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use Flyway with multiple datasources. Any settings that need to
    be configured for each datasource are named with the same schema as datasource
    names: `quarkus.flyway.*datasource name*.*setting*`. For example, it might be
    `quarkus.flyway.users.migrate-at-start`.'
  prefs: []
  type: TYPE_NORMAL
- en: 7.25 Using Flyway Programmatically
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to use Flyway programmatically. There may be times when you want to
    control when the schema is migrated instead of doing it at application startup.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the `quarkus-flyway` extension and inject the `Flyway` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This will inject the default `org.flywaydb.core.Flyway` instance configured
    against the default datasource. If you have multiple datasources and Flyway instances,
    you can inject specific ones using either the `@FlywayDataSource` or `@Named`
    annotation. When using `@FlywayDataSource`, the value is the name of the datasource.
    If instead you use `@Named`, the value should be the name of the datasource with
    the `flyway_` prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Naturally, you will be able to run all the standard Flyway operations such as
    `clean`, `migrate`, `validate`, `info`, `baseline`, and `repair`.
  prefs: []
  type: TYPE_NORMAL
