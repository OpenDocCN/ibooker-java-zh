- en: Chapter 6\. Remote WebDriver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, the examples explained in this book use web browsers locally installed
    on the machine that executes the tests. This chapter covers another relevant feature
    of the Selenium WebDriver API, i.e., the ability to use remote browsers (i.e.,
    installed in other hosts). First, we review the architecture that allows using
    remote browsers in Selenium WebDriver. Second, we study Selenium Grid, a networked
    infrastructure that provides remote browsers for Selenium WebDriver tests. Third,
    we analyze some of the most relevant cloud providers, i.e., companies that provide
    managed services for automated testing. Finally, we explore how to use Docker
    to support the browser infrastructure for Selenium.
  prefs: []
  type: TYPE_NORMAL
- en: Selenium WebDriver Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As introduced in [Chapter 1](ch01.html#ch01), Selenium WebDriver is a library
    that allows controlling web browsers programmatically. The automation is based
    on the native capabilities of each browser. Therefore, we need to place a binary
    file called a *driver* between the script (typically, a test) using the Selenium
    WebDriver API and the browser. The examples you have seen so far in this book
    use local browsers, i.e., browsers installed in the same machine that executes
    the test that uses the Selenium WebDriver API. [Figure 6-1](#remotewebdriver-local)
    illustrates this approach. In this case, and when using the Java language binding
    of the Selenium WebDriver API, we need to create an instance of `ChromeDriver`
    to control Chrome, `FirefoxDriver` for Firefox, etc.
  prefs: []
  type: TYPE_NORMAL
- en: '![hosw 0601](assets/hosw_0601.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-1\. Selenium WebDriver architecture using local browsers
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The communication protocol that supports this process is called W3C WebDriver.
    This standard protocol is based on JSON messages over HTTP. Thanks to this, the
    Selenium WebDriver architecture can be distributed to different interconnected
    computers (*hosts*). [Figure 6-2](#remotewebdriver-remote) shows a schematic representation
    of a remote architecture.
  prefs: []
  type: TYPE_NORMAL
- en: '![hosw 0602](assets/hosw_0602.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-2\. Selenium WebDriver architecture using remote browsers
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this case, the Selenium WebDriver API sends W3C WebDriver messages to a server-side
    component usually called *Selenium Server*. This server acts as a proxy of the
    client requests to other hosts that provide web browsers where the automation
    happens. This remote architecture eases cross-browser testing (i.e., verifying
    web applications in multiple browser types, versions, or operating systems) and
    parallel test execution.
  prefs: []
  type: TYPE_NORMAL
- en: Creation of RemoteWebDriver Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Selenium WebDriver API provides the class `RemoteWebDriver` to control remote
    browsers. As shown in [Figure 2-2](ch02.html#webdriver-hierarchy), this class
    is the parent of the rest of the `WebDriver` classes that drive local browsers
    (i.e., `ChromeDriver`, `FirefoxDriver`, etc.). This way, you can use `RemoteWebDriver`
    objects in the same way we have previously studied in this book.
  prefs: []
  type: TYPE_NORMAL
- en: RemoteWebDriver Constructor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are different ways to instantiate a `RemoteWebDriver` object. The most
    common way is to invoke its constructor by passing two arguments: the URL of the
    Selenium Server and the required capabilities. As shown in [Figure 5-1](ch05.html#capabilities-hierarchy),
    these capabilities are objects that inherit from the `Capabilities` interface
    (e.g., `ChromeOptions`, `Firefox​Op⁠tions`, etc.). [Example 6-1](#remotewebdriver_creation_1)
    shows a test setup. You can find the complete test in this book’s [code repository](https://github.com/bonigarcia/selenium-webdriver-java).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There is a second `RemoteWebDriver` constructor, which accepts only one parameter
    for the desired capabilities. In this case, the Selenium Server URL is read from
    the Java system property `webdriver.remote.server`. You can find an example of
    this feature in the examples repository.
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-1\. Instantiation of a RemoteWebDriver object using the constructor
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_remote_webdriver_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We create a Java `URL` object with the Selenium Server address.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_remote_webdriver_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We assume this URL is online. For that, we create an AssertJ assumption by invoking
    the static method `isOnline` available on WebDriverManager. As a result, the test
    is skipped when the Selenium Server is offline.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_remote_webdriver_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We instantiate a `ChromeOptions` object to specify the required capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_remote_webdriver_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: We invoke the `RemoteWebDriver` constructor using the Selenium Server URL and
    the Chrome options as arguments.
  prefs: []
  type: TYPE_NORMAL
- en: We use a `ChromeOptions` object without any particular setup to specify the
    required capabilities in the previous example. In other words, we request to use
    a remote Chrome browser using its default behavior. Nevertheless, we could use
    this object to configure specific capabilities (e.g., headless browser, page loading
    strategies, device emulation, etc.) as explained in [Chapter 5](ch05.html#ch05).
    Moreover, since capabilities are internally handled using key-value pairs that
    encapsulate specific browser aspects, we can manage individual capabilities invoking
    the method `options.setCapability(key, value);`. The Selenium WebDriver API provides
    the class `CapabilityType` to specify the key of these capabilities. This class
    has a set of public attributes that can be used as a `key` in the `setCapability()`
    method. [Table 6-1](#capabilitytype-attributes) shows some of these attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-1\. CapabilityType attributes
  prefs: []
  type: TYPE_NORMAL
- en: '| Attribute | Capability name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '| Browser name (e.g., `chrome`, `firefox`, or `msedge`) |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '| Platform name (e.g., `WINDOWS`, `LINUX`, `MAC`, `ANDROID`, `IOS`, among others)
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '| Browser version |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '| Enable or disable JavaScript execution |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '| Page loading strategy (`normal`, `eager`, or `none`) |'
  prefs: []
  type: TYPE_TB
- en: An alternative way to specify the required capabilities in a `RemoteWebDriver`
    object is using an instance of `DesiredCapabilities`. [Table 6-2](#desiredcapabilities-methods)
    summarizes the methods provided by these objects.
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-2\. DesiredCapabilities methods
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Return | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '| Specify the browser name |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '| Specify the browser version |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '| Specify the platform name |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '| Enable or disable JavaScript execution |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '| Enable or disable loading insecure pages |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '| Enable loading insecure pages |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '| Merge with another capabilities object |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`DesiredCapabilities` is still supported by Selenium WebDriver 4 since there
    is a lot of existing code relying on this feature. Nevertheless, the recommended
    way to specify capabilities is using browser-specific options (e.g., `ChromeOptions`,
    `FirefoxOptions`, etc.).'
  prefs: []
  type: TYPE_NORMAL
- en: RemoteWebDriver Builder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A second way to create `RemoteWebDriver` objects is using the built-in builder
    available in the Selenium WebDriver API. [Example 6-2](#remotewebdriver_creation_2)
    demonstrates how, using Edge as the remote browser.
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-2\. Instantiation of a RemoteWebDriver object using the builder
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: WebDriverManager Builder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Alternatively, we can also use WebDriverManager to create an instance of `RemoteWebDriver`.
    To that aim, we need to invoke the method `remoteAddress()` of a given manager
    to pass the Selenium Server URL. [Example 6-3](#remotewebdriver_creation_3) shows
    a test setup using this feature and Firefox as the remote browser.
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-3\. Instantiation of a RemoteWebDriver object using WebDriverManager
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Selenium-Jupiter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As usual, Selenium-Jupiter uses the parameter resolution feature provided by
    Jupiter. This way, and concerning remote browsers, you need to declare a test
    (or constructor) parameter using the type `RemoteWebDriver`. Then, the following
    Selenium-Jupiter annotations allow configuring the remote browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@DriverUrl`'
  prefs: []
  type: TYPE_NORMAL
- en: Annotation used to identify the Selenium Server URL. Alternatively, the annotation
    `@EnabledIfDriverUrlOnline` allows specifying this URL, and at the same time,
    disables the test if that URL is not responding.
  prefs: []
  type: TYPE_NORMAL
- en: '`@DriverCapabilities`'
  prefs: []
  type: TYPE_NORMAL
- en: Annotation used to configure the desired capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 6-4](#remotewebdriver_creation_4) shows a Selenium-Jupiter test using
    a remote Chrome provided by a local Selenium Server. This test will be skipped
    when the URL `http://localhost:4444/` is offline.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-4\. Using a RemoteWebDriver object in Selenium-Jupiter test
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `RemoteWebDriver` instantiation modes described in this section are equivalent
    from a functional point of view. In other words, these objects work in the same
    way. The difference between them is the provided *syntactic sugar* (i.e., the
    style and expressiveness).
  prefs: []
  type: TYPE_NORMAL
- en: Selenium Grid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As introduced in [Chapter 1](ch01.html#ch01), Selenium Grid is a subproject
    of the Selenium suite that allows creating a networked infrastructure for remote
    browsers accessible with the W3C WebDriver protocol. Selenium Grid allows running
    parallel tests across different machines and different browsers. To that aim,
    Selenium Grid provides a Selenium Server that you can control using an instance
    of `RemoteWebDriver`. There are three ways to run Selenium Grid:'
  prefs: []
  type: TYPE_NORMAL
- en: Standalone
  prefs: []
  type: TYPE_NORMAL
- en: A single host acts as Selenium Server and supplies the browsers in this mode.
    It provides a simple way to run Selenium WebDriver tests in remote browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Hub-nodes
  prefs: []
  type: TYPE_NORMAL
- en: A potential problem of the standalone mode is the scalability (since the Selenium
    Server and the browsers are executed in the same home). Thus, the hub-nodes architecture
    defines two types of components to solve this issue. First, one host acts as *hub*
    (or Selenium Server). Then, one or most hosts are registered as *nodes* in the
    hub, providing browsers to be controlled with Selenium WebDriver. This architecture
    was introduced in [Chapter 1](ch01.html#ch01) (see [Figure 1-2](ch01.html#selenium-grid-hub-node-arch)).
  prefs: []
  type: TYPE_NORMAL
- en: Fully distributed
  prefs: []
  type: TYPE_NORMAL
- en: The standalone and the hub-nodes approaches are centralized architectures that
    can degrade performance when the number of incoming requests increases. As of
    Selenium 4, Selenium Grid provides a fully distributed mode that implements load
    balancing mechanisms to solve this bottleneck.
  prefs: []
  type: TYPE_NORMAL
- en: The following subsections provide more details about these modes and explain
    how to set up each approach.
  prefs: []
  type: TYPE_NORMAL
- en: Standalone
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The standalone is the simplest approach for a Selenium Grid infrastructure.
    We can execute this mode using the shell and Java code.
  prefs: []
  type: TYPE_NORMAL
- en: From the shell
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, we can use the shell and the Selenium Grid binary distribution to launch
    it. Selenium Grid is developed in Java, and each release is distributed as a self-contained
    JAR file with all its dependencies (also known as *uber-JAR* or *fat-JAR*). You
    can download this fat-JAR from the [Selenium download page](https://www.selenium.dev/downloads).
  prefs: []
  type: TYPE_NORMAL
- en: The Selenium Server automatically detects the drivers (e.g., chromedriver, geckodriver,
    etc.) available in the system in the standalone mode. To that aim, it looks for
    these drivers in the `PATH` environment variable. As usual, we can manage these
    driver managers manually. Nevertheless, it is recommended to use WebDriverManager
    to resolve the drivers automatically. Thus, and as explained in [Appendix B](app02.html#appendix02),
    WebDriverManager can be used as a CLI tool. WebDriverManager CLI is distributed
    as a fat-JAR, available for download on [GitHub](https://github.com/bonigarcia/webdrivermanager/releases).
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate this, [Example 6-5](#standalone_cli) shows the shell commands
    required to resolve chromedriver and geckodriver in a Linux machine with WebDriverManager
    CLI. Then, we use the Selenium Grid fat-JAR to start a standalone grid. Notice
    that these commands are executed in the same folder. This way, the drivers downloaded
    with WebDriverManager are available for Selenium Grid.
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-5\. Commands to resolve drivers with WebDriverManager CLI and to start
    Selenium Grid in standalone mode using the shell
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_remote_webdriver_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We use WebDriverManager CLI to resolve chromedriver.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_remote_webdriver_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We use WebDriverManager CLI to resolve geckodriver (the driver required for
    Firefox).
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_remote_webdriver_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We start Selenium Grid in standalone mode in the same folder (which contains
    chromedriver and geckodriver).
  prefs: []
  type: TYPE_NORMAL
- en: 'After these commands, the standalone Selenium Server listens to incoming HTTP
    requests in port 4444 of the localhost. Therefore, we can create an instance of
    `RemoteWebDriver` using that URL (e.g., `http://localhost:4444/` if the test executes
    in the same host) and the required capabilities (for Chrome or Firefox, in this
    case). For instance, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In Selenium Grid 3, the default Selenium Server URL is `http://localhost:4444/wd/hub`.
    In Selenium Grid 4, although this URL should also work, the path `/wd/hub` is
    no longer required.
  prefs: []
  type: TYPE_NORMAL
- en: Another helpful feature provided by Selenium Grid is its *web console*. This
    console is a web UI accessible in the Selenium Server URL that allows monitoring
    of the available browsers registered in the grid and the sessions in execution.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 6-3](#selenium-grid-ui) shows a screenshot of the console of the previous
    standalone grid. Notice that in this case, the standalone Selenium Server can
    serve up to eight concurrent sessions (the same number of the available processors
    in the machine running the grid) of Chrome and Firefox.'
  prefs: []
  type: TYPE_NORMAL
- en: '![hosw 0603](assets/hosw_0603.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-3\. Selenium Grid console
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: From Java code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An alternative way to start Selenium Grid is using Java. In addition to the
    fat-JAR, Selenium Grid is released to Maven Central using `org.seleniumhq.selenium`
    as `groupId` and `selenium-grid` as `artifactId`. This way, we need to resolve
    its coordinates in our project setup (Maven or Gradle) to use it in our Java project
    (see [Appendix B](app02.html#appendix02) for the configuration details). [Example 6-6](#standalone_grid_java)
    demonstrates how to start Selenium Grid in standalone mode from a Java test case.
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-6\. Test starting Selenium Grid in standalone mode
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_remote_webdriver_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We find a free port on the localhost. For that, we use the class `PortProber`,
    available on Selenium WebDriver API.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_remote_webdriver_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We use WebDriverManager to resolve chromedriver since the standalone grid to
    be started will serve Chrome browsers.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_remote_webdriver_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We start Selenium Grid in standalone mode, calling its `main` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_remote_webdriver_CO3-4)'
  prefs: []
  type: TYPE_NORMAL
- en: We create a Java `URL` using the port previously selected.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_remote_webdriver_CO3-5)'
  prefs: []
  type: TYPE_NORMAL
- en: We create an instance of `RemoteWebDriver`. As usual, we use this object in
    the test logic to invoke the Selenium WebDriver API and control the browser (see
    the examples repository for the entire class).
  prefs: []
  type: TYPE_NORMAL
- en: Hub-nodes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The classic architecture of Selenium Grid involves two types of hosts: the
    hub (i.e., the Selenium Server) and a group of nodes. Like in the standalone mode,
    we can use the Selenium Grid fat-JAR to start this mode in the shell. First, we
    start the hub in a host. Then, we register one or more nodes in the same or different
    host. [Example 6-7](#hub_nodes_cli) shows the execution of these commands in a
    Windows console.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-7\. Command to start Selenium Grid in hub-nodes mode using the shell
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_remote_webdriver_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We start the hub. By default, this server listens to W3C WebDriver HTTP requests
    in port 4444 and TCP ports 4442 and 4443 for registering nodes.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_remote_webdriver_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a second console, we register the node(s). In this example, this command
    is executed in the same host as the hub. Moreover, it supposes that the required
    drivers (e.g., chromedriver and geckodriver) are already resolved (as in [Example 6-5](#standalone_cli)).
    To start nodes from another host, we would need to invoke the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the same way as the standalone mode, you can start a hub-nodes grid using
    Java code. For that, you need to change the parameters to invoke the Selenium
    Grid main class following the same syntax of the CLI commands for hub and nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Fully Distributed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As of version 4, we can execute a Selenium Grid infrastructure following a
    fully distributed architecture. The decisive aspect of this approach is scalability.
    Specialized nodes take care of different automation and infrastructure management
    aspects in this mode. These nodes are:'
  prefs: []
  type: TYPE_NORMAL
- en: Router
  prefs: []
  type: TYPE_NORMAL
- en: Node acting as a single entry point to the Grid. This component listens to W3C
    WebDriver commands from Selenium scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Session Queue
  prefs: []
  type: TYPE_NORMAL
- en: Node that stores the new session requests. These incoming sessions wait to be
    read by the *Distributor*.
  prefs: []
  type: TYPE_NORMAL
- en: Distributor
  prefs: []
  type: TYPE_NORMAL
- en: Node aware of all nodes and their capabilities. It asks for new session requests
    to the *Session Queue* in regular intervals.
  prefs: []
  type: TYPE_NORMAL
- en: Event Bus
  prefs: []
  type: TYPE_NORMAL
- en: Component that provides a message-oriented communication channel among several
    members of the Grid architecture. This communication is represented with dotted
    lines in Figures [6-4](#selenium-grid-distributed-arch-node-reg) and [6-5](#selenium-grid-distributed-arch-new-session).
  prefs: []
  type: TYPE_NORMAL
- en: Session Map
  prefs: []
  type: TYPE_NORMAL
- en: It keeps the relation of the WebDriver sessions and the nodes where the sessions
    are being executed.
  prefs: []
  type: TYPE_NORMAL
- en: Node(s)
  prefs: []
  type: TYPE_NORMAL
- en: Hosts that provide web browsers (and their corresponding drivers) for automation
    based on Selenium WebDriver.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In a hub-nodes architecture, the hub aggregates the responsibilities of the
    Router, Session Queue, Distributor, Event Bus, and Session Map of the fully distributed
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following subsections provide details about the most relevant processes
    in a fully distributed Selenium Grid: node registration, new session, and other
    WebDriver commands.'
  prefs: []
  type: TYPE_NORMAL
- en: Node registration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first process required to operate a distributed Selenium Grid is registering
    one or more nodes. To that aim, nodes need to register their capabilities in the
    Distributor. [Figure 6-4](#selenium-grid-distributed-arch-node-reg) illustrates
    this process, composed of three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: A node sends a message through the Event Bus to announce its capabilities.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This message reaches the Distributor, which stores the relationship between
    nodes and capabilities.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Distributor double-checks that the node exists by exchanging HTTP messages
    (solid line) with the source node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![hosw 0604](assets/hosw_0604.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-4\. Node registration in a Selenium Grid distributed architecture
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: New session
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At some point, a script (typically a test case) will try to start a new session
    to drive a browser automatically. [Figure 6-5](#selenium-grid-distributed-arch-new-session)
    describes the communication required to carry out this process in a fully distributed
    Selenium Grid, namely:'
  prefs: []
  type: TYPE_NORMAL
- en: A script/test using the Selenium WebDriver API sends a request to the Router
    to create a new session (i.e., to drive a browser programmatically).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Router creates a new entry in the Session Queue to store this new session
    request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Distributor asks the Session Queue for incoming new session requests in
    intervals.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the Distributor discovers a new session request, it checks if a node can
    support this session. If the session is possible (i.e., a node previously registered
    in the Distributor offers the required capabilities), the Distributor creates
    a new session with the node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Distributor sends an HTTP message to the Session Map to store the new session.
    The Session Map stores a unique session identifier (*session id*) that univocally
    associates the node executing the browser session.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![hosw 0605](assets/hosw_0605.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-5\. New session in a Selenium Grid distributed architecture
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: WebDriver commands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once the session is established, the Selenium WebDriver API script will continue
    sending W3C WebDriver commands to control the web browser in the remote node.
    [Figure 6-6](#selenium-grid-distributed-arch-webdriver-commands) shows how this
    communication occurs in a distributed Selenium Grid infrastructure following these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The script/test exchanges W3C WebDriver commands to drive the browser (e.g.,
    open a web page, interact with web elements, etc.) in the current session.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further requests to the same browser session use the same session id. The Router
    recognizes that a browser session is active by reading the Session Map.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Router forwards the subsequent commands of the same session directly to
    the assigned node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![hosw 0606](assets/hosw_0606.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-6\. WebDriver commands in a Selenium Grid distributed architecture
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Setting up a distributed grid
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like in the standalone and hub-nodes modes, we can use the Selenium Grid distribution
    (as a fat-JAR or regular Java dependency) to start the fully distributed architecture.
    [Example 6-8](#fully_distributed_cli) shows the shell command required to do this
    using the command line.
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-8\. Command to start Selenium Grid in distributed mode using the shell
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_remote_webdriver_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We start the Event Bus. By default, the Event Bus listens to TCP ports 4442
    and 4443.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_remote_webdriver_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We start the Session Map. By default, this component listens to incoming HTTP
    messages in port 5556.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_remote_webdriver_CO5-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We start the Session Queue. By default, this queue listens to HTTP in port 5559.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_remote_webdriver_CO5-4)'
  prefs: []
  type: TYPE_NORMAL
- en: We start the Distributor. For that, we need to specify the Session Map and Session
    Queue addresses. In addition, and since we already started the Event Bus independently,
    we set the flag `--bind-bus` to `false`. By default, the Distributor uses port
    5553 for the HTTP communication.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_remote_webdriver_CO5-5)'
  prefs: []
  type: TYPE_NORMAL
- en: We start the Router. We need to specify the URLs of the Session Map, Session
    Queue, and Distributor.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_remote_webdriver_CO5-6)'
  prefs: []
  type: TYPE_NORMAL
- en: We start the Nodes. We need to specify the ports where the Event Bus listens
    to publish-subscribe messages. Moreover, in this example, several drivers (chomedriver
    and geckodriver) are available in the same folder in which this command is executed.
  prefs: []
  type: TYPE_NORMAL
- en: Observability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In software engineering, *observability* is a measure that determines the current
    state of a software system based on its external outputs or signals. This way,
    observability allows understanding the internal state of the system by leveraging
    its external indicators. Observability can be critical for maintaining complex
    software systems and determining the root cause of any issue. To that aim, the
    three pillars of observability are:'
  prefs: []
  type: TYPE_NORMAL
- en: Metrics
  prefs: []
  type: TYPE_NORMAL
- en: Measures of system performance over time, such as response time, transactions
    per second, or memory usage, to name a few
  prefs: []
  type: TYPE_NORMAL
- en: Logs
  prefs: []
  type: TYPE_NORMAL
- en: Lines of text (typically timestamped) that a system produces when running a
    piece of code
  prefs: []
  type: TYPE_NORMAL
- en: Traces
  prefs: []
  type: TYPE_NORMAL
- en: Representation of causally related distributed events (such as selected logs)
    that characterize the request flow of a given operation in a software system
  prefs: []
  type: TYPE_NORMAL
- en: Selenium Grid 4 provides different features for measuring observability. First,
    Selenium Grid allows tracing using the [OpenTelemetry](https://opentelemetry.io)
    API. Second, Selenium Grid provides a GraphQL endpoint to run queries against
    the grid.
  prefs: []
  type: TYPE_NORMAL
- en: Tracing with OpenTelemetry
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Tracing* is an essential way of measuring observability based on the logs
    and metrics of a software system. Selenium Grid exposes tracing in two ways. First,
    we can check the log traces when executing a grid from the shell. By default,
    the logs at the `INFO` level are displayed. We can change the level using the
    argument `--log-level` in the shell command, for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, Selenium Grid supports *distributed tracing* via OpenTelemetry
    APIs. This feature allows tracing the commands flowing through a Selenium Grid
    infrastructure. Distributed tracing requires two activities in this order:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Code instrumentation
  prefs: []
  type: TYPE_NORMAL
- en: Selenium Grid allows exporting tracing information using the OpenTelemetry API.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Data collection
  prefs: []
  type: TYPE_NORMAL
- en: For example, we can use [Jaeger](https://www.jaegertracing.io), an open source
    distributed tracing platform that provides seamless integration with OpenTelemetry.
    It allows querying, visualizing, and collecting tracing data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following commands show how to set up Selenium Grid to export data to Jaeger.
    First, we need a Jaeger backend up and running. For that, we can download the
    executable binaries for the [Jaeger download page](https://www.jaegertracing.io/download).
    Alternatively, we can start the server using Docker, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_remote_webdriver_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We will use the URL `http://localhost:16686` to access the Jaeger UI.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_remote_webdriver_CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We will use the URL `http://localhost:14250` to collect the data (exported by
    Selenium Grid).
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we start Selenium Grid as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_remote_webdriver_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We use a Jaeger endpoint to export the tracing data.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_remote_webdriver_CO7-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We specify the service name `selenium-standalone`. We will look for this name
    in the Jaeger UI to visualize the gathered data (see [Figure 6-7](#jaeger)).
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_remote_webdriver_CO7-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We use [Coursier](https://get-coursier.io) to download and generate the classpath
    of two required dependencies (`opentelemetry-exporter-jaeger` and `grpc-netty`).
  prefs: []
  type: TYPE_NORMAL
- en: '![hosw 0607](assets/hosw_0607.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-7\. Jaeger UI showing the data gathered from Selenium Grid
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: GraphQL queries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[GraphQL](https://graphql.org) is an open source data query and manipulation
    language for APIs. GraphQL defines a syntax to ask for data, generally from an
    online service. Selenium Grid 4 provides a GraphQL endpoint (`http://localhost:4444/graphql`).
    A simple way to make GraphQL queries to this endpoint is using [curl](https://curl.se)
    from the shell. For example, and supposing that we have a Selenium Grid running
    in the localhost, we can send the following command to the GraphQL endpoint to
    get the maximum and the current number of sessions in the grid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can find more details about Selenium Grid in its official [documentation](https://www.selenium.dev/documentation/grid).
    For advanced configuration, there are two ways to specify a custom setup for Selenium
    Grid:'
  prefs: []
  type: TYPE_NORMAL
- en: Using CLI options for the different aspects of Selenium Grid
  prefs: []
  type: TYPE_NORMAL
- en: Some examples of these options are `--port` to change the default port through
    which the Selenium Server listens (4444 by default), or `--session-timeout`, which
    is the timeout in which nodes are terminated when there is no activity (three
    hundred seconds by default).
  prefs: []
  type: TYPE_NORMAL
- en: Using [TOML](https://toml.io) files
  prefs: []
  type: TYPE_NORMAL
- en: TOML (Tom’s Obvious Minimal Language) is a configuration format designed to
    be human-readable. Like the CLI options, these files allow configuring the Selenium
    Grid parameters but using TOML notation.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud Providers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As introduced in [Chapter 1](ch01.html#ch01), a *cloud provider* in the Selenium
    ecosystem is a company that provides managed services (usually commercial) for
    automated web and mobile testing. Common services offered by cloud providers include:'
  prefs: []
  type: TYPE_NORMAL
- en: Browsers *as a service*
  prefs: []
  type: TYPE_NORMAL
- en: To request on-demand web browsers hosted by the providers. These browsers are
    usually of different types, versions, and operating systems. This feature is typically
    used for cross-browser automated or live testing.
  prefs: []
  type: TYPE_NORMAL
- en: Analysis capabilities
  prefs: []
  type: TYPE_NORMAL
- en: To monitor and debug automated tests. To that aim, cloud providers typically
    support session recordings or rich error-reporting features.
  prefs: []
  type: TYPE_NORMAL
- en: Mobile testing
  prefs: []
  type: TYPE_NORMAL
- en: To request emulated (and real) mobile devices on different platforms, such as
    Android and iOS.
  prefs: []
  type: TYPE_NORMAL
- en: Visual testing
  prefs: []
  type: TYPE_NORMAL
- en: Automatically inspect the UI and ensure that end users have a correct visual
    experience.
  prefs: []
  type: TYPE_NORMAL
- en: Examples of current cloud providers for Selenium are [Sauce Labs](https://saucelabs.com),
    [BrowserStack](https://www.browserstack.com), [LambdaTest](https://www.lambdatest.com),
    [CrossBrowserTesting](https://crossbrowsertesting.com), [Moon Cloud](https://aerokube.com/moon-cloud),
    [TestingBot](https://testingbot.com), [Perfecto](https://www.perfecto.io), or
    [Testinium](https://testinium.com). All these companies offer specific services
    with different pricing plans. Their common aspect is that each cloud provider
    maintains a Selenium Server endpoint that we can use in `RemoteWebDriver` tests.
    [Example 6-9](#saucelabs_setup) illustrates how to use one of them (concretely,
    Sauce Labs) to create a `WebDriver` object. You can find equivalent tests for
    other cloud providers (BrowserStack, LambdaTest, CrossBrowserTesting, Perfecto,
    and Testinium) in the [examples repository](https://github.com/bonigarcia/selenium-webdriver-java).
    These tests allow using remote browsers managed by the cloud providers.
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-9\. Test setup for using Sauce Labs
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_remote_webdriver_CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: To use Sauce Labs, we need a valid account. In other words, we need credentials
    in the form of a username and access key. To avoid hardcoding these credentials
    in our test logic, I use Java system properties in this test. These properties
    can be informed in the execution command (e.g., `mvn test -DsauceLabsUsername​=myname
    -DsauceLabsAccessKey=mykey`). An alternative way to specify this data is using
    environment variables (e.g., `String username = Sys⁠tem.getenv​("SAU⁠CE​LABS_USERNAME");`).
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_remote_webdriver_CO8-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We skip this test (using assumptions) when the username or the key is unavailable.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_remote_webdriver_CO8-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We need to include the username and the key as Selenium capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_remote_webdriver_CO8-4)'
  prefs: []
  type: TYPE_NORMAL
- en: We can specify a custom label to identify this test in the Sauce Labs dashboard
    (see [Figure 6-8](#saucelabs)).
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_remote_webdriver_CO8-5)'
  prefs: []
  type: TYPE_NORMAL
- en: We use the latest version of a given browser (Chrome, as specified in the following
    line).
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_remote_webdriver_CO8-6)'
  prefs: []
  type: TYPE_NORMAL
- en: We use a custom label called `sauce:options` to select the required capabilities
    in the Sauce Labs cloud.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_remote_webdriver_CO8-7)'
  prefs: []
  type: TYPE_NORMAL
- en: We use the Sauce Labs public endpoint as a remote URL. Sauce Labs provides endpoints
    in different regions. In this example, I use the EU Central data center. Other
    possibilities are [US West](https://ondemand.us-west-1.saucelabs.com/wd/hub),
    [US East](https://ondemand.us-east-1.saucelabs.com/wd/hub), or [Asia-Pacific Southeast](https://ondemand.apac-southeast-1.saucelabs.com).
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_remote_webdriver_CO8-8)'
  prefs: []
  type: TYPE_NORMAL
- en: We use both the URL and the capabilities to create an instance of `RemoteWebDriver`.
  prefs: []
  type: TYPE_NORMAL
- en: '![hosw 0608](assets/hosw_0608.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-8\. Sauce Labs dashboard showing an automated test result
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Browsers in Docker Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Docker](https://www.docker.com) is an open source platform that allows creating,
    deploying, and running applications as lightweight, portable containers. The Docker
    platform is made up of two main components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Docker Engine](https://docs.docker.com/engine), an application that allows
    creating and running containers in a host. Docker Engine is a client-server application
    composed of three elements:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A server implemented as a daemon process (`dockerd`)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A REST API used by application clients to instruct the daemon
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A CLI tool (the `docker` command)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Docker Hub](https://hub.docker.com), a cloud service for distributing containers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Selenium, Docker can be a relevant technology to support the browser infrastructure
    required for automated tests based on Selenium WebDriver. The following subsections
    explain the alternatives for executing browsers in Docker containers.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Images for Selenium Grid
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An official subproject of the Selenium suite is [docker-selenium](https://github.com/SeleniumHQ/docker-selenium).
    This project maintains Docker images for the different Selenium Grid components
    (i.e., standalone, hub, nodes, router, distributor, session queue, etc.) and web
    browsers (Chrome, Firefox, and Edge). These Docker images are open source and
    released on [Docker Hub](https://hub.docker.com/u/selenium). A simple way to use
    these images is to start them using the shell (with the `docker` command) and
    use an instance of `RemoteWebDriver` to drive *dockerized* browsers. The following
    subsections explain how.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The commands and tests presented in this section suppose Docker is available
    in your system. In other words, you need to have installed a Docker Engine in
    your machine to execute these examples properly.
  prefs: []
  type: TYPE_NORMAL
- en: Standalone
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can find Selenium images for standalone browsers (Chrome, Firefox, and Edge)
    in Docker Hub. The following command shows how to start Chrome in Docker using
    the shell.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This command starts the Docker image `selenium/standalone-chrome:latest`, i.e.,
    the latest version of Chrome available in Docker Hub. Alternatively, we can use
    a fixed Chrome version (e.g., `selenium/standalone-chrome:94.0`). The Docker container
    is started in detached mode (using the `-d` flag) using a shared memory of 2 GB
    (`--shm-size="2g"`). This figure is a value known to work well, although you can
    change it depending on your resources or specific needs. Finally, the internal
    container port `4444` is mapped to the same port of the host where the command
    is executed (`-p 4444:4444`). We can then use the following Java command to instantiate
    a `WebDriver` object that uses this dockerized Chrome:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, when using Selenium Grid, we can use Docker containers for registering
    nodes. The following command shows how to start a Selenium Grid in standalone
    mode using a node with Firefox in Docker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Hub-nodes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can easily start Selenium Grid in the hub-nodes mode using the official Selenium
    Docker images. The following commands show how to do it in the shell.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_remote_webdriver_CO9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: First, we create a Docker network called `grid`. This network allows communication
    between hub and node(s) using their hostnames (e.g., `selenium-hub`).
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_remote_webdriver_CO9-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We start the Selenium Hub. We need to map ports 4444 (for the Selenium Server
    URL) and 4442-4443 (for registering nodes).
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_remote_webdriver_CO9-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We register nodes. In this command, we use Chrome (`selenium/node-chrome`).
    Other browsers can be registered in the hub using other Docker images (e.g., `selenium/node-firefox`
    or `selenium/node-edge`).
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_remote_webdriver_CO9-4)'
  prefs: []
  type: TYPE_NORMAL
- en: If not required anymore, we can remove the `grid` network at the end.
  prefs: []
  type: TYPE_NORMAL
- en: Further features
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The project `docker-selenium` provides a wide variety of features. I recommend
    you take a look at its [README](https://github.com/SeleniumHQ/docker-selenium)
    for more details. Here is a summary of these features:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker Compose scripts
  prefs: []
  type: TYPE_NORMAL
- en: These scripts allow starting Selenium Grid hub-nodes and the fully distributed
    mode effortlessly.
  prefs: []
  type: TYPE_NORMAL
- en: Video recording
  prefs: []
  type: TYPE_NORMAL
- en: We can record the desktop session of the browsers in the nodes using another
    Docker container.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic grid
  prefs: []
  type: TYPE_NORMAL
- en: This allows us to start Docker containers on demand.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying to Kubernetes
  prefs: []
  type: TYPE_NORMAL
- en: '[Kubernetes](https://kubernetes.io) is an open source container-orchestration
    system that automates the deployment and management of containerized applications.
    We can use Kubernetes to deploy the Selenium Docker containers.'
  prefs: []
  type: TYPE_NORMAL
- en: Advanced container configuration
  prefs: []
  type: TYPE_NORMAL
- en: This can be used, for instance, to specify Selenium or Java custom configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Access to the remote session
  prefs: []
  type: TYPE_NORMAL
- en: This can be achieved using Virtual Network Computing (VNC) (a graphical desktop
    sharing system) and [noVNC](https://novnc.com) (an open source web-based VNC client).
  prefs: []
  type: TYPE_NORMAL
- en: Selenoid
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Selenoid](https://aerokube.com/selenoid) is an open source Golang implementation
    of a Selenium Hub. Selenoid can be seen as a lightweight Selenium Server that
    provides a browser infrastructure based on Docker. The Selenoid team also maintains
    the Docker images used by Selenoid. These images include multiple web browsers
    and Android devices, such as Chrome, Firefox, Edge, Opera, Safari (WebKit engine),
    or Chrome Mobile.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are different ways to use Selenoid and its Docker images. A straightforward
    way is to use the configuration manager (a binary called `cm`) provided by the
    project. The following snippet shows how to start Selenoid and its UI (a web-based
    dashboard to monitor Selenoid):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_remote_webdriver_CO10-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We start Selenoid. The configuration manager downloads the Docker image for
    Selenoid and the two latest versions of several browsers (Chrome, Firefox, and
    Opera). Once it is started, Selenoid listens to Selenium WebDriver requests in
    the URL `http://localhost:4444/wd/hub`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_remote_webdriver_CO10-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Optionally, we can start the Selenoid UI. This UI is a web application accessible
    in the URL `http://localhost:8080/`. [Figure 6-9](#selenoid-ui) shows a screenshot
    of this UI during the execution of a Selenium WebDriver test. [Example 6-10](#selenoid_test_setup)
    shows the setup of a test that uses a Chrome browser served by Selenoid.
  prefs: []
  type: TYPE_NORMAL
- en: '![hosw 0609](assets/hosw_0609.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-9\. Selenoid UI during a test execution using VNC
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Example 6-10\. Instantiation of a RemoteWebDriver object using the constructor
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_remote_webdriver_CO11-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The capability `enableVNC` is Selenoid-specific and allows us to start the dockerized
    browser with VNC support (this way, we can visualize the browser session in the
    Selenoid UI, as illustrated in [Figure 6-9](#selenoid-ui)).
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_remote_webdriver_CO11-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Since this capability is vendor-specific, the W3C WebDriver-compatible way to
    set this capability is using a custom namespace (`selenoid:options` in this case).
  prefs: []
  type: TYPE_NORMAL
- en: Further features
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Selenoid provides different features and configuration capabilities. You can
    check its [documentation](https://aerokube.com/selenoid/latest) for more details.
    These features include video recording, custom configuration, log management,
    or access to browser developer tools, to name a few.
  prefs: []
  type: TYPE_NORMAL
- en: WebDriverManager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As of version 5, WebDriverManager allows the effortless use of web browsers
    in Docker containers. To that aim, each manager (e.g., `chromedriver()`, `firefoxdriver()`,
    etc.) provides the method `browserInDocker()`. WebDriverManager internally pulls
    the Docker images and runs the container, creating a `RemoteWebDriver` instance
    when invoking the method `create()`. WebDriverManager uses the Docker images maintained
    by the Selenoid team. This way, you can use Chrome (desktop and mobile), Firefox,
    Edge, Opera, and Safari as Docker containers out of the box through WebDriverManager.
    [Example 6-11](#wdm_chrome) illustrates a basic test using this feature.
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-11\. Complete test using WebDriverManager and Chrome in Docker
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_remote_webdriver_CO12-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We get an instance of the manager for Chrome (`chromedriver()`). Then, using
    the WebDriverManager fluent API, we specify that the future `WebDriver` objects
    created with this instance (called `wmd`) will use Docker to execute the corresponding
    browser (Chrome, in this case).
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_remote_webdriver_CO12-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We assume a Docker engine is available in the machine running this test. For
    that, we create an AssertJ assumption by invoking the static method `isDocker​A⁠vailable`
    on WebDriverManager. This way, when Docker is not available, the test is skipped.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_remote_webdriver_CO12-3)'
  prefs: []
  type: TYPE_NORMAL
- en: In the test setup, we create the `WebDriver` instance. Internally, WebDriverManager
    will connect to Docker Hub to discover the latest version of Chrome available
    as a Docker image. This image is pulled to the local machine, the Docker container
    is executed, and the corresponding `RemoteWebDriver` instance is returned to the
    test logic.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_remote_webdriver_CO12-4)'
  prefs: []
  type: TYPE_NORMAL
- en: WebDriverManager allows quitting the previously created `WebDriver` instances
    through the method `quit()`. This method has the same effect of directly quitting
    the instance (`driver.quit()` in this case), and the used Docker containers are
    gracefully terminated.
  prefs: []
  type: TYPE_NORMAL
- en: WebDriverManager provides a fluent API to configure different aspects of the
    dockerized web browsers. The following snippet shows several possibilities. As
    usual, you can find the complete tests using these features in the [examples repository
    for this book](https://github.com/bonigarcia/selenium-webdriver-java).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_remote_webdriver_CO13-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We select a given manager to use the corresponding dockerized browser (Firefox
    in this case). In addition to Chrome and Firefox, the other alternatives are Edge,
    Opera, Safari, and Chrome Mobile.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_remote_webdriver_CO13-2)'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, WebDriverManager uses the latest version available in Docker Hub
    for the dockerized browser. Nevertheless, we can force the use of a given version
    (e.g., `94.0`). Moreover, different wildcards are valid for specifying the following
    versions, namely:'
  prefs: []
  type: TYPE_NORMAL
- en: '`latest`'
  prefs: []
  type: TYPE_NORMAL
- en: To use the latest version (default option).
  prefs: []
  type: TYPE_NORMAL
- en: '`latest-N`'
  prefs: []
  type: TYPE_NORMAL
- en: To use a previous version to the stable release. For example, if we specify
    `latest-1` (i.e., latest version minus one), the former version to the stable
    release is used.
  prefs: []
  type: TYPE_NORMAL
- en: '`beta`'
  prefs: []
  type: TYPE_NORMAL
- en: To use the beta version. This version is only available for Chrome and Firefox,
    using a fork of the Aerokube Docker images for these browsers maintained by [Twilio](https://hub.docker.com/r/twilio/selenoid).
  prefs: []
  type: TYPE_NORMAL
- en: '`dev`'
  prefs: []
  type: TYPE_NORMAL
- en: To use the development version (again, for Chrome and Firefox).
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_remote_webdriver_CO13-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Connect to the remote desktop session using VNC or noVNC. By default, WebDriverManager
    prints the noVNC URL in the log traces. In addition, this URL is accessible by
    invoking the method `wdm.getDockerNoVncUrl()`. [Figure 6-10](#wdm-novnc) shows
    a web browser that allows watching and interacting with a remote session with
    noVNC.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_remote_webdriver_CO13-4)'
  prefs: []
  type: TYPE_NORMAL
- en: To enable the session recording. At the end of the test, you can find the recording
    (in MP4 format) in the project root folder.
  prefs: []
  type: TYPE_NORMAL
- en: '![hosw 0610](assets/hosw_0610.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-10\. Remote desktop using noVNC of a dockerized browser started with
    WebDriverManager
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Further features
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As explained in its [documentation](https://bonigarcia.dev/webdrivermanager),
    you can configure WebDriverManager in multiple ways. For instance, you can specify
    fine-grained aspects of dockerized browsers, such as the time zone, network, shared
    memory, volumes, environment variables, screen resolution, or recording output,
    among others. In addition, WebDriverManager can be used as a Selenium Server.
    This server uses the container images pulled from Docker Hub to support the browser
    infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Selenium-Jupiter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Selenium-Jupiter internally uses WebDriverManager to manage and handle web browsers
    in Docker containers. For dockerized browsers, Selenium-Jupiter provides the annotation
    `@DockerBrowser`. You can use this annotation with `WebDriver` or `RemoteWebDriver`
    parameters in test methods. [Example 6-12](#seljup_chrome) demonstrates this feature.
    In this example, we use Chrome in Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-12\. Complete test using Selenium-Jupiter and Chrome in Docker
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_remote_webdriver_CO14-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We decorate the test class with the Selenium-Jupiter annotation `@EnabledIf​Dock⁠erAvailable`.
    This annotation disables the test when Docker is not installed in the machine
    running the test.
  prefs: []
  type: TYPE_NORMAL
- en: The annotation `@DockerBrowser` allows setting different aspects and features.
    The following snippet illustrates some of them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_remote_webdriver_CO15-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We can change the browser using the `type` attribute. The accepted values are
    `CHROME`, `FIREFOX`, `OPERA`, `EDGE`, `SAFARI`, and `CHROME_MOBILE`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_remote_webdriver_CO15-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We can change the browser version using the attribute `version`. Like WebDriverManager,
    Selenium-Jupiter allows specifying a fixed version value (e.g., `94.0`) and using
    the wildcards `latest` and `latest-N`, as well as `beta` and `dev` for Chrome
    and Firefox.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_remote_webdriver_CO15-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We enable access to the remote desktop session through VNC and noVNC using the
    attribute `vnc`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_remote_webdriver_CO15-4)'
  prefs: []
  type: TYPE_NORMAL
- en: We enable the session recording with the `recording` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more details, examples, and configuration capabilities of Selenium-Jupiter
    in its [documentation](https://bonigarcia.dev/selenium-jupiter).
  prefs: []
  type: TYPE_NORMAL
- en: Summary and Outlook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Selenium WebDriver allows controlling remote web browsers. This feature is
    feasible because the underlying communication protocol (W3C WebDriver) is based
    on JSON messages over HTTP. This way, the components of the Selenium WebDriver
    architecture (Selenium Server, nodes, or client script) can be distributed (i.e.,
    executed in different hosts). To use this feature in Java, we need to create an
    instance of `RemoteWebDriver`, typically passing two arguments: the Selenium Server
    URL and the required capabilities. We can start a Selenium Server infrastructure
    using Selenium Grid (in standalone, hub-nodes, or fully distributed mode). Alternatively,
    we can use the managed services provided by a cloud provider (such as Sauce Labs,
    BrowserStack, LambdaTest, or CrossBrowserTesting, among others). Finally, we can
    use Docker to support a containerized infrastructure of web browsers.'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter concludes the second part of the book, in which you have discovered
    the main features of the Selenium WebDriver API. The next part of the book covers
    different aspects of developing end-to-end tests using the Selenium WebDriver
    API, starting with the Page Object Model (POM), a widely used design pattern for
    enhancing test maintenance and reducing code duplication in Selenium WebDriver.
  prefs: []
  type: TYPE_NORMAL
