- en: 'Chapter 1\. Getting Started: Compiling and Running Java'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. 入门：编译和运行Java
- en: 1.0 Introduction
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.0 引言
- en: 'This chapter covers some entry-level tasks that you need to know how to do
    before you can go on. It is said you must crawl before you can walk, and walk
    before you can ride a bicycle. Before you can try out anything in this book, you
    need to be able to compile and run your Java code, so I start there, showing several
    ways to do that: the JDK way, the Integrated Development Environment (IDE) way,
    and the build tools (Ant, Maven, etc.) way. Another issue people run into is setting
    `CLASSPATH` correctly, so that’s dealt with next. Deprecation warnings follow
    after that, because you’re likely to encounter them in maintaining old Java code.
    The chapter ends with some general information about conditional compilation,
    unit testing, assertions, and debugging.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了一些入门级的任务，你需要知道如何在开始之前做这些事情。据说你必须先爬行，然后才能行走，再之后才能骑自行车。在本书中尝试任何东西之前，你需要能够编译和运行你的Java代码，因此我从这里开始，展示了几种方法来实现：JDK方法、集成开发环境（IDE）方法以及构建工具（Ant、Maven等）方法。另一个人们遇到的问题是正确设置`CLASSPATH`，所以接下来处理这个问题。之后是关于弃用警告的信息，因为你在维护旧Java代码时可能会遇到它们。本章以关于条件编译、单元测试、断言和调试的一般信息结束。
- en: If you don’t already have Java installed, you’ll need to download it. Be aware
    that there are several different downloads. The JRE (Java Runtime Environment)
    was, up until Java 8, a smaller download for end users. Since there is far less
    desktop Java than there once was, the JRE was eliminated in favor of `jlink` to
    make a custom download (see [Recipe 15.8](ch15.html#javacook-packages-SECT-jlink)).
    The JDK or Java SDK download is the full development environment, which you’ll
    want if you’re going to be developing Java software.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有安装Java，你需要下载它。请注意，有几种不同的下载选项。直到Java 8，JRE（Java运行环境）是面向最终用户的一个较小的下载包。由于现在桌面Java的使用远不如从前，JRE已被淘汰，取而代之的是`jlink`，用于创建自定义下载（参见[Recipe
    15.8](ch15.html#javacook-packages-SECT-jlink)）。JDK或Java SDK下载是完整的开发环境，如果你打算开发Java软件，这是你需要的。
- en: Standard downloads for the current release of Java are available at [Oracle’s
    website](http://www.oracle.com/technetwork/java/javase/downloads/index.html).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当前Java版本的标准下载可在[Oracle网站](http://www.oracle.com/technetwork/java/javase/downloads/index.html)找到。
- en: You can sometimes find prerelease builds of the next major Java version on [*http://jdk.java.net*](http://jdk.java.net).
    The entire JDK is maintained as an open source project, and the OpenJDK source
    tree is used (with changes and additions) to build the commercial and supported
    Oracle JDKs.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可以在[*http://jdk.java.net*](http://jdk.java.net)找到下一个主要Java版本的预发布版本。整个JDK作为一个开源项目进行维护，OpenJDK源代码树用于构建商业和支持的Oracle
    JDK（经过修改和增加）。
- en: If you’re already happy with your IDE, you may wish to skip some or all of this
    material. It’s here to ensure that everybody can compile and debug their programs
    before we move on.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经对你的集成开发环境（IDE）满意，你可能希望跳过这部分或全部内容。这里的内容确保每个人在继续之前都能够编译和调试他们的程序。
- en: '1.1 Compiling and Running Java: Standard JDK'
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.1 编译和运行Java：标准JDK
- en: Problem
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to compile and run your Java program.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要编译和运行你的Java程序。
- en: Solution
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: This is one of the few areas where your computer’s operating system impinges
    on Java’s portability, so let’s get these issues out of the way first.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你的计算机操作系统影响Java可移植性的少数几个领域之一，因此让我们先解决这些问题。
- en: JDK
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JDK
- en: 'Using the command-line Java Development Kit (JDK) may be the best way to keep
    up with the very latest improvements in Java. Assuming you have the standard JDK
    installed in the standard location and/or have set its location in your `PATH`,
    you should be able to run the command-line JDK tools. Use the commands *javac*
    to compile and *java* to run your program (and, on Windows only, *javaw* to run
    a program without a console window), like this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令行Java开发工具包（JDK）可能是跟进Java最新改进的最佳方式。假设你已经在标准位置安装了标准JDK并且将其位置设置在你的`PATH`中，你应该可以运行命令行JDK工具。使用命令
    *javac* 进行编译和 *java* 运行你的程序（在Windows上还有 *javaw* 用于无控制台窗口运行程序），如下所示：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If the program refers to other classes for which the source is available (in
    the same directory) and a compiled *.class* file is not, *javac* will automatically
    compile it for you. Effective with Java 11, for simple programs that don’t need
    any such co-compilation, you can combine the two operations by simply passing
    the Java source file to the *java* command:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序引用其他类，这些类的源代码在同一目录中可用且没有编译过的 *.class* 文件，*javac* 将自动为您编译它们。从 Java 11 开始，对于不需要任何这种共同编译的简单程序，您可以通过简单地将
    Java 源文件传递给 *java* 命令来合并这两个操作：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you can see from the compiler’s (lack of) output, both *javac* and *java*
    compilation works on the Unix “no news is good news” philosophy: if a program
    was able to do what you asked it to, it shouldn’t bother nattering at you to say
    that it did so.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你从编译器的（缺少）输出中可以看到的，*javac* 和 *java* 编译工作采用了 Unix 的“没有消息就是好消息”的哲学：如果程序能够按照你的要求执行，它就不应该烦扰你告诉它已经完成了。
- en: There is an optional setting called `CLASSPATH`, discussed in [Recipe 1.5](#javacook-getstarted-SECT-4),
    that controls where Java looks for classes. `CLASSPATH`, if set, is used by both
    *javac* and *java*. In older versions of Java, you had to set your `CLASSPATH`
    to include “.” even to run a simple program from the current directory; this is
    no longer true on current Java implementations.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个可选设置叫做 `CLASSPATH`，在 [Recipe 1.5](#javacook-getstarted-SECT-4) 中讨论，它控制 Java
    查找类的位置。如果设置了 `CLASSPATH`，*javac* 和 *java* 都会使用它。在旧版本的 Java 中，即使是从当前目录运行一个简单程序，你也必须将
    `CLASSPATH` 设置为包含“.”；但在当前的 Java 实现中，这已经不再需要。
- en: Sun/Oracle’s *javac* compiler is the official reference implementation. There
    were several alternative open source command-line compilers, including [Jikes](http://sourceforge.net/projects/jikes)
    and [Kaffe](http://github.com/kaffe/kaffe), but they are, for the most part, no
    longer actively maintained.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Sun/Oracle 的 *javac* 编译器是官方的参考实现。还有几个替代的开源命令行编译器，包括[Jikes](http://sourceforge.net/projects/jikes)和[Kaffe](http://github.com/kaffe/kaffe)，但它们大多数情况下已经不再积极维护。
- en: There have also been some Java runtime clones, including [Apache Harmony](http://harmony.apache.org),
    [Japhar](http://www.hungry.com/old-hungry/products/japhar), the IBM Jikes Runtime
    (from the same site as Jikes), and even [JNode](http://www.jnode.org), a complete,
    standalone operating system written in Java; but since the Sun/Oracle JVM has
    been open sourced (GPL), most of these projects have stopped being maintained.
    Harmony was retired by Apache in November 2011.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 也有一些 Java 运行时的克隆品，包括[Apache Harmony](http://harmony.apache.org)，[Japhar](http://www.hungry.com/old-hungry/products/japhar)，IBM
    Jikes Runtime（与 Jikes 相同的站点），甚至[ JNode](http://www.jnode.org)，一个完整的、独立的用 Java
    编写的操作系统；但自从 Sun/Oracle 的 JVM 开源（GPL）以来，大多数这些项目已经停止维护。Apache 于 2011 年 11 月退役了 Harmony。
- en: macOS
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: macOS
- en: The JDK is pure command line. At the other end of the spectrum in terms of keyboard-versus-visual,
    we have the Apple Macintosh. Books have been written about how great the Mac user
    interface is, and I won’t step into that debate. macOS (Release 10.x of the OS)
    is built upon a BSD Unix (and “Mach”) base. As such, it has a regular command
    line (the Terminal application, hidden away under */Applications/Utilities*),
    as well as both the traditional Unix command-line tools and the graphical Mac
    tools. If you’re using macOS, you can use the command-line JDK tools or any of
    the modern build tools. Compiled classes can be packaged into clickable applications
    using the Jar Packager discussed in [Recipe 15.6](ch15.html#javacook-packages-SECT-7).
    Mac fans can use one of the many full IDE tools discussed in [Recipe 1.3](#javacook-getstarted-SECT-3).
    Apple provides XCode as its IDE, but out of the box it isn’t very Java-friendly.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: JDK 纯命令行。在键盘与可视化之间的另一端，我们有苹果 Macintosh。有关 Mac 用户界面有很多好评，我不想卷入那场辩论。macOS（OS 版本
    10.x）建立在 BSD Unix（和“Mach”）基础上。因此，它既有常规的命令行（Terminal 应用程序，隐藏在 */Applications/Utilities*
    下），也有传统的 Unix 命令行工具和图形化的 Mac 工具。如果你使用 macOS，你可以使用命令行 JDK 工具或任何现代构建工具。编译后的类可以使用在
    [Recipe 15.6](ch15.html#javacook-packages-SECT-7) 中讨论的 Jar 打包工具打包为可点击的应用程序。Mac
    粉丝可以使用在 [Recipe 1.3](#javacook-getstarted-SECT-3) 中讨论的许多完整 IDE 工具之一。苹果提供 XCode
    作为其 IDE，但原装状态下它对 Java 并不友好。
- en: '1.2 Compiling and Running Java: GraalVM for Better Performance'
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.2 编译和运行 Java：GraalVM 提升性能
- en: Problem
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You’ve heard that Graal is a JVM from Oracle that’s faster than the standard
    JDK, and you want to try it out. Graal promises to offer better performance, and
    it offers the ability to mix and match programming languages and pre-compile your
    Java code into executable form for a given platform.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你听说过 Graal 是 Oracle 推出的比标准 JDK 更快的 JVM，你想试一试。Graal 承诺提供更好的性能，并且支持混合编程语言以及将你的
    Java 代码预编译为特定平台的可执行形式。
- en: Solution
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Download and install GraalVM.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 下载并安装 GraalVM。
- en: Discussion
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: GraalVM bills itself as “a universal virtual machine for running applications
    written in JavaScript, Python, Ruby, R, JVM-based languages like Java, Scala,
    Clojure, Kotlin, and LLVM-based languages such as C and C++.”
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: GraalVM 自称为“一个通用的虚拟机，用于运行JavaScript、Python、Ruby、R，基于 JVM 的语言如 Java、Scala、Clojure、Kotlin，以及基于
    LLVM 的语言，如 C 和 C++。”
- en: Note that Graal is undergoing rapid change. While this recipe reflects the latest
    information at press time (late 2019), there may be newer versions and changed
    functionality by the time you are ready to install.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Graal 正在快速变化。虽然此处的步骤反映了出版时（2019 年末）的最新信息，但到你准备安装时，可能已经有了更新版本和功能上的变化。
- en: As we go to press, GraalVM is based on OpenJDK 11, which means you can use Modules
    and other Java 9, 10, and 11 features, but it doesn’t have support for Java 12,
    13 or 14 features. You can build your own Graal on later releases, since [the
    complete source is on GitHub](https://github.com/oracle/graal).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写时，GraalVM 基于 OpenJDK 11，这意味着你可以使用模块和其他 Java 9、10 和 11 特性，但不支持 Java 12、13
    或 14 的功能。你可以在后续版本上构建自己的 Graal，因为 [完整的源代码位于 GitHub 上](https://github.com/oracle/graal)。
- en: See [the GraalVM website](https://www.graalvm.org) for more information on GraalVM.
    See also [this presentation](https://www.infoq.com/presentations/graal-jvm-jit)
    by Chris Thalinger, who has worked on JVMs for a decade and a half.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 [GraalVM 网站](https://www.graalvm.org) 获取更多关于 GraalVM 的信息。还可以参考由 Chris Thalinger（他在
    JVM 领域工作了十五年）所做的 [这个演示](https://www.infoq.com/presentations/graal-jvm-jit)。
- en: '[Start at the downloads page](https://www.graalvm.org/downloads). You will
    have to choose between the Community Edition and the Enterprise Edition. To avoid
    any licensing issues, this recipe starts with the Community Edition. You can download
    a tarball for Linux, macOS, and Windows. There is no formal installer at this
    point. To install it, open a terminal window and try the following (the directory
    chosen is for macOS):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[从下载页面开始](https://www.graalvm.org/downloads)。你需要在社区版和企业版之间做出选择。为避免任何许可问题，此处的步骤从社区版开始。你可以在
    Linux、macOS 和 Windows 上下载 tarball。目前还没有正式的安装程序。要安装它，请打开终端窗口并尝试以下操作（选择的目录适用于 macOS）：'
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'On other systems, do the install in a sensible place. On most versions of Linux,
    after installing a JDK, you can use the standard Linux [*alternatives* command](https://access.redhat.com/documentation/en-US/JBoss_Communications_Platform/5.1/html/Platform_Installation_Guide/sect-Setting_the_Default_JDK.html)
    to make this your default. On MacOS, the *java_home* command output confirms that
    you have installed GraalVM, but it’s not your default JVM yet. To do that, you
    have to set your `PATH`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他系统上，安装应放在合适的位置。在大多数 Linux 版本上，安装 JDK 后，可以使用标准的 Linux [*alternatives* 命令](https://access.redhat.com/documentation/en-US/JBoss_Communications_Platform/5.1/html/Platform_Installation_Guide/sect-Setting_the_Default_JDK.html)
    来设置为默认。在 MacOS 上，*java_home* 命令的输出确认你已安装了 GraalVM，但它还不是你的默认 JVM。要做到这一点，你需要设置你的
    `PATH`：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Be very sure to include the `:$PATH` at the end of the line—no space—or all
    your standard command-line tools will appear to disappear (if you made this mistake,
    just log out and log back in to restore your path). I suggest you don’t update
    your login scripts until you are sure the settings you have are correct.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在行末包含 `:$PATH` ——没有空格——否则你所有的标准命令行工具都将消失（如果你犯了这个错误，只需退出并重新登录即可恢复你的路径）。我建议你在确定你的设置是正确的之前不要更新登录脚本。
- en: 'Now you should be running the Graal version of Java. This is what you should
    see:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该正在运行 Graal 版本的 Java。你应该看到以下内容：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Your output may differ, but as long as it says “GraalVM” you should be good.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 输出可能不同，但只要显示“GraalVM”，你就没错。
- en: Graal includes a number of useful tools, including *native-image*, which can
    in some cases translate a class file into a binary executable for the platform
    it’s running on, optimizing startup speed and also reducing the download size
    needed to run a single application. The *native-image* tool must be downloaded
    separately using `gu install native-image`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Graal 包含许多有用的工具，包括 *native-image*，在某些情况下可以将类文件转换为运行平台的二进制可执行文件，优化启动速度并减少运行单个应用程序所需的下载大小。*native-image*
    工具必须单独下载，使用 `gu install native-image`。
- en: We’ll explore running some of the other non-Java languages in [Recipe 18.4](ch18.html#javacook-otherlang-with-graalvm).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [第18.4节](ch18.html#javacook-otherlang-with-graalvm) 中探索运行一些非Java语言。
- en: 1.3 Compiling, Running, and Testing with an IDE
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.3 使用IDE进行编译、运行和测试
- en: Problem
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: It is cumbersome to use several tools for the various development tasks.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 对于各种开发任务使用多个工具非常繁琐。
- en: Solution
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use an Integrated Development Environment (IDE), which combines editing, testing,
    compiling, running, debugging, and package management.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用集成开发环境（IDE），它结合了编辑、测试、编译、运行、调试和包管理功能。
- en: Discussion
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Many programmers find that using a handful of separate tools—a text editor,
    a compiler, and a runner program, not to mention a debugger—is too many. An IDE
    *integrates* all of these into a single toolset with a graphical user interface.
    Many IDEs are available, and the better ones are fully integrated tools with their
    own compilers and virtual machines. Class browsers and other features of IDEs
    round out the ease-of-use feature sets of these tools. Today most developers use
    an IDE because of the productivity gains. Although I started as a command-line
    junkie, I do find that IDE features like the following make me more productive:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 许多程序员发现使用一些单独的工具——文本编辑器、编译器和运行程序，更不用说调试器——是太多了。一个IDE *整合* 所有这些功能到一个带有图形用户界面的单一工具集中。许多IDE都可用，并且较好的IDE是具有自己编译器和虚拟机的完全集成工具。类浏览器和其他IDE功能完善了这些工具的易用性特性。今天，大多数开发者使用IDE因为它们提升了生产力。尽管我最初是一个命令行爱好者，但我发现IDE的以下功能使我更加高效：
- en: 'Code completion:: *Ian’s Rule* here is that I never type more than three characters
    of any name that is known to the IDE; let the computer do the typing! Incremental
    compiling features:: Note and report compilation errors as you type, instead of
    waiting until you are finished typing. Refactoring:: The ability to make far-reaching
    yet behavior-preserving changes to a code base without having to manually edit
    dozens of individual files.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '代码完成:: *Ian’s Rule* 是我从不输入已知于IDE的任何名称的超过三个字符；让计算机完成打字工作！增量编译功能:: 在键入时即时通知和报告编译错误，而不是等到完成输入后再检查。重构::
    在不手动编辑数十个单独文件的情况下，进行深远但保留行为的更改的能力。'
- en: Beyond that, I don’t plan to debate the merits of IDE versus the command-line
    process; I use both modes at different times and on different projects. I’m just
    going to show a few examples of using a couple of the Java-based IDEs.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，我不打算讨论IDE与命令行处理的优缺点；在不同的时间和项目中，我都会使用两种模式。我只是打算展示使用几个基于Java的IDE的几个示例。
- en: The three most popular Java IDEs, which run on all mainstream computing platforms
    and quite a few niche ones, are *Eclipse*, *NetBeans*, and *IntelliJ IDEA*. Eclipse
    is the most widely used, but the others each have a special place in the hearts
    and minds of some developers. If you develop for Android, the ADT has traditionally
    been developed for Eclipse, but it has now transitioned to IntelliJ as the basis
    for Android Studio, which is the standard IDE for Android, and for Google’s other
    mobile platform, [Flutter](https://flutter.io). All three IDEs are plug-in based
    and offer a wide selection of optional and third-party plug-ins to enhance the
    IDE, such as supporting other programming languages, frameworks, and file types.
    While the following paragraph shows creating and running a program with Eclipse,
    the IntelliJ IDEA and NetBeans IDEs all offer similar capabilities.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 三个最流行的Java集成开发环境（IDE），可在所有主流计算平台和一些小众平台上运行，分别是 *Eclipse*、*NetBeans* 和 *IntelliJ
    IDEA*。Eclipse 是最广泛使用的，但其他两个在一些开发者心目中各有特殊地位。如果你开发Android应用，ADT 传统上是为 Eclipse 开发的，但现在已过渡到
    IntelliJ 作为 Android Studio 的基础，后者是Android的标准IDE，也是Google的另一个移动平台 [Flutter](https://flutter.io)
    的基础。这三个IDE都是基于插件的，提供了大量可选的第三方插件，用于增强IDE的功能，例如支持其他编程语言、框架和文件类型。虽然下面的段落展示了如何使用 Eclipse
    创建和运行程序，但 IntelliJ IDEA 和 NetBeans IDE 都提供了类似的功能。
- en: One of the most popular cross-platform, open source IDEs for Java is Eclipse,
    originally from IBM and now shepherded by the [Eclipse Foundation](http://eclipse.org),
    the home of many software projects including [Jakarta](https://projects.eclipse.org/projects/ee4j.jakartaee-platform),
    the follow-on to the Java Enterprise Edition. The Eclipse Platform is also used
    as the basis of other tools such as SpringSource Tool Suite (STS) and IBM’s Rational
    Application Developer (RAD). All IDEs do basically the same thing for you when
    getting started. The example in [Figure 1-1](#javacook-getstarted-FIG-5a) shows
    starting a new project.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse是最流行的跨平台开源Java IDE之一，最初由IBM开发，现由[Eclipse Foundation](http://eclipse.org)管理，这是许多软件项目的家园，包括[Jakarta](https://projects.eclipse.org/projects/ee4j.jakartaee-platform)，即Java企业版的后继者。Eclipse平台还作为其他工具的基础，如SpringSource
    Tool Suite (STS)和IBM的Rational Application Developer (RAD)。所有的IDE在起步时基本都为你提供相同的功能。例如，[图1-1](#javacook-getstarted-FIG-5a)展示了如何开始一个新项目。
- en: '![jcb4 0101](assets/jcb4_0101.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![jcb4 0101](assets/jcb4_0101.png)'
- en: Figure 1-1\. Starting a new project with the Eclipse New Java Class Wizard
  id: totrans-55
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-1\. 使用Eclipse新建Java类向导开始一个新项目
- en: The Eclipse New Java Class Wizard shown in [Figure 1-2](#javacook-getstarted-FIG-5b)
    shows creating a new class.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse新建Java类向导如[图1-2](#javacook-getstarted-FIG-5b)所示，展示了创建新类的过程。
- en: '![jcb4 0102](assets/jcb4_0102.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![jcb4 0102](assets/jcb4_0102.png)'
- en: Figure 1-2\. Creating a new class with the Eclipse New Java Class Wizard
  id: totrans-58
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-2\. 使用Eclipse新建Java类向导创建新类
- en: Eclipse, like all modern IDEs, features a number of refactoring capabilities,
    shown in [Figure 1-3](#javacook-getstarted-FIG-6).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse和现代所有IDE一样，具备多项重构能力，如[图1-3](#javacook-getstarted-FIG-6)所示。
- en: '![jcb4 0103](assets/jcb4_0103.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![jcb4 0103](assets/jcb4_0103.png)'
- en: Figure 1-3\. Refactoring in Eclipse
  id: totrans-61
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-3\. Eclipse中的重构操作
- en: And, of course, all the IDEs allow you to run and/or debug your application.
    [Figure 1-4](#javacook-getstarted-intellij) shows running an application; for
    variety and neutrality, this is shown using IntelliJ IDEA.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，所有的IDE都允许你运行和/或调试你的应用程序。[图1-4](#javacook-getstarted-intellij)展示了运行一个应用程序的过程；为了多样性和中立性，此处展示使用的是IntelliJ
    IDEA。
- en: macOS includes Apple’s Developer Tools. The main IDE is Xcode. Unfortunately,
    current versions of Xcode do not really support Java development, so I can’t recommend
    it for our purposes; it is primarily for those building nonportable (iOS-only
    or OS X–only) applications in the Swift or Objective-C programming languages.
    So even if you are on OS X, to do Java development you should use one of the three
    Java IDEs.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: macOS包含了Apple的开发工具，主要IDE是Xcode。不幸的是，当前版本的Xcode实际上并不支持Java开发，所以我无法推荐它用于我们的目的；它主要用于构建非可移植（仅限iOS或仅限OS
    X）的应用程序，使用Swift或Objective-C编程语言。因此，即使你使用OS X，如果要进行Java开发，你应该使用三大Java IDE之一。
- en: Microsoft VSCode (formerly part of Visual Studio) has been getting some attention
    in Java circles lately, but it’s not a Java-specific IDE. Give it a try if you
    like.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，Microsoft VSCode（原属于Visual Studio的一部分）在Java领域引起了一些关注，但它并不是一个专门针对Java的IDE。如果你喜欢，可以试试看。
- en: How do you choose an IDE? Perhaps it will be dictated by your organization or
    chosen by majority vote of your fellow developers. Given that all three major
    IDEs (Eclipse, NetBeans, and IntelliJ) can be downloaded free and are 100% open
    source, why not try them all and see which one best fits the kind of development
    you do? Regardless of what platform you use to develop Java, if you have a Java
    runtime, you should have plenty of IDEs from which to choose.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如何选择一个IDE呢？也许会由你的组织决定，或者由你的开发团队中的多数人投票决定。考虑到Eclipse、NetBeans和IntelliJ这三个主要的IDE都可以免费下载并且是100%开源的，为什么不都试试看，看哪一个最适合你的开发需求呢？不管你用什么平台开发Java，只要有Java运行时，你都可以有很多IDE可供选择。
- en: '![jcb4 0104](assets/jcb4_0104.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![jcb4 0104](assets/jcb4_0104.png)'
- en: Figure 1-4\. IntelliJ program output
  id: totrans-67
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-4\. IntelliJ程序输出
- en: See Also
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Each IDE’s website maintains an up-to-date list of resources, including books.
    See [Table 1-1](#javacook-getstarted-idelist) for the website for each.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 每个IDE的网站都会维护一个更新的资源列表，包括书籍。查看[表1-1](#javacook-getstarted-idelist)获取每个IDE的网站信息。
- en: Table 1-1\. The three major Java IDEs and their websites
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 表1-1\. 三大Java IDE及其网站
- en: '| Product name | Project URL | Note |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 产品名称 | 项目URL | 备注 |'
- en: '| --- | --- | --- |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Eclipse | [*https://eclipse.org/*](https://eclipse.org/) | Basis of STS,
    RAD |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| Eclipse | [*https://eclipse.org/*](https://eclipse.org/) | STS、RAD的基础 |'
- en: '| IntelliJ Idea | [*https://jetbrains.com/idea/*](https://jetbrains.com/idea/)
    | Basis of Android Studio |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| IntelliJ Idea | [*https://jetbrains.com/idea/*](https://jetbrains.com/idea/)
    | Android Studio的基础 |'
- en: '| Netbeans | [*https://netbeans.apache.org*](https://netbeans.apache.org) |
    Run anywhere JavaSE does |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| Netbeans | [*https://netbeans.apache.org*](https://netbeans.apache.org) |
    可在JavaSE支持的任何地方运行 |'
- en: These major IDEs are extensible; see their documentation for a list of the many,
    many plug-ins available. Most of them allow you to find and install plug-ins from
    within the IDE. For Eclipse, use the Eclipse Marketplace, near the bottom of the
    Help menu. As a last resort, if you need/want to write a plug-in that extends
    the functionality of your IDE, you can do that too, and in Java.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这些主要的集成开发环境是可扩展的；查阅它们的文档以获取可用的许多插件列表。其中大多数允许您在IDE内查找和安装插件。对于Eclipse，请使用Eclipse
    Marketplace，在帮助菜单的底部附近。作为最后的手段，如果您需要/想要编写一个扩展IDE功能的插件，您也可以使用Java进行操作。
- en: For Eclipse, I have some useful information at [*https://darwinsys.com/java*](https://darwinsys.com/java).
    The site includes a list of shortcuts to aid developer productivity.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Eclipse，我在[*https://darwinsys.com/java*](https://darwinsys.com/java)上有一些有用的信息。该网站包含了一些快捷方式列表，以帮助开发者提高生产效率。
- en: 1.4 Exploring Java with JShell
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.4 使用JShell探索Java
- en: Problem
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to try out Java expressions and APIs quickly, without having to create
    a file with `public class X { public static void main(String[] args) { … }` every
    time.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望快速尝试Java表达式和API，而不必每次创建一个包含`public class X { public static void main(String[]
    args) { … }`的文件。
- en: Solution
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use JShell, Java’s REPL (Read-Evaluate-Print-Loop) interpreter.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JShell，Java的REPL（读取-求值-打印-循环）解释器。
- en: Discussion
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Starting with Java 11, `JShell` is included as a standard part of Java. It allows
    you to enter Java statements and have them evaluated without the bother of creating
    a class and a main program. You can use it for quick calculations, to try out
    an API to see how it works, or for almost any purpose; if you find an expression
    you like, you can copy it into a regular Java source file and make it permanent.
    JShell can also be used as a scripting language over Java, but the overhead of
    starting the JVM means that it won’t be as fast as awk, Perl, or Python for quick
    scripting.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 从Java 11开始，`JShell`被包括为Java的标准部分。它允许您输入Java语句并对其进行评估，而无需创建类和主程序。您可以用它进行快速计算，尝试API以查看其工作原理，或几乎任何其他用途；如果找到您喜欢的表达式，您可以将其复制到常规Java源文件中，并使其永久化。JShell还可以用作Java的脚本语言，但启动JVM的开销意味着它不如awk、Perl或Python那样快速进行脚本编写。
- en: 'REPL programs are very convenient, and they are hardly a new idea (LISP languages
    from the 1950s included them). You can think of Command-Line Interpreters (CLIs)
    such as the Bash or Ksh shells on UNIX/Linux, or Command.com and PowerShell on
    Microsoft Windows, as REPLs for the system as a whole. Many interpreted languages
    like Ruby and Python can also be used as REPLs. Java finally has its own REPL,
    *JShell*. Here’s an example of using it:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: REPL程序非常方便，而且它们并不是一个新的想法（上世纪50年代的LISP语言已经包括了它们）。您可以将命令行解释器（CLI）（例如UNIX/Linux上的Bash或Ksh
    shell，或Microsoft Windows上的Command.com和PowerShell）视为系统整体的REPL。许多解释性语言如Ruby和Python也可以用作REPL。Java最终有了自己的REPL，*JShell*。这里有一个使用它的示例：
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can see some obvious features and benefits here:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里看到一些明显的特性和优点：
- en: The value of an expression is printed without needing to call `System.out.println`
    every time, but you can call it if you like.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式的值会被打印出来，无需每次调用`System.out.println`，但如果您愿意，也可以调用它。
- en: Values that are not assigned to a variable get assigned synthetic identifiers,
    like `$1`, that can be used in subsequent statements.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未分配给变量的值会被分配合成标识符，如`$1`，可以在后续语句中使用。
- en: The semicolon at the end of a statment is optional (unless you type more than
    one statement on a line).
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语句末尾的分号是可选的（除非您在一行上键入多个语句）。
- en: If you make a mistake, you get a helpful message immediately.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果出现错误，您将立即收到一条有帮助的消息。
- en: You can get completion with a single tab, as in shell filename completion.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以像在shell文件名补全中一样使用单个制表符完成。
- en: You can get the relevant portion of the Javadoc documentation on known classes
    or methods with just a double tab.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你只需双击标签，就可以获得有关已知类或方法的Javadoc文档的相关部分。
- en: If you omit a close quote, parenthesis, or other punctuation, JShell will just
    wait for you, giving a continuation prompt (`…`).
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果省略了闭引号、括号或其他标点符号，JShell将等待您，显示一个继续提示 (`…`)。
- en: If you do make a mistake, you can use “shell history” (i.e., up arrow) to recall
    the statement so you can repair it.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果确实出现错误，您可以使用“shell历史”（即向上箭头）来调出语句，以便修复它。
- en: 'JShell is also useful in prototyping Java code. For example, I wanted one of
    those health-themed timers that reminds you to get up and move around a bit every
    half hour:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: JShell在原型化Java代码时也很有用。例如，我想要一个健康主题的计时器，提醒你每半小时起来活动一下：
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: I then put the final working version into a Java file called *MoveTimer.java*,
    put a `class` statement and a `main()` method around the main line, told the IDE
    to reformat the whole thing, and saved it into my *darwinsys-api* repository.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我将最终的工作版本放入了一个名为*MoveTimer.java*的Java文件中，围绕主要代码行加了一个`class`语句和一个`main()`方法，告诉IDE重新格式化整个内容，并将其保存到了我的*darwinsys-api*存储库中。
- en: So go ahead and experiment with JShell. Read the built-in introductory tutorial
    for more details! When you get something you like, either use `/save`, or copy
    and paste it into a Java program and save it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 那就开始尝试使用JShell吧。阅读内置的入门教程以获取更多细节！当你找到喜欢的东西时，要么使用`/save`，要么将其复制粘贴到Java程序中并保存。
- en: Read more about JShell at the [OpenJDK JShell Tutorial](https://cr.openjdk.java.net/~rfield/tutorial/JShellTutorial.html).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在[OpenJDK JShell教程](https://cr.openjdk.java.net/~rfield/tutorial/JShellTutorial.html)中了解更多关于JShell的内容。
- en: 1.5 Using CLASSPATH Effectively
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.5 有效使用CLASSPATH
- en: Problem
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to keep your class files in a common directory, or you’re wrestling
    with `CLASSPATH`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要将类文件放在一个共同的目录中，否则你将要与`CLASSPATH`抗争。
- en: Solution
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Set `CLASSPATH` to the list of directories and/or JAR files that contain the
    classes you want.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 将`CLASSPATH`设置为包含你想要的类的目录和/或JAR文件的列表。
- en: Discussion
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: '`CLASSPATH` is a list of class files in any of a number of directories, JAR
    files, or ZIP files. Just like the `PATH` your system uses for finding programs,
    the `CLASSPATH` is used by the Java runtime to find classes. Even when you type
    something as simple as *java HelloWorld*, the Java interpreter looks in each of
    the places named in your `CLASSPATH` until it finds a match. Let’s work through
    an example.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`CLASSPATH`是一个包含在任意数量的目录、JAR文件或ZIP文件中的类文件列表。就像你的系统用于查找程序的`PATH`一样，Java运行时使用`CLASSPATH`来查找类。即使当你键入像*java
    HelloWorld*这样简单的命令时，Java解释器也会在你的`CLASSPATH`中的每个命名位置查找，直到找到匹配项。让我们通过一个例子来进行说明。'
- en: 'The `CLASSPATH` can be set as an environment variable the same way you set
    other environment variables, such as your `PATH` environment variable. However,
    it’s usually preferable to specify the `CLASSPATH` for a given command on the
    command line:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`CLASSPATH`可以像设置其他环境变量（比如你的`PATH`环境变量）一样设置为一个环境变量。然而，通常最好为给定的命令在命令行上指定`CLASSPATH`：'
- en: '[PRE7]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Suppose your `CLASSPATH` were set to *C:\classes;.* on Windows or *~/classes:.*
    on Unix or Mac. Suppose you had just compiled a source file named *HelloWorld.java*
    (with no package statement) into *HelloWorld.class* in the default directory (which
    is your current directory) and tried to run it. On Unix, if you run one of the
    kernel tracing tools (`trace`, `strace`, `truss`, or `ktrace`), you would probably
    see the Java program `open` or `stat` or `access` the following files:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的`CLASSPATH`设置为Windows上的*C:\classes;.*，或Unix或Mac上的*~/classes:.*。假设你刚刚在默认目录（也就是当前目录）中编译了一个名为*HelloWorld.java*（没有包声明）的源文件，生成了*HelloWorld.class*并尝试运行它。在Unix上，如果你运行了一个内核跟踪工具（`trace`、`strace`、`truss`或`ktrace`），你可能会看到Java程序`open`、`stat`或`access`以下文件：
- en: Some file(s) in the JDK directory
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDK目录中的一些文件
- en: Then ~*/classes/HelloWorld.class*, which it probably wouldn’t find
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后是~*/classes/HelloWorld.class*，它可能找不到
- en: Finally, *./HelloWorld.class*, which it would find, open, and read into memory
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后是*./HelloWorld.class*，它会找到、打开并读入内存
- en: 'The vague “some file(s) in the JDK directory” is release dependent. You should
    not mess with the JDK files, but if you’re curious, you can find them in the System
    Properties (see [Recipe 2.2](ch02.html#javacook-environ-SECT-2)). There used to
    be a variable named `sun.boot.class.path`, but that is not found anymore. Let’s
    look for any property with `boot` in its name:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 含糊的“JDK目录中的一些文件”是与发行版相关的。你不应该去碰JDK文件，但如果你好奇的话，你可以在系统属性中找到它们（参见[食谱2.2](ch02.html#javacook-environ-SECT-2)）。以前有一个名为`sun.boot.class.path`的变量，但现在找不到了。让我们寻找任何名称中包含`boot`的属性：
- en: '[PRE8]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The reason I and others suggest *not* setting `CLASSPATH` as an environment
    variable is that we don’t like surprises. It’s easy to add a JAR to your `CLASSPATH`
    and then forget that you’ve done so; a program might then work for you but not
    for your colleagues, due to their being unaware of your hidden dependency. And
    if you add a new version to `CLASSPATH` without removing the old version, you
    may run into conflicts.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我和其他人建议不要将 `CLASSPATH` 设置为环境变量的原因是，我们不喜欢意外。很容易将一个 JAR 添加到你的 `CLASSPATH`，然后忘记你已经这样做了；程序可能会在你这里工作，但由于他们不知道你的隐藏依赖，对你的同事来说却无法工作。如果你在
    `CLASSPATH` 中添加新版本而不删除旧版本，可能会遇到冲突问题。
- en: Note also that providing the `-classpath` argument causes the `CLASSPATH` environment
    variable to be ignored.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，提供 `-classpath` 参数会导致 `CLASSPATH` 环境变量被忽略。
- en: If you still want to set `CLASSPATH` as an environment variable, you can. Suppose
    you had also installed the JAR file containing the supporting classes for programs
    from this book, *darwinsys-api.jar* (the actual filename if you download it may
    have a version number as part of the filename). You might then set your `CLASSPATH`
    to *C:\classes;C:\classes\darwinsys-api.jar;.* on Windows or *~/classes:~/classes/darwinsys-api.jar:.*
    on Unix.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍然希望将 `CLASSPATH` 设置为环境变量，那是可以的。假设你还安装了包含本书程序支持类的 JAR 文件 *darwinsys-api.jar*（如果你下载的实际文件名包含版本号）。你可以将
    `CLASSPATH` 设置为在 Windows 上是 *C:\classes;C:\classes\darwinsys-api.jar;.*，在 Unix
    上是 *~/classes:~/classes/darwinsys-api.jar:.*。
- en: Notice that you *do* need to list the full name of the JAR file explicitly.
    Unlike a single class file, placing a JAR file into a directory listed in your
    `CLASSPATH` does not make it available.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你确实需要显式列出 JAR 文件的完整名称。与单个类文件不同，将 JAR 文件放入列在 `CLASSPATH` 中的目录中并不会使其可用。
- en: Certain specialized programs (such as a web server running a `Servlet` container)
    might not use either bootpath or `CLASSPATH` exactly as shown; these application
    servers typically provide their own `ClassLoader` (see [Recipe 17.5](ch17.html#javacook-reflection-SECT-4)
    for information on class loaders). EE Web containers, for example, set your web
    app `CLASSPATH` to include the directory *WEB-INF/classes* and all the JAR files
    found under *WEB-INF/lib*.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 某些专业程序（如运行 `Servlet` 容器的 Web 服务器）可能不会完全像显示的那样使用 `bootpath` 或 `CLASSPATH`；这些应用服务器通常提供自己的
    `ClassLoader`（参见 [Recipe 17.5](ch17.html#javacook-reflection-SECT-4) 获取有关类加载器的信息）。例如，EE
    Web 容器会将您的 Web 应用的 `CLASSPATH` 设置为包括目录 *WEB-INF/classes* 和 *WEB-INF/lib* 下找到的所有
    JAR 文件。
- en: 'How can you easily generate class files into a directory in your `CLASSPATH`?
    The *javac* command has a `-d` dir option, which specifies where the compiler
    output should go. For example, using `-d` to put the *HelloWorld* class file into
    my *$HOME/classes* directory, I just type the following (note that from here on
    I will be using the package name in addition to the class name, like a good kid):'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如何将类文件轻松生成到你的 `CLASSPATH` 目录中？*javac* 命令有一个 `-d` dir 选项，用于指定编译器输出的位置。例如，使用 `-d`
    将 *HelloWorld* 类文件放入我的 *$HOME/classes* 目录中，只需输入以下内容（请注意，从这里开始，我将使用包名加类名，像一个好孩子）：
- en: '[PRE9]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As long as this directory remains in my `CLASSPATH`, I can access the class
    file regardless of my current directory. That’s one of the key benefits of using
    `CLASSPATH`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 只要这个目录保持在我的 `CLASSPATH` 中，无论当前目录如何，我都可以访问类文件。这是使用 `CLASSPATH` 的主要好处之一。
- en: While these examples show explicit use of `java` with `-classpath`, it is generally
    more convenient (and reproducible) to use a build tool such as Maven ([Recipe
    1.7](#javacook-getstarted-maven)) or Gradle, which automatically provide the `CLASSPATH`
    for both compilation and execution.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些示例显示了使用 `-classpath` 的 `java` 的显式用法，但通常更方便（且可重现）使用构建工具如 Maven（参见 [Recipe
    1.7](#javacook-getstarted-maven)）或 Gradle，它们会自动为编译和执行提供 `CLASSPATH`。
- en: Note that Java 9 and later also have a module path (environment variable `MODULEPATH`,
    command-line argument `--module-path entry[:,…]`) with the same syntax as the
    class path. The module path contains code that has been modularized; the Java
    Module System is discussed in [Recipe 2.5](ch02.html#javacook-environ-modules)
    and [Recipe 15.9](ch15.html#javacook-packages-creating-JPMS-modules).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Java 9 及更高版本还有一个模块路径（环境变量 `MODULEPATH`，命令行参数 `--module-path entry[:,…]`），其语法与类路径相同。模块路径包含已模块化的代码；Java
    模块系统在 [Recipe 2.5](ch02.html#javacook-environ-modules) 和 [Recipe 15.9](ch15.html#javacook-packages-creating-JPMS-modules)
    中有所讨论。
- en: 1.6 Downloading and Using the Code Examples
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.6 下载和使用代码示例
- en: Problem
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to try out my example code and/or use my utility classes.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你想试试我的示例代码和/或使用我的实用类。
- en: Solution
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Download the latest archive of the book source files, unpack it, and run Maven
    (see [Recipe 1.7](#javacook-getstarted-maven)) to compile the files.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 下载最新的书籍源文件存档，解压缩并运行 Maven（参见[配方 1.7](#javacook-getstarted-maven)）编译文件。
- en: Discussion
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The source code used as examples in this book is included in a couple of source
    code repositories that have been in continuous development since 1995. These are
    listed in [Table 1-2](#javacook-getstarted-TABLE-0).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 本书示例中使用的源代码包含在自 1995 年以来持续开发的几个源代码库中。这些列在[表 1-2](#javacook-getstarted-TABLE-0)中。
- en: Table 1-2\. The main source repositories
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Table 1-2\. 主要源代码库
- en: '| Repository name | GitHub URL | Package description | Approx. size |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 仓库名称 | GitHub 网址 | 包描述 | 大约大小 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| *javasrc* | [*http://github.com/IanDarwin/javasrc*](http://github.com/IanDarwin/javasrc)
    | Java code examples/demos | 1,400 classes |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| *javasrc* | [*http://github.com/IanDarwin/javasrc*](http://github.com/IanDarwin/javasrc)
    | Java 代码示例/演示 | 1,400 类 |'
- en: '| *darwinsys-api* | [*http://github.com/Iandarwin/darwinsys-api*](http://github.com/Iandarwin/darwinsys-api)
    | A published API | 200 classes |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| *darwinsys-api* | [*http://github.com/Iandarwin/darwinsys-api*](http://github.com/Iandarwin/darwinsys-api)
    | 已发布的 API | 200 类 |'
- en: You can download these repositories from the GitHub URLs shown in [Table 1-2](#javacook-getstarted-TABLE-0).
    GitHub allows you to download a ZIP file of the entire repository’s current state,
    as well as view individual files on the web interface. Downloading with *git clone*
    instead of as an archive is preferred because you can then update at any time
    with a simple *git pull* command. And with the amount of updating this code base
    has undergone for the current release of Java, you are sure to find changes after
    the book is published.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[表 1-2](#javacook-getstarted-TABLE-0)中显示的 GitHub 网址下载这些仓库。GitHub 允许您下载整个仓库当前状态的
    ZIP 文件，以及在 Web 界面上查看单个文件。使用 *git clone* 而不是作为存档进行下载更为推荐，因为您可以随时使用简单的 *git pull*
    命令进行更新。鉴于这个代码库为当前 Java 版本的发布进行了大量更新，您肯定会发现书籍出版后有所变化。
- en: If you are not familiar with Git, see [“CVS, Subversion, Git, Oh My!”](#javacook-getstarted-scms).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不熟悉 Git，请参阅 [“CVS, Subversion, Git, Oh My!”](#javacook-getstarted-scms)。
- en: javasrc
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: javasrc
- en: This is the largest repo and consists primarily of code written to show a particular
    feature or API. The files are organized into subdirectories by topic, many of
    which correspond more or less to book chapters—for example, a directory for *strings*
    examples ([Chapter 3](ch03.html#javacook-strings)), *regex* for regular expressions
    ([Chapter 4](ch04.html#javacook-regex)), *numbers* ([Chapter 5](ch05.html#javacook-numbers)),
    and so on. The archive also contains the index by name and index by chapter files
    from the download site, so you can easily find the files you need.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最大的仓库，主要包含用于展示特定功能或 API 的代码。文件按主题组织成子目录，其中许多与书籍章节大致对应，例如 *strings* 示例目录（[第 3
    章](ch03.html#javacook-strings)），*regex* 正则表达式目录（[第 4 章](ch04.html#javacook-regex)），*numbers*
    数字目录（[第 5 章](ch05.html#javacook-numbers)）等等。存档还包含按名称和按章节索引的文件，因此您可以轻松找到所需的文件。
- en: The *javasrc* library is further broken down into a dozen Maven modules (shown
    in [Table 1-3](#javacook_javasrc_modules)) so that you don’t need all the dependencies
    for everything on your `CLASSPATH` all the time.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*javasrc* 库进一步分解为十几个 Maven 模块（在[表 1-3](#javacook_javasrc_modules)中显示），这样你就不需要一直将所有依赖项放在
    `CLASSPATH` 上。'
- en: Table 1-3\. JavaSrc Maven modules
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Table 1-3\. JavaSrc Maven 模块
- en: '| Directory/module name | Description |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 目录/模块名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| *pom.xml* | Maven *parent pom* |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| *pom.xml* | Maven *parent pom* |'
- en: '| *Rdemo-web* | R demo using a web framework |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| *Rdemo-web* | 使用 Web 框架的 R 演示 |'
- en: '| *desktop* | AWT and Swing stuff (no longer covered in the *Java Cookbook*)
    |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| *desktop* | AWT 和 Swing 相关内容（不再包含在*Java Cookbook*中） |'
- en: '| *ee* | Enterprise stuff (no longer covered in the *Java Cookbook*) |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| *ee* | 企业相关内容（不再包含在*Java Cookbook*中） |'
- en: '| *graal* | GraalVM demos |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| *graal* | GraalVM 演示 |'
- en: '| *jlink* | JLink demos |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| *jlink* | JLink 演示 |'
- en: '| *json* | JSON processing |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| *json* | JSON 处理 |'
- en: '| *main* | Contains the majority of the files, i.e., those not required to
    be in one of the other modules due to `CLASSPATH` or other issues |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| *main* | 包含大多数文件，即不需要因为 `CLASSPATH` 或其他问题而放在其他模块中的文件 |'
- en: '| *restdemo* | REST service demo |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| *restdemo* | REST 服务演示 |'
- en: '| *spark* | Apache Spark demo |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| *spark* | Apache Spark 演示 |'
- en: '| *testing* | Code for testing |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| *testing* | 测试代码 |'
- en: '| *unsafe* | Demo of `Unsafe` class |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| *unsafe* | `Unsafe` 类演示 |'
- en: '| *xml* | XML stuff (no longer covered in the *Java Cookbook*) |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| *xml* | XML 相关内容（不再包含在*Java Cookbook*中） |'
- en: darwinsys-api
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: darwinsys-api
- en: I have built up a collection of useful stuff partly by moving some reusable
    classes from *javasrc* into my own API, which I use in my own Java projects. I
    use example code from it in this book, and I import classes from it into many
    of the other examples. So, if you’re going to be downloading and compiling the
    examples *individually*, you should first download the file *darwinsys-api-1.*x*.jar*
    (for the latest value of *x*) and include it in your `CLASSPATH`. Note that if
    you are going to build the *javasrc* code with Eclipse or Maven, you can skip
    this download because the top-level Maven script starts off by including the JAR
    file for this API.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我收集了一些有用的内容，部分是通过将一些可重复使用的类从 *javasrc* 移到我的 API 中实现的，我在自己的 Java 项目中使用它。我在本书中使用它的示例代码，并将其导入到许多其他示例中。因此，如果你打算单独下载和编译示例，你应该先下载文件
    *darwinsys-api-1.*x*.jar*（*x* 的最新值）并将其包含在你的 `CLASSPATH` 中。请注意，如果你打算使用 Eclipse
    或 Maven 构建 *javasrc* 代码，可以跳过此下载，因为顶级 Maven 脚本开始时包含了此 API 的 JAR 文件。
- en: 'A compiled JAR file of *darwinsys-api* is available in [Maven Central](http://search.maven.org);
    find it by searching for *darwinsys*. This is the current Maven artifact:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*darwinsys-api* 的编译 JAR 文件可在 [Maven Central](http://search.maven.org) 获取；搜索
    *darwinsys* 即可找到。当前的 Maven 构件如下：'
- en: '[PRE10]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This API consists of about two dozen `com.darwinsys` packages, listed in [Table 1-4](#javacook-getstarted-TABLE-1).
    The structure vaguely parallels the standard Java API; this is intentional. These
    packages now include around 200 classes and interfaces. Most of them have javadoc
    documentation that can be viewed with the source download.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 API 包含大约两打 `com.darwinsys` 包，如 [表 1-4](#javacook-getstarted-TABLE-1) 所示。其结构模糊地类似于标准
    Java API；这是有意为之。这些包目前包括约 200 个类和接口。其中大多数都有 javadoc 文档，可与源码一起下载查看。
- en: Table 1-4\. The com.darwinsys packages
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1-4\. com.darwinsys 包
- en: '| Package name | Package description |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: 包名称 | 包描述 |
- en: '| --- | --- |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `com.darwinsys.csv` | Classes for comma-separated values files |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `com.darwinsys.csv` | 处理逗号分隔值文件的类 |'
- en: '| `com.darwinsys.database` | Classes for dealing with databases in a general
    way |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `com.darwinsys.database` | 通用数据库操作类 |'
- en: '| `com.darwinsys.diff` | Comparison utilities |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `com.darwinsys.diff` | 比较工具 |'
- en: '| `com.darwinsys.genericui` | Generic GUI stuff |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `com.darwinsys.genericui` | 通用 GUI 组件 |'
- en: '| `com.darwinsys.geo` | Classes relating to country codes, provinces/states,
    and so on |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `com.darwinsys.geo` | 国家代码、省/州等相关类 |'
- en: '| `com.darwinsys.graphics` | Graphics |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `com.darwinsys.graphics` | 图形处理 |'
- en: '| `com.darwinsys.html` | Classes (only one so far) for dealing with HTML |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `com.darwinsys.html` | 处理 HTML 的类（目前只有一个） |'
- en: '| `com.darwinsys.io` | Classes for input and output operations, using Java’s
    underlying I/O classes |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `com.darwinsys.io` | 使用 Java 底层 I/O 类的输入输出操作类 |'
- en: '| `com.darwinsys.jsptags` | Java EE JSP tags |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `com.darwinsys.jsptags` | Java EE JSP 标签 |'
- en: '| `com.darwinsys.lang` | Classes for dealing with standard features of Java
    |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `com.darwinsys.lang` | 处理 Java 标准特性的类 |'
- en: '| `com.darwinsys.locks` | Pessimistic locking API |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `com.darwinsys.locks` | 悲观锁定 API |'
- en: '| `com.darwinsys.mail` | Classes for dealing with email, mainly a convenience
    class for sending mail |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `com.darwinsys.mail` | 邮件处理类，主要是发送邮件的便捷类 |'
- en: '| `com.darwinsys.model` | Sample data models |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `com.darwinsys.model` | 样例数据模型 |'
- en: '| `com.darwinsys.net` | Networking |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `com.darwinsys.net` | 网络操作 |'
- en: '| `com.darwinsys.preso` | Presentations |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `com.darwinsys.preso` | 演示文稿 |'
- en: '| `com.darwinsys.reflection` | Reflection |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `com.darwinsys.reflection` | 反射相关 |'
- en: '| `com.darwinsys.regex` | Regular expression stuff: an REDemo program, a Grep
    variant |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `com.darwinsys.regex` | 正则表达式工具：包含 REDemo 程序和一个 Grep 变种 |'
- en: '| `com.darwinsys.security` | Security |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `com.darwinsys.security` | 安全相关 |'
- en: '| `com.darwinsys.servlet` | Servlet API helpers |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `com.darwinsys.servlet` | Servlet API 辅助类 |'
- en: '| `com.darwinsys.sql` | Classes for dealing with SQL databases |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `com.darwinsys.sql` | 处理 SQL 数据库的类 |'
- en: '| `com.darwinsys.swingui` | Classes for helping construct and use Swing GUIs
    |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `com.darwinsys.swingui` | 辅助构建和使用 Swing GUI 的类 |'
- en: '| `com.darwinsys.swingui.layout` | A few interesting LayoutManager implementations
    |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `com.darwinsys.swingui.layout` | 几个有趣的 LayoutManager 实现 |'
- en: '| `com.darwinsys.testdata` | Test data generators |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `com.darwinsys.testdata` | 测试数据生成器 |'
- en: '| `com.darwinsys.testing` | Testing tools |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `com.darwinsys.testing` | 测试工具 |'
- en: '| `com.darwinsys.unix` | Unix helpers |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `com.darwinsys.unix` | Unix 辅助工具 |'
- en: '| `com.darwinsys.util` | A few miscellaneous utility classes |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `com.darwinsys.util` | 几个杂项实用类 |'
- en: '| `com.darwinsys.xml` | XML utilities |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `com.darwinsys.xml` | XML 工具 |'
- en: 'Many of these classes are used as examples in this book; just look for files
    whose first line begins with the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书中许多示例都使用这些类；只需查找以以下内容开头的文件即可：
- en: '[PRE11]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You’ll also find that many of the other examples have imports from the `com.darwinsys`
    packages.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 您还会发现许多其他示例引用了来自`com.darwinsys`包的导入。
- en: General notes
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一般注意事项
- en: Your best bet is to use *git clone* to download a copy of both the Git projects
    and then do a *git pull* every few months to get updates. Alternatively, you can
    download from this book’s [catalog page](http://shop.oreilly.com/product/0636920026518.do)
    a single intersection subset of both libraries that is made up almost exclusively
    of files actually used in the book. This archive is made from the sources that
    are dynamically included into the book at formatting time, so it should reflect
    exactly the examples you see in the book. But it will not include as many examples
    as the three individual archives, nor is it guaranteed that everything will compile
    because of missing dependencies, nor will it get updated often. But if all you
    want is to copy pieces into a project you’re working on, this may be the one to
    get. You can find links to all of these files from my own [website for this book](http://javacook.darwinsys.com);
    just follow the Downloads link.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 您最好使用*git clone*下载两个Git项目的副本，然后每隔几个月使用*git pull*获取更新。或者，您可以从本书的[目录页面](http://shop.oreilly.com/product/0636920026518.do)下载两个库的单个交集子集，该子集几乎完全由实际在书中使用的文件组成。此存档是从格式化时动态包含到书中的源文件创建的，因此它应该完全反映您在书中看到的示例。但它不会包括三个单独存档中的那么多示例，也不能保证由于缺少依赖关系而编译所有内容，也不会经常更新。但是，如果您只想将片段复制到正在进行的项目中，这可能是您要获取的内容。您可以从我自己的[本书网站](http://javacook.darwinsys.com)找到所有这些文件的链接；只需跟随下载链接即可。
- en: The two separate repositories contain multiple self-contained projects with
    support for building both with Eclipse ([Recipe 1.3](#javacook-getstarted-SECT-3))
    and with Maven ([Recipe 1.7](#javacook-getstarted-maven)). Note that Maven will
    automatically fetch a vast array of prerequisite libraries when first invoked
    on a given project, so be sure you’re online on a high-speed internet link. Maven
    will thus ensure that all prerequisites are installed before building. If you
    choose to build pieces individually, look in the file *pom.xml* for the list of
    dependencies. Unfortunately, I will not be able to help you if you are using tooling
    other than Eclipse or Maven with the control files included in the download.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个单独的存储库包含多个独立项目，支持在Eclipse（[Recipe 1.3](#javacook-getstarted-SECT-3)）和Maven（[Recipe
    1.7](#javacook-getstarted-maven)）中构建。请注意，第一次在特定项目上调用Maven时，它会自动获取大量的先决条件库，因此请确保您在高速互联网链接上线。因此，Maven将在构建之前确保安装所有先决条件。如果选择逐个构建各部分，请查看*pom.xml*文件中的依赖列表。如果您使用的工具不是Eclipse或包含在下载中的Maven，则很遗憾我无法帮助您。
- en: If you have a version of Java older than Java 12, a few files will not compile.
    You can make up exclusion elements for the files that are known not to compile.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的Java版本早于Java 12，则有几个文件无法编译。您可以为已知无法编译的文件创建排除元素。
- en: All my code in the two projects is released under the least-restrictive credit-only
    license, the two-clause BSD license. If you find it useful, incorporate it into
    your own software. There is no need to write to ask me for permission; just use
    it, with credit. If you get rich off it, send me some money.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这两个项目中的所有代码都是根据最不限制性的仅信用许可证——两条款BSD许可证发布的。如果您发现它有用，请将其合并到您自己的软件中。无需写信询问我的许可；只需使用它，并署名。如果您因此变得富裕，请给我寄些钱。
- en: Tip
  id: totrans-202
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Most of the command-line examples refer to source files, assuming you are in
    *src/main/java*, and runnable classes, assuming you are in (or have added to your
    `CLASSPATH`) the build directory (e.g., usually *target/classes*). This will not
    be mentioned with each example, as doing so would waste a lot of paper.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数命令行示例都涉及源文件，假设您在*src/main/java*目录中，并且可运行的类，假设您在（或已添加到您的`CLASSPATH`中）构建目录（例如，通常是*target/classes*）。每个示例都不会提到这一点，因为这样做会浪费很多纸张。
- en: Caveat lector
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Caveat lector
- en: 'The repos have been in development since 1995\. This means that you will find
    some code that is not up to date or that no longer reflects best practices. This
    is not surprising: any body of code will grow old if any part of it is not actively
    maintained. (Thus, at this point, I invoke Culture Club’s song “Do You Really
    Want to Hurt Me”: “Give me time to realize my crime.”) Where advice in the book
    disagrees with some code you found in the repo, keep this in mind. One of the
    practices of Extreme Programming is Continuous Refactoring, the ability to improve
    any part of the code base at any time. Don’t be surprised if the code in the online
    source directory differs from what appears in the book; it is a rare month that
    I don’t make some improvement to the code, and the results are committed and pushed
    quite often. So if there are differences between what’s printed in the book and
    what you get from GitHub, be glad, not sad, for you’ll have received the benefit
    of hindsight. Also, people can contribute easily on GitHub via pull requests;
    that’s what makes it interesting. If you find a bug or an improvement, do send
    me a pull request! The consolidated archive on [the page for this book](http://shop.oreilly.com/product/0636920304371.do)
    will not be updated as frequently.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这些仓库从 1995 年开始开发。这意味着你会发现一些不是最新的代码，或者不再反映最佳实践。这并不奇怪：如果其中任何部分不活跃地维护，任何代码库都会变旧。因此，在此时，我引用
    Culture Club 的歌曲“Do You Really Want to Hurt Me”：“给我时间意识到我的错误。”当这本书中的建议与您在仓库中发现的某些代码不一致时，请记住这一点。极限编程的一个实践是持续重构，即随时改进代码库的任何部分。如果在线源目录中的代码与书中的不同，请不要感到惊讶；我几乎每个月都会对代码进行一些改进，并且结果经常被提交和推送。所以如果书中打印的内容与您从
    GitHub 获取的内容有所不同，请高兴，而不是难过，因为您将受益于前瞻性。此外，人们可以通过拉取请求轻松在 GitHub 上做出贡献；这就是它变得有趣的地方。如果您发现错误或改进，请向我发送拉取请求！[本书页面](http://shop.oreilly.com/product/0636920304371.do)上的综合档案不会经常更新。
- en: 1.7 Automating Dependencies, Compilation, Testing, and Deployment with Apache
    Maven
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.7 使用 Apache Maven 自动处理依赖关系、编译、测试和部署
- en: Problem
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: 'You want a tool that does it all automatically: downloads your dependencies,
    compiles your code, compiles and runs your tests, packages the app, and installs
    or deploys it.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望有一个自动执行所有操作的工具：下载您的依赖项，编译您的代码，编译和运行您的测试，打包应用程序，并安装或部署它。
- en: Solution
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use Apache Maven.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Apache Maven。
- en: Discussion
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Maven is a Java-centric build tool that includes a sophisticated, distributed
    dependency management system that also gives it rules for building application
    packages such as JAR, WAR, and EAR files and deploying them to an array of different
    targets. Whereas older build tools focus on the *how*, Maven files focus on the
    *what*, specifying what you want done.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Maven 是一个以 Java 为中心的构建工具，它包括一个复杂的、分布式的依赖管理系统，同时也提供了构建应用程序包（如 JAR、WAR 和 EAR 文件）和将其部署到各种不同目标的规则。而老的构建工具关注于*如何*构建，Maven
    文件关注于*做什么*，指定你想要做什么。
- en: 'Maven is controlled by a file called *pom.xml* (for Project Object Model).
    A sample *pom.xml* might look like this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Maven 由一个名为 *pom.xml*（项目对象模型）的文件控制。一个示例 *pom.xml* 可能如下所示：
- en: '[PRE12]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This specifies a project called *my-se-project* (my standard-edition project)
    that will be packaged into a JAR file; it depends on the JUnit 4.x framework for
    unit testing (see [Recipe 1.10](#javacook-getstarted-junit)) but only needs it
    for compiling and running tests. If I type *mvn install* in the directory with
    this POM, Maven will ensure that it has a copy of the given version of JUnit (and
    anything that JUnit depends on). Then it will compile everything (setting CLASSPATH
    and other options for the compiler), run any and all unit tests, and if they all
    pass, generate a JAR file for the program. It will then install it in my personal
    Maven repo (under *~/.m2/repository*) so that other Maven projects can depend
    on my new project JAR file. Note that I haven’t had to tell Maven where the source
    files live, nor how to compile them—this is all handled by sensible defaults,
    based on a well-defined project structure. The program source is expected to be
    found in *src/main/java*, and the tests in *src/test/java*; if it’s a web application,
    the web root is expected to be in *src/main/webapp* by default. Of course, you
    can override these settings.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这指定了一个名为 *my-se-project*（标准版项目）的项目，将打包成一个 JAR 文件；它依赖于 JUnit 4.x 框架进行单元测试（参见
    [Recipe 1.10](#javacook-getstarted-junit)），但仅需要在编译和运行测试时。如果我在具有此 POM 文件的目录中键入
    *mvn install*，Maven 将确保我有给定版本的 JUnit 的副本（以及任何 JUnit 依赖的内容）。然后，它将编译所有内容（为编译器设置
    CLASSPATH 和其他选项），运行所有单元测试，如果所有测试通过，则为程序生成一个 JAR 文件。然后，它将安装它在我的个人 Maven 仓库（位于 *~/.m2/repository*），以便其他
    Maven 项目可以依赖于我的新项目的 JAR 文件。请注意，我不需要告诉 Maven 源文件的位置，也不需要告诉它如何编译它们——这一切都由合理的默认值处理，基于良好定义的项目结构。程序源代码预期在
    *src/main/java* 中找到，测试在 *src/test/java* 中找到；如果是 Web 应用程序，则默认情况下 Web 根目录预期在 *src/main/webapp*
    中。当然，您可以覆盖这些设置。
- en: 'Note that even the preceding config file does not have to be, and was not,
    written by hand; Maven’s archetype generation rules let it build the starting
    version of any of several hundred types of projects. Here is how the file was
    created:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，即使前面的配置文件也不必手工编写；Maven 的原型生成规则允许它构建几百种项目类型的初始版本。下面是文件的创建方式：
- en: '[PRE13]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Alternately, you can do *mvn archetype:generate* and select the default from
    a rather long list of choices. The default is a quickstart Java archetype, which
    makes it easy to get started.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以执行 *mvn archetype:generate*，并从一个相当长的选择列表中选择默认选项。默认选项是一个快速启动的 Java 原型，可以轻松入门。
- en: The IDEs (see [Recipe 1.3](#javacook-getstarted-SECT-3)) have support for Maven.
    For example, if you use Eclipse, M2Eclipse (m2e) is an Eclipse plug-in that will
    build your Eclipse project dependencies from your POM file; this plug-in ships
    by default with current Java Developer builds of Eclipse. It is also available
    for some older releases; see the [Eclipse website](http://eclipse.org/m2e) for
    plug-in details.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: IDE（参见 [Recipe 1.3](#javacook-getstarted-SECT-3)）支持 Maven。例如，如果您使用 Eclipse，M2Eclipse（m2e）是一个
    Eclipse 插件，可以根据 POM 文件构建您的 Eclipse 项目依赖项；该插件默认随当前 Java 开发者版的 Eclipse 发货。它也适用于一些旧版本；请参阅
    [Eclipse 网站](http://eclipse.org/m2e) 获取插件详细信息。
- en: 'A POM file can redefine any of the standard goals. Common Maven goals (predefined
    by default to do something sensible) include the following:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: POM 文件可以重新定义任何标准目标。常见的 Maven 目标（默认预定义为执行合理的操作）包括以下内容：
- en: clean
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: clean
- en: Removes all generated artifacts
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 移除所有生成的构件
- en: compile
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: compile
- en: Compiles all source files
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 编译所有源文件
- en: test
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: test
- en: Compiles and runs all unit tests
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行所有单元测试
- en: package
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: package
- en: Builds the package
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 构建包
- en: install
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: install
- en: Installs *pom.xml* and the package into your local Maven repository for use
    by your other projects
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 将 *pom.xml* 和包安装到您本地的 Maven 仓库，以供其他项目使用
- en: deploy
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: deploy
- en: Tries to install the package (e.g., on an application server)
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试安装包（例如，在应用服务器上）
- en: Most of the steps implicitly invoke the previous ones. For example, `package`
    will compile any missing *.class* files and run the tests if that hasn’t already
    been done in this run.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数步骤都会隐式地调用前面的步骤。例如，`package` 将编译任何缺失的 *.class* 文件，并在此次运行中运行测试（如果尚未完成）。
- en: There is an optional `distributionManagement` element in the POM file or a `-DaltDeploymentRepository`
    on the command line to specify an alternate deployment location. There are application-server–specific
    targets provided by the app server vendors; as a single example, with the WildFly
    Application Server (known as JBoss AS a decade or more ago), you would install
    some additional plug-in(s) as per their documentation and then deploy to the app
    server using
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: POM 文件中有一个可选的 `distributionManagement` 元素或命令行上的 `-DaltDeploymentRepository`，用于指定备用的部署位置。
    应用服务器供应商提供了特定于应用服务器的目标；例如，使用 WildFly 应用服务器（十多年前称为 JBoss AS），您可以按照其文档安装一些额外的插件，然后使用该应用服务器进行部署。
- en: '[PRE14]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: instead of the regular deploy. Since I use this Maven incantation frequently,
    I have a shell alias or batch file `mwd` to automate even that.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是常规部署。由于我经常使用这个 Maven 咒语，我有一个 shell 别名或批处理文件 `mwd` 来自动化甚至那个。
- en: Maven pros and cons
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Maven 的优缺点
- en: Maven can handle complex projects and is very configurable. I build the *darwinsys-api*
    and *javasrc* projects with Maven and let it handle finding dependencies, making
    the download of the project source code smaller (actually, moving the download
    overhead to the servers of the projects themselves). The only real downsides to
    Maven are that it takes a while to get fully up to speed with it, and it can be
    hard to diagnose when things go wrong. A good web search engine is your friend
    when things fail.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: Maven 可以处理复杂的项目并且非常可配置。 我使用 Maven 构建 *darwinsys-api* 和 *javasrc* 项目，并让其处理找到的依赖关系，使项目源代码的下载变小（实际上，将下载开销移到项目本身的服务器上）。
    Maven 的唯一真正缺点是需要一段时间来完全掌握它，并且当出现问题时很难进行诊断。 当事情失败时，一个好的网络搜索引擎是您的朋友。
- en: One issue I fear is that a hacker could gain access to a project’s site and
    modify, or install a new version of, a POM. Maven automatically fetches updated
    POM versions. However, it does use hash signatures to verify that files have not
    been tampered with during the download process, and all files to be uploaded must
    be signed with PGP/GPG, so an attacker would have to compromise both the upload
    account and the signing keys. I am not aware of this ever having happened though.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我担心的一个问题是，黑客可能会访问项目的站点并修改或安装 POM 的新版本。 Maven 会自动获取更新的 POM 版本。 但是，在下载过程中它确实使用哈希签名来验证文件未被篡改，并且所有要上传的文件必须使用
    PGP/GPG 签名，因此攻击者必须同时破坏上传帐户和签名密钥。 虽然我并不知道这种情况曾经发生过。
- en: See Also
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Start at [*http://maven.apache.org*](http://maven.apache.org).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*http://maven.apache.org*](http://maven.apache.org)开始。
- en: 1.8 Automating Dependencies, Compilation, Testing, and Deployment with Gradle
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.8 使用 Gradle 自动化依赖项、编译、测试和部署
- en: Problem
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want a build tool that doesn’t make you use a lot of XML in your configuration
    file.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望一个构建工具不要求您在配置文件中使用大量的 XML。
- en: Solution
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use Gradle’s simple build file format with configuration by convention for shorter
    build files and fast builds.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Gradle 的简单构建文件格式和按约定的配置，可以实现更短的构建文件和快速的构建。
- en: Discussion
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Gradle is the latest in the succession of build tools (Make, Ant, and Maven).
    Gradle bills itself as “the enterprise automation tool” and has integration with
    the other build tools and IDEs.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle 是构建工具（Make、Ant 和 Maven）的最新继任者。 Gradle 自称为“企业自动化工具”，并与其他构建工具和 IDE 集成。
- en: Unlike the other Java-based tools, Gradle doesn’t use XML as its scripting language,
    but rather a Domain-Specific Language (DSL) based on the JVM-based and Java-based
    scripting language [Groovy](http://groovy.codehaus.org).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他基于 Java 的工具不同，Gradle 不使用 XML 作为其脚本语言，而是使用基于 JVM 和基于 Java 的脚本语言[Groovy](http://groovy.codehaus.org)的领域特定语言（DSL）。
- en: You can install Gradle by downloading from the [Gradle website](http://gradle.org),
    unpacking the ZIP, and adding its *bin* subdirectory to your path.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过从[Gradle 网站](http://gradle.org)下载并解压 ZIP 文件，将其 *bin* 子目录添加到路径中来安装 Gradle。
- en: Then you can begin to use Gradle. Assuming you use the standard source directory
    (*src/main/java*, *src/main/test*) that is shared by Maven and Gradle, among other
    tools, the example *build.gradle* file in [Example 1-1](#javacook-getstarted-gradle-samplefile)
    will build your app and run your unit tests.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以开始使用 Gradle。 假设您使用标准的源目录（*src/main/java*、*src/main/test*），该目录被 Maven 和
    Gradle 等工具共享，在[Example 1-1](#javacook-getstarted-gradle-samplefile)中的示例 *build.gradle*
    文件将构建您的应用程序并运行单元测试。
- en: Example 1-1\. Example build.gradle file
  id: totrans-252
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 1-1\. 示例 build.gradle 文件
- en: '[PRE15]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can bootstrap the industry’s vast investment in Maven infrastructure by
    adding lines like these into your *build.gradle*:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过添加以下行到您的*build.gradle*文件中，来启动行业在Maven基础设施上的巨大投资：
- en: '[PRE16]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: See Also
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: There is much more functionality in Gradle. Start at [Gradle’s website](http://www.gradle.org),
    and see the [documentation](http://www.gradle.org/docs).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle中还有更多功能。从[Gradle的网站](http://www.gradle.org)开始，查看[文档](http://www.gradle.org/docs)。
- en: 1.9 Dealing with Deprecation Warnings
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.9 处理废弃警告
- en: Problem
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Your code used to compile cleanly, but now it gives deprecation warnings.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码曾经可以干净地编译，但现在出现了废弃警告。
- en: Solution
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: You must have blinked. Either live—dangerously—with the warnings or revise your
    code to eliminate them.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经忽略了。要么带着这些警告——危险地——生活，要么修改您的代码以消除它们。
- en: Discussion
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Each new release of Java includes a lot of powerful new functionality, but
    at a price: during the evolution of this new stuff, Java’s maintainers find some
    old stuff that wasn’t done right and shouldn’t be used anymore because they can’t
    really fix it. In the first major revision, for example, they realized that the
    `java.util.Date` class had some serious limitations with regard to internationalization.
    Accordingly, many of the `Date` class methods and constructors are marked “deprecated.”
    According to the *American Heritage Dictionary*, to deprecate something means
    to “express disapproval of; deplore.” Java’s developers are therefore disapproving
    of the old way of doing things. Try compiling this code:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 每个新版本的Java都包含大量强大的新功能，但代价是：在这些新功能的演变过程中，Java的维护者们发现了一些旧功能存在问题，因此不应再使用，因为它们无法真正修复。例如，在第一个主要修订版中，他们意识到`java.util.Date`类在国际化方面存在严重的限制。因此，`Date`类的许多方法和构造函数都被标记为“不推荐使用”。根据*美国传统词典*的定义，废弃（deprecate）意味着“表示不赞成；谴责”。因此，Java的开发者们不赞成旧的做法。尝试编译以下代码：
- en: '[PRE17]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'What happened? When I compiled it (prior to adding the `@SuppressWarnings()`
    annotation), I got this warning:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么？当我编译它时（在添加`@SuppressWarnings()`注解之前），我得到了这个警告：
- en: '[PRE18]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'So, we follow orders. For details, recompile with `-deprecation` to see the
    additional details:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们遵循指示。有关详细信息，请使用`-deprecation`重新编译以查看其他细节：
- en: '[PRE19]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The warning is simple: the `Date` constructor that takes three integer arguments
    has been deprecated. How do you fix it? The answer is, as in most questions of
    usage, to refer to the javadoc documentation for the class. The introduction to
    the `Date` page says, in part:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 警告很简单：接受三个整数参数的`Date`构造函数已被废弃。如何修复它？答案通常是查阅该类的javadoc文档。`Date`页面的介绍部分如下：
- en: The class `Date` represents a specific instant in time, with millisecond precision.
  id: totrans-271
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Date`类表示时间的特定时刻，精确到毫秒。'
- en: ''
  id: totrans-272
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Prior to JDK 1.1, the class `Date` had two additional functions. It allowed
    the interpretation of dates as year, month, day, hour, minute, and second values.
    It also allowed the formatting and parsing of date strings. Unfortunately, the
    API for these functions was not amenable to internationalization. As of JDK 1.1,
    the `Calendar` class should be used to convert between dates and time fields and
    the `DateFormat` class should be used to format and parse date strings. The corresponding
    methods in `Date` are deprecated.
  id: totrans-273
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在JDK 1.1之前，`Date`类具有两个额外的功能。它允许将日期解释为年、月、日、小时、分钟和秒的值。它还允许格式化和解析日期字符串。不幸的是，这些功能的API不适合国际化。从JDK
    1.1开始，应使用`Calendar`类在日期和时间字段之间进行转换，并使用`DateFormat`类格式化和解析日期字符串。`Date`中对应的方法已被废弃。
- en: 'And more specifically, in the description of the three-integer constructor,
    the `Date` javadoc says:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，在描述接受三个整数参数的构造函数时，`Date`的javadoc如下所示：
- en: '`Date(int year, int month, int date)`'
  id: totrans-275
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Date(int year, int month, int date)`'
- en: ''
  id: totrans-276
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Deprecated. As of JDK version 1.1, replaced by `Calendar.set(year + 1900`, `month`,
    `date)` or `GregorianCalendar(year + 1900`, `month`, `date)`.
  id: totrans-277
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 废弃。自JDK版本1.1起，被`Calendar.set(year + 1900, month, date)`或`GregorianCalendar(year
    + 1900, month, date)`所取代。
- en: Of course, the older `Date` class is replaced by `LocalDate` and `LocalDateTime`
    (see [Chapter 6](ch06.html#javacook-dates)), so you’d only see that particular
    example in legacy code, but the principles of dealing with deprecation warnings
    matter, because many new releases of Java add deprecation warnings to parts of
    the API that were previously “OK” to use.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，旧的`Date`类已被`LocalDate`和`LocalDateTime`所取代（参见[第6章](ch06.html#javacook-dates)），因此您只会在遗留代码中看到这个特定的例子，但处理废弃警告的原则很重要，因为许多Java的新版本都会对以前“可用”的API部分添加废弃警告。
- en: As a general rule, when something has been deprecated, you should not use it
    in any new code; and, when maintaining code, strive to eliminate the deprecation
    warnings.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，当某些东西被弃用时，你不应该在任何新代码中使用它；而在维护代码时，应努力消除弃用警告。
- en: In addition to `Date` (Java 8 includes a whole new date/time API; see [Chapter 6](ch06.html#javacook-dates)),
    the main areas of deprecation warnings in the standard API are the really ancient
    event handling and some methods (a few of them important) in the `Thread` class.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`Date`（Java 8包含一个全新的日期/时间API；参见[第6章](ch06.html#javacook-dates)）之外，在标准API中被弃用警告的主要领域是古老的事件处理和一些方法（其中一些很重要）在`Thread`类中。
- en: You can also deprecate your own code, when you come up with a better way of
    doing things. Put an `@Deprecated` annotation immediately before the class or
    method you wish to deprecate and/or use a `@deprecated` tag in a javadoc comment
    (see [Recipe 15.2](ch15.html#javacook-packages-javadoc)). The javadoc comment
    allows you to explain the deprecation, whereas the annotation is easier for some
    tools to recognize because it is present at runtime (so you can use Reflection;
    see [Chapter 17](ch17.html#javacook-reflection)).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想出更好的方法来做事情时，你也可以弃用自己的代码。在你希望弃用的类或方法之前立即放置一个`@Deprecated`注解和/或在javadoc注释中使用一个`@deprecated`标签（参见[Recipe
    15.2](ch15.html#javacook-packages-javadoc)）。javadoc注释允许你解释弃用，而注解对于一些工具更容易识别，因为它在运行时存在（所以你可以使用反射；参见[第17章](ch17.html#javacook-reflection)）。
- en: See Also
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Numerous other tools perform extra checking on your Java code. See my [Checking
    Java Programs](https://cjp.darwinsys.com/) website.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 许多其他工具对你的Java代码执行额外的检查。请参阅我的[Java程序检查](https://cjp.darwinsys.com/)网站。
- en: '1.10 Maintaining Code Correctness with Unit Testing: JUnit'
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.10 使用单元测试维护代码正确性：JUnit
- en: Problem
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You don’t want to have to debug your code.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 你不想调试你的代码。
- en: Solution
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use unit testing to validate each class as you develop it.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单元测试在开发每个类时验证它。
- en: Discussion
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Stopping to use a debugger is time-consuming, and finding a bug in released
    code is much worse! It’s better to *test* beforehand. The methodology of unit
    testing has been around for a long time; it is a tried-and-true means of getting
    your code tested in small blocks. Typically, in an OO language like Java, unit
    testing is applied to individual classes, in contrast to system or integration
    testing where a complete slice or even the entire application is tested.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 停止使用调试器是耗时的，而在发布的代码中找到错误则更糟糕！最好事先*测试*。单元测试方法论已经存在很长时间了；这是一种可靠的方法，可以将代码分成小块进行测试。通常，在像Java这样的面向对象语言中，单元测试是应用于单个类的，与系统或集成测试相反，在系统或集成测试中会测试完整的切片甚至整个应用程序。
- en: 'I have long been an advocate of this very basic testing methodology. Indeed,
    developers of the software methodology known as [Extreme Programming](http://www.extremeprogramming.org)
    (XP for short) advocate *Test-Driven Development* (TDD): writing the unit tests
    *before* you write the code. They also advocate running your tests almost every
    time you build your application. And they ask one good question: *If you don’t
    have a test, how do you know your code (still) works?* This group of unit-testing
    advocates has some well-known leaders, including Erich Gamma of *Design Patterns*
    book fame and Kent Beck of *eXtreme Programming* book fame (both Addison-Wesley).
    I definitely go along with their advocacy of unit testing.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我长期以来一直是这种非常基本的测试方法的支持者。确实，被称为[极限编程](http://www.extremeprogramming.org)（简称XP）的软件方法论的开发者倡导*测试驱动开发*（TDD）：在编写代码之前编写单元测试。他们还主张几乎每次构建应用程序时都运行测试。他们提出了一个很好的问题：*如果你没有测试，你怎么知道你的代码（还）能工作？*这个单元测试倡导者群体有一些著名的领导者，包括因*设计模式*而著名的Erich
    Gamma和因*eXtreme Programming*而著名的Kent Beck（都是Addison-Wesley的作者）。我绝对支持他们对单元测试的倡导。
- en: Indeed, many of my classes used to come with a “built-in” unit test. Classes
    that are not main programs in their own right would often include a `main` method
    that just tests out or at least exercises the functionality of the class. What
    surprised me is that, before encountering XP, I used to think I did this often,
    but an actual inspection of two projects indicated that only about a third of
    my classes had test cases, either internally or externally. Clearly what is needed
    is a uniform methodology. That is provided by JUnit.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我的许多类过去都附带“内置”单元测试。那些不是其自身主程序的类通常会包含一个 `main` 方法，该方法仅测试或至少练习类的功能。令我惊讶的是，在遇到
    XP 之前，我经常认为我经常这样做，但实际检查了两个项目后发现，只有大约三分之一的类有测试用例，无论是内部还是外部。显然需要的是一种统一的方法论。这由 JUnit
    提供。
- en: JUnit is a Java-centric methodology for providing test cases, and can be [downloaded
    for free](http://www.junit.org). It is a very simple but useful testing tool.
    It is easy to use—you just write a test class that has a series of methods and
    annotate them with `@Test` (the older JUnit 3.8 required you to have test methods’
    names begin with `test`). JUnit uses introspection (see [Chapter 17](ch17.html#javacook-reflection))
    to find all these methods and then runs them for you. Extensions to JUnit handle
    tasks as diverse as load testing and testing enterprise components; the JUnit
    website provides links to these extensions. All modern IDEs provide built-in support
    for generating and running JUnit tests.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 是一个以 Java 为中心的提供测试用例的方法论，可以免费下载。它是一个非常简单但有用的测试工具。它易于使用 — 您只需编写一个测试类，其中包含一系列方法，并用
    `@Test` 注解它们（较旧的 JUnit 3.8 要求测试方法的名称以 `test` 开头）。JUnit 使用内省（参见 [Chapter 17](ch17.html#javacook-reflection)）查找所有这些方法，然后为您运行它们。JUnit
    的扩展处理各种任务，如负载测试和测试企业组件；JUnit 网站提供了这些扩展的链接。所有现代 IDE 都提供内置支持来生成和运行 JUnit 测试。
- en: 'How do you get started using JUnit? All that’s necessary is to write a test.
    Here I have written a simple test of my `Person` class and placed it into a class
    called `PersonTest` (note the obvious naming pattern):'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如何开始使用 JUnit？只需编写一个测试就可以了。这里我已经写了一个简单的测试我的 `Person` 类，并将它放在一个名为 `PersonTest`
    的类中（请注意显而易见的命名模式）：
- en: '[PRE20]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: JUnit 4 has been around for ages and works well. JUnit 5 is only a few years
    old and has some improvements. A simple test like this `PersonTest` class will
    be the same in JUnit 4 or 5 (but with different imports). Using additional features,
    like setup methods to be run before each test, requires different annotations
    between JUnit 4 and 5.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 4 已经存在很长时间并且运行良好。JUnit 5 只有几年历史并且有一些改进。像这样的简单测试 `PersonTest` 类在 JUnit
    4 或 5 中是相同的（但导入不同）。使用额外功能，如设置方法在每个测试之前运行，需要在 JUnit 4 和 5 之间使用不同的注解。
- en: 'To show you running `PersonTest` manually, I compile the test and invoke the
    command-line test harness `TestRunner`:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示手动运行 `PersonTest`，我编译测试并调用命令行测试工具 `TestRunner`：
- en: '[PRE21]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In practice, running tests that way is incredibly tedious, so I just put my
    tests in the standard directory structure (i.e., *src/test/java/*) with the same
    package as the code being tested and run Maven (see [Recipe 1.7](#javacook-getstarted-maven)),
    which will automatically compile and run all the unit tests and will halt the
    build if any test fails, *every time you try to build, package, or deploy your
    application*. Gradle will do so too.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，以这种方式运行测试非常繁琐，因此我只是将测试放在标准目录结构中（即 *src/test/java/*），与被测试的代码包相同，并运行 Maven（参见
    [Recipe 1.7](#javacook-getstarted-maven)），它会自动编译和运行所有单元测试，并在任何测试失败时中止构建，*每次尝试构建、打包或部署应用时*。Gradle
    也会这样做。
- en: All modern IDEs provide built-in support for running JUnit tests; in Eclipse,
    you can right-click a project in the Package Explorer and select Run As→Unit Test
    to have it find and run all the JUnit tests in the entire project. The `MoreUnit`
    plugin (free in the Eclipse Marketplace) aims to simplify creation and running
    of tests.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 所有现代 IDE 都提供内置支持来运行 JUnit 测试；在 Eclipse 中，您可以在 Package Explorer 中右键单击项目，然后选择
    Run As→Unit Test，它会找到并运行整个项目中的所有 JUnit 测试。`MoreUnit` 插件（在 Eclipse Marketplace
    免费提供）旨在简化测试的创建和运行。
- en: The *Hamcrest matchers* allow you to write more expressive tests at the cost
    of an additional download. Support for them is built into JUnit 4 with the `assertThat`
    static method, but you need to download the matchers from [Hamcrest](http://hamcrest.org)
    or via the Maven artifact.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '*Hamcrest matchers* 允许您编写更具表达力的测试，但需要额外下载。在 JUnit 4 中内置了支持它们的 `assertThat`
    静态方法，但您需要从 [Hamcrest](http://hamcrest.org) 下载匹配器或通过 Maven 构件获取。'
- en: 'Here’s an example of using the Hamcrest matchers:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用 Hamcrest 匹配器的一个例子：
- en: '[PRE22]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: See Also
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: JUnit offers considerable documentation of its own; download it from the website
    listed earlier.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 本身提供了大量的文档；可以从之前列出的网站下载。
- en: An alternative unit test framework for Java is *TestNG*; it got some early traction
    by adopting features such as Java annotations before JUnit did; but since JUnit
    got with the annotations program, it has remained the dominant package for Java
    unit testing.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: Java 的另一个备选单元测试框架是*TestNG*；它通过采用诸如 Java 注解等功能而获得了一些早期的吸引力，但自从 JUnit 跟随注解程序后，它仍然是
    Java 单元测试的主要包。
- en: Another package of interest is [AssertJ](https://assertj.github.io/doc), which
    appears to offer similar power to the combination of JUnit with Hamcrest.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个感兴趣的包是[AssertJ](https://assertj.github.io/doc)，它似乎提供了与 JUnit 结合使用的 Hamcrest
    相似的功能强大的能力。
- en: Finally, one often needs to create substitute objects for use by the class being
    tested (the dependencies of the class under test). While you can code these by
    hand, in general I encourage use of packages such as [Mockito](https://site.mockito.org),
    which can generate *mock objects* dynamically, have these mocks provide fixed
    return values, verify that the dependencies were called correctly, and so on.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，人们经常需要创建替代对象来供被测试的类使用（被测试类的依赖项）。虽然你可以手工编写这些，但通常我鼓励使用诸如[Mockito](https://site.mockito.org)这样的包，它可以动态生成*模拟对象*，让这些模拟对象提供固定的返回值，验证依赖项是否被正确调用等功能。
- en: 'Remember: *test early and often!*'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：*尽早、经常地进行测试！*
- en: 1.11 Maintaining Your Code with Continuous Integration
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.11 使用持续集成维护你的代码
- en: Problem
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to be sure that your entire code base compiles and passes its tests
    periodically.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望确保整个代码库定期编译并通过其测试。
- en: Solution
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use a Continuous Integration server such as Jenkins/Hudson.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像 Jenkins/Hudson 这样的持续集成服务器。
- en: Discussion
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: If you haven’t previously used Continuous Integration, you are going to wonder
    how you got along without it. CI is simply the practice of having all developers
    on a project periodically *integrate* (e.g., commit) their changes into a single
    master copy of the project’s source and then building and testing the project
    to make sure it still works and passes its tests. This might be a few times a
    day, or every few days, but should not be more than that or else the integration
    will likely run into larger hurdles where multiple developers have modified the
    same file.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前没有使用过持续集成（Continuous Integration，CI），你会想知道在没有它的情况下是如何运作的。CI 简单来说就是让项目中的所有开发者定期地*集成*（比如提交）他们的变更到项目源代码的一个单一主副本中，然后构建和测试项目，确保它仍然能正常工作并通过其测试。这可能是每天几次，或者每几天一次，但不应该更频繁，否则集成可能会遇到更大的障碍，因为多个开发者可能已修改了同一文件。
- en: But it’s not just big projects that benefit from CI. Even on a one-person project,
    it’s great to have a single button you can click that will check out the latest
    version of everything, compile it, link or package it, run all the automated tests,
    and give a red or green pass/fail indicator. Better yet, it can do this automatically
    every day or even on every commit to the master branch.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 但并不只是大型项目从 CI 中受益。即使在一个人的项目中，拥有一个可以点击的单一按钮来检出所有最新版本的东西，编译它，链接或打包它，运行所有自动化测试，并给出红色或绿色的通过/失败指示器也是非常棒的。更好的是，它可以每天自动执行，甚至在每次提交到主分支时都可以自动执行。
- en: It’s not just code-based projects that benefit from CI. If you have a number
    of small websites, putting them all under CI control is one of several important
    steps toward developing an automated, DevOps culture around website deployment
    and management.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅仅是基于代码的项目从 CI 中受益。如果你有多个小型网站，将它们全部纳入 CI 控制是朝着围绕网站部署和管理开发自动化、DevOps 文化的几个重要步骤之一。
- en: If you are new to the idea of CI, I can do no better than to plead with you
    to read Martin Fowler’s insightful (as ever) [paper on the topic](http://martinfowler.com/articles/continuousIntegration.html).
    One of the key points is to automate both the *management* of the code *and* all
    the other artifacts needed to build your project, and to automate the actual process
    of *building* it, possibly using one of the build tools discussed earlier in this
    chapter.^([1](ch01.html#idm45290706957032))
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对 CI 的概念还很陌生，我无法做得比恳请你阅读马丁·福勒（Martin Fowler）的深思熟虑的（正如他一直以来所做的）[关于这个主题的论文](http://martinfowler.com/articles/continuousIntegration.html)更好了。其中一个关键点是自动化代码的*管理*以及构建项目所需的所有其他工件，并自动化*构建*实际过程，可能使用本章前面讨论过的其中一个构建工具。^([1](ch01.html#idm45290706957032))
- en: There are many CI servers, both free and commercial. In the open source world,
    [CruiseControl](http://cruisecontrol.sourceforge.net) and Jenkins/Hudson^([2](ch01.html#idm45290706953272))
    are among the best known CI servers that you deploy yourself. There are also hosted
    solutions such as [Travis CI](https://travis-ci.com), [TeamCity](https://www.jetbrains.com/teamcity),
    or [CircleCI](https://circleci.com). These hosted ones eliminate the need for
    setting up and running your own CI server. They also tend to have their configuration
    right in your repo (*travis.yml* etc.) so deployment to them is simplified.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CI 服务器中有许多免费和商业选择。在开源世界中，[CruiseControl](http://cruisecontrol.sourceforge.net)
    和 Jenkins/Hudson^([2](ch01.html#idm45290706953272)) 是你自己部署的最知名的 CI 服务器之一。还有托管解决方案，如
    [Travis CI](https://travis-ci.com)，[TeamCity](https://www.jetbrains.com/teamcity)，或
    [CircleCI](https://circleci.com)。这些托管解决方案消除了设置和运行自己的 CI 服务器的需要。它们也倾向于在你的存储库中有其配置（如
    *travis.yml* 等），因此向它们部署变得更加简单。
- en: 'Jenkins runs as a web application, either inside a Jakarta EE server or in
    its own standalone web server. Once it’s started, you can use any standard web
    browser as its user interface. Installing and starting Jenkins can be as simple
    as unpacking a distribution and invoking it as follows:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins 作为一个 Web 应用程序运行，可以在 Jakarta EE 服务器内或者作为独立的 Web 服务器运行。一旦它启动了，你可以使用任何标准的
    Web 浏览器作为其用户界面。安装和启动 Jenkins 可以像解压分发文件和调用如下所示那样简单：
- en: '[PRE23]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This will start up its own tiny web server. If you do that, be sure to configure
    security if your machine is reachable from the internet!
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动自己的一个小型 Web 服务器。如果你这样做，请确保配置安全性，如果你的机器可以从互联网访问到！
- en: Many people find it more secure to run Jenkins in a full-function Java EE or
    Java web server; anything from Tomcat to JBoss to WebSphere or Weblogic will do
    the job and let you impose additional security constraints.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人发现将 Jenkins 运行在一个完整功能的 Java EE 或 Java Web 服务器中更安全；从 Tomcat 到 JBoss 再到 WebSphere
    或 Weblogic，都可以完成这项工作并让你施加额外的安全约束。
- en: Once Jenkins is up and running and you have enabled security and are logged
    in on an account with sufficient privilege, you can create *jobs*. A job usually
    corresponds to one project, both in terms of origin (one source code checkout)
    and in terms of results (one *.war* file, one executable, one library, one whatever).
    Setting up a project is as simple as clicking the New Job button at the top left
    of the dashboard, as shown in [Figure 1-6](#jvck_0112).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Jenkins 启动并运行，并且你已经启用了安全性并且以具有足够权限的帐户登录，你可以创建*任务*。一个任务通常对应一个项目，无论是源代码检出（一个源代码检出）还是结果（一个
    *.war* 文件，一个可执行文件，一个库，一个任何东西）。设置一个项目就像在仪表板左上角点击“新建任务”按钮那样简单，如 [图 1-6](#jvck_0112)
    所示。
- en: 'You can fill in the first few pieces of information: the project’s name and
    a brief description. Note that each and every input field has a question mark
    icon beside it, which will give you hints as you go along. Don’t be afraid to
    peek at these hints! [Figure 1-7](#jvck_0113) shows the first few steps of setting
    up a new job.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以填写前几个信息：项目的名称和简要描述。请注意，每个输入字段旁边都有一个问号图标，这将在你填写时给你提示。不要害怕偷看这些提示！ [图 1-7](#jvck_0113)
    显示了设置新任务的前几个步骤。
- en: 'In the next few sections of the form, Jenkins uses dynamic HTML to make entry
    fields appear based on what you’ve checked. My demo project “TooSmallToFail” starts
    off with no Source Code Management (SCM) repository, but your real project is
    probably already in Git, Subversion, or ome other SCM. Don’t worry if yours is
    not listed; there are hundreds of plug-ins to handle almost any SCM. Once you’ve
    chosen your SCM, you will enter the parameters to fetch the project’s source from
    that SCM repository, using text fields that ask for the specifics needed for that
    SCM: a URL for Git, a CVSROOT for CVS, and so on.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在表单的接下来几个部分中，Jenkins 使用动态 HTML 来根据你选择的内容显示输入字段。我的演示项目“TooSmallToFail”开始时没有源代码管理（SCM）仓库，但你的真实项目可能已经在
    Git、Subversion 或其他 SCM 中。如果你的 SCM 没有在列表中，不要担心；有数百个插件可以处理几乎任何 SCM。一旦选择了你的 SCM，你将会进入到提取项目源代码的参数设置页面，使用文本字段请求
    SCM 需要的具体信息：Git 的 URL，CVS 的 CVSROOT 等等。
- en: '![jcb4 0106](assets/jcb4_0106.png)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![jcb4 0106](assets/jcb4_0106.png)'
- en: Figure 1-6\. The dashboard in Jenkins
  id: totrans-329
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-6\. Jenkins 仪表板
- en: '![jcb4 0107](assets/jcb4_0107.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![jcb4 0107](assets/jcb4_0107.png)'
- en: Figure 1-7\. Creating a new job in Jenkins
  id: totrans-331
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-7\. 在 Jenkins 中创建一个新任务
- en: You also have to tell Jenkins *when* and *how* to build (and package, test,
    deploy…) your project. For the *when*, you have several choices such as building
    it after another Jenkins project, building it every so often based on a cron-like
    schedule, or based on polling the SCM to see if anything has changed (using the
    same cron-like scheduler). If your project is at GitHub (not just a local Git
    server), or some other SCMs, you can have the project built whenever somebody
    pushes changes up to the repository. It’s all a matter of finding the right plug-ins
    and following the documentation for them.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要告诉Jenkins *何时* 和 *如何* 构建（以及打包、测试、部署…）您的项目。对于*何时*，您有几种选择，例如在另一个Jenkins项目之后构建，根据类似cron的定时表定期构建，或者根据轮询SCM以查看是否有任何更改（使用相同的cron样式调度程序）。如果您的项目位于GitHub（而不仅仅是本地Git服务器）或其他某些SCM上，则可以在有人将更改推送到存储库时构建项目。这完全取决于找到合适的插件并按照其文档进行操作。
- en: 'Then we have the *how*, or the build process. Again, a few build types are
    included with Jenkins, and many more are available as plug-ins: I’ve used Apache
    Maven, Gradle, the traditional Unix `make` tool, and even shell or command lines.
    As before, text fields specific to your chosen tool will appear once you select
    the tool. In the toy example, `TooSmallToFail`, I just use the shell command */bin/false*
    (which should be present on any Unix or Linux system) to ensure that the project
    does, in fact, fail to build, just so you can see what that looks like.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是*how*，即构建过程。同样，在Jenkins中包含了几种构建类型，并且还有许多插件可供选择：我使用过Apache Maven、Gradle、传统的Unix
    `make`工具，甚至是shell或命令行。与之前一样，一旦选择了工具，将会显示特定于所选工具的文本字段。在玩具示例中，`TooSmallToFail`，我只是使用shell命令*/bin/false*（这在任何Unix或Linux系统上都应该存在），以确保项目实际上无法构建，这样您就可以看到其表现如何。
- en: You can have zero or more build steps; just keep clicking the Add button and
    add additional ones, as shown in [Figure 1-8](#jvck_0114).
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以拥有零个或多个构建步骤；只需不断点击添加按钮并添加额外的步骤，如[图1-8](#jvck_0114)所示。
- en: '![jcb4 0108](assets/jcb4_0108.png)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![jcb4 0108](assets/jcb4_0108.png)'
- en: Figure 1-8\. Configuration for SCM and adding build steps in Jenkins
  id: totrans-336
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-8\. 在Jenkins中配置SCM并添加构建步骤
- en: Once you think you’ve entered all the necessary information, click the Save
    button at the bottom of the page, and you’ll go back to the project’s main page.
    Here you can click the funny little Build Now icon at the far left to initiate
    a build right away. Or if you have set up build triggers, you could wait until
    they kick in; but then again, wouldn’t you rather know right away whether you’ve
    got it just right? [Figure 1-9](#jvck_0115) shows the build starting.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您认为已输入所有必要信息，请点击页面底部的保存按钮，您将返回到项目的主页面。在这里，您可以点击最左边的有趣的小“立即构建”图标来启动构建。或者，如果您设置了构建触发器，您可以等待它们启动；但再次，您是否宁愿立即知道是否做得恰到好处？[图1-9](#jvck_0115)显示构建正在开始。
- en: Should a job fail to build, you get a red ball instead of a green one. Actually,
    a successful build shows a blue ball by default (the *go* bulb in Japanese traffic
    lights, where Kohsuke lives, is blue rather than green), but most people outside
    Japan prefer green for success, so the optional Green Balls plug-in is often one
    of the first to be added to a new installation.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 如果作业未能构建，您将看到一个红色的球而不是绿色的。实际上，默认情况下，成功的构建显示为蓝色球（日本交通灯中的*go*灯泡是蓝色而不是绿色，Kohsuke居住的地方），但大多数人在日本以外地区更喜欢绿色来表示成功，因此可选的Green
    Balls插件通常是新安装中首先添加的插件之一。
- en: Beside the red or green ball, you will see a weather report ranging from sunny
    (the last several builds have succeeded) to cloudy, rainy, or stormy (no recent
    builds have succeeded).
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 除了红色或绿色的球，您还会看到一个天气报告，从晴朗（最近几次构建成功）到多云、雨天或暴风雨（最近没有构建成功）不等。
- en: Click the link to the project that failed, and then the link to Console Output,
    and figure out what went wrong. The usual workflow is then to make changes to
    the project, commit/push them to the source code repository, and run the Jenkins
    build again.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 点击失败的项目链接，然后点击控制台输出的链接，找出问题所在。通常的工作流程是对项目进行更改，将其提交/推送到源代码库，并再次运行Jenkins构建。
- en: '![jcb4 0109](assets/jcb4_0109.png)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![jcb4 0109](assets/jcb4_0109.png)'
- en: Figure 1-9\. After a new job is added in Jenkins
  id: totrans-342
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-9\. 在Jenkins中添加新作业后
- en: There are *hundreds* of optional plug-ins for Jenkins. To make your life easier,
    almost all of them can be installed by clicking the Manage Jenkins link and then
    going to Manage Plug-ins. The Available tab lists all the ones that are available
    from Jenkins.org; you just need to click the checkbox beside the ones you want,
    and click Apply. You can also find updates there. If your plug-in addtion or upgrade
    requires a restart, you’ll see a yellow ball and words to that effect; otherwise
    you should see a green (or blue) ball indicating plug-in success. You can also
    see the list of plug-ins [directly on the web](https://wiki.jenkins-ci.org/display/JENKINS/Plugins).
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins 有*数百*个可选插件。为了让您的生活更轻松，几乎所有这些插件都可以通过点击“管理 Jenkins”链接，然后转到“管理插件”来安装。可用选项卡列出了来自
    Jenkins.org 的所有可用插件；您只需勾选您想要的插件旁边的复选框，然后点击应用。您也可以在那里找到更新。如果您的插件添加或升级需要重新启动，则会看到一个黄色球和相关的字样；否则，您应该看到一个表示插件成功的绿色（或蓝色）球。您还可以直接在网上查看插件列表：[链接](https://wiki.jenkins-ci.org/display/JENKINS/Plugins)。
- en: I mentioned that Jenkins began life under the name Hudson. The Hudson project
    still exists and is hosted at the Eclipse website. Last I checked, both projects
    had maintained plug-in compatibility, so many or most plug-ins from one can be
    used with the other. In fact, the most popular plug-ins appear in the Available
    tab of both, and most of what’s said in this recipe about Jenkins applies equally
    to Hudson. If you use a different CI system, you’ll need to check that system’s
    documentation, but the concepts and the benefits will be similar.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到过 Jenkins 最初以 Hudson 的名字开始。Hudson 项目仍然存在，并托管在 Eclipse 网站上。据我上次检查，两个项目都保持了插件的兼容性，因此一个项目中的许多或大多数插件可以与另一个项目一起使用。事实上，最受欢迎的插件在两个项目的可用选项卡中都有，并且关于
    Jenkins 的这个配方所说的大部分内容同样适用于 Hudson。如果您使用不同的 CI 系统，则需要检查该系统的文档，但概念和好处将是相似的。
- en: 1.12 Getting Readable Stack Traces
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.12 获取可读的堆栈跟踪
- en: Problem
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You’re getting an exception stack trace at runtime, but most of the important
    parts don’t have line numbers.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，您会得到一个异常堆栈跟踪，但其中大部分重要部分没有行号。
- en: Solution
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Be sure you have compiled with debugging enabled.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 确保已启用调试编译。
- en: Discussion
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'When a Java program throws an exception, the exception propagates up the call
    stack until there is a `catch` clause that matches it. If none is found, the Java
    interpreter program that invoked your `main()` method catches the exception and
    prints a stack traceback showing all the method calls that got from the top of
    the program to the place where the exception was thrown. You can print this traceback
    yourself in any `catch` clause: the `Throwable` class has several overloads of
    the method called `printStackTrace()`.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Java 程序引发异常时，异常会沿调用堆栈传播，直到找到一个匹配的 `catch` 子句。如果找不到，则调用了您的 `main()` 方法的 Java
    解释程序会捕获异常并打印堆栈跟踪，显示从程序顶部到引发异常的地方的所有方法调用。您可以在任何 `catch` 子句中打印此跟踪：`Throwable` 类有几个名为
    `printStackTrace()` 的方法重载。
- en: The traceback includes line numbers only if they were compiled in. When using
    *javac*, this is the default. If you add the `-g` option, *javac* will also include
    local variable names and other information in the compiled code, which will make
    for better debugging information in the event of a crash.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪包含行号仅在编译时包含。在使用 *javac* 时，这是默认设置。如果添加了 `-g` 选项，*javac* 还将在编译代码中包含局部变量名称和其他信息，这将使得在崩溃事件中获得更好的调试信息。
- en: 1.13 Finding More Java Source Code
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.13 查找更多 Java 源代码
- en: Problem
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to build a large application and need to minimize coding, avoiding
    the “Not Invented Here” syndrome.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 你想构建一个大型应用程序，需要尽量减少编码，避免“自行发明”综合症。
- en: Solution
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the Source, Luke. There are thousands of Java apps, frameworks, and libraries
    available in open source.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 使用源码，卢克。有数千个 Java 应用程序、框架和库可供使用。
- en: Discussion
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Java source code is everywhere. As mentioned earlier, all the code examples
    from this book can be downloaded: see [Recipe 1.6](#javacook-getstarted-samplecode).'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: Java 源代码随处可见。如前所述，本书的所有代码示例都可以下载：参见 [Recipe 1.6](#javacook-getstarted-samplecode)。
- en: Another valuable resource is the source code for the Java API. You may not have
    realized it, but the source code for all the public parts of the Java API are
    included with each release of the Java Development Kit. Want to know how `java.util.ArrayList`
    actually works? You have the source code. Got a problem making a `JTable` behave?
    The standard JDK includes the source for all the public classes! Look for a file
    called *src.zip* or *src.jar*; some versions unzip this and some do not.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有价值的资源是Java API的源代码。你可能没有意识到，但Java API所有公共部分的源代码都包含在每个Java开发工具包的发布版中。想知道`java.util.ArrayList`是如何工作的？你有源代码。在制作`JTable`行为时遇到问题？标准JDK包含所有公共类的源代码！寻找一个名为*src.zip*或*src.jar*的文件；有些版本会解压缩它，有些不会。
- en: If that’s not enough, you can get the source for the whole JDK for free over
    the internet, either via the Mercurial source code librarian at [*openjdk.java.net*](http://hg.openjdk.java.net/jdk/jdk)
    or from the Git mirror at [AdoptOpenJDK at *github.com*](https://github.com/AdoptOpenJDK/openjdk-jdk).
    This includes the source for the public and nonpublic parts of the API, as well
    as the compiler (written in Java) and a large body of code written in C/C++ (the
    runtime itself and the interfaces to the native library). For example, `java.io.Reader`
    has a method called `read()`, which reads bytes of data from a file or network
    connection. There is a version of this written in C for each operating system
    because it calls down to the `read()` system call for Unix, Windows, macOS, or
    whatever. The JDK source kit includes the source for all this stuff.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这还不够，你可以免费通过互联网获取整个JDK的源代码，可以通过[*openjdk.java.net*](http://hg.openjdk.java.net/jdk/jdk)的Mercurial源代码库管理员或[AdoptOpenJDK在*github.com*](https://github.com/AdoptOpenJDK/openjdk-jdk)的Git镜像。这包括公共和非公共API部分的源代码，以及编译器（用Java编写）和大量用C/C++编写的代码（运行时本身和与本机库的接口）。例如，`java.io.Reader`有一个名为`read()`的方法，它从文件或网络连接读取数据字节。这个方法的每个操作系统版本都有用C语言编写，因为它调用Unix、Windows、macOS或其他操作系统的`read()`系统调用。JDK源代码包括所有这些东西的源代码。
- en: 1.14 Finding Runnable Java Libraries
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.14 寻找可运行的Java库
- en: Problem
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to reuse a published library rather than reinventing a well-known solution
    to your problem at hand.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望重用已发布的库，而不是重新发明手头问题的众所周知的解决方案。
- en: Solution
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the internet to find reusable software.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 利用互联网寻找可重用的软件。
- en: Discussion
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Although most of this book is about writing Java code, this recipe is about
    *not* writing code, but about using code written by others. There are hundreds
    of good frameworks to add to your Java application—why reinvent the flat tire
    when you can buy a perfectly round one? Many of these frameworks have been around
    for years and have become well rounded by feedback from users.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本书的大部分内容都是关于编写Java代码，但本节是关于*不*编写代码，而是使用他人编写的代码。有数百个优秀的框架可用于增强你的Java应用程序——为什么要重新发明轮子，当你可以买一个完美圆的？许多这些框架已经存在多年，并通过用户的反馈变得非常成熟。
- en: What, though, is the difference between a library and a framework? It’s sometimes
    a bit vague, but in general, a framework is a program with holes that you fill
    in, whereas a library is code you call. It is roughly the difference between building
    a car by buying a car almost complete but with no engine and building a car by
    buying all the pieces and bolting them together yourself.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是库和框架之间的区别？有时候这个区分有些模糊，但总体来说，框架是一个带有你需要填充的空白的程序，而库是你调用的代码。这大致相当于通过购买一个几乎完整但没有引擎的汽车来建造汽车，与购买所有零件并自己将它们螺栓在一起建造汽车的区别。
- en: When considering using a third-party framework, there are many choices and issues
    to consider. One is cost, which gets into the issue of open source versus closed
    source. Most open source tools can be downloaded for free and used, either without
    any conditions or with conditions that you must comply with. There is not the
    space here to discuss these licensing issues, so I will refer you to *[Understanding
    Open Source and Free Software Licensing](http://shop.oreilly.com/product/9780596005818.do)*
    (O’Reilly).
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑使用第三方框架时，有许多选择和需要考虑的问题。其中一个是成本，涉及开源与闭源的问题。大多数开源工具可以免费下载和使用，要么没有任何条件，要么有你必须遵守的条件。在这里没有足够的空间来讨论这些许可问题，因此我会推荐你阅读《[理解开源和自由软件许可证](http://shop.oreilly.com/product/9780596005818.do)》（O’Reilly）。
- en: 'Much open source software is available in compiled library form on Maven Central,
    as discussed in [“Maven Central: Mapping the World of Java Software”](#javacook-getstarted-mavencentral).'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '大量开源软件以编译库的形式在 Maven 中央仓库上提供，详见 [“Maven Central: Mapping the World of Java
    Software”](#javacook-getstarted-mavencentral)。'
- en: Some well-known collections of open source frameworks and libraries for Java
    are listed in [Table 1-5](#chAppDesign-SECT-1-TABLE-1). Most of the projects on
    these sites are curated—that is, judged and found worthy—by some sort of community
    process.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是列出的一些知名的 Java 开源框架和库，详见 [Table 1-5](#chAppDesign-SECT-1-TABLE-1)。这些站点上的大多数项目都经过了社区审查，即经过某种形式的社区过程评判和认可。
- en: Table 1-5\. Reputable open source Java collections
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: Table 1-5\. Java 可信赖的开源集合
- en: '| Organization | URL | Notes |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| 组织 | URL | 备注 |'
- en: '| --- | --- | --- |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Apache Software Foundation | [*http://projects.apache.org*](http://projects.apache.org)
    | Not just a web server! |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '| Apache 软件基金会 | [*http://projects.apache.org*](http://projects.apache.org)
    | 不仅仅是一个网页服务器！ |'
- en: '| Eclipse Software Foundation | [*https://eclipse.org/projects*](https://eclipse.org/projects)
    | Home of IDE and of Jakarta EE |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '| Eclipse 软件基金会 | [*https://eclipse.org/projects*](https://eclipse.org/projects)
    | IDE 的家园，也是 Jakarta EE 的主场 |'
- en: '| Spring Framework | [*http://spring.io/projects*](http://spring.io/projects)
    | Home to a dozen frameworks: Spring IOC (DI factory), Spring MVC (web), more
    |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '| Spring 框架 | [*http://spring.io/projects*](http://spring.io/projects) | 包含数十个框架：Spring
    IOC（DI 工厂）、Spring MVC（Web）、等等 |'
- en: '| JBoss community | [*https://redhatofficial.github.io/*](https://redhatofficial.github.io/)
    | Lists half a dozen of their projects, plus a long list of current open source
    projects they use and/or support. |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '| JBoss 社区 | [*https://redhatofficial.github.io/*](https://redhatofficial.github.io/)
    | 列出了他们的数个项目，以及他们当前使用和/或支持的许多开源项目。 |'
- en: '| Codehaus |  —  | See footnote^([a](ch01.html#idm45290706818824)) |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '| Codehaus |  —  | 见脚注^([a](ch01.html#idm45290706818824)) |'
- en: '| ^([a](ch01.html#idm45290706818824-marker)) Codehaus itself went offline a
    few years ago. As of 2019, the domain is owned by the Apache Software Foundation
    but does not respond to browser requests. There is also [a Codehaus account on
    github](https://github.com/codehaus) holding some of the projects that were previously
    on Codehaus, some active and some not. See [this article](https://www.javaworld.com/article/2892227/codehaus-the-once-great-house-of-code-has-fallen.html)
    for more on the history of Codehaus. |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '| ^([a](ch01.html#idm45290706818824-marker)) Codehaus 几年前已经下线。截至2019年，该域名归
    Apache 软件基金会所有，但不再响应浏览器请求。GitHub 上仍有 [Codehaus 的帐户](https://github.com/codehaus)，其中包含一些此前在
    Codehaus 上的项目，有些活跃，有些不活跃。详见 [本文](https://www.javaworld.com/article/2892227/codehaus-the-once-great-house-of-code-has-fallen.html)
    了解 Codehaus 的历史。 |'
- en: There are also a variety of open source code repositories, which are not curated—anybody
    who signs up can create a project there, regardless of the existing community
    size (if any). Sites like this that are successful accumulate too many projects
    to have a single page listing them—you have to search. Most are not specific to
    Java. [Table 1-6](#chAppDesign-SECT-1-TABLE-2) shows some of the open source code
    repos.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有各种开源代码库，这些库未经过审查，任何注册用户都可以在那里创建项目，无论现有社区的大小如何（如果有的话）。成功的站点积累了太多的项目，无法在单个页面列出它们
    —— 您必须搜索。大多数并非专门针对 Java。[Table 1-6](#chAppDesign-SECT-1-TABLE-2) 展示了一些开源代码库。
- en: Table 1-6\. Open source code repositories
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: Table 1-6\. 开源代码库
- en: '| Name | URL | Notes |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | URL | 备注 |'
- en: '| --- | --- | --- |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Sourceforge.net | [*https://sourceforge.net/*](https://sourceforge.net/)
    | One of the oldest |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
  zh: '| Sourceforge.net | [*https://sourceforge.net/*](https://sourceforge.net/)
    | 最古老之一 |'
- en: '| GitHub | [*http://github.com/*](http://github.com/) | “Social Coding”; probably
    most heavily used, now owned by Microsoft |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
  zh: '| GitHub | [*http://github.com/*](http://github.com/) | “社交编码”；目前可能是使用最广泛的，现在由微软拥有
    |'
- en: '| Bitbucket | [*https://bitbucket.org/*](https://bitbucket.org/) | Public and
    private repos; free and paid plans |'
  id: totrans-388
  prefs: []
  type: TYPE_TB
  zh: '| Bitbucket | [*https://bitbucket.org/*](https://bitbucket.org/) | 公共和私有仓库；免费和付费计划
    |'
- en: '| GitLab | [*https://gitlab.org/*](https://gitlab.org/) | Public and private
    repos; free and paid plans |'
  id: totrans-389
  prefs: []
  type: TYPE_TB
  zh: '| GitLab | [*https://gitlab.org/*](https://gitlab.org/) | 公共和私有仓库；免费和付费计划 |'
- en: '| Maven Central | [*https://search.maven.org/*](https://search.maven.org/)
    | Has compiled jar, source jar and javadoc jar for each project |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
  zh: '| Maven 中央仓库 | [*https://search.maven.org/*](https://search.maven.org/) | 每个项目均有编译
    jar、源码 jar 和 javadoc jar |'
- en: I’m not trying to disparage these repositories—indeed, the collection of demo
    programs for this book is hosted on GitHub. I’m only saying that you have to know
    what you’re looking for and exercise a bit of care before deciding on a framework.
    Is there a community around it, or is it a dead end?
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: I maintain a small [Java site](https://darwinsys.com/java) that may be of value.
    It includes a listing of Java resources and material related to this book.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: 'For the Java enterprise or web tier, there are two main frameworks that also
    provide dependency injection: the first is JavaServer Faces (JSF) and CDI, and
    the second is the Spring Framework SpringMVC package. JSF and the built-in CDI
    (Contexts and Dependency Injection) provides DI as well as some additional contexts,
    such as a very useful Web Conversation context that holds objects across multiple
    web page interactions. The Spring Framework provides dependency injection and
    the SpringMVC web-tier helper classes. [Table 1-7](#chAppDesign-SECT-1-TABLE-3)
    shows some web tier resources. Spring MVC and JSF are far from the only web frameworks;
    the list in [Table 1-7](#chAppDesign-SECT-1-TABLE-3) includes many others, which
    may be a better fit for your application. You have to decide!'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: Table 1-7\. Web tier resources
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | URL | Notes |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
- en: '| Ian’s List of 100 Java Web Frameworks | [*http://darwinsys.com/jwf/*](http://darwinsys.com/jwf/)
    |  |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
- en: '| JSF | [*http://www.oracle.com/technetwork/java/javaee/overview/*](http://www.oracle.com/technetwork/java/javaee/overview/)
    | Java EE standard technology for web pages |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
- en: Because JSF is a component-based framework, there are many add-on components
    that will make your JSF-based website much more capable (and better looking) than
    the default JSF components. [Table 1-8](#chAppDesign-SECT-1-TABLE-4) shows some
    of the JSF add-on libraries.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: Table 1-8\. JSF add-on libraries
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | URL | Notes |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
- en: '| BootsFaces | [*https://bootsfaces.net/*](https://bootsfaces.net/) | Combines
    BootStrap with JSF |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
- en: '| ButterFaces | [*http://butterfaces.org/*](http://butterfaces.org/) | Rich
    components library |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
- en: '| ICEfaces | [*http://icefaces.org/*](http://icefaces.org/) | Rich components
    library |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
- en: '| OpenFaces | [*http://openfaces.org/*](http://openfaces.org/) | Rich components
    library |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
- en: '| PrimeFaces | [*http://primefaces.org/*](http://primefaces.org/) | Rich components
    library |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
- en: '| RichFaces | [*http://richfaces.org/*](http://richfaces.org/) | Rich components;
    no longer maintained |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
- en: '| Apache DeltaSpike | [*http://deltaspike.apache.org/*](http://deltaspike.apache.org/)
    | Numerous code add-ons for JSF |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
- en: '| JSFUnit | [*http://www.jboss.org/jsfunit/*](http://www.jboss.org/jsfunit/)
    | JUnit Testing for JSF |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
- en: '| OmniFaces | [*http://omnifaces.org/*](http://omnifaces.org/) | JSF Utilities
    add-on |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
- en: There are frameworks and libraries for almost everything these days. If my lists
    don’t lead you to what you need, a web search probably will. Try not to reinvent
    the flat tire!
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: As with all free software, be sure that you understand the ramifications of
    the various licensing schemes. Code covered by the GPL, for example, automatically
    transfers the GPL to any code that uses even a small part of it. Consult a lawyer.
    Your mileage may vary. Despite these caveats, the source code is an invaluable
    resource to the person who wants to learn more Java.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 就像所有免费软件一样，请确保您理解各种许可方案的后果。例如，GPL 下的代码会自动将 GPL 转移到使用其中任何一小部分的代码上。请咨询律师。结果可能有所不同。尽管存在这些警告，源代码对于想要深入了解
    Java 的人来说是一种无价的资源。
- en: ^([1](ch01.html#idm45290706957032-marker)) If the deployment or build includes
    a step like “Get Smith to process file X on his desktop and copy to the server,”
    you probably don’t quite get the notion of automated testing.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch01.html#idm45290706957032-marker)) 如果部署或构建包括“让史密斯在他的桌面上处理文件 X 并复制到服务器”的步骤，那么您可能还不太理解自动化测试的概念。
- en: ^([2](ch01.html#idm45290706953272-marker)) [Jenkins](http://jenkins-ci.org)
    and [Hudson](https://www.eclipse.org/hudson) began as Hudson, largely written
    by Kohsuke Kawaguchi while working for Sun Microsystems. There was later a cultural
    spat that resulted in Jenkins splitting off from Hudson, creating a new fork of
    the project. Kohsuke works on the half now known as Jenkins. I’ll just use the
    name Jenkins, because that’s the one I use, and because it takes too long to say
    “Jenkins/Hudson” all the time. But almost everything here applies to Hudson as
    well.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch01.html#idm45290706953272-marker)) [Jenkins](http://jenkins-ci.org)
    和 [Hudson](https://www.eclipse.org/hudson) 最初是 Hudson，由小林克树在 Sun Microsystems
    工作时编写的。后来发生了文化冲突，导致 Jenkins 从 Hudson 中分离出来，创建了项目的一个新分支。小林克树现在致力于后来被称为 Jenkins
    的部分。我会一直使用 Jenkins 这个名字，因为这是我使用的名字，而且每次都说“Jenkins/Hudson”太长了。但几乎这里的所有内容也适用于 Hudson。
