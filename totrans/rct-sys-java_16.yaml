- en: 'Chapter 12\. Reactive REST Client: Connecting with HTTP Endpoints'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 12 章\. 反应式 REST 客户端：与 HTTP 端点连接
- en: The previous two chapters focused on messaging, the connective tissue of reactive
    systems. Modern message brokers provide the perfect feature set to implement the
    internal communication of reactive systems. However, at the frontier of your system,
    where you need to integrate remote services, there’s a good chance you need to
    use HTTP. So let’s be pragmatic and see how we can consume HTTP services without
    breaking the reactive principles.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 前两章专注于消息传递，这是反应式系统的连接组件。现代消息代理提供了完美的功能集来实现反应式系统的内部通信。然而，在系统的前沿，当您需要集成远程服务时，您很有可能需要使用
    HTTP。因此，让我们务实一点，看看如何在不违反反应式原则的情况下消费 HTTP 服务。
- en: 'In [Chapter 8](ch08.html#http), you saw how to *expose* reactive HTTP endpoints.
    This chapter presents the other side: how to *consume* HTTP endpoints. Quarkus
    offers a nonblocking way to consume HTTP endpoints. In addition, it provides resilience
    features to protect the integration points against failures and slowness. It’s
    important to notice that the called service does not have to be a reactive application.
    That’s up to the implementation of that service.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 8 章](ch08.html#http) 中，您看到如何 *公开* 反应式 HTTP 端点。本章介绍另一方面：如何 *消费* HTTP 端点。Quarkus
    提供了一种非阻塞方式来消费 HTTP 端点。此外，它提供了可靠性特性，以保护集成点免受故障和缓慢的影响。重要的是要注意，被调用的服务不一定是反应式应用程序，这取决于该服务的实现。
- en: Let’s see what Quarkus offers to consume HTTP endpoints.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 Quarkus 提供了哪些功能来消费 HTTP 端点。
- en: Interacting with an HTTP Endpoint
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 HTTP 端点交互
- en: 'Quarkus provides multiple ways to consume HTTP endpoints:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus 提供了多种消费 HTTP 端点的方式：
- en: Vert.x Web Client
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Vert.x Web 客户端
- en: This low-level HTTP client is implemented on top of Vert.x and Netty (and so
    is inherently asynchronous and based on nonblocking I/O).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这种低级别的 HTTP 客户端是基于 Vert.x 和 Netty 实现的（因此本质上是异步的，基于非阻塞 I/O）。
- en: Reactive Messaging connector
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式消息连接器
- en: This connector sends HTTP requests for each processed message.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 此连接器为每个处理的消息发送 HTTP 请求。
- en: REST client
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: REST 客户端
- en: This type-safe approach eases the consumption of HTTP-based APIs.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型安全的方法简化了消费基于 HTTP 的 API。
- en: Vert.x Web Client is convenient when you don’t want to bother being exposed
    to low-level HTTP details, such as verbs, headers, bodies, and response status.
    The web client is flexible, and you have complete control over the HTTP request
    and the response processing.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当您不想被暴露于底层 HTTP 细节（如动词、头部、主体和响应状态）时，Vert.x Web 客户端是非常方便的选择。Web 客户端灵活，并且您可以完全控制
    HTTP 请求和响应处理。
- en: To use Vert.x Web Client, you need to add the dependency shown in [Example 12-1](#dep-vertx-client)
    in your project.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Vert.x Web 客户端，您需要在项目中添加 [示例 12-1](#dep-vertx-client) 中显示的依赖项。
- en: Example 12-1\. Dependency for Mutiny Vert.x Web Client
  id: totrans-14
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-1\. Mutiny Vert.x Web 客户端的依赖项
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Then you can use it as shown in [Example 12-2](#http-vertx-client).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然后您可以按照 [示例 12-2](#http-vertx-client) 中所示使用它。
- en: Example 12-2\. Vert.x Web Client example
  id: totrans-17
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-2\. Vert.x Web 客户端示例
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, you need to create and close `WebClient` yourself. It exposes
    a Mutiny API, so it integrates perfectly within your Quarkus application.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，您需要自己创建并关闭 `WebClient`。它暴露了 Mutiny API，因此它完美地集成在您的 Quarkus 应用程序中。
- en: The HTTP reactive connector integrates with Reactive Messaging (see [Chapter 10](ch10.html#messaging))
    and allows sending HTTP requests for each message. It’s convenient when you design
    a message-processing pipeline where the outbound is an HTTP endpoint. It handles
    the backpressure and controls the amount of concurrency (number of in-flight requests)
    but does not allow processing the response.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 反应式连接器集成了反应式消息传递（见 [第 10 章](ch10.html#messaging)），允许为每条消息发送 HTTP 请求。当您设计一个消息处理流水线，其中出站是
    HTTP 端点时，这非常方便。它处理背压并控制并发量（正在处理的请求数量），但不允许处理响应。
- en: To use this HTTP connector, you need the dependency shown in [Example 12-3](#dep-http-connect).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此 HTTP 连接器，您需要 [示例 12-3](#dep-http-connect) 中显示的依赖项。
- en: Example 12-3\. Dependency for the HTTP connector
  id: totrans-22
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-3\. HTTP 连接器的依赖项
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Then you can configure the connector as shown in [Example 12-4](#http-send-messages).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以按照 [示例 12-4](#http-send-messages) 中所示配置连接器。
- en: Example 12-4\. Use the HTTP connector to send messages using HTTP POST requests
  id: totrans-25
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-4\. 使用 HTTP 连接器通过 HTTP POST 请求发送消息
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[![1](assets/1.png)](#co_reactive_rest_client__connecting___span_class__keep_together__with_http_endpoints__span__CO1-1)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_reactive_rest_client__connecting___span_class__keep_together__with_http_endpoints__span__CO1-1)'
- en: Instruct Quarkus to use the `quarkus-http` connector to manage the `my-http-endpoint`
    channel.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 指示 Quarkus 使用 `quarkus-http` 连接器管理 `my-http-endpoint` 通道。
- en: '[![2](assets/2.png)](#co_reactive_rest_client__connecting___span_class__keep_together__with_http_endpoints__span__CO1-2)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_reactive_rest_client__connecting___span_class__keep_together__with_http_endpoints__span__CO1-2)'
- en: Configure the HTTP method to use.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 配置要使用的 HTTP 方法。
- en: '[![3](assets/3.png)](#co_reactive_rest_client__connecting___span_class__keep_together__with_http_endpoints__span__CO1-3)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_reactive_rest_client__connecting___span_class__keep_together__with_http_endpoints__span__CO1-3)'
- en: Configure the URL of the service to invoke.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 配置要调用的服务的 URL。
- en: By default, the connector encodes the received messages to JSON. You can also
    configure a custom serializer. The connector also supports retries and time-out
    but, as said earlier, does not allow processing the response. Any non-2*XX* HTTP
    response is considered a failure and will nack the message.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，连接器将接收到的消息编码为 JSON。你还可以配置自定义序列化器。连接器还支持重试和超时，但正如前面所述，不允许处理响应。任何非2*XX*
    HTTP 响应都被视为失败，并将 NACK 消息。
- en: The last approach, the REST client, offers a declarative way to invoke an HTTP
    service. It implements the [MicroProfile REST Client specification](https://oreil.ly/dX0Lv).
    Instead of dealing with the HTTP requests and responses, you map the HTTP API
    in a Java interface. Thanks to a couple of annotations, you express how to send
    the request and process the response. The client uses the same JAX-RS annotations
    as the server side; see [Example 12-5](#eg-rest-client).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: REST 客户端提供了一种声明性的方式来调用 HTTP 服务。它实现了[MicroProfile REST Client 规范](https://oreil.ly/dX0Lv)。你无需处理
    HTTP 请求和响应，只需将 HTTP API 映射到一个 Java 接口中。通过几个注解，你可以表达如何发送请求和处理响应。客户端使用与服务器端相同的 JAX-RS
    注解；详见[示例 12-5](#eg-rest-client)。
- en: Example 12-5\. Example of REST client
  id: totrans-35
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-5\. REST 客户端示例
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The application uses the method from the interface directly. The rest of this
    chapter focuses on the REST client and how to integrate it in reactive applications,
    including how to handle failure gracefully.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序直接使用接口中的方法。本章的其余部分重点介绍 REST 客户端以及如何在响应式应用程序中集成它，包括如何优雅地处理故障。
- en: The REST Client Reactive
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式 REST 客户端
- en: We need to be careful. Lots of *asynchronous* HTTP and REST clients do not use
    nonblocking I/O and instead delegate the HTTP requests to an internal thread pool.
    This is not the case with the reactive REST client from Quarkus. It relies on
    the reactive architecture of Quarkus. Note that it’s not because it’s reactive
    that you can’t use it in a blocking manner. As with most Quarkus features, you
    have the choice. Even if you decide to use the blocking way, Quarkus would continue
    using I/O threads and delegate the calls on a worker thread for your application.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要小心。许多*异步* HTTP 和 REST 客户端并未使用非阻塞 I/O，而是将 HTTP 请求委托给内部线程池。但这不适用于 Quarkus
    的响应式 REST 客户端。它依赖于 Quarkus 的响应式架构。请注意，尽管它是响应式的，但你仍然可以以阻塞的方式使用它。与大多数 Quarkus 特性一样，你可以选择使用方式。即使你决定使用阻塞方式，Quarkus
    仍会继续使用 I/O 线程，并将调用委托给应用程序的工作线程。
- en: To use the reactive REST client in Quarkus, add the dependency in [Example 12-6](#dep-react-rest-client)
    to your project.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Quarkus 中使用响应式 REST 客户端，请将依赖项添加到[示例 12-6](#dep-react-rest-client)所述的项目中。
- en: Example 12-6\. Dependency for the reactive REST client (*chapter-12/rest-client-example/pom.xml*)
  id: totrans-41
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-6\. 用于响应式 REST 客户端的依赖（*chapter-12/rest-client-example/pom.xml*）
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you plan to use JSON, which is often the case when using HTTP services, also
    add the dependency in [Example 12-7](#dep-jackson-support).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果计划使用 JSON（在使用 HTTP 服务时通常如此），还需在[示例 12-7](#dep-jackson-support)中添加依赖项。
- en: Example 12-7\. Dependency for the Jackson support for the reactive REST client
    (*chapter-12/rest-client-example/pom.xml*)
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-7\. 用于支持响应式 REST 客户端的 Jackson 依赖（*chapter-12/rest-client-example/pom.xml*）
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The dependency adds the ability to serialize the request body into JSON and
    deserialize JSON payloads into objects.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 此依赖项增加了将请求体序列化为 JSON 并将 JSON 载荷反序列化为对象的能力。
- en: Mapping HTTP APIs to Java Interfaces
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 HTTP API 映射到 Java 接口
- en: The cornerstone of the REST client is a Java interface that represents the consumed
    HTTP endpoint. This interface represents the HTTP API your application consumes.
    It acts as a facade, enabling your application to avoid dealing with HTTP directly.
    On each method of the interface, you use JAX-RS annotations to describe how to
    handle the HTTP request and response. Let’s consider an example. Imagine that
    you need to integrate the [`httpbin`](https://httpbin.org) service. To call the
    */uuid* endpoint (which returns a UUID), you need to create a Java interface with
    the method representing the call; see [Example 12-8](#client-httpbin).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-8\. REST client for the `httpbin` service (*chapter-12/rest-client-example/src/main/java/org/acme/restclient/HttpApi.java*)
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first important fact about this interface is the `@RegisterRestClient` annotation.
    It indicates that the interface represents an HTTP endpoint. The `configKey` attribute
    defines the key we will use to configure the HTTP endpoint, such as the location.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, this interface has a single method: `getUUID`. When the application
    calls this method, it sends a `GET` request to `/uuid`, waits for the response,
    and reads the response body as `String`. We define this behavior by using the
    `@GET` and `@Path` annotations.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Let’s add a method by using another HTTP method, as shown in [Example 12-9](#send-json-payloads).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-9\. Send JSON payloads
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Calling this method sends a `POST` request on `/anything` with a JSON payload
    as the body. The reactive REST client maps the instance of `Person` to JSON. You
    can also use the `@Consume` annotation to set `content-type` explicitly.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: The REST client also lets you configure the request headers. These headers can
    be constant and defined by using the `@ClientHeaderParam` annotation or can be
    passed as a method parameter by using the `@HeaderParam` annotation; see [Example 12-10](#pass-headers).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-10\. Pass headers
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: To pass query parameters, use the `@QueryParameter` annotation ([Example 12-11](#pass-query-params)).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-11\. Pass query parameters
  id: totrans-61
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let’s now look at the response. So far, we used only `String`, but the REST
    client can map the response to objects. If we go back to the initial example (`/uuid`),
    it returns a JSON object with a single field: `uuid`. We can map this response
    into an object, as shown in [Example 12-12](#receive-json-objs).'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-12\. Receive JSON objects
  id: totrans-64
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: By default, the REST client uses JSON to map the responses to objects. You can
    use the `@Produces` annotation to configure the `Accept` header.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: If you want to handle the HTTP response yourself, to retrieve the status code
    or headers, you can return a `Response`, as shown in [Example 12-13](#use-responses).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-13\. Use responses
  id: totrans-68
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It’s the same `Response` as in [“Dealing with Failure and Customizing the Response”](ch08.html#response).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Mapping an HTTP API to a Java interface introduces a clear contract and avoids
    having HTTP code everywhere in the application code. It also improves testability
    as you can quickly mock the remote service. Finally, note that you don’t have
    to map all the endpoints of the remote service, only the one you use in your application.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 将 HTTP API 映射到 Java 接口引入了一个清晰的契约，并避免了在应用程序代码中到处使用 HTTP 代码。它还提高了可测试性，因为你可以快速模拟远程服务。最后，请注意，你不必映射远程服务的所有端点，只需映射你在应用程序中使用的端点即可。
- en: Invoking the Service
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用服务
- en: 'To use the interface we defined in the previous section in your application,
    we need to do the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要在应用程序中使用我们在前一节中定义的接口，我们需要执行以下步骤：
- en: Inject the REST client in the application code.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序代码中注入 REST 客户端。
- en: Configure the URL of the service.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置服务的 URL。
- en: The first step is straightforward; we just need to inject the client, as shown
    in [Example 12-14](#use-httpbin-client).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步很简单；我们只需要像 [示例 12-14](#use-httpbin-client) 中所示注入客户端即可。
- en: Example 12-14\. Use the HTTPBin REST client (*chapter-12/rest-client-example/src/main/java/org/acme/restclient/HttpEndpoint.java*)
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-14\. 使用 HTTPBin REST 客户端 (*chapter-12/rest-client-example/src/main/java/org/acme/restclient/HttpEndpoint.java*)
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `@RestClient` qualifier indicates that the injected object is a REST client.
    Once it’s injected, you can use any of the methods you have defined on the interface.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`@RestClient` 限定符表示注入的对象是一个 REST 客户端。一旦它被注入，你就可以使用你在接口上定义的任何方法。'
- en: 'To configure the client, open the *application.properties* file and add the
    following property:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置客户端，打开 *application.properties* 文件并添加以下属性：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `httpbin` part is the configuration key used in the `@RegisterRestClient`
    interface. Here we configure only the location, but you can configure [a lot more](https://oreil.ly/rD1tL).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`httpbin` 部分是在 `@RegisterRestClient` 接口中使用的配置键。在这里我们只配置了位置，但你可以[配置更多](https://oreil.ly/rD1tL)。'
- en: Of course, the URL can also be passed at runtime by using the `httpbin/mp-rest/url`
    system property or the `HTTPBIN_MP_REST_URL` environment property.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，URL 也可以在运行时通过使用 `httpbin/mp-rest/url` 系统属性或 `HTTPBIN_MP_REST_URL` 环境属性传递。
- en: Blocking and Nonblocking
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阻塞和非阻塞
- en: As said previously, the reactive REST client from Quarkus supports both imperative
    (blocking) methods and reactive (nonblocking) methods. The distinction is made
    by using the return type. In [“Mapping HTTP APIs to Java Interfaces”](#http-client-mapping),
    all our returned types are synchronous. So Quarkus blocks the caller thread until
    the reception of the HTTP responses. This is not great in terms of Reactive. Fortunately,
    you can avoid this by changing the return types to `Uni`, as shown in [Example 12-15](#mutiny-rest-client).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Quarkus 的响应式 REST 客户端支持即时（阻塞）方法和反应式（非阻塞）方法。通过返回类型来区分。在 [“将 HTTP API 映射到
    Java 接口”](#http-client-mapping) 中，我们所有的返回类型都是同步的。因此，Quarkus 会阻塞调用线程，直到接收到 HTTP
    响应。这在响应式方面不是很好。幸运的是，你可以通过将返回类型更改为 `Uni` 来避免这种情况，就像 [示例 12-15](#mutiny-rest-client)
    中所示的那样。
- en: Example 12-15\. Use Mutiny in the REST client interfaces
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-15\. 在 REST 客户端接口中使用 Mutiny
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: By returning `Uni` instead of the direct result type, you instruct the REST
    client not to block the caller thread. Even better, it will use the current I/O
    thread, embrace the asynchronous execution model, and avoid additional thread
    switches.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通过返回 `Uni` 而不是直接的结果类型，你指示 REST 客户端不要阻塞调用线程。更好的是，它将使用当前的 I/O 线程，采用异步执行模型，并避免额外的线程切换。
- en: On the consumer side, you just use `Uni` and append the processing of the response
    to your pipeline ([Example 12-16](#http-client-reactive-api)).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在消费者端，你只需使用 `Uni` 并将响应的处理附加到你的管道中（[示例 12-16](#http-client-reactive-api)）。
- en: Example 12-16\. Use the reactive API of the REST client
  id: totrans-90
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-16\. 使用 REST 客户端的响应式 API
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this example, we handle the subscription ourselves. Don’t forget that you
    often rely on Quarkus to take care of this. For example, returning `Uni` from
    a RESTEasy Reactive endpoint subscribes on the returned `Uni`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们自己处理订阅。不要忘记，你通常依赖于 Quarkus 来处理这个。例如，从 RESTEasy 反应式端点返回 `Uni` 将订阅返回的
    `Uni`。
- en: Handling Failures
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理失败
- en: If you look at [Example 12-16](#http-client-reactive-api), you can see that
    calling the REST client can emit a failure, and you need to handle it. Quarkus
    provides multiple ways to handle failure gracefully. You can use the Mutiny API
    to handle the failure, execute retries, or recover gracefully, as shown in [Chapter 7](ch07.html#mutiny).
    Also, Quarkus provides a declarative way to express how to handle failures. This
    approach is particularly convenient when integrating remote systems (as with the
    REST client), because it combines the integration point and the failure management
    in a single location.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 [示例 12-16](#http-client-reactive-api)，你会发现调用 REST 客户端可能会导致失败，你需要处理它。Quarkus
    提供多种方法来优雅地处理失败。你可以使用 Mutiny API 处理失败，执行重试或优雅地恢复，如 [第 7 章](ch07.html#mutiny) 所示。此外，Quarkus
    提供了一种声明性的方法来表达如何处理失败。当集成远程系统（如 REST 客户端）时，这种方法特别方便，因为它将集成点和失败管理结合在一个位置。
- en: 'The `quarkus-smallrye-fault-tolerance` extension provides a set of annotations
    to configure:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`quarkus-smallrye-fault-tolerance` 扩展提供了一组注解来配置：'
- en: Fallback methods
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回退方法
- en: Retries
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重试
- en: Circuit breakers
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断路器
- en: Bulkheads
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隔离舱
- en: '`quarkus-smallrye-fault-tolerance` works for both imperative and reactive APIs.
    In this section, we focus only on the latter.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`quarkus-smallrye-fault-tolerance` 适用于命令式和响应式 API。在本节中，我们仅关注后者。'
- en: First, to use the Fault-Tolerance extension, add the dependency in [Example 12-17](#dep-fault-tolerance)
    to your project.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，要使用容错扩展，在你的项目中添加依赖项 [示例 12-17](#dep-fault-tolerance)。
- en: Example 12-17\. Dependency for fault-tolerance support (*chapter-12/api-gateway-example/api-gateway/pom.xml*)
  id: totrans-102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-17\. 容错支持的依赖项（*chapter-12/api-gateway-example/api-gateway/pom.xml*）
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Fallback
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回退
- en: A *fallback* is a method that provides an alternative result if the original
    invocation fails. Let’s reuse the example we have seen before, shown again here
    in [Example 12-18](#uuid-method).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*回退* 是在原始调用失败时提供替代结果的方法。让我们重用之前看过的示例，再次在 [示例 12-18](#uuid-method) 中展示。'
- en: Example 12-18\. The `uuid` method
  id: totrans-106
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-18\. `uuid` 方法
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If the interaction with the remote service fails, we can generate a fallback
    (local) UUID, as shown in [Example 12-19](#declare-fallback).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果与远程服务的交互失败，我们可以生成一个回退（本地）UUID，如[示例 12-19](#declare-fallback)所示。
- en: Example 12-19\. Declare a fallback for the `uuid` method
  id: totrans-109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-19\. 声明 `uuid` 方法的回退
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `@Fallback` annotation indicates the name of the method to call. This method
    must have the same signature as the original method. So, in our case, it must
    return `Uni<UUID>`. Our fallback implementation is simple, but you can imagine
    more complex scenarios such as calling an alternative service.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Fallback` 注解指示调用的方法名称。此方法必须与原始方法具有相同的签名。因此，在我们的情况下，它必须返回 `Uni<UUID>`。我们的回退实现很简单，但你可以想象更复杂的场景，如调用备用服务。'
- en: If you need more control on the fallback, you can also provide a `FallbackHandler`;
    see [Example 12-20](#fallback-handler).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要更多对回退的控制，还可以提供 `FallbackHandler`；参见 [示例 12-20](#fallback-handler)。
- en: Example 12-20\. Use a fallback handler
  id: totrans-113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-20\. 使用回退处理程序
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The configured fallback handler is called with an `ExecutionContext` encapsulating
    the original method and the exception.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 配置的回退处理程序通过封装原始方法和异常的 `ExecutionContext` 被调用。
- en: Retries
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重试
- en: Fallback allows recovering gracefully with a local value. The Fault-Tolerance
    extension also allows retrying. Remember, retries should be used only when the
    called service is idempotent. So, before using this feature, be sure it won’t
    harm your system.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 回退允许以本地值优雅地恢复。容错扩展还允许重试。请记住，只有在调用服务是幂等的情况下才应使用重试功能。因此，在使用此功能之前，请确保它不会损害你的系统。
- en: The `@Retry` annotation instructs Quarkus to retry the invocation multiple times,
    hoping that the next call would be successful ([Example 12-21](#http-client-retry)).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Retry` 注解指示 Quarkus 多次重试调用，希望下一次调用会成功（[示例 12-21](#http-client-retry)）。'
- en: Example 12-21\. Declare a retry strategy
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-21\. 声明重试策略
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see, you can configure the number of retries, as well as a delay
    and jitter to avoid retrying immediately. You could combine `@Retry` and `@Fallback`
    to invoke the fallback method if all the attempts failed.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，你可以配置重试次数，以及延迟和抖动，以避免立即重试。你可以结合 `@Retry` 和 `@Fallback`，如果所有尝试都失败，调用回退方法。
- en: Time-out
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 超时
- en: Failing fast is always better than having users waiting a long time. The `@Timeout`
    annotation enforces that an invocation completes in a timely fashion; see [Example 12-22](#config-timeout).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 快速失败总比让用户长时间等待好。`@Timeout`注解强制调用在及时完成；参见[示例 12-22](#config-timeout)。
- en: Example 12-22\. Configure a time-out
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-22\. 配置超时
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If the invocation does not produce a result in the configured time-out, it fails.
    Combining `@Timeout` with `@Fallback` allows using a fallback result if the original
    call was unable to complete in the expected time.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用在配置的超时时间内未产生结果，则调用失败。将`@Timeout`与`@Fallback`结合使用允许在原始调用无法按预期时间完成时使用备用结果。
- en: Bulkheads and Circuit Breaker
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 舱壁和断路器
- en: The Quarkus fault-tolerance feature also provides circuit breakers and bulkheads.
    While the other patterns protect your application against remote failures and
    slowness, these two last patterns avoid hammering unhealthy or brittle services.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus的容错特性还提供了断路器和舱壁功能。虽然其他模式保护您的应用免受远程故障和缓慢的影响，但这两个模式避免了对不健康或脆弱服务的过度调用。
- en: The first pattern, popularized a few years ago with libraries such as [Hystrix](https://oreil.ly/eLHn0)
    or [Resilience4j](https://oreil.ly/yr4dO), detects failing services and gives
    them time to recover (instead of continuously calling them). The circuit breaker
    allows your application to fail immediately to prevent repeated calls that are
    likely going to fail. The circuit breaker operates much like an electrical circuit
    breaker. A closed circuit represents a fully functional system, and an open circuit
    means an incomplete system. If a failure occurs, the circuit breaker triggers
    to open the circuit, removing the point of failure from the system.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个模式几年前由[Hystrix](https://oreil.ly/eLHn0)或[Resilience4j](https://oreil.ly/yr4dO)等库广泛推广，它检测到失败的服务并给予其恢复的时间（而不是不断地调用它们）。断路器允许您的应用立即失败，以防止可能会失败的重复调用。断路器的操作类似于电气断路器。闭合电路表示完全功能的系统，开放电路意味着不完整的系统。如果发生故障，断路器将触发打开电路，从系统中删除故障点。
- en: 'The software circuit breaker has one more state: the half-open state. After
    the circuit is opened, it periodically changes to the half-open state. It checks
    whether the failed component is restored and closes the circuit after being considered
    safe and functional. To use a circuit breaker in Quarkus, just use the `@CircuitBreaker`
    annotation, as shown in [Example 12-23](#use-circuit-breaker).'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 软件断路器有一个额外的状态：半开放状态。在断路器打开后，它周期性地转换到半开放状态。它检查失败的组件是否已恢复，并在被认为安全和功能正常后关闭电路。在Quarkus中使用断路器，只需使用`@CircuitBreaker`注解，如[示例 12-23](#use-circuit-breaker)所示。
- en: Example 12-23\. Use a circuit breaker
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-23\. 使用断路器
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You can also configure the circuit breaker; see [Example 12-24](#config-circuit-breaker).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以配置断路器；参见[示例 12-24](#config-circuit-breaker)。
- en: Example 12-24\. Configure a circuit breaker
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-24\. 配置断路器
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Protecting your integration point with a circuit breaker not only allows you
    to prevent slow responses and failures in your application, but also gives the
    failing service time to recover. Using a circuit breaker is handy when the service
    you interact with is under maintenance or heavy load.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通过断路器保护您的集成点，不仅可以防止应用程序中的响应缓慢和故障，还可以让故障服务有时间恢复。当您与的服务处于维护或高负载状态时，使用断路器非常方便。
- en: The idea behind the bulkhead pattern is to limit the propagation of failure.
    You protect your application from failures happening in the remote service and
    avoid cascading them to the entire system and causing widespread issues. The `@Bulkhead`
    annotation limits the number of concurrent requests and saves an unresponsive
    remote service from wasting system resources.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 舱壁模式的理念是限制故障的传播。您保护应用程序免受远程服务中的故障，并避免将其级联到整个系统中，从而导致广泛的问题。`@Bulkhead`注解限制并发请求的数量，并节省无响应的远程服务浪费系统资源的情况。
- en: Using the annotation helps you avoid having to deal with too many failures and
    avoids flooding a remote service with a high number of concurrent requests. The
    latter aspect is essential. With the reactive principles enabling high concurrency,
    you should never forget that the service you are calling may not be prepared for
    that load. So using the `@Bulkhead` annotation allows controlling the outbound
    concurrency. Yes, it will increase your response time and reduce your concurrency,
    but that’s for the sake of the global system state.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用该注解可帮助您避免处理过多的失败，并避免向远程服务发送大量并发请求。 后者很重要。 由于反应式原则使高并发成为可能，您永远不应忘记您调用的服务可能无法承受这种负载。
    因此，使用 `@Bulkhead` 注解允许控制出站并发性。 是的，这会增加您的响应时间并减少您的并发性，但这是为了全局系统状态的利益。
- en: You can configure the bulkhead with the max concurrency (`value`), and the maximum
    number of requests waiting for their turn, as demonstrated in [Example 12-25](#http-client-bulkhead).
    If the queue is full, it rejects any new invocations immediately, avoiding slow
    response time.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用最大并发性 (`value`) 和等待轮次的最大请求数来配置批处理隔离，如 [示例 12-25](#http-client-bulkhead)
    所示。 如果队列已满，它将立即拒绝任何新的调用，避免响应时间过慢。
- en: Example 12-25\. Declare a bulkhead
  id: totrans-140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-25\. 声明一个批处理隔离
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Building API Gateways with the RESTEasy Reactive Client
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 RESTEasy Reactive 客户端构建 API 网关
- en: In [Chapter 8](ch08.html#http), we showed how to implement HTTP endpoints relying
    on nonblocking I/O and how this implementation can use Mutiny (covered in [Chapter 7](ch07.html#mutiny))
    to orchestrate asynchronous tasks and avoid blocking. This approach enables high
    concurrency and efficient resource usage. This is the perfect combination for
    building API gateways.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 8 章](ch08.html#http) 中，我们展示了如何实现依赖非阻塞 I/O 的 HTTP 端点，以及此实现如何使用 Mutiny（在
    [第 7 章](ch07.html#mutiny) 中介绍）来编排异步任务并避免阻塞。 此方法实现了高并发和有效的资源使用。 这是构建 API 网关的完美组合。
- en: An *API gateway* is a service that sits in front of a set of backend services.
    The gateway handles external requests and orchestrates other services. For example,
    it can delegate a request to a single service and implement more complex processes
    involving multiple backend services.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*API 网关* 是位于一组后端服务前面的服务。 网关处理外部请求并编排其他服务。 例如，它可以将请求委托给单个服务，并实现涉及多个后端服务的更复杂的流程。'
- en: 'We can build highly concurrent, responsive, and resilient API gateways by combining
    Mutiny, RESTEasy Reactive, the reactive REST client, and the fault-tolerance annotations.
    In this section, we explain the basics of implementing such a gateway by exploring
    an example. Three applications compose our system:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合 Mutiny、RESTEasy Reactive、反应式 REST 客户端和容错注解，我们可以构建高并发、响应迅速、弹性的 API 网关。 在本节中，我们通过探索一个示例来解释实现这样一个网关的基础知识。
    我们的系统由三个应用程序组成：
- en: Greeting service
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 问候服务
- en: Exposes an HTTP API returning `Hello *{name}*`, the name being a query parameter.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 暴露一个 HTTP API 返回 `Hello *{name}*`，其中名称是查询参数。
- en: Quote service
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 报价服务
- en: Exposes another HTTP API returning a random funny quote about coffee.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 暴露另一个 HTTP API 返回有关咖啡的随机有趣引用。
- en: API gateway
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: API 网关
- en: Exposes an HTTP API that delegates requests on `/quote` to the quote service.
    Requests made to `/` will call the greeting and quote services and build a JSON
    object encapsulating both.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 将 HTTP API 暴露，将 `/quote` 上的请求委托给报价服务。 发送到 `/` 的请求将调用问候和报价服务，并构建一个封装两者的 JSON
    对象。
- en: You can find the full code of the system in the *chapter-12/api-gateway-example*
    directory. This section focuses on the API gateway component. We do not cover
    the code of the greeting and quote services here as they are simple. The source
    code of these components is available in the *chapter-12/api-gateway-example/greeting-service*
    and *chapter-12/api-gateway-example/quote-service* directories. The API gateway
    application that you can find in *chapter-12/api-gateway-example/api-gateway*
    is more interesting, and we explore it together.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 *chapter-12/api-gateway-example* 目录中找到系统的完整代码。 本节重点介绍 API 网关组件。 我们在这里不涵盖问候和报价服务的代码，因为它们很简单。
    这些组件的源代码位于 *chapter-12/api-gateway-example/greeting-service* 和 *chapter-12/api-gateway-example/quote-service*
    目录中。 您可以在 *chapter-12/api-gateway-example/api-gateway* 中找到的 API 网关应用程序更有趣，我们一起来探索它。
- en: 'First, let’s build and run this system. To build this example, in a terminal,
    navigate into *chapter-12/api-gateway-example* and run `mvn package`. Then you
    will need three terminals:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们构建并运行此系统。 要构建此示例，请在终端中导航到 *chapter-12/api-gateway-example*，然后运行 `mvn package`。
    然后您将需要三个终端：
- en: In the first one, run `java -jar target/quarkus-app/quarkus-run.jar` from the
    *chapter-12/api-gateway-example/greeting-service* directory.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一个中，从*chapter-12/api-gateway-example/greeting-service*目录运行`java -jar target/quarkus-app/quarkus-run.jar`。
- en: In the second one, run `java -jar target/quarkus-app/quarkus-run.jar` from the
    *chapter-12/api-gateway-example/quote-service* directory.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二个中，从*chapter-12/api-gateway-example/quote-service*目录运行`java -jar target/quarkus-app/quarkus-run.jar`。
- en: Finally, in the third one, run `java -jar target/quarkus-app/quarkus-run.jar`
    from the *chapter-12/api-gateway-example/api-gateway* directory.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在第三个中，从*chapter-12/api-gateway-example/api-gateway*目录运行`java -jar target/quarkus-app/quarkus-run.jar`。
- en: Note
  id: totrans-157
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Ensure that ports 9010 (greeting service) and 9020 (quote service) are not used
    on your system. The API gateway uses port 8080.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的系统上没有使用端口9010（问候服务）和9020（报价服务）。API 网关使用端口8080。
- en: Once all services are running, you can use `curl` to invoke the API gateway,
    which orchestrates the other backend services ([Example 12-26](#invoke-greeting)).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有服务都运行起来，你可以使用`curl`来调用 API 网关，它会编排其他后端服务（[示例 12-26](#invoke-greeting)）。
- en: Example 12-26\. Invoke the greeting endpoint
  id: totrans-160
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-26\. 调用问候端点
- en: '[PRE26]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The cornerstone of the API gateway is the `Gateway` class, shown in [Example 12-27](#gateway-class).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: API 网关的核心是`Gateway`类，如[示例 12-27](#gateway-class)所示。
- en: Example 12-27\. The `Gateway` class (*chapter-12/api-gateway-example/api-gateway/src/main/java/org/acme/gateway/Gateway.java*)
  id: totrans-163
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-27\. `Gateway`类（*chapter-12/api-gateway-example/api-gateway/src/main/java/org/acme/gateway/Gateway.java*）
- en: '[PRE27]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `Gateway` class retrieves the two REST clients and handles the HTTP requests
    using them. As an API gateway can be under heavy load and high concurrency, we
    use RESTEasy Reactive and its Mutiny integration, so we don’t need worker threads.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`Gateway`类检索两个 REST 客户端并使用它们处理 HTTP 请求。由于 API 网关可能会承受大量负载和高并发，我们使用RESTEasy
    Reactive及其Mutiny集成，因此不需要工作线程。'
- en: The `getQuote` method is straightforward. It delegates the calls to the `QuoteService`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`getQuote`方法很简单。它将调用委托给`QuoteService`。'
- en: The `getBoth` method is more interesting. It needs to call both services and
    aggregate the response. As both services are unrelated, we can call them concurrently.
    As you have seen in [Chapter 7](ch07.html#mutiny), this can be easily achieved
    with Mutiny by using the `Uni.combine` construct. Once we have both responses
    encapsulated in a tuple, we build the `Greeting` structure and emit it.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`getBoth`方法更加有趣。它需要调用两个服务并聚合响应。由于这两个服务是无关的，我们可以同时调用它们。正如你在[第7章](ch07.html#mutiny)中看到的，通过Mutiny的`Uni.combine`结构可以轻松实现这一点。一旦我们将两个响应封装在元组中，我们就构建`Greeting`结构并发出它。'
- en: Let’s look at the REST clients. `GreetingService` uses the fault-tolerance annotation
    to be sure we handle failures or slow responses appropriately; see [Example 12-28](#greeting-service-client).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 REST 客户端。`GreetingService`使用容错注解以确保我们适当处理失败或慢响应；参见[示例 12-28](#greeting-service-client)。
- en: Example 12-28\. The `GreetingService` REST client (*chapter-12/api-gateway-example/api-gateway/src/main/java/org/acme/gateway/GreetingService.java*)
  id: totrans-169
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-28\. `GreetingService` REST 客户端（*chapter-12/api-gateway-example/api-gateway/src/main/java/org/acme/gateway/GreetingService.java*）
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Notice that the greeting method combines the circuit breaker, time-out, and
    fallback annotations. `QuoteService` is similar but does not use the fallback
    annotation, as you can see in [Example 12-29](#quote-service-client).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 注意问候方法结合了断路器、超时和回退注解。`QuoteService`类似，但不使用回退注解，正如你在[示例 12-29](#quote-service-client)中所见。
- en: Example 12-29\. The `QuoteService` REST client (*chapter-12/api-gateway-example/api-gateway/src/main/java/org/acme/gateway/QuoteService.java*)
  id: totrans-172
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-29\. `QuoteService` REST 客户端（*chapter-12/api-gateway-example/api-gateway/src/main/java/org/acme/gateway/QuoteService.java*）
- en: '[PRE29]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Instead, as you may have noticed, we handle failure by using the Mutiny API
    in the `Gateway` class ([Example 12-30](#mutiny-fail-recover)).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，正如你可能已经注意到的那样，我们在`Gateway`类中使用Mutiny API来处理失败（[示例 12-30](#mutiny-fail-recover)）。
- en: Example 12-30\. Recover from failures by using the Mutiny API (*chapter-12/api-gateway-example/api-gateway/src/main/java/org/acme/gateway/Gateway.java*)
  id: totrans-175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-30\. 使用Mutiny API从失败中恢复（*chapter-12/api-gateway-example/api-gateway/src/main/java/org/acme/gateway/Gateway.java*）
- en: '[PRE30]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: While, in general, we choose between using the fault-tolerance annotation or
    using the Mutiny API, we wanted to highlight that you have the choice and can
    combine the two easily. However, the `getQuote` method does not handle the failure
    and propagate the error. So, when using Mutiny to handle the failure, make sure
    you cover all entry points. Now, if you stop the quote service (by pressing Ctrl-C
    in the second terminal), you get the output in [Example 12-31](#invoke-endpoint).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，我们在使用容错注解或使用 Mutiny API 之间进行选择，我们想要强调您可以选择并且可以轻松地将两者结合起来。然而，`getQuote`
    方法不处理失败并传播错误。因此，在使用 Mutiny 处理失败时，请确保覆盖所有入口点。现在，如果停止报价服务（通过在第二个终端中按 Ctrl-C），您将在
    [Example 12-31](#invoke-endpoint) 中获得输出。
- en: Example 12-31\. Invoke the endpoint
  id: totrans-178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-31\. 调用端点
- en: '[PRE31]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If you also stop the greeting service, by pressing Ctrl-C in the first terminal,
    you get [Example 12-32](#invoke-greeting-wo-service).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您也停止了问候服务，通过在第一个终端中按 Ctrl-C，您将获得 [Example 12-32](#invoke-greeting-wo-service)。
- en: Example 12-32\. Invoke the greeting endpoint when there’s no greeting service
  id: totrans-181
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-32\. 在没有问候服务时调用问候端点
- en: '[PRE32]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This section explored the fundamental constructs to build a highly concurrent
    API gateway. Combining RESTEasy Reactive, the reactive REST client, fault tolerance,
    and Mutiny provides all the features you need to expose robust APIs to your users
    and handle failure gracefully. The following section illustrates how the REST
    client can also be used in messaging applications.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 本节探讨了构建高度并发 API 网关的基本构造。结合 RESTEasy Reactive、反应式 REST 客户端、容错和 Mutiny 提供了所有您需要向用户公开健壮
    API 并优雅处理失败的功能。下一节说明了如何在消息应用程序中也可以使用 REST 客户端。
- en: Using the REST Client in Messaging Applications
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在消息应用程序中使用 REST 客户端
- en: 'The REST client can also be helpful in messaging applications. For example,
    a message-processing pipeline can call a remote HTTP API for each message or forward
    the messages to a remote HTTP endpoint. We can use the REST client in a processing
    pipeline modeled with Reactive Messaging to achieve this. In this section, we
    explore an application receiving simple orders from an HTTP endpoint, process
    them, and persist them in a database:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: REST 客户端在消息应用程序中也很有用。例如，消息处理管道可以为每个消息调用远程 HTTP API，或将消息转发到远程 HTTP 端点。我们可以在使用
    Reactive Messaging 建模的处理管道中使用 REST 客户端来实现这一点。在本节中，我们探讨了一个从 HTTP 端点接收简单订单、处理它们并将其持久化到数据库中的应用程序：
- en: '`OrderEndpoint` receives `Order` and emits it into the `new-orders` channel.'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`OrderEndpoint` 接收 `Order` 并将其发送到 `new-orders` 通道中。'
- en: An `OrderProcessing` component consumes the orders from the `new-order` channel
    and invokes the remote validation service. If the order gets validated successfully,
    it is sent to the `validated-orders` channel. Otherwise, the order is acknowledged
    negatively.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`OrderProcessing` 组件从 `new-order` 通道消费订单，并调用远程验证服务。如果订单验证成功，则将其发送到 `validated-orders`
    通道。否则，将否定确认订单。'
- en: '`OrderStorage` receives the order from the `validated-orders` channel and stores
    it in the database.'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`OrderStorage` 接收来自 `validated-orders` 通道的订单并将其存储在数据库中。'
- en: For the sake of simplicity, the validation endpoint runs in the same process,
    but invocations still use the REST client. You can find the complete code of the
    application in *chapter-12/http-messaging-example*, but let’s go through it quickly.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，验证端点在同一进程中运行，但调用仍然使用 REST 客户端。您可以在 *chapter-12/http-messaging-example*
    找到应用程序的完整代码，但让我们快速浏览一下。
- en: As you can see in [Example 12-33](#http-client-order), the `Order` structure
    is simple. It contains just the name of a product and a quantity. Note that the
    `Order` class is a Panache entity. We will use that to store the validated orders
    in the database.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在 [Example 12-33](#http-client-order) 中所见，`Order` 结构很简单。它仅包含产品名称和数量。请注意，`Order`
    类是 Panache 实体。我们将使用它来在数据库中存储验证通过的订单。
- en: Example 12-33\. The `Order` structure (*chapter-12/http-messaging-example/src/main/java/org/acme/http/model/Order.java*)
  id: totrans-191
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-33\. `Order` 结构 (*chapter-12/http-messaging-example/src/main/java/org/acme/http/model/Order.java*)
- en: '[PRE33]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`OrderEndpoint` is also straightforward, as you can see in [Example 12-34](#order-endpoint-class).'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrderEndpoint` 同样简单，如您在 [Example 12-34](#order-endpoint-class) 中所见。'
- en: Example 12-34\. The `OrderEndpoint` class (*chapter-12/http-messaging-example/src/main/java/org/acme/http/OrderEndpoint.java*)
  id: totrans-194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-34\. `OrderEndpoint` 类 (*chapter-12/http-messaging-example/src/main/java/org/acme/http/OrderEndpoint.java*)
- en: '[PRE34]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `order` method emits the received order to the `new-orders` channel. When
    the message gets acknowledged, it produces a `202 - ACCEPTED` response. If the
    message is nacked, it creates a `400 - BAD REQUEST` response.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`order` 方法将收到的订单发送到 `new-orders` 通道。当消息被确认时，它会产生 `202 - ACCEPTED` 响应。如果消息被拒绝，它会创建一个
    `400 - BAD REQUEST` 响应。'
- en: The `getAllValidatedOrders` method lets us check what has been written in the
    database. The `OrderProcessing` component consumes the orders from the `new-orders`
    channel and invokes the validation service, as shown in [Example 12-35](#order-processing-class).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`getAllValidatedOrders` 方法允许我们检查数据库中的写入情况。`OrderProcessing` 组件从 `new-orders`
    通道中消费订单，并调用验证服务，如[示例 12-35](#order-processing-class)所示。'
- en: Example 12-35\. The `OrderProcessing` class (*chapter-12/http-messaging-example/src/main/java/org/acme/http/OrderProcessing.java*)
  id: totrans-198
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-35\. `OrderProcessing` 类 (*chapter-12/http-messaging-example/src/main/java/org/acme/http/OrderProcessing.java*)
- en: '[PRE35]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The validation service fails if the order is invalid. As a result, the message
    is nacked. If the order is valid, it sends the order to the `validated-orders`
    channel. The `OrderStorage` component consumes this channel and writes each order
    in the database ([Example 12-36](#persist-orders)).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果订单无效，则验证服务失败。结果，消息被拒绝。如果订单有效，则它会将订单发送到 `validated-orders` 通道。`OrderStorage`
    组件消费此通道，并将每个订单写入数据库（[示例 12-36](#persist-orders)）。
- en: Example 12-36\. Persist orders in a database (*chapter-12/http-messaging-example/src/main/java/org/acme/http/OrderStorage.java*)
  id: totrans-201
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-36\. 在数据库中持久化订单（*chapter-12/http-messaging-example/src/main/java/org/acme/http/OrderStorage.java*)
- en: '[PRE36]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Run the application with `mvn quarkus:dev` from the *chapter-12/http-messaging-example*
    directory. As it uses Quarkus Dev Services, you don’t need to provision a database
    in dev mode; Quarkus does it for you.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 从 *chapter-12/http-messaging-example* 目录运行应用程序使用 `mvn quarkus:dev` 命令。由于它使用
    Quarkus Dev 服务，在开发模式下不需要为数据库提供服务；Quarkus 会为您完成这一切。
- en: Once the application is running, add an order as shown in [Example 12-37](#add-new-order).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序运行后，按照[示例 12-37](#add-new-order)的方法添加一个订单。
- en: Example 12-37\. Invoke the endpoint to add a new order
  id: totrans-205
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-37\. 调用端点以添加新订单
- en: '[PRE37]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You can verify that the order has been processed by using [Example 12-38](#retrieve-persisted-orders).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用[示例 12-38](#retrieve-persisted-orders)来验证订单是否已被处理。
- en: Example 12-38\. Invoke the endpoint to retrieve the persisted orders
  id: totrans-208
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-38\. 调用端点以检索持久化的订单
- en: '[PRE38]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now try to insert an invalid order (using a negative quantity), as shown in
    [Example 12-39](#invalid-order).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试插入一个无效订单（使用负数量），如[示例 12-39](#invalid-order)所示。
- en: Example 12-39\. Invoke the endpoint to introduce an invalid order
  id: totrans-211
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-39\. 调用端点以引入无效订单
- en: '[PRE39]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The response is `400`. You can verify that it was not inserted in the database
    by using code in [Example 12-40](#invalid-not-listed).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 响应是 `400`。您可以使用[示例 12-40](#invalid-not-listed)中的代码验证它是否未被插入到数据库中。
- en: 'Example 12-40\. Invoke the endpoint to retrieve the persisted orders: the invalid
    order is not listed'
  id: totrans-214
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-40\. 调用端点以检索持久化的订单：无效订单未列出
- en: '[PRE40]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The validation step of the processing can use the fault-tolerance annotations
    to improve the reliability of the application ([Example 12-41](#ft-annotations)).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 处理的验证步骤可以使用容错注解来提高应用程序的可靠性（[示例 12-41](#ft-annotations)）。
- en: Example 12-41\. Use fault-tolerance annotations
  id: totrans-217
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-41\. 使用容错注解
- en: '[PRE41]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Using the REST client in the messaging application allows you to smoothly integrate
    remote services in a processing workflow.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在消息应用程序中使用 REST 客户端可以让您在处理工作流程中顺利集成远程服务。
- en: Summary
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'This chapter focused on integrating a remote HTTP API into your reactive application
    without breaking the reactive principles. You learned how to do the following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍了如何将远程 HTTP API 集成到您的响应式应用程序中，而不会违反响应式原则。您学会了如何执行以下操作：
- en: Integrate a remote HTTP endpoint with your reactive application by using the
    reactive REST client
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用响应式 REST 客户端，将远程 HTTP 终端集成到您的响应式应用程序中
- en: Protect your integration point by using the fault-tolerance annotations
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用容错注解保护你的集成点
- en: Build API gateways by combining Mutiny, RESTEasy Reactive, and the REST client
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过结合 Mutiny、RESTEasy Reactive 和 REST 客户端构建 API 网关
- en: Integrate remote HTTP APIs in message-processing pipelines
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在消息处理管道中集成远程 HTTP API
- en: The next chapter focuses on observability and how to keep your reactive system
    running under fluctuating load and when facing failures.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章重点介绍可观察性，以及如何在负载波动和面对故障时保持响应式系统的运行。
