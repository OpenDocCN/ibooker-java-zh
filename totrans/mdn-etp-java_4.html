<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 4. A Kubernetes-Based Software Development Platform"><div class="chapter" id="kubernetes_based_softw_dev_platform">
<h1><span class="label">Chapter 4. </span>A Kubernetes-Based Software Development Platform</h1>


<p>In the previous chapter, we outlined our methodology around modernization and the steps required to design and develop modern architectures. We described the need for a platform like Kubernetes that can help you with requirements to make your applications cloud native, ready to scale up proportionally to your business’s need.</p>

<p>We have also demonstrated that a microservices-based architecture is usually implemented using container technology, which makes apps portable and consistent. Let’s now see in detail how Kubernetes can help us modernize our Java applications and what the steps are to achieve that using its declarative approach through a rich set of APIs.</p>






<section data-type="sect1" data-pdf-bookmark="Developers and Kubernetes"><div class="sect1" id="idm45261446470656">
<h1>Developers and Kubernetes</h1>

<p><a href="https://kubernetes.io">Kubernetes</a>, which in Greek <a data-type="indexterm" data-primary="developers" data-secondary="Kubernetes and" id="devkub"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="developers and" id="kubdevers"/>translates to “pilot” or “governor,” is an open source project that is currently the de facto target environment for modern architectures and the most popular container orchestration platform; a simple illustration is presented in <a data-type="xref" href="#fig4-1">Figure 4-1</a>. Started from Google’s experience in managing distributed complex applications for their software stack back in 2015, today it is one of the biggest open source communities; it is managed by a foundation, the Cloud Native Computing Foundation (CNCF), and embraced by vendors and individual contributors.</p>

<figure><div id="fig4-1" class="figure">
<img src="Images/moej_0401.png" alt="A Kubernetes Cluster running apps in Nodes" width="600" height="241"/>
<h6><span class="label">Figure 4-1. </span>A Kubernetes cluster running apps in Nodes</h6>
</div></figure>

<p>As a container-orchestration platform, its focus is primarily on ensuring that our apps are running correctly, providing out-of-the-box self-healing, recovery, and a powerful API to control this mechanism.
You may be wondering now: as a developer, why should I care about Kubernetes if it is so self-proficient?</p>

<p>That’s a good question, and maybe a good answer is an analogy: you have a Formula 1 car with autopilot, but if you want to win the race, you need to tune and set up your car to compete with all other good ones. The same is true for your apps, which can benefit from all the capabilities offered by the platform to tune them so they run 
<span class="keep-together">optimally</span>.</p>








<section data-type="sect2" data-pdf-bookmark="What Kubernetes Does"><div class="sect2" id="idm45261446460272">
<h2>What Kubernetes Does</h2>

<p>When you have Kubernetes as a target platform to run your applications, you can rely on an ecosystem of APIs and components put in place to make deployments easier so developers can focus only on the most important part: coding.  Kubernetes provides you with <a href="https://oreil.ly/DNRQS">a framework to run distributed systems resiliently</a>.</p>

<p>In practice, this means you don’t need to reimplement custom solutions when it comes to:</p>
<dl>
<dt>Service discovery</dt>
<dd>
<p>Kubernetes uses <a data-type="indexterm" data-primary="Kubernetes" data-secondary="service discovery and" id="idm45261446455632"/><a data-type="indexterm" data-primary="service discovery" data-secondary="Kubernetes" id="idm45261446454624"/>internal DNS resolution to expose your apps; this is automatically assigned and can also be used to send the traffic to multiple instances of your app.</p>
</dd>
<dt>Load balancing</dt>
<dd>
<p>Kubernetes takes care of <a data-type="indexterm" data-primary="Kubernetes" data-secondary="load balancing" id="idm45261446452112"/><a data-type="indexterm" data-primary="load balancing, Kubernetes" id="idm45261446451136"/>managing the load on your apps, balancing the traffic, and distributing user requests accordingly.</p>
</dd>
<dt>Self-healing</dt>
<dd>
<p>Kubernetes discovers and replaces failing containers automatically, providing a health check and self-healing mechanism out of the box.</p>
</dd>
<dt>Rollout and Rollback</dt>
<dd>
<p>Kubernetes ensures your <a data-type="indexterm" data-primary="Kubernetes" data-secondary="rollout" id="idm45261446447424"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="rollback" id="idm45261446446448"/><a data-type="indexterm" data-primary="rollout, Kubernetes" id="idm45261446445504"/><a data-type="indexterm" data-primary="rollbacks, Kubernetes" id="idm45261446444832"/>app is always running consistently at the desired state, providing control to scale up and scale down workloads. In addition, it offers the capability to rollout or rollback to a specific version of your application.</p>
</dd>
</dl>
</div></section>













<section data-type="sect2" data-pdf-bookmark="What Kubernetes Doesn’t Do"><div class="sect2" id="idm45261446443408">
<h2>What Kubernetes Doesn’t Do</h2>

<p>Many headaches that developers usually need to deal with in production are already solved and delegated to a platform, whose primary goal is to ensure applications are running. But does that provide all you need for modernizing your apps? Probably not.</p>

<p>As we discussed in the previous chapter, the modernization steps toward a cloud native approach are more closely tied to a methodology rather than a specific technology. Once you’ve converted your mindset from building monolithic apps to creating microservices, we are in a good position to start thinking big. Nowadays, many apps run on cloud platforms targeting Kubernetes, and those are the ones running global-reach workloads. Here are some things to consider:</p>

<ul>
<li>
<p>Kubernetes doesn’t know how to <a data-type="indexterm" data-primary="Kubernetes" data-secondary="application handling" id="idm45261446439680"/>handle your app. It can restart it if it fails, but it cannot understand why that is happening, so we need to ensure we have full control of our microservices-based architecture and be able to debug each container. This is particularly important in the case of a large-scale deployment.</p>
</li>
<li>
<p>Kubernetes doesn’t provide <a data-type="indexterm" data-primary="Kubernetes" data-secondary="services" id="idm45261446437392"/><a data-type="indexterm" data-primary="microservices" data-secondary="Kubernetes" id="idm45261446436416"/>any middleware or application-level services. Granular discovery services need to be addressed by interacting with Kubernetes API or relying on some service on top of Kubernetes, such as a service mesh framework. There is no ecosystem for developers out of the box.</p>
</li>
<li>
<p>Kubernetes doesn’t build your app. You are <a data-type="indexterm" data-primary="Kubernetes" data-secondary="application building" id="idm45261446434160"/>responsible for providing your app compiled and packaged as a container image or relying on additional components on top of Kubernetes.</p>
</li>
</ul>

<p>With that in mind, let’s start digging into a Kubernetes journey for developers in order to make our first step to bringing our app into the next cloud native production environment.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Infrastructure as a Code"><div class="sect2" id="idm45261446431936">
<h2>Infrastructure as a Code</h2>

<p>Kubernetes provides a <a data-type="indexterm" data-primary="Kubernetes" data-secondary="infrastructure and" id="idm45261446430240"/><a data-type="indexterm" data-primary="infrastructure, Kubernetes" id="idm45261446429264"/>set of APIs to manage the desired state of our app as well as the whole platform.  Each component in Kubernetes has an API representation that can be consumed. Kubernetes offers a <a href="https://oreil.ly/cURvG">declarative deployment pattern</a> that allows you to to automate the execution of upgrade and rollback processes for a group of Pods. The declarative approach is granular, and it is also used <a data-type="indexterm" data-primary="Kubernetes" data-secondary="custom resources" id="idm45261446427392"/><a data-type="indexterm" data-primary="custom resources, Kubernetes" id="idm45261446426448"/>to extend Kubernetes APIs with the concept of <em>custom resources</em>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Custom resources are extensions of the Kubernetes API. A <em>custom resource</em> represents a customization of a particular Kubernetes installation, bringing additional objects to extend cluster capabilities. You can get more info about it from the official Kubernetes <a href="https://oreil.ly/cVBnl">documentation</a>.</p>
</div>

<p>Some of the core objects you have to manage an application in Kubernetes are:</p>
<dl>
<dt>Pod</dt>
<dd>
<p>A group of one or more containers <a data-type="indexterm" data-primary="Kubernetes" data-secondary="pods" id="idm45261446420528"/><a data-type="indexterm" data-primary="pods, Kubernetes" id="idm45261446419552"/>deployed into a Kubernetes cluster. This is the entity that Kubernetes manages and orchestrates, so any application packaged as a container needs to be declared as a Pod.</p>
</dd>
<dt>Service</dt>
<dd>
<p>The resource responsible for <a data-type="indexterm" data-primary="Kubernetes" data-secondary="services" id="idm45261446417280"/><a data-type="indexterm" data-primary="microservices" data-secondary="Kubernetes" id="idm45261446416304"/>service discovery and load balancing. For any Pod to be discoverable and consumable, it needs to be mapped to a Service.</p>
</dd>
<dt>Deployment</dt>
<dd>
<p>This allows describing an <a data-type="indexterm" data-primary="Kubernetes" data-secondary="deployment" id="idm45261446413808"/><a data-type="indexterm" data-primary="deployment" data-secondary="Kubernetes and" id="idm45261446412832"/>application’s life cycle, driving the creation of Pods in terms of which images to use for the app, the number of Pods there should be, and how they should be updated. Furthermore, it helps to define health checks and constraint resources for your application.</p>
</dd>
</dl>

<p>Each of these objects, along with all other resources in the cluster, can be defined and controlled with a YAML representation, or by Kubernetes API. There are also other useful API objects such as those related to storage (PersistentVolume) or used specifically to manage stateful apps (StatefulSet). In this chapter, we will focus on the fundamental <a data-type="indexterm" data-primary="developers" data-secondary="Kubernetes and" data-startref="devkub" id="idm45261446410608"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="developers and" data-startref="kubdevers" id="idm45261446409360"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="infrastructure" id="idm45261446408144"/><a data-type="indexterm" data-primary="infrastructure, Kubernetes" id="idm45261446407200"/>ones needed to bring your app up and running inside a Kubernetes platform.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Container Images"><div class="sect1" id="idm45261446406256">
<h1>Container Images</h1>

<p>The first step for you in this journey is to containerize your microservices so they can be deployed into Kubernetes as a Pod, which is controlled by using a YAML file, invoking the API, or using a Kubernetes Java client.</p>

<p>You can use the Inventory Quarkus microservice <a data-type="indexterm" data-primary="microservices" data-secondary="Inventory Quarkus" id="idm45261446404096"/><a data-type="indexterm" data-primary="Inventory Quarkus microservice" id="idm45261446403120"/><a data-type="indexterm" data-primary="container images" data-secondary="Inventory Quarkus microservice" id="idm45261446402480"/>from Coolstore as an example to create your first container image. Containers are defined by a manifest called Dockerfile or Containerfile, where you will define your software stack as a layer, from the operating system layer to your application binary layer. The benefits of this approach are multiple: it is easy to track versions, inherit from existing layers, add layers, and expand the container. A diagram of layers is shown in <a data-type="xref" href="#fig4-2">Figure 4-2</a>.</p>

<figure><div id="fig4-2" class="figure">
<img src="Images/moej_0402.png" alt="Container Image Layers" width="600" height="239"/>
<h6><span class="label">Figure 4-2. </span>Container image layers</h6>
</div></figure>








<section data-type="sect2" data-pdf-bookmark="Dockerfile"><div class="sect2" id="idm45261446398048">
<h2>Dockerfile</h2>

<p>Writing a Dockerfile to <a data-type="indexterm" data-primary="container images" data-secondary="Dockerfiles" id="contDock"/><a data-type="indexterm" data-primary="Dockerfiles" data-secondary="container images" id="Dockcontimag"/>package our app as a container is pretty straightforward for simple use cases. There are some basic <a data-type="indexterm" data-primary="Dockerfiles" data-secondary="Instructions" id="idm45261446393808"/>directives called <em>Instructions</em> to use, such as the ones listed in <a data-type="xref" href="#dockerfile_instructions">Table 4-1</a>.</p>
<table id="dockerfile_instructions">
<caption><span class="label">Table 4-1. </span>Dockerfile Instructions</caption>
<thead>
<tr>
<th>Instruction</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>FROM</code></p></td>
<td><p>Used to inherit from a base image. For example, it can be a Linux distribution like <code>fedora</code>, <code>centos</code>, <code>rhel</code>, <code>ubuntu</code>.</p></td>
</tr>
<tr>
<td><p><code>ENV</code></p></td>
<td><p>Use environment variable for the container. These variables will be visible to the application and can be set at runtime.</p></td>
</tr>
<tr>
<td><p><code>RUN</code></p></td>
<td><p>Execute a command in the current layer, like installing a package or executing an application.</p></td>
</tr>
<tr>
<td><p><code>ADD</code></p></td>
<td><p>Copy files from your workstation to the container layer, like a JAR file or a configuration file.</p></td>
</tr>
<tr>
<td><p><code>EXPOSE</code></p></td>
<td><p>If your application is listening to some port, you can expose it to the container network so Kubernetes can map it to a Pod and a Service.</p></td>
</tr>
<tr>
<td><p><code>CMD</code></p></td>
<td><p>The command you use to start your application: the final step of the container image building process where you have all your dependencies in the layers, and you can run your app safely.</p></td>
</tr>
</tbody>
</table>

<p>The process for creating your container from your Dockerfile is also described in <a data-type="xref" href="#fig4-3">Figure 4-3</a>.</p>

<figure><div id="fig4-3" class="figure">
<img src="Images/moej_0403.png" alt="Building a Container Image" width="600" height="135"/>
<h6><span class="label">Figure 4-3. </span>Building a container image</h6>
</div></figure>

<p>An example of a Dockerfile for the Inventory Quarkus Java microservice that we created in <a data-type="xref" href="ch02.xhtml#changing_technologies">Chapter 2</a> is listed next, and you can find it in this <a href="https://oreil.ly/D9u1k">book’s GitHub repository</a>:</p>

<pre data-type="programlisting" data-code-language="text"><code>FROM registry.access.redhat.com/ubi8/openjdk-11 </code><a class="co" id="co_a_kubernetes_based_software_development_platform_CO1-1" href="#callout_a_kubernetes_based_software_development_platform_CO1-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a><code>
ENV PROFILE=prod </code><a class="co" id="co_a_kubernetes_based_software_development_platform_CO1-2" href="#callout_a_kubernetes_based_software_development_platform_CO1-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a><code>
ADD target/*.jar app.jar </code><a class="co" id="co_a_kubernetes_based_software_development_platform_CO1-3" href="#callout_a_kubernetes_based_software_development_platform_CO1-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a><code>
EXPOSE 8080 </code><a class="co" id="co_a_kubernetes_based_software_development_platform_CO1-4" href="#callout_a_kubernetes_based_software_development_platform_CO1-4"><img src="Images/4.png" alt="4" width="12" height="12"/></a><code>
CMD java -jar app.jar </code><a class="co" id="co_a_kubernetes_based_software_development_platform_CO1-5" href="#callout_a_kubernetes_based_software_development_platform_CO1-5"><img src="Images/5.png" alt="5" width="12" height="12"/></a></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_a_kubernetes_based_software_development_platform_CO1-1" href="#co_a_kubernetes_based_software_development_platform_CO1-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>We start from OpenJDK 11 layer to build our container image.</p></dd>
<dt><a class="co" id="callout_a_kubernetes_based_software_development_platform_CO1-2" href="#co_a_kubernetes_based_software_development_platform_CO1-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>Set an environment variable that can be consumed within the app for differentiating profiles or configurations to load.</p></dd>
<dt><a class="co" id="callout_a_kubernetes_based_software_development_platform_CO1-3" href="#co_a_kubernetes_based_software_development_platform_CO1-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a></dt>
<dd><p>Copy the JAR artifact built during compilation into the container image. This supposes you have compiled a “fat-jar” or “uber-jar” that contains all dependencies in the same JAR file.</p></dd>
<dt><a class="co" id="callout_a_kubernetes_based_software_development_platform_CO1-4" href="#co_a_kubernetes_based_software_development_platform_CO1-4"><img src="Images/4.png" alt="4" width="12" height="12"/></a></dt>
<dd><p>Expose port 8080 to the container network.</p></dd>
<dt><a class="co" id="callout_a_kubernetes_based_software_development_platform_CO1-5" href="#co_a_kubernetes_based_software_development_platform_CO1-5"><img src="Images/5.png" alt="5" width="12" height="12"/></a></dt>
<dd><p>Run the application invoking the artifact we copied into the layer.</p></dd>
</dl>

<p>In this section, we defined a Dockerfile with the minimum instructions set to build up a container image. Let’s see now how to <a data-type="indexterm" data-primary="container images" data-secondary="Dockerfiles" data-startref="contDock" id="idm45261446316752"/><a data-type="indexterm" data-primary="Dockerfiles" data-secondary="container images" data-startref="Dockcontimag" id="idm45261446315504"/>create container images from a Dockerfile.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Building Container Images"><div class="sect2" id="idm45261446313968">
<h2>Building Container Images</h2>

<p>Now you need to create the <a data-type="indexterm" data-primary="container images" data-secondary="Dockerfile" data-tertiary="building" id="Dockerbuild"/><a data-type="indexterm" data-primary="Dockerfiles" data-secondary="container images" data-tertiary="building" id="imagebuild"/>container image. <a href="https://www.docker.com">Docker</a> is a popular open source project to create containers; you can download it for your operating system and start using it to build and run your containers. <a href="https://podman.io">Podman</a> is another open source alternative to do this, and it can also generate Kubernetes objects.</p>

<p>When you have Docker or <a data-type="indexterm" data-primary="Podman, container building" id="idm45261446307248"/>Podman on your workstation, you can start building your container from the Dockerfile with this command:</p>

<pre data-type="programlisting" data-code-language="bash">docker build -f Dockerfile -t docker.io/modernizingjavaappsbook/
  inventory-quarkus:latest</pre>

<p>This will generate your container image by reading the instructions from the Dockerfile. Then it will tag your container image in the form <code>&lt;repository&gt;/&lt;name&gt;:&lt;tag&gt;</code>, in this case, <code>docker.io/modernizingjavaappsbook/inventory-quarkus:latest</code>. You will see an output similar to this:</p>

<pre data-type="programlisting" data-code-language="text">STEP 1: FROM registry.access.redhat.com/ubi8/openjdk-11
Getting image source signatures
Copying blob 57562f1b61a7 done
Copying blob a6b97b4963f5 done
Copying blob 13948a011eec done
Copying config 5d89ab50b9 done
Writing manifest to image destination
Storing signatures
STEP 2: ENV PROFILE=prod
STEP 3: ADD target/*.jar app.jar
STEP 4: EXPOSE 8080
STEP 5: CMD java -jar app.jar
STEP 6: COMMIT inventory-quarkus:latest
Getting image source signatures
Copying blob 3aa55ff7bca1 skipped: already exists
Copying blob 00af10937683 skipped: already exists
Copying blob 7f08faf4d929 skipped: already exists
Copying blob 1ab317e3c719 done
Copying config b2ae304e3c done
Writing manifest to image destination
Storing signatures
--&gt; b2ae304e3c5
b2ae304e3c57216e42b11d8be9941dc8411e98df13076598815d7bc376afb7a1</pre>

<p>Your container image is now stored in Docker’s or <a data-type="indexterm" data-primary="container images" data-secondary="Dockerfile" data-tertiary="Docker cache" id="idm45261446285488"/><a data-type="indexterm" data-primary="Dockerfiles" data-secondary="container images" data-tertiary="Docker cache" id="idm45261446284400"/><a data-type="indexterm" data-primary="Docker" data-secondary="Docker cache" id="idm45261446266768"/><a data-type="indexterm" data-primary="container images" data-secondary="Dockerfile" data-tertiary="Container cache" id="idm45261446265824"/><a data-type="indexterm" data-primary="Dockerfiles" data-secondary="container images" data-tertiary="Container cache" id="idm45261446264608"/><a data-type="indexterm" data-primary="Container cache" id="idm45261446263392"/>Podman’s local storage called <em>Docker cache</em> or <em>Container cache</em>, and it is ready to be used locally.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>You can create an Uber-Jar for production <a data-type="indexterm" data-primary="container images" data-secondary="Dockerfile" data-tertiary="building" data-startref="Dockerbuild" id="idm45261446260656"/><a data-type="indexterm" data-primary="Dockerfiles" data-secondary="container images" data-tertiary="building" data-startref="imagebuild" id="idm45261446259136"/><a data-type="indexterm" data-primary="uber-jar" id="idm45261446299344"/>for the Inventory service with this command:
 <code>./mvnw package -Dquarkus.profile=prod</code>. You can let Docker or Podman compile your software and create the container using a particular kind of container images build called <a href="https://oreil.ly/HzhDj">Multi-stage</a>. See <a href="https://oreil.ly/UK3c2">this Dockerfile</a> as an example.</p>
</div>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Run Containers"><div class="sect2" id="idm45261446296512">
<h2>Run Containers</h2>

<p><em>Running containers</em> refers to pulling the container images from the container cache to run <a data-type="indexterm" data-primary="containers" data-secondary="Docker, running" id="idm45261446294624"/><a data-type="indexterm" data-primary="Docker" data-secondary="containers" id="idm45261446293648"/>applications. This process will be isolated by the container runtime (such as Docker or Podman) from the other ones in our workstation, providing a portable application with all dependencies managed inside a container and not in our workstation.</p>

<p>To start testing the Inventory microservice packaged now as a container image, you can run the command below:</p>

<pre data-type="programlisting" data-code-language="bash">docker run -ti docker.io/modernizingjavaappsbook/inventory-quarkus:latest</pre>

<p>You see that the Quarkus microservice is up and running in a container, listening to the port 8080. Docker or Podman takes care of mapping container networking into your workstation; open your browser at <a href="http://localhost:8080"><em class="hyperlink">http://localhost:8080</em></a>, and you will see the Quarkus welcome page (as in <a data-type="xref" href="ch02.xhtml#fig2-4">Figure 2-4</a>).</p>
<div data-type="tip"><h6>Tip</h6>
<p><a href="https://oreil.ly/ja9Iu">Docker Network documentation</a> contains more info on how to map ports and networks within containers and hosts running Docker.</p>
</div>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Registry"><div class="sect2" id="idm45261446223792">
<h2>Registry</h2>

<p>As we described in the previous section, container <a data-type="indexterm" data-primary="container images" data-secondary="Dockerfile" data-tertiary="registry" id="containDockreg"/><a data-type="indexterm" data-primary="Docker" data-secondary="container images, registry" id="containregister"/>images are stored in a local cache. However, if you want to make them available outside your workstation, you need to send them over in some convenient way. A container image’s size is generally hundreds of megabytes. That’s why you need a container image registry.</p>

<p>The registry essentially acts as a place to store container images and share them via a process of uploading to (pushing) and downloading from (pulling). Once the image is on another system, the original application contained within it can be run on that system as well.</p>

<p>Registries can be <a data-type="indexterm" data-primary="registry, container images" id="idm45261446236480"/>public or private. Popular public registries include <a href="https://hub.docker.com">Docker Hub</a> and <a href="https://quay.io">Quay.io</a>. They are offered as a SaaS on the internet and allow images to be available publicly with or without authentication. Private registries are usually dedicated to specific users and are not accessible for public usage. However, you may make them available to private environments, such as private Kubernetes clusters.</p>

<p>In this example, we created an organization at DockerHub for the book, called 
<span class="keep-together"><code>modernizingjavaappsbook</code></span>, that maps into a repository of this public registry where we want to push our container image.</p>

<p>First, you need to log in to the registry. You need to authenticate against it in order 
<span class="keep-together">to be</span> able to push new content, then you will leave the container image publicly 
<span class="keep-together">available</span>:</p>

<pre data-type="programlisting" data-code-language="bash">docker login docker.io</pre>

<p>After you log in successfully, you can start uploading the Inventory container image to the registry:</p>

<pre data-type="programlisting" data-code-language="bash">docker push docker.io/modernizingjavaappsbook/inventory-quarkus:latest</pre>

<p>This command pushes the images to the registry, and you should get  output similar to the following as confirmation:</p>

<pre data-type="programlisting" data-code-language="text">Getting image source signatures
Copying blob 7f08faf4d929 done
Copying blob 1ab317e3c719 done
Copying blob 3aa55ff7bca1 skipped: already exists
Copying blob 00af10937683 skipped: already exists
Copying config b2ae304e3c done
Writing manifest to image destination
Storing signatures</pre>

<p>The Quarkus microservice, packaged as a <a data-type="indexterm" data-primary="container images" data-secondary="Docker" data-tertiary="registry" data-startref="containDockreg" id="idm45261446172400"/><a data-type="indexterm" data-primary="Docker" data-secondary="container images, registry" data-startref="containregister" id="idm45261446170976"/>container image, is now ready to be deployed everywhere!</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Deploying to Kubernetes"><div class="sect1" id="idm45261446223200">
<h1>Deploying to Kubernetes</h1>

<p>Deploying applications to Kubernetes <a data-type="indexterm" data-primary="Kubernetes" data-secondary="deploying to" id="idm45261446168080"/><a data-type="indexterm" data-primary="deployment" data-secondary="to Kubernetes" id="idm45261446167104"/>is done by interacting with Kubernetes API to create the objects representing the desired state of the app in a Kubernetes cluster. As we discussed, Pods, Services, and Deployments are the minimum objects created to let Kubernetes manage the entire application life cycle and connectivity.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>If you don’t have a Kubernetes cluster yet, you <a data-type="indexterm" data-primary="Kubernetes" data-secondary="clusters" id="idm45261446148336"/>can download and use <a href="https://oreil.ly/n2Kgx">minikube</a>, a standalone Kubernetes cluster designed for local development.</p>
</div>

<p>Every object in Kubernetes contains the following values:</p>
<dl>
<dt>apiVersion</dt>
<dd>
<p>Kubernetes API version used to create this object</p>
</dd>
<dt>kind</dt>
<dd>
<p>The object type (e.g. Pod, Service)</p>
</dd>
<dt>metadata</dt>
<dd>
<p>Pieces of information that help uniquely identify the object, such as a name or UID</p>
</dd>
<dt>spec</dt>
<dd>
<p>The desired state for the object</p>
</dd>
</dl>

<p>In this section, we defined the basic structure of any Kubernetes objects. Now, let’s explore the fundamental objects needed to run applications on top of Kubernetes.</p>








<section data-type="sect2" data-pdf-bookmark="Pod"><div class="sect2" id="idm45261446204432">
<h2>Pod</h2>

<p>A <a href="https://oreil.ly/KQk2T">Pod</a> is a group of one or more containers <a data-type="indexterm" data-primary="Kubernetes" data-secondary="deploying to" data-tertiary="pods" id="Kuberdeploy"/><a data-type="indexterm" data-primary="deployment" data-secondary="to Kubernetes" data-tertiary="pods" id="deploytoKuber"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="pods" id="KuberPods"/>with shared storage and network resources and a specification for how to run the containers. In <a data-type="xref" href="#fig4-4">Figure 4-4</a>, you can see a representation of two Pods in a Kubernetes cluster, with an example IP address assigned by Kubernetes to each of them.</p>

<figure><div id="fig4-4" class="figure">
<img src="Images/moej_0404.png" alt="Pods and containers" width="600" height="130"/>
<h6><span class="label">Figure 4-4. </span>Pods and containers</h6>
</div></figure>

<p>Kubernetes doesn’t work directly with containers; it relies on the Pod concept to orchestrate containers. As such, you need to provide a Pod definition that matches your container:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">v1</code><code>
</code><code class="nt">kind</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">Pod</code><code>
</code><code class="nt">metadata</code><code class="p">:</code><code>
</code><code>  </code><code class="nt">name</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">inventory-quarkus</code><code> </code><a class="co" id="co_a_kubernetes_based_software_development_platform_CO2-1" href="#callout_a_kubernetes_based_software_development_platform_CO2-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a><code>
</code><code>  </code><code class="nt">labels</code><code class="p">:</code><code>
</code><code>    </code><code class="nt">app</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">inventory-quarkus</code><code> </code><a class="co" id="co_a_kubernetes_based_software_development_platform_CO2-2" href="#callout_a_kubernetes_based_software_development_platform_CO2-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a><code>
</code><code class="nt">spec</code><code class="p">:</code><code>
</code><code>  </code><code class="nt">containers</code><code class="p">:</code><code> </code><a class="co" id="co_a_kubernetes_based_software_development_platform_CO2-3" href="#callout_a_kubernetes_based_software_development_platform_CO2-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a><code>
</code><code>    </code><code class="p-Indicator">-</code><code> </code><code class="nt">name</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">inventory-quarkus</code><code>
</code><code>      </code><code class="nt">image</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">docker.io/modernizingjavaappsbook/inventory-quarkus:latest</code><code> </code><a class="co" id="co_a_kubernetes_based_software_development_platform_CO2-4" href="#callout_a_kubernetes_based_software_development_platform_CO2-4"><img src="Images/4.png" alt="4" width="12" height="12"/></a><code>
</code><code>      </code><code class="nt">ports</code><code class="p">:</code><code>
</code><code>        </code><code class="p-Indicator">-</code><code> </code><code class="nt">containerPort</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">8080</code><code> </code><a class="co" id="co_a_kubernetes_based_software_development_platform_CO2-5" href="#callout_a_kubernetes_based_software_development_platform_CO2-5"><img src="Images/5.png" alt="5" width="12" height="12"/></a></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_a_kubernetes_based_software_development_platform_CO2-1" href="#co_a_kubernetes_based_software_development_platform_CO2-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>Name for the Pod object, unique per Namespace</p></dd>
<dt><a class="co" id="callout_a_kubernetes_based_software_development_platform_CO2-2" href="#co_a_kubernetes_based_software_development_platform_CO2-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>A list of key/value pairs to apply to this object</p></dd>
<dt><a class="co" id="callout_a_kubernetes_based_software_development_platform_CO2-3" href="#co_a_kubernetes_based_software_development_platform_CO2-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a></dt>
<dd><p>A list of containers used in this Pod</p></dd>
<dt><a class="co" id="callout_a_kubernetes_based_software_development_platform_CO2-4" href="#co_a_kubernetes_based_software_development_platform_CO2-4"><img src="Images/4.png" alt="4" width="12" height="12"/></a></dt>
<dd><p>The container image URI, in this case a repository publicly available in Docker Hub</p></dd>
<dt><a class="co" id="callout_a_kubernetes_based_software_development_platform_CO2-5" href="#co_a_kubernetes_based_software_development_platform_CO2-5"><img src="Images/5.png" alt="5" width="12" height="12"/></a></dt>
<dd><p>The port exposed by this container, to be mapped into a Pod</p></dd>
</dl>
<div data-type="tip"><h6>Tip</h6>
<p>Generally, one Pod contains one container, thus the mapping is 
<span class="keep-together">1 Pod</span> : 1 application. Although you could have multiple containers in one Pod for some use cases (e.g., sidecars), the best practice 
<span class="keep-together">is to map</span> 1 Pod to 1 app, because this ensures scalability and 
<span class="keep-together">maintainability</span>.</p>
</div>

<p>You can create any of the Kubernetes objects <a data-type="indexterm" data-primary="Kubernetes CLI" id="idm45261446014928"/><a data-type="indexterm" data-primary="CLI (command-line interface)" data-secondary="Kubernetes" id="idm45261446014224"/>described previously as a YAML file with the Kubernetes CLI <code>kubectl</code>. Run the command as shown next to deploy your first microservice as a single Pod.  You can find it in this <a href="https://oreil.ly/YF8bT">book’s GitHub repository</a>:</p>

<pre data-type="programlisting" data-code-language="bash">kubectl create -f pod.yaml</pre>

<p>To check that it is running on Kubernetes:</p>

<pre data-type="programlisting" data-code-language="bash">kubectl get pods</pre>

<p>You should get an output similar to:</p>

<pre data-type="programlisting" data-code-language="bash">NAME               READY  STATUS   RESTARTS  AGE
inventory-quarkus  1/1    Running  <code class="m">0</code>         30s</pre>

<p>If you look at the <code>STATUS</code> column, it shows the Pod is running correctly and all default health checks <a data-type="indexterm" data-primary="Kubernetes" data-secondary="deploying to" data-tertiary="pods" data-startref="Kuberdeploy" id="idm45261445976736"/><a data-type="indexterm" data-primary="deployment" data-secondary="to Kubernetes" data-tertiary="pods" data-startref="deploytoKuber" id="idm45261445975392"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="pods" data-startref="KuberPods" id="idm45261445973904"/>are correctly satisfied.</p>
<div data-type="tip"><h6>Tip</h6>
<p>If you want further details on how to make more granular health checks, please refer to the official Kubernetes documentation for <a href="https://oreil.ly/sOdnL">liveness and readiness probes</a>.</p>
</div>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Service"><div class="sect2" id="idm45261446203808">
<h2>Service</h2>

<p><a href="https://oreil.ly/fOfpN">Kubernetes Services</a> are used to expose an <a data-type="indexterm" data-primary="Kubernetes" data-secondary="deploying to" data-tertiary="services" id="Kuberdeployserv"/><a data-type="indexterm" data-primary="deployment" data-secondary="to Kubernetes" data-tertiary="services" id="deploytoKuberserv"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="services" id="KuberServ"/>application running on a set of Pods. This is useful because a Pod gets a random IP address from the Kubernetes network, which may change if it is restarted or moved to another node within a Kubernetes cluster. Services offers a more consistent way to communicate with Pods, acting as a DNS server and load balancer.</p>

<p>A Service is mapped to one or more Pods; it uses the internal DNS to resolve to an internal IP from a mnemonic short hostname (e.g., <code>inventory-quarkus</code>), and balances the traffic to the Pods as shown in <a data-type="xref" href="#fig4-5">Figure 4-5</a>. Each Service get its own IP address from a dedicated IP address range, which is different from a Pod’s IP address range.</p>

<figure><div id="fig4-5" class="figure">
<img src="Images/moej_0405.png" alt="Kubernetes Service" width="600" height="296"/>
<h6><span class="label">Figure 4-5. </span>A Kubernetes Service</h6>
</div></figure>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The balancing method offered by Kubernetes Services is Layer 4 (TCP/UDP). The only two strategies usable are round-robin and source IP. For application layer balancing (e.g., HTTP), there are other objects like <code>Ingress</code> not covered in this book, but you can find the documentation for them <a href="https://oreil.ly/VBvOu">here</a>.</p>
</div>

<p>Let’s have a look at a Service that could map our Pod:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">v1</code><code>
</code><code class="nt">kind</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">Service</code><code>
</code><code class="nt">metadata</code><code class="p">:</code><code>
</code><code>  </code><code class="nt">name</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">inventory-quarkus-service</code><code> </code><a class="co" id="co_a_kubernetes_based_software_development_platform_CO3-1" href="#callout_a_kubernetes_based_software_development_platform_CO3-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a><code>
</code><code class="nt">spec</code><code class="p">:</code><code>
</code><code>  </code><code class="nt">selector</code><code class="p">:</code><code>
</code><code>    </code><code class="nt">app</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">inventory-quarkus</code><code> </code><a class="co" id="co_a_kubernetes_based_software_development_platform_CO3-2" href="#callout_a_kubernetes_based_software_development_platform_CO3-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a><code>
</code><code>  </code><code class="nt">ports</code><code class="p">:</code><code>
</code><code>    </code><code class="p-Indicator">-</code><code> </code><code class="nt">protocol</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">TCP</code><code> </code><a class="co" id="co_a_kubernetes_based_software_development_platform_CO3-3" href="#callout_a_kubernetes_based_software_development_platform_CO3-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a><code>
</code><code>      </code><code class="nt">port</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">8080</code><code> </code><a class="co" id="co_a_kubernetes_based_software_development_platform_CO3-4" href="#callout_a_kubernetes_based_software_development_platform_CO3-4"><img src="Images/4.png" alt="4" width="12" height="12"/></a><code>
</code><code>      </code><code class="nt">targetPort</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">8080</code><code> </code><a class="co" id="co_a_kubernetes_based_software_development_platform_CO3-5" href="#callout_a_kubernetes_based_software_development_platform_CO3-5"><img src="Images/5.png" alt="5" width="12" height="12"/></a></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_a_kubernetes_based_software_development_platform_CO3-1" href="#co_a_kubernetes_based_software_development_platform_CO3-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>Name for the Service object</p></dd>
<dt><a class="co" id="callout_a_kubernetes_based_software_development_platform_CO3-2" href="#co_a_kubernetes_based_software_development_platform_CO3-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>The label exposed by the Pod to match the Service</p></dd>
<dt><a class="co" id="callout_a_kubernetes_based_software_development_platform_CO3-3" href="#co_a_kubernetes_based_software_development_platform_CO3-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a></dt>
<dd><p>The L4 protocol used, TCP or UDP</p></dd>
<dt><a class="co" id="callout_a_kubernetes_based_software_development_platform_CO3-4" href="#co_a_kubernetes_based_software_development_platform_CO3-4"><img src="Images/4.png" alt="4" width="12" height="12"/></a></dt>
<dd><p>The port used by this Service</p></dd>
<dt><a class="co" id="callout_a_kubernetes_based_software_development_platform_CO3-5" href="#co_a_kubernetes_based_software_development_platform_CO3-5"><img src="Images/5.png" alt="5" width="12" height="12"/></a></dt>
<dd><p>The port used by the Pod and mapped into the Service</p></dd>
</dl>

<p>To create your Service, run the command as shown below.  You can also find it in this <a href="https://oreil.ly/e13Dd">book’s GitHub repository</a>:</p>

<pre data-type="programlisting" data-code-language="bash">kubectl create -f service.yaml</pre>

<p>To check that it is running on Kubernetes:</p>

<pre data-type="programlisting" data-code-language="bash">kubectl get svc</pre>

<p>You should get output similar to:</p>

<pre data-type="programlisting" data-code-language="bash">NAME                       TYPE       CLUSTER-IP    EXTERNAL-IP  PORT<code class="o">(</code>S<code class="o">)</code>   AGE
inventory-quarkus-service  ClusterIP  172.30.34.73  &lt;none&gt;       8080/TCP  6s</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>You just defined a Service, mapped to a Pod. This is only accessible from the internal Kubernetes network, unless <a data-type="indexterm" data-primary="Kubernetes" data-secondary="deploying to" data-tertiary="services" data-startref="Kuberdeployserv" id="idm45261445795536"/><a data-type="indexterm" data-primary="deployment" data-secondary="to Kubernetes" data-tertiary="services" data-startref="deploytoKuberserv" id="idm45261445777104"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="services" data-startref="KuberServ" id="idm45261445775616"/>you expose it with an object that can accept the traffic from outside the cluster, like Ingress.</p>
</div>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Deployment"><div class="sect2" id="idm45261445970032">
<h2>Deployment</h2>

<p>Deployments are Kubernetes objects <a data-type="indexterm" data-primary="Kubernetes" data-secondary="deployments" id="Kuberdeployments"/><a data-type="indexterm" data-primary="deployment" data-secondary="to Kubernetes" data-tertiary="deployments" id="deploymentsKuberserv"/>created for managing an application life cycle. A deployment describes a desired state, and Kubernetes will implement it using either a <em>rolling</em> or <em>re-create</em> deployment <a data-type="indexterm" data-primary="re-create deployment, Kubernetes" id="idm45261445826704"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="rolling update" id="idm45261445826000"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="re-create deployment strategy" id="idm45261445825056"/>strategy. The rollout life cycle consists of progressing, complete, and failed states. A deployment is progressing while it is performing update tasks, such as updating or scaling Pods.</p>

<p>Kubernetes deployments offer a set of capabilities on top of the basic Pod and Service concepts as listed next and in <a data-type="xref" href="#fig4-6">Figure 4-6</a>:</p>

<ul>
<li>
<p>Deploy a ReplicaSet or Pod</p>
</li>
<li>
<p>Update Pods and ReplicaSets</p>
</li>
<li>
<p>Rollback to previous deployment versions</p>
</li>
<li>
<p>Scale a deployment</p>
</li>
<li>
<p>Pause or continue a deployment</p>
</li>
<li>
<p>Define health checks</p>
</li>
<li>
<p>Define resources constraints</p>
</li>
</ul>

<figure><div id="fig4-6" class="figure">
<img src="Images/moej_0406.png" alt="Deployments manage applications life-cycle and updates" width="600" height="192"/>
<h6><span class="label">Figure 4-6. </span>Deployments manage an application’s life cycle and updates</h6>
</div></figure>

<p>Managing applications with a Kubernetes deployment includes the way in which an application should be updated. A major benefit of a deployment is the ability to start and stop a set of Pods predictably. There are two strategies for deploying apps in Kubernetes:</p>
<dl>
<dt>Rolling update</dt>
<dd>
<p>It provides a controlled, phased <a data-type="indexterm" data-primary="rolling update, Kubernetes" id="idm45261445746896"/>replacement of the application’s Pods, ensuring that there are always a minimum number available. This is useful for the business continuity of an application, where the traffic is not routed into a new version of the application until the health checks (probes) on the desired number of Pods deployed are satisfied.</p>
</dd>
</dl>
<dl class="pagebreak-before">
<dt>Re-create</dt>
<dd>
<p>It removes all <a data-type="indexterm" data-primary="re-create deployment, Kubernetes" id="idm45261445743712"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="re-create deployment strategy" id="idm45261445742960"/>existing pods before new ones are created. Kubernetes first terminates all containers from the current version and then starts all new containers simultaneously when the old containers are gone. This provides downtime for the app, but it ensures there aren’t multiple versions running at the same time.</p>
</dd>
</dl>

<p>A <code>Deployment</code> object driving Pods deployment <a data-type="indexterm" data-primary="Kubernetes" data-secondary="Deployment object" id="idm45261445740464"/>on Kubernetes is listed in the following example:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">apps/v1</code><code>
</code><code class="nt">kind</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">Deployment</code><code>
</code><code class="nt">metadata</code><code class="p">:</code><code>
</code><code>  </code><code class="nt">name</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">inventory-quarkus-deploy</code><code> </code><a class="co" id="co_a_kubernetes_based_software_development_platform_CO4-1" href="#callout_a_kubernetes_based_software_development_platform_CO4-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a><code>
</code><code>  </code><code class="nt">labels</code><code class="p">:</code><code>
</code><code>    </code><code class="nt">app</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">inventory-quarkus</code><code> </code><a class="co" id="co_a_kubernetes_based_software_development_platform_CO4-2" href="#callout_a_kubernetes_based_software_development_platform_CO4-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a><code>
</code><code class="nt">spec</code><code class="p">:</code><code>
</code><code>  </code><code class="nt">replicas</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">1</code><code> </code><a class="co" id="co_a_kubernetes_based_software_development_platform_CO4-3" href="#callout_a_kubernetes_based_software_development_platform_CO4-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a><code>
</code><code>  </code><code class="nt">selector</code><code class="p">:</code><code>
</code><code>    </code><code class="nt">matchLabels</code><code class="p">:</code><code>
</code><code>      </code><code class="nt">app</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">inventory-quarkus</code><code> </code><a class="co" id="co_a_kubernetes_based_software_development_platform_CO4-4" href="#callout_a_kubernetes_based_software_development_platform_CO4-4"><img src="Images/4.png" alt="4" width="12" height="12"/></a><code>
</code><code>  </code><code class="nt">template</code><code class="p">:</code><code> </code><a class="co" id="co_a_kubernetes_based_software_development_platform_CO4-5" href="#callout_a_kubernetes_based_software_development_platform_CO4-5"><img src="Images/5.png" alt="5" width="12" height="12"/></a><code>
</code><code>    </code><code class="nt">metadata</code><code class="p">:</code><code>
</code><code>      </code><code class="nt">labels</code><code class="p">:</code><code>
</code><code>        </code><code class="nt">app</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">inventory-quarkus</code><code>
</code><code>    </code><code class="nt">spec</code><code class="p">:</code><code>
</code><code>      </code><code class="nt">containers</code><code class="p">:</code><code>
</code><code>      </code><code class="p-Indicator">-</code><code> </code><code class="nt">name</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">inventory-quarkus</code><code>
</code><code>        </code><code class="nt">image</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">docker.io/modernizingjavaappsbook/inventory-quarkus:latest</code><code> </code><a class="co" id="co_a_kubernetes_based_software_development_platform_CO4-6" href="#callout_a_kubernetes_based_software_development_platform_CO4-6"><img src="Images/6.png" alt="6" width="12" height="12"/></a><code>
</code><code>        </code><code class="nt">ports</code><code class="p">:</code><code>
</code><code>        </code><code class="p-Indicator">-</code><code> </code><code class="nt">containerPort</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">8080</code><code>
</code><code>        </code><code class="nt">readinessProbe</code><code class="p">:</code><code> </code><a class="co" id="co_a_kubernetes_based_software_development_platform_CO4-7" href="#callout_a_kubernetes_based_software_development_platform_CO4-7"><img src="Images/7.png" alt="7" width="12" height="12"/></a><code>
</code><code>          </code><code class="nt">httpGet</code><code class="p">:</code><code>
</code><code>            </code><code class="nt">path</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">/</code><code>
</code><code>            </code><code class="nt">port</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">8080</code><code>
</code><code>            </code><code class="nt">scheme</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">HTTP</code><code>
</code><code>          </code><code class="nt">periodSeconds</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">10</code><code>
</code><code>          </code><code class="nt">successThreshold</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">1</code><code>
</code><code>          </code><code class="nt">failureThreshold</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">3</code><code>
</code><code>        </code><code class="nt">livenessProbe</code><code class="p">:</code><code> </code><a class="co" id="co_a_kubernetes_based_software_development_platform_CO4-8" href="#callout_a_kubernetes_based_software_development_platform_CO4-8"><img src="Images/8.png" alt="8" width="12" height="12"/></a><code>
</code><code>          </code><code class="nt">httpGet</code><code class="p">:</code><code>
</code><code>            </code><code class="nt">path</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">/</code><code>
</code><code>            </code><code class="nt">port</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">8080</code><code>
</code><code>            </code><code class="nt">scheme</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">HTTP</code><code>
</code><code>          </code><code class="nt">periodSeconds</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">10</code><code>
</code><code>          </code><code class="nt">successThreshold</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">1</code><code>
</code><code>          </code><code class="nt">failureThreshold</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">3</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_a_kubernetes_based_software_development_platform_CO4-1" href="#co_a_kubernetes_based_software_development_platform_CO4-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>Name for the Deployment object.</p></dd>
<dt><a class="co" id="callout_a_kubernetes_based_software_development_platform_CO4-2" href="#co_a_kubernetes_based_software_development_platform_CO4-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>The label for this object.</p></dd>
<dt><a class="co" id="callout_a_kubernetes_based_software_development_platform_CO4-3" href="#co_a_kubernetes_based_software_development_platform_CO4-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a></dt>
<dd><p>The desired number of Pod replicas.</p></dd>
<dt><a class="co" id="callout_a_kubernetes_based_software_development_platform_CO4-4" href="#co_a_kubernetes_based_software_development_platform_CO4-4"><img src="Images/4.png" alt="4" width="12" height="12"/></a></dt>
<dd><p>The selector to find which Pods to manage using labels.</p></dd>
<dt><a class="co" id="callout_a_kubernetes_based_software_development_platform_CO4-5" href="#co_a_kubernetes_based_software_development_platform_CO4-5"><img src="Images/5.png" alt="5" width="12" height="12"/></a></dt>
<dd><p>The Pod template to use, including labels to inherit or containers to create.</p></dd>
<dt><a class="co" id="callout_a_kubernetes_based_software_development_platform_CO4-6" href="#co_a_kubernetes_based_software_development_platform_CO4-6"><img src="Images/6.png" alt="6" width="12" height="12"/></a></dt>
<dd><p>The container image to use.</p></dd>
<dt><a class="co" id="callout_a_kubernetes_based_software_development_platform_CO4-7" href="#co_a_kubernetes_based_software_development_platform_CO4-7"><img src="Images/7.png" alt="7" width="12" height="12"/></a></dt>
<dd><p>Kubernetes uses readiness probes to know when a container is ready to start accepting traffic, and a Pod is considered ready when all of its containers are ready. Here we define an HTTP health check on the root path as a readiness probe.</p></dd>
<dt><a class="co" id="callout_a_kubernetes_based_software_development_platform_CO4-8" href="#co_a_kubernetes_based_software_development_platform_CO4-8"><img src="Images/8.png" alt="8" width="12" height="12"/></a></dt>
<dd><p>Kubernetes uses liveness probes to know when to restart a container. Here we define an HTTP health check on the root path as a liveness probe.</p></dd>
</dl>

<p>Run the following command to create your Deployment.  You can also find it in this <a href="https://oreil.ly/PWucG">book’s GitHub repository</a>:</p>

<pre data-type="programlisting" data-code-language="bash">kubectl create -f deployment.yaml</pre>

<p>Run the following command to verify that the Deployment has been created, and to get the status:</p>

<pre data-type="programlisting" data-code-language="bash">kubectl get deploy</pre>

<p>You should get output similar to:</p>

<pre data-type="programlisting" data-code-language="bash">NAME                       READY   UP-TO-DATE   AVAILABLE   AGE
inventory-quarkus-deploy   1/1     <code class="m">1</code>            <code class="m">1</code>           10s</pre>

<p>Looking at the <code>READY</code> column, you have your desired state correctly matched, having requested one replica for the Inventory microservice running on Kubernetes. You can cross-check that a Pod has been created:</p>

<pre data-type="programlisting" data-code-language="bash">kubectl get pods</pre>

<p>You should get similar output to:</p>

<pre data-type="programlisting" data-code-language="bash">NAME                                        READY   STATUS    RESTARTS   AGE
inventory-quarkus                           1/1     Running   <code class="m">0</code>          1m
inventory-quarkus-deploy-5cb46f5d8d-fskpd   1/1     Running   <code class="m">0</code>          30s</pre>

<p>Now a new Pod has been created using a randomly generated name, starting from the <code>inventory-quarkus-deploy</code> Deployment name. If the app crashes or if we kill the Pod managed by the Deployment, Kubernetes will re-create it automatically for us. This is not true for the Pod generated without a Deployment:</p>

<pre data-type="programlisting" data-code-language="bash">kubectl delete pod inventory-quarkus inventory-quarkus-deploy-5cb46f5d8d-fskpd</pre>

<p class="pagebreak-before">You can see that the desired state <a data-type="indexterm" data-primary="Kubernetes" data-secondary="deployments" data-startref="Kuberdeployments" id="idm45261445448864"/><a data-type="indexterm" data-primary="deployment" data-secondary="to Kubernetes" data-tertiary="deployments" data-startref="deploymentsKuberserv" id="idm45261445447744"/>is always met:</p>

<pre data-type="programlisting" data-code-language="bash">kubectl get pods</pre>

<p>You should get output similar to:</p>

<pre data-type="programlisting" data-code-language="bash">NAME                                        READY   STATUS    RESTARTS   AGE
inventory-quarkus-deploy-5cb46f5d8d-llp7n   1/1     Running   <code class="m">0</code>          42s</pre>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Kubernetes and Java"><div class="sect1" id="idm45261445773120">
<h1>Kubernetes and Java</h1>

<p>Kubernetes has a tremendous amount of potential for managing applications’ life cycles, and there are a number of <a data-type="indexterm" data-primary="Kubernetes" data-secondary="Java and" id="idm45261445388816"/><a data-type="indexterm" data-primary="Java" data-secondary="Kubernetes and" id="idm45261445387840"/>studies on how developers and architects could best fit in its architecture, like patterns. Kubernetes patterns are reusable design patterns for container-based applications and services.</p>

<p>From a Java developer perspective, the first step is to migrate from the monolithic approach to a microservice-based approach. Once that is complete, the next step is to get into the Kubernetes context and maximize the benefits this platform offers: API extendibility, a declarative model, and a standarized process where the IT industry is converging.</p>

<p>There are Java frameworks that help developers connect to Kubernetes and convert their apps to containers. You already containerized the <code>Inventory</code> Quarkus microservice with a Dockerfile. Now let’s drive this containerization from Java, generating a container image for the <code>Catalog</code> Spring Boot microservice using Maven and Gradle.</p>








<section data-type="sect2" data-pdf-bookmark="Jib"><div class="sect2" id="idm45261445345232">
<h2>Jib</h2>

<p><a href="https://oreil.ly/N2jRr">Jib</a> is an open source framework made by Google to build container <a data-type="indexterm" data-primary="Kubernetes" data-secondary="Java and" data-tertiary="Jib" id="KubJavJib"/><a data-type="indexterm" data-primary="Java" data-secondary="Kubernetes and" data-tertiary="Jib" id="JavKubJib"/><a data-type="indexterm" data-primary="Jib" id="jib"/><a data-type="indexterm" data-primary="OCI (Open Container Initiative)" id="idm45261445502192"/><a data-type="indexterm" data-primary="container images" data-secondary="Jib" id="idm45261445501552"/>images compliant to the Open Container Initiative (OCI) image format, without the need of Docker or any container runtime. You can create containers even from your Java codebase because it offers a Maven and Gradle plug-in for that. This means Java developers can containerize their app without writing and/or maintaining any Dockerfiles, delegating this complexity to Jib.</p>

<p>We see the <a href="https://oreil.ly/2y92D">benefits from this approach</a> as follows:</p>
<dl>
<dt>Pure Java</dt>
<dd>
<p>No Docker or Dockerfile knowledge is required; simply add Jib as a plug-in, and it will generate the container image for you. The resulting image is commonly referred to as “distroless,” since it doesn’t inherit from any base image.</p>
</dd>
<dt>Speed</dt>
<dd>
<p>The application is divided into multiple layers, splitting dependencies from classes. There’s no need to rebuild the container image as is necessary for Dockerfiles; Jib takes care of deploying the layers that changed.</p>
</dd>
<dt>Reproducibility</dt>
<dd>
<p>Unnecessary updates are not triggered, as the same contents always generate the same image.</p>
</dd>
</dl>

<p>The easiest way to kick-start a container image build with Jib, on existing Maven, is by adding the plug-in via command line:</p>

<pre data-type="programlisting" data-code-language="bash">mvn compile com.google.cloud.tools:jib-maven-plugin:2.8.0:build
  -Dimage<code class="o">=</code>&lt;MY IMAGE&gt;</pre>

<p>Alternatively, you can do so by adding Jib as a plug-in into <em>pom.xml</em>:</p>

<pre data-type="programlisting" data-code-language="xml"><code class="nt">&lt;project&gt;</code>
  ...
  <code class="nt">&lt;build&gt;</code>
    <code class="nt">&lt;plugins&gt;</code>
      ...
      <code class="nt">&lt;plugin&gt;</code>
        <code class="nt">&lt;groupId&gt;</code>com.google.cloud.tools<code class="nt">&lt;/groupId&gt;</code>
        <code class="nt">&lt;artifactId&gt;</code>jib-maven-plugin<code class="nt">&lt;/artifactId&gt;</code>
        <code class="nt">&lt;version&gt;</code>2.8.0<code class="nt">&lt;/version&gt;</code>
        <code class="nt">&lt;configuration&gt;</code>
          <code class="nt">&lt;to&gt;</code>
            <code class="nt">&lt;image&gt;</code>myimage<code class="nt">&lt;/image&gt;</code>
          <code class="nt">&lt;/to&gt;</code>
        <code class="nt">&lt;/configuration&gt;</code>
      <code class="nt">&lt;/plugin&gt;</code>
      ...
    <code class="nt">&lt;/plugins&gt;</code>
  <code class="nt">&lt;/build&gt;</code>
  ...
<code class="nt">&lt;/project&gt;</code></pre>

<p>In this way you can also manage other settings such as authentication or parameters for the build. Run the command below if you want to build the Catalog service and push it directly to Docker Hub:</p>

<pre data-type="programlisting" data-code-language="bash">mvn compile com.google.cloud.tools:jib-maven-plugin:2.8.0:build↳
-Dimage<code class="o">=</code>docker.io/modernizingjavaappsbook/catalog-spring-boot:latest↳
-Djib.to.auth.username<code class="o">=</code>&lt;USERNAME&gt;↳
-Djib.to.auth.password<code class="o">=</code>&lt;PASSWORD&gt;</pre>

<p>The authentication here is managed as command line options, but Jib is able to 
<span class="keep-together">manage</span> existing authentication with Docker CLI or read credentials from your 
<span class="keep-together"><em>settings.xml</em></span>.</p>

<p>The build takes a few moments, and the result is a distroless container image built locally and pushed directly to a registry, in this case Docker Hub:</p>

<pre data-type="programlisting" data-code-language="bash"><code class="o">[</code>INFO<code class="o">]</code> Scanning <code class="k">for</code> projects...
<code class="o">[</code>INFO<code class="o">]</code>
<code class="o">[</code>INFO<code class="o">]</code> -------------------&lt; com.redhat.cloudnative:catalog &gt;-------------------
<code class="o">[</code>INFO<code class="o">]</code> Building CoolStore Catalog Service 1.0-SNAPSHOT
<code class="o">[</code>INFO<code class="o">]</code> --------------------------------<code class="o">[</code> jar <code class="o">]</code>---------------------------------
<code class="o">[</code>INFO<code class="o">]</code>
<code class="o">[</code>INFO<code class="o">]</code> --- maven-resources-plugin:2.6:resources <code class="o">(</code>default-resources<code class="o">)</code> @ catalog ---
<code class="o">[</code>INFO<code class="o">]</code> Copying <code class="m">4</code> resources
<code class="o">[</code>INFO<code class="o">]</code>
<code class="o">[</code>INFO<code class="o">]</code> --- maven-compiler-plugin:3.6.1:compile <code class="o">(</code>default-compile<code class="o">)</code> @ catalog ---
<code class="o">[</code>INFO<code class="o">]</code> Nothing to compile - all classes are up to date
<code class="o">[</code>INFO<code class="o">]</code>
<code class="o">[</code>INFO<code class="o">]</code> --- jib-maven-plugin:2.8.0:build <code class="o">(</code>default-cli<code class="o">)</code> @ catalog ---
<code class="o">[</code>INFO<code class="o">]</code>
<code class="o">[</code>INFO<code class="o">]</code> Containerizing application to modernizingjavaappsbook/catalog-spring-boot
  ...
<code class="o">[</code>WARNING<code class="o">]</code> Base image <code class="s1">'gcr.io/distroless/java:11'</code> does not use a specific image
  digest↳ - build may not be reproducible
<code class="o">[</code>INFO<code class="o">]</code> Using credentials from &lt;to&gt;&lt;auth&gt; <code class="k">for</code> modernizingjavaappsbook/
  catalog-spring-boot
<code class="o">[</code>INFO<code class="o">]</code> Using base image with digest:↳
sha256:65aa73135827584754f1f1949c59c3e49f1fed6c35a918fadba8b4638ebc9c5d
<code class="o">[</code>INFO<code class="o">]</code>
<code class="o">[</code>INFO<code class="o">]</code> Container entrypoint <code class="nb">set </code>to <code class="o">[</code>java, -cp, /app/resources:/app/classes:/app/
  libs/*, com.redhat.cloudnative.catalog.CatalogApplication<code class="o">]</code>
<code class="o">[</code>INFO<code class="o">]</code>
<code class="o">[</code>INFO<code class="o">]</code> Built and pushed image as modernizingjavaappsbook/catalog-spring-boot
<code class="o">[</code>INFO<code class="o">]</code> Executing tasks:
<code class="o">[</code>INFO<code class="o">]</code> <code class="o">[==============================]</code> 100,0% <code class="nb">complete</code>
<code class="o">[</code>INFO<code class="o">]</code>
<code class="o">[</code>INFO<code class="o">]</code> ------------------------------------------------------------------------
<code class="o">[</code>INFO<code class="o">]</code> BUILD SUCCESS
<code class="o">[</code>INFO<code class="o">]</code> ------------------------------------------------------------------------
<code class="o">[</code>INFO<code class="o">]</code> Total <code class="nb">time</code>:  27.817 s
<code class="o">[</code>INFO<code class="o">]</code> Finished at: 2021-03-19T11:48:16+01:00
<code class="o">[</code>INFO<code class="o">]</code> ------------------------------------------------------------------------</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Your container image is not present in your local cache, as you don’t need any container runtime to build images with Jib. You won’t see it with the <code>docker images</code> command, but you pull it from Docker Hub afterward and it will be stored in your cache.
In case you also want to store it <a data-type="indexterm" data-primary="Kubernetes" data-secondary="Java and" data-tertiary="Jib" data-startref="KubJavJib" id="idm45261445153152"/><a data-type="indexterm" data-primary="Java" data-secondary="Kubernetes and" data-tertiary="Jib" data-startref="JavKubJib" id="idm45261445151632"/><a data-type="indexterm" data-primary="Jib" data-startref="jib" id="idm45261445150144"/>locally from the beginning, Jib also connects to Docker hosts and can do it for you.</p>
</div>
</div></section>













<section data-type="sect2" data-pdf-bookmark="JKube"><div class="sect2" id="idm45261445344608">
<h2>JKube</h2>

<p><a href="https://oreil.ly/Km2ci">Eclipse JKube</a>, a community project supported by the Eclipse Foundation and Red Hat, is another open source Java framework to help with interacting with Kubernetes from a Java developer perspective. It supports building <a data-type="indexterm" data-primary="Kubernetes" data-secondary="Java and" data-tertiary="JKube" id="KubJavJKub"/><a data-type="indexterm" data-primary="Java" data-secondary="Kubernetes and" data-tertiary="JKube" id="JavKubJKub"/><a data-type="indexterm" data-primary="JKube" id="jkube"/>container images using Docker/Podman, Jib, and Source-to-Image (S2I). Eclipse JKube also provides a set of tools to deploy automatically to Kubernetes and manage the application with helpers for debugging and logging. It comes from Fabric8 Maven Plug-in, rebranded and enhanced as a project to target Kubernetes.</p>
<div data-type="tip"><h6>Tip</h6>
<p>JKube supports Kubernetes and OpenShift. OpenShift brings <a href="https://oreil.ly/4z2Zn">Source-to-Image</a> on top of Kubernetes, a mechanism to automatically compile a container image from source code. In this way the build is made on Kubernetes, so developers can test and deploy their apps directly on the target platform.</p>
</div>

<p>As with Jib, JKube provides Zero Configuration mode for a quick ramp-up where opinionated defaults will be preselected. It provides Inline Configuration within the plug-in configuration using an XML syntax. Furthermore, it provides External Configuration templates of real deployment descriptors, which are enriched by the 
<span class="keep-together">plug-in</span>.</p>

<p>JKube is offered in three forms:</p>
<dl>
<dt>Kubernetes Plug-in</dt>
<dd>
<p>It works in any Kubernetes cluster, providing either distroless or Dockerfile-driven builds.</p>
</dd>
<dt>OpenShift Plug-in</dt>
<dd>
<p>It works in any Kubernetes or OpenShift cluster, providing either distroless, Dockerfile-driven builds, or Source-to-Image (S2I) builds.</p>
</dd>
<dt>JKube Kit</dt>
<dd>
<p>A toolkit and a CLI to interact with JKube Core, it also acts as a Kubernetes Client and provides an Enricher API to extend Kubernetes manifests.</p>
</dd>
</dl>

<p>JKube offers more functionality than Jib; in fact, it can be considered a superset. You can do distroless Jib builds, but you can also work with Dockerfile and deploy Kubernetes manifests from Java. In this case, we don’t need to write a Deployment or Service; JKube will take care of building the container and deploy it to Kubernetes.</p>

<p>Let’s include JKube in our Catalog POM file and configure it to do a Jib build and a deploy to Kubernetes. Doing so will make the plug-in persistent. You can also find the source code in this <a href="https://oreil.ly/Ba4Ro">book’s GitHub repository</a>.</p>

<p>First, we need to add JKube as a plug-in:</p>

<pre data-type="programlisting" data-code-language="xml"><code class="nt">&lt;project&gt;</code>
  ...
  <code class="nt">&lt;build&gt;</code>
    <code class="nt">&lt;plugins&gt;</code>
      ...
    <code class="nt">&lt;plugin&gt;</code>
       <code class="nt">&lt;groupId&gt;</code>org.eclipse.jkube<code class="nt">&lt;/groupId&gt;</code>
       <code class="nt">&lt;artifactId&gt;</code>kubernetes-maven-plugin<code class="nt">&lt;/artifactId&gt;</code>
       <code class="nt">&lt;version&gt;</code>1.1.1<code class="nt">&lt;/version&gt;</code>
    <code class="nt">&lt;/plugin&gt;</code>
      ...
    <code class="nt">&lt;/plugins&gt;</code>
  <code class="nt">&lt;/build&gt;</code>
  ...
<code class="nt">&lt;/project&gt;</code></pre>

<p>After that, you can drive the container image build with properties. In this case, you may want to use Jib for building the image and pushing it to Docker Hub. Afterward, you will deploy it to Kubernetes:</p>

<pre data-type="programlisting" data-code-language="xml">...
<code class="nt">&lt;properties&gt;</code>
...
    <code class="nt">&lt;jkube.build.strategy&gt;</code>jib<code class="nt">&lt;/jkube.build.strategy&gt;</code>
    <code class="nt">&lt;jkube.generator.name&gt;</code>docker.io/modernizingjavaappsbook/catalog-spring-boot:
      ${project.version}<code class="nt">&lt;/jkube.generator.name&gt;</code>
<code class="nt">&lt;/properties&gt;</code>
...</pre>

<p>Let’s build the image:</p>

<pre data-type="programlisting" data-code-language="bash">mvn k8s:build</pre>

<p>You should get output similar to:</p>

<pre data-type="programlisting" data-code-language="bash">JIB&gt;... modernizingjavaappsbook/catalog-spring-boot/1.0-SNAPSHOT/build/
  deployments/catalog-1.0-SNAPSHOT.jar
JIB&gt;    :
JIB&gt;... modernizingjavaappsbook/catalog-spring-boot/1.0-SNAPSHOT/build/Dockerfile
...
JIB&gt; <code class="o">[========================</code>      <code class="o">]</code> 80,0% <code class="nb">complete</code> &gt; building image to tar file
JIB&gt; Building image to tar file...
JIB&gt; <code class="o">[========================</code>      <code class="o">]</code> 80,0% <code class="nb">complete</code> &gt; writing to tar file
JIB&gt; <code class="o">[==============================]</code> 100,0% <code class="nb">complete</code>
<code class="o">[</code>INFO<code class="o">]</code> k8s: ... modernizingjavaappsbook/catalog-spring-boot/1.0-SNAPSHOT/tmp/↳
docker-build.tar successfully built
<code class="o">[</code>INFO<code class="o">]</code> ------------------------------------------------------------------------
<code class="o">[</code>INFO<code class="o">]</code> BUILD SUCCESS
<code class="o">[</code>INFO<code class="o">]</code> ------------------------------------------------------------------------
<code class="o">[</code>INFO<code class="o">]</code> Total <code class="nb">time</code>:  36.229 s
<code class="o">[</code>INFO<code class="o">]</code> Finished at: 2021-03-19T13:03:19+01:00
<code class="o">[</code>INFO<code class="o">]</code> ------------------------------------------------------------------------</pre>

<p>JKube using Jib created the container image locally, and it is now ready to be pushed to Docker Hub. You can specify credentials in one of three ways:</p>
<dl>
<dt>Docker login</dt>
<dd>
<p>You can log in to your registry, in this case Docker Hub, and JKube will read the <em>~/.docker/config.json</em> file to get authentication details.</p>
</dd>
<dt>Provide credentials inside POM</dt>
<dd>
<p>Provide registry credentials as part of XML configuration.</p>
</dd>
<dt>Provide credentials inside Maven Settings</dt>
<dd>
<p>You can provide registry credentials in your <em>~/.m2/settings.xml</em> file and the plug-in will read it from there.</p>
</dd>
</dl>

<p>In this case, you use the third option and set up credentials into Maven Settings, so you can copy this file using your credentials. You can also find the source code in this <a href="https://oreil.ly/uxAxW">book’s GitHub repository</a>:</p>

<pre data-type="programlisting" data-code-language="xml"><code class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</code>
<code class="nt">&lt;settings</code> <code class="na">xmlns=</code><code class="s">"http://maven.apache.org/SETTINGS/1.0.0"</code>
          <code class="na">xmlns:xsi=</code><code class="s">"http://www.w3.org/2001/XMLSchema-instance"</code>
          <code class="na">xsi:schemaLocation=</code><code class="s">"http://maven.apache.org/SETTINGS/1.0.0↳</code>
<code class="s">          http://maven.apache.org/xsd/settings-1.0.0.xsd"</code><code class="nt">&gt;</code>

  <code class="nt">&lt;servers&gt;</code>
    <code class="nt">&lt;server&gt;</code>
      <code class="nt">&lt;id&gt;</code>https://index.docker.io/v1<code class="nt">&lt;/id&gt;</code>
      <code class="nt">&lt;username&gt;</code>USERNAME<code class="nt">&lt;/username&gt;</code>
      <code class="nt">&lt;password&gt;</code>PASSWORD<code class="nt">&lt;/password&gt;</code>
    <code class="nt">&lt;/server&gt;</code>
  <code class="nt">&lt;/servers&gt;</code>
<code class="nt">&lt;/settings&gt;</code></pre>

<p>To push it to Docker Hub, you just run this Maven goal:</p>

<pre data-type="programlisting" data-code-language="bash">mvn k8s:push</pre>

<p>You should see output similar to:</p>

<pre data-type="programlisting" data-code-language="bash">JIB&gt; <code class="o">[=========================]</code> 81,8% <code class="nb">complete</code> &gt; scheduling pushing manifests
JIB&gt; <code class="o">[=========================]</code> 81,8% <code class="nb">complete</code> &gt; launching manifest pushers
JIB&gt; <code class="o">[=========================]</code> 81,8% <code class="nb">complete</code> &gt; pushing manifest <code class="k">for</code> latest
JIB&gt; Pushing manifest <code class="k">for</code> latest...
JIB&gt; <code class="o">[=========================]</code> 90,9% <code class="nb">complete</code> &gt; building images to registry
JIB&gt; <code class="o">[=========================]</code> 90,9% <code class="nb">complete</code> &gt; launching manifest list pushers
JIB&gt; <code class="o">[=========================]</code> 100,0% <code class="nb">complete</code>
<code class="o">[</code>INFO<code class="o">]</code> ------------------------------------------------------------------------
<code class="o">[</code>INFO<code class="o">]</code> BUILD SUCCESS
<code class="o">[</code>INFO<code class="o">]</code> ------------------------------------------------------------------------
<code class="o">[</code>INFO<code class="o">]</code> Total <code class="nb">time</code>:  01:08 min
<code class="o">[</code>INFO<code class="o">]</code> Finished at: 2021-03-19T13:21:28+01:00</pre>

<p>Now it’s time to deploy the Catalog on Kubernetes. JKube will connect to your Kubernetes cluster reading the <code>~/.kube/config</code> file on your workstation:</p>

<pre data-type="programlisting" data-code-language="bash">mvn k8s:resource k8s:apply</pre>

<p>You should get output similar to:</p>

<pre data-type="programlisting" data-code-language="bash"><code class="o">[</code>INFO<code class="o">]</code> Scanning <code class="k">for</code> projects...
<code class="o">[</code>INFO<code class="o">]</code>
<code class="o">[</code>INFO<code class="o">]</code> -------------------&lt; com.redhat.cloudnative:catalog &gt;-------------------
<code class="o">[</code>INFO<code class="o">]</code> Building CoolStore Catalog Service 1.0-SNAPSHOT
<code class="o">[</code>INFO<code class="o">]</code> --------------------------------<code class="o">[</code> jar <code class="o">]</code>---------------------------------
<code class="o">[</code>INFO<code class="o">]</code>
<code class="o">[</code>INFO<code class="o">]</code> --- kubernetes-maven-plugin:1.1.1:resource <code class="o">(</code>default-cli<code class="o">)</code> @ catalog ---
<code class="o">[</code>INFO<code class="o">]</code> k8s: Running generator spring-boot
  ...
<code class="o">[</code>INFO<code class="o">]</code> k8s: Creating a Service from kubernetes.yml namespace default name catalog
<code class="o">[</code>INFO<code class="o">]</code> k8s: Created Service: target/jkube/applyJson/default/service-catalog.json
<code class="o">[</code>INFO<code class="o">]</code> k8s: Creating a Deployment from kubernetes.yml namespace default name
  catalog
<code class="o">[</code>INFO<code class="o">]</code> k8s: Created Deployment: target/jkube/applyJson/default/deployment-
  catalog.json
<code class="o">[</code>INFO<code class="o">]</code> k8s: HINT: Use the <code class="nb">command</code> <code class="sb">`</code>kubectl get pods -w<code class="sb">`</code> to watch your pods start
  up
<code class="o">[</code>INFO<code class="o">]</code> ------------------------------------------------------------------------
<code class="o">[</code>INFO<code class="o">]</code> BUILD SUCCESS
<code class="o">[</code>INFO<code class="o">]</code> ------------------------------------------------------------------------
<code class="o">[</code>INFO<code class="o">]</code> Total <code class="nb">time</code>:  7.464 s
<code class="o">[</code>INFO<code class="o">]</code> Finished at: 2021-03-19T13:38:27+01:00
<code class="o">[</code>INFO<code class="o">]</code> ------------------------------------------------------------------------</pre>

<p>The app has been deployed successfully to Kubernetes, using generated manifests:</p>

<pre data-type="programlisting" data-code-language="bash">kubectl get pods</pre>

<pre data-type="programlisting" data-code-language="bash">NAME                       READY   STATUS    RESTARTS   AGE
catalog-64869588f6-fpjj8   1/1     Running   <code class="m">0</code>          2m2s</pre>

<pre data-type="programlisting" data-code-language="bash">kubectl get deploy</pre>

<pre data-type="programlisting" data-code-language="bash">NAME      READY   UP-TO-DATE   AVAILABLE   AGE
catalog   1/1     <code class="m">1</code>            <code class="m">1</code>           3m54s</pre>

<p>To test it, let’s have a look at the Service:</p>

<pre data-type="programlisting" data-code-language="bash">kubectl get svc</pre>

<pre data-type="programlisting" data-code-language="bash">NAME         TYPE        CLUSTER-IP     EXTERNAL-IP   PORT<code class="o">(</code>S<code class="o">)</code>    AGE
catalog      ClusterIP   10.99.26.127   &lt;none&gt;        8080/TCP   4m44s</pre>
<div data-type="tip"><h6>Tip</h6>
<p>By default, Kubernetes exposes the application only internally to the cluster, using <code>ClusterIP</code> Service type. You can expose it externally using a Service type <code>NodePort</code> or using an Ingress. In this example, you will use <code>kubectl port-forward</code> to map the Kubernetes exposed <a data-type="indexterm" data-primary="Kubernetes" data-secondary="Java and" data-tertiary="JKube" data-startref="KubJavJKub" id="idm45261444605776"/><a data-type="indexterm" data-primary="Java" data-secondary="Kubernetes and" data-tertiary="JKube" data-startref="JavKubJKub" id="idm45261444567936"/><a data-type="indexterm" data-primary="JKube" data-startref="jkube" id="idm45261444566560"/>port to our workstation’s port.</p>
</div>

<p>Let’s try our app using the <code>kubectl port-forward</code> command:</p>

<pre data-type="programlisting" data-code-language="bash"> kubectl port-forward deployment/catalog 8080:8080</pre>

<p>If you open your browser now at <a href="http://localhost:8080/api/catalog"><em class="hyperlink">http://localhost:8080/api/catalog</em></a>, you will see the Coolstore’s Catalog JSON output.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Summary"><div class="sect1" id="idm45261445147392">
<h1>Summary</h1>

<p>In this chapter, we discussed how Java developers can benefit from Kubernetes capabilities to modernize and enhance their apps, showing a developer’s inner loop with Kubernetes environments.
We have demonstrated how to create container images and how to deploy them to Kubernetes. We also walked through steps to drive container creation and deploy directly from Java with Maven thanks to Jib and JKube.</p>

<p>Modernization is important for developers in order to make apps cloud native and portable, ready for serving highly available productions and services. In the next chapter, we will look deeper into the modernization of existing Java applications and what steps are needed to achieve it.</p>
</div></section>







</div></section></div></body></html>