- en: Chapter 5\. Configuring and Inspecting Your Spring Boot App
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章。配置和检查您的 Spring Boot 应用程序
- en: There are many things that can go wrong with any application, and some of these
    many things may even have simple solutions. With the rare exception of an occasional
    good guess, however, one must determine the root cause of a problem before it
    is possible to truly solve it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 任何应用程序都可能出现许多问题，其中一些问题甚至可能有简单的解决方案。然而，除了偶尔的猜测，必须在真正解决问题之前确定问题的根本原因。
- en: Debugging Java or Kotlin applications—or any other applications, for that matter—is
    a fundamental skill that every developer should learn very early on in their career
    and refine and expand throughout. I don’t find that to be the case universally,
    so if you haven’t already become handy with the debugging capabilities of your
    language and tools of choice, please explore the options at your disposal as soon
    as possible. It really is important in everything you develop and can save you
    inordinate amounts of time.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 调试 Java 或 Kotlin 应用程序——或者任何其他应用程序，这是每个开发人员在职业生涯早期都应该学会并在其后不断完善和扩展的基本技能。我并不认为这在所有情况下都是适用的，所以如果你尚未熟悉所选语言和工具的调试能力，请尽快探索你手头的选择。这确实在你开发的每个项目中都非常重要，并可以节省大量时间。
- en: 'That said, debugging code is only one level of establishing, identifying, and
    isolating behaviors manifested within your application. As applications become
    more dynamic and distributed, developers often need to do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，调试代码只是确定、识别和隔离应用程序中显现行为的一种级别。随着应用程序变得更加动态和分布式，开发人员通常需要执行以下操作：
- en: Configure and reconfigure applications dynamically
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态配置和重新配置应用程序
- en: Determine/confirm current settings and their origins
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定/确认当前设置及其来源
- en: Inspect and monitor application environment and health indicators
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查和监控应用程序环境和健康指标
- en: Temporarily adjust logging levels of live apps to identify root causes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 临时调整活动应用程序的日志级别以识别根本原因
- en: This chapter demonstrates how to use Spring Boot’s built-in configuration capabilities,
    its Autoconfiguration Report, and Spring Boot Actuator to create, identify, and
    modify application environment settings flexibly and dynamically.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章演示如何利用 Spring Boot 的内置配置能力、其自动配置报告和 Spring Boot 执行器来灵活、动态地创建、识别和修改应用程序环境设置。
- en: Code Checkout Checkup
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码检出检查
- en: Please check out branch *chapter5begin* from the code repository to begin.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看代码仓库中的 *chapter5begin* 分支以开始。
- en: Application Configuration
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序配置
- en: No app is an island.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 没有应用程序是孤立的。
- en: 'Most times when I say that, it’s to point out the truism that in nearly every
    case, an application doesn’t provide all of its utility without interaction with
    other applications/services. But there is another meaning that is just as true:
    no application can be as useful without access to its environment, in one form
    or another. A static, unconfigurable app is rigid, inflexible, and hobbled.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当我说这句话时，大多数时候是为了指出这个真理：几乎在每种情况下，一个应用程序在没有与其他应用程序/服务的交互时不能提供其全部效用。但还有另一层意思同样正确：没有应用程序能够在没有以某种形式访问其环境的情况下如此有用。一个静态、不可配置的应用程序是僵化的、不灵活的和受限的。
- en: 'Spring Boot applications supply a variety of powerful mechanisms for developers
    to dynamically configure and reconfigure their applications, even while the app
    is running. These mechanisms leverage the Spring `Environment` to manage configuration
    properties from all sources, including the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot 应用程序为开发人员提供了多种强大的机制，可以在应用程序运行时动态配置和重新配置其应用程序。这些机制利用了 Spring `Environment`
    来管理来自所有来源的配置属性，包括以下内容：
- en: Spring Boot Developer Tools (devtools) global settings properties in the *$HOME/.config/spring-boot*
    directory when devtools is active.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当开发工具（devtools）处于活动状态时，Spring Boot 开发者工具（devtools）全局设置属性位于 *$HOME/.config/spring-boot*
    目录中。
- en: '`@TestPropertySource` annotations on tests.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试中的 `@TestPropertySource` 注解。
- en: '`properties` attribute on tests, available on `@SpringBootTest` and the various
    test annotations for testing an application slice.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试中的 `properties` 属性，可在 `@SpringBootTest` 和各种测试注解中用于测试应用程序片段。
- en: Command line arguments.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令行参数。
- en: Properties from `SPRING_APPLICATION_JSON` (inline JSON embedded in an environment
    variable or system property).
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自 `SPRING_APPLICATION_JSON`（嵌入在环境变量或系统属性中的内联 JSON）的属性。
- en: '`ServletConfig` init parameters.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ServletConfig` 初始化参数。'
- en: '`ServletContext` init parameters.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ServletContext` 初始化参数。'
- en: JNDI attributes from *java:comp/env*.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自 *java:comp/env* 的 JNDI 属性。
- en: Java System properties (`System.getProperties()`).
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 系统属性（`System.getProperties()`）。
- en: OS environment variables.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统环境变量。
- en: A `RandomValuePropertySource` that has properties only in `random.*`.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅包含 `random.*` 属性的 `RandomValuePropertySource`。
- en: Profile-specific application properties outside of the packaged jar (*application-{profile}.properties*
    and YAML variants).
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打包在 jar 外的特定配置文件的应用程序属性（*application-{profile}.properties* 和 YAML 变体）。
- en: Profile-specific application properties packaged inside the jar (*application-{profile}.properties*
    and YAML variants).
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打包在 jar 中的特定配置文件的应用程序属性（*application-{profile}.properties* 和 YAML 变体）。
- en: Application properties outside of the packaged jar (*application.properties*
    and YAML variants).
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打包在 jar 外的应用程序属性（*application.properties* 和 YAML 变体）。
- en: Application properties packaged inside the jar (*application.properties* and
    YAML variants).
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打包在 jar 中的应用程序属性（*application.properties* 和 YAML 变体）。
- en: '`@PropertySource` annotations on `@Configuration` classes; note that such property
    sources are not added to the Environment until the application context is refreshed,
    which is too late to configure certain properties read before refresh begins,
    such as `logging.*` and `spring.main.*`.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@PropertySource` 注解用于 `@Configuration` 类；请注意，这些属性源在应用程序上下文刷新之前不会添加到 `Environment`
    中，这对于在刷新开始之前读取的某些属性（例如 `logging.*` 和 `spring.main.*`）进行配置来说为时已晚。'
- en: 'Default properties specified by setting `SpringApplication.setDefaultProperties`.
    NOTE: The preceding property sources are listed in decreasing order of precedence:
    properties from sources higher in the list supersede identical properties from
    lower sources.^([1](ch05.xhtml#idm45693962724088))'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过设置 `SpringApplication.setDefaultProperties` 指定的默认属性。注意：前述属性源按优先级降序列出：来自列表更高位置的属性将替换来自列表较低位置的相同属性。^([1](ch05.xhtml#idm45693962724088))
- en: 'All of these can be extremely useful, but I’ll choose a few in particular for
    the code scenarios in this chapter:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都可能非常有用，但在本章的代码场景中，我特别选择了其中几个：
- en: Command line arguments
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令行参数
- en: OS environment variables
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统环境变量
- en: Application properties packaged inside the jar (*application.properties* and
    YAML variants)
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打包在 jar 内的应用程序属性（*application.properties* 和 YAML 变体）。
- en: Let’s begin with properties defined in the app’s *application.properties* file
    and work our way up the food chain.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从应用程序的 *application.properties* 文件中定义的属性开始，并逐步深入了解。
- en: '@Value'
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`@Value`'
- en: The `@Value` annotation is perhaps the most straightforward approach to ingesting
    configuration settings into your code. Built around pattern-matching and the Spring
    Expression Language (SpEL), it’s simple and powerful.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Value` 注解可能是将配置设置引入代码中最直接的方法。围绕模式匹配和Spring表达语言（SpEL）构建，它简单而强大。'
- en: I’ll start by defining a single property in our application’s *application.properties*
    file, as shown in [Figure 5-1](#defining_greetingname_in_application_properties).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从我们应用程序的 *application.properties* 文件中定义一个属性开始，如 [图 5-1](#在_application_properties_中定义_greetingname)
    所示。
- en: '![sbur 0501](Images/sbur_0501.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![sbur 0501](Images/sbur_0501.png)'
- en: Figure 5-1\. Defining `greeting-name` in application.properties
  id: totrans-41
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-1\. 在 application.properties 中定义 `greeting-name`
- en: To show how to put this property to use, I create an additional `@RestController`
    within the application to handle tasks related to greeting application users,
    as demonstrated in [Figure 5-2](#greetings_restcontroller_class).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示如何使用这个属性，我在应用程序中创建了一个额外的 `@RestController` 来处理与问候应用程序用户相关的任务，如 [图 5-2](#greetings_restcontroller_class)
    所示。
- en: '![sbur 0502](Images/sbur_0502.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![sbur 0502](Images/sbur_0502.png)'
- en: Figure 5-2\. Greeting `@RestController` class
  id: totrans-44
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-2\. 问候 `@RestController` 类
- en: 'Note that the `@Value` annotation applies to the `name` member variable and
    accepts a single parameter of type `String` called `value`. I define the `value`
    using SpEL, placing the variable name (as the expression to evaluate) between
    the delimiters `${` and `}`. One other thing of note: SpEL allows for a default
    value after the colon—in this example, “Mirage”—for cases in which the variable
    isn’t defined in the app `Environment`.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`@Value` 注解适用于 `name` 成员变量，并接受类型为 `String` 的单个名为 `value` 的参数。我使用 SpEL 定义
    `value`，将变量名（作为要评估的表达式）放置在 `${` 和 `}` 之间的定界符中。还有一件事需要注意：在这个示例中，SpEL 允许在冒号后设置默认值——“Mirage”，用于在应用程序
    `Environment` 中未定义变量的情况。
- en: Upon executing the application and querying the */greeting* endpoint, the app
    responds with “Dakota” as expected, shown in [Figure 5-3](#greeting_response_with_defined_property_value).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行应用程序并查询 */greeting* 端点时，应用程序如预期地响应“Dakota”，如 [图 5-3](#greeting_response_with_defined_property_value)
    所示。
- en: '![sbur 0503](Images/sbur_0503.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![sbur 0503](Images/sbur_0503.png)'
- en: Figure 5-3\. Greeting response with defined property value
  id: totrans-48
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-3\. 具有定义属性值的问候响应
- en: 'To verify the default value is being evaluated, I comment out the following
    line in *application.properties* with a `#` as follows and restart the application:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证默认值正在被评估，我在 *application.properties* 中以 `#` 注释掉以下行，并重新启动应用程序：
- en: '[PRE0]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Querying the *greeting* endpoint now results in the response shown in [Figure 5-4](#greeting_repsonse_with_default_value).
    Since `greeting-name` is no longer defined in any source for the application’s
    `Environment`, the default value of “Mirage” kicks in, as expected.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 查询 *greeting* 端点现在返回 [Figure 5-4](#greeting_repsonse_with_default_value) 中所示的响应。由于应用程序的
    `Environment` 中不再定义 `greeting-name`，因此期望的默认值“Mirage”生效了。
- en: '![sbur 0504](Images/sbur_0504.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![sbur 0504](Images/sbur_0504.png)'
- en: Figure 5-4\. Greeting response with default value
  id: totrans-53
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figure 5-4\. 默认值问候响应
- en: 'Using `@Value` with roll-your-own properties provides another useful capability:
    the value of one property can be derived/built using the value of another.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自定义属性和 `@Value` 提供了另一个有用的功能：一个属性的值可以使用另一个属性的值进行推导/构建。
- en: To demonstrate how property nesting works, we’ll need at least two properties.
    I create a second property `greeting-coffee` in *application.properties*, as in
    [Figure 5-5](#property_value_feeding_another_property).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示属性嵌套的工作原理，我们至少需要两个属性。我在 *application.properties* 中创建了第二个属性 `greeting-coffee`，如
    [Figure 5-5](#property_value_feeding_another_property) 所示。
- en: '![sbur 0505](Images/sbur_0505.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![sbur 0505](Images/sbur_0505.png)'
- en: Figure 5-5\. Property value feeding another property
  id: totrans-57
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figure 5-5\. 属性值传递给另一个属性
- en: Next, I add a bit of code to our `GreetingController` to represent a coffee-fied
    greeting and an endpoint we can access to see the results. Note that I provide
    a default value for `coffee`’s value as well, per [Figure 5-6](#adding_a_coffee_greeting_to_greetingcontroller).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我向我们的 `GreetingController` 添加了一些代码，以表示一个带有咖啡的问候和我们可以访问以查看结果的端点。请注意，我还为 `coffee`
    的值提供了一个默认值，如 [Figure 5-6](#adding_a_coffee_greeting_to_greetingcontroller) 所示。
- en: '![sbur 0506](Images/sbur_0506.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![sbur 0506](Images/sbur_0506.png)'
- en: Figure 5-6\. Adding a coffee greeting to `GreetingController`
  id: totrans-60
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figure 5-6\. 向 `GreetingController` 添加咖啡问候
- en: To verify the proper outcome, I restart the application and query the new */greeting/coffee*
    endpoint, resulting in the output shown in [Figure 5-7](#querying_the_coffee_greeting_endpoint).
    Note that since both properties in question are defined in *application.properties*,
    the values displayed are consistent with those values’ definitions.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证正确的结果，我重新启动应用程序并查询新的 */greeting/coffee* 端点，结果显示在 [Figure 5-7](#querying_the_coffee_greeting_endpoint)
    中。请注意，由于问题中的两个属性都在 *application.properties* 中定义，因此显示的值与这些值的定义一致。
- en: '![sbur 0507](Images/sbur_0507.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![sbur 0507](Images/sbur_0507.png)'
- en: Figure 5-7\. Querying the coffee greeting endpoint
  id: totrans-63
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figure 5-7\. 查询咖啡问候端点
- en: 'As with all things in life and software development, `@Value` does have some
    limitations. Since we provided a default value for the `greeting-coffee` property,
    we can comment out its definition in *application.properties*, and the `@Value`
    annotation still properly processes its (default) value using the `coffee` member
    variable within `GreetingController`. However, commenting out both `greeting-name`
    and `greeting-coffee` in the properties file results in no `Environment` source
    actually defining them, further resulting in the following error when the application
    attempts to initialize the `GreetingController` bean using a reference to (now-undefined)
    `greeting-name` within `greeting-coffee`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 就像生活和软件开发中的所有事物一样，`@Value` 确实有一些限制。由于我们为 `greeting-coffee` 属性提供了一个默认值，我们可以将其在
    *application.properties* 中的定义注释掉，`@Value` 注解仍然会使用 `GreetingController` 中的 `coffee`
    成员变量正确处理其（默认）值。但是，如果在属性文件中注释掉 `greeting-name` 和 `greeting-coffee` 两者，那么实际上没有任何
    `Environment` 源定义它们，进而在应用程序尝试使用 `GreetingController` 中的 (现在未定义的) `greeting-name`
    引用 `greeting-coffee` 时会导致以下错误：
- en: '[PRE1]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-66
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Full stacktrace removed for brevity and clarity.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的堆栈跟踪已删除以提高简洁性和清晰性。
- en: 'Another limitation with properties defined in *application.properties* and
    used solely via `@Value`: they aren’t recognized by the IDE as being used by the
    application, as they’re only referenced in the code within quote-delimited `String`
    variables; as such, there is no direct tie-in to code. Of course, developers can
    visually check for correct spelling of property names and usage, but this is entirely
    manual and thus more prone to error.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个 *application.properties* 中定义的属性并且仅通过 `@Value` 使用的限制是：它们不被 IDE 认为是应用程序使用的，因为它们只在引号限定的
    `String` 变量中的代码中被引用；因此，与代码没有直接的关联。当然，开发人员可以通过目视检查属性名称和用法的正确拼写，但这完全是手动操作，因此更容易出错。
- en: As you might imagine, a typesafe and tool-verifiable mechanism for property
    use and definition would be a better all-around option.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所想象的那样，一种类型安全且可验证的属性使用和定义机制将是更好的全面选择。
- en: '@ConfigurationProperties'
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '@ConfigurationProperties'
- en: Appreciating the flexibility of `@Value` but recognizing its shortcomings, the
    Spring team created `@ConfigurationProperties`. Using `@ConfigurationProperties`,
    a developer can define properties, group related properties, and reference/use
    them in a tool-verifiable and typesafe way.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 欣赏`@Value`的灵活性，但也意识到其局限性，Spring团队创建了`@ConfigurationProperties`。使用`@ConfigurationProperties`，开发者可以定义属性，将相关属性分组，并以可验证和类型安全的方式引用/使用它们。
- en: For example, if a property is defined in an app’s *application.properties* file
    that isn’t used in code, the developer will see the name highlighted to flag it
    as a confirmed unused property. Similarly, if the property is defined as a `String`
    but associated with a differently typed member variable, the IDE will point out
    the type mismatch. These are valuable helps that catch simple, but frequent, mistakes.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果在应用的*application.properties*文件中定义了一个未在代码中使用的属性，开发者将看到其名称被突出显示，以标识其为确认的未使用属性。同样地，如果属性定义为`String`，但与不同类型的成员变量相关联，IDE将指出类型不匹配。这些都是捕捉简单但频繁错误的宝贵帮助。
- en: 'To demonstrate how to put `@ConfigurationProperties` to work, I’ll start by
    defining a POJO to encapsulate the desired related properties: in this case, our
    `greeting-name` and `greeting-coffee` properties previously referenced. As shown
    in the code that follows, I create a `Greeting` class to hold both:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何使用`@ConfigurationProperties`，我将从定义一个POJO开始，用于封装所需的相关属性：在这种情况下，我们先前引用的`greeting-name`和`greeting-coffee`属性。如下所示的代码中，我创建了一个`Greeting`类来保存这两个属性：
- en: '[PRE2]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In order to register `Greeting` to manage configuration properties, I add the
    `@ConfigurationProperties` annotation shown in [Figure 5-8](#annotation_and_error)
    and specify the `prefix` to use for all `Greeting` properties. This annotation
    prepares the class for use only with configuration properties; the application
    also must be told to process classes annotated in such manner for properties to
    include in the application `Environment`. Note the helpful error message that
    results:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了注册`Greeting`以管理配置属性，我添加了如下所示的`@ConfigurationProperties`注解，并指定了用于所有`Greeting`属性的前缀。此注解仅为使用配置属性准备该类；还必须告知应用程序处理这种方式注释的类，以便包含在应用程序`Environment`中的属性。请注意产生的有用错误消息：
- en: '![sbur 0508](Images/sbur_0508.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![sbur 0508](Images/sbur_0508.png)'
- en: Figure 5-8\. Annotation and error
  id: totrans-77
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-8\. 注解和错误
- en: 'Instructing the application to process `@ConfigurationProperties` classes and
    add their properties to the app’s `Environment` is, in most cases, best accomplished
    by adding the `@ConfigurationPropertiesScan` annotation to the main application
    class, as demonstrated here:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，指示应用处理`@ConfigurationProperties`类并将其属性添加到应用的`Environment`中最好的方法是将`@ConfigurationPropertiesScan`注解添加到主应用类中，如下所示：
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-80
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The exceptions to the rule of having Boot scan for `@ConfigurationProperties`
    classes are if you need to enable certain `@ConfigurationProperties` classes conditionally
    or if you are creating your own autoconfiguration. In all other cases, however,
    `@ConfigurationPropertiesScan` should be used to scan for and enable `@ConfigurationProperties`
    classes in like manner to Boot’s component scanning mechanism.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 除了要求Boot扫描`@ConfigurationProperties`类之外的例外情况是，如果需要有条件地启用某些`@ConfigurationProperties`类或者正在创建自己的自动配置。然而，在所有其他情况下，应使用`@ConfigurationPropertiesScan`来扫描和启用类似于Boot组件扫描机制中的`@ConfigurationProperties`类。
- en: 'In order to generate metadata using the annotation processor, enabling the
    IDE to connect the dots between `@ConfigurationProperties` classes and related
    properties defined in the *application.properties* file, I add the following dependency
    to the project’s *pom.xml* build file:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用注解处理器生成元数据，使IDE能够连接`@ConfigurationProperties`类和*application.properties*文件中定义的相关属性之间的关联，我将以下依赖项添加到项目的*pom.xml*构建文件中：
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-84
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This dependency also can be selected and added automatically from the Spring
    Initializr at the time of project creation.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个依赖项也可以在项目创建时从Spring Initializr自动选择并添加。
- en: Once the configuration processor dependency is added to the build file, it’s
    necessary to refresh/reimport the dependencies and rebuild the project to take
    advantage of them. To reimport deps, I open the Maven menu in IntelliJ and click
    the Reimport button at the top left, as shown in [Figure 5-9](#reimporting_project_dependencies).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将配置处理器依赖项添加到构建文件中，就需要刷新/重新导入依赖项并重新构建项目以充分利用它们。要重新导入依赖项，我在 IntelliJ 中打开 Maven
    菜单，并点击左上角的重新导入按钮，如 [图 5-9](#reimporting_project_dependencies) 所示。
- en: '![sbur 0509](Images/sbur_0509.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![sbur 0509](Images/sbur_0509.png)'
- en: Figure 5-9\. Reimporting project dependencies
  id: totrans-88
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-9\. 重新导入项目依赖
- en: Note
  id: totrans-89
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Unless the option is disabled, IntelliJ also presents a small button over the
    changed *pom.xml* to allow for a quick reimport without needing to open the Maven
    menu. The overlaid reimport button, a small *m* with a circular arrow on its bottom
    left portion, can be seen in [Figure 5-9](#reimporting_project_dependencies) hovering
    over the first dependency’s `<groupid>` entry; it disappears when reimport is
    complete.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 除非选项被禁用，IntelliJ 也会在更改的 *pom.xml* 上方显示一个小按钮，允许快速重新导入，而无需打开 Maven 菜单。重导入按钮位于其底部左侧带有圆形箭头的小
    *m*，悬停在第一个依赖项的 `<groupid>` 条目上时可见；当重新导入完成时，它会消失。
- en: Once dependencies are updated, I rebuild the project from the IDE to incorporate
    the configuration processor.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦更新了依赖项，我从 IDE 中重新构建项目以整合配置处理器。
- en: Now, to define some values for these properties. Returning to *application.properties*,
    when I begin typing `greeting`, the IDE helpfully shows property names that match,
    as demonstrated in [Figure 5-10](#full_ide_property_support_for_configurationproperties).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要为这些属性定义一些值。返回到 *application.properties*，当我开始输入 `greeting` 时，IDE 会显示匹配的属性名，如
    [图 5-10](#full_ide_property_support_for_configurationproperties) 所示。
- en: '![sbur 0510](Images/sbur_0510.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![sbur 0510](Images/sbur_0510.png)'
- en: Figure 5-10\. Full IDE property support for `@ConfigurationProperties`
  id: totrans-94
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-10\. `@ConfigurationProperties` 的完整 IDE 属性支持
- en: To use these properties instead of the ones we were using before, a bit of refactoring
    is required.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这些属性替代之前使用的属性，需要进行一些重构。
- en: 'I can do away entirely with `GreetingController`’s own member variables `name`
    and `coffee` along with their `@Value` annotations; instead, I create a member
    variable for the `Greeting` bean that now manages `greeting.name` and `greeting.coffee`
    properties and inject it into `GreetingController` via constructor injection,
    as shown in the following code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以完全放弃 `GreetingController` 自己的成员变量 `name` 和 `coffee` 以及它们的 `@Value` 注解；相反，我创建了一个成员变量用于管理
    `Greeting` bean 现在管理的 `greeting.name` 和 `greeting.coffee` 属性，并通过构造函数注入到 `GreetingController`
    中，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Running the application and querying the *greeting* and *greeting/coffee* endpoints
    results in the outcomes captured in [Figure 5-11](#retrieving_greeting_properties).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序并查询 *greeting* 和 *greeting/coffee* 端点会得到 [图 5-11](#retrieving_greeting_properties)
    中捕获的结果。
- en: '![sbur 0511](Images/sbur_0511.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![sbur 0511](Images/sbur_0511.png)'
- en: Figure 5-11\. Retrieving `Greeting` properties
  id: totrans-100
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-11\. 检索 `Greeting` 属性
- en: Properties managed by an `@ConfigurationProperties` bean still obtain their
    values from the `Environment` and all of its potential sources; the only significant
    thing missing in comparison to `@Value`-based properties is the ability to specify
    a default value at the annotated member variable. That is less of a sacrifice
    than it might appear to be at first glance because the app’s *application.properties*
    file typically serves as the place for defining sensible defaults for an application.
    If there is a need for different property values to accommodate different deployment
    environments, those environment-specific values are ingested into the application’s
    `Environment` via other sources, e.g., environment variables or command line parameters.
    In short, `@ConfigurationProperties` simply enforces the better practice for default
    property values.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 由 `@ConfigurationProperties` bean 管理的属性仍然从 `Environment` 及其所有潜在来源中获取其值；与基于 `@Value`
    的属性相比，唯一显著缺失的是在注解成员变量中指定默认值的能力。乍看起来可能不太理想，但这并不是问题，因为应用程序的 *application.properties*
    文件通常用于定义应用程序的合理默认值。如果需要不同的属性值以适应不同的部署环境，这些环境特定的值通过其他来源，例如环境变量或命令行参数，被摄入到应用程序的
    `Environment` 中。简而言之，`@ConfigurationProperties` 简单地强制执行了更好的默认属性值的实践。
- en: Potential Third-Party Option
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 潜在的第三方选项
- en: A further extension to the already impressive usefulness of `@ConfigurationProperties`
    is the ability to wrap third-party components and incorporate their properties
    into the application’s `Environment`. To demonstrate how, I create a POJO to simulate
    a component that might be incorporated into the application. Note that in typical
    use cases where this feature is handiest, one would add an external dependency
    to the project and consult the component’s documentation to determine the class
    from which to create a Spring bean, rather than creating one by hand as I do here.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`@ConfigurationProperties`已经令人印象深刻的实用性的进一步扩展，是能够包装第三方组件并将它们的属性合并到应用的`Environment`中。为了演示这一点，我创建了一个POJO来模拟一个可能被整合到应用中的组件。请注意，在典型的使用案例中，当这个特性最有用时，我们会向项目添加一个外部依赖，并参考组件的文档来确定创建Spring
    bean的类，而不像我在这里手动创建。
- en: 'In the code listing that follows, I create the simulated third-party component
    called `Droid` with two properties—`id` and `description`—and their associated
    accessor and mutator methods:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的代码清单中，我创建了一个模拟的第三方组件称为`Droid`，具有两个属性——`id`和`description`——及其关联的访问器和修改器方法：
- en: '[PRE6]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The next step falls into place the same way a true third-party component would:
    instantiating the component as a Spring bean. Spring beans can be created from
    defined POJOs in several ways, but the one most appropriate to this particular
    use case is to create an `@Bean`-annotated method within a class annotated with
    `@Configuration`, either directly or via a meta-annotation.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步的操作与真实的第三方组件完全相同：将组件实例化为Spring bean。可以通过几种方式从定义的POJO创建Spring bean，但对于这个特定的用例来说，最合适的方法是在带有`@Configuration`注解的类中创建一个`@Bean`注解的方法，无论是直接还是通过元注解。
- en: One meta-annotation that incorporates `@Configuration` within its definition
    is `@SpringBootApplication`, which is found on the main application class. That’s
    why developers often place bean creation methods there.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一个将`@Configuration`包含在其定义中的元注解是`@SpringBootApplication`，它位于主应用程序类上。这就是为什么开发人员经常将bean创建方法放在这里的原因。
- en: Note
  id: totrans-108
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Within IntelliJ and most other IDEs and advanced text editors with solid Spring
    support, it’s possible to drill into Spring meta-annotations to explore the annotations
    nested within. In IntelliJ, Cmd+LeftMouseClick (on MacOS) will expand the annotation.
    `@SpringBootApplication` includes `@SpringBootConfiguration`, which includes `@Configuration`,
    making only two degrees of separation from Kevin Bacon.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在IntelliJ和大多数其他具有良好Spring支持的IDE和高级文本编辑器中，可以深入探索Spring元注解来探索嵌套的注解。在IntelliJ中，Cmd+LeftMouseClick（在MacOS上）将展开注解。`@SpringBootApplication`包含`@SpringBootConfiguration`，它包含`@Configuration`，使得与凯文·贝肯（Kevin
    Bacon）仅有两度分离。
- en: 'In the following code listing I demonstrate the bean creation method and the
    requisite `@ConfigurationProperties` annotation and `prefix` parameter, indicating
    that `Droid` properties should be incorporated within the `Environment` under
    the top-level property grouping `droid`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的代码清单中，我演示了bean创建方法以及必需的`@ConfigurationProperties`注解和`prefix`参数，指示应将`Droid`属性合并到`Environment`中的顶层属性组`droid`中：
- en: '[PRE7]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As before, it is necessary to rebuild the project for the configuration processor
    to detect the properties exposed by this new source of configuration properties.
    After executing a build, we can return to *application.properties* and see that
    both `droid` properties have now surfaced complete with type information, as per
    [Figure 5-12](#droid_properties_and_type_information_now_visible_in_application_properties).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 正如以往一样，需要重新构建项目以便配置处理器检测到此新配置属性源暴露的属性。执行构建后，我们可以返回到*application.properties*，看到`droid`属性现在完整地展现出来，包括类型信息，如[图 5-12](#droid_properties_and_type_information_now_visible_in_application_properties)所示。
- en: '![sbur 0512](Images/sbur_0512.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![sbur 0512](Images/sbur_0512.png)'
- en: Figure 5-12\. `droid` properties and type information now visible in *application.properties*
  id: totrans-114
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-12\. `droid`属性和类型信息现在在*application.properties*中可见
- en: I assign some default values to `droid.id` and `droid.description` for use as
    defaults, as shown in [Figure 5-13](#droid_properties_with_default_values_assigned_in_application_properties).
    This is a good habit to adopt for all `Environment` properties, even those obtained
    from third parties.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我为`droid.id`和`droid.description`分配了一些默认值，用作默认值，如[图 5-13](#droid_properties_with_default_values_assigned_in_application_properties)所示。对于所有的`Environment`属性来说，这是一个养成的好习惯，即使是从第三方获取的属性也不例外。
- en: '![sbur 0513](Images/sbur_0513.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![sbur 0513](Images/sbur_0513.png)'
- en: Figure 5-13\. `droid` properties with default values assigned in *application.properties*
  id: totrans-117
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-13。在 *application.properties* 中分配了默认值的 `droid` 属性
- en: 'In order to verify that everything works as expected with the `Droid`’s properties,
    I create a very simple `@RestController` with a single `@GetMapping` method, as
    shown in the code that follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证一切是否按预期运行与 `Droid` 属性，我创建了一个非常简单的 `@RestController`，其中包含一个单独的 `@GetMapping`
    方法，如下所示的代码：
- en: '[PRE8]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: After building and running the project, I query the new */droid* endpoint and
    confirm the appropriate response, as indicated in [Figure 5-14](#querying_the_droid_endpoint_to_retrieve_properties_from_the_droid).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行项目后，我查询新的 */droid* 端点，并确认适当的响应，如 [图 5-14](#querying_the_droid_endpoint_to_retrieve_properties_from_the_droid)
    中所示。
- en: '![sbur 0514](Images/sbur_0514.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![sbur 0514](Images/sbur_0514.png)'
- en: Figure 5-14\. Querying the */droid* endpoint to retrieve properties from the
    Droid
  id: totrans-122
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-14。查询 */droid* 端点以检索来自 Droid 的属性
- en: Autoconfiguration Report
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动配置报告
- en: 'As mentioned previously, Boot does a *lot* on behalf of developers via autoconfiguration:
    setting up the application with the beans it needs to fulfill the functionalities
    that are part and parcel to chosen capabilities, dependencies, and code. Also
    mentioned earlier is the ability to override any bit of autoconfiguration necessary
    to implement functionality in a more specific (to your use case) manner. But how
    can one see what beans are created, what beans aren’t created, and what conditions
    prompted either outcome?'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Boot 通过自动配置为开发人员执行了大量操作：使用所选功能、依赖项和代码来设置应用程序所需的 bean，从而实现所选功能和代码。还提到了根据用例更具体（符合您的用例）地实现功能所需的任何自动配置的能力。但是，如何查看创建了哪些
    bean、未创建哪些 bean，以及是什么条件促使了其中任一结果呢？
- en: 'It’s a simple matter to produce the autoconfiguration report using the `debug`
    flag in one of several ways, owing to the flexibility of the JVM:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 JVM 的灵活性，通过在几种方式之一中使用 `debug` 标志，可以很容易地生成自动配置报告：
- en: 'Executing the application’s jar file with the `--debug` option: `java -jar
    bootapplication.jar --debug`'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `--debug` 选项执行应用程序的 jar 文件：`java -jar bootapplication.jar --debug`
- en: 'Executing the application’s jar file with a JVM parameter: `java -Ddebug=true`
    `-jar bootapplication.jar`'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JVM 参数执行应用程序的 jar 文件：`java -Ddebug=true` `-jar bootapplication.jar`
- en: Adding `debug=true` to your application’s *application.properties* file
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `debug=true` 添加到应用程序的 *application.properties* 文件
- en: Executing `export DEBUG=true` in your shell (Linux or Mac) or adding it to your
    Windows environment, then running `java -jar bootapplication.jar`
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的 shell（Linux 或 Mac）中执行 `export DEBUG=true` 或将其添加到 Windows 环境中，然后运行 `java
    -jar bootapplication.jar`
- en: Note
  id: totrans-130
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: Any way to add an affirmative value for `debug` to the application’s `Environment`,
    as discussed earlier, will provide the same results. These are just more frequently
    used options.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 任何方式将肯定值添加到应用程序的 `Environment` 中，如前所述，都将提供相同的结果。这些只是更常用的选项。
- en: 'The autoconfiguration report’s section listing positive matches—those conditions
    that evaluated to true and caused an action to take place—are listed within a
    section headed by “Positive matches.” I’ve copied that section header here, along
    with one example of a positive match and its resultant autoconfiguration action:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 自动配置报告的部分列出了正匹配的条件——这些条件评估为真，并导致执行操作的条件——列在以“Positive matches”为标题的部分中。我在这里复制了该部分标题，以及一个正匹配及其相应的自动配置操作的示例：
- en: '[PRE9]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This particular match demonstrates what we expected to happen, although it’s
    always good to confirm the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这种匹配符合我们的预期，尽管确认以下内容总是好的：
- en: JPA and H2 are application dependencies.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JPA 和 H2 是应用程序依赖项。
- en: JPA works with SQL datasources.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JPA 与 SQL 数据源一起使用。
- en: H2 is an embedded database.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: H2 是一个嵌入式数据库。
- en: Classes were found that support embedded SQL datasources.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到支持嵌入式 SQL 数据源的类。
- en: As a result, `DataSourceAutoConfiguration` is invoked.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，调用了 `DataSourceAutoConfiguration`。
- en: 'Similarly, the “Negative matches” section displays actions not taken by Spring
    Boot’s autoconfiguration and why, as illustrated in the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，"Negative matches" 部分显示了 Spring Boot 自动配置未执行的操作以及原因，如下所示：
- en: '[PRE10]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this case, `ActiveMQAutoConfiguration` was not performed because the application
    didn’t find the JMS `ConnectionFactory` class upon startup.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，未执行 `ActiveMQAutoConfiguration`，因为应用程序在启动时未找到 JMS `ConnectionFactory`
    类。
- en: 'Another useful tidbit is the section listing “Unconditional classes,” which
    are created without having to satisfy any conditions. I’ve listed one next that
    is of particular interest given the previous section:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的信息片段是列出“无条件类”的部分，这些类无需满足任何条件即可创建。鉴于前一节，我列出了一个特别感兴趣的类：
- en: '[PRE11]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, `ConfigurationPropertiesAutoConfiguration` is always instantiated
    to manage any `ConfigurationProperties` created and referenced within a Spring
    Boot application; it’s integral to every Spring Boot app.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，`ConfigurationPropertiesAutoConfiguration`始终被实例化，以管理Spring Boot应用程序中创建和引用的任何`ConfigurationProperties`；它是每个Spring
    Boot应用程序的一部分。
- en: Actuator
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行器
- en: actuator
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 执行器
- en: 'n. One that actuates specifically: a mechanical device for moving or controlling
    something'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: n. 特指：用于移动或控制某物的机械装置
- en: The original version of Spring Boot Actuator reached General Availability (GA)
    in 2014 and was hailed for providing valuable insights into production Boot applications.
    Providing monitoring and management capabilities of running apps via HTTP endpoints
    or Java Management Extensions (JMX), Actuator encompasses and exposes all of Spring
    Boot’s production-ready features.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot Actuator的原始版本于2014年达到了一般可用性（GA），因为它为生产中的Boot应用程序提供了宝贵的洞察。通过HTTP端点或Java管理扩展（JMX）提供正在运行的应用程序的监控和管理功能，Actuator涵盖并公开了Spring
    Boot的所有生产准备功能。
- en: Completely retooled with the 2.0 version of Spring Boot, Actuator now leverages
    the Micrometer instrumentation library to provide metrics via a consistent façade
    from numerous leading monitoring systems, similar to how SLF4J operates with regard
    to various logging mechanisms. This dramatically extends the scope of things that
    can be integrated, monitored, and exposed via Actuator within any given Spring
    Boot application.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Spring Boot 2.0版本的彻底改造，Actuator现在利用Micrometer仪表化库提供度量标准，通过与多种主流监控系统的一致外观类似于SLF4J处理各种日志机制，大大扩展了可以在任何给定的Spring
    Boot应用程序中通过执行器集成、监控和公开的范围。
- en: 'To get started with Actuator, I add another dependency to the current project’s
    `pom.xml` dependencies section. As shown in the following snippet, the `spring-boot-starter-actuator`
    dependency provides the necessary capabilities; to do so, it brings with it both
    Actuator itself and Micrometer, along with autoconfiguration capabilities to slide
    into place within a Spring Boot application with nearly zero effort:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用执行器，我将在当前项目的`pom.xml`依赖项部分中添加另一个依赖项。如下片段所示，`spring-boot-starter-actuator`依赖项提供了必要的功能；为此，它将Actuator本身和Micrometer一起带到Spring
    Boot应用程序中，并具备几乎零配置的自动配置能力：
- en: '[PRE12]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: After refreshing/reimporting dependencies once more, I rerun the application.
    With the application running, we can see what information Actuator exposes by
    default by accessing its primary endpoint. Again, I use HTTPie to accomplish this,
    as per [Figure 5-15](#accessing_actuator_endpoint_default_configuration).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新/重新导入依赖后，我再次运行应用程序。应用程序运行时，通过访问其主要端点，我们可以查看执行器默认公开的信息。再次使用HTTPie完成此操作，如[图 5-15](#accessing_actuator_endpoint_default_configuration)所示。
- en: '![sbur 0515](Images/sbur_0515.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![sbur 0515](Images/sbur_0515.png)'
- en: Figure 5-15\. Accessing Actuator endpoint, default configuration
  id: totrans-155
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-15\. 访问执行器端点，默认配置
- en: Note
  id: totrans-156
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: All Actuator information is grouped together under the app’s */actuator* endpoint
    by default, but this too is configurable.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 执行器的所有信息默认情况下都集中在应用程序的*/actuator*端点下，但这也是可配置的。
- en: This doesn’t seem like much information for the fanfare (and fanbase) that Actuator
    has created. But this terseness is intentional.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎并不像执行器所创造的那么热闹（和粉丝基地）。但这种简洁是有意的。
- en: Actuator has access to and can expose a great deal of information about running
    applications. This information can be incredibly useful to developers, operational
    personnel, and also nefarious individuals who might desire to threaten your application’s
    security. Following Spring Security’s de facto goal of *secure by default*, Actuator’s
    autoconfiguration exposes very limited *health* and *info* responses—in fact,
    *info* defaults to an empty set—that provide an application heartbeat and little
    else out of the box (OOTB).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 执行器可以访问并公开有关正在运行的应用程序的大量信息。此信息对开发人员、运营人员以及可能希望威胁您应用程序安全性的不良个人尤为有用。遵循Spring Security的默认安全目标，执行器的自动配置仅公开非常有限的*health*和*info*响应——事实上，*info*默认为空集，提供应用程序心跳和其他少量信息（OOTB）。
- en: As with most things Spring, you can create some pretty sophisticated mechanisms
    for controlling access to various Actuator data feeds, but there are fast, consistent,
    and low-friction options available as well. Let’s take a look at those now.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数 Spring 的事物一样，您可以创建一些非常复杂的机制来控制对各种 Actuator 数据源的访问，但也有一些快速、一致和低摩擦的选项可用。
    现在让我们来看看这些。
- en: 'It’s possible to easily configure Actuator via properties with either a set
    of included endpoints or a set of excluded endpoints. For simplicity’s sake, I
    choose the inclusion route, adding the following to *application.properties*:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过属性轻松配置 Actuator，要么使用一组包含的端点，要么使用一组排除的端点。 为了简单起见，我选择了包含路线下内容添加到 *application.properties*
    中：
- en: '[PRE13]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this example, I direct the app (and Actuator) to expose only the */actuator/env*,
    */actuator/info*, and */actuator/health* endpoints (and any subordinate endpoints).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我指示应用程序（和 Actuator）仅暴露*/actuator/env*、*/actuator/info*和*/actuator/health*端点（和任何下级端点）。
- en: '[Figure 5-16](#accessing_the_actuator_after_specifying_endpoints_to_include)
    confirms the expected outcome upon rerunning the application and querying its
    */actuator* endpoint.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-16](#accessing_the_actuator_after_specifying_endpoints_to_include) 在重新运行应用程序并查询其*/actuator*端点后确认了预期结果。'
- en: 'In order to fully demonstrate Actuator’s OOTB capabilities, I can go a step
    further and disable security entirely *for demonstration purposes only* by using
    a wildcard with the aforementioned *application.properties* setting:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分展示 Actuator 的 OOTB 能力，我可以进一步禁用安全性，*仅用于演示目的*，通过使用前述的*application.properties*
    设置的通配符：
- en: '[PRE14]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Warning
  id: totrans-167
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: 'This point is impossible to overstate: security mechanisms for sensitive data
    should be disabled only for demonstration or verification purposes. *NEVER DISABLE
    SECURITY FOR PRODUCTION APPLICATIONS*.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点不容忽视：对于敏感数据的安全机制应该仅在演示或验证目的下禁用。*永远不要为生产应用程序禁用安全性*。
- en: '![sbur 0516](Images/sbur_0516.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![sbur 0516](Images/sbur_0516.png)'
- en: Figure 5-16\. Accessing the Actuator after specifying endpoints to include
  id: totrans-170
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-16\. 在指定要包括的端点后访问 Actuator
- en: 'For verification when starting the application, Actuator dutifully reports
    the number of endpoints it is currently exposing and the root path to reach them—in
    this case, the default of */actuator*—as shown in the startup report fragment
    that follows. This is a useful reminder/warning to provide a quick visual check
    that no more endpoints are being exposed than desired before advancing the application
    to a target deployment:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 启动应用程序时进行验证，Actuator 忠实地报告了它当前正在暴露的端点数量和到达它们的根路径——在这种情况下，默认为*/actuator*——如下所示的启动报告片段。
    这是一个有用的提醒/警告，可以快速进行视觉检查，以确保在将应用程序推进到目标部署之前不会暴露更多端点：
- en: '[PRE15]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To examine all mappings currently accessible via Actuator, simply query the
    provided Actuator root path to retrieve a full listing:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查通过 Actuator 当前可访问的所有映射，只需查询提供的 Actuator 根路径以检索完整列表：
- en: '[PRE16]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The listing of Actuator endpoints provides a good idea of the scope of information
    captured and exposed for examination, but of particular usefulness to actors good
    and bad are the following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Actuator 端点列表提供了捕获和暴露供检查的信息范围的良好概念，但对于好的和坏的行为者特别有用的是以下内容：
- en: '*/actuator/beans*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*/actuator/beans*'
- en: All Spring beans created by the application
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序创建的所有 Spring bean
- en: '*/actuator/conditions*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*/   */actuator/conditions*'
- en: Conditions met (or not) to create Spring beans; similar to the Conditions Evaluation
    Report discussed previously
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 Spring bean 所需满足的条件（或不满足的条件）； 类似于之前讨论过的条件评估报告
- en: '*/actuator/configprops*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*/actuator/configprops*'
- en: All `Environment` properties accessible by the application
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可访问的所有`Environment` 属性
- en: '*/actuator/env*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*/actuator/env*'
- en: Myriad aspects of the environment in which the application is operating; especially
    useful to see where each individual `configprop` value originates
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序正在运行的环境的种种方面； 特别有用的是看到每个个体`configprop` 值的来源
- en: '*/actuator/health*'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*/actuator/health*'
- en: Health info (basic or expanded, depending on settings)
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 健康信息（基本或扩展，取决于设置）
- en: '*/actuator/heapdump*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*/actuator/heapdump*'
- en: Initiates heap dump for troubleshooting and/or analysis
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 启动堆转储以进行故障排除和/或分析
- en: '*/actuator/loggers*'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*/actuator/loggers*'
- en: Logging levels for every component
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 每个组件的日志级别
- en: '*/actuator/mappings*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*/actuator/mappings*'
- en: All endpoint mappings and supporting details
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 所有端点映射和支持详细信息
- en: '*/actuator/metrics*'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*/actuator/metrics*'
- en: Metrics currently being captured by the application
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序当前正在捕获的指标
- en: '*/actuator/threaddump*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '*/actuator/threaddump*'
- en: Initiates thread dump for troubleshooting and/or analysis
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 启动线程转储以进行故障排除和/或分析
- en: These, and all of the remaining preconfigured Actuator endpoints, are handy
    when needed and easy to access for examination. Continuing to focus on the application’s
    environment, even among these endpoints there are firsts among peers.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这些，以及其余的预配置执行器端点，在需要时都非常方便，并且易于访问进行检查。继续专注于应用程序的环境，即使在这些端点之中也有同行中的先例。
- en: Getting Actuator to Open Up
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让执行器打开
- en: As mentioned, Actuator’s default security posture intentionally exposes only
    very limited *health* and *info* responses. In fact, the */actuator/health* endpoint
    provides a rather utilitarian “UP” or “DOWN” application status out of the box.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 正如提到的，执行器的默认安全姿态有意仅公开非常有限的*health*和*info*响应。实际上，*/actuator/health*端点提供了一个相当实用的应用程序状态“UP”或“DOWN”。
- en: 'With most applications, however, there are dependencies for which Actuator
    tracks health information; it simply doesn’t expose that additional information
    unless authorized to do so. To show expanded health information for preconfigured
    dependencies, I add the following property to *application.properties*:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序都有依赖关系，执行器会跟踪健康信息；除非获得授权，否则它不会公开其他信息。为了显示预配置依赖项的扩展健康信息，我将以下属性添加到*application.properties*中：
- en: '[PRE17]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-201
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'There are three possible values for the health indicator’s `show-details` property:
    `never` (default), `when_authorized`, and `always`. For this example, I choose
    `always` simply to demonstrate the possible, but for every application put into
    production, the correct choices would be either `never` or `when_authorized` in
    order to limit visibility to the application’s expanded health information.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 健康指标的`show-details`属性有三个可能的取值：`never`（默认值）、`when_authorized`和`always`。在这个例子中，我选择`always`仅仅是为了演示可能性，但对于每个投入生产的应用程序，正确的选择应该是要么`never`，要么`when_authorized`，以限制应用程序扩展的健康信息的可见性。
- en: Restarting the application results in the addition of health information for
    the application’s primary components to the overall application health summary
    when accessing the */actuator/health* endpoint, per [Figure 5-17](#expanded_health_information).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动应用程序会导致将应用程序的主要组件的健康信息添加到访问*/actuator/health*端点时的整体应用程序健康摘要中，参见[图 5-17](#expanded_health_information)。
- en: '![sbur 0517](Images/sbur_0517.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![sbur 0517](Images/sbur_0517.png)'
- en: Figure 5-17\. Expanded health information
  id: totrans-205
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-17\. 扩展健康信息
- en: Becoming More Environmentally Aware Using Actuator
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用执行器更环保意识
- en: One malady that often afflicts developers—present company included—is an assumption
    of complete knowledge of current application environment/state when behavior doesn’t
    match expectations. This isn’t entirely unexpected, especially if one wrote the
    anomalous code oneself. A relatively quick and invaluable first step is to *check
    all assumptions*. Do you *know* what that value is? Or are you just really certain
    you know?
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者经常会受到一种毛病的困扰——包括在内的现在这个公司——即当行为与预期不符时，完全了解当前应用程序环境/状态的假设。这并不完全出乎意料，尤其是如果是自己写的异常代码。一个相对快速且非常宝贵的第一步是*检查所有的假设*。你*知道*那个值是多少吗？还是你只是确信你知道？
- en: Have you checked?
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你有检查过吗？
- en: 'Especially in code in which outcomes are driven by inputs, this should be a
    required starting point. Actuator helps make this painless. Querying the application’s
    */actuator/env* endpoint returns all environmental information; following is the
    portion of that result that shows only the properties set in the application to
    this point:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是在输入驱动结果的代码中，这应该是一个必需的起点。执行器帮助使这一过程变得轻松。查询应用程序的*/actuator/env*端点返回所有环境信息；以下是该结果的部分，仅显示到目前为止在应用程序中设置的属性：
- en: '[PRE18]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Actuator shows not only the current value for each defined property but also
    its source, down to the line and column number where each value is defined. But
    what happens if one or more of those values is overridden by another source, e.g.,
    an external environment variable or command line argument when executing the application?
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 执行器不仅显示每个定义属性的当前值，还显示其来源，甚至显示定义每个值的行号和列号。但是，如果其中一个或多个值被另一个来源覆盖，例如在执行应用程序时由外部环境变量或命令行参数？
- en: 'To demonstrate a typical production-bound application scenario, I run `mvn
    clean package` from the application’s directory at the command line, then execute
    the app with the following command:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示一个典型的生产绑定应用程序场景，我从应用程序的目录中使用命令行运行`mvn clean package`，然后使用以下命令执行应用程序：
- en: '[PRE19]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Querying */actuator/env* once more, you can see that there is a new section
    for command line arguments with a single entry for `greeting.name`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 再次查询 */actuator/env*，您可以看到有一个新的命令行参数部分，其中只有一个条目`greeting.name`：
- en: '[PRE20]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Following the order of precedence for `Environment` inputs that was referenced
    earlier, command line arguments should override the value set from within *application.properties*.
    Querying the */greeting* endpoint returns “Sertanejo” as expected; querying */greeting/coffee*
    likewise results in the overridden value being incorporated into that response
    via the SpEL expression as well: `Sertanejo is drinking Cafe Cereza`.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循之前提到的`Environment`输入的优先顺序，命令行参数应该覆盖*application.properties*内部设置的值。查询 */greeting*
    端点返回预期的“Sertanejo”；同样，通过SpEL表达式查询 */greeting/coffee* 也将覆盖的值合并到响应中：`Sertanejo is
    drinking Cafe Cereza`。
- en: Trying to get to the bottom of errant, data-driven behavior just got a lot simpler
    thanks to Spring Boot Actuator.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Spring Boot Actuator，试图弄清楚错误的、数据驱动行为变得更加简单。
- en: Turning Up the Volume on Logging with Actuator
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Actuator增加日志记录的音量
- en: Like many other choices in developing and deploying software, choosing logging
    levels for production applications involves tradeoffs. Opting for more logging
    results in more system-level work and storage consumption and the capture of both
    more relevant and irrelevant data. This in turn can make it considerably more
    difficult to find an elusive issue.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 与开发和部署软件中的许多其他选择一样，为生产应用程序选择日志记录级别涉及权衡。选择更多日志记录会导致更多的系统级工作和存储消耗，以及捕获更多相关和不相关的数据。这反过来可能会使寻找难以捉摸的问题变得更加困难。
- en: As part of its mission of providing Boot’s production-ready features, Actuator
    addresses this as well, allowing developers to set a typical logging level like
    “INFO” for most or all components and change that level temporarily when a critical
    issue surfaces…all in live, production Spring Boot applications. Actuator facilitates
    the setting and resetting of logging levels with a simple `POST` to the applicable
    endpoint. For example, [Figure 5-18](#default_logging_level_for_orgspringframeworkdataweb)
    shows the default logging level for `org.springframework.data.web`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提供Boot生产就绪功能的使命的一部分，Actuator也解决了这个问题，允许开发人员为大多数或所有组件设置典型的日志级别，当关键问题出现时可以临时更改这个级别……所有这些都是在现场、生产中的Spring
    Boot应用中进行的。Actuator通过向适用的端点发送简单的`POST`请求来便捷地设置和重置日志级别。例如，[图 5-18](#default_logging_level_for_orgspringframeworkdataweb)显示了`org.springframework.data.web`的默认日志级别。
- en: '![sbur 0518](Images/sbur_0518.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![sbur 0518](Images/sbur_0518.png)'
- en: Figure 5-18\. Default logging level for `org.springframework.data.web`
  id: totrans-222
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-18\. `org.springframework.data.web`的默认日志级别
- en: Of particular interest is that since a logging level wasn’t configured for this
    component, an effective level of “INFO” is used. Again, Spring Boot provides a
    sensible default when specifics aren’t provided.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 特别值得注意的是，由于未为此组件配置日志级别，因此使用了有效级别“INFO”。再次强调，当未提供具体配置时，Spring Boot会提供合理的默认设置。
- en: 'If I’m notified of an issue with a running app and would like to increase logging
    to help diagnose and resolve it, all that is necessary to do so for a particular
    component is to `POST` a new JSON-formatted value for `configuredLevel` to its
    */actuator/loggers* endpoint, as shown here:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我收到有关正在运行的应用程序的问题并希望增加日志记录以帮助诊断和解决问题，那么为了特定组件执行此操作所需的全部步骤就是向其 */actuator/loggers*
    端点发布一个新的JSON格式的`configuredLevel`值，如下所示：
- en: '[PRE21]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Requerying the logging level now returns confirmation that the logger for `org.springframework.data.web`
    is now set to “TRACE” and will provide intensive diagnostic logging for the application,
    as shown in [Figure 5-19](#new_trace_logging_level_for_orgspringframeworkdataweb).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重新查询日志级别，确认 `org.springframework.data.web` 的记录器现在设置为“TRACE”，将为应用程序提供详尽的诊断日志记录，如[图 5-19](#new_trace_logging_level_for_orgspringframeworkdataweb)所示。
- en: Warning
  id: totrans-227
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: “TRACE” can be essential in pinning down an elusive issue, but it is a rather
    heavyweight level of logging, capturing even finer-grained information than “DEBUG”—use
    in production applications can provide essential information, but be mindful of
    the impact.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: “TRACE”在确定难以捉摸的问题时可能至关重要，但它是一个相当重量级的日志级别，甚至比“DEBUG”还要详细——在生产应用程序中使用可以提供重要的信息，但要注意其影响。
- en: '![sbur 0519](Images/sbur_0519.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![sbur 0519](Images/sbur_0519.png)'
- en: Figure 5-19\. New “TRACE” Logging Level for `org.springframework.data.web`
  id: totrans-230
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-19\. `org.springframework.data.web`的新“TRACE”日志级别
- en: Code Checkout Checkup
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码检查
- en: For complete chapter code, please check out branch *chapter5end* from the code
    repository.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 获取完整的章节代码，请从代码库的*chapter5end*分支查看。
- en: Summary
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'It’s critical for a developer to have useful tools to establish, identify,
    and isolate behaviors manifested within production applications. As applications
    become more dynamic and distributed, there is often a need to do the following:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员必须拥有有用的工具来建立、识别和隔离生产应用程序中表现出的行为是至关重要的。随着应用程序变得越来越动态和分布式，通常需要做以下工作：
- en: Configure and reconfigure applications dynamically
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置和动态重新配置应用程序
- en: Determine/confirm current settings and their origins
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定/确认当前设置及其来源
- en: Inspect and monitor application environment and health indicators
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查和监控应用程序环境和健康指标
- en: Temporarily adjust logging levels of live apps to identify root causes
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 临时调整实时应用程序的日志级别以识别根本原因
- en: This chapter demonstrated how to use Spring Boot’s built-in configuration capabilities,
    its Autoconfiguration Report, and Spring Boot Actuator to create, identify, and
    modify application environment settings flexibly and dynamically.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 本章展示了如何利用Spring Boot的内置配置能力、其自动配置报告和Spring Boot执行器来灵活动态地创建、识别和修改应用程序环境设置。
- en: 'In the next chapter, I dive deep into data: how to define its storage and retrieval
    using various industry standards and leading database engines and the Spring Data
    projects and facilities that enable their use in the most streamlined and powerful
    ways possible.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我将深入探讨数据：如何使用各种行业标准和领先的数据库引擎定义其存储和检索，以及Spring Data项目和工具如何以最简单和强大的方式支持它们的使用。
- en: ^([1](ch05.xhtml#idm45693962724088-marker)) [Order of precedence for Spring
    Boot PropertySources](https://oreil.ly/OrderPredSB).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch05.xhtml#idm45693962724088-marker)) [Spring Boot属性源的优先级顺序](https://oreil.ly/OrderPredSB)。
