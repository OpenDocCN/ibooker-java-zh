- en: Chapter 10\. Securing Your Spring Boot Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第十章。保护您的Spring Boot应用程序
- en: Understanding the concepts of authentication and authorization are critical
    to building secure applications, providing the foundations for user verification
    and access control. Spring Security combines options for authentication and authorization
    with other mechanisms like the HTTP Firewall, filter chains, extensive use of
    IETF and the World Wide Web Consortium (W3C) standards and options for exchanges,
    and more to help lock down applications. Adopting a secure out-of-the-box mindset,
    Spring Security leverages Boot’s powerful autoconfiguration to evaluate developer
    inputs and available dependencies to deliver maximal security for Spring Boot
    applications with minimal effort.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 理解认证和授权的概念对构建安全应用程序至关重要，为用户验证和访问控制提供基础。Spring Security结合认证和授权的选项与HTTP防火墙、过滤器链、广泛使用的IETF和万维网联盟（W3C）标准及用于交换的选项等其他机制，帮助锁定应用程序。采用安全的开箱即用思维方式，Spring
    Security利用Boot强大的自动配置来评估开发者的输入和可用的依赖关系，以在最小的努力下为Spring Boot应用程序提供最大的安全性。
- en: This chapter introduces and explains core aspects of security and how they apply
    to applications. I demonstrate multiple ways to incorporate Spring Security into
    Spring Boot apps to strengthen an application’s security posture, closing dangerous
    gaps in coverage and reducing attack surface area.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍并解释了安全的核心方面以及它们如何适用于应用程序。我演示了多种将Spring Security集成到Spring Boot应用程序中以增强应用程序安全姿态的方法，弥补了覆盖中的危险漏洞并减少了攻击面积。
- en: Code Checkout Checkup
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码结帐检查
- en: Please check out branch *chapter10begin* from the code repository to begin.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 请从代码库中检出分支 *chapter10begin* 开始。
- en: Authentication and Authorization
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证和授权
- en: Often used together, the terms *authentication* and *authorization* are related
    but separate concerns.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 经常一起使用，*认证* 和 *授权* 这两个术语相关但又是独立的关注点。
- en: authentication
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 认证
- en: An act, process, or method of showing something (such as an identity, a piece
    of art, or a financial transaction) to be real, true, or genuine; the act or process
    of authenticating something.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 表示、展示或证实某事物（如身份、艺术品或金融交易）的真实性、真实性或真实性的行为、过程或方法；验证某事物的真实性的行为或过程。
- en: authorization
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 授权
- en: '1: the act of *authorizing* 2: an instrument that authorizes: SANCTION'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '1: *授权* 的行为 2: 授权的工具：批准'
- en: 'The first definition for *authorization* points to *authorizing* for more information:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*授权* 的第一个定义指向 *授权* 以获取更多信息：'
- en: authorize
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 授权
- en: '1: to endorse, empower, justify, or permit by or as if by some recognized or
    proper authority (such as custom, evidence, personal right, or regulating power)
    a custom authorized by time 2: to invest especially with legal authority: EMPOWER
    3: archaic: JUSTIFY'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '1: 通过或像通过某种公认或适当的权威（如习惯、证据、个人权利或监管权力）背书、授权、证明或允许的习惯由时间授权的 2: 尤其是具有法律权威的投资 3:
    古老：证明'
- en: The definition for *authorize* in turn points to *justify* for more information.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*授权* 的定义反过来指向 *证明* 以获取更多信息。'
- en: While somewhat interesting, these definitions aren’t very clear. Sometimes the
    dictionary definitions can be less helpful than we might like. My own definitions
    follow.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有些有趣，但这些定义并不十分清晰。有时，词典定义可能没有我们期望的那么有帮助。我自己的定义如下。
- en: authentication
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 认证
- en: Proving that someone is who they claim to be
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 证明某人是他们所声称的人
- en: authorization
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 授权
- en: Verifying that someone has access to a particular resource or operation
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 验证某人是否有权访问特定资源或操作
- en: Authentication
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 认证
- en: Simply put, *authentication* is proving that someone (or something) is who (or
    what, in the case of a device, application, or service) they claim to be.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，*认证* 是证明某人（或某物）是其所声称的人（或物，如设备、应用程序或服务）。
- en: The concept of authentication has several concrete examples in the physical
    world. If you’ve ever had to show a form of ID like an employee badge, driver’s
    license, or passport to prove your identity, you have been authenticated. Demonstrating
    that one is who one claims to be is a procedure to which we’ve all grown accustomed
    in a variety of situations, and the conceptual differences between authentication
    at the physical level and to an application are insignificant.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 认证的概念在物理世界中有几个具体的例子。如果您曾经需要展示像员工工牌、驾驶执照或护照等身份证明来证明您的身份，那么您已经进行了认证。证明某人是其声称的人是一个我们在多种情况下都习以为常的程序，而在物理级别和应用程序级别的认证概念差异微不足道。
- en: 'Authentication typically involves one or more of the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证通常涉及以下一项或多项：
- en: Something you are
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你所是的东西
- en: Something you know
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你所知道的东西
- en: Something you have
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你所拥有的东西
- en: Note
  id: totrans-27
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: These three *factors* can be used individually or combined to compose Multi-Factor
    Authentication (MFA).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个*因素*可以单独使用，也可以组合起来构成多因素身份验证（MFA）。
- en: The manner in which authentication occurs in the physical and virtual worlds
    is of course different. Rather than a human being eyeing a photo ID and comparing
    it to your current physical appearance as often happens in the physical world,
    authenticating to an application often involves typing a password, inserting a
    security key, or providing biometric data (iris scan, fingerprint, etc.) that
    can be more easily evaluated by software than is currently feasible with a comparison
    of physical appearance with a photo. Nevertheless, a comparison of stored data
    with provided data is performed in both cases, and a match provides a positive
    authentication.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证在物理世界和虚拟世界中发生的方式当然是不同的。与物理世界中经常发生的人类注视照片ID并将其与您当前的外貌进行比较不同，身份验证到应用程序通常涉及键入密码，插入安全密钥或提供生物特征数据（虹膜扫描，指纹等）。这些数据可以更容易地由软件进行评估，而不是与照片的外观进行比较，目前比较难以实现。尽管如此，两种情况下都会对提供的数据进行比较，并且匹配会提供积极的身份验证。
- en: Authorization
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 授权
- en: Once a person is authenticated, they have the possibility of gaining access
    to resources available and/or operations permitted to one or more individuals.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦一个人通过身份验证，他们就有可能获得一个或多个个人可以使用的资源和/或允许执行的操作。
- en: Note
  id: totrans-32
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In this context, an individual may (and most likely is) a human being, but the
    same concept and access considerations apply to applications, services, devices,
    and more, depending on context.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，一个人可能是（而且很可能是）一个人类，但是对于应用程序，服务，设备等，根据上下文，相同的概念和访问考虑都适用。
- en: Once an individual’s identity is proven, that individual gains some general
    level of access to an application. From there, the now-authenticated application
    user can request access to something. The application then must somehow determine
    if the user is allowed, i.e., *authorized*, to access that resource. If so, access
    is granted to the user; if not, the user is notified that their lack of *authority*
    has resulted in their request being rejected.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦个人的身份得到证明，该个人就会获得对应用程序的一般级别的访问权限。从那里，现在已验证的应用程序用户可以请求访问某些内容。然后，应用程序必须以某种方式确定用户是否被允许访问该资源，即*授权*。如果是这样，则授予用户访问权限；如果不是，则通知用户，他们缺乏*权限*导致其请求被拒绝。
- en: Spring Security in a Nutshell
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Security简介
- en: In addition to providing solid options for authentication and authorization,
    Spring Security provides several other mechanisms to help developers lock down
    their Spring Boot applications. Thanks to autoconfiguration, Spring Boot applications
    enable each applicable Spring Security feature with an eye toward maximum possible
    security with the information provided, or even owing to the lack of more specific
    guidance. Security capabilities can of course be adjusted or relaxed by developers
    as necessary to accommodate their organizations’ specific requirements.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提供可靠的身份验证和授权选项外，Spring Security还提供了其他几种机制，帮助开发人员确保其Spring Boot应用程序的安全性。由于自动配置，Spring
    Boot应用程序根据提供的信息启用每个适用的Spring Security功能，甚至由于缺乏更具体的指导。安全功能当然可以根据开发人员的需要进行调整或放宽，以适应其组织的具体要求。
- en: Spring Security’s capabilities are far too numerous to detail exhaustively in
    this chapter, but there are three key features I consider essential to understanding
    the Spring Security model and its foundations. They are the HTTP Firewall, security
    filter chains, and Spring Security’s extensive use of IETF and W3C standards and
    options for requests and corresponding responses.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security的功能远远超出了本章详尽介绍的范围，但有三个关键功能对理解Spring Security模型及其基础至关重要。它们是HTTP防火墙，安全过滤器链以及Spring
    Security对IETF和W3C标准的广泛使用以及对请求和相应的选项。
- en: The HTTP Firewall
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP防火墙
- en: While exact numbers are difficult to obtain, many security compromises begin
    with a request using a malformed URI and a system’s unexpected response to it.
    This is really an application’s first line of defense, and as such, it is the
    problem that should be solved prior to considering further efforts to secure one’s
    application(s).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然确切的数字很难获得，但许多安全妥协始于使用格式不正确的 URI 进行请求，以及系统对其的意外响应。这实际上是应用程序的第一道防线，因此在考虑进一步努力保护应用程序之前，应首先解决这个问题。
- en: Since version 5.0, Spring Security has included a built-in HTTP Firewall that
    scrutinizes all inbound requests for problematic formatting. If there are any
    problems with a request, such as bad header values or incorrect formatting, the
    request is discarded. Unless overridden by the developer, the default implementation
    used is the aptly named `StrictHttpFirewall`, quickly closing the first and potentially
    easiest gap to exploit within an application’s security profile.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 自 5.0 版本起，Spring Security 已经包含了一个内置的 HTTP 防火墙，用于审查所有入站请求的问题格式。如果请求存在任何问题，如不良的头部值或格式不正确，则请求将被丢弃。除非开发者进行了覆盖，否则默认实现使用的是名为`StrictHttpFirewall`的适当命名的实现，快速关闭应用程序安全配置中的第一个且可能最容易被利用的漏洞。
- en: Security Filter Chains
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全过滤器链
- en: Providing a more specific, next-level filter for inbound requests, Spring Security
    uses filter chains to process properly formed requests that make it past the HTTP
    Firewall.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security 提供了一个更为具体、更高级别的入站请求过滤器链，用于处理成功通过 HTTP 防火墙的正常形式的请求。
- en: Simply put, for most applications a developer specifies a chain of filter conditions
    through which an inbound request passes until it matches one. When a request matches
    a filter, its corresponding conditions are evaluated to determine if the request
    will be fulfilled. For example, if a request for a particular API endpoint arrives
    and matches a filter condition in the filter chain, the user who made the request
    may be checked to verify they have the proper role/authority to access the requested
    resource. If so, the request is processed; if not, it is rejected, usually with
    a *403 Forbidden* status code.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，对于大多数应用程序，开发者通过指定一系列过滤器条件，使得入站请求通过这些条件直到匹配一个过滤器。当请求与过滤器匹配时，将评估其相应的条件，以确定是否满足请求。例如，如果到达特定
    API 端点的请求与过滤器链中的某个条件匹配，则将检查发出请求的用户是否具有访问所请求资源的适当角色/权限。如果是，则处理请求；如果不是，则通常使用 *403
    Forbidden* 状态码拒绝请求。
- en: If a request passes through all defined filters in the chain without matching
    any, the request is discarded.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个请求通过链中定义的所有过滤器而不匹配任何过滤器，则该请求将被丢弃。
- en: Request and Response Headers
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请求和响应头部
- en: The IETF and W3C have created a number of specifications and standards for HTTP-based
    exchanges, several of which relate to the secure exchange of information. There
    are several headers defined for interactions between user agents—command line
    utilities, web browsers, etc.—and server or cloud-based applications/services.
    These headers are used to request or signal specific behavior and have defined
    allowed values and behavioral responses, and Spring Security makes extensive use
    of these header details to strengthen your Spring Boot application’s security
    posture.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: IETF 和 W3C 创建了多个基于 HTTP 的交换规范和标准，其中几个与信息安全的安全交换相关。这些头部用于请求或指示特定行为，并定义了允许的值和行为响应。Spring
    Security 广泛使用这些头部详情来增强您的 Spring Boot 应用程序的安全性姿态。
- en: Realizing it’s true that different user agents may support some or all of these
    standards and specifications, and even then fully or partially, Spring Security
    embraces a best-possible-coverage approach by checking for all known header options
    and applying them across the board, looking for them in requests and supplying
    them in responses, as applicable.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 了解到不同的用户代理可能支持这些标准和规范的一些或全部，Spring Security 通过检查所有已知的头部选项并在请求中查找它们，在响应中适用时提供它们，采用了尽可能覆盖的最佳实践方法。
- en: Implementing Forms-Based Authentication and Authorization with Spring Security
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Spring Security 实现基于表单的身份验证和授权
- en: Innumerable applications that use the “something you know” method of authentication
    are used every day. Whether for apps internal to an organization, web applications
    provided directly to consumers via the internet, or apps native to a mobile device,
    typing in a user ID and password is a familiar routine for developers and non-developers
    alike. And in most of those cases, the security this provides is more than sufficient
    for the task at hand.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 每天都有无数使用“something you know”身份验证方法的应用程序被使用。无论是用于组织内部的应用程序，直接通过互联网提供给消费者的Web应用程序，还是移动设备本地的应用程序，输入用户ID和密码对开发者和非开发者来说都是熟悉的例行公事。在大多数情况下，这种提供的安全性已经足以完成手头的任务。
- en: Spring Security provides Spring Boot applications with superb out-of-the-box
    (OOTB) support for password authentication via autoconfiguration and easy-to-grasp
    abstractions. This section demonstrates the various stepping-off points by refactoring
    the `Aircraft Positions` application to incorporate forms-based authentication
    using Spring Security.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security为Spring Boot应用程序提供了出色的开箱即用（OOTB）支持，通过自动配置和易于理解的抽象来进行密码验证。本节演示了通过重构`Aircraft
    Positions`应用程序以使用Spring Security实现基于表单的身份验证的各种起始点。
- en: Adding Spring Security Dependencies
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加Spring Security依赖项
- en: When creating a new Spring Boot project, it’s a simple matter to add one more
    dependency via the Spring Initializr—that of *Spring Security*—and to enable a
    top-tier level of security without additional configuration to a fledgling app,
    as shown in [Figure 10-1](#spring_security_dependency_within_spring_initializr).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建新的Spring Boot项目时，通过Spring Initializr添加一个更多的依赖项，即*Spring Security*，可以在不对新应用程序进行额外配置的情况下提供顶级安全性，如[图10-1](#spring_security_dependency_within_spring_initializr)所示。
- en: '![sbur 1001](Images/sbur_1001.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![sbur 1001](Images/sbur_1001.png)'
- en: Figure 10-1\. Spring Security dependency within Spring Initializr
  id: totrans-54
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10-1\. Spring Initializr中的Spring Security依赖项
- en: 'Updating an existing application is only slightly less simple. I’ll add the
    same two complementary dependencies that Initializr adds, one for Spring Security
    itself and one for testing it, to `Aircraft Positions` ’s *pom.xml* Maven build
    file:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 更新现有应用程序稍微复杂一点。我将在`Aircraft Positions`的*pom.xml* Maven构建文件中添加与Initializr添加的两个互补依赖项，一个是用于Spring
    Security本身，另一个用于测试它：
- en: '[PRE0]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: With Spring Security on the classpath and no code or configuration changes to
    the application, I restart `Aircraft Positions` for a quick functionality check.
    This provides a great opportunity to see what Spring Security does on a developer’s
    behalf OOTB.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 将Spring Security添加到类路径中并且没有代码或配置更改应用时，我重新启动`Aircraft Positions`进行快速功能检查。这提供了一个很好的机会，了解Spring
    Security在开发者方面所做的工作。
- en: 'With both PlaneFinder and `Aircraft Positions` running, I return to the terminal
    and again exercise `Aircraft Positions` ’s */aircraft* endpoint, as shown here:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`PlaneFinder`和`Aircraft Positions`两个应用后，我返回终端，并再次调用`Aircraft Positions`的*/aircraft*端点，如下所示：
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-60
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注：
- en: Some response headers have been removed for clarity.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，已删除了一些响应头。
- en: As you can see, I no longer have access to the */aircraft* endpoint, receiving
    a *401 Unauthorized* response to my request. Since the */aircraft* endpoint is
    currently the only means of accessing information from the `Aircraft Positions`
    application, this effectively means the application is secured in its entirety
    from unwanted access. This is great news, but it’s important to understand both
    how this happened and how to restore desired access for valid users.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我无法再访问*/aircraft*端点，因为我的请求收到了*401 Unauthorized*的响应。由于*/aircraft*端点目前是从`Aircraft
    Positions`应用程序访问信息的唯一途径，这有效地意味着该应用程序已经完全保护免受未经授权的访问。这是一个好消息，但重要的是要理解这是如何发生的，以及如何为合法用户恢复所需的访问权限。
- en: As I mentioned earlier, Spring Security adopts a mindset of “secure by default”
    to the extent possible at every level of configuration—even zero configuration—by
    the developer employing it in a Spring Boot application. When Spring Boot finds
    Spring Security on the classpath, security is configured using sensible defaults.
    Even with no user(s) defined or password(s) specified or any other effort made
    by the developer, the inclusion of Spring Security in the project indicates a
    goal of a secure application.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，Spring Security采用“默认安全”的思路，在开发者使用它在Spring Boot应用程序中的每个级别配置甚至零配置时尽可能安全。当Spring
    Boot在类路径中找到Spring Security时，安全性将使用合理的默认值进行配置。即使没有定义任何用户或指定任何密码或开发者未作出任何其他努力，项目中包含Spring
    Security都表明其目标是创建一个安全的应用程序。
- en: 'As you can imagine, this is very little to go on. But Spring Boot+Security
    autoconfiguration creates a number of essential beans to implement basic security
    capabilities based on forms authentication and user authorization using user IDs
    and passwords. The next questions to quite reasonably flow from that logical assumption
    are these: What user(s)? What password(s)?'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 可以想象，这些信息非常少。但是，Spring Boot+Security 自动配置创建了一些基本安全功能的关键 Bean，基于表单认证和使用用户 ID
    和密码进行用户授权。从这个逻辑假设合理地得出的下一个问题是：使用什么用户？什么密码？
- en: 'Returning to the startup log for the `Aircraft Positions` application, one
    can find the answer to one of those questions in this line:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到`Aircraft Positions`应用程序的启动日志，可以在以下行找到其中一个问题的答案：
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If no user ID(s) and password(s) are specified in the application or no means
    are provided to access them by other means, a security-enabled Spring Boot app
    defaults to a single user account `user` with a unique password that is generated
    anew each time the application is started. Returning to the terminal window, I
    try to access the application once again, this time with the provided credentials:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在应用程序中未指定用户 ID 和密码，也未提供其他访问方式，则启用安全性的 Spring Boot 应用程序将默认使用一个名为`user`的单一用户帐户，并在每次应用程序启动时生成一个新的唯一密码。回到终端窗口，我尝试再次访问应用程序，这次使用提供的凭据：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-69
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: As before, some response headers have been removed for clarity.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，为了清晰起见，已删除了一些响应标头。
- en: Using the correct default user ID and the generated password, I receive a *200
    OK* response and once again have access to the */aircraft* endpoint, and thus
    the `Aircraft Positions` application.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用正确的默认用户 ID 和生成的密码，我收到了*200 OK*的响应，并再次可以访问*/aircraft*端点，从而访问了`Aircraft Positions`应用程序。
- en: Returning to the `Aircraft Positions` application, there are a few concerns
    with the current state of application security. First among them is that by having
    only a single defined user, multiple individuals that need to access the application
    must all use that single account. This is antithetical to the security principle
    of accountability and even authentication, as no single individual uniquely proves
    they are who they say they are. Returning to accountability, how can one determine
    who committed or contributed to a breach if one occurs? Not to mention that if
    a breach were to occur, locking the only user account would disable access for
    all users; there is currently no way to avoid it.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`Aircraft Positions`应用程序，当前应用程序安全状态存在几个问题。首先，只有一个定义的用户，需要访问该应用程序的多个人员必须全部使用该单一帐户。这与安全责任和甚至身份验证的原则背道而驰，因为没有单一的个体可以唯一证明他们是谁。再谈责任问题，如果发生漏洞，如何确定是谁造成或贡献了漏洞？更不用说，如果发生漏洞，锁定唯一用户帐户将禁止所有用户访问；目前没有办法避免这种情况。
- en: A secondary concern with the existing security configuration is the way the
    single password is handled. With each application startup, a new password is automatically
    generated, which must then be shared with all users. And while application scaling
    hasn’t yet been discussed, each instance of `Aircraft Positions` that is started
    will generate a unique password, requiring that particular password from a user
    attempting to log into that particular app instance. Clearly some improvements
    can and should be made.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现有安全配置的次要问题是如何处理单一密码。每次应用程序启动时，都会自动生成新密码，然后必须与所有用户共享。虽然尚未讨论应用程序的扩展性，但每个启动的`Aircraft
    Positions`实例将生成一个唯一密码，需要用户输入该特定应用程序实例的密码。显然可以并且应该做出一些改进。
- en: Adding Authentication
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加认证
- en: Spring Security employs the concept of a `UserDetailsService` as the centerpiece
    of its authentication capability. `UserDetailsService` is an interface with a
    single method `loadUserByUsername(String username)` that (when implemented) returns
    an object that fulfills the `UserDetails` interface, from which can be obtained
    key information such as the user’s name, password, authorities granted to the
    user, and account status. This flexibility allows for numerous implementations
    using various technologies; as long as a `UserDetailsService` returns `UserDetails`,
    the application doesn’t need to be aware of underlying implementation details.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security使用`UserDetailsService`的概念作为其认证能力的核心。`UserDetailsService`是一个接口，具有一个`loadUserByUsername(String
    username)`方法（在实现时）返回一个满足`UserDetails`接口的对象，从中可以获取关键信息，如用户的名称、密码、授予用户的权限和账户状态。这种灵活性允许使用各种技术进行多种实现；只要`UserDetailsService`返回`UserDetails`，应用程序就不需要知道底层实现细节。
- en: To create a `UserDetailsService` bean, I create a configuration class in which
    to define a bean creation method.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个`UserDetailsService` bean，我创建一个配置类，在其中定义一个bean创建方法。
- en: 'First, I create a class called `SecurityConfig` and annotate it with `@Configuration`
    to enable Spring Boot to find and execute bean creation methods within. The bean
    necessary for authentication is one that implements the `UserDetailsService` interface,
    so I create a method `authentication()` to create and return that bean. Here is
    a first, intentionally incomplete pass at the code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我创建一个名为`SecurityConfig`的类，并使用`@Configuration`进行注解，以便Spring Boot能够找到并执行其中的bean创建方法。用于身份验证的bean是实现`UserDetailsService`接口的bean，因此我创建一个名为`authentication()`的方法来创建并返回该bean。这是第一次，有意不完整的代码：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Within the `UserDetailService` `authentication()` method, I create two application
    objects that implement the `UserDetails` interface requirements using the `User`
    class’s `builder()` method and specifying username, password, and roles/authorities
    the user possesses. I then `build()` these users and assign each of them to a
    local variable.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在`UserDetailService`的`authentication()`方法中，我使用`User`类的`builder()`方法创建了两个实现`UserDetails`接口要求的应用对象，并指定了用户名、密码和用户拥有的角色/权限。然后我使用`build()`方法构建这些用户，并将每个用户分配给一个局部变量。
- en: Next, I display the passwords *for demonstration purposes only*. This helps
    to demonstrate another concept in this chapter but is *for demonstration purposes
    only*.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我仅仅为演示目的显示密码。这有助于展示本章中的另一个概念，但**仅供演示目的**。
- en: Warning
  id: totrans-81
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Logging passwords is an antipattern of the worst kind. Never log passwords in
    production applications.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 记录密码是一种最坏的反模式。永远不要在生产应用程序中记录密码。
- en: Finally, I create an `InMemoryUserDetailsManager` using the two created `User`
    objects and return it as a Spring bean. An `InMemoryUserDetailsManager` implements
    interfaces `UserDetailsManager` and `UserDetailsPasswordService`, enabling user
    management tasks like determining if a particular user exists; creating, updating,
    and deleting the user; and changing/updating the user’s password. I use `InMemoryUserDetailsManager`
    for its clarity in demonstrating the concept (due to no external dependencies),
    but any bean that implements the `UserDetailsService` interface can be provided
    as the authentication bean.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我创建了一个`InMemoryUserDetailsManager`，使用这两个创建的`User`对象，并将其作为Spring bean返回。`InMemoryUserDetailsManager`实现了`UserDetailsManager`和`UserDetailsPasswordService`接口，使得可以进行用户管理任务，如确定特定用户是否存在、创建、更新和删除用户，以及更改/更新用户的密码。我使用`InMemoryUserDetailsManager`是为了在演示概念时更加清晰（因为没有外部依赖），但任何实现`UserDetailsService`接口的bean都可以作为认证bean提供。
- en: 'Restarting `Aircraft Positions`, I attempt to authenticate and retrieve a list
    of current aircraft positions, with the following results (some headers removed
    for brevity):'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动`Aircraft Positions`，我尝试进行身份验证，并检索当前飞机位置的列表，结果如下（为简洁起见，删除了一些标题）：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This prompts a bit of troubleshooting. Returning to the IDE, there is a helpful
    bit of information in the stack trace:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这促使一些故障排除。返回到IDE，堆栈跟踪中有一些有用的信息：
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This provides a hint at the root of the problem. Examining the logged passwords
    (kind reminder: logging passwords is *for demonstration purposes only*) provides
    confirmation:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这为问题的根源提供了一个提示。检查记录的密码（友情提醒：记录密码**仅供演示目的**）得到了确认：
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Clearly* these passwords are in plain text, with no encoding whatsoever being
    performed. The next step toward working and secure authentication is to add a
    password encoder for use within the `SecurityConfig` class, as shown in the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*显然* 这些密码是明文的，没有进行任何编码。实现工作和安全的身份验证的下一步是在 `SecurityConfig` 类中添加一个密码编码器，如下所示：'
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: One of the challenges of creating and maintaining secure applications is that,
    of necessity, security is ever evolving. Recognizing this, Spring Security doesn’t
    simply have a designated encoder it plugs in; rather, it uses a factory with several
    available encoders and delegates to one for encoding and decoding chores.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 创建和维护安全应用程序的一个挑战在于，安全性必须不断进化。Spring Security 正是出于这个必要性，不仅仅有一个指定的编码器可供插入；它使用一个具有多个可用编码器的工厂，并委托其中一个进行编码和解码任务。
- en: Of course, this means that one must serve as a default in the event one isn’t
    specified, as in the previous example. Currently *BCrypt* is the (excellent) default,
    but the flexible, delegated nature of Spring Security’s encoder architecture is
    such that one encoder can be replaced easily by another as standards evolve and/or
    requirements change. The elegance of this approach allows for a frictionless migration
    of credentials from one encoder to another when an application user logs into
    the application, again reducing tasks that don’t directly provide value to an
    organization but are nevertheless critical to perform in a correct and timely
    manner.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这意味着在前面的示例中，如果没有指定编码器，则必须作为默认值服务。目前 *BCrypt* 是（非常好的）默认值，但是 Spring Security
    编码器架构的灵活委托性质使得在标准演变和/或需求变化时可以轻松地将一个编码器替换为另一个。这种方法的优雅性允许在应用程序用户登录时轻松地将凭据从一个编码器迁移到另一个编码器，从而再次减少了一些虽然对组织至关重要但并不直接提供价值的任务。
- en: Now that I have an encoder in place, the next step is to use it to encrypt the
    user passwords. This is done very simply by plugging in a call to the password
    encoder’s `encode()` method, passing the plain text password and receiving in
    return the encrypted result.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我已经放置了一个编码器，下一步是使用它来加密用户密码。这可以通过简单地调用密码编码器的 `encode()` 方法，并传递明文密码来完成，然后收到加密结果。
- en: Tip
  id: totrans-95
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Technically speaking, encrypting a value also encodes that value, but all encoders
    do not encrypt. For example, hashing encodes a value but does not necessarily
    encrypt it. That said, every encoding algorithm supported by Spring Security also
    encrypts; to support legacy applications, however, some supported algorithms are
    far less secure than others. Always choose a current recommended Spring Security
    encoder or opt for the default one provided by `PasswordEncoderFactories.createDelegatingPasswordEncoder()`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，加密一个值也会对该值进行编码，但并非所有编码器都会加密。例如，哈希编码一个值但不一定加密它。也就是说，Spring Security 支持的每种编码算法也都会进行加密；然而，为了支持旧的应用程序，某些支持的算法远不如其他算法安全。始终选择当前推荐的
    Spring Security 编码器或选择由 `PasswordEncoderFactories.createDelegatingPasswordEncoder()`
    提供的默认编码器。
- en: 'The revised, authenticating version of the `SecurityConfig` class follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 经过修订的 `SecurityConfig` 类的身份验证版本如下所示：
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'I restart `Aircraft Positions`, then attempt once again to authenticate and
    retrieve a list of current aircraft positions with the following results (some
    headers and results removed for brevity):'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我重新启动 `Aircraft Positions`，然后再次尝试进行身份验证并检索当前飞机位置列表，结果如下（为简洁起见，某些标题和结果已删除）：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: These results confirm that authentication is now successful (an intentional
    failing scenario using an incorrect password is omitted due to space considerations)
    and valid users can once again access the exposed API.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这些结果证实了认证已成功（由于空间限制，故意使用不正确的密码进行失败的场景被省略），有效用户可以再次访问暴露的 API。
- en: 'Returning to examine the logged, and now encoded, passwords, I note values
    similar to the following in the IDE’s output:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾并且现在查看已编码的密码，我注意到在 IDE 输出中类似以下值：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The logged values confirm that both example passwords specified in the code
    have been encoded successfully by the delegated password encoder using *BCrypt*.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 登录的值确认了代码中指定的两个示例密码已经由委托密码编码器成功编码，使用 *BCrypt*。
- en: Authorization
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 授权
- en: 'The `Aircraft Positions` application now successfully authenticates users and
    allows only said users to access its exposed API. There is a rather large issue
    with the current security configuration, though: access to any part of the API
    means access to all of it, regardless of roles/authority the user possesses—or
    more accurately, regardless of roles *not* possessed.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`Aircraft Positions`应用程序成功地认证用户，并仅允许这些用户访问其暴露的API。然而，当前安全配置存在一个相当大的问题：访问API的任何部分都意味着可以访问所有部分，无论用户拥有的角色/权限，或者更确切地说，无论用户*不*拥有的角色。
- en: 'As a very simple example of this security flaw, I add another endpoint to `Aircraft
    Position` ’s API by cloning, renaming, and remapping the existing `getCurrentAircraftPositions()`
    method in the `PositionController` class as a second endpoint. Once complete,
    `PositionController` appears as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这个安全漏洞的一个非常简单的例子，我在`Aircraft Position`的API中添加了另一个端点，通过克隆、重命名和重新映射`PositionController`类中现有的`getCurrentAircraftPositions()`方法作为第二个端点。完成后，`PositionController`如下所示：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The goal is to allow only users having the “ADMIN” role access to the second
    method, `getCurrentAircraftPositionsAdminPrivs()`. While in this version of this
    example the values returned are identical to those returned by the `getCurrentAircraftPositions()`,
    this will likely not remain the case as the application expands, and the concept
    applies regardless.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是只允许具有“ADMIN”角色的用户访问第二个方法`getCurrentAircraftPositionsAdminPrivs()`。虽然在这个例子的当前版本中，返回的值与`getCurrentAircraftPositions()`返回的值相同，但随着应用程序的扩展，这种情况可能不会持续，这个概念仍然适用。
- en: 'Restarting the `Aircraft Positions` application and returning to the command
    line, I login first as user Jodie to verify access to the new endpoint, as expected
    (first endpoint access confirmed but omitted due to space; some headers and results
    also omitted for brevity):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动`Aircraft Positions`应用程序并返回命令行，我首先以用户Jodie的身份登录，以验证对新端点的访问，预期的访问已确认（由于空间限制，省略了第一个端点的访问确认以及部分标题和结果）。
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, I log in as Peter. Peter should not have access to the `getCurrentAircraftPositionsAdminPrivs()`
    method, mapped to */aircraftadmin*. But that isn’t the case; currently Peter—an
    authenticated user—can access everything:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我以Peter的身份登录。Peter不应该能够访问映射到*/aircraftadmin*的`getCurrentAircraftPositionsAdminPrivs()`方法。但情况并非如此；目前，作为经过身份验证的用户，Peter可以访问一切：
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To enable the `Aircraft Positions` application to not simply authenticate users
    but also to check user authorization to access particular resources, I refactor
    `SecurityConfig` to perform that task.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让`Aircraft Positions`应用程序不仅能够简单地认证用户，还能检查用户是否有权限访问特定资源，我重构了`SecurityConfig`来执行这项任务。
- en: The first step is to replace the class-level annotation `@Configuration` with
    `@EnableWebSecurity`. `@EnableWebSecurity` is a meta-annotation that includes
    the removed `@Configuration`, still allowing for bean creation methods within
    the annotated class; but it also includes the `@EnableGlobalAuthentication` annotation
    that enables a great deal more security autoconfiguration to be done by Spring
    Boot for the application. This positions `Aircraft Positions` well for the next
    step of defining the authorization mechanism itself.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是用`@EnableWebSecurity`替换类级注解`@Configuration`。`@EnableWebSecurity`是一个元注解，包含了被移除的`@Configuration`，仍然允许在注解类中创建bean方法；但它还包括`@EnableGlobalAuthentication`注解，允许Spring
    Boot为应用程序自动配置更多安全性。这为`Aircraft Positions`应用程序为定义授权机制本身做好了准备。
- en: 'I refactor the `SecurityConfig` class to extend `WebSecurityConfigurerAdapter`,
    an abstract class with numerous member variables and methods useful for extending
    the basic configuration of an application’s web security. In particular, `WebSecurityConfigurerAdapter`
    has a `configure(HttpSecurity http)` method that provides a basic implementation
    for user authorization:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我重构了`SecurityConfig`类，使其扩展`WebSecurityConfigurerAdapter`，这是一个抽象类，具有许多对扩展应用程序Web安全性基本配置有用的成员变量和方法。特别是，`WebSecurityConfigurerAdapter`有一个`configure(HttpSecurity
    http)`方法，为用户授权提供了基本实现：
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the preceding implementation, the following directives are issued:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述实现中，发出了以下指令：
- en: Authorize any request from an authenticated user.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权任何经过身份验证的用户的请求。
- en: Simple login and logout forms (overridable ones created by the developer) will
    be provided.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供简单的登录和注销表单（开发者可以覆盖的表单）。
- en: HTTP Basic Authentication is enabled for nonbrowser user agents (command line
    tools, for example).
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 针对非浏览器用户代理（例如命令行工具）启用了HTTP基本认证。
- en: This provides a reasonable security posture if no authorization specifics are
    supplied by the developer. The next step is to provide more specifics and thus
    override this behavior.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果开发人员未提供授权详细信息，则此方法提供了合理的安全姿态。下一步是提供更具体的信息，从而覆盖此行为。
- en: 'I use IntelliJ for Mac’s `CTRL+O` keyboard shortcut or click the right mouse
    button and then Generate to open the Generate menu, then select the Override methods…
    option to display overridable/implementable methods. Selecting the method with
    signature `configure(http:HttpSecurity):void` produces the following method:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用IntelliJ for Mac的`CTRL+O`键盘快捷键或单击右鼠标按钮，然后生成以打开生成菜单，然后选择“Override methods…”选项来显示可重写/可实现的方法。选择具有签名`configure(http:HttpSecurity):void`的方法将生成以下方法：
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'I then replace the call to the superclass’s method with the following code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我用以下代码替换了对超类方法的调用：
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This implementation of the `configure(HttpSecurity http)` method performs the
    following actions:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`configure(HttpSecurity http)`方法的实现执行以下操作：'
- en: Using a `String` pattern matcher, the request path is compared for a match with
    */aircraftadmin* and all paths below.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`String`模式匹配器，将请求路径与*/aircraftadmin*及其以下所有路径进行比较。
- en: If the match is successful, the user is authorized to make the request if the
    user has the “ADMIN” role/authority.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果匹配成功，且用户具有“ADMIN”角色/权限，则授权用户发出请求。
- en: Any other request is fulfilled for any authenticated user
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于任何已认证用户，均可完成其他请求
- en: Simple login and logout forms (overridable ones created by the developer) will
    be provided
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供简单的登录和注销表单（由开发人员创建的可重写表单）。
- en: HTTP Basic Authentication is enabled for nonbrowser user agents (command line
    tools, etc.).
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用非浏览器用户代理（命令行工具等）的HTTP基本身份验证。
- en: 'This minimal authorization mechanism places two filters in the security filter
    chain: one to check for a path match and admin privileges and one for all other
    paths and an authenticated user. A tiered approach allows for complex scenarios
    to be captured in fairly simple, easy-to-reason-about logic.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这种最小授权机制将两个过滤器放置在安全过滤器链中：一个用于检查路径匹配和管理员权限，另一个用于所有其他路径和已认证用户。分层方法允许捕获相当简单、易于理解的复杂场景逻辑。
- en: 'The final version (for forms-based security) of the `SecurityConfig` class
    looks like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: （用于基于表单的安全性的）`SecurityConfig`类的最终版本如下：
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now to confirm that all works as intended. I restart the `Aircraft Positions`
    application and access the */aircraftadmin* endpoint as Jodie from the command
    line (first endpoint access confirmed but omitted due to space; some headers and
    results also omitted for brevity):'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在确认所有操作按预期进行。我重新启动`Aircraft Positions`应用程序，并作为Jodie从命令行访问*/aircraftadmin*端点（由于篇幅原因省略了第一个端点访问确认；部分标题和结果也因简洁起见而省略）：
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Jodie is able to access the */aircraftadmin* endpoint as expected owing to
    having the “ADMIN” role. Next, I try using Peter’s login. Note that the first
    endpoint access was confirmed but omitted due to space; some headers were also
    omitted for brevity:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 由于具有“ADMIN”角色，Jodie可以按预期访问*/aircraftadmin*端点。接下来，我尝试使用Peter的登录。请注意，由于篇幅原因省略了第一个端点访问确认；为简洁起见，某些标题也已省略：
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is exactly what should have occurred, since Peter only has the “USER” role
    and not “ADMIN.” The system works.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是应该发生的事情，因为Peter只有“USER”角色，而不是“ADMIN”。系统正常运行。
- en: Code Checkout Checkup
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码检出检查
- en: Please check out branch *chapter10forms* from the code repository for a complete
    forms-based example.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 请从代码仓库的分支*chapter10forms*检出一个完整的基于表单的示例。
- en: Implementing OpenID Connect and OAuth2 for Authentication and Authorization
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施OpenID Connect和OAuth2进行身份验证和授权
- en: 'While forms-based authentication and internal authorization is useful for a
    large number of applications, numerous use cases exist in which “something you
    know” methods of authentication are less than ideal or even insufficient for the
    desired or required level of security. Some examples include but are not limited
    to the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管基于表单的身份验证和内部授权对于许多应用程序非常有用，但在许多情况下，“您所知道的”身份验证方法可能不够理想，甚至不足以实现所需的安全级别。一些例子包括但不限于以下情况：
- en: Free services that require authentication but that don’t need to know anything
    about the user (or don’t want to know, for legal or other reasons)
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要身份验证但不需要了解用户任何信息（或因法律或其他原因不想了解用户信息的）的免费服务
- en: Situations in which single-factor authentication isn’t considered secure enough,
    desiring and/or requiring Multi-Factor Authentication (MFA) support
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不认为单因素身份验证足够安全的情况下，需要和/或需要多因素身份验证（MFA）支持的情况
- en: Concerns about creating and maintaining secure software infrastructure for managing
    passwords, roles/authorities, and other necessary mechanisms
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于创建和维护用于管理密码、角色/权限和其他必要机制的安全软件基础设施的关注
- en: Concerns over liability in the event of compromise
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于妥协事件的责任问题的关注
- en: 'There is no simple answer to any of these concerns or goals, but several companies
    have built and maintain robust and secure infrastructure assets for authentication
    and authorization and offer it for general use at low or no cost. Companies like
    Okta, a leading security vendor, and others whose businesses require proven user
    validation and permissions verification: Facebook, GitHub, and Google, to name
    a few. Spring Security supports all of these options and more via OpenID Connect
    and OAuth2.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些问题或目标，没有简单的答案，但是一些公司已经构建并维护了强大且安全的基础设施资产，用于验证用户和验证权限，并提供给广大用户以低廉或零成本的一般使用。像Okta这样的领先安全供应商以及其他需要经过验证用户和权限验证的企业：Facebook、GitHub和Google等等。Spring
    Security支持所有这些选项，以及通过OpenID Connect和OAuth2提供更多选项。
- en: 'OAuth2 was created to provide a means for third-party authorization of users
    for specified resources, such as cloud-based services, shared storage, and applications.
    OpenID Connect builds on OAuth2 to add consistent, standardized authentication
    using one or more factors from the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth2是为第三方授权用户访问指定资源（如基于云的服务、共享存储和应用程序）提供手段而创建的。OpenID Connect在OAuth2的基础上添加了一致的、标准化的身份验证，使用以下一种或多种因素之一：
- en: Something you know, for example, a password
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你知道的东西，例如密码
- en: Something you have, like a hardware key
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你拥有的东西，比如硬件密钥
- en: Something you are, such as a biometric identifier
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是某个人，比如生物特征识别器
- en: Spring Boot and Spring Security support autoconfiguration out of the box for
    OpenID Connect and OAuth2 implementations offered by Facebook, GitHub, Google,
    and Okta, with additional providers easily configurable due to the published standards
    for OpenID Connect and OAuth2 and Spring Security’s extensible architecture. I
    use Okta’s libraries and authentication+authorization mechanisms for the examples
    that follow, but differences between providers are mostly variations on a theme.
    Feel free to use the security provider that best suits your needs.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot和Spring Security支持由Facebook、GitHub、Google和Okta提供的OpenID Connect和OAuth2实现的开箱即用的自动配置，由于OpenID
    Connect和OAuth2的公布标准以及Spring Security的可扩展架构，额外的提供者可以很容易地进行配置。我在接下来的示例中使用了Okta的库和身份验证+授权机制，但是提供者之间的差异基本上是主题的变化。请随意使用最适合您需求的安全提供程序。
- en: In this example, I refactor `Aircraft Positions` to serve as an OpenID Connect
    and OAuth2 client application, working with Okta’s capabilities to validate the
    user and obtain the user’s authorities to access resources exposed by a resource
    server. I then refactor PlaneFinder to provide its resources—as an OAuth2 resource
    server—based on credentials supplied with requests from the `Aircraft Positions`
    (client) application.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我重构`飞机位置`以作为OpenID Connect和OAuth2客户端应用程序，利用Okta的能力来验证用户并获取用户访问由资源服务器公开的资源的权限。然后，我重构PlaneFinder以根据从`飞机位置`（客户端）应用程序的请求中提供的凭据提供其资源——作为OAuth2资源服务器。
- en: Aircraft Positions Client Application
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 飞机位置客户端应用程序
- en: I typically begin with the application farthest back in the stack, but in this
    case, I believe the opposite approach has more merit due to the flows associated
    with a user gaining (or being denied) access to a resource.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我通常从堆栈中最后的应用程序开始，但在这种情况下，由于与用户获得（或被拒绝）访问资源相关的流程，我认为相反的方法更有价值。
- en: A user accesses a client application that uses some mechanism to authenticate
    them. Once authenticated, user requests for resources are relayed to so-called
    resource servers that hold and manage said resources. This is a logical flow that
    most of us follow repeatedly and find very familiar. By enabling security in the
    same order—client, then resource server—it neatly aligns with our own, expected
    flow.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 用户访问使用某种机制对其进行身份验证的客户端应用程序。一旦经过身份验证，用户对资源的请求将被转发到所谓的资源服务器，该服务器保存和管理所述资源。这是大多数人反复遵循并感到非常熟悉的逻辑流程。通过按照相同顺序启用安全性——先客户端，然后是资源服务器——它与我们自己的预期流程完美对齐。
- en: Adding OpenID Connect and OAuth2 dependencies to Aircraft Positions
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将OpenID Connect和OAuth2依赖项添加到飞机位置
- en: As with forms-based security, it’s simple to add additional dependencies via
    the Spring Initializr when creating a new Spring Boot client project to get started
    with OpenID Connect and OAuth2 in a greenfield client application, as shown in
    [Figure 10-2](#dependencies_for_openid_connect_and_oauth2_client_application_using_okta_within_spring_initializr).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 与基于表单的安全性一样，当在 Spring Initializr 中创建一个新的 Spring Boot 客户端项目以启动 OpenID Connect
    和 OAuth2 在绿地客户端应用中时，可以通过 Spring Initializr 简单地添加额外的依赖项，如图 [10-2](#dependencies_for_openid_connect_and_oauth2_client_application_using_okta_within_spring_initializr)
    所示。
- en: '![sbur 1002](Images/sbur_1002.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![sbur 1002](Images/sbur_1002.png)'
- en: Figure 10-2\. Dependencies for OpenID Connect and OAuth2 Client application
    using Okta within Spring Initializr
  id: totrans-162
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-2\. 在 Spring Initializr 中使用 Okta 配置 OpenID Connect 和 OAuth2 客户端应用所需的依赖项。
- en: 'Updating an existing application requires only a bit more effort. Since I’m
    replacing the current forms-based security, I first remove the existing dependency
    for Spring Security that I added in the previous section. Then I add the same
    two dependencies that Initializr adds for OpenID Connect and OAuth2, one for the
    OAuth2 Client (which includes the OpenID Connect authentication piece and other
    necessary components) and one for Okta, since we’ll be using their infrastructure
    to authenticate and manage authorities, to `Aircraft Positions` ’s *pom.xml* Maven
    build file:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 更新现有的应用程序只需要更多的努力。因为我正在替换当前的基于表单的安全性，所以首先删除我在上一节中添加的 Spring Security 的现有依赖项。然后，我添加两个与
    Initializr 添加的相同的依赖项，一个是用于 OAuth2 客户端（包括 OpenID Connect 认证部分和其他必要组件），另一个是用于 Okta
    的依赖项，因为我们将使用他们的基础设施来认证和管理权限，到 `Aircraft Positions` 的 *pom.xml* Maven 构建文件中：
- en: '[PRE21]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-165
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The current included version of Okta’s Spring Boot Starter library is 1.4.0\.
    This is the version that has been tested and verified to work well with the current
    version of Spring Boot. When adding dependencies to a build file manually, a good
    practice for developers to make habit is to visit the [Spring Initializr](https://start.spring.io),
    select the current (at that time) version of Boot, add the Okta (or other specifically
    versioned) dependency, and *Explore* the project to confirm the current recommended
    version number.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当前包含的 Okta 的 Spring Boot Starter 库版本为 1.4.0\. 这是经过测试并与当前版本的 Spring Boot 良好配合的版本。当开发人员手动向构建文件添加依赖项时，一个好的实践习惯是访问
    [Spring Initializr](https://start.spring.io)，选择当前版本（当时的）的 Boot，添加 Okta（或其他具体版本）依赖项，并
    *探索* 项目以确认当前推荐的版本号。
- en: Once I refresh the build, it’s time to refactor the code to enable `Aircraft
    Positions` to authenticate with Okta and obtain user authorities.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦刷新构建，就是重构代码的时候了，使 `Aircraft Positions` 能够与 Okta 进行身份验证并获取用户权限。
- en: Refactoring Aircraft Positions for authentication and authorization
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重构 Aircraft Positions 以进行身份验证和授权
- en: 'There are really three things required to configure the current `Aircraft Positions`
    as an OAuth2 client app:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 配置当前 `Aircraft Positions` 作为 OAuth2 客户端应用程序实际上有三件事需要做：
- en: Remove the forms-based security configuration.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除基于表单的安全配置。
- en: Add OAuth2 configuration to the created `WebClient` used to access PlaneFinder
    endpoints.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在用于访问 PlaneFinder 端点的创建的 `WebClient` 中添加 OAuth2 配置。
- en: Specify OpenID Connect+OAuth2 registered client credentials and a URI for the
    security provider (in this case, Okta).
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定 OpenID Connect+OAuth2 注册的客户端凭据和安全提供者的 URI（在本例中为 Okta）。
- en: I tackle the first two together, beginning by removing the body of the `SecurityConfig`
    class in its entirety. If access control to resources provided locally by `Aircraft
    Positions` is still desired or required, `SecurityConfig` can of course remain
    as it is or with some slight modification; however, for this example, PlaneFinder
    fulfills the role of resource server and as such should control or deny access
    to requested resources of value. `Aircraft Positions` acts simply as a user client
    that works with security infrastructure to enable a user to authenticate, then
    passes requests for resources to resource server(s).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我首先一起处理前两者，首先完全删除 `SecurityConfig` 类的主体。如果仍希望或需要通过本地提供的 `Aircraft Positions`
    访问控制资源，则 `SecurityConfig` 当然可以保留原样或进行一些微小修改；但是，对于本示例，PlaneFinder 扮演资源服务器的角色，因此应控制或拒绝对请求资源的访问价值。
    `Aircraft Positions` 只是一个用户客户端，与安全基础设施合作，使用户能够进行身份验证，然后将资源请求传递给资源服务器。
- en: I replace the `@EnableWebSecurity` annotation with `@Configuration`, as the
    autoconfiguration for local authentication is no longer needed. Also gone is `extends
    WebSecurityConfigurerAdapter` from the class header, since this particular iteration
    of the `Aircraft Positions` application doesn’t restrict requests to its endpoints,
    instead passing the user’s authorities with requests to PlaneFinder so it can
    compare those authorities against those allowed for each resource and act accordingly.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我将`@EnableWebSecurity`注解替换为`@Configuration`，因为不再需要本地认证的自动配置。此外，从类头部删除了`extends
    WebSecurityConfigurerAdapter`，因为此版本的`Aircraft Positions`应用程序不再限制对其端点的请求，而是通过请求将用户的权限传递给PlaneFinder，使其可以将这些权限与每个资源允许的权限进行比较，并据此采取行动。
- en: 'Next, I create a `WebClient` bean within the `SecurityConfig` class for use
    throughout the `Aircraft Positions` application. This is not a hard requirement
    at this point, as I could simply incorporate the OAuth2 configuration into the
    creation of the `WebClient` assigned to the member variable within `PositionRetriever`,
    and there are valid arguments for doing so. That said, `PositionRetriever` needs
    access to a `WebClient`, but configuring the `WebClient` to handle OpenID Connect
    and OAuth2 configuration runs pretty far afield of the core mission of `PositionRetriever`:
    to retrieve aircraft positions.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`SecurityConfig`类中创建了一个`WebClient` bean，以在整个`Aircraft Positions`应用程序中使用。目前这不是硬性要求，因为我可以将OAuth2配置直接整合到分配给`PositionRetriever`成员变量的`WebClient`的创建中，而且这样做确实有其合理的理由。尽管如此，`PositionRetriever`需要访问一个`WebClient`，但是配置`WebClient`来处理OpenID
    Connect和OAuth2配置远超出了`PositionRetriever`的核心任务：检索飞机位置。
- en: 'Creating and configuring a `WebClient` for authentication and authorization
    fits very well within the scope of a class named `SecurityConfig`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为身份验证和授权创建和配置`WebClient`非常适合名为`SecurityConfig`的类的范围内：
- en: '[PRE22]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Two beans are autowired into the `client()` bean creation method:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在`client()` bean创建方法中，自动装配了两个bean：
- en: The `ClientRegistrationRepository`, a list of OAuth2 clients specified for use
    by the application, usually in a properties file like *application.yml*
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClientRegistrationRepository`，一个OAuth2客户端列表，由应用程序指定使用，通常在类似*application.yml*的属性文件中配置。'
- en: '`OAuth2AuthorizedClientRepository`, a list of OAuth2 clients that represent
    an authenticated user and manage that user’s `OAuth2AccessToken`'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OAuth2AuthorizedClientRepository`，一个OAuth2客户端列表，表示已认证用户并管理该用户的`OAuth2AccessToken`。'
- en: 'Within the method to create and configure the `WebClient` bean, I perform the
    following actions:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建和配置`WebClient` bean的方法内部，我执行以下操作：
- en: I initialize a filter function with the two injected repositories.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我使用两个注入的存储库初始化了一个过滤器函数。
- en: I confirm that the default authorized client should be used. This is typically
    the case—after all, the authenticated user is typically the resource owner who
    wishes to gain access to the resource—but optionally, a different authorized client
    could be desired for use cases involving delegated access. . I specify the URL
    and apply the filter configured for OAuth2 to the `WebClient` builder and build
    the `WebClient`, returning it as a Spring bean and adding it to the `ApplicationContext`.
    The OAuth2-enabled `WebClient` is now available for use throughout the `Aircraft
    Positions` application.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我确认应使用默认的授权客户端。这通常是情况——毕竟，已认证用户通常是希望访问资源的资源所有者——但是可以选择为涉及委派访问的用例使用不同的授权客户端。我指定URL并将配置为OAuth2的过滤器应用于`WebClient`构建器，并构建`WebClient`，将其作为Spring
    bean返回并添加到`ApplicationContext`。现在，启用了OAuth2的`WebClient`可以在整个`Aircraft Positions`应用程序中使用。
- en: 'Since the `WebClient` bean is now created by the application via a bean creation
    method, I now remove the statement creating and directly assigning a `WebClient`
    object to a member variable within the `PositionRetriever` class and replace it
    with a simple member variable declaration. With the Lombok `@AllArgsConstructor`
    annotation on the class, Lombok automatically adds a `WebClient` parameter to
    the “all arguments constructor” it generates for the class. Since a `WebClient`
    bean is available in the `ApplicationContext`, Spring Boot autowires it into `PositionRetriever`
    where it is assigned to the `WebClient` member variable automatically. The newly
    refactored `PositionRetriever` class now looks like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`WebClient` bean现在通过一个bean创建方法由应用程序创建，我现在移除了在`PositionRetriever`类中创建和直接分配`WebClient`对象的语句，并将其替换为一个简单的成员变量声明。使用Lombok的`@AllArgsConstructor`注解在类上，Lombok自动为该类生成的“所有参数构造函数”添加了一个`WebClient`参数。由于`ApplicationContext`中有一个`WebClient`
    bean，Spring Boot会自动将其注入到`PositionRetriever`中，并自动分配给`WebClient`成员变量。重新构造后的`PositionRetriever`类现在如下所示：
- en: '[PRE23]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Earlier in this section I mentioned the use of a `ClientRegistrationRepository`,
    a list of OAuth2 clients specified for use by the application. There are many
    ways to populate this repository, but entries are usually specified as application
    properties. In this example, I add the following information to `Aircraft Position`
    ’s *application.yml* file (dummy values shown here):'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的早些时候，我提到了`ClientRegistrationRepository`的使用，这是一个指定应用程序使用的OAuth2客户端列表。有多种方法可以填充此存储库，但通常是将条目指定为应用程序属性。在这个例子中，我将以下信息添加到`Aircraft
    Position`的*application.yml*文件中（这里显示了虚拟值）：
- en: '[PRE24]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: With that information in place, the `Aircraft Positions` application’s `ClientRegistrationRepository`
    will have a single entry for Okta that it will use automatically when a user attempts
    to access the application.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些信息，`Aircraft Positions`应用程序的`ClientRegistrationRepository`将有一个单独的Okta条目，在用户尝试访问该应用程序时将自动使用它。
- en: Tip
  id: totrans-189
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: If multiple entries are defined, a web page will be presented upon first request,
    prompting the user to choose a provider.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果定义了多个条目，将在第一次请求时呈现一个网页，提示用户选择一个提供程序。
- en: 'I make one other small change to `Aircraft Positions` (and a small downstream
    change to `PositionRetriever`), only to better demonstrate successful and unsuccessful
    user authorization. I replicate the sole endpoint currently defined in the `PositionController`
    class, rename it, and assign it a mapping implying “admin only” access:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我对`Aircraft Positions`做了另一个小改动（以及对`PositionRetriever`的一个小的下游改动），只是为了更好地演示成功和失败的用户授权。我复制了当前在`PositionController`类中定义的唯一端点，将其重命名，并分配一个映射，暗示“仅管理员”访问：
- en: '[PRE25]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To accommodate access to both PlaneFinder endpoints using a single method in
    `PositionRetriever`, I change its `retrieveAircraftPositions()` method to accept
    a dynamic path parameter `String endpoint` and use it when building the client
    request. The updated `PositionRetriever` class looks like this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适应使用单个方法访问PlaneFinder两个端点的需求，在`PositionRetriever`中，我将其`retrieveAircraftPositions()`方法修改为接受一个动态路径参数`String
    endpoint`，并在构建客户端请求时使用它。更新后的`PositionRetriever`类如下所示：
- en: '[PRE26]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`Aircraft Positions` is now a fully configured OpenID Connect and OAuth2 client
    application. Next, I refactor PlaneFinder to serve as an OAuth2 resource server,
    providing resources upon request to authorized users.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`Aircraft Positions`已经是一个完全配置的OpenID Connect和OAuth2客户端应用程序。接下来，我将重构PlaneFinder，使其成为一个OAuth2资源服务器，在用户授权时提供资源。
- en: PlaneFinder Resource Server
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PlaneFinder资源服务器
- en: With any refactoring involving a change of dependencies, the place to begin
    is with the build file.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何涉及更改依赖项的重构中，开始的地方是构建文件。
- en: Adding OpenID Connect and OAuth2 Dependencies to Aircraft Positions
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将OpenID Connect和OAuth2依赖项添加到Aircraft Positions
- en: As mentioned before, it’s easy to simply add another dependency or two via the
    Spring Initializr when creating a new Spring Boot OAuth2 resource server in a
    greenfield client application, as shown in [Figure 10-3](#dependencies_for_oauth2_resource_server_using_okta_within_spring_initializr).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前提到的，在创建新的Spring Boot OAuth2资源服务器时，可以通过Spring Initializr简单地添加另一个或两个依赖项到绿地客户端应用程序，如[图10-3](#dependencies_for_oauth2_resource_server_using_okta_within_spring_initializr)所示。
- en: '![sbur 1003](Images/sbur_1003.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![sbur 1003](Images/sbur_1003.png)'
- en: Figure 10-3\. Dependencies for OAuth2 Resource Server using Okta within Spring
    Initializr
  id: totrans-201
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10-3\. 使用Okta在Spring Initializr中的OAuth2资源服务器的依赖项
- en: 'Updating the existing PlaneFinder application is straightforward enough. I
    add the same two dependencies that Initializr adds for the OAuth2 Resource Server
    and for Okta, since we’ll be using their infrastructure to verify authorities,
    to PlaneFinder’s *pom.xml* Maven build file:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 更新现有的PlaneFinder应用程序非常简单。我在PlaneFinder的*pom.xml* Maven构建文件中添加了与Initializr添加的OAuth2资源服务器和Okta相同的两个依赖项，因为我们将使用它们的基础设施来验证权限。
- en: '[PRE27]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Once I refresh the build, it’s time to refactor the code to enable PlaneFinder
    to verify user authorities provided with inbound requests to verify user permissions
    and grant (or deny) access to PlaneFinder resources.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我刷新了构建，现在是时候重构代码，使PlaneFinder能够验证与入站请求提供的用户权限相匹配的用户权限，并授予（或拒绝）对PlaneFinder资源的访问。
- en: Refactoring PlaneFinder for resource authorization
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为资源授权重构PlaneFinder
- en: 'Much of the work to enable OpenID Connect and OAuth2 authentication and authorization
    using Okta for our distributed system has already been accomplished by this point.
    Refactoring PlaneFinder to correctly perform the duties of an OAuth2 resource
    server requires minimal effort:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，使用Okta为我们的分布式系统启用OpenID Connect和OAuth2身份验证和授权的大部分工作已经完成。正确重构PlaneFinder以执行OAuth2资源服务器的职责需要很少的工作：
- en: Incorporating JWT (JSON Web Token) support
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整合JWT（JSON Web Token）支持
- en: Comparing the authorities delivered within the JWTs (pronounced “jots”) to those
    required for access to designated resources
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将JWT中传递的权限与指定资源的访问所需权限进行比较
- en: Both of these tasks can be accomplished by creating a single `SecurityWebFilterChain`
    bean that Spring Security will use for retrieving, verifying, and comparing the
    contents of the inbound request’s JWT with required authorities.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个任务可以通过创建一个名为`SecurityWebFilterChain`的单一bean来完成，Spring Security将使用该bean来检索、验证和比较入站请求的JWT内容与所需权限。
- en: 'Once again I create a `SecurityConfig` class and annotate it with `@Configuration`
    to provide a distinct place for bean creation methods. Next, I create a `securityWebFilterChain()`
    method as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我创建一个`SecurityConfig`类，并使用`@Configuration`对其进行注释，以提供一个独立的位置用于bean创建方法。接下来，我创建一个名为`securityWebFilterChain()`的方法，如下所示：
- en: '[PRE28]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: To create the filter chain, I autowire the existing `ServerHttpSecurity` bean
    provided by Spring Boot’s security autoconfiguration. This bean is used with WebFlux-enabled
    applications, i.e., when `spring-boot-starter-webflux` is on the classpath.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建过滤器链，我自动装配了Spring Boot安全自动配置提供的现有`ServerHttpSecurity` bean。当`spring-boot-starter-webflux`在类路径中时，此bean用于支持WebFlux的应用程序。
- en: Note
  id: totrans-213
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Applications without WebFlux on the classpath would use the `HttpSecurity` bean
    and its corresponding methods instead, as was done in the forms-based authentication
    example earlier in this chapter.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类路径中没有WebFlux，则应用程序将使用`HttpSecurity` bean及其相应的方法，就像本章早些时候在基于表单的身份验证示例中所做的那样。
- en: Next, I configure the `ServerHttpSecurity` bean’s security criteria, specifying
    how requests should be handled. To do so, I provide two resource paths to match
    against requests and their required user authorities; I also enable OAuth2 resource
    server support using JWTs to bear the user information.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我配置`ServerHttpSecurity` bean的安全标准，指定如何处理请求。为此，我提供了两个资源路径以匹配请求及其所需的用户权限；我还启用了使用JWT作为OAuth2资源服务器支持的配置。
- en: Note
  id: totrans-216
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: JWTs are sometimes referred to as *bearer tokens* because they bear the user’s
    authorization for access to resources.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: JWT有时被称为*bearer tokens*，因为它们携带用户对资源的授权。
- en: Finally, I build the `SecurityWebFilterChain` from the `ServerHttpSecurity`
    bean and return it, making it available as a bean throughout the PlaneFinder application.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我从`ServerHttpSecurity` bean构建`SecurityWebFilterChain`，并将其返回，使其在整个PlaneFinder应用程序中作为一个bean可用。
- en: When a request arrives, the filter chain compares the requested resource’s path
    to paths specified in the chain until a match is found. Once a match is made,
    the application verifies the token validity with the OAuth2 provider—Okta, in
    this case—and then compares the contained authorities with those required for
    access to the mapped resources. If there is a valid match, access is granted;
    if not, the application returns a *403 Forbidden* status code.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求到达时，过滤器链将请求的资源路径与链中指定的路径进行比较，直到找到匹配项。一旦匹配成功，应用程序将使用OAuth2提供者（在此例中为Okta）验证令牌的有效性，然后比较包含的权限与访问映射资源所需的权限。如果匹配成功，则授予访问权限；如果不匹配，则应用程序返回*403
    Forbidden*状态码。
- en: You might have noticed that the second `pathMatcher` specifies a resource path
    that doesn’t (yet) exist in PlaneFinder. I add this path to the `PlaneController`
    class solely to be able to provide examples of both successful and failed authority
    checks.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到第二个`pathMatcher`指定了一个在PlaneFinder中尚不存在的资源路径。我将此路径添加到`PlaneController`类中，仅仅是为了能够提供成功和失败权限检查的示例。
- en: OAuth2 providers may include several default authorities, including *openid*,
    *email*, *profile*, and more. In the example filter chain, I check a nonexistent
    (for my provider and OAuth2 authority configuration) authority of *closedid*;
    consequently, any request for a resource with a path beginning with */aircraft*
    will fail. As currently written, any inbound request for resources beginning with
    a path of */aircraftadmin* and bearing a valid token will succeed.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth2提供程序可能包括几个默认权限，包括*openid*、*email*、*profile*等。在示例过滤器链中，我检查一个不存在的权限*closedid*（对于我的提供程序和OAuth2权限配置而言），因此任何请求资源路径以*/aircraft*开头的请求将失败。按目前的编写方式，对于路径以*/aircraftadmin*开头并携带有效令牌的任何入站请求将成功。
- en: Note
  id: totrans-222
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Spring Security prepends “SCOPE_” to OAuth2 provider-supplied authorities, mapping
    Spring Security’s internal concept of scopes 1:1 with OAuth2 authorities. For
    developers using Spring Security with OAuth2, this is important to be aware of
    but is a distinction without a practical difference.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security在OAuth2提供的权限之前添加“SCOPE_”，将Spring Security内部的作用域概念与OAuth2权限一对一映射。对于使用Spring
    Security与OAuth2的开发者来说，这一点很重要，但实际上没有实际的区别。
- en: 'To complete the code refactoring, I now add the */aircraftadmin* endpoint mapping
    referenced in the previous path matcher to PlaneFinder’s `PlaneController` class,
    simply copying the functionality of the existing */aircraft* endpoint in order
    to demonstrate two endpoints with different access criteria:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成代码重构，我现在在PlaneFinder的`PlaneController`类中添加了前面路径匹配引用的*/aircraftadmin*端点映射，简单地复制现有的*/aircraft*端点的功能，以演示具有不同访问条件的两个端点：
- en: '[PRE29]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Finally, I must indicate to the application where to go to access the OAuth2
    provider in order to validate the incoming JWTs. There may be variations in how
    this is done, as the specification for OAuth2 provider endpoints has some latitude,
    but Okta helpfully implements an issuer URI to act as a central URI for configuration
    from which other necessary URIs can be obtained. This reduces the burden on application
    developers to adding a single property.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我必须指示应用程序去哪里访问OAuth2提供程序，以验证传入的JWT。关于这个的操作可能会有所不同，因为OAuth2提供程序端点的规范具有一定的灵活性，但是Okta贴心地实现了一个发行者URI，作为一个配置的中心URI，从中可以获得其他必要的URI。这减少了应用开发者添加单个属性的负担。
- en: 'I’ve converted the *application.properties* file from a key-value pairs format
    to *application.yml*, allowing for a structured tree of properties, reducing repetition
    a bit. Note that this is optional but useful when duplication in property keys
    begins to manifest:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我已将*application.properties*文件从键值对格式转换为*application.yml*，允许属性的结构化树，稍微减少了重复。请注意，这是可选的，但在属性键中出现重复时非常有用：
- en: '[PRE30]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: With all elements now in place, I restart both the PlaneFinder OAuth2 resource
    server and the `Aircraft Positions` OpenID Connect + OAuth2 client application
    to verify the results. Loading the address for `Aircraft Positions` ’s */aircraftadmin*
    API endpoint (*http://localhost:8080/aircraftadmin*) in a browser, I’m redirected
    to Okta for authentication, as shown in [Figure 10-4](#login_prompt_provided_by_openid_connect_providder_okta).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有元素都已就位，我重新启动PlaneFinder OAuth2资源服务器和`Aircraft Positions` OpenID Connect
    + OAuth2客户端应用程序来验证结果。在浏览器中加载`Aircraft Positions`的*/aircraftadmin* API端点（*http://localhost:8080/aircraftadmin*），我被重定向到Okta进行身份验证，如[图 10-4](#login_prompt_provided_by_openid_connect_providder_okta)所示。
- en: '![sbur 1004](Images/sbur_1004.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![sbur 1004](Images/sbur_1004.png)'
- en: Figure 10-4\. Login prompt provided by OpenID Connect provider (Okta)
  id: totrans-231
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-4\. OpenID Connect提供程序提供的登录提示（Okta）
- en: Once I provide my valid user credentials, Okta redirects the authenticated user
    (me) to the client application, `Aircraft Positions`. The endpoint I requested
    in turn requests aircraft positions from PlaneFinder, passing along the JWT supplied
    to it by Okta. Once PlaneFinder matches the path requested to a resource path
    and verifies the JWT and its contained authorities, it responds with current aircraft
    positions to the `Aircraft Positions` client app, which in turn provides them
    to me, as shown in [Figure 10-5](#successful_return_current_aircraft_positions).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我提供有效的用户凭据，Okta将经过身份验证的用户（我）重定向到客户端应用程序`飞机位置`。我请求的端点进而从PlaneFinder请求飞机位置，并传递由Okta提供的JWT。一旦PlaneFinder将请求的路径匹配到资源路径并验证JWT及其包含的权限后，它将当前的飞机位置响应给`飞机位置`客户端应用程序，后者再将其提供给我，如图[10-5](#successful_return_current_aircraft_positions)所示。
- en: '![sbur 1005](Images/sbur_1005.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![sbur 1005](Images/sbur_1005.png)'
- en: Figure 10-5\. Successful return current aircraft positions
  id: totrans-234
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10-5\. 成功返回当前飞机位置
- en: What happens if I request a resource for which I have no authorization? To see
    an example of a failed authorization, I attempt to access `AircraftPosition` ’s
    */aircraft* endpoint at *http://localhost:8080/aircraft*, with the results shown
    in [Figure 10-6](#results_of_failed_authorization). Note that since I’ve already
    authenticated, I needn’t reauthenticate to continue accessing the `Aircraft Positions`
    application.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我请求一个没有授权的资源会发生什么？为了看到一个授权失败的例子，我试图访问`飞机位置`的*/aircraft*端点，网址为*http://localhost:8080/aircraft*，结果如图[10-6](#results_of_failed_authorization)所示。注意，由于我已经经过身份验证，因此无需重新认证即可继续访问`飞机位置`应用程序。
- en: '![sbur 1006](Images/sbur_1006.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![sbur 1006](Images/sbur_1006.png)'
- en: Figure 10-6\. Results of failed authorization
  id: totrans-237
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10-6\. 授权失败的结果
- en: 'Note that the response doesn’t provide much information regarding the failure
    to retrieve results. It is generally considered a good security practice to avoid
    leaking details that could provide potential hostile actors with information that
    is helpful toward an eventual compromise. Visiting the logs for `Aircraft Positions`,
    however, I see the following additional information:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，响应未提供有关无法检索结果的详细信息。通常认为，避免泄露可能为潜在的恶意行为者提供有助于最终妥协的信息是一个良好的安全实践。但是，访问`飞机位置`的日志，我看到了以下额外的信息：
- en: '[PRE31]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This is exactly the response expected, since PlaneFinder’s filter that matched
    requests for resources at or under */aircraft* expected the undefined authority
    *closedid*, which of course wasn’t supplied.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这恰好是预期的响应，因为PlaneFinder的过滤器匹配请求资源路径在或者低于*/aircraft*时预期的未定义权限*closedid*未提供。
- en: These examples were distilled to the maximum extent possible, but they represent
    the key aspects of OpenID Connect authentication and OAuth2 authorization using
    a respected third-party security provider. Everything else that can be done to
    customize and extend this type of authentication and authorization for Spring
    Boot applications builds upon these fundamental principles and steps.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例子被精简到最大限度，但它们代表了使用受尊敬的第三方安全提供者进行OpenID Connect认证和OAuth2授权的关键方面。其他所有定制和扩展此类认证和授权的方法都建立在这些基本原则和步骤之上，适用于Spring
    Boot应用程序。
- en: Code Checkout Checkup
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码检查
- en: For complete chapter code, please check out branch *chapter10end* from the code
    repository.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 欲获取完整的章节代码，请查看代码库的*chapter10end*分支。
- en: Summary
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: Understanding the concepts of authentication and authorization are critical
    to building secure applications, providing the foundations for user verification
    and access control. Spring Security combines options for authentication and authorization
    with other mechanisms like the HTTP Firewall, filter chains, extensive use of
    IETF and W3C standards and options for exchanges, and more to help lock down applications.
    Adopting a secure out-of-the-box mindset, Spring Security leverages Boot’s powerful
    autoconfiguration to evaluate developer inputs and available dependencies to deliver
    maximal security for Spring Boot applications with minimal effort.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 理解认证和授权的概念对于构建安全应用程序至关重要，这为用户验证和访问控制奠定了基础。Spring Security将认证和授权选项与HTTP防火墙、过滤器链、广泛使用的IETF和W3C标准以及交换选项等机制结合起来，帮助确保应用程序的安全性。采用安全开箱即用的理念，Spring
    Security利用Boot强大的自动配置来评估开发者的输入和可用依赖项，以尽量少的工作量提供Spring Boot应用程序的最大安全性。
- en: This chapter discussed several core aspects of security and how they apply to
    applications. I demonstrated multiple ways to incorporate Spring Security into
    Spring Boot apps to strengthen an application’s security posture, closing dangerous
    gaps in coverage and reducing attack surface area.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了安全的几个核心方面以及它们如何适用于应用程序。我演示了多种将Spring Security整合到Spring Boot应用程序中的方法，以加强应用程序的安全姿态，填补覆盖范围中的危险漏洞，并减少攻击面。
- en: The next chapter examines ways to deploy your Spring Boot application to various
    target destinations and discusses their relative merits. I also demonstrate how
    to create these deployment artifacts, provide options for their optimal execution,
    and show how to verify their components and provenance.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将探讨部署Spring Boot应用程序到各种目标位置的方法，并讨论它们的相对优点。我还将演示如何创建这些部署工件，提供它们的最佳执行选项，并展示如何验证它们的组件和来源。
