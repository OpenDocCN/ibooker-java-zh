- en: Chapter 10\. Securing Your Spring Boot Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding the concepts of authentication and authorization are critical
    to building secure applications, providing the foundations for user verification
    and access control. Spring Security combines options for authentication and authorization
    with other mechanisms like the HTTP Firewall, filter chains, extensive use of
    IETF and the World Wide Web Consortium (W3C) standards and options for exchanges,
    and more to help lock down applications. Adopting a secure out-of-the-box mindset,
    Spring Security leverages Boot’s powerful autoconfiguration to evaluate developer
    inputs and available dependencies to deliver maximal security for Spring Boot
    applications with minimal effort.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduces and explains core aspects of security and how they apply
    to applications. I demonstrate multiple ways to incorporate Spring Security into
    Spring Boot apps to strengthen an application’s security posture, closing dangerous
    gaps in coverage and reducing attack surface area.
  prefs: []
  type: TYPE_NORMAL
- en: Code Checkout Checkup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Please check out branch *chapter10begin* from the code repository to begin.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication and Authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often used together, the terms *authentication* and *authorization* are related
    but separate concerns.
  prefs: []
  type: TYPE_NORMAL
- en: authentication
  prefs: []
  type: TYPE_NORMAL
- en: An act, process, or method of showing something (such as an identity, a piece
    of art, or a financial transaction) to be real, true, or genuine; the act or process
    of authenticating something.
  prefs: []
  type: TYPE_NORMAL
- en: authorization
  prefs: []
  type: TYPE_NORMAL
- en: '1: the act of *authorizing* 2: an instrument that authorizes: SANCTION'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first definition for *authorization* points to *authorizing* for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: authorize
  prefs: []
  type: TYPE_NORMAL
- en: '1: to endorse, empower, justify, or permit by or as if by some recognized or
    proper authority (such as custom, evidence, personal right, or regulating power)
    a custom authorized by time 2: to invest especially with legal authority: EMPOWER
    3: archaic: JUSTIFY'
  prefs: []
  type: TYPE_NORMAL
- en: The definition for *authorize* in turn points to *justify* for more information.
  prefs: []
  type: TYPE_NORMAL
- en: While somewhat interesting, these definitions aren’t very clear. Sometimes the
    dictionary definitions can be less helpful than we might like. My own definitions
    follow.
  prefs: []
  type: TYPE_NORMAL
- en: authentication
  prefs: []
  type: TYPE_NORMAL
- en: Proving that someone is who they claim to be
  prefs: []
  type: TYPE_NORMAL
- en: authorization
  prefs: []
  type: TYPE_NORMAL
- en: Verifying that someone has access to a particular resource or operation
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Simply put, *authentication* is proving that someone (or something) is who (or
    what, in the case of a device, application, or service) they claim to be.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of authentication has several concrete examples in the physical
    world. If you’ve ever had to show a form of ID like an employee badge, driver’s
    license, or passport to prove your identity, you have been authenticated. Demonstrating
    that one is who one claims to be is a procedure to which we’ve all grown accustomed
    in a variety of situations, and the conceptual differences between authentication
    at the physical level and to an application are insignificant.
  prefs: []
  type: TYPE_NORMAL
- en: 'Authentication typically involves one or more of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Something you are
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Something you know
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Something you have
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: These three *factors* can be used individually or combined to compose Multi-Factor
    Authentication (MFA).
  prefs: []
  type: TYPE_NORMAL
- en: The manner in which authentication occurs in the physical and virtual worlds
    is of course different. Rather than a human being eyeing a photo ID and comparing
    it to your current physical appearance as often happens in the physical world,
    authenticating to an application often involves typing a password, inserting a
    security key, or providing biometric data (iris scan, fingerprint, etc.) that
    can be more easily evaluated by software than is currently feasible with a comparison
    of physical appearance with a photo. Nevertheless, a comparison of stored data
    with provided data is performed in both cases, and a match provides a positive
    authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once a person is authenticated, they have the possibility of gaining access
    to resources available and/or operations permitted to one or more individuals.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this context, an individual may (and most likely is) a human being, but the
    same concept and access considerations apply to applications, services, devices,
    and more, depending on context.
  prefs: []
  type: TYPE_NORMAL
- en: Once an individual’s identity is proven, that individual gains some general
    level of access to an application. From there, the now-authenticated application
    user can request access to something. The application then must somehow determine
    if the user is allowed, i.e., *authorized*, to access that resource. If so, access
    is granted to the user; if not, the user is notified that their lack of *authority*
    has resulted in their request being rejected.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Security in a Nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to providing solid options for authentication and authorization,
    Spring Security provides several other mechanisms to help developers lock down
    their Spring Boot applications. Thanks to autoconfiguration, Spring Boot applications
    enable each applicable Spring Security feature with an eye toward maximum possible
    security with the information provided, or even owing to the lack of more specific
    guidance. Security capabilities can of course be adjusted or relaxed by developers
    as necessary to accommodate their organizations’ specific requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Security’s capabilities are far too numerous to detail exhaustively in
    this chapter, but there are three key features I consider essential to understanding
    the Spring Security model and its foundations. They are the HTTP Firewall, security
    filter chains, and Spring Security’s extensive use of IETF and W3C standards and
    options for requests and corresponding responses.
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP Firewall
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While exact numbers are difficult to obtain, many security compromises begin
    with a request using a malformed URI and a system’s unexpected response to it.
    This is really an application’s first line of defense, and as such, it is the
    problem that should be solved prior to considering further efforts to secure one’s
    application(s).
  prefs: []
  type: TYPE_NORMAL
- en: Since version 5.0, Spring Security has included a built-in HTTP Firewall that
    scrutinizes all inbound requests for problematic formatting. If there are any
    problems with a request, such as bad header values or incorrect formatting, the
    request is discarded. Unless overridden by the developer, the default implementation
    used is the aptly named `StrictHttpFirewall`, quickly closing the first and potentially
    easiest gap to exploit within an application’s security profile.
  prefs: []
  type: TYPE_NORMAL
- en: Security Filter Chains
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Providing a more specific, next-level filter for inbound requests, Spring Security
    uses filter chains to process properly formed requests that make it past the HTTP
    Firewall.
  prefs: []
  type: TYPE_NORMAL
- en: Simply put, for most applications a developer specifies a chain of filter conditions
    through which an inbound request passes until it matches one. When a request matches
    a filter, its corresponding conditions are evaluated to determine if the request
    will be fulfilled. For example, if a request for a particular API endpoint arrives
    and matches a filter condition in the filter chain, the user who made the request
    may be checked to verify they have the proper role/authority to access the requested
    resource. If so, the request is processed; if not, it is rejected, usually with
    a *403 Forbidden* status code.
  prefs: []
  type: TYPE_NORMAL
- en: If a request passes through all defined filters in the chain without matching
    any, the request is discarded.
  prefs: []
  type: TYPE_NORMAL
- en: Request and Response Headers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The IETF and W3C have created a number of specifications and standards for HTTP-based
    exchanges, several of which relate to the secure exchange of information. There
    are several headers defined for interactions between user agents—command line
    utilities, web browsers, etc.—and server or cloud-based applications/services.
    These headers are used to request or signal specific behavior and have defined
    allowed values and behavioral responses, and Spring Security makes extensive use
    of these header details to strengthen your Spring Boot application’s security
    posture.
  prefs: []
  type: TYPE_NORMAL
- en: Realizing it’s true that different user agents may support some or all of these
    standards and specifications, and even then fully or partially, Spring Security
    embraces a best-possible-coverage approach by checking for all known header options
    and applying them across the board, looking for them in requests and supplying
    them in responses, as applicable.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Forms-Based Authentication and Authorization with Spring Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Innumerable applications that use the “something you know” method of authentication
    are used every day. Whether for apps internal to an organization, web applications
    provided directly to consumers via the internet, or apps native to a mobile device,
    typing in a user ID and password is a familiar routine for developers and non-developers
    alike. And in most of those cases, the security this provides is more than sufficient
    for the task at hand.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Security provides Spring Boot applications with superb out-of-the-box
    (OOTB) support for password authentication via autoconfiguration and easy-to-grasp
    abstractions. This section demonstrates the various stepping-off points by refactoring
    the `Aircraft Positions` application to incorporate forms-based authentication
    using Spring Security.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Spring Security Dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When creating a new Spring Boot project, it’s a simple matter to add one more
    dependency via the Spring Initializr—that of *Spring Security*—and to enable a
    top-tier level of security without additional configuration to a fledgling app,
    as shown in [Figure 10-1](#spring_security_dependency_within_spring_initializr).
  prefs: []
  type: TYPE_NORMAL
- en: '![sbur 1001](Images/sbur_1001.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-1\. Spring Security dependency within Spring Initializr
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Updating an existing application is only slightly less simple. I’ll add the
    same two complementary dependencies that Initializr adds, one for Spring Security
    itself and one for testing it, to `Aircraft Positions` ’s *pom.xml* Maven build
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: With Spring Security on the classpath and no code or configuration changes to
    the application, I restart `Aircraft Positions` for a quick functionality check.
    This provides a great opportunity to see what Spring Security does on a developer’s
    behalf OOTB.
  prefs: []
  type: TYPE_NORMAL
- en: 'With both PlaneFinder and `Aircraft Positions` running, I return to the terminal
    and again exercise `Aircraft Positions` ’s */aircraft* endpoint, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Some response headers have been removed for clarity.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, I no longer have access to the */aircraft* endpoint, receiving
    a *401 Unauthorized* response to my request. Since the */aircraft* endpoint is
    currently the only means of accessing information from the `Aircraft Positions`
    application, this effectively means the application is secured in its entirety
    from unwanted access. This is great news, but it’s important to understand both
    how this happened and how to restore desired access for valid users.
  prefs: []
  type: TYPE_NORMAL
- en: As I mentioned earlier, Spring Security adopts a mindset of “secure by default”
    to the extent possible at every level of configuration—even zero configuration—by
    the developer employing it in a Spring Boot application. When Spring Boot finds
    Spring Security on the classpath, security is configured using sensible defaults.
    Even with no user(s) defined or password(s) specified or any other effort made
    by the developer, the inclusion of Spring Security in the project indicates a
    goal of a secure application.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can imagine, this is very little to go on. But Spring Boot+Security
    autoconfiguration creates a number of essential beans to implement basic security
    capabilities based on forms authentication and user authorization using user IDs
    and passwords. The next questions to quite reasonably flow from that logical assumption
    are these: What user(s)? What password(s)?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returning to the startup log for the `Aircraft Positions` application, one
    can find the answer to one of those questions in this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If no user ID(s) and password(s) are specified in the application or no means
    are provided to access them by other means, a security-enabled Spring Boot app
    defaults to a single user account `user` with a unique password that is generated
    anew each time the application is started. Returning to the terminal window, I
    try to access the application once again, this time with the provided credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As before, some response headers have been removed for clarity.
  prefs: []
  type: TYPE_NORMAL
- en: Using the correct default user ID and the generated password, I receive a *200
    OK* response and once again have access to the */aircraft* endpoint, and thus
    the `Aircraft Positions` application.
  prefs: []
  type: TYPE_NORMAL
- en: Returning to the `Aircraft Positions` application, there are a few concerns
    with the current state of application security. First among them is that by having
    only a single defined user, multiple individuals that need to access the application
    must all use that single account. This is antithetical to the security principle
    of accountability and even authentication, as no single individual uniquely proves
    they are who they say they are. Returning to accountability, how can one determine
    who committed or contributed to a breach if one occurs? Not to mention that if
    a breach were to occur, locking the only user account would disable access for
    all users; there is currently no way to avoid it.
  prefs: []
  type: TYPE_NORMAL
- en: A secondary concern with the existing security configuration is the way the
    single password is handled. With each application startup, a new password is automatically
    generated, which must then be shared with all users. And while application scaling
    hasn’t yet been discussed, each instance of `Aircraft Positions` that is started
    will generate a unique password, requiring that particular password from a user
    attempting to log into that particular app instance. Clearly some improvements
    can and should be made.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Spring Security employs the concept of a `UserDetailsService` as the centerpiece
    of its authentication capability. `UserDetailsService` is an interface with a
    single method `loadUserByUsername(String username)` that (when implemented) returns
    an object that fulfills the `UserDetails` interface, from which can be obtained
    key information such as the user’s name, password, authorities granted to the
    user, and account status. This flexibility allows for numerous implementations
    using various technologies; as long as a `UserDetailsService` returns `UserDetails`,
    the application doesn’t need to be aware of underlying implementation details.
  prefs: []
  type: TYPE_NORMAL
- en: To create a `UserDetailsService` bean, I create a configuration class in which
    to define a bean creation method.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, I create a class called `SecurityConfig` and annotate it with `@Configuration`
    to enable Spring Boot to find and execute bean creation methods within. The bean
    necessary for authentication is one that implements the `UserDetailsService` interface,
    so I create a method `authentication()` to create and return that bean. Here is
    a first, intentionally incomplete pass at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Within the `UserDetailService` `authentication()` method, I create two application
    objects that implement the `UserDetails` interface requirements using the `User`
    class’s `builder()` method and specifying username, password, and roles/authorities
    the user possesses. I then `build()` these users and assign each of them to a
    local variable.
  prefs: []
  type: TYPE_NORMAL
- en: Next, I display the passwords *for demonstration purposes only*. This helps
    to demonstrate another concept in this chapter but is *for demonstration purposes
    only*.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Logging passwords is an antipattern of the worst kind. Never log passwords in
    production applications.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, I create an `InMemoryUserDetailsManager` using the two created `User`
    objects and return it as a Spring bean. An `InMemoryUserDetailsManager` implements
    interfaces `UserDetailsManager` and `UserDetailsPasswordService`, enabling user
    management tasks like determining if a particular user exists; creating, updating,
    and deleting the user; and changing/updating the user’s password. I use `InMemoryUserDetailsManager`
    for its clarity in demonstrating the concept (due to no external dependencies),
    but any bean that implements the `UserDetailsService` interface can be provided
    as the authentication bean.
  prefs: []
  type: TYPE_NORMAL
- en: 'Restarting `Aircraft Positions`, I attempt to authenticate and retrieve a list
    of current aircraft positions, with the following results (some headers removed
    for brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This prompts a bit of troubleshooting. Returning to the IDE, there is a helpful
    bit of information in the stack trace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This provides a hint at the root of the problem. Examining the logged passwords
    (kind reminder: logging passwords is *for demonstration purposes only*) provides
    confirmation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Clearly* these passwords are in plain text, with no encoding whatsoever being
    performed. The next step toward working and secure authentication is to add a
    password encoder for use within the `SecurityConfig` class, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: One of the challenges of creating and maintaining secure applications is that,
    of necessity, security is ever evolving. Recognizing this, Spring Security doesn’t
    simply have a designated encoder it plugs in; rather, it uses a factory with several
    available encoders and delegates to one for encoding and decoding chores.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this means that one must serve as a default in the event one isn’t
    specified, as in the previous example. Currently *BCrypt* is the (excellent) default,
    but the flexible, delegated nature of Spring Security’s encoder architecture is
    such that one encoder can be replaced easily by another as standards evolve and/or
    requirements change. The elegance of this approach allows for a frictionless migration
    of credentials from one encoder to another when an application user logs into
    the application, again reducing tasks that don’t directly provide value to an
    organization but are nevertheless critical to perform in a correct and timely
    manner.
  prefs: []
  type: TYPE_NORMAL
- en: Now that I have an encoder in place, the next step is to use it to encrypt the
    user passwords. This is done very simply by plugging in a call to the password
    encoder’s `encode()` method, passing the plain text password and receiving in
    return the encrypted result.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Technically speaking, encrypting a value also encodes that value, but all encoders
    do not encrypt. For example, hashing encodes a value but does not necessarily
    encrypt it. That said, every encoding algorithm supported by Spring Security also
    encrypts; to support legacy applications, however, some supported algorithms are
    far less secure than others. Always choose a current recommended Spring Security
    encoder or opt for the default one provided by `PasswordEncoderFactories.createDelegatingPasswordEncoder()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The revised, authenticating version of the `SecurityConfig` class follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'I restart `Aircraft Positions`, then attempt once again to authenticate and
    retrieve a list of current aircraft positions with the following results (some
    headers and results removed for brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: These results confirm that authentication is now successful (an intentional
    failing scenario using an incorrect password is omitted due to space considerations)
    and valid users can once again access the exposed API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returning to examine the logged, and now encoded, passwords, I note values
    similar to the following in the IDE’s output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The logged values confirm that both example passwords specified in the code
    have been encoded successfully by the delegated password encoder using *BCrypt*.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Aircraft Positions` application now successfully authenticates users and
    allows only said users to access its exposed API. There is a rather large issue
    with the current security configuration, though: access to any part of the API
    means access to all of it, regardless of roles/authority the user possesses—or
    more accurately, regardless of roles *not* possessed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a very simple example of this security flaw, I add another endpoint to `Aircraft
    Position` ’s API by cloning, renaming, and remapping the existing `getCurrentAircraftPositions()`
    method in the `PositionController` class as a second endpoint. Once complete,
    `PositionController` appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The goal is to allow only users having the “ADMIN” role access to the second
    method, `getCurrentAircraftPositionsAdminPrivs()`. While in this version of this
    example the values returned are identical to those returned by the `getCurrentAircraftPositions()`,
    this will likely not remain the case as the application expands, and the concept
    applies regardless.
  prefs: []
  type: TYPE_NORMAL
- en: 'Restarting the `Aircraft Positions` application and returning to the command
    line, I login first as user Jodie to verify access to the new endpoint, as expected
    (first endpoint access confirmed but omitted due to space; some headers and results
    also omitted for brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, I log in as Peter. Peter should not have access to the `getCurrentAircraftPositionsAdminPrivs()`
    method, mapped to */aircraftadmin*. But that isn’t the case; currently Peter—an
    authenticated user—can access everything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: To enable the `Aircraft Positions` application to not simply authenticate users
    but also to check user authorization to access particular resources, I refactor
    `SecurityConfig` to perform that task.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to replace the class-level annotation `@Configuration` with
    `@EnableWebSecurity`. `@EnableWebSecurity` is a meta-annotation that includes
    the removed `@Configuration`, still allowing for bean creation methods within
    the annotated class; but it also includes the `@EnableGlobalAuthentication` annotation
    that enables a great deal more security autoconfiguration to be done by Spring
    Boot for the application. This positions `Aircraft Positions` well for the next
    step of defining the authorization mechanism itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'I refactor the `SecurityConfig` class to extend `WebSecurityConfigurerAdapter`,
    an abstract class with numerous member variables and methods useful for extending
    the basic configuration of an application’s web security. In particular, `WebSecurityConfigurerAdapter`
    has a `configure(HttpSecurity http)` method that provides a basic implementation
    for user authorization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding implementation, the following directives are issued:'
  prefs: []
  type: TYPE_NORMAL
- en: Authorize any request from an authenticated user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple login and logout forms (overridable ones created by the developer) will
    be provided.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP Basic Authentication is enabled for nonbrowser user agents (command line
    tools, for example).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This provides a reasonable security posture if no authorization specifics are
    supplied by the developer. The next step is to provide more specifics and thus
    override this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'I use IntelliJ for Mac’s `CTRL+O` keyboard shortcut or click the right mouse
    button and then Generate to open the Generate menu, then select the Override methods…
    option to display overridable/implementable methods. Selecting the method with
    signature `configure(http:HttpSecurity):void` produces the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'I then replace the call to the superclass’s method with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This implementation of the `configure(HttpSecurity http)` method performs the
    following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Using a `String` pattern matcher, the request path is compared for a match with
    */aircraftadmin* and all paths below.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the match is successful, the user is authorized to make the request if the
    user has the “ADMIN” role/authority.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any other request is fulfilled for any authenticated user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple login and logout forms (overridable ones created by the developer) will
    be provided
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP Basic Authentication is enabled for nonbrowser user agents (command line
    tools, etc.).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This minimal authorization mechanism places two filters in the security filter
    chain: one to check for a path match and admin privileges and one for all other
    paths and an authenticated user. A tiered approach allows for complex scenarios
    to be captured in fairly simple, easy-to-reason-about logic.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The final version (for forms-based security) of the `SecurityConfig` class
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now to confirm that all works as intended. I restart the `Aircraft Positions`
    application and access the */aircraftadmin* endpoint as Jodie from the command
    line (first endpoint access confirmed but omitted due to space; some headers and
    results also omitted for brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Jodie is able to access the */aircraftadmin* endpoint as expected owing to
    having the “ADMIN” role. Next, I try using Peter’s login. Note that the first
    endpoint access was confirmed but omitted due to space; some headers were also
    omitted for brevity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This is exactly what should have occurred, since Peter only has the “USER” role
    and not “ADMIN.” The system works.
  prefs: []
  type: TYPE_NORMAL
- en: Code Checkout Checkup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Please check out branch *chapter10forms* from the code repository for a complete
    forms-based example.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing OpenID Connect and OAuth2 for Authentication and Authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While forms-based authentication and internal authorization is useful for a
    large number of applications, numerous use cases exist in which “something you
    know” methods of authentication are less than ideal or even insufficient for the
    desired or required level of security. Some examples include but are not limited
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Free services that require authentication but that don’t need to know anything
    about the user (or don’t want to know, for legal or other reasons)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Situations in which single-factor authentication isn’t considered secure enough,
    desiring and/or requiring Multi-Factor Authentication (MFA) support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concerns about creating and maintaining secure software infrastructure for managing
    passwords, roles/authorities, and other necessary mechanisms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concerns over liability in the event of compromise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is no simple answer to any of these concerns or goals, but several companies
    have built and maintain robust and secure infrastructure assets for authentication
    and authorization and offer it for general use at low or no cost. Companies like
    Okta, a leading security vendor, and others whose businesses require proven user
    validation and permissions verification: Facebook, GitHub, and Google, to name
    a few. Spring Security supports all of these options and more via OpenID Connect
    and OAuth2.'
  prefs: []
  type: TYPE_NORMAL
- en: 'OAuth2 was created to provide a means for third-party authorization of users
    for specified resources, such as cloud-based services, shared storage, and applications.
    OpenID Connect builds on OAuth2 to add consistent, standardized authentication
    using one or more factors from the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Something you know, for example, a password
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Something you have, like a hardware key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Something you are, such as a biometric identifier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Boot and Spring Security support autoconfiguration out of the box for
    OpenID Connect and OAuth2 implementations offered by Facebook, GitHub, Google,
    and Okta, with additional providers easily configurable due to the published standards
    for OpenID Connect and OAuth2 and Spring Security’s extensible architecture. I
    use Okta’s libraries and authentication+authorization mechanisms for the examples
    that follow, but differences between providers are mostly variations on a theme.
    Feel free to use the security provider that best suits your needs.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, I refactor `Aircraft Positions` to serve as an OpenID Connect
    and OAuth2 client application, working with Okta’s capabilities to validate the
    user and obtain the user’s authorities to access resources exposed by a resource
    server. I then refactor PlaneFinder to provide its resources—as an OAuth2 resource
    server—based on credentials supplied with requests from the `Aircraft Positions`
    (client) application.
  prefs: []
  type: TYPE_NORMAL
- en: Aircraft Positions Client Application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I typically begin with the application farthest back in the stack, but in this
    case, I believe the opposite approach has more merit due to the flows associated
    with a user gaining (or being denied) access to a resource.
  prefs: []
  type: TYPE_NORMAL
- en: A user accesses a client application that uses some mechanism to authenticate
    them. Once authenticated, user requests for resources are relayed to so-called
    resource servers that hold and manage said resources. This is a logical flow that
    most of us follow repeatedly and find very familiar. By enabling security in the
    same order—client, then resource server—it neatly aligns with our own, expected
    flow.
  prefs: []
  type: TYPE_NORMAL
- en: Adding OpenID Connect and OAuth2 dependencies to Aircraft Positions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As with forms-based security, it’s simple to add additional dependencies via
    the Spring Initializr when creating a new Spring Boot client project to get started
    with OpenID Connect and OAuth2 in a greenfield client application, as shown in
    [Figure 10-2](#dependencies_for_openid_connect_and_oauth2_client_application_using_okta_within_spring_initializr).
  prefs: []
  type: TYPE_NORMAL
- en: '![sbur 1002](Images/sbur_1002.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-2\. Dependencies for OpenID Connect and OAuth2 Client application
    using Okta within Spring Initializr
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Updating an existing application requires only a bit more effort. Since I’m
    replacing the current forms-based security, I first remove the existing dependency
    for Spring Security that I added in the previous section. Then I add the same
    two dependencies that Initializr adds for OpenID Connect and OAuth2, one for the
    OAuth2 Client (which includes the OpenID Connect authentication piece and other
    necessary components) and one for Okta, since we’ll be using their infrastructure
    to authenticate and manage authorities, to `Aircraft Positions` ’s *pom.xml* Maven
    build file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The current included version of Okta’s Spring Boot Starter library is 1.4.0\.
    This is the version that has been tested and verified to work well with the current
    version of Spring Boot. When adding dependencies to a build file manually, a good
    practice for developers to make habit is to visit the [Spring Initializr](https://start.spring.io),
    select the current (at that time) version of Boot, add the Okta (or other specifically
    versioned) dependency, and *Explore* the project to confirm the current recommended
    version number.
  prefs: []
  type: TYPE_NORMAL
- en: Once I refresh the build, it’s time to refactor the code to enable `Aircraft
    Positions` to authenticate with Okta and obtain user authorities.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring Aircraft Positions for authentication and authorization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are really three things required to configure the current `Aircraft Positions`
    as an OAuth2 client app:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove the forms-based security configuration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add OAuth2 configuration to the created `WebClient` used to access PlaneFinder
    endpoints.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specify OpenID Connect+OAuth2 registered client credentials and a URI for the
    security provider (in this case, Okta).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I tackle the first two together, beginning by removing the body of the `SecurityConfig`
    class in its entirety. If access control to resources provided locally by `Aircraft
    Positions` is still desired or required, `SecurityConfig` can of course remain
    as it is or with some slight modification; however, for this example, PlaneFinder
    fulfills the role of resource server and as such should control or deny access
    to requested resources of value. `Aircraft Positions` acts simply as a user client
    that works with security infrastructure to enable a user to authenticate, then
    passes requests for resources to resource server(s).
  prefs: []
  type: TYPE_NORMAL
- en: I replace the `@EnableWebSecurity` annotation with `@Configuration`, as the
    autoconfiguration for local authentication is no longer needed. Also gone is `extends
    WebSecurityConfigurerAdapter` from the class header, since this particular iteration
    of the `Aircraft Positions` application doesn’t restrict requests to its endpoints,
    instead passing the user’s authorities with requests to PlaneFinder so it can
    compare those authorities against those allowed for each resource and act accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, I create a `WebClient` bean within the `SecurityConfig` class for use
    throughout the `Aircraft Positions` application. This is not a hard requirement
    at this point, as I could simply incorporate the OAuth2 configuration into the
    creation of the `WebClient` assigned to the member variable within `PositionRetriever`,
    and there are valid arguments for doing so. That said, `PositionRetriever` needs
    access to a `WebClient`, but configuring the `WebClient` to handle OpenID Connect
    and OAuth2 configuration runs pretty far afield of the core mission of `PositionRetriever`:
    to retrieve aircraft positions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating and configuring a `WebClient` for authentication and authorization
    fits very well within the scope of a class named `SecurityConfig`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Two beans are autowired into the `client()` bean creation method:'
  prefs: []
  type: TYPE_NORMAL
- en: The `ClientRegistrationRepository`, a list of OAuth2 clients specified for use
    by the application, usually in a properties file like *application.yml*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OAuth2AuthorizedClientRepository`, a list of OAuth2 clients that represent
    an authenticated user and manage that user’s `OAuth2AccessToken`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Within the method to create and configure the `WebClient` bean, I perform the
    following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: I initialize a filter function with the two injected repositories.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I confirm that the default authorized client should be used. This is typically
    the case—after all, the authenticated user is typically the resource owner who
    wishes to gain access to the resource—but optionally, a different authorized client
    could be desired for use cases involving delegated access. . I specify the URL
    and apply the filter configured for OAuth2 to the `WebClient` builder and build
    the `WebClient`, returning it as a Spring bean and adding it to the `ApplicationContext`.
    The OAuth2-enabled `WebClient` is now available for use throughout the `Aircraft
    Positions` application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Since the `WebClient` bean is now created by the application via a bean creation
    method, I now remove the statement creating and directly assigning a `WebClient`
    object to a member variable within the `PositionRetriever` class and replace it
    with a simple member variable declaration. With the Lombok `@AllArgsConstructor`
    annotation on the class, Lombok automatically adds a `WebClient` parameter to
    the “all arguments constructor” it generates for the class. Since a `WebClient`
    bean is available in the `ApplicationContext`, Spring Boot autowires it into `PositionRetriever`
    where it is assigned to the `WebClient` member variable automatically. The newly
    refactored `PositionRetriever` class now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier in this section I mentioned the use of a `ClientRegistrationRepository`,
    a list of OAuth2 clients specified for use by the application. There are many
    ways to populate this repository, but entries are usually specified as application
    properties. In this example, I add the following information to `Aircraft Position`
    ’s *application.yml* file (dummy values shown here):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: With that information in place, the `Aircraft Positions` application’s `ClientRegistrationRepository`
    will have a single entry for Okta that it will use automatically when a user attempts
    to access the application.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If multiple entries are defined, a web page will be presented upon first request,
    prompting the user to choose a provider.
  prefs: []
  type: TYPE_NORMAL
- en: 'I make one other small change to `Aircraft Positions` (and a small downstream
    change to `PositionRetriever`), only to better demonstrate successful and unsuccessful
    user authorization. I replicate the sole endpoint currently defined in the `PositionController`
    class, rename it, and assign it a mapping implying “admin only” access:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To accommodate access to both PlaneFinder endpoints using a single method in
    `PositionRetriever`, I change its `retrieveAircraftPositions()` method to accept
    a dynamic path parameter `String endpoint` and use it when building the client
    request. The updated `PositionRetriever` class looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '`Aircraft Positions` is now a fully configured OpenID Connect and OAuth2 client
    application. Next, I refactor PlaneFinder to serve as an OAuth2 resource server,
    providing resources upon request to authorized users.'
  prefs: []
  type: TYPE_NORMAL
- en: PlaneFinder Resource Server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With any refactoring involving a change of dependencies, the place to begin
    is with the build file.
  prefs: []
  type: TYPE_NORMAL
- en: Adding OpenID Connect and OAuth2 Dependencies to Aircraft Positions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned before, it’s easy to simply add another dependency or two via the
    Spring Initializr when creating a new Spring Boot OAuth2 resource server in a
    greenfield client application, as shown in [Figure 10-3](#dependencies_for_oauth2_resource_server_using_okta_within_spring_initializr).
  prefs: []
  type: TYPE_NORMAL
- en: '![sbur 1003](Images/sbur_1003.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-3\. Dependencies for OAuth2 Resource Server using Okta within Spring
    Initializr
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Updating the existing PlaneFinder application is straightforward enough. I
    add the same two dependencies that Initializr adds for the OAuth2 Resource Server
    and for Okta, since we’ll be using their infrastructure to verify authorities,
    to PlaneFinder’s *pom.xml* Maven build file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Once I refresh the build, it’s time to refactor the code to enable PlaneFinder
    to verify user authorities provided with inbound requests to verify user permissions
    and grant (or deny) access to PlaneFinder resources.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring PlaneFinder for resource authorization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Much of the work to enable OpenID Connect and OAuth2 authentication and authorization
    using Okta for our distributed system has already been accomplished by this point.
    Refactoring PlaneFinder to correctly perform the duties of an OAuth2 resource
    server requires minimal effort:'
  prefs: []
  type: TYPE_NORMAL
- en: Incorporating JWT (JSON Web Token) support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing the authorities delivered within the JWTs (pronounced “jots”) to those
    required for access to designated resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both of these tasks can be accomplished by creating a single `SecurityWebFilterChain`
    bean that Spring Security will use for retrieving, verifying, and comparing the
    contents of the inbound request’s JWT with required authorities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again I create a `SecurityConfig` class and annotate it with `@Configuration`
    to provide a distinct place for bean creation methods. Next, I create a `securityWebFilterChain()`
    method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: To create the filter chain, I autowire the existing `ServerHttpSecurity` bean
    provided by Spring Boot’s security autoconfiguration. This bean is used with WebFlux-enabled
    applications, i.e., when `spring-boot-starter-webflux` is on the classpath.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Applications without WebFlux on the classpath would use the `HttpSecurity` bean
    and its corresponding methods instead, as was done in the forms-based authentication
    example earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Next, I configure the `ServerHttpSecurity` bean’s security criteria, specifying
    how requests should be handled. To do so, I provide two resource paths to match
    against requests and their required user authorities; I also enable OAuth2 resource
    server support using JWTs to bear the user information.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: JWTs are sometimes referred to as *bearer tokens* because they bear the user’s
    authorization for access to resources.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, I build the `SecurityWebFilterChain` from the `ServerHttpSecurity`
    bean and return it, making it available as a bean throughout the PlaneFinder application.
  prefs: []
  type: TYPE_NORMAL
- en: When a request arrives, the filter chain compares the requested resource’s path
    to paths specified in the chain until a match is found. Once a match is made,
    the application verifies the token validity with the OAuth2 provider—Okta, in
    this case—and then compares the contained authorities with those required for
    access to the mapped resources. If there is a valid match, access is granted;
    if not, the application returns a *403 Forbidden* status code.
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that the second `pathMatcher` specifies a resource path
    that doesn’t (yet) exist in PlaneFinder. I add this path to the `PlaneController`
    class solely to be able to provide examples of both successful and failed authority
    checks.
  prefs: []
  type: TYPE_NORMAL
- en: OAuth2 providers may include several default authorities, including *openid*,
    *email*, *profile*, and more. In the example filter chain, I check a nonexistent
    (for my provider and OAuth2 authority configuration) authority of *closedid*;
    consequently, any request for a resource with a path beginning with */aircraft*
    will fail. As currently written, any inbound request for resources beginning with
    a path of */aircraftadmin* and bearing a valid token will succeed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Spring Security prepends “SCOPE_” to OAuth2 provider-supplied authorities, mapping
    Spring Security’s internal concept of scopes 1:1 with OAuth2 authorities. For
    developers using Spring Security with OAuth2, this is important to be aware of
    but is a distinction without a practical difference.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete the code refactoring, I now add the */aircraftadmin* endpoint mapping
    referenced in the previous path matcher to PlaneFinder’s `PlaneController` class,
    simply copying the functionality of the existing */aircraft* endpoint in order
    to demonstrate two endpoints with different access criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Finally, I must indicate to the application where to go to access the OAuth2
    provider in order to validate the incoming JWTs. There may be variations in how
    this is done, as the specification for OAuth2 provider endpoints has some latitude,
    but Okta helpfully implements an issuer URI to act as a central URI for configuration
    from which other necessary URIs can be obtained. This reduces the burden on application
    developers to adding a single property.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ve converted the *application.properties* file from a key-value pairs format
    to *application.yml*, allowing for a structured tree of properties, reducing repetition
    a bit. Note that this is optional but useful when duplication in property keys
    begins to manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: With all elements now in place, I restart both the PlaneFinder OAuth2 resource
    server and the `Aircraft Positions` OpenID Connect + OAuth2 client application
    to verify the results. Loading the address for `Aircraft Positions` ’s */aircraftadmin*
    API endpoint (*http://localhost:8080/aircraftadmin*) in a browser, I’m redirected
    to Okta for authentication, as shown in [Figure 10-4](#login_prompt_provided_by_openid_connect_providder_okta).
  prefs: []
  type: TYPE_NORMAL
- en: '![sbur 1004](Images/sbur_1004.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-4\. Login prompt provided by OpenID Connect provider (Okta)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Once I provide my valid user credentials, Okta redirects the authenticated user
    (me) to the client application, `Aircraft Positions`. The endpoint I requested
    in turn requests aircraft positions from PlaneFinder, passing along the JWT supplied
    to it by Okta. Once PlaneFinder matches the path requested to a resource path
    and verifies the JWT and its contained authorities, it responds with current aircraft
    positions to the `Aircraft Positions` client app, which in turn provides them
    to me, as shown in [Figure 10-5](#successful_return_current_aircraft_positions).
  prefs: []
  type: TYPE_NORMAL
- en: '![sbur 1005](Images/sbur_1005.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-5\. Successful return current aircraft positions
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: What happens if I request a resource for which I have no authorization? To see
    an example of a failed authorization, I attempt to access `AircraftPosition` ’s
    */aircraft* endpoint at *http://localhost:8080/aircraft*, with the results shown
    in [Figure 10-6](#results_of_failed_authorization). Note that since I’ve already
    authenticated, I needn’t reauthenticate to continue accessing the `Aircraft Positions`
    application.
  prefs: []
  type: TYPE_NORMAL
- en: '![sbur 1006](Images/sbur_1006.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-6\. Results of failed authorization
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Note that the response doesn’t provide much information regarding the failure
    to retrieve results. It is generally considered a good security practice to avoid
    leaking details that could provide potential hostile actors with information that
    is helpful toward an eventual compromise. Visiting the logs for `Aircraft Positions`,
    however, I see the following additional information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This is exactly the response expected, since PlaneFinder’s filter that matched
    requests for resources at or under */aircraft* expected the undefined authority
    *closedid*, which of course wasn’t supplied.
  prefs: []
  type: TYPE_NORMAL
- en: These examples were distilled to the maximum extent possible, but they represent
    the key aspects of OpenID Connect authentication and OAuth2 authorization using
    a respected third-party security provider. Everything else that can be done to
    customize and extend this type of authentication and authorization for Spring
    Boot applications builds upon these fundamental principles and steps.
  prefs: []
  type: TYPE_NORMAL
- en: Code Checkout Checkup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For complete chapter code, please check out branch *chapter10end* from the code
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding the concepts of authentication and authorization are critical
    to building secure applications, providing the foundations for user verification
    and access control. Spring Security combines options for authentication and authorization
    with other mechanisms like the HTTP Firewall, filter chains, extensive use of
    IETF and W3C standards and options for exchanges, and more to help lock down applications.
    Adopting a secure out-of-the-box mindset, Spring Security leverages Boot’s powerful
    autoconfiguration to evaluate developer inputs and available dependencies to deliver
    maximal security for Spring Boot applications with minimal effort.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter discussed several core aspects of security and how they apply to
    applications. I demonstrated multiple ways to incorporate Spring Security into
    Spring Boot apps to strengthen an application’s security posture, closing dangerous
    gaps in coverage and reducing attack surface area.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter examines ways to deploy your Spring Boot application to various
    target destinations and discusses their relative merits. I also demonstrate how
    to create these deployment artifacts, provide options for their optimal execution,
    and show how to verify their components and provenance.
  prefs: []
  type: TYPE_NORMAL
