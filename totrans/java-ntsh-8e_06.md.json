["```java\npublic void manipulate(Circle circle) {\n    circle = new Circle(3);\n}\n\nCircle c = new Circle(2);\nSystem.out.println(\"Radius: \"+ c.getRadius());\nmanipulate(c);\nSystem.out.println(\"Radius: \"+ c.getRadius());\n```", "```java\n// This class represents a circle with immutable position and radius.\npublic class Circle implements Comparable<Circle> {\n    // These fields hold the coordinates of the center and the radius.\n    // They are private for data encapsulation and final for immutability\n    private final int x, y, r;\n\n    // The basic constructor: initialize the fields to specified values\n    public Circle(int x, int y, int r) {\n        if (r < 0) throw new IllegalArgumentException(\"negative radius\");\n        this.x = x; this.y = y; this.r = r;\n    }\n\n    // This is a \"copy constructor\"--a useful alternative to clone()\n    public Circle(Circle original) {\n        x = original.x;   // Just copy the fields from the original\n        y = original.y;\n        r = original.r;\n    }\n\n    // Public accessor methods for the private fields.\n    // These are part of data encapsulation.\n    public int getX() { return x; }\n    public int getY() { return y; }\n    public int getR() { return r; }\n\n    // Return a string representation\n    @Override public String toString() {\n        return String.format(\"center=(%d,%d); radius=%d\", x, y, r);\n    }\n\n    // Test for equality with another object\n    @Override public boolean equals(Object o) {\n        // Identical references?\n        if (o == this) return true;\n        // Correct type and non-null?\n        if (!(o instanceof Circle)) return false;\n        Circle that = (Circle) o;                 // Cast to our type\n        if (this.x == that.x && this.y == that.y && this.r == that.r)\n            return true;                          // If all fields match\n        else\n            return false;                         // If fields differ\n    }\n\n    // A hash code allows an object to be used in a hash table.\n    // Equal objects must have equal hash codes.  Unequal objects are\n    // allowed to have equal hash codes, but we try to avoid that.\n    // We must override this method because we also override equals().\n    @Override public int hashCode() {\n        int result = 17;          // This hash code algorithm from\n        result = 37*result + x;   // Effective Java, by Joshua Bloch\n        result = 37*result + y;\n        result = 37*result + r;\n        return result;\n    }\n\n    // This method is defined by the Comparable interface. Compare\n    // this Circle to that Circle.  Return a value < 0 if this < that\n    // Return 0 if this == that. Return a value > 0 if this > that.\n    // Circles are ordered top to bottom, left to right, then by radius\n    public int compareTo(Circle that) {\n        // Smaller circles have bigger y\n        long result = (long)that.y - this.y;\n        // If same compare l-to-r\n        if (result==0) result = (long)this.x - that.x;\n        // If same compare radius\n        if (result==0) result = (long)this.r - that.r;\n\n        // We have to use a long value for subtraction because the\n        // differences between a large positive and large negative\n        // value could overflow an int. But we can't return the long,\n        // so return its sign as an int.\n        return Long.signum(result);\n    }\n}\n```", "```java\nCircle original = new Circle(1, 2, 3);  // regular constructor\nCircle copy = new Circle(original);     // copy constructor\n```", "```java\npublic class Circle {\n  // This is a generally useful constant, so we keep it public\n  public static final double PI = 3.14159;\n\n  protected double r;     // State inheritance via a protected field\n\n  // A method to enforce the restriction on the radius\n  protected void checkRadius(double radius) {\n    if (radius < 0.0)\n      throw new IllegalArgumentException(\"radius may not < 0\");\n  }\n\n  // The non-default constructor\n  public Circle(double r) {\n    checkRadius(r);\n    this.r = r;\n  }\n\n  // Public data accessor methods\n  public double getRadius() { return r; }\n  public void setRadius(double r) {\n    checkRadius(r);\n    this.r = r;\n  }\n\n  // Methods to operate on the instance field\n  public double area() { return PI * r * r; }\n  public double circumference() { return 2 * PI * r; }\n}\n\npublic class PlaneCircle extends Circle {\n  // We automatically inherit the fields and methods of Circle,\n  // so we only have to put the new stuff here.\n  // New instance fields that store the center point of the circle\n  private final double cx, cy;\n\n  // A new constructor to initialize the new fields\n  // It uses a special syntax to invoke the Circle() constructor\n  public PlaneCircle(double r, double x, double y) {\n    super(r);       // Invoke the constructor of the superclass\n    this.cx = x;    // Initialize the instance field cx\n    this.cy = y;    // Initialize the instance field cy\n  }\n\n  public double getCenterX() {\n    return cx;\n  }\n\n  public double getCenterY() {\n    return cy;\n  }\n\n  // The area() and circumference() methods are inherited from Circle\n  // A new instance method that checks whether a point is inside the\n  // circle; note that it uses the inherited instance field r\n  public boolean isInside(double x, double y) {\n    double dx = x - cx, dy = y - cy;\n    // Pythagorean theorem\n    double distance = Math.sqrt(dx*dx + dy*dy);\n    return (distance < r);                   // Returns true or false\n  }\n}\n```", "```java\npublic class PlaneCircle extends Circle {\n  // Rest of class is the same as above; the field r in\n  // the superclass Circle can be made private because\n  // we no longer access it directly here\n\n  // Note that we now use the accessor method getRadius()\n  public boolean isInside(double x, double y) {\n    double dx = x - cx, dy = y - cy;            // Distance to center\n    double distance = Math.sqrt(dx*dx + dy*dy); // Pythagorean theorem\n    return (distance < getRadius());\n  }\n}\n```", "```java\npublic class Singleton {\n  private final static Singleton instance = new Singleton();\n  private static boolean initialized = false;\n\n  // Constructor\n  private Singleton() {\n    super();\n  }\n\n  private void init() {\n    /* Do initialization */\n  }\n\n  // This method should be the only way to get a reference\n  // to the instance\n  public static synchronized Singleton getInstance() {\n    if (initialized) return instance;\n    instance.init();\n    initialized = true;\n    return instance;\n  }\n}\n```", "```java\npublic final class Circle implements Comparable<Circle> {\n    private final int x, y, r;\n\n    // Main constructor\n    private Circle(int x, int y, int r) {\n        if (r < 0) throw new IllegalArgumentException(\"radius < 0\");\n        this.x = x; this.y = y; this.r = r;\n    }\n\n    // Usual factory method\n    public static Circle of(int x, int y, int r) {\n        return new Circle(x, y, r);\n    }\n\n    // Factory method playing the role of the copy constructor\n    public static Circle of(Circle original) {\n        return new Circle(original.x, original.y, original.r);\n    }\n\n    // Third factory with intent given by name\n    public static Circle ofOrigin(int r) {\n        return new Circle(0, 0, r);\n    }\n\n    // other methods elided\n}\n```", "```java\n// Generic builder interface\npublic interface Builder<T> {\n    T build();\n}\n\npublic class BCircle {\n    private final int x, y, r;\n\n    // The main constructor is now private\n    private BCircle(CircleBuilder cb) {\n        if (cb.r < 0)\n        throw new IllegalArgumentException(\"negative radius\");\n        this.x = cb.x; this.y = cb.y; this.r = cb.r;\n    }\n\n    public static class CircleBuilder implements Builder<BCircle> {\n        private int x = 0, y = 0, r = 0;\n\n        public CircleBuilder x(int x) {\n            this.x = x;\n            return this;\n        }\n\n        public int x() {\n            return x;\n        }\n\n        // Similarly for y and r\n\n        @Override\n        public BCircle build() {\n            return new BCircle(this);\n        }\n    }\n\n    // Other methods elided\n}\n```", "```java\nvar cb = new BCircle.CircleBuilder();\ncb.x(1).y(2).r(3);\nvar circle = cb.build();\n```", "```java\n// Here is a basic interface. It represents a shape that fits inside\n// of a rectangular bounding box. Any class that wants to serve as a\n// RectangularShape can implement these methods from scratch.\npublic interface RectangularShape {\n    void setSize(double width, double height);\n    void setPosition(double x, double y);\n    void translate(double dx, double dy);\n    double area();\n    boolean isInside();\n}\n\n// Here is a partial implementation of that interface. Many\n// implementations may find this a useful starting point.\npublic abstract class AbstractRectangularShape\n                        implements RectangularShape {\n    // The position and size of the shape\n    protected double x, y, w, h;\n\n    // Default implementations of some of the interface methods\n    public void setSize(double width, double height) {\n     w = width; h = height;\n    }\n    public void setPosition(double x, double y) {\n     this.x = x; this.y = y;\n    }\n    public void translate (double dx, double dy) { x += dx; y += dy; }\n}\n```", "```java\npublic interface IntFunc {\n    int apply(int x);\n\n    default IntFunc compose(IntFunc before) {\n        return (int y) -> apply(before.apply(y));\n    }\n\n    default IntFunc andThen(IntFunc after) {\n        return (int z) -> after.apply(apply(z));\n    }\n\n    static IntFunc id() {\n        return x -> x;\n    }\n}\n```", "```java\nRunnable r = () -> System.out.println(\"Hello World\");\n```", "```java\nList<Person> persons = ... // derived from somewhere\ndouble aveAge = persons.stream()\n        .mapToDouble(o -> o.getAge())\n        .reduce(0, (x, y) -> x + y ) / persons.size();\n```", "```java\npublic class IntOps {\n    private Map<String, BinaryOperator> table =\n        Map.of(\"add\", IntOps::add, \"subtract\", IntOps::sub);\n\n    private static int add(int x, int y) {\n        return x + y;\n    }\n\n    private static int sub(int x, int y) {\n        return x - y;\n    }\n\n    public int eval(String op, int x, int y) {\n        return table.get(op).apply(x, y);\n    }\n}\n```", "```java\n// Note the absence of a permits clause\npublic abstract sealed class Shape {\n\n    public static final class Circle extends Shape {\n        // ...\n    }\n\n    public static final class Rectangle extends Shape {\n        // ...\n    }\n}\n```", "```java\nvar temp = switch(season) {\n    case WINTER -> 2.0;\n    case SPRING -> 10.5;\n    case SUMMER -> 24.5;\n    case AUTUMN -> 16.0;\n};\nSystem.out.println(\"Average temp: \"+ temp);\n```", "```java\nShape shape = ...\n\nif (shape instanceof Shape.Circle c) {\n    System.out.println(\"Circle: \"+ c.circumference());\n} else if (shape instanceof Shape.Rectangle r) {\n    System.out.println(\"Rectangle: \"+ r.circumference());\n}\n```", "```java\npublic record Circle(int x, int y, int r) {\n    // Primary (compact) constructor\n    public Circle {\n        // Validation code in the constructor\n        // This would be impossible in a tuple\n        if (r < 0) {\n            throw new IllegalArgumentException(\"negative radius\");\n        }\n    }\n\n    // Factory method playing the role of the copy constructor\n    public static Circle of(Circle original) {\n        return new Circle(original.x, original.y, original.r);\n    }\n}\n```", "```java\nsealed interface Order permits BasicOrder, ExpressOrder {\n    double price();\n    String address();\n    LocalDate delivery();\n}\n```", "```java\npublic record BasicOrder(double price,\n                         String address,\n                         LocalDate delivery) implements Order {}\n\npublic record ExpressOrder(double price,\n                           String address,\n                           LocalDate delivery,\n                           double deliveryCharge) implements Order {}\n```", "```java\npublic static double area(double r) { return PI * r * r; }\n```", "```java\n// Compare the implicit \"this\" circle to the \"that\" circle passed\n// explicitly as an argument and return the bigger one.\npublic Circle bigger(Circle that) {\n  if (this.r > that.r) return this;\n  else return that;\n}\n```", "```java\n// Compare circles a and b and return the one with the larger radius\npublic static Circle bigger(Circle a, Circle b) {\n  if (a.r > b.r) return a;\n  else return b;\n}\n```", "```java\n// Instance method: also y.bigger(x)\nCircle biggest = x.bigger(y);\nCircle biggest = Circle.bigger(x, y);  // Static method\n```", "```java\npublic interface Employee {\n  void work();\n}\n\npublic class Programmer implements Employee {\n  public void work() { /* program computer */ }\n}\n\npublic class Manager implements Employee {\n  private Employee report;\n\n  public Manager(Employee staff) {\n    report = staff;\n  }\n\n  public Employee setReport(Employee staff) {\n    report = staff;\n  }\n\n  public void work() {\n    report.work();\n  }\n}\n```", "```java\n// The basic interface for our burritos\ninterface Burrito {\n  double getPrice();\n}\n\n// Concrete implementation-standard size burrito\npublic class StandardBurrito implements Burrito {\n  private static final double BASE_PRICE = 5.99;\n\n  public double getPrice() {\n    return BASE_PRICE;\n  }\n}\n\n// Larger, super-size burrito\npublic class SuperBurrito implements Burrito {\n  private static final double BASE_PRICE = 6.99;\n\n  public double getPrice() {\n    return BASE_PRICE;\n  }\n}\n```", "```java\n/*\n * This class is the Decorator for Burrito. It represents optional\n * extras that the burrito may or may not have.\n */\npublic abstract class BurritoOptionalExtra implements Burrito {\n    private final Burrito burrito;\n    private final double price;\n\n    protected BurritoOptionalExtra(Burrito toDecorate,\n          double myPrice) {\n        burrito = toDecorate;\n        price = myPrice;\n    }\n\n    public final double getPrice() {\n        return (burrito.getPrice() + price);\n    }\n}\n```", "```java\nBurrito lunch = new Jalapeno(new Guacamole(new SuperBurrito()));\n// The overall cost of the burrito is the expected $8.09.\nSystem.out.println(\"Lunch cost: \"+ lunch.getPrice());\n```", "```java\n// Never just swallow an exception\ntry {\n  someMethodThatMightThrow();\n} catch(Exception e){\n}\n\n// Never catch, log, and rethrow an exception\ntry {\n  someMethodThatMightThrow();\n} catch(SpecificException e){\n  log(e);\n  throw e;\n}\n```"]