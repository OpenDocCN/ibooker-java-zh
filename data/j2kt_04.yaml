- en: Chapter 4\. Optional to Nullable
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章：Optional to Nullable
- en: Tony Hoare may consider the invention of null references his billion dollar
    mistake,^([1](ch04.html#idm46393409336056)) but we still need to represent the
    absence of things in our software systems. How can we use Kotlin to embrace null
    while still having safe software?
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 托尼·霍尔（Tony Hoare）可能认为空引用的发明是他的十亿美元错误[^1]，但在软件系统中我们仍然需要表示缺失的事物。我们如何利用Kotlin在保持软件安全的同时接纳空值呢？
- en: Representing Absence
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表示缺失
- en: Perhaps Kotlin’s most attractive feature for Java programmers is its representation
    of nullability in the type system. This is another area where the grains of Java
    and Kotlin are different.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Java程序员来说，Kotlin最具吸引力的特性之一可能是其在类型系统中对空值的表示。这是Java和Kotlin的另一个不同的领域。
- en: Prior to Java 8, Java relied on convention, documentation, and intuition to
    distinguish between references that could or could not be null. We can deduce
    that methods that return an item from a collection must be able to return `null`,
    but can `addressLine3` be `null`, or do we use an empty string when there is no
    information?
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 8之前，Java依赖于约定、文档和直觉来区分可以为null或不可以为null的引用。我们可以推断从集合中返回项的方法必须能够返回`null`，但`addressLine3`可以为`null`吗？或者在没有信息时我们使用空字符串？
- en: Over the years, your authors and their colleagues settled into a convention
    where Java references are assumed to be nonnull unless otherwise flagged. So we
    might name a field `addressLine3OrNull`, or a method `previousAddressOrNull`.
    Within a codebase, this works well enough (even if it is a little verbose, and
    requires eternal vigilance to avoid the scourge of `NullPointerException`s).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，您的作者及其同事们已经形成了一个惯例，假设Java引用在未做特殊标记时为非null。因此，我们可能会将字段命名为`addressLine3OrNull`，或者方法命名为`previousAddressOrNull`。在代码库中，这效果还不错（即使有点啰嗦，并需要永久警惕以避免`NullPointerException`的瘟疫）。
- en: Some codebases opted to use `@Nullable` and `@NotNullable` annotations instead,
    often supported by tools that would check for correctness. Java 8, released in
    2014, enhanced support for annotations to the extent that tools like the [Checker
    Framework](https://oreil.ly/qGYlH) could statically check much more than just
    null safety. More crucially, though, Java 8 also introduced a standard `Optional`
    type.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 一些代码库选择使用`@Nullable`和`@NotNullable`注解，通常由检查工具支持，以确保正确性。2014年发布的Java 8加强了对注解的支持，使得像[Checker
    Framework](https://oreil.ly/qGYlH)这样的工具可以静态检查不仅仅是空指针安全。然而更重要的是，Java 8还引入了标准的`Optional`类型。
- en: By this time, many JVM developers had dabbled in Scala. They came to appreciate
    the advantages of using an *Optional* type (named `Option` in Scala’s standard
    library) when absence was possible, and plain references when it was not. Oracle
    muddied the waters by telling developers not to use its `Optional` for field or
    parameter values, but as with many features introduced in Java 8, it was good
    enough and was adopted into the mainstream usage of Java.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到了这个时候，许多JVM开发者已经涉猎过Scala。他们开始欣赏在可能缺失时使用*Optional*类型（在Scala的标准库中称为`Option`），以及在不可能缺失时使用普通引用的优势。Oracle混淆了局势，告诉开发者不要将其`Optional`用于字段或参数值，但和Java
    8引入的许多功能一样，它已经足够好，并被广泛应用于Java的主流使用中。
- en: Depending on its age, your Java code may use some or all of these strategies
    for dealing with absence. It is certainly possible to have a codebase in which
    `Null⁠Pointer​Excep⁠tion`s are practically never seen, but the reality is that
    this is hard work. Java is weighed down by null and embarrassed by its halfhearted
    `Optional` type.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 根据其年龄，您的Java代码可能会使用某些或所有这些策略来处理缺失。在一个几乎从未见到`Null⁠Pointer​Excep⁠tion`的代码库中是完全可能的，但现实情况是这需要大量的工作。Java受空指针的困扰，并因其半吊子的`Optional`类型而感到尴尬。
- en: 'In contrast, Kotlin *embraces* null. Making optionality part of the type system
    rather than the standard library means that Kotlin codebases have refreshing uniformity
    in their treatment of missing values. It isn’t all perfect: `Map<K, V>.get(key)`
    returns `null` if there is no value for `key`; but `List<T>.get(index)` throws
    `IndexOutOfBoundsException` when there is no value at `index`. Likewise, `Iterable<T>.first()`
    throws `No⁠Such​Ele⁠ment⁠Exception` rather than returning `null`. Such imperfections
    are generally caused by the desire for backward compatibility with Java.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，Kotlin *拥抱* null。将选项性作为类型系统的一部分，而不是标准库的一部分，意味着 Kotlin 代码库在处理缺失值时具有令人耳目一新的统一性。并非一切都完美：如果
    `Map<K, V>.get(key)` 没有找到 `key` 的值，会返回 `null`；但是 `List<T>.get(index)` 在索引 `index`
    没有值时会抛出 `IndexOutOfBoundsException`。同样，`Iterable<T>.first()` 在没有元素时会抛出 `NoSuchElementException`
    而不是返回 `null`。这些不完美通常是为了与 Java 的向后兼容性而设计的。
- en: Where Kotlin has its own APIs, they are generally good examples of how to safely
    use null to represent optional properties, parameters, and return values, and
    we can learn a lot from studying them. After you’ve experienced first-class nullability,
    returning to languages without this support feels unsafe; you are acutely aware
    that you are always only a dereference away from a `NullPointerException`, and
    that you’re relying on convention to find the safe path through the minefield.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 拥有自己的 API 的地方，它们通常是安全使用 null 表示可选属性、参数和返回值的好例子，我们可以通过学习它们来学到很多。一旦体验了一流的空安全性，回到不支持此功能的语言会感觉不安全；你清楚地意识到，只需一次解引用操作就可能引发
    `NullPointerException`，而且你在依赖约定来找到安全路径时。
- en: Functional programmers may advise you to use an optional (also known as *Maybe*)
    type rather than nullability in Kotlin. We counsel against this, even though it
    will give you the option to use the same (monadic—there, we said it) tools to
    represent potential absence, errors, asynchrony, and so on. One reason not to
    use `Optional` in Kotlin is that you will lose access to the language features
    designed specifically to support nullability; in this area the grain of Kotlin
    is different from the grain of, say, Scala.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式程序员可能建议你在 Kotlin 中使用可选类型（也称为 *Maybe*），而不是空安全性。我们建议不要这样做，尽管它会给你提供使用相同（单子化的—是的，我们说了）工具来表示可能的缺失、错误、异步等选项。在
    Kotlin 中不使用 `Optional` 的一个原因是你将失去专门设计支持空安全性的语言特性；在这方面，Kotlin 的粒度与 Scala 等语言是不同的。
- en: 'Another reason not to use a wrapper type to represent optionality is subtle
    but important. In the Kotlin type system, `T` is a subtype of `T?`. If you have
    a `String` that cannot be null, you can always use it where a nullable `String`
    is required. In contrast, `T` is not a subtype of `Optional<T>`. If you have a
    `String` and want to assign it to an optional variable, you first have to wrap
    it in an `Optional`. Worse, if you have a function that returns an `Optional<String>`
    and later discover a way to always return a result, changing the return type to
    `String` will break all your clients. Had your return type been the nullable `String?`,
    you could have strengthened it to `String` while maintaining compatibility. The
    same applies to properties of data structures: you can easily migrate from optional
    to nonoptional with nullability—but not, ironically, with `Optional`.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 不使用包装类型来表示可选性的另一个理由是微妙但重要的。在 Kotlin 类型系统中，`T` 是 `T?` 的子类型。如果你有一个不能为 null 的 `String`，你可以随时将其用在需要可空
    `String` 的地方。相比之下，`T` 不是 `Optional<T>` 的子类型。如果你有一个返回 `Optional<String>` 的函数，并且后来发现总是返回结果，将返回类型更改为
    `String` 将会打破所有客户端的兼容性。如果返回类型是可空的 `String?`，你可以在保持兼容性的同时将其强化为 `String`。同样的情况也适用于数据结构的属性：你可以轻松地从可选的转变为非可选的，但具有讽刺意味的是，使用
    `Optional` 则不行。
- en: Your authors love Kotlin’s support for nullability, and have learned to lean
    on it to solve many problems. It takes a while to wean yourself off of avoiding
    nulls, but once you have, there is literally a whole new dimension of expressiveness
    to explore and exploit.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你们的作者们喜爱 Kotlin 对空安全的支持，并学会依赖它来解决许多问题。摆脱避免 null 的习惯需要一段时间，但一旦做到了，就可以探索和利用全新的表达方式。
- en: It seems a shame not to have that facility in Travelator, so let’s look at how
    to migrate from Java code using `Optional`, to Kotlin and nullable.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Travelator 中没有这种便利似乎是一种遗憾，所以让我们看看如何从使用 `Optional` 的 Java 代码迁移到 Kotlin 和可空类型。
- en: Refactoring from Optional to Nullable
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构：从 Optional 到 Nullable
- en: 'Travelator trips are divided into `Leg`s, where each `Leg` is an unbroken journey.
    Here is one of the utility functions we’ve found in the code:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Travelator 旅行被分成`Leg`，其中每个`Leg`是一次不间断的旅程。这是我们在代码中找到的其中一个实用函数：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[Example 4.1 [nullability.0:src/main/java/travelator/Legs.java]](https://java-to-kotlin.dev/code.html?ref=4.1&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=4.1&show=diff)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 4.1 [nullability.0:src/main/java/travelator/Legs.java]](https://java-to-kotlin.dev/code.html?ref=4.1&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=4.1&show=diff)'
- en: 'The tests check that the code works as intended, and allow us to see its behavior
    at a glance:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 测试检查代码是否按预期工作，并允许我们一目了然地看到其行为：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[Example 4.2 [nullability.0:src/test/java/travelator/LongestLegOverTests.java]](https://java-to-kotlin.dev/code.html?ref=4.2&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=4.2&show=diff)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 4.2 [nullability.0:src/test/java/travelator/LongestLegOverTests.java]](https://java-to-kotlin.dev/code.html?ref=4.2&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=4.2&show=diff)'
- en: 'Let’s see what we can do to make things better in Kotlin. Converting `Legs.java`
    to Kotlin gives us this (after a little reformatting):'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们能做些什么来让 Kotlin 变得更好。将`Legs.java`转换为 Kotlin，我们得到了这个（稍作重新格式化后）：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[Example 4.3 [nullability.3:src/main/java/travelator/Legs.kt]](https://java-to-kotlin.dev/code.html?ref=4.3&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=4.3&show=diff)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 4.3 [nullability.3:src/main/java/travelator/Legs.kt]](https://java-to-kotlin.dev/code.html?ref=4.3&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=4.3&show=diff)'
- en: The method parameters are as we might expect, with Kotlin `List<Leg>` transparently
    accepting a `java.util.List`. (We examine Java and Kotlin collections more in
    [Chapter 6](ch06.html#java-to-kotlin-collections).) It’s worth mentioning here
    that when a Kotlin function declares a nonnullable parameter (`legs` and `duration`
    here), the compiler inserts a null check before the function body. That way, if
    Java callers sneak in a `null`, we’ll know straightaway. Because of these defensive
    checks, Kotlin detects unexpected nulls as close as possible to their source,
    in contrast to Java, where a reference can be set to `null` a long way in time
    and space from where it finally explodes.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 方法参数与我们预期的一样，Kotlin 的`List<Leg>`会透明地接受一个`java.util.List`。（我们在[第6章](ch06.html#java-to-kotlin-collections)中更详细地讨论了
    Java 和 Kotlin 集合。）值得在这里提到的是，当 Kotlin 函数声明一个非空参数（这里是`legs`和`duration`）时，编译器会在函数体之前插入一个空检查。这样，如果
    Java 调用者偷偷传入一个`null`，我们会立即知道。由于这些防御性检查，Kotlin 会尽可能地检测到意外的空值，与 Java 相反，在 Java 中，一个引用可以在很长一段时间和空间内设置为`null`，直到最终爆炸的地方。
- en: Returning to the example, the Kotlin `for` loop is very similar to Java’s, except
    for the use of the `in` keyword rather than `:`, and similarly applies to any
    type that extends `Iterable`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 回到例子，Kotlin 的`for`循环与 Java 的非常相似，除了使用`in`关键字而不是`:`，并且同样适用于任何扩展`Iterable`的类型。
- en: 'The converted `findLongestLegOver` code is not very idiomatic Kotlin. (Arguably,
    since the introduction of streams, it isn’t very idiomatic Java either.) Instead
    of a `for` loop, we should look for something more intention revealing, but let’s
    park that for now because our primary mission is to migrate from `Optional` to
    nullable. We’ll illustrate that by converting our tests one by one, so that we
    have a mix, as we would in a codebase that we were migrating. To make use of nullability
    in our clients, they have to be Kotlin, so let’s convert the tests:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 转换后的`findLongestLegOver`代码在 Kotlin 中不太符合惯用法。（可以说，自从引入了流之后，它在 Java 中也不太符合惯用法。）我们应该寻找一些更具表意性的东西来替代`for`循环，但是让我们暂时搁置这个问题，因为我们的主要任务是从`Optional`迁移到可空类型。我们将通过逐个转换测试来说明这一点，这样我们就会有一个混合体，就像我们要迁移的代码库中一样。为了在客户端利用可空性，它们必须是
    Kotlin，所以让我们转换测试：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[Example 4.4 [nullability.4:src/test/java/travelator/LongestLegOverTests.kt]](https://java-to-kotlin.dev/code.html?ref=4.4&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=4.4&show=diff)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 4.4 [nullability.4:src/test/java/travelator/LongestLegOverTests.kt]](https://java-to-kotlin.dev/code.html?ref=4.4&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=4.4&show=diff)'
- en: 'Now to migrate gradually, we’ll need two versions of `findLongestLegOver`:
    the existing `Optional<Leg>`-returning one, and a new one that returns `Leg?`.
    We can do that by extracting the guts of the current implementation. This is currently:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在为了逐步迁移，我们需要两个版本的`findLongestLegOver`：现有的返回`Optional<Leg>`的版本和返回`Leg?`的新版本。我们可以通过提取当前实现的要点来做到这一点。目前是这样的：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[Example 4.5 [nullability.4:src/main/java/travelator/Legs.kt]](https://java-to-kotlin.dev/code.html?ref=4.5&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=4.5&show=diff)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 4.5 [nullability.4:src/main/java/travelator/Legs.kt]](https://java-to-kotlin.dev/code.html?ref=4.5&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=4.5&show=diff)'
- en: 'We “Extract Function” on all but the return statement of this `findLongestLegOver`.
    We can’t give it the same name, so we use `longestLegOver`; we make it public
    because this is our new interface:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对这个 `findLongestLegOver` 的所有部分进行“提取函数”。我们不能给它相同的名称，所以我们使用 `longestLegOver`；我们将其设为公共，因为这是我们的新接口：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[Example 4.6 [nullability.5:src/main/java/travelator/Legs.kt]](https://java-to-kotlin.dev/code.html?ref=4.6&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=4.6&show=diff)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 4.6 [nullability.5:src/main/java/travelator/Legs.kt]](https://java-to-kotlin.dev/code.html?ref=4.6&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=4.6&show=diff)'
- en: 'The refactoring has left a vestigial `result` variable in `findLongestLegOver`.
    We can select it and “Inline” to give:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 重构留下了 `findLongestLegOver` 中的一个残留 `result` 变量。我们可以选择它，然后“内联”以得到：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[Example 4.7 [nullability.6:src/main/java/travelator/Legs.kt]](https://java-to-kotlin.dev/code.html?ref=4.7&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=4.7&show=diff)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 4.7 [nullability.6:src/main/java/travelator/Legs.kt]](https://java-to-kotlin.dev/code.html?ref=4.7&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=4.7&show=diff)'
- en: Now we have two versions of our interface, one defined in terms of the other.
    We can leave our Java clients consuming the `Optional` from `findLongestLegOver`
    and convert our Kotlin clients to call the nullable-returning `longestLegOver`.
    Let’s show the conversion with our tests.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了两个版本的接口，一个是基于另一个定义的。我们可以让我们的 Java 客户端使用 `findLongestLegOver` 中的 `Optional`，并将我们的
    Kotlin 客户端转换为调用可空返回的 `longestLegOver`。让我们通过测试来展示转换。
- en: 'We’ll do the absent ones first. They currently call `assert⁠Equals​(Optional.empty<Any>(),
    findLongestLegOver…)`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们先处理缺失的调用。它们目前调用 `assert⁠Equals​(Optional.empty<Any>(), findLongestLegOver…)`：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[Example 4.8 [nullability.6:src/test/java/travelator/LongestLegOverTests.kt]](https://java-to-kotlin.dev/code.html?ref=4.8&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=4.8&show=diff)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 4.8 [nullability.6:src/test/java/travelator/LongestLegOverTests.kt]](https://java-to-kotlin.dev/code.html?ref=4.8&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=4.8&show=diff)'
- en: 'So we change them to `assertNull(longestLegOver(...)`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们将它们改为 `assertNull(longestLegOver(...)`：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[Example 4.9 [nullability.7:src/test/java/travelator/LongestLegOverTests.kt]](https://java-to-kotlin.dev/code.html?ref=4.9&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=4.9&show=diff)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 4.9 [nullability.7:src/test/java/travelator/LongestLegOverTests.kt]](https://java-to-kotlin.dev/code.html?ref=4.9&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=4.9&show=diff)'
- en: Note that we’ve changed the test names to use `backtick quoted identifiers`.
    IntelliJ will do this for us if we Alt-Enter on function_names with_underscores_in_tests.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已更改测试名称以使用 `backtick quoted identifiers`。如果我们在带有_测试中的下划线的 function_names
    上按 Alt-Enter，IntelliJ 将为我们执行此操作。
- en: 'Now for the calls that don’t return empty:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是不返回空的调用：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[Example 4.10 [nullability.6:src/test/java/travelator/LongestLegOverTests.kt]](https://java-to-kotlin.dev/code.html?ref=4.10&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=4.10&show=diff)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 4.10 [nullability.6:src/test/java/travelator/LongestLegOverTests.kt]](https://java-to-kotlin.dev/code.html?ref=4.10&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=4.10&show=diff)'
- en: 'The Kotlin equivalent of `Optional.orElseThrow()` (aka `get()` pre-Java 10)
    is the `!!` (bang-bang or dammit) operator. Both the Java `orElseThrow` and the
    Kotlin `!!` return the value or throw an exception if there isn’t one. Kotlin
    logically throws a `NullPointerException`. Java equally logically throws a `NoSuchElementExecption`;
    they just think of absence in different ways! Provided we haven’t relied on the
    type of the exception, we can replace `findLongestLegOver(...).orElseThrow()`
    with `longestLegOver(...)!!`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`Optional.orElseThrow()`（Java 10 之前的 `get()` 的 Kotlin 等效）的 Kotlin 版本是 `!!`（叹号叹号或该死）操作符。Java
    的 `orElseThrow` 和 Kotlin 的 `!!` 都会返回值，如果没有值则抛出异常。Kotlin 逻辑上会抛出 `NullPointerException`。Java
    逻辑上会抛出 `NoSuchElementExecption`；他们只是以不同的方式考虑缺失！只要我们没有依赖于异常的类型，我们就可以将 `findLongestLegOver(...).orElseThrow()`
    替换为 `longestLegOver(...)!!`：'
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[Example 4.11 [nullability.8:src/test/java/travelator/LongestLegOverTests.kt]](https://java-to-kotlin.dev/code.html?ref=4.11&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=4.11&show=diff)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 4.11 [nullability.8:src/test/java/travelator/LongestLegOverTests.kt]](https://java-to-kotlin.dev/code.html?ref=4.11&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=4.11&show=diff)'
- en: 'We’ve converted the first of the nonnull-returning tests (`is longest leg when
    one match`) with the `!!` operator. If it were to fail (which it doesn’t, but
    we like to plan for these things), it would fail with a thrown `NullPointerException`
    rather than with a nice diagnostic. In the second case, we’ve solved that problem
    with the safe call operator `?.`, which continues evaluation only if its receiver
    is not `null`. This means that if the leg *is* `null`, the error will read as
    follows, which is much nicer:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将第一个非空返回测试（`is longest leg when one match`）转换为使用`!!`运算符。如果它失败了（虽然它并没有，但我们喜欢为这些事情做计划），它将抛出`NullPointerException`而不是提供良好的诊断信息。在第二种情况下，我们使用了安全调用操作符`?.`来解决这个问题，它仅在接收者不为`null`时继续评估。这意味着如果腿确实为`null`，错误信息将如下所示，这要好得多：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Tests are one of the few places we use `!!` in practice, and even here there
    is usually a better alternative.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是我们在实践中使用`!!`的少数几个地方之一，即使在这里通常还有更好的选择。
- en: We can work this refactoring through our clients, converting them to Kotlin
    and then to using `longestLegOver`. Once we have converted all of them, we can
    delete the `Optional`-returning `findLongestLegOver`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将客户端重构来进行这种重构，将它们转换为 Kotlin，然后使用 `longestLegOver`。一旦我们将它们全部转换完毕，就可以删除返回
    `Optional` 的 `findLongestLegOver`。
- en: Refactoring to Idiomatic Kotlin
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构成惯用的 Kotlin
- en: Now all the code in this example is Kotlin, and we’ve seen how to migrate from
    optional to nullable. We could stop there, but consistent with our policy of going
    the extra refactoring mile, we’ll press on to see what else this code has to teach
    us.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个示例中的所有代码都是 Kotlin，并且我们已经看到了如何从可选类型迁移到可空类型。我们可以在此停止，但是考虑到我们进行额外重构的政策，我们将继续前进，看看这段代码还能教给我们什么。
- en: 'Here is the current version of `Legs`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这是当前版本的 `Legs`：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[Example 4.12 [nullability.9:src/main/java/travelator/Legs.kt]](https://java-to-kotlin.dev/code.html?ref=4.12&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=4.12&show=diff)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 4.12 [nullability.9:src/main/java/travelator/Legs.kt]](https://java-to-kotlin.dev/code.html?ref=4.12&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=4.12&show=diff)'
- en: 'The functions are contained in an `object` because our Java methods were static,
    so the conversion needed somewhere to put them. As we’ll see in [Chapter 8](ch08.html#static-methods-to-top-level-functions),
    Kotlin doesn’t need this extra level of namespace, so we can “Move to top level”
    on `longestLegOver`. At the time of writing, this doesn’t work very well, because
    IntelliJ fails to bring `isLongerThan` with its calling function, leaving it in
    `Legs`. The breakage is easy to fix though, leaving us with a top-level function
    and fixed-up references in existing code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 函数包含在一个 `object` 中，因为我们的 Java 方法是静态的，所以转换需要一个地方来放置它们。正如我们将在 [第 8 章](ch08.html#static-methods-to-top-level-functions)
    中看到的，Kotlin 不需要这种额外的命名空间级别，因此我们可以在 `longestLegOver` 上执行“移动到顶层”的操作。在撰写本文时，这并不是很有效，因为
    IntelliJ 未能将调用 `isLongerThan` 的函数带入，使其保留在 `Legs` 中。但这个破损很容易修复，留下一个顶层函数和现有代码中修复的引用：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[Example 4.13 [nullability.10:src/main/java/travelator/Legs.kt]](https://java-to-kotlin.dev/code.html?ref=4.13&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=4.13&show=diff)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 4.13 [nullability.10:src/main/java/travelator/Legs.kt]](https://java-to-kotlin.dev/code.html?ref=4.13&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=4.13&show=diff)'
- en: You may have noticed that `isLongerThan` has lost its braces and return statement.
    We’ll talk though the pros and cons of single-expression functions in [Chapter 9](ch09.html#multi-to-single-expression-functions).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到 `isLongerThan` 已经失去了它的大括号和返回语句。我们将讨论单表达式函数的利弊，在 [第 9 章](ch09.html#multi-to-single-expression-functions)
    中详细说明。
- en: 'While we’re here, there’s something odd about the phrase `isLongerThan(leg,
    ...)`. It just doesn’t read right in English. You’ll no doubt get bored of our
    infatuation with extension functions (certainly by the end of [Chapter 10](ch10.html#functions-to-extension-functions)),
    but while we still have your goodwill, let’s Alt-Enter on the `leg` parameter
    and “Convert parameter to receiver”, so that we can write `leg.isLongerThan(...)`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进行这个重构的时候，`isLongerThan(leg, ...)` 这个短语有些奇怪。在英语中读起来并不对劲。毫无疑问，我们对扩展函数的迷恋可能会使你感到厌烦（尤其是在
    [第 10 章](ch10.html#functions-to-extension-functions) 的结尾之前），但是在你还愿意继续之际，让我们在 `leg`
    参数上按下 Alt-Enter 并选择“将参数转换为接收者”，这样我们就可以编写 `leg.isLongerThan(...)`：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[Example 4.14 [nullability.11:src/main/java/travelator/Legs.kt]](https://java-to-kotlin.dev/code.html?ref=4.14&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=4.14&show=diff)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 4.14 [nullability.11:src/main/java/travelator/Legs.kt]](https://java-to-kotlin.dev/code.html?ref=4.14&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=4.14&show=diff)'
- en: So far, our changes have all been structural, changing where code is defined
    and how we call it. Structural refactors are inherently quite (as in mostly, rather
    than completely) safe. They can change the behavior of code that relies on polymorphism
    (either through methods or functions) or reflection, but otherwise, if the code
    continues to compile, it probably behaves.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所有的更改都是结构性的，改变了代码的定义位置和调用方式。结构性重构在本质上是相当安全的（大多数情况下，而不是完全）。它们可以改变依赖多态性（通过方法或函数）或反射的代码行为，但如果代码继续编译，那它可能仍然是有效的。
- en: Now we are going to turn our attention to the *algorithm* in `longestLegOver`.
    Refactoring algorithms is more dangerous, especially ones like this that rely
    on mutation, because tool support for transforming them is not good. We have good
    tests though, and it’s hard to work out what this does by reading it, so let’s
    see what we can do.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将注意力转向 `longestLegOver` 中的*算法*。重构算法更危险，特别是那些依赖变异的算法，因为工具支持转换它们并不好。尽管如此，我们有良好的测试，通过阅读它很难弄清楚它的功能，所以让我们看看我们能做什么。
- en: The only suggestion IntelliJ gives is to replace `compareTo` with `>`, so let’s
    do that first. At this point, Duncan at least has run out of refactoring talent
    (if we were actually pairing maybe you would have a suggestion?) and so decides
    to rewrite the function from scratch.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: IntelliJ 提供的唯一建议是用 `>` 替换 `compareTo`，所以让我们首先这样做。此时，至少 Duncan 已经用完了重构的天赋（如果我们实际上在配对，也许你会有建议？），所以决定从头开始重写这个函数。
- en: 'To reimplement the functionality, we ask ourselves, “What is the code trying
    to do?” The answer is, helpfully, in the name of the function: `longestLegOver`.
    To implement this calculation, we can find the longest leg, and if it is longer
    than duration, return it, otherwise `null`. After typing `legs.` at the beginning
    of the function, we look at the suggestions and find `maxByOrNull`. Our longest
    leg is going to be `legs.max⁠By​Or⁠Null(Leg::plannedDuration)`. This API helpfully
    returns `Leg?` (and includes the phrase `orNull`) to remind us that it can’t give
    a result if `legs` is empty. Converting our algorithm “find the longest leg, and
    if it is longer than duration, return it, otherwise null” to code directly, we
    get:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了重新实现功能，我们要问自己，“代码尝试做什么？” 答案很明显，在函数名 `longestLegOver` 中已经给出了：帮助我们计算最长的腿。为了实现这个计算，我们可以找到最长的腿，如果它比持续时间长，就返回它，否则返回
    `null`。在函数开头输入 `legs.` 后，我们查看建议，并找到 `maxByOrNull`。我们最长的腿将是 `legs.maxByOrNull(Leg::plannedDuration)`。这个
    API 友好地返回 `Leg?`（并包含短语 `orNull`）来提醒我们，如果 `legs` 是空的，它不能给出结果。将我们的算法“找到最长的腿，如果它比持续时间长，返回它，否则返回
    null”直接转换成代码，我们得到：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[Example 4.15 [nullability.12:src/main/java/travelator/Legs.kt]](https://java-to-kotlin.dev/code.html?ref=4.15&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=4.15&show=diff)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 4.15 [nullability.12:src/main/java/travelator/Legs.kt]](https://java-to-kotlin.dev/code.html?ref=4.15&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=4.15&show=diff)'
- en: 'That passes the tests, but those multiple returns are ugly. IntelliJ will helpfully
    offer to lift the `return` out of the `if`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过了测试，但是多次返回看起来很丑陋。IntelliJ 会友好地建议将 `return` 从 `if` 中提取出来：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[Example 4.16 [nullability.13:src/main/java/travelator/Legs.kt]](https://java-to-kotlin.dev/code.html?ref=4.16&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=4.16&show=diff)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 4.16 [nullability.13:src/main/java/travelator/Legs.kt]](https://java-to-kotlin.dev/code.html?ref=4.16&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=4.16&show=diff)'
- en: Now, Kotlin’s nullability support allows several ways to refactor this, depending
    on your tastes.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Kotlin 的空安全支持允许多种方式来重构这个问题，这取决于你的喜好。
- en: 'We can use the Elvis operator `?:`, which evaluates to its lefthand side unless
    that is `null`, in which case it evaluates its righthand side. This lets us return
    early if we have no longest leg:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Elvis 操作符 `?:`，它如果左侧为 `null` 则评估为左侧，否则评估为右侧。这让我们可以在没有最长腿的情况下提前返回：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[Example 4.17 [nullability.14:src/main/java/travelator/Legs.kt]](https://java-to-kotlin.dev/code.html?ref=4.17&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=4.17&show=diff)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 4.17 [nullability.14:src/main/java/travelator/Legs.kt]](https://java-to-kotlin.dev/code.html?ref=4.17&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=4.17&show=diff)'
- en: 'We could go with a single `?.let` expression. The `?.` evaluates to `null`
    if fed a `null`; otherwise, it pipes the longest leg into the `let` block for
    us:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以采用单个 `?.let` 表达式。`?.` 如果给定 `null` 则评估为 `null`；否则，它会将最长的腿导入 `let` 块：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[Example 4.18 [nullability.15:src/main/java/travelator/Legs.kt]](https://java-to-kotlin.dev/code.html?ref=4.18&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=4.18&show=diff)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 4.18 [nullability.15:src/main/java/travelator/Legs.kt]](https://java-to-kotlin.dev/code.html?ref=4.18&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=4.18&show=diff)'
- en: 'So inside the `let`, `longestLeg` cannot be `null`. That is succinct, and it
    is a pleasing single expression, but it may be hard to comprehend in a single
    glance. Spelling out the options with a `when` is clearer:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在`let`内部，`longestLeg`不能为`null`。这很简洁，是一个令人愉悦的单表达式，但一眼看去可能难以理解。用`when`明确表达选项更清晰：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[Example 4.19 [nullability.17:src/main/java/travelator/Legs.kt]](https://java-to-kotlin.dev/code.html?ref=4.19&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=4.19&show=diff)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 4.19 [nullability.17:src/main/java/travelator/Legs.kt]](https://java-to-kotlin.dev/code.html?ref=4.19&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=4.19&show=diff)'
- en: 'To simplify further, we need a trick that Duncan (who is writing this) has
    so far failed to internalize: `takeIf` returns its receiver if a predicate is
    `true`; otherwise, it returns `null`. This is exactly the logic of our previous
    `let` block. So we can write:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步简化，我们需要一个技巧，邓肯（撰写此文的人）迄今未能内化：`takeIf`如果断言为`true`，则返回其接收者；否则返回`null`。这正是我们先前`let`块的逻辑。因此，我们可以写成：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[Example 4.20 [nullability.16:src/main/java/travelator/Legs.kt]](https://java-to-kotlin.dev/code.html?ref=4.20&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=4.20&show=diff)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 4.20 [nullability.16:src/main/java/travelator/Legs.kt]](https://java-to-kotlin.dev/code.html?ref=4.20&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=4.20&show=diff)'
- en: Depending on our team’s experience with Kotlin, that may be too subtle. Nat
    thinks it’s fine, but we’re going to err on the side of explicitness, so the `when`
    version gets to stay, at least until the next time someone refactors here.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们团队对 Kotlin 的经验，这可能太微妙了。Nat 认为没问题，但我们会选择显式表达，所以`when`版本会留下来，至少在下次重构之前是这样。
- en: 'Finally, let’s convert the `legs` parameter to the receiver in an extension
    function. This allows us to rename the function to something less dubious:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们将`legs`参数转换为扩展函数的接收者。这使我们能够将函数重命名为更少可疑的内容：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[Example 4.21 [nullability.18:src/main/java/travelator/Legs.kt]](https://java-to-kotlin.dev/code.html?ref=4.21&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=4.21&show=diff)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 4.21 [nullability.18:src/main/java/travelator/Legs.kt]](https://java-to-kotlin.dev/code.html?ref=4.21&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=4.21&show=diff)'
- en: Just before we finish this chapter, take the time to compare this version with
    the original. Are there any advantages to the old version?
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成本章之前，抽出时间将此版本与原始版本进行比较。旧版本有什么优势吗？
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[Example 4.22 [nullability.0:src/main/java/travelator/Legs.java]](https://java-to-kotlin.dev/code.html?ref=4.22&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=4.22&show=diff)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 4.22 [nullability.0:src/main/java/travelator/Legs.java]](https://java-to-kotlin.dev/code.html?ref=4.22&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=4.22&show=diff)'
- en: 'Usually we would say “it depends,” but in this case we think that the new version
    is better on pretty much every front. It is shorter and simpler; it’s easier to
    see how it works; and in most cases it results in fewer calls to `getPlannedDuration()`,
    which is a relatively expensive operation. What if we had taken the same approach
    in Java? A direct translation is:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通常我们会说“这取决于”，但在这种情况下，我们认为新版本在几乎所有方面都更好。它更短，更简单；更容易理解其工作原理；在大多数情况下，它导致对`getPlannedDuration()`的调用更少，这是一个相对昂贵的操作。如果我们在
    Java 中采取相同的方法呢？直接翻译如下：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[Example 4.23 [nullability.1:src/main/java/travelator/Legs.java]](https://java-to-kotlin.dev/code.html?ref=4.23&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=4.23&show=diff)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 4.23 [nullability.1:src/main/java/travelator/Legs.java]](https://java-to-kotlin.dev/code.html?ref=4.23&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=4.23&show=diff)'
- en: Actually, that isn’t bad, but compared with the Kotlin version, you can see
    how `Optional` adds noise to pretty much every line of the method. Because of
    this, a version using `Optional.filter` is probably preferable, even though it
    suffers from the same comprehension problems as the Kotlin `takeIf`. Which is
    to say, Duncan can’t tell that it works without running the tests, but Nat prefers
    it.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这并不差，但与 Kotlin 版本相比，你可以看到`Optional`几乎在每行方法中都添加了噪音。因此，尽管存在与 Kotlin `takeIf`相同的理解问题，使用`Optional.filter`版本可能更可取。也就是说，邓肯无法在运行测试之前确认其有效性，但
    Nat 更喜欢这个版本。
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[Example 4.24 [nullability.2:src/main/java/travelator/Legs.java]](https://java-to-kotlin.dev/code.html?ref=4.24&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=4.24&show=diff)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 4.24 [nullability.2:src/main/java/travelator/Legs.java]](https://java-to-kotlin.dev/code.html?ref=4.24&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=4.24&show=diff)'
- en: Moving On
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向前迈进
- en: The absence or presence of information is inescapable in our code. By raising
    it to first-class status, Kotlin makes sure that we take account of absence when
    we have to and are not overwhelmed by it when we don’t. In comparison, Java’s
    `Optional` type feels clumsy. Luckily, we can easily migrate from `Optional` to
    nullable and support both simultaneously when we are not ready to convert all
    our code to Kotlin.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，信息的存在或缺失是不可避免的。通过将其提升为一级状态，Kotlin 确保我们在需要时考虑缺失，并在不需要时不被其压倒。相比之下，Java
    的 `Optional` 类型显得笨拙。幸运的是，当我们还没有准备好将所有代码转换为 Kotlin 时，我们可以轻松地从 `Optional` 转换为可空类型，并同时支持两者。
- en: In [Chapter 10, *Functions to Extension Functions*](ch10.html#functions-to-extension-functions),
    we’ll see how nullable types combine with other Kotlin language features—the safe
    call and Elvis operators, and extension functions—to form a grain that results
    in designs quite different from those we write in Java.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 10 章，*从函数到扩展函数*](ch10.html#functions-to-extension-functions)中，我们将看到可空类型如何与其他
    Kotlin 语言特性——安全调用和 Elvis 运算符，以及扩展函数——结合，形成一个粒度，导致设计与我们在 Java 中编写的设计截然不同。
- en: 'But that’s getting ahead of ourselves. In the next chapter, we’ll look at a
    typical Java class and translate it into a typical Kotlin class. Translation from
    Java to Kotlin is more than syntactic: the two languages differ in their acceptance
    of mutable state.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 但这已经超出了我们的范畴。在下一章中，我们将看一下典型的 Java 类，并将其翻译成典型的 Kotlin 类。从 Java 到 Kotlin 的翻译不仅仅是句法上的转换：这两种语言在对可变状态的接受上也有所不同。
- en: '^([1](ch04.html#idm46393409336056-marker)) “Null References: The Billion Dollar
    Mistake” [on YouTube](https://oreil.ly/Ue3Ct).'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch04.html#idm46393409336056-marker)) “空引用：百亿美元的错误” [YouTube 上的视频](https://oreil.ly/Ue3Ct)。
