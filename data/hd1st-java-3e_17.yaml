- en: 'Chapter 14\. A Very Graphic Story: Getting Gui'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 14 章。一个非常图形化的故事：获取 Gui
- en: '![image](Images/f0461-01.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0461-01.png)'
- en: '**Face it, you need to make GUIs**. If you’re building applications that other
    people are going to use, you *need* a graphical interface. If you’re building
    programs for yourself, you *want* a graphical interface. Even if you believe that
    the rest of your natural life will be spent writing server-side code, where the
    client user interface is a web page, sooner or later you’ll need to write tools,
    and you’ll want a graphical interface. Sure, command-line apps are retro, but
    not in a good way. They’re weak, inflexible, and unfriendly. We’ll spend two chapters
    working on GUIs and learn key Java language features along the way including **Event
    Handling** and **Inner Classes** and **lambdas**. In this chapter, we’ll put a
    button on the screen, and make it do something when you click it. We’ll paint
    on the screen, we’ll display a JPEG image, and we’ll even do some (crude) animation.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**面对现实吧，你需要制作 GUI**。如果你正在构建其他人将使用的应用程序，你*需要*一个图形界面。如果你正在为自己构建程序，你*想要*一个图形界面。即使你相信你的余生都将花在编写服务器端代码上，其中客户端用户界面是一个网页，迟早你也会需要编写工具，并且你会想要一个图形界面。当然，命令行应用程序是复古的，但不是以一种好的方式。它们是薄弱的、不灵活的和不友好的。我们将花两章的时间来研究
    GUI，并学习关键的 Java 语言特性，包括**事件处理**、**内部类**和**lambda**。在本章中，我们将在屏幕上放置一个按钮，并在点击时使其执行某些操作。我们将在屏幕上绘制，显示
    JPEG 图像，甚至进行一些（粗糙的）动画。'
- en: It all starts with a window
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一切都始于一个窗口
- en: '![image](Images/f0462-02.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0462-02.png)'
- en: '**She’s asked a couple of really good questions.** In a few pages we’ll address
    these questions with an extra-special “No Dumb Questions.”'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**她问了几个非常好的问题**。在接下来的几页中，我们将用一个特别的“无愚蠢问题”来回答这些问题。'
- en: A JFrame is the object that represents a window on the screen. It’s where you
    put all the interface things like buttons, check boxes, text fields, and so on.
    It can have an honest-to-goodness menu bar with menu items. And it has all the
    little windowing icons for whatever platform you’re on, for minimizing, maximizing,
    and closing the window.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: JFrame 是代表屏幕上窗口的对象。在其中放置所有的界面元素，如按钮、复选框、文本字段等。它可以有一个真正的菜单栏，其中包含菜单项。并且它具有所有平台的窗口图标，用于最小化、最大化和关闭窗口。
- en: 'The JFrame looks different depending on the platform you’re on. This is a JFrame
    on an old Mac OS X:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: JFrame 在你所在的平台上看起来会有所不同。这是一个在旧 Mac OS X 上的 JFrame：
- en: '![image](Images/f0462-01.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0462-01.png)'
- en: Put widgets in the window
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将小部件放入窗口中
- en: Once you have a JFrame, you can put things (“widgets”) in it by adding them
    to the JFrame. There are a ton of Swing components you can add; look for them
    in the javax.swing package. The most common include JButton, JRadioButton, JCheckBox,
    JLabel, JList, JScrollPane, JSlider, JTextArea, JTextField, and JTable. Most are
    really simple to use, but some (like JTable) can be a bit more complicated.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了一个 JFrame，你可以通过将它们添加到 JFrame 中来将东西（“小部件”）放入其中。有很多 Swing 组件可以添加；在 javax.swing
    包中查找它们。最常见的包括 JButton、JRadioButton、JCheckBox、JLabel、JList、JScrollPane、JSlider、JTextArea、JTextField
    和 JTable。大多数都很简单易用，但有些（如 JTable）可能会有点复杂。
- en: '**Making a GUI is easy:**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**制作 GUI 很容易：**'
- en: '![images](Images/1.png) Make a frame (a JFrame)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_IMG
  zh: '![图片](Images/1.png) 制作一个框架（JFrame）'
- en: '`**JFrame frame = new JFrame();**`'
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`**JFrame frame = new JFrame();**`'
- en: '![images](Images/2.png) Make a widget (button, text field, etc.)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_IMG
  zh: '![图片](Images/2.png) 制作一个小部件（按钮、文本字段等）'
- en: '`**JButton button = new JButton("click me");**`'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`**JButton button = new JButton("点击我");**`'
- en: '![images](Images/3.png) Add the widget to the frame'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/3.png) 将小部件添加到框架中'
- en: '`**frame.getContentPane().add(button);**`'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`**frame.getContentPane().add(button);**`'
- en: Note
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You don’t add things to the frame directly. Think of the frame as the trim around
    the window, and you add things to the window pane.
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你不直接向框架添加东西。把框架看作窗口周围的装饰，然后将东西添加到窗格中。
- en: '![images](Images/4.png) Display it (give it a size and make it visible)'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_IMG
  zh: '![图片](Images/4.png) 显示它（给它一个大小并使其可见）'
- en: '[PRE0]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Your first GUI: a button on a frame'
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你的第一个 GUI：一个在框架上的按钮
- en: '![image](Images/f0463-01.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0463-01.png)'
- en: '**Let’s see what happens when we run it:**'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**让我们看看运行时会发生什么：**'
- en: '`%java SimpleGui1`'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`%java SimpleGui1`'
- en: '![image](Images/f0463-02.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0463-02.png)'
- en: Note
  id: totrans-27
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**Whoa! That’s a Really Big Button.**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**哇！那是一个非常大的按钮。**'
- en: The button fills all the available space in the frame. Later we’ll learn to
    control where (and how big) the button is on the frame.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮填充了框架中所有可用的空间。稍后我们将学习如何控制按钮在框架中的位置（以及大小）。
- en: But nothing happens when I click it...
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 但是当我点击它时什么都不会发生...
- en: That’s not exactly true. When you press the button, it shows that “pressed”
    or “pushed in” look (which changes depending on the platform look and feel, but
    it always does *something* to show when it’s being pressed).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不完全正确。当您按下按钮时，它会显示“按下”或“推入”的外观（这取决于平台的外观和感觉，但它总是会*做一些事情*来显示正在被按下）。
- en: The real question is, “How do I get the button to do something specific when
    the user clicks it?”
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的问题是：“当用户点击按钮时，我如何让按钮执行特定的操作？”
- en: '**We need two things:**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们需要两件事：**'
- en: '![images](Images/1.png) A ***method*** to be called when the user clicks (the
    thing you want to happen as a result of the button click).'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![images](Images/1.png) 用户点击时调用的***方法***（按钮点击后要发生的事情）。'
- en: '![images](Images/2.png) A way to ***know*** when to trigger that method. In
    other words, a way to know when the user clicks the button!'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![images](Images/2.png) 一种***知道***何时触发该方法的方法。换句话说，一种知道用户何时点击按钮的方法！'
- en: Getting a user event
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取用户事件
- en: 'Imagine you want the text on the button to change from *click me* to *I’ve
    been clicked* when the user presses the button. First we can write a method that
    changes the text of the button (a quick look through the API will show you the
    method):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您希望用户按下按钮时将按钮上的文本从*click me*更改为*I’ve been clicked*。首先，我们可以编写一个更改按钮文本的方法（通过API快速查看该方法）：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: But *now* what? How will we *know* when this method should run? ***How will
    we know when the button is clicked?***
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 但是*现在*呢？我们如何*知道*何时运行这个方法？***当按钮被点击时我们怎么知道？***
- en: In Java, the process of getting and handling a user event is called *event-handling*.
    There are many different event types in Java, although most involve GUI user actions.
    If the user clicks a button, that’s an event. An event that says “The user wants
    the action of this button to happen.” If it’s a “Slow the Tempo” button, the user
    wants the slow-the-music-tempo action to occur. If it’s a Send button on a chat
    client, the user wants the send-my-message action to happen. So the most straightforward
    event is when the user clicked the button, indicating they want an action to occur.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，获取和处理用户事件的过程称为*事件处理*。在Java中有许多不同的事件类型，尽管大多数涉及GUI用户操作。如果用户点击按钮，那就是一个事件。一个事件表明“用户希望执行此按钮的操作。”如果它是“减慢速度”按钮，则用户希望执行减慢音乐节奏的操作。如果是聊天客户端上的发送按钮，则用户希望执行发送我的消息的操作。因此，最简单的事件是用户点击按钮，表示他们希望执行某个操作。
- en: With buttons, you usually don’t care about any intermediate events like button-is-being-pressed
    and button-is-being-released. What you want to say to the button is, “I don’t
    care how the user plays with the button, how long they hold the mouse over it,
    how many times they change their mind and roll off before letting go, etc. ***Just
    tell me when the user means business!*** In other words, don’t call me unless
    the user clicks in a way that indicates he wants the darn button to do what it
    says it’ll do!”
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于按钮，通常不关心任何中间事件，如按钮正在被按下和按钮正在被释放。你想要对按钮说的是：“我不在乎用户如何与按钮交互，他们在上面按住鼠标多久，他们在放手之前改变主意的次数等等。***告诉我只有当用户认真对待时才调用我！***换句话说，除非用户点击表明他想要该死的按钮执行其所说的操作，否则不要调用我！”
- en: '**First, the button needs to know that we care.**'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**首先，按钮需要知道我们关心。**'
- en: '![image](Images/f0465-02.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0465-02.png)'
- en: '**Second, the button needs a way to call us back when a button-clicked event
    occurs.**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**其次，按钮需要在按钮点击事件发生时回调我们。**'
- en: '**If you care about the button’s events, **implement an interface** that says,
    “I’m **listening** for your events.”**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果你关心按钮的事件，**实现一个接口**，说：“我**监听**你的事件。”**'
- en: A **listener interface** is the bridge between the **listener** (you) and **event
    source** (the button).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**监听器接口**是**监听器**（你）和**事件源**（按钮）之间的桥梁。'
- en: The Swing GUI components are event sources. In Java terms, an event source is
    an object that can turn user actions (click a mouse, type a key, close a window)
    into events. And like virtually everything else in Java, an event is represented
    as an object. An object of some event class. If you scan through the java.awt.event
    package in the API, you’ll see a bunch of event classes (easy to spot—they all
    have ***Event*** in the name). You’ll find MouseEvent, KeyEvent, WindowEvent,
    ActionEvent, and several others.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Swing GUI组件是事件源。在Java术语中，事件源是一个可以将用户动作（点击鼠标，键入键，关闭窗口）转换为事件的对象。就像Java中的几乎所有其他内容一样，事件表示为对象。某个事件类的对象。如果您在API中的java.awt.event包中扫描，您会看到一堆事件类（很容易发现它们都有***Event***在名称中）。您会找到MouseEvent，KeyEvent，WindowEvent，ActionEvent等几个事件类。
- en: An event ***source*** (like a button) creates an ***event object*** when the
    user does something that matters (like *click* the button). Most of the code you
    write (and all the code in this book) will *receive* events rather than *create*
    events. In other words, you’ll spend most of your time as an event *listener*
    rather than an event *source*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 事件***源***（比如按钮）在用户执行重要操作时（比如*点击*按钮）创建一个***事件对象***。大多数你编写的代码（以及本书中的所有代码）都会*接收*事件，而不是*创建*事件。换句话说，你会大部分时间作为事件*监听器*而不是事件*源*。
- en: Every event type has a matching listener interface. If you want MouseEvents,
    implement the MouseListener interface. Want WindowEvents? Implement WindowListener.
    You get the idea. And remember your interface rules—to implement an interface
    you *declare* that you implement it (class Dog implements Pet), which means you
    must *write implementation methods* for every method in the interface.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 每种事件类型都有一个相应的监听器接口。如果你想要MouseEvents，实现MouseListener接口。想要WindowEvents？实现WindowListener。你明白了。记住接口的规则——实现接口时，你*声明*你实现它（类Dog实现Pet），这意味着你必须*编写实现方法*来处理接口中的每个方法。
- en: Some interfaces have more than one method because the event itself comes in
    different flavors. If you implement MouseListener, for example, you can get events
    for mousePressed, mouseReleased, mouseMoved, etc. Each of those mouse events has
    a separate method in the interface, even though they all take a MouseEvent. If
    you implement MouseListener, the mousePressed() method is called when the user
    (you guessed it) presses the mouse. And when the user lets go, the mouseReleased()
    method is called. So for mouse events, there’s only one event *object*, MouseEvent,
    but several different event *methods*, representing the different *types* of mouse
    events.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有些接口有多个方法，因为事件本身具有不同的类型。例如，如果你实现了MouseListener，你可以获取鼠标按下、鼠标释放、鼠标移动等事件。每一个鼠标事件在接口中都有一个单独的方法，即使它们都接收一个MouseEvent。如果你实现了MouseListener，当用户按下鼠标时会调用mousePressed()方法。当用户松开鼠标时会调用mouseReleased()方法。因此，对于鼠标事件，只有一个事件*对象*，即MouseEvent，但是有几种不同的事件*方法*，代表不同的鼠标事件*类型*。
- en: Note
  id: totrans-51
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**When you implement a listener interface, you give the button a way to call
    you back. The interface is where the call-back method is declared.**'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**当你实现一个监听器接口时，你为按钮提供了一种回调你的方法。接口是声明回调方法的地方。**'
- en: '![image](Images/f0466-01.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0466-01.png)'
- en: '**How the listener and source communicate:**'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**监听器和源如何通信：**'
- en: '![image](Images/f0467-01.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0467-01.png)'
- en: '**The Listener**'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**监听器**'
- en: If your class wants to know about a button’s ActionEvents, you implement the
    ActionListener interface. The button needs to know you’re interested, so you register
    with the button by calling its addActionListener(this) and passing an ActionListener
    reference to it. In our first example, *you* are the ActionListener so you pass
    *this*, but it’s more common to create a specific class to do listen to events.
    The button needs a way to call you back when the event happens, so it calls the
    method in the listener interface. As an ActionListener, you *must* implement the
    interface’s sole method, actionPerformed(). The compiler guarantees it.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的类想要知道按钮的ActionEvents，你需要实现ActionListener接口。按钮需要知道你感兴趣，所以你通过调用它的addActionListener(this)并传递一个ActionListener引用来注册。在我们的第一个例子中，*你*是ActionListener，所以你传递了*this*，但更常见的是创建一个专门的类来监听事件。按钮需要一种方法在事件发生时回调你，所以它调用监听器接口中的方法。作为ActionListener，你*必须*实现接口中的唯一方法actionPerformed()。编译器保证了这一点。
- en: '**The Event Source**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件源**'
- en: A button is a source of ActionEvents, so it has to know which objects are interested
    listeners. The button has an addActionListener() method to give interested objects
    (listeners) a way to *tell* the button they’re interested.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮是ActionEvents的源，因此它必须知道哪些对象是感兴趣的监听器。按钮有一个addActionListener()方法，为感兴趣的对象（监听器）提供一种*告知*按钮它们感兴趣的方式。
- en: When the button’s addActionListener() runs (because a potential listener invoked
    it), the button takes the parameter (a reference to the listener object) and stores
    it in a list. When the user clicks the button, the button “fires” the event by
    calling the actionPerformed() method on each listener in the list.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当按钮的addActionListener()运行时（因为潜在的监听器调用了它），按钮将参数（指向监听器对象的引用）存储在列表中。当用户点击按钮时，按钮通过调用列表中每个监听器的actionPerformed()方法来“触发”事件。
- en: '**Getting a button’s ActionEvent**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**获取按钮的ActionEvent**'
- en: '![images](Images/1.png) Implement the ActionListener interface'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![images](Images/1.png) 实现ActionListener接口'
- en: '![images](Images/2.png) Register with the button (tell it you want to listen
    for events)'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_IMG
  zh: '![图片](Images/2.png) 注册按钮（告诉它你要监听事件）'
- en: '![images](Images/3.png) Define the event-handling method (implement the actionPerformed()
    method from the ActionListener interface)'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_IMG
  zh: '![图片](Images/3.png) 定义事件处理方法（实现ActionListener接口中的actionPerformed()方法）'
- en: '![image](Images/f0468-01.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0468-01.png)'
- en: Listeners, Sources, and Events
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监听器、源和事件
- en: For most of your stellar Java career, *you* will not be the *source* of events.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在你辉煌的Java职业生涯中，*你*不会是事件的*源头*。
- en: (No matter how much you fancy yourself the center of your social universe.)
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: （无论你多么幻想自己是你社交宇宙的中心。）
- en: Get used to it. ***Your job is to be a good listener.***
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 习惯它。 ***你的工作是成为一个好的倾听者。***
- en: (Which, if you do it sincerely, *can* improve your social life.)
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: （如果你真诚地去做，*确实*能改善你的社交生活。）
- en: '![image](Images/f0469-01.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0469-01.png)'
- en: '![image](Images/arr.png) **Yours to solve.**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](Images/arr.png) **由你解决。**'
- en: Getting back to graphics...
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回到图形处理...
- en: Now that we know a little about how events work (we’ll learn more later), let’s
    get back to putting stuff on the screen. We’ll spend a few minutes playing with
    some fun ways to get graphic, before returning to event handling.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了一些事件如何工作的知识（稍后我们会学到更多），让我们回到屏幕上放东西的问题上。我们会花几分钟玩一些有趣的图形方式，然后再回到事件处理。
- en: '**Three ways to put things on your GUI:**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**三种方法将事物放在你的GUI上：**'
- en: '![images](Images/1.png) **Put widgets on a frame**'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/1.png) **将小部件放在框架上**'
- en: Add buttons, menus, radio buttons, etc.
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 添加按钮、菜单、单选按钮等。
- en: '`**frame.getContentPane().add(myButton);**`'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`**frame.getContentPane().add(myButton);**`'
- en: The javax.swing package has more than a dozen widget types.
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: javax.swing包有十几种小部件类型。
- en: '![image](Images/f0471-01.png)'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](Images/f0471-01.png)'
- en: '![images](Images/2.png) **Draw 2D graphics on a widget**'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/2.png) **在小部件上绘制2D图形**'
- en: Use a graphics object to paint shapes.
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用图形对象绘制形状。
- en: '`**graphics.fillOval(70,70,100,100);**`'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`**graphics.fillOval(70,70,100,100);**`'
- en: You can paint a lot more than boxes and circles; the Java2D API is full of fun,
    sophisticated graphics methods.
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以画出比盒子和圆圈更多的东西；Java2D API充满了有趣和复杂的图形方法。
- en: '![image](Images/f0471-02.png)'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](Images/f0471-02.png)'
- en: '![images](Images/3.png) **Put a JPEG on a widget**'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/3.png) **在小部件上放置JPEG**'
- en: You can put your own images on a widget.
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以把自己的图像放在一个小部件上。
- en: '`**graphics.drawImage(myPic,10,10,this);**`'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`**graphics.drawImage(myPic,10,10,this);**`'
- en: '![image](Images/f0471-03.png)'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](Images/f0471-03.png)'
- en: Make your own drawing widget
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作你自己的绘图小部件
- en: If you want to put your own graphics on the screen, your best bet is to make
    your own paintable widget. You plop that widget on the frame, just like a button
    or any other widget, but when it shows up, it will have your images on it. You
    can even make those images move, in an animation, or make the colors on the screen
    change every time you click a button.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在屏幕上放置自己的图形，最好的办法是制作一个可绘制的小部件。你把那个小部件放在框架上，就像按钮或任何其他小部件一样，但是当它显示出来时，它将有你的图像。你甚至可以让这些图像动起来，作为动画，或者每次点击按钮时改变屏幕上的颜色。
- en: It’s a piece of cake.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这简直就是小菜一碟。
- en: '**Make a subclass of JPanel and override one method, paintComponent().**'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**创建JPanel的子类并覆盖一个方法，paintComponent()。**'
- en: All of your graphics code goes inside the paintComponent() method. Think of
    the paintComponent() method as the method called by the system to say, “Hey widget,
    time to paint yourself.” If you want to draw a circle, the paintComponent() method
    will have code for drawing a circle. When the frame holding your drawing panel
    is displayed, paintComponent() is called and your circle appears. If the user
    iconifies/minimizes the window, the JVM knows the frame needs “repair” when it
    gets de-iconified, so it calls paintComponent() again. Anytime the JVM thinks
    the display needs refreshing, your paintComponent() method will be called.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 所有你的图形代码都放在paintComponent()方法里。把paintComponent()方法想象成系统调用的方法，“嘿小部件，该你画自己了。”如果你想画一个圆，paintComponent()方法会有画圆的代码。当显示包含你的绘图面板的框架时，就会调用paintComponent()，你的圆就会出现。如果用户最小化窗口，JVM知道当它最小化后需要“修复”，所以当它被还原时再次调用paintComponent()。任何时候JVM认为显示需要刷新时，都会调用你的paintComponent()方法。
- en: One more thing, ***you never call this method yourself!*** The argument to this
    method (a Graphics object) is the actual drawing canvas that gets slapped onto
    the *real* display. You can’t get this by yourself; it must be handed to you by
    the system. You’ll see later, however, that you *can* ask the system to refresh
    the display (repaint()), which ultimately leads to paintComponent() being called.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事，***你永远不会自己调用这个方法！*** 这个方法的参数（一个Graphics对象）是实际的绘图画布，最终被打印到*真正的*显示器上。你不能自己得到它；它必须由系统交给你。稍后你会看到，你*可以*要求系统刷新显示（repaint()），这最终会导致调用paintComponent()。
- en: '![image](Images/f0472-01.png)![image](Images/f0472-02.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0472-01.png)![image](Images/f0472-02.png)'
- en: Fun things to do in paintComponent()
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在paintComponent()中有趣的事情
- en: Let’s look at a few more things you can do in paintComponent(). The most fun,
    though, is when you start experimenting yourself. Try playing with the numbers,
    and check the API for class Graphics (later we’ll see that there’s even *more*
    you can do besides what’s in the Graphics class).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在paintComponent()中还可以做些什么。不过，最有趣的是当你开始自己尝试时。试着改变一些数字，并查看Graphics类的API（稍后我们会看到除了Graphics类中的内容外，还有更多你可以做的）。
- en: '**Display a JPEG**'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**显示JPEG图像**'
- en: '![image](Images/f0473-01.png)![image](Images/f0473-02.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0473-01.png)![image](Images/f0473-02.png)'
- en: '**Paint a randomly colored circle on a black background**'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**在黑色背景上绘制一个随机颜色的圆**'
- en: '![image](Images/f0473-03.png)![image](Images/f0473-04.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0473-03.png)![image](Images/f0473-04.png)'
- en: Behind every good Graphics reference is a Graphics2D object
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在每个良好的Graphics引用的背后都是一个Graphics2D对象
- en: The argument to paintComponent() is declared as type Graphics (java.awt.Graphics).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: paintComponent()的参数声明为Graphics类型（java.awt.Graphics）。
- en: '**`public void paintComponent(Graphics g) { }`**'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**`public void paintComponent(Graphics g) { }`**'
- en: So the parameter “g” IS-A Graphics object. This means it *could* be a *subclass*
    of Graphics (because of polymorphism). And in fact, it *is*.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，“g”参数是一个Graphics对象。这意味着它*可能*是Graphics的*子类*（因为多态性）。事实上，它*是*。
- en: '***The object referenced by the “g” parameter is actually an instance of the***
    Graphics2D ***class.***'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '***“g”参数引用的对象实际上是*** Graphics2D ***类的一个实例。***'
- en: Why do you care? Because there are things you can do with a Graphics2D reference
    that you can’t do with a Graphics reference. A Graphics2D object can do more than
    a Graphics object, and it really is a Graphics2D object lurking behind the Graphics
    reference.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么你会在乎？因为Graphics2D引用可以做的事情比Graphics引用多。Graphics2D对象可以做的比Graphics对象多，实际上Graphics引用背后隐藏的是Graphics2D对象。
- en: 'Remember your polymorphism. The compiler decides which methods you can call
    based on the reference type, not the object type. If you have a Dog object referenced
    by an Animal reference variable:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 记住你的多态性。编译器根据引用类型而不是对象类型决定你可以调用哪些方法。如果你有一个Animal引用变量引用的Dog对象：
- en: '`**Animal a = new Dog();**`'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`**Animal a = new Dog();**`'
- en: 'You CANNOT say:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能说：
- en: '`**a.bark();**`'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`**a.bark();**`'
- en: 'Even though you know it’s really a Dog back there. The compiler looks at “a,”
    sees that it’s of type Animal, and finds that there’s no remote control button
    for bark() in the Animal class. But you can still get the object back to the Dog
    it really *is* by saying:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你知道背后真的是一只狗。编译器看到“a”，看到它是Animal类型，发现Animal类中没有bark()的遥控按钮。但你仍然可以通过以下方式将对象还原为它真正*是*的Dog：
- en: '[PRE2]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'So the bottom line with the Graphics object is this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，关于Graphics对象的底线是：
- en: '**If you need to use a method from the Graphics2D class, you can’t *use* the
    paintComponent parameter (“g”) straight from the method. But you can *cast* it
    with a new Graphics2D variable:**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果你需要使用Graphics2D类的方法，你不能直接从方法中使用paintComponent参数（“g”）。但是你可以用一个新的Graphics2D变量来*转换*它：**'
- en: '`**Graphics2D g2d = (Graphics2D) g;**`'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`**Graphics2D g2d = (Graphics2D) g;**`'
- en: Because life’s too short to paint the circle a solid color when there’s a gradient
    blend waiting for you
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 因为人生苦短，当有一个渐变混合在等着你时，你就不必把圆圈画成一个实心颜色了。
- en: '![image](Images/f0475-01.png)![image](Images/f0475-02.png)![image](Images/f0475-03.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0475-01.png)![image](Images/f0475-02.png)![image](Images/f0475-03.png)'
- en: '**Bullet Points**'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目符号**'
- en: We can get an event. We can paint graphics. But can we paint graphics *when*
    we get an event?
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们可以得到一个事件。我们可以绘制图形。但是我们能否在*得到*事件时绘制图形呢？
- en: 'Let’s hook up an event to a change in our drawing panel. We’ll make the circle
    change colors each time you click the button. Here’s how the program flows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将一个事件连接到我们绘图面板上的变化。每次单击按钮时，我们将使圆圈更改颜色。程序的流程如下：
- en: '![images](Images/1-circle.png) The frame is built with the two widgets (your
    drawing panel and a button). A listener is created and registered with the button.
    Then the frame is displayed, and it just waits for the user to click.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/1-circle.png) 框架使用两个小部件构建（您的绘图面板和一个按钮）。监听器创建并注册到按钮上。然后显示框架，它只是等待用户点击。'
- en: '![image](Images/f0477-01.png)'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](Images/f0477-01.png)'
- en: '![images](Images/2-circle.png) The user clicks the button, and the button creates
    an event object and calls the listener’s event handler.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/2-circle.png) 用户点击按钮，按钮创建一个事件对象并调用监听器的事件处理程序。'
- en: '![image](Images/f0477-02.png)'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](Images/f0477-02.png)'
- en: '![images](Images/3-circle.png) The event handler calls repaint() on the frame.
    The system calls paintComponent() on the drawing panel.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/3-circle.png) 事件处理程序在框架上调用`repaint()`。系统在绘图面板上调用`paintComponent()`。'
- en: '![images](Images/4-circle.png) Voilà! A new color is painted because paintComponent()
    runs again, filling the circle with a random color.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/4-circle.png) 哇！由于再次运行`paintComponent()`，一个新的颜色被绘制在圆圈中。'
- en: '![image](Images/f0477-03.png)'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](Images/f0477-03.png)'
- en: '![image](Images/f0478-01.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0478-01.png)'
- en: 'GUI layouts: putting more than one widget on a frame'
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GUI布局：在框架上放置多个小部件
- en: 'We cover GUI layouts in the *next* chapter, but we’ll do a quickie lesson here
    to get you going. By default, a frame has five regions you can add to. You can
    add only *one* thing to each region of a frame, but don’t panic! That one thing
    might be a panel that holds three other things including a panel that holds two
    more things and...you get the idea. In fact, we were “cheating” when we added
    a button to the frame using:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*下一*章节中介绍GUI布局，但我们将在这里进行快速学习以帮助您入门。默认情况下，一个框架有五个可以添加的区域。您只能向框架的每个区域添加*一*个东西，但不要惊慌！这个东西可能是一个面板，它包含三个其他东西，包括一个面板，其中包含两个更多的东西和...你明白了。事实上，当我们使用以下方式将按钮添加到框架时，我们是在“作弊”：
- en: '![image](Images/f0478-02.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0478-02.png)'
- en: '**The circle changes color each time you click the button.**'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**每次点击按钮时，圆圈的颜色都会改变。**'
- en: '![image](Images/f0479-01.png)![image](Images/f0479-02.png)![image](Images/f0479-03.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0479-01.png)![图片](Images/f0479-02.png)![图片](Images/f0479-03.png)'
- en: Let’s try it with TWO buttons
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们用两个按钮试试
- en: The south button will act as it does now, simply calling repaint on the frame.
    The second button (which we’ll stick in the east region) will change the text
    on a label. (A label is just text on the screen.)
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 南侧按钮将继续如现在一样运行，只需在框架上调用`repaint`。第二个按钮（我们将其放在东侧区域）将更改标签上的文本。（标签只是屏幕上的文本。）
- en: So now we need FOUR widgets
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 所以现在我们需要四个小部件
- en: '![image](Images/f0480-01.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0480-01.png)'
- en: And we need to get TWO events
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们需要得到两个事件
- en: Uh-oh.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 啊哦。
- en: Is that even possible? How do you get *two* events when you have only *one*
    actionPerformed() method?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这种可能吗？当你只有一个`actionPerformed()`方法时，如何得到*两个*事件？
- en: '![image](Images/f0480-02.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0480-02.png)'
- en: How do you get action events for two different buttons when each button needs
    to do something different?
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当每个按钮需要执行不同操作时，如何获取两个不同按钮的操作事件？
- en: '![image](Images/f0483-01.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0483-01.png)'
- en: Inner class to the rescue!
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内部类来拯救！
- en: You *can* have one class nested inside another. It’s easy. Just make sure that
    the definition for the inner class is *inside* the curly braces of the outer class.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 您*可以*在一个类中嵌套另一个类。这很容易。只需确保内部类的定义在外部类的大括号*内部*。
- en: '**Simple inner class:**'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**简单的内部类：**'
- en: '![image](Images/f0484-01.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0484-01.png)'
- en: An inner class gets a special pass to use the outer class’s stuff. *Even the
    private stuff.* And the inner class can use those private variables and methods
    of the outer class as if the variables and members were defined in the inner class.
    That’s what’s so handy about inner classes—they have most of the benefits of a
    normal class, but with special access rights.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 内部类可以特别使用外部类的东西。*甚至是私有的东西。* 内部类可以像在内部类中定义了这些私有变量和方法一样使用外部类的私有变量和方法。这就是内部类如此方便的地方——它们具有普通类的大部分优点，但具有特殊的访问权限。
- en: '**Inner class using an outer class variable**'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用外部类变量的内部类**'
- en: '![image](Images/f0484-02.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0484-02.png)'
- en: An inner class instance must be tied to an outer class instance*
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内部类实例必须与外部类实例绑定*
- en: Remember, when we talk about an inner *class* accessing something in the outer
    class, we’re really talking about an *instance* of the inner class accessing something
    in an *instance* of the outer class. But *which* instance?
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当我们讨论内部*类*访问外部类的东西时，我们实际上是在讨论内部类的*实例*访问外部类的*实例*中的东西。但是*哪个*实例？
- en: Can *any* arbitrary instance of the inner class access the methods and variables
    of *any* instance of the outer class? **No!**
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*任何*内部类的任意实例都可以访问*任何*外部类的方法和变量吗？**不！**'
- en: '*An **inner** object must be tied to a specific **outer** object on the heap.*'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*一个**内部**对象必须与堆上的一个特定**外部**对象绑定。*'
- en: '![image](Images/f0485-03.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0485-03.png)'
- en: '![images](Images/1.png) Make an instance of the outer class'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/1.png) 创建外部类的一个实例'
- en: '![image](Images/f0485-01.png)'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](Images/f0485-01.png)'
- en: '![images](Images/2.png) Make an instance of the inner class, by using the instance
    of the outer class.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/2.png) 通过外部类的实例来创建内部类的一个实例。'
- en: '![image](Images/f0485-02.png)'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](Images/f0485-02.png)'
- en: '![images](Images/3.png) The outer and inner objects are now intimately linked.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/3.png) 外部对象和内部对象现在紧密相连。'
- en: '![image](Images/f0485-04.png)'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](Images/f0485-04.png)'
- en: '* There’s an exception to this, for a very special case—an inner class defined
    within a static method. But we’re not going there, and you might go your entire
    Java life without ever encountering one of these.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*有一个例外情况，对于一个非常特殊的情况——在静态方法内定义的内部类。但我们不会涉及到这一点，你可能在整个Java生涯中都不会遇到这种情况。'
- en: How to make an instance of an inner class
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何创建内部类的一个实例
- en: If you instantiate an inner class from code *within* an outer class, the instance
    of the outer class is the one that the inner object will “bond” with. For example,
    if code within a method instantiates the inner class, the inner object will bond
    to the instance whose method is running.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在外部类的代码*内部*实例化一个内部类，那么内部对象将与外部类的实例“绑定”。例如，如果方法内的代码实例化内部类，内部对象将与正在运行方法的实例绑定。
- en: Code in an outer class can instantiate one of its own inner classes, in exactly
    the same way it instantiates any other class...**`new MyInner()`**.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 外部类中的代码可以实例化自己的内部类，就像实例化任何其他类一样...**`new MyInner()`**。
- en: '![image](Images/f0486-01.png)![image](Images/f0486-02.png)![image](Images/f0486-03.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0486-01.png)![图片](Images/f0486-02.png)![图片](Images/f0486-03.png)'
- en: '**Now we can get the two-button code working**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**现在我们可以让两个按钮的代码运行起来**'
- en: '![image](Images/f0487-01.png)![image](Images/f0487-02.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0487-01.png)![图片](Images/f0487-02.png)'
- en: Java Exposed
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java揭秘
- en: '![image](Images/f0488-01.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0488-01.png)'
- en: '**This week’s interview: Instance of an Inner Class**'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**本周的访谈：内部类的实例**'
- en: '**HeadFirst:** What makes inner classes important?'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**HeadFirst:** 什么使内部类如此重要？'
- en: '**Inner object:** Where do I start? We give you a chance to implement the same
    interface more than once in a class. Remember, you can’t implement a method more
    than once in a normal Java class. But using *inner* classes, each inner class
    can implement the *same* interface, so you can have all these *different* implementations
    of the very same interface methods.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**内部对象:** 我从哪里开始？我们给你一个机会在一个类中多次实现相同的接口。记住，在普通的Java类中，你不能多次实现一个方法。但是使用*内部*类，每个内部类都可以实现*相同*的接口，因此你可以有所有这些*不同*的实现方式的相同接口方法。'
- en: '**HeadFirst:** *Why would you ever* want to implement the same method twice?'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**HeadFirst:** *你为什么要*想要实现同一个方法两次？'
- en: '**Inner object:** *Let’s revisit GUI event handlers. Think about it...if you
    want* three *buttons to each have a different event behavior, then use* three
    inner classes, all implementing ActionListener—which means each class gets to
    implement its own actionPerformed method.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**内部对象:** *让我们重新思考GUI事件处理程序。想想看...如果你想要*三个*按钮每个都有不同的事件行为，那么使用*三个*实现ActionListener的内部类，这意味着每个类都可以实现自己的actionPerformed方法。'
- en: '**HeadFirst:** So are event handlers the only reason to use inner classes?'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**HeadFirst:** 那么事件处理程序是使用内部类的唯一原因吗？'
- en: '**Inner object:** *Oh, gosh no. Event handlers are just an obvious example.
    Anytime you need a separate class but still want that class to behave as if it
    were part of* another *class, an inner class is the best—and sometimes* only—way
    to do it.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**内部对象:** *哦，天啊。事件处理程序只是一个明显的例子。每当你需要一个独立的类但仍希望该类表现得好像是*另一个*类的一部分时，内部类是最好的——有时是*唯一*的方法。'
- en: '**HeadFirst:** *I’m still confused here. If you want the inner class to* behave
    *like it belongs to the outer class, why have a separate class in the first place?
    Why wouldn’t the inner class code just be* in the outer class in the first place?'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**HeadFirst:** *我还是很困惑。如果你希望内部类*表现得*像属于外部类一样，为什么一开始就有一个单独的类呢？为什么内部类的代码不直接放在外部类中呢？'
- en: '**Inner object:** *I just* gave *you one scenario, where you need more than
    one implementation of an interface. But even when you’re not using interfaces,
    you might need two different* classes *because those classes represent two different*
    things. It’s good OO.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**Inner object:** *我刚刚*给了*你一个场景，在那里你需要多个接口的实现。但即使你不使用接口，你可能也需要两个不同*的类*，因为这些类代表两个不同的*事物。这是良好的OO设计。'
- en: '**HeadFirst:** *Whoa. Hold on here. I thought a big part of OO design is about
    reuse and maintenance. You know, the idea that if you have two separate classes,
    they can each be modified and used independently, as opposed to stuffing it all
    into one class yada yada yada. But with an* inner *class, you’re still just working
    with one* real class in the end, right? The enclosing class is the only one that’s
    reusable and separate from everybody else. Inner classes aren’t exactly reusable.
    In fact, I’ve heard them called “Reuseless—useless over and over again.”'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**HeadFirst:** *哇。等一下。我以为OO设计的一个重要部分是关于重用和维护的。你知道的，如果你有两个单独的类，它们可以各自修改和独立使用，而不是把所有东西都塞进一个类里面，等等。但是对于一个*内部*类来说，你最终仍然只是在处理一个*真实的类，对吗？外部类是唯一可以重用并与其他人分离的类。内部类并不完全可重用。事实上，我听说过它们被称为“无法重用——一遍又一遍”。'
- en: '**Inner object:** Yes, it’s true that the inner class is not *as* reusable,
    in fact sometimes not reusable at all, because it’s intimately tied to the instance
    variables and methods of the outer class. But it—'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**Inner object:** 是的，内部类确实不*像*可重用，有时甚至完全不可重用，因为它与外部类的实例变量和方法紧密联系。但是—'
- en: '**HeadFirst:** —which only proves my point! If they’re not reusable, why bother
    with a separate class? I mean, other than the interface issue, which sounds like
    a workaround to me.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**HeadFirst:** —这只是证明了我的观点！如果它们不可重用，为什么还要费劲去做一个单独的类？我是说，除了接口问题之外，这听起来像是一个变通方法。'
- en: '**Inner object:** As I was saying, you need to think about IS-A and polymorphism.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**Inner object:** 正如我之前所说，你需要考虑IS-A和多态性。'
- en: '**HeadFirst:** OK. And I’m thinking about them because...'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**HeadFirst:** 好的。我之所以考虑它们是因为...'
- en: '**Inner object:** *Because the outer and inner classes might need to pass*
    different *IS-A tests! Let’s start with the polymorphic GUI listener example.
    What’s the declared argument type for the button’s listener registration method?
    In other words, if you go to the API and check, what kind of* thing (class or
    interface type) do you have to pass to the addActionListener() method?'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**Inner object:** *因为外部和内部类可能需要通过*不同*的IS-A测试！让我们从多态GUI监听器的例子开始。按钮的监听器注册方法的声明参数类型是什么？换句话说，如果你去API检查，你必须传递给addActionListener()方法什么样的*东西（类或接口类型）？'
- en: '**HeadFirst:** You have to pass a listener. Something that implements a particular
    listener interface, in this case ActionListener. Yeah, we know all this. What’s
    your point?'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**HeadFirst:** 你必须传递一个监听器。某个实现特定监听器接口的东西，这种情况下是ActionListener。是的，我们知道这些。你的观点是什么？'
- en: '**Inner object:** *My point is that polymorphically, you have a method that
    takes only one particular* type*. Something that passes the IS-A test for ActionListener.
    But—and here’s the big thing—what if your class needs to be an IS-A of something
    that’s a* class type rather than an interface?'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**Inner object:** *我的观点是，从多态的角度看，你有一个方法只接受一个特定的*类型*。需要通过ActionListener的IS-A测试。但是——这里有一个重要的问题——如果你的类需要成为某个*类*类型的IS-A，而不是一个接口呢？'
- en: '**HeadFirst:** *Wouldn’t you have your class just* extend the class you need
    to be a part of? Isn’t that the whole point of how subclassing works? If B is
    a subclass of A, then anywhere an A is expected a B can be used. The whole pass-a-Dog-where-an-Animal-is-the-declared-type
    thing.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**HeadFirst:** *你会让你的类*扩展*你需要成为一部分的类吗？这不就是子类化的全部意义吗？如果B是A的子类，那么任何需要A的地方都可以使用B。这就是传递一个Dog到期望Animal的地方的整个过程。'
- en: '**Inner object:** Yes! Bingo! So now what happens if you need to pass the IS-A
    test for two different classes? Classes that aren’t in the same inheritance hierarchy?'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**Inner object:** 是的！ Bingo！那么现在如果你需要通过两个不同类的IS-A测试会发生什么？那些类不在同一个继承层次结构中？'
- en: '**HeadFirst:** *Oh, well you just...hmmm. I think I’m getting it. You can always*
    implement *more than one interface, but you can* extend *only* one *class. You
    can be only one kind of IS-A when it comes to* class types.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**HeadFirst:** *哦，好吧，你只是...嗯。我想我明白了。你总是可以*实现*多个接口，但你只能*扩展*一个*类。当涉及到*类类型*时，你只能成为一种IS-A。'
- en: '**Inner object:** *Well done! Yes, you can’t be both a Dog and a Button. But
    if you’re a Dog that needs to sometimes be a Button (in order to pass yourself
    to methods that take a Button), the Dog class (which extends Animal so it can’t
    extend Button) can have an* inner class that acts on the Dog’s behalf as a Button,
    by extending Button, and thus wherever a Button is required, the Dog can pass
    his inner Button instead of himself. In other words, instead of saying x.takeButton(this),
    the Dog object calls x.takeButton(new MyInnerButton()).'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**内部对象：** *干得漂亮！是的，你不能同时是狗和按钮。但如果你是一个需要有时表现为按钮的狗（为了把自己传递给需要按钮的方法），那么狗类（继承了
    Animal 所以不能继承 Button）可以有一个* 内部类，代表狗的按钮行为，继承按钮，这样在需要按钮的地方，狗可以传递他的内部按钮而不是他自己。换句话说，不是说
    x.takeButton(this)，而是狗对象调用 x.takeButton(new MyInnerButton())。'
- en: '**HeadFirst:** Can I get a clear example?'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**HeadFirst：** 能给我一个清晰的例子吗？'
- en: '**Inner object:** Remember the drawing panel we used, where we made our own
    subclass of JPanel? Right now, that class is a separate, non-inner, class. And
    that’s fine, because the class doesn’t need special access to the instance variables
    of the main GUI. But what if it did? What if we’re doing an animation on that
    panel, and it’s getting its coordinates from the main application (say, based
    on something the user does elsewhere in the GUI). In that case, if we make the
    drawing panel an inner class, the drawing panel class gets to be a subclass of
    JPanel, while the outer class is still free to be a subclass of something else.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**内部对象：** 记得我们用过的绘图面板吗？我们在那里创建了自己的 JPanel 子类？现在，那个类是一个独立的非内部类。这没问题，因为这个类不需要特殊访问主
    GUI 的实例变量。但如果需要呢？如果我们在面板上做动画，它的坐标是从主应用程序获取的（比如基于用户在 GUI 其他地方的操作）。在这种情况下，如果把绘图面板设为内部类，绘图面板类就可以成为
    JPanel 的子类，而外部类仍然可以自由地成为其他类的子类。'
- en: '**HeadFirst:** Yes, I see! And the drawing panel isn’t reusable enough to be
    a separate class anyway, since what it’s actually painting is specific to this
    one GUI application.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**HeadFirst：** 是的，我明白了！而且绘图面板本身不够可重用，不能作为一个独立的类，因为它实际上所绘制的内容是特定于这个 GUI 应用程序的。'
- en: '**Inner object:** Yes! You’ve got it!'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**内部对象：** 是的！你懂了！'
- en: '**HeadFirst:** *Good. Then we can move on to the nature of the* relationship
    between you and the outer instance.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**HeadFirst：** *好的。那么我们可以继续谈谈* 你与外部实例的关系的本质。'
- en: '**Inner object:** What is it with you people? Not enough sordid gossip in a
    serious topic like polymorphism?'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**内部对象：** 你们这些人怎么了？在像多态这样严肃的话题上，八卦还不够吗？'
- en: '**HeadFirst:** Hey, you have no idea how much the public is willing to pay
    for some good old tabloid dirt. So, someone creates you, and you become instantly
    bonded to the outer object, is that right?'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**HeadFirst：** 嘿，你不知道公众愿意为一些老旧小报八卦消息支付多少钱。那么，有人创建了你，然后你立即与外部对象绑定，对吗？'
- en: '**Inner object:** Yes, that’s right.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**内部对象：** 是的，就是这样。'
- en: '**HeadFirst:** What about the outer object? Can it be associated with any other
    inner objects?'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**HeadFirst：** 外部对象呢？它可以与其他内部对象关联吗？'
- en: '**Inner object:** *So now we have it. This is what you* really *wanted. Yes,
    yes. My so-called* “mate” can have as many inner objects as it wants.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**内部对象：** *现在我们知道了。这才是你真正想要的。是的，是的。我的所谓“伴侣”可以有多少个内部对象都行。*'
- en: '**HeadFirst:** Is that like, serial monogamy? Or can it have them all at the
    same time?'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**HeadFirst：** 那是类似于连续一夫一妻制吗？还是可以同时拥有所有这些？'
- en: '**Inner object:** All at the same time. There. Satisfied?'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**内部对象：** 全部同时存在。满意了吧？'
- en: '**HeadFirst:** *Well, it does make sense. And let’s not forget, it was* you
    extolling the virtues of “multiple implementations of the same interface.” So
    it makes sense that if the outer class has three buttons, it would need three
    different inner classes (and thus three different inner class objects) to handle
    the events.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**HeadFirst：** *嗯，这确实有道理。别忘了，是* 你在赞扬“同一个接口的多个实现”。所以如果外部类有三个按钮，它需要三个不同的内部类（因此三个不同的内部类对象）来处理事件。'
- en: '**Inner objects:** You got it!'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**内部对象们：** 你懂了！'
- en: '**HeadFirst:** One more question. I’ve heard that when lambdas came along,
    you were almost put out of a job?'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**HeadFirst：** 再问一个问题。我听说，当 Lambda 出现时，你差点失业了？'
- en: '**Inner objects:** Ouch, that really hurts! Okay, full disclosure, there are
    many cases for which a lambda is an easier to read, more concise way to do what
    I do. But inner classes have been around for a long time, and you’re sure to encounter
    us in older code. Plus, those pesky lambdas aren’t better at everything..'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**内部对象：**哎呀，这真的很痛！好吧，完全披露，有很多情况下lambda是一个更容易阅读、更简洁的方式来做我所做的事情。但内部类已经存在很长时间了，你肯定会在旧代码中遇到我们。而且，这些讨厌的lambda并不是在所有方面都更好。'
- en: '![image](Images/f0489-01.png)![image](Images/f0490-01.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0489-01.png)![image](Images/f0490-01.png)'
- en: Lambdas to the rescue! (again)
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda再次拯救！
- en: 'He’s not wrong! One way to interpret the two highlighted lines of code would
    be:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 他说得没错！解释两行代码中的内容的一种方式可能是：
- en: “When the `labelButton` *ActionListener gets an event,* `setText("Ouch");`”
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: “当`labelButton`的*ActionListener收到事件*时，`setText("Ouch");`”
- en: Not only are those two ideas separated from each other in the code, the inner
    class takes FIVE lines of code to invoke the setText method. And of course, everything
    we’ve said about the labelButton code is also true about the colorButton code.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个想法在代码中是分开的，内部类需要五行代码来调用`setText`方法。当然，我们对`labelButton`代码说的一切也适用于`colorButton`代码。
- en: Remember a few pages back we said that in order to implement the ActionListener
    interface you had provide code for its actionPerformed method? Hmmm...does that
    ring any bells?
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得前几页我们说过为了实现ActionListener接口，你需要为其`actionPerformed`方法提供代码吗？嗯...这是不是让你想起了什么？
- en: '![image](Images/f0490-02.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0490-02.png)'
- en: ActionListener is a Functional Interface
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ActionListener是一个函数式接口
- en: '**Remember that a lambda provides an implementation for a functional interface’s
    *one and only* abstract method.**'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**记住，lambda为函数式接口的*唯一*抽象方法提供了实现。**'
- en: Since ActionListener is a functional interface, you can replace the inner classes
    we saw on the previous page with lambda expressions.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 由于ActionListener是一个函数式接口，你可以用lambda表达式替换我们在前一页看到的内部类。
- en: '![image](Images/f0491-01.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0491-01.png)'
- en: Lambdas, clearer and more concise
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda，更清晰更简洁
- en: Well, maybe not quite yet, but once you get used to reading lambdas, we’re pretty
    sure you’ll agree that they make your code clearer.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，也许现在还不完全明白，但一旦你习惯阅读lambda，我们相信你会同意它们让你的代码更清晰。
- en: Using an inner class for animation
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用内部类进行动画
- en: We saw why inner classes are handy for event listeners, because you get to implement
    the same event-handling method more than once. But now we’ll look at how useful
    an inner class is when used as a subclass of something the outer class doesn’t
    extend. In other words, when the outer class and inner class are in different
    inheritance trees!
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到为什么内部类对于事件监听器很方便，因为你可以多次实现相同的事件处理方法。但现在我们将看看当内部类被用作外部类不扩展的东西的子类时，内部类是多么有用。换句话说，当外部类和内部类在不同的继承树中时！
- en: Our goal is to make a simple animation, where the circle moves across the screen
    from the upper left down to the lower right.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是制作一个简单的动画，圆圈从屏幕的左上角向右下角移动。
- en: '![image](Images/f0492-01.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0492-01.png)'
- en: '**How simple animation works**'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '**简单动画的工作原理**'
- en: '![images](Images/1.png) Paint an object at a particular x and y coordinate.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![images](Images/1.png) 在特定的x和y坐标处绘制一个对象。'
- en: '![image](Images/f0492-02.png)'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0492-02.png)'
- en: '![images](Images/2.png) Repaint the object at a different x and y coordinate.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![images](Images/2.png) 在不同的x和y坐标处重新绘制对象。'
- en: '![image](Images/f0492-03.png)'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0492-03.png)'
- en: '![images](Images/3.png) Repeat the previous step with changing x and y values
    for as long as the animation is supposed to continue.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![images](Images/3.png) 重复上一步，改变x和y的值，直到动画应该继续。'
- en: '**What we really want is something like...**'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们真正想要的是这样的东西...**'
- en: '![image](Images/f0493-01.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0493-01.png)'
- en: '**The complete simple animation code**'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**完整的简单动画代码**'
- en: '![image](Images/f0494-01.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0494-01.png)'
- en: '**Did it work?**'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**它起作用了吗？**'
- en: You might not have got the smooth animation that you expected.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能没有得到你期望的平滑动画。
- en: What did we do wrong?
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做错了什么？
- en: There’s one little flaw in the paintComponent() method.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在`paintComponent()`方法中有一个小缺陷。
- en: '**We need to erase what was already there! Or we might get trails.**'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们需要擦除已经存在的内容！否则可能会留下痕迹。**'
- en: 'To fix it, all we have to do is fill in the entire panel with the background
    color, before painting the circle each time. The code below adds two lines at
    the start of the method: one to set the color to white (the background color of
    the drawing panel) and the other to fill the entire panel rectangle with that
    color. In English, the code below says, “Fill a rectangle starting at x and y
    of 0 (0 pixels from the left and 0 pixels from the top) and make it as wide and
    as high as the panel is currently.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 要修复它，我们只需在每次绘制圆之前用背景色填充整个面板。下面的代码在方法开头添加了两行：一行将颜色设置为白色（绘图面板的背景色），另一行用该颜色填充整个面板矩形。用英语说，下面的代码表示：“在
    x 和 y 处填充一个矩形（从左侧和顶部各 0 像素）并使其宽度和高度与当前面板一样。”
- en: '![image](Images/f0495-01.png)![image](Images/f0495-02.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0495-01.png)![image](Images/f0495-02.png)'
- en: '![image](Images/arr.png) **Yours to solve.**'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '![image](Images/arr.png) **由你来解决。**'
- en: Code Kitchen
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码厨房
- en: '![image](Images/f0496-01.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0496-01.png)'
- en: '**Let’s make a music video. We’ll use Java-generated random graphics that keep
    time with the music beats.**'
  id: totrans-247
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**让我们制作一个音乐视频。我们将使用与音乐节拍同步的 Java 生成的随机图形。**'
- en: ''
  id: totrans-248
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Along the way we’ll register (and listen for) a new kind of non-GUI event,
    triggered by the music itself.**'
  id: totrans-249
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**在此过程中，我们将注册（并监听）一个由音乐本身触发的新类型的非 GUI 事件。**'
- en: Note
  id: totrans-250
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Remember, this part is all optional. But we think it’s good for you. And you’ll
    like it. And you can use it to impress people.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这部分是可选的。但我们认为这对你有好处。而且你会喜欢它的。你可以用它来给人留下深刻的印象。
- en: (OK, sure, it might work only on people who are really easy to impress, but
    still....)
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: （好吧，当然，它可能只对那些很容易被打动的人有效，但是....）
- en: Listening for a non-GUI event
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监听非 GUI 事件
- en: OK, maybe not a music video, but we *will* make a program that draws random
    graphics on the screen with the beat of the music. In a nutshell, the program
    listens for the beat of the music and draws a random graphic rectangle with each
    beat.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: OK，也许不是一个音乐视频，但我们*确实*会制作一个程序，在音乐的节拍下在屏幕上绘制随机图形。简而言之，程序监听音乐的节拍，并在每个节拍时绘制一个随机的矩形图形。
- en: 'That brings up some new issues for us. So far, we’ve listened for only GUI
    events, but now we need to listen for a particular kind of MIDI event. Turns out,
    listening for a non-GUI event is just like listening for GUI events: you implement
    a listener interface, register the listener with an event source, and then sit
    back and wait for the event source to call your event-handler method (the method
    defined in the listener interface).'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们带来了一些新问题。到目前为止，我们只听取了 GUI 事件，但现在我们需要监听特定类型的 MIDI 事件。事实证明，监听非 GUI 事件就像监听
    GUI 事件一样：您实现一个监听器接口，将监听器注册到事件源，然后坐等事件源调用您的事件处理方法（监听器接口中定义的方法）。
- en: The simplest way to listen for the beat of the music would be to register and
    listen for the actual MIDI events so that whenever the sequencer gets the event,
    our code will get it too and can draw the graphic. But...there’s a problem. A
    bug, actually, that won’t let us listen for the MIDI events *we’re* making (the
    ones for NOTE ON).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 监听音乐节拍的最简单方法是注册和监听实际的 MIDI 事件，以便每当序列器获得事件时，我们的代码也会得到它，并且可以绘制图形。但是...有一个问题。实际上是一个
    bug，它让我们无法监听我们制作的 MIDI 事件（NOTE ON 的那些事件）。
- en: 'So we have to do a little workaround. There is another type of MIDI event we
    can listen for, called a ControllerEvent. Our solution is to register for ControllerEvents
    and then make sure that for every NOTE ON event, there’s a matching ControllerEvent
    fired at the same “beat.” How do we make sure the ControllerEvent is fired at
    the same time? We add it to the track just like the other events! In other words,
    our music sequence goes like this:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要做一些变通。还有另一种类型的 MIDI 事件我们可以监听，称为 ControllerEvent。我们的解决方案是注册 ControllerEvents，然后确保每个
    NOTE ON 事件都有一个在同一“节拍”触发的 ControllerEvent。我们如何确保 ControllerEvent 在同一时间被触发呢？我们像其他事件一样将其添加到轨道中！换句话说，我们的音乐序列是这样的：
- en: BEAT 1 - NOTE ON, CONTROLLER EVENT
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: BEAT 1 - NOTE ON, CONTROLLER EVENT
- en: BEAT 2 - NOTE OFF
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: BEAT 2 - NOTE OFF
- en: BEAT 3 - NOTE ON, CONTROLLER EVENT
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: BEAT 3 - NOTE ON, CONTROLLER EVENT
- en: BEAT 4 - NOTE OFF
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: BEAT 4 - NOTE OFF
- en: and so on.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 等等。
- en: Before we dive into the full program, though, let’s make it a little easier
    to make and add MIDI messages/events since in *this* program, we’re gonna make
    a lot of them.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入全面程序之前，让我们让制作和添加 MIDI 消息/事件变得更加容易，因为在*这个*程序中，我们会制作很多这样的事件。
- en: '**What the music art program needs to do:**'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**音乐艺术程序需要做的事情：**'
- en: '![images](Images/1.png) Make a series of MIDI messages/events to play random
    notes on a piano (or whatever instrument you choose).'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/1.png) 制作一系列MIDI消息/事件，以在钢琴（或您选择的其他乐器）上播放随机音符。'
- en: '![images](Images/2.png) Register a listener for the events.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/2.png) 为事件注册监听器。'
- en: '![images](Images/3.png) Start the sequencer playing.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/3.png) 开始播放定序器。'
- en: '![images](Images/4.png) Each time the listener’s event handler method is called,
    draw a random rectangle on the drawing panel, and call repaint.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/4.png) 每次调用监听器的事件处理程序方法时，在绘图面板上绘制一个随机矩形，并调用repaint。'
- en: '**We’ll build it in three iterations:**'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们将分三个迭代来构建它：**'
- en: '![images](Images/1.png) Version One: Code that simplifies making and adding
    MIDI events, since we’ll be making a lot of them.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/1.png) 第一版本：简化制作和添加MIDI事件的代码，因为我们将会制作很多这样的事件。'
- en: '![images](Images/2.png) Version Two: Register and listen for the events, but
    without graphics. Prints a message at the command line with each beat.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/2.png) 第二版本：注册并监听事件，但没有图形界面。每拍节拍都在命令行打印一条消息。'
- en: '![images](Images/3.png) Version Three: The real deal. Adds graphics to version
    two.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/3.png) 第三版本：真实操作。将图形添加到第二版本。'
- en: An easier way to make messages/events
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作消息/事件的更简单方法
- en: Right now, making and adding messages and events to a track is tedious. For
    each message, we have to make the message instance (in this case, ShortMessage),
    call setMessage(), make a MidiEvent for the message, and add the event to the
    track. In the previous chapter’s code, we went through each step for every message.
    That means eight lines of code just to make a note play and then stop playing!
    Four lines to add a NOTE ON event, and four lines to add a NOTE OFF event.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，制作并添加轨道上的消息和事件非常繁琐。对于每条消息，我们必须创建消息实例（在本例中为ShortMessage），调用setMessage()，创建消息的MidiEvent，并将事件添加到轨道中。在上一章节的代码中，我们对每条消息进行了详细步骤。这意味着仅仅为了播放音符并停止播放，需要写八行代码！四行用于添加NOTE
    ON事件，另外四行用于添加NOTE OFF事件。
- en: '[PRE3]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Things that have to happen for each event:**'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '**每个事件都必须发生的事情：**'
- en: '![images](Images/1.png) Make a message instance'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/1.png) 制作消息实例'
- en: '`**ShortMessage msg = new ShortMessage();**`'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`**ShortMessage msg = new ShortMessage();**`'
- en: '![images](Images/2.png) Call setMessage() with the instructions'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/2.png) 使用指令调用setMessage()'
- en: '`**msg.setMessage(NOTE_ON, 1, instrument, 0);**`'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`**msg.setMessage(NOTE_ON, 1, instrument, 0);**`'
- en: '![images](Images/3.png) Make a MidiEvent instance for the message'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/3.png) 为消息创建一个MidiEvent实例'
- en: '`**MidiEvent noteOn = new MidiEvent(msg, 1);**`'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`**MidiEvent noteOn = new MidiEvent(msg, 1);**`'
- en: '![images](Images/4.png) Add the event to the track'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/4.png) 将事件添加到轨道上'
- en: '`**track.add(noteOn);**`'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`**track.add(noteOn);**`'
- en: '**Let’s build a static utility method that makes a message and returns a MidiEvent**'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '**让我们建立一个静态的实用方法来制作消息并返回MidiEvent**'
- en: '![image](Images/f0498-02.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0498-02.png)'
- en: 'Version One: using the new static makeEvent() method'
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一版本：使用新的静态makeEvent()方法
- en: There’s no event handling or graphics here, just a sequence of 15 notes that
    go up the scale. The point of this code is simply to learn how to use our new
    makeEvent() method. The code for the next two versions is much smaller and simpler
    thanks to this method.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有事件处理或图形，只是一个顺序的15个音符，沿着音阶上升。这段代码的目的只是学习如何使用我们的新makeEvent()方法。由于这个方法，接下来两个版本的代码变得更加简洁和简单。
- en: '![image](Images/f0499-01.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0499-01.png)'
- en: 'Version Two: registering and getting ControllerEvents'
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二版本：注册并获取ControllerEvents
- en: '![image](Images/f0500-01.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0500-01.png)'
- en: Note
  id: totrans-292
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**Code that’s different from the previous version is highlighted in gray (and
    we’ve moved the code out of the main() method into its own go() method).**'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '**与上一个版本不同的代码以灰色突出显示（并且我们已将代码从main()方法移到了独立的go()方法中）。**'
- en: 'Version Three: drawing graphics in time with the music'
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三版本：与音乐同步绘制图形
- en: This final version builds on Version Two by adding the GUI parts. We build a
    frame and add a drawing panel to it, and each time we get an event, we draw a
    new rectangle and repaint the screen. The only other change from Version Two is
    that the notes play randomly as opposed to simply moving up the scale.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这最终版本在第二版本的基础上添加了GUI部分。我们建立一个框架并向其添加绘图面板，每次获得事件时，我们绘制一个新的矩形并重新绘制屏幕。与第二版本唯一的变化是音符随机播放，而不是简单地按音阶移动。
- en: The most important change to the code (besides building a simple GUI) is that
    we make the drawing panel implement the ControllerEventListener rather than the
    program itself. So when the drawing panel (an inner class) gets the event, it
    knows how to take care of itself by drawing the rectangle.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的最重要变化（除了构建一个简单的GUI之外）是，我们使绘图面板实现ControllerEventListener，而不是程序本身。因此，当绘图面板（一个内部类）接收到事件时，它知道如何通过绘制矩形来自我照顾。
- en: Complete code for this version is on the next page.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 此版本的完整代码在下一页。
- en: '**The drawing panel inner class:**'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '**绘图面板内部类:**'
- en: '![image](Images/f0501-01.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0501-01.png)'
- en: '![image](Images/arr.png) **Yours to solve.**'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](Images/arr.png) **由你来解决。**'
- en: '[PRE4]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Exercise
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: '![image](Images/exercise.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/exercise.png)'
- en: A bunch of Java hotshots, in full costume, are playing the party game “Who am
    I?” They give you a clue, and you try to guess who they are, based on what they
    say. Assume they always tell the truth about themselves. If they happen to say
    something that could be true for more than one guy, then write down all for whom
    that sentence applies. Fill in the blanks next to the sentence with the names
    of one or more attendees.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 一群Java高手，穿着整装，正在玩“我是谁？”的派对游戏。他们给了你一个线索，你根据他们说的话来猜他们是谁。假设他们关于自己总是说实话。如果他们碰巧说的话对于多个人可能都是真实的，那么请写下所有适用的人名，并在句子旁边的空白处填写一个或多个参与者的名字。
- en: Who Am I?
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我是谁？
- en: '![image](Images/f0504-02.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0504-02.png)'
- en: '**Tonight’s attendees:**'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '**今晚的参与者：**'
- en: '**Any of the charming personalities from this chapter just might show up!**'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章节中任何迷人的个性可能都会出现！**'
- en: '| **I got the whole GUI, in my hands.** | ______________________ |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| **我拿到整个GUI了，就在我手中。** | ______________________ |'
- en: '| **Every event type has one of these.** | ______________________ |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| **每种事件类型都有一个这样的东西。** | ______________________ |'
- en: '| **The listener’s key method.** | ______________________ |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| **监听器的关键方法。** | ______________________ |'
- en: '| **This method gives JFrame its size.** | ______________________ |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| **此方法使 JFrame 获得其大小。** | ______________________ |'
- en: '| **You add code to this method but never call it.** | ______________________
    |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| **你向这个方法添加代码，但从不调用它。** | ______________________ |'
- en: '| **When the user actually does something, it’s an _____ .** | ______________________
    |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| **当用户真正做某事时，它是一个_____ 。** | ______________________ |'
- en: '| **Most of these are event sources.** | ______________________ |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| **这些大多数是事件源。** | ______________________ |'
- en: '| **I carry data back to the listener.** | ______________________ |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| **我将数据返回给监听器。** | ______________________ |'
- en: '| **An addXxxListener( ) method says an object is an _____ .** | ______________________
    |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| **addXxxListener( ) 方法说对象是一个_____ 。** | ______________________ |'
- en: '| **How a listener signs up.** | ______________________ |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| **监听器如何注册。** | ______________________ |'
- en: '| **The method where all the graphics code goes.** | ______________________
    |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| **所有图形代码都放在这个方法中。** | ______________________ |'
- en: '| **I’m typically bound to an instance.** | ______________________ |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| **我通常绑定到一个实例。** | ______________________ |'
- en: '| **The “g” in (Graphics g) is really of this class.** | ______________________
    |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| **(Graphics g) 中的“g”实际上属于此类。** | ______________________ |'
- en: '| **The method that gets paintComponent( ) rolling.** | ______________________
    |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| **导致 paintComponent( ) 方法启动的方法。** | ______________________ |'
- en: '| **The package where most of the Swingers reside.** | ______________________
    |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| **大多数Swingers居住的包。** | ______________________ |'
- en: '![image](Images/arr.png) **Answers in [“Who am I?”](#who_am_iquestion_mark_left_parenthesisfr).**'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](Images/arr.png) **答案在[“Who am I?”](#who_am_iquestion_mark_left_parenthesisfr)中。**'
- en: BE the Compiler
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 成为编译器
- en: '![image](Images/f0505-02.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0505-02.png)'
- en: Note
  id: totrans-327
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The Java file on this page represents a complete source file. Your job is to
    play compiler and determine whether this file will compile. If it won’t compile,
    how would you fix it, and if it does compile, what would it do?
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 此页面上的 Java 文件表示完整的源文件。您的任务是扮演编译器，并确定此文件是否会编译。如果不能编译，您将如何修复它；如果能够编译，它将执行什么操作？
- en: '[PRE5]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![image](Images/arr.png) **Answers in [“BE the Compiler”](#be_the_compiler-id00003).**'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](Images/arr.png) **答案在[“成为编译器”](#be_the_compiler-id00003)中。**'
- en: Pool Puzzle
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pool Puzzle
- en: '![image](Images/f0506-01.png)![image](Images/f0506-02.png)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0506-01.png)![图片](Images/f0506-02.png)'
- en: Your ***job*** is to take code snippets from the pool and place them into the
    blank lines in the code. You **may** use the same snippet more than once, and
    you won’t need to use all the snippets. Your ***goal*** is to make a class that
    will compile and run and produce the output listed.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 你的***任务***是从池中获取代码片段，并将它们放入代码中的空白行。您**可以**多次使用相同的片段，并且不需要使用所有片段。您的***目标***是创建一个能够编译、运行并生成列出的输出的类。
- en: '**Output**'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出**'
- en: The Amazing, Shrinking, Blue Rectangle. This program will produce a blue rectangle
    that will shrink and shrink and disappear into a field of white.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊奇的、缩小的、蓝色矩形。这个程序将产生一个蓝色矩形，它会不断缩小并消失在白色的领域中。
- en: '![image](Images/f0506-03.png)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0506-03.png)'
- en: '**Note: Each snippet from the pool can be used more than once!**'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：池中的每个片段可以使用多次！**'
- en: '![image](Images/f0506-04.png)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0506-04.png)'
- en: '[PRE6]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![image](Images/arr.png) **Answers in [“Pool Puzzle”](#pool_puzzle_left_parenthesisfrom_page_50).**'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](Images/arr.png) **[“游泳池谜题”](#pool_puzzle_left_parenthesisfrom_page_50)的答案。**'
- en: Exercise Solutions
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习解决方案
- en: '![image](Images/exercise.png)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/exercise.png)'
- en: Who am I?
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我是谁？
- en: (from [“Exercise”](#exercise-id000023))
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: (来自[“练习”](#exercise-id000023))
- en: '| **I got the whole GUI, in my hands.** | JFrame |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| **我手中拿着整个 GUI。** | JFrame |'
- en: '| **Every event type has one of these.** | listener interface |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| **每种事件类型都有一个。** | 监听器接口 |'
- en: '| **The listener’s key method.** | actionPerformed( ) |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| **监听器的关键方法。** | actionPerformed( ) |'
- en: '| **This method gives JFrame its size.** | setSize( ) |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| **这个方法给 JFrame 设置大小。** | setSize( ) |'
- en: '| **You add code to this method but never call it.** | paintComponent( ) |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| **你向这个方法添加代码，但从未调用它。** | paintComponent( ) |'
- en: '| **When the user actually does something, it’s an ____ .** | event |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| **当用户实际执行操作时，它是一个 ____ 。** | 事件 |'
- en: '| **Most of these are event sources.** | swing components |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| **大多数这些都是事件源。** | Swing 组件 |'
- en: '| **I carry data back to the listener.** | event object |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| **我将数据传递回监听器。** | 事件对象 |'
- en: '| **An addXxxListener( ) method says an object is an ___ .** | event source
    |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| **addXxxListener( ) 方法表示一个对象是 ___ 。** | 事件源 |'
- en: '| **How a listener signs up.** | addXxxListener( ) |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| **监听器如何注册。** | addXxxListener( ) |'
- en: '| **The method where all the graphics code goes.** | paintComponent( ) |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| **所有图形代码都放在这个方法中。** | paintComponent( ) |'
- en: '| **I’m typically bound to an instance.** | inner class |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| **我通常绑定到一个实例。** | 内部类 |'
- en: '| **The “g” in (Graphics g) is really of this class.** | Graphics2D |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| **(Graphics g) 中的“g”实际上是这个类的。** | Graphics2D |'
- en: '| **The method that gets paintComponent( ) rolling.** | repaint( ) |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| **使 paintComponent( ) 开始运行的方法。** | repaint( ) |'
- en: '| **The package where most of the Swingers reside.** | javax.swing |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| **大多数 Swingers 驻留的包。** | javax.swing |'
- en: BE the Compiler
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 成为编译器
- en: (from [“BE the Compiler”](#be_the_compiler-id00003))
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: (来自[“成为编译器”](#be_the_compiler-id00003))
- en: '![image](Images/f0507-01.png)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0507-01.png)'
- en: Pool Puzzle
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游泳池谜题
- en: (from [“Pool Puzzle”](#pool_puzzle-id00006))
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: (来自[“游泳池谜题”](#pool_puzzle-id00006))
- en: '![image](Images/f0506-01.png)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0506-01.png)'
- en: '[PRE7]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The Amazing, Shrinking, Blue Rectangle.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊奇的、缩小的、蓝色矩形。
- en: '![image](Images/f0508-01.png)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0508-01.png)'
