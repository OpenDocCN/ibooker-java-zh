- en: 'Chapter 10\. Numbers Matter: Numbers and Statics'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。数字很重要：数字和静态方法
- en: '![image](Images/f0275-01.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0275-01.png)'
- en: '**Do the Math.** But there’s more to working with numbers than just doing primitive
    arithmetic. You might want to get the absolute value of a number, or round a number,
    or find the larger of two numbers. You might want your numbers to print with exactly
    two decimal places, or you might want to put commas into your large numbers to
    make them easier to read. And what about parsing a String into a number? Or turning
    a number into a String? Someday you’re gonna want to put a bunch of numbers into
    a collection like ArrayList that takes only objects. You’re in luck. Java and
    the Java API are full of handy number-tweaking capabilities and methods, ready
    and easy to use. But most of them are **static**, so we’ll start by learning what
    it means for a variable or method to be static, including constants in Java, also
    known as static *final* variables.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**做数学运算。** 但与仅仅进行基本算术运算不同，使用数字还有更多的技巧。你可能想要获取一个数的绝对值，或者四舍五入一个数，或者找出两个数中较大的那个。你可能希望你的数字打印时保留两位小数，或者你可能想在大数字中插入逗号以便更易于阅读。还有将字符串解析为数字呢？或者将数字转换为字符串？总有一天你会想把一堆数字放进像只接受对象的ArrayList这样的集合中。你真是幸运。Java和Java
    API中充满了方便的数字调整功能和方法，可以随时使用，而且使用起来非常简单。但大多数方法都是**静态的**，因此我们将从学习变量或方法被声明为静态的含义开始，包括Java中的常量，也称为静态*final*变量。'
- en: 'MATH methods: as close as you’ll ever get to a *global* method'
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MATH方法：你能接触到的最接近*全局*方法
- en: 'Except there’s no global *anything* in Java. But think about this: what if
    you have a method whose behavior doesn’t depend on an instance variable value.
    Take the round() method in the Math class, for example. It does the same thing
    every time—rounds a floating-point number (the argument to the method) to the
    nearest integer. Every time. If you had 10,000 instances of class Math, and ran
    the round(42.2) method, you’d get an integer value of 42\. Every time. In other
    words, the method acts on the argument but is never affected by an instance variable
    state. The only value that changes the way the round() method runs is the argument
    passed to the method!'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在Java中没有全局的*任何东西*。但是想想这个：如果你有一个方法，其行为不依赖于实例变量值。例如Math类中的round()方法。每次都会执行相同的操作——将浮点数（作为方法参数）四舍五入到最接近的整数。每次都是这样。如果你有10,000个Math类的实例，并且运行round(42.2)方法，你会得到一个整数值42。换句话说，该方法作用于参数，但不受实例变量状态的影响！唯一改变round()方法运行方式的是传递给方法的参数！
- en: Doesn’t it seem like a waste of perfectly good heap space to make an instance
    of class Math simply to run the round() method? And what about *other* Math methods
    like min(), which takes two numerical primitives and returns the smaller of the
    two? Or max(). Or abs(), which returns the absolute value of a number.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 将类Math的实例化仅仅为了运行round()方法看起来是在浪费堆空间。那么其他的Math方法呢，比如min()，它接受两个数值型参数并返回较小的那个呢？或者max()？或者abs()，它返回一个数的绝对值。
- en: '***These methods never use instance variable values***. In fact, the Math class
    doesn’t *have* any instance variables. So there’s nothing to be gained by making
    an instance of class Math. So guess what? You don’t have to. As a matter of fact,
    you can’t.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '***这些方法从不使用实例变量值***。事实上，Math类*没有*任何实例变量。因此创建Math类的实例没有任何意义。因此，你不必这样做。事实上，你也做不到。'
- en: '**If you try to make an instance of class Math:**'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果你尝试创建Math类的实例：**'
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**You’ll get this error:**'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**你会得到这个错误：**'
- en: '![image](Images/f0276-02.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0276-02.png)'
- en: Note
  id: totrans-11
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Methods in the Math class don’t use any instance variable values. And because
    the methods are “static,” you don’t need to have an instance of Math. All you
    need is the Math class.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Math类中的方法不使用任何实例变量值。由于这些方法是“静态”的，你不需要创建Math类的实例。你只需要Math类本身。
- en: '![image](Images/f0276-01.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0276-01.png)'
- en: The difference between regular (non-static) and static methods
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态方法与常规（非静态）方法的区别
- en: Java is object-oriented, but once in a while you have a special case, typically
    a utility method (like the Math methods), where there is no need to have an instance
    of the class. The keyword **`static`** lets a method run ***without any instance
    of the class***. A static method means “behavior not dependent on an instance
    variable, so no instance/object is required. Just the class.”
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Java是面向对象的，但偶尔你会遇到一个特殊情况，通常是一个实用方法（如Math方法），在这种情况下，没有必要创建类的实例。关键字**`static`**允许一个方法在***没有类的实例***的情况下运行。静态方法意味着“行为不依赖于实例变量，因此不需要实例/对象。只需要类本身。”
- en: '![image](Images/f0277-01.png)![image](Images/f0278-01.png)![image](Images/f0278-02.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0277-01.png)![image](Images/f0278-01.png)![image](Images/f0278-02.png)'
- en: What it means to have a class with static methods
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拥有具有静态方法的类意味着什么
- en: Often (although not always), a class with static methods is not meant to be
    instantiated. In [Chapter 8](ch08.xhtml#serious_polymorphism_interfaces_and_abst),
    *Serious Polymorphism*, we talked about abstract classes, and how marking a class
    with the **`abstract`** modifier makes it impossible for anyone to say “new” on
    that class type. In other words, ***it’s impossible to instantiate an abstract
    class.***
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通常（虽然不总是），一个具有静态方法的类并不意味着要被实例化。在[第8章](ch08.xhtml#serious_polymorphism_interfaces_and_abst)《严肃的多态性》中，我们谈到了抽象类，并且如何通过标记带有**`abstract`**修饰符的类，使得任何人都无法对该类类型说“new”。换句话说，***无法实例化抽象类***。
- en: But you can restrict other code from instantiating a *non*-abstract class by
    marking the constructor **`private`**. Remember, a *method* marked private means
    that only code from within the class can invoke the method. A *constructor* marked
    private means essentially the same thing—only code from within the class can invoke
    the constructor. Nobody can say “new” from *outside* the class. That’s how it
    works with the Math class, for example. The constructor is private; you cannot
    make a new instance of Math. The compiler knows that your code doesn’t have access
    to that private constructor.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 但是你可以通过将构造函数标记为**`private`**来限制其他代码实例化*非*抽象类。请记住，标记为private的*方法*意味着只有类内部的代码可以调用该方法。标记为private的*构造函数*基本上意味着相同的事情——只有类内部的代码可以调用构造函数。从*外部*类中没有人可以说“new”。这就是Math类的工作方式，例如。构造函数是私有的；你不能创建Math的新实例。编译器知道你的代码无法访问那个私有构造函数。
- en: This does *not* mean that a class with one or more static methods should never
    be instantiated. In fact, every class you put a main() method in is a class with
    a static method in it!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着一个具有一个或多个静态方法的类永远不应该被实例化。事实上，你在其中放置了一个main()方法的每个类都是一个具有静态方法的类！
- en: Typically, you make a main() method so that you can launch or test another class,
    nearly always by instantiating a class in main and then invoking a method on that
    new instance.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会创建一个main()方法，以便你可以启动或测试另一个类，几乎总是通过在main中实例化一个类，然后调用该新实例上的方法。
- en: So you’re free to combine static and non-static methods in a class, although
    even a single non-static method means there must be *some* way to make an instance
    of the class. The only ways to get a new object are through “new” or deserialization
    (or something called the Java Reflection API that we don’t go into). No other
    way. But exactly *who* says new can be an interesting question, and one we’ll
    look at a little later in this chapter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你可以自由地在一个类中组合静态方法和非静态方法，尽管即使一个非静态方法也意味着必须有某种方法来创建类的实例。获取新对象的唯一方法是通过“new”或反序列化（或称为Java反射API的某些东西，我们不深入讨论）。没有其他方法。但是到底*谁*说new可能是一个有趣的问题，我们稍后在本章会稍作讨论。
- en: Static methods can’t use non-static (instance) variables!
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态方法不能使用非静态（实例）变量！
- en: Static methods run without knowing about any particular instance of the static
    method’s class. And as you saw on the previous pages, there might not even *be*
    any instances of that class. Since a static method is called using the *class*
    (***Math***.random()) as opposed to an *instance reference* (***t2***.play()),
    a static method can’t refer to any instance variables of the class. The static
    method doesn’t know *which* instance’s variable value to use.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法在不知道静态方法的类的任何特定实例的情况下运行。正如你在前几页上看到的那样，可能甚至没有*任何*该类的实例。由于静态方法是使用*类*（***Math***.random()）而不是*实例引用*（***t2***.play()）调用的，静态方法不能引用类的任何实例变量。静态方法不知道要使用哪个实例的变量值。
- en: '**If you try to compile this code:**'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果你试图编译这段代码：**'
- en: '![image](Images/f0279-01.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0279-01.png)'
- en: '**You’ll get this error:**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**你会得到这个错误：**'
- en: '![image](Images/f0279-02.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0279-02.png)'
- en: Note
  id: totrans-29
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you try to use an instance variable from inside a static method, the compiler
    thinks, “I don’t know which object’s instance variable you’re talking about!”
    If you have ten Duck objects on the heap, a static method doesn’t know about any
    of them.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你试图在静态方法内部使用实例变量，编译器会认为：“我不知道你在说哪个对象的实例变量！”如果你在堆上有十个Duck对象，静态方法对它们一无所知。
- en: '![image](Images/f0279-03.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0279-03.png)'
- en: Static methods can’t use non-static methods, either!
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态方法也不能使用非静态方法！
- en: What do non-static methods do? ***They usually use instance variable state to
    affect the behavior of the method.*** A getName() method returns the value of
    the name variable. Whose name? The object used to invoke the getName() method.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 非静态方法通常做什么？***它们通常使用实例变量状态来影响方法的行为。*** 一个getName()方法返回name变量的值。谁的名字？用来调用getName()方法的对象的名字。
- en: '**This won’t compile:**'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**这段代码不会编译：**'
- en: '![image](Images/f0280-01.png)![image](Images/f0280-02.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0280-01.png)![图片](Images/f0280-02.png)'
- en: 'Static variable: value is the same for ALL instances of the class'
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态变量：所有类实例的值都相同
- en: Imagine you wanted to count how many Duck instances are being created while
    your program is running. How would you do it? Maybe an instance variable that
    you increment in the constructor?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你想在程序运行时计算创建了多少个Duck实例。你会怎么做？也许是在构造函数中递增的实例变量？
- en: '![image](Images/f0281-01.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0281-01.png)'
- en: No, that wouldn’t work because duckCount is an instance variable, and starts
    at 0 for each Duck. You could try calling a method in some other class, but that’s
    kludgey. You need a class that’s got only a single copy of the variable, and all
    instances share that one copy.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 不，这行不通，因为duckCount是一个实例变量，并且每个Duck的起始值都是0。你可以尝试在其他类中调用一个方法，但那样太笨拙了。你需要一个类，只有一个变量的副本，并且所有实例共享这个副本。
- en: 'That’s what a static variable gives you: a value shared by all instances of
    a class. In other words, one value per *class*, instead of one value per *instance*.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是静态变量带给你的：一个所有类实例共享的值。换句话说，每个*类*有一个值，而不是每个*实例*有一个。
- en: '![image](Images/f0281-02.png)![image](Images/f0281-03.png)![image](Images/f0282-01.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0281-02.png)![图片](Images/f0281-03.png)![图片](Images/f0282-01.png)'
- en: '**Static variables are shared.**'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**静态变量是共享的。**'
- en: '**All instances of the same class share a single copy of the static variables.**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**同一个类的所有实例共享静态变量的单个副本。**'
- en: 'instance variables: 1 per **instance**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 实例变量：每个**实例**有一个
- en: 'static variables: 1 per **class**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 静态变量：每个**类**有一个
- en: Initializing a static variable
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化静态变量
- en: Static variables are initialized when a *class is loaded*. A class is loaded
    because the JVM decides it’s time to load it. Typically, the JVM loads a class
    because somebody’s trying to make a new instance of the class, for the first time,
    or use a static method or variable of the class. As a programmer, you also have
    the option of telling the JVM to load a class, but you’re not likely to need to
    do that. In nearly all cases, you’re better off letting the JVM decide when to
    *load* the class.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当*加载*一个类时，静态变量被初始化。JVM决定何时加载类。通常，JVM加载一个类是因为有人试图首次创建类的新实例或使用类的静态方法或变量。作为程序员，你也可以选择告诉JVM加载一个类，但你不太可能需要这样做。在几乎所有情况下，最好让JVM决定何时*加载*类。
- en: 'And there are two guarantees about static initialization:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 静态初始化有两个保证：
- en: Static variables in a class are initialized before any *object* of that class
    can be created.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类中的静态变量在可以创建该类的*对象*之前初始化。
- en: Static variables in a class are initialized before any *static method* of the
    class runs.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类中的静态变量在任何*静态方法*运行之前初始化。
- en: '![image](Images/f0283-01.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0283-01.png)'
- en: If you don’t explicitly initialize a static variable (by assigning it a value
    at the time you declare it), it gets a default value, so int variables are initialized
    to zero, which means we didn’t need to explicitly say playerCount = 0\. Declaring,
    but not initializing, a static variable means the static variable will get the
    default value for that variable type, in exactly the same way that instance variables
    are given default values when declared.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不显式初始化静态变量（在声明时给它赋值），它会得到一个默认值，所以int变量会初始化为零，这意味着我们不需要显式地写playerCount = 0。声明但不初始化静态变量意味着静态变量会得到该变量类型的默认值，就像实例变量在声明时会得到默认值一样。
- en: '![image](Images/f0283-02.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0283-02.png)'
- en: static final variables are constants
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态final变量是常量
- en: 'A variable marked **`final`** means that—once initialized—it can never change.
    In other words, the value of the static final variable will stay the same as long
    as the class is loaded. Look up Math.PI in the API, and you’ll find:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 变量标记为**`final`**意味着——一旦初始化，它永远不会改变。换句话说，静态final变量的值会在类加载期间保持不变。在API中查找Math.PI，你会发现：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The variable is marked **`public`** so that any code can access it.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 变量标记为**`public`**，以便任何代码都可以访问它。
- en: The variable is marked **`static`** so that you don’t need an instance of class
    Math (which, remember, you’re not allowed to create).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 变量标记为**`static`**以便你不需要类Math的实例（记住，你不能创建它）。
- en: The variable is marked **`final`** because PI doesn’t change (as far as Java
    is concerned).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 变量标记为**`final`**因为在Java看来PI不会改变。
- en: There is no other way to designate a variable as a constant, but there is a
    naming convention that helps you to recognize one. ***Constant variable names
    are usually in all caps!***
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 没有其他方法来指定变量为常量，但有一个命名约定可以帮助你识别。***常量变量名通常全大写！***
- en: '**Initialize a *final* static variable:**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**初始化一个*最终*静态变量：**'
- en: '![Images](Images/1.png) **At the time you declare it:**'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Images](Images/1.png) **在你声明它的时候：**'
- en: '![image](Images/f0284-01.png)'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0284-01.png)'
- en: '**OR**'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**或**'
- en: '![Images](Images/2.png) **In a static initializer:**'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Images](Images/2.png) **在静态初始化器中：**'
- en: '![image](Images/f0284-02.png)'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0284-02.png)'
- en: '**If you don’t give a value to a final variable in one of those two places:**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果你在这两个地方之一不给final变量赋值：**'
- en: '![image](Images/f0284-03.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0284-03.png)'
- en: '**The compiler will catch it:**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**编译器将会捕获它：**'
- en: '![image](Images/f0284-04.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0284-04.png)'
- en: final isn’t just for static variables...
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: final不仅仅适用于静态变量...
- en: 'You can use the keyword **`final`** to modify non-static variables too, including
    instance variables, local variables, and even method parameters. In each case,
    it means the same thing: the value can’t be changed. But you can also use final
    to stop someone from overriding a method or making a subclass.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用关键字**`final`**来修改非静态变量，包括实例变量、局部变量，甚至方法参数。在每种情况下，它的含义是一样的：值不能被改变。但你也可以使用final来阻止别人重写方法或创建子类。
- en: '**non-static final variables**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**非静态最终变量**'
- en: '![image](Images/f0285-01.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0285-01.png)'
- en: '**final method**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**final method**'
- en: '[PRE2]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**final class**'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**最终类**'
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**A final variable means you can’t change its value.**'
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**一个最终变量表示你不能改变它的值。**'
- en: '**A final method means you can’t override the method.**'
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**一个最终方法表示你不能覆盖这个方法。**'
- en: '**A final class means you can’ extend the class (i.e., you can’t make a subclass).**'
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**一个最终类表示你不能扩展这个类（例如，你不能创建一个子类）。**'
- en: '![image](Images/f0285-03.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0285-03.png)'
- en: '![Images](Images/arr.png) **Answers in [“Sharpen your pencil”](#sharpen_your_pencil_left_parenthesisfrom).**'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '![Images](Images/arr.png) **在 [“磨刀”](#sharpen_your_pencil_left_parenthesisfrom)
    中的答案。**'
- en: Math methods
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Math方法
- en: Now that we know how static methods work, let’s look at some static methods
    in class Math. This isn’t all of them, just the highlights. Check your API for
    the rest including cos(), sin(), tan(), ceil(), floor(), and asin().
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了静态方法如何工作，让我们来看看Math类中的一些静态方法。这不是全部，只是一些亮点。查看你的API获取其余方法，包括cos()，sin()，tan()，ceil()，floor()和asin()。
- en: '![image](Images/f0288-01.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0288-01.png)'
- en: '**Math.abs()**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**Math.abs()**'
- en: Returns a double that is the absolute value of the argument. The method is overloaded,
    so if you pass it an int, it returns an int. Pass it a double, it returns a double.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 返回参数的绝对值。该方法重载，因此如果传入int，则返回int。传入double，则返回double。
- en: '[PRE4]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Math.random()**'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**Math.random()**'
- en: Returns a double between (and including) 0.0 through (but not including) 1.0.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个介于0.0到1.0之间（包括0.0但不包括1.0）的double值。
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-93
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: We’ve been using this method so far, but there’s also java.util.Random, which
    is a bit nicer to use.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用这个方法，但也有java.util.Random，用起来更方便一些。
- en: '**Math.round()**'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**Math.round()**'
- en: Returns an int or a long (depending on whether the argument is a float or a
    double) rounded to the nearest integer value.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 返回int或long（取决于参数是float还是double）的四舍五入最接近的整数值。
- en: '![image](Images/f0289-01.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0289-01.png)'
- en: '**Math.min()**'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**Math.min()**'
- en: Returns a value that is the minimum of the two arguments. The method is overloaded
    to take ints, longs, floats, or doubles.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 返回两个参数中的最小值。该方法重载以接受int、long、float或double。
- en: '[PRE6]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Math.max()**'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**Math.max()**'
- en: Returns a value that is the maximum of the two arguments. The method is overloaded
    to take ints, longs, floats, or doubles.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 返回两个参数中的最大值。该方法重载以接受int、long、float或double。
- en: '[PRE7]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**Math.sqrt()**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**Math.sqrt()**'
- en: Returns the positive square root of the argument. The method takes a double,
    but of course you can pass in anything that fits in a double.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 返回参数的正平方根。该方法接受一个double，但当然你可以传入任何适合double的值。
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Wrapping a primitive
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包装原始类型
- en: 'Sometimes you want to treat a primitive like an object. For example, collections
    like ArrayList only work with Objects:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你希望像对象一样处理原始类型。例如，像ArrayList这样的集合只能使用对象：
- en: '![image](Images/f0290-01.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0290-01.png)'
- en: There’s a wrapper class for every primitive type, and since the wrapper classes
    are in the java.lang package, you don’t need to import them. You can recognize
    wrapper classes because each one is named after the primitive type it wraps, but
    with the first letter capitalized to follow the class naming convention.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 每个原始类型都有一个包装类，由于包装类位于java.lang包中，你不需要导入它们。你可以识别包装类，因为每个包装类都以包装的原始类型命名，但首字母大写以遵循类命名约定。
- en: 'Oh yeah, for reasons absolutely nobody on the planet is certain of, the API
    designers decided not to map the names *exactly* from primitive type to class
    type. You’ll see what we mean:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 哦对了，由于绝对没有人确定的原因，API设计者决定不将原始类型的名称*完全*映射到类类型。你会明白我们的意思：
- en: '![image](Images/f0290-02.png)![image](Images/f0290-03.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0290-02.png)![图片](Images/f0290-03.png)'
- en: Note
  id: totrans-113
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: When you need to treat a primitive like an object, wrap it.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要将原始类型视为对象时，进行包装。
- en: '![image](Images/f0290-04.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0290-04.png)'
- en: 'Note: the picture at the top is a chocolate in a foil wrapper. Get it? Wrapper?
    Some people think it looks like a baked potato, but that works too.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：顶部的图片是一个包装在箔纸中的巧克力。明白了吗？包装？有些人认为它看起来像一个烤土豆，但那也可以。
- en: '![image](Images/f0291-01.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0291-01.png)'
- en: Java will Autobox primitives for you
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java会为你自动装箱原始类型
- en: In The Olden Days (pre–Java 5), we did have to do all this ourselves, manually
    wrapping and unwrapping primitives. Fortunately, now it’s all done for us *automatically*.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在古老的日子里（Java 5之前），我们必须手动包装和解包原始类型。幸运的是，现在这一切都被*自动*完成了。
- en: Let’s see what happens when we want to make an ArrayList to hold ints.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我们想要创建一个用于保存整数的ArrayList时会发生什么。
- en: '**An ArrayList of primitive ints**'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**一个包含原始整数的ArrayList**'
- en: '![image](Images/f0291-02.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0291-02.png)'
- en: Autoboxing works almost everywhere
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动装箱几乎在任何地方都适用
- en: Autoboxing lets you do more than just the obvious wrapping and unwrapping to
    use primitives in a collection...it also lets you use either a primitive or its
    wrapper type virtually anywhere one or the other is expected. Think about that!
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 自动装箱让你不仅可以做显而易见的包装和解包以在集合中使用原始类型...它还让你在任何需要原始类型或其包装类型的地方都可以使用其中之一。想想看！
- en: '**Fun with autoboxing**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**玩转自动装箱**'
- en: '| **Method arguments** If a method takes a wrapper type, you can pass a reference
    to a wrapper or a primitive of the matching type. And of course the reverse is
    true—if a method takes a primitive, you can pass in either a compatible primitive
    or a reference to a wrapper of that primitive type. | ![image](Images/f0292-01.png)
    |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| **方法参数** 如果一个方法接受一个包装类型，你可以传递一个包装类型的引用或匹配类型的原始类型。当然反之亦然——如果一个方法接受一个原始类型，你可以传递一个兼容的原始类型或该原始类型的包装类型的引用。
    | ![图片](Images/f0292-01.png) |'
- en: '| **Return values** If a method declares a primitive return type, you can return
    either a compatible primitive or a reference to the wrapper of that primitive
    type. And if a method declares a wrapper return type, you can return either a
    reference to the wrapper type or a primitive of the matching type. | ![image](Images/f0292-02.png)
    |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| **返回值** 如果一个方法声明一个原始返回类型，你可以返回一个兼容的原始类型或该原始类型的包装类型的引用。如果一个方法声明一个包装返回类型，你可以返回一个包装类型的引用或匹配类型的原始类型。
    | ![图片](Images/f0292-02.png) |'
- en: '| **Boolean expressions** Any place a boolean value is expected, you can use
    either an expression that evaluates to a boolean (4 > 2), a primitive boolean,
    or a reference to a Boolean wrapper. | ![image](Images/f0292-03.png) |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| **布尔表达式** 任何需要布尔值的地方，你可以使用一个求值为布尔值的表达式（4 > 2），一个原始布尔值，或一个Boolean包装类型的引用。
    | ![图片](Images/f0292-03.png) |'
- en: '| **Operations on numbers** This is probably the strangest one—yes, you can
    use a wrapper type as an operand in operations where the primitive type is expected.
    That means you can apply, say, the increment operator against a reference to an
    Integer object!'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '| **数字运算** 这可能是最奇怪的一点—是的，你可以在期望原始类型的操作中使用包装类型作为操作数。这意味着你可以对一个Integer对象的引用应用递增运算符！'
- en: But don’t worry—this is just a compiler trick. The language wasn’t modified
    to make the operators work on objects; the compiler simply converts the object
    to its primitive type before the operation. It sure looks weird, though.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 但别担心—这只是一个编译器技巧。语言并没有被修改以使运算符在对象上起作用；编译器只是在操作之前将对象转换为其原始类型。尽管看起来很奇怪。
- en: Integer i = new Integer(42); i++;
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Integer i = new Integer(42); i++;
- en: 'And that means you can also do things like:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你也可以做一些事情：
- en: Integer j = new Integer(5); Integer k = j + 3; | ![image](Images/f0293-01.png)
    |
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Integer j = new Integer(5); Integer k = j + 3; | ![image](Images/f0293-01.png)
    |
- en: '| **Assignments** You can assign either a wrapper or primitive to a variable
    declared as a matching wrapper or primitive. For example, a primitive int variable
    can be assigned to an Integer reference variable, and vice versa—a reference to
    an Integer object can be assigned to a variable declared as an int primitive.
    | ![image](Images/f0293-02.png) |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| **赋值** 你可以将包装类或基本类型分配给声明为匹配包装类或基本类型的变量。例如，原始int变量可以分配给Integer引用变量，反之亦然——可以将指向Integer对象的引用分配给声明为int基本类型的变量。
    | ![image](Images/f0293-02.png) |'
- en: '![Images](Images/arr.png) **Yours to solve.**'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![Images](Images/arr.png) **这是你要解决的问题。**'
- en: But wait! There’s more! Wrappers have static utility methods too!
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 但等等！还有更多！包装类还有静态实用方法！
- en: Besides acting like a normal class, the wrappers have a bunch of really useful
    static methods.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像普通类一样运行外，包装类还有一堆非常有用的静态方法。
- en: For example, the *parse* methods take a String and give you back a primitive
    value.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，*parse*方法接受一个字符串，并返回一个原始值。
- en: '![image](Images/f0294-01.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0294-01.png)'
- en: '**Converting a String to a primitive value is easy:**'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**将字符串转换为原始值很简单：**'
- en: '![image](Images/f0294-02.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0294-02.png)'
- en: '**But if you try to do this:**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**但如果你试图这样做：**'
- en: '![image](Images/f0294-03.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0294-03.png)'
- en: '**You’ll get a runtime exception:**'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**你将会得到一个运行时异常：**'
- en: '![image](Images/f0294-04.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0294-04.png)'
- en: '**Every method or constructor that parses a String can throw a NumberFormatException****.
    It’s a runtime exception, so you don’t have to handle or declare it. But you might
    want to.**'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**每个解析字符串的方法或构造函数都可能抛出NumberFormatException****。这是一个运行时异常，所以你不需要处理或声明它。但你可能希望这样做。**'
- en: (We’ll talk about exceptions in [Chapter 13](ch13.xhtml#risky_behavior_exception_handling),
    *Risky Behavior*.)
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: （我们将在[第13章](ch13.xhtml#risky_behavior_exception_handling)中讨论异常，*风险行为*。）
- en: And now in reverse...turning a primitive number into a String
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现在反过来…将原始数转换为字符串
- en: You may want to turn a number into a String, for example when you want to show
    this number to a user or put it into a message. There are several ways to turn
    a number into a String. The easiest is to simply concatenate the number to an
    existing String.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当你想要向用户显示这个数字或将其放入消息中时，可能会想要将数字转换为字符串。有几种方法可以将数字转换为字符串。最简单的方法是将数字简单地串联到现有字符串中。
- en: '![image](Images/f0295-01.png)![image](Images/f0295-02.png)![image](Images/f0295-03.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0295-01.png)![image](Images/f0295-02.png)![image](Images/f0295-03.png)'
- en: Number formatting
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数字格式化
- en: In Java, formatting numbers and dates doesn’t have to be coupled with I/O. Think
    about it. One of the most typical ways to display numbers to a user is through
    a GUI. You put Strings into a scrolling text area, or maybe a table. If formatting
    was built only into print statements, you’d never be able to format a number into
    a nice String to display in a GUI.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，格式化数字和日期并不一定要与I/O耦合在一起。想想看。向用户显示数字的最典型方式之一是通过GUI。你将字符串放入滚动文本区域，或者可能是一个表格。如果格式化只内置在打印语句中，你将永远无法将数字格式化为漂亮的字符串以在GUI中显示。
- en: The Java API provides powerful and flexible formatting using the Formatter class
    in java.util. But often you don’t need to create and call methods on the Formatter
    class yourself, because the Java API has convenience methods in some of the I/O
    classes (including printf()) and the String class. So it can be a simple matter
    of calling a static String.format() method and passing it the thing you want formatted
    along with formatting instructions.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Java API提供了强大而灵活的格式化功能，使用java.util中的Formatter类。但通常你不需要自己创建和调用Formatter类中的方法，因为Java
    API在一些I/O类（包括printf()）和String类中提供了方便的方法。因此，只需调用一个静态的String.format()方法，并传递你想要格式化的内容以及格式化指令，就可以轻松搞定。
- en: Of course, you do have to know how to supply the formatting instructions, and
    that takes a little effort unless you’re familiar with the ***printf()*** function
    in C/C++. Fortunately, even if you *don’t* know printf(), you can simply follow
    recipes for the most basic things (that we’re showing in this chapter). But you
    *will* want to learn how to format if you want to mix and match to get *anything*
    you want.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你确实需要知道如何提供格式化指令，这需要一点努力，除非你熟悉C/C++中的***printf()***函数。幸运的是，即使你*不*知道printf()，你也可以简单地遵循我们在本章中展示的最基本的事物的配方。但如果你想要混搭以获得*任何*你想要的东西，你*肯定*会想学会如何进行格式化。
- en: 'We’ll start here with a basic example and then look at how it works. (Note:
    we’ll revisit formatting again in [Chapter 16](ch16.xhtml#saving_objects_left_parenthesisand_textr),
    *Saving Objects*.)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个基本示例开始，然后看看它是如何工作的。（注意：我们将在[第16章](ch16.xhtml#saving_objects_left_parenthesisand_textr)中再次讨论格式化。）
- en: '**Making big numbers more readable with underscores, a quick detour**'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用下划线使大数字更易读，一个快速的绕道**'
- en: 'Before we get into formatting numbers, let’s take a small, useful detour. Sometimes
    you’ll want to declare variables with large initial values. Let’s look at three
    declarations that assign the same large value, a billion, to long primitives:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入讨论格式化数字之前，让我们进行一个小而有用的绕道。有时您可能希望声明具有大初始值的变量。让我们看看三个声明，它们将相同的大值，十亿，分配给长整型原语：
- en: '![image](Images/f0296-01.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0296-01.png)'
- en: '**Formatting a number to use commas**'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**格式化数字以使用逗号**'
- en: '![image](Images/f0296-02.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0296-02.png)'
- en: Formatting deconstructed...
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 格式化解析...
- en: 'At the most basic level, formatting consists of two main parts (there is more,
    but we’ll start with this to keep it cleaner):'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在最基本的级别上，格式化包含两个主要部分（还有更多，但我们将从这里开始以保持简洁）：
- en: '![Images](Images/1.png) **Formatting instructions**'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Images](Images/1.png) **格式化说明**'
- en: You use special format specifiers that describe how the argument should be formatted.
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用特殊的格式说明符来描述参数应该如何格式化。
- en: '![Images](Images/2.png) **The argument to be formatted.**'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Images](Images/2.png) **要格式化的参数。**'
- en: Although there can be more than one argument, we’ll start with just one. The
    argument type can’t be just *anything*...it has to be something that can be formatted
    using the format specifiers in the formatting instructions. For example, if your
    formatting instructions specify a *floating-point number*, you can’t pass in a
    Dog or even a String that looks like a floating-point number.
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 虽然可能会有多个参数，但我们将从一个开始。参数类型不能只是*任意的*…它必须是可以使用格式说明符进行格式化的内容。例如，如果你的格式化说明指定了*浮点数*，你不能传入一只狗，甚至是看起来像浮点数的字符串。
- en: '![image](Images/f0297-01.png)'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0297-01.png)'
- en: '**What do these instructions actually say?**'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**这些说明实际上是在说什么？**'
- en: “Take the second argument to this method, and format it as a **d**ecimal integer
    and insert **commas**.”
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: “将此方法的第二个参数作为**十进制整数（d）**格式化，并插入**逗号**。”
- en: '**How do they say that?**'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**他们是怎么说的？**'
- en: On the next page we’ll look in more detail at what the syntax “%,d” actually
    means, but for starters, any time you see the percent sign (%) in a format String
    (which is always the first argument to a format() method), think of it as representing
    a variable, and the variable is the other argument to the method. The rest of
    the characters after the percent sign describe the formatting instructions for
    the argument.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一页中，我们将更详细地看一下“%,d”语法实际上意味着什么，但首先，任何时候在格式字符串中看到百分号（%）时（这总是 format() 方法的第一个参数），将其视为表示变量，并且该变量是方法的另一个参数。百分号后面的其余字符描述了参数的格式化说明。
- en: Note
  id: totrans-172
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note: if you already know printf() from c/C++, you can probably just skim the
    next few pages. Otherwise, read carefully!'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果你已经了解来自 C/C++ 的 printf()，可能只需快速浏览接下来的几页。否则，请仔细阅读！
- en: The percent (%) says, “insert argument here” (and format it using these instructions)
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 百分号（%）表示，“在这里插入参数”（并使用这些说明格式化它）
- en: The first argument to a format() method is called the format String, and it
    can actually include characters that you just want printed as-is, without extra
    formatting. When you see the % sign, though, think of the percent sign as a variable
    that represents the other argument to the method.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: format() 方法的第一个参数称为格式字符串，实际上它可以包含你希望原样打印的字符，无需额外格式化。但当你看到 % 符号时，将百分号视为一个变量，表示方法的另一个参数。
- en: '![image](Images/f0298-01.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0298-01.png)'
- en: The “%” sign tells the formatter to insert the other method argument (the second
    argument to format(), the number) here, AND format it using the “.2f” characters
    after the percent sign. Then the rest of the format String, “bugs to fix,” is
    added to the final output.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: “%”符号告诉格式化程序在此处插入其他方法参数（format()的第二个参数，即数字），并使用百分号后的“.2f”字符格式化它。然后将格式字符串的其余部分“bugs
    to fix”添加到最终输出。
- en: '**Adding a comma**'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**添加逗号**'
- en: '![image](Images/f0298-02.png)![image](Images/f0299-01.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0298-02.png)![image](Images/f0299-01.png)'
- en: The format String uses its own little language syntax
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 格式字符串使用自己的小语言语法。
- en: You obviously can’t put just *anything* after the “%” sign. The syntax for what
    goes after the percent sign follows very specific rules, and describes how to
    format the argument that gets inserted at that point in the result (formatted)
    String.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 显然你不能在“%”符号后面随便放东西。百分号后面的内容遵循非常具体的规则，描述如何格式化在结果（格式化后）字符串中插入的参数。
- en: 'You’ve already seen some examples:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到一些例子：
- en: '**%,d** means “insert commas and format the number as a decimal integer.”'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**%,d** 表示“插入逗号并将数字格式化为十进制整数。”'
- en: and
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '**%.2f** means “format the number as a floating point with a precision of two
    decimal places.”'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**%.2f** 表示“将数字格式化为带有两位小数的浮点数。”'
- en: and
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '**%,.2f** means “insert commas and format the number as a floating point with
    a precision of two decimal places.”'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**%,.2f** 表示“插入逗号并将数字格式化为带有两位小数的浮点数。”'
- en: 'Really the question is: “How do I know what to put after the percent sign to
    get it to do what I want?” And that includes knowing the symbols (like “d” for
    decimal and “f” for floating point) as well as the order in which the instructions
    must be placed following the percent sign. For example, if you put the comma after
    the “d” like “%d,” instead of “%,d” it won’t work!'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上问题是：“我怎么知道在百分号后面放什么才能让它按照我想要的方式工作？”这包括知道符号（比如“d”表示十进制，“f”表示浮点数）以及按照百分号后面必须放置指令的顺序。例如，如果你在“d”后面放逗号，像“%d,”而不是“%,d”，它就不会起作用！
- en: 'Or will it? What do you think this will do:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 或者呢？你认为这会做什么：
- en: '[PRE9]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: (We’ll answer that on the next page.)
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: （我们将在下一页回答这个问题。）
- en: The format specifier
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 格式说明符
- en: Everything after the percent sign up to and including the type indicator (like
    “d” or “f”) is part of the formatting instructions. After the type indicator,
    the formatter assumes the next set of characters is meant to be part of the output
    String, until or unless it hits another percent (%) sign. Hmmmm...is that even
    possible? Can you have more than one formatted argument variable? Put that thought
    on hold for right now; we’ll come back to it in a few minutes. For now, let’s
    look at the syntax for the format specifiers—the things that go after the percent
    (%) sign and describe how the argument should be formatted.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 百分号后面直到包括类型指示符（比如“d”或“f”）都是格式化指令的一部分。在类型指示符之后，格式化程序会假定下一组字符应该是输出字符串的一部分，直到或除非它遇到另一个百分号（%）符号。嗯...这甚至可能吗？你可以有多个格式化参数变量吗？暂时搁置这个想法；我们几分钟后会回到这个问题。现在，让我们看看格式说明符的语法——百分号（%）后面的内容，描述参数应该如何格式化。
- en: '**A format specifier can have up to five different parts (not including the
    “%”). Everything in brackets [ ] below is optional, so only the percent (%) and
    the type are required. But the order is also mandatory, so any parts you DO use
    must go in this order.**'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**格式说明符最多可以有五个不同的部分（不包括“%”）。下面方括号中的所有内容都是可选的，所以只有百分号（%）和类型是必需的。但是顺序也是强制的，所以任何你使用的部分必须按照这个顺序。**'
- en: '![image](Images/f0300-01.png)![image](Images/f0300-02.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0300-01.png)![image](Images/f0300-02.png)'
- en: The only required specifier is for TYPE
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 唯一必需的说明符是类型
- en: Although type is the only required specifier, remember that if you *do* put
    in anything else, type must always come last! There are more than a dozen different
    type modifiers (not including dates and times; they have their own set), but most
    of the time you’ll probably use %d (decimal) or %f (floating point). And typically
    you’ll combine %f with a precision indicator to set the number of decimal places
    you want in your output.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然类型是唯一必需的说明符，但要记住，如果你确实放入其他内容，类型必须始终放在最后！有超过十几种不同的类型修饰符（不包括日期和时间；它们有自己的一套），但大多数情况下你可能会使用%d（十进制）或%f（浮点数）。通常你会将%f与精度指示器结合使用，以设置输出中所需的小数位数。
- en: '**The TYPE is mandatory, everything else is optional.**'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**类型是必需的，其他所有内容都是可选的。**'
- en: '![image](Images/f0301-01.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0301-01.png)'
- en: Note
  id: totrans-200
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You must include a type in your format instructions, and if you specify things
    besides type, the type must always come last. Most of the time, you’ll probably
    format numbers using either “d” for decimal or “f” for floating point.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须在格式说明中包含一个类型，如果你指定除了类型之外的东西，类型必须始终放在最后。大多数情况下，你可能会使用“d”表示十进制或“f”表示浮点数来格式化数字。
- en: The argument must be a byte, short, char, or int (including both primitive and
    wrapper types).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 参数必须是字节、短整型、字符或整型（包括基本类型和包装类型）。
- en: What happens if I have more than one argument?
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如果我有多个参数会发生什么？
- en: 'Imagine you want a String that looks like this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下你想要一个看起来像这样的字符串：
- en: “The rank is ***20,456,654*** out of ***100,567,890.24***.”
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: “排名是 ***20,456,654*** 在 ***100,567,890.24*** 之中。”
- en: But the numbers are coming from variables. What do you do? You simply add *two*
    arguments after the format String (first argument), so that means your call to
    format() will have three arguments instead of two. And inside that first argument
    (the format String), you’ll have two different format specifiers (two things that
    start with “%”). The first format specifier will insert the second argument to
    the method, and the second format specifier will insert the third argument to
    the method. In other words, the variable insertions in the format String use the
    order in which the other arguments are passed into the format() method.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 但是这些数字来自变量。您该怎么办？您只需在格式字符串（第一个参数）之后添加*两个*参数，这意味着您对 format() 的调用将有三个参数而不是两个。并且在第一个参数（格式字符串）内部，您将有两个不同的格式规范（以“%”开头的两个东西）。第一个格式规范将插入方法的第二个参数，第二个格式规范将插入方法的第三个参数。换句话说，在格式字符串中的变量插入使用传递给
    format() 方法的其他参数的顺序。
- en: '![image](Images/f0302-01.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0302-01.png)'
- en: As you’ll see when we get to date formatting, you might actually want to apply
    different formatting specifiers to the same argument. That’s probably hard to
    imagine until you see how *date* formatting (as opposed to the *number* formatting
    we’ve been doing) works. Just know that in a minute, you’ll see how to be more
    specific about which format specifiers are applied to which arguments.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论日期格式化时，您会看到，您实际上可能希望对同一参数应用不同的格式化规范。在我们一直在做的*数字*格式化之外，*日期*格式化可能很难想象。只要知道，在一分钟内，您将看到如何更具体地指定哪些格式规范适用于哪些参数。
- en: Just one more thing...static imports
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 再说一件事……静态导入
- en: Static imports are a real mixed blessing. Some people love this idea, some people
    hate it. Static imports exist to make your code a little shorter. If you hate
    to type or hate long lines of code, you might just like this feature. The downside
    to static imports is that—if you’re not careful—using them can make your code
    a lot harder to read.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 静态导入真是一件利弊参半的事情。有些人喜欢这个想法，有些人讨厌它。静态导入的存在是为了让您的代码变短一点。如果您不喜欢打字或讨厌长行代码，您可能会喜欢这个功能。静态导入的缺点是，如果您不小心使用它们，它可能会使您的代码难以阅读。
- en: The basic idea is that whenever you’re using a static class, a static variable,
    or an enum (more on those later), you can import them and save yourself some typing.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 基本思想是，每当您使用静态类、静态变量或枚举（稍后会详细介绍）时，您都可以导入它们，节省一些输入时间。
- en: '**Without static imports:**'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**没有静态导入：**'
- en: '[PRE10]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**Same code, with static imports:**'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**相同代码，使用静态导入：**'
- en: '![image](Images/f0303-01.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0303-01.png)'
- en: Note
  id: totrans-216
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Use carefully: Static imports can make your code confusing to read. Always
    re-read your code after using a static import and think: “Will I understand this
    in six months time?”'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 使用时要小心：静态导入可能会使您的代码变得难以阅读。在使用静态导入后，始终重新阅读您的代码并思考：“我在六个月后还能理解这个吗？”
- en: Fireside Chats
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 炉边谈话
- en: '![image](Images/f0304-01.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0304-01.png)'
- en: 'Tonight’s Talk: **An instance variable takes cheap shots at a static variable**'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 今晚的演讲：**一个实例变量对静态变量进行便宜攻击**
- en: '| Instance Variable | Static Variable |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| 实例变量 | 静态变量 |'
- en: '| --- | --- |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| I don’t even know why we’re doing this. Everyone knows static variables are
    just used for constants. And how many of those are there? I think the whole API
    must have, what, four? And it’s not like anybody ever uses them. |  |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| 我甚至不知道我们为什么要这样做。每个人都知道静态变量只用于常量。那么其中有多少个？我觉得整个 API 只有，什么，四个？而且也不像有人会用它们。
    |  |'
- en: '|  | You really should check your facts. When was the last time you looked
    at the API? It’s frickin’ loaded with statics! It even has entire classes dedicated
    to holding constant values. There’s a class called SwingConstants, for example,
    that’s just full of them. |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '|  | 您真的应该查查您的事实。您上次查看 API 是什么时候？它充满了静态变量！甚至有整个类专门用来保存常量值。例如，有一个叫 SwingConstants
    的类，里面全都是它们。 |'
- en: '| Full of it. Yeah, you can say that again. OK, so there are a few in the Swing
    library, but everybody knows Swing is just a special case. |  |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| 充满了。是的，你可以再说一遍。好吧，Swing 库中有几个，但是每个人都知道 Swing 只是一个特殊情况。 |  |'
- en: '|  | It might be a special case, but it’s a really important one! And what
    about the Color class? What a pain if you had to remember the RGB values to make
    the standard colors! But the color class already has constants defined for blue,
    purple, white, red, etc. Very handy. |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '|  | 这可能是一个特例，但它确实非常重要！还有颜色类呢？如果你必须记住RGB值才能生成标准颜色，那该有多麻烦！但颜色类已经为蓝色、紫色、白色、红色等定义了常量。非常方便。
    |'
- en: '| Ok, but besides a few GUI things, give me an example of just one static variable
    that anyone would actually use. In the real world. |  |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| 好吧，除了一些GUI的东西，给我举一个在真实世界中真正有人会使用的静态变量的例子。 |  |'
- en: '|  | How’s System.out for starters? The out in System.out is a static variable
    of the System class. You personally don’t make a new instance of the System; you
    just ask the System class for its out variable. |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '|  | 那System.out怎么说？System.out中的out是System类的静态变量。你个人不会创建System的新实例；你只需请求System类的其out变量。
    |'
- en: '| Well, that’s another special case. And nobody uses that except for debugging
    anyway. |  |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| 好吧，这又是另一种特例。反正除了调试，也没人用它。 |  |'
- en: '|  | Oh, like debugging isn’t important? And here’s something that probably
    never crossed your narrow mind—let’s face it, static variables are more efficient.
    One per class instead of one per instance. The memory savings might be huge! |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '|  | 哦，像调试不重要似的？而且也有一件事可能从没进过你狭隘的脑海——承认吧，静态变量更高效。一个类只需一个，而不是每个实例一个。这可能带来巨大的内存节省！
    |'
- en: '| Um, aren’t you forgetting something? |  |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| 呃，你不是忘了什么吗？ |  |'
- en: '|  | What? |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '|  | 什么？ |'
- en: '| Static variables are about as un-OO as it gets!! Gee, why not just go take
    a giant backward step and do some procedural programming while we’re at it. |  |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| 静态变量是非常不面向对象的！！天呐，我们干嘛不一下子退回到过程化编程呢。 |  |'
- en: '|  | What do you mean *un-*OO? |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '|  | 你说的是什么 *非*面向对象吗？ |'
- en: '| You’re like a global variable, and any programmer worth their sticker-covered
    laptop knows that’s usually a Bad Thing. |  |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| 你就像一个全局变量，任何值得贴了贴纸的笔记本电脑的程序员都知道，那通常是件坏事。 |  |'
- en: '|  | I am NOT a global variable. There’s no such thing. I live in a class!
    That’s pretty OO you know, a CLASS. I’m not just sitting out there in space somewhere;
    I’m a natural part of the state of an object; the only difference is that I’m
    shared by all instances of a class. Very efficient. |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '|  | 我可不是全局变量。根本不存在这种东西。我生活在一个类里！这相当面向对象，一个**类**。我并不是悬浮在空间中的某个东西；我是对象状态的自然组成部分；唯一的区别是我被所有类的实例共享。非常高效。
    |'
- en: '| Yeah, you live in a class, but they don’t call it *Class*-Oriented programming.
    That’s just stupid. You’re a relic. Something to help the old-timers make the
    leap to Java. |  |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| 是的，你确实生活在一个类里，但他们并不称其为 *类*-导向编程。那简直愚蠢。你就是个遗物，帮助老手们迈向Java的东西。 |  |'
- en: '|  | Alright just stop right there. THAT is definitely not true. Some static
    variables are absolutely crucial to a system. And even the ones that aren’t crucial
    sure are handy. |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '|  | 好了好了，停下来。那绝对不对。有些静态变量对系统至关重要。而即使那些不是必不可少的，确实非常方便。 |'
- en: '| Well, OK, every once in a while sure, it makes sense to use a static, but
    let me tell you, abuse of static variables (and methods) is the mark of an immature
    OO programmer. A designer should be thinking about *object* state, not *class*
    state. |  |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| 好吧，确实，偶尔使用静态方法是有道理的，但让我告诉你，滥用静态变量（和方法）是一个不成熟的面向对象程序员的标志。设计者应该思考*对象*状态，而不是*类*状态。
    |  |'
- en: '|  | Why do you say that? And what’s wrong with static methods? |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '|  | 你为什么这么说？静态方法有什么问题？ |'
- en: '| Static methods are the worst things of all, because it usually means the
    programmer is thinking procedurally instead of about objects doing things based
    on their unique object state. |  |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| 静态方法是最糟糕的东西，因为通常意味着程序员在考虑过程化而不是基于对象状态的事物行为。 |  |'
- en: '|  | Sure, I know that objects should be the focus of an OO design, but just
    because there are some clueless programmers out there...don’t throw the baby out
    with the bytecode. There’s a time and place for statics, and when you need one,
    nothing else beats it. |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '|  | 当然，我知道对象应该是面向对象设计的重点，但只因为有些无知的程序员……别因噎废食。静态变量有时是必需的，当你需要它时，没有什么比它更好的了。
    |'
- en: '| Riiiiiight. Whatever you need to tell yourself. |  |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| 对啊，你自己怎么说都行。 |  |'
- en: Exercise
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: '![image](Images/exercise.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/exercise.png)'
- en: BE the compiler
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 做个编译器
- en: '![image](Images/f0306-02.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0306-02.png)'
- en: '**The Java file on this page represents a complete program. Your job is to
    play compiler and determine whether this file will compile. If it won’t compile,
    how would you fix it? When it runs, what would be its output?**'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '**此页面上的 Java 文件代表一个完整的程序。您的任务是扮演编译器，判断这个文件是否能编译。如果不能，如何修复？当它运行时，输出是什么？**'
- en: '[PRE11]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Which of these is the output?
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 下面哪个是输出结果？
- en: '**Possible Output**'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**可能的输出**'
- en: '![image](Images/f0306-04.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0306-04.png)'
- en: '**Possible Output**'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '**可能的输出**'
- en: '![image](Images/f0306-05.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0306-05.png)'
- en: '![Images](Images/arr.png) **Answers in [“BE the compiler”](#be_the_compiler_left_parenthesisfrom_pag).**'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '![Images](Images/arr.png) **答案在 [“BE the compiler”](#be_the_compiler_left_parenthesisfrom_pag)。**'
- en: This chapter explored the wonderful, static world of Java. Your job is to decide
    whether each of the following statements is true or false.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了 Java 中美妙而静态的世界。您的任务是判断以下每个语句是否为真或假。
- en: True or False
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 真或假
- en: '![image](Images/hand.png)![image](Images/hand1.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/hand.png)![image](Images/hand1.png)'
- en: To use the Math class, the first step is to make an instance of it.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用 Math 类，第一步是实例化它。
- en: You can mark a constructor with the **`static`** keyword.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以用关键字“`static`”标记一个构造方法。
- en: Static methods don’t have access to instance variable state of the “this” object.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 静态方法无法访问“this”对象的实例变量状态。
- en: It is good practice to call a static method using a reference variable.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用静态方法时使用引用变量是一种良好的实践。
- en: Static variables could be used to count the instances of a class.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 静态变量可以用来计算类的实例数量。
- en: Constructors are called before static variables are initialized.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造方法在静态变量初始化之前被调用。
- en: MAX_SIZE would be a good name for a static final variable.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MAX_SIZE是一个静态 final 变量的良好命名。
- en: A static initializer block runs before a class’s constructor runs.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 静态初始化块在类的构造方法运行之前执行。
- en: If a class is marked final, all of its methods must be marked final.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个类被标记为 final，则其所有方法必须被标记为 final。
- en: A final method can be overridden only if its class is extended.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个 final 方法只有在其类被扩展时才能被重写。
- en: There is no wrapper class for boolean primitives.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 布尔原始类型没有包装类。
- en: A wrapper is used when you want to treat a primitive like an object.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你想把原始类型作为对象处理时，可以使用包装类。
- en: The parseXxx methods always return a String.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: parseXxx 方法总是返回一个字符串。
- en: Formatting classes (which are decoupled from I/O) are in the java.format package.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 格式化类（与 I/O 解耦）位于 java.format 包中。
- en: '![Images](Images/arr.png) **Answers in [“True or False”](#true_or_false_left_parenthesisfr-id0002).**'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '![Images](Images/arr.png) **答案在 [“真或假”](#true_or_false_left_parenthesisfr-id0002)。**'
- en: Exercise Solution
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习解答
- en: Sharpen your pencil
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 磨尖你的铅笔
- en: (from [“Sharpen your pencil”](#sharpen_your_pencil-id00021))
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: （来源于 [“磨尖你的铅笔”](#sharpen_your_pencil-id00021)）
- en: '![image](Images/pencil.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/pencil.png)'
- en: 1, 4, 5, and 6 are legal.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 1, 4, 5 和 6 是合法的。
- en: 2 doesn’t compile because the static method references a non-static instance
    variable.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 2 不会编译，因为静态方法引用了非静态实例变量。
- en: 3 doesn’t compile because the instance variable is final but hasn’t been initialized.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 3 不会编译，因为实例变量是 final 的但尚未初始化。
- en: BE the compiler
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BE the compiler
- en: (from [“BE the compiler”](#be_the_compiler-id00002))
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: （来源于 [“BE the compiler”](#be_the_compiler-id00002)）
- en: '[PRE12]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: StaticSuper is a constructor and must have ( ) in its signature. Notice that
    as the output below demonstrates, the static blocks for both classes run before
    either of the constructors run.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: StaticSuper 是一个构造方法，必须在其签名中加入 ()。请注意，如下面的输出所示，两个类的静态块在任何构造方法运行之前运行。
- en: '![image](Images/f0308-02.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0308-02.png)'
- en: True or False
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 真或假
- en: (from [“True or False”](#true_or_false))
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: （来源于 [“真或假”](#true_or_false)）
- en: '|'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: To use the Math class, the first step is to make an instance of it.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用 Math 类，第一步是实例化它。
- en: '| **False** |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| **False** |'
- en: '|'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: You can mark a constructor with the keyword “static.”
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以用关键字“`static`”标记一个构造方法。
- en: '| **False** |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| **False** |'
- en: '|'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Static methods don’t have access to an object’s instance variables.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 静态方法无法访问对象的实例变量。
- en: '| **True** |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| **True** |'
- en: '|'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: It is good practice to call a static method using a reference variable.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用静态方法时使用引用变量是一种良好的实践。
- en: '| **False** |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| **False** |'
- en: '|'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Static variables could be used to count the instances of a class.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 静态变量可以用来计算类的实例数量。
- en: '| **True** |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| **True** |'
- en: '|'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Constructors are called before static variables are initialized.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造方法在静态变量初始化之前被调用。
- en: '| **False** |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| **False** |'
- en: '|'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: MAX_SIZE would be a good name for a static final variable.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MAX_SIZE是一个静态 final 变量的良好命名。
- en: '| **True** |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| **True** |'
- en: '|'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: A static initializer block runs before a class’s constructor runs.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 静态初始化块在类的构造方法运行之前执行。
- en: '| **True** |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| **True** |'
- en: '|'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: If a class is marked final, all of its methods must be marked final.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个类被标记为 final，那么它的所有方法必须被标记为 final。
- en: '| **False** |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| **错误** |'
- en: '|'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: A final method can be overridden only if its class is extended.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅当它的类被扩展时，才能重写 final 方法。
- en: '| **False** |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| **错误** |'
- en: '|'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: There is no wrapper class for boolean primitives.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 布尔原始类型没有包装类。
- en: '| **False** |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| **错误** |'
- en: '|'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: A wrapper is used when you want to treat a primitive like an object.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你想将原始类型像对象一样对待时，使用包装器。
- en: '| **True** |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| **正确** |'
- en: '|'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: The parseXxx methods always return a String.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`parseXxx` 方法始终返回一个字符串。'
- en: '| **False** |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| **错误** |'
- en: '|'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Formatting classes (which are decoupled from I/O) are in the java.format package.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 格式化类（与 I/O 解耦）位于 java.format 包中。
- en: '| **False** |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| **错误** |'
