- en: Chapter 19\. Throwing to Returning
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 19 章。抛出到返回
- en: Java uses checked and unchecked exceptions to represent and handle errors. Kotlin
    supports exceptions, but doesn’t build checked exceptions into the language in
    the same way. Why did Kotlin reject Java’s approach, and what should we use instead?
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Java 使用已检查和未检查的异常来表示和处理错误。Kotlin 支持异常，但并不像 Java 那样在语言中内置已检查的异常。为什么 Kotlin 拒绝了
    Java 的方法，我们应该使用什么代替呢？
- en: You don’t have program computers for long to discover that things go wrong…
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 您不需要长时间为计算机编写程序才会发现事情会出错…
- en: …in *so many* ways.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: …以 *如此多* 的方式。
- en: Early in their careers, your authors tended to gloss over errors. We often still
    do, at least early in a project. As the system grows, though, we learn how failures
    affect the application and start to add code to cope—at first piecemeal, later
    with some strategy informed by experience. In this respect our error handling
    evolves in the same way as other aspects of our software design. Sometimes we
    design up front, making use of our experience of similar systems; other times
    we allow the writing of the software to teach us what it needs.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在他们的职业生涯早期，您的作者倾向于忽略错误。至少在项目早期，我们经常仍然这样做。但随着系统的增长，我们学会了故障如何影响应用程序，并开始添加处理代码——起初是零散的，后来是根据经验制定的某种策略。在这方面，我们的错误处理与我们软件设计的其他方面一样发展。有时我们从一开始就设计，利用我们对类似系统的经验；其他时候，我们允许软件编写教导我们它需要什么。
- en: In the absence of a more deliberate strategy, most systems default to raising
    exceptions when something goes wrong, and catching and logging those exceptions
    at some outer level. Command-line utilities will just exit in this case, hopefully
    having provided enough information for the user to correct the problem and try
    again. A server app, or a GUI with an event loop, will usually abort only the
    current interaction and get on with the next.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有更明确的策略的情况下，大多数系统默认在出现问题时引发异常，并在某个外部级别捕获和记录这些异常。在这种情况下，命令行实用程序将只是退出，希望提供足够的信息给用户以纠正问题并重试。服务器应用程序或具有事件循环的
    GUI 通常只会中止当前交互并继续下一个。
- en: Often this is just a poor experience for our users, but sometimes the error
    will corrupt the persistent state of the system, so correcting the initial problem
    and retrying does not work. This is the source of the sage advice to “turn it
    off and on again.” Our systems mainly start in a safe state, so that after a restart
    a retry should succeed. If not, well, you’ve probably been in a situation where
    the only solution has been to reinstall the operating system—the ultimate way
    of removing corrupted persistent state.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 通常这只是对我们用户的不良体验，但有时错误会损坏系统的持久状态，因此更正初始问题并重试是无效的。这是“关闭并重新启动”的明智建议的源头。我们的系统主要在安全状态下启动，因此重新启动后重试应该成功。如果不行，嗯，您可能曾经处于重新安装操作系统的情况——这是删除受损持久状态的终极方法。
- en: If errors are not well managed, but despite this the system becomes successful,
    diagnosing and fixing corruption due to errors can expand to fill all the team’s
    time. This is not a great place for a software project to be. Ask us how we know!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果错误没有得到很好的管理，但尽管如此系统变得成功，由于错误导致的损坏的诊断和修复可能会占用整个团队的所有时间。这对于软件项目来说并不是一个好的位置。问我们是怎么知道的！
- en: So we don’t want errors because they annoy our users and may result in corruption
    that takes a lot of effort to fix, if we can fix it at all. What sort of errors
    do we see?
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不希望出现错误，因为它们会让我们的用户感到烦恼，并且可能导致需要花费大量精力才能修复的损坏，如果我们可以修复的话。我们看到了什么样的错误呢？
- en: Programs can go wrong for many reasons. When we say *program*, we also mean
    functions, methods, procedures—any code that we invoke. And when we say *go wrong*,
    we mean fail to do the job that we expected them to do.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 程序出错的原因有很多。当我们说 *程序* 时，我们也指的是函数、方法、过程——我们调用的任何代码。当我们说 *出错* 时，我们指的是未能完成我们期望它们完成的工作。
- en: 'Reasons for this failure include:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 导致此故障的原因包括：
- en: Sometimes programs need to talk to other systems and that communication fails
    in some way.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时程序需要与其他系统通信，但通信在某种程度上失败了。
- en: Often we don’t give software the correct input it needs to do its job.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们经常没有为软件提供执行其工作所需的正确输入。
- en: 'Apparently some programmers make errors: even instructing their computers to
    dereference null references or read past the ends of collections!'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显然，一些程序员会犯错误：甚至会指示他们的计算机取消引用空引用或读取超出集合末尾的内容！
- en: The environment that we are running in fails for some reason; for example, it
    might run out of memory or not be able to load a class.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们运行的环境由于某种原因而失败；例如，它可能耗尽内存或无法加载类。
- en: There are failures that don’t fit into these categories, but most do.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 有些失败情况不属于这些类别，但大多数情况下是适用的。
- en: That doesn’t seem to be too long a list, and yet as an industry we don’t have
    a great reputation for reliability. Error handling just seems to be hard. Why
    is that?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎不是一个太长的列表，然而作为一个行业，我们在可靠性方面并不享有很好的声誉。错误处理似乎很难。为什么呢？
- en: Well, for a start we often don’t know whether an operation can fail and, if
    so, how it can fail. If we do know, then knowledge about how to handle an error
    may be in code a long way from where the problem is detected. Then the code that
    detects an error, and the code that recovers from it, are hard to isolate from
    the happy path and so are hard to test. Combine these with the tendency for errors
    to leave our system in unrecoverable states, and we end up with a situation where
    most developers would rather hope for the best than take on the hard work and
    still get it wrong.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们经常不知道操作是否会失败，以及如果失败的话会是怎样的失败。如果我们知道，那么处理错误的知识可能在离问题检测点很远的代码中。然后检测错误的代码和从错误中恢复的代码很难与正常路径分离，因此很难测试。再加上错误可能使我们的系统陷入无法恢复的状态，我们最终面临的情况是，大多数开发者宁愿抱有乐观期望，而不愿承担艰苦的工作并且最终还是会出错。
- en: Hard work *and* error-prone? Weren’t computers supposed to free us from tasks
    like these, taking on the drudge work, so that we can focus on the fun creative
    stuff? Yes they were, so we will focus on error handling through the lens of how
    our programming language can make things safer and easier for programmers.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 艰苦的工作 *和* 容易出错？计算机不是应该解放我们，从事这些苦活使我们能专注于有趣的创造性工作吗？是的，它们确实应该，因此我们将通过编程语言如何使程序员的工作更安全更简单的角度来关注错误处理。
- en: Error Handling Before Exceptions
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常之前的错误处理
- en: Most error handling these days is based on exceptions, but other techniques
    have been used and are still applicable in some circumstances. We’ll look at the
    pros and cons of those techniques first. The cons will show us why exceptions
    now dominate; the pros may give us options when exceptions aren’t appropriate.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数错误处理如今都基于异常，但在某些情况下仍然可以使用其他技术。我们将首先看看这些技术的优缺点。缺点将告诉我们为什么异常现在占据主导地位；而优点则可能在异常不适用时为我们提供选择。
- en: Ignoring errors
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略错误
- en: We can ignore errors. Either the failing routine does nothing to bring them
    to the attention of the caller, or the caller doesn’t bother to check.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以忽略错误。要么失败的例程不做任何事情来引起调用者的注意，要么调用者根本不去检查。
- en: This may lead to corruption of persistent data and silent failure to do the
    job, so in most cases we need to aim higher.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能导致持久数据的损坏和静默地未能完成任务，所以在大多数情况下，我们需要有更高的要求。
- en: Just crashing
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅崩溃
- en: Some programs just exit when an error is detected.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一些程序在检测到错误时会直接退出。
- en: Combined with a supervisor to restart on error and careful coding to prevent
    corruption of persistent state, this is a battle-tested strategy that may be appropriate.
    Throwing an exception to abort an operation is the application of this technique
    to a procedure rather than to a whole program.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 结合错误重启的监控程序和仔细编码以防止持久状态的破坏，这是一种经过考验的战略，可能是适当的。抛出异常来中止操作是将这种技术应用于过程而不是整个程序的表现。
- en: Returning a special value
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个特殊值
- en: Returning a special value to signify an error can be a useful technique. For
    example, a function can return `-1` instead of an index when an item is not found
    in a list.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个特殊值来表示错误可以是一种有用的技术。例如，当在列表中找不到项时，函数可以返回`-1`而不是索引。
- en: This technique cannot be used when all return values are valid results for a
    function. It can also be dangerous, because the caller has to know (and remember)
    the convention. If we try to calculate the distance between two items in a list
    by subtracting their indices, when one of them is not found and returns -1, our
    calculation will be incorrect unless we explicitly handle the special case. We
    can’t lean on the type checker to help us avoid errors.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有返回值都是函数的有效结果时，此技术无法使用。它也可能很危险，因为调用者必须了解（并记住）约定。如果我们尝试通过减去它们的索引来计算列表中两个项之间的距离，当其中一个找不到并返回`-1`时，除非我们明确处理特殊情况，否则我们的计算将是错误的。我们不能依赖类型检查器来帮助我们避免错误。
- en: A special case of returning a special value is returning null on error. This
    is quite dangerous in most languages, because if the caller doesn’t explicitly
    check for null, then using the result will throw a `NullPointerException`, which
    may be worse than the initial problem. In Kotlin, though, the type checker forces
    callers to deal with null, making this a safe and effective technique.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在发生错误时返回特殊值的一个特殊情况是返回 null。在大多数语言中，这样做非常危险，因为如果调用者没有显式检查 null，那么使用结果将抛出`NullPointerException`，这可能比初始问题更严重。不过，在
    Kotlin 中，类型检查强制调用者处理 null，这使得这种技术是安全和有效的。
- en: Setting a global flag
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 设置全局标志
- en: One problem with returning special values is that they make it hard to signal
    which of several possible errors occurred. To solve this we can combine the special
    value with setting a global variable. When the special value is detected, the
    caller can read `errno`, for example, to establish what the problem was.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 返回特殊值的一个问题是很难表明发生了几种可能的错误之一。为了解决这个问题，我们可以将特殊值与设置全局变量结合起来。当检测到特殊值时，调用者可以读取`errno`，例如，以确定问题所在。
- en: This technique was popular in C but was largely superseded by exception-based
    error handling.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术在 C 语言中很流行，但在很大程度上被基于异常的错误处理所取代。
- en: Returning a status code
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 返回状态码
- en: Another technique from the days before exceptions is returning a status code.
    This is possible when a function either returns no value (it is entirely side
    effect) or returns a value in another way, often by mutating a parameter passed
    by reference.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种在异常出现之前的技术是返回状态码。当函数不返回值（完全是副作用）或以其他方式返回值，通常通过改变传递的引用参数时，可以使用这种技术。
- en: Invoking a special function
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 调用特殊函数
- en: Invoking a special function when an error occurs is sometimes a good strategy.
    Usually the error function is passed as a parameter to the invoked function. If
    a problem is detected, the error function is invoked with a value representing
    the error as a parameter. Sometimes the error function can signal by its return
    value if the failed operation should be retried or aborted. Another technique
    is for the error function to provide the value that should be returned by the
    invoked function.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当出现错误时调用特殊函数有时是一个好策略。通常，错误函数作为参数传递给被调用的函数。如果检测到问题，则调用错误函数，并将表示错误的值作为参数传递。有时，错误函数可以通过其返回值来表示失败的操作是否应重试或中止。另一种技术是让错误函数提供应由被调用函数返回的值。
- en: This technique is an example of the strategy pattern applied to error handling.
    Even when exceptions are available, it is a useful tool in niche situations.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术是错误处理中应用策略模式的一个例子。即使异常可用，它在特定情况下也是一个有用的工具。
- en: Error Handling with Exceptions
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常处理与异常
- en: All these techniques suffer from the drawback that the calling code is able,
    to a greater or lesser extent, to ignore that an error occurred.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些技术都存在一个缺点，即调用代码能够在更大或更小程度上忽略错误的发生。
- en: Exceptions solve this problem. The operation automatically aborts on error,
    and the caller explicitly handles the exception. If the caller does not handle
    it, the exception propagates further down the call stack until something does,
    and if nothing handles the exception, the thread terminates.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 异常解决了这个问题。在错误发生时，操作会自动中止，并且调用者显式处理异常。如果调用者没有处理它，异常将继续传播到调用栈的更深层，直到有地方处理它；如果没有处理异常，线程将终止。
- en: Java and Checked Exceptions
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 和 Checked Exceptions
- en: Exceptions were relatively new when Java was released, and the language designers
    decided to innovate in this area. They made the exceptions that a method could
    throw part of its signature. This way, callers could know that, for example, a
    method might fail because the network resource that it was reading was no longer
    available. If a method declared that it could fail in this way, then every caller
    of that method would either have to deal with the failure (by specifying in a
    `catch` block how it should be handled) or declare that it, too, was liable to
    fail with the same exception. This ensures that the programmer takes account of
    the possibility of these errors. Such exceptions are called *checked exceptions*,
    because the compiler checks that they are handled (or redeclared to be thrown
    by the calling method).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当Java发布时，异常相对较新，语言设计者决定在这一领域进行创新。他们使方法可能引发的异常成为其签名的一部分。这样，调用者可以知道，例如，一个方法可能因为它正在读取的网络资源不再可用而失败。如果一个方法声明它可能以这种方式失败，那么调用该方法的每个调用者都必须处理该失败（通过指定在`catch`块中如何处理）或声明它也可能因相同的异常而失败。这确保了程序员考虑到这些错误的可能性。这些异常称为*检查异常*，因为编译器检查它们是否已处理（或重新声明为调用方法抛出）。
- en: 'Checked exceptions were designed for when the programmer might reasonably be
    able to find a way to recover: retrying a database write or reopening a socket,
    for example. The language designers identified two other types: errors and runtime
    exceptions.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 检查异常设计用于当程序员可能合理地找到一种恢复方法时：例如重试数据库写入或重新打开套接字。语言设计者确定了另外两种类型：错误和运行时异常。
- en: Errors
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 错误
- en: Subclasses of `java.lang.Error` are reserved for failures so severe that the
    JVM can no longer guarantee the correct functioning of the runtime. Maybe a class
    cannot be loaded, or the system runs out of memory. These conditions can happen
    at any point in the execution of a program, and so could cause any function to
    fail. Because any method could fail in this way, there is no value in including
    them in every method signature, so `Error`s do not have to be declared.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.lang.Error`的子类专门用于严重到JVM无法保证运行时正确功能的故障。可能是无法加载类，或者系统内存耗尽。这些情况可能发生在程序执行的任何时刻，因此可能导致任何函数执行失败。由于任何方法都可能以这种方式失败，所以在每个方法签名中包含它们是没有价值的，因此不需要声明`Error`。'
- en: Runtime Exceptions
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时异常
- en: Subclasses of `RuntimeException` represent other errors. The intention was that
    these would be reserved for problems caused by programmer mistakes, such as accessing
    a null reference or trying to read outside the bounds of a collection. In both
    these cases the programmer could have been more careful. Again though, every piece
    of code is subject to programmer error, so `RuntimeExceptions` are also exempted
    from having to be declared.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`RuntimeException`的子类代表其他错误。其意图是这些错误应该保留给程序员错误造成的问题，例如访问空引用或尝试读取集合的边界外。在这两种情况下，程序员本可以更加谨慎。尽管如此，每一行代码都可能存在程序员错误，因此`RuntimeExceptions`也免除了必须声明的义务。'
- en: This scheme forces developers to deal with operations that can fail due to I/O
    errors or other things that are out of their control (the checked exceptions),
    allowing defensive programming where it is economical. At the other extreme, if
    an `Error` is thrown, the best default approach is exit the process as quickly
    as possible, before any more damage can be done to persistent state.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方案迫使开发人员处理可能因I/O错误或其他超出其控制范围的事物（检查异常）而失败的操作，允许经济有效的防御性编程。在另一极端，如果抛出`Error`，最好的默认方法是尽快退出进程，以免对持久状态造成更多损害。
- en: '`RuntimeException`s are a middle ground. If they represent a programmer error,
    we should probably assume that we have just proved that we don’t really know what
    is going on in our program and abort the current operation or whole application.
    Otherwise, we might try to recover, especially if our system has been designed
    to limit the damage that can be done to persistent state.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`RuntimeException`是一个折中的情况。如果它们代表了程序员的错误，我们可能应该假设我们刚刚证明了我们并不真正知道我们的程序正在做什么，并中止当前操作或整个应用程序。否则，我们可能会尝试恢复，特别是如果我们的系统已被设计为限制对持久状态可能造成的损害。'
- en: 'Your authors both really liked checked exceptions, but it seems they were in
    the minority, because checked exceptions fell out of favor in Java over the years.
    Checked exceptions were hampered from the start by the odd decision to make the
    unchecked `RuntimeException` a subclass of the otherwise checked `Exception`,
    so that code that wanted to handle all checked exceptions found itself catching
    unchecked ones as well, hiding programming errors. They were also not helped by
    the fact that the Java APIs used them inconsistently. Take extracting data from
    a string for example: the `URL` constructor `URL(String)` throws the *checked*
    `MalformedURLException`, while `Integer.​par⁠seInt(String)` throws the *unchecked*
    `NumberFormatException`.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你的作者们确实非常喜欢检查异常，但似乎他们是少数派，因为多年来Java中的检查异常已经不受欢迎。从一开始，检查异常就受到奇怪的决定的影响，使得未检查的`RuntimeException`成为否定其他检查异常的`Exception`的子类，因此那些想要处理所有检查异常的代码发现自己也在捕获未检查的异常，隐藏了编程错误。它们也没有因为Java
    API的不一致而得到帮助。以从字符串中提取数据为例：`URL`构造函数`URL(String)`抛出*检查*的`MalformedURLException`，而`Integer.parseInt(String)`抛出*未检查*的`NumberFormatException`。
- en: Confusion over what type of exception to use multiplied, and it wasn’t long
    before the default was that the only checked exceptions that most Java libraries
    declared were `IOExceptions`. Even then, database libraries such as Hibernate,
    which were definitely talking over the network and definitely subject to `IOExceptions`,
    would throw only `RuntimeExceptions`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 混淆对于使用哪种类型的异常的困惑加剧了，不久之后，大多数Java库声明的唯一检查异常都是`IOExceptions`。即使是数据库库如Hibernate，明确在网络上传输并且明确会遭遇`IOExceptions`的情况下，也只会抛出`RuntimeExceptions`。
- en: Once a good proportion of the code that you call just uses unchecked exceptions,
    the game is up. You can’t rely on checked exceptions to warn you about how a function
    might fail. Instead, you are reduced to some tactical defensive programming and
    the age-old technique of putting it into production, seeing what errors you log,
    and adding code to handle those you don’t like the look of.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的代码中有相当一部分使用了未检查异常，情况就不妙了。无法依赖于检查异常来警示你函数可能失败的方式。相反，你只能采取一些战术性的防御编程和老旧技术，将其投入生产，查看日志中记录的错误，并添加代码来处理那些看起来不太合适的情况。
- en: The final nail in the coffin of checked exceptions was the introduction of lambdas
    in Java 8. The decision was taken not to declare an exception type in the signature
    of the functional interfaces introduced to support lambdas (`Producer`, `Consumer`,
    etc.), so these cannot propagate checked exceptions. This wasn’t an insurmountable
    problem, but to be fair, your authors would probably have given up there too.
    The net result, though, is that the old standard Java API declares checked exceptions
    (in particular, `IOException`) that the new standard API (in particular streams)
    forces developers to deny.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8引入lambda函数是检查异常的最后一击。决定在支持lambda的函数式接口的签名中不声明异常类型，因此这些异常无法传播。这并非是无法克服的问题，但公正地说，你的作者们也可能在这里放弃。然而，结果是，旧的标准Java
    API声明了检查异常（特别是`IOException`），而新的标准API（特别是streams）迫使开发者否认它们。
- en: Kotlin and Exceptions
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kotlin与异常
- en: Kotlin has exceptions, because it runs on the JVM, and exceptions are built
    into the platform. It does not treat checked exceptions specially though, because
    Java had already lost that fight, and, as with Java, they are hard to reconcile
    with higher-order functions. Kotlin is able to largely ignore checked exceptions
    because they are not a feature of the JVM but, rather, of the Java compiler. The
    compiler does record in the bytecode what checked exceptions a method declares
    (to be able to check them), but the JVM itself does not care.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin支持异常，因为它运行在JVM上，并且异常是平台内置的。尽管如此，Kotlin并没有特别处理检查异常，因为Java在这方面已经败北了，并且与Java一样，它们难以与高阶函数协调。Kotlin能够大部分忽略检查异常，因为它们不是JVM的特性，而是Java编译器的特性。编译器确实在字节码中记录了方法声明的检查异常（以便进行检查），但JVM本身并不关心。
- en: The result is that Kotlin programs are by default no better or worse than most
    Java programs when it comes to error handling.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，当涉及错误处理时，默认情况下，Kotlin程序与大多数Java程序一样既不好也不坏。
- en: 'An exception (lowercase e) to this is that, as we observed earlier, Kotlin
    can use `null` to indicate an error, safe in the knowledge that callers will have
    to take the possibility of `null` into consideration. An example of this is the
    `<T> Iterable<T>.firstOrNull(): T?` in the runtime. Tellingly, though, the runtime
    also defines `first()`, which throws `NoSuchElementException` if the collection
    is empty.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '这个例外是，正如我们早些时候观察到的那样，Kotlin可以使用`null`来指示错误，因此调用者将不得不考虑到`null`的可能性。例如，在运行时中有`<T>
    Iterable<T>.firstOrNull(): T?`。不过，值得注意的是，运行时也定义了`first()`，如果集合为空则会抛出`NoSuchElementException`。'
- en: 'Beyond Exceptions: Functional Error Handling'
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超越异常：函数式错误处理
- en: Statically typed functional programming languages often reject exceptions in
    favor of another error handling technique based on *Either Types*. We’ll see what
    an Either Type is shortly, but why don’t functional programmers like exceptions?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 静态类型的函数式编程语言通常不接受异常，而是倾向于另一种基于*Either Types*的错误处理技术。我们很快会看到Either Type是什么，但为什么函数式编程人员不喜欢异常呢？
- en: 'A distinguishing feature of functional programming is *referential transparency*.
    When an expression is referentially transparent, we can safely replace it with
    the result of its evaluation. So if we write:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程的一个显著特征是*引用透明性*。当一个表达式是引用透明的时候，我们可以安全地用其评估结果替换它。所以如果我们写下：
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: then we can replace `60 * 60` with `3600` or `60 * 24` with `1440` without affecting
    the results. In fact, the compiler may decide to replace the whole expression
    with `86400` for us, and (unless we examine the bytecode or use a debugger) we
    will be none the wiser.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以用`3600`替换`60 * 60`，或者用`1440`替换`60 * 24`而不影响结果。事实上，编译器可以决定为我们用`86400`替换整个表达式，而（除非我们检查字节码或使用调试器）我们不会知道这一点。
- en: 'In contrast:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下：
- en: '[PRE1]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: is not referentially transparent, because `today()` will yield a different result
    than it did yesterday, and any day may have a leap second applied. As a result,
    the value of `secondsIn(today())` may differ depending on when we call it, and
    we can’t just substitute the same value for the expression every time we use it.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 不是引用透明的，因为`today()`的结果与昨天不同，并且任何一天都可能增加一秒。因此，`secondsIn(today())`的值可能因调用时间不同而异，并且我们不能每次使用它时都用相同的值替换表达式。
- en: This is the same concept as we saw in [Chapter 7](ch07.html#actions-to-calculations).
    [“Calculations”](ch07.html#calculations) are referentially transparent; [“Actions”](ch07.html#actions)
    are not.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们在[第7章](ch07.html#actions-to-calculations)中看到的概念相同。[“Calculations”](ch07.html#calculations)是引用透明的；[“Actions”](ch07.html#actions)不是。
- en: Why should we care? Because referential transparency makes it a lot easier to
    reason about the behavior of a program, which in turn leads to fewer errors and
    more opportunities to refactor and optimize. If we want these things (and at the
    very least we don’t want more errors and fewer opportunities), then we should
    strive for referential transparency.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们应该关心呢？因为引用透明性大大简化了对程序行为的推理，这反过来会减少错误并提供更多重构和优化的机会。如果我们希望实现这些目标（至少我们不希望出现更多错误和减少机会），那么我们应该追求引用透明性。
- en: What does this have to do with error handling? Let’s return to our `Integer.​par⁠seInt(String)`
    example and see. For a given valid input, `parseInt` will always return the same
    value, so it could be referentially transparent. In the cases where the `String`
    doesn’t represent an integer, though, `parseInt` throws an exception rather than
    returning a result. We can’t replace the result of the function invocation with
    an exception, because the type of the expression is `Int`, and an `Exception`
    isn’t an `Int`. Exceptions break referential transparency.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这与错误处理有什么关系？让我们回到我们的`Integer.​par⁠seInt(String)`示例中来看看。对于给定的有效输入，`parseInt`将始终返回相同的值，因此它可以是引用透明的。然而，在`String`不表示整数的情况下，`parseInt`会抛出异常而不是返回结果。我们无法用异常替换函数调用的结果，因为表达式的类型是`Int`，而`Exception`不是`Int`。异常破坏了引用透明性。
- en: If instead of using exceptions we returned to the old trick of using a special
    value to represent errors, we would have referential transparency, because that
    error value can replace the expression. In Kotlin, `null` would be great here,
    so we could define `parseInt` to return `Int?`. But what if we needed to know
    which was the first character that wasn’t a digit? We can convey that information
    in an exception but not in a return type of `Int?`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不使用异常，而是回到使用特殊值来表示错误的旧技巧，我们将具有引用透明性，因为该错误值可以替换表达式。在Kotlin中，`null`在这里非常适合，因此我们可以定义`parseInt`返回`Int?`。但是如果我们需要知道第一个不是数字的字符是什么呢？我们可以通过异常传达这些信息，但不能在返回类型为`Int?`中。
- en: Can we find a way for our function to return *either* the `Int`, or the way
    that it failed?
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否找到一种方法，让我们的函数返回*要么*`Int`，要么它失败的方式？
- en: 'The answer, as they say, is in the question. We define a type `Either`, which
    can hold one of two types, but only one at a time:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如他们所说，答案就在问题中。我们定义了一个类型`Either`，它可以同时持有两种类型中的一种：
- en: '[PRE2]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In Kotlin, sealed classes ([Chapter 18](ch18.html#open-to-sealed-classes)) are
    excellent for this, because we can define our own subtypes but know that no one
    else can.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中，密封类（[第18章](ch18.html#open-to-sealed-classes)）非常适合这种情况，因为我们可以定义自己的子类型，但其他人无法访问。
- en: 'When `Either` is used for error handling, the convention is that `Right` is
    used for a result, `Left` for an error. If we stick to this convention, we could
    define:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当`Either`用于错误处理时，约定是`Right`用于结果，`Left`用于错误。如果我们遵循这个约定，我们可以定义：
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'How would we use this? As we saw in [Chapter 18](ch18.html#open-to-sealed-classes),
    `when` expressions and smart casting work really nicely to let us write things
    like:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何使用这个？正如我们在[第18章](ch18.html#open-to-sealed-classes)中看到的，`when`表达式和智能转换非常适合让我们编写如下代码：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'By returning an `Either`, we force our clients to deal with the fact that we
    may have failed. This gives some of the advantages of checked exceptions in a
    functional form. To embrace this style, we make all functions that in Java we
    would have declared to throw a checked exception return an `Either`. The callers
    then either unwrap the success and act on it or pass on any failure:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 通过返回`Either`，我们强制客户端处理可能失败的情况。这在功能形式上具有一些检查异常的优势。为了采纳这种风格，我们使得所有在Java中声明会抛出检查异常的函数返回`Either`。调用者可以解开成功的部分并对其进行操作，或者传递任何失败：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Although using `when` to unwrap an `Either` is logical, it is also verbose.
    This particular pattern occurs so much that we define `map` to be:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管使用`when`来解开`Either`是合乎逻辑的，但也很冗长。这种模式经常出现，因此我们定义`map`如下：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This allows us to write the previous function as:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们可以将前面的函数写成：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Why is that function called `map` and not `invokeUnlessLeft`? Well, if you squint
    you may be able to see that it is kind of the same thing as `List.map`. It applies
    a function to the contents of a container, returning the result in another container.
    In the case of `Either`, `map` applies the function only if it is a `Right` (nonerror);
    otherwise, it passes `Left`s on unchanged.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么那个函数叫做`map`而不是`invokeUnlessLeft`？嗯，如果你眯起眼睛，你可能能看出它和`List.map`有些相似。它将一个函数应用于容器的内容，并将结果放入另一个容器中。对于`Either`来说，`map`仅在是`Right`（非错误）时应用该函数；否则，它保持不变传递`Left`。
- en: 'Practice that squinting, because we are now going to define:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 练习那种眯眼看的技能，因为我们现在要定义：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This unpacks our value and uses it to invoke a function that in turn might
    fail (as it returns `Either`). What can we do with that? Well, let’s say we want
    to read from a `Reader` and print double the result. We can define a wrapper for
    `readLine` that returns an `Either` rather than failing with an exception:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这将解开我们的值并使用它来调用一个可能失败的函数（因为它返回`Either`）。我们能对此做些什么呢？好吧，假设我们想要从`Reader`中读取并打印结果的两倍。我们可以定义一个`readLine`的包装器，它返回`Either`而不是用异常失败：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This lets us combine `eitherReadLine` and `doubleString` with `flatMap`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们使用`flatMap`将`eitherReadLine`和`doubleString`组合起来：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This code will return a `Left` with the failure if `eitherReadLine` fails; otherwise,
    it will return the result of `doubleString`, which may itself be either a `Left`
    for failure or a `Right` with the final `Int` result. In this way a chain of `map`
    and/or `flatMap` calls acts like a series of expressions, which might throw an
    exception; the first failure aborts the rest of the computation.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`eitherReadLine`失败，此代码将返回一个带有失败的`Left`；否则，它将返回`doubleString`的结果，该结果本身可能是一个带有最终`Int`结果的`Left`或`Right`。通过这种方式，一系列`map`和/或`flatMap`调用就像一系列表达式，可能会抛出异常；第一个失败会中止其余的计算。
- en: If you come from an object-oriented background, this style does take some getting
    used to. In our experience no amount of reading helps; you just have to knuckle
    down and start writing code this way until it becomes less strange. We’ll share
    your pain by pairing with you in the worked example later.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自面向对象的背景，这种风格确实需要一些时间来适应。根据我们的经验，再多的阅读也不会有帮助；你只需认真开始以这种方式编写代码，直到它变得不那么陌生。我们将通过在后续的示例中与你合作来分享你的痛苦。
- en: Error Handling in Kotlin
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kotlin中的错误处理
- en: Now that we know the error handling options open to us, which should we use
    in our Kotlin projects, and how do we migrate our Java code?
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了开放给我们的错误处理选项，我们在Kotlin项目中应该使用哪种，以及如何迁移我们的Java代码？
- en: As usual, it depends.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，这要看情况而定。
- en: Using nullable types to represent failure is very effective, provided that you
    don’t need to convey any information about the reason for failure.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用可空类型来表示失败非常有效，前提是你不需要传达失败原因的任何信息。
- en: You won’t be fired for using exceptions as your default strategy. The lack of
    type checking makes it hard to communicate what code is subject to what failure,
    though, which in turn makes it hard to build reliable systems. Adding insult to
    this injury, you will lose the benefits of referential transparency, making it
    harder to refactor and fix your unreliable system.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用异常作为默认策略不会导致你被解雇。然而，缺乏类型检查使得很难明确哪些代码会失败，这反过来使得构建可靠系统变得困难。更加让人难堪的是，你将失去参考透明性的好处，这样一来，重构和修复不可靠系统就更加困难了。
- en: 'Our preference is to return an `Either` type from those operations that would
    have thrown a checked exception in Java, either because of I/O problems, or because,
    like `parseInt`, they cannot give a result for all inputs. This allows us to reserve
    the use of exceptions for more pernicious problems. `Errors` are still appropriate
    for unrecoverable program errors: in this case we should design our systems so
    that the program exits and is restarted by some other process. `RuntimeExceptions`
    are still good for signaling when we have made an error as programmers: `IndexOutOfBounds`
    and the like. If we have carefully designed our system, it should be able to survive
    these issues and process other inputs that do not run into the same problem.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更倾向于从那些在Java中会抛出已检查异常的操作中返回`Either`类型，无论是因为I/O问题，还是像`parseInt`一样，它们无法为所有输入提供结果。这使我们可以将异常保留给更为恶劣的问题。对于不可恢复的程序错误，仍然适用`Errors`：在这种情况下，我们应设计我们的系统，使得程序退出并由其他进程重新启动。`RuntimeExceptions`在我们作为程序员犯错误时仍然是很好的信号：例如`IndexOutOfBounds`等情况。如果我们精心设计了我们的系统，它应该能够处理这些问题并处理不会遇到同样问题的其他输入。
- en: Which `Either` type should you choose? The built-in Kotlin `Result` type is,
    at the time of writing, a frustrating placeholder which just teases and gets in
    the way. It is designed for coroutines, is restricted to an `Exception` (actually
    `Throwable`) as its error value, and IntelliJ moans if you use it as a property
    type. This would be reasonable if it wasn’t published in the `kotlin` package.
    It is, though, so if you try to use a more useful type called `Result`, you get
    strange error messages until you remember that the compiler is assuming that `Result`
    refers to the `kotlin.Result` type that you aren’t supposed to use.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该选择哪种`Either`类型？在撰写本文时，内置的Kotlin `Result`类型是一个令人沮丧的占位符，它只是一种挑逗并且会妨碍进展。它专为协程设计，受限于`Exception`（实际上是`Throwable`）作为其错误值，并且如果你将其用作属性类型，IntelliJ会抱怨。如果它没有发布在`kotlin`包中，这就合理了。然而，它确实发布在那里，所以如果你尝试使用一个更有用的名为`Result`的类型，你会得到奇怪的错误消息，直到你记住编译器假设`Result`指的是你不应该使用的`kotlin.Result`类型。
- en: Plenty of other result types are available, but for this book we will use [Result4k](https://oreil.ly/F5Y4M),
    not coincidentally written by Nat. Compared to the generic `Either` type we introduced
    earlier, Result4k defines `Result<SuccessType, FailureType>`, with subtypes `Success`
    and `Failure` rather than `Left` and `Right`. Because it is specialized for representing
    errors, Result4k reverses the `Either` convention by having the success type as
    the first of the generic parameters. It can also offer operations, such as `onFailure`
    and `recover`, that would not make sense on `Either`. We’ll see some of these
    operations as we refactor.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他的结果类型可用，但是在本书中我们将使用 [Result4k](https://oreil.ly/F5Y4M)，这不是巧合，它是由 Nat 编写的。与我们之前介绍的通用
    `Either` 类型相比，Result4k 定义了 `Result<SuccessType, FailureType>`，具有子类型 `Success`
    和 `Failure`，而不是 `Left` 和 `Right`。由于它专门用于表示错误，Result4k 通过将成功类型作为泛型参数的第一个来反转 `Either`
    惯例。它还可以提供诸如 `onFailure` 和 `recover` 等操作，在 `Either` 上是不合理的。在重构时，我们将看到其中的一些操作。
- en: Refactoring Exceptions to Errors
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将异常重构为错误
- en: Now that we know the error handling options available to us, let’s refactor
    some Java code to Kotlin, converting the error handling as we go.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了可用的错误处理选项，让我们重构一些 Java 代码到 Kotlin，逐步转换错误处理。
- en: 'There is an HTTP endpoint in Travelator that allows the client app to register
    a `Customer`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Travelator 中有一个 HTTP 端点，允许客户端应用注册一个 `Customer`：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[Example 19.1 [errors.0:src/main/java/travelator/handlers/CustomerRegistrationHandler.java]](https://java-to-kotlin.dev/code.html?ref=19.1&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.1&show=diff)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.1 [errors.0:src/main/java/travelator/handlers/CustomerRegistrationHandler.java]](https://java-to-kotlin.dev/code.html?ref=19.1&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.1&show=diff)'
- en: '`CustomerRegistrationHandler`’s job is to extract data from the request body,
    pass it to `registration` for processing, and return a response with either a
    JSON representation of a `Customer` or a suitable error status code.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`CustomerRegistrationHandler` 的工作是从请求体中提取数据，将其传递给 `registration` 进行处理，并返回一个
    JSON 表示的 `Customer` 或适当的错误状态码响应。'
- en: '`CustomerRegistration` implements the business rules, which is that potential
    customers should be vetted against an `ExclusionList`. We don’t want to allow
    known undesirables to register and abuse our services, so we reject them at this
    point:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`CustomerRegistration` 实现了业务规则，即潜在客户应该经过 `ExclusionList` 的审核。我们不希望允许已知的不良分子注册并滥用我们的服务，因此我们在这一点上拒绝他们：'
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[Example 19.2 [errors.0:src/main/java/travelator/CustomerRegistration.java]](https://java-to-kotlin.dev/code.html?ref=19.2&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.2&show=diff)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.2 [errors.0:src/main/java/travelator/CustomerRegistration.java]](https://java-to-kotlin.dev/code.html?ref=19.2&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.2&show=diff)'
- en: 'Look at the `throws` clause of `register`. It tells us that the method can
    fail because of the explicit exclusion, but also that `customers.add` can fail
    with a `DuplicateException`. Here is the `Customers` interface:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 `register` 方法的 `throws` 子句。它告诉我们，这个方法可能因为明确的排除而失败，但也可能因为 `customers.add`
    导致 `DuplicateException` 失败。这是 `Customers` 接口：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[Example 19.3 [errors.0:src/main/java/travelator/Customers.java]](https://java-to-kotlin.dev/code.html?ref=19.3&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.3&show=diff)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.3 [errors.0:src/main/java/travelator/Customers.java]](https://java-to-kotlin.dev/code.html?ref=19.3&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.3&show=diff)'
- en: 'Finally, `Customer` is another value type. Here it is after conversion to Kotlin:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Customer` 是另一个值类型。在这里它转换为 Kotlin 后的样子：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[Example 19.4 [errors.1:src/main/java/travelator/Customer.kt]](https://java-to-kotlin.dev/code.html?ref=19.4&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.4&show=diff)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.4 [errors.1:src/main/java/travelator/Customer.kt]](https://java-to-kotlin.dev/code.html?ref=19.4&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.4&show=diff)'
- en: This is typical of your authors’ Java style. It expresses the things that might
    reasonably go wrong as the checked `ExcludedException` and `DuplicateException`,
    and these are all caught at the top level in `handle`, where they are reported
    to the caller, in this case as HTTP status codes. Your style might be to use unchecked
    exceptions, in which case this code would be similar but without the exceptions
    as part of the method signatures.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你们作者的典型 Java 风格。它表达了可能发生的事情，如检查的 `ExcludedException` 和 `DuplicateException`，这些都在
    `handle` 的顶层捕获，然后作为 HTTP 状态码报告给调用者。你的风格可能是使用未检查的异常，在这种情况下，这段代码的写法会类似，但方法签名中不包括异常。
- en: One thing we don’t see is any checked exception related to failures to persist
    a `Customer` in `Customers::add`. This method will be talking across the network
    to a database, but our query code is evidently swallowing `IOException` at some
    point and raising a `RuntimeException` in its place. These will propagate out
    of `Customer​Regis⁠tration::register`, be caught at the top level of `CustomerRegistrationHandler`,
    and passed back to clients as `HTTP_INTERNAL_ERROR` (500). It’s a shame that we
    aren’t logging any information about those stray `RuntimeException`s, because
    they might reveal systematic connection issues or be hiding a frequent `NullPointer​Excep⁠tion`
    in some lower-level code. Someone should probably address that, but in the meantime
    at least we have a shorter example to show in this book.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看不到与将`Customer`持久化到`Customers::add`失败相关的任何检查异常。这个方法将通过网络与数据库通信，但显然我们的查询代码在某个点上吞掉了`IOException`并替换为`RuntimeException`。这些异常将传播到`Customer​Regis⁠tration::register`的顶层，被`CustomerRegistrationHandler`捕获，并作为`HTTP_INTERNAL_ERROR`（500）传递回客户端。很遗憾我们没有记录关于这些零散`RuntimeException`的任何信息，因为它们可能揭示系统性连接问题或者在一些低级代码中隐藏着频繁的`NullPointer​Excep⁠tion`。在此期间，有人应该解决这个问题，但与此同时，至少我们在本书中展示了一个较短的示例。
- en: Our Conversion Strategy
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的转换策略
- en: If we were just to convert this code to Kotlin, we would lose the advantages
    of checked exceptions to tell us what could go wrong and show where we are handling
    those problems. So as we convert, we will replace exception-based error handling
    with a functional alternative using Result4k.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仅将此代码转换为 Kotlin，我们将失去检查异常提供的优势，无法告诉我们可能出现什么问题以及我们在哪里处理了这些问题。因此，在转换过程中，我们将使用
    Result4k 替换基于异常的错误处理功能性替代方案。
- en: In this example, we’ll start at the lowest level and work our way up, keeping
    higher levels working until the predictable error cases (those that are currently
    expressed as checked exceptions) no longer use exceptions. At the same time, we
    have to be mindful that pretty much any instruction in the JVM can fail, so we
    need to defend against these runtime issues.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将从最底层开始，逐步向上工作，保持更高级别的工作，直到那些当前表达为检查异常的可预测错误案例不再使用异常。与此同时，我们必须注意，JVM
    中几乎任何指令都可能失败，因此我们需要防范这些运行时问题。
- en: Starting at the Bottom
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从底层开始
- en: 'If we convert `Customers` to Kotlin, we get:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`Customers`转换为 Kotlin，我们得到：
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[Example 19.5 [errors.3:src/main/java/travelator/Customers.kt]](https://java-to-kotlin.dev/code.html?ref=19.5&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.5&show=diff)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.5 [errors.3:src/main/java/travelator/Customers.kt]](https://java-to-kotlin.dev/code.html?ref=19.5&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=19.5&show=diff)'
- en: '[![1](assets/1.png)](#co_introduction_CO42-1)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_introduction_CO42-1)'
- en: Although Kotlin doesn’t have checked exceptions, the `@Throws` annotation allows
    interop with Java code by adding the exception to the method’s signature in the
    bytecode. Without it, a Java implementation of `Customers` that does throw `DuplicateException`
    cannot implement the method. Worse, Java code that calls the method on the interface
    would not be able to catch the exception or declare that it is passed on, because
    it is a compile error for Java code to handle a checked exception that the compiler
    cannot see is possible.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Kotlin 没有检查异常，但`@Throws`注解允许通过将异常添加到方法的字节码签名中与 Java 代码进行互操作。如果没有它，一个 Java
    实现的`Customers`如果抛出`DuplicateException`将无法实现该方法。更糟的是，调用接口上的方法的 Java 代码将无法捕获异常或声明它被传递，因为
    Java 代码处理编译器无法看到的检查异常将是一个编译错误。
- en: Our strategy is to add to our interface a version of `Customers::add` that,
    instead of throwing an exception, returns `Result<Customer, DuplicateException>`.
    If we were starting from scratch, we wouldn’t use `DuplicateException` as the
    error type, but here it lets us interoperate with Java easily. We are going to
    keep the current throwy version around for now so that we don’t break existing
    callers. Then we will convert those callers to use the `Result` version and then
    remove the old version when we can. That’s right, it’s our old friend [“Expand-and-Contract
    Refactoring”](ch04.html#expand-contract).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的策略是在接口中添加`Customers::add`的一个版本，该版本不会抛出异常，而是返回`Result<Customer, DuplicateException>`。如果我们从头开始，我们不会将`DuplicateException`作为错误类型使用，但在这里它让我们可以轻松地与
    Java 进行交互。目前我们会保留当前的抛出版本，以免破坏现有的调用者。然后，当我们可以时，我们将转换这些调用者以使用`Result`版本，然后删除旧版本。没错，这是我们的老朋友[“扩展和收缩重构”](ch04.html#expand-contract)。
- en: 'What should we call the method that works like `Customers::add` but returns
    a `Result`? We can’t name it `add` too, because both have the same parameters,
    so we call it `addToo` for now. If the new method delegates to `add`, we can make
    it a default method so that it is available to all implementations:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该如何称呼像`Customers::add`但返回`Result`的方法？我们不能再命名为`add`，因为两者具有相同的参数，所以暂时称其为`addToo`。如果新方法委托给`add`，我们可以将其作为默认方法，以便所有实现都可以使用：
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[Example 19.6 [errors.5:src/main/java/travelator/Customers.kt]](https://java-to-kotlin.dev/code.html?ref=19.6&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.6&show=diff)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.6 [errors.5:src/main/java/travelator/Customers.kt]](https://java-to-kotlin.dev/code.html?ref=19.6&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=19.6&show=diff)'
- en: 'Now that we have both exception and result versions of the method, we can migrate
    the callers of the exception version. Although we can use Result4k from Java,
    it’s a lot more convenient from Kotlin. So let’s take `CustomerRegistration` (the
    caller of `add`):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们既有异常版本又有结果版本的方法，我们可以迁移调用异常版本的调用者。虽然我们可以从Java中使用Result4k，但从Kotlin更加方便。因此，让我们来看看`CustomerRegistration`（调用`add`的地方）：
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[Example 19.7 [errors.5:src/main/java/travelator/CustomerRegistration.java]](https://java-to-kotlin.dev/code.html?ref=19.7&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.7&show=diff)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.7 [errors.5:src/main/java/travelator/CustomerRegistration.java]](https://java-to-kotlin.dev/code.html?ref=19.7&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=19.7&show=diff)'
- en: 'Converting this to Kotlin gives:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 将其转换为Kotlin如下：
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[Example 19.8 [errors.6:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.8&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.8&show=diff)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.8 [errors.6:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.8&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=19.8&show=diff)'
- en: 'That `customers.add` expression is the one that can throw `DuplicateException`.
    We’re going to replace it with a call to `addToo` but keeping the behavior the
    same. So we pull out `result` as a local:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 那个`customers.add`表达式就是可能抛出`DuplicateException`的表达式。我们将其替换为调用`addToo`，但保持行为不变。因此，我们将`result`作为局部变量提取出来：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[Example 19.9 [errors.7:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.9&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.9&show=diff)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.9 [errors.7:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.9&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=19.9&show=diff)'
- en: 'If we now call `addToo` instead, it will no longer throw, but the exception
    will be returned in the `Result`. This won’t compile yet:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在调用`addToo`而不是`add`，它将不再抛出异常，但异常将在`Result`中返回。但这暂时无法编译：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[Example 19.10 [errors.8:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.10&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.10&show=diff)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.10 [errors.8:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.10&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=19.10&show=diff)'
- en: '[![1](assets/1.png)](#co_introduction_CO43-1)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_introduction_CO43-1)'
- en: '`Type mismatch. Required: Customer Found: Result<Customer,` `Duplicate​Excep⁠tion>`'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`类型不匹配。要求：Customer 实际：Result<Customer,` `Duplicate​Excep⁠tion>`'
- en: 'We have a `Result`, so we need to unpack it. When it is `Success`, we want
    to return the wrapped value; when `Failure`, throw the wrapped `DuplicateException`
    (to keep the current behavior of `register`):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个`Result`，所以我们需要解开它。当它是`Success`时，我们希望返回包装的值；当是`Failure`时，抛出包装的`DuplicateException`（以保持`register`的当前行为）：
- en: '[PRE21]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[Example 19.11 [errors.9:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.11&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.11&show=diff)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.11 [errors.9:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.11&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=19.11&show=diff)'
- en: 'As it happens, where the error type is an `Exception`, Result4k has a function
    to shortcut this case: `Result::orThrow`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 恰巧的是，当错误类型是`Exception`时，Result4k有一个函数来简化此情况：`Result::orThrow`：
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[Example 19.12 [errors.10:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.12&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.12&show=diff)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.12 [errors.10:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.12&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=19.12&show=diff)'
- en: 'Now we can inline to get back to a shorter form:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以内联以回到更简洁的形式：
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[Example 19.13 [errors.11:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.13&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.13&show=diff)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.13 [errors.11:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.13&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.13&show=diff)'
- en: Finally, that nesting is too confusing for comfort, so let’s simplify it by
    using “Replace ‘if’ with ‘when’”, “Replace return with ‘when’ expression”, and
    “Remove braces from all ‘when’ entries”. Alt-Enter all the things!
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，嵌套过多让人感到困惑，所以让我们通过使用“用‘when’替换‘if’”、“用‘when’表达式替换return”和“从所有‘when’条目中删除大括号”来简化它。Alt-Enter
    一切！
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[Example 19.14 [errors.12:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.14&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.14&show=diff)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.14 [errors.12:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.14&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.14&show=diff)'
- en: Splendid. We’ve replaced one of the uses of exceptions with a result type; let’s
    have a little rest.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 卓越的。我们用结果类型替换了异常的一种用法；让我们稍作休息。
- en: Contract
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合同
- en: Ready to go again? Good.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好再开始了吗？好的。
- en: We now have to choose whether to proceed depth- or breadth-first. Depth-first
    would address the caller of `CustomerRegistration::register`; breadth-first would
    first fix up the other callers of `Customers::add` so that we can remove it. As
    it happens, our example code has no other callers of `add`, so breadth-first isn’t
    an option, and we can get on with the contract phase of expand and contract.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在必须选择是深度优先还是广度优先。深度优先会解决`CustomerRegistration::register`的调用者；广度优先会先修复`Customers::add`的其他调用者，以便我们可以删除它。恰好，我们的示例代码没有`add`的其他调用者，所以广度优先不是一个选项，我们可以继续扩展和收缩的合同阶段。
- en: 'We currently have two implementations of `Customers::add`. One is the production
    implementation that talks to the database, the other a test implementation. Our
    code now calls them via the default implementation of `Customers::addToo` that
    we added to the interface. We want to delete the `add` implementations, so we
    need to implement `addToo` directly. Let’s look at the (not thread-safe) test
    version:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前有两个`Customers::add`的实现。一个是与数据库交互的生产实现，另一个是测试实现。我们的代码现在通过我们添加到接口的`Customers::addToo`的默认实现来调用它们。我们想要删除`add`实现，因此我们需要直接实现`addToo`。让我们看一下（不是线程安全的）测试版本：
- en: '[PRE25]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[Example 19.15 [errors.12:src/test/java/travelator/InMemoryCustomers.java]](https://java-to-kotlin.dev/code.html?ref=19.15&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.15&show=diff)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.15 [errors.12:src/test/java/travelator/InMemoryCustomers.java]](https://java-to-kotlin.dev/code.html?ref=19.15&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.15&show=diff)'
- en: 'The easiest way to implement `addToo` here is probably just to duplicate `add`
    and fix it up, returning `Failure` where we had thrown and `Success` for the happy
    path:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里实现`addToo`的最简单方法可能就是复制`add`并修复它，将我们抛出的地方返回`Failure`，将快乐路径返回`Success`：
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[Example 19.16 [errors.13:src/test/java/travelator/InMemoryCustomers.java]](https://java-to-kotlin.dev/code.html?ref=19.16&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.16&show=diff)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.16 [errors.13:src/test/java/travelator/InMemoryCustomers.java]](https://java-to-kotlin.dev/code.html?ref=19.16&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.16&show=diff)'
- en: 'We can also use this strategy to add `addToo` to our production implementations
    of `Customers`; we’ll skip the details. Once we are done, we can delete the unused
    `add` from the implementations and the interface and then rename `addToo` to `add`,
    leaving us with:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '我们也可以使用这种策略将`addToo`添加到`Customers`的生产实现中；我们将跳过细节。完成后，我们可以从实现和接口中删除未使用的`add`，然后将`addToo`重命名为`add`，留下： '
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[Example 19.17 [errors.14:src/main/java/travelator/Customers.kt]](https://java-to-kotlin.dev/code.html?ref=19.17&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.17&show=diff)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.17 [errors.14:src/main/java/travelator/Customers.kt]](https://java-to-kotlin.dev/code.html?ref=19.17&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.17&show=diff)'
- en: 'The clients of `Customers` are now back to calling `add`, albeit the version
    returning a `Result` rather than declaring checked exceptions:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`Customers`的客户现在又开始调用`add`，尽管是返回`Result`的版本，而不是声明受检异常：'
- en: '[PRE28]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[Example 19.18 [errors.14:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.18&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.18&show=diff)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.18 [errors.14:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.18&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.18&show=diff)'
- en: We left `InMemoryCustomers` as Java really just to demonstrate that we could
    return Result4k types from our old code, but we can’t resist the conversion, because
    the code now has a number of warnings of the type `Not annotated [X] overrides
    @NotNull [X]`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `InMemoryCustomers` 保留为 Java 仅仅是为了演示我们可以从旧代码返回 `Result4k` 类型，但我们无法抵制转换，因为现在代码有许多类型为
    `Not annotated [X] overrides @NotNull [X]` 的警告。
- en: 'After conversion, including moving from streams to Kotlin collection operations
    ([Chapter 13](ch13.html#streams-to-sequences)), we have:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 转换后，包括从流操作到 Kotlin 集合操作的移动（[第 13 章](ch13.html#streams-to-sequences)），我们有：
- en: '[PRE29]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[Example 19.19 [errors.15:src/test/java/travelator/InMemoryCustomers.kt]](https://java-to-kotlin.dev/code.html?ref=19.19&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.19&show=diff)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.19 [errors.15:src/test/java/travelator/InMemoryCustomers.kt]](https://java-to-kotlin.dev/code.html?ref=19.19&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.19&show=diff)'
- en: 'Let’s recap where we are now. `Customers` is now Kotlin, and `add` returns
    a `Result` instead of throwing `DuplicateException`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们现在的状态。`Customers` 现在是 Kotlin，`add` 返回 `Result` 而不是抛出 `DuplicateException`：
- en: '[PRE30]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[Example 19.20 [errors.15:src/main/java/travelator/Customers.kt]](https://java-to-kotlin.dev/code.html?ref=19.20&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.20&show=diff)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.20 [errors.15:src/main/java/travelator/Customers.kt]](https://java-to-kotlin.dev/code.html?ref=19.20&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.20&show=diff)'
- en: '`IRegisterCustomers` is still Java and still throws two types of exception:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`IRegisterCustomers` 仍然是 Java，并且仍然会抛出两种类型的异常：'
- en: '[PRE31]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[Example 19.21 [errors.15:src/main/java/travelator/IRegisterCustomers.java]](https://java-to-kotlin.dev/code.html?ref=19.21&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.21&show=diff)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.21 [errors.15:src/main/java/travelator/IRegisterCustomers.java]](https://java-to-kotlin.dev/code.html?ref=19.21&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.21&show=diff)'
- en: '`CustomerRegistration` is now Kotlin and is where we now thunk between `Result.Error`
    and `DuplicateException`, using `orThrow`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`CustomerRegistration` 现在是 Kotlin，我们现在在 `Result.Error` 和 `DuplicateException`
    之间进行 thunk 操作，使用 `orThrow`：'
- en: '[PRE32]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[Example 19.22 [errors.15:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.22&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.22&show=diff)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.22 [errors.15:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.22&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.22&show=diff)'
- en: We have converted a whole layer of our interaction to use a result type and
    can move out to the next.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将交互的整个层次转换为使用结果类型，并可以继续到下一个阶段。
- en: Stepping Out
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 走出去
- en: If we are to follow the same pattern with `IRegisterCustomers::register` as
    we did with `Customers`—providing a default implementation of an adapter between
    exception-throwing and error-returning—we will have to address the issue of how
    to express the result of a function that can fail for two reasons. That’s because
    `register` is currently declaring that it throws both `ExcludedException` and
    `DuplicateException` checked exceptions. In code, we want something like `Result<Customer,`
    `Either​<Exclu⁠dedException,` `DuplicateException>>`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要像处理 `Customers` 的 `IRegisterCustomers::register` 一样遵循相同的模式——提供异常抛出和错误返回之间的适配器的默认实现——我们将不得不解决一个函数可能由于两个原因失败的结果表达的问题。这是因为
    `register` 目前声明同时抛出 `ExcludedException` 和 `DuplicateException` 检查异常。在代码中，我们希望得到类似
    `Result<Customer, Either​<Exclu⁠dedException, DuplicateException>>` 的东西。
- en: 'We *could* use a generic `Either` type, but that only gets us so far as a strategy.
    Unlike Java, where the order that we declare exceptions doesn’t matter, `Either<Exclu⁠ded​Excep⁠tion,
    DuplicateException>` is not the same thing as `Either<DuplicateException,` `ExcludedException>`.
    The `Either` is at best really confusing and will get even worse if we ever have
    more than two exceptions: `OneOf<ExcludedException, Duplicate​Ex⁠cep⁠tion, SomeOtherProblem>`
    is just horrible.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们*可以*使用通用的 `Either` 类型，但这只能作为一种策略，这和 Java 不同，我们声明异常的顺序不重要，`Either<Exclu⁠ded​Excep⁠tion,
    DuplicateException>` 不同于 `Either<DuplicateException, ExcludedException>`。`Either`
    最多只是令人困惑的东西，如果我们有超过两个异常，情况将变得更糟：`OneOf<ExcludedException, Duplicate​Ex⁠cep⁠tion,
    SomeOtherProblem>` 简直糟透了。
- en: 'Another option is to move up to the common superclass of the two exceptions
    and declare the return type as `Result<Customer, Exception>`. This fails the communication
    test: we can’t look at the signature and gain any clues about what types of errors
    we are expecting.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是提升到这两个异常的共同超类，并将返回类型声明为 `Result<Customer, Exception>`。这不符合通信测试：我们无法查看签名并获取任何关于我们期望的错误类型的线索。
- en: Instead, our best strategy here is not to try to express the error in terms
    of existing types, but to map to a new type.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们在这里的最佳策略不是试图用现有类型来表达错误，而是映射到一个新类型。
- en: 'As *exception* and *error* are all overloaded terms, we’ve chosen `RegistrationProblem`,
    with subtypes of `Excluded` (which carries no additional information and so can
    be an `object`), and `Duplicate` (which carries any message from the original
    `DuplicateException`):'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 由于“异常”和“错误”都是负载过重的术语，我们选择了`RegistrationProblem`，其子类型有`Excluded`（不携带额外信息，因此可以是一个`object`）和`Duplicate`（携带原始`DuplicateException`的任何消息）：
- en: '[PRE33]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[Example 19.23 [errors.16:src/main/java/travelator/IRegisterCustomers.kt]](https://java-to-kotlin.dev/code.html?ref=19.23&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.23&show=diff)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.23 [errors.16:src/main/java/travelator/IRegisterCustomers.kt]](https://java-to-kotlin.dev/code.html?ref=19.23&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.23&show=diff)'
- en: By making `RegistrationProblem` a sealed class, we know at compile time what
    subclasses can exist and, hence, what errors have to be handled—very much like
    the checked exception signature of a method.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`RegistrationProblem`定义为密封类，我们在编译时知道哪些子类可能存在，因此知道必须处理的错误，这非常类似于方法的检查异常签名。
- en: 'We can use this `RegistrationProblem` when we follow the pattern from earlier,
    adding a default implementation of `registerToo` to the interface that returns
    `Result<Customer, RegistrationProblem>`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们遵循先前的模式时，我们可以在接口中添加`registerToo`的默认实现，并使用返回`Result<Customer, RegistrationProblem>`：
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[Example 19.24 [errors.16:src/main/java/travelator/IRegisterCustomers.kt]](https://java-to-kotlin.dev/code.html?ref=19.24&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.24&show=diff)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.24 [errors.16:src/main/java/travelator/IRegisterCustomers.kt]](https://java-to-kotlin.dev/code.html?ref=19.24&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.24&show=diff)'
- en: 'Now we can migrate callers of `register` to `registerToo`. We’ll start with
    `Customer​Regis⁠trationHandler`, converting it to Kotlin first:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将`register`的调用者迁移到`registerToo`。我们将从`Customer​Regis⁠trationHandler`开始，首先将其转换为
    Kotlin：
- en: '[PRE35]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[Example 19.25 [errors.17:src/main/java/travelator/handlers/CustomerRegistrationHandler.kt]](https://java-to-kotlin.dev/code.html?ref=19.25&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.25&show=diff)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.25 [errors.17:src/main/java/travelator/handlers/CustomerRegistrationHandler.kt]](https://java-to-kotlin.dev/code.html?ref=19.25&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.25&show=diff)'
- en: 'Now, as we did before, we swap to calling the new method (`registerToo`) instead
    of the old one (`register`) and interpret the return type with a `when` expression:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，就像之前一样，我们转而调用新方法（`registerToo`）而不是旧方法（`register`），并使用`when`表达式解释返回类型：
- en: '[PRE36]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[Example 19.26 [errors.18:src/main/java/travelator/handlers/CustomerRegistrationHandler.kt]](https://java-to-kotlin.dev/code.html?ref=19.26&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.26&show=diff)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.26 [errors.18:src/main/java/travelator/handlers/CustomerRegistrationHandler.kt]](https://java-to-kotlin.dev/code.html?ref=19.26&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.26&show=diff)'
- en: 'Finally, we can remove the unnecessary exception cases and simplify the error
    case with `map` and `recover`. `Result::recover` is a Result4k extension function
    that unwraps the result if it is `Success`, otherwise returning the result of
    mapping the failure’s `reason`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以删除不必要的异常情况，并使用`map`和`recover`简化错误情况。`Result::recover`是一个 Result4k 的扩展函数，如果是`Success`则解包结果，否则返回映射失败的`reason`的结果：
- en: '[PRE37]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[Example 19.27 [errors.19:src/main/java/travelator/handlers/CustomerRegistrationHandler.kt]](https://java-to-kotlin.dev/code.html?ref=19.27&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.27&show=diff)'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.27 [errors.19:src/main/java/travelator/handlers/CustomerRegistrationHandler.kt]](https://java-to-kotlin.dev/code.html?ref=19.27&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.27&show=diff)'
- en: 'Note that this code is still not exception-free. First, the `ObjectMapper`
    can still throw `JSONProcessingException`. That is the reality of Java (and frankly
    most Kotlin) APIs, but the code is safe and communicates well, because the throwing
    and catching are in the same method. Second, we still have to consider other `RuntimeException`s
    that could be thrown from anywhere: `NullPointerException` and so on. These could
    have crossed function boundaries and leaked up to here, where the buck stops at
    the top-level catch-all, which returns `HTTP_INTERNAL_ERROR`. The reality is that
    we can still have *unexpected* exceptions, but the *expected* failure cases are
    now expressed by `Results` and communicated in our code.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这段代码仍然不是无异常的。首先，`ObjectMapper`仍然可以抛出`JSONProcessingException`。这是Java（实际上大多数Kotlin）API的现实，但代码是安全的且表达清晰，因为抛出和捕获在同一个方法中。其次，我们仍然需要考虑可能从任何地方抛出的其他`RuntimeException`，例如`NullPointerException`等。这些异常可能已经跨越了函数边界并最终泄漏到这里，在这里的顶级全捕捉中返回`HTTP_INTERNAL_ERROR`。现实情况是，我们仍然可能会遇到*意外*的异常，但*预期的*失败情况现在由`Results`表示并在我们的代码中传达。
- en: More Fixup
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多修复
- en: We can now confess that the `RegistrationHandlerTests` got broken a few steps
    ago. Ordinarily we would have fixed them straightaway, but that would have interrupted
    our explanation.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以承认，`RegistrationHandlerTests`在几步之前就已经出问题了。通常我们会立即修复它们，但那样会打断我们的解释。
- en: 'The problem is that the tests are mock tests, which expect calls to `IRegister.register`,
    but we are now calling `registerToo`. For example:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于这些测试是模拟测试，期望调用`IRegister.register`，但我们现在却调用了`registerToo`。例如：
- en: '[PRE38]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[Example 19.28 [errors.20:src/test/java/travelator/handlers/CustomerRegistrationHandlerTests.java]](https://java-to-kotlin.dev/code.html?ref=19.28&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.28&show=diff)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.28 [errors.20:src/test/java/travelator/handlers/CustomerRegistrationHandlerTests.java]](https://java-to-kotlin.dev/code.html?ref=19.28&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.28&show=diff)'
- en: 'To fix the tests, we need to change the call from `register`, returning `Customer`
    or throwing, to `registerToo`, returning `Result<Customer, RegistrationProblem>`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复测试，我们需要将调用`register`改为调用`registerToo`，后者返回`Result<Customer, RegistrationProblem>`或抛出异常：
- en: '[PRE39]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[Example 19.29 [errors.21:src/test/java/travelator/handlers/CustomerRegistrationHandlerTests.java]](https://java-to-kotlin.dev/code.html?ref=19.29&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.29&show=diff)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.29 [errors.21:src/test/java/travelator/handlers/CustomerRegistrationHandlerTests.java]](https://java-to-kotlin.dev/code.html?ref=19.29&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.29&show=diff)'
- en: The tests are actually simplified, because instead of having to choose `thenReturn`
    or `thenThrow`, we are now always mocking with `thenReturn`, with `Success` or
    `Failure`, respectively.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的测试变得更简单了，因为我们不再需要选择`thenReturn`或`thenThrow`，而是总是使用`thenReturn`进行模拟，分别返回`Success`或`Failure`。
- en: 'Now that our tests are passing again, we can return to production code and
    implement `CustomerRegistration::registerToo` directly. In lieu of any cleverer
    idea, we do this by duplicating the `register` method and fettling the error handling.
    We do this using `Result::mapFailure` (part of Result4k) to convert `DuplicateException`
    to `Duplicate`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的测试再次通过了，我们可以返回到生产代码并直接实现`CustomerRegistration::registerToo`。如果没有更聪明的想法，我们可以通过复制`register`方法并调整错误处理来做到这一点。我们使用`Result::mapFailure`（Result4k的一部分）将`DuplicateException`转换为`Duplicate`：
- en: '[PRE40]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[Example 19.30 [errors.22:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.30&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.30&show=diff)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.30 [errors.22:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.30&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.30&show=diff)'
- en: '[![1](assets/1.png)](#co_introduction_CO44-1)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_introduction_CO44-1)'
- en: Note that we explicitly specify the type of the lambda parameter in `mapFailure`.
    As we will see later, this way if we change the return type of `add` to have a
    different failure type, the compiler will force us to change how we handle it.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在`mapFailure`中我们显式指定了lambda参数的类型。正如我们后面将看到的，这样做可以在我们将`add`的返回类型更改为不同的失败类型时，强制我们更改处理方式。
- en: 'There are two problems with this. First, `registerToo` has no test code, and
    second, we have the duplicate logic caused by our duplicating `register` to create
    `registerToo`. We can fix both by implementing `register` in terms of `registerToo`—the
    opposite of what we did in `Customers`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个问题。首先，`registerToo`没有测试代码；其次，我们由于复制`register`来创建`registerToo`而导致重复逻辑。我们可以通过将`register`实现为`registerToo`的调用来解决这两个问题，这与我们在`Customers`中所做的相反：
- en: '[PRE41]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[Example 19.31 [errors.23:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.31&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.31&show=diff)'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.31 [errors.23:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.31&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.31&show=diff)'
- en: '[![1](assets/1.png)](#co_introduction_CO45-1)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_introduction_CO45-1)'
- en: Delegate to `registerToo` and process `Error` type.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 委托给`registerToo`并处理`Error`类型。
- en: 'Now our `CustomerRegistrationTests`, which work in terms of `register`, will
    be testing `registerToo` for us:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的`CustomerRegistrationTests`，工作于`register`的调用者，将为我们测试`registerToo`：
- en: '[PRE42]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[Example 19.32 [errors.23:src/test/java/travelator/CustomerRegistrationTests.java]](https://java-to-kotlin.dev/code.html?ref=19.32&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.32&show=diff)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.32 [errors.23:src/test/java/travelator/CustomerRegistrationTests.java]](https://java-to-kotlin.dev/code.html?ref=19.32&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.32&show=diff)'
- en: 'This would be a good way to keep both `register` and `registerToo` while we
    migrate away from Java and exceptions to Kotlin and an error type. In this case,
    though, the tests are actually the last callers of `register`, so let’s convert
    them to call `registerToo`. We could take the time to show how to use Result4k
    in Java, but we’re all pretty tired of this example now, so we’ll convert the
    tests to Kotlin and then have them call `register` with the immortal words, “Here’s
    one I made earlier”:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们从Java迁移到Kotlin和错误类型时，保留`register`和`registerToo`是一个不错的方式。然而，在这种情况下，测试实际上是`register`的最后调用者，所以让我们将它们转换为调用`registerToo`。我们可以花时间展示如何在Java中使用Result4k，但我们对这个示例已经厌倦了，所以我们将把测试用例转换为Kotlin，然后让它们调用`register`，并说上一些不朽的话：“这是我之前制作的一个例子”：
- en: '[PRE43]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[Example 19.33 [errors.24:src/test/java/travelator/CustomerRegistrationTests.kt]](https://java-to-kotlin.dev/code.html?ref=19.33&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.33&show=diff)'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.33 [errors.24:src/test/java/travelator/CustomerRegistrationTests.kt]](https://java-to-kotlin.dev/code.html?ref=19.33&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.33&show=diff)'
- en: 'Now that we have no callers of `register`, we can finally remove it and rename
    `registerToo` to `register`, ending up with exception-free Kotlin:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们没有`register`的调用者了，我们终于可以删除它，并将`registerToo`重命名为`register`，最终得到无异常的Kotlin：
- en: '[PRE44]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[Example 19.34 [errors.25:src/main/java/travelator/IRegisterCustomers.kt]](https://java-to-kotlin.dev/code.html?ref=19.34&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.34&show=diff)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.34 [errors.25:src/main/java/travelator/IRegisterCustomers.kt]](https://java-to-kotlin.dev/code.html?ref=19.34&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.34&show=diff)'
- en: '[PRE45]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[Example 19.35 [errors.25:src/main/java/travelator/Customers.kt]](https://java-to-kotlin.dev/code.html?ref=19.35&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.35&show=diff)'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.35 [errors.25:src/main/java/travelator/Customers.kt]](https://java-to-kotlin.dev/code.html?ref=19.35&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.35&show=diff)'
- en: Hmm, not quite exception-free because of that `DuplicateException`. It is not
    actually *thrown* from anywhere anymore, just created and put into a `Failure`.
    We can fix this either by renaming the class to `DuplicateCustomerProblem` and
    stop it from extending `Exception`, or reuse the existing `Duplicate` subclass
    of `RegistrationProblem`. Which is better?
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，因为那个`DuplicateException`，并不完全是无异常的。它实际上不再从任何地方*抛出*，只是被创建并放入了一个`Failure`中。我们可以通过将类重命名为`DuplicateCustomerProblem`并停止它继承`Exception`来解决这个问题，或者重用`RegistrationProblem`的现有`Duplicate`子类。哪个更好呢？
- en: Layers
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 层次
- en: If we think in terms of layers, `Customers` is in a lower layer than `Registration`,
    which depends on it. So `Customers` should not depend on the higher-level `Registration​Pro⁠blem`.
    We could try to invert the dependency so that the `Duplicate` subclass of `RegistrationProblem`
    is a subtype (or even just the same type) of `DuplicateCustomer​Pro⁠blem` declared
    in the repository layer. That would work here, but is a bit of a dead-end if `Customers::add`
    ever needs to declare another way that it might fail. If, for example, we want
    to show in our result that database communications might fail, we can’t (well,
    shouldn’t) make that a subtype of `DuplicateCustomerProblem`. So we will be back
    to the problem of expressing more than one error type in a single result.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从层次角度来思考，`Customers`位于比`Registration`更低的层次，后者依赖于它。因此，`Customers`不应该依赖于更高级别的`RegistrationPro⁠blem`。我们可以尝试反转依赖关系，使`RegistrationProblem`的`Duplicate`子类成为在存储库层声明的`DuplicateCustomerPro⁠blem`的子类型（甚至仅是相同类型）。这在这里可以工作，但如果`Customers::add`需要声明另一种可能失败的方式，这可能是一个死胡同。例如，如果我们想在我们的结果中显示数据库通信可能会失败，我们不能（或者不应该）将其作为`DuplicateCustomerProblem`的子类型。因此，我们将再次面临在单个结果中表达多个错误类型的问题。
- en: 'Let’s chase that through. If `Customers::add` needs to declare more than one
    way that it can fail—our previous `DuplicateCustomerProblem` and our new `DatabaseCustomer​Pro⁠blem`—we
    introduce a sealed `CustomersProblem` as the error type and make the two known
    problems its only subclasses:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们跟踪一下。如果 `Customers::add` 需要声明不止一种可能失败的方式——我们之前的 `DuplicateCustomerProblem`
    和我们的新 `DatabaseCustomer​Pro⁠blem`——我们将引入一个封闭的 `CustomersProblem` 作为错误类型，并使这两个已知问题成为其唯一的子类：
- en: '[PRE46]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[Example 19.36 [errors.27:src/main/java/travelator/Customers.kt]](https://java-to-kotlin.dev/code.html?ref=19.36&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.36&show=diff)'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.36 [errors.27:src/main/java/travelator/Customers.kt]](https://java-to-kotlin.dev/code.html?ref=19.36&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=19.36&show=diff)'
- en: '`CustomerRegistration` was calling `Customers::add` and handling just `DuplicateCustomerProblem`
    in `mapFailure`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`CustomerRegistration` 调用 `Customers::add` 并仅处理 `mapFailure` 中的 `DuplicateCustomerProblem`
    ：'
- en: '[PRE47]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[Example 19.37 [errors.26:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.37&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.37&show=diff)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.37 [errors.26:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.37&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=19.37&show=diff)'
- en: 'This no longer compiles, because the type of the failure is now the `CustomersProblem`
    base class. You can see that we are getting the advantages of checked exceptions:
    code is communicating the ways in which it can fail and forcing us to deal with
    the cases.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这不再编译，因为失败的类型现在是 `CustomersProblem` 基类。您可以看到我们正在获得已检查异常的好处：代码正在传达它可以失败的方式，并强制我们处理这些情况。
- en: 'Now that `Customers::add` admits that it can fail in a new and interesting
    way, `register` is also forced to handle the truth. It decides to pass the knowledge
    on to its callers (well OK, we decide for it) by adding a new `DatabaseProblem`
    subtype of the existing `RegistrationProblem` sealed class:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `Customers::add` 承认它可能以一种新颖的方式失败，`register` 也被迫处理事实。它决定将这一知识传递给其调用者（好吧，我们替它决定），通过添加现有
    `RegistrationProblem` 封闭类的新 `DatabaseProblem` 子类型：
- en: '[PRE48]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[Example 19.38 [errors.27:src/main/java/travelator/IRegisterCustomers.kt]](https://java-to-kotlin.dev/code.html?ref=19.38&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.38&show=diff)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.38 [errors.27:src/main/java/travelator/IRegisterCustomers.kt]](https://java-to-kotlin.dev/code.html?ref=19.38&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=19.38&show=diff)'
- en: 'Now we can fix `register` by converting between the ways that `add` can fail
    (`DuplicateCustomerProblem` and `DatabaseCustomerProblem`) and the ways that `register`
    can fail (`Duplicate` and `DatabaseProblem`, respectively). This now makes the
    choice of `map​Fai⁠lure` clear:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过转换 `add` 可能失败的方式（`DuplicateCustomerProblem` 和 `DatabaseCustomerProblem`）以及
    `register` 可能失败的方式（分别是 `Duplicate` 和 `DatabaseProblem`）来修复 `register`。现在 `map​Fai⁠lure`
    的选择已经清晰：
- en: '[PRE49]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[Example 19.39 [errors.27:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.39&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.39&show=diff)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.39 [errors.27:src/main/java/travelator/CustomerRegistration.kt]](https://java-to-kotlin.dev/code.html?ref=19.39&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=19.39&show=diff)'
- en: 'Finally, because we’ve added to the `RegistrationProblem` sealed hierarchy,
    the compiler now forces us to consider the `DatabaseProblem` in the next layer
    up by failing to compile `CustomerRegistrationHandler`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，因为我们已经扩展了 `RegistrationProblem` 封闭层次结构，编译器现在通过编译 `CustomerRegistrationHandler`
    来强迫我们考虑 `DatabaseProblem` 在上一层中的影响。
- en: '[PRE50]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[Example 19.40 [errors.27:src/main/java/travelator/handlers/CustomerRegistrationHandler.kt]](https://java-to-kotlin.dev/code.html?ref=19.40&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=19.40&show=diff)'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19.40 [errors.27:src/main/java/travelator/handlers/CustomerRegistrationHandler.kt]](https://java-to-kotlin.dev/code.html?ref=19.40&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=19.40&show=diff)'
- en: '[![1](assets/1.png)](#co_introduction_CO46-1)'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_introduction_CO46-1)'
- en: We have to add a case for `DatabaseProblem` to get the `when` expression to
    compile.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须添加一个 `DatabaseProblem` 案例以使 `when` 表达式编译通过。
- en: Because the `CustomerRegistrationHandler` is the entry point for this interaction,
    our work is now done.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `CustomerRegistrationHandler` 是此交互的入口点，我们的工作现在已经完成。
- en: Moving On
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继续前进
- en: This has been a long chapter, but its length is in proportion to its importance.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很长的章节，但其长度与其重要性成比例。
- en: Your Java project may already have declared exception bankruptcy, with no systematic
    use of checked exceptions. In this case, Kotlin’s policy of treating everything
    as an unchecked exception will be fine.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 Java 项目可能已经宣告了异常破产，没有系统地使用已检查的异常。在这种情况下，Kotlin 将一切视为未检查异常的政策将是合适的。
- en: If you do lean on checked exceptions and want to translate to Kotlin, or want
    to raise your error handling game as part of the conversion, then using a result
    type is the best strategy. Where an operation can fail in multiple ways, we can
    use sealed classes to enumerate the failure modes, at the expense of not being
    able to propagate the same type through multiple layers. When we have multiple
    layers, things return to being tedious, but at least they are not very error prone.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你依赖于受检异常并希望转换为 Kotlin，或者希望在转换过程中提升错误处理能力，那么使用结果类型是最佳策略。当操作可能以多种方式失败时，我们可以使用密封类来列举失败模式，尽管这会导致不能在多个层次中传播相同类型。当我们有多个层次时，事情会变得繁琐，但至少不容易出错。
- en: We could (and maybe should) write a whole book on error handling, but in the
    meantime you can follow Duncan’s journey down the rabbit hole on [his blog](https://oreil.ly/kfvAn).
    As well as the material covered here, this shows how to reduce the number of functions
    that are subject to failure because they are [partial functions](https://oreil.ly/8RoO4).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们或许应该（*maybe should*）撰写一本完整的关于错误处理的书籍，但与此同时，你可以跟随邓肯在[他的博客](https://oreil.ly/kfvAn)中的探索之旅。除了这里涵盖的材料外，这还展示了如何减少因为它们是[部分函数](https://oreil.ly/8RoO4)而会失败的函数的数量。
- en: 'Reducing the number of our functions that can fail is important, because code
    that is subject to error is very similar to the actions that we saw in [Chapter 7,
    *Actions to Calculations*](ch07.html#actions-to-calculations). Actions pollute
    their callers: by default, code that calls an action becomes an action. In the
    same way, code that calls code that is subject to failure is itself subject to
    failure. We can mitigate the effects of both actions and errors by moving them
    as close as we can to the entry points to our system, so that they taint the least
    code.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 减少我们的函数可能失败的数量是很重要的，因为受错误影响的代码与我们在[第7章，“从操作到计算”](ch07.html#actions-to-calculations)中看到的行为非常相似。操作会污染它们的调用者：默认情况下，调用操作的代码本身也成为操作。同样，调用可能失败的代码的代码本身也可能失败。我们可以通过尽可能将它们移动到系统入口点附近来减少两者的影响，以便它们污染的代码最少。
- en: We touched briefly in this chapter on making our code robust to errors when
    they occur. Actions are a problem here too, because they affect the state of our
    system. State can be corrupted when two things need to be updated, and the first
    action writes, but the second doesn’t because an error happened before it was
    invoked. A rigorous focus on the difference between actions and calculations is
    the key to making robust software.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们简要提到了当错误发生时使我们的代码健壮的方法。操作在这里也是一个问题，因为它们会影响我们系统的状态。当两个事物需要更新时，第一个操作写入，但第二个操作由于在调用之前发生错误而没有执行时，状态可能会被损坏。严格区分操作和计算的差异是制作健壮软件的关键。
- en: We will return to error handling in [Chapter 21, *Exceptions to Values*](ch21.html#exceptions-to-values).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第21章，“从值到异常”](ch21.html#exceptions-to-values)中回顾错误处理。
