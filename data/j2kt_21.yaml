- en: Chapter 21\. Exceptions to Values
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第21章。从异常到值
- en: In [Chapter 19](ch19.html#throwing-to-returning) we looked at error-handling
    strategies for Kotlin, and how to refactor from exceptions in Java to more functional
    techniques. The truth is that most code ignores errors in the hope that they won’t
    happen. Can we do better?
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在[第19章](ch19.html#throwing-to-returning)中，我们讨论了Kotlin的错误处理策略，以及如何从Java中的异常重构为更功能化的技术。事实上，大多数代码都忽略了错误，希望它们不会发生。我们能做得更好吗？
- en: Someone new in marketing has taken to tweaking the spreadsheet that we last
    saw in [Chapter 20](ch20.html#performing-io-to-passing-data)—the one that generates
    the high-value customer scores. We don’t know what they are doing in detail, but
    they keep on exporting files that break our parsing and then asking us to explain
    what a stack trace is. It’s getting a bit embarrassing on both sides of the relationship,
    so the cake has begun to dry up. Could there be any more incentive?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 新加入市场营销团队的人员开始调整我们在[第20章](ch20.html#performing-io-to-passing-data)中最后看到的电子表格，这个表格用于生成高价值客户评分。我们不清楚他们具体在做什么，但他们不断导出破坏我们解析的文件，然后要求我们解释堆栈跟踪是什么。这在关系的两端都有些尴尬，所以情况开始变得尴尬。还能有更多的激励吗？
- en: Well yes, there could. We’ve also been asked to write an unattended job so that
    marketing can save the file onto a server, and *we* will automatically write the
    summarized version. Without a person in the loop to interpret those stack traces,
    it looks like we’ll have to find a way to report errors properly.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，是的，可能会有。我们还被要求编写一个无人参与的作业，以便市场可以将文件保存到服务器上，而*我们*将自动编写摘要版本。没有人在其中来解释那些堆栈跟踪，似乎我们必须找到一种适当报告错误的方法。
- en: Identifying What Can Go Wrong
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定可能出现问题的内容
- en: 'Here’s the code as we left it:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们离开时的代码：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[Example 21.1 [exceptions-to-values.0:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=21.1&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=21.1&show=diff)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 21.1 [exceptions-to-values.0:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=21.1&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=21.1&show=diff)'
- en: If we’re to do a thorough job of error handling, the first thing we have to
    do is establish what might go wrong. As we saw in [Chapter 19](ch19.html#throwing-to-returning),
    in Kotlin we don’t have checked exceptions to give us clues, but these were so
    badly used in most Java code that in this respect there isn’t much of a difference
    between the languages. Unless code has been written to communicate the ways that
    it can fail, we’ll have to rely on examination, intuition, and experience to work
    it out. In this case, experience tells us that the failures we actually get are
    due to missing fields, so we can concentrate there, but we should still do due
    diligence on all aspects of the code. Let’s work our way up the functions from
    the bottom of the listing, looking for potential errors.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要做好错误处理的彻底工作，首先要做的是确定可能出现的问题。正如我们在[第19章](ch19.html#throwing-to-returning)中所看到的，在Kotlin中，我们没有检查异常来提供线索，但是在大多数Java代码中，它们的使用非常糟糕，因此在这方面两种语言之间没有太大的区别。除非代码已经编写好来传达它可能失败的方式，否则我们将不得不依靠检查、直觉和经验来解决问题。在这种情况下，经验告诉我们，我们实际遇到的失败是由于缺少字段，因此我们可以集中精力解决这个问题，但我们仍然应该对代码的所有方面进行尽职调查。让我们从清单底部的函数开始逐步分析，寻找潜在的错误。
- en: '`CustomerData.marketingName` looks benign:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`CustomerData.marketingName`看起来是无害的：'
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[Example 21.2 [exceptions-to-values.0:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=21.2&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=21.2&show=diff)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 21.2 [exceptions-to-values.0:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=21.2&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=21.2&show=diff)'
- en: If `CustomerData` were implemented in Java, we might find `familyName` resolving
    to `null` and, hence, throwing when we try `toUpperCase()`, but in Kotlin it can’t,
    so it won’t. As with all code, the function is subject to subclasses of `Error`
    (such as `OutOfMemoryError`) being thrown, but it should be generally safe. From
    here on we’ll count throwing `Error` as extraordinary and not consider it in our
    analysis.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`CustomerData`是用Java实现的，我们可能会发现`familyName`解析为`null`，因此在尝试`toUpperCase()`时会抛出异常，但在Kotlin中不会这样，所以也不会发生。与所有代码一样，该函数可能会抛出`Error`的子类（如`OutOfMemoryError`），但通常是安全的。从现在开始，我们将不将抛出`Error`视为普通情况，因此不在我们的分析之内。
- en: 'Now `formattedAs`:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是`formattedAs`：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[Example 21.3 [exceptions-to-values.0:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=21.3&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=21.3&show=diff)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 21.3 [exceptions-to-values.0:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=21.3&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=21.3&show=diff)'
- en: '`String.format(format, this)` is implemented as `java.lang.String::format`,
    which is documented to throw `IllegalFormatException` if the `format` is not compatible
    with its other input. This is a [partial function](https://oreil.ly/ErpGo): one
    that only returns a result for some of the possible values of its parameters.
    In this case, it can return a result for all values of `Double`, but only when
    we use very specific values of `format`. Luckily, we are only feeding it one particular
    `format`, the value `%#.2f`, which we know works, so this and its only caller,
    `Double.toMoneyString()`, should not fail. If they do fail, it’s because our analysis
    is incorrect (or its assumptions are no longer true), and runtime errors are a
    reasonable way of signaling this programmer error.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`String.format(format, this)` 实现为 `java.lang.String::format`，如果 `format` 与其它输入不兼容，文档中说明会抛出
    `IllegalFormatException`。这是一个[偏函数](https://oreil.ly/ErpGo)：只针对某些参数值返回结果。在这种情况下，它可以为所有
    `Double` 的值返回结果，但只有在我们使用非常特定的 `format` 值时才能。幸运的是，我们只是传递了一个特定的 `format`，即值 `%#.2f`，我们知道它是有效的，所以这个函数及其唯一的调用者
    `Double.toMoneyString()` 不应该失败。如果它们失败了，那是因为我们的分析有误（或其假设已不再成立），运行时错误是一种合理的方式来表明程序员的错误。'
- en: 'Next we have:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们有：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[Example 21.4 [exceptions-to-values.0:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=21.4&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=21.4&show=diff)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 21.4 [exceptions-to-values.0:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=21.4&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=21.4&show=diff)'
- en: This only calls code that we have just reasoned shouldn’t fail, so by the transitive
    property of failure, it should also be safe.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这只调用我们刚刚推断不应该失败的代码，因此按失败的传递性原则，它也应该是安全的。
- en: Note this has been easy so far because these functions are all calculations
    ([“Calculations”](ch07.html#calculations)). They don’t depend on any external
    state, so we can reason about them just by looking at them.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，到目前为止都很简单，因为这些函数都是计算函数（[“Calculations”](ch07.html#calculations)）。它们不依赖于任何外部状态，所以我们可以通过查看它们来推理。
- en: 'So far so good, now `String.toCustomerData()`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切顺利，现在是 `String.toCustomerData()`：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[Example 21.5 [exceptions-to-values.0:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=21.5&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=21.5&show=diff)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 21.5 [exceptions-to-values.0:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=21.5&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=21.5&show=diff)'
- en: 'OK, this is another partial function: almost no values of the `String` receiver
    will lead to this function being able to return a result. Luckily, almost all
    the ones that we are getting in practice are OK, which is why error handling is
    only now becoming a priority. What could go wrong though?'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这又是一个偏函数：几乎没有 `String` 接收者的值会导致该函数能够返回结果。幸运的是，实践中我们获取的几乎所有值都是可以接受的，这就是为什么错误处理现在才成为优先事项的原因。但是，可能出现什么问题呢？
- en: Starting from the top of the function, `String.split` may behave oddly if we
    pass it an empty delimiter, but we aren’t. Then we may not have enough parts,
    so that `parts[n]` throws `IndexOutOfBoundsException`. Finally, `parts[3]` may
    not represent an `Int`, or `parts[4]` may not represent a `Double`, both of which
    will throw `NumberFormatException`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 从函数顶部开始，如果我们传递空分隔符给`String.split`，它可能会表现得很奇怪，但我们并没有。接着，可能会出现部分不足的情况，这样`parts[n]`会抛出`IndexOutOfBoundsException`。最后，`parts[3]`可能不表示一个`Int`，或者`parts[4]`可能不表示一个`Double`，这两种情况都会抛出`NumberFormatException`。
- en: 'Having established that `toCustomerData` can fail if passed a `String` that
    doesn’t meet our format specification, what should we do about it? At the moment,
    all the ways that it can fail result in an exception being thrown, the program
    being aborted with an unfriendly error message, and marketing calling us over.
    Which leads to two follow-on questions: “Should we abort?” and “How can we improve
    the error message so that marketing can interpret it?”'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 已经确定 `toCustomerData` 如果传入不符合我们格式规范的 `String` 可能会失败，那我们该怎么办呢？目前，所有可能导致失败的方式都会抛出异常，程序会以不友好的错误消息中止，并且会有市场部门找我们。这引出了两个后续问题：“我们应该中止吗？”以及“如何改进错误消息以便市场部门理解？”
- en: 'As we saw in [Chapter 19](ch19.html#throwing-to-returning), we shouldn’t use
    exceptions to abort on predictable errors. The lack of checked exceptions in Kotlin
    (and their lack of use in Java) means that if we do, we lose the opportunity to
    communicate that the code is susceptible to failure. The callers of our code then
    have to do what we are currently doing: reason with every line of code in an implementation.
    Even after then, the implementation might change, silently invalidating the findings.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 [第 19 章](ch19.html#throwing-to-returning) 中看到的，我们不应该使用异常来中止可预测的错误。 Kotlin
    中的未检查异常的缺失（以及在 Java 中的不使用）意味着如果我们这样做，我们失去了表明代码容易失败的机会。然后，我们代码的调用者必须像我们目前正在做的那样：推理出实现中的每一行代码。即使在那之后，实现可能会发生变化，默默地使结果无效。
- en: 'If we aren’t to throw an exception, then the cheapest change (provided our
    callers are all Kotlin) is to return `null` when we fail. Client code will then
    be forced to consider the `null` case and act accordingly. For example:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不打算抛出异常，那么最便宜的更改（只要我们的调用方都是 Kotlin）就是在失败时返回 `null`。客户端代码将被迫考虑 `null` 情况并相应地采取行动。例如：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[Example 21.6 [exceptions-to-values.1:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=21.6&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=21.6&show=diff)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[示   [示例 21.6 [exceptions-to-values.1:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=21.6&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=21.6&show=diff)'
- en: We could have chosen to simply wrap the whole implementation in a `try` block
    and return `null` from the `catch`, but here we have been more proactive than
    reactive. This means that the code will still throw if the relevant fields cannot
    be converted to `Int` or `Double`. We’ll get to that.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以选择简单地将整个实现包装在 `try` 块中，并从 `catch` 中返回 `null`，但在这里，我们比反应更主动。这意味着如果相关字段无法转换为
    `Int` 或 `Double`，代码仍将抛出异常。我们会解决这个问题。
- en: 'This change breaks `toHighValueCustomerReport`, which is now forced to consider
    the possibility of failure:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变化破坏了 `toHighValueCustomerReport`，现在必须考虑失败的可能性：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[Example 21.7 [exceptions-to-values.1:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=21.7&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=21.7&show=diff)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 21.7 [exceptions-to-values.1:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=21.7&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=21.7&show=diff)'
- en: '[![1](assets/1.png)](#co_introduction_CO47-1)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_introduction_CO47-1)'
- en: Doesn’t compile because `it` is nullable.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `it` 是可空的，所以无法编译。
- en: 'Now if we want to just ignore badly formed input lines, we can get everything
    running again with `filterNotNull`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们只想忽略格式错误的输入行，我们可以使用 `filterNotNull` 让一切重新运行：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[Example 21.8 [exceptions-to-values.2:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=21.8&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=21.8&show=diff)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 21.8 [exceptions-to-values.2:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=21.8&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=21.8&show=diff)'
- en: 'We don’t have any tests to support this, and we really should write some, but
    for now we’ll proceed without a safety net because this is an exploratory spike
    solution. From here, we can use `null` to represent the other ways that we know
    `toCustomerData` can fail:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有任何测试来支持这一点，而且我们真的应该写一些测试，但是现在我们将继续进行，因为这是一种探索性的尝试性解决方案。从这里开始，我们可以使用 `null`
    来表示我们知道 `toCustomerData` 可以失败的其他方式：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[Example 21.9 [exceptions-to-values.3:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=21.9&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=21.9&show=diff)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 21.9 [exceptions-to-values.3:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=21.9&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=21.9&show=diff)'
- en: Note that the Kotlin standard library has helped us out by providing `String::toSomethingOrNull`
    functions with just this error-handling convention. Now that this code represents
    all reasonable errors with `null`, we can go back to `toHighValueCustomer​Re⁠port`
    and work out what to do with them instead of pretending that they haven’t happened
    (pronounced `filterNotNull`).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Kotlin 标准库通过提供 `String::toSomethingOrNull` 函数来帮助我们处理此错误处理约定。现在，由回到 `toHighValueCustomer​Re⁠port`
    并想想如何处理它们，而不是假装它们没有发生（读作 `filterNotNull`）。
- en: 'We could abort on the first error, but it seems worth the extra effort to collect
    all the problem lines and report them somehow. *Somehow* is a bit vague, but funnily
    enough it has a type: `(String) -> Unit` in this case. Which is to say, we can
    delegate the what-to-do to a function that accepts the errant line and doesn’t
    affect the result. We allude to this technique in [“Error Handling Before Exceptions”](ch19.html#errors-invoking-a-function).
    To illustrate this, let’s add a test:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在第一个错误上中止，但值得额外努力收集所有的问题行并以某种方式报告它们。*某种方式*有点模糊，但有趣的是它有一个类型：在这种情况下是`(String)
    -> Unit`。也就是说，我们可以将该做什么委托给一个接受错误行并且不影响结果的函数。我们在[“异常之前的错误处理”](ch19.html#errors-invoking-a-function)中提到了这种技术。为了说明这一点，让我们添加一个测试：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[Example 21.10 [exceptions-to-values.4:src/test/java/travelator/marketing/HighValueCustomersReportTests.kt]](https://java-to-kotlin.dev/code.html?ref=21.10&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=21.10&show=diff)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 21.10 [exceptions-to-values.4:src/test/java/travelator/marketing/HighValueCustomersReportTests.kt]](https://java-to-kotlin.dev/code.html?ref=21.10&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=21.10&show=diff)'
- en: '[![1](assets/1.png)](#co_introduction_CO48-1)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_introduction_CO48-1)'
- en: This lambda implements `onErrorLine` in the next sample.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个lambda在下一个示例中实现了`onErrorLine`。
- en: 'Let’s implement that with the simplest thing that could possibly work:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用可能能够正常工作的最简单的方法来实现它：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[Example 21.11 [exceptions-to-values.4:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=21.11&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=21.11&show=diff)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 21.11 [exceptions-to-values.4:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=21.11&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=21.11&show=diff)'
- en: 'This is still filtering out error lines, but only after passing them off to
    `onErrorLine`, which can decide what to do. In `main`, we’ll use it to print errors
    to `System.err` and then abort:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然在过滤出错误行，但只有在将它们传递给`onErrorLine`后才会这样做，它可以决定要执行什么操作。在`main`中，我们将使用它将错误打印到`System.err`，然后中止：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[Example 21.12 [exceptions-to-values.4:src/main/java/travelator/marketing/HighValueCustomersMain.kt]](https://java-to-kotlin.dev/code.html?ref=21.12&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=21.12&show=diff)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 21.12 [exceptions-to-values.4:src/main/java/travelator/marketing/HighValueCustomersMain.kt]](https://java-to-kotlin.dev/code.html?ref=21.12&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=21.12&show=diff)'
- en: This is one of the few places in this book where we have fallen back on a mutable
    `List`. Why here? For example, we could have changed `toHighValueCustomerReport`
    to return `Pair<Sequence<String>, List<String>>`, where the second of the pairs
    is the errors. The main advantage of this scheme is that it allows the caller
    to abort early by throwing an exception in `onErrorLine`. For maximum flexibility,
    we could even have an error-handling strategy with signature `(String) -> CustomerData?`
    so that the caller could supply a substitute, allowing recovery from errors in
    any particular line.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本书中我们仅有的几处借助可变`List`的地方之一。为什么在这里？例如，我们可以将`toHighValueCustomerReport`更改为返回`Pair<Sequence<String>,
    List<String>>`，其中第二个元素是错误。这种方案的主要优点是它允许调用者通过在`onErrorLine`中抛出异常来尽早中止。为了最大灵活性，我们甚至可以有一个具有签名`(String)
    -> CustomerData?`的错误处理策略，以便调用者可以提供替代方法，从而允许从任何特定行的错误中恢复。
- en: In [Chapter 20](ch20.html#performing-io-to-passing-data), we went out of our
    way to convert `toHighValueCustomerReport` from an action to a calculation. We
    then relaxed the purity a little by reading and writing from and to a `Sequence`.
    Here we have introduced an error-handling function returning `Unit`, a sure sign
    that we have introduced an action. Provided that action’s scope is confined to
    error handling, and any side effects are, as in this `main`, restricted to local
    variables, this is another reasonable compromise. This is an expedient error-handling
    solution that is flexible and communicates well, but pure it isn’t.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第20章](ch20.html#performing-io-to-passing-data)中，我们费了一番功夫将`toHighValueCustomerReport`从一个操作转换为一个计算。然后，我们通过从`Sequence`读取和写入来放松了纯度，但在这里，我们引入了一个返回`Unit`的错误处理函数，这是我们引入了一个操作的明确迹象。只要该操作的范围限定在错误处理中，并且任何副作用都像在这个`main`中一样，限制在局部变量中，这是另一个合理的折衷方案。这是一种灵活且表达清晰的应急错误处理解决方案，但并非纯粹。
- en: Representing Errors
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表示错误
- en: Now that we are communicating *that* our parsing can fail (by returning a nullable
    type), and *where* it has failed (with a callback passing the line), can we better
    communicate *why* it has failed?
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在传达*我们的解析可能失败*（通过返回可空类型），以及*它在哪里失败*（通过回调传递行），我们是否可以更好地传达*为什么*它失败了？
- en: 'Returning a result type rather than a nullable type allows us to specify what
    failure modes there are and provide details when they happen. Let’s change `String.to​Custo⁠merData()`
    to return a `Result` rather than nullable:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 返回结果类型而不是可空类型允许我们指定存在哪些失败模式并在发生时提供详细信息。让我们将`String.to​Custo⁠merData()`更改为返回`Result`而不是可空：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[Example 21.13 [exceptions-to-values.5:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=21.13&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=21.13&show=diff)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 21.13 [exceptions-to-values.5:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=21.13&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=21.13&show=diff)'
- en: 'As we did in [Chapter 19](ch19.html#throwing-to-returning), we create a sealed
    class to represent why parsing failed:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第19章](ch19.html#throwing-to-returning)中所做的那样，我们创建一个密封类来表示解析失败的原因：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[Example 21.14 [exceptions-to-values.5:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=21.14&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=21.14&show=diff)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 21.14 [exceptions-to-values.5:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=21.14&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=21.14&show=diff)'
- en: 'To be honest, this is overkill in this situation (a single data class carrying
    the failing line and a string reason would do here), but we are exemplifying excellence
    in error engineering. We can fix up the callers of `toCustomerData` by invoking
    `onErrorLine` with the data held in the `ParseFailure` and then yielding `null`
    when we have an `Error`. This passes the current tests:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 说实话，在这种情况下（一个单一的数据类携带失败的行和一个字符串原因就足够了），这有些过度，但我们正在举例展示错误工程的卓越性。我们可以通过调用`toCustomerData`的调用者并在`ParseFailure`中保持的数据上调用`onErrorLine`，然后在出现`Error`时产生`null`来修复`toCustomerData`的调用者。这样可以通过当前的测试：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[Example 21.15 [exceptions-to-values.5:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=21.15&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=21.15&show=diff)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 21.15 [exceptions-to-values.5:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=21.15&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=21.15&show=diff)'
- en: 'What we really want, though, is to expose the `ParseFailure`. Let’s change
    the test first to collect the `ParseFailure`s instead of lines with errors:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们真正想要的是暴露`ParseFailure`。让我们首先更改测试以收集`ParseFailure`而不是带有错误行的行：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[Example 21.16 [exceptions-to-values.6:src/test/java/travelator/marketing/HighValueCustomersReportTests.kt]](https://java-to-kotlin.dev/code.html?ref=21.16&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=21.16&show=diff)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 21.16 [exceptions-to-values.6:src/test/java/travelator/marketing/HighValueCustomersReportTests.kt]](https://java-to-kotlin.dev/code.html?ref=21.16&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=21.16&show=diff)'
- en: 'Now we can change `onErrorLine` to take the failure:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以更改`onErrorLine`以接受失败：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[Example 21.17 [exceptions-to-values.6:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=21.17&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=21.17&show=diff)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 21.17 [exceptions-to-values.6:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=21.17&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=21.17&show=diff)'
- en: 'This lets `main` report the reason and the line:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这样`main`就可以报告原因和行：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[Example 21.18 [exceptions-to-values.6:src/main/java/travelator/marketing/HighValueCustomersMain.kt]](https://java-to-kotlin.dev/code.html?ref=21.18&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=21.18&show=diff)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 21.18 [exceptions-to-values.6:src/main/java/travelator/marketing/HighValueCustomersMain.kt]](https://java-to-kotlin.dev/code.html?ref=21.18&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=21.18&show=diff)'
- en: We might not have used the runtime type of the `ParseFailure` to process errors
    differently, but we have used its name in the error message, so we are at least
    getting some value from our little sealed class hierarchy. If the resulting error
    messages aren’t enough to allow marketing to fix their input, then we can use
    a `when` expression on the sealed class to differentiate between the types of
    failure, as we saw in [“Layers”](ch19.html#error-layers).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能没有使用`ParseFailure`的运行时类型来处理不同的错误，但我们已经在错误消息中使用了其名称，因此至少我们从我们的小密封类层次结构中获得了一些价值。如果生成的错误消息不足以让营销部门修复其输入，那么我们可以在密封类上使用`when`表达式来区分不同类型的失败，就像我们在[“层次”](ch19.html#error-layers)中看到的那样。
- en: At this point, everything is compiling and our tests pass, so all is good in
    this little part of the world at least. Had we had more client code calling this
    API, or our changes were to ripple through more layers of code, we might have
    picked a more sophisticated refactoring strategy than changing code in one file
    and fixing the broken things. Often, though, it isn’t worth the effort when we
    can get the code compiling and passing the tests in a couple of minutes at most.
    If we do find out that we have bitten off more than we can chew, it’s easy to
    revert and take a more considered approach.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，一切都在编译并且我们的测试通过，所以至少在这个小世界中一切都很好。如果我们有更多客户端代码调用此API，或者我们的更改需要通过更多代码层级传播，我们可能会选择比在一个文件中更改代码并修复错误更复杂的重构策略。然而，通常情况下，当我们能够在最多几分钟内使代码编译并通过测试时，这种努力是不值得的。如果我们发现我们的野心超过了我们的承受能力，那么回退并采取更加考虑周到的方法是很容易的。
- en: 'Now that the tests are passing, we should go back and make sure everything
    is as tidy and expressive as it can be. In particular, we did the quickest thing
    we could to get everything to work again in `toHighValueCustomerReport`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在测试通过了，我们应该回头确保一切都尽可能整洁和表达力强。特别是，在`toHighValueCustomerReport`中，我们做的是为了让一切重新工作而采取的最快的方法：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[Example 21.19 [exceptions-to-values.6:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=21.19&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=21.19&show=diff)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 21.19 [exceptions-to-values.6:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=21.19&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=21.19&show=diff)'
- en: There’s something about yielding `null` from the `recover` block and then skipping
    these with `filterNotNull` that is a little unsatisfactory. It doesn’t communicate
    how it works directly, and gets in the way of the happy path. We would like to
    be able to find a nicer formulation of the `valuableCustomers` expression, but
    the truth is that everything else is a bit worse in your authors’ eyes. If you
    do find a nice simple way, then please let us know.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 从`recover`块中产生`null`然后用`filterNotNull`跳过这些东西有点不令人满意。它不能直接传达它的工作方式，并且妨碍了愉快的路径。我们希望能找到一个更好的`valuableCustomers`表达式的表达方式，但事实上，在你们的作者看来，其他一切都有点更糟。如果您找到一个简单而好的方法，请告诉我们。
- en: 'Similarly, the early returns in `toCustomerData` look a bit ugly:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`toCustomerData`中的提前返回看起来有点丑陋：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[Example 21.20 [exceptions-to-values.6:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=21.20&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=21.20&show=diff)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 21.20 [exceptions-to-values.6:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=21.20&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=21.20&show=diff)'
- en: '“Proper” functional error handling would not return early, but use a `flatMap`
    chain. Readers of a nervous disposition may wish to look away:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: “适当”的功能性错误处理不会提前返回，而是使用`flatMap`链。易于紧张的读者可能希望离开：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[Example 21.21 [exceptions-to-values.7:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=21.21&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=21.21&show=diff)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 21.21 [exceptions-to-values.7:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=21.21&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=21.21&show=diff)'
- en: Your authors like a single expression even more than most people, but not if
    this is the `Result` (pun intended). We could obviously simplify here by introducing
    more functions (`asResultOr ... flatMap` looks like it is a concept trying to
    get out, for example). Some other result libraries would let us abuse coroutines
    or exceptions to get the same effect as the previous early returns, but without
    better language support to avoid the indent-per-statement, the grain of Kotlin
    favors early returns in these cases. We haven’t addressed it specifically in this
    book, but the fact that lambdas can be compiled inline and so support returns
    from their enclosing function encourages us to use imperative code in situations
    like this. For us then, the early returns will do.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你们的作者甚至比大多数人更喜欢单一表达式，但如果这是`Result`（故意的双关语），那就不行了。在这里，我们显然可以通过引入更多函数来简化（例如，`asResultOr
    ... flatMap`看起来就像是一个试图获得的概念）。其他一些结果库可以让我们滥用协程或异常来达到与之前提前返回相同的效果，但是没有更好的语言支持来避免每个语句都需要缩进，Kotlin的语法更青睐于在这些情况下提前返回。虽然我们在本书中没有专门讨论过这一点，但Lambda可以被内联编译，因此支持从其包围函数返回的事实鼓励我们在这种情况下使用命令式代码。因此，对我们来说，提前返回是可以接受的。
- en: 'Finally, returning to `main` on our final check before check-in:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们最后检查之前返回`main`：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[Example 21.22 [exceptions-to-values.6:src/main/java/travelator/marketing/HighValueCustomersMain.kt]](https://java-to-kotlin.dev/code.html?ref=21.22&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=21.22&show=diff)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[例子 21.22 [exceptions-to-values.6:src/main/java/travelator/marketing/HighValueCustomersMain.kt]](https://java-to-kotlin.dev/code.html?ref=21.22&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=21.22&show=diff)'
- en: 'Those three levels of nested `use` obfuscate the actual structure, and that
    `exitProcess` from deep in the bowels of the function is also a bit iffy. We can
    define our own `using` overload to address the former and pass out an exit code
    to solve the latter (an example of using data rather than control flow to address
    errors). We can extract an extension function to print the errors too:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这三层嵌套的`use`使实际结构变得模糊，而函数深处的`exitProcess`也有些靠不住。我们可以定义自己的`using`重载来解决前者，并传递一个退出码来解决后者（这是使用数据而不是控制流来处理错误的示例）。我们还可以提取一个扩展函数来打印错误：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[Example 21.23 [exceptions-to-values.8:src/main/java/travelator/marketing/HighValueCustomersMain.kt]](https://java-to-kotlin.dev/code.html?ref=21.23&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=21.23&show=diff)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[例子 21.23 [exceptions-to-values.8:src/main/java/travelator/marketing/HighValueCustomersMain.kt]](https://java-to-kotlin.dev/code.html?ref=21.23&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=21.23&show=diff)'
- en: What About I/O?
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: I/O 怎么样？
- en: That’s very nearly good enough. Before we go, though, we should think about
    I/O errors. Since we introduced `List`s and then `Sequence`s, our report generation
    code does not have to worry about writing failing, because it is the calling code’s
    responsibility to iterate over the result lines and actually perform the write.
    The `main` function in this case makes the reasonable assumption that `System.out`
    will always be there, but when we implement the unattended job that motivated
    this refactor, we will have to deal with the possibility that the file or network
    socket may disappear even if it was open when we started.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 那几乎是足够好的了。然而，在我们离开之前，我们应该考虑一下I/O错误。由于我们引入了`List`然后是`Sequence`，我们的报告生成代码不必担心写入失败，因为迭代结果行并实际执行写入是调用代码的责任。在这种情况下的`main`函数合理地假设`System.out`总是存在，但当我们实现激发此重构的无人看管作业时，我们将不得不处理文件或网络套接字即使在我们开始时它们是打开的也可能消失的可能性。
- en: There is a similar situation reading. We are now iterating over each `String`
    in a `Sequence`. In the test code, these are in memory, but in production they
    are being fetched from a file (via `System.in`). So our `Sequence` operations
    are subject to failure with `IOExceptions` that the report generation is blissfully
    unaware of.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 读取时也存在类似的情况。我们现在正在迭代`Sequence`中的每个`String`。在测试代码中，这些都在内存中，但在生产中，它们是从文件（通过`System.in`）中获取的。因此，我们的`Sequence`操作可能会因为报告生成不知情的`IOExceptions`而失败。
- en: 'There is little that `toHighValueCustomerReport()` can or should do in these
    cases. There is no practical way of recovering from I/O errors once we have started
    reading here—aborting the whole operation is the sensible thing to do. Helpfully,
    now the onus is entirely on the caller (in this case `main`). `toHighValueCustomerReport`
    signals the errors that it knows about (failure to parse) and how they are represented
    (subclasses of `ParseFailure`) through its `onErrorLine` parameter. `IOException`s
    are not its responsibility. It is `main` that is passing an I/O-backed `Sequence`
    into `toHighValueCustomerReport`, so `main` should be aware that `toHighValueCustomerReport`
    can therefore fail with an `IOException` and deal with it accordingly. Let’s add
    that code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，`toHighValueCustomerReport()`很少能或应该做什么。一旦我们开始在这里读取，就没有实际的恢复I/O错误的方法——中止整个操作是明智的选择。幸运的是，现在责任完全落在调用者（在这种情况下是`main`）身上。`toHighValueCustomerReport`通过其`onErrorLine`参数信号化它知道的错误（解析失败）及其表示方式（`ParseFailure`的子类）。`IOException`不是它的责任。正是`main`将I/O支持的`Sequence`传入`toHighValueCustomerReport`，因此`main`应该意识到`toHighValueCustomerReport`可能因此失败并相应地处理。让我们添加那段代码：
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[Example 21.24 [exceptions-to-values.9:src/main/java/travelator/marketing/HighValueCustomersMain.kt]](https://java-to-kotlin.dev/code.html?ref=21.24&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=21.24&show=diff)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[例子 21.24 [exceptions-to-values.9:src/main/java/travelator/marketing/HighValueCustomersMain.kt]](https://java-to-kotlin.dev/code.html?ref=21.24&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=21.24&show=diff)'
- en: This is perhaps overkill for this application, but it shows the pattern of catching
    and dealing with the exceptions that we *expect* (printing a relatively friendly
    message for `IOException`) but allowing all others to leak and quit the application.
    If we follow the strategy from [Chapter 19](ch19.html#throwing-to-returning),
    *unexpected* exceptions are either unrecoverable environment errors or programmer
    errors. In both cases, the default JVM behavior of quitting the process after
    printing a stack trace gives us a fighting chance of diagnosing the issue. When
    we convert this to an unattended server job, we will similarly process expected
    errors in our top-level handler function. We might abort on `IOException` or retry
    the whole interaction if we think the problem may be transient. We know that retrying
    won’t help with parse errors, so we will have to log these and/or send notifications
    somewhere. Unexpected errors in handler functions are normally allowed to leak
    to generic exception-handling code, which will log them and send an internal server
    error status before returning the thread to its pool.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个应用来说可能有点过头了，但它展示了捕获和处理我们*期望*的异常模式（例如为`IOException`打印一个相对友好的消息），但允许其他所有异常泄露并退出应用程序。如果我们遵循第[19章](ch19.html#throwing-to-returning)的策略，*意外*的异常要么是不可恢复的环境错误，要么是程序员错误。在这两种情况下，默认的JVM行为是在打印堆栈跟踪后退出进程，这样我们有一定的机会诊断问题。当我们将其转换为无人看管的服务器作业时，我们将类似地处理顶层处理程序函数中的预期错误。我们可能会在`IOException`上中止或重新尝试整个交互，如果认为问题可能是暂时性的。我们知道重新尝试对解析错误无济于事，因此我们必须记录这些错误和/或将通知发送到某个地方。处理程序函数中的意外错误通常允许泄漏到通用异常处理代码，该代码将记录它们并在返回线程到其池之前发送内部服务器错误状态。
- en: Moving On
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继续前进
- en: Very often in engineering, we have to make compromises. In particular, attempts
    to make one thing simpler often complicate another. I/O complicates our software
    in two ways. It is an action, so we can’t just ignore whether or when it happens
    as we refactor; and it is subject to errors, which we have to deal with if we
    want a robust system. These errors may be simple environmental failures to read
    or write, or because the things that we are reading don’t meet our expectations—when
    the marketing file ends badly formatted, for example.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在工程中，我们经常不得不做出妥协。特别是，试图简化一件事往往会使另一件事复杂化。I/O以两种方式使我们的软件复杂化。它是一种行为，因此我们不能简单地忽视它何时发生或重构时发生；它也容易出现错误，如果我们想要一个强大的系统，就必须处理这些错误。这些错误可能是简单的环境故障导致无法读取或写入，或者是因为我们正在读取的内容不符合我们的预期——例如，当营销文件以不良格式结尾时。
- en: 'Both actions and errors taint their callers, and the solution in both cases
    is the same: move the code closer to the entry points so that it taints less of
    our system. This, then, is an area where, rather than having to compromise, we
    can kill two birds with one stone. By moving I/O to the outside of our systems,
    we can reduce the ways that both actions and errors complicate our code.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 行为和错误都会影响调用者，而解决方法在两种情况下是一样的：将代码移近入口点，以减少系统的污染。因此，在这个领域，我们无需做出妥协，却可以一举解决两个问题。通过将I/O操作移到系统外部，我们可以减少行为和错误增加代码复杂性的方式。
