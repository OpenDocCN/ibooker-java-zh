- en: Chapter 4\. The Java Type System
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 Java类型系统
- en: In this chapter, we move beyond basic object-oriented programming with classes
    and into the additional concepts required to work effectively with Java’s type
    system.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们超越了基本的面向对象编程与类，进入了有效使用Java类型系统所需的其他概念。
- en: Note
  id: totrans-2
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A *statically typed* language is one in which variables have definite types,
    and where it is a compile-time error to assign a value of an incompatible type
    to a variable. Languages that only check type compatibility at runtime are called
    *dynamically typed*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*静态类型*语言是指变量具有明确的类型，并且将不兼容类型的值分配给变量是编译时错误的语言。仅在运行时检查类型兼容性的语言称为*动态类型*语言。'
- en: Java is a fairly classic example of a statically typed language. JavaScript
    is an example of a dynamically typed language that allows any variable to store
    any type of value.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Java是一个典型的静态类型语言的例子。JavaScript则是一个动态类型语言的例子，允许任何变量存储任何类型的值。
- en: The Java type system involves not only classes and primitive types but also
    other kinds of reference type that are related to the basic concept of a class,
    but which differ in some way and are usually treated in a special way by `javac`
    or the JVM.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Java类型系统不仅涉及类和基本类型，还包括与类的基本概念相关的其他种类的引用类型，但它们在某些方面有所不同，并且通常由`javac`或JVM特殊处理。
- en: We have already met arrays and classes, two of Java’s most widely used kinds
    of reference type. This chapter starts by discussing another very important kind
    of reference type—*interfaces*. We then move on to discuss Java’s *generics*,
    which have a major role to play in Java’s type system. With these topics under
    our belts, we can discuss the differences between compile-time and runtime types
    in Java.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经见过数组和类，Java最广泛使用的两种引用类型之一。本章开始讨论另一种非常重要的引用类型——*接口*。然后我们进入讨论Java的*泛型*，它在Java类型系统中扮演重要角色。掌握了这些主题后，我们可以讨论Java中编译时和运行时类型的差异。
- en: To complete the full picture of Java’s reference types, we look at specialized
    kinds of classes and interfaces—known as *enums* and *annotations*. We conclude
    the chapter by looking at *lambda expressions* and *nested types* and then reviewing
    how enhanced type inference has allowed Java’s *nondenotable types* to become
    usable by programmers.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整展示Java参考类型的全貌，我们看看特殊类型的类和接口——被称为*枚举*和*注解*。我们在这一章节结束时讨论*lambda表达式*和*嵌套类型*，然后回顾增强类型推断如何使Java的*非显式类型*可供程序员使用。
- en: Let’s get started by taking a look at interfaces—probably the most important
    of Java’s reference types after classes and a key building block for the rest
    of Java’s type system.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始看一下接口——除了类之外Java最重要的参考类型之一，也是Java类型系统其余部分的关键构建块。
- en: Interfaces
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口
- en: In [Chapter 3](ch03.xhtml#javanut8-CHP-3), we met the idea of inheritance. We
    also saw that a Java class can inherit only from a single class. This is quite
    a big restriction on the kinds of object-oriented programs that we want to build.
    The designers of Java knew this, but they also wanted to ensure that Java’s approach
    to object-oriented programming was less complex and error-prone than, for example,
    that of C++.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第三章](ch03.xhtml#javanut8-CHP-3)中，我们介绍了继承的概念。我们也看到Java类只能继承自一个类。这对我们想要构建的面向对象程序类型是一个相当大的限制。Java的设计者们知道这一点，但他们也希望确保Java的面向对象编程方法比如C++更简单且不易出错。
- en: The solution that they chose was to introduce the concept of an interface to
    Java. Like a class, an *interface* defines a new reference type. As its name implies,
    an interface is intended to represent only an API—so it provides a description
    of a type and the methods (and signatures) that classes that *implement* that
    API must provide.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 他们选择的解决方案是引入接口的概念到Java中。像类一样，*接口*定义了一个新的引用类型。顾名思义，接口旨在表示API——因此它提供了一个类型的描述以及实现该API的类必须提供的方法（及其签名）的描述。
- en: In general, a Java interface does not provide any implementation code for the
    methods that it describes. These methods are considered *mandatory*—any class
    that wishes to implement the interface must provide an implementation of these
    methods.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，Java接口不提供描述的方法的任何实现代码。这些方法被认为是*强制性的*——希望实现接口的任何类必须提供这些方法的实现。
- en: However, an interface may wish to mark that some API methods are optional and
    that implementing classes do not need to implement them if they choose not to.
    This is done with the `default` keyword—and the interface must provide an implementation
    of these optional methods, which will be used by any implementing class that elects
    not to implement them.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，接口可能希望标记一些API方法是可选的，如果选择不实现它们，则实现类不需要实现它们。这是通过`default`关键字完成的，并且接口必须提供这些可选方法的实现，这将被任何选择不实现它们的实现类使用。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The ability to have optional methods in interfaces was new in Java 8. It is
    not available in any earlier version. See [“Records and Interfaces”](#javanut8-CHP-4-SECT-1.5)
    for a full description of how optional (also called default) methods work.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 8中引入了接口中可选方法的能力。在任何早期版本中都不可用。请参阅[“记录和接口”](#javanut8-CHP-4-SECT-1.5)以获取有关可选（也称为默认）方法如何工作的完整描述。
- en: It is not possible to directly instantiate an interface and create a member
    of the interface type. Instead, a class must *implement* the interface to provide
    the necessary method bodies.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 不可能直接实例化一个接口并创建一个接口类型的成员。相反，类必须*实现*接口以提供必要的方法体。
- en: Any instances of the implementing class are *compatible with* both the type
    defined by the class and the type defined by the interface. This means that the
    instances may be substituted at any point in the code that requires an instance
    of either the class type or the interface type. This extends the Liskov principle
    as seen in [“Reference Type Conversions”](ch03.xhtml#javanut8-CHP-3-SECT-6.1).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 实现类的任何实例都*与*类定义的类型和接口定义的类型兼容。这意味着实例可以在需要类类型或接口类型的任何代码中替换。这扩展了Liskov原则，如在[“引用类型转换”](ch03.xhtml#javanut8-CHP-3-SECT-6.1)中所见。
- en: Another way of saying this is that two objects that do not share the same class
    or superclass may still both be compatible with the same interface type if both
    objects are instances of classes that implement the interface.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种说法是，如果两个对象不共享相同的类或超类，它们仍然可以与相同接口类型兼容，如果两个对象都是实现接口的类的实例的话。
- en: Defining an Interface
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义接口
- en: 'An interface definition is somewhat like a class definition in which all the
    (mandatory) methods are abstract and the keyword `class` has been replaced with
    `interface`. For example, this code shows the definition of an interface named
    `Centered` (a `Shape` class, such as those defined in [Chapter 3](ch03.xhtml#javanut8-CHP-3),
    might implement this interface if it wants to allow the coordinates of its center
    to be set and queried):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 接口定义有些类似于类定义，其中所有（必需的）方法都是抽象的，关键字`class`已被替换为`interface`。例如，以下代码显示了名为`Centered`的接口的定义（例如，一个`Shape`类，比如在[第三章](ch03.xhtml#javanut8-CHP-3)中定义的那些，如果想要允许其中心坐标被设置和查询，则可能实现该接口）：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A number of restrictions apply to the members of an interface:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对接口成员施加了一些限制：
- en: All mandatory methods of an interface are implicitly `abstract` and must have
    a semicolon in place of a method body. The `abstract` modifier is allowed but
    by convention is usually omitted.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有接口的强制方法都是隐式`abstract`的，必须用分号代替方法体。`abstract`修饰符是允许的，但按照惯例通常省略。
- en: An interface defines a public API. By convention, members of an interface are
    implicitly `public`, and it is conventional to omit the unnecessary `public` modifier.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口定义了一个公共API。按照惯例，接口成员隐式地是`public`的，并且通常省略不必要的`public`修饰符。
- en: An interface may not define any instance fields. Fields are an implementation
    detail, and an interface is a specification, not an implementation. The only fields
    allowed in an interface definition are constants that are declared both `static`
    and `final`.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个接口不能定义任何实例字段。字段是一个实现细节，而接口是一个规范，不是一个实现。在接口定义中唯一允许的字段是声明为`static`和`final`的常量。
- en: An interface cannot be instantiated, so it does not define a constructor.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个接口不能被实例化，因此它不定义构造函数。
- en: Interfaces may contain nested types. Any such types are implicitly `public`
    and `static`. See [“Nested Types”](#javanut8-CHP-4-SECT-5) for a full description
    of nested types.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口可以包含嵌套类型。任何此类类型都隐式地是`public`和`static`的。请参阅[“嵌套类型”](#javanut8-CHP-4-SECT-5)以获取嵌套类型的完整描述。
- en: As of Java 8, an interface may contain static methods. Previous versions of
    Java did not allow this, which is widely believed to have been a flaw in the design
    of the Java language.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自Java 8起，接口可以包含静态方法。Java的早期版本不允许这样做，这被广泛认为是Java语言设计上的一个缺陷。
- en: As of Java 9, an interface may contain `private` methods. These have limited
    use cases, but with the other changes to the interface construct, it seems arbitrary
    to disallow them.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Java 9开始，接口可以包含`private`方法。这些方法的使用案例有限，但是随着接口结构的其他变化，禁止它们似乎是随意的。
- en: It is a compile-time error to try to define a `protected` method in an interface.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在接口中尝试定义`protected`方法是编译时错误。
- en: Extending Interfaces
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展接口
- en: 'Interfaces may extend other interfaces, and, like a class definition, an interface
    definition indicates this by including an `extends` clause. When one interface
    extends another, it inherits all the methods and constants of its superinterface
    and can define new methods and constants. Unlike classes, however, the `extends`
    clause of an interface definition may include more than one superinterface. For
    example, here are some interfaces that extend other interfaces:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接口可以扩展其他接口，并且与类定义类似，接口定义通过包含一个`extends`子句来指示这一点。当一个接口扩展另一个接口时，它继承其超接口的所有方法和常量，并且可以定义新的方法和常量。然而，不同于类，接口定义的`extends`子句可以包含多个超接口。例如，以下是一些扩展其他接口的接口：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: An interface that extends more than one interface inherits all the methods and
    constants from each of those interfaces and can define its own additional methods
    and constants. A class that implements such an interface must implement the abstract
    methods defined directly by the interface, as well as all the abstract methods
    inherited from all the superinterfaces.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个接口扩展了多个接口，则继承每个接口的所有方法和常量，并且可以定义自己的额外方法和常量。实现这种接口的类必须实现直接由接口定义的抽象方法，以及从所有超接口继承的所有抽象方法。
- en: Implementing an Interface
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现一个接口
- en: Just as a class uses `extends` to specify its superclass, it can use `implements`
    to name one or more interfaces it supports. The `implements` keyword can appear
    in a class declaration following the `extends` clause. It should be followed by
    a comma-separated list of interfaces that the class implements.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 就像类使用`extends`指定其超类一样，它可以使用`implements`来命名一个或多个它支持的接口。`implements`关键字可以出现在类声明中，在`extends`子句之后。它应该跟随一个逗号分隔的接口列表，该类实现这些接口。
- en: When a class declares an interface in its `implements` clause, it is saying
    that it provides an implementation (i.e., a body) for each mandatory method of
    that interface. If a class implements an interface but does not provide an implementation
    for every mandatory interface method, it inherits those unimplemented `abstract`
    methods from the interface and must itself be declared `abstract`. If a class
    implements more than one interface, it must implement every mandatory method of
    each interface it implements (or be declared `abstract`).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类在其`implements`子句中声明一个接口时，它表明它为该接口的每个强制方法提供了一个实现（即一个主体）。如果一个类实现了一个接口但没有为每个强制接口方法提供实现，它会从接口继承这些未实现的`abstract`方法，并且必须自己声明为`abstract`。如果一个类实现了多个接口，则必须实现每个接口的每个强制方法（或声明为`abstract`）。
- en: 'The following code shows how to define a `CenteredRectangle` class that extends
    the `Rectangle` class from [Chapter 3](ch03.xhtml#javanut8-CHP-3) and implements
    our `Centered` interface:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了如何定义一个`CenteredRectangle`类，它扩展了[第3章](ch03.xhtml#javanut8-CHP-3)中的`Rectangle`类，并实现我们的`Centered`接口：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Suppose we implement `CenteredCircle` and `CenteredSquare` just as we have
    implemented this `CenteredRectangle` class. Each class extends `Shape`, so instances
    of the classes can be treated as instances of the `Shape` class, as we saw earlier.
    Because each class implements the `Centered` interface, instances can also be
    treated as instances of that type. The following code demonstrates how objects
    can be members of both a class type and an interface type:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们实现了`CenteredCircle`和`CenteredSquare`，就像我们实现了这个`CenteredRectangle`类一样。每个类都扩展了`Shape`，所以类的实例可以被视为`Shape`类的实例，正如我们之前看到的那样。因为每个类实现了`Centered`接口，实例也可以被视为该类型的实例。以下代码演示了对象如何可以是类类型和接口类型的成员：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-42
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Interfaces are data types in Java, just like classes. When a class implements
    an interface, instances of that class can be assigned to variables of the interface
    type.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接口是Java中的数据类型，就像类一样。当一个类实现一个接口时，该类的实例可以赋值给接口类型的变量。
- en: Don’t interpret this example to imply that you must assign a `CenteredRectangle`
    object to a `Centered` variable before you can invoke the `setCenter()` method
    or to a `Shape` variable before invoking the `area()` method. Instead, because
    the `CenteredRectangle` class defines `setCenter()` and inherits `area()` from
    its `Rectangle` superclass, you can always invoke these methods.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 不要解释此示例为必须将`CenteredRectangle`对象分配给`Centered`变量，然后才能调用`setCenter()`方法或者分配给`Shape`变量然后再调用`area()`方法。相反，因为`CenteredRectangle`类定义了`setCenter()`方法并从其`Rectangle`超类继承了`area()`方法，所以你总是可以调用这些方法。
- en: As we could see by examining the bytecode (e.g., by using the `javap` tool we
    will meet in [Chapter 13](ch13.xhtml#javanut8-CHP-13)), the JVM calls the `setCenter()`
    method slightly differently depending on whether the local variable holding the
    shape is of the type `CenteredRectangle` or `Centered`, but this is not a distinction
    that matters most of the time when you’re writing Java code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们可以通过查看字节码（例如，使用`javap`工具我们将在[第13章](ch13.xhtml#javanut8-CHP-13)遇到）所见，JVM根据持有形状的局部变量类型是`CenteredRectangle`还是`Centered`而稍有不同地调用`setCenter()`方法，但这在大多数情况下在编写Java代码时并不重要。
- en: Records and Interfaces
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录和接口
- en: Records, being a special case of classes, can implement interfaces, just like
    any other class. The body of the record must contain implementation code for all
    of the mandatory methods of the interface, and it may contain overriding implementations
    for any of the default methods of the interface.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 记录（records）作为类的一种特例，可以像任何其他类一样实现接口。记录的主体必须包含接口所有强制方法的实现代码，并且可以包含接口任意默认方法的覆盖实现。
- en: 'Let’s look at an example as applied to the `Point` record we met in the last
    chapter. Given an interface defined like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，应用于我们在上一章中遇到的`Point`记录。给定一个定义如下的接口：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'then we can update the `Point` type like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们可以像这样更新`Point`类型：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that because records are immutable, it is not possible to mutate instances
    in-place and so, if we need a modified object, we have to create one and return
    it explicitly. This implies that not every interface will be suitable for implementation
    by a record type.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，因为记录是不可变的，所以不可能在原地修改实例，因此，如果我们需要一个修改过的对象，我们必须显式地创建一个并返回它。这意味着并非每个接口都适合由记录类型实现。
- en: Sealed Interfaces
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 密封接口
- en: 'We met the `sealed` keyword in the last chapter, as applied to classes. It
    can also be applied to interfaces, like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章中遇到了`sealed`关键字，应用于类。它也可以应用于接口，如下所示：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This sealed interface represents the capability for a shape to be rotated by
    90 degrees. Note that the declaration also contains a `permits` clause that specifies
    the only classes that are allowed to implement this interface—in this case just
    the `Circle` and `Rectangle` for simplicity. The `Circle` is modified like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个密封接口表示一个形状可以旋转90度的能力。注意声明中还包含一个`permits`子句，指定允许实现这个接口的唯一类——在这种情况下，只有`Circle`和`Rectangle`类，以简化问题。`Circle`被修改如下：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'whereas the `Rectangle` has been modified like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 而`Rectangle`已被修改如下：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As it stands, we don’t want to deal with the complexity of allowing other shapes
    to have rotational behavior, so we restrict the interface so that it can only
    be implemented by the two simplest cases: circles and rectangles.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 目前为止，我们不希望处理其他形状具有旋转行为的复杂性，因此我们限制接口只能由两种最简单的情况实现：圆和矩形。
- en: There is also an interesting interplay between sealed interfaces and records,
    which we will discuss in [Chapter 5](ch05.xhtml#javanut8-CHP-5).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 密封接口与记录之间还有一个有趣的互动，我们将在[第5章](ch05.xhtml#javanut8-CHP-5)讨论。
- en: Default Methods
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认方法
- en: From Java 8 onward, it is possible to declare methods in interfaces that include
    an implementation. In this section, we’ll discuss these methods, which should
    be understood as optional methods in the API the interfaces represent—they’re
    usually called *default methods*. Let’s start by looking at the reasons why we
    need the default mechanism in the first place.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 从Java 8开始，可以在接口中声明包含实现的方法。在本节中，我们将讨论这些方法，应该将它们理解为接口所代表的API中的可选方法——通常称为*默认方法*。让我们首先看看为什么我们需要首先的默认机制。
- en: Backward compatibility
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向后兼容性
- en: The Java platform has always been very concerned with backward compatibility.
    This means that code that was written (or even compiled) for an earlier version
    of the platform must continue to work with later releases of the platform. This
    principle allows development groups to have a high degree of confidence that an
    upgrade of their JDK or Java Runtime Environment (JRE) will not break currently
    working applications.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Java平台一直非常关注向后兼容性。这意味着为早期版本的平台编写（甚至编译）的代码必须继续在后续版本的平台上运行。这一原则使得开发团队对其JDK或Java运行时环境（JRE）的升级具有高度信心，不会破坏当前正常运行的应用程序。
- en: Backward compatibility is a great strength of the Java platform, but in order
    to achieve it, some constraints are placed on the platform. One of them is that
    interfaces may not have new mandatory methods added to them in a new release of
    the interface.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 向后兼容性是Java平台的一大优势，但为了实现它，平台对其施加了一些限制。其中之一是接口不能在新版本中添加新的强制性方法。
- en: 'For example, let’s suppose that we want to update the `Positionable` interface
    with the ability to add a bottom-left bounding point as well:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想要更新`Positionable`接口以添加底部左下角边界点的能力：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With this new definition, if we try to use this new interface with code developed
    for the old, it just won’t work, as the existing code is missing the mandatory
    methods `setLowerLeftCorner()`, `getLowerLeftX()`, and `getLowerLeftY()`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个新的定义，如果我们试图将这个新接口与为旧接口开发的代码一起使用，那就不会起作用，因为现有代码缺少强制性方法`setLowerLeftCorner()`、`getLowerLeftX()`和`getLowerLeftY()`。
- en: Note
  id: totrans-70
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You can see this effect quite easily in your own code. Compile a class file
    that depends on an interface. Then add a new mandatory method to the interface
    and try to run the program with the new version of the interface, together with
    your old class file. You should see the program crash with a `NoClassDefError`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以很容易地在自己的代码中看到这种效果。编译一个依赖于接口的类文件。然后向接口添加一个新的强制性方法，并尝试使用新版本的接口与旧类文件一起运行程序。您应该会看到程序因为`NoClassDefError`而崩溃。
- en: This limitation was a concern for the designers of Java 8—as one of their goals
    was to be able to upgrade the core Java Collections libraries and introduce methods
    that used lambda expressions.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个限制是Java 8设计者的一个关注点——因为他们的目标之一是能够升级核心Java集合库并引入使用lambda表达式的方法。
- en: To solve this problem, a new mechanism was needed, essentially to allow interfaces
    to evolve by allowing new methods to be added without breaking backward compatibility.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这个问题，需要一个新的机制，基本上允许接口通过添加新方法来演变，而不会破坏向后兼容性。
- en: Implementation of default methods
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现默认方法
- en: Adding new methods to an interface without breaking backward compatibility requires
    providing some implementation for the older implementations of the interface so
    that they can continue to work. This mechanism is a `default` method, and it was
    first added to the platform in JDK 8.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在不破坏向后兼容性的情况下向接口添加新方法，需要为接口的旧实现提供一些实现，以便它们可以继续工作。这个机制就是`default`方法，在JDK 8中首次添加到平台中。
- en: Note
  id: totrans-76
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A default method (sometimes called an optional method) can be added to any interface.
    This must include an implementation, called the *default implementation*, which
    is written inline in the interface definition.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 可以向任何接口添加默认方法（有时称为可选方法）。这必须包括一个内联的实现，称为*默认实现*，它写在接口定义中。
- en: 'The basic behavior of a default method is:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 默认方法的基本行为是：
- en: An implementing class may (but is not required to) implement the default method.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现类可以（但不需要）实现默认方法。
- en: If an implementing class implements the default method, then the implementation
    in the class is used.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果实现类实现了默认方法，则使用类中的实现。
- en: If no other implementation can be found, then the default implementation is
    used.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果找不到其他实现，则使用默认实现。
- en: 'An example default method is the `sort()` method. It’s been added to the interface
    `java.util.List` in JDK 8, and is defined as:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子是`sort()`方法。它已经在JDK 8中被添加到接口`java.util.List`中，并且定义如下：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Thus, from Java 8 upward, any object that implements `List` has an instance
    method `sort()` that can be used to sort the list using a suitable `Comparator`.
    As the return type is `void`, we might expect that this is an in-place sort, and
    this is indeed the case.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，从Java 8开始，任何实现`List`的对象都有一个`sort()`实例方法，可用于使用适当的`Comparator`对列表进行排序。由于返回类型是`void`，我们可能期望这是一种原地排序，事实也是如此。
- en: One consequence of default methods is that when implementing multiple interfaces,
    it’s possible that two or more interfaces may contain a default method with a
    completely identical name and signature.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 默认方法的一个结果是，在实现多个接口时，可能有两个或更多接口包含具有完全相同名称和签名的默认方法。
- en: 'For example:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: These two interfaces have very different default semantics for `call()` and
    could cause a potential implementation clash—a *colliding default method*. In
    versions of Java prior to 8, this could not occur, as the language permitted only
    single inheritance of implementation. The introduction of default methods means
    that Java now permits a limited form of *multiple inheritance* (but only of method
    implementations). Java still does not permit (and has no plans to add) multiple
    inheritance of object state.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个接口对`call()`的默认语义有很大的不同，并且可能导致潜在的实现冲突——*冲突的默认方法*。在Java 8之前的版本中，这种情况是不可能发生的，因为语言只允许单一实现继承。引入默认方法意味着Java现在允许一种有限的*多继承*形式（但仅限于方法实现）。Java仍然不允许（也没有计划添加）对象状态的多重继承。
- en: Tip
  id: totrans-89
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: In some other languages, notably C++, this problem is known as *diamond inheritance*.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些其他语言中，特别是C++，这个问题被称为*菱形继承*。
- en: 'Default methods have a simple set of rules to help resolve any potential ambiguities:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 默认方法有一组简单的规则，以帮助解决任何潜在的歧义：
- en: If a class implements multiple interfaces in such a way as to cause a potential
    clash of default method implementations, the implementing class must override
    the clashing method and provide a definition of what is to be done.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个类以导致默认方法实现潜在冲突的方式实现了多个接口，则实现类必须重写冲突方法并提供所需的定义。
- en: 'Syntax is provided to allow the implementing class to simply call one of the
    interface default methods if that is what is required:'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供了语法，允许实现类简单地调用接口的默认方法之一，如果需要的话：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As a side effect of the design of default methods, there is a slight, unavoidable
    usage issue that may arise in the case of evolving interfaces with colliding methods.
    Consider the case where a bytecode version 51.0 (Java 7) class implements two
    interfaces `A` and `B` with version numbers `a.0` and `b.0`, respectively. As
    defaults are not available in Java 7, this class will work correctly. However,
    if at a later time either or both interfaces adopt a default implementation of
    a colliding method, then compile-time breakage can occur.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于默认方法的设计，存在一个轻微但无法避免的使用问题，可能在演化中的接口出现方法冲突时出现。考虑一个字节码版本为51.0（Java 7）的类实现了两个接口`A`和`B`，它们的版本号分别为`a.0`和`b.0`。由于Java
    7中没有默认方法，这个类将正常工作。然而，如果稍后其中一个或两个接口采用了冲突方法的默认实现，则可能会发生编译时断裂。
- en: 'For example, if version `a.1` introduces a default method in `A`, then the
    implementing class will pick up the implementation when run with the new version
    of the dependency. If version `b.1` now introduces the same method, it causes
    a collision:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果版本`a.1`在`A`中引入了一个默认方法，那么当使用新版本的依赖运行时，实现类将采用这个实现。如果版本`b.1`现在也引入了相同的方法，就会造成冲突：
- en: If `B` introduces the method as a mandatory (i.e., abstract) method, then the
    implementing class continues to work—both at compile time and at runtime.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`B`将方法引入为强制性的（即抽象的）方法，则实现类将继续工作——无论是在编译时还是在运行时。
- en: If `B` introduces the method as a default method, then this is not safe and
    the implementing class will fail both at compile and at runtime.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`B`将方法引入为默认方法，则这是不安全的，实现类将在编译时和运行时均失败。
- en: This minor issue is very much a corner case and in practice is a very small
    price to pay in order to have usable default methods in the language.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小问题很大程度上是一个边界情况，在实践中支付的代价很小，以便在语言中拥有可用的默认方法。
- en: 'When working with default methods, we should be aware that there is a slightly
    restricted set of operations we can perform from within a default method:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用默认方法时，我们应该意识到我们可以在默认方法内部执行的操作集合有一定的限制：
- en: Call another method present in the interface’s public API (whether mandatory
    or optional); some implementation for such methods is guaranteed to be available.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用接口公共API中的另一个方法（无论是强制性还是可选的）；此类方法的某些实现是可用的。
- en: Call a private method on the interface (Java 9 and up).
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在接口上调用私有方法（Java 9及以上）。
- en: Call a static method, whether on the interface or defined elsewhere.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用静态方法，无论是在接口上还是在其他地方定义的。
- en: Use the `this` reference (e.g., as an argument to method calls).
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`this`引用（例如，作为方法调用的参数）。
- en: The biggest takeaway from these restrictions is that even with default methods,
    Java interfaces still lack meaningful state; we cannot alter or store state within
    the interface.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这些限制的最大教训是，即使有了默认方法，Java 接口仍然缺乏有意义的状态；我们不能在接口内部修改或存储状态。
- en: Default methods have had a profound impact on the way that Java practitioners
    approach object-oriented programming. When combined with the rise of lambda expressions,
    they have upended many previous conventions of Java coding; we will discuss this
    in detail in the next chapter.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 默认方法对 Java 实践者处理面向对象编程的方式产生了深远影响。与 lambda 表达式的兴起相结合，它们颠覆了许多以前的 Java 编码约定；我们将在下一章中详细讨论这一点。
- en: Marker Interfaces
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标记接口
- en: Occasionally it is useful to define an interface that is entirely empty. A class
    can implement this interface simply by naming it in its `implements` clause without
    having to implement any methods. In this case, any instances of the class become
    valid instances of the interface as well and can be cast to the type. Java code
    can check whether an object is an instance of the interface using the `instanceof`
    operator, so this technique is a useful way to provide additional information
    about an object. It can be thought of as providing additional, auxiliary type
    information about a class.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候定义一个完全空的接口是很有用的。一个类可以通过在其 `implements` 子句中简单地命名该接口来实现它，而无需实现任何方法。在这种情况下，该类的任何实例也将成为该接口的有效实例，并且可以将其强制类型转换为该类型。Java
    代码可以使用 `instanceof` 运算符检查对象是否是接口的实例，因此这种技术是提供关于对象的附加信息的有用方式。它可以被看作是为类提供额外的辅助类型信息。
- en: Tip
  id: totrans-109
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Marker interfaces are much less widely used than they once were. Java’s *annotations*
    (which we shall meet presently) have largely replaced them due to their much greater
    flexibility at conveying extended type information.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 标记接口的使用远不如以前广泛。由于注解（我们将很快见到）在传递扩展类型信息时具有更大的灵活性，它们已经大多取代了标记接口。
- en: 'The interface `java.util.RandomAccess` is an example of a marker interface:
    `java.util.List` implementations use this interface to advertise that they provide
    fast random access to the elements of the list. For example, `ArrayList` implements
    `RandomAccess`, while `LinkedList` does not. Algorithms that care about the performance
    of random-access operations can test for `RandomAccess` like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接口 `java.util.RandomAccess` 就是一个标记接口的示例：`java.util.List` 实现使用这个接口来表明它们提供对列表元素的快速随机访问。例如，`ArrayList`
    实现了 `RandomAccess`，而 `LinkedList` 则没有。关心随机访问操作性能的算法可以像这样测试 `RandomAccess`：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As we will see later, Java’s type system is very tightly coupled to the names
    that types have—an approach called *nominal typing*. A marker interface is a great
    example of this: it has nothing at all *except* a name.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们稍后将看到的，Java 的类型系统与类型名称紧密耦合，这被称为 *命名类型* 的方法。标记接口就是一个很好的例子：除了名称外，它什么都没有。
- en: Java Generics
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 泛型
- en: One of the great strengths of the Java platform is the standard library it ships.
    It provides a great deal of useful functionality—and in particular robust implementations
    of common data structures. These implementations are relatively simple to develop
    with and are well documented. The libraries are known as the Java Collections,
    and we will spend a big chunk of [Chapter 8](ch08.xhtml#javanut8-CHP-8) discussing
    them. For a far more complete treatment, see the book [*Java Generics and Collections*](http://shop.oreilly.com/product/9780596527754.do)
    by Maurice Naftalin and Philip Wadler (O’Reilly).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Java 平台的一个显著优势是其提供的标准库。它提供了大量有用的功能，特别是常见数据结构的健壮实现。这些实现相对简单易用，并且有很好的文档支持。这些库被称为
    Java 集合框架，我们将在 [第 8 章](ch08.xhtml#javanut8-CHP-8) 中详细讨论它们。如需更全面的信息，请参阅 Maurice
    Naftalin 和 Philip Wadler 的书 [*Java Generics and Collections*](http://shop.oreilly.com/product/9780596527754.do)（O’Reilly）。
- en: 'Although they were still very useful, the earliest versions of the collections
    had a fairly major limitation: the data structure (sometimes called the *container*)
    essentially obscured the type of the data being stored in it.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管最早期的集合版本仍然非常有用，但它们存在一个相当重要的限制：数据结构（有时称为 *容器*）基本上会隐藏在其中存储的数据类型。
- en: Note
  id: totrans-117
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Data hiding and encapsulation is a great principle of object-oriented programming,
    but in this case, the opaque nature of the container caused a lot of problems
    for the developer.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 数据隐藏和封装是面向对象编程的重要原则，但在这种情况下，容器的不透明性给开发者带来了许多问题。
- en: Let’s kick off the section by demonstrating the problem and showing how the
    introduction of *generic types* solved it and made life much easier for Java developers.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过展示问题并展示*泛型类型*的引入是如何解决它并使Java开发人员的生活变得更加轻松的。
- en: Introduction to Generics
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型介绍
- en: 'If we want to build a collection of `Shape` instances, we can use a `List`
    to hold them, like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要构建一个`Shape`实例的集合，我们可以使用`List`来持有它们，就像这样：
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: A problem with this code stems from the requirement to perform a cast to get
    the shape objects back out in a usable form—the `List` doesn’t know what type
    of objects it contains. Not only that, but it’s actually possible to put different
    types of objects into the same container, and everything will work fine until
    an illegal cast is used and the program crashes.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的一个问题源于需要执行强制类型转换以获得可用形式的形状对象——`List`不知道它包含的对象类型。不仅如此，而且实际上可以将不同类型的对象放入同一个容器中，一切工作正常，直到使用非法强制转换并导致程序崩溃。
- en: What we really want is a form of `List` that understands what type it contains.
    Then, `javac` could detect when an illegal argument was passed to the methods
    of `List` and cause a compilation error, rather than deferring the issue to runtime.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真正想要的是一种形式的`List`，它能理解它包含的类型。然后，`javac`可以在将非法参数传递给`List`的方法时检测到并导致编译错误，而不是推迟到运行时处理。
- en: Note
  id: totrans-125
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Collections that have all elements of the same type are called *homogeneous*,
    while the collections that can have elements of potentially different types are
    called *heterogeneous* (sometimes called “mystery meat collections”).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 所有元素类型相同的集合称为*同类*，而可能包含不同类型元素的集合称为*异类*（有时称为“神秘肉集合”）。
- en: 'Java provides a simple syntax to cater to homogeneous collections. To indicate
    that a type is a container that holds instances of another reference type, we
    enclose the *payload* type that the container holds within angle brackets:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Java提供了一个简单的语法来适应同类集合。要指示一个类型是一个容器，它持有另一个引用类型的实例，我们将容器持有的*有效载荷*类型括在尖括号内：
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This syntax ensures that a large class of unsafe code is caught by the compiler,
    before it gets anywhere near runtime. This is, of course, the whole point of static
    type systems—to use compile-time knowledge to help eliminate runtime problems
    wherever possible.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法确保了编译器在运行时之前能够捕获大类不安全的代码。这当然是静态类型系统的整体目标——利用编译时的知识尽可能地帮助消除运行时问题。
- en: 'The resulting types, which combine an enclosing container type and a payload
    type, are usually called *generic types*, and they are declared like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 结果类型结合了一个封装的容器类型和一个有效载荷类型，通常称为*泛型类型*，并且它们声明如下：
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This indicates that the `Box` interface is a general construct, which can hold
    any type of payload. It isn’t really a complete interface by itself—it’s more
    like a general description of a whole family of interfaces, one for each type
    that can be used in place of `T`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明`Box`接口是一个通用的构造，可以容纳任何类型的有效载荷。它本身并不是一个完整的接口——它更像是一个整个接口家族的通用描述，每个接口都可以用`T`的类型替代。
- en: Generic Types and Type Parameters
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型类型和类型参数
- en: We’ve seen how to use a generic type to provide enhanced program safety by using
    compile-time knowledge to prevent simple type errors. In this section, let’s dig
    deeper into the properties of generic types.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何使用泛型类型通过利用编译时知识来提供增强的程序安全性，以防止简单的类型错误。在这一节中，让我们更深入地探讨泛型类型的属性。
- en: The syntax `<T>` has a special name, *type parameter*, and another name for
    a generic type is a *parameterized type*. This should convey the sense that the
    container type (e.g., `List`) is parameterized by another type (the payload type).
    When we write a type like `Map<String, Integer>`, we are assigning concrete values
    to the type parameters.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`<T>`这种语法有一个特殊的名称，*类型参数*，另一个泛型类型的名称是*参数化类型*。这应该传达出容器类型（例如，`List`）由另一种类型（有效载荷类型）参数化的意义。当我们写一个类型像`Map<String,
    Integer>`时，我们正在为类型参数指定具体的值。'
- en: When we define a type that has parameters, we need to do so in a way that does
    not make assumptions about the type parameters. So the `List` type is declared
    in a generic way as `List<E>`, and the type parameter `E` is used all the way
    through to stand as a placeholder for the actual type that programmers will use
    for the payload when they use the `List` data structure.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义具有参数的类型时，需要以不假设类型参数的方式进行。因此，`List` 类型以泛型方式声明为 `List<E>`，而类型参数 `E` 在整个过程中都作为占位符，用于当程序员使用
    `List` 数据结构时使用的实际类型的载荷。
- en: Tip
  id: totrans-137
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Type parameters always stand in for reference types. It is not possible to use
    a primitive type as a value for a type parameter.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 类型参数总是代表引用类型。不可能使用原始类型作为类型参数的值。
- en: 'The type parameter can be used in the signatures and bodies of methods as though
    it is a real type, for example:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 类型参数可以像真实类型一样在方法的签名和主体中使用，例如：
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note how the type parameter `E` can be used as a parameter for both return types
    and method arguments. We don’t assume that the payload type has any specific properties
    and only make the basic assumption of consistency—that the type we put in is the
    same type that we will later get back out.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意类型参数 `E` 如何用作返回类型和方法参数的参数。我们不假设载荷类型具有任何特定属性，只做一致性的基本假设——我们放入的类型是后来取出的相同类型。
- en: This enhancement has effectively introduced a new kind of type to Java’s type
    system. By combining the container type with the value of the type parameter,
    we are making new types.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这种增强实际上引入了一种新类型到 Java 的类型系统中。通过将容器类型与类型参数的值组合，我们正在创建新类型。
- en: Diamond Syntax
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Diamond 语法
- en: When we create an instance of a generic type, the righthand side of the assignment
    statement repeats the value of the type parameter. This is usually unnecessary,
    as the compiler can infer the values of the type parameters. In modern versions
    of Java, we can leave out the repeated type values in what is called *diamond
    syntax*.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建泛型类型的实例时，赋值语句的右侧重复了类型参数的值。通常情况下这是不必要的，因为编译器可以推断出类型参数的值。在现代版本的 Java 中，我们可以在所谓的
    *diamond 语法* 中省略重复的类型值。
- en: 'Let’s look at an example of how to use diamond syntax, by rewriting one of
    our earlier examples:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过重新编写我们早期的一个例子来看如何使用 diamond 语法：
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is a small improvement in the verbosity of the assignment statement—we’ve
    managed to save a few characters of typing. We’ll return to the topic of type
    inference when we discuss lambda expressions later in this chapter.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这是赋值语句冗长性的小幅改进——我们设法节省了一些键入字符。在本章稍后讨论 Lambda 表达式时，我们将返回类型推断的话题。
- en: Type Erasure
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型擦除
- en: In [“Default Methods”](#javanut8-CHP-4-SECT-1.7), we discussed the Java platform’s
    strong preference for backward compatibility. The addition of generics in Java
    5 was another example of where backward compatibility was an issue for a new language
    feature.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [“默认方法”](#javanut8-CHP-4-SECT-1.7) 中，我们讨论了 Java 平台对向后兼容性的强烈偏好。Java 5 中引入泛型就是向新语言特性的向后兼容性的另一个例子。
- en: 'The central question was how to make a type system that allowed older, nongeneric
    collection classes to be used alongside with newer, generic collections. The design
    decision was to achieve this by the use of casts:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 中心问题是如何设计一个类型系统，允许旧的非泛型集合类与新的泛型集合类并存。设计决策是通过使用强制类型转换来实现这一点：
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This means that `List` and `List<String>` are compatible as types, at least
    at some level. Java achieves this compatibility by *type erasure*. This means
    that generic type parameters are only visible at compile time—they are stripped
    out by `javac` and are not reflected in the bytecode.^([1](ch04.xhtml#idm45927740773536))
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 `List` 和 `List<String>` 作为类型是兼容的，至少在某种程度上是这样。Java 通过 *类型擦除* 实现了这种兼容性。这意味着泛型类型参数只在编译时可见——它们被
    `javac` 剥离并不反映在字节码中。^([1](ch04.xhtml#idm45927740773536))
- en: Warning
  id: totrans-153
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: The nongeneric type `List` is usually called a *raw type*. It is still perfectly
    legal Java to work with the raw form of types, even for types that are now generic.
    This is almost always a sign of poor-quality code, however.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 非泛型类型 `List` 通常被称为 *原始类型*。对于现在是泛型的类型来说，使用原始形式仍然是完全合法的 Java。然而，这几乎总是质量较差代码的标志。
- en: The mechanism of type erasure gives rise to a difference in the type system
    seen by `javac` and that seen by the JVM—we will discuss this fully in [“Compile
    and Runtime Typing”](#javanut8-CHP-4-SECT-2.10).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 类型擦除机制导致 `javac` 和 JVM 看到的类型系统存在差异——我们将在[“编译和运行时类型”](#javanut8-CHP-4-SECT-2.10)中全面讨论这一点。
- en: 'Type erasure also prohibits some other definitions, which would otherwise seem
    legal. In this code, we want to count the orders as represented in two slightly
    different data structures:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 类型擦除还禁止了一些其他本来看起来合法的定义。在这段代码中，我们想要计算两种稍有不同的数据结构中表示的订单：
- en: '[PRE20]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This seems like perfectly legal Java code, but it will not compile. The issue
    is that although the two methods seem like normal overloads, after type erasure,
    the signature of both methods becomes:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码看起来像是完全合法的Java代码，但它将无法编译。问题在于，尽管这两个方法看起来像是普通的重载方法，但在类型擦除后，两个方法的签名变成了相同的：
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: All that is left after type erasure is the raw type of the container—in this
    case, `Map`. The runtime would be unable to distinguish between the methods by
    signature, and so the language specification makes this syntax illegal.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 类型擦除后，容器的原始类型仅剩下 `Map`。运行时无法通过签名区分这些方法，因此语言规范将此语法视为非法。
- en: Bounded Type Parameters
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有界类型参数
- en: 'Consider a simple generic box:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个简单的泛型盒子：
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This is a useful abstraction, but suppose we want to have a restricted form
    of box that holds only numbers. Java allows us to achieve this by using a *bound*
    on the type parameter. This is the ability to restrict the types that can be used
    as the value of a type parameter, for example:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有用的抽象，但假设我们想要一个只能容纳数字的限制形式的盒子。Java 允许我们通过对类型参数设置 *边界* 来实现这一点。这是限制可以用作类型参数值的类型的能力，例如：
- en: '[PRE23]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The type bound `T extends Number` ensures that `T` can only be substituted with
    a type that is compatible with the type `Number`. As a result of this, the compiler
    knows that `value` will definitely have a method `intValue()` available on it.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 类型边界 `T extends Number` 确保 `T` 只能被兼容于 `Number` 类型的类型所替代。因此，编译器知道 `value` 必定有一个可用的
    `intValue()` 方法。
- en: Note
  id: totrans-167
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that because the `value` field has protected access, it can be accessed
    directly in the subclass.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于 `value` 字段具有受保护的访问权限，在子类中可以直接访问它。
- en: 'If we attempt to instantiate `NumberBox` with an invalid value for the type
    parameter, the result will be a compilation error:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们试图用类型参数的无效值实例化 `NumberBox`，结果将是编译错误：
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Beginning Java programmers should avoid using raw types altogether. Even experienced
    Java programmers can run into problems when using them. For example, when using
    raw types when working with a type bound, then the type bound can be evaded, but
    in doing so, the code is left vulnerable to a runtime exception:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 初学者应尽量避免使用原始类型。即使是有经验的Java程序员在使用时也可能遇到问题。例如，在使用原始类型处理类型边界时，类型边界可能会被规避，但这样做会使代码容易受到运行时异常的影响：
- en: '[PRE25]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The call to `intValue()` fails with a `java.lang.ClassCastException`—as `javac`
    has inserted an unconditional cast of `value` to `Number` before calling the method.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `intValue()` 失败，并抛出 `java.lang.ClassCastException` —— 因为在调用方法之前，`javac` 已经对
    `value` 插入了一个无条件的强制类型转换到 `Number`。
- en: 'In general, type bounds can be used to write better generic code and libraries.
    With practice, some fairly complex constructions can be built, for example:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，类型边界可用于编写更好的泛型代码和库。通过实践，一些相当复杂的结构可以被构建，例如：
- en: '[PRE26]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The definition might seem daunting, but the `ComparingBox` is really just a
    `Box` that contains a `Comparable` value. The type also extends the comparison
    operation to the `ComparingBox` type itself, just by comparing the contents of
    the two boxes.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义可能看起来令人生畏，但 `ComparingBox` 实际上只是包含一个 `Comparable` 值的 `Box`。该类型还通过比较两个盒子的内容，扩展了对
    `ComparingBox` 类型本身的比较操作。
- en: Introducing Covariance
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引入协变性
- en: The design of Java’s generics contains the solution to an old problem. In the
    earliest versions of Java, before the collections libraries were even introduced,
    the language had been forced to confront a deep-seated type system design issue.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Java 泛型的设计包含了一个古老问题的解决方案。在Java的早期版本中，甚至在引入集合库之前，语言就不得不面对一个深层次的类型系统设计问题。
- en: 'Put simply, the question is this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，问题是这样的：
- en: Should an array of strings be compatible with a variable of type array-of-object?
  id: totrans-180
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 字符串数组是否应与类型为对象数组的变量兼容？
- en: In other words, should this code be legal?
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，这段代码应该合法吗？
- en: '[PRE27]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Without this, then even simple methods like `Arrays::sort` would have been
    very difficult to write in a useful way, as this would not work as expected:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有这一点，那么甚至像 `Arrays::sort` 这样的简单方法都将非常难以以预期的方式编写：
- en: '[PRE28]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The method declaration would work only for the type `Object[]` and not for
    any other array type. As a result of these complications, the very first version
    of the Java Language Standard determined that:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 方法声明仅适用于类型为 `Object[]` 而不适用于任何其他数组类型。由于这些复杂性的结果，Java 语言标准的第一个版本确定了以下结论：
- en: If a value of type `C` can be assigned to a variable of type `P`, then a value
    of type `C[]` can be assigned to a variable of type `P[]`.
  id: totrans-186
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果类型 `C` 的值可以分配给类型 `P` 的变量，则类型 `C[]` 的值可以分配给类型 `P[]` 的变量。
- en: That is, arrays’ assignment syntax *varies with* the base type that they hold,
    or arrays are *covariant*.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，数组的赋值语法 *随其所持有的基本类型变化*，或者说数组是 *协变的*。
- en: 'This design decision is rather unfortunate, as it leads to immediate negative
    consequences:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设计决定相当不幸，因为它导致了立即的负面后果：
- en: '[PRE29]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The assignment to `objects[0]` attempts to store an `Integer` into a piece of
    storage that is expecting to hold a `String`. This obviously will not work and
    will throw an `ArrayStoreException`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `objects[0]` 的赋值企图将 `Integer` 存储到期望保存 `String` 的存储空间中。这显然是行不通的，并将抛出 `ArrayStoreException`。
- en: Warning
  id: totrans-191
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: The usefulness of covariant arrays led to them being seen as a necessary evil
    in the very early days of the platform, despite the hole in the static type system
    that the feature exposes.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 协变数组的实用性导致它们在平台的早期阶段被视为一种必要之恶，尽管这种功能暴露了静态类型系统中的漏洞。
- en: However, more recent research on modern open-source codebases indicates that
    array covariance is extremely rarely used and is a language misfeature.^([2](ch04.xhtml#idm45927740053936))
    You should avoid it when writing new code.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对现代开源代码库的更多研究表明，数组协变极少被使用，且是语言的误功能。^([2](ch04.xhtml#idm45927740053936)) 写新代码时应避免使用它。
- en: 'When considering the behavior of generics in the Java platform, a very similar
    question can be asked: “Is `List<String>` a subtype of `List<Object>`?” That is,
    can we write this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑 Java 平台上泛型行为时，可以提出一个非常相似的问题：“`List<String>` 是否是 `List<Object>` 的子类型？”也就是说，我们可以这样写：
- en: '[PRE30]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: At first glance, this seems entirely reasonable—`String` is a subclass of `Object`,
    so we know that any `String` element in our collection is also a valid `Object`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这似乎是完全合理的——`String` 是 `Object` 的子类，因此我们知道集合中的任何 `String` 元素也是有效的 `Object`。
- en: 'However, consider the following code (which is just the array covariance code
    translated to use `List`):'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请考虑以下代码（只是将数组协变代码转换为使用 `List`）：
- en: '[PRE31]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As the type of `objects` was declared to be `List<Object>`, then it should be
    legal to add an `Object` instance to it. However, as the actual instance holds
    strings, then trying to add an `Object` would not be compatible, and so this would
    fail at runtime.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `objects` 的类型声明为 `List<Object>`，因此将 `Object` 实例添加到其中应该是合法的。然而，由于实际实例持有字符串，尝试添加
    `Object` 将不兼容，因此在运行时会失败。
- en: 'This would have changed nothing from the case of arrays, and so the resolution
    is to realize that although this is legal:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这将与数组的情况没有任何变化，因此解决方案是意识到虽然这是合法的：
- en: '[PRE32]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'that does not mean that the corresponding statement for generic container types
    is also true, and as a result:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着泛型容器类型的相应语句也是正确的，因此：
- en: '[PRE33]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Another way of saying this is that `List<String>` is *not* a subtype of `List<Object>`
    or that generic types are *invariant*, not *covariant*. We will have more to say
    about this when we discuss bounded wildcards.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种说法是，`List<String>` *不是* `List<Object>` 的子类型，或者泛型类型是 *不变的*，而不是 *协变的*。在讨论有界通配符时，我们将详细说明这一点。
- en: Wildcards
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通配符
- en: A parameterized type, such as `ArrayList<T>`, is not *instantiable*; we cannot
    create instances of them. This is because `<T>` is just a type parameter, merely
    a placeholder for a genuine type. It is only when we provide a concrete value
    for the type parameter (e.g., `ArrayList<String>`) that the type becomes fully
    formed and we can create objects of that type.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 例如 `ArrayList<T>` 这样的参数化类型是不 *可实例化* 的；我们无法创建它们的实例。这是因为 `<T>` 只是一个类型参数，仅仅是一个真实类型的占位符。只有当我们为类型参数提供一个具体值（例如
    `ArrayList<String>`）时，类型才变得完全形成，我们才能创建该类型的对象。
- en: This poses a problem if the type that we want to work with is unknown at compile
    time. Fortunately, the Java type system is able to accommodate this concept. It
    does so by having an explicit concept of the *unknown type*, which is represented
    as `<?>`. This is the simplest example of Java’s *wildcard types*.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望在编译时不知道要使用的类型，则会出现问题。幸运的是，Java类型系统能够容纳这一概念。它通过具有显式概念的*未知类型*来实现。这表示为`<?>`。这是Java的*通配符类型*的最简单示例。
- en: 'We can write expressions that involve the unknown type:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写涉及未知类型的表达式：
- en: '[PRE34]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This is perfectly valid Java: `ArrayList<?>` is a complete type that a variable
    can have, unlike `ArrayList<T>`. We don’t know anything about `mysteryList`’s
    payload type, but that may not be a problem for our code.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完全有效的Java代码：`ArrayList<?>`是一个变量可以拥有的完整类型，不像`ArrayList<T>`。我们不知道`mysteryList`的载荷类型的任何信息，但这对我们的代码可能并非问题。
- en: For example, when we get an item out of `mysteryList`, it has a completely unknown
    type. However, we can be sure that the object is assignable to `Object`—because
    all valid values of a generic type parameter are reference types and all reference
    values can be assigned to a variable of type `Object`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当我们从`mysteryList`中获取一个项时，它具有完全未知的类型。但是，我们可以确保该对象可以赋值给`Object`，因为泛型类型参数的所有有效值都是引用类型，而所有引用值都可以赋给类型为`Object`的变量。
- en: 'On the other hand, when we’re working with the unknown type, there are some
    limitations on its use in user code. For example, this code will not compile:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当我们使用未知类型时，它在用户代码中有一些使用限制。例如，以下代码将无法编译：
- en: '[PRE35]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The reason for this is simple: we don’t know what the payload type of `mysteryList`
    is! For example, if `mysteryList` was really a instance of `ArrayList<String>`,
    then we wouldn’t expect to be able to put an `Object` into it.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的原因很简单：我们不知道`mysteryList`的载荷类型是什么！例如，如果`mysteryList`实际上是`ArrayList<String>`的实例，那么我们不希望能够将`Object`放入其中。
- en: 'The only value that we know we can always insert into a container is `null`,
    as we know that `null` is a possible value for any reference type. This isn’t
    that useful, and for this reason, the Java language spec also rules out instantiating
    a container object with the unknown type as payload, for example:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们始终可以将`null`插入到容器中，因为我们知道`null`是任何引用类型的可能值。这并不是很有用，因此，Java语言规范还排除了使用未知类型作为载荷来实例化容器对象的可能性，例如：
- en: '[PRE36]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The unknown type may seem to be of limited utility, but one very important
    use for it is as a starting point for resolving the covariance question. We can
    use the unknown type if we want to have a subtyping relationship for containers,
    like this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 未知类型可能看起来用处不大，但它的一个非常重要的用途是作为解决协变问题的起点。如果我们想要为容器使用子类型关系，我们可以使用未知类型，例如：
- en: '[PRE37]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This means that `List<String>` *is* a subtype of `List<?>`—although when we
    use an assignment like the preceding one, we have lost some type information.
    For example, the return type of `objects.get()` is now effectively `Object`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`List<String>`实际上是`List<?>`的子类型 — 虽然当我们使用像前面这样的赋值时，我们会丢失一些类型信息。例如，`objects.get()`的返回类型现在实际上是`Object`。
- en: Note
  id: totrans-220
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: For any value of the type parameter `T`, `List<?>` is not a subtype of the type
    `List<T>`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类型参数`T`的任何值，`List<?>`不是类型`List<T>`的子类型。
- en: The unknown type sometimes confuses developers—provoking questions like, “Why
    wouldn’t you just use `Object` instead of the unknown type?” However, as we’ve
    seen, the need to have subtyping relationships between generic types essentially
    requires us to have a notion of the unknown type.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 未知类型有时会使开发人员感到困惑，引发类似以下问题：“为什么不只使用`Object`而不是未知类型？”然而，正如我们所见，需要在泛型类型之间具有子类型关系，这实质上要求我们具有未知类型的概念。
- en: Bounded wildcards
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有界通配符
- en: In fact, Java’s wildcard types extend beyond just the unknown type, with the
    concept of *bounded wildcards*.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，Java的通配符类型不仅限于未知类型，还有*有界通配符*的概念。
- en: These are used to describe the inheritance hierarchy of a mostly unknown type—effectively
    making statements like, for example, “I don’t know anything about this type, except
    that it must implement `List`.”
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这些用于描述大部分未知类型的继承层次结构 —— 有效地使类似“我不知道这种类型的任何信息，但它必须实现`List`”的语句成立。
- en: This would be written as `? extends List` in the type parameter. This provides
    a useful lifeline to programmers. Instead of being restricted to the totally unknown
    type, they know that at least the capabilities of the type bound are available.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在类型参数中，这将被写成`? extends List`。这为程序员提供了一个有用的生命线。不再局限于完全未知的类型，他们知道至少类型边界的功能是可用的。
- en: Warning
  id: totrans-227
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: The `extends` keyword is always used, regardless of whether the constraining
    type is a class or interface type.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 不管约束类型是类类型还是接口类型，都始终使用`extends`关键字。
- en: This is an example of a concept called *type variance*, which is the general
    theory of how inheritance between container types relates to the inheritance of
    their payload types.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个被称为*类型变异*的概念的示例，它是关于容器类型之间继承如何与它们的载荷类型之间的继承关系相关的一般理论。
- en: Type covariance
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 类型协变性
- en: This means that the container types have the same relationship to each other
    as the payload types do. This is expressed using the `extends` keyword.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着容器类型之间的关系与载荷类型的关系相同。这是用`extends`关键字来表达的。
- en: Type contravariance
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 类型逆变性
- en: This means that the container types have the inverse relationship to each other
    as the payload types. This is expressed using the `super` keyword.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着容器类型之间的关系与载荷类型的关系相反。这是用`super`关键字来表达的。
- en: 'These ideas tend to appear when discussing container types. For example, if
    `Cat` extends `Pet`, then `List<Cat>` is a subtype of `List<? extends Pet>`, and
    so:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当讨论容器类型时，这些想法往往会出现。例如，如果`Cat`扩展`Pet`，那么`List<Cat>`是`List<? extends Pet>`的子类型，因此：
- en: '[PRE38]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'However, this differs from the array case, because type safety is maintained
    in the following way:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这与数组情况不同，因为类型安全性是以以下方式维护的：
- en: '[PRE39]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The compiler cannot prove that the storage pointed at by `pets` is capable of
    storing a `Cat` and so it rejects the call to `add()`. However, as `cats` definitely
    points at a list of `Cat` objects, then it must be acceptable to add a new one
    to the list.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器不能证明由`pets`指向的存储能够存储`Cat`，因此拒绝调用`add()`。然而，由于`cats`明确指向一个`Cat`对象列表，因此将新对象添加到列表中是可以接受的。
- en: As a result, it is very commonplace to see these types of generic constructions
    with types that act as producers or consumers of payload types.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，非常普遍地看到这些类型的通用构造与作为载荷类型的生产者或消费者的类型一起使用。
- en: For example, when the `List` is acting as a *producer* of `Pet` objects, then
    the appropriate keyword is `extends`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当`List`充当`Pet`对象的*生产者*时，适当的关键字是`extends`。
- en: '[PRE40]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note that for the producer case, the payload type appears as the return type
    of the producer method.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于生产者情况，载荷类型出现为生产者方法的返回类型。
- en: For a container type that is acting purely as a *consumer* of instances of a
    type, we would use the `super` keyword, and we would expect to see the payload
    type as the type of a method argument.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 对于作为某种类型实例的*消费者*的容器类型，我们将使用`super`关键字，并且我们期望在方法参数的类型中看到载荷类型。
- en: Note
  id: totrans-244
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 请注意
- en: This is codified in the *Producer Extends, Consumer Super* (PECS) principle
    coined by Joshua Bloch.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这在由Joshua Bloch提出的*生产者扩展，消费者超级*（PECS）原则中得到了具体表述。
- en: As we will discuss in [Chapter 8](ch08.xhtml#javanut8-CHP-8), both covariance
    and contravariance appear throughout the Java Collections. They largely exist
    to ensure that the generics just “do the right thing” and behave in a manner that
    should not surprise the developer.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在[第8章](ch08.xhtml#javanut8-CHP-8)中讨论的那样，协变性和逆变性都出现在Java集合中。它们主要存在是为了确保通用性“做正确的事情”，并且表现出不会让开发人员感到惊讶的方式。
- en: Generic Methods
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用方法
- en: A *generic method* is a method that is able to take instances of any reference
    type.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '*通用方法*是能够接受任何引用类型实例的方法。'
- en: Let’s look at an example. In Java, the comma is used to allow multiple declarations
    in a single line (usually referred to as a *compound declaration*). Other languages,
    such as Javascript or C, have a comma operator that is much more general. The
    JS comma operator `(,)` evaluates both expressions provided to it (from left to
    right) and returns the value of the last expression. The aim is to create a compound
    expression in which multiple expressions are evaluated, with the compound expression’s
    value being the value of the rightmost of its member expressions. Note that any
    side effects from evaluating the expressions to the comma are always triggered,
    unlike in a short-circuiting logic operator.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子。在 Java 中，逗号用于允许在单行中进行多个声明（通常称为*复合声明*）。其他语言，如 Javascript 或 C，具有更一般的逗号运算符。JS
    的逗号运算符 `(,)` 会评估其提供的两个表达式（从左到右），并返回最后一个表达式的值。其目的是创建一个复合表达式，在这个表达式中，多个表达式被评估，而复合表达式的值是其成员表达式的最右边的值。请注意，与短路逻辑运算符不同，逗号评估表达式的任何副作用总是会触发。
- en: 'Java’s comma is much more restrictive than this, by design. This is because
    the comma in other languages can lead to some very hard-to-understand code and
    can be a fantastic source of bugs. However, if we did want to emulate the behavior
    of the comma operator from other language, we could do so by creating a generic
    method:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Java 的逗号比设计时更为严格。这是因为其他语言中的逗号可能导致一些非常难以理解的代码，并且可能是错误的一个极好的来源。然而，如果我们确实想要模仿其他语言中逗号运算符的行为，我们可以通过创建一个泛型方法来实现：
- en: '[PRE41]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Calling the method `Utils.comma()` will cause the values of the expressions
    `a` and `b` to be computed, and any side effects to be triggered, before the method
    call, which is the behavior we want.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `Utils.comma()` 方法将导致计算表达式 `a` 和 `b` 的值，并在方法调用之前触发任何副作用，这是我们想要的行为。
- en: However, notice that even though a type parameter is used in the definition
    of the method, the class it is defined in (`Utils`) is not generic. Instead, we
    see that a new syntax is used to indicate that the method can be used freely,
    and that the return type is the same as the argument.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，需要注意的是，即使在方法的定义中使用了类型参数，其定义所在的类（`Utils`）也不是泛型的。相反，我们看到使用了新的语法来指示可以自由使用该方法，并且返回类型与参数类型相同。
- en: 'Let’s look at another example, from the Java Collections library. In the `ArrayList`
    class we can find a method to create a new array object from an arraylist instance:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看一个例子，来自 Java 集合库。在 `ArrayList` 类中，我们可以找到一个方法，用于从 ArrayList 实例创建一个新的数组对象：
- en: '[PRE42]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This method uses the low-level `arraycopy()` method to do the actual work.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法使用低级的 `arraycopy()` 方法来执行实际的工作。
- en: Note
  id: totrans-257
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If we look at the class definition for `ArrayList` we can see that it is a generic
    class—but the type parameter is `<E>`, not `<T>`, and the type parameter `<E>`
    does not appear at all in the definition of `toArray()`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看 `ArrayList` 的类定义，我们可以看到它是一个泛型类，但类型参数是 `<E>`，而不是 `<T>`，而且类型参数 `<E>` 在
    `toArray()` 的定义中根本不出现。
- en: The `toArray()` method provides one half of a bridge API between the collections
    and Java’s original arrays. The other half of the API—moving from arrays to collections—involves
    a few additional subtleties, as we will discuss in [Chapter 8](ch08.xhtml#javanut8-CHP-8).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`toArray()` 方法提供了集合与 Java 原始数组之间桥接 API 的一半。API 的另一半——从数组到集合的转换——涉及一些额外的细微差别，我们将在[第
    8 章](ch08.xhtml#javanut8-CHP-8)中讨论。'
- en: Compile and Runtime Typing
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译和运行时类型
- en: 'Consider an example piece of code:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个代码示例：
- en: '[PRE43]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can ask the following question: what is the type of `l`? The answer to that
    question depends on whether we consider `l` at compile time (i.e., the type seen
    by `javac`) or at runtime (as seen by the JVM).'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以提出以下问题：`l` 的类型是什么？这个问题的答案取决于我们是在编译时（即 `javac` 看到的类型）还是在运行时（作为 JVM 看到的类型）考虑
    `l`。
- en: '`javac` will see the type of `l` as `List-of-String` and will use that type
    information to carefully check for syntax errors, such as an attempted `add()`
    of an illegal type.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`javac` 将会将 `l` 的类型视为 `List-of-String`，并使用该类型信息来仔细检查语法错误，比如尝试对非法类型进行 `add()`
    操作。'
- en: Conversely, the JVM will see `l` as an object of type `ArrayList`, as we can
    see from the `println()` statement. The runtime type of `l` is a raw type due
    to type erasure.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: JVM 将会把 `l` 视为 `ArrayList` 类型的对象，正如我们可以从 `println()` 语句看到的那样。由于类型擦除，`l` 的运行时类型是原始类型。
- en: The compile-time and runtime types are therefore slightly different from each
    other. The slightly strange thing is that in some ways, the runtime type is both
    more *and* less specific than the compile-time type.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，编译时和运行时类型略有不同。稍微奇怪的是，在某些方面，运行时类型既比编译时类型更具体，也比编译时类型更不具体。
- en: The runtime type is less specific than the compile-time type, because the type
    information about the payload type is gone—it has been erased, and the resulting
    runtime type is just a raw type.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时类型比编译时类型更不具体，因为有关有效载荷类型的类型信息已经消失 —— 它已经被擦除，并且产生的运行时类型只是一个原始类型。
- en: The compile-time type is less specific than the runtime type, because we don’t
    know exactly what concrete type `l` will be; all we know is that it will be of
    a type compatible with `List`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 编译时类型比运行时类型更不具体，因为我们不知道 `l` 将具体是什么类型；我们只知道它将是与 `List` 兼容的类型。
- en: The differences between compile-time and runtime typing sometimes confuse new
    Java programmers, but the distinction quickly comes to be seen as a normal part
    of working in the language.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 编译时和运行时类型的差异有时会让新手 Java 程序员感到困惑，但这种区别很快会被视为语言工作中的正常部分。
- en: Using and Designing Generic Types
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用和设计泛型类型
- en: 'When working with Java’s generics, it can be helpful to think in terms of two
    different levels of understanding:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Java 泛型时，按照两种不同的理解层次进行思考可能会有所帮助：
- en: Practitioner
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 实践者
- en: A practitioner needs to use existing generic libraries and to build some fairly
    simple generic classes. At this level, the developer should also understand the
    basics of type erasure, as several Java syntax features are confusing without
    at least an awareness of the runtime handling of generics.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 从实践者的角度来看，需要使用现有的通用库并构建一些相当简单的通用类。在这个层次上，开发人员还应该理解类型擦除的基础知识，因为几个 Java 语法特性如果没有对泛型运行时处理的意识，可能会感到困惑。
- en: Designer
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 设计师
- en: The designer of new libraries that use generics needs to understand much more
    of the capabilities of generics. There are some nastier parts of the spec, including
    a full understanding of wildcards, and advanced topics such as “capture-of” error
    messages.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 使用泛型的新库的设计者需要更多地了解泛型的能力。规范中还包括一些更难理解的部分，包括对通配符的完全理解，以及高级主题，例如“捕获”错误消息。
- en: Java generics are one of the most complex parts of the language specification
    with a lot of potential corner cases. Not every developer needs to fully understand
    this part of the language, at least not on their first encounter with this part
    of Java’s type system.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: Java 泛型是语言规范中最复杂的部分之一，具有许多潜在的边界情况。并非每个开发人员在首次接触 Java 类型系统的时候都需要完全理解这部分内容。
- en: Enums and Annotations
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举和注解
- en: We have already met records, but Java has additional specialized forms of classes
    and interfaces used to fulfill specific roles in the type system. They are known
    as *enumerated types* and *annotation types*, or normally just *enums* and *annotations*.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经见过记录（records），但 Java 还有额外的专用类和接口形式，用于在类型系统中扮演特定角色。它们被称为*枚举类型*和*注解类型*，通常简称为*枚举*和*注解*。
- en: Enums
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 枚举
- en: Enums are a variation of classes that have limited functionality and the specific
    semantic meaning that the type has only a small number of possible permitted values.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举是类的一种变体，具有有限的功能和特定的语义意义，即该类型仅具有少量可能的允许值。
- en: 'For example, suppose we want to define a type to represent the primary colors
    of red, green, and blue, and we want these to be the only possible values of the
    type. We can do this by using the `enum` keyword:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想定义一个类型来表示红、绿和蓝的主要颜色，并且我们希望这些是该类型的唯一可能值。我们可以使用 `enum` 关键字来实现：
- en: '[PRE44]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The only available instances of the type `PrimaryColor` can then be referenced
    as static fields: `PrimaryColor.RED`, `PrimaryColor.GREEN`, and `PrimaryColor.BLUE`.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，类型 `PrimaryColor` 的唯一可用实例可以作为静态字段进行引用：`PrimaryColor.RED`、`PrimaryColor.GREEN`
    和 `PrimaryColor.BLUE`。
- en: Note
  id: totrans-284
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: In other languages, such as C++, the role of enum types is fulfilled by using
    constant integers, but Java’s approach provides better type safety and more flexiblity.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他语言（如 C++）中，通过使用常量整数来实现枚举类型的角色，但 Java 的方法提供了更好的类型安全性和更大的灵活性。
- en: As enums are specialized classes, enums can have member fields and methods.
    If they do have a body (consisting of fields or methods), then the semicolon at
    the end of the list of instances is required, and the list of enum constants must
    precede the methods and fields.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 由于枚举是专门的类，因此枚举可以具有成员字段和方法。如果它们具有主体（由字段或方法组成），则需要在实例列表的末尾使用分号，并且枚举常量列表必须在方法和字段之前。
- en: 'For example, suppose that we want to have an enum that encompasses the suits
    of standard playing cards. We can achieve this by using an enum that takes a value
    as a parameter, like this:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想要一个枚举来包含标准扑克牌的花色。我们可以通过使用一个带有参数值的枚举来实现这一点，像这样：
- en: '[PRE45]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The parameters (only one of them in this example) are passed to the constructor
    to create the individual enum instances. As the enum instances are created by
    the Java runtime, and can’t be instantiated from outside, the constructor is declared
    as private.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 参数（在此示例中仅有一个）被传递给构造函数以创建单个枚举实例。由于枚举实例由Java运行时创建，并且不能从外部实例化，因此构造函数被声明为私有。
- en: 'Enums have some special properties:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举具有一些特殊属性：
- en: All (implicitly) extend `java.lang.Enum`
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有（隐式地）扩展`java.lang.Enum`
- en: May not be generic
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能不是泛型的
- en: May implement interfaces
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能实现接口
- en: Cannot be extended
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不能被扩展
- en: May have only abstract methods if all enum values provide an implementation
    body
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果所有枚举值提供实现主体，则可能只有抽象方法。
- en: May not be directly instantiated by `new`
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能不能直接通过`new`实例化
- en: Annotations
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注释
- en: Annotations are a specialized kind of interface that, as the name suggests,
    annotate some part of a Java program.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 注释是一种特殊的接口，顾名思义，用于注释Java程序的某些部分。
- en: 'For example, consider the `@Override` annotation. You may have seen it on some
    methods in some of the earlier examples and may have asked the following question:
    what does it do?'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑`@Override`注释。您可能在一些早期的示例中的一些方法上看到了它，并且可能提出了以下问题：它是做什么的？
- en: The short, and perhaps surprising, answer is that it does nothing at all.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 简短的，也许令人惊讶的答案是它根本不起作用。
- en: The less short (and flippant) answer is that, like all annotations, it has no
    direct effect but instead acts as additional information about the method that
    it annotates; in this case, it denotes that a method overrides a superclass method.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 简短的答案是，与所有注释一样，它没有直接影响，而是作为有关所注释的方法的附加信息；在这种情况下，它表示一个方法覆盖了超类方法。
- en: This acts as a useful hint to compilers and integrated development environments
    (IDEs)—if a developer has misspelled the name of a method intended to be an override
    of a superclass method, then the presence of the `@Override` annotation on the
    misspelled method (which does not override anything) alerts the compiler to the
    fact that something is not right.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这对编译器和集成开发环境（IDE）来说是一个有用的提示——如果开发人员拼错了一个意图作为超类方法的覆盖的方法的名称，那么在拼错的方法上存在`@Override`注释（它不覆盖任何内容）会提示编译器有些地方不对。
- en: Annotations, as originally conceived, were not supposed to alter program semantics;
    instead, they were to provide optional metadata. In its strictest sense, this
    means that they should not affect program execution and instead should only provide
    information for compilers and other pre-execution phases.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 注释，如最初的构思，不应改变程序语义；相反，它们应该提供可选的元数据。在最严格的意义上，这意味着它们不应影响程序执行，而应该只为编译器和其他执行前阶段提供信息。
- en: In practice, modern Java applications make heavy use of annotations, and this
    now includes many use cases that essentially render the annotated classes useless
    without additional runtime support.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，现代Java应用程序广泛使用注释，现在包括许多使用情况，实际上使带注释的类在没有额外运行时支持的情况下无法使用。
- en: For example, classes bearing annotations such as `@Inject`, `@Test`, or `@Autowired`
    cannot realistically be used outside of a suitable container. As a result, it
    is difficult to argue that such annotations do not violate the “no semantic meaning”
    rule.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，带有诸如`@Inject`、`@Test`或`@Autowired`之类的注释的类在适当的容器之外实际上不能使用。因此，很难说此类注释不违反“没有语义意义”规则。
- en: The platform defines a small number of basic annotations in `java.lang`. The
    original set were `@Override`, `@Deprecated`, and `@SuppressWarnings`, which were
    used to indicate that a method was overriden, deprecated, or that it generated
    some compiler warnings that should be suppressed.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 平台在`java.lang`中定义了一小部分基本注释。最初的集合是`@Override`、`@Deprecated`和`@SuppressWarnings`，它们用于指示方法已被覆盖、已过时或生成了一些应该被抑制的编译器警告。
- en: These were augmented by `@SafeVarargs` in Java 7 (which provides extended warning
    suppression for varargs methods) and `@FunctionalInterface` in Java 8.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: Java 7 中通过 `@SafeVarargs` 扩展了这些（为可变参数方法提供了扩展警告抑制），Java 8 中通过 `@FunctionalInterface`
    进行了扩展。
- en: This last annotation indicates an interface can be used as a target for a lambda
    expression—it is a useful marker annotation although not mandatory, as we will
    see.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最后的注解表明一个接口可以作为 lambda 表达式的目标使用 — 虽然不是强制的，我们会看到它是一个有用的标记注解。
- en: 'Annotations have some special properties, compared to regular interfaces:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 注解与常规接口相比具有一些特殊的属性：
- en: All (implicitly) extend `java.lang.annotation.Annotation`
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有（隐式）扩展 `java.lang.annotation.Annotation`
- en: May not be generic
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不得是泛型的
- en: May not extend any other interface
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不得扩展任何其他接口
- en: May only define zero-arg methods
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只能定义零参数方法
- en: May not define methods that throw exceptions
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不得定义抛出异常的方法
- en: Have restrictions on the return types of methods
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对方法的返回类型有限制
- en: Can have a default return value for methods
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法可以有默认返回值
- en: In practice, annotations do not typically have a great deal of functionality
    and instead are a fairly simple language concept.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，注解通常没有太多功能，而是一个相当简单的语言概念。
- en: Defining Custom Annotations
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义自定义注解
- en: Defining custom annotation types for use in your own code is not that hard.
    The `@interface` keyword allows the developer to define a new annotation type,
    in much the same way that `class` or `interface` is used.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在自己的代码中使用定义的自定义注解类型并不困难。`@interface` 关键字允许开发人员定义新的注解类型，与使用 `class` 或 `interface`
    类似。
- en: Note
  id: totrans-320
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The key to writing custom annotations is the use of “meta-annotations.” These
    are special annotations that appear on the definition of new (custom) annotation
    types.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义注解的关键在于使用“元注解”。这些特殊的注解出现在新（自定义）注解类型的定义中。
- en: The meta-annotations are defined in `java.lang.annotation` and allow the developer
    to specify policy for where the new annotation type is to be used and how it will
    be treated by the compiler and runtime.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 元注解定义在 `java.lang.annotation` 中，并允许开发人员指定新注解类型的使用策略，以及编译器和运行时的处理方式。
- en: There are two primary meta-annotations that are both required when creating
    a new annotation type—`@Target` and `@Retention`. These both take values that
    are represented as enums.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新注解类型时需要两个主要的元注解 — `@Target` 和 `@Retention`，它们都接受枚举表示的值。
- en: The `@Target` meta-annotation indicates where the new custom annotation can
    be legally placed within Java source code. The enum `ElementType` has the possible
    values `TYPE`, `FIELD`, `METHOD`, `PARAMETER`, `CONSTRUCTOR`, `LOCAL_VARIABLE`,
    `ANNOTATION_TYPE`, `PACKAGE`, `TYPE_PARAMETER`, and `TYPE_USE`, and annotations
    can indicate that they intend to be used at one or more of these locations.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Target` 元注解指示新的自定义注解可以在 Java 源代码中合法放置的位置。枚举 `ElementType` 包含可能的取值 `TYPE`,
    `FIELD`, `METHOD`, `PARAMETER`, `CONSTRUCTOR`, `LOCAL_VARIABLE`, `ANNOTATION_TYPE`,
    `PACKAGE`, `TYPE_PARAMETER`, 和 `TYPE_USE`，注解可以指示它们意图在一个或多个位置使用。'
- en: 'The other meta-annotation is `@Retention`, which indicates how `javac` and
    the Java runtime should process the custom annotation type. It can have one of
    three values, which are represented by the enum `RetentionPolicy`:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个元注解是 `@Retention`，它指示 `javac` 和 Java 运行时如何处理自定义注解类型。它可以有三个值，由枚举 `RetentionPolicy`
    表示：
- en: '`SOURCE`'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`SOURCE`'
- en: Annotations with this retention policy are discarded by `javac` during compilation.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 具有此保留策略的注解在编译时由 `javac` 丢弃。
- en: '`CLASS`'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`CLASS`'
- en: This means that the annotation will be present in the class file but will not
    necessarily be accessible at runtime by the JVM. This is rarely used but is sometimes
    seen in tools that do offline analysis of JVM bytecode.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着注解将出现在类文件中，但不一定可以通过 JVM 在运行时访问。这很少使用，但有时在对 JVM 字节码进行离线分析的工具中可见。
- en: '`RUNTIME`'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`RUNTIME`'
- en: This indicates that the annotation will be available for user code to access
    at runtime (by using reflection).
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明注解将可供用户代码在运行时访问（通过反射）。
- en: 'Let’s take a look at an example, a simple annotation called `@Nickname`, which
    allows the developer to define a nickname for a method, which can then be used
    to find the method reflectively at runtime:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，一个简单的注解称为 `@Nickname`，允许开发人员为方法定义一个昵称，然后可以在运行时通过反射找到该方法：
- en: '[PRE46]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This is all that’s required to define the annotation—a syntax element where
    the annotation can appear, a retention policy, and the name of the element. As
    we need to be able to supply the nickname we’re assigning to the method, we also
    need to define a method on the annotation. Despite this, defining new custom annotations
    is a remarkably compact undertaking.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 定义注解所需的全部内容只是一个语法元素，用于注解可以出现的位置，保留策略和元素的名称。由于我们需要能够提供方法的昵称，我们还需要在注解上定义一个方法。尽管如此，定义新的自定义注解是一项非常紧凑的工作。
- en: In addition to the two primary meta-annotations, there are also the `@Inherited`
    and `@Documented` meta-annotations. These are much less frequently encountered
    in practice, and details on them can be found in the platform documentation.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 除了两个主要的元注解外，还有`@Inherited`和`@Documented`元注解。这两个在实践中遇到的频率要低得多，详细信息可以在平台文档中找到。
- en: Type Annotations
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型注解
- en: 'With the release of Java 8, two new values for `ElementType` were added: `TYPE_PARAMETER`
    and `TYPE_USE`. These new values allow the use of annotations in places where
    they were previously not legal, such as at any site where a type is used. This
    enables the developer to write code such as:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Java 8的发布，`ElementType`新增了两个新的取值：`TYPE_PARAMETER`和`TYPE_USE`。这些新的取值允许在以前不合法的地方使用注解，比如任何类型使用的地方。这使得开发人员可以编写如下代码：
- en: '[PRE47]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The extra type information conveyed by the `@NotNull` can then be used by a
    special type checker to detect problems (a possible `NullPointerException`, in
    this example) and to perform additional static analysis. The basic Java 8 distribution
    ships with some basic pluggable type checkers, but it also provides a framework
    for allowing developers and library authors to create their own.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '`@NotNull`传递的额外类型信息可以被特殊类型检查器用于检测问题（例如可能的`NullPointerException`），并执行额外的静态分析。基本的Java
    8发行版附带了一些基本的可插拔类型检查器，但它也提供了一个框架，允许开发人员和库作者创建他们自己的类型检查器。'
- en: 'In this section, we’ve met Java’s enum and annotation types. Let’s move on
    to consider the next important part of Java’s type system: lambda expressions.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经接触了Java的枚举和注解类型。让我们继续考虑Java类型系统的下一个重要部分：lambda表达式。
- en: Lambda Expressions
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda表达式
- en: One of the most eagerly anticipated features of Java 8 was the introduction
    of lambda expressions (frequently referred to as just lambdas).
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8最令人期待的功能之一是引入了Lambda表达式（通常简称为lambda）。
- en: 'This major upgrade to the Java platform was driven by five goals, in roughly
    descending order of priority:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这次Java平台的重大升级由五个目标驱动，大致按优先级降序排列：
- en: More expressive programming
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更有表现力的编程
- en: Better libraries
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更好的库
- en: Concise code
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简洁的代码
- en: Improved programming safety
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提升的编程安全性
- en: Potentially increased data parallelism
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 潜在的增加数据并行性
- en: 'Lambdas have three key aspects that help define the essential nature of the
    feature:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda具有三个关键方面，帮助定义该特性的基本特性：
- en: They allow small bits of code to be written inline as literals in a program.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们允许在程序中将小段代码以字面量形式内联编写。
- en: They relax the strict grammar of Java code by using type inference.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们通过使用类型推断放宽了Java代码的严格语法。
- en: They facilitate a more functional style of programming Java.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们促进了更加功能化的Java编程风格。
- en: 'As we saw in [Chapter 2](ch02.xhtml#javanut8-CHP-2), the syntax for a lambda
    expression is to take a list of parameters (the types of which are typically inferred),
    and to attach that to a method body, like this:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第2章](ch02.xhtml#javanut8-CHP-2)中看到的，lambda表达式的语法是取参数列表（其类型通常是推断出来的），并将其附加到方法体，就像这样：
- en: '[PRE48]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This can provide a very compact way to represent what is effectively a single
    method. It is also a major departure from earlier versions of Java—until now,
    we always required a class declaration and then a complete method declaration,
    all of which add to the verboseness of the code.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以提供一种非常紧凑的方式来表示实际上是单一方法的内容。这也是与早期版本的Java的一个重大变化 —— 目前为止，我们总是需要一个类声明，然后是一个完整的方法声明，所有这些都增加了代码的冗长。
- en: In fact, before the arrival of lambdas, the only way to approximate this coding
    style was to use *anonymous classes*, which we will discuss later in this chapter.
    However, since Java 8, lambdas have proved to be very popular with Java programmers
    and now have mostly taken over the role of anonymous classes.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，在lambda出现之前，模拟这种编码风格的唯一方法是使用*匿名类*，我们将在本章后面讨论。然而，自Java 8以来，lambda表达式在Java程序员中非常受欢迎，并且现在大多数情况下已经取代了匿名类的角色。
- en: Note
  id: totrans-357
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Despite the similarities between lambda expressions and anonymous classes, lambdas
    are *not* simply syntactic sugar over anonymous classes. In fact, lambdas are
    implemented using method handles (which we will meet in [Chapter 11](ch11.xhtml#javanut8-CHP-11))
    and a special JVM bytecode called `invokedynamic`.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Lambda 表达式与匿名类之间有相似之处，但 Lambda 并不仅仅是匿名类的语法糖。事实上，Lambda 使用方法句柄（我们将在 [第 11
    章](ch11.xhtml#javanut8-CHP-11) 中遇到）和一个名为 `invokedynamic` 的特殊 JVM 字节码实现。
- en: Lambda expressions represent the creation of an object of a specific type. The
    type of the instance that is created is known as the *target type* of the lambda.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 表达式代表创建特定类型的对象。创建的实例类型称为 Lambda 的 *目标类型*。
- en: Only certain types are eligible to be the target of a lambda.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 只有特定类型才能作为 Lambda 的目标。
- en: 'Target types are also called *functional interfaces* and they must:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 目标类型也称为 *功能接口*，它们必须：
- en: Be interfaces
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须是接口
- en: Have only one nondefault method (but may have other methods that are default)
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只能有一个非默认方法（但可以有其他默认方法）
- en: Some developers also like to use the *single abstract method* (or SAM) type
    to refer to the interface type that the lambda is converted into. This draws attention
    to the fact that to be usable by the lambda expression mechanism, an interface
    must have only a single nondefault method.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发人员也喜欢使用 *单一抽象方法*（或 SAM）类型来指代 Lambda 转换的接口类型。这突出了一个事实，即要能够使用 Lambda 表达式机制，接口必须只有一个非默认方法。
- en: Note
  id: totrans-365
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A lambda expression has almost all of the component parts of a method, with
    the obvious exception that a lambda doesn’t have a name. In fact, many developers
    like to think of lambdas as “anonymous methods.”
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 表达式几乎具备方法的所有组成部分，唯一的异常是 Lambda 没有名称。事实上，许多开发人员喜欢将 Lambda 视为“匿名方法”。
- en: 'As a result, this means that the single line of code:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这意味着单行代码：
- en: '[PRE49]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: does not result in the execution of the `println()` but instead creates an object,
    which is assigned to a variable `r`, of type `Runnable`. This object, `r`, will
    execute the `println()` statement, but only when `r.run()` is called, and not
    until then.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 并不执行 `println()`，而是创建一个对象，该对象赋值给变量 `r`，类型为 `Runnable`。这个对象 `r` 将执行 `println()`
    语句，但只有在调用 `r.run()` 时才执行，而不是立即执行。
- en: Lambda Expression Conversion
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lambda 表达式转换
- en: When `javac` encounters a lambda expression, it interprets it as the body of
    a method with a specific signature—but which method?
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `javac` 遇到 Lambda 表达式时，它将其解释为具有特定签名的方法体——但是哪个方法？
- en: 'To resolve this question, `javac` looks at the surrounding code. To be legal
    Java code, the lambda expression must satisfy the following properties:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这个问题，`javac` 查看周围的代码。为了合法的 Java 代码，Lambda 表达式必须满足以下属性：
- en: The lambda must appear where an instance of an interface type is expected.
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda 必须出现在期望接口类型的实例位置上。
- en: The expected interface type should have exactly one mandatory method.
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预期的接口类型应该有且仅有一个强制方法。
- en: The expected interface method should have a signature that exactly matches that
    of the lambda expression.
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预期的接口方法应该具有与 Lambda 表达式完全匹配的签名。
- en: If this is the case, then an instance is created of a type that implements the
    expected interface and uses the lambda body as the implementation for the mandatory
    method.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这样，那么将创建一个实现预期接口并将 Lambda 体作为强制方法实现的类型的实例。
- en: This slightly complex conversion approach comes from the desire to keep Java’s
    type system as purely *nominative* (based on names). The lambda expression is
    said to be *converted* to an instance of the correct interface type.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 这种稍微复杂的转换方法源于希望保持 Java 的类型系统纯粹 *名义*（基于名称）。Lambda 表达式被称为 *转换* 成正确接口类型的实例。
- en: From this discussion, we can see that although Java 8 has added lambda expressions,
    they have been specifically designed to fit into Java’s existing type system—which
    has a very strong emphasis on nominal types (rather than the other possible sorts
    of types that exist in some other programming languages).
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个讨论中，我们可以看到，虽然 Java 8 添加了 Lambda 表达式，但它们被专门设计为适应 Java 现有的类型系统——这个系统非常强调名义类型（而不是其他一些编程语言中可能存在的类型）。
- en: 'Let’s consider an example of lambda conversion—the `list()` method of the `java.io.File`
    class. This method lists the files in a directory. Before it returns the list,
    though, it passes the name of each file to a `FilenameFilter` object that the
    programmer must supply. This `FilenameFilter` object accepts or rejects each file
    and is a SAM type defined in the `java.io` package:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑lambda转换的一个例子——`java.io.File`类的`list()`方法。此方法列出目录中的文件。在返回列表之前，它会将每个文件的名称传递给程序员必须提供的`FilenameFilter`对象。这个`FilenameFilter`对象接受或拒绝每个文件，是`java.io`包中定义的SAM类型之一。
- en: '[PRE50]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The type `FilenameFilter` carries the `@FunctionalInterface` to indicate that
    it is a suitable type to be used as the target type for a lambda. However, this
    annotation is not required, and any type that meets the requirements (by being
    an interface and a SAM type) can be used as a target type.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 类型`FilenameFilter`携带了`@FunctionalInterface`注解，以指示它是一个适合作为lambda目标类型的合适类型。然而，此注解并非必需，任何符合要求的类型（通过是接口且为SAM类型）都可以用作目标类型。
- en: This is because the JDK and the existing corpus of Java code already had a huge
    number of SAM types available before Java 8 was released. To require potential
    target types to carry the annotation would have prevented lambdas from being retrofitted
    to existing code for no real benefit.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为在Java 8发布之前，JDK和现有的Java代码库已经拥有大量的SAM类型。要求潜在的目标类型携带注解会阻止将lambda适配到现有代码中，但并没有真正的好处。
- en: Tip
  id: totrans-383
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: In code that you write, you should always try to indicate when your types are
    usable as target types, which you can do by adding the `@FunctionalInterface`
    to them. This aids readability and can help some automated tools as well.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在您编写的代码中，您应该始终尝试指示您的类型可用作目标类型，这可以通过为它们添加`@FunctionalInterface`来实现。这有助于提高可读性，并且可以帮助一些自动化工具。
- en: 'Here’s how we can define a `FilenameFilter` class to list only those files
    whose names end with *.java*, using a lambda:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何定义一个`FilenameFilter`类，以仅列出那些文件名以*.java*结尾的文件，使用lambda：
- en: '[PRE51]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: For each file in the list, the block of code in the lambda expression is evaluated.
    If the method returns `true` (which happens if the filename ends in *.java*),
    then the file is included in the output—which ends up in the array `filelist`.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 对于列表中的每个文件，将评估lambda表达式中的代码块。如果方法返回`true`（如果文件名以*.java*结尾），则该文件将包含在输出中，最终存储在数组`filelist`中。
- en: This pattern, where a block of code is used to test if an element of a container
    matches a condition, and to return only the elements that pass the condition,
    is called a *filter idiom*. It is one of the standard techniques of functional
    programming, which we will discuss in more depth presently.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式，其中一个代码块用于测试容器中的元素是否满足条件，并且仅返回通过条件的元素，被称为*过滤习语*。这是函数式编程的标准技术之一，我们将很快更深入地讨论它。
- en: Method References
  id: totrans-389
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法引用
- en: 'Recall that we can think of lambda expressions as objects representing methods
    that don’t have names. Now, consider this lambda expression:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 请回忆，我们可以将lambda表达式视为代表没有名称的方法的对象。现在，请考虑这个lambda表达式：
- en: '[PRE52]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This will be autoconverted to an implementation of a `@FunctionalInterface`
    type that has a single nondefault method that takes a single `MyObject` and returns
    a `String`—specifically, the string obtained by calling `toString()` on the instance
    of `MyObject`. However, this seems like excessive boilerplate, and so Java 8 provides
    a syntax for making this easier to read and write:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 这将自动转换为实现`@FunctionalInterface`类型的实现，该类型具有一个非默认方法，接受一个`MyObject`并返回一个`String`，具体来说，是通过在`MyObject`实例上调用`toString()`获取的字符串。然而，这似乎是过度样板代码，因此Java
    8提供了一种语法以使其更易于阅读和编写：
- en: '[PRE53]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This shorthand, known as a *method reference*, uses an existing method as a
    lambda expression. The method reference syntax is completely equivalent to the
    previous form expressed as a lambda. It can be thought of as using an existing
    method but ignoring the name of the method, so it can be used as a lambda and
    then autoconverted in the usual way. Java defines four types of method reference,
    which are equivalent to four slightly different lambda expression forms (see [Table 4-1](#javanut8-CHP-4-TABLE-1)).
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简写称为*方法引用*，它使用现有方法作为lambda表达式。方法引用语法与作为lambda表达式表示的先前形式完全等效。可以将其视为使用现有方法但忽略方法名称，因此它可以用作lambda，然后以通常的方式自动转换。Java定义了四种方法引用类型，这等效于四种略有不同的lambda表达式形式（见[Table 4-1](#javanut8-CHP-4-TABLE-1)）。
- en: Table 4-1\. Method references
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 4-1\. 方法引用
- en: '| Name | Method reference | Equivalent lambda |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 方法引用 | 等效的lambda |'
- en: '| --- | --- | --- |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Unbound | `Trade::getPrice` | `trade -> trade.getPrice()` |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '| 未绑定 | `Trade::getPrice` | `trade -> trade.getPrice()` |'
- en: '| Bound | `System.out::println` | `s -> System.out.println(s)` |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '| 绑定 | `System.out::println` | `s -> System.out.println(s)` |'
- en: '| Static | `System::getProperty` | `key -> System.getProperty(key)` |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
  zh: '| 静态 | `System::getProperty` | `key -> System.getProperty(key)` |'
- en: '| Constructor | `Trade::new` | `price -> new Trade(price)` |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '| 构造函数 | `Trade::new` | `price -> new Trade(price)` |'
- en: The form we originally introduced can be seen to be an *unbound method reference*.
    When we use an unbound method reference, it is equivalent to a lambda that is
    expecting an instance of the type that contains the method reference—​in [Table 4-1](#javanut8-CHP-4-TABLE-1)
    that is a `Trade` object.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最初引入的形式可以看作是一个 *未绑定的方法引用*。当我们使用未绑定的方法引用时，它等同于一个期望包含方法引用的类型实例的 lambda 表达式—​在
    [Table 4-1](#javanut8-CHP-4-TABLE-1) 中，这是一个 `Trade` 对象。
- en: It is called an unbound method reference because the receiver object needs to
    be supplied (as the first argument to the lambda) when the method reference is
    used. That is, we are going to call `getPrice()` on some `Trade` object, but the
    supplier of the method reference has not defined which one. That is left up to
    the user of the reference.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 它被称为未绑定的方法引用，因为接收对象需要在使用方法引用时提供（作为 lambda 的第一个参数）。也就是说，我们将在某个 `Trade` 对象上调用
    `getPrice()`，但方法引用的提供者尚未定义具体是哪一个。这由引用的使用者决定。
- en: By contrast, a *bound method reference* always includes the receiver as part
    of the instantiation of the method reference. In [Table 4-1](#javanut8-CHP-4-TABLE-1),
    the receiver is `System.out` so, when the reference is used, the `println()` method
    will always be called on `System.out`, and all the parameters of the lambda will
    be used as method parameters to `println()`.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，*绑定的方法引用* 总是将接收者作为方法引用的实例化的一部分。在 [Table 4-1](#javanut8-CHP-4-TABLE-1) 中，接收者是
    `System.out`，因此在使用引用时，`println()` 方法将始终在 `System.out` 上调用，并且 lambda 的所有参数都将作为
    `println()` 方法的参数使用。
- en: We will discuss use cases for method references versus lambda expressions in
    more detail in the next chapter.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章节更详细地讨论方法引用与 lambda 表达式的使用场景。
- en: Functional Programming
  id: totrans-406
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数式编程
- en: Java is fundamentally an object-oriented language. However, with the arrival
    of lambda expressions, it becomes much easier to write code that is closer to
    the functional approach.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: Java 从根本上来说是一种面向对象的语言。然而，随着 lambda 表达式的到来，编写接近函数式编程风格的代码变得更加容易。
- en: Note
  id: totrans-408
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: There’s no single definition of exactly what constitutes a *functional language*—but
    there is at least consensus that it should at a minimum contain the ability to
    represent a function as a value that can be put into a variable.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 没有一个确切的定义可以说明什么是 *函数式语言* —— 但至少有共识认为，它应该至少包含将函数表示为可以放入变量中的值的能力。
- en: Java has always (since version 1.1) been able to represent functions via inner
    classes (see next section), but the syntax was complex and lacking in clarity.
    Lambda expressions greatly simplify that syntax, and so it is only natural that
    more developers will be seeking to use aspects of functional programming in their
    Java code.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 自从版本 1.1 以来，Java 一直能够通过内部类来表示函数（参见下一节），但语法复杂且缺乏清晰度。Lambda 表达式极大地简化了这种语法，因此很自然地，更多的开发人员将寻求在其
    Java 代码中使用函数式编程的方面。
- en: 'The first taste of functional programming that Java developers are likely to
    encounter are three basic idioms that are remarkably useful:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: Java 开发人员可能会遇到的第一次函数式编程尝试是三种基本习语，这些习语非常实用：
- en: '`map()`'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '`map()`'
- en: The map idiom is used with lists and list-like containers. The idea is that
    a function is passed in that is applied to each element in the collection, and
    a new collection is created that consists of the results of applying the function
    to each element in turn. This means that a map idiom converts a collection of
    one type to a collection of potentially a different type.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 映射习语通常与列表和类列表容器一起使用。其思想是传入一个应用于集合中每个元素的函数，并创建一个由将该函数应用于每个元素的结果组成的新集合。这意味着映射习语可以将一个类型的集合转换为可能是不同类型的新集合。
- en: '`filter()`'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter()`'
- en: We have already met an example of the filter idiom, when we discussed how to
    replace an anonymous implementation of `FilenameFilter` with a lambda. The filter
    idiom is used for producing a new subset of a collection, based on some selection
    criteria. Note that in functional programming, it is normal to produce a new collection
    rather than modifying an existing one in place.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论如何用lambda替换`FilenameFilter`的匿名实现时，我们已经见过filter惯用语的一个例子。该filter惯用语用于基于某些选择条件生成集合的新子集。请注意，在函数式编程中，通常生成新集合而不是就地修改现有集合是正常的。
- en: '`reduce()`'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce()`'
- en: The reduce idiom has several different guises. It is an aggregation operation,
    which can be called *fold*, *accumulate*, or *aggregate* as well as reduce. The
    basic idea is to take an initial value and an aggregation (or reduction) function,
    and apply the reduction function to each element in turn, building up a final
    result for the whole collection by making a series of intermediate results—similar
    to a “running total”—as the reduce operation traverses the collection.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: reduce惯用语有几种不同的形式。它是一个聚合操作，也可以称为*fold*、*accumulate*或*aggregate*，以及reduce。其基本思想是使用初始值和聚合（或缩减）函数，逐个应用缩减函数于每个元素，通过一系列中间结果（类似于“运行总计”）构建整个集合的最终结果，当reduce操作遍历集合时。
- en: Java has full support for these key functional idioms (and several others).
    The implementation is explained in some depth in [Chapter 8](ch08.xhtml#javanut8-CHP-8),
    where we discuss Java’s data structures and collections, and in particular the
    *stream* abstraction, which makes all of this possible.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: Java具有对这些关键函数惯用语（和其他几种）的全面支持。具体实现在[第8章](ch08.xhtml#javanut8-CHP-8)中有详细解释，我们在那里讨论了Java的数据结构和集合，特别是*stream*抽象，这使得所有这些都成为可能。
- en: 'Let’s conclude this introduction with some words of caution. It’s worth noting
    that Java is best regarded as having support for “slightly functional programming.”
    It is not an especially functional language, nor does it try to be. Some particular
    aspects of Java that militate against any claims to being a functional language
    include:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在这个介绍中总结一些警告。值得注意的是，Java最好被视为对“稍微函数式编程”的支持。它不是特别函数式的语言，也没有尝试成为一个。Java的一些特定方面反对它成为函数式语言的任何主张，包括：
- en: Java has no structural types, which means no “true” function types. Every lambda
    is automatically converted to the appropriate target type.
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java没有结构类型，这意味着没有“真正”的函数类型。每个lambda都会自动转换为相应的目标类型。
- en: Type erasure causes problems for functional programming—type safety can be lost
    for higher-order functions.
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型擦除对函数式编程造成问题——对于高阶函数，类型安全可能会丢失。
- en: Java is inherently mutable (as we’ll discuss in [Chapter 6](ch06.xhtml#javanut8-CHP-6))—mutability
    is often regarded as highly undesirable for functional languages.
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java本质上是可变的（正如我们将在[第6章](ch06.xhtml#javanut8-CHP-6)中讨论的那样）—对于函数式语言来说，可变性通常被认为是非常不可取的。
- en: The Java collections are imperative, not functional. Collections must be converted
    to streams to use functional style.
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java集合是命令式的，而不是函数式的。集合必须转换为流才能使用函数式风格。
- en: Despite this, easy access to the basics of functional programing—and especially
    idioms such as map, filter, and reduce—is a huge step forward for the Java community.
    These idioms are so useful that a large majority of Java developers will never
    need or miss the more advanced capabilities provided by languages with a more
    thoroughbred functional pedigree.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，易于访问函数式编程的基础知识——特别是map、filter和reduce等惯用语——对Java社区来说是一大步向前的。这些惯用语非常有用，以至于大多数Java开发人员永远不需要或错过具有更彻底函数式血统的语言提供的更高级功能。
- en: In truth, many of these techniques were possible using nested types (see next
    section for details), via patterns like callbacks and handlers, but the syntax
    was always quite cumbersome, especially given that you had to explicitly define
    a completely new type even when you needed to express only a single line of code
    in the callback.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，许多这些技术使用嵌套类型是可能的（请参阅下一节的详细信息），通过诸如回调和处理程序之类的模式，但是语法总是相当繁琐的，特别是在你需要仅表达单行代码的回调时，你必须显式定义一个全新的类型。
- en: Lexical Scoping and Local Variables
  id: totrans-426
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 词法作用域和局部变量
- en: A local variable is defined within a block of code that defines its *scope*
    and, outside of that scope, a local variable cannot be accessed and ceases to
    exist. Only code within the curly braces that define the boundaries of a block
    can use local variables defined in that block. This type of scoping is known as
    *lexical scoping*, and it just defines a section of source code within which a
    variable can be used.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 局部变量在定义其*作用域*的代码块内部定义，在该作用域之外，无法访问局部变量并且停止存在。只有在定义块边界的花括号内的代码可以使用该块中定义的局部变量。这种作用域被称为*词法作用域*，它只定义了可以使用变量的源代码部分。
- en: It is common for programmers to think of such a scope as *temporal* instead—that
    is, to think of a local variable as existing from the time the JVM begins executing
    the block until the time control exits the block. This is usually a reasonable
    way to think about local variables and their scope. However, lambda expressions
    (and anonymous and local classes, which we will meet later) have the ability to
    bend or break this intuition.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员通常将这样的作用域视为*临时*，即将局部变量视为从JVM开始执行块到控制退出块的时间存在。这通常是一种合理的局部变量及其作用域的思考方式。然而，lambda表达式（以及稍后将遇到的匿名和本地类）有能力弯曲或打破这种直觉。
- en: 'This can cause effects that some developers initially find surprising. Because
    lambdas can use local variables, they can contain copies of values from lexical
    scopes that no longer exist. This can been seen in the following code:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能导致一些开发人员最初感到惊讶的效果。因为lambda可以使用局部变量，它们可以包含来自不存在的词法范围的值的副本。这可以在以下代码中看到：
- en: '[PRE54]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Each instance of a lambda has an automatically created private copy of each
    of the final local variables it uses, so, in effect, it has its own private copy
    of the scope that existed when it was created. This is sometimes referred to as
    a *captured* variable.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 每个lambda实例都有一个自动创建的私有副本每个使用的最终局部变量，因此实际上它有其自己的私有副本在创建时存在的作用域。这有时被称为*captured*变量。
- en: Lambdas that capture variables like this are referred to as *closures*, and
    the variables are said to have been *closed over*.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获变量这样的lambda称为*closures*，而这些变量被称为*closed over*。
- en: Warning
  id: totrans-433
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Other programming languages may have a slightly different definition of a closure.
    In fact, some theorists would dispute that Java’s mechanism counts as a closure
    because, technically, it is the contents of the variable (a value) and not the
    variable itself that is captured.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 其他编程语言对闭包的定义可能略有不同。事实上，一些理论家会质疑Java的机制是否算得上闭包，因为技术上来说，被捕获的是变量的内容（一个值），而不是变量本身。
- en: 'In practice, the preceding closure example is more verbose than it needs to
    be in two separate ways:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，前述闭包示例比实际需要的更冗长，有两种不同的方式：
- en: The lambda has an explicit scope `{}` and `return` statement.
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda有一个明确的作用域`{}`和`return`语句。
- en: The variable `fi` is explicitly declared `final`.
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量`fi`明确声明为`final`。
- en: The compiler `javac` helps with both of these.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器`javac`帮助处理这两种情况。
- en: Lambdas that return the value of only a single expression need not include a
    scope or `return`; instead, the body of the lambda is just the expression without
    the need for curly braces. In our example, we have explicitly included the braces
    and `return` statement to spell out that the lambda is defining its own scope.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 只返回单个表达式值的lambda不需要包括作用域或者`return`；相反，lambda的主体只是表达式，不需要花括号。在我们的示例中，我们明确地包含了花括号和`return`语句，以阐明lambda正在定义其自身的作用域。
- en: 'In early versions of Java, there were two hard requirements when closing over
    a variable:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java早期版本中，关闭变量时有两个严格的要求：
- en: The captures must not be modified after they have been captured (e.g., after
    the lambda)
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在捕获后，被捕获的变量不能被修改（例如，在lambda之后）。
- en: The captured variables must be declared `final`
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被捕获的变量必须声明为`final`。
- en: However, in recent Java versions, `javac` can analyze the code and detect whether
    the programmer attempts to modify the captured variable after the scope of the
    lambda. If not, then the `final` qualifier on the captured variable can be omitted
    (such a variable is said to be *effectively final*). If the `final` qualifier
    is omitted, then it is a compile-time error to attempt to modify a captured variable
    after the lambda’s scope.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在最近的Java版本中，`javac`可以分析代码并检测程序员是否尝试在lambda的范围之后修改捕获的变量。如果没有，则可以省略对捕获变量的`final`修饰符（这样的变量被称为*effectively
    final*）。如果省略了`final`修饰符，则试图在lambda范围之后修改捕获变量将导致编译时错误。
- en: The reason for this is that Java implements closures by copying the bit pattern
    of the contents of the variable into the scope created by the closure. Further
    changes to the contents of the closed-over variable would not be reflected in
    the copy contained in closure scope, so the design decision was made to make such
    changes illegal and a compile-time error.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为Java通过将变量内容的位模式复制到闭包创建的范围来实现闭包。对于封闭变量内容的进一步更改不会反映在闭包范围中的副本中，因此设计决策是使这些更改非法并在编译时错误。
- en: 'These assists from `javac` mean that we can rewrite the inner loop of the preceding
    example to the very compact form:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 这些来自`javac`的辅助功能意味着我们可以将前面示例的内部循环重写为非常紧凑的形式：
- en: '[PRE55]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Closures are very useful in some styles of programming, and different programming
    languages define and implement closures in different ways. Java implements closures
    as lambda expressions, but local classes and anonymous classes can also capture
    state—and in fact this is how Java implemented closures before lambdas were available.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包在某些编程风格中非常有用，不同的编程语言以不同的方式定义和实现闭包。Java将闭包实现为lambda表达式，但本地类和匿名类也可以捕获状态——实际上这是Java在lambda可用之前实现闭包的方式。
- en: Nested Types
  id: totrans-448
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌套类型
- en: The classes, interfaces, and enum types we have seen so far in this book have
    all been defined as *top-level types*. This means that they are direct members
    of packages, defined independently of other types. However, type definitions can
    also be nested within other type definitions. These *nested types*, commonly known
    as “inner classes,” are a powerful feature of the Java language.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中到目前为止所见的类、接口和枚举类型都被定义为*顶级类型*。这意味着它们是包的直接成员，独立于其他类型之外定义。然而，类型定义也可以嵌套在其他类型定义之内。这些*嵌套类型*，通常被称为“内部类”，是Java语言的一个强大特性。
- en: In general, nested types are used for two separate purposes, both related to
    encapsulation. First, a type may be nested because it needs especially intimate
    access to the internals of another type. By being a nested type, it has access
    in the same way that member variables and methods do. This means that nested types
    have privileged access and can be thought of as “slightly bending the rules of
    encapsulation.”
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，嵌套类型用于两个不同的目的，都与封装相关。首先，类型可能被嵌套，因为它需要特别亲密地访问另一个类型的内部。作为嵌套类型，它以与成员变量和方法相同的方式访问。这意味着嵌套类型具有特权访问权限，可以被视为“略微违反封装规则”。
- en: Another way of thinking about this use case of nested types is that they are
    types that are somehow tied together with another type. This means that they don’t
    really have a completely independent existence as an entity and only coexist.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 对于嵌套类型的此用例的另一种思考方式是，它们是与另一个类型紧密联系的类型。这意味着它们实际上并没有完全独立的实体存在，只是共存。
- en: Alternatively, a type may be only required for a very specific reason and in
    a very small section of code. This means that it should be tightly localized,
    as it is really part of the implementation detail.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，类型可能仅仅是因为一个非常特定的原因在代码的一个非常小的部分中需要。这意味着它应该被紧密地局部化，因为它实际上是实现细节的一部分。
- en: In older versions of Java, the only way to do this was with a nested type, such
    as an anonymous implementation of an interface. In practice, with the advent of
    Java 8, this use case has substantially been taken over by lambda expressions.
    The use of anonymous types as closely localized types has dramatically declined
    as a result, although it still persists for some cases.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 在较早版本的Java中，这样做的唯一方法是使用嵌套类型，例如接口的匿名实现。实际上，随着Java 8的出现，这种用例已经大大被lambda表达式取代。将匿名类型作为紧密局部化类型的使用在某些情况下仍然存在，但显著下降。
- en: 'Types can be nested within another type in four different ways:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 类型可以以四种不同的方式嵌套在另一个类型中：
- en: Static member types
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 静态成员类型
- en: A static member type is any type defined as a `static` member of another type.
    Nested interfaces, enums, and annotations are always static (even if you don’t
    use the keyword).
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 静态成员类型是定义为另一个类型的`static`成员的任何类型。嵌套接口、枚举和注解始终是静态的（即使您没有使用关键字）。
- en: Nonstatic member classes
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 非静态成员类
- en: A “nonstatic member type” is simply a member type that is not declared `static`.
    Only classes can be nonstatic member types.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: “非静态成员类型”简单地是不声明为`static`的成员类型。只有类可以是非静态成员类型。
- en: Local classes
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 本地类
- en: A local class is a class that is defined and only visible within a block of
    Java code. Interfaces, enums, and annotations may not be defined locally.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 本地类是在Java代码块内定义并且仅在其中可见的类。接口、枚举和注解不能在本地定义。
- en: Anonymous classes
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名类
- en: An anonymous class is a kind of local class that has no meaningful name that
    is useful to humans; it is merely an arbitrary name assigned by the compiler,
    which programmers should not use directly. Interfaces, enums, and annotations
    cannot be defined anonymously.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名类是一种没有对人类有意义的有意义名称的本地类；它仅仅是编译器分配的任意名称，程序员不应直接使用。接口、枚举和注解不能匿名定义。
- en: The term “nested types,” while correct and precise, is not widely used by developers.
    Instead, most Java programmers use the much vaguer term “inner class.” Depending
    on the situation, this can refer to a nonstatic member class, local class, or
    anonymous class, but not a static member type, with no real way to distinguish
    between them.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: “嵌套类型”这个术语虽然准确和精确，但并不被开发人员广泛使用。相反，大多数Java程序员使用更模糊的术语“内部类”。根据情况，这可能指非静态成员类、本地类或匿名类，但不是静态成员类型，没有真正的区分方法。
- en: Fortunately, although the terminology for describing nested types is not always
    clear, the syntax for working with them is, and it is usually apparent from context
    which kind of nested type is being discussed.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，尽管描述嵌套类型的术语并不总是清晰，但与其一起工作的语法通常是明显的，通常可以从上下文中看出正在讨论哪种类型的嵌套类型。
- en: Note
  id: totrans-465
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Until Java 11, nested types were implemented using a compiler trick and were
    mostly syntactic sugar. Experienced Java programmers should note that this detail
    changed in Java 11, and it is no longer done in quite the same way as it used
    to be.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 直到Java 11，嵌套类型是使用编译器技巧实现的，大部分是语法糖。有经验的Java程序员应注意，这个细节在Java 11中发生了变化，不再像过去那样实现。
- en: Let’s move on to describe each of the four kinds of nested types in greater
    detail. Each section describes the features of the nested type, the restrictions
    on its use, and any special Java syntax used with the type.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续详细描述四种嵌套类型中的每一种。每个部分描述了嵌套类型的特点、其使用的限制以及与该类型一起使用的任何特殊Java语法。
- en: Static Member Types
  id: totrans-468
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态成员类型
- en: 'A *static member type* is much like a regular top-level type. For convenience,
    however, it is nested within the namespace of another type. Static member types
    have the following basic properties:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '*静态成员类型*与常规顶层类型非常相似。然而，为了方便起见，它嵌套在另一个类型的命名空间内。静态成员类型具有以下基本属性：'
- en: 'A static member type is like the other static members of a class: static fields
    and static methods.'
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态成员类型与类的其他静态成员（如静态字段和静态方法）类似。
- en: A static member type is not associated with any instance of the containing class
    (i.e., there is no `this` object).
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态成员类型与包含类的任何实例无关（即没有`this`对象）。
- en: A static member type can access (only) the `static` members of the class that
    contains it.
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态成员类型可以（仅）访问包含它的类的`static`成员。
- en: A static member type has access to all the `static` members (including any other
    static member types) of its containing type.
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态成员类型可以访问其包含类型的所有`static`成员（包括任何其他静态成员类型）。
- en: Nested interfaces, enums, and annotations are implicitly static, whether or
    not the `static` keyword appears.
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌套接口、枚举和注解无论`static`关键字是否出现，都隐式为静态。
- en: Any type nested within an interface or annotation is also implicitly `static`.
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何嵌套在接口或注解中的类型也隐式为`static`。
- en: Static member types may be defined within top-level types or nested to any depth
    within other static member types.
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态成员类型可以在顶层类型内定义，也可以在其他静态成员类型内的任何深度嵌套。
- en: A static member type may not be defined within any other kind of nested type.
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态成员类型不能在任何其他类型的嵌套类型内定义。
- en: Let’s look at a quick example of the syntax for static member types. [Example 4-1](#javanut8-CHP-4-EX-1)
    shows a helper interface defined as a static member of a containing interface,
    in this case Java’s `Map`.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下静态成员类型的语法示例。[示例 4-1](#javanut8-CHP-4-EX-1) 展示了一个帮助接口作为包含接口的静态成员定义的示例，本例中为Java的`Map`。
- en: Example 4-1\. Defining and using a static member interface
  id: totrans-479
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-1\. 定义并使用静态成员接口
- en: '[PRE56]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: When used by an external class, `Entry` will be referred to by its hierarchical
    name `Map.Entry`.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 当被外部类使用时，`Entry`将通过其层次名称`Map.Entry`来引用。
- en: Features of static member types
  id: totrans-482
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态成员类型的特点
- en: 'A static member type has access to all static members of its containing type,
    including `private` members. The reverse is true as well: the methods of the containing
    type have access to all members of a static member type, including the `private`
    members. A static member type even has access to all the members of any other
    static member types, including the `private` members of those types. A static
    member type can use any other static member without qualifying its name with the
    name of the containing type.'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 静态成员类型可以访问其包含类型的所有静态成员，包括`private`成员。反之亦然：包含类型的方法可以访问静态成员类型的所有成员，包括这些类型的`private`成员。静态成员类型甚至可以访问任何其他静态成员类型的所有成员，包括这些类型的`private`成员。静态成员类型可以使用任何其他静态成员，而无需使用包含类型的名称限定其名称。
- en: Top-level types can be declared as either `public` or package-private (if they’re
    declared without the `public` keyword). But declaring top-level types as `private`
    and `protected` wouldn’t make a great deal of sense—`protected` would just mean
    the same as package-private, and a `private` top-level class would be unable to
    be accessed by any other type.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 顶层类型可以声明为`public`或包私有（如果它们没有使用`public`关键字声明）。但将顶层类型声明为`private`和`protected`并没有太大意义——`protected`只是意味着与包私有相同，而`private`顶层类无法被任何其他类型访问。
- en: Static member types, on the other hand, are members and so can use any access
    control modifiers that other members of the containing type can. These modifiers
    have the same meanings for static member types as they do for other members of
    a type.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，静态成员类型是成员，因此可以使用与包含类型的其他成员相同的任何访问控制修饰符。对于静态成员类型，这些修饰符的含义与类型的其他成员相同。
- en: 'Under most circumstances, the `Outer.Inner` syntax for class names provides
    a helpful reminder that the inner class is interconnected with its containing
    type. However, the Java language does permit you to use the `import` directive
    to directly import a static member type:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，类名使用`Outer.Inner`语法可以很好地提醒内部类与其包含类型的互联性。但是，Java语言允许您使用`import`指令直接导入静态成员类型：
- en: '[PRE57]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: You can then reference the nested type without including the name of its enclosing
    type (e.g., just as `Entry`).
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以引用嵌套类型，而无需包含其封闭类型的名称（例如，只需像`Entry`这样）。
- en: Note
  id: totrans-489
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You can also use the `import static` directive to import a static member type.
    See [“Packages and the Java Namespace”](ch02.xhtml#javanut8-CHP-2-SECT-10) in
    [Chapter 2](ch02.xhtml#javanut8-CHP-2) for details on `import` and `import static`.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`import static`指令导入静态成员类型。有关`import`和`import static`的详细信息，请参见[第2章](ch02.xhtml#javanut8-CHP-2)中的[“包和Java命名空间”](ch02.xhtml#javanut8-CHP-2-SECT-10)。
- en: However, importing a nested type obscures the fact that that type is closely
    associated with its containing type—which is usually important information—and
    as a result it is not commonly done.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，导入嵌套类型会掩盖该类型与其包含类型紧密关联的事实——这通常是重要信息，并因此不常见。
- en: Nonstatic Member Classes
  id: totrans-492
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非静态成员类
- en: 'A *nonstatic member class* is a class that is declared as a member of a containing
    class or enumerated type without the `static` keyword:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '*非静态成员类*是一种声明为包含类或枚举类型的成员的类，没有`static`关键字：'
- en: If a static member type is analogous to a class field or class method, a nonstatic
    member class is analogous to an instance field or instance method.
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果静态成员类型类比于类字段或类方法，那么非静态成员类类比于实例字段或实例方法。
- en: Only classes can be nonstatic member types.
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有类可以是非静态成员类型。
- en: An instance of a nonstatic member class is always associated with an instance
    of the enclosing type.
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非静态成员类的实例始终与封闭类型的实例相关联。
- en: The code of a nonstatic member class has access to all the fields and methods
    (both `static` and non-`static`) of its enclosing type.
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非静态成员类的代码可以访问其封闭类型的所有字段和方法（包括`static`和非`static`）。
- en: Several Java syntax features exist specifically to work with the enclosing instance
    of a nonstatic member class.
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java语法具有几个特定功能，专门用于处理非静态成员类的封闭实例。
- en: '[Example 4-2](#javanut8-CHP-4-EX-2) shows how a member class can be defined
    and used. This example shows a `LinkedStack` example: it defines a nested interface
    that describes the nodes of the linked list underlying the stack and a nested
    class to allow enumeration of the elements on the stack. The member class defines
    an implementation of the `java.util.Iterator` interface.'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 4-2](#javanut8-CHP-4-EX-2)展示了如何定义和使用成员类。这个例子展示了一个`LinkedStack`的例子：它定义了一个嵌套接口，描述了堆栈底层的链表节点，并且定义了一个嵌套类来允许对堆栈上的元素进行枚举。成员类定义了`java.util.Iterator`接口的一个实现。'
- en: Example 4-2\. An iterator implemented as a member class
  id: totrans-500
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-2\. 作为成员类实现的迭代器
- en: '[PRE58]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Notice how the `LinkedIterator` class is nested within the `LinkedStack` class.
    `LinkedIterator` is a helper class used only within `LinkedStack`, so having it
    defined close to where it is used by the containing class makes for a clean design.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`LinkedIterator`类如何嵌套在`LinkedStack`类内部。`LinkedIterator`是一个仅在`LinkedStack`内部使用的辅助类，因此在包含类使用它的地方定义它可以产生清晰的设计。
- en: Features of member classes
  id: totrans-503
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 成员类的特性
- en: Like instance fields and instance methods, every instance of a nonstatic member
    class is associated with an instance of the class in which it is defined. This
    means that the code of a member class has access to all the instance fields and
    instance methods (as well as the `static` members) of the containing instance,
    including any that are declared `private`.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 像实例字段和实例方法一样，每个非静态成员类的实例都与其定义的包含类的实例关联。这意味着成员类的代码可以访问包含实例的所有实例字段和实例方法（以及`static`成员），包括任何声明为`private`的成员。
- en: 'This crucial feature was already illustrated in [Example 4-2](#javanut8-CHP-4-EX-2).
    Here is the `LinkedStack.LinkedIterator()` constructor again:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 这一关键特性已经在[示例 4-2](#javanut8-CHP-4-EX-2)中进行了演示。这里再次展示了`LinkedStack.LinkedIterator()`构造函数：
- en: '[PRE59]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This single line of code sets the `current` field of the inner class to the
    value of the `head` field of the containing class. The code works as shown, even
    though `head` is declared as a `private` field in the containing class.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码将内部类的`current`字段设置为包含类的`head`字段的值。尽管在包含类中，`head`声明为`private`字段，代码如所示仍然可以工作。
- en: A nonstatic member class, like any member of a class, can be assigned one of
    the standard access control modifiers. In [Example 4-2](#javanut8-CHP-4-EX-2),
    the `LinkedIterator` class is declared `protected`, so it is inaccessible to code
    (in a different package) that uses the `LinkedStack` class but is accessible to
    any class that subclasses `LinkedStack`.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 非静态成员类，像类的任何成员一样，可以被分配标准访问控制修饰符之一。在[示例 4-2](#javanut8-CHP-4-EX-2)中，`LinkedIterator`类声明为`protected`，因此对使用`LinkedStack`类的代码（在不同包中）是不可访问的，但对任何子类化`LinkedStack`的类是可访问的。
- en: 'Member classes have two important restrictions:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 成员类有两个重要的限制：
- en: A nonstatic member class cannot have the same name as any containing class or
    package. This is an important rule, one that is *not* shared by fields and methods.
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非静态成员类不能与任何包含类或包具有相同的名称。这是一个重要的规则，不同于字段和方法。
- en: Nonstatic member classes cannot contain any `static` fields, methods, or types,
    except for constant fields declared both `static` and `final`.
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非静态成员类不能包含任何`static`字段、方法或类型，除了被声明为`static`和`final`的常量字段。
- en: Syntax for member classes
  id: totrans-512
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 成员类的语法
- en: The most important feature of a member class is that it can access the instance
    fields and methods in its containing object.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 成员类最重要的特性是它可以访问其包含对象的实例字段和方法。
- en: 'If we want to use explicit references, and make use of `this`, then we have
    to use a special syntax for explicitly referring to the containing instance of
    the `this` object. For example, if we want to be explicit in our constructor,
    we can use the following syntax:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要使用显式引用，并使用`this`，那么我们必须使用一种特殊的语法来显式地引用`this`对象的包含实例。例如，如果我们在构造函数中想要显式地表示，我们可以使用以下语法：
- en: '[PRE60]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The general syntax is *`classname.this`*, where *`classname`* is the name of
    a containing class. Note that member classes can themselves contain member classes,
    nested to any depth.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 通用语法是*`classname.this`*，其中*`classname`*是包含类的名称。请注意，成员类本身可以包含成员类，嵌套到任意深度。
- en: However, no member class can have the same name as any containing class, so
    the use of the enclosing class name prepended to `this` is a perfectly general
    way to refer to any containing instance. Another way of saying this is that the
    syntax construction `EnclosingClass.this` is an unambiguous way of referring to
    the containing instance as an *uplevel reference*.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，没有任何成员类可以与任何包含类具有相同的名称，因此，在`this`之前加上包含类名称是引用任何包含实例的一种完全通用的方式。换句话说，`EnclosingClass.this`的语法构造是引用包含实例的一种明确方式，称为*上级引用*。
- en: Local Classes
  id: totrans-518
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地类
- en: 'A *local class* is declared locally within a block of Java code rather than
    as a member of a class. Only classes may be defined locally: interfaces, enumerated
    types, and annotation types must be top-level or static member types. Typically,
    a local class is defined within a method, but it can also be defined within a
    static initializer or instance initializer of a class.'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '*本地类*是在Java代码块内部声明的类，而不是类的成员。只有类可以在本地定义：接口、枚举类型和注释类型必须是顶级或静态成员类型。通常，本地类在方法内部定义，但也可以在类的静态初始化器或实例初始化器内定义。'
- en: Just as all blocks of Java code appear within class definitions, all local classes
    are nested within containing blocks. For this reason, although local classes share
    many of the features of member classes, it is usually more appropriate to think
    of them as an entirely separate kind of nested type.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所有Java代码块都出现在类定义内部一样，所有本地类都嵌套在包含块内部。因此，尽管本地类与成员类共享许多特性，通常更合适的是将它们视为一种完全不同的嵌套类型。
- en: Note
  id: totrans-521
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: See [Chapter 5](ch05.xhtml#javanut8-CHP-5) for details as to when it’s appropriate
    to choose a local class versus a lambda expression.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 详见[第 5 章](ch05.xhtml#javanut8-CHP-5)，了解何时适合选择本地类而不是lambda表达式。
- en: The defining characteristic of a local class is that it is local to a block
    of code. Like a local variable, a local class is valid only within the scope defined
    by its enclosing block. [Example 4-3](#javanut8-CHP-4-EX-3) illustrates how we
    can modify the `iterator()` method of the `LinkedStack` class so it defines `LinkedIterator`
    as a local class instead of a member class.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 本地类的定义特点是它仅在代码块的范围内有效。[示例 4-3](#javanut8-CHP-4-EX-3)演示了如何修改`LinkedStack`类的`iterator()`方法，使其将`LinkedIterator`定义为本地类而不是成员类。
- en: By doing this, we move the definition of the class even closer to where it is
    used and hopefully improve the clarity of the code even further. For brevity,
    [Example 4-3](#javanut8-CHP-4-EX-3) shows only the `iterator()` method, not the
    entire `LinkedStack` class that contains it.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做可以将类的定义更接近其使用位置，从而进一步提高代码的清晰度。为简洁起见，[示例 4-3](#javanut8-CHP-4-EX-3)仅显示了`iterator()`方法，而不是包含它的整个`LinkedStack`类。
- en: Example 4-3\. Defining and using a local class
  id: totrans-525
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-3\. 定义和使用本地类
- en: '[PRE61]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Features of local classes
  id: totrans-527
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本地类的特性
- en: 'Local classes have the following interesting features:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 本地类具有以下有趣的特性：
- en: Like member classes, local classes are associated with a containing instance
    and can access any members, including `private` members, of the containing class.
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像成员类一样，本地类与包含实例关联，并且可以访问包含类的任何成员，包括`private`成员。
- en: In addition to accessing fields defined by the containing class, local classes
    can access any local variables, method parameters, or exception parameters that
    are in the scope of the local method definition and are declared `final`.
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了访问包含类定义的字段外，本地类还可以访问任何本地方法定义作用域内的局部变量、方法参数或异常参数，并且这些变量必须声明为`final`。
- en: 'Local classes are subject to the following restrictions:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 本地类受以下限制：
- en: The name of a local class is defined only within the block that defines it;
    it can never be used outside that block. (Note, however, that instances of a local
    class created within the scope of the class can continue to exist outside of that
    scope. This situation is described in more detail later in this section.)
  id: totrans-532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地类的名称仅在定义它的块内部有效；它永远不能在该块外部使用。（注意，但是，在类的范围内创建的本地类的实例可以继续存在于该范围之外。本节稍后将详细描述这种情况。）
- en: Local classes cannot be declared `public`, `protected`, `private`, or `static`.
  id: totrans-533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地类不能声明为`public`、`protected`、`private`或`static`。
- en: Like member classes, and for the same reasons, local classes cannot contain
    `static` fields, methods, or classes. The only exception is for constants that
    are declared both `static` and `final`.
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与成员类一样，由于同样的原因，局部类不能包含`static`字段、方法或类。唯一的例外是同时声明为`static`和`final`的常量。
- en: Interfaces, enumerated types, and annotation types cannot be defined locally.
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口、枚举类型和注解类型不能在局部定义。
- en: A local class, like a member class, cannot have the same name as any of its
    enclosing classes.
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与成员类一样，局部类也不能与其封闭类的任何名称相同。
- en: As noted earlier, a local class can close over the local variables, method parameters,
    and even exception parameters that are in its scope but only if those variables
    or parameters are effectively `final`.
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如前面提到的，局部类可以关闭作用域内的局部变量、方法参数甚至异常参数，但前提是这些变量或参数是有效地`final`。
- en: Scope of a local class
  id: totrans-538
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 局部类的作用域
- en: In discussing nonstatic member classes, we saw that a member class can access
    any members inherited from superclasses and any members defined by their containing
    classes.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论非静态成员类时，我们看到成员类可以访问从超类继承的任何成员以及由其包含的类定义的任何成员。
- en: The same is true for local classes, but local classes can also behave like lambdas
    and access effectively `final` local variables and parameters. [Example 4-4](#javanut8-CHP-4-EX-4)
    illustrates the different kinds of fields and variables that may be accessible
    to a local class (or a lambda, for that matter).
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 对于局部类也是如此，但局部类还可以像Lambda一样访问有效的`final`局部变量和参数。[示例 4-4](#javanut8-CHP-4-EX-4)展示了局部类（或Lambda）可以访问的不同类型的字段和变量。
- en: Example 4-4\. Fields and variables available to a local class
  id: totrans-541
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-4\. 局部类可访问的字段和变量
- en: '[PRE62]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Local classes have quite a complex scoping structure, therefore. To see why,
    notice that instances of a local class can have a lifetime that extends past the
    time that the JVM exits the block where the local class is defined.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，局部类具有相当复杂的作用域结构。要了解原因，请注意，局部类的实例的生命周期可以延伸到JVM退出定义局部类的块之后。
- en: Note
  id: totrans-544
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In other words, if you create an instance of a local class, that instance does
    not automatically go away when the JVM finishes executing the block that defines
    the class. So, even though the definition of the class was local, instances of
    that class can escape the place they were defined.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果您创建了局部类的实例，那么当JVM完成定义类的块的执行时，该实例不会自动消失。因此，即使类的定义是局部的，该类的实例也可以逃离其定义的位置。
- en: Local classes, therefore, behave like lambdas in many regards, although the
    use case of local classes is more general than that of lambdas. However, in practice,
    the extra generality is rarely required, and lambdas are preferred wherever possible.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，局部类在许多方面的行为类似于Lambda，尽管局部类的用例比Lambda更通用。然而，在实践中，很少需要额外的通用性，并且尽可能使用Lambda。
- en: Anonymous Classes
  id: totrans-547
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匿名类
- en: An *anonymous class* is a local class without a name. It is defined and instantiated
    in a single expression using the `new` operator. While a local class definition
    is a statement in a block of Java code, an anonymous class definition is an expression,
    which means that it can be included as part of a larger expression, such as a
    method call.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '*匿名类*是一种没有名称的局部类。它在一个表达式中使用`new`运算符进行定义和实例化。虽然局部类定义是Java代码块中的语句，但匿名类定义是一个表达式，这意味着它可以作为较大表达式的一部分，例如方法调用。'
- en: Note
  id: totrans-549
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: For the sake of completeness, we cover anonymous classes here, but for most
    use cases, lambda expressions (see [“Lambda Expressions”](#javanut8-CHP-4-SECT-4))
    have replaced anonymous classes.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整起见，我们在这里涵盖了匿名类，但对于大多数用例，Lambda表达式（参见[“Lambda表达式”](#javanut8-CHP-4-SECT-4)）已经取代了匿名类。
- en: Consider [Example 4-5](#javanut8-CHP-4-EX-5), which shows the `LinkedIterator`
    class implemented as an anonymous class within the `iterator()` method of the
    `LinkedStack` class. Compare it with [Example 4-4](#javanut8-CHP-4-EX-4), which
    shows the same class implemented as a local class.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考[示例 4-5](#javanut8-CHP-4-EX-5)，它展示了`LinkedIterator`类作为`LinkedStack`类的`iterator()`方法内的匿名类实现。与[示例 4-4](#javanut8-CHP-4-EX-4)进行比较，它展示了相同的类作为局部类实现。
- en: Example 4-5\. An enumeration implemented with an anonymous class
  id: totrans-552
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-5\. 使用匿名类实现的枚举
- en: '[PRE63]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: As you can see, the syntax for defining an anonymous class and creating an instance
    of that class uses the `new` keyword, followed by the name of a type and a class
    body definition in curly braces. If the name following the `new` keyword is the
    name of a class, the anonymous class is a subclass of the named class. If the
    name following `new` specifies an interface, as in the two previous examples,
    the anonymous class implements that interface and extends `Object`.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，定义匿名类并创建该类的实例的语法使用 `new` 关键字，后跟类型名称和用大括号括起的类体定义。如果 `new` 关键字后面的名称是类的名称，则匿名类是指定类的子类。如果
    `new` 后面的名称指定了一个接口，就像前两个示例中一样，匿名类实现该接口并扩展 `Object`。
- en: Note
  id: totrans-555
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The syntax for anonymous classes deliberately does not include any way to specify
    an `extends` clause, an `implements` clause, or a name for the class.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名类的语法特意不包括任何指定 `extends` 子句、`implements` 子句或类名的方式。
- en: Because an anonymous class has no name, it is not possible to define a constructor
    for it within the class body. This is one of the basic restrictions on anonymous
    classes. Any arguments you specify between the parentheses following the superclass
    name in an anonymous class definition are implicitly passed to the superclass
    constructor. Anonymous classes are commonly used to subclass simple classes that
    do not take any constructor arguments, so the parentheses in the anonymous class
    definition syntax are often empty.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 因为匿名类没有名称，所以不可能在类体中为其定义构造函数。这是匿名类的基本限制之一。在匿名类定义中紧随超类名称后的括号内指定的任何参数都会隐式传递给超类构造函数。匿名类通常用于子类化不需要任何构造函数参数的简单类，因此匿名类定义语法中的括号经常是空的。
- en: Because an anonymous class is just a type of local class, anonymous classes
    and local classes share the same restrictions. An anonymous class cannot define
    any `static` fields, methods, or classes, except for `static` `final` constants.
    Interfaces, enumerated types, and annotation types cannot be defined anonymously.
    Also, like local classes, anonymous classes cannot be `public`, `private`, `protected`,
    or `static`.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 因为匿名类只是一种局部类的类型，匿名类和局部类共享相同的限制。匿名类不能定义任何 `static` 字段、方法或类，除了 `static final`
    常量。接口、枚举类型和注解类型不能匿名定义。此外，像局部类一样，匿名类不能是 `public`、`private`、`protected` 或 `static`。
- en: The syntax for defining an anonymous class combines definition with instantiation,
    similar to a lambda expression. Using an anonymous class instead of a local class
    is not appropriate if you need to create more than a single instance of the class
    each time the containing block is executed.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 定义匿名类的语法将定义与实例化结合在一起，类似于 lambda 表达式。如果每次执行包含块时需要创建多个类的实例，则不适合使用匿名类而应使用局部类。
- en: Describing the Java Type System
  id: totrans-560
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 描述 Java 类型系统
- en: At this point, we have met all of the major aspects of the Java type system,
    and so it is possible for us to describe and characterize it.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了 Java 类型系统的所有主要方面，因此我们可以对其进行描述和表征。
- en: 'The most important and obvious characteristics of Java’s type system are that
    it is:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: Java 类型系统的最重要和显而易见的特征是它是：
- en: Static
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态
- en: Not single-rooted
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不是单根
- en: Nominal
  id: totrans-565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名义上
- en: Static typing, which is the most widely recognized of the three aspects, means
    that in Java, every piece of data storage (such as variables, fields, etc.) has
    a type, and that type is declared when the storage is first introduced. It is
    a compile-time error to try to put an incompatible value into storage that does
    not support it.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 静态类型是三个方面中最广为人知的，意味着在 Java 中，每个数据存储（如变量、字段等）都有一个类型，并且该类型在首次引入存储时声明。尝试将不兼容的值放入不支持的存储中会导致编译时错误。
- en: That Java’s type system is not single-rooted is also immediately apparent. Java
    has both primitive types and reference types. Every object in Java belongs to
    a class, and every class, except `Object`, has a single parent. This means that
    the set of classes in any Java program forms a tree structure with `Object` at
    the root.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: Java 的类型系统不是单根的也是立即显而易见的。Java 有原始类型和引用类型。Java 中的每个对象都属于一个类，除了 `Object` 外，每个类都有一个单一的父类。这意味着任何
    Java 程序中的类集合形成一个以 `Object` 为根的树结构。
- en: However, there is no inheritance relationship between any of the primitive types
    and `Object`. As a result, the overall graph of Java classes consists of a large
    tree of reference types and eight disjoint, isolated points that correspond to
    the primitives. This leads to the need to use wrapper types, such as `Integer`,
    to represent primitive values as objects where necessary (such as in the Java
    Collections).
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，任何原始类型和`Object`之间都没有继承关系。因此，Java 类的整体图形由大量的引用类型树和八个不相交的孤立点（对应于原始类型）组成。这导致需要使用包装类型，如`Integer`，在必要时将原始值表示为对象（例如在
    Java 集合中）。
- en: The final aspect, though, requires a bit more of a detailed discussion.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个方面，则需要更详细的讨论。
- en: Nominal Typing
  id: totrans-570
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 名义类型
- en: In Java, each type has a name. In the normal course of Java programming, this
    will be a simple string of letters (and sometimes numbers) that has some semantic
    meaning that reflects the purpose of the type. This approach is known as *nominal
    typing*.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，每种类型都有一个名称。在 Java 编程的正常过程中，这将是一个简单的字母（有时是数字）串，具有反映类型用途的语义意义。这种方法被称为*名义类型*。
- en: Not all languages have purely nominal typing; for example, some languages can
    express the idea that “this type has a method with a certain signature” without
    needing to explicitly refer to the name of the type, sometimes known as a *structural
    type*.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有语言都具有纯粹的名义类型；例如，一些语言可以表达“此类型具有特定签名方法”的概念，而无需显式引用类型名称，有时被称为*结构类型*。
- en: For example, in Python, you can call `len()` on any object that defines a `__len__()`
    method. Of course, Python is a dynamically typed language and so will throw a
    runtime exception if the call to `len()` cannot be made. However, it is also possible
    to express a similar idea in statically typed languages, such as Scala.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 Python 中，您可以对定义了`__len__()`方法的任何对象调用`len()`。当然，Python 是一种动态类型语言，如果无法进行`len()`调用，则会引发运行时异常。但是，在静态类型语言中也可以表达类似的概念，例如
    Scala。
- en: 'Java, on the other hand, has no way to express this idea without using an interface,
    which, of course, has a name. Java also maintains type compatibility based strictly
    on inheritance and implementation. Let’s look at an example:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: Java 另一方面，没有办法在不使用接口的情况下表达这个想法，这当然有一个名字。Java 也严格基于继承和实现来维护类型兼容性。让我们看一个例子：
- en: '[PRE64]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The interface `MyRunnable` has a single method that exactly matches that of
    `Runnable`. However, the two interfaces have no inheritance or other relationship
    to each other and so code like this:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 接口`MyRunnable`有一个单一方法，与`Runnable`完全匹配。然而，这两个接口彼此没有继承或其他关系，所以像这样的代码：
- en: '[PRE65]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'will compile cleanly but will fail with a `ClassCastException` at runtime.
    The fact that a `run()` method with an identical signature exists on both interfaces
    is not considered, and in fact the program never even makes it to the point where
    `run()` would be called: it fails on the previous line where the cast is attempted.'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 将会编译成功，但在运行时会失败并抛出`ClassCastException`。事实上，即使两个接口上存在具有相同签名的`run()`方法，编译器也不会考虑，实际上程序根本没有执行到调用`run()`的地步：它失败在前一行，即尝试进行类型转换的地方。
- en: 'Another important point is that the entire construction of Java’s lambda expressions,
    and especially the use of target typing to a functional interface, is to ensure
    that lambdas fit into the nominal typing approach. For example, consider an interface
    such as:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的点是 Java 的整个 lambda 表达式构建，特别是将目标类型定型为函数接口，是为了确保 lambda 能够适应名义类型方法。例如，考虑这样一个接口：
- en: '[PRE66]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'then a lambda expression that yields a constant, e.g., `() -> 42`, can be used
    in a number of different ways:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，可以在多种不同的情况下使用一个产生常量的 lambda 表达式，例如`() -> 42`：
- en: '[PRE67]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: From this, we can see that the expression `() -> 42` is, by itself, incomplete.
    Java lambdas rely upon type inference, and so we need to see the expression in
    context with its target type for it to be meaningful. When combined with a target
    type, the lambda’s class type is “an unknown-at-compile-time implementation of
    the target interface,” and the programmer must use the interface type as the type
    of the lambda.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里我们可以看到，单独的表达式`() -> 42`是不完整的。Java lambda 表达式依赖于类型推断，因此我们需要看到表达式与其目标类型结合在一起才有意义。与目标类型组合时，lambda
    的类类型是“一个在编译时未知的目标接口的实现”，程序员必须将接口类型作为 lambda 的类型使用。
- en: Beyond lambdas, there are some corner cases of nominal typing in Java. One example
    is anonymous classes, but even here the types still have names. However, the type
    names of anonymous types are automatically generated by the compiler and are specially
    chosen so as to be usable by the JVM but not accepted by the Java source code
    compiler.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 除了lambda之外，在Java中还有一些名义类型的边缘情况。一个例子是匿名类，但即使在这里，类型仍然有名称。然而，匿名类型的类型名称是由编译器自动生成的，并且专门选择以便JVM可以使用但Java源代码编译器不接受。
- en: There is one other corner case that we should consider, and it relates to the
    enhanced type inference introduced in recent Java versions.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种边缘情况需要考虑，它与近期Java版本引入的增强类型推断有关。
- en: Nondenotable Types and var
  id: totrans-586
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非标记类型和`var`
- en: 'From Java 11 onwards (actually introduced in the Java 10 non-LTS release),
    Java developers can make use of a new language feature *Local Variable Type Inference*
    (LVTI), otherwise known as `var`. This is an enhancement to Java’s type inference
    capabilities that may prove to be more significant than it first appears. In the
    simplest case, it allows code such as:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 从Java 11开始（实际上是在Java 10非LTS版本中引入），Java开发人员可以利用新的语言特性*局部变量类型推断*（LVTI），又称`var`。这是Java类型推断能力的增强，可能比一开始看起来更重要。在最简单的情况下，它允许如下代码：
- en: '[PRE68]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: which moves the inference from the type of values to the type of variables.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 将推断从值的类型移到变量的类型。
- en: The implementation achieves this by making `var` a reserved type name rather
    than a keyword. This means that code can still use `var` as a variable, method,
    or package name without being affected by the new syntax. However, code that has
    previously used `var` as the name of a type will have to be recompiled.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 实现方法是将`var`作为保留的类型名称而不是关键字。这意味着代码仍然可以将`var`用作变量、方法或包名，而不受新语法的影响。然而，先前将`var`用作类型名称的代码将需要重新编译。
- en: This simple case is designed to reduce verbosity and to make programmers coming
    to Java from other languages (especially Scala, .NET, and JavaScript) feel more
    comfortable. However, it does carry the risk that overuse will potentially obscure
    the intent of the code being written, so it should be used sparingly.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的案例旨在减少冗长，并使从其他语言（特别是Scala、.NET和JavaScript）转到Java的程序员感觉更舒适。然而，过度使用可能会模糊编写代码的意图，因此应该谨慎使用。
- en: 'As well as the simple cases, `var` actually permits programming constructs
    that were not possible before. To see the differences, let’s consider that `javac`
    has always permitted a very limited form of type inference:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 除了简单的情况外，`var`实际上允许了以前不可能的编程构造。为了看到差异，让我们考虑`javac`一直允许的一种非常有限的类型推断：
- en: '[PRE69]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The code will compile and run, printing out `bar!`. This slightly counterintuitive
    result occurs because `javac` preserves enough type information about the anonymous
    class (i.e., that it has a `bar()` method) for just long enough that the compiler
    can conclude that the call to `bar()` is valid.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将编译并运行，打印出`bar!`。这种略显反直觉的结果发生是因为`javac`保留了关于匿名类的足够类型信息（即它有一个`bar()`方法），以至于编译器可以推断调用`bar()`是有效的。
- en: In fact, this edge case has been [known in the Java community](https://oreil.ly/RVqng)
    since at least 2009, long before the arrival of Java 7.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这种边缘情况自2009年以来就在[Java社区中已知](https://oreil.ly/RVqng)，早在Java 7到来之前。
- en: 'The problem with this form of type inference is that it has no real practical
    applications: the type of “Object-with-a-bar-method” exists within the compiler,
    but the type is impossible to express as the type of a variable—it is not a *denotable
    type*. This means that before Java 10, the existence of this type is restricted
    to a single expression and cannot be used in a larger scope.'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型推断的问题在于它没有真正的实际应用：“带有bar方法的对象”的类型存在于编译器中，但是这种类型无法表达为变量的类型——它不是一个*可标记的类型*。这意味着在Java
    10之前，这种类型的存在仅限于单个表达式，不能在更大的范围内使用。
- en: With the arrival of LVTI, however, the type of variables does not always need
    to be made explicit. Instead, we can use `var` to allow us to preserve the static
    type information by avoiding denoting the type.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着LVTI的到来，变量的类型并不总是需要显式指定。相反，我们可以使用`var`来允许我们通过避免指定类型来保留静态类型信息。
- en: 'This means we can now modify our example and write:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着现在我们可以修改我们的示例并编写：
- en: '[PRE70]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This has allowed us to preserve the true type of `o` beyond a single expression.
    The type of `o` cannot be denoted, and so it cannot appear as the type of either
    a method parameter or return type. This means the type is still limited to only
    a single method, but it is still useful to express some constructions that would
    be awkward or impossible otherwise.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得我们能够在单个表达式之外保留`o`的真实类型。`o`的类型不能被指定，因此它不能作为方法参数或返回类型的类型出现。这意味着类型仍然仅限于单个方法，但仍然可以用于表达某些在其他情况下会很尴尬或不可能的结构。
- en: This use of `var` as a “magic type” allows the programmer to preserve type information
    for each distinct usage of `var`, in a way that is somewhat reminiscent of bounded
    wildcards from Java’s generics.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 将`var`用作“魔术类型”允许程序员为每个`var`的不同使用保留类型信息，这在某种程度上类似于Java泛型的有界通配符。
- en: More advanced usages of `var` with nondenotable types [are possible](https://oreil.ly/p0w-a).
    While the feature is not able to satisfy every criticism of Java’s type system,
    it does represent a definite (if cautious) step forward.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 更高级的`var`用法与非注记类型[是可能的](https://oreil.ly/p0w-a)。虽然这个特性不能满足所有对Java类型系统的批评，但它确实代表了一个明确（尽管谨慎）的进步步骤。
- en: Summary
  id: totrans-603
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: 'By examining Java’s type system, we have been able to build up a clear picture
    of the worldview that the Java platform has about data types. Java’s type system
    can be characterized as:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 通过分析Java的类型系统，我们已经能够建立起Java平台对数据类型的世界观的清晰图景。Java的类型系统可以被描述为：
- en: Static
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 静态的
- en: All Java variables have types that are known at compile time.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的Java变量在编译时都有已知的类型。
- en: Nominal
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 名义上的
- en: The name of a Java type is of paramount importance. Java does not permit structural
    types and has only limited support for nondenotable types.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: Java类型的名称至关重要。Java不允许结构类型，并且对于非注记类型的支持有限。
- en: Object/imperative
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象/命令式
- en: Java code is object-oriented, and all code must live inside methods, which must
    live inside classes. However, Java’s primitive types prevent full adoption of
    the “everything is an object” worldview.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: Java代码是面向对象的，所有的代码必须存在于方法中，方法必须存在于类中。然而，Java的原始类型阻止了对“一切皆对象”的完全采纳。
- en: Slightly functional
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 稍微具有函数式特征
- en: Java provides support for some of the more common functional idioms but more
    as a convenience to programmers than anything else.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: Java提供对一些常见的函数式习语的支持，但更多作为程序员的便利而非其他。
- en: Type-inferred
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 类型推断
- en: Java is optimized for readability (even by novice progammers) and prefers to
    be explicit but uses type inference to reduce boilerplate where it does not impact
    the legibility of the code.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: Java优化了代码的可读性（即使是对初学者），并倾向于显式声明，但在不影响代码可读性的情况下使用类型推断来减少样板代码。
- en: Strongly backward compatible
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 强大的向后兼容性
- en: Java is primarily a business-focused language, and backward compatibility and
    protection of existing codebases are very high priorities.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: Java主要是面向业务的语言，向后兼容性和保护现有代码库是非常高的优先事项。
- en: Type erased
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 类型擦除
- en: Java permits parameterized types, but this information is not available at runtime.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: Java允许参数化类型，但这些信息在运行时不可用。
- en: Java’s type system has evolved (albeit slowly and cautiously) over the years—and
    is now on par with the type systems of other mainstream programming languages.
    Lambda expressions, along with default methods, represent the greatest transformation
    since the advent of Java 5 and the introduction of generics, annotations, and
    related innovations.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: Java的类型系统经过多年的演进（尽管缓慢而谨慎），现在与其他主流编程语言的类型系统处于同一水平。Lambda表达式与默认方法一起，代表了自Java 5问世以来最大的转变，以及泛型、注解及相关创新的引入。
- en: Default methods represent a major shift in Java’s approach to object-oriented
    programming—perhaps the biggest since the language’s inception. From Java 8 onward,
    interfaces can contain implementation code. This fundamentally changes Java’s
    nature. Previously a single-inherited language, Java is now multiply inherited
    (but only for behavior—there is still no multiple inheritance of state).
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 默认方法代表了Java面向对象编程方法的一个重大转变，也许是自语言问世以来最大的转变。从Java 8开始，接口可以包含实现代码。这从根本上改变了Java的性质。此前是单继承语言的Java，现在在行为上可以多继承（但仅限于行为，状态仍然不支持多继承）。
- en: Despite all of these innovations, Java’s type system is not (and is not intended
    to be) equipped with the power of the type systems of languages such as Scala
    or Haskell. Instead, Java’s type system is strongly biased in favor of simplicity,
    readability, and a simple learning curve for newcomers.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有所有这些创新，Java 的类型系统并没有（也不打算）配备类似于 Scala 或 Haskell 等语言的类型系统的强大能力。相反，Java 的类型系统在简洁性、可读性和新手学习曲线方面都倾向于简单。
- en: Java has also benefited enormously from the approaches to types developed in
    other languages over the last 10 years. Scala’s example of a statically typed
    language that nevertheless achieves much of the feel of a dynamically typed language
    through the use of type inference has been a good source of ideas for features
    to add to Java, even though the languages have quite different design philosophies.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 过去 10 年，Java 也从其他语言中开发的类型方法中受益匪浅。Scala 作为一种静态类型语言的例子，通过使用类型推断实现了很多动态类型语言的感觉，为
    Java 添加特性提供了很好的思路，即使这两种语言有着非常不同的设计理念。
- en: One remaining question is whether the modest support for functional idioms that
    lambda expressions provide in Java is sufficient for the majority of Java programmers.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然有一个问题是，Java 中 Lambda 表达式提供的对函数式习惯的适度支持是否足以满足大多数 Java 程序员的需求。
- en: Note
  id: totrans-624
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注：
- en: The long-term direction of Java’s type system is being explored in research
    projects such as Valhalla, where concepts such as data classes, pattern matching,
    and sealed classes are being explored.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: Java 的类型系统的长期发展方向正在研究项目中探索，例如 Valhalla，其中正在探索诸如数据类、模式匹配和密封类等概念。
- en: It remains to be seen whether the majority of ordinary Java programmers require
    the added power—and attendant complexity—that comes from an advanced (and much
    less nominal) type system such as Scala’s, or whether the “slightly functional
    programming” introduced in Java 8 (e.g., *map*, *filter*, *reduce*, and their
    peers) will suffice for most developers’ needs.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 尚待观察的是，普通 Java 程序员是否需要像 Scala 那样的高级（且远非名义上的）类型系统所带来的更大能力——以及随之而来的复杂性，还是 Java
    8 中引入的“稍微函数式编程”（例如 *map*、*filter*、*reduce* 等）已经足够满足大多数开发者的需求。
- en: ^([1](ch04.xhtml#idm45927740773536-marker)) Some small traces of generics remain,
    which can be seen at runtime via reflection.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch04.xhtml#idm45927740773536-marker)) 一些泛型的小痕迹仍然存在，可以通过反射在运行时看到。
- en: '^([2](ch04.xhtml#idm45927740053936-marker)) Raoul-Gabriel Urma and Janina Voigt,
    “Using the OpenJDK to Investigate Covariance in Java,” *Java Magazine* (May/June
    2012): 44–47.'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch04.xhtml#idm45927740053936-marker)) Raoul-Gabriel Urma 和 Janina Voigt，“使用
    OpenJDK 探究 Java 中的协变”，*Java Magazine*（2012 年 5 月/6 月）：44–47。
