- en: Chapter 7\. Programming and Documentation Conventions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第七章。编程和文档约定
- en: 'This chapter explains a number of important and useful Java programming and
    documentation conventions. It covers:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章解释了许多重要且有用的 Java 编程和文档约定。它涵盖了：
- en: General naming and capitalization conventions
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一般的命名和大小写约定
- en: Portability tips and conventions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可移植性提示和约定
- en: '`javadoc` documentation comment syntax and conventions'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javadoc` 文档注释语法和约定'
- en: Naming and Capitalization Conventions
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名和大小写约定
- en: 'The following widely adopted naming conventions apply to modules, packages,
    reference types, methods, fields, and constants in Java. Because these conventions
    are almost universally followed and because they affect the public API of the
    classes you define, you should adopt them as well:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 以下广泛采用的命名约定适用于 Java 中的模块、包、引用类型、方法、字段和常量。由于这些约定几乎被普遍遵循，并且因为它们影响你所定义的类的公共 API，你应该也要采用它们：
- en: Modules
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 模块
- en: As modules are the preferred unit of distribution for Java applications from
    Java 9 onward, you should take special care when naming them.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 由于从 Java 9 开始，模块是 Java 应用程序的首选分发单元，所以当命名它们时应特别小心。
- en: Module names must be globally unique—the modules system is essentially predicated
    on this assumption. As modules are effectively super packages (or aggregates of
    packages), the module name should be closely related to the package names grouped
    into the module. One recommended way to do this is to group the packages within
    a module and use the *root name* of the packages as the module name. For example,
    if an application’s packages all live under `com.mycompany.*`, then `com.mycompany`
    is a good name for your module.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 模块名必须是全局唯一的——模块系统基本上是以此假设为前提的。由于模块实际上是超级包（或者包的聚合），模块名应与分组到模块中的包名密切相关。一个推荐的做法是将包分组到模块中，并使用包的
    *根名称* 作为模块名。例如，如果一个应用程序的所有包都位于 `com.mycompany.*` 下，则 `com.mycompany` 是你的模块的一个好名字。
- en: Packages
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 包
- en: It is customary to ensure that your publicly visible package names are unique.
    One common way of doing this is by prefixing them with the inverted name of an
    internet domain that you own (e.g., `com.oreilly.javanutshell`).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 通常习惯确保你公开可见的包名是唯一的。一种常见的做法是用你拥有的互联网域名的倒置名称作为前缀（例如，`com.oreilly.javanutshell`）。
- en: This convention is now followed less strictly than it used to be, with some
    projects merely adopting a simple, recognizable, and unique prefix instead. All
    package names should be lowercase.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在对这个约定的严格遵循已经不像以前那样严格了，一些项目仅仅采用一个简单、可识别且唯一的前缀。所有包名应该是小写的。
- en: Classes
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 类
- en: A type name should begin with a capital letter and be written in mixed case
    (e.g., `String`). This is usually referred to as *Pascal case*. If a class name
    consists of more than one word, each word should begin with a capital letter (e.g.,
    `StringBuffer`). If a type name, or one of the words of a type name, is an acronym,
    the acronym can be written in all capital letters (e.g., `URL`, `HTMLParser`).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 类型名应该以大写字母开头，并使用驼峰命名法（例如，`String`）。这通常被称为 *帕斯卡命名法*。如果一个类名由多个单词组成，每个单词应该以大写字母开头（例如，`StringBuffer`）。如果类型名或类型名中的一个词是一个首字母缩写词，那么首字母缩写词可以用全大写字母来书写（例如，`URL`，`HTMLParser`）。
- en: Because classes and enumerated types are designed to represent objects, you
    should choose class names that are nouns (e.g., `Thread`, `Teapot`, `FormatConverter`).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 因为类和枚举类型被设计用来表示对象，所以你应该选择名词作为类名（例如，`Thread`，`Teapot`，`FormatConverter`）。
- en: Enum types are a special case of a class with a finite number of instances.
    They should be named as nouns in all but highly exceptional circumstances. The
    constants defined by `enum` types are also typically written in all capital letters,
    as per the rules for constants below.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举类型是具有有限实例数量的类的特殊情况。除非是非常特殊的情况，它们应该被命名为名词。`enum` 类型定义的常量通常也是按照下面的常量规则写成全大写字母。
- en: Interfaces
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 接口
- en: 'Java programmers typically use interfaces in one of two ways: either to convey
    that a class has additional, supplementary aspects or behaviors; or to indicate
    that the class is one possible implementation of an interface for which there
    are multiple valid implementation choices.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Java 程序员通常以以下两种方式使用接口：要么传达一个类具有额外的、补充的方面或行为；要么指示该类是接口的一个可能的实现，而对于这个接口有多种有效的实现选择。
- en: When an interface is used to provide additional information about the classes
    that implement it, it is common to choose an interface name that is an adjective
    (i.e., `Runnable`, `Cloneable`, `Serializable`).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个接口用于提供关于实现它的类的附加信息时，通常选择一个形容词作为接口名称（例如 `Runnable`，`Cloneable`，`Serializable`）。
- en: When an interface is intended to work more like an abstract superclass, use
    a name that is a noun (e.g., `Document`, `FileNameMap`, `Collection`). It is conventional
    to not indicate via the name that it is an interface (i.e., don’t use `IDocument`
    or `DocumentInterface`).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个接口旨在更像一个抽象超类时，使用名词作为名称（例如，`Document`，`FileNameMap`，`Collection`）。按照惯例，不要通过名称表明它是一个接口（即不要使用
    `IDocument` 或 `DocumentInterface`）。
- en: Methods
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 方法
- en: A method name always begins with a lowercase letter. If the name contains more
    than one word, every word after the first begins with a capital letter (e.g.,
    `insert()`, `insertObject()`, `insertObjectAt()`). This is usually referred to
    as *camel case*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 方法名始终以小写字母开头。如果名称包含多个单词，则从第二个单词开始每个单词的首字母大写（例如，`insert()`，`insertObject()`，`insertObjectAt()`）。这通常被称为*驼峰命名法*。
- en: Method names are typically chosen so that the first word is a verb. Method names
    can be as long as is necessary to make their purpose clear, but choose succinct
    names where possible. Avoid overly general method names, such as `performAction()`,
    `go()`, or the dreadful `doIt()`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 方法名称通常选择使第一个单词为动词。方法名称可以尽可能长以清晰表达其目的，但在可能的情况下选择简洁的名称。避免过于通用的方法名称，如 `performAction()`，`go()`，或可怕的
    `doIt()`。
- en: Fields and constants
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 字段和常量
- en: Nonconstant field names follow the same capitalization conventions as method
    names. A field name should be chosen to best describe the purpose of the field
    or the value it holds. Prefixes to indicate types or visibility of fields are
    discouraged.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 非常量字段名称遵循与方法名称相同的大写规范。应选择最能描述字段用途或值的名称。不鼓励使用前缀来指示字段的类型或可见性。
- en: If a field is a `static final` constant, it should be written in all uppercase.
    If the name of a constant includes more than one word, the words should be separated
    with underscores (e.g., `MAX_VALUE`).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个字段是 `static final` 常量，则应使用全大写字母编写。如果常量的名称包含多个单词，则应使用下划线分隔这些单词（例如，`MAX_VALUE`）。
- en: Parameters
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: Method parameters follow the same capitalization conventions as nonconstant
    fields. The names of method parameters appear in the documentation for a method,
    so you should choose names that make the purpose of the parameters as clear as
    possible. Try to keep parameter names to a single word and use them consistently.
    For example, if a `WidgetProcessor` class defines many methods that accept a `Widget`
    object as the first parameter, name this parameter `widget`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 方法参数遵循与非常量字段相同的大写规范。方法参数的名称出现在方法的文档中，因此应选择能够尽可能清楚地表明参数用途的名称。尽量将参数名称保持为单个单词，并且在使用时保持一致。例如，如果一个
    `WidgetProcessor` 类定义了许多接受 `Widget` 对象作为第一个参数的方法，则将该参数命名为 `widget`。
- en: Local variables
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 局部变量
- en: Local variable names are an implementation detail and never visible outside
    your class. Nevertheless, choosing good names makes your code easier to read,
    understand, and maintain. Variables are typically named following the same conventions
    as methods and fields.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 局部变量名称是实现细节，从不在类外部可见。尽管如此，选择良好的名称可以使您的代码更易于阅读、理解和维护。通常，变量的命名遵循与方法和字段相同的约定。
- en: In addition to the conventions for specific types of names, there are conventions
    regarding the characters you should use in your names. Java allows the `$` character
    in any identifier, but, by convention, its use is reserved for synthetic names
    generated by source-code processors. For example, it is used by the Java compiler
    to make inner classes work. You should not use the `$` character in any name that
    you create.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 除了特定类型名称的约定外，还有关于您应在名称中使用哪些字符的约定。Java 允许在任何标识符中使用 `$` 字符，但按照惯例，其使用应保留给源代码处理器生成的合成名称。例如，Java
    编译器用它来使内部类工作。不应在您创建的任何名称中使用 `$` 字符。
- en: Java allows names to use any alphanumeric characters from the entire Unicode
    character set. While this can be convenient for non-English-speaking programmers,
    Unicode use has never really taken off, and this usage is extremely rare.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Java 允许名称使用来自整个 Unicode 字符集的任何字母数字字符。虽然这对于非英语系程序员来说可能很方便，但 Unicode 的使用从未真正普及，这种用法非常罕见。
- en: Practical Naming
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实用命名
- en: The names we give to our constructs matter—a lot. Naming is a key part of the
    process that conveys our abstract designs to our peers. The process of transferring
    a software design from one human mind to another is hard—harder, in many cases,
    than the process of transferring our design from our mind to the machines that
    will execute it.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们赋予构造物的名称非常重要。命名是将我们的抽象设计传达给同行的关键过程。将软件设计从一个人的头脑转移到另一个人的头脑的过程很难——在许多情况下，比将我们的设计从头脑转移到将执行它的机器更难。
- en: 'We must, therefore, do everything we can to ensure that this process is eased.
    Names are a keystone of this. When reviewing code (and all code should be reviewed),
    pay particular attention to the names that have been chosen:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们必须尽一切努力确保这一过程得以简化。名称是这一过程的关键。在审查代码时（所有代码都应该经过审查），特别注意已选择的名称：
- en: Do the names of the types reflect the purpose of those types?
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型的名称是否反映了这些类型的目的？
- en: Does each method do exactly what its name suggests? Ideally, no more and no
    less?
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个方法是否确切地执行其名称所暗示的操作？理想情况下，既不多也不少？
- en: Are the names descriptive enough? Could a more specific name be used instead?
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称是否足够描述性？是否可以使用更具体的名称？
- en: Are the names well suited for the domain they describe?
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些名称是否适合描述它们所描述的领域？
- en: Are the names consistent across the domain?
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称是否在整个领域中保持一致？
- en: Do the names mix metaphors?
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称是否混合了隐喻？
- en: Does the name reuse a common term of software engineering?
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称是否重复使用了软件工程中的常见术语？
- en: Do the names of boolean-returning methods include negation? These often need
    more attention to understand when reading (e.g., `notEnabled()` vs. `enabled()`)
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔返回方法的名称是否包括否定？这些通常需要更多注意力才能理解（例如，`notEnabled()` vs. `enabled()`）。
- en: Mixed metaphors are common in software, especially after several releases of
    an application. A system that starts off perfectly reasonably with components
    called `Receptionist` (for handling incoming connections), `Scribe` (for persisting
    orders), and `Auditor` (for checking and reconciling orders) can quite easily
    end up in a later release with a class called `Watchdog` for restarting processes.
    This isn’t terrible, but it breaks the established pattern of people’s job titles
    that previously existed.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件中，混合隐喻很常见，尤其是在应用程序发布了几个版本之后。一个系统最初完全合理地使用称为`Receptionist`（用于处理传入连接）、`Scribe`（用于持久化订单）和`Auditor`（用于检查和调解订单）的组件，很容易在后续版本中以一个称为`Watchdog`的类结束，用于重新启动进程。这并不是很糟糕，但它打破了先前存在的人们职称的已建立模式。
- en: It is also incredibly important to realize that software changes a lot over
    time. A perfectly apposite name on release 1 can become highly misleading by release
    4\. Care should be taken that as the system focus and intent shift, the names
    are refactored along with the code. Modern IDEs have no problem with global search
    and replace of symbols, so there is no need to cling to outdated metaphors once
    they are no longer useful.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一点非常重要，那就是要意识到软件随时间变化很多。发布第1版时非常适当的名称可能到第4版时已经非常误导。应该注意的是，随着系统的重心和意图的变化，名称应该与代码一起进行重构。现代
    IDE 对全局搜索和替换符号没有问题，因此在不再有用时没有必要固守过时的隐喻。
- en: 'One final note of caution: an overly strict interpretation of these guidelines
    can lead the developer to some very odd naming constructs. There are a number
    of excellent descriptions of some of the absurdities that can result by taking
    these conventions to their extremes.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要注意的一点是：过于严格地解释这些指南可能会导致开发人员产生一些非常奇怪的命名结构。有许多优秀的描述，说明了将这些约定推向极端可能导致的一些荒谬行为。
- en: In other words, none of the conventions described here is mandatory. Following
    them will, in the vast majority of cases, make your code easier to read and maintain.
    However, you should not be afraid to deviate from these guidelines if it makes
    your code easier to read and understand.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，这里描述的约定并非强制性的。在绝大多数情况下，遵循它们将使您的代码更易于阅读和维护。但是，如果因为更易于阅读和理解而偏离这些指南，也不必害怕。
- en: Break any of these rules rather than say anything outright barbarous.
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 宁可违反这些规则，也不要说出任何显得十分粗野的话。
- en: ''
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: George Orwell
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 乔治·奥威尔
- en: Above all, you should have a sense of the expected lifetime of the code you
    are writing. A risk calculation system in a bank may have a lifetime of a decade
    or more, whereas a prototype for a startup may be relevant for only a few weeks.
    Document accordingly—the longer the code is likely to be live, the better its
    documentation and naming need to be.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，您应该对您编写的代码预期的寿命有所了解。银行中的风险计算系统可能有十年或更长的寿命，而初创公司的原型可能仅在几周内相关。因此，需要相应地进行文档编写
    - 代码越长时间活跃，其文档和命名就需要越好。
- en: Java Documentation Comments
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java文档注释
- en: Most ordinary comments within Java code explain the implementation details of
    that code. By contrast, the Java language specification defines a special type
    of comment known as a *doc comment* that serves to document the API of your code.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Java代码中的大多数普通注释解释了该代码的实现细节。相比之下，Java语言规范定义了一种特殊类型的注释，称为*文档注释*，用于记录您代码的API。
- en: A doc comment is an ordinary multiline comment that begins with `/**` (instead
    of the usual `/*`) and ends with `*/`. A doc comment appears immediately before
    a type or member definition and contains documentation for that type or member.
    The documentation can include simple HTML formatting tags and other special keywords
    that provide additional information.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 文档注释是普通的多行注释，以`/**`开头（而不是通常的`/*`），以`*/`结尾。文档注释出现在类型或成员定义之前，包含该类型或成员的文档。文档可以包括简单的HTML格式化标记和其他特殊关键字，提供额外的信息。
- en: Doc comments are ignored by the compiler, but they can be extracted and automatically
    turned into online HTML documentation by the `javadoc` program. (See [Chapter 13](ch13.xhtml#javanut8-CHP-13)
    for more information about `javadoc`.)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器会忽略文档注释，但可以通过`javadoc`程序提取并自动转换为在线HTML文档（请参阅[第13章](ch13.xhtml#javanut8-CHP-13)以获取有关`javadoc`的更多信息）。
- en: 'Here is an example class that contains appropriate doc comments:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个包含适当文档注释的示例类：
- en: '[PRE0]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Structure of a Doc Comment
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文档注释的结构
- en: The body of a doc comment should begin with a one-sentence summary of the type
    or member being documented. This sentence may be displayed by itself as summary
    documentation, so it should be written to stand on its own. The initial sentence
    may be followed by any number of other sentences and paragraphs that describe
    the class, interface, method, or field in full detail.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 文档注释的正文应以对被记录的类型或成员的一句摘要开始。这句话可能会单独显示为摘要文档，因此应编写得能够独立存在。初始句子后面可以跟随任意数量的其他句子和段落，详细描述类、接口、方法或字段。
- en: After the descriptive paragraphs, a doc comment can contain any number of other
    paragraphs, each of which begins with a special doc-comment tag, such as `@author`,
    `@param`, or `@returns`. These tagged paragraphs provide specific information
    about the class, interface, method, or field that the `javadoc` program displays
    in a standard way. The full set of doc-comment tags is listed in the next section.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在描述性段落之后，文档注释可以包含任意数量的其他段落，每个段落以特殊的文档注释标签开头，例如`@author`、`@param`或`@returns`。这些标记段落为`javadoc`程序以标准方式显示提供了有关类、接口、方法或字段的具体信息。文档注释标签的完整集合将在下一节中列出。
- en: The descriptive material in a doc comment can contain simple HTML markup tags,
    such as `<i>` for emphasis; `<code>` for class, method, and field names; and `<pre>`
    for multiline code examples. It can also contain `<p>` tags to break the description
    into separate paragraphs and `<ul>`, `<li>`, and related tags to display bulleted
    lists and similar structures. Remember, however, that the material you write is
    embedded within a larger, more complex HTML document. For this reason, doc comments
    should not contain major structural HTML tags, such as `<h2>` or `<hr>`, that
    might interfere with the structure of the larger document.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 文档注释中的描述材料可以包含简单的HTML标记，如用于强调的`<i>`；用于类、方法和字段名称的`<code>`；以及用于多行代码示例的`<pre>`。它还可以包含`<p>`标记以将描述分隔成单独的段落，以及`<ul>`、`<li>`和相关标记以显示项目符号列表和类似结构。但请记住，您编写的材料嵌入在更大、更复杂的HTML文档中。因此，文档注释不应包含可能干扰更大文档结构的主要结构HTML标记，如`<h2>`或`<hr>`。
- en: Avoid the use of the `<a>` tag to include hyperlinks or cross-references in
    your doc comments. Instead, use the special `{@link}` doc-comment tag, which,
    unlike the other doc-comment tags, can appear anywhere within a doc comment. As
    described in the next section, the `{@link}` tag allows you to specify hyperlinks
    to other classes, interfaces, methods, and fields without knowing the HTML-structuring
    conventions and filenames used by `javadoc`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 避免在文档注释中使用 `<a>` 标签来包含超链接或交叉引用。相反，请使用特殊的 `{@link}` 文档注释标签，与其他文档注释标签不同，它可以出现在文档注释的任何位置。正如在下一节所述，`{@link}`
    标签允许您指定到其他类、接口、方法和字段的超链接，而无需了解 `javadoc` 使用的 HTML 结构约定和文件名。
- en: 'If you want to include an image in a doc comment, place the image file in a
    *doc-files* subdirectory of the source code directory. Give the image the same
    name as the class, with an integer suffix. For example, the second image that
    appears in the doc comment for a class named `Circle` can be included with this
    HTML tag:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要在文档注释中包含图像，请将图像文件放置在源代码目录的 *doc-files* 子目录中。将图像命名为与类相同，并带有整数后缀。例如，名为 `Circle`
    类文档注释中的第二个图像可以使用以下HTML标签包含：
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Because the lines of a doc comment are embedded within a Java comment, any leading
    spaces and asterisks (`*`) are stripped from each line of the comment before processing.
    Thus, you don’t need to worry about the asterisks appearing in the generated documentation
    or about the indentation of the comment affecting the indentation of code examples
    included within the comment with a `<pre>` tag.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 因为文档注释的行被嵌入在Java注释中，每行注释的开头空格和星号 (`*`) 在处理之前都会被去除。因此，您不需要担心星号出现在生成的文档中，也不需要担心注释的缩进会影响使用
    `<pre>` 标签包含在注释中的代码示例的缩进。
- en: Doc-Comment Tags
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文档注释标签
- en: The `javadoc` program recognizes a number of special tags, each of which begins
    with an `@` character. These doc-comment tags allow you to encode specific information
    into your comments in a standardized way, and they allow `javadoc` to choose the
    appropriate output format for that information. For example, the `@param` tag
    lets you specify the name and meaning of a single parameter for a method. `javadoc`
    can extract this information and display it using an HTML `<dl>` list, an HTML
    `<table>`, or whatever it sees fit.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`javadoc` 程序识别一些特殊标签，每个标签以 `@` 字符开头。这些文档注释标签允许您以标准化的方式将特定信息编码到您的注释中，并允许 `javadoc`
    选择适合该信息的输出格式。例如，`@param` 标签允许您指定方法的单个参数的名称和含义。`javadoc` 可以提取此信息并使用HTML `<dl>`
    列表、HTML `<table>` 或其他适合的方式显示它。'
- en: 'The following doc-comment tags are recognized by `javadoc`; a doc comment should
    typically use these tags in the order listed here:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`javadoc`所识别的文档注释标签；一个文档注释应按照这里列出的顺序使用这些标签：
- en: '`@author` *`name`*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`@author` *`name`*'
- en: 'Adds an “Author:” entry that contains the specified name. This tag should be
    used for every class or interface definition but must not be used for individual
    methods and fields. If a class has multiple authors, use multiple `@author` tags
    on adjacent lines. For example:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个包含指定名称的“Author:”条目。这个标签应该用于每个类或接口的定义，但不能用于单独的方法和字段。如果一个类有多个作者，可以在相邻的行上使用多个
    `@author` 标签。例如：
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: List the authors in chronological order, with the original author first. If
    the author is unknown, you can use “unascribed.” `javadoc` does not output authorship
    information unless the `-author` command-line argument is specified.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 按照时间顺序列出作者，首先是原始作者。如果作者未知，您可以使用“未署名”。除非指定了 `-author` 命令行参数，否则 `javadoc` 不会输出作者信息。
- en: '`@version` *`text`*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`@version` *`text`*'
- en: 'Inserts a “Version:” entry that contains the specified text. For example:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 插入一个包含指定文本的“Version:”条目。例如：
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This tag should be included in every class and interface doc comment but cannot
    be used for individual methods and fields. This tag is often used in conjunction
    with the automated version-numbering capabilities of a version control system,
    such as git, Perforce, or SVN. `javadoc` does not output version information in
    its generated documentation unless the `-version` command-line argument is specified.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个标签应该包含在每个类和接口的文档注释中，但不能用于单独的方法和字段。这个标签通常与版本控制系统（如git、Perforce或SVN）的自动版本编号功能一起使用。除非指定了
    `-version` 命令行参数，否则`javadoc`不会在生成的文档中输出版本信息。
- en: '`@param` *`parameter-name`* *`description`*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`@param` *`parameter-name`* *`description`*'
- en: Adds the specified parameter and its description to the “Parameters:” section
    of the current method. The doc comment for a method or constructor must contain
    one `@param` tag for each parameter the method expects. These tags should appear
    in the same order as the parameters specified by the method. The tag can be used
    only in doc comments for methods and constructors.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 将指定的参数及其描述添加到当前方法的“Parameters:”部分。方法或构造函数的文档注释必须包含方法期望的每个参数的一个`@param`标记。这些标记应按方法指定的参数顺序出现。此标记仅可用于方法和构造函数的注释。
- en: 'You are encouraged to use phrases and sentence fragments where possible to
    keep the descriptions brief. However, if a parameter requires detailed documentation,
    the description can wrap onto multiple lines and include as much text as necessary.
    For readability in source-code form, consider using spaces to align the descriptions
    with each other. For example:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 鼓励您在可能的情况下使用短语和句子片段，以保持描述的简洁性。但是，如果一个参数需要详细的文档，描述可以换行并包含尽可能多的文本。为了在源代码形式中的可读性，考虑使用空格来对齐描述。例如：
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`@return` *`description`*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`@return` *`description`*'
- en: 'Inserts a “Returns:” section that contains the specified description. This
    tag should appear in every doc comment for a method, unless the method returns
    `void` or is a constructor. The description can be as long as necessary, but consider
    using a sentence fragment to keep it short. For example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 插入一个包含指定描述的“Returns:”部分。除非方法返回`void`或是构造函数，否则该标记应出现在每个方法的文档注释中。描述可以尽可能长，但考虑使用句子片段以保持简短。例如：
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`@exception` *`full-classname description`*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`@exception` *`full-classname description`*'
- en: 'Adds a “Throws:” entry that contains the specified exception name and description.
    A doc comment for a method or constructor should contain an `@exception` tag for
    every checked exception that appears in its `throws` clause. For example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个包含指定异常名称和描述的“Throws:”条目。方法或构造函数的文档注释应该为其`throws`子句中出现的每个已检查异常包含一个`@exception`标记。例如：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `@exception` tag can optionally be used to document unchecked exceptions
    (i.e., subclasses of `RuntimeException`) the method may throw, when these are
    exceptions that a user of the method may reasonably want to catch. If a method
    can throw more than one exception, use multiple `@exception` tags on adjacent
    lines and list the exceptions in alphabetical order. The description can be as
    short or as long as necessary to describe the significance of the exception. This
    tag can be used only for method and constructor comments. The `@throws` tag is
    a synonym for `@exception`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当方法可能抛出用户可能希望捕获的未检查异常（即`RuntimeException`的子类）时，可以选择使用`@exception`标记。如果方法可能抛出多个异常，请在相邻的行上使用多个`@exception`标记，并按字母顺序列出异常。描述可以简短或长到足以描述异常的重要性。此标记仅可用于方法和构造函数的注释。`@throws`标记是`@exception`的同义词。
- en: '`@throws` *`full-classname description`*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`@throws` *`full-classname description`*'
- en: This tag is a synonym for `@exception`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此标记是`@exception`的同义词。
- en: '`@see` *`reference`*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`@see` *`reference`*'
- en: Adds a “See Also:” entry that contains the specified reference. This tag can
    appear in any kind of doc comment. The syntax for the *`reference`* is explained
    in [“Cross-References in Doc Comments”](#javanut8-CHP-7-SECT-3.4).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个包含指定引用的“See Also:”条目。此标记可以出现在任何类型的文档注释中。*`reference`*的语法在 [“交叉引用在文档注释中”](#javanut8-CHP-7-SECT-3.4)
    中有解释。
- en: '`@deprecated` *`explanation`*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`@deprecated` *`explanation`*'
- en: 'This tag specifies that the following type or member has been deprecated and
    that its use should be avoided. `javadoc` adds a prominent “Deprecated” entry
    to the documentation and includes the specified *`explanation`* text. This text
    should specify when the class or member was deprecated and, if possible, suggest
    a replacement class or member and include a link to it. For example:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 该标记指定以下类型或成员已被弃用，应避免使用。`javadoc`在文档中添加一个突出显示的“Deprecated”条目，并包含指定的*`explanation`*文本。此文本应指明类或成员被弃用的时间，如果可能的话，建议替换类或成员，并包含指向其的链接。例如：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `@deprecated` tag is an exception to the general rule that `javac` ignores
    all comments. When this tag appears, the compiler notes the deprecation in the
    class file it produces. This allows it to issue warnings for other classes that
    rely on the deprecated feature.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`@deprecated`标记是`javac`忽略所有注释的一般规则的例外情况。当此标记出现时，编译器会在生成的类文件中记录此过时信息。这使得它能够为依赖于过时特性的其他类发出警告。'
- en: '`@since` *`version`*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`@since` *`version`*'
- en: 'Specifies when the type or member was added to the API. This tag should be
    followed by a version number or other version specification. For example:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 指定类型或成员添加到 API 的时间。此标签应跟随版本号或其他版本规范。例如：
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Every doc comment for a type should include an `@since` tag, and any members
    added after the initial release of the type should have `@since` tags in their
    doc comments.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类型的文档注释都应包括一个 `@since` 标签，而在类型的初始发布之后添加的任何成员应在其文档注释中具有 `@since` 标签。
- en: '`@serial` *`description`*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`@serial` *`描述`*'
- en: Technically, the way a class is serialized is part of its public API. If you
    write a class that you expect to be serialized, you should document its serialization
    format using `@serial` and the related tags listed next. `@serial` should appear
    in the doc comment for any field that is part of the serialized state of a `Serializable`
    class.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，类序列化的方式是其公共 API 的一部分。如果你编写了一个希望被序列化的类，你应该使用 `@serial` 和相关标签来记录其序列化格式，这些标签列在下面。对于任何作为
    `Serializable` 类序列化状态的一部分的字段，`@serial` 应该出现在其文档注释中。
- en: For classes that use the default serialization mechanism, this means all fields
    that are not declared `transient`, including fields declared `private`. The *`description`*
    should be a brief description of the field and of its purpose within a serialized
    object.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用默认序列化机制的类，这意味着所有非声明为 `transient` 的字段，包括声明为 `private` 的字段。*`描述`* 应为序列化对象中字段及其目的的简要描述。
- en: 'You can also use the `@serial` tag at the class and package level to specify
    whether a “serialized form page” should be generated for the class or package.
    The syntax is:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在类和包级别使用 `@serial` 标签来指定是否为类或包生成“序列化形式页面”。语法是：
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`@serialField` *`name type description`*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`@serialField` *`名称 类型 描述`*'
- en: A `Serializable` class can define its serialized format by declaring an array
    of `ObjectStreamField` objects in a field named `serialPersistentFields`. For
    such a class, the doc comment for `serialPersistentFields` should include an `@serialField`
    tag for each element of the array. Each tag specifies the name, type, and description
    for a particular field in the serialized state of the class.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 可序列化类可以通过在名为 `serialPersistentFields` 的字段中声明 `ObjectStreamField` 对象的数组来定义其序列化格式。对于这样的类，`serialPersistentFields`
    的文档注释应包括数组每个元素的 `@serialField` 标签。每个标签指定了类序列化状态中特定字段的名称、类型和描述。
- en: '`@serialData` *`description`*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`@serialData` *`描述`*'
- en: A `Serializable` class can define a `writeObject()` method to write data other
    than that written by the default serialization mechanism. An `Externalizable`
    class defines a `writeExternal()` method responsible for writing the complete
    state of an object to the serialization stream. The `@serialData` tag should be
    used in the doc comments for these `writeObject()` and `writeExternal()` methods,
    and the *`description`* should document the serialization format used by the method.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 可序列化类可以定义 `writeObject()` 方法来写入除了默认序列化机制之外的数据。`Externalizable` 类定义 `writeExternal()`
    方法来负责将对象的完整状态写入序列化流。应该在这些 `writeObject()` 和 `writeExternal()` 方法的文档注释中使用 `@serialData`
    标签，而 *`描述`* 则应该描述方法使用的序列化格式。
- en: Inline Doc-Comment Tags
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内联文档注释标签
- en: 'In addition to the preceding tags, `javadoc` also supports several *inline
    tags* that may appear anywhere that HTML text appears in a doc comment. Because
    these tags appear directly within the flow of HTML text, they require the use
    of curly braces as delimiters to separate the tagged text from the HTML text.
    Supported inline tags include the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面列出的标签外，`javadoc` 还支持几个内联标签，它们可以出现在文档注释中的 HTML 文本任何位置。由于这些标签直接出现在 HTML 文本的流中，它们需要使用大括号作为定界符，以将标记文本与
    HTML 文本分隔开。支持的内联标签包括：
- en: '`{@link` *`reference`* `}`'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`{@link` *`引用`* `}`'
- en: 'The `{@link}` tag is like the `@see` tag except that instead of placing a link
    to the specified *`reference`* in a special “See Also:” section, it inserts the
    link inline. An `{@link}` tag can appear anywhere that HTML text appears in a
    doc comment. In other words, it can appear in the initial description of the class,
    interface, method, or field and in the descriptions associated with the `@param`,
    `@returns`, `@exception`, and `@deprecated` tags. The *`reference`* for the `{@link}`
    tag uses the syntax described next in [“Cross-References in Doc Comments”](#javanut8-CHP-7-SECT-3.4).
    For example:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`{@link}` 标签类似于 `@see` 标签，不同之处在于它会在行内插入链接，而不是将链接放在特定的“See Also:”部分中。 `{@link}`
    标签可以出现在文档注释中的任何 HTML 文本位置。换句话说，它可以出现在类、接口、方法或字段的初始描述以及与 `@param`、`@returns`、`@exception`
    和 `@deprecated` 标签相关联的描述中。 `{@link}` 标签的 *`reference`* 使用下面 [“Cross-References
    in Doc Comments”](#javanut8-CHP-7-SECT-3.4) 中描述的语法。例如：'
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`{@linkplain` *`reference`* `}`'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`{@linkplain` *`reference`* `}`'
- en: The `{@linkplain}` tag is just like the `{@link}` tag, except that the text
    of the link is formatted using the normal font rather than the code font used
    by the `{@link}` tag. This is most useful when *`reference`* contains both a *`feature`*
    to link to and a *`label`* that specifies alternate text to be displayed in the
    link. See [“Cross-References in Doc Comments”](#javanut8-CHP-7-SECT-3.4) for more
    on the *`feature`* and *`label`* portions of the *`reference`* argument.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`{@linkplain}` 标签与 `{@link}` 标签类似，不同之处在于链接的文本使用正常字体而不是 `{@link}` 标签使用的代码字体。当
    *`reference`* 同时包含要链接到的 *`feature`* 和指定要在链接中显示的 *`label`* 时，这是最有用的。更多关于 *`reference`*
    参数中 *`feature`* 和 *`label`* 部分的信息，请参见 [“Cross-References in Doc Comments”](#javanut8-CHP-7-SECT-3.4)。'
- en: '`{@inheritDoc}`'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`{@inheritDoc}`'
- en: 'When a method overrides a method in a superclass or implements a method in
    an interface, you can omit a doc comment, and `javadoc` automatically inherits
    the documentation from the overridden or implemented method. You can use the `{@inheritDoc}`
    tag to inherit the text of individual tags. This tag also allows you to inherit
    and augment the descriptive text of the comment. To inherit individual tags, use
    it like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个方法覆盖超类中的方法或实现接口中的方法时，可以省略文档注释，`javadoc` 会自动从被覆盖或实现的方法继承文档。可以使用 `{@inheritDoc}`
    标签来继承单个标签的文本。此标签还允许继承和增强注释的描述性文本。要继承单个标签，请像这样使用它：
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`{@docRoot}`'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`{@docRoot}`'
- en: 'This inline tag takes no parameters and is replaced with a reference to the
    root directory of the generated documentation. It is useful in hyperlinks that
    refer to an external file, such as an image or a copyright statement:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此内联标签不带参数，将替换为生成文档的根目录的引用。它在引用外部文件（如图像或版权声明）的超链接中非常有用：
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`{@literal` *`text`* `}`'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`{@literal` *`text`* `}`'
- en: This inline tag displays *`text`* literally, escaping any HTML in it and ignoring
    any `javadoc` tags it may contain. It does not retain whitespace formatting but
    is useful when used within a `<pre>` tag.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此内联标签以文本的形式显示 *`text`*，逐字显示其中的 HTML 并忽略其中可能包含的 `javadoc` 标签。它不保留空格格式，但在 `<pre>`
    标签内使用时非常有用。
- en: '`{@code` *`text`* `}`'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`{@code` *`text`* `}`'
- en: 'This tag is like the `{@literal}` tag but displays the literal *`text`* in
    code font. Equivalent to:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 此标签类似于 `{@literal}` 标签，但以代码字体显示 *`text`* 的文字。相当于：
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`{@value}`'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`{@value}`'
- en: The `{@value}` tag, with no arguments, is used inline in doc comments for `static
    final` fields and is replaced with the constant value of that field.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`{@value}` 标签不带参数，用于文档注释中的 `static final` 字段中，将替换为该字段的常量值。'
- en: '`{@value` *`reference`* `}`'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`{@value` *`reference`* `}`'
- en: This variant of the `{@value}` tag includes a *`reference`* to a `static final`
    field and is replaced with the constant value of that field.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 此 `{@value}` 标签的变体包括对 `static final` 字段的 *`reference`* 引用，并替换为该字段的常量值。
- en: Cross-References in Doc Comments
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文档注释中的交叉引用
- en: The `@see` tag and the inline tags `{@link}`, `{@linkplain}`, and `{@value}`
    all encode a cross-reference to some other source of documentation, typically
    to the documentation comment for some other type or member.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`@see` 标签和内联标签 `{@link}`、`{@linkplain}` 和 `{@value}` 都编码了对某些其他文档源的交叉引用，通常是对某些其他类型或成员的文档注释的引用。'
- en: '*`reference`* can take three different forms. If it begins with a quote character,
    it is taken to be the name of a book or some other printed resource and is displayed
    as is. If *`reference`* begins with a < character, it is taken to be an arbitrary
    HTML hyperlink that uses the `<a>` tag, and the hyperlink is inserted into the
    output documentation as is. This form of the `@see` tag can insert links to other
    online documents, such as a programmer’s guide or user’s manual.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*`reference`*可以采用三种不同的形式。如果以引号字符开头，则视为书籍名称或其他印刷资源的名称，并按原样显示。如果*`reference`*以<字符开头，则视为任意HTML超链接，使用`<a>`标签，并将超链接插入输出文档中。`@see`标签的此形式可以插入到其他在线文档中，例如程序员指南或用户手册。'
- en: 'If *`reference`* is not a quoted string or a hyperlink, it is expected to have
    the following form:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*`reference`*不是引号括起的字符串或超链接，则预期其具有以下形式：
- en: '[PRE14]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this case, `javadoc` outputs the text specified by *`label`* and encodes
    it as a hyperlink to the specified *`feature`*. If *`label`* is omitted (as it
    usually is), `javadoc` uses the name of the specified *`feature`* instead.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`javadoc`输出由*`label`*指定的文本，并将其编码为指定*`feature`*的超链接。如果通常省略*`label`*，`javadoc`将使用指定*`feature`*的名称。
- en: '*`feature`* can refer to a package, type, or type member, using one of the
    following forms:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*`feature`*可以引用包、类型或类型成员，采用以下形式之一：'
- en: '*`pkgname`*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*`pkgname`*'
- en: 'A reference to the named package. For example:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 对命名包的引用。例如：
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*`pkgname`*.*`typename`*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*`pkgname`*.*`typename`*'
- en: 'A reference to a class, interface, enumerated type, or annotation type specified
    with its full package name. For example:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对使用其完整包名指定的类、接口、枚举类型或注解类型的引用。例如：
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*`typename`*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*`typename`*'
- en: 'A reference to a type specified without its package name. For example:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对未指定其包名的类型的引用。例如：
- en: '[PRE17]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`javadoc` resolves this reference by searching the current package and the
    list of imported classes for a class with this name.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`javadoc`通过搜索当前包和导入类列表来解析此引用，以找到具有此名称的类。'
- en: '*`typename`* `#` *`methodname`*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*`typename`* `#` *`methodname`*'
- en: 'A reference to a named method or constructor within the specified type. For
    example:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对指定类型中命名方法或构造函数的引用。例如：
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If the type is specified without its package name, it is resolved as described
    for *`typename`*. This syntax is ambiguous if the method is overloaded or the
    class defines a field by the same name.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类型没有指定其包名，则按照*`typename`*描述的方式解析。如果方法重载或类定义了同名字段，则此语法存在歧义。
- en: '*`typename`* `#` *`methodname`* `(` *`paramtypes`* `)`'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*`typename`* `#` *`methodname`* `(` *`paramtypes`* `)`'
- en: 'A reference to a method or constructor with the type of its parameters explicitly
    specified. This is useful when cross-referencing an overloaded method. For example:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对方法或构造函数的引用，其参数类型明确指定。在交叉引用重载方法时很有用。例如：
- en: '[PRE19]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`#` *`methodname`*'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`#` *`methodname`*'
- en: 'A reference to a nonoverloaded method or constructor in the current class or
    interface or one of the containing classes, superclasses, or superinterfaces of
    the current class or interface. Use this concise form to refer to other methods
    in the same class. For example:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对当前类或接口中的非重载方法或构造函数的引用，或者对当前类或接口的包含类、超类或超接口中的一个方法的引用。使用这种简洁形式来引用同一类中的其他方法。例如：
- en: '[PRE20]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`#` *`methodname`* `(` *`paramtypes`* `)`'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`#` *`methodname`* `(` *`paramtypes`* `)`'
- en: 'A reference to a method or constructor in the current class or interface or
    one of its superclasses or containing classes. This form works with overloaded
    methods because it lists the types of the method parameters explicitly. For example:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 对当前类或接口或其超类或包含类中方法或构造函数的引用。此形式适用于重载方法，因为它明确列出了方法参数的类型。例如：
- en: '[PRE21]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*`typename`* `#` *`fieldname`*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*`typename`* `#` *`fieldname`*'
- en: 'A reference to a named field within the specified class. For example:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对指定类中命名字段的引用。例如：
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If the type is specified without its package name, it is resolved as described
    for *`typename`*.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类型没有指定其包名，则按照*`typename`*描述的方式解析。
- en: '`#` *`fieldname`*'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`#` *`fieldname`*'
- en: 'A reference to a field in the current type or one of the containing classes,
    superclasses, or superinterfaces of the current type. For example:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对当前类型或其包含类、超类或超接口中的字段的引用。例如：
- en: '[PRE23]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Doc Comments for Packages
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包的文档注释
- en: Documentation comments for classes, interfaces, methods, constructors, and fields
    appear in Java source code immediately before the definitions of the features
    they document. `javadoc` can also read and display summary documentation for packages.
    Because a package is defined in a directory, not in a single file of source code,
    `javadoc` looks for the package documentation in a file named *package.xhtml*
    in the directory that contains the source code for the classes of the package.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Java 源代码中类、接口、方法、构造函数和字段的文档注释出现在其定义之前。`javadoc` 也可以读取并显示包的摘要文档。由于包在目录中定义，而不是在单个源代码文件中，因此
    `javadoc` 在包含该包类的源代码目录中查找名为 *package.xhtml* 的文件以获取包文档。
- en: The *package.xhtml* file should contain simple HTML documentation for the package.
    It can also contain `@see`, `@link`, `@deprecated`, and `@since` tags. Because
    *package.xhtml* is not a file of Java source code, the documentation it contains
    should be HTML and should *not* be a Java comment (i.e., it should not be enclosed
    within `/**` and `*/` characters). Finally, any `@see` and `@link` tags that appear
    in *package.xhtml* must use fully qualified class names.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*package.xhtml* 文件应包含包的简单 HTML 文档。它还可以包含 `@see`、`@link`、`@deprecated` 和 `@since`
    标签。因为 *package.xhtml* 不是 Java 源代码文件，所以其中的文档应为 HTML，并且不应为 Java 注释（即不应该包含在 `/**`
    和 `*/` 字符之间）。最后，在 *package.xhtml* 中出现的任何 `@see` 和 `@link` 标签都必须使用完全限定的类名。'
- en: In addition to defining a *package.xhtml* file for each package, you can also
    provide high-level documentation for a group of packages by defining an *overview.xhtml*
    file in the source tree for those packages. When `javadoc` is run over that source
    tree, it uses *overview.xhtml* as the highest-level overview it displays.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 除了为每个包定义 *package.xhtml* 文件外，还可以通过在这些包的源树中定义 *overview.xhtml* 文件来为一组包提供高级文档。当对该源树运行
    `javadoc` 时，它将使用 *overview.xhtml* 作为显示的最高级概述。
- en: Doclets
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文档生成器
- en: The `javadoc` tool that is used to generate HTML documentation is based upon
    a standard API. Since Java 9, this standard interface has been delivered in the
    module `jdk.javadoc` and tools leveraging this API are typically called *doclets*
    (with `javadoc` being referred to as the standard doclet).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 用于生成 HTML 文档的 `javadoc` 工具基于标准 API。自 Java 9 以来，此标准接口已通过模块 `jdk.javadoc` 提供，并且通常使用此
    API 的工具称为 *doclets*（其中 `javadoc` 被称为标准文档生成器）。
- en: The Java 9 release also included a major upgrade of the standard doclet. In
    particular, it now (as of Java 10) generates modern HTML5 by default. This allows
    for other improvements—such as implementing the [WAI-ARIA standard](https://oreil.ly/4Slwr)
    for accessibility. This standard makes it easier for people with visual or other
    impairments to access `javadoc` output using tools such as screen readers.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9 发布还包括标准文档生成器的主要升级。特别是自 Java 10 起，默认生成现代 HTML5。这允许其他改进，例如实现 [WAI-ARIA
    标准](https://oreil.ly/4Slwr) 以提高可访问性。该标准使视觉或其他障碍的人能够使用屏幕阅读器等工具访问 `javadoc` 输出。
- en: Note
  id: totrans-175
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '`javadoc` has also been enhanced to understand the new platform modules, and
    so the semantic meaning of what constitutes an API (and so what should be documented)
    is now aligned with the modular Java definition.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`javadoc` 还已经增强以理解新的平台模块，因此构成 API 的语义含义（以及应该记录的内容）现在与模块化 Java 定义对齐。'
- en: 'The standard doclet now also automatically indexes the code as documentation
    is generated and creates a client-side index in JavaScript. The resulting web
    pages have a search capability to allow developers to easily find some common
    program components, such as the names of:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 标准文档生成器现在在生成文档时还会自动索引代码，并在 JavaScript 中创建客户端索引。生成的网页具有搜索功能，允许开发人员轻松找到一些常见的程序组件，例如：
- en: Modules
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块
- en: Packages
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包
- en: Types and members
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型和成员
- en: Method parameter types
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法参数类型
- en: The developer can also add search terms or phrases using an `@index` inline
    `javadoc` tag.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员还可以使用 `@index` 内联 `javadoc` 标签添加搜索术语或短语。
- en: Conventions for Portable Programs
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 便携程序的约定
- en: 'One of the earliest slogans for Java was “write once, run anywhere.” This emphasizes
    that Java makes it easy to write portable programs, but it is still possible to
    write Java programs that do not automatically run successfully on any Java platform.
    The following tips help to avoid portability problems:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Java 最早的口号之一是“一次编写，到处运行”。这强调了 Java 使编写便携程序变得容易，但仍然可能编写不会自动在任何 Java 平台上成功运行的
    Java 程序。以下提示有助于避免可移植性问题：
- en: Native methods
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 本地方法
- en: Portable Java code can use any methods in the core Java APIs, including methods
    implemented as `native` methods. However, portable code must not define its own
    native methods. By their very nature, native methods must be ported to each new
    platform, so they directly subvert the “write once, run anywhere” promise of Java.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 可移植的Java代码可以使用核心Java API中的任何方法，包括作为`native`方法实现的方法。但是，可移植的代码不得定义自己的native方法。由于其本质，native方法必须适应每个新平台，因此直接违反了Java“一次编写，到处运行”的承诺。
- en: The `Runtime.exec()` method
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`Runtime.exec()`方法'
- en: Calling the `Runtime.exec()` method to spawn a process and execute an external
    command on the native system is rarely allowed in portable code. This is because
    the native OS command to be executed is never guaranteed to exist or behave the
    same way on all platforms.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在可移植代码中，几乎不允许调用`Runtime.exec()`方法来生成一个进程并在本地系统上执行外部命令。这是因为无法保证要执行的本地操作系统命令在所有平台上都存在或行为相同。
- en: The only time it is legal to use `Runtime.exec()` in portable code is when the
    user is allowed to specify the command to run, either by typing the command at
    runtime or by specifying the command in a configuration file or preferences dialog
    box.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在可移植代码中，唯一允许使用`Runtime.exec()`的时候是用户可以指定要运行的命令，可以通过在运行时输入命令或在配置文件或首选项对话框中指定命令来实现。
- en: If the programmer wishes to control external processes, then this should be
    done through the enhanced `ProcessHandle` capability introduced in Java 9, rather
    than by using `Runtime.exec()` and parsing the output. This is not fully portable,
    but it at least reduces the amount of platform-specific logic necessary to control
    external processes.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序员希望控制外部进程，则应通过Java 9引入的增强的`ProcessHandle`功能而不是使用`Runtime.exec()`和解析输出来实现。这并非完全可移植，但至少可以减少控制外部进程所需的特定于平台的逻辑量。
- en: The `System.getenv()` method
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.getenv()`方法'
- en: Using `System.getenv()` is inherently nonportable. Different operating systems
    have differing casing conventions (e.g., Windows is case-insensitive, where Unix
    systems are not). Also, typical values found in an environment vary greatly between
    operating systems and organizations. Use of `System.getenv()` to parameterize
    specific values your application expects can be acceptable if well documented;
    this is frequently done with containerized applications. But reaching out to the
    broader environment can yield incompatible behavior.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`System.getenv()`在本质上是不可移植的。不同的操作系统具有不同的大小写约定（例如，Windows不区分大小写，而Unix系统则不同）。此外，环境中常见的值在操作系统和组织之间有很大的差异。如果良好记录，使用`System.getenv()`来参数化应用程序所期望的特定值是可以接受的；这在容器化应用程序中经常这样做。但是，访问更广泛的环境可能会产生不兼容的行为。
- en: Undocumented classes
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 未记录的类
- en: Portable Java code must use only classes and interfaces that are a documented
    part of the Java platform. Most Java implementations ship with additional undocumented
    public classes that are part of the implementation but not part of the Java platform
    specification.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 可移植的Java代码必须仅使用作为Java平台文档的一部分记录的类和接口。大多数Java实现都附带有作为实现的一部分但不属于Java平台规范的额外未记录的公共类。
- en: The modules system prevents a program from using and relying on these implementation
    classes, but even with the increased restrictions in Java 17 it is still possible
    to circumvent this protection by using reflection (although the exact runtime
    switches permitting reflection have changed in recent versions; see [Chapter 12](ch12.xhtml#javanut8-CHP-12)
    for more details).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 模块系统防止程序使用和依赖这些实现类，但即使在Java 17中增加了更多限制，仍然可以通过使用反射来绕过此保护（尽管允许反射的确切运行时开关在最近的版本中已经改变；请参阅[第12章](ch12.xhtml#javanut8-CHP-12)了解更多详情）。
- en: However, doing so is not portable because the implementation classes are not
    guaranteed to exist in all Java implementations or on all platforms, and they
    may change or disappear in future versions. Even if you don’t care much about
    portability, use of undocumented classes can greatly complicate future JDK version
    upgrades.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这样做是不可移植的，因为实现类不能保证存在于所有Java实现或所有平台上，并且它们可能会在未来版本中更改或消失。即使你对可移植性不是很在意，使用未记录的类也可能会大大复杂化未来JDK版本的升级。
- en: Of particular note is the `sun.misc.Unsafe` class, which provides access to
    a number of “unsafe” methods, which can allow developers to circumvent key restrictions
    of the Java platform. Developers should not directly use the `Unsafe` class under
    any circumstances.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 特别需要注意的是 `sun.misc.Unsafe` 类，它提供了许多“不安全”方法，开发者可以利用这些方法绕过 Java 平台的关键限制。无论何种情况下，开发者都不应直接使用
    `Unsafe` 类。
- en: Implementation-specific features
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 实现特定的特性
- en: Portable code must not rely on features specific to a single implementation.
    For example, in the early years of Java, Microsoft distributed a version of the
    Java runtime system that included a number of additional methods that were not
    part of the Java platform as defined by the specifications. Any program that depends
    on such extensions is obviously not portable to other platforms.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 可移植的代码不能依赖于特定于单个实现的特性。例如，在 Java 的早期年份，Microsoft 发布了一个包含许多额外方法的 Java 运行时系统版本，这些方法不属于规范定义的
    Java 平台。任何依赖此类扩展的程序显然无法在其他平台上移植。
- en: Implementation-specific bugs
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 实现特定的 bug
- en: Just as portable code must not depend on implementation-specific features, it
    must not depend on implementation-specific bugs. If a class or method behaves
    differently than the specification says it should, a portable program cannot rely
    on this behavior, which may be different on different platforms, and a future
    version may ultimately fix the bug, hindering JDK upgrades.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 正如可移植的代码不得依赖于特定于实现的特性，它也不得依赖于特定于实现的 bug。如果类或方法的行为与规范所述的不同，可移植程序不能依赖于这种行为，因为它可能在不同的平台上有所不同，并且将来的版本可能会修复该
    bug，从而阻碍 JDK 的升级。
- en: Implementation-specific behavior
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 实现特定的行为
- en: Sometimes different platforms and different implementations present different
    behaviors, all of which are legal according to the Java specification. Portable
    code must not depend on any one specific behavior. For example, the Java specification
    does not indicate whether threads of equal priority share the CPU or if one long-running
    thread can starve another thread at the same priority. If an application assumes
    one behavior or the other, it may not run properly on all platforms.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 有时不同平台和不同实现会呈现不同的行为，所有这些行为都符合 Java 规范的要求。可移植的代码不能依赖于任何特定的行为。例如，Java 规范没有指示相同优先级的线程是否共享
    CPU，或者一个长时间运行的线程是否可以饿死同一优先级的另一个线程。如果应用程序假定其中一种行为，可能无法在所有平台上正确运行。
- en: Defining system classes
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 定义系统类
- en: Portable Java code never attempts to define classes in any of the system or
    standard extension packages. Doing so violates the protection boundaries of those
    packages and exposes package-visible implementation details, even in those cases
    where it is not forbidden by the modules system.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 可移植的 Java 代码永远不会尝试在系统或标准扩展包中定义类。这样做违反了这些包的保护边界，并暴露了包可见的实现细节，即使在模块系统不禁止的情况下，也是如此。
- en: Hardcoded filenames
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 硬编码的文件名
- en: A portable program contains no hardcoded file or directory names. This is because
    different platforms have significantly different filesystem organizations and
    use different directory separator characters. If you need to work with a file
    or directory, have the user specify the filename, or at least the base directory
    beneath which the file can be found. This specification can be done at runtime,
    in a configuration file, or as a command-line argument to the program. When concatenating
    a file or directory name to a directory name, use the `File()` constructor, the
    `File.separator` constant, or the `Path.of()` method.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 可移植程序不包含硬编码的文件或目录名。这是因为不同的平台有着显著不同的文件系统组织和不同的目录分隔符字符。如果需要处理文件或目录，应该让用户指定文件名，或者至少指定基本目录，在运行时、配置文件或程序的命令行参数中进行规范。在将文件或目录名称连接到目录名称时，应使用
    `File()` 构造函数、`File.separator` 常量或 `Path.of()` 方法。
- en: Line separators
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 行分隔符
- en: Different systems use different characters or sequences of characters as line
    separators. Do not hardcode `\n`, `\r`, or `\r\n` as the line separator in your
    program. Instead, use the `println()` method of `PrintStream` or `PrintWriter`,
    which automatically terminates a line with the line separator appropriate for
    the platform, or use the value of the `line.separator` system property. You can
    also use the “%n” format string to `printf()` and `format()` methods of `java.util.Formatter`
    and related classes.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 不同系统使用不同字符或字符序列作为行分隔符。不要在程序中硬编码 `\n`、`\r` 或 `\r\n` 作为行分隔符。相反，使用 `PrintStream`
    或 `PrintWriter` 的 `println()` 方法，该方法会自动以适合平台的行分隔符终止行，或使用 `line.separator` 系统属性的值。您还可以使用
    `java.util.Formatter` 及其相关类的 `printf()` 和 `format()` 方法中的 “%n” 格式字符串。
- en: Summary
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we’ve seen the standard conventions around naming parts of
    our Java code. While the language allows many things beyond these conventions,
    your code will be easier for others to read and understand the more these are
    followed.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了关于命名 Java 代码部分的标准约定。虽然语言允许超出这些约定的许多内容，但遵循这些约定的代码将更容易让其他人阅读和理解。
- en: Good documentation is at the heart of creating maintainable systems. The `javadoc`
    tool allows us to write much of our documentation within our code, keeping it
    in context when things change. A variety of document tags allow for generating
    clear and consistent documentation.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的文档是创建可维护系统的核心。`javadoc` 工具允许我们在代码中编写大部分文档，保持文档与代码的关联性。各种文档标签可生成清晰一致的文档。
- en: Part of the appeal of the JVM is its broad install base across many operating
    systems and types of hardware. However, you can compromise the portability of
    your application if you’re not careful in a few areas, so this chapter reviewed
    guidelines around the most typical of those stumbling blocks to avoid.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: JVM 的吸引力之一是它在许多操作系统和硬件类型上的广泛安装基础。然而，如果您在几个方面不注意，可能会损害应用程序的可移植性，因此本章回顾了围绕其中最典型的障碍的指导方针以避免出错。
- en: 'Next up, we’ll take a look at one of the most commonly used parts of Java’s
    standard libraries: collections.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看一下 Java 标准库中最常用的部分之一：集合。
