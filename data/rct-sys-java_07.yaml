- en: 'Chapter 5\. Reactive Programming: Taming the Asynchronicity'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章\. 响应式编程：驯服异步性
- en: In the previous chapter, we introduced reactive systems and how they elegantly
    handle the challenges of distributed systems. Although never forget that nothing
    comes for free in the IT world. One of the characteristics of reactive systems
    is the use of nonblocking I/O. Nonblocking I/O improves the concurrency, responsiveness,
    and resource utilization of reactive applications. To fully benefit from nonblocking
    I/O, you must design and develop the code in a nonblocking manner, and that is
    a not-so-easy challenge.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们介绍了响应式系统及其如何优雅地处理分布式系统的挑战。但永远不要忘记，在IT世界中没有免费的午餐。响应式系统的特征之一是使用非阻塞I/O。非阻塞I/O改进了响应式应用的并发性、响应性和资源利用率。要充分利用非阻塞I/O的优势，必须以非阻塞方式设计和开发代码，这是一个并不那么容易的挑战。
- en: This chapter explores approaches to writing nonblocking and asynchronous Java
    code such as callbacks and reactive programming. We also cover flow control and
    Reactive Streams, which is an essential part of modern reactive applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了编写非阻塞和异步Java代码的方法，例如回调和响应式编程。我们还涵盖了流控制和响应式流，这是现代响应式应用的重要部分。
- en: Asynchronous Code and Patterns
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步代码与模式
- en: How does nonblocking lead to asynchronous code? Remember the design of nonblocking
    I/O from the preceding chapter. It allows using a few threads to handle concurrent
    network interactions. That particular architecture reduces memory consumption
    but also CPU usage. As a consequence, the application code gets executed by one
    of these I/O threads, and there are scarce resources. If your code unconsciously
    blocks one of these threads, it would reduce your application’s concurrency and
    increase the response time, as fewer threads are available to handle the requests.
    In the worst-case scenario, all the I/O threads get blocked, and the application
    cannot handle requests anymore. In other words, the benefits from nonblocking
    I/O would vanish.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 非阻塞如何导致异步代码？回想一下上一章的非阻塞I/O设计。它允许使用少量线程处理并发网络交互。这种特定的架构减少了内存消耗，同时也减少了CPU使用率。因此，应用代码由其中一个I/O线程执行，资源稀缺。如果你的代码无意中阻塞了其中一个线程，将降低应用程序的并发性，并增加响应时间，因为可用于处理请求的线程更少。在最坏的情况下，所有I/O线程都被阻塞，应用程序无法处理请求。换句话说，非阻塞I/O的好处会消失。
- en: Let’s illustrate this with an example. Imagine a `greeting` service, which takes
    a name as a parameter and produces a greeting message. With a synchronous model,
    you would invoke that service as shown in [Example 5-1](#reactive-programming::synchronous-code).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来说明这一点。想象一个`greeting`服务，它以一个名字作为参数，并生成一个问候消息。在同步模型中，你会像在[示例 5-1](#reactive-programming::synchronous-code)中展示的那样调用该服务。
- en: Example 5-1\. Example of synchronous code
  id: totrans-6
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-1\. 同步代码示例
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You call the service, synchronously get the result, and use it on the next line.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你调用服务，同步获取结果，并在下一行使用它。
- en: Now, let’s imagine that the `greeting` service is a remote service. You could
    still call it synchronously, but, in this case, you are going to block the thread
    until the response is received, as depicted in [Figure 5-1](#image:synchronous-sequence-diagram).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设`greeting`服务是一个远程服务。你仍然可以同步调用它，但在这种情况下，你将阻塞线程，直到接收到响应，就像[图 5-1](#image:synchronous-sequence-diagram)中所示。
- en: '![Synchronous invocation](assets/rsij_0501.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![同步调用](assets/rsij_0501.png)'
- en: Figure 5-1\. Synchronous invocation
  id: totrans-11
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-1\. 同步调用示意图
- en: If your code runs on the I/O thread, you block that thread. As a consequence,
    the service cannot handle any other requests while waiting for the response. Blocking
    the I/O thread discards all the advantages of nonblocking I/O.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的代码运行在I/O线程上，你会阻塞该线程。因此，服务在等待响应时无法处理任何其他请求。阻塞I/O线程会丢弃非阻塞I/O的所有优势。
- en: 'What can we do? That’s simple: we must not block the thread. We call the method,
    and it returns immediately, not *waiting* for the response. But, there is a small
    problem with this approach: how would you get this response? You need to pass
    some continuation, invoked when the response is received, as shown in [Example 5-2](#reactive-programming::asynchronous-code).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做什么？很简单：我们不能阻塞线程。我们调用方法，它立即返回，而不是等待响应。但是，这种方法有一个小问题：你如何获取这个响应？你需要传递一些延续，在接收到响应时调用，就像在[示例 5-2](#reactive-programming::asynchronous-code)中展示的那样。
- en: Example 5-2\. Example of asynchronous code
  id: totrans-14
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-2\. 异步代码示例
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this code snippet, we pass a continuation implemented using a *callback*,
    a function invoked with the received result. It embraces well the event-driven
    nature of this code: `on result, call that function`. With this asynchronous model,
    we release the I/O thread. When the response is received, it calls the function
    with that response and continues the execution. During that time, this I/O thread
    can be used to handle more requests ([Figure 5-2](#image:asynchronous-sequence-diagram)).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码片段中，我们传递了一个使用*回调*实现的延续，即收到结果后调用的函数。它很好地包含了此代码的事件驱动特性：`在结果上，调用该函数`。通过这种异步模型，我们释放了I/O线程。当接收到响应时，它将用该响应调用函数并继续执行。在此期间，该I/O线程可以用来处理更多的请求（[图 5-2](#image:asynchronous-sequence-diagram)）。
- en: '![Asynchronous invocation](assets/rsij_0502.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![异步调用](assets/rsij_0502.png)'
- en: Figure 5-2\. Asynchronous invocation
  id: totrans-18
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-2\. 异步调用
- en: Let’s have a deeper look at the preceding code snippet and add some traces by
    using the good old `System.out` statements ([Example 5-3](#reactive-programming::asynchronous-code-trace)).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入看一下前面的代码片段，并通过使用老式的`System.out`语句添加一些跟踪（[示例 5-3](#reactive-programming::asynchronous-code-trace)）。
- en: Example 5-3\. Asynchronous code and ordering
  id: totrans-20
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-3\. 异步代码和排序
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: What would be the output of this program? For sure, `Before` is printed first,
    but what about the greeting message and `After`? Which one would be first? There
    is a good chance that `After` is printed first because invoking the `greeting`
    service takes at least a few milliseconds (remember, it’s a remote service). This
    means that with asynchronous code, the next line often is executed before the
    *continuation*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的输出会是什么？肯定会先打印`Before`，但问候消息和`After`呢？哪个会先打印？`After`很有可能会先打印，因为调用`greeting`服务至少需要几毫秒（记住，它是一个远程服务）。这意味着使用异步代码时，下一行通常在*延续*之前执行。
- en: What does that mean in practice? Let’s imagine you want to call the `greeting`
    service twice, once for Luke and once for Leia; see [Example 5-4](#reactive-programming::asynchronous-code-calls).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中意味着什么？让我们想象一下，你想调用`greeting`服务两次，一次是为Luke，一次是为Leia；参见[示例 5-4](#reactive-programming::asynchronous-code-calls)。
- en: Example 5-4\. Calling asynchronous methods twice
  id: totrans-24
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-4\. 两次调用异步方法
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this code, we can’t anticipate which message is going to appear first. It
    depends on many factors such as latency, speed, and number of instances of the
    `greeting` service. However, both calls run concurrently, which is an attractive
    benefit.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们无法预料哪条消息会首先出现。这取决于许多因素，如延迟、速度和`greeting`服务的实例数量。然而，两次调用都是并发运行的，这是一个吸引人的好处。
- en: If you want or need a strict order (for example, to call the service for Leia
    first and then Luke), we need to compose the asynchronous calls ([Example 5-5](#reactive-programming::sequential-composition)).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要或需要严格的顺序（例如，先为Leia调用服务，然后再为Luke调用），我们需要组合异步调用（[示例 5-5](#reactive-programming::sequential-composition)）。
- en: Example 5-5\. Sequential composition pattern
  id: totrans-28
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-5\. 顺序组合模式
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With this code, we first call the service with `Leia`, and when we get the response,
    call it with `Luke`. The calls don’t run concurrently anymore, but at least we
    know the order. We call this pattern *sequential composition*. It’s quite common,
    as you can imagine.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这段代码，我们首先使用`Leia`调用服务，当我们收到响应后，再使用`Luke`调用服务。调用不再并发运行，但至少我们知道顺序。我们称这种模式为*顺序组合*。正如你可以想象的那样，这是相当常见的。
- en: 'Let’s continue our investigation with another type of useful composition: *parallel
    composition*. We want to execute the calls concurrently this time, but we need
    to pass a continuation invoked when both calls are complete ([Example 5-6](#reactive-programming::parallel-composition)).'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续我们的调查，使用另一种有用的组合类型：*并行组合*。这次我们想同时执行这些调用，但我们需要传递一个在两次调用都完成时调用的延续函数（[示例 5-6](#reactive-programming::parallel-composition)）。
- en: Example 5-6\. Simplified parallel composition pattern
  id: totrans-32
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-6\. 简化的并行组合模式
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It starts to be a bit more convoluted, and this code is not totally correct,
    as you can have race conditions if both callbacks are invoked concurrently. We
    need to store the results, check if they are non-null, and invoke the continuation
    function.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 开始变得有些复杂，这段代码并不完全正确，因为如果两个回调同时被调用，你可能会遇到竞态条件。我们需要存储结果，检查它们是否非空，并调用延续函数。
- en: 'We have slightly forgotten another aspect: failures. It’s not because it’s
    an asynchronous API that failures don’t happen. You cannot use `try/catch` blocks
    anymore, as the failure can also happen asynchronously; see [Example 5-7](#reactive-programming::asynchronous-code-try-catch).'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍微忘记了另一个方面：失败。这不是因为它是一个异步 API 就不会发生失败。你不能再使用 `try/catch` 块了，因为失败也可能是异步的；参见
    [示例 5-7](#reactive-programming::asynchronous-code-try-catch)。
- en: Example 5-7\. Would this `try`/`catch` work as intended?
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-7\. 这个 `try`/`catch` 能正常工作吗？
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `catch` block would catch only synchronous exceptions. If the service produces
    a failure asynchronously, like the inability to produce the greeting message,
    this `try/catch` is useless. To handle failures, we need to have a proper construct
    for it. We can imagine two *simple* ways:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`catch` 块只能捕获同步异常。如果服务异步产生失败，例如无法生成问候消息，这个 `try/catch` 就毫无用处。为了处理失败，我们需要一个适当的结构。我们可以想象两种*简单*的方式：'
- en: Use an asynchronous result construct encapsulating both the result and the failure.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用封装了结果和失败的异步结果结构。
- en: Have a second callback for failures.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于失败，有第二个回调。
- en: With the first approach, you would need something like [Example 5-8](#reactive-programming::asynchronous-result).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一种方法，你需要类似于 [示例 5-8](#reactive-programming::asynchronous-result) 的东西。
- en: Example 5-8\. Use asynchronous result encapsulating both result and failure
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-8\. 使用封装了结果和失败的异步结果。
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`greeting` is not a `String` anymore but a type encapsulating the operation’s
    outcome.^([1](ch05.html#idm45358829664160)) You need to check whether the operation
    failed or succeeded and act accordingly. You can quickly imagine how this would
    impact our previous composition examples. At that level, it’s not challenging;
    it’s a nightmare!'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`greeting` 不再是一个 `String`，而是一个封装了操作结果的类型。^([1](ch05.html#idm45358829664160))
    您需要检查操作是失败还是成功，并据此采取行动。您可以很快想象到这将如何影响我们之前的组合示例。在这个层次上，这不是挑战，而是一场噩梦！'
- en: 'The second approach uses two callbacks: the first one when the operation succeeded,
    and the second one when it failed ([Example 5-9](#reactive-programming::onSuccess_onError)).'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法使用了两个回调函数：第一个在操作成功时调用，第二个在操作失败时调用（[示例 5-9](#reactive-programming::onSuccess_onError)）。
- en: Example 5-9\. Use different continuations for each outcome
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-9\. 对于每个结果使用不同的延续
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This approach clearly distinguishes the two cases, but again, it makes composition
    harder ([Example 5-10](#reactive-programming::onSuccess_onError_composition)).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法清楚地区分了这两种情况，但同时也使得组合变得更加困难（[示例 5-10](#reactive-programming::onSuccess_onError_composition)）。
- en: Example 5-10\. Use multiple continuations and compositing actions
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-10\. 使用多个延续和组合动作
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It’s not simple, right? However, this second approach has an advantage. If we
    imagine having a `greeting` service accepting multiple names, it is well suited
    to handle sequential responses ([Example 5-11](#reactive-programming::first_stream)).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 不简单吧？不过，这第二种方法有一个优点。如果我们设想一个接受多个名称的 `greeting` 服务，它非常适合处理顺序响应（[示例 5-11](#reactive-programming::first_stream)）。
- en: Example 5-11\. Multiple results for a single operation
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-11\. 单个操作的多个结果
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This example starts exhibiting a new construct: streams of data. You will see
    a lot more of these in this book. These streams can be internal to the application
    or convey messages coming from a message broker. In this chapter, we consider
    only streams internal to the reactive applications. We will cover how these streams
    can be connected to various message brokers in [Chapter 11](ch11.html#event-bus).'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子开始展示一种新的结构：数据流。你将在本书中看到更多这样的内容。这些流可以是应用程序内部的，也可以是来自消息代理的消息传递。在本章中，我们只考虑与响应式应用程序内部相关的流。我们将在[第 11
    章](ch11.html#event-bus)中介绍如何将这些流连接到各种消息代理。
- en: In Java, to express your continuation using callbacks, we often use Java 8 Lambdas.
    They are well integrated in the language, but we have also seen the limit of that
    approach. Callbacks do not compose well. So we need a higher-level construct.
    Any seasoned developers would say future!
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，为了使用回调表达您的延续，我们经常使用Java 8 Lambdas。它们在语言中很好地集成了，但我们也看到了这种方法的局限性。回调不太容易组合。因此，我们需要一个更高级别的构造。任何经验丰富的开发人员都会说：未来！
- en: Using Futures
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Futures
- en: A *future* is a placeholder for a value resolved later. By nature, it’s asynchronous;
    you don’t know when the future will get the value. It’s just *later*. When the
    value gets set, the future allows *reacting* on it—for example, transforming the
    value, implementing side effects, and so forth.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*Future* 是一个稍后解析值的占位符。它是异步的；你不知道未来何时获取这个值。只是*稍后*。当值被设置时，future允许对其进行*反应*，例如转换值、实现副作用等等。'
- en: How does it help our asynchronous code concern? In Java, `CompletableFuture`,
    or `CompletionStage`, the associated interface, can represent the result of an
    asynchronous action. Your API returns a `CompletionStage` object, which gets the
    result when the operation completes. The method returning the `CompletionStage`
    object returns immediately, and so does not block the caller thread, and the continuation
    can be attached to the returned `CompletionStage`; see [Example 5-12](#reactive-programming::future).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 它如何帮助我们的异步代码关注？在Java中，`CompletableFuture`或`CompletionStage`，关联的接口，可以表示异步操作的结果。您的API返回一个`CompletionStage`对象，当操作完成时获取结果。返回`CompletionStage`对象的方法会立即返回，因此不会阻塞调用线程，可以附加后续操作到返回的`CompletionStage`上；参见[Example 5-12](#reactive-programming::future)。
- en: Example 5-12\. Example of `CompletionStage` (*chapter-5/reactive-programming-examples/src/main/java/org/acme/future/Futures.java*)
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 5-12\. `CompletionStage`示例 (*chapter-5/reactive-programming-examples/src/main/java/org/acme/future/Futures.java*)
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-61
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The full examples from this section are located in *chapter-5/reactive-programming-examples/src/main/java/org/acme/future/Futures.java*.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此节的完整示例位于*chapter-5/reactive-programming-examples/src/main/java/org/acme/future/Futures.java*中。
- en: The continuation can be divided into a set of *stages* to process, consume,
    and transform the results, as shown in [Example 5-13](#reactive-programming::future-chain).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 继续可以分成一组*阶段*来处理、消耗和转换结果，如[Example 5-13](#reactive-programming::future-chain)所示。
- en: Example 5-13\. Chaining operation with `CompletionStage` (*chapter-5/reactive-programming-examples/src/main/java/org/acme/future/Futures.java*)
  id: totrans-64
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 5-13\. 使用`CompletionStage`进行链式操作 (*chapter-5/reactive-programming-examples/src/main/java/org/acme/future/Futures.java*)
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Futures also ease the implementation of sequential composition. With the `CompletionStage`
    API, you can use `thenCompose` to invoke a second operation (as seen in [Example 5-14](#reactive-programming::future-sequential-composition)).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Futures还简化了顺序组合的实现。使用`CompletionStage` API，您可以使用`thenCompose`来调用第二个操作（如[Example 5-14](#reactive-programming::future-sequential-composition)中所示）。
- en: Example 5-14\. Sequential composition with `CompletionStage` (*chapter-5/reactive-programming-examples/src/main/java/org/acme/future/Futures.java*)
  id: totrans-67
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 5-14\. 使用`CompletionStage`进行顺序组合 (*chapter-5/reactive-programming-examples/src/main/java/org/acme/future/Futures.java*)
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `allOf` method allows implementing parallel composition; see [Example 5-15](#reactive-programming::future-parallel-composition).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`allOf`方法允许实现并行组合；参见[Example 5-15](#reactive-programming::future-parallel-composition)。'
- en: Example 5-15\. Parallel composition with `CompletableFuture` (*chapter-5/reactive-programming-examples/src/main/java/org/acme/future/Futures.java*)
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 5-15\. 使用`CompletableFuture`进行并行组合 (*chapter-5/reactive-programming-examples/src/main/java/org/acme/future/Futures.java*)
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Futures make composing asynchronous actions much more straightforward than callbacks.
    Besides, futures encapsulate both the result and failure. In `CompletionStage`,
    specific methods handle failure and recover, as you can see in [Example 5-16](#reactive-programming::future-failure-management).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Futures使得组合异步操作比回调函数更加简单。此外，futures封装了结果和失败情况。在`CompletionStage`中，特定的方法处理失败和恢复，正如你在[Example 5-16](#reactive-programming::future-failure-management)中看到的那样。
- en: Example 5-16\. Recover from failure with the `CompletionStage` API (*chapter-5/reactive-programming-examples/src/main/java/org/acme/future/Futures.java*)
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 5-16\. 使用`CompletionStage` API从失败中恢复 (*chapter-5/reactive-programming-examples/src/main/java/org/acme/future/Futures.java*)
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When using `CompletionStage`, we start seeing the creation of *pipelines*:
    a sequence of operations handling events and asynchronous results.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`CompletionStage`时，我们开始看到*管道*的创建：一系列处理事件和异步结果的操作。
- en: 'You may be wondering, what’s missing? Futures seem to tick all the boxes. But
    one tick is missing: streams. Futures do not handle streams of data well. They
    can be used for operations returning single values, but they won’t work for functions
    returning sequences as in [Example 5-11](#reactive-programming::first_stream).'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道，缺少了什么？ Futures似乎完成了所有任务。但是还缺少一项：流。 Futures无法很好地处理数据流。它们可用于返回单个值的操作，但无法处理像[Example 5-11](#reactive-programming::first_stream)中返回序列的函数。
- en: 'Project Loom: Virtual Threads and Carrier Threads'
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Project Loom：虚拟线程和载体线程
- en: If you follow the news around Java, you may have heard about [Project Loom](https://oreil.ly/vuLzu).
    Loom adds the concept of *virtual threads* into Java. Unlike regular threads,
    virtual threads are lightweight. A single carrier thread, a regular OS thread,
    can execute many virtual threads, potentially millions. Loom (the JVM) manages
    the scheduling of these virtual threads, while the operating system manages the
    carrier thread’s scheduling.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你关注 Java 相关的新闻，可能已经听说过 [Project Loom](https://oreil.ly/vuLzu)。Loom 在 Java
    中引入了 *虚拟线程* 的概念。与常规线程不同，虚拟线程轻量级。一个常规操作系统线程可以执行许多虚拟线程，甚至可以达到百万级。Loom（JVM）管理这些虚拟线程的调度，而操作系统管理载体线程的调度。
- en: One benefit is that you can execute blocking code in a virtual thread; it does
    not block the carrier thread. When a virtual thread executes a blocking call,
    such as an I/O call, the Loom scheduler, managing the virtual threads, parks that
    virtual thread and runs another virtual thread. So the carrier thread is not blocked
    and is used to execute this other virtual thread. That does smell good, right?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 其一好处是，你可以在虚拟线程中执行阻塞代码；它不会阻塞载体线程。当虚拟线程执行阻塞调用（如 I/O 调用）时，管理虚拟线程的 Loom 调度器会将该虚拟线程挂起，并运行另一个虚拟线程。因此，载体线程不会被阻塞，可以用来执行另一个虚拟线程。这听起来不错，对吧？
- en: 'In other words, you can write blocking code using a synchronous syntax without
    having to take care of the continuation. Loom handles that for you! Even better:
    because virtual threads are lightweight, you don’t need thread pools anymore;
    you can create new ones on the fly.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，你可以使用同步语法编写阻塞代码，而无需关注续行。Loom 为你处理！更棒的是：由于虚拟线程轻量级，你不再需要线程池；可以随时创建新线程。
- en: However, at the time of writing, the Loom project is still incubating.^([2](ch05.html#idm45358829062432))
    The following code snippets may slightly change as the API is still evolving.
    Besides, some concurrency or blocking constructs are not yet supported, and you
    may unintentionally block the carrier threads, which, as you can imagine, can
    be catastrophic.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在撰写本文时，Loom 项目仍在孵化中。^([2](ch05.html#idm45358829062432)) 由于某些并发或阻塞结构尚未得到支持，你可能会意外地阻塞载体线程，而这可能是灾难性的。
- en: But, to give some ideas, let’s see how we could use our `greeting` service in
    a Loom world. First, the `greeting` service implementation can be blocking and
    use blocking I/O to interact with a remote service. If the call is executed on
    a virtual thread, it does not block the carrier thread, which can execute another
    virtual thread. Loom replaces the blocking I/O calls with a nonblocking I/O and
    parks the virtual thread until the response is received. When the response is
    available, the parked virtual thread can continue its execution with the result.
    From the developer point of view, it’s all synchronous, but under the hood it’s
    not; see [Example 5-17](#reactive-programming::loom-simple).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，为了给出一些想法，让我们看看如何在 Loom 的世界中使用我们的 `greeting` 服务。首先，`greeting` 服务的实现可能是阻塞的，并使用阻塞
    I/O 与远程服务进行交互。如果调用在虚拟线程上执行，则不会阻塞载体线程，载体线程可以执行另一个虚拟线程。Loom 将阻塞 I/O 调用替换为非阻塞 I/O，并将虚拟线程挂起，直到接收到响应。当响应可用时，挂起的虚拟线程可以继续执行并处理结果。从开发者的角度来看，这一切都是同步的，但在底层并非如此；参见
    [Example 5-17](#reactive-programming::loom-simple)。
- en: Example 5-17\. Create a virtual thread
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-17\. 创建一个虚拟线程
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, it’s pure synchronous code. As a consequence, the sequential
    composition is remarkably simple ([Example 5-18](#reactive-programming::loom-sequential-composition)).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这是纯粹的同步代码。因此，顺序组合非常简单（参见 [Example 5-18](#reactive-programming::loom-sequential-composition)）。
- en: Example 5-18\. Sequential composition with Loom
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-18\. 使用 Loom 进行顺序组合
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It’s not different from what you would use in a traditional application. Don’t
    forget that the virtual thread is suspended and resumes multiple times. But, again,
    the carrier thread is not.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这与传统应用程序中使用的方式没有什么不同。不要忘记，虚拟线程会挂起并多次恢复。但是，载体线程不会。
- en: Failure management can use `try/catch` as, again, you use synchronous code.
    If the call to the service fails, the failure is thrown as a regular exception
    ([Example 5-19](#reactive-programming::loom-failure)).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 失败管理可以使用 `try/catch`，因为再次使用同步代码。如果服务调用失败，则作为常规异常抛出（参见 [Example 5-19](#reactive-programming::loom-failure)）。
- en: Example 5-19\. Exception handling with Loom
  id: totrans-90
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-19\. 使用 Loom 进行异常处理
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Unfortunately, Loom does not offer any specific construct for parallel composition.
    You need to use the same approach as for `CompletableFuture`, as shown in [Example 5-20](#reactive-programming::loom-parallel-composition).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Loom 并没有为并行组合提供任何特定的构造。你需要像对待 `CompletableFuture` 一样使用相同的方法，如 [例子 5-20](#reactive-programming::loom-parallel-composition)
    所示。
- en: Example 5-20\. Parallel composition with Loom
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例子 5-20\. 使用 Loom 进行并行组合
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Sounds magic, right? But, you see it coming; there is a catch…
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来像魔法，对吧？但是，你看到了；有个小问题……
- en: While you write synchronous code and do not block the carrier thread, I/Os are
    still happening on I/O threads. The carrier threads are not I/O threads ([Figure 5-3](#image:loom-thread-switch)).
    So, there are multiple thread switches that are not free, even if optimized.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当您编写同步代码且不阻塞载体线程时，I/O 仍然发生在 I/O 线程上。载体线程不是 I/O 线程（参见 [图 5-3](#image:loom-thread-switch)）。因此，即使经过优化，多次线程切换也不是免费的。
- en: '![Thread switches hapenning under the hood](assets/rsij_0503.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![在幕后发生的线程切换](assets/rsij_0503.png)'
- en: Figure 5-3\. Thread switches happening under the hood
  id: totrans-98
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-3\. 在幕后发生的线程切换
- en: 'Also, the temptation to create a massive number of virtual threads can lead
    to complicated execution. Even if virtual threads are lightweight, storing their
    stacks in memory may lead to unexpected memory consumption. It’s like any software
    using many threads; they can be hard to understand and tune. That’s being said,
    Loom is promising. Does that make Reactive pointless? It’s the opposite. Loom
    addresses only the development model, not the architecture concepts behind reactive
    systems. Also, a synchronous model looks attractive but does not accommodate every
    situation, especially when you need to group events or implement stream-based
    logic. That’s what we cover in the next section: reactive programming.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，诱惑创建大量虚拟线程可能会导致复杂的执行。即使虚拟线程很轻量级，将它们的堆栈存储在内存中可能会导致意外的内存消耗。就像使用许多线程的任何软件一样，它们可能难以理解和调优。话虽如此，Loom
    是有前途的。这是否使得响应式变得无意义呢？恰恰相反。Loom 仅解决了开发模型，而不是响应式系统背后的架构概念。此外，同步模型看起来很有吸引力，但并不适用于每种情况，特别是当你需要分组事件或实现基于流的逻辑时。这就是我们下一节要讨论的内容：响应式编程。
- en: Reactive Programming
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式编程
- en: 'First, what is *reactive programming*? A common definition is:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，什么是 *响应式编程*？一个常见的定义是：
- en: Reactive programming combines functional programming, the observer pattern,
    and the iterable pattern.
  id: totrans-102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 响应式编程结合了函数式编程、观察者模式和可迭代模式。
- en: ''
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The [ReactiveX website](http://reactivex.io)
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[ReactiveX 网站](http://reactivex.io)'
- en: 'We never found that definition helpful—too many patterns, and it’s hard to
    clearly convey what reactive programming is about. Let’s make another definition,
    much more straightforward: “Reactive programming is about programming with asynchronous
    streams.”'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从未发现那个定义有帮助——太多模式了，很难清楚地表达响应式编程到底是什么。让我们来做一个更简单的定义：“响应式编程是关于使用异步流进行编程。”
- en: 'That’s it. Reactive programming is about streams and, especially, observing
    them. It pushes that idea to its limit: everything is a stream. These streams
    can be seen as a pipe in which *events* flow. We observe the events flowing—such
    as items, failures, completion, cancellations—and implement side effects (see
    [Figure 5-4](#image:rp-stream)).'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。响应式编程是关于流，特别是观察它们。它将这一理念推向极限：一切皆为流。这些流可以看作是一个管道，*事件*在其中流动。我们观察流动的事件——比如项目、失败、完成、取消——并实现副作用（参见
    [图 5-4](#image:rp-stream)）。
- en: '![Reactive Programming is about observing streams](assets/rsij_0504.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![响应式编程是关于观察流的](assets/rsij_0504.png)'
- en: Figure 5-4\. Reactive programming is about observing streams
  id: totrans-108
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-4\. 响应式编程是关于观察流的
- en: Reactive programming is a specialization of the observer pattern in the sense
    that you observe an object (the stream) and react. It’s asynchronous by nature,
    as you don’t know when the event is going to be seen. Yet, reactive programming
    goes beyond this. It provides a toolbox to compose streams and process events.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程在某种程度上是观察者模式的一个特化，你观察一个对象（流）并作出反应。由于其异步性质，你不知道事件何时会被看到。然而，响应式编程超越了这一点。它提供了一个工具箱来组合流和处理事件。
- en: Streams
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流
- en: 'When using reactive programming, everything—yes, *everything*—is a stream of
    items. The stock market, user clicks, keystrokes, steps, ticks… All these are
    streams, and it’s easy to see why: they are sequences of individual events. So
    the stream carries every occurrence of this event, and the observer can react.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用响应式编程时，一切——是的，*一切*——都是项目的流。股票市场、用户点击、按键、步骤、节拍……所有这些都是流，并且很容易理解：它们是单个事件的序列。因此，流携带这些事件的每次发生，观察者可以做出反应。
- en: But reactive programming also considers asynchronous actions, HTTP requests,
    RPC method invocations, and database insertions or queries as streams. So, a stream
    does not need to carry multiple items; it can contain a single one or even none!
    That is a bit harder to imagine, but it can be powerful.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 但是响应式编程也考虑异步操作，如HTTP请求、RPC方法调用和数据库插入或查询作为流。因此，一个流不需要携带多个项目；它可以包含一个单一的项目，甚至可能没有！这有点难以想象，但它确实很强大。
- en: With reactive programming, you structure your code around streams and build
    chains of transformation, also called *pipelines*. The events flow from the *upstream*
    source to the *downstream* subscriber, traversing each operator and getting transformed,
    processed, filtered, and so on. Each operator observes the upstream and produces
    a new stream. But, there is an important point to not miss in this chain. You
    need a final *subscriber* that subscribes to the last stream and triggers the
    whole computation. When this subscription happens, the direct upstream of the
    final observer subscribes to its own upstream, which subscribes to its upstream,
    until it reaches the root.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用响应式编程时，你会围绕流结构化你的代码，并构建转换链，也称为*管道*。事件从*上游*源流向*下游*订阅者，经过每个操作符并进行转换、处理、过滤等。每个操作符观察上游并生成一个新的流。但在这个链中有一个重要的点不容忽视。你需要一个最终的*订阅者*订阅最后的流，并触发整个计算。当这个订阅发生时，最终观察者的直接上游订阅其自身的上游，依次类推，直到达到根源。
- en: Let’s go back to the idea of a stream. As we’ve mentioned, we consider a stream
    as only internal to the reactive applications. These streams are sequences of
    events ordered in time. The order matters. You observe them in the emission order.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到流的概念。正如我们所提到的，我们将流仅视为响应式应用程序内部的内容。这些流是按时间顺序排列的事件序列。顺序很重要。你按照它们发出的顺序观察它们。
- en: 'A stream can emit three types of events ([Figure 5-5](#image:rp-stream-failure-completion)):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一个流可以发出三种类型的事件（[图 5-5](#image:rp-stream-failure-completion)）：
- en: Items
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 项目
- en: The type depends on the stream; it can be a step, a click, or a response from
    a remote service.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 类型取决于流；它可以是一个步骤、一个点击或来自远程服务的响应。
- en: Failures
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 失败
- en: Indicate that something bad happened, and no more items will be emitted.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 表示发生了不好的事情，不会再发出更多项目。
- en: Completions
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 完成
- en: Indicate that there are no more items to emit.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 表示没有更多项目要发出。
- en: '![Streams can emit three types of events: item, failure and completion](assets/rsij_0505.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![流可以发出三种类型的事件：项目、失败和完成](assets/rsij_0505.png)'
- en: 'Figure 5-5\. Streams can emit three types of events: items, failures, and completions'
  id: totrans-123
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-5\. 流可以发出三种类型的事件：项目、失败和完成。
- en: Item is the most frequent type of event. As an observer, you get notified every
    time a new item is transiting in the stream. You can react to it, transform it,
    implement side effects, and so on.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 项目是事件中最频繁的类型。作为观察者，每当流中传输新项目时，你都会收到通知。你可以对其做出反应、转换它、实施副作用等等。
- en: Failure is an error signal. It indicates that something *terrible* happened,
    and the observed stream cannot recover from it. If not handled properly, failures
    are a terminal event, and no more items will be emitted after a failure. You may
    wonder, why do we need to handle failure? Because streams are asynchronous, and
    if something breaks the source of items, you should be aware of it, and not wait
    for additional items, as they won’t come. As for the other asynchronous development
    models, you cannot use a `try/catch` block, so you need to observe failures and
    react to them. For example, you can log an error or use a fallback item.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 失败是一个错误信号。它表明发生了*可怕*的事情，并且观察的流无法从中恢复。如果未能正确处理，失败将是一个终端事件，在失败后不会再发出更多项目。你可能会想，为什么我们需要处理失败？因为流是异步的，如果某些事情打断了项目的来源，你应该意识到，并且不再等待额外的项目，因为它们不会到来。至于其他异步开发模型，你无法使用`try/catch`块，因此你需要观察失败并对其做出反应。例如，你可以记录错误或使用回退项目。
- en: Finally, the completion event is emitted only when observing a bounded stream,
    as unbounded streams never terminate. The event indicates the end of the stream;
    the source (upstream) is not going to send any more items.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，只有在观察有界流时才会发出完成事件，因为无界流永远不会终止。该事件表示流的结束；源（上游）不会再发送任何项目。
- en: Every time one of these events transit in the observed stream, you, as the observer,
    get notified. You attach functions handling each of them, as shown in [Example 5-21](#reactive-programming::subscription).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 每当这些事件在观察的流中传递时，作为观察者的你会收到通知。你会附加处理每个事件的函数，如[示例 5-21](#reactive-programming::subscription)所示。
- en: Example 5-21\. Subscribe to a stream to receive the events (*chapter-5/reactive-programming-examples/src/main/java/org/acme/reactive/StreamsExample.java*)
  id: totrans-128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-21\. 订阅流以接收事件（*chapter-5/reactive-programming-examples/src/main/java/org/acme/reactive/StreamsExample.java*）
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To observe a stream, you *subscribe* to it. It’s a key concept in reactive
    programming, as streams are lazy by default. Subscribing indicates your interest
    in the events. Without a subscription:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要观察流，你需要*订阅*它。这是响应式编程中的一个关键概念，因为流默认是惰性的。订阅表示你对事件的兴趣。没有订阅：
- en: You won’t receive the items
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不会收到这些项目
- en: You won’t tell the stream that it needs to operate
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不会告诉流它需要操作
- en: The second point is important. It means that, in general, if no one subscribes
    to a stream, the stream won’t do anything. That may look odd but allows you to
    save resources and to start the computation only when everything is ready and
    you actually need the events.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 第二点很重要。这意味着一般情况下，如果没有人订阅流，流将不会执行任何操作。这可能看起来很奇怪，但可以帮助你节省资源，并且只在一切准备就绪并且确实需要事件时才开始计算。
- en: Operators
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作符
- en: Although reactive programming is about streams, it would be useless without
    a toolbox to manipulate these streams. Reactive programming libraries offer countless
    operators that let you create, combine, filter, and transform the object emitted
    by streams. As depicted in [Figure 5-6](#image:rp-stream-transform), a stream
    can be used as input to another one.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管响应式编程是关于流的，但如果没有一个工具箱来操作这些流，它将毫无用处。响应式编程库提供无数的操作符，让你可以创建、组合、过滤和转换流发出的对象。如图 5-6（#image:rp-stream-transform）所示，一个流可以作为另一个流的输入。
- en: '![Example of transform operator](assets/rsij_0506.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![转换操作符示例](assets/rsij_0506.png)'
- en: Figure 5-6\. Example of transform operator
  id: totrans-137
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-6\. 转换操作符示例
- en: It’s important to understand that operators return new streams. The operator
    observes the previous stream (named `upstream`) and creates a new stream by combining
    their logic and the received events. For example, the `transform` operator from
    [Figure 5-6](#image:rp-stream-transform) applies a function for each received
    item^([3](ch05.html#idm45358828566736)) and emits the result to its *downstream*
    subscriber ([Example 5-22](#reactive-programming::transform)).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，操作符会返回新的流。操作符观察先前的流（称为`upstream`）并通过结合它们的逻辑和接收到的事件创建一个新的流。例如，来自图 5-6（#image:rp-stream-transform）的`transform`操作符对每个接收到的项目应用一个函数^（[3](ch05.html#idm45358828566736)）并将结果发送给它的*下游*订阅者（示例 5-22，#reactive-programming::transform）。
- en: Example 5-22\. Transform items (*chapter-5/reactive-programming-examples/src/main/java/org/acme/reactive/StreamsExample.java*)
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-22\. 转换项目（*chapter-5/reactive-programming-examples/src/main/java/org/acme/reactive/StreamsExample.java*）
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As depicted in [Figure 5-7](#image-rp-stream-recover) and [Example 5-23](#reactive-programming::recover),
    operators can also handle failures; for example, to recover or retry.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如图 5-7（#image-rp-stream-recover）和示例 5-23（#reactive-programming::recover）所示，操作符也可以处理故障；例如，进行恢复或重试。
- en: '![Recovering from failures](assets/rsij_0507.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![从故障中恢复](assets/rsij_0507.png)'
- en: Figure 5-7\. Recovering from failures
  id: totrans-143
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-7\. 从故障中恢复
- en: Example 5-23\. Recover from failures (*chapter-5/reactive-programming-examples/src/main/java/org/acme/reactive/StreamsExample.java*)
  id: totrans-144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-23\. 从故障中恢复（*chapter-5/reactive-programming-examples/src/main/java/org/acme/reactive/StreamsExample.java*）
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You may wonder why the `recover` operator emits a completion event after the
    recovery, as shown in [Figure 5-7](#image-rp-stream-recover). When the operator
    receives the failure event, it knows that the source is not going to emit any
    more items, as failures are terminal. So, after emitting the *fallback* item,
    the operator emits the completion event. For the downstream subscriber, it’s like
    the failure did not happen and the stream completed successfully.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么`recover`操作符在恢复后会发出完成事件，如[图 5-7](#image-rp-stream-recover)所示。当操作符接收到失败事件时，它知道源不会再发出任何项目，因为失败是终端的。因此，在发出*fallback*项目后，操作符会发出完成事件。对于下游订阅者来说，就像失败没有发生过，流顺利完成了。
- en: Operators are not limited to synchronous or single-in, single-out types of transformations.
    Operators can transform a single item into a stream, or on the flip side, discard
    items, as shown in [Figure 5-8](#image-rp-stream-operators).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符不仅限于同步或单输入单输出类型的转换。操作符可以将单个项目转换为流，或者反过来，丢弃项目，如[图 5-8](#image-rp-stream-operators)所示。
- en: '![Example of operators emitting multiple items or discarding some items](assets/rsij_0508.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![操作符发出多个项目或丢弃某些项目的示例](assets/rsij_0508.png)'
- en: Figure 5-8\. Example of operators emitting multiple items or discarding some
    items
  id: totrans-149
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-8\. 操作符发出多个项目或丢弃某些项目的示例
- en: Finally, operators can observe multiple upstreams, to merge them, for example,
    as shown in [Figure 5-9](#image-rp-stream-merge) and demonstrated in [Example 5-24](#reactive-programming::merge).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，操作符可以观察多个上游，将它们合并，例如在[图 5-9](#image-rp-stream-merge)中所示，并在[示例 5-24](#reactive-programming::merge)中演示。
- en: '![Merging multiple streams](assets/rsij_0509.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![合并多个流](assets/rsij_0509.png)'
- en: Figure 5-9\. Merging multiple streams
  id: totrans-152
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-9\. 合并多个流
- en: Example 5-24\. Merge multiple streams (*chapter-5/reactive-programming-examples/src/main/java/org/acme/reactive/StreamsExample.java*)
  id: totrans-153
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-24\. 合并多个流（*chapter-5/reactive-programming-examples/src/main/java/org/acme/reactive/StreamsExample.java*）
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-155
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In the preceding example, note when the observer received the completion event.
    The merging operator waits for all the merged streams to complete before sending
    the completion event, as at that point, no more items will be emitted. That illustrates
    the coordination role of operators.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，请注意观察者接收到完成事件的时间点。合并操作符在发送完成事件之前会等待所有合并的流都完成，因为此时不会再发出任何项目。这说明了操作符的协调作用。
- en: Reactive Programming Libraries
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应式编程库
- en: Java has many reactive programming libraries. In this book, we are using SmallRye
    Mutiny, the reactive programming library integrated in Quarkus. We will have a
    deeper look at Mutiny in [Chapter 7](ch07.html#mutiny). Project Reactor and RxJava,
    two popular alternatives, propose similar concepts.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Java拥有许多响应式编程库。在本书中，我们使用的是SmallRye Mutiny，这是集成在Quarkus中的响应式编程库。我们将在[第7章](ch07.html#mutiny)深入了解Mutiny。Project
    Reactor和RxJava是两个流行的替代方案，提出了类似的概念。
- en: Reactive programming is not limited to Java. [RX-JS](https://oreil.ly/pF21o)
    is a reactive programming library in JavaScript, often used in combination with
    Angular. [RxPY](https://oreil.ly/tlGl1) and [RxGo](https://oreil.ly/Mg4Rj) offer
    the same type of constructs for Python and Go applications, respectively.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程不局限于Java。[RX-JS](https://oreil.ly/pF21o) 是JavaScript中的一个响应式编程库，经常与Angular一起使用。[RxPY](https://oreil.ly/tlGl1)
    和 [RxGo](https://oreil.ly/Mg4Rj) 分别为Python和Go应用程序提供了相同类型的构造。
- en: Reactive Streams and the Need for Flow Control
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式流和流量控制的需求
- en: 'Using data streams as primary constructs does not come without issues. One
    of the main problems is the need for flow control. Let’s imagine a fast producer
    and a slow consumer. The producer sends events too quickly for the consumer, which
    can’t keep up. Imagine that this producer emits an item every 10 milliseconds,
    while a downstream consumer can consume only one per second. Run the code in [Example 5-25](#reactive-programming::streams-back-pressure-failure),
    and you’ll see how it ends: badly.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数据流作为主要构建块并非没有问题。其中一个主要问题是需要流量控制。让我们想象一个快速的生产者和一个慢速的消费者。生产者每10毫秒发送一个事件，而下游消费者每秒只能消费一个。运行[示例 5-25](#reactive-programming::streams-back-pressure-failure)中的代码，你会看到它的结局：很糟糕。
- en: Example 5-25\. Example of backpressure failure (*chapter-5/reactive-programming-examples/src/main/java/org/acme/streams/BackPressureExample.java*)
  id: totrans-162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-25\. 回压失败示例（*chapter-5/reactive-programming-examples/src/main/java/org/acme/streams/BackPressureExample.java*）
- en: '[PRE24]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If you run that code, you will see that the subscriber gets `MissingBackPressureFailure`,
    indicating that the downstream could not keep up ([Example 5-26](#reactive-programming::stream-back-pressure-failure-output)).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行那段代码，你会看到订阅者收到`MissingBackPressureFailure`，表明下游无法跟上（见[示例 5-26](#reactive-programming::stream-back-pressure-failure-output)）。
- en: Example 5-26\. Subscriber getting a `BackPressureFailure`
  id: totrans-165
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例5-26\. 订阅者收到`BackPressureFailure`
- en: '[PRE25]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note
  id: totrans-167
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: In [Example 5-25](#reactive-programming::streams-back-pressure-failure), you
    may wonder about `emitOn`. This operator controls when a thread is used to emit
    the events.^([4](ch05.html#idm45358828159456)) Backpressure is required when multiple
    threads are involved because in a single thread, blocking the thread would block
    the source.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 5-25](#reactive-programming::streams-back-pressure-failure)中，你可能会对`emitOn`感到疑惑。这个操作符控制何时使用线程来发出事件。^([4](ch05.html#idm45358828159456))
    当涉及多个线程时，需要反压力，因为在单个线程中，阻塞线程会阻塞源。
- en: So, what can we do to handle this case?
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们可以怎么处理这种情况呢？
- en: Buffering Items
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓冲项目
- en: The first natural solution uses buffers. The consumer can buffer the events,
    so it does not fail ([Figure 5-10](#image:rp-buffer)).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个自然的解决方案是使用缓冲区。消费者可以缓冲事件，这样就不会失败（见[图 5-10](#image:rp-buffer)）。
- en: '![Buffering to avoid overwhelming downstream consumers](assets/rsij_0510.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![缓冲以避免淹没下游消费者](assets/rsij_0510.png)'
- en: Figure 5-10\. Buffering to avoid overwhelming downstream consumers
  id: totrans-173
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-10\. 缓冲以避免淹没下游消费者
- en: Buffers allow handling small bumps, but they’re not a long-term solution. If
    you update your code to use a buffer, as in [Example 5-27](#reactive-programming::streams-back-pressure-buffer),
    the consumer can handle more events but eventually fails.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区允许处理小的颠簸，但它们不是长期解决方案。如果你更新你的代码以使用缓冲区，就像[示例 5-27](#reactive-programming::streams-back-pressure-buffer)中那样，消费者可以处理更多事件，但最终会失败。
- en: Example 5-27\. Handle overflow with buffers (*chapter-5/reactive-programming-examples/src/main/java/org/acme/streams/BufferingExample.java*)
  id: totrans-175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例5-27\. 使用缓冲区处理溢出（*chapter-5/reactive-programming-examples/src/main/java/org/acme/streams/BufferingExample.java*）
- en: '[PRE26]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here’s the output:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '[PRE27]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You can imagine increasing the buffer’s size, but it’s hard to anticipate the
    optimal value. These buffers are local to the application, so, using large buffers
    also increases your memory consumption and reduces your resource utilization efficiency.
    Not to mention that unbounded buffers are a terrible idea, as you may run out
    of memory.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以想象增加缓冲区的大小，但很难预测最佳值。这些缓冲区是应用程序本地的，因此使用大缓冲区也会增加内存消耗并降低资源利用效率。更不用说无界缓冲区是个糟糕的主意，因为可能会耗尽内存。
- en: Dropping Items
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 丢弃项目
- en: Another solution consists of dropping items. We can drop the newest received
    items or oldest ones; see [Example 5-28](#reactive-programming::streams-back-pressure-drop).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种解决方案是丢弃项目。我们可以丢弃最新接收到的项目或最旧的项目；参见[示例 5-28](#reactive-programming::streams-back-pressure-drop)。
- en: Example 5-28\. Handle overflow by dropping items (*chapter-5/reactive-programming-examples/src/main/java/org/acme/streams/DropExample.java*)
  id: totrans-182
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例5-28\. 通过丢弃项目来处理溢出（*chapter-5/reactive-programming-examples/src/main/java/org/acme/streams/DropExample.java*）
- en: '[PRE28]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here’s the output:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '[PRE29]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Dropping items provides a sustainable solution to our problem, but we are losing
    items! As we can see in the preceding output, we may drop the majority of items.
    In many cases, this is not acceptable.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 丢弃项目提供了一个可持续的解决方案，但我们正在失去项目！正如我们在前面的输出中看到的那样，我们可能会丢弃大部分项目。在许多情况下，这是不可接受的。
- en: We need another solution, one that adjusts the overall pace to satisfy the pipeline’s
    slowest element. We need a backpressure protocol.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要另一个解决方案，一个可以调整整体速度以满足管道最慢元素的反压力协议。
- en: What Is Backpressure?
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是反压力？
- en: In mechanics, backpressure is a way to control the flow of fluid through pipes,
    leading to a pressure drop. That control can use reducers or bends. While this
    is great if you are a plumber, it’s not clear how it can help us here.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在力学中，反压是控制液体通过管道流动的一种方法，导致压力降低。这种控制可以使用减压器或弯头。如果你是一名管道工，这非常棒，但目前不清楚它如何对我们有所帮助。
- en: We can see our streams as a flow of fluid, and the set of stages (operator or
    subscriber) forms a pipe. We want to make the fluid flow as frictionless as possible,
    without swirls and waves.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以把我们的流想象成流体的流动，而阶段的集合（操作者或订阅者）形成管道。我们希望尽可能使流体流动起来没有摩擦和波浪。
- en: 'An interesting characteristic of fluid mechanics is the way a downstream reduction
    of the throughput affects the upstream. Essentially, that’s what we need: a way
    for the downstream operators and subscribers to reduce the throughput, not only
    locally but also upstream.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 流体力学的一个有趣特性是下游吞吐量的降低会如何影响上游。基本上，这就是我们需要的：一种让下游操作符和订阅者减少吞吐量的方式，不仅仅在本地，还有在上游。
- en: 'Don’t be mistaken; backpressure is not something new in the IT world and is
    not limited to Reactive. One of the most brilliant uses of backpressure is in
    TCP.^([5](ch05.html#idm45358827846624)) A reader receiving data can block the
    writer on the other side of the wire if it does not read the sent data. That way,
    the reader is never overwhelmed. But the consequences need to be understood: blocking
    the writer may not be without side effects.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 不要误解；背压并不是IT世界的新事物，也不仅限于响应式。背压在TCP中有着非常出色的运用。^([5](ch05.html#idm45358827846624))
    数据接收者可以阻塞另一端的写入者，如果它不读取发送的数据。这样，数据接收者永远不会被压倒。但是，需要理解其后果：阻塞写入者可能不是没有副作用的。
- en: Introducing Reactive Streams
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引入响应式流
- en: 'Let’s now focus on another backpressure protocol: Reactive Streams. This asynchronous
    and backpressure protocol is suited to our fast producer/slow consumer problem.
    With Reactive Streams, the consumer, named `Subscriber`, requests items from the
    producer, named `Publisher`. As depicted in [Figure 5-11](#image:rp-control-flow),
    `Publisher` cannot send more than the requested number of items.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们专注于另一个背压协议：响应式流。这种异步和背压协议非常适合我们的快速生产者/慢速消费者问题。使用响应式流，消费者，称为`Subscriber`，从生产者，称为`Publisher`，请求项目。如图
    [Figure 5-11](#image:rp-control-flow) 所示，`Publisher` 不能发送超过请求的项目数量。
- en: '![Using flow control to avoid overwhelming consumers](assets/rsij_0511.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![使用流控制来避免消费者过载](assets/rsij_0511.png)'
- en: Figure 5-11\. Using flow control to avoid overwhelming consumers
  id: totrans-196
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-11\. 使用流控制来避免消费者过载
- en: When the items are received and processed, the consumer can request more items,
    and so on. Thus, the consumer controls the flow.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当接收并处理项目时，消费者可以请求更多项目，依此类推。因此，消费者控制着流量。
- en: Note that Reactive Streams introduces a strong coupling between a consumer and
    a producer. The producer must listen to the requests from the consumer.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，响应式流引入了消费者和生产者之间的强耦合。生产者必须监听来自消费者的请求。
- en: To implement that protocol, Reactive Streams defines a set of entities. First,
    `Subscriber` is a consumer. It subscribes to a stream, called `Publisher`, which
    produces items ([Figure 5-12](#image:rp-back-pressure-sequence)). Then `Publisher`
    sends, asynchronously, a `Subscription` object to `Subscriber`. This `Subscription`
    object is a contract. With `Subscription`, `Subscriber` can request items and
    then cancel the subscription when it does not want any more items. Each subscriber
    subscribing to a publisher gets a different `Subscription`, and so emits independent
    requests. The publisher implementation is in charge of the orchestration of the
    various requests and the emission of the items to the multiple subscribers.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现该协议，响应式流定义了一组实体。首先，`Subscriber` 是一个消费者。它订阅一个称为`Publisher`的流，该流产生项目（见图 [Figure 5-12](#image:rp-back-pressure-sequence)）。然后，`Publisher`
    异步地发送一个 `Subscription` 对象给 `Subscriber`。这个 `Subscription` 对象是一个合约。通过 `Subscription`，`Subscriber`
    可以请求项目，然后在不想要更多项目时取消订阅。每个订阅者订阅一个发布者都会得到一个不同的 `Subscription`，因此发出独立的请求。发布者的实现负责协调各种请求并向多个订阅者发出项目。
- en: '![Example of interactions between a `Subscriber` and a `Publisher`](assets/rsij_0512.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![一个`Subscriber`和`Publisher`之间交互的示例](assets/rsij_0512.png)'
- en: Figure 5-12\. Example of interactions between `Subscriber` and `Publisher`
  id: totrans-201
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-12\. `Subscriber` 和 `Publisher` 之间交互的示例
- en: '`Publisher` cannot send more items than requested to `Subscriber`, and `Subscriber`
    can request more items at any time.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`Publisher` 不能发送超过 `Subscriber` 请求的项目数量，并且 `Subscriber` 随时可以请求更多项目。'
- en: It is essential to understand that the requests and emissions are not necessarily
    happening synchronously. `Subscriber` can request three items, and `Publisher`
    will send them one by one when they are available.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 需要理解的关键是请求和发射不一定是同步发生的。`Subscriber` 可以请求三个项目，`Publisher` 将在可用时逐个发送它们。
- en: Reactive Streams introduces another entity named `Processor`. `Processor` is
    a subscriber and a publisher simultaneously. In other words, it’s a link in our
    pipeline, as shown in [Figure 5-13](#image:rp-back-processor).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Reactive Streams引入了另一个名为`Processor`的实体。`Processor`同时是订阅者和发布者。换句话说，它是我们管道中的一个链接，如图[5-13](#image:rp-back-processor)所示。
- en: '![Example of interactions between a `Subscriber`, a `Processor` and a `Publisher`](assets/rsij_0513.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![展示了`Subscriber`、`Processor`和`Publisher`之间相互作用的示例](assets/rsij_0513.png)'
- en: Figure 5-13\. Example of interactions between `Subscriber`, `Processor`, and
    `Publisher`
  id: totrans-206
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-13\. 交互示例，展示了`Subscriber`、`Processor`和`Publisher`之间的相互作用。
- en: '`Subscriber` calls `subscribe` on `Processor`. Before receiving a `Subscription`,
    `Processor` subscribes to its own upstream source (`Publisher` in [Figure 5-13](#image:rp-back-processor)).
    When that upstream provides `Subscription` to our `Processor`, it can give `Subscription`
    to `Subscriber`. All these interactions are asynchronous. When this handshake
    completes, `Subscriber` can start requesting items. `Processor` is responsible
    for mediating the `Subscriber` requests with its upstream. For example, as illustrated
    in [Figure 5-13](#image:rp-back-processor), if `Subscriber` requires two items,
    `Processor` also requests two items to its own upstream. Of course, depending
    on the `Processor` code, it may not be that simple. What’s fundamental is that
    each `Publisher` and `Processor` enforces the flowing requests to never overload
    downstream subscribers.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`Subscriber`在`Processor`上调用`subscribe`。在接收到`Subscription`之前，`Processor`订阅其自身的上游源（在[图
    5-13](#image:rp-back-processor)中称为`Publisher`）。当上游为我们的`Processor`提供`Subscription`时，它可以将`Subscription`提供给`Subscriber`。所有这些交互都是异步的。当这个握手完成时，`Subscriber`可以开始请求项目。`Processor`负责在其上游和下游之间调解`Subscriber`的请求。例如，如图[5-13](#image:rp-back-processor)所示，如果`Subscriber`需要两个项目，`Processor`也会向其自身的上游请求两个项目。当然，根据`Processor`的代码，情况可能并不那么简单。重要的是，每个`Publisher`和`Processor`都强制执行流动请求，以防止过载下游订阅者。'
- en: 'Be Warned: It’s a Trap!'
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 警告：这是一个陷阱！
- en: 'If you look at the Reactive Streams API,^([6](ch05.html#idm45358827782352))
    you will find it *simple*: a few classes, a couple of methods. It’s a trap! Behind
    this apparent simplicity, implementing Reactive Streams entities yourself is a
    nightmare. The problem is not the interfaces; it’s the protocol. Reactive Streams
    comes with a broad set of rules, and a strict Technology Compatibility Kit (TCK)
    to verify that your implementation enforces the protocol.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看Reactive Streams API^([6](ch05.html#idm45358827782352))，你会发现它*看起来*很简单：几个类，几个方法。这是一个陷阱！在这种表面简单背后，自己实现Reactive
    Streams实体是一场噩梦。问题不在于接口，而在于协议。Reactive Streams带来了广泛的规则，以及一个严格的技术兼容性测试套件（TCK），用于验证你的实现是否符合协议。
- en: Fortunately, you don’t need to implement publishers, subscribers, or processors
    yourself. Recent reactive programming libraries already implement the protocol
    for you. Project Reactor, RxJava (versions 2 and 3), and Mutiny implement the
    specification. For example, Mutiny’s `Multi` is a publisher following the Reactive
    Streams protocol. All the subscription handshakes and request negotiations are
    done for you.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你不需要自己实现发布者、订阅者或处理器。最近的响应式编程库已经为你实现了协议。例如，Mutiny的`Multi`是遵循Reactive Streams协议的发布者。所有订阅握手和请求协商都已为你完成。
- en: 'Also, because all these libraries are using the same core concepts and API,
    it allows smooth integration: you can consume a Reactor `Flux` by using a Mutiny
    `Subscriber` and vice versa! Reactive Streams is the integration layer between
    the various reactive programming libraries, in addition to being a backpressure
    protocol.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，由于所有这些库都使用相同的核心概念和API，它允许平滑集成：你可以通过使用Mutiny的`Subscriber`来消费Reactor的`Flux`，反之亦然！除了作为背压协议外，Reactive
    Streams还是各种响应式编程库之间的集成层。
- en: Backpressure in Distributed Systems
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分布式系统中的背压
- en: Reactive Streams works perfectly within a local node, but what about distributed
    systems? In such a system, it’s important that event producers do not overflow
    the consumers. We need flow control. Fortunately, we have many alternatives.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Reactive Streams在本地节点内运行得很完美，但在分布式系统中呢？在这样的系统中，重要的是事件生产者不要溢出消费者。我们需要流量控制。幸运的是，我们有很多替代方案。
- en: First, RSocket is proposing a distributed variant of Reactive Streams. However,
    because of distributed systems’ challenges and potential communication disruptions,
    the protocol requires a few adaptations.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，RSocket提出了一种分布式的响应式流变体。然而，由于分布式系统面临的挑战和潜在的通信中断，协议需要进行一些适应。
- en: AMQP 1.0 uses a [flow control protocol based on credit](https://oreil.ly/ZKURr).
    As a producer, you get a certain amount of credit. When you run out of credit,
    you can’t send messages anymore. The broker refills your credit according to the
    consumer pace.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: AMQP 1.0 使用基于信用的[流控制协议](https://oreil.ly/ZKURr)。作为生产者，你会得到一定数量的信用。当你的信用用完时，你就无法再发送消息了。代理根据消费者的速度重新填充你的信用。
- en: Apache Kafka consumers can also implement backpressure by using pause/resume
    cycles and explicit polling. In this case, Kafka does not prevent the production
    of messages. It stores the messages in the broker, and uses it as a large buffer.
    The consumer polls the messages according to its capacity.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Kafka 消费者也可以通过使用暂停/恢复周期和显式轮询来实现背压。在这种情况下，Kafka 不会阻止消息的产生。它将消息存储在代理中，并将其用作大型缓冲区。消费者根据其容量轮询消息。
- en: The mechanism presented for AMQP 1.0 and Apache Kafka are not the same as Reactive
    Streams. Frameworks, such as Quarkus, create bridges between these mechanisms
    with the Reactive Streams protocol.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 所呈现的 AMQP 1.0 和 Apache Kafka 的机制与反应式流不同。像 Quarkus 这样的框架使用反应式流协议在这些机制之间创建桥梁。
- en: Summary
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, you have learned the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学到了以下内容：
- en: Asynchronous code is hard but is required to avoid discarding the benefits of
    nonblocking I/O.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步代码很难，但是为了避免丢弃非阻塞 I/O 的好处，这是必需的。
- en: Reactive programming is one possibility for writing asynchronous code.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应式编程是编写异步代码的一种可能性。
- en: Reactive programming uses data streams as primary constructs. You write a processing
    pipeline reacting to events flowing from upstream.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应式编程以数据流作为主要构造。你编写一个处理管道来对来自上游的事件做出反应。
- en: Reactive Streams is an essential aspect of Reactive. It avoids overwhelming
    fragile parts of your system.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应式流是反应式的一个重要方面。它避免了你系统中脆弱部分的不堪重负。
- en: Small cracks that ripple in your system can lead to dreadful consequences.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的系统中出现的细微裂缝可能导致可怕的后果。
- en: Now, you have enough knowledge about Reactive to build your own reactive systems
    and appreciate the benefits. Wait! You may need some more concrete details, no?
    That’s what we are going to cover in [Part III](part03.html#quarkus-part), where
    we explore how easy it is to build reactive systems with Quarkus.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经有足够的了解来构建自己的反应式系统并体会到其好处。等等！你可能需要一些更具体的细节，不是吗？这就是我们将在[第三部分](part03.html#quarkus-part)中介绍的内容，我们将探讨如何使用
    Quarkus 轻松构建反应式系统。
- en: ^([1](ch05.html#idm45358829664160-marker)) The Vert.x 3 main development model
    uses callbacks. Many operations pass a callback receiving `AsyncResult`. In Vert.x
    4, an alternative model using futures has been introduced.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch05.html#idm45358829664160-marker)) Vert.x 3 的主要开发模型使用回调。许多操作通过接收 `AsyncResult`
    的回调传递。在 Vert.x 4 中，引入了一个使用 futures 的备用模型。
- en: ^([2](ch05.html#idm45358829062432-marker)) Check the [Project Loom site](https://oreil.ly/arP4E)
    for updates on the general availability.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch05.html#idm45358829062432-marker)) 查看[Project Loom 网站](https://oreil.ly/arP4E)以获取一般可用性的更新。
- en: ^([3](ch05.html#idm45358828566736-marker)) In functional programming, `transform`
    is often called `map`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch05.html#idm45358828566736-marker)) 在函数式编程中，`transform` 常被称为 `map`。
- en: ^([4](ch05.html#idm45358828159456-marker)) More details about `emitOn` can be
    found in the [Mutiny online guides](https://oreil.ly/qrVdD).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch05.html#idm45358828159456-marker)) 可以在[Mutiny 在线指南](https://oreil.ly/qrVdD)中找到有关
    `emitOn` 的更多详细信息。
- en: ^([5](ch05.html#idm45358827846624-marker)) We recommend reading [“Using Backpressure
    to Improve TCP Performance with Many Flows”](https://oreil.ly/JEbNh) by Carlos
    M. Pazos et al., which explains how TCP backpressure can be used to improve performance.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch05.html#idm45358827846624-marker)) 我们建议阅读 Carlos M. Pazos 等人的[“使用背压提高具有多个流的
    TCP 性能”](https://oreil.ly/JEbNh)，该文解释了如何使用 TCP 背压来提高性能。
- en: ^([6](ch05.html#idm45358827782352-marker)) For more information, see the [Reactive
    Streams Javadoc](https://oreil.ly/mcYRu).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch05.html#idm45358827782352-marker)) 欲知更多信息，请参阅[反应式流 Javadoc](https://oreil.ly/mcYRu)。
