- en: Chapter 3\. An Introduction to Containers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章。容器简介
- en: Melissa McKay
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 梅丽莎·麦凯
- en: Any fool can know. The point is to understand.
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 任何傻瓜都可以知道。关键在于理解。
- en: ''
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Albert Einstein
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 阿尔伯特·爱因斯坦
- en: If you know the why, you can live any how.
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你知道为什么，你可以任何怎样都行。
- en: ''
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Friedrich Nietzsche
  id: totrans-7
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 弗里德里希·尼采
- en: At the time of this writing, the use of containers in production and other environments
    is growing exponentially, and best practices around containerizing applications
    are still being discussed and defined. As we home in on efficiency improvements
    and consider specific use cases, techniques and patterns have evolved that come
    highly recommended by the blogosphere and professional practitioners through experience.
    And as expected, a fair share of patterns and common uses have evolved, as well
    as antipatterns that I hope this chapter will help you recognize and avoid.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，生产和其他环境中使用容器的使用正在呈指数级增长，而围绕应用容器化的最佳实践仍在讨论和定义中。随着我们专注于效率提升并考虑具体用例，经验丰富的博客圈和专业实践者已经发展出了一些高度推荐的技术和模式。并且如预期的那样，已经发展出了相当一部分模式和常见用途，以及希望本章能帮助您识别和避免的反模式。
- en: My own trial-and-error introduction to containers felt like stirring up a hornet’s
    nest (oh, the stings!). I was undeniably unprepared. Containerization on the surface
    is deceptively simple. Knowing what I know now about how to develop and deploy
    with containers, especially within the Java ecosystem, I hope to pass this knowledge
    on in a way that will help prevent similar pain for you. This chapter outlines
    the essential concepts you will need to successfully containerize your applications
    and discusses *why* you would even want to do such a thing.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我自己对容器的试错式介绍感觉就像是搅动了一个黄蜂窝（哦，那些蛰伤！）。毫无疑问，我毫无准备。表面上看，容器化似乎简单得令人难以置信。现在我知道如何在Java生态系统中开发和部署容器，我希望以一种方式传授这些知识，帮助你避免类似的痛苦。本章概述了您成功容器化应用所需的基本概念，并讨论了*为什么*您甚至想要做这样的事情。
- en: '[Chapter 4](ch04.xhtml#dissecting_the_monolith) discusses the bigger picture
    of microservices, but here we will start with learning about one of the basic
    building blocks of microservice deployments that you will no doubt encounter if
    you haven’t already: the container. Note that the concept of microservices, an
    architectural concern, *does not imply the use of containers*; rather, it’s the
    concern of *deploying* these services, especially in a cloud native environment,
    that usually begins the conversation around containerization.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[第四章](ch04.xhtml#dissecting_the_monolith)讨论了微服务的更大图景，但在这里我们将从学习微服务部署的基本构建块开始，如果您尚未遇到的话，您无疑会遇到：容器。请注意，微服务的概念作为一种架构关注，并不意味着一定要使用容器；相反，特别是在云原生环境中部署这些服务通常是围绕容器化展开对话的关键。'
- en: Let’s start with considering *why* we would use a container. The best way to
    do that is to back up and get some context on how we got here to begin with. Patience
    is a virtue. If you persevere, going through this history lesson will also naturally
    lead you to a clearer understanding of *what* a container actually is.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从考虑*为什么*我们会使用容器开始。做到这点的最佳方式是回过头来，了解我们是如何开始的。耐心是一种美德。如果你坚持不懈，通过这段历史课程将自然而然地使你更清楚地理解*什么*是容器。
- en: Understanding the Problem
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解问题的本质
- en: I’m certain I’m not alone in experiencing the company of an “elephant in the
    room.” Despite the looming frame, deafening noise, and potential for dangerous
    consequences when ignored, this elephant-sized subject is just allowed to roam,
    unchallenged. I’ve witnessed it. I’m guilty of it. I’ve even had the distinct
    pleasure of *being* said elephant.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我确信我不是唯一一个经历“房间里的大象”陪伴的人。尽管庞大的身影、震耳欲聋的噪音以及被忽视时可能带来的危险后果，这个象大小的主题却被允许自由漫游，毫无挑战地。我亲眼目睹过。我也有过这样的罪行。我甚至曾经有幸*成为*这只大象。
- en: 'In the context of containerization, I’m going to make the argument that we
    need to address *two* elephants in the room—in the form of two questions: *What
    is a container?* and *Why would we use a container?* Those sound simple enough.
    How could anyone miss these basic starting points?'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器化的背景下，我要提出这样一个论点，我们需要解决*两只*房间里的大象——以两个问题的形式：*什么是容器？*和*为什么我们会使用容器？*听起来很简单。怎么可能有人会忽略这些基本的起点呢？
- en: Perhaps it’s because the microservice movement tends to lead into discussions
    about deploying containers more now than ever, and we’re suffering from the fear
    of missing out. Maybe it’s because a container implementation is expected by default
    with the exceedingly popular Kubernetes ride, and “our K8s cluster” is the cool
    new phrase to include in our conversations. It might even just be that we are
    suffering such an onslaught of new technologies and tools in the DevOps ecosystem
    that, as a developer (a Java developer, no less), if we stop to ask questions,
    we fear getting left behind. Whatever the reasons may be, before we can even get
    into the details of how to build and use containers, these *what* and *why* questions
    must be addressed.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 或许这是因为微服务运动现在比以往任何时候都更多地引入了有关部署容器的讨论，我们担心错过时机。也许这是因为容器实施在目前极为流行的Kubernetes潮流中被默认期望，而“我们的K8s集群”是我们对话中的新潮流。甚至可能仅仅是因为在DevOps生态系统中，我们面临如此多的新技术和工具的攻击，作为开发者（尤其是Java开发者），如果我们停下来问问题，我们就害怕被落下。无论原因如何，在我们甚至能够详细讨论如何构建和使用容器之前，这些*什么*和*为什么*的问题必须先解决。
- en: 'I’m deeply grateful for the incredible colleagues and mentors I’ve had the
    privilege of working with over the years. I frequently recall, from the formative
    years of my career, sage advice that has become a mantra of mine. It’s simple;
    always begin and then proceed working on any project with a constant, repeating
    question in mind: *What is the problem you are trying to solve?* The success of
    your solution will be measured by how well it meets this requirement—that it indeed
    solves the original problem.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，我有幸与不可思议的同事和导师们一起工作，对此深表感激。在职业生涯的初期，我经常回想起一些至理名言。它很简单；始终以一个不断重复的问题开始并继续进行任何项目的工作：*你试图解决的问题是什么？*
    你解决方案的成功将取决于它如何满足这个要求——确实解决了最初的问题。
- en: 'Carefully consider whether you are solving the right problem to begin with.
    Be especially vigilant to reject problem statements that are actually implementation
    instructions in disguise, like this one: *Improve the performance of your application
    by breaking it into containerized microservices*. You will be better served by
    a problem statement like this: *To decrease the time it takes for customers to
    complete their objectives, improve the performance of the application by 5%*.
    Note that the latter statement includes a tangible metric to gauge success and
    is not restricted to a microservices implementation.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细考虑你是否从根本上解决了正确的问题。特别警惕拒绝那些实际上是实施指令的问题陈述，比如这样一个：*通过将应用程序分解为容器化的微服务来提高其性能*。你将更好地通过像这样一个问题陈述服务：*为了减少客户完成目标所需的时间，将应用程序的性能提高5%*。请注意，后者包含一个具体的度量标准来衡量成功，并不限于微服务的实现。
- en: This same principle applies to your day-to-day choices in what tools you use,
    what frameworks and languages you choose to code within, how you choose to design
    a system, and even how you package and deploy your software to production. What
    problem are you solving with the choices you’ve made? And how do you know if you’ve
    chosen the best tool for the job? One way is to understand the problem the particular
    tool under review is intended to solve. And the best way to do that is to look
    at its history. This practice should be in place for every tool you pick up to
    use. I guarantee that you will make better decisions knowing its history, and
    you will benefit from skirting known pitfalls or, at the very least, have some
    justification for accepting any disadvantages and moving forward anyway.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则同样适用于你日常选择使用的工具、选择编码的框架和语言、你如何设计系统，甚至如何打包和部署软件到生产环境。你所做的选择解决了什么问题？你如何知道你选择了最合适的工具？其中一种方法是了解特定工具旨在解决的问题。而了解其历史是做到这一点的最佳方式。这种做法应该适用于你使用的每一个工具。我保证，了解其历史后，你将能做出更好的决策，并从绕过已知的陷阱中受益，或者至少有理由接受任何不利因素并继续前进。
- en: My plan is not to completely bore you with historical details, but you should
    know some basic information and important milestones before jumping into containerizing
    every bit of code put in front of you. By understanding more about the original
    problem and the solutions that have come out of it, you’ll be able to intelligently
    explain why you are choosing to deploy with containers.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我的计划不是要完全无聊地向你讲述历史细节，但在你开始对每一行代码进行容器化之前，你应该了解一些基本信息和重要的里程碑。通过更多地了解原始问题及其解决方案，你将能够智能地解释为什么选择使用容器进行部署。
- en: I don’t want to go all the way back to the Big Bang, but I’m going to go back
    more than 50 years, mostly to make the point that virtualization and containerization
    are not new. In fact, this concept has been worked on and improved for more than
    half a century. I’ve picked out some points to highlight that will bring us up
    to speed quickly. This is not intended to be a deep technical manual on any of
    the topics mentioned—rather, just enough material to wrap your mind around the
    progress that has been made over time and how we’ve ended up where we are today.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我不打算回溯到宇宙大爆炸，但我会回顾50多年前的情况，主要是为了表明虚拟化和容器化并不是新概念。事实上，这个概念已经经过半个多世纪的努力和改进。我挑选了一些重点来快速介绍，让我们跟上时代的步伐。这不是深入技术的手册，而是足够让你了解随着时间的推移取得的进展以及我们是如何达到今天的地步的一些材料。
- en: Let’s begin.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始。
- en: The History of Containers
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器的历史
- en: In the 1960s and ’70s, computing resources were in general exceptionally limited
    and expensive (by today’s standards). It took a long time for processes to complete
    (again, by today’s standards), and it was common for a computer to be dedicated
    for a long period of time to a single task for a single user. Efforts were begun
    to improve the sharing of compute resources and address the bottlenecks and inefficiency
    brought by these limitations. But just being able to share resources was not enough.
    A need arose for a method of sharing resources without getting in each other’s
    way or having one person inadvertently cause an entire system to crash for everyone.
    Both hardware and software that advanced virtualization technology started to
    trickle in. One development in software is `chroot`, which is where we’ll begin.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在20世纪60年代和70年代，计算资源一般极为有限且昂贵（按今天的标准）。进程完成需要很长时间（同样按今天的标准），通常一个计算机会长时间专门为单个用户的单个任务而运行。开始了改进计算资源共享和解决这些限制带来的瓶颈和低效的努力。但仅仅能够共享资源还不够。出现了一种需求，即在互相不干扰或者导致一个人无意间导致整个系统崩溃的情况下共享资源的方法。硬件和软件方面推进了虚拟化技术的发展。软件方面的一个发展是`chroot`，我们将从这里开始。
- en: In 1979, during the development of the seventh edition of Unix, `chroot` was
    developed and then in 1982 was added to the Berkeley Software Distribution (BSD).
    This system command changed the apparent root directory for a process and its
    children, which resulted in a limited view of the filesystem in order to provide
    an environment for testing a different distribution, for example. Although a step
    in the right direction, `chroot` was just a start on the path to providing the
    isolation of applications required from us today. In 2000, FreeBSD expanded the
    concept and introduced the more sophisticated `jail` command and utility in FreeBSD
    4.0\. Its features (improved in the later 5.1 and 7.2 releases) help further isolate
    filesystems, users, and networks, and include the ability to assign an IP address
    to each `jail`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 1979年，在Unix第七版开发期间，开发了`chroot`，并在1982年加入了伯克利软件分发（BSD）。这个系统命令改变了进程及其子进程的根目录，导致文件系统的视图受限，以提供一个测试不同分发环境的环境，例如。尽管是朝着正确方向迈出的一步，但`chroot`只是提供我们今天所需应用隔离的开端。2000年，FreeBSD扩展了这个概念，并在FreeBSD
    4.0版中引入了更复杂的`jail`命令和实用程序。其功能（在稍后的5.1和7.2版本中得到改进）有助于进一步隔离文件系统、用户和网络，并包括为每个`jail`分配IP地址的能力。
- en: In 2004, Solaris containers and zones brought us ahead even further by giving
    an application full user, process, and filesystem space and access to system hardware.
    Google jumped in with its *process containers* in 2006, later renamed *cgroups*,
    which centered around isolating and limiting the resource usage of a process.
    In 2008, *cgroups* were merged into the Linux kernel, which, along with Linux
    namespaces, led to IBM’s development of Linux Containers (LXC).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 2004年，Solaris容器和区域使我们更进一步，通过给应用程序提供完整的用户、进程和文件系统空间以及系统硬件访问权限。 谷歌在2006年推出了其*进程容器*，后来改名为*cgroups*，它的核心是隔离和限制进程的资源使用。
    2008年，*cgroups*被合并到Linux内核中，随后，与Linux命名空间一起，IBM开发了Linux容器（LXC）。
- en: Now things get even more interesting. Docker became open source in 2013\. That
    same year, Google offered its Let Me Contain That For You (lmctfy) open source
    project, which gave applications the ability to create and manage their own subcontainers.
    And from there, we saw the use of containers explode—Docker containers specifically.
    Initially, Docker used LXC as its default execution environment, but in 2014 Docker
    chose to swap out its use of the LXC toolset for launching containers with *libcontainer*,
    a native solution written in Go. Soon after, the lmctfy project ceased active
    development with the intention of joining forces and migrating the core concepts
    to the libcontainer project.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在事情变得更加有趣。 Docker在2013年成为开源项目。 同年，谷歌提供了其Let Me Contain That For You（lmctfy）开源项目，该项目使应用程序能够创建和管理自己的子容器。
    从那时起，我们看到了容器的使用激增——尤其是Docker容器。 最初，Docker将LXC作为其默认的执行环境，但在2014年，Docker选择将其用于启动容器的LXC工具集替换为*libcontainer*，这是一个用Go编写的本地解决方案。
    不久之后，lmctfy项目停止了活跃开发，并打算与libcontainer项目合作，并将核心概念迁移到libcontainer项目中。
- en: A lot more happened during this period of time. I’m intentionally skipping over
    additional details about other projects, organizations, and specifications that
    were developed because I want to get to a specific event in 2015\. This event
    is especially important because it will give you some insight into some of the
    activity and motivations behind shifts in the market, especially concerning Docker.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段时间内发生了很多事情。 我故意跳过了关于其他项目、组织和规范的更多细节，因为我想要谈论的是2015年的一个特定事件。 这个事件尤其重要，因为它将让您对市场变化背后的一些活动和动机有所了解，特别是涉及Docker的情况。
- en: On June 22, 2015, the establishment of the [Open Container Initiative (OCI)](https://oreil.ly/Vsr6U)
    was announced. This is an organization under the [Linux Foundation](https://oreil.ly/J5ioU)
    with the goal of creating open standards for container runtimes and image specification.
    Docker is a heavy contributor, but Docker’s announcement of this new organization
    listed participants including Apcera, Amazon Web Services (AWS), Cisco, CoreOS,
    EMC, Fujitsu, Google, Goldman Sachs, HP, Huawei Technologies, IBM, Intel, Joyent,
    Pivotal Software, the Linux Foundation, Mesosphere, Microsoft, Rancher Labs, Red
    Hat, and VMware. Clearly, the development of containers and the ecosystem around
    them has reached a significant point to glean this much attention, and has evolved
    to where establishing some common ground will be beneficial to all parties involved.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 2015年6月22日，宣布成立了[开放容器倡议组织（OCI）](https://oreil.ly/Vsr6U)。 这是[Linux基金会](https://oreil.ly/J5ioU)旗下的一个组织，旨在为容器运行时和镜像规范创建开放标准。
    Docker是重要的贡献者，但Docker宣布这个新组织时列出了参与者，包括Apcera，亚马逊网络服务（AWS），思科，CoreOS，EMC，富士通，谷歌，高盛，惠普，华为技术，IBM，英特尔，Joyent，Pivotal
    Software，Linux基金会，Mesosphere，微软，Rancher Labs，红帽和VMware。 显然，容器的发展及其周围的生态系统已经达到了一个引人注目的地步，并且发展到了确立一些共同基础对所有涉及方都有益处的地步。
- en: When the formation of the OCI was announced, Docker also announced its intention
    to donate its base container format and runtime, runC. In quick succession, *runC*
    became the reference implementation for the [OCI Runtime Specification](https://oreil.ly/lLia7),
    and the Docker v2 Schema 2 image format, donated in April 2016, became the basis
    for the [OCI Image Format Specification](https://oreil.ly/mmPu4). [Version 1.0
    of these specifications](https://oreil.ly/y6QwF) were both released in July 2017.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在OCI成立时，Docker还宣布了将捐赠其基础容器格式和运行时runC的意图。 紧随其后，*runC* 成为了[OCI运行时规范](https://oreil.ly/lLia7)的参考实现，而Docker
    v2 Schema 2镜像格式，在2016年4月捐赠，成为了[OCI镜像格式规范](https://oreil.ly/mmPu4)的基础。 [这些规范的版本1.0](https://oreil.ly/y6QwF)都于2017年7月发布。
- en: Note
  id: totrans-30
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '*runC* is a repackage of libcontainer, which meets the requirements of the
    OCI runtime specification. In fact, as of this writing, the [source code for runC](https://oreil.ly/hbUaP)
    contains a directory called *libcontainer*.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*runC*是libcontainer的一个再打包，符合OCI运行时规范的要求。事实上，截至本文撰写时，[runC的源代码](https://oreil.ly/hbUaP)中包含一个名为*libcontainer*的目录。'
- en: In tandem with developments in the container ecosystem, orchestration of these
    systems was also under rapid development. On July 21, 2015, one month after the
    OCI was established, Google released Kubernetes v1.0\. Along with this release,
    the [Cloud Native Computing Foundation (CNCF)](https://www.cncf.io) was established
    in partnership with Google and the Linux Foundation. Another important step taken
    by Google and released with v1.5 of Kubernetes in December 2016 was the development
    of the Container Runtime Interface (CRI), which created the level of abstraction
    needed to allow the Kubernetes machine daemon, *kubelet*, to support alternative
    low-level container runtimes. In March 2017, Docker, also a member of the CNCF,
    contributed its CRI-compatible runtime *containerd* that it had developed in order
    to integrate runC into Docker v1.11.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 随着容器生态系统的发展，这些系统的编排也在快速发展之中。2015年7月21日，在OCI成立一个月后，Google发布了Kubernetes v1.0。与此同时，[Cloud
    Native Computing Foundation (CNCF)](https://www.cncf.io)与Google和Linux基金会合作成立。Google在2016年12月发布的Kubernetes
    v1.5中另一个重要的进展是开发了容器运行时接口（CRI），这为Kubernetes的机器守护进程*kubelet*支持替代低级别容器运行时提供了必要的抽象层。2017年3月，CNCF的另一成员Docker贡献了其自己开发的与CRI兼容的运行时*containerd*，用于将runC整合到Docker
    v1.11中。
- en: In February 2021, Docker donated yet another reference implementation to the
    CNCF. This contribution was centered around the distribution of images (pushing
    and pulling container images). Three months later, in May 2021, the OCI released
    version 1.0 of the [OCI Distribution Spec](https://oreil.ly/JfGvb) based on the
    Docker Registry HTTP API V2 protocol.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 2021年2月，Docker向CNCF捐赠了另一个参考实现。此贡献集中于图像分发（推送和拉取容器镜像）。三个月后，即2021年5月，OCI基于Docker
    Registry HTTP API V2协议发布了版本1.0的[OCI分发规范](https://oreil.ly/JfGvb)。
- en: Today, the use of containers and orchestration systems like Kubernetes is typical
    fare for cloud native deployments. Containers are an important factor in keeping
    deployments flexible among a variety of hosts and play a huge role in scaling
    distributed applications. Cloud providers including AWS, Google Cloud, Microsoft
    Azure, and others are continuously bulking up their offerings using shared infrastructure
    and pay-per-use storage.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，像Kubernetes这样的容器编排系统在云原生部署中非常普遍。容器在保持在各种主机中灵活部署方面起着重要作用，并在扩展分布式应用程序方面发挥了重要作用。包括AWS、Google
    Cloud、Microsoft Azure在内的云服务提供商正在不断增强其提供的共享基础设施和按使用量付费的存储。
- en: Congratulations for getting through that bit of history! In a few paragraphs,
    we spanned more than 50 years of development and advancement. You were introduced
    to a lot of the projects that have evolved into our solutions as well as some
    of the common terms used in the context of containers and their deployment. You’ve
    also learned how much Docker has contributed to the state of containers today—which
    makes this a perfect time to get a solid understanding of the container ecosystem,
    the technical details behind containers, and the implementation components that
    come into play.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你已经走完了那段历史！在几段文字中，我们跨越了50多年的发展和进步。你已经了解了一些已经发展成为我们解决方案的项目，以及容器及其部署背景中使用的一些常见术语。你还了解了Docker对今天容器状态的重大贡献——这正是我们深入了解容器生态系统、容器背后的技术细节以及实施组件的理想时机。
- en: But wait! Before we dive into that, let’s discuss that second elephant. You
    learned a lot about *what* happened, but *why* did the industry shift in this
    way?
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等！在我们深入讨论之前，让我们讨论第二只大象。你已经了解了*发生了什么*，但是*为什么*行业会以这种方式转变呢？
- en: Why Containers?
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么要使用容器？
- en: Knowing what containers are and how to describe them is not enough. To talk
    intelligently about them, you should have some understanding of *why* they are
    used. What are the advantages of using containers? Some of this may seem obvious,
    given what you now know about containers and their history, but it’s worth going
    in depth before jumping into the fray. Project changes and any introduction of
    a new tech stack should always be intentional with a thoughtful cost-benefit analysis.
    Following the crowd is not a good enough reason in and of itself.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 知道容器是什么以及如何描述它们还不够。要能够有条理地讨论它们，你应该理解*为什么*使用它们。使用容器的优势是什么？鉴于你现在对容器及其历史的了解，其中一些可能显而易见，但在激烈竞争之前深入探讨仍然是值得的。项目变更和任何新技术栈的引入都应该经过深思熟虑的成本效益分析。跟风并不是一个足够的理由。
- en: Your first question is likely along the lines of *why are containers a developer’s
    concern?*—a valid question, indeed. If containers are simply a method of deployment,
    it seems that this should be in the wheelhouse of operations. It is here that
    we approach a blurry line between development and operations, an argument for
    a DevOps mindset. Packaging your app into a container involves more thought and
    foresight from the developer’s perspective than you may initially think. After
    you’ve learned some of the best practices and some of the problems encountered
    by others’ experience, you will find yourself considering the packaging *while*
    developing your application. Certain aspects of the process will drive the decisions
    you make about how your application or service uses memory, how it uses the filesystem,
    how you plug in observability hooks, how you allow for different configurations,
    and how you communicate with other services (such as databases). These are just
    a few examples. Ultimately, it will depend on how your team is organized, but
    on a DevOps team, I would expect that as a developer, knowing how to build and
    maintain container images and to understand the container environment will be
    valuable.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你的第一个问题很可能是：*为什么容器是开发者关注的事情？*——确实是一个合理的问题。如果容器只是一种部署方法，似乎这应该是运维的责任范围。在这里，我们接近了开发和运维之间模糊的界线，这是支持DevOps思维方式的一个论据。将你的应用打包成容器，从开发者的角度来看，需要比你最初想象的更多的思考和远见。在学习了一些最佳实践和他人经验中遇到的问题后，你会在开发应用的同时考虑打包的问题。在这个过程中的某些方面将影响你关于应用或服务如何使用内存、文件系统的决策，如何插入可观察性钩子，如何允许不同的配置，以及如何与其他服务（如数据库）通信。这些只是几个例子。最终，这将取决于你的团队如何组织，但在一个DevOps团队中，作为开发者，掌握如何构建和维护容器镜像以及理解容器环境将是非常有价值的。
- en: 'I recently had the opportunity to be part of a panel discussion for the Cloud
    and DevOps international track at The Developer’s Conference titled “Cloud Efficiency
    and Simplicity: What Will the Future Bring?” As part of this discussion, we talked
    about the current state of technologies available and where we would expect more
    simplification. I introduced the following question/analogy to the discussion:
    *How many of us would be driving cars today if we were expected to build our own?*
    We are still in very early stages of so many technologies in this area. The market
    is ripe for manufacturers of full-featured products that allow our software and
    services to take full advantage of the scalability, availability, and resilience
    that the cloud has to offer, packaged in a way that reduces complexity. However,
    we are still in the middle of designing the individual pieces and parts that would
    be used to build something like this.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我最近有机会参加了“开发者大会”云与DevOps国际专场的座谈会，主题是“云计算的效率与简易性：未来将会带来什么？”作为讨论的一部分，我们谈论了当前可用的技术状态以及我们期望更多简化的领域。我在讨论中引入了以下问题/类比：*如果我们期望自己制造汽车，今天有多少人会开车？*在这个领域的许多技术仍处于非常早期阶段。市场上急需能够充分利用云计算提供的可伸缩性、可用性和弹性，并以减少复杂性为目标打包的全功能产品制造商。然而，我们仍然在设计用于构建这样东西的各个部件和零件之中。
- en: Containers are a huge step in this direction, providing a useful level of abstraction
    between the packaging of an application and the infrastructure where it will be
    deployed. I anticipate a time when developers will no longer need to be involved
    in the details at the level of containers, but for now, *we should be*. At the
    very least, we should have a seat at the table to make sure that development concerns
    are addressed moving forward. To that end, and to satisfy any remaining doubts
    about why you should even broach the subject of containers, let’s learn more.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 容器在这方面是一个巨大的进步，提供了在打包应用程序和部署应用程序的基础设施之间提供有用的抽象级别。我预计有一天开发人员将不再需要涉及容器级别的细节，但目前，*我们应该*。至少，我们应该有一个位置来确保开发方面的问题在前进中得到解决。为了达到这个目的，以及消除你为什么甚至应该提出容器主题的任何剩余疑虑，让我们更多地了解一下。
- en: Think about all it takes to package, deploy, and run your Java application.
    To begin development, you install a particular version of the Java Development
    Kit (JDK) to your development machine. Then you might install a dependency manager
    such as Apache Maven or Gradle to pull in all of the needed third-party libraries
    you choose to use in your app and package it up into a WAR or a JAR file. At this
    point, it might be ready to deploy… *somewhere*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 想想打包、部署和运行你的Java应用程序需要做的一切。为了开始开发，你需要在开发机器上安装特定版本的Java开发工具包（JDK）。然后，你可能会安装诸如Apache
    Maven或Gradle之类的依赖管理器，以获取你选择在应用程序中使用的所有所需的第三方库，并将其打包成WAR或JAR文件。到这一步，它可能已经准备好部署到……
    *某个地方*。
- en: And here the problems begin. What is installed on the production server—what
    version of the Java runtime, what application server (for example, JBoss, Apache
    Tomcat, WildFly)? Are other processes running on the production server that might
    interfere with your application’s performance? Does your application require root
    access for any reason, and is your application user set up appropriately with
    the correct permissions? Does your app require access to external services like
    a database or APIs for alive or well checks? Before any of these questions can
    be answered, do you even have access to a dedicated production server to begin
    with, or do you need to begin the process of requesting one to be provisioned
    for your application? And then what happens when your application is strained
    with heavy activity—are you able to scale quickly and automatically, or must you
    begin the provisioning process all over again?
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 开始出现问题。在生产服务器上安装了什么——Java运行时的哪个版本，什么应用服务器（例如，JBoss，Apache Tomcat，WildFly）？在生产服务器上是否运行了其他可能干扰应用程序性能的进程？你的应用程序是否因为任何原因需要root访问权限，并且你的应用程序用户是否以正确的权限设置适当地配置？你的应用程序是否需要访问外部服务，比如数据库或API进行存活或健康检查？在回答这些问题之前，你甚至是否有权限访问专用的生产服务器，还是需要开始请求为你的应用程序提供一个生产服务器？那么当你的应用程序受到大量活动的影响时会发生什么——你能够快速自动地扩展，还是必须重新开始配置过程？
- en: Given these issues, it’s easy to see why virtualization using virtual machines
    (VMs) became such an attractive option. VMs provide more flexibility when it comes
    to isolating application processes, and the ability to snapshot a VM can provide
    consistency in deployments. However, VM images are large and not easy to move
    around because they include an entire OS, which contributes to their overall bulk.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些问题，很容易理解为什么使用虚拟机（VM）的虚拟化变得如此有吸引力。虚拟机在隔离应用程序进程方面提供了更多的灵活性，而快照虚拟机可以在部署中提供一致性。然而，VM映像很大，并且不容易移动，因为它们包含整个操作系统，这增加了它们的整体体积。
- en: More than a few times when first introducing fellow developers to containers,
    I’ve gotten the response, “Oh! So a container is like a VM?” While it’s convenient
    to think of *containers* as analogous to VMs, an important distinction exists.
    VMs (VMware vSphere, Microsoft Hyper-V, and others) are an abstraction of the
    hardware, emulating a complete server. In a sense, the entire operating system
    is included in a VM. VMs are managed by a software layer called a *hypervisor*,
    which divides and allocates the host’s resources to the VMs as required.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在向其他开发人员首次介绍容器时，我多次收到过这样的回答，“哦！所以容器就像虚拟机？”虽然将*容器*类比于虚拟机是方便的，但存在重要区别。虚拟机（VMware
    vSphere、Microsoft Hyper-V等）是硬件的抽象，模拟完整的服务器。在某种意义上，整个操作系统都包含在虚拟机中。虚拟机由一个称为*hypervisor*的软件层管理，它根据需要将主机的资源划分和分配给虚拟机。
- en: Containers, on the other hand, are not as heavy as a traditional VM. Rather
    than include an entire OS, a Linux container, for example, can be thought of as
    a Linux distribution that shares the host operating system. As shown in [Figure 3-1](#vm_vs_container),
    VMs and containers are different levels of abstraction, as is the Java Virtual
    Machine (JVM).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，容器并不像传统虚拟机那样重。例如，Linux 容器不包含整个操作系统，可以被视为共享主机操作系统的 Linux 发行版。正如在[图 3-1](#vm_vs_container)中所示，VM
    和容器是不同的抽象级别，Java 虚拟机（JVM）也是如此。
- en: Where does the JVM fit in all of this? It gets confusing when terms like *virtual
    machine* are overloaded. The JVM is a completely different abstraction altogether
    and is a *process* virtual machine as opposed to a *system* virtual machine. Its
    primary concern is to provide the Java Runtime Environment (or JRE, the implementation
    of the JVM) for a Java application. The JVM virtualizes the host’s processor(s)
    for the purpose of executing Java bytecode.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: JVM 在这一切中扮演了什么角色？当像*虚拟机*这样的术语被重载时会让人感到困惑。JVM 完全是一个不同的抽象，并且是一个*进程*虚拟机，与*系统*虚拟机形成对比。它的主要任务是为
    Java 应用程序提供 Java 运行环境（或 JRE，即 JVM 的实现）。JVM 虚拟化主机的处理器，以便执行 Java 字节码。
- en: '![dtjd 0301](Images/dtjd_0301.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![dtjd 0301](Images/dtjd_0301.png)'
- en: Figure 3-1\. VMs versus containers
  id: totrans-49
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-1\. 虚拟机与容器
- en: Containers are a lightweight solution that promises to solve most of the issues
    around application consistency, process isolation, and OS-level dependencies.
    This method of packaging a service or application can utilize caching mechanisms
    that drastically reduce the time it takes to get an application deployed and up
    and running. Rather than having to wait for custom provisioning and setup, containers
    can be deployed to existing infrastructure—whether that’s an available dedicated
    server, an existing VM on premises in a private data center, or cloud resources.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是一个轻量级解决方案，承诺解决大部分围绕应用程序一致性、进程隔离和操作系统级别依赖的问题。这种打包服务或应用程序的方法可以利用缓存机制，大幅减少部署和启动应用程序所需的时间。与等待定制的供应和设置不同，容器可以部署到现有基础设施上——无论是现有的专用服务器、私人数据中心中的现有
    VM，还是云资源。
- en: Even if you choose not to utilize containers in production, you are well advised
    to consider a couple of other use cases around development and test environments.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您选择在生产环境中不使用容器，也强烈建议考虑一些围绕开发和测试环境的其他用例。
- en: A big challenge in onboarding a new developer to a team is the time spent setting
    up their local development environment. It is generally understood that it’s going
    to take some time to get a developer to the point where they can contribute their
    first bug fix or improvement. While some companies dictate the development tools
    (consistency is often believed to improve support efforts and therefore efficiency),
    developers have more choices today than ever. I’m of the opinion that forcing
    a specific toolset on developers when they are already accustomed to something
    different actually has the opposite effect. Frankly, in many cases, it simply
    just isn’t necessary anymore—especially now that we can utilize containers.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 将新开发人员引入团队的一个重大挑战是设置他们的本地开发环境所花费的时间。一般来说，人们普遍认为，让开发人员达到能够贡献其第一个 bug 修复或改进的水平需要一些时间。虽然一些公司会规定开发工具（通常认为一致性可以提高支持工作的效率），但今天开发者比以往更有更多的选择。我认为，在开发人员已经习惯于不同工具时，强迫他们使用特定的工具集实际上会产生相反的效果。坦率地说，在许多情况下，这实际上已经不再必要——特别是现在我们可以利用容器。
- en: Containers help keep the runtime environment consistent, and when configured
    correctly, can easily be launched in dev, test, or production modes. The risk
    of your service or application behaving differently in these environments because
    of a missing dependency is greatly reduced since the environment is shipped along
    with your application in a container image.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 容器有助于保持运行环境的一致性，并且在正确配置后，可以轻松在开发、测试或生产模式下启动。由于环境与应用程序一同打包在容器镜像中，因此由于缺少依赖项而导致服务或应用程序在这些环境中行为不同的风险大大降低。
- en: This portability improves a developer’s ability to sanity-test changes in a
    local environment as well as the ability to deploy the same version of the code
    that’s in production in order to reproduce a bug. Integration testing with containers
    also comes with the added benefit of being able to reproduce as close as possible
    a production environment. For example, instead of using an in-memory database
    for integration tests, you can now launch containers that match the version of
    the database used in production. Using a project like TestContainers for this
    purpose will prevent irregularities in behavior due to slightly different SQL
    syntax or other differences between database software versions. Using containers
    in this way improves efficiency by circumventing the complications of installing
    new software or multiple versions of the same software to your local machine.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这种可移植性提升了开发人员在本地环境中进行变更的理智测试能力，以及部署与生产环境中相同版本的代码以重现错误的能力。使用容器进行集成测试还带来了额外的好处，即尽可能地复现生产环境。例如，不再使用内存数据库进行集成测试，而是可以启动与生产中使用的数据库版本匹配的容器。像
    TestContainers 这样的项目可以防止由于轻微的 SQL 语法或其他数据库软件版本之间的差异而导致的行为不规则。以这种方式使用容器可以通过避免在本地安装新软件或同一软件的多个版本而简化效率。
- en: If we’ve learned anything about containers thus far, it is that they are likely
    here to stay in one form or another. This section began with an illustration of
    the exponential increase in container usage over the last several years, and the
    toolsets being continuously developed and improved around the container ecosystem
    have gained a solid foothold in both development and operations processes. Apart
    from a huge, and as of yet unknown, advancement in a completely different direction
    (remember, containers have over 50 years of history behind them), you are well
    advised to learn about the container ecosystem and how to exploit this technology
    to your full advantage.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果迄今为止我们对容器有什么了解，那就是它们以某种形式很可能会继续存在。本节从容器使用在过去几年中的指数增长开始，围绕容器生态系统不断开发和改进的工具集已经在开发和运营过程中获得了牢固的立足点。除了在完全不同方向上（请记住，容器已经有超过50年的历史了）可能会有巨大且目前未知的进展之外，你应该建议了解容器生态系统及如何充分利用这项技术。
- en: Intro to Container Anatomy
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器解剖简介
- en: My first experience with containers as a developer was via a project, developed
    by a third-party contractor, that my team was now responsible to further develop
    and maintain. Aside from bringing the initial codebase into our internal GitHub
    organization, a lot of setup needed to happen to establish our internal DevOps
    environment around the project—setting up our continuous integration and deployment
    (CI/CD) pipeline as well as our development and test environments, and, of course,
    our deployment process.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发人员，我第一次接触容器是通过一个由第三方承包商开发的项目，而现在这个项目由我的团队负责进一步开发和维护。除了将初始代码库引入我们内部的 GitHub
    组织之外，还需要进行大量设置，以在项目周围建立我们的内部 DevOps 环境——设置我们的持续集成和部署（CI/CD）流水线，以及我们的开发和测试环境，当然还有我们的部署流程。
- en: I compare this experience to clearing my desk (even more so after days of neglect).
    I’m about to reveal entirely too much about my personal habits here, but it’s
    worth doing to make this point. The most time-consuming bit of clearing my desk
    is a stack of papers and mail that invariably grows to the point of falling over.
    It’s terribly convenient to rush into the house with these items and, because
    of other urgent tasks on my mind, set them down on the kitchen counter…frequently
    on top of an existing stack of papers, with the promise that I’ll get to it later.
    The problem is, I never know what’s going to be in there. The stack could contain
    bills that need to be paid, important papers that need filing, or invites or letters
    that need responding to and thought put toward scheduling on our family calendar.
    I often dread the amount of time I anticipate it will take to get through it,
    which only leads to a larger stack of neglected correspondence.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我将这种经历比作整理我的桌面（尤其是在几天疏忽之后）。这里我将完全过多地透露关于我的个人习惯的内容，但为了表达这一点，这是值得的。清理我的桌面最耗时的部分是一堆文件和邮件，它们总是长得足以倒塌。匆忙赶回家，将这些物品放在厨房柜台上，因为脑海中有其他紧急任务，常常放在已有的文件堆上……并且承诺稍后处理它们。问题是，我从不知道里面会有什么。这堆可能包含需要支付的账单、需要归档的重要文件，或者需要回复并在我们家庭日历上进行安排的邀请函或信件。我常常对预计要花费的时间感到害怕，这只会导致一堆被忽视的信件变得更大。
- en: For the project my team was responsible for, my first step was to metaphorically
    clear the desk. The Dockerfile that I found in the source code was the equivalent
    of tackling that dreaded stack of papers. Although getting through it and learning
    the concepts was necessary, I felt like I was getting derailed from the task at
    hand. Learning a new technology when starting a new project sometimes doesn’t
    get the amount of time it should be allotted during project planning, even though
    it adds variables and inherent risk to the project timeline. This does *not* mean
    that new technology should never be introduced. Developers absolutely need to
    learn new things as the industry grows and changes, but it’s best to mitigate
    risk by either limiting the amount of new tech introduced to a project or being
    up-front about the variability of the timeline.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们团队负责的项目，我的第一步是象征性地整理桌面。在源代码中找到的Dockerfile相当于解决了那些令人头疼的文件堆。尽管通过并学习这些概念是必要的，但我感觉自己被从手头任务上偏离了。在启动新项目时学习新技术有时并没有得到应有的时间规划，即使它会为项目进度表增加变数和固有风险。这并*不*意味着新技术永远不应该引入。开发人员绝对需要学习行业的新变化和技术，但最好通过限制引入项目的新技术数量或在时间表的变化上坦率地面对来减少风险。
- en: Note
  id: totrans-60
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A *Dockerfile* is a text file that contains instructions providing the blueprint
    for your container. This file is typically named *Dockerfile*, and although originally
    specific to Docker, because of its wide use, other image-building tools support
    using Dockerfiles to build a container image (such as Buildah, kaniko, and BuildKit).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*Dockerfile* 是一个包含提供容器蓝图指令的文本文件。这个文件通常命名为 *Dockerfile*，尽管最初是专门为 Docker 设计的，由于其广泛的使用，其他构建镜像工具也支持使用
    Dockerfile 来构建容器镜像（如 Buildah、kaniko 和 BuildKit）。'
- en: The information available here is not meant to be a regurgitation of documentation
    that’s already out there (for example, the online [Docker getting started guide](https://oreil.ly/Tez72)
    is exceptional). Instead, I hope to peel this onion in a way that will orient
    you on the basics and give you immediate value and enough detail to better estimate
    what it’s going to take to get your own desk cleared and ready for business. You
    now have quite a bit of information under your belt about containers and how they
    came to be. This next section covers the terminology and functionality that you
    will be exposed to as a developer.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提供的信息并非是对已有文档的简单复述（例如，在线[Docker入门指南](https://oreil.ly/Tez72)非常出色）。相反，我希望像剥洋葱一样，以一种方式来介绍基础知识，并为您提供即时价值和足够的细节，以便更好地评估准备好自己的桌面并准备好开展业务所需的工作量。现在您已经掌握了关于容器及其产生过程的大量信息。接下来的部分涵盖了开发人员将接触到的术语和功能。
- en: Docker Architecture and the Container Runtime
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker 架构和容器运行时
- en: Just like Kleenex is a brand of tissue, Docker is a *brand* of container. The
    Docker company developed an entire technology stack around containerization. So
    even though the terms *Docker container* and *Docker image* have been somewhat
    genericized, when you install something like Docker Desktop to your development
    machine, you are getting more than just the ability to run containers. You’re
    getting an entire container platform that makes building, running, and managing
    them easy and convenient for developers.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 Kleenex 是面巾纸的品牌一样，Docker 是容器的*品牌*。Docker 公司围绕容器化开发了一整套技术栈。因此，即使*Docker 容器*和*Docker
    镜像*这些术语已经被泛化使用，但当你将 Docker Desktop 安装到你的开发机上时，你得到的不仅仅是运行容器的能力。你得到的是一个完整的容器平台，使得开发者能够轻松便捷地构建、运行和管理它们。
- en: It is important to understand that installing Docker is not required for building
    container images or running containers. It is simply a widely used and convenient
    tool for doing so. In much the same way that you can package a Java project without
    using Maven or Gradle, you can build a container image without using Docker or
    a Dockerfile. My advice to a developer new to containers would be to take advantage
    of the toolset Docker provides and then experiment with other options or methods
    to get a good feel for a comparison. Even if you choose to utilize other tools
    instead of or in addition to Docker, a lot of time and effort was spent on engineering
    a good developer experience, and this alone scores big points for including Docker
    Desktop in your development environment.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 需要理解的是，安装 Docker 并非构建容器镜像或运行容器的必要条件。它只是一个被广泛使用且方便的工具而已。就像你可以在没有使用 Maven 或 Gradle
    的情况下打包一个 Java 项目一样，你可以在没有使用 Docker 或 Dockerfile 的情况下构建一个容器镜像。我给新接触容器技术的开发者的建议是利用
    Docker 提供的工具集，然后尝试其他选项或方法，以便对比和获得更好的使用体验。即使你选择使用 Docker 之外的其他工具或方法，花费在工程化良好的开发者体验上的时间和精力也足以给包含
    Docker Desktop 在你的开发环境中带来很大的收益。
- en: 'With Docker, you get an isolated environment in which a user/application can
    operate, sharing the host system’s OS/kernel without interfering with the operation
    of another isolated environment on the same system (a container). Docker enables
    you to do the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Docker，你可以获得一个隔离的环境，用户/应用程序可以在其中操作，共享主机系统的操作系统/内核，而不会干扰同一系统上另一个隔离的环境（容器）的操作。Docker
    使你能够做到以下几点：
- en: Define a container (an image format)
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义容器（一种镜像格式）
- en: Build an image of a container
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建容器镜像
- en: Manage container images
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理容器镜像
- en: Distribute/share container images
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分发/分享容器镜像
- en: Create a container environment
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建容器环境
- en: Launch/run a container (a container runtime)
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动/运行容器（容器运行时）
- en: Manage the lifecycle of container instances
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理容器实例的生命周期
- en: The container landscape contains much more than Docker, but many of the container
    toolset alternatives focus on a subset of these items. Beginning with learning
    how Docker operates is helpful in understanding and evaluating these alternatives.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 容器领域远不止 Docker，但许多容器工具集的替代方案专注于这些项目的子集。从学习 Docker 如何运作开始，有助于理解和评估这些替代方案。
- en: A lot of pictures and diagrams are readily available that describe the Docker
    architecture. An image search online will most likely result in a version of [Figure 3-2](#docker_architecture).
    This diagram does a fairly good job of showing how Docker works on your development
    machine—the Docker CLI is the interface available to you to send commands to the
    Docker daemon to build images, retrieve requested images from an external registry
    (by default, this is Docker Hub), manage these images in local storage, and then
    use these images to launch and run containers on your machine.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在线可以找到许多描述 Docker 架构的图片和图表。一个图片搜索很可能会得到一个版本的 [图 3-2](#docker_architecture)。这个图表相当好地展示了
    Docker 在开发机上的工作原理 —— Docker CLI 是你可以使用的接口，用来向 Docker 守护进程发送命令来构建镜像，从外部仓库（默认是 Docker
    Hub）检索请求的镜像，在本地存储中管理这些镜像，然后使用这些镜像在你的机器上启动和运行容器。
- en: '![Docker architecture](Images/dtjd_0302.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![Docker 架构](Images/dtjd_0302.png)'
- en: Figure 3-2\. Docker architecture
  id: totrans-77
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-2\. Docker 架构
- en: 'One of the more confusing concepts when first introduced to this landscape
    is the focus on one aspect of the Docker ecosystem: the *container runtime*. To
    reiterate, this is just one part of the entire tech stack Docker offers, but because
    orchestration frameworks like Kubernetes require this portion of functionality
    to launch and run containers, it is often spoken of as a separate entity from
    Docker (and in the case of alternative container runtimes, it is).'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当首次介绍这个领域时，其中一个更令人困惑的概念是对 Docker 生态系统的一个方面的关注：*容器运行时*。再强调一遍，这只是 Docker 提供的整个技术栈的一部分，但是因为编排框架如
    Kubernetes 需要这部分功能来启动和运行容器，所以它通常被称为 Docker 的一个单独实体（在替代容器运行时的情况下，也是如此）。
- en: The topic of container runtimes deserves this section all to itself, because
    it can be one of the most confusing aspects to someone new to the world of containers.
    Even more confusing is that container runtimes fall into two different categories,
    low-level or high-level, depending on what features are implemented. And just
    to keep you on your toes, some overlap can occur in that feature set.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 关于容器运行时的主题值得单独列出这一节，因为对于新接触容器世界的人来说，这可能是最令人困惑的方面之一。更加令人困惑的是，容器运行时分为两种不同的类别，低级或高级，这取决于实现了哪些功能。而且为了让您保持警惕，这些功能集可能会有重叠。
- en: This is a good spot to present a visual on how container runtimes fit together
    with what you’ve learned earlier about the OCI and projects like containerd and
    runC. [Figure 3-3](#container_runtimes) illustrates the relationship between older
    and newer versions of Docker, high-level and low-level runtimes, and where Kubernetes
    fits in.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个展示容器运行时如何与您早前学到的 OCI 和诸如 containerd 和 runC 等项目结合在一起的可视化图表的好地方。[图 3-3](#container_runtimes)
    说明了旧版和新版 Docker、高级和低级运行时之间的关系，以及 Kubernetes 的位置。
- en: '![Container runtimes](Images/dtjd_0303.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![容器运行时](Images/dtjd_0303.png)'
- en: Figure 3-3\. Runtimes in the container ecosystem
  id: totrans-82
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-3\. 容器生态系统中的运行时
- en: Tip
  id: totrans-83
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: One of the best explanations I’ve come across that really gets into the details
    of container runtimes along with a historical perspective is a [blog series](https://oreil.ly/Y2Fow)
    composed by Ian Lewis, a developer advocate on the Google Cloud Platform Team.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我遇到过的关于容器运行时的详细解释之一，并带有历史视角的最佳解释是由 Google 云平台团队的开发者倡导 Ian Lewis 撰写的 [博客系列](https://oreil.ly/Y2Fow)。
- en: Prior to version 1.11 (released in 2016), Docker could be described as a monolithic
    application that wrapped up the entire feature set required of a runtime, plus
    other management tools. Docker did quite a bit of reorganizing its codebase over
    the last several years, developing abstractions and pulling out discrete functionality.
    The runC project that was contributed by Docker to the OCI came out of this effort.
    This was the first and, for some time, the *only* implementation of a low-level
    container runtime that implemented the OCI Runtime Specification.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2016 年发布的 1.11 版本之前，Docker 可以被描述为一个将整个运行时所需的功能集合以及其他管理工具封装在一起的单块应用程序。在过去的几年里，Docker
    进行了大量的代码重组，开发了抽象化并提取了离散功能。Docker 贡献给 OCI 的 runC 项目就是出于这个努力。这是第一个，也是一段时间内*唯一*实现
    OCI Runtime 规范的低级容器运行时的实现。
- en: Other runtimes are out there, and as of this writing this is an active space,
    so be sure to reference [the current list maintained by the OCI](https://oreil.ly/Vro14)
    for the most up-to-date information. Notable low-level runtime projects include
    *crun*, an implementation in C led by Red Hat; and *railcar*, an implementation
    in Rust led by Oracle, although this project is now archived.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他的运行时存在，并且截至目前，这是一个活跃的领域，因此请务必参考 [OCI 维护的当前列表](https://oreil.ly/Vro14) 以获取最新信息。值得注意的低级运行时项目包括
    *crun*，由 Red Hat 领导的 C 实现；以及 *railcar*，由 Oracle 领导的 Rust 实现，尽管该项目现在已经存档。
- en: Developing a specification is a challenging feat, and collaboration on the OCI
    Runtime Specification wasn’t any less challenging. Figuring out the boundaries—what
    *should* and what *should not* be included in the specification—took time before
    the release of version 1.0\. It’s clear, however, that just implementing the OCI
    Runtime Specification isn’t enough to drive adoption of an implementation. Additional
    features are needed to make a low-level runtime usable for developers since we
    are concerned with much more than just the launching and running of a container.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 制定规范是一项具有挑战性的任务，参与 OCI 运行时规范的协作同样具有挑战性。在发布 1.0 版本之前，花费了不少时间来确定边界——规范中应该包括什么内容和不应该包括什么内容。然而，显而易见的是，仅仅实现
    OCI 运行时规范并不足以推动实施的采用。我们需要额外的功能来使低级运行时对开发者更加可用，因为我们关注的远不止容器的启动和运行。
- en: This leads us to higher-level runtimes like *containerd* and *cri-o*, the two
    primary players as of this writing that include solutions for many of the concerns
    around container orchestration, including image management and distribution. Both
    of these runtimes implement the CRI (which eases the path to a Kubernetes deployment)
    and delegate low-level container activities to OCI-compliant low-level runtimes
    (for example, runC).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这将我们引向更高级的运行时，如 *containerd* 和 *cri-o*，这两个是当前的主要解决方案，涵盖了许多围绕容器编排的关注点，包括镜像管理和分发。这两个运行时都实现了
    CRI（这简化了 Kubernetes 部署的路径），并将低级容器活动委托给符合 OCI 标准的低级运行时（例如 runC）。
- en: Docker on Your Machine
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 您的机器上的 Docker
- en: 'The second most important thing to understand about containers is that they
    are not magic. Containers utilize a combination of existing Linux features (as
    covered at the beginning of this chapter). Container implementations vary in the
    details, but a container image, in a sense, is simply a tarball of a complete
    filesystem, and a running container is a Linux process that is constrained to
    provide a level of isolation from other processes running on a host. The implementation
    of a Docker container, for example, primarily involves these three ingredients:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的第二个重要理解点是它们并非魔法。容器利用了现有的 Linux 特性（如本章开头所述）。容器的具体实现细节有所不同，但容器镜像本质上就是一个完整文件系统的
    tar 压缩包，而运行中的容器则是一个受限的 Linux 进程，从而与主机上运行的其他进程隔离开来。例如，Docker 容器的实现主要涉及以下三个要素：
- en: Namespaces
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间
- en: cgroups
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: cgroups
- en: A union filesystem
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 联合文件系统
- en: But what does a container look like on your local filesystem? First, let’s figure
    out where Docker is storing things on our development machine. Then let’s take
    a look at a real Docker image pulled from Docker Hub.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 但是容器在本地文件系统上是什么样子的呢？首先，让我们弄清楚 Docker 在开发机器上的存储位置。然后让我们来看一看从 Docker Hub 拉取的真实
    Docker 镜像。
- en: 'After installing Docker Desktop, running the command `docker info` from a terminal
    will provide you with detailed information about your installation. This output
    includes information about where your images and containers are stored with the
    label `Docker Root Dir`. The following example output (truncated for brevity)
    indicates that the Docker root directory is */var/lib/docker*:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Docker Desktop 后，从终端运行 `docker info` 命令将为您提供关于安装的详细信息。此输出包括关于镜像和容器存储位置的信息，标签为
    `Docker Root Dir`。下面是示例输出（为简洁起见进行了截断），指示 Docker 根目录为 */var/lib/docker*：
- en: '[PRE0]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This result is from an existing Docker Desktop (version 3.3.3) installation
    on macOS Big Sur. A quick listing of */var/lib/docker* shows the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果来自 macOS Big Sur 上已有的 Docker Desktop（版本 3.3.3）安装。快速列出 */var/lib/docker*
    显示如下内容：
- en: '[PRE1]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: According to the previous output, 5 stopped containers and 62 images are on
    this system, so how is it that this directory doesn’t exist? Is the output incorrect?
    You can check another place for the image and container storage location, as shown
    in [Figure 3-4](#docker_desktop_preferences), a screenshot of the Preferences
    section available in the Mac version of the Docker Desktop UI.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的输出，系统上有 5 个停止的容器和 62 个镜像，那么为什么这个目录不存在呢？输出有误吗？您可以查看另一个位置的镜像和容器存储位置，如 [图
    3-4](#docker_desktop_preferences)，这是 Docker Desktop UI 的 macOS 版本中可用的“首选项”部分的截图。
- en: However, this location is completely different. A reasonable explanation for
    this exists, and note that depending on your operating system, your installation
    may be slightly different. The reason this matters at all is that Docker Desktop
    for Mac requires a Linux environment to run Linux containers, and to that end,
    a minimal Linux virtual machine is instantiated during installation. This means
    that the Docker root directory referred to in the earlier output is actually referencing
    a directory within this Linux VM.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，此位置完全不同。存在一个合理的解释，并且请注意，根据您的操作系统不同，您的安装可能略有不同。这个原因很重要，因为 Docker Desktop for
    Mac 需要在安装期间实例化一个 Linux 虚拟机来运行 Linux 容器。这意味着之前输出中提到的 Docker 根目录实际上是指向此 Linux 虚拟机内部的一个目录。
- en: '![Docker Desktop Preferences](Images/dtjd_0304.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![Docker Desktop Preferences](Images/dtjd_0304.png)'
- en: Figure 3-4\. Docker Desktop Preferences
  id: totrans-102
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-4\. Docker Desktop Preferences
- en: But wait…what if you’re on Windows? Because containers are sharing the host’s
    operating system, Windows-based containers require a Windows environment to run,
    and Linux-based containers require a Linux environment. Docker Desktop (version
    3.3.3) is a marked improvement from earlier versions (a.k.a Docker Toolbox) in
    that no additional supporting software is required to run Linux-based containers.
    In the old days, to run Docker on a Mac, you would need to install something like
    VirtualBox and boot2docker to get everything up and functioning as expected. Today,
    Docker Desktop handles the necessary virtualization behind the scenes. Docker
    Desktop also supports Windows containers via Hyper-V on Windows 10 and Linux containers
    on Windows 10 via Windows Subsystem for Linux 2 (WSL 2). To run Windows containers
    on macOS, however, VirtualBox is still required.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等……如果您在 Windows 上怎么办？因为容器共享主机的操作系统，所以基于 Windows 的容器需要在 Windows 环境中运行，而基于 Linux
    的容器需要在 Linux 环境中运行。Docker Desktop（版本 3.3.3）相比早期版本（即 Docker Toolbox），无需安装额外的支持软件即可运行
    Linux-based 容器是一大进步。在旧版本中，要在 Mac 上运行 Docker，您需要安装像 VirtualBox 和 boot2docker 这样的软件才能如预期地启动和运行。今天，Docker
    Desktop 在幕后处理所需的虚拟化。Docker Desktop 还通过 Windows 10 上的 Hyper-V 支持 Windows 容器，以及通过
    Windows Subsystem for Linux 2（WSL 2）在 Windows 10 上支持 Linux 容器。然而，要在 macOS 上运行
    Windows 容器，仍然需要 VirtualBox。
- en: 'Now that you know we need to access the Linux virtual machine to get to this
    Docker root directory, let’s pull a Docker image by using the command **`docker
    pull *IMAGE NAME*`** and see what it looks like on the filesystem:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道我们需要访问 Linux 虚拟机才能进入这个 Docker 根目录，让我们使用命令 **`docker pull *IMAGE NAME*`**
    拉取一个 Docker 镜像，并看看它在文件系统中的样子：
- en: '[PRE2]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The command **`docker images`** lists all of the images stored locally. You
    can see from its output that two versions of the *openjdk* image are stored. The
    one we pulled in the previous command brought in the image with the tag `latest`.
    This is the default behavior, but we could have specified a specific *openjdk*
    image version like this: **`docker pull openjdk:11-jre`**:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 命令 **`docker images`** 列出了所有本地存储的镜像。从输出中可以看出，我们之前拉取的命令带来了带有标签 `latest` 的 *openjdk*
    镜像。这是默认行为，但我们也可以指定特定的 *openjdk* 镜像版本，比如 **`docker pull openjdk:11-jre`**：
- en: '[PRE3]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can learn more details about the latest *openjdk* image by running the
    `**docker inspect**` command using the *image ID*:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用 *image ID* 运行 `**docker inspect**` 命令来了解最新的 *openjdk* 镜像的更多详细信息：
- en: '[PRE4]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `docker inspect` command spits out a ton of interesting information. But
    what I want to highlight here is the `GraphDriver` section, which contains the
    paths to the directories where all the layers that belong to this image live.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker inspect` 命令会输出大量有趣的信息。但我想在这里强调的是 `GraphDriver` 部分，其中包含属于此镜像的所有层所在的路径。'
- en: Docker images are composed of layers that correspond to instructions in the
    Dockerfile that was used to build the image originally. These layers translate
    into directories and can be shared across images in order to save space.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 镜像由对应于 Dockerfile 中用于构建镜像的指令的层组成。这些层被转换为目录，并且可以在不同镜像之间共享以节省空间。
- en: Note the `LowerDir`, `MergedDir`, and `UpperDir` sections. The `LowerDir` section
    contains all the directories, or layers, that were used to build the original
    image. These are *read-only*. The *UpperDir* directory contains all the content
    that has been modified while the container is running. If modifications are needed
    for a read-only layer in *LowerDir*, then that layer is copied into the *UpperDir*
    where it can be written to. This is called a *copy-on-write* operation.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 *LowerDir*、*MergedDir* 和 *UpperDir* 部分。*LowerDir* 部分包含用于构建原始镜像的所有目录或层，这些层是只读的。*UpperDir*
    目录包含容器运行时修改的所有内容。如果需要对 *LowerDir* 中的只读层进行修改，则会将该层复制到 *UpperDir* 中，然后可以对其进行写入操作。这称为写时复制操作。
- en: It’s important to remember that the data in *UpperDir* is ephemeral data that
    lives only as long as the container lives. In fact, if you have data that you
    intend to keep, you should utilize the volume features of Docker and mount a location
    that will stick around even after the container dies. For example, a database-driven
    application running in a container will likely utilize a volume mounted to the
    container for the database data.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住 *UpperDir* 中的数据是临时数据，仅在容器存在期间有效。事实上，如果您有意保留的数据，应该利用 Docker 的卷特性并挂载一个即使容器停止后仍然存在的位置。例如，运行在容器中的数据库驱动应用程序可能会利用挂载到容器的卷来存储数据库数据。
- en: Lastly, the `MergedDir` section is kind of like a virtual directory that combines
    everything from *LowerDir* and *Upper Dir*. The way the Union File System works
    is that any edited layers that were copied into *UpperDir* will overlay layers
    in *LowerDir*.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，*MergedDir* 部分有点像虚拟目录，它将 *LowerDir* 和 *UpperDir* 中的所有内容合并在一起。联合文件系统的工作方式是，任何编辑后复制到
    *UpperDir* 的层将覆盖 *LowerDir* 中的层。
- en: Warning
  id: totrans-115
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Notice all the references to directories within */var/lib/docker*, the Docker
    root directory. If you monitor the size of this directory, you will notice that
    the more images and containers you create and run, the storage space required
    for this directory will increase substantially over time. Consider mounting a
    dedicated drive, and make sure that you are cleaning up unused images and containers
    regularly. Also, make sure that containerized apps aren’t continuously producing
    unmanaged data files or other artifacts. For example, utilize log shipping and
    or log rotation to manage logs generated by your container and its running processes.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意所有对 */var/lib/docker* 目录的引用，这是 Docker 的根目录。如果您监控此目录的大小，会发现随着创建和运行的镜像和容器数量增加，该目录所需的存储空间会显著增加。考虑挂载一个专用驱动器，并确保定期清理未使用的镜像和容器。此外，确保容器化应用程序不会持续产生未管理的数据文件或其他工件。例如，可以使用日志传送或日志轮换来管理容器及其运行进程生成的日志。
- en: Any number of containers can be launched using the same image. Each container
    will be created with the image blueprint and will run independently. In the context
    of Java, think of a container image as a Java class, and a container as a Java
    object instantiated from that class.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用相同的镜像启动任意数量的容器。每个容器将以镜像蓝图创建并独立运行。在 Java 的上下文中，将容器镜像视为 Java 类，将容器视为从该类实例化的
    Java 对象。
- en: 'Containers can be stopped and later restarted without being re-created. To
    list containers on your system, use the `docker ps -a` command. Note that the
    `-a` flag will display both stopped containers as well as containers currently
    running:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 可以停止并稍后重新启动容器，而无需重新创建。要列出系统上的容器，请使用 `docker ps -a` 命令。请注意，`-a` 标志将显示已停止的容器以及当前正在运行的容器：
- en: '[PRE5]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you navigate to the Docker root directory, you will see a subdirectory named
    *containers*. Within this directory, you will find additional subdirectories named
    after the *container ID* of each container on your system. Stopped containers
    will retain their state and data in these directories so that they can be restarted
    if needed. When a container is removed using the `docker rm *CONTAINER NAME*`,
    its correlated directory will be deleted.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您导航到 Docker 的根目录，您会看到一个名为 *containers* 的子目录。在这个目录中，您会找到根据系统上每个容器的 *container
    ID* 命名的额外子目录。停止的容器将在这些目录中保留其状态和数据，以便在需要时可以重新启动。当使用 `docker rm *CONTAINER NAME*`
    删除容器时，相应的目录将被删除。
- en: Warning
  id: totrans-121
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: 'Remember to regularly remove unused containers from your systems (*remove*,
    not just stop). I personally witnessed a scenario with this part of the deployment
    process missing. Every time new images were released, the old containers were
    stopped and new containers were launched based on the new images. This was an
    oversight that quickly used up hard drive space and eventually prevented new deployments.
    The following Docker command is useful to clean up unused containers in bulk:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 记得定期清理系统中未使用的容器（*删除*而不仅仅是停止）。我亲眼见证了缺少这个部署过程的情况。每次发布新镜像时，旧容器都会停止，基于新镜像启动新容器。这是一个疏忽，很快就会消耗硬盘空间，最终阻止新的部署。以下
    Docker 命令可以批量清理未使用的容器：
- en: '`docker container prune`'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker container prune`'
- en: '[PRE6]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-125
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you are using Mac for development, remember that your containers are running
    in a tiny VM that you will need to first access before you can see the Docker
    root directory contents. For example, on a Mac, you can access and navigate this
    directory by interactively running a container in privileged mode that has *nsenter*
    installed (you may need to run this with `sudo`):'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 Mac 上进行开发，请记住你的容器运行在一个小型虚拟机中，你需要首先访问该虚拟机，然后才能查看 Docker 根目录的内容。例如，在 Mac
    上，您可以通过以特权模式交互式运行一个已安装*nsenter*的容器来访问和导航到此目录（可能需要使用`sudo`运行）：
- en: '[PRE7]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Later versions of Windows (10+) now have the capability of running Linux containers
    natively using Windows Subsystem for Linux (WSL). The default Docker root directory
    for Windows 11 Home can be found here in File Explorer:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 较新的 Windows 版本（10+）现在具有使用 Windows Subsystem for Linux（WSL）原生运行 Linux 容器的功能。在文件资源管理器中可以找到
    Windows 11 Home 的默认 Docker 根目录：
- en: '*\\wsl.localhost\docker-desktop-data\version-pack-data\* *community\docker\*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*\\wsl.localhost\docker-desktop-data\version-pack-data\* *community\docker\*'
- en: Basic Tagging and Image Version Management
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本标记和镜像版本管理
- en: After working with images awhile, you will see that identifying them and versioning
    them are a bit different from the way you version your Java software. Working
    with build tools like Maven has gotten most Java developers accustomed to standard
    semantic versioning and always specifying dependency versions (or at least accepting
    of the version Maven chooses to pull within a particular dependency tree). These
    guardrails are a little more relaxed in other package managers like npm, where
    a dependency version can be specified as a range in order to allow for ease and
    flexibility in updating dependencies.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用镜像一段时间后，您会发现其标识和版本管理与您对 Java 软件版本化的方式有所不同。使用像 Maven 这样的构建工具已经让大多数 Java 开发者习惯于标准的语义版本控制，并始终指定依赖版本（或者至少接受
    Maven 在特定依赖树中选择的版本）。这些限制措施在其他包管理器（如 npm）中稍微放松，其中可以将依赖版本指定为范围，以便轻松和灵活地更新依赖项。
- en: Image versioning can become a stumbling block if not well understood. No guardrails
    exist (at least not the kind that Java developers are used to). Flexibility in
    tagging an image is preferred over any enforcement of good practices. However,
    just because you *can*, doesn’t mean you *should*, and just as with proper versioning
    of Java libraries and packages, it is best to start out of the gate with a naming
    and versioning scheme that makes sense and follows an accepted pattern.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不理解，镜像版本管理可能会成为一个障碍。没有（至少不是 Java 开发者习惯的那种）限制措施。在标记镜像方面的灵活性优于任何强制执行的良好实践。然而，仅仅因为你*能*做到，并不意味着你*应该*这样做，就像正确版本化
    Java 库和包一样，最好从一开始就采用符合逻辑和遵循公认模式的命名和版本化方案。
- en: Container image names and versions follow a specific format, including multiple
    components that you rarely see in complete form in examples and tutorials. Most
    example code and Dockerfiles you find when scouring the internet identify images
    in an abbreviated format.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像名称和版本遵循特定的格式，包括多个组件，这些在示例和教程中很少以完整形式出现。大多数在互联网上找到的示例代码和 Dockerfile 都使用缩写格式标识镜像。
- en: 'It is easiest to visualize image management as a directory structure, where
    the name of an image (such as *openjdk*) is a directory containing all the versions
    available for this image. Images are usually identified by a *name* and a version,
    known as a *tag*. But these two components are composed of subcomponents that
    have an assumed default value if not specified, and often, even a tag is omitted
    in commands. For example, the simplest command for pulling the *openjdk* Docker
    image might take the following form:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 将图像管理视为目录结构最为直观，其中图像的名称（例如*openjdk*）是包含此图像所有可用版本的目录。通常使用图像的*名称*和版本，称为*标签*来标识图像。但这两个组件由子组件组成，如果未指定，则具有默认值，并且通常在命令中甚至会省略标签。例如，拉取*openjdk*
    Docker 图像的最简单命令可能采用以下形式：
- en: '[PRE8]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: What is this command actually giving us? Aren’t there several versions of the
    *openjdk* image that you could use? Indeed, yes, and if you are concerned with
    having repeatable builds, you will immediately spot this ambiguity as a potential
    problem.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令实际上给我们带来了什么？*openjdk*图像有几个版本可供选择？确实有，如果您关注可重复构建，您会立即注意到此模糊性可能是一个问题。
- en: 'The first step is to include the image tag in this command, which represents
    a version. The following command implies that I would be pulling version 11 of
    the *openjdk* image:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是在此命令中包含图像标签，表示一个版本。以下命令意味着我将拉取*openjdk*图像的版本11：
- en: '[PRE9]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: So what was I pulling previously, if not 11? A special tag called `latest` is
    implied by default if a tag is not specified. This tag is intended to point to
    the latest version of the image available, but that might not always be the case.
    At any point, a tag can be updated to point to a different version of an image,
    and in some cases, you might find that the tag `latest` has not been set to point
    to anything at all.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 那么之前我拉取的是什么，如果不是11？如果未指定标签，默认情况下会隐含使用特殊标签`latest`。此标签旨在指向可用图像的最新版本，但情况并非总是如此。任何时候，都可以更新标签以指向图像的不同版本，并且在某些情况下，您可能会发现标签`latest`根本未设置指向任何内容。
- en: It is easy to stumble over the nomenclature as well, notably *tag*, which can
    mean something different in different contexts. The term *tag* can mean a specific
    version, or it can also mean the full *image tag*, which includes all the components
    of identification together, including the image *name*.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 同样容易出错的是命名规则，特别是*标签*，在不同的上下文中可能意味着不同的东西。术语*标签*可以指代特定版本，也可以指代包括所有标识组件在内的完整*图像标签*，包括图像*名称*。
- en: 'Here’s the complete format of a Docker image tag with all possible components:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是包含所有可能组件的 Docker 图像标签的完整格式：
- en: '[PRE10]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The only required component is the image *name*, also known as the *image repository*.
    If *tag* is not specified, then *latest* is assumed. If the registry is not specified,
    Docker Hub is the default registry. The following command is an example of how
    to reference an image on a registry other than Docker Hub:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一必需的组件是图像的*名称*，也称为*图像仓库*。如果未指定*标签*，则假定为*latest*。如果未指定注册表，则 Docker Hub 是默认注册表。以下命令是如何引用不同于
    Docker Hub 上的注册表中的图像的示例：
- en: '[PRE11]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Image and Container Layers
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图像和容器层
- en: To build efficient containers, having a thorough understanding of layers is
    essential. The details behind how you build the source of your containers—your
    container *images*—greatly impact their size and performance, and some approaches
    have security implications, making this concept even more important to master.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建高效的容器，深入理解层的重要性至关重要。构建容器源代码（即容器*图像*）的详细信息极大地影响其大小和性能，并且一些方法还涉及安全问题，使这一概念变得更加重要。
- en: Basically, Docker images are built by establishing a base layer and then subsequently
    making small changes until you arrive at your desired final state. Each layer
    represents a set of changes including, but not limited to, the creation of users
    and related permissions, modifications to configuration or application settings,
    and updates to existing packages or adding/removing packages. These changes all
    amount to additions, modifications, or the removal of sets of files in the resulting
    filesystem. Layers are stacked on top of each other, each one being a delta of
    the changes from the previous layer, and each one identified by a SHA-256 hash
    digest of its contents. As discussed in [“Docker on Your Machine”](#docker_on_your_machine),
    these layers are stored within the root Docker directory.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，Docker镜像是通过建立基础层，然后逐步进行小的更改，直到达到所需的最终状态而构建的。每个图层代表一组更改，包括但不限于创建用户及相关权限、修改配置或应用程序设置，以及更新现有软件包或添加/删除软件包。这些更改都是对最终文件系统中文件集的添加、修改或移除。图层叠加在彼此之上，每个图层都是从前一个图层的更改增量，并由其内容的SHA-256哈希摘要进行标识。如[“你的机器上的Docker”](#docker_on_your_machine)所讨论的那样，这些图层存储在根Docker目录中。
- en: Visualizing layers
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可视化图层
- en: One good way to really visualize layers is to use the command-line tool `dive`,
    available on [GitHub](https://oreil.ly/M2ZBZ). [Figure 3-5](#dive-openjdk-screenshot)
    shows a screenshot of the tool in action using the official latest *openjdk* image
    pulled from Docker Hub. The left pane displays details about the three layers
    that compose the *openjdk* image. The right pane highlights the changes each layer
    applies to the filesystem of the image.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一个真正可视化图层的好方法是使用命令行工具`dive`，该工具可在[GitHub](https://oreil.ly/M2ZBZ)上找到。[图3-5](#dive-openjdk-screenshot)展示了使用从Docker
    Hub拉取的官方最新*openjdk*镜像运行该工具的屏幕截图。左侧窗格显示了组成*openjdk*镜像的三个图层的详细信息。右侧窗格突出显示了每个图层对镜像文件系统应用的更改。
- en: '![Dive OpenJDK](Images/dtjd_0305.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![Dive OpenJDK](Images/dtjd_0305.png)'
- en: Figure 3-5\. `dive` with openjdk
  id: totrans-151
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-5\. `dive`与openjdk
- en: The `dive` tool is useful in showing you what the filesystem would look like
    if you were to launch a container based on the *openjdk* image. As you move through
    each subsequent layer, you can see the changes made to the initial filesystem.
    The most important part to convey here is that subsequent layers may obfuscate
    parts of the filesystem of the previous layer (in the case of any moves or deletions
    of files), but the original layer still exists in its original form.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`dive`工具在展示基于*openjdk*镜像启动容器时文件系统的外观时非常有用。随着你浏览每个后续图层，你可以看到对初始文件系统所做的更改。这里最重要的部分是，后续的图层可能会混淆前一个图层文件系统的部分（如果有文件的移动或删除），但原始图层仍以其原始形式存在。'
- en: Leveraging layer cache
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 利用层缓存
- en: Utilizing image layers speeds up image requests, builds, and pushes. It’s a
    clever way to decrease the amount of storage required for images. This strategy
    allows for identical image layers to be shared across multiple images, and reduces
    the amount of time and bandwidth needed for pulling or pushing images that are
    already cached locally or stored in the registry.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 利用图像层可以加快图像请求、构建和推送速度。这是减少图像存储所需空间的巧妙方法。这种策略允许多个图像共享相同的图像层，并减少本地缓存或存储在注册表中的图像拉取或推送所需的时间和带宽。
- en: If you’re using Docker, your system will keep an internal cache of all the images
    you’ve either requested from external registries or built yourself. When new images
    are pushed and pulled, comparisons of each of the image layers are made between
    your local cache and the registry, and decisions are made about whether to push
    or pull individual layers, increasing efficiency.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Docker，系统将保留你从外部注册表请求或自行构建的所有图像的内部缓存。在推送和拉取新图像时，会在本地缓存和注册表之间比较每个图像层，并决定是推送还是拉取单个图层，以提高效率。
- en: Anyone who has ever struggled with their internal Maven repository (haven’t
    we all at some point?), or with any caching mechanism for that matter, is very
    aware that the efficiency and performance improvements internal cache provides
    also come with caveats. Sometimes what you have stored in cache is *not* what
    you intended to use. Using stale cache can easily happen in active development
    and local testing if you aren’t mindful of how and when your local image cache
    is used.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 任何曾经与内部 Maven 仓库（我们都曾在某个时刻吧？）或任何缓存机制（如此类推）挣扎过的人都非常清楚，内部缓存提供的效率和性能改进也伴随着注意事项。有时候你在缓存中存储的并不是你想要使用的内容。在活跃的开发和本地测试中，如果不注意如何及何时使用本地镜像缓存，很容易出现使用过期缓存的情况。
- en: For example, the commands `docker run openjdk` and `docker pull openjdk` behave
    differently where cache is concerned. The former searches for the specified image
    in your local cache with the tag `latest`. If the image exists, the search will
    be considered satisfied, and a new container based on the cached image will be
    launched. The latter command will go a step further and update the *openjdk* image
    on your system if an update exists in the remote registry it was retrieved from.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，命令 `docker run openjdk` 和 `docker pull openjdk` 在涉及缓存时表现不同。前者在本地缓存中查找指定标签为
    `latest` 的镜像。如果镜像存在，搜索将被视为满足，将启动一个基于缓存镜像的新容器。后者的命令将进一步更新来自远程注册表中存在更新的 *openjdk*
    镜像。
- en: Another common mistake is assuming a command in a Dockerfile will run again
    when an image is rebuilt. This is common with `RUN` commands such as `RUN apt-get
    update`. If this line in the Dockerfile doesn’t change at all, as it would if
    you were to specify package names along with specific versions, then the initial
    layer built with this command will live in your cache. It will not get built again.
    This is not a bug, but a feature of the cache to speed up build processes. If
    a layer is determined to be already built, the layer will not be built again.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的错误是假设 Dockerfile 中的命令在重新构建镜像时会再次运行。这在 `RUN` 命令中尤为常见，如 `RUN apt-get update`。如果
    Dockerfile 中的这行代码根本没有变化，比如你未指定包名及其具体版本，那么包含此命令的初始层将存在于缓存中，不会重新构建。这不是错误，而是缓存的一种特性，用于加快构建过程。如果确定层已构建，则不会重新构建该层。
- en: In an attempt to avoid stale cache, you might be tempted to combine commands
    on one line (producing one layer) in a Dockerfile in order for changes to be more
    easily recognized and acted on more frequently. The problem with this approach
    is that by squashing too much into a single layer, you lose the benefit of the
    cache altogether.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免过期缓存，你可能会试图在 Dockerfile 中将多个命令组合成一行（生成一个层），以便更容易识别和更频繁地执行更改。但这种方法的问题在于，如果把太多内容压缩成一个层，将完全失去缓存的好处。
- en: Tip
  id: totrans-160
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: As a developer, be conscientious regarding your local cache. And beyond local
    development, consider how your continuous integration, build servers, and automated
    integration testing is using cache. Ensuring that all systems are consistent in
    this way will help keep you from chasing unexplained and intermittent failures.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发人员，要注意本地缓存。除了本地开发外，还要考虑持续集成、构建服务器和自动集成测试如何使用缓存。确保所有系统在这方面的一致性将有助于避免不明原因和间歇性的失败。
- en: Best Image Build Practices and Container Gotchas
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳镜像构建实践和容器注意事项
- en: After some time spent building and playing with images, you’re going to discover
    that you can shoot yourself in the foot in a lot of places in even the most basic
    build process. The following is a set of practices to keep in mind as you start
    on your image-building journey. You will discover more, but these are the most
    important.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建和使用镜像时，你会发现即使是最基本的构建过程也可能在许多地方给自己制造麻烦。以下是一些在开始镜像构建旅程时要牢记的实践方法。你会发现更多内容，但这些是最重要的。
- en: Respect the Docker Context and .dockerignore File
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尊重 Docker 上下文和 .dockerignore 文件。
- en: You don’t want to have certain things in your production Docker image—things
    like your development environment configuration, keys, your *.git* directory,
    or other sensitive hidden directories. When you run the command to build a Docker
    image, you provide the *context*, or the location of files you want to make available
    to the build process.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 不希望将开发环境配置、密钥、*.git*目录或其他敏感隐藏目录包含在生产 Docker 镜像中。构建 Docker 镜像时，需提供*上下文*，即要在构建过程中提供文件的位置。
- en: 'The following is a contrived Dockerfile example:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个虚构的Dockerfile示例：
- en: '[PRE12]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: See the `COPY` instruction? Depending on what you sent in as the context, this
    could be problematic. It could be copying *everything* from your working directory
    into the Docker image you build, which will end up in any container launched from
    this image.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 看到`COPY`指令了吗？取决于您作为上下文发送的内容，这可能会有问题。它可能会将*所有*工作目录中的内容复制到您构建的Docker映像中，并最终出现在从此映像启动的任何容器中。
- en: 'Make sure to use a *.dockerignore* file to exclude files from the context that
    you don’t want showing up unintentionally. You can use it to avoid accidentally
    adding any user-specific files or secrets that you might have stored locally.
    In fact, you can greatly reduce the size of the context (and the time it takes
    to build) by excluding anything the build doesn’t require access to:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 确保使用*.dockerignore*文件来排除上下文中不希望无意中出现的文件。您可以使用它来避免意外添加任何本地存储的用户特定文件或机密信息。事实上，通过排除构建不需要访问的任何内容，您可以大大减少上下文的大小（以及构建所需的时间）：
- en: '[PRE13]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The *.dockerignore* matching format follows [Go’s `filepath.Match` rules](https://oreil.ly/sCjIv).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*.dockerignore*匹配格式遵循[Go的`filepath.Match`规则](https://oreil.ly/sCjIv)。'
- en: Use Trusted Base Images
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用可信的基础映像
- en: Whether you choose to use images that include OpenJDK, Oracle JDK, GraalVM,
    or other images that include a web server or a database, make sure you are using
    trusted images as parent images, or creating your own from scratch.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您选择使用包含OpenJDK、Oracle JDK、GraalVM或其他包含Web服务器或数据库的映像，确保使用可信的映像作为父映像，或者从头开始创建您自己的映像。
- en: Docker Hub proclaims to be the world’s largest library for publicly available
    container images, with over 100,000 images from software vendors, open source
    projects, and the community. *Not all of these images should be trusted to use
    as base images.*
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub自称是全球最大的公共可用容器映像库，拥有来自软件供应商、开源项目和社区的超过100,000个映像。*并非所有这些映像都应该信任用作基础映像。*
- en: 'Docker Hub includes a set of curated images labeled “Docker Official Images”
    that are suitable for use as base images (note that distribution of these requires
    an agreement with Docker). These details are from the [online Docker docs on official
    images](https://oreil.ly/TO8Po):'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub包含一组经策划的映像，标记为“Docker官方映像”，适合用作基础映像（请注意，分发这些映像需要与Docker的协议达成一致）。这些详细信息来自[官方映像的在线Docker文档](https://oreil.ly/TO8Po)：
- en: Docker, Inc. sponsors a dedicated team that is responsible for reviewing and
    publishing all content in the Docker Official Images. This team works in collaboration
    with upstream software maintainers, security experts, and the broader Docker community.
  id: totrans-176
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Docker, Inc.赞助了一个专门的团队，负责审查和发布Docker官方映像中的所有内容。该团队与上游软件维护者、安全专家以及更广泛的Docker社区合作。
- en: As important as understanding what Java dependencies are brought into your project
    and the depth of your dependency tree, so is understanding what your base image
    is bringing in under that one little `FROM` line at the top of your Dockerfile.
    The inheritance structure of Dockerfiles can easily obfuscate how much your base
    image is dragging along with it in the form of additional libraries and packages
    you don’t need or possibly even malevolent content.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 与了解Java依赖项引入到您的项目及依赖树深度同样重要的是，了解您的基础映像在Dockerfile顶部的那一行`FROM`中带入了什么。Dockerfile的继承结构很容易掩盖基础映像在其后带入的额外库和包，这些可能是您不需要的，甚至可能是恶意内容。
- en: Specify Package Versions and Keep Up with Updates
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指定包版本并跟上更新
- en: Given the caveats discussed earlier about caching on top of the desire to maintain
    repeatable builds, specify versions in your Dockerfile just as you would in your
    Java project. Avoid broken builds and unexpected behavior from new versions or
    unexpected updates.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于前面讨论过的有关缓存的警告以及保持可重复构建的愿望，像在Java项目中一样在您的Dockerfile中指定版本。避免由新版本或意外更新引起的构建失败和意外行为。
- en: That said, it’s easy to get complacent with updating versions if they never
    force you to look at them because of a failed build or test. Regularly audit your
    project for needed updates and make these updates intentional. This should be
    part of your regular project planning. I advise that this activity be separate
    from any other feature development or bug fixing in order to eliminate unrelated
    moving parts in your development lifecycle.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，如果由于构建失败或测试而强迫您查看版本，很容易对更新版本变得漠不关心。定期审计项目以获取所需的更新，并使这些更新成为有意义的。这应该成为您常规项目规划的一部分。我建议将这种活动与任何其他特性开发或错误修复分开，以消除开发生命周期中无关的动态部分。
- en: Keep Your Images Small
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保持镜像小巧
- en: It is easy for images to become very large, very fast. Monitor size increases
    in your automated builds and set up notifications for unusual size changes. Gluttonous
    disk storage packages can easily sneak in via updates to a base image or be unintentionally
    included in a `COPY` statement.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像很容易变得非常大，速度很快。在自动化构建中监控大小的增加，并设置异常大小变化的通知。贪吃的磁盘存储包可以通过基础镜像的更新轻易悄然进入，或者无意中包含在`COPY`语句中。
- en: 'Utilize multistage builds to keep your images small. A multistage build can
    be set up by creating a Dockerfile that uses multiple `FROM` statements, which
    begin a build stage with a different base image. By using multistage builds, you
    can avoid including things like build tools or package managers that are not needed
    (and really should not be included) in a production image. For example, the following
    Dockerfile shows a two-stage build. The first uses a base image that includes
    Maven. After the Maven build is complete, the required JAR file is copied to the
    second stage, which uses an image that does *not* include Maven:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 利用多阶段构建保持您的镜像小巧。可以通过创建一个使用多个`FROM`语句的Dockerfile来设置多阶段构建，每个语句都使用不同的基础镜像开始构建阶段。通过使用多阶段构建，您可以避免在生产镜像中包含不需要的（实际上也不应该包含）构建工具或包管理器。例如，以下Dockerfile显示了一个两阶段构建。第一阶段使用包含Maven的基础镜像。在Maven构建完成后，所需的JAR文件被复制到第二阶段，该阶段使用不包含Maven的镜像：
- en: '[PRE14]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is also a good way to implement the use of a custom *distroless* image,
    an image that has been stripped of everything (including a shell) but the absolute
    essentials for running your application.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是实现自定义*distroless*镜像的好方法，该镜像已经剥离了所有内容（包括shell），只保留了运行应用程序的绝对必需品。
- en: Beware of External Resources
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 警惕外部资源
- en: I have often seen requests to external resources within Dockerfiles in the form
    of `wget` commands for installation of proprietary software or even external requests
    for shell scripts that perform a custom installation. These terrify me. More than
    general suspicion and paranoia are involved here. Even if the external resource
    is trusted, the more you relinquish control to parts of your build to external
    parties, the more likely you are to suffer build failures that are out of your
    control to fix.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常看到在Dockerfile中请求外部资源的要求，形式为用于安装专有软件的`wget`命令，甚至用于执行自定义安装的shell脚本的外部请求。这使我感到恐惧。这不仅仅是普通的怀疑和偏执。即使外部资源是可信的，当你把构建的控制权交给外部方之后，你更可能遭遇无法解决的构建失败。
- en: 'The first response I often get when making this observation is this: “There’s
    nothing to worry about because once you’ve built your image, it’s cached or stored
    within a base image, and you won’t have to ever make the request again.”'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当我指出这一观察时，我经常得到的第一个反应是：“不用担心，因为一旦构建了您的镜像，它就被缓存或存储在基础镜像中，您将永远不必再次发出请求。”
- en: This is absolutely true. Once you have your base image stored, or your image
    layer cached, you’re good to go. But the first time a new build node (with zero
    cache) is put into play, or even when a new developer joins your team, building
    that image might fail. When you need to build a new version of the base image,
    your build might fail. Why? Because time and time again, external managers of
    resources will move them, restrict access to them, or simply *dispose of them*.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这是绝对真实的。一旦您存储了基础镜像或您的镜像层被缓存，您就可以放心了。但是，当新的构建节点（没有缓存）投入使用时，或者当新的开发人员加入您的团队时，构建该镜像可能会失败。当您需要构建基础镜像的新版本时，您的构建可能会失败。为什么？因为一次又一次地，资源的外部管理者会移动它们，限制对它们的访问，或者简单地*丢弃它们*。
- en: Protect Your Secrets
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保护你的机密
- en: I include this because in addition to not moving secrets into your image in
    the first place, don’t think that using a command in a Dockerfile to remove them
    from a base image or any other previous layer is good enough. I’ve seen this before
    as a hack to “fix” a base layer that couldn’t be rebuilt right away.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我包括这个因为除了一开始就不将机密移入您的映像之外，不要认为在Dockerfile中使用命令从基础映像或任何先前层中删除它们就足够好。我曾经见过这种情况，将其作为“修复”无法立即重建的基础层的黑客方式。
- en: Now that you know how layering works, you know that a subsequent layer deleting
    items does not actually remove them from the underlying layer. You can’t see them
    if you were to `exec` into a running container based on that image, but they are
    still there. They exist on the system the image is stored on, they exist anywhere
    a container based on that image is launched, and they also exist in the image
    registry you’ve chosen for long-term storage. This is close to the equivalent
    of checking your passwords into source control. Do not put secrets into images
    to begin with.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您了解了层次结构的工作原理，您知道后续层次删除项目并不实际从底层删除它们。如果您对基于该映像的运行容器执行`exec`，则看不到它们，但它们仍然存在。它们存在于存储映像的系统上，它们存在于启动基于该映像的容器的任何地方，它们还存在于您选择的映像注册表中，以供长期存储。这几乎相当于将您的密码检入源代码控制中。一开始就不要将机密放入映像中。
- en: Know Your Outputs
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解您的输出
- en: Numerous factors can cause a container to continuously grow while it’s running.
    One of the most common is not dealing with log files appropriately. Ensure that
    your application is logging to a volume where you can implement a log-rotating
    solution. Given the ephemeral nature of containers, it doesn’t make sense to keep
    logs that you would use for troubleshooting or for compliance stored within the
    container (on the Docker host).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 多种因素可能导致容器在运行时持续增长。其中最常见的之一是未适当处理日志文件。确保您的应用程序记录到一个卷中，您可以实施日志轮换解决方案。考虑到容器的临时性质，将用于故障排除或合规性的日志存储在容器内部（在Docker主机上）是没有意义的。
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Much of this chapter was about exploring Docker. And this is an excellent place
    to start. Once you are comfortable with images and containers, you can branch
    out to other tools available in the ecosystem. Depending on the operating system
    and build utilities you’ve chosen for your project, tools such as [Buildah](https://buildah.io),
    [Podman](https://podman.io), or [Bazel](https://bazel.build) might work well for
    you. You might also choose to use a Maven plug-in such as [Jib](https://oreil.ly/pwGsw)
    to build your container image.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的大部分内容是关于探索Docker的。这是一个开始的绝佳地方。一旦您熟悉了映像和容器，您可以扩展到生态系统中提供的其他工具。根据您选择的操作系统和项目构建工具，诸如[Buildah](https://buildah.io)，[Podman](https://podman.io)或[Bazel](https://bazel.build)这样的工具可能非常适合您。您还可以选择使用像[Jib](https://oreil.ly/pwGsw)这样的Maven插件来构建您的容器映像。
- en: 'One word of caution: whichever tool you choose, understand how your images
    and containers are built so you don’t suffer the consequences of bulky and/or
    insecure images and containers when you are ready to deploy.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个警告：无论选择哪种工具，请了解您的映像和容器是如何构建的，以免在准备部署时遭受臃肿和/或不安全的映像和容器的后果。
