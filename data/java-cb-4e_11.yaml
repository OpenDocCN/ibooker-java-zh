- en: Chapter 11\. Data Science and R
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 11 章 数据科学与 R
- en: 'Data science is a relatively new discipline that first came to the attention
    of many with this [article by O’Reilly’s Mike Loukides](https://www.oreilly.com/ideas/what-is-data-science).
    While there are many definitions in the field, Loukides distills his detailed
    observation of and participation in the field into this definition:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 数据科学是一个相对较新的学科，最初因 [O’Reilly 的 Mike Loukides 的这篇文章](https://www.oreilly.com/ideas/what-is-data-science)
    而引起了许多人的注意。虽然在这个领域有许多定义，但 Loukides 将他对该领域的详细观察和参与归结为这个定义：
- en: A data application acquires its value from the data itself, and creates more
    data as a result. It’s not just an application with data; it’s a data product.
    Data science enables the creation of data products.
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 数据应用从数据本身获取其价值，并随之生成更多数据。它不仅仅是一个带有数据的应用程序；它是一个数据产品。数据科学使得数据产品的创建成为可能。
- en: One of the main open source ecosystems for data science software is at Apache
    and includes [Hadoop](https://hadoop.apache.org) (which includes the HDFS distributed
    filesystem, Hadoop Map/Reduce,^([1](ch11.html#idm45290648185096)) Ozone object
    store, and Yarn scheduler), the [Cassandra distributed database](https://cassandra.apache.org),
    and the [Spark compute engine](https://spark.apache.org). Read the “Modules and
    Related Tools” section of the Hadoop page for a current list.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 用于数据科学软件的主要开源生态系统之一位于 Apache，包括 [Hadoop](https://hadoop.apache.org)（包括 HDFS
    分布式文件系统，Hadoop Map/Reduce，^([1](ch11.html#idm45290648185096)) Ozone 对象存储和 Yarn
    调度程序）、[Cassandra 分布式数据库](https://cassandra.apache.org) 和 [Spark 计算引擎](https://spark.apache.org)。请阅读
    Hadoop 页面的“模块和相关工具”部分以获取当前列表。
- en: What’s interesting here is that a great deal of this infrastructure, which is
    taken for granted by data scientists, is written in Java and Scala (a JVM language).
    Much of the rest is written in Python, a language that complements Java.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有趣的是，许多数据科学家视为理所当然的大部分基础设施都是用 Java 和 Scala（一种 JVM 语言）编写的。其余大部分则是用 Python 编写的，这是一种与
    Java 互补的语言。
- en: Data science problems may involve a lot of setup, so we’ll only give one example
    from traditional DS, using the Spark framework. Spark is written in Scala so it
    can be used directly by Java code.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 数据科学问题可能涉及大量的设置，所以我们只会从传统数据科学中给出一个使用 Spark 框架的例子。Spark 是用 Scala 编写的，因此可以直接被
    Java 代码使用。
- en: In the rest of the chapter I’ll focus on a language called R, which is widely
    used both in statistics and in data science (well, also in many other sciences;
    many of the graphs you see in refereed journal articles are prepared with R).
    R is widely used and is useful to know. Its primary implementation was not written
    in Java, but in a mixture of C, Fortran, and R itself. But R can be used within
    Java, and Java can be used within R. I’ll talk about several implementations of
    R and how to select one, and then I’ll show techniques for using Java from R and
    R from Java, as well as using R in a web application.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，我将专注于一种称为 R 的语言，它在统计学和数据科学中被广泛使用（好吧，在许多其他科学领域也是如此；你在同行评审的期刊文章中看到的许多图表都是用
    R 准备的）。R 被广泛使用，了解它是很有用的。它的主要实现不是用 Java 编写的，而是用 C、Fortran 和 R 本身的混合语言。但是 R 可以在
    Java 中使用，Java 也可以在 R 中使用。我将讨论几种 R 的实现方式以及如何选择一种，然后展示如何从 R 中使用 Java，从 Java 中使用
    R，以及在 Web 应用程序中使用 R 的技术。
- en: 11.1 Machine Learning with Java
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11.1 使用 Java 进行机器学习
- en: Problem
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to use Java for machine learning and data science, but everyone tells
    you to use Python.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要使用 Java 进行机器学习和数据科学，但每个人都告诉你要使用 Python。
- en: Solution
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use one of the many powerful Java toolkits available for free download.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 使用众多免费下载的强大 Java 工具包之一。
- en: Discussion
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: It’s sometimes said that machine learning (ML) and deep learning have to be
    done in C++ for efficiency or in Python for the wide availability of software.
    While these languages have their advantages and their advocates, it is certainly
    possible to use Java for these purposes. However, setting up these packages and
    presenting a short demo tends to be longer than would fit in this book’s typical
    recipe format.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候人们说机器学习（ML）和深度学习必须用 C++ 来提高效率，或者用 Python 来利用广泛的软件可用性。尽管这些语言各有其优势和支持者，但确实可以使用
    Java 来实现这些目的。然而，设置这些软件包并展示一个简短的演示比适合本书典型的配方格式要长。
- en: With industry giant Amazon having released its Java-based Deep Java Learning
    (DJL) library as this book was going to press, and many other good libraries available
    (with quite a few supporting [CUDA](https://developer.nvidia.com/cuda-zone) for
    faster GPU-based processing) (see [Table 11-1](#javacook-ds-java-ml)), there is
    no reason to avoid using Java for ML. With the exception of DJL, I’ve tried to
    list packages that are still being maintained and have a decent reputation among
    users.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 随着行业巨头亚马逊发布基于 Java 的 Deep Java Learning (DJL) 库，以及许多其他优秀的库（其中不少支持 [CUDA](https://developer.nvidia.com/cuda-zone)
    以加速 GPU 计算）（参见 [Table 11-1](#javacook-ds-java-ml)），没有理由不使用 Java 进行机器学习。除了 DJL
    外，我尽量列出那些仍在维护且在用户中口碑不错的包。
- en: Table 11-1\. Some Java machine learning packages
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Table 11-1\. 一些 Java 机器学习包
- en: '| Library name | Description | Info URL | Source URL |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| Library name | 描述 | 信息网址 | 源码网址 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| ADAMS | Workflow engine for building/maintaining data-driven, reactive workflows;
    integration with business processes | [*https://adams.cms.waikato.ac.nz/*](https://adams.cms.waikato.ac.nz/)
    | [*https://github.com/waikato-datamining/adams-base*](https://github.com/waikato-datamining/adams-base)
    |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| ADAMS | 用于构建/维护数据驱动反应式工作流程的工作流引擎；与业务流程集成 | [*https://adams.cms.waikato.ac.nz/*](https://adams.cms.waikato.ac.nz/)
    | [*https://github.com/waikato-datamining/adams-base*](https://github.com/waikato-datamining/adams-base)
    |'
- en: '| Deep Java Library | Amazon’s ML library | [*https://djl.ai*](https://djl.ai)
    | [*https://github.com/awslabs/djl*](https://github.com/awslabs/djl) |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| Deep Java Library | 亚马逊的机器学习库 | [*https://djl.ai*](https://djl.ai) | [*https://github.com/awslabs/djl*](https://github.com/awslabs/djl)
    |'
- en: '| Deeplearning4j | DL4J, Eclipse’s distributed deep-learning library; integrates
    w/ Hadoop and Apache Spark | [*https://deeplearning4j.org/*](https://deeplearning4j.org/)
    | [*https://github.com/eclipse/deeplearning4j*](https://github.com/eclipse/deeplearning4j)
    |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| Deeplearning4j | DL4J，Eclipse 的分布式深度学习库；与 Hadoop 和 Apache Spark 集成 | [*https://deeplearning4j.org/*](https://deeplearning4j.org/)
    | [*https://github.com/eclipse/deeplearning4j*](https://github.com/eclipse/deeplearning4j)
    |'
- en: '| ELKI | Data mining toolkit | [*https://elki-project.github.io/*](https://elki-project.github.io/)
    | [*https://github.com/elki-project/elki*](https://github.com/elki-project/elki)
    |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| ELKI | 数据挖掘工具包 | [*https://elki-project.github.io/*](https://elki-project.github.io/)
    | [*https://github.com/elki-project/elki*](https://github.com/elki-project/elki)
    |'
- en: '| Mallet | ML for text processing | mallet.cs.umass.edu | [*https://github.com/mimno/Mallet.git*](https://github.com/mimno/Mallet.git)
    |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| Mallet | 用于文本处理的机器学习库 | mallet.cs.umass.edu | [*https://github.com/mimno/Mallet.git*](https://github.com/mimno/Mallet.git)
    |'
- en: '| Weka | ML algorithms for data mining; tools for data preparation, classification,
    regression, clustering, association rules mining, and visualization | [*https://www.cs.waikato.ac.nz/ml/weka/index.html*](https://www.cs.waikato.ac.nz/ml/weka/index.html)
    | [*https://svn.cms.waikato.ac.nz/svn/weka/trunk/weka*](https://svn.cms.waikato.ac.nz/svn/weka/trunk/weka)
    |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| Weka | 数据挖掘的机器学习算法；提供数据准备、分类、回归、聚类、关联规则挖掘和可视化工具 | [*https://www.cs.waikato.ac.nz/ml/weka/index.html*](https://www.cs.waikato.ac.nz/ml/weka/index.html)
    | [*https://svn.cms.waikato.ac.nz/svn/weka/trunk/weka*](https://svn.cms.waikato.ac.nz/svn/weka/trunk/weka)
    |'
- en: See Also
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'The book *Data Mining: Practical Machine Learning and Techniques* by Ian Witten
    et al. (Morgan Kaufmann) was written by the team behind Weka.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '书籍 *Data Mining: Practical Machine Learning and Techniques* 由 Ian Witten 等人（Morgan
    Kaufmann 出版）编写，他们也是 Weka 背后团队的成员。'
- en: See also Eugen Parschiv’s [list of Java AI software packages](https://www.baeldung.com/java-ai).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以参考 Eugen Parschiv 的 [Java AI 软件包列表](https://www.baeldung.com/java-ai)。
- en: 11.2 Using Data In Apache Spark
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11.2 在 Apache Spark 中使用数据
- en: Problem
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to process data using Spark.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望使用 Spark 处理数据。
- en: Solution
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Create a `SparkSession`, use its `read()` function to read a `DataSet`, apply
    operations, and summarize results.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 `SparkSession`，使用其 `read()` 函数读取 `DataSet`，应用操作并总结结果。
- en: Discussion
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Spark is a massive subject! Entire books have been written on using it. Quoting
    [Databricks](https://databricks.com), home of much of the original Spark team:^([2](ch11.html#idm45290648114600))
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Spark 是一个非常庞大的主题！已经有整本书专门讲述了它。引用 [Databricks](https://databricks.com)，这个团队是
    Spark 最初的开发者之一：^([2](ch11.html#idm45290648114600))
- en: Apache Spark™ has seen immense growth over the past several years, becoming
    the de-facto data processing and AI engine in enterprises today due to its speed,
    ease of use, and sophisticated analytics. Spark unifies data and AI by simplifying
    data preparation at massive scale across various sources, providing a consistent
    set of APIs for both data engineering and data science workloads, as well as seamless
    integration with popular AI frameworks and libraries such as TensorFlow, PyTorch,
    R and SciKit-Learn.
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Apache Spark™ 在过去几年中取得了巨大的增长，成为今天企业中的事实标准数据处理和AI引擎，这归功于其速度、易用性和复杂的分析功能。Spark通过简化跨多个来源的大规模数据准备，为数据工程和数据科学工作负载提供一致的API集，以及与流行的AI框架和库（如TensorFlow、PyTorch、R和SciKit-Learn）的无缝集成，统一了数据和人工智能。
- en: I cannot convey the whole subject matter in this book. However, one thing Spark
    is good for is dealing with lots of data. In [Example 11-1](#javacook-ds-EX-spark1),
    we read an Apache-format logfile and find (and count) the lines with 200, 404,
    and 500 responses.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我无法在本书中传达整个主题内容。然而，Spark擅长处理大量数据，比如在[示例 11-1](#javacook-ds-EX-spark1)中，我们读取了一个Apache格式的日志文件，并找到（和计数）具有200、404和500响应的行。
- en: Example 11-1\. spark/src/main/java/sparkdemo/LogReader.java
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-1\. spark/src/main/java/sparkdemo/LogReader.java
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[![1](assets/1.png)](#co_data_science_and_r_CO1-1)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_data_science_and_r_CO1-1)'
- en: Set up the filename for the logfile. It probably should come from `args`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 设置日志文件的文件名。可能应该从`args`中获取。
- en: '[![2](assets/2.png)](#co_data_science_and_r_CO1-2)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_data_science_and_r_CO1-2)'
- en: Start up the Spark `SparkSession` object—the runtime.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 启动Spark `SparkSession`对象——运行时环境。
- en: '[![3](assets/3.png)](#co_data_science_and_r_CO1-3)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_data_science_and_r_CO1-3)'
- en: Tell Spark to read the logfile and keep it in memory (cache).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 告诉Spark读取日志文件并将其保留在内存中（缓存）。
- en: '[![4](assets/4.png)](#co_data_science_and_r_CO1-4)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_data_science_and_r_CO1-4)'
- en: Define the filters for 200, 404, and 500 errors. They should be able to use
    lambdas to make the code shorter, but there’s an ambiguity between the Java and
    Scala versions of `FilterFunction`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 定义200、404和500错误的过滤器。它们应该能够使用lambda表达式来使代码更简洁，但Java和Scala版本的`FilterFunction`之间存在歧义。
- en: '[![5](assets/5.png)](#co_data_science_and_r_CO1-5)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_data_science_and_r_CO1-5)'
- en: Print the results.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 打印结果。
- en: 'To make this *compile*, you need to add the following to a Maven POM file:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要使其*编译*通过，您需要将以下内容添加到Maven的POM文件中：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Then you should be able to do `mvn package` to get a JAR file packaged.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你应该能够执行`mvn package`命令来生成一个打包好的JAR文件。
- en: 'The use of the `provided` scope is because we will also download the Apache
    Spark runtime package from [the Spark Download page](https://spark.apache.org/downloads.html)
    in order to *run* the application. Unpack the distribution and set the `SPARK_HOME`
    environment to the root of it:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`provided`范围的原因是因为我们还将从[Spark下载页面](https://spark.apache.org/downloads.html)下载Apache
    Spark运行时包以*运行*应用程序。解压分发包并将`SPARK_HOME`环境设置为其根目录：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Then you can use the `run` script that I’ve provided in the source download
    (*javasrc/spark*).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以使用我在源代码下载中提供的`run`脚本（*javasrc/spark*）。
- en: 'Spark is designed for larger-scale computing than what’s in this simple example,
    so its voluminous output simply dwarfs the output from my simple sample program.
    Nonetheless, for an approximately 42,000-line file, I did get this result, buried
    among the logging:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Spark的设计面向比这个简单示例更大规模的计算，因此其庞大的输出简直淹没了我简单示例程序的输出。尽管如此，对于一个大约有42,000行的文件，我确实得到了这个结果，埋藏在日志记录中：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As mentioned, Spark is a massive subject but a necessary tool for most data
    scientists. You can program Spark in Java (obviously), or in Scala. Scala is a
    JVM language that promotes functional programming (see [this Scala tutorial for
    Java devs](https://www.dhgarrette.com/nlpclass/scala/basics.html)) in Python and
    probably other languages. You can learn more at [*https://spark.apache.org*](https://spark.apache.org)
    or from the many books, videos, and tutorials online.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Spark 是一个庞大的主题，但对大多数数据科学家来说是一个必不可少的工具。你可以使用Java（显然），或者Scala来编写Spark程序。Scala是一种促进函数式编程的JVM语言（参见[此Scala教程供Java开发人员使用](https://www.dhgarrette.com/nlpclass/scala/basics.html)），以及Python和可能其他语言。你可以在[*https://spark.apache.org*](https://spark.apache.org)或者在线的众多书籍、视频和教程中了解更多。
- en: 11.3 Using R Interactively
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11.3 使用R进行交互
- en: Problem
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You don’t know the first thing about R, and you want to.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你对R一无所知，但你想要了解它。
- en: Solution
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: R has been around for ages, and its predecessor S for a decade before that.
    There are many books and online resources devoted to this language. The official
    home page is at [*https://www.r-project.org*](https://www.r-project.org). There
    are many online tutorials; the [R Project hosts one](https://cran.r-project.org/doc/contrib/Paradis-rdebuts_en.pdf).
    R itself is available in most systems’ package managers, and it can be downloaded
    from the official [download site](https://cran.r-project.org/mirrors.html). The
    name *CRAN* in these URLs stands for Comprehensive R Archive Network, named in
    a similar fashion to TeX’s CTAN and the Perl language’s CPAN.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: R 已经存在多年，其前身 S 则存在了十年之久。有许多书籍和在线资源致力于这种语言。官方主页位于[*https://www.r-project.org*](https://www.r-project.org)。还有许多在线教程；[R
    项目](https://cran.r-project.org/doc/contrib/Paradis-rdebuts_en.pdf)提供了一个。R 本身可以在大多数系统的软件包管理器中找到，并且可以从官方[下载站点](https://cran.r-project.org/mirrors.html)下载。这些
    URL 中的名称 *CRAN* 代表 Comprehensive R Archive Network，类似于 TeX 的 CTAN 和 Perl 语言的 CPAN。
- en: In this example we’ll write some data from a Java program and then analyze and
    graph it using R interactively.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将从 Java 程序中写入一些数据，然后使用 R 进行交互式分析和绘图。
- en: Discussion
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'This is merely a brief intro to using R interactively. Suffice to say that
    R is a valuable interactive environment for exploring data. Here are some simple
    calculations to show the flavor of the language: a chatty startup (so long I had
    to cut part of it), simple arithmetic, automatic printing of results if not saved,
    half-decent errors when you make a mistake, and arithmetic on vectors. You may
    see some similarities to Java’s JShell (see [Recipe 1.4](ch01.html#javacook-getstarted-JSHELL));
    both are REPL (Read-Evaluate-Print Loop) interfaces. R adds the ability to save
    your interactive session (*workspace*) when exiting the program, so all your data
    and function definitions are restored next time you start R. A simple interactive
    session showing a bit of the syntax of R might look like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个使用 R 进行交互式操作简介。可以说，R 是一个非常有价值的交互式环境，用于探索数据。以下是一些简单的计算，展示了该语言的特色：一个健谈的启动（如此之长，我不得不截断了一部分），简单算术运算，如果未保存则自动打印结果，当你犯错误时会有相当不错的错误提示，以及对向量的算术运算。你可能会发现与
    Java 的 JShell（见[食谱 1.4](ch01.html#javacook-getstarted-JSHELL)）有些相似之处；它们都是 REPL（读取-求值-打印
    循环）接口。R 添加了在退出程序时保存你的交互会话（*工作空间*）的功能，因此下次启动 R 时会恢复所有的数据和函数定义。展示 R 语法的简单交互会话可能如下所示：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: R purists will usually use the *assignment arrow* ← in lieu of the *=* sign
    when assigning. If you like that, go for it.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: R 纯粹主义者通常会在分配时使用*赋值箭头* ← 替代 *=* 符号。如果你喜欢这样，可以去尝试。
- en: 'This short session barely scratches the surface: R offers hundreds of built-in
    functions, sample datasets, over a thousand add-on packages, built-in help, and
    much more. For interactive exploration of data, R is really the one to beat.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简短的会话只是浅尝辄止：R 提供了数百个内置函数、示例数据集、一千多个附加包、内置帮助等等。对于交互式数据探索，R 确实是首选。
- en: Some people prefer a GUI frontend to R. [RStudio](https://rstudio.com) is the
    most widely used GUI frontend.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人更喜欢使用 R 的图形用户界面。[RStudio](https://rstudio.com) 是最广泛使用的 GUI 前端。
- en: 'Now we want to write some data from Java and process it in R (we’ll use Java
    and R together in later recipes in this chapter). In [Recipe 5.9](ch05.html#javacook-numbers-SECT-13)
    we discussed the `java.util.Random` class and its `nextDouble()` and `nextGaussian()`
    methods. The `nextDouble()` and related methods try to give a flat distribution
    between 0 and 1.0, in which each value has an equal chance of being selected.
    A Gaussian or normal distribution is a bell curve of values from negative infinity
    to positive infinity, with the majority of the values clustered around zero (0.0).
    We’ll use R’s histogramming and graphics functions to examine visually how well
    they do so:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想要从 Java 中写入一些数据，并在 R 中进行处理（我们将在本章后续的食谱中一起使用 Java 和 R）。在[食谱 5.9](ch05.html#javacook-numbers-SECT-13)中，我们讨论了
    `java.util.Random` 类及其 `nextDouble()` 和 `nextGaussian()` 方法。`nextDouble()` 和相关方法试图提供在
    0 到 1.0 之间的平均分布，其中每个值被选择的概率相等。高斯或正态分布是从负无穷到正无穷的钟形曲线，大多数值聚集在零（0.0）附近。我们将使用 R 的直方图和图形函数来视觉化地检查它们的效果：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To illustrate the different distributions, I generated 10,000 numbers each using
    `nextRandom()` and `nextGaussian()`. The code for this is in *Random4.java* (not
    shown here) and is a combination of the preceding sample code with code to print
    just the numbers into two files. I then plotted histograms using R; the R script
    used to generate the graph is in *javasrc* under *src/main/resources*, but its
    core is shown in [Example 11-2](#javacook-ds-histograms). The results are shown
    in [Figure 11-1](#javacook-ds-FIG-1).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明不同的分布，我使用 `nextRandom()` 和 `nextGaussian()` 生成了 10,000 个数字。代码在 *Random4.java*
    中（此处未显示），是前面示例代码和仅将数字打印到两个文件中的代码的组合。然后我使用 R 绘制了直方图；生成图形的 R 脚本在 *javasrc* 下的 *src/main/resources*
    中，但其核心显示在[示例 11-2](#javacook-ds-histograms)中。结果显示在[图 11-1](#javacook-ds-FIG-1)中。
- en: Example 11-2\. R commands to generate histograms
  id: totrans-72
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-2\. 生成直方图的 R 命令
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `png()` call tells R which graphics device to use. Others include `X11()`
    and `Postscript()`. `read.table()` reads data from a text file into a table; the
    `[1]` gives us just the data column, ignoring some metadata. The `layout()` call
    says we want two graphics objects displayed side by side. Each `hist()` call draws
    one of the two histograms. And `dev.off()` closes the output and flushes any writing
    buffers to the PNG file. The result is shown in [Figure 11-1](#javacook-ds-FIG-1).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`png()` 调用告诉 R 使用哪个图形设备。其他包括 `X11()` 和 `Postscript()`。`read.table()` 从文本文件中读取数据到表格中；`[1]`
    给出了我们只需要的数据列，忽略了一些元数据。`layout()` 调用表示我们想要两个并排显示的图形对象。每个 `hist()` 调用绘制两个直方图中的一个。而
    `dev.off()` 关闭输出并刷新任何写入缓冲区到 PNG 文件。结果显示在[图 11-1](#javacook-ds-FIG-1)中。'
- en: '![jcb4 1101](assets/jcb4_1101.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![jcb4 1101](assets/jcb4_1101.png)'
- en: Figure 11-1\. Flat (left) and Gaussian (right) distributions
  id: totrans-76
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-1\. 平面（左）和高斯（右）分布
- en: 11.4 Comparing/Choosing an R Implementation
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11.4 比较/选择 R 实现
- en: Problem
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You’re not sure which implementation of R to use.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你不确定要使用哪个 R 的实现。
- en: Solution
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Look at original R, Renjin, and FastR.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 查看原始的 R、Renjin 和 FastR。
- en: Discussion
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'The original for R was S, an environment for interactive programming developed
    by John Chambers and others at AT&T Bell Labs starting in 1976. I ran into S when
    supporting the University of Toronto Statistics Department, and again when reviewing
    a commercial implementation of it, SPlus, for a long-ago glossy magazine called
    *Sun Expert*. AT&T was only making S source available to universities and to commercial
    licensees who could not further distribute the source. Two developers at the University
    of Auckland, Ross Ihaka and Robert Gentleman, developed a clone of S, starting
    in 1995. They named it R after their own first initials and as a play on the name
    S. (There is precedent for this: the *awk* language popular on Unix/Linux was
    named for the initials of its designers Aho, Weinberger, and Kernighan). R grew
    quickly because it was very largely compatible with S and was more readily available.
    This implementation of original R is actively managed by the [R Foundation for
    Statistical Computing](https://r-project.org), which also manages the [Comprehensive
    R Archive Network](https://cran.r-project.org).'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: R 的原始版本是 S，这是一个由约翰·钱伯斯等人于 1976 年在 AT&T 贝尔实验室开发的交互式编程环境。我在支持多伦多大学统计系时遇到了 S，还在为一个名为
    *Sun Expert* 的很久以前的杂志审查了它的商业实现 SPlus。AT&T 只向大学和无法进一步分发源代码的商业许可证持有人提供 S 源代码。奥克兰大学的两位开发人员
    Ross Ihaka 和 Robert Gentleman 从 1995 年开始开发了 S 的克隆，并将其命名为 R，以代表他们自己的首字母，同时也是对 S
    名称的一种玩笑。（这方面有先例：在 Unix/Linux 上流行的 *awk* 语言是以其设计者 Aho、Weinberger 和 Kernighan 的首字母命名的）。R
    发展迅速，因为它与 S 非常兼容，并且更容易获取。这个原始 R 的实现由[R Foundation for Statistical Computing](https://r-project.org)积极管理，该基金会还管理[综合
    R 存档网络](https://cran.r-project.org)。
- en: '[Renjin](http://renjin.org) is a fairly complete implementation of R in Java.
    This project provides built JAR files via their own Maven repository.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[Renjin](http://renjin.org) 是一个在 Java 中相当完整的 R 实现。该项目通过他们自己的 Maven 仓库提供构建的
    JAR 文件。'
- en: '[FastR](https://jaxenter.com/fastr-r-virtual-machine-java-140667.html) is another
    implementation in Java, designed to run in the faster GraalVM and supporting direct
    invocation of JVM code from almost any other programming language. The technical
    lead of the FastR descibes the implementation in [this blog post](https://medium.com/graalvm/faster-r-with-fastr-4b8db0e0dceb).'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[FastR](https://jaxenter.com/fastr-r-virtual-machine-java-140667.html) 是另一个
    Java 实现，在更快的 GraalVM 中运行，并支持从几乎任何其他编程语言直接调用 JVM 代码。FastR 的技术负责人在[这篇博文](https://medium.com/graalvm/faster-r-with-fastr-4b8db0e0dceb)中描述了该实现。'
- en: Besides these implementations, R’s popularity has led to development of many
    access libraries for invoking R from many popular programming languages. [Rserve](https://www.rforge.net/Rserve)
    is a TCP/IP networked access mode for R, for which Java wrappers exist.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些实现，R 的流行还促使开发了许多访问库，用于从许多流行的编程语言调用 R。[Rserve](https://www.rforge.net/Rserve)
    是一个 TCP/IP 网络访问模式，为其存在 Java 封装。
- en: '11.5 Using R from Within a Java App: Renjin'
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11.5 在 Java 应用程序中使用 R：Renjin
- en: Problem
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to access R from within a Java application using Renjin.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望通过 Renjin 从 Java 应用程序中访问 R。
- en: Solution
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Add Renjin to your Maven or Gradle build, and call it via the Script Engines
    mechanism described in [Recipe 18.3](ch18.html#javacook-otherlang-scripting).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Renjin 添加到您的 Maven 或 Gradle 构建中，并通过 [Recipe 18.3](ch18.html#javacook-otherlang-scripting)
    中描述的脚本引擎机制进行调用。
- en: Discussion
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Renjin is a pure-Java, open source reimplementation of R and provides a script
    engines interface. Add the following dependency to your build tool:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Renjin 是一个纯 Java 实现的开源 R 重现，提供脚本引擎接口。将以下依赖项添加到您的构建工具中：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Of course there is probably a later version of Renjin than the one shown above
    by the time you read this; use the latest unless there’s a reason not to.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，阅读本文时可能已经有更新版本的 Renjin；除非有特殊原因，应使用最新版本。
- en: 'Note that you will also need a `<repository>` entry since the maintainers put
    their artifacts in the repo at `nexus.betadriven.com` instead of the usual Maven
    Central. Here’s what I used (obtained from [*https://www.renjin.org/downloads.html*](https://www.renjin.org/downloads.html)):'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您还需要一个 `<repository>` 条目，因为维护者将其构件放在 `nexus.betadriven.com` 而不是通常的 Maven
    Central。这是我使用的内容（从 [*https://www.renjin.org/downloads.html*](https://www.renjin.org/downloads.html)
    获取）：
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Once that’s done, you should be able to access Renjin via the Script Engines
    framework, as in [Example 11-3](#otherlang-renjinscriptingjava).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成这些步骤，您应该能够通过脚本引擎框架访问 Renjin，就像 [示例 11-3](#otherlang-renjinscriptingjava)
    中描述的那样。
- en: Example 11-3\. main/src/main/java/otherlang/RenjinScripting.java
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-3\. main/src/main/java/otherlang/RenjinScripting.java
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Because R treats all numbers as floating point, like many interpreters, the
    value printed is `84.0`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 R 将所有数字视为浮点数，类似于许多解释器，打印的值是 `84.0`。
- en: One can also get Renjin to invoke a script file; [Example 11-4](#otherlang-renjinscriptinglonger)
    invokes the same script used in [Recipe 11.3](#javacook-ds-r-interact) to generate
    and plot a batch of pseudorandom numbers.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以让 Renjin 调用一个脚本文件；[示例 11-4](#otherlang-renjinscriptinglonger) 调用与 [Recipe
    11.3](#javacook-ds-r-interact) 中使用的相同脚本来生成和绘制一批伪随机数。
- en: Example 11-4\. Renjin with a script file
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-4\. 使用脚本文件的 Renjin
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Renjin can also be used as a standalone R implementation if you download an
    all-dependencies JAR file from [*https://renjin.org/downloads.html*](https://renjin.org/downloads.html).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您从 [*https://renjin.org/downloads.html*](https://renjin.org/downloads.html)
    下载一个包含所有依赖项的 JAR 文件，Renjin 也可以作为一个独立的 R 实现来使用。
- en: 11.6 Using Java from Within an R Session
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11.6 在 R 会话中使用 Java
- en: Problem
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You are partway through a computation in R and realize that there’s a Java library
    to do the next step. Or for any other reason, you need to call Java code from
    within an R session.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您正在使用 R 计算的过程中，意识到有一个 Java 库可以完成下一步操作。或者出于其他原因，需要在 R 会话中调用 Java 代码。
- en: Solution
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Install rJava, call `.jinit()`, and use `J()` to load classes or invoke methods.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 `rJava`，调用 `.jinit()`，然后使用 `J()` 加载类或调用方法。
- en: Discussion
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Here is the part of an interactive R session in which we install rJava, initialize
    it by calling `.jinit()`, and invoke `java.time.LocalDate.now()` to get the current
    date:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是交互式 R 会话的一部分，在这部分中我们安装 rJava，通过调用 `.jinit()` 进行初始化，并调用 `java.time.LocalDate.now()`
    获取当前日期：
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[![1](assets/1.png)](#co_data_science_and_r_CO2-1)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_data_science_and_r_CO2-1)'
- en: Install the `rJava` package; only needs to be done once.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 `rJava` 包；只需执行一次。
- en: '[![2](assets/2.png)](#co_data_science_and_r_CO2-2)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_data_science_and_r_CO2-2)'
- en: load `rJava`, and initialize it with `.jinit()`; both needed in every R session.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 加载 `rJava`，并使用 `.jinit()` 初始化；每个 R 会话都需要这两步。
- en: '[![3](assets/3.png)](#co_data_science_and_r_CO2-3)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_data_science_and_r_CO2-3)'
- en: The `J` function takes one argument of a full class name. If only that argument
    is given, a class descriptor (like a `java.lang.Class` object) is returned. If
    more than one argument is given, the second is a static method name, and any subsequent
    arguments are passed to that method.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`J` 函数接受一个完整类名作为参数。如果只提供该参数，则返回一个类描述符（例如 `java.lang.Class` 对象）。如果提供多于一个参数，则第二个参数是静态方法名，后续的参数将传递给该方法。'
- en: '[![4](assets/4.png)](#co_data_science_and_r_CO2-4)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_data_science_and_r_CO2-4)'
- en: Returned objects can have Java methods invoked with the standard R *\$* notation;
    here the `toString()` method is invoked to return just a character string instead
    of a `LocalDate` object.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的对象可以使用标准的 R *\$* 符号调用 Java 方法；这里调用 `toString()` 方法以返回字符串而不是 `LocalDate` 对象。
- en: 'The `.jcall` function gives you more control over calling method and return
    types:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`.jcall` 函数使您可以更好地控制调用方法和返回类型：'
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[![1](assets/1.png)](#co_data_science_and_r_CO3-1)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_data_science_and_r_CO3-1)'
- en: Invoke Java `LocalDate.now()` method and save result in R variable *d*.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在 R 变量 *d* 中调用 Java `LocalDate.now()` 方法并保存结果。
- en: '[![2](assets/2.png)](#co_data_science_and_r_CO3-2)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_data_science_and_r_CO3-2)'
- en: Invoke Java `getYear()` method on the `LocalDate` object; the “I” tells `jcall`
    to expect an integer result.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `LocalDate` 对象上调用 Java `getYear()` 方法；“I”告诉 `jcall` 期望一个整数结果。
- en: '[![3](assets/3.png)](#co_data_science_and_r_CO3-3)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_data_science_and_r_CO3-3)'
- en: Call `System.getProperty("user.dir")` and print the result; the “S” tells `.jcall`
    to expect a string return.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `System.getProperty("user.dir")` 并打印结果；“S”告诉 `.jcall` 期望返回一个字符串。
- en: '[![4](assets/4.png)](#co_data_science_and_r_CO3-4)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_data_science_and_r_CO3-4)'
- en: If you will be using a class several times, save the `Class` object, and pass
    it as the first argument of `.jcall()`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将要多次使用一个类，请保存 `Class` 对象，并将其作为 `.jcall()` 的第一个参数传递。
- en: There are more capabilities here; consult [the documentation](https://cran.r-project.org/web/packages/rJava)
    and [a developer.com article](https://www.developer.com/java/ent/getting-started-with-r-using-java.html).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有更多的功能；请参考[文档](https://cran.r-project.org/web/packages/rJava)和[developer.com
    的文章](https://www.developer.com/java/ent/getting-started-with-r-using-java.html)。
- en: 11.7 Using FastR, the GraalVM Implementation of R
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11.7 使用 FastR，GraalVM 实现的 R
- en: Problem
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You use the R language but feel a need for speed.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 您使用 R 语言，但感觉需要更快的速度。
- en: Solution
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use FastR, Oracle’s GraalVM reimplementation of the R language.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 FastR，Oracle 的 GraalVM 重新实现的 R 语言。
- en: Discussion
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Assuming you have installed GraalVM as described in [Recipe 1.2](ch01.html#jcb-getstarted-graal),
    you can just type the following command:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您已经按照[第 1.2 节的描述](ch01.html#jcb-getstarted-graal)安装了 GraalVM，您可以直接输入以下命令：
- en: '[PRE13]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you have set your `PATH` to have GraalVM before other directories, the command
    *R* will now give you the GraalVM version of R. To access the standard R, you
    will have to either set your `PATH` or give a full path to the R installation.
    On all Unix and Unix-like systems, the command *which R* will reveal all R commands
    on your `PATH`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已将 `PATH` 设置为在其他目录之前使用 GraalVM，那么命令 *R* 现在将给出 GraalVM 版本的 R。要访问标准的 R，您将需要设置您的
    `PATH` 或者给出 R 安装的完整路径。在所有 Unix 和类 Unix 系统上，命令 *which R* 将显示您的 `PATH` 上的所有 R 命令：
- en: '[PRE14]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let’s just run it:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来运行它：
- en: '[PRE15]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: From that point on, you should be able to do practically anything that you would
    do in standard R, since this R’s source code is largely derived from the R Foundation’s
    source.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 从那时起，您应该能够做几乎任何在标准 R 中做的事情，因为此 R 的源代码大部分来自 R 基金会的源代码。
- en: 11.8 Using R in a Web App
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11.8 在 Web 应用程序中使用 R
- en: Problem
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to display R’s data and graphics in a web page on a web server.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望在 Web 服务器上的网页中显示 R 的数据和图形。
- en: Solution
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'There are several approaches that would achieve this effect:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以实现这个效果：
- en: Prepare the data, generate graphics as we did in [Recipe 11.3](#javacook-ds-r-interact),
    and then incorporate both into a static web page.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备数据，生成图形，就像我们在[第 11.3 节的示例](#javacook-ds-r-interact)中所做的那样，然后将它们都整合到静态网页中。
- en: Use one of [several R add-on web frameworks](https://cran.r-project.org/web/views/WebTechnologies.html#web-and-server-frameworks),
    such as [shiny](https://cran.r-project.org/web/packages/shiny/index.html) or [Rook](https://cran.r-project.org/web/packages/Rook/index.html).
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多种[R 的附加 Web 框架](https://cran.r-project.org/web/views/WebTechnologies.html#web-and-server-frameworks)，如
    [shiny](https://cran.r-project.org/web/packages/shiny/index.html) 或 [Rook](https://cran.r-project.org/web/packages/Rook/index.html)。
- en: Invoke a JVM implementation of R from within a Servlet, JSF, Spring Bean, or
    other web-tier component.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Servlet、JSF、Spring Bean 或其他 Web 层组件中调用 R 的 JVM 实现。
- en: Discussion
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The first approach is trivial, and doesn’t need discussion here.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法很简单，这里不需要讨论。
- en: 'For the second, I’ll actually use `timevis`, which in turn uses `shiny`. This
    isn’t built in to the R library, so we first have to install it, using R’s `install.packages()`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二种方法，我实际上会使用 `timevis`，它反过来使用 `shiny`。这并未内置到 R 库中，因此我们首先需要使用 R 的 `install.packages()`
    安装它：
- en: '[PRE16]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This may take a while as it downloads and builds multiple dependencies.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能需要一些时间，因为它会下载并构建多个依赖项。
- en: 'For this demo I have a small dataset with some basic information on medieval
    literature, which I load and display using `shiny`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个演示，我有一个包含一些关于中世纪文学基本信息的小数据集，我使用`shiny`加载和显示：
- en: '[PRE17]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When run, this creates a temporary file containing HTML and JavaScript to allow
    interactive exploration of the data. The library also opens this in a browser,
    shown in [Figure 11-2](#javacook-ds-FIG-timevis). One can explore the data by
    expanding or contracting the timeline and scrolling sideways.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时，这会创建一个包含HTML和JavaScript的临时文件，以允许对数据进行交互式探索。该库还会在浏览器中打开此文件，显示在[图11-2](#javacook-ds-FIG-timevis)中。用户可以通过展开或收缩时间线并横向滚动来探索数据。
- en: '![jcb4 1102](assets/jcb4_1102.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![jcb4 1102](assets/jcb4_1102.png)'
- en: Figure 11-2\. TimeVis (shiny) in action
  id: totrans-163
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11-2\. TimeVis（shiny）的操作
- en: Where there are two boxes (Cid, Sagas), the first is when the life or stories
    took place, and the second is when they were written down.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当存在两个框（Cid，Sagas）时，第一个是生活或故事发生的时间，第二个是它们被书写的时间。
- en: To expose this on the public web, copy the file (whose full path is revealed
    in the browser titlebar) and the *lib* folder in that same directory into a directory
    served by the web server. Or just use File→Save As→Complete Web Page within the
    browser. Either way, you must do this while the R session is running, as the temporary
    files are deleted when the session ends. Or, if you are familiar with the `shiny`
    framework, you can insert the `timevis` visualization into a `shiny` application.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要将其暴露在公共网络上，请复制文件（完整路径显示在浏览器标题栏中）和*lib*文件夹放入同一目录，并将该目录服务于Web服务器。或者直接使用文件→另存为→完整网页，在浏览器中执行。无论哪种方式，您都必须在R会话运行时执行此操作，因为会话结束时会删除临时文件。或者，如果您熟悉`shiny`框架，可以将`timevis`可视化插入到`shiny`应用程序中。
- en: ^([1](ch11.html#idm45290648185096-marker)) *Map/Reduce* is a famous algorithm
    pioneered by Google to handle large data problems. An unspecified number of generators
    process *map* data—such as words on a web page or the page’s URL—and a single
    (usually) reduce process reduces the maps to a manageable form, such as a list
    of all the pages that contain the given words. Early on, data science went overboard
    on trying to do everything with Map/Reduce; now the pendulum has swung back to
    using compute engines like Spark.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch11.html#idm45290648185096-marker)) *Map/Reduce*是由Google开发的处理大数据问题的著名算法。未指定数量的生成器处理*map*数据，如网页上的单词或页面的URL，单个（通常）reduce进程将这些映射减少为可管理的形式，例如包含给定单词的所有页面的列表。早期，数据科学试图通过Map/Reduce做所有事情；现在，风向标已经回到使用像Spark这样的计算引擎。
- en: ^([2](ch11.html#idm45290648114600-marker)) DataBricks offers several free ebooks
    on Spark from their website; it also offers commercial Spark add-ons.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch11.html#idm45290648114600-marker)) DataBricks在其网站上提供了几本关于Spark的免费电子书；它还提供商业Spark附加组件。
