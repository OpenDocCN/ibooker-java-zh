- en: Appendix B. Exercise Answers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录 B. 练习答案
- en: This appendix contains answers (and usually a bit of context) for the review
    questions at the end of each chapter. The code exercise answers are included with
    the source download for the example programs, in the *exercises* folder. [Appendix A](app01.html#learnjava6-APP-A)
    has details on obtaining the source and setting it up inside IntelliJ IDEA.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录包含每章末尾的复习问题答案（通常还包含一些背景信息）。代码练习的答案随附示例程序的源码下载，存储在 *exercises* 文件夹中。[附录 A](app01.html#learnjava6-APP-A)
    中详细介绍了获取源码并在 IntelliJ IDEA 中设置的方法。
- en: 'Chapter 1: A Modern Language'
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章：现代语言
- en: Which company currently maintains Java?
  id: totrans-3
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪家公司当前维护 Java？
- en: While Java was developed in the 1990s at Sun Microsystems, Oracle purchased
    Sun (and thus Java) in 2009\. Oracle maintains ownership and is an active partner
    in the development and distribution of its own commercial JDK and the open source
    OpenJDK.
  id: totrans-4
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尽管 Java 是在 1990 年代由 Sun Microsystems 开发的，但 Oracle 在 2009 年购买了 Sun（因此也购买了 Java）。Oracle
    拥有并积极参与其商业 JDK 和开源 OpenJDK 的开发和分发。
- en: What is the name of the open source development kit for Java?
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java 的开源开发工具包的名称是什么？
- en: The open source version of the JDK is known as the OpenJDK.
  id: totrans-6
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: JDK 的开源版本被称为 OpenJDK。
- en: Name the two main components that play a role in Java’s approach to securely
    running bytecode.
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 名称 Java 安全运行字节码的两个主要组件。
- en: Java has many features that relate to security, but the main components at play
    in every Java application are the class loader and the bytecode verifier.
  id: totrans-8
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Java 具有许多与安全相关的特性，但在每个 Java 应用程序中起作用的主要组件是类加载器和字节码验证器。
- en: 'Chapter 2: A First Application'
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章：首个应用程序
- en: What command should you use to compile a Java source file?
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该使用什么命令来编译 Java 源文件？
- en: If you are working in a terminal, the *javac* command compiles Java source files.
    While the details are often hidden when using an IDE like IntelliJ IDEA, the IDE
    is also using *javac* behind the scenes.
  id: totrans-11
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您在终端中工作，*javac* 命令会编译 Java 源文件。虽然在使用像 IntelliJ IDEA 这样的 IDE 时，细节通常被隐藏，但是这些
    IDE 在幕后也使用 *javac*。
- en: How does the JVM know where to start when you run a Java application?
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您运行 Java 应用程序时，JVM 如何知道从哪里开始？
- en: Any executable Java class must have a `main()` method defined. The JVM uses
    this method as the entry point.
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 任何可执行的 Java 类必须定义 `main()` 方法。JVM 使用此方法作为入口点。
- en: Can you extend more than one class when creating a new class?
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建新类时，您可以扩展多个类吗？
- en: No. Java does not support direct multiple inheritance from multiple, separate
    classes.
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不。Java 不支持从多个单独的类直接进行多重继承。
- en: Can you implement more than one interface when creating a new class?
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建新类时，您可以实现多个接口吗？
- en: Yes. Java allows you to implement as many interfaces as needed. Using interfaces
    provides programmers with most of the useful features of multiple inheritance
    without many of the pitfalls.
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 是的。Java 允许您实现尽可能多的接口。使用接口为程序员提供了多重继承的大部分有用功能，而避开了许多陷阱。
- en: Which class represents the window in a graphical application?
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个类代表图形应用程序中的窗口？
- en: The `JFrame` class represents the main window used in Java graphical applications,
    although later chapters will introduce you to some lower-level classes that can
    also create specialized windows.
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`JFrame` 类代表 Java 图形应用程序中使用的主窗口，尽管后续章节将介绍一些也能创建特定窗口的低级类。'
- en: Code Exercises
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码练习
- en: 'We won’t generally list the code solutions in this appendix, but we want to
    make it easy to check your solution for this first program. The simple text version
    of “Goodbye, Java!” should look something like this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一般情况下，我们不会在本附录中列出代码解决方案，但我们希望可以轻松地检查您对这个第一个程序的解决方案。简单文本版的“Goodbye, Java!” 应该看起来类似于这样：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For the graphical version, your code should look similar to this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于图形版本，您的代码应该类似于这样：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Note that we added the extra `EXIT_ON_CLOSE` that we introduced in `HelloJava2`
    so that the app will quit correctly when you close it. If you are using IDEA,
    you can run either class using the green Play button right inside the IDE. If
    you are using a terminal, you can change to the directory where *GoodbyeJava.java*
    is located and type the following commands:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们添加了额外的 `EXIT_ON_CLOSE`，这是在 `HelloJava2` 中引入的，以便在关闭应用程序时正确退出。如果您使用 IDEA，可以使用
    IDE 内部的绿色播放按钮运行任何一个类。如果您使用终端，可以切换到 *GoodbyeJava.java* 所在的目录并输入以下命令：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Chapter 3: Tools of the Trade'
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章：工具
- en: What statement gives you access to the Swing components in you application?
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个语句允许您在应用程序中访问 Swing 组件？
- en: The `import` statement loads information the compiler needs from the specified
    class or package. For Swing components, you typically import the entire package
    with `import javax.swing.*;`.
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`import` 语句从指定的类或包加载编译器需要的信息。对于 Swing 组件，您通常使用 `import javax.swing.*;` 导入整个包。'
- en: What environment variable determines where Java will look for class files when
    compiling or executing?
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么环境变量确定 Java 在编译或执行时查找类文件的位置？
- en: The `CLASSPATH` environment variable holds a list of directories containing
    the other classes or JAR files available for both compilation and execution. If
    you are using an IDE, the `CLASSPATH` is still defined, but it is not something
    you typically edit yourself.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`CLASSPATH` 环境变量保存了一个包含其他类或 JAR 文件的目录列表，这些文件可用于编译和执行。如果您使用的是 IDE，`CLASSPATH`
    仍然被定义，但通常不需要您自己编辑。'
- en: What options can you use to look at the contents of a JAR file without unpacking
    it?
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用哪些选项查看 JAR 文件的内容而不解压缩它？
- en: 'You can run the following command to show the contents of a JAR file without
    actually unpacking it into the current directory:'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以运行以下命令来显示 JAR 文件的内容，而不实际将其解压到当前目录：
- en: '[PRE3]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `tvf` flags represent the table of contents (`t`), verbose (`v`), and file
    (`f` followed by a filename).
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`tvf` 标志代表目录（`t`）、详细信息（`v`）和文件（`f` 后跟文件名）的表格。'
- en: What entry is required in the *MANIFEST.MF* file to make a JAR file executable?
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使 JAR 文件可执行所需的 *MANIFEST.MF* 文件条目是什么？
- en: You must include an entry for `Main-Class` that gives the fully qualified name
    of a class with a valid `main()` method to make a given JAR file executable.
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您必须包含一个 `Main-Class` 条目，该条目给出具有有效 `main()` 方法的类的完全限定名称，以使给定的 JAR 文件可执行。
- en: What tool allows you to try out Java code interactively?
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么工具允许您交互式地尝试 Java 代码？
- en: You can run *jshell* from a terminal to try simple Java code interactively.
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以从终端运行 *jshell* 来交互式地尝试简单的 Java 代码。
- en: Code Exercises
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码练习
- en: You will find our solutions to the code exercises in the *ch03/solutions* folder.
    ([Appendix A](app01.html#learnjava6-APP-A) has details on downloading the examples.)
    Our solutions are not the only—or even best—way to solve these problems. We try
    to present clean, maintainable code that follows best practices, but there are
    always other ways to approach a coding problem. Hopefully you are able to write
    and run your own answers, but here are a few hints if you are stuck.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在 *ch03/solutions* 文件夹中找到我们对代码练习的解决方案。([附录 A](app01.html#learnjava6-APP-A)
    中有关于下载示例的详细信息。) 我们的解决方案并不是解决这些问题的唯一或者最佳方式。我们尝试呈现整洁、可维护的代码，并遵循最佳实践，但解决编码问题还有其他方法。希望您能够编写和运行自己的答案，但如果遇到困难，这里有一些提示。
- en: To make the executable *hello.jar* file, we’ll do all of our work in the *ch03/exercises*
    folder in a terminal. (You can certainly do this type of work [inside IDEA](https://oreil.ly/l0akz)
    as well.) Go ahead and open a terminal and change into that folder.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建可执行的 *hello.jar* 文件，我们将在 *ch03/exercises* 文件夹中的终端中进行所有工作。（您当然也可以在[IDEA 中进行](https://oreil.ly/l0akz)此类工作。）请打开终端并切换到该文件夹。
- en: 'Before we create the JAR file itself, we need to edit the *manifest.mf* file.
    Add the `Main-Class` entry. The final file should look something like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 JAR 文件本身之前，我们需要编辑 *manifest.mf* 文件。添加 `Main-Class` 条目。最终文件应如下所示：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now you can create and test your JAR file with the following commands:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用以下命令创建和测试您的 JAR 文件：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Recall that the `m` element in the flags is necessary to include our manifest.
    It’s also worth a reminder that the order of the `m` and `f` flags determines
    the order of the *manifest.mf* and *hello.jar* command-line arguments that follow.
    Do you remember how to look at the contents of your newly created JAR to verify
    the manifest is there?^([1](app02.html#id2590))
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，标志中的 `m` 元素是必要的，以包含我们的清单。还值得提醒的是，`m` 和 `f` 标志的顺序决定了随后跟随的 *manifest.mf* 和
    *hello.jar* 命令行参数的顺序。您还记得如何查看您新创建的 JAR 的内容以验证清单是否存在吗？^([1](app02.html#id2590))
- en: 'Chapter 4: The Java Language'
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章：Java 语言
- en: What text encoding format does JAVA use by default by Java in compiled classes?
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java 在编译类时默认使用什么文本编码格式？
- en: By default, Java uses the 8-bit Unicode Transformation Format (UTF-8) encoding.
    The 8-bit (or one byte) encoding can accommodate single and multibyte characters.
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 默认情况下，Java 使用 8 位 Unicode 转换格式（UTF-8）编码。8 位（或一个字节）编码可以容纳单字节和多字节字符。
- en: What characters are used to enclose a multiline comment? Can those comments
    be nested?
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于包围多行注释的字符是什么？这些注释可以嵌套吗？
- en: Java borrows from C and C++ for its comment syntax. Single-line comments begin
    with two slashes (`//`), while multiline comments are enclosed in `/*` and `*/`
    pairs. The multiline style can also be used to embed small comments in the middle
    of a line of code.
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Java借鉴了C和C++的注释语法。单行注释以双斜杠（`//`）开头，而多行注释则用`/*`和`*/`括起来。多行样式也可以用于在代码行中嵌入小注释。
- en: Which looping constructs does Java support?
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java支持哪些循环结构？
- en: Java supports the `for` loop (both traditional C-style, and an enhanced form
    for iterating over collections), the `while` loop, and the `do/while` loop.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Java支持`for`循环（传统的C风格和用于遍历集合的增强形式）、`while`循环和`do/while`循环。
- en: In a chain of `if/else if/else` tests, what happens if multiple conditions are
    true?
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`if/else if/else`测试链中，如果多个条件都为真会发生什么？
- en: The block associated with the first test that evaluates to `true` will be executed.
    After that block completes, control resumes after the entire chain—regardless
    of how many other tests would have also returned `true`.
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与第一个评估为`true`的测试相关联的块将被执行。在该块完成后，控制将在整个链路后继续执行——无论有多少其他测试也会返回`true`。
- en: If you wanted to store the US stock market’s total capitalization (roughly $31
    trillion at the close of fiscal year 2022) as whole dollars, what primitive data
    type could you use?
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想要将美国股市的总市值（大约在2022财年结束时为31万亿美元）存储为整数，你可以使用什么原始数据类型？
- en: You could use the `long` integer type; it can store numbers up to 9 quintillion
    (positive or negative). While you could also use the `double` type, as the numbers
    get larger, their precision falls off. And since “whole dollars” implies no fractions,
    an integer type makes more sense.
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以使用`long`整型；它可以存储高达9千亿（正负数皆可）的数字。虽然你也可以使用`double`类型，但随着数字变大，精度会降低。而且，“整数”意味着没有小数部分，整数类型更为合理。
- en: What does the expression `18 – 7 * 2` evaluate to?
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 表达式`18 – 7 * 2`的计算结果是什么？
- en: This is an order-of-precedence question to make sure your high school algebra
    teacher finally gets some credit after all those “but when will I ever use this?”
    queries. The multiplication of 7 and 2 will occur first, then the subtraction.
    The final answer is 4\. (You might have come up with 22, which results from performing
    the operations from left to right. If you actually want that result, you could
    enclose the `18 – 7` portion inside parentheses…​just like this aside.)
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个优先级问题，以确保你的高中代数老师最终得到了一些肯定，经历了所有那些“但我什么时候会用到这个？”的质疑。首先进行7和2的乘法运算，然后进行减法运算。最终答案是4。（你可能得到了22，这是从左到右执行操作的结果。如果你确实需要那个结果，你可以将`18
    – 7`部分用括号括起来……就像这个旁注一样。）
- en: How would you create an array holding the names of the days of the week?
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何创建一个包含一周的天数名称的数组？
- en: 'You can create and initialize an array using curly braces. For the days of
    the week, we need an array of `String`s, like this:'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以使用花括号创建和初始化数组。对于一周的天数，我们需要一个`String`数组，就像这样：
- en: '[PRE6]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The spacing around the names in the list is optional. You can list everything
    on one line, list each name on its own line, or some combination as we did here.
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 列表中名称的间距是可选的。你可以将所有内容列在一行上，将每个名称列在单独的行上，或者像我们在这里做的那样，采用一些组合。
- en: Code Exercises
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码练习
- en: There are a number of ways to print the original `a` and `b` to the screen along
    with the calculated greatest common denominator. You could use a `print()` statement
    (*not* `println()`) before you begin calculating, and then use a `println()` with
    the answer to finish the output. Or you could store a copy of `a` and `b` in a
    second set of variables before beginning the calculation. After you find the answer,
    you can print the copied values along with the result.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有多种方法可以将原始的`a`和`b`以及计算得到的最大公约数打印到屏幕上。你可以在开始计算之前使用`print()`语句（*而不是* `println()`），然后在计算结束时使用`println()`打印答案。或者你可以在开始计算之前将`a`和`b`复制到第二组变量中。找到答案后，你可以打印出复制的值以及结果。
- en: 'To output the triangular data in a simple row, you can use the same nested
    loops that you use to fill the triangle:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要以简单的行形式输出三角形数据，可以使用填充三角形的相同嵌套循环：
- en: '[PRE7]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Advanced Exercises
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级练习
- en: To present your output in a visual triangle, use a `print()` statement inside
    the inner `j` loop. (Be sure to print a space after each number as well.) After
    the inner loop finishes, you can use an empty `println()` to terminate the line
    and be ready for the next row.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在视觉三角形中呈现输出，可以在内部`j`循环中使用`print()`语句。（确保在每个数字后打印一个空格。）内部循环完成后，可以使用空的`println()`来结束该行并准备下一行。
- en: 'Chapter 5: Objects in Java'
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章：Java 中的对象
- en: What is the primary organizing unit in Java?
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java 中的主要组织单元是什么？
- en: The main “unit” in Java is a class. Many other structures play important roles,
    of course, but you can’t use any of those other things without at least one class.
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Java 中的主要“单元”是一个类。当然，许多其他结构也起着重要作用，但是你至少需要一个类才能使用其他任何东西。
- en: What operator do you use to create an object (or instance) from a class?
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你使用什么运算符来从类创建一个对象（或实例）？
- en: The `new` operator instantiates an object from a class and calls the appropriate
    constructor.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`new` 操作符实例化一个类的对象并调用适当的构造函数。'
- en: Java does not support classic multiple inheritance. What mechanisms does Java
    provide as alternatives?
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java 不支持经典的多重继承。Java 提供哪些机制作为替代？
- en: Java uses interfaces to accomplish most of the goals of multiple inheritance
    found in many other object-oriented languages.
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Java 使用接口来完成许多其他面向对象语言中多重继承的目标。
- en: How can you organize multiple related classes?
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何组织多个相关的类？
- en: You place related classes in a package. In your filesystem, a package appears
    as nested folders. In your code, packages use dot-separated names.
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将相关的类放在一个包中。在你的文件系统中，包显示为嵌套文件夹。在你的代码中，包使用点分隔的名称。
- en: How do you include classes from other packages for use in your own code?
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何将其他包中的类包含到你自己的代码中以供使用？
- en: You can `import` other individual classes or entire packages for your own use.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以 `import` 其他单独的类或整个包供你自己使用。
- en: What do you call a class defined inside the scope of another class? What are
    some features that make such a class useful in some circumstances?
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何称呼定义在另一个类范围内的类？在某些情况下，使这样的类变得有用的一些特性是什么？
- en: A simple class defined within the curly braces of another class (not just in
    the same file) is called an inner class. Inner classes have access to all the
    variables and methods of the outer class—including private members. They can be
    used to help break up your code into manageable and reusable pieces while providing
    good control over who else can use them.
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在另一个类的大括号内部（不仅仅在同一个文件中）定义的简单类称为内部类。内部类具有对外部类的所有变量和方法的访问权限，包括私有成员。它们可以帮助将代码分割成可管理和可重用的片段，同时提供对谁可以使用它们的良好控制。
- en: What do you call a method designed to be overridden that has a name, return
    type, and argument list, but no body?
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何称呼旨在被重写的方法，它具有名称、返回类型和参数列表，但没有主体？
- en: Methods defined with only their signatures are known as abstract methods. Including
    an abstract method in a class makes the class abstract as well. The abstract class
    cannot be instantiated. You must create a subclass and then provide a real body
    for the abstract method to use it.
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 只有它们的签名定义的方法称为抽象方法。在类中包含抽象方法也使得该类成为抽象类。抽象类不能被实例化。你必须创建一个子类，然后为抽象方法提供一个真实的体来使用它。
- en: What is an overloaded method?
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是重载方法？
- en: Java allows you to use the same method name with different types or numbers
    of arguments. If two methods share the same name, they are said to be overloaded.
    Overloading makes it possible to create a batch of methods that do the same logical
    work on disparate arguments. The classic example of an overloaded method in Java
    is `System.out.println()` which can take several different types of arguments
    and convert them all to strings for printing to a terminal.
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Java 允许你使用相同的方法名以不同类型或数量的参数。如果两个方法共享相同的名称，它们被称为重载。重载使得在不同参数上执行相同逻辑工作的方法批量创建成为可能。Java
    中重载方法的经典示例是 `System.out.println()`，它可以接受多种类型的参数并将它们全部转换为字符串以打印到终端。
- en: If you want to make sure no other class can use a variable you have defined,
    what access modifier should you use?
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你希望确保没有其他类可以使用你定义的变量，你应该使用什么访问修饰符？
- en: The `private` access modifier for a variable (or a method, or indeed an entire
    inner class) restricts its use to the class where it is defined.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`private` 访问修饰符用于变量（或方法，或者整个内部类），将其使用限制在它定义的类中。'
- en: Code Exercises
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码练习
- en: For the first problem in our `Zoo`, you just need to add a `print()` statement
    to the empty `speak()` method in the inner `Gibbon` class. Hopefully the `Lion`
    example is straightforward to follow.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的 `Zoo` 中的第一个问题，你只需在内部 `Gibbon` 类的空 `speak()` 方法中添加一个 `print()` 语句。希望 `Lion`
    的示例容易跟随。
- en: Adding another animal should also be straightforward; you can copy the entire
    `Lion` class. Rename the class and print an appropriate noise in the `speak()`
    method. You’ll also need to replicate a few lines in the `listen()` method so
    that your animal’s sound is added to the output.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加另一个动物也应该很简单；你可以复制整个`Lion`类。重命名类并在`speak()`方法中打印适当的声音。你还需要复制`listen()`方法中的几行代码，以便将你的动物声音添加到输出中。
- en: To refactor the `listen()` method, we noted that the output for each animal
    is very similar, but the name of the animal obviously changes for each animal.
    If we move that name into the animals’ respective classes, we can create a loop
    whose body prints out the details (name and noise) for one animal. Then we iterate
    over our array of animals. If you make another animal, you only have to add an
    instance of your new inner class to the array.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了重构`listen()`方法，我们注意到每个动物的输出非常相似，但显然每个动物的名称都会改变。如果我们将这个名称移到动物各自的类中，我们就可以创建一个循环，其主体打印出一个动物的细节（名称和声音）。然后我们迭代我们的动物数组。如果你再创建另一个动物，你只需要将你的新内部类的实例添加到数组中。
- en: 'The `AppleToss` class for this exercise is part of the `exercises.ch05` package.
    (The *game* folder contains the completed game, with all the features we’ll be
    building throughout the book. The classes in that folder are part of the `game`
    package. You’re welcome to compile and run that version, but it has several features
    we haven’t discussed yet.) To compile the game from a terminal, you can either
    change into the *ch05/exercises* directory and compile the Java classes there,
    or stay in the top-level folder where you unpacked the source code and give the
    path when compiling:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此练习的`AppleToss`类是`exercises.ch05`包的一部分。（*game*文件夹包含了已完成的游戏，其中包含了我们将在本书中构建的所有功能。该文件夹中的类属于`game`包。您可以编译和运行该版本，但它有一些我们尚未讨论的功能。）要从终端编译游戏，你可以进入*ch05/exercises*目录并在那里编译Java类，或者留在你解压源代码的顶层文件夹中，并在编译时给出路径：
- en: '[PRE8]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To run the game, you need to be in that top-level folder. From there, you can
    run the `exercises.ch05.AppleToss` class with the *java* command.
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要运行游戏，你需要在顶层文件夹中。从那里，你可以使用*java*命令运行`exercises.ch05.AppleToss`类。
- en: Advanced Exercises
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级练习
- en: Hopefully, adding a `Hedge` feels straightforward. You can start with a copy
    of the `Tree` class. Rename the file *Hedge.java*. Edit the class to reflect our
    new `Hedge` obstacle and update its `paintComponent()` method. Inside the `Field`
    class, you’ll need to add a member variable for the `Hedge`. Create a `setupHedge()`
    method similar to `setupTree()` and be sure to include your hedge in the `paintComponent()`
    method of `Field`.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 希望添加一个`Hedge`看起来很简单。你可以从`Tree`类的副本开始。将文件重命名为*Hedge.java*。编辑类以反映我们的新`Hedge`障碍，并更新其`paintComponent()`方法。在`Field`类内部，你需要为`Hedge`添加一个成员变量。创建一个类似于`setupTree()`的`setupHedge()`方法，并确保在`Field`的`paintComponent()`方法中包含你的树篱。
- en: Last, but certainly not least, update the `setupFieldForOnePlayer()` method
    to call our `setupHedge()` method. Compile and run the game just like you did
    in the previous exercise. Your new hedge(s) should appear!
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，但肯定不是最不重要的，更新`setupFieldForOnePlayer()`方法以调用我们的`setupHedge()`方法。编译并运行游戏，就像你在前面的练习中做的那样。你的新树篱应该会出现！
- en: 'Chapter 6: Error Handling'
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章：错误处理
- en: What statement do you use to manage potential exceptions in your code?
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的代码中，你使用什么语句来处理潜在的异常？
- en: You can use a `try/catch` block around any statement or group of statements
    that might generate an exception.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在可能生成异常的任何语句或语句组周围使用`try/catch`块。
- en: Which exceptions does the compiler require you to handle or throw?
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译器要求你处理或抛出哪些异常？
- en: In Java, the term *checked exception* refers to a category of exceptions that
    the compiler understands and requires the programmer to acknowledge. You can use
    a `try/catch` block within a method where checked exceptions might occur, or you
    can add the exception to the method’s `throws` clause in its signature.
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在Java中，术语*checked exception*指的是编译器理解并要求程序员承认的异常类别。你可以在可能发生checked exceptions的方法中使用`try/catch`块，或者你可以在方法的签名中的`throws`子句中添加异常。
- en: Where do you place any “clean-up” code that you always want to run after using
    some resources in a `try` block?
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`try`块中使用完资源后，你会把任何“清理”代码放在哪里？
- en: The `finally` clause will run at the end of a `try` block regardless of what
    happens. If there are no problems, the code in the `finally` clause runs. If there
    is an exception and a `catch` block handles it, `finally` still runs. If an exception
    occurs that is not handled, the `finally` clause still runs before control is
    transferred back to the calling method.
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`finally`子句将在`try`块结束时无论发生什么都会运行。如果没有问题，`finally`子句中的代码将运行。如果有异常并且`catch`块处理了它，`finally`仍然会运行。如果发生未处理的异常，`finally`子句在控制转移回调用方法之前仍会运行。'
- en: Do assertions have much of a performance penalty when they are disabled?
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 禁用断言会对性能造成很大的惩罚吗？
- en: No. This is by design. Assertions are meant to be used more during development
    or debugging. When you turn them off, they are skipped. Even in a production application,
    though, you might leave assertions in your code. If a user reports a problem,
    assertions could be turned on temporarily to allow your user to collect any output
    and help you find the cause.
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不是的。这是设计如此。断言通常更多用于开发或调试。当你关闭它们时，它们会被跳过。即使在生产应用中，你可能也会在代码中保留断言。如果用户报告了问题，可以临时打开断言以允许用户收集任何输出并帮助你找到原因。
- en: Code Exercises
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码练习
- en: To get the *Pause.java* file to compile, you need to add a `try/catch` block
    around the call to `Thread.sleep()`. For this simple exercise, you only need to
    encapsulate the `Thread.sleep()` line.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使*Pause.java*文件编译通过，你需要在调用`Thread.sleep()`周围添加一个`try/catch`块。对于这个简单的练习，你只需要封装`Thread.sleep()`行。
- en: 'The assertions statements we need will have the following form:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要的断言语句将具有以下形式：
- en: '[PRE9]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The bigger question is: where should we place them? We only need to check the
    starting position of our message, so we don’t want the assertions inside the `paintComponent()`
    method. A better place would be in the `HelloComponent0()` constructor, perhaps
    right after we store the supplied `message` argument.'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更重要的问题是：我们应该把它们放在哪里？我们只需要检查消息的起始位置，所以我们不希望断言在`paintComponent()`方法内部。更好的地方可能是在`HelloComponent0()`构造函数中，在我们存储提供的`message`参数之后。
- en: To test the assertions, you’ll need to edit the source file to change the `x`
    or `y` values and recompile.
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要测试断言，你需要编辑源文件以更改`x`或`y`的值并重新编译。
- en: Advanced Exercises
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级练习
- en: 'Your `GCDException` class will probably look something like this:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的`GCDException`类可能看起来像这样：
- en: '[PRE10]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can test the result of your GCD calculation with a simple `if` statement.
    If the result is 1, you can throw your new `GCDException` with our original `a`
    and `b` as arguments to its constructor, like this:'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以用一个简单的`if`语句测试你的GCD计算结果。如果结果是1，你可以使用我们原来的`a`和`b`作为参数调用你的新`GCDException`构造函数，像这样：
- en: '[PRE11]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Chapter 7: Collections and Generics'
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章：集合和泛型
- en: If you want to store a contact list with names and phone numbers, which kind
    of collection would work best?
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想存储一个包含姓名和电话号码的联系人列表，哪种集合类型最适合？
- en: A `Map` would do the trick. The keys could be simple strings containing the
    contact’s name, and the values could be a simple (though wrapped) long number.
    Or you could create a `Person` class and a `PhoneNumber` class, and the map could
    use your custom classes.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Map`是个好办法。键可以是简单的字符串，包含联系人的姓名，值可以是一个简单（尽管包装过的）长数字。或者你可以创建一个`Person`类和一个`PhoneNumber`类，然后地图可以使用你的自定义类。'
- en: What method do you use to get an iterator for the items in a `Set`?
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你用什么方法为`Set`中的项目获取迭代器？
- en: The imaginatively named `iterator()` method from the `Collection` interface
    will get your iterator.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Collection`接口中富有创意的`iterator()`方法将为你获取迭代器。'
- en: How can you turn a `List` into an array?
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何将`List`转换为数组？
- en: You can use the `toArray()` method to turn a `List` into either an array of
    type `Object` or an array of the list’s parameterized type.
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以使用`toArray()`方法将`List`转换为`Object`类型的数组或列表的参数化类型的数组。
- en: How can you turn an array into a `List`?
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何将数组转换为`List`？
- en: The `Arrays` helper class includes the handy `asList()` method that accepts
    an array and returns a parameterized list of the same type.
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Arrays`辅助类包括方便的`asList()`方法，接受一个数组并返回相同类型的参数化列表。'
- en: What interface should you implement to sort a list using the `Collections.sort()`
    method?
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用`Collections.sort()`方法对列表进行排序，你应该实现什么接口？
- en: While there are many ways to sort collections, a list of `Comparable` objects
    (meaning objects whose class implements the `Comparable` interface) can use the
    standard `sort()` method provided by the `Collections` helper class.
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尽管有许多方法可以对集合进行排序，但`Comparable`对象列表（表示其类实现了`Comparable`接口的对象）可以使用`Collections`辅助类提供的标准`sort()`方法。
- en: Code Exercises
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码练习
- en: 'As we mentioned in this chapter, you can’t directly sort a simple map in the
    same way you can sort a list or array. Even `Set`s are not typically sortable.^([2](app02.html#id2591))
    You can sort a list, though, so using the `keySet()` method to fill a list should
    give you what you need:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如我们在本章中提到的，您不能像对列表或数组进行排序一样直接对简单映射进行排序。甚至`Set`通常也不可排序。^([2](app02.html#id2591))不过，您可以对列表进行排序，因此使用`keySet()`方法填充列表应该可以满足您的需求：
- en: '[PRE12]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Hopefully, the expansion to support multiple hedges feels straightforward to
    you. We mostly just duplicate any code we already have for the trees. And using
    `List`s allows us to use the enhanced `for` loop to quickly run through all of
    our hedges:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 希望你对于支持多种对冲的扩展感觉很直观。我们主要是复制已有的树代码。使用`List`允许我们使用增强的`for`循环快速遍历所有对冲：
- en: '[PRE13]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Advanced Exercises
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级练习
- en: 'You can use the `values()` output to create and sort a list similar to the
    solution for Code Exercise 1\. The interesting part of this exercise is implementing
    the `Comparable` interface with the `Employee` class. (Actually, in the *ch07/solutions*
    folder, the sortable employee class is `Employee2`. We wanted to leave the original
    `Employee` class as a valid solution to the first exercise.) Here’s an example
    of doing string comparisons, using the employees’ names:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用`values()`输出创建并排序类似于代码练习1解决方案的列表。这个练习的有趣部分是使用`Employee`类实现`Comparable`接口。（实际上，在*ch07/solutions*文件夹中，可排序的员工类是`Employee2`。我们希望将原始的`Employee`类保留为第一个练习的有效解决方案。）这是一个使用员工姓名进行字符串比较的示例：
- en: '[PRE14]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Of course, you could perform other comparisons using the other `Employee` attributes.
    Try playing around with some other orderings and see if you get the results you
    expect. And if you want to dig even deeper, take a look at the `java.util.TreeMap`
    class as a way to store your employees in a sorted manner without needing the
    list-conversion detour.
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当然，您可以使用其他`Employee`属性进行其他比较。尝试玩弄一些其他排序，并查看是否得到您预期的结果。如果想进一步深入，请查看`java.util.TreeMap`类，以一种无需列表转换的方式将员工存储为排序方式。
- en: 'Chapter 8: Text and Core Utilities'
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章：文本和核心工具
- en: Which class contains the constant π? Do you need to import that class to use
    π?
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个类包含常量π？需要导入该类来使用π吗？
- en: The `java.lang.Math` class contains the constant `PI`. All of the classes in
    the `java.lang` package are imported by default; no explicit `import` is required
    to use them.
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`java.lang.Math`类包含常量`PI`。`java.lang`包中的所有类都会默认导入；使用它们无需显式`import`。'
- en: Which package contains newer, better replacements for the original `java.util.Date`
    class?
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个包含原始`java.util.Date`类的新的、更好的替代品？
- en: The `java.time` package contains a wide variety of quality classes for handling
    dates, times, timestamps (or “instants” consisting of both a date and a time),
    and time spans or durations.
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`java.time`包包含各种质量类，用于处理日期、时间、时间戳（或由日期和时间组成的“时刻”）以及时间跨度或持续时间。'
- en: Which class do you use to format a date for user-friendly output?
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你使用哪个类来为用户友好输出格式化日期？
- en: The `DateFormat` class in the `java.text` package has a marvelously flexible
    (if occasionally opaque) formatting engine for rendering both dates and times.
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`java.text`包中的`DateFormat`类具有非常灵活（有时不透明）的格式化引擎，用于呈现日期和时间。'
- en: What symbol do you use in a regular expression to help match the words “yes”
    and “yup”?
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正则表达式中使用什么符号来帮助匹配单词“yes”和“yup”？
- en: You can use the alternation operator, `|` (vertical pipe), to create an expression
    such as `yes|yup` for use as a pattern.
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以使用交替运算符`|`（竖线）创建表达式，例如`yes|yup`，用作模式。
- en: How would you convert the string “42” into the integer 42?
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何将字符串“42”转换为整数42？
- en: The various numeric wrappers all have string conversion methods. For an integer
    like 42, the `Integer.parseInt()` method would work. The wrapper classes are all
    part of the `java.lang` package.
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 各种数值包装类都有字符串转换方法。对于像42这样的整数，`Integer.parseInt()`方法是适用的。包装类都属于`java.lang`包。
- en: How would you compare two strings to see if they match, ignoring any capitalization,
    such as “yes” and “YES”?
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何比较两个字符串以查看它们是否匹配，忽略大小写，例如“yes”和“YES”？
- en: 'The `String` class has two main comparison methods: `equals()` and `equals``IgnoreCase()`.
    The latter would ignore capitalization, as its name suggests.'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`String`类有两个主要的比较方法：`equals()`和`equalsIgnoreCase()`。后者会忽略大小写，顾名思义。'
- en: Which operator allows for simple string concatenation?
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个运算符允许简单的字符串连接？
- en: Java does not generally support operator overloading, but the plus sign (`+`)
    performs addition when used with numeric base types, and concatenation when used
    with `String` objects. If you use `+` to “add” a string and a number, the result
    will be a string. (So `7 + "is lucky"` would result in the string “7is lucky.”
    Notice that concatenation does not insert any whitespace. If you are assembling
    a typical sentence, you must add your own spacing between the parts.)
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Java通常不支持运算符重载，但加号（`+`）在与数字基本类型一起使用时执行加法，在与`String`对象一起使用时执行连接。如果你使用`+`来“添加”一个字符串和一个数字，结果将是一个字符串。（因此，`7
    + "is lucky"`将得到字符串“7is lucky”。注意，连接不会插入任何空格。如果你要组装一个典型的句子，你必须在部分之间添加自己的空格。）
- en: Code Exercises
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码练习
- en: There are many ways to accomplish the goals of this exercise. Testing the number
    of arguments should be straightforward. Then you can use some of the `String`
    class features to figure out whether you have the random keyword or a pair of
    coordinates. You can `split()` the coordinates, or craft a regular expression
    to separate the numeric values. When creating random coordinates, you can use
    `Math.random()`, similar to how we positioned the trees for our game in [“Math
    in action”](ch08.html#learnjava6-CHP-8-SECT-4.1.1).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多方法可以完成这个练习的目标。测试参数数量应该很简单。然后，你可以使用`String`类的一些特性来判断你是否有随机关键字或一对坐标。你可以使用`split()`方法分割坐标，或者编写一个正则表达式来分离数值。在创建随机坐标时，你可以使用`Math.random()`，类似于我们在[“数学实践中”](ch08.html#learnjava6-CHP-8-SECT-4.1.1)中为游戏定位树木的方式。
- en: 'Chapter 9: Threads'
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章：线程
- en: What is a thread?
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是线程？
- en: A thread represents a “thread of execution” within a program. Threads have their
    own state and can run independently from other threads. Typically you use threads
    to handle long-running tasks that can be put in the background while more important
    tasks can continue to do their work. Java has both platform threads (tied one-to-one
    with native threads supplied by the operating system) and virtual threads (pure
    Java constructs that retain the semantics and benefits of native threads without
    the operating system overhead).
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 线程代表程序内的“执行线程”。线程有自己的状态，并且可以独立于其他线程运行。通常，你使用线程来处理可以放在后台运行的长时间任务，而更重要的任务可以继续进行。Java既有平台线程（与操作系统提供的本地线程一一对应）又有虚拟线程（纯Java构造，保留了本地线程的语义和好处，但没有操作系统的开销）。
- en: What keyword can you add to a method if you want threads to “take turns” when
    calling it? (Meaning no two threads should be executing the method at the same
    time to avoid corrupting shared data.)
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你希望线程在调用方法时“轮流”执行（即不希望两个线程同时执行该方法以避免破坏共享数据），你可以为该方法添加哪个关键字？
- en: You can use the `synchronized` modifier on any method that reads or writes shared
    data. If two threads need to use the same method, the first thread sets a lock
    that blocks the second thread from calling the method. Once the first thread finishes,
    the lock is cleared and the second thread can proceed.
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在任何读取或写入共享数据的方法上使用`synchronized`修饰符。如果两个线程需要使用同一个方法，第一个线程设置一个锁，阻止第二个线程调用该方法。一旦第一个线程完成，锁将被清除，第二个线程可以继续。
- en: What flags allow you to compile a Java program that includes preview feature
    code?
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些标志允许你编译包含预览特性代码的Java程序？
- en: When compiling a Java class that relies on a preview feature, you must supply
    the `--enable-preview` and either the `-source` or `--release` flags to *javac*.
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在编译依赖于预览特性的Java类时，你必须提供`--enable-preview`以及`-source`或`--release`标志给*javac*。
- en: What flags allow you to run a Java program that includes preview feature code?
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些标志允许你运行包含预览特性代码的Java程序？
- en: When running a compile class that includes a preview feature, you only need
    to supply the `--enable-preview` flag.
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行包含预览特性的编译类时，你只需要提供`--enable-preview`标志。
- en: How many platform threads can one native thread support?
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个本地线程能支持多少平台线程？
- en: Just one. Creating a platform thread using the `Thread` class with a `Runnable`
    target or using something like the `ExecutorService` in the `java.util.concurrent`
    package requires the operating system to supply a thread as well.
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 只有一个。使用`Thread`类创建一个平台线程，并带有`Runnable`目标或使用`java.util.concurrent`包中的`ExecutorService`类，都需要操作系统提供一个线程。
- en: How many virtual threads can one native thread support?
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单个本机线程可以支持多少个虚拟线程？
- en: A single native thread will support many virtual threads. Project Loom set out
    to separate the threads used in Java programs from the threads managed by the
    operating system. For certain scenarios, lightweight virtual threads perform much
    better when Java is responsible for their scheduling. There is no fixed ratio
    of virtual to native, but the key insight with virtual threads is that the number
    of virtual threads is not tied to the number of native threads.
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个单独的本机线程可以支持许多虚拟线程。Project Loom旨在将Java程序中使用的线程与操作系统管理的线程分开。对于某些场景，轻量级虚拟线程在Java负责其调度时表现更佳。虚拟线程与本机线程的数量之间没有固定的比率，但虚拟线程的关键洞见是，其数量不与本机线程的数量挂钩。
- en: Is the statement `x = x + 1;` an atomic action for the `int` variable `x`?
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`int`变量`x`，语句`x = x + 1;`是否是原子操作？
- en: No. While it seems like such a small operation, there are several low-level
    steps involved. Any one of those low-level steps can be interrupted, and the value
    of `x` can be adversely affected. You could use an `AtomicInteger` or wrap the
    statement in a synchronized block if you need to guarantee a thread-safe increment.
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尽管这看起来是一个小操作，但涉及到几个低级步骤。这些低级步骤中的任何一个都可能被中断，并且`x`的值可能会受到不利影响。如果需要保证线程安全的增量，可以使用`AtomicInteger`或将语句包装在同步块中。
- en: What package includes thread-safe versions of popular collection classes like
    `Queue` and `Map`?
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个包含了像`Queue`和`Map`这样的流行集合类的线程安全版本？
- en: The `java.util.concurrent` package contains several collection classes that
    Java defines as “concurrent,” such as `ConcurrentLinkedQueue` and `ConcurrentHashMap`.
    Concurrency implies a few other behaviors beyond pure thread-safe reads and writes,
    but thread safety is guaranteed.
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`java.util.concurrent`包含几个Java定义为“并发”的集合类，例如`ConcurrentLinkedQueue`和`ConcurrentHashMap`。并发除了纯线程安全的读写之外，还涉及几个其他行为，但线程安全是得到保证的。'
- en: Code Exercises
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码练习
- en: 'You’ll do most of your work inside the `startClock()` method. (You will still
    have to import anything beyond the AWT and Swing packages that you use, of course.)
    You can create a separate class, an inner class or an anonymous inner class to
    handle the clock update loop. Recall that you can request a GUI element refresh
    by calling its `repaint()` method. Java supports a few mechanisms for “infinite”
    loops. You can use something like `while (true) { …​ }` or the cleverly named
    “forever” loop: `for (;;) { …​ }`. Don’t forget to start your thread once everything
    is in place!'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将会在`startClock()`方法内完成大部分工作。（当然，除了使用的AWT和Swing包外，你仍需导入其他内容。）你可以创建一个单独的类、内部类或匿名内部类来处理时钟更新循环。记住，可以通过调用其`repaint()`方法请求GUI元素的刷新。Java支持几种“无限”循环的机制。你可以使用像`while
    (true) { …​ }`这样的结构，或者巧妙命名的“forever”循环：`for (;;) { …​ }`。一切就绪后，别忘了启动你的线程！
- en: Hopefully, this exercise is fairly simple for you. As a testament to the overall
    compatibility of virtual threads with the existing codebase in Java, you should
    have to change only a few lines where the demo apple toss animation starts. In
    this iteration of the game, all of the setup and kickoff code happens in the `Field`
    class. Look for code like `new Thread()` or `new Runnable()`. You should be able
    to reuse the actual animation logic with no alterations.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 希望对你来说，这个练习相对简单。作为Java现有代码库与虚拟线程的整体兼容性的证明，你只需更改演示苹果投掷动画开始的几行代码。在这个游戏的这一轮中，所有设置和启动代码都发生在`Field`类中。查找类似`new
    Thread()`或`new Runnable()`的代码。你应该能够在不做任何修改的情况下重用实际的动画逻辑。
- en: 'Chapter 10: File Input and Output'
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章：文件输入和输出
- en: How could you check to see if a given file already exists?
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何检查给定的文件是否已经存在？
- en: There are a number of ways to see if a file exists, but two of the simplest
    rely on helper methods from either the `java.io` or `java.nio` package. An instance
    of `java.io.File` can use the `exists()` method. The static `java.nio.file.Files.exists()`
    method can test a `Path` object to see if a represented file exists.
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有几种方法可以检查文件是否存在，但其中两种最简单的方法依赖于`java.io`或`java.nio`包中的辅助方法。`java.io.File`的实例可以使用`exists()`方法。静态的`java.nio.file.Files.exists()`方法可以测试`Path`对象以查看所表示的文件是否存在。
- en: If you have to work with a legacy text file using an old encoding scheme, such
    as ISO 8859, how might you set up a reader to properly convert that content to
    UTF-8?
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果必须使用旧的编码方案（如ISO 8859）处理遗留文本文件，如何设置读取器以正确将内容转换为UTF-8？
- en: You can supply an appropriate character set (`java.nio.charset.Charset`) to
    the constructor of `FileReader` to safely convert the file to Java strings.
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以向`FileReader`的构造函数提供适当的字符集（`java.nio.charset.Charset`），安全地将文件转换为Java字符串。
- en: Which package has the best classes for nonblocking file I/O?
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个包中有最适合非阻塞文件I/O的类？
- en: One of the primary features of the `java.nio` package and its subpackages is
    support for nonblocking I/O.
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`java.nio`包及其子包的主要特性之一是支持非阻塞I/O。'
- en: Which type of input stream might you use to parse a binary file, such as a JPEG-compressed
    image?
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能会使用哪种类型的输入流来解析二进制文件，比如JPEG压缩的图片？
- en: From `java.io`, you could use the `DataInputStream` class. For NIO, channels
    and buffers (like `ByteBuffer`) naturally support binary data.
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从`java.io`，你可以使用`DataInputStream`类。对于NIO，通道和缓冲区（如`ByteBuffer`）自然地支持二进制数据。
- en: What are the three standard text streams built into the `System` class?
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`System`类内置了哪三个标准文本流？'
- en: The `System` class gives you access to two output streams, `System.out` and
    `System.err`, and one input stream, `System.in`. These streams are attached to
    the OS handles for `stdout`, `stderr`, and `stdin`, respectively.
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`System`类提供了两个输出流，`System.out`和`System.err`，以及一个输入流`System.in`。这些流分别连接到操作系统的`stdout`、`stderr`和`stdin`句柄。'
- en: Absolute paths begin at a root (*/* or *C:\*, for example). Where do relative
    paths begin? More specifically, where are relative paths relative to?
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绝对路径从根目录开始（例如`/`或`C:\`）。相对路径从哪里开始？更具体地说，相对路径相对于什么？
- en: Relative paths are relative to the “working directory,” which is typically where
    you started the program if you are using the command line to launch your application.
    In most IDEs, the working directory is something that can be configured.
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 相对路径是相对于“工作目录”的，通常这是你启动程序的地方，如果你使用命令行启动你的应用程序。在大多数IDE中，工作目录是可以配置的。
- en: How do you retrieve a NIO channel from an existing `FileInputStream`?
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何从现有的`FileInputStream`中检索一个NIO通道？
- en: If you already have an instance of `FileInputStream`, you can use its `getChannel()`
    method to return a `FileChannel` associated with the input stream.
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你已经有一个`FileInputStream`实例，你可以使用它的`getChannel()`方法返回与输入流关联的`FileChannel`。
- en: Code Exercises
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码练习
- en: The first iteration of our `Count` needs only one of the utilities discussed
    in the chapter. You’ll can use the `File` class with the path given as a command-line
    argument. From there, the `exists()` method will let you know if you can proceed
    or if you should print a friendly error message, and the `length()` method will
    give you the file’s size, in bytes. (The solution for this example is `Count1.java`
    in the *ch10/solutions* folder.)
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的第一个`Count`迭代只需使用本章讨论的其中一个工具。你可以使用作为命令行参数给定路径的`File`类。从那里，`exists()`方法将告诉你是否可以继续，或者是否应该打印友好的错误消息；`length()`方法将给出文件的大小，以字节为单位。（此示例的解决方案是位于*ch10/solutions*文件夹中的`Count1.java`。）
- en: For the second iteration that shows the line and word count in the given file,
    you’ll need to read and parse the contents of the file. One of the `Reader` classes
    would be great, but there are a variety of ways to read text files. However you
    open the file, you can count each line and then break that line up into words
    with something like `String.split()` or a regular expression. (The solution to
    this exercise is `Count2.java`.)
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于第二次迭代，在给定文件中显示行数和单词数，你需要读取和解析文件的内容。其中一个`Reader`类会很好，但有多种读取文本文件的方式。无论如何打开文件，你可以计算每一行，然后用`String.split()`或正则表达式将该行分解为单词。（此练习的解决方案是`Count2.java`。）
- en: There isn’t any new functionality in this third version, but we hope you’ll
    take this chance to try out some of the NIO classes and methods. Take a look at
    the methods of the `java.nio.file.Files` class. You’ll be surprised how much this
    helper class helps! (The solution to this exercise is `Count3.java`.)
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这第三个版本中没有任何新功能，但我们希望你能借此机会尝试一些NIO类和方法。看看`java.nio.file.Files`类的方法。你会惊讶于这个助手类有多大帮助！（此练习的解决方案是`Count3.java`。）
- en: Advanced Exercises
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级练习
- en: For this final upgrade, you get to write to a file or channel. Depending on
    how you chose to read the contents in version 2 or 3, this may represent a fairly
    significant addition to our class. You’ll need to check to make sure the second
    argument (if it was given!) is writable. Then use one of the classes that allows
    appending, such as `RandomAccessFile`, or include the `APPEND` option for a `FileChannel`.
    (The solution to this exercise is `Count4.java`. We used the previous `Count3`
    with NIO, but you are welcome to start from `Count2` and use the standard I/O
    classes.)
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这次最终的升级，您可以写入文件或通道。根据您选择在版本2或3中读取内容的方式，这可能代表我们类中的相当重要的添加。您需要检查确保第二个参数（如果给定！）是可写的。然后使用允许追加的类之一，如`RandomAccessFile`，或为`FileChannel`包括`APPEND`选项。（此练习的解决方案是`Count4.java`。我们使用了之前的`Count3`与NIO，但您可以从`Count2`开始并使用标准I/O类。）
- en: 'Chapter 11: Functional Approaches in Java'
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章：Java中的函数式方法
- en: Which package contains the majority of functional interfaces?
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个包含大多数功能接口？
- en: While functional interfaces are scattered throughout the JDK, you will find
    the bulk of the “official” interfaces defined in the `java.util.function` package.
    We used qualifying quotes on “official” because any interface with a single abstract
    method (SAM) can be treated as a functional interface.
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 虽然函数式接口分散在整个JDK中，但您会发现大多数“官方”接口定义在`java.util.function`包中。我们在“官方”上加了引号，因为任何具有单个抽象方法（SAM）的接口都可以视为函数式接口。
- en: Do you need to use any special flags when compiling or running Java applications
    that use functional features like lambdas?
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编译或运行使用像lambda这样的函数特性的Java应用程序时，是否需要使用任何特殊标志？
- en: No. The many FP features currently available in Java are full members of the
    JDK. There are no preview or feature flags required to compile or execute Java
    code that uses them.
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 是的。目前Java中的许多函数式编程功能都是JDK的完整成员。编译或执行使用它们的Java代码时不需要预览或功能标志。
- en: How do you create lambda expressions with multiple statements in the body?
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何创建具有多个语句的lambda表达式主体？
- en: 'The body of a lambda expression follows the same rules as the body of something
    like a `while` loop: single statements do not require enclosing curly braces,
    but multiple statements do. You can use a curly brace block on the right side
    of the lambda if you have multiple statements. If your lambda returns a value,
    you can use the standard `return` statement as well.'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: lambda表达式的主体遵循与诸如`while`循环之类的主体相同的规则：单个语句不需要括号括起来，但多个语句需要。如果您的lambda返回一个值，您也可以使用标准的`return`语句。
- en: Can lambda expressions be void? Can they return values?
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: lambda表达式可以是void吗？它们可以返回值吗？
- en: Yes on both counts. Lambda expressions run the same gamut of options as methods.
    You can have lambdas that take no arguments and return no values. You can have
    lambdas that consume arguments but produce no results. You can have lambda generators
    that don’t have arguments but do return values. Finally, you can have lambdas
    that accept one or more arguments and return a value.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这两个方面都是可以的。Lambda表达式可以运行与方法相同的各种选项。您可以有不接受参数且不返回值的lambda表达式。您可以有消耗参数但不产生结果的lambda表达式。您可以有不接受参数但返回值的lambda生成器。最后，您可以有接受一个或多个参数并返回值的lambda表达式。
- en: Can you reuse a stream after you have processed it?
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在处理完流后能否重用它？
- en: No. Once you start processing a stream, that’s it. Attempting to reuse a stream
    will result in an exception. You can often reuse the original source to create
    an entirely new but identical stream, if needed.
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不行。一旦您开始处理流，那就是它了。试图重用流将导致异常。如果需要，您通常可以重用原始源来创建一个全新但完全相同的流。
- en: How might you take a stream of objects and convert it to a stream of integers?
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何将对象流转换为整数流？
- en: 'You could use one of the `mapToInt()` variations from the `Stream` class: `mapToInt()`,
    `flatMapToInt()`, or `mapMultiToInt()`. The `IntStream` class, in turn, has a
    `mapToObj()` method to convert in the opposite direction.'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以使用`Stream`类的`mapToInt()`变体之一：`mapToInt()`，`flatMapToInt()`或`mapMultiToInt()`。反过来，`IntStream`类有一个`mapToObj()`方法以在相反方向进行转换。
- en: If you have a stream that filters out empty lines from a file, what operation
    might you use to tell you how many lines had some content?
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您有一个从文件中过滤空行的流，您可能会使用什么操作来告诉您有多少行包含内容？
- en: The easiest way to count the remaining lines would be to use the `count()` terminal
    operation. You could also create your own reducer, or use a collector and then
    query the length of the resulting list.
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 计算剩余行数的最简单方法是使用`count()`终端操作。你也可以创建自己的规约器，或者使用一个收集器然后查询结果列表的长度。
- en: Code Exercises
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码练习
- en: 'Hopefully the use of a more interesting formula for our adjustment feels straightforward.
    We don’t need any alternative syntax or extra methods; we just put the Celsius
    conversion, C = (F – 32) * 5 / 9, into the body of our lambda, like so:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 希望我们对调整使用更有趣的公式感到顺利。我们不需要任何替代语法或额外方法；我们只需将摄氏度转换公式C =（F - 32）* 5 / 9放入我们的lambda体中，如下所示：
- en: '[PRE15]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Not very dramatic, but we want to point out that lambdas can open up some really
    clever possibilities that extend beyond your initial plans.
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这并不是非常引人注目，但我们想指出，Lambda表达式可以开启一些非常聪明的可能性，这些可能性超出了最初的计划。
- en: 'You have a number of choices available to accomplish this averaging task. You
    could write an averaging reducer. You could collect the salaries into a simpler
    container and then write your own averaging code. But if you look over the documentation
    on the different streams, you’ll notice that the numeric streams already have
    the perfect operation: `average()`. It returns an `OptionalDouble` object. You’ll
    still need to start the stream and then use something like `mapToInt()` to get
    your stream of numeric values.'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这种平均值任务，你有多种选择可用。你可以编写一个平均值规约器。你可以将工资收集到一个更简单的容器中，然后编写自己的平均代码。但是，如果你查看不同流的文档，你会注意到数值流已经有了完美的操作：`average()`。它返回一个`OptionalDouble`对象。你仍然需要启动流，然后使用类似`mapToInt()`的东西来获取你的数值流。
- en: Advanced Exercises
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级练习
- en: 'The `groupingBy()` collector needs a function that extracts a key from each
    element of the stream and returns a map of the keys paired with a list of all
    the elements that have matching keys. For our `PaidEmployee` example, you will
    probably have something like this:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`groupingBy()`收集器需要一个从流的每个元素中提取键并返回键与所有具有匹配键的元素列表的映射的函数。对于我们的`PaidEmployee`示例，你可能会有类似这样的内容：'
- en: '[PRE16]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The type of the key in our map must match the type of object we extract in our
    `groupingBy()` operation. We used a method reference here, but any lambda that
    returns the role of the employee would also work.
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们映射中键的类型必须与我们在`groupingBy()`操作中提取的对象类型相匹配。我们在这里使用了一个方法引用，但是任何返回员工角色的lambda也将起作用。
- en: We didn’t want to complicate the previous solution, so we made copies of the
    report and employee classes named `Report2` and `PaidEmployee2`, respectively.
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们不想使先前的解决方案复杂化，所以我们复制了报告和员工类，并分别命名为`Report2`和`PaidEmployee2`。
- en: 'Chapter 12: Desktop Applications'
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章：桌面应用程序
- en: Which component would you use to display some text to the user?
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会用哪个组件向用户显示一些文本？
- en: While you could use a variety of text-based components, `JLabel` is the simplest
    way to show the user some (read-only) textual information.
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 虽然你可以使用多种基于文本的组件，但`JLabel`是向用户展示一些（只读）文本信息的最简单方式。
- en: Which component(s) would you use to allow the user to enter text?
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会用哪些组件来允许用户输入文本？
- en: Depending on how much information you expect from the user, you could use either
    `JTextField` or `JTextArea`. (Other text components exist, but they serve more
    specialized purposes.)
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 根据用户期望获得的信息量，你可以使用`JTextField`或`JTextArea`。 （还有其他文本组件存在，但它们提供更专业化的用途。）
- en: What event does clicking a button generate?
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击按钮会生成什么事件？
- en: Clicking a button or any button-like component such as `JMenuItem` generates
    an `ActionEvent`.
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 单击按钮或类似按钮的组件（如`JMenuItem`）会生成`ActionEvent`。
- en: Which listener should you attach to `JList` if you want to know when the user
    changes the selected item?
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想知道用户何时更改所选项目，应该将监听器附加到`JList`。
- en: You can implement the `ListSelectionListener` from the `javax.swing.event` package
    to receive list selection (and deselection) events from a `JList` object.
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以实现来自`javax.swing.event`包的`ListSelectionListener`来接收`JList`对象的列表选择（和取消选择）事件。
- en: What is the default layout manager for `JPanel`?
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`JPanel`的默认布局管理器是什么？'
- en: By default, `JPanel` uses the `FlowLayout` manager. One notable exception to
    this default is the content pane of `JFrame`. That pane is a `JPanel`, but the
    frame automatically changes the pane’s manager to `BorderLayout`.
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 默认情况下，`JPanel`使用`FlowLayout`管理器。这个默认的一个显著例外是`JFrame`的内容窗格。该窗格是一个`JPanel`，但是框架会自动将窗格的管理器更改为`BorderLayout`。
- en: Which thread is responsible for processing events in Java?
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Java中，哪个线程负责处理事件？
- en: The event dispatch thread, sometimes called the event dispatch queue, manages
    delivery of events and updates to components on screen.
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 事件分发线程，有时被称为事件分发队列，管理着事件的传递和屏幕上组件的更新。
- en: What method would you use to update a component like `JLabel` after a background
    task completes?
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在后台任务完成后，你会用什么方法来更新像`JLabel`这样的组件？
- en: You could use `SwingUtilities.invokeAndWait()` if you want to wait for the label
    to be updated before processing any other events. You could use `Swing` `Utilities.invokeLater()`
    if it doesn’t matter exactly when the label gets updated.
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你希望在处理其他事件之前等待标签更新完成，可以使用`SwingUtilities.invokeAndWait()`。如果不在乎标签何时更新完成，可以使用`Swing`
    `Utilities.invokeLater()`。
- en: What container holds `JMenuItem` objects?
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么容器持有`JMenuItem`对象？
- en: A `JMenu` object can hold `JMenuItem` objects as well as nested `JMenu` objects.
    The menus themselves are contained in a `JMenuBar`.
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`JMenu`对象可以持有`JMenuItem`对象以及嵌套的`JMenu`对象。菜单本身则包含在`JMenuBar`中。'
- en: Code Exercises
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码练习
- en: 'You can tackle the calculator layout one of two ways: you can use nested panels
    or you can use the `GridBagLayout`. (Our solution in *ch12/solutions/Calculator.java*
    uses a nested panel for the buttons.) Start simple. Add the text field to the
    top of the frame. Then add one button to the center. Now decide how you want to
    handle adding the remaining buttons. If your buttons use the `Calculator` instance
    (using the keyword `this` we discussed in [“Shadowing”](ch05.html#learnjava6-CHP-5-SECT-2.2))
    as their listener, you should see the label of any button you click printed to
    the terminal.'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以以两种方式处理计算器布局：使用嵌套面板或使用`GridBagLayout`。（我们在 *ch12/solutions/Calculator.java*
    中的解决方案使用了嵌套面板来布置按钮。）从简单开始。将文本字段添加到框架顶部。然后在中心添加一个按钮。现在决定如何处理添加剩余按钮。如果你的按钮使用了`Calculator`实例（使用我们在
    [“Shadowing”](ch05.html#learnjava6-CHP-5-SECT-2.2) 中讨论的关键字`this`作为它们的监听器），你应该看到任何点击的按钮标签都会打印到终端上。
- en: This exercise doesn’t require much new graphical code. But you do need to work
    within the UI event thread to safely alter the obstacles shown on the field. You
    can start slowly by simply printing a message or using a `JOptionPane` to show
    an alert any time an apple touches a tree or a hedge. Once you’re confident in
    your distance measuring, review how to remove an object from a list. After removing
    an obstacle, be sure to repaint the field.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个练习并不需要太多新的图形代码。但是你需要在 UI 事件线程中安全地修改场地上显示的障碍物。你可以从简单的打印消息或使用`JOptionPane`来显示警告开始慢慢进行，只要苹果碰到树或篱笆就触发。在你对距离测量有信心后，回顾一下如何从列表中移除对象。移除障碍物后，记得重新绘制场地。
- en: Advanced Exercises
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级练习
- en: The logic for a calculator is relatively straightforward, but it certainly is
    not trivial. Start by getting the various digit buttons (1, 2, 3, and so on) hooked
    up to the display. You’ll need to append digits to create full numbers. Clicking
    the 1 button followed by the 2 button should display a 12\. When the user clicks
    on an operation button such as “–”, store whatever number is currently displayed
    as well as the operation to use later. Let the user type in a second number. Clicking
    the “=” should store this second number and then perform the actual calculation.
    Put the result in the display and then let the user start over.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算器的逻辑相对简单，但绝对不是琐碎的。首先让各种数字按钮（1、2、3等）与显示器连接起来。你需要追加数字来创建完整的数字。当用户点击“–”等操作按钮时，将当前显示的数字及将来使用的操作存储起来。让用户输入第二个数字。点击“=”应该存储这第二个数字，然后执行实际的计算。将结果显示在显示器上，然后让用户重新开始。
- en: There are many (many!) subtleties in a full, professional calculator app. Don’t
    worry if your early attempts impose restrictions like working only with single-digit
    numbers. The point of this exercise is to practice responding to events. Even
    just getting a digit to show in the display field after the user clicks a button
    is worth celebrating!
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在完整的专业计算器应用程序中有许多（许多！）微妙之处。如果你的早期尝试限制为仅处理单个数字，不要担心。这个练习的重点是练习响应事件。即使只是在用户点击按钮后让一个数字显示在显示字段中，也值得庆祝！
- en: 'Chapter 13: Network Programming in Java'
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章：Java 网络编程
- en: Which networking protocols does the `URL` class support by default?
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`URL`类默认支持哪些网络协议？'
- en: Java’s `URL` class includes support for the HTTP, HTTPS, and FTP protocols.
    These three protocols cover a great deal of the resources available online, but
    you can create your own protocol handler if you deal with systems other than web
    or file servers.
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Java的`URL`类包含对HTTP、HTTPS和FTP协议的支持。这三种协议涵盖了在线资源的大部分内容，但如果你处理除Web或文件服务器之外的系统，你可以创建自己的协议处理程序。
- en: Can you use Java to download binary data from an online source?
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用Java从在线源下载二进制数据吗？
- en: Yes. Byte streams lie at the heart of all network data in Java. You can read
    the raw bytes, or you can chain some other higher-level stream. For example, `InputStreamReader`
    and `BufferedReader` work great for text. `DataInputStream` can handle binary
    data.
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以。字节流是Java中所有网络数据的核心。你可以读取原始字节，或者可以链接其他更高级别的流。例如，`InputStreamReader`和`BufferedReader`非常适合文本。`DataInputStream`可以处理二进制数据。
- en: How do you send form data to a web server using Java? (No need for a fully functional
    application, we just want you to think about the high-level steps you take and
    the Java classes involved.)
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何使用Java将表单数据发送到Web服务器？（不需要完整功能的应用程序，我们只想让你考虑涉及的高级步骤和涉及的Java类。）
- en: You can use the `URL` class to open a connection to a web server. Before making
    any requests, you can configure the connection for bidirectional communication.
    The HTTP `POST` command allows you to send data to the server in the body of your
    request.
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以使用`URL`类打开到Web服务器的连接。在发出任何请求之前，你可以配置双向通信的连接。HTTP `POST`命令允许你在请求的正文中向服务器发送数据。
- en: What class do you use to listen for incoming network connections?
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你用什么类来监听传入的网络连接？
- en: You use the `java.net.ServerSocket` class to create a network listener.
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你使用`java.net.ServerSocket`类来创建一个网络监听器。
- en: When creating your own server like we did for our game, are there any rules
    for picking a port number?
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当像我们的游戏一样创建自己的服务器时，有关于选择端口号的规则吗？
- en: Yes. Port numbers must be between 0 and 65,535 with ports below 1,024 typically
    reserved for well-known services that often require special permissions to use.
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以。端口号必须在0到65,535之间，通常为小于1,024的端口保留给常见服务，通常需要特殊权限才能使用。
- en: Can a server application written in Java support multiple, simultaneous clients?
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用Java编写的服务器应用程序可以支持多个同时客户端吗？
- en: Yes. While you can create only one `ServerSocket` on a given port, you can accept
    hundreds or even thousands of clients and process their requests in a thread.
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 是的。虽然你只能在给定端口上创建一个`ServerSocket`，但你可以接受数百甚至数千个客户端并在线程中处理他们的请求。
- en: How many simultaneous servers can a given client `Socket` instance talk to?
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定的客户端`Socket`实例可以与多少个同时服务器通信？
- en: One. A client socket communicates with one host on one port. A client application
    may allow multiple, distinct sockets for communicating with multiple servers at
    the same time, but each socket will still talk to a single server.
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个。客户端套接字与一个主机在一个端口上通信。客户端应用程序可以允许使用多个独立的套接字与多个服务器同时通信，但每个套接字仍然只能与一个服务器通信。
- en: Code Exercises
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码练习
- en: Adding a feature to the protocol of our game requires updating both the server
    and client code. Fortunately we can reuse much of the `TREE` entry’s logic on
    both sides. Even more fortunately, all of our network communication code is in
    the `Multiplayer` class.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向我们的游戏协议添加一个功能需要更新服务器和客户端代码。幸运的是，我们可以在两端重复使用`TREE`条目的逻辑。更幸运的是，我们所有的网络通信代码都在`Multiplayer`类中。
- en: The client and the server are inner classes, creatively named `Client` and `Server`,
    respectively. For the server, add a loop in the `run()` method to send hedge data
    right after you have sent the tree data. For the client, add a `HEDGE` segment
    to the `run()` method that accepts the location of the hedge and adds it to the
    field.
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 客户端和服务器是内部类，分别被创造性地命名为`Client`和`Server`。对于服务器，在`run()`方法中添加一个循环来在发送树数据后立即发送树篱数据。对于客户端，在`run()`方法中添加一个`HEDGE`段，接受树篱的位置并将其添加到场地上。
- en: Once the fields are set up for the two players, the in-game portion of the protocol
    only reports scores and disconnects. We don’t have to modify any of this code.
    Each player will have the same hedge obstacles and the same opportunity to remove
    them with a tossed apple.
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦为两名玩家设置了字段，在游戏内部分协议中只报告分数和断开连接。我们不必修改任何此代码。每个玩家都将面对相同的树篱障碍，并有机会用扔苹果来移除它们。
- en: A human-readable date/time server should be fairly straightforward, but we want
    you to practice setting up your own sockets from scratch. You’ll need to decide
    on a port number for the server. 3283 spells “DATE” on a phone keypad if you need
    a little inspiration. We recommend processing the client request immediately after
    accepting the connection. (The advanced exercises give you a chance to try the
    more sophisticated approach of using threads.)
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个人类可读的日期/时间服务器应该相当简单，但是我们希望您练习从头设置自己的套接字。您需要为服务器选择一个端口号。3283在电话键盘上拼写“DATE”，如果您需要一些灵感。我们建议在接受连接后立即处理客户端请求。（高级练习为您提供了尝试使用线程更复杂方法的机会。）
- en: For the client, the only real piece of configurable data is the name of the
    server. You’re free to hardcode `“localhost”` if you plan to test your solution
    using two terminal windows on your local machine. Our solution takes an optional
    command-line argument, defaulting to `“localhost”` as well if you don’t provide
    an argument.
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于客户端，唯一的可配置数据是服务器的名称。如果您计划在本地机器上的两个终端窗口上测试您的解决方案，则可以随意硬编码`“localhost”`。我们的解决方案还接受一个可选的命令行参数，默认为`“localhost”`，如果您不提供参数。
- en: Advanced Exercises
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级练习
- en: To handle clients using threads, you need to isolate the code responsible for
    communicating with the client. A helper class (inner, anonymous, or separate are
    all fine options) or a lambda will work. You still need to let the `ServerSocket`
    do its work and `accept()` a new connection, but you can hand off the accepted
    `Socket` object to your helper as soon as you get it.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要处理使用线程的客户端，您需要隔离与客户端通信的代码。可以使用帮助类（内部类、匿名类或独立类都可以），或者使用 lambda 表达式。您仍然需要让`ServerSocket`完成其工作并`accept()`新连接，但一旦接收到，您可以立即将接受的`Socket`对象移交给您的帮助类。
- en: It’ll be hard to really test this class, as you would need many clients all
    requesting the current date at the same moment. At a minimum, though, your current
    `FDClient` class should work with no changes, and you should still receive the
    correct date.
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 真的很难测试这个类，因为您需要同时有许多客户端在同一时刻请求当前日期。但至少，您的当前`FDClient`类应该可以在不更改的情况下工作，并且您应该仍然收到正确的日期。
- en: 'Working with online APIs can be fun, but it also requires paying attention
    to details. You typically need to answer a few questions as you begin to create
    your client:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用在线API可以很有趣，但也需要注意细节。通常在开始创建客户端时，您需要回答一些问题：
- en: What is the base URL for the API?
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: API的基本URL是什么？
- en: Does the API use standard web form encoding or JSON? If not, is there a library
    with support for encoding and decoding?
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: API使用标准的Web表单编码或JSON吗？如果不是，是否有支持编码和解码的库？
- en: Are there limits on how many requests you can make or how much data you can
    download?
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您能够发起多少请求或下载多少数据有限制吗？
- en: Does the site have good documentation with common examples of sending and retrieving
    data?
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网站是否有良好的文档，包含发送和检索数据的常见示例？
- en: As you practice, you’ll develop your own sense of what information you need
    to start using new APIs. But you do need to practice. After you build your first
    client, look up another service. Write a client for that API and see if you can
    already spot common problems, or better, reusable code from your first client.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 随着实践，您将会形成自己对开始使用新API所需信息的感觉。但是，您确实需要练习。在构建第一个客户端之后，查找另一个服务。为该API编写客户端，并查看您是否已经能够识别常见问题或更好地重用第一个客户端的代码。
- en: ^([1](app02.html#id2590-marker)) You can look at any JAR or ZIP file with `jar
    tvf <jarfile>`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](app02.html#id2590-marker)) 您可以使用`jar tvf <jarfile>`查看任何JAR或ZIP文件。
- en: ^([2](app02.html#id2591-marker)) You could, however, use a `SortedSet` or a
    `TreeMap`, which both keep their entries sorted. For `TreeMap`, the keys are kept
    in order.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](app02.html#id2591-marker)) 不过，您可以使用`SortedSet`或`TreeMap`，它们都会保持其条目排序。对于`TreeMap`，键保持有序。
