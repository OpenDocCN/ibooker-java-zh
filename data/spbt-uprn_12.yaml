- en: Chapter 12\. Going Deeper with Reactive
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章 深入探讨响应式编程
- en: As previously discussed, reactive programming gives developers a way to make
    better use of resources in distributed systems, even extending powerful scaling
    mechanisms across application boundaries and into the communication channels.
    For developers with experience exclusively with mainstream Java development practices—often
    called *imperative* Java due to its explicit and sequential logic versus the more
    declarative approach generally used in reactive programming, although this label,
    like most, is imperfect—these reactive capabilities may bear some undesired costs.
    In addition to the expected learning curve, which Spring helps flatten considerably
    due to parallel and complementary WebMVC and WebFlux implementations, there are
    also relative limitations in tooling, its maturity, and established practices
    for essential activities like testing, troubleshooting, and debugging.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前讨论的，响应式编程为开发人员提供了一种在分布式系统中更好地利用资源的方法，甚至将强大的扩展机制扩展到应用程序边界和通信通道中。对于仅有主流Java开发实践经验的开发人员（通常被称为*命令式*Java，因其显式和顺序逻辑，与响应式编程中通常使用的更声明式方法相对），这些响应式能力可能带来一些不希望的成本。除了预期的学习曲线外，Spring通过并行和互补的WebMVC和WebFlux实现大大降低了这种学习曲线，还存在工具、成熟度和针对关键活动（如测试、故障排除和调试）的已建立实践的相对限制。
- en: While it is true that reactive Java development is in its infancy relative to
    its imperative cousin, the fact that they are family has allowed a much faster
    development and maturation of useful tooling and processes. As mentioned, Spring
    builds similarly on established imperative expertise within its development and
    community to condense decades of evolution into production-ready components available
    *now*.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管相对于其命令式表亲而言，响应式Java开发确实还处于起步阶段，但它们同属一个大家庭的事实，已经允许了更快的工具和流程的发展和成熟。如前所述，Spring在其开发和社区中建立的成熟命令式专业知识基础上，已经将数十年的演变压缩成现在可用的生产就绪组件。
- en: This chapter introduces and explains the current state of the art in testing
    and diagnosing/debugging issues you might encounter as you begin to deploy reactive
    Spring Boot applications and demonstrates how to put WebFlux/Reactor to work for
    you, even before—and to help—you go to production.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍并解释了测试和诊断/调试问题的最新技术，您可能在部署响应式Spring Boot应用程序时会遇到，并展示了如何在生产之前，并帮助您进行生产之前，使WebFlux/Reactor发挥作用。
- en: Code Checkout Checkup
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码检查检查完成
- en: Please check out branch *chapter12begin* from the code repository to begin.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看代码仓库中的*chapter12begin*分支开始。
- en: When Reactive?
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用响应式？
- en: Reactive programming, and in particular those applications focusing on reactive
    streams, enables system-wide scaling that is difficult to match using other means
    available at this point in time. However, not all applications need to perform
    at the far reaches of end-to-end scalability, or they may already be performing
    (or are expected to perform) admirably with relatively predictable loads over
    impressive time frames. Imperative apps have long fulfilled production demands
    for organizations globally, and they will not simply cease to do so because a
    new option arrives.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程，特别是那些专注于响应式流的应用程序，使得系统范围的扩展难以用其他现有手段匹敌。然而，并非所有应用程序都需要在端到端可扩展性的极端要求下运行，或者它们可能已经表现得非常出色，可以在可预见的时间范围内处理相对可预测的负载。命令式应用程序长期以来一直满足全球组织的生产需求，它们不会仅仅因为有了新选项就停止工作。
- en: 'While reactive programming is unquestionably exciting in terms of the possibilities
    it offers, the Spring team clearly states that reactive code will not replace
    all imperative code for the foreseeable future, if ever. As stated in the [Spring
    Framework reference documentation for Spring WebFlux](https://oreil.ly/SFRefDoc):'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管响应式编程在其提供的可能性方面毫无疑问地令人兴奋，Spring团队明确表示，响应式代码在可预见的未来，甚至可能永远也不会取代所有命令式代码。正如在[Spring
    WebFlux的参考文档中所述](https://oreil.ly/SFRefDoc)：
- en: If you have a large team, keep in mind the steep learning curve in the shift
    to non-blocking, functional, and declarative programming. A practical way to start
    without a full switch is to use the reactive WebClient. Beyond that, start small
    and measure the benefits. We expect that, for a wide range of applications, the
    shift is unnecessary. If you are unsure what benefits to look for, start by learning
    about how non-blocking I/O works (for example, concurrency on single-threaded
    Node.js) and its effects.
  id: totrans-9
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你有一个庞大的团队，请记住在转向非阻塞、函数式和声明式编程时的陡峭学习曲线。一个实际的开始方法，而不是完全转变，是使用响应式的WebClient。除此之外，从小处开始，并测量收益。我们预期，在广泛应用的情况下，这种转变是不必要的。如果你不确定要寻找什么样的好处，首先了解非阻塞I/O的工作方式（例如，单线程Node.js上的并发）及其影响是个不错的开始。
- en: ''
  id: totrans-10
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Spring Framework Reference Documentation
  id: totrans-11
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Spring框架参考文档
- en: In short, adopting reactive programming and Spring WebFlux is a choice—a great
    choice that provides perhaps the best way to accomplish certain requirements—but
    still a choice to make after careful consideration of the relevant requirements
    and demands for the system in question. Reactive or not, Spring Boot provides
    unsurpassed options to develop business-critical software to handle all of your
    production workloads.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，采用响应式编程和Spring WebFlux是一个选择——这是一个极好的选择，可能是实现某些需求的最佳方式——但在仔细考虑所涉及系统的相关需求和要求后再做出的选择。无论是响应式还是非响应式，Spring
    Boot都提供了无与伦比的选项来开发处理所有生产工作负载的关键业务软件。
- en: Testing Reactive Applications
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试响应式应用程序
- en: In order to better focus on the key concepts of testing reactive Spring Boot
    applications, I take several steps to tighten the scope of code under consideration.
    Like zooming in on a subject you wish to photograph, other project code is still
    present but is not on the critical path for the information in this section.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地专注于测试响应式Spring Boot应用程序的关键概念，我采取了几个步骤来缩小考虑范围的代码范围。就像放大你希望拍摄的主题一样，其他项目代码仍然存在，但不在本节信息的关键路径上。
- en: 'For this section I’ll zero in specifically on testing externally those APIs
    that expose reactive streams publishers—`Flux`, `Mono`, and `Publisher` types
    that could be either `Flux` or `Mono`—instead of the typical blocking `Iterable`
    or `Object` types. I begin with the class within `Aircraft Positions` that provides
    the external APIs: `PositionController`.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这一部分，我将专注于专门测试那些公开响应式流发布者的API，如`Flux`、`Mono`和`Publisher`类型，这些类型可以是`Flux`或`Mono`，而不是典型的阻塞`Iterable`或`Object`类型。我首先从提供外部API的`Aircraft
    Positions`类内部开始，即`PositionController`。
- en: Tip
  id: totrans-16
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: If you haven’t already checked out the [Chapter 12](#sbur-12) code as indicated
    at the beginning of this chapter, please do so now.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有检查过[第12章](#sbur-12)的代码，请立即去看看。
- en: But First, Refactoring
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 但首先，重构
- en: 'While the code within `PositionController` does work, it is a bit of a testing
    muddle. The first order of business is to provide a cleaner separation of concerns,
    and I begin by removing the code to create an `RSocketRequester` object to an
    `@Configuration` class that will create it as a Spring bean, accessible anywhere
    within the application:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`PositionController`内部的代码确实有效，但有点混乱。首要任务是提供更清晰的关注点分离，我开始通过将创建`RSocketRequester`对象的代码移动到一个`@Configuration`类中，使其作为Spring
    bean创建，可以在应用程序的任何地方访问：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This streamlines the constructor for `PositionController`, placing the work
    for creating the `RSocketRequester` where it belongs and well outside of a controller
    class. To use the `RSocketRequester` bean in `PositionController`, I simply autowire
    it in using Spring Boot’s constructor injection:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这简化了`PositionController`的构造函数，将创建`RSocketRequester`的工作放在了适当的位置，并且远离控制器类。要在`PositionController`中使用`RSocketRequester`
    bean，我只需使用Spring Boot的构造函数注入自动装配它：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-23
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Testing the RSocket connection would require integration testing. While this
    section focuses on unit testing and not integration testing, it is still essential
    to decouple the construction of the `RSocketRequester` from `PositionController`
    in order to isolate and properly unit test `PositionController`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 测试RSocket连接需要进行集成测试。虽然本节重点是单元测试而不是集成测试，但仍然需要将`RSocketRequester`的构造与`PositionController`分离开来，以便隔离和正确地单元测试`PositionController`。
- en: 'There is another source of logic that falls well outside of controller functionality
    that remains, this time involving the acquisition, then the storing and retrieving,
    of aircraft positions using the `AircraftRepository` bean. Typically when complex
    logic unrelated to a particular class finds its way into that class, it’s best
    to extract it, as I did for the `RSocketRequester` bean. To relocate this somewhat
    complex and unrelated code outside of `PositionController`, I create a `PositionService`
    class and define it as a `@Service` bean available throughout the application.
    The `@Service` annotation is simply a more visually specific description of the
    oft-used `@Component` annotation:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 另外一个逻辑来源并不完全属于控制器功能，这次涉及使用`AircraftRepository` bean 获取、存储和检索飞行器位置。通常，当与特定类无关的复杂逻辑进入该类时，最好将其提取出来，就像我为`RSocketRequester`
    bean 所做的那样。为了将这段有些复杂且不相关的代码从`PositionController`中移出，我创建了一个`PositionService`类，并将其定义为一个在整个应用程序中可用的`@Service`
    bean。`@Service`注解只是对常用的`@Component`注解的更为具体的视觉描述：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-27
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Currently there is no `findAircraftByReg()` method defined within `AircraftRepository`.
    I address that prior to creating tests.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当前在`AircraftRepository`中没有定义`findAircraftByReg()`方法。在创建测试之前，我解决了这个问题。
- en: 'Although more work could be done (especially with regard to the `WebClient`
    member variable), it is sufficient for now to remove the complex logic shown in
    `PositionService::getAllAircraft` from its former home within `PositionController::getCurrentAircraftPositions`
    and inject the `PositionService` bean into the controller for its use, resulting
    in a much cleaner and focused controller class:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可以做更多的工作（特别是关于`WebClient`成员变量的工作），但现在将`PositionService::getAllAircraft`中显示的复杂逻辑从其以前的位置移除，并将`PositionService`
    bean注入到控制器中供其使用已足够，这导致控制器类更加干净和专注：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Reviewing the existing `PositionController` endpoints shows that they feed a
    Thymeleaf template (`public String getCurrentAircraftPositions(Model model)`)
    or require an external `RSocket` connection (`public Flux<Aircraft>` `getCurrentACPositionsStream()`).
    In order to isolate and test the Aircraft Positions application’s ability to provide
    an external API, I need to expand the currently defined endpoints. I add two more
    endpoints mapped to */acpos* and */acpos/search* to create a basic, but flexible,
    API leveraging the methods I created within `PositionService`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾现有的`PositionController`端点显示它们供给了一个Thymeleaf模板（`public String getCurrentAircraftPositions(Model
    model)`）或者需要一个外部的`RSocket`连接（`public Flux<Aircraft>` `getCurrentACPositionsStream()`）。为了隔离和测试飞行器位置应用程序提供外部API的能力，我需要扩展当前定义的端点。我添加了两个额外的端点映射到`/acpos`和`/acpos/search`，以创建一个基本但灵活的API，利用我在`PositionService`内部创建的方法。
- en: I first create a method to retrieve and return as JSON all positions of aircraft
    currently within range of our PlaneFinder service-enabled device. The `getCurrentACPositions()`
    method calls `PositionService::getAllAircraft` just as its counterpart `getCurrentAircraftPositions(Model
    model)`, but it returns JSON object values instead of adding them to the domain
    object model and redirecting to the template engine for display of an HTML page.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我首先创建了一个方法，以JSON格式检索并返回目前位于我们的PlaneFinder服务启用设备范围内的所有飞行器的位置。`getCurrentACPositions()`方法调用`PositionService::getAllAircraft`，就像它的对应方法`getCurrentAircraftPositions(Model
    model)`一样，但它返回JSON对象值，而不是将它们添加到领域对象模型并重定向到模板引擎以显示HTML页面。
- en: Next, I create a method for searching current aircraft positions by the unique
    position record identifier and by the aircraft registration number. The record
    (technically document, since this version of `Aircraft Positions` uses MongoDB)
    identifier is the database unique ID among the stored positions last retrieved
    from PlaneFinder. It is useful for retrieving a specific position record; but
    more useful from an aircraft perspective is the ability to search for an aircraft’s
    unique registration number.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我创建了一种方法，通过唯一的位置记录标识符和飞行器注册号来搜索当前飞行器位置。记录（在技术上是文档，因为这个版本的`Aircraft Positions`使用MongoDB）标识符是数据库中存储的最后从PlaneFinder检索到的位置中的唯一ID。它对于检索特定位置记录很有用；但从飞行器的角度来看，根据飞行器的唯一注册号进行搜索更有用。
- en: Interestingly, PlaneFinder may report a small number of positions reported by
    a single aircraft when queried. This is due to near-constant position reports
    being sent from aircraft in flight. What this means for us is that when searching
    by an aircraft’s unique registration number within currently reported positions,
    we may actually retrieve 1+ position reports for that flight.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，PlaneFinder在查询时可能会报告单个飞机发送的少量位置。这是由于正在飞行的飞机几乎不间断地发送位置报告。对于我们来说，这意味着当根据飞机的唯一注册号在当前报告的位置中进行搜索时，实际上我们可能会检索到该航班的1+位置报告。
- en: 'There are various ways to write a search mechanism with flexibility to accept
    different search criteria of different types returning different numbers of potential
    results, but I chose to incorporate all options within a single method:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以编写具有灵活性的搜索机制，以接受不同类型的不同搜索条件，并返回不同数量的潜在结果，但我选择将所有选项合并到单个方法中：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The final (for now) version of the `PositionController` class should look something
    like this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最终（暂时）版本的`PositionController`类应该如下所示：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, I return to the `PositionService` class. As mentioned earlier, its `public
    Flux<Aircraft> getAircraftByReg(String reg)` method references a currently undefined
    method in `AircraftRepository`. To fix that, I add a `Flux<Aircraft>` `findAircraftByReg(String
    reg)` method to the `AircraftRepository` interface definition:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我回到`PositionService`类。正如前面提到的，它的`public Flux<Aircraft> getAircraftByReg(String
    reg)`方法引用了`AircraftRepository`中当前未定义的方法。为了解决这个问题，我在`AircraftRepository`接口定义中添加了一个`Flux<Aircraft>`
    `findAircraftByReg(String reg)`方法：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This interesting bit of code, this single method signature, demonstrates the
    powerful Spring Data concept of query derivation using a set of widely applicable
    conventions: operators like `find`, `search`, or `get`, the specified type of
    objects stored/retrieved/managed (in this case `Aircraft`), and member variable
    names like `reg`. By declaring a method signature with parameters+types and return
    type using the method naming conventions mentioned, Spring Data can build the
    method implementation for you.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这段有趣的代码，这个单一的方法签名，展示了使用一组广泛适用的约定的强大Spring Data概念：像`find`、`search`或`get`这样的操作符，存储/检索/管理的对象类型（在本例中为`Aircraft`），以及成员变量名称如`reg`。通过使用参数+类型和返回类型声明方法签名，并使用提到的方法命名约定，Spring
    Data可以为您构建方法实现。
- en: If you want or need to provide more specifics or hints, it’s also possible to
    annotate the method signature with `@Query` and supply desired or required details.
    That isn’t necessary for this case, as stating we wish to search aircraft positions
    by registration number and return 0+ values in a reactive streams `Flux` is ample
    information for Spring Data to create the implementation.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望或需要提供更多具体或提示，也可以注释方法签名，并提供所需的细节。对于这种情况并不需要，因为声明我们希望通过注册号搜索飞机位置，并在响应式流`Flux`中返回0+值就足够Spring
    Data创建实现。
- en: Returning to `PositionService`, the IDE now happily reports `repo.findAircraftByReg(reg)`
    as a valid method call.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`PositionService`，IDE现在高兴地报告`repo.findAircraftByReg(reg)`是一个有效的方法调用。
- en: Note
  id: totrans-44
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Another design decision I made for this example was to have both `getAircraftByXxx`
    methods query the current position documents. This may be considered to assume
    some position documents exist in the database or that the user isn’t concerned
    with a fresh retrieval if the database doesn’t already contain any positions within.
    Your requirements may drive a different choice, such as verifying some positions
    are present prior to searching and if not executing a fresh retrieval with a call
    to `getAllAircraft`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我为这个示例做出的另一个设计决策是让`getAircraftByXxx`方法都查询当前位置文档。这可能被认为假定数据库中存在一些位置文档，或者用户对如果数据库中尚未包含任何位置不感兴趣的情况。您的需求可能推动做出不同的选择，例如在搜索之前验证某些位置是否存在，并且如果不存在，则执行一个使用`getAllAircraft`调用进行新的检索。
- en: And Now, the Testing
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现在，进行测试
- en: In the earlier chapter on testing, standard `Object` types were used to test
    expected outcomes. I did use `WebClient` and `WebTestClient`, but only as the
    tool of choice for interacting with all HTTP-based endpoints, regardless of whether
    they returned reactive streams publisher types or not. Now, it’s time to properly
    test those reactive streams semantics.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期的测试章节中，使用了标准的`Object`类型来测试预期结果。我确实使用了`WebClient`和`WebTestClient`，但只作为与所有基于HTTP的端点交互的首选工具，无论它们是否返回响应式流发布者类型。现在，是时候正确测试这些响应式流语义了。
- en: 'Using the existing `PositionControllerTest` class as a starting point, I retool
    it to accommodate the new reactive endpoints exposed by its counterpart class
    `PositionController`. Here are the class-level details:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我将现有的`PositionControllerTest`类作为起点，重新调整以适应其对应类`PositionController`公开的新的响应式端点。以下是类级别的细节：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: First, I make the class-level annotation `@WebFluxTest(controllers = {PositionController.class})`.
    I still use the reactive `WebTestClient` and wish to restrict the scope of this
    test class to WebFlux capabilities, so loading a full Spring Boot application
    context is unnecessary and wasteful of time and resources.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我使用类级别的注解`@WebFluxTest(controllers = {PositionController.class})`。我仍然使用响应式的`WebTestClient`，并希望将此测试类的范围限制在WebFlux功能范围内，因此加载完整的Spring
    Boot应用程序上下文是不必要且浪费时间和资源的。
- en: Second, I autowire a `WebTestClient` bean. In the earlier chapter on testing,
    I directly injected the `WebTestClient` bean into a single test method, but since
    it now will be needed in multiple methods, it makes more sense to create a member
    variable from which to reference it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我自动装配了一个`WebTestClient` bean。在早期关于测试的章节中，我直接将`WebTestClient` bean注入到单个测试方法中，但由于现在它将在多个方法中需要使用，因此创建一个成员变量来引用它更加合理。
- en: Third, I create mock beans using Mockito’s `@MockBean` annotation. I mock the
    `RSocketRequester` bean simply because `PositionController`—which we request (and
    need) to be loaded in the class-level annotation—requires a bean, real or mocked,
    of an `RSocketRequester`. I mock the `PositionService` bean in order to mock and
    use its behavior within this class’s tests. Mocking `PositionService` allows me
    to assure its proper behavior, exercise a consumer of its outputs (`PositionController`),
    and compare the actual results with known expected results.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 第三步，我使用Mockito的`@MockBean`注解创建了模拟Bean。我简单地模拟了`RSocketRequester` bean，因为`PositionController`需要一个`RSocketRequester`
    bean，无论是真实的还是模拟的。我模拟了`PositionService` bean，以便在这个类的测试中模拟并使用其行为。模拟`PositionService`允许我确保其正确行为，同时测试其输出（`PositionController`），并将实际结果与预期结果进行比较。
- en: Finally, I create three `Aircraft` instances for use in the contained tests.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我创建了三个`Aircraft`实例用于包含的测试中。
- en: 'Prior to executing a JUnit `@Test` method, a method annotated with `@BeforeEach`
    is run to configure the scenario and expected results. This is the `setUp()` method
    I use to prepare the testing environment before each test method:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行JUnit的`@Test`方法之前，会运行一个使用`@BeforeEach`注解的方法来配置场景和预期结果。这是我在每个测试方法之前使用的`setUp()`方法，用于准备测试环境：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: I assign an aircraft position for the aircraft with registration N12345 to the
    `ac1` member variable. For `ac2` and `ac3`, I assign positions very close to each
    other for the same aircraft, N54321, simulating a frequent case of closely updated
    position reports arriving from PlaneFinder.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我为注册号为N12345的飞机分配了飞机位置给`ac1`成员变量。对于`ac2`和`ac3`，我为同一架飞机N54321分配了非常接近的位置，模拟了从PlaneFinder接收到频繁更新的位置报告的常见情况。
- en: The last several lines of the `setUp()` method define the behavior that the
    `PositionService` mock bean will provide when its methods are called in various
    ways. Similar to the method mocks in the earlier chapter on testing, the only
    difference of import is the types of return values; since the actual `PositionService`
    methods return Reactor `Publisher` types of `Flux` and `Mono`, so must the mock
    methods.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`setUp()`方法的最后几行定义了`PositionService`模拟Bean在不同方式调用其方法时将提供的行为。与早期关于测试的方法模拟类似，唯一的重要区别在于返回值的类型；因为实际的`PositionService`方法返回Reactor的`Publisher`类型的`Flux`和`Mono`，所以模拟方法也必须如此。'
- en: Test for retrieving all aircraft positions
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试以检索所有飞机位置为目的。
- en: 'Finally, I create a method to test the `PositionController` method `getCurrentACPositions()`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我创建了一个方法来测试`PositionController`的方法`getCurrentACPositions()`：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Testing reactive streams applications can bring myriad challenges to what is
    often considered a pretty mundane (if prone to omission) effort of setting expected
    results, obtaining actual results, and comparing the two to determine test success
    or failure. Though multiple results *can* be obtained in an effectively instantaneous
    manner, just as with a blocking type of `Iterable`, reactive streams `Publishers`
    don’t wait for a complete result set prior to returning it as a single unit. From
    a machine perspective, it’s the difference between receiving one group of five
    all at once (for example) or receiving five results very quickly, but individually.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 测试响应式流应用程序可能带来多种挑战，通常被认为是设置预期结果、获取实际结果并比较二者以确定测试成功或失败的一个相当乏味（如果容易遗漏）的努力。尽管可以有效地即时获取多个结果，就像阻塞类型的`Iterable`一样，响应式流`Publishers`并不等待完整的结果集再返回为一个单一单元。从机器的角度来看，这就是一次性接收一组五个结果（例如）或非常快速地接收五个结果，但是单独接收的差异。
- en: 'The core of Reactor’s testing tools is the `StepVerifier` and its utility methods.
    `StepVerifier` subscribes to a `Publisher` and, as the name implies, enables the
    developer to consider results obtained as discrete values and verify each one.
    In the test for `getCurrentACPositions`, I perform the following actions:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Reactor测试工具的核心是`StepVerifier`及其实用方法。`StepVerifier`订阅`Publisher`，正如其名称所示，使开发人员能够将获得的结果视为离散值并逐个验证。在对`getCurrentACPositions`的测试中，我执行以下操作：
- en: Create a `StepVerifier`.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`StepVerifier`。
- en: 'Supply it a `Flux` produced by the following steps:'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供由以下步骤产生的`Flux`：
- en: Use the `WebTestClient` bean.
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`WebTestClient` bean。
- en: Access the `PositionController::getCurrentACPositions` method mapped to the
    */acpos* endpoint.
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问映射到*/acpos*端点的`PositionController::getCurrentACPositions`方法。
- en: Initiate the `exchange()`.
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化`exchange()`。
- en: Verify a response status of `200 OK`.
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证`200 OK`的响应状态。
- en: Verify the response header has a content type of “application/json”.
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证响应头具有“application/json”的内容类型。
- en: Return the result items as instances of the `Aircraft` class.
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以`Aircraft`类的实例形式返回结果项。
- en: GET the response.
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取响应。
- en: Evaluate the actual first value against the expected first value `ac1`.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估实际的第一个值与预期的第一个值`ac1`。
- en: Evaluate the actual second value against the expected second value `ac2`.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估实际的第二个值与预期的第二个值`ac2`。
- en: Evaluate the actual third value against the expected third value `ac3`.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估实际的第三个值与预期的第三个值`ac3`。
- en: Verify all actions and receipt of `Publisher` completion signal.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证所有操作并接收`Publisher`完成信号。
- en: 'This is quite an exhaustive evaluation of expected behavior, including conditions
    and values returned. Running the test results in output similar to the following
    (trimmed to fit page):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对预期行为的相当详尽评估，包括条件和返回值。运行测试的结果输出类似于以下内容（已修剪以适应页面）：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Run from the IDE, the result will look similar to that shown in [Figure 12-1](#successful_test).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 从IDE运行，结果将类似于在[图12-1](#successful_test)中显示的内容。
- en: '![sbur 1201](Images/sbur_1201.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![sbur 1201](Images/sbur_1201.png)'
- en: Figure 12-1\. Successful test
  id: totrans-80
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图12-1\. 成功的测试
- en: Testing Aircraft Positions search capabilities
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试飞机位置搜索功能
- en: Testing the search functionality within `PositionController::searchForACPosition`
    requires a minimum of two separate tests due to the ability to handle searches
    for aircraft positions by database document ID and aircraft registration numbers.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PositionController::searchForACPosition`内测试搜索功能至少需要进行两个单独的测试，因为能够通过数据库文档ID和飞机注册号处理飞机位置搜索。
- en: 'To test searching by database document identifier, I create the following unit
    test:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试通过数据库文档标识符搜索，我创建了以下单元测试：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is similar to the unit test for all aircraft positions. There are two
    notable exceptions:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这与所有飞机位置的单元测试类似。有两个显著的例外：
- en: The specified URI references the search endpoint and includes the search parameter
    `id=1` to retrieve `ac1`.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定的URI引用搜索端点，并包括搜索参数`id=1`以检索`ac1`。
- en: The expected result is only `ac1`, as indicated in the `expectNext(ac1)` chained
    operation.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预期结果仅为`ac1`，如`expectNext(ac1)`链式操作中所示。
- en: 'To test searching for aircraft positions by an aircraft registration number,
    I create the following unit test, using a registration that I’ve mocked to include
    two corresponding position documents:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试通过飞机注册号搜索飞机位置，我创建了以下单元测试，使用我模拟的注册号，包括两个对应的位置文档：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The differences between this test and the previous one are minimal:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试与前一个测试之间的差异很小：
- en: The URI includes the search parameter `reg=N54321` and should result in the
    return of both `ac2` and `ac3`, both of which contain reported positions for the
    aircraft with registration number N54321.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URI 包含搜索参数 `reg=N54321`，应返回`ac2`和`ac3`，它们都包含了注册编号为N54321的飞机的报告位置。
- en: Expected results are verified to be `ac2` and `ac3` with the `expectNext(ac2)`
    and `expectNext(ac3)` chained operations.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预期结果被验证为`ac2`和`ac3`，使用 `expectNext(ac2)` 和 `expectNext(ac3)` 连接操作。
- en: 'The final state of the `PositionControllerTest` class is shown in the following
    listing:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的清单展示了`PositionControllerTest`类的最终状态：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Executing all tests within the `PositionControllerTest` class provides the gratifying
    results shown in [Figure 12-2](#successful_execution_of_all_unit_tests).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PositionControllerTest`类中执行所有测试会得到令人满意的结果，如[图12-2](#successful_execution_of_all_unit_tests)所示。
- en: '![sbur 1202](Images/sbur_1202.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![sbur 1202](Images/sbur_1202.png)'
- en: Figure 12-2\. Successful execution of all unit tests
  id: totrans-97
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图12-2\. 所有单元测试成功执行
- en: Note
  id: totrans-98
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '`StepVerifier` enables more testing possibilities, a few of which have been
    hinted at in this section. Of particular interest is the `StepVerifier::withVirtualTime`
    method that enables tests of publishers that emit values sporadically to be compressed,
    producing results instantaneously that might ordinarily be spaced over extensive
    periods of time. `StepVerifier::withVirtualTime` accepts a `Supplier<Publisher>`
    instead of a `Publisher` directly, but otherwise the mechanics of its use are
    quite similar.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`StepVerifier` 提供了更多的测试可能性，本节已经示意了其中一部分。特别值得关注的是 `StepVerifier::withVirtualTime`
    方法，它可以压缩偶尔发出值的发布者的测试，使得通常会在很长时间内分布的结果立即呈现。`StepVerifier::withVirtualTime` 接受一个
    `Supplier<Publisher>` 而不是直接的 `Publisher`，但其使用机制相当类似。'
- en: These are essential elements of testing reactive Spring Boot applications. But
    what happens when you encounter issues in production? What tools does Reactor
    offer for identification and resolution of issues when your app goes live?
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是测试响应式Spring Boot应用的基本要素。但是，当您在生产环境中遇到问题时会发生什么？当您的应用程序上线时，Reactor 提供了哪些工具来识别和解决问题？
- en: Diagnosing and Debugging Reactive Applications
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 诊断和调试响应式应用
- en: 'When things go sideways in typical Java applications, there is usually a stacktrace.
    A useful (if sometimes voluminous) stacktrace can be produced by imperative code
    for several reasons, but at a high level, two factors enable this helpful information
    to be collected and shown:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当传统的Java应用程序出现问题时，通常会有一个堆栈跟踪。命令式代码可以出于多种原因生成有用的（有时冗长的）堆栈跟踪，但在高层次上，有两个因素使得可以收集和显示这些有用信息：
- en: Sequential execution of code that typically dictates how to do something (imperative)
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码的顺序执行通常决定了如何执行某些操作（命令式）
- en: Execution of that sequential code occurs within a single thread
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该顺序代码的执行发生在单个线程内
- en: 'There are exceptions to every rule, but generally speaking, this is the common
    combination that allows for the capture of steps executed sequentially up to the
    time an error was encountered: everything happens one step at a time in a single
    swimlane. It may not leverage full system resources as effectively, and it generally
    doesn’t, but it makes isolating and resolving issues a much simpler affair.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 规则总有例外，但一般来说，这是允许捕获到发生错误的时间点之前顺序执行的步骤的常见组合：所有操作都在单一的泳道中一步步地执行。它可能不会有效地利用系统资源，通常情况下确实不会，但这使得隔离和解决问题变得更加简单。
- en: Enter reactive streams. Project Reactor and other reactive streams implementations
    use schedulers to manage and use those other threads. Resources that would typically
    have remained idle or underutilized can be put to work to enable reactive applications
    to scale far beyond their blocking counterparts. I would refer you to the [Reactor
    Core documentation](https://projectreactor.io/docs/core/release/reference) for
    more details regarding `Schedulers` and the options available for controlling
    how they can be used and tuned, but suffice it to say for now that Reactor does
    a fine job handling scheduling automatically in the vast majority of circumstances.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 进入响应式流。Project Reactor 和其他响应式流实现使用调度程序来管理和使用其他线程。通常会保持空闲或低效的资源可以被利用起来，以使得响应式应用能够远远超越其阻塞对应物而扩展。关于如何控制和调整
    `Schedulers` 的选项以及它们可以如何使用的更多详细信息，我建议您查阅[Reactor Core文档](https://projectreactor.io/docs/core/release/reference)，但目前可以简单地说，Reactor
    在绝大多数情况下都可以很好地自动处理调度。
- en: This does highlight one challenge with producing a meaningful execution trace
    for a reactive Spring Boot (or any reactive) application, however. One can’t expect
    to simply follow a single thread’s activity and produce a meaningful sequential
    list of code executed.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这确实突显了为响应式 Spring Boot（或任何响应式）应用程序生成有意义的执行跟踪的一个挑战。人们不能指望简单地跟随单个线程的活动并生成有意义的顺序代码执行列表。
- en: Compounding the difficulty of tracing execution due to this thread-hopping optimizing
    feature is that reactive programming separates code *assembly* from code *execution*.
    As mentioned in [Chapter 8](ch08.xhtml#sbur-08), in most cases for most `Publisher`
    types, nothing happens until you *subscribe*.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种线程跳转优化特性，追踪执行的难度增加了，这使得响应式编程将代码 *组装* 与代码 *执行* 分开。正如在 [第 8 章](ch08.xhtml#sbur-08)
    中提到的，在大多数情况下对于大多数 `Publisher` 类型，直到 *订阅* 之前什么也不会发生。
- en: 'Simply put, it’s unlikely that you will ever see a production failure that
    points to an issue with the code where you declaratively assembled the `Publisher`
    (whether `Flux` or `Mono`) pipeline of operations. Failures nearly universally
    occur at the point the pipeline becomes active: producing, processing, and passing
    values to a `Subscriber`.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，几乎不太可能看到生产故障指向您在声明式组装 `Publisher`（无论是 `Flux` 还是 `Mono`）操作流水线的代码的问题。故障几乎普遍发生在流水线变得活跃时：产生、处理和传递值给
    `Subscriber`。
- en: This distancing between code assembly and execution and Reactor’s ability to
    utilize multiple threads to complete a chain of operations necessitates better
    tooling to effectively troubleshoot errors that surface at runtime. Fortunately,
    Reactor provides several excellent options.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于代码组装与执行之间的距离以及 Reactor 利用多线程完成操作链的能力，需要更好的工具来有效地排查运行时出现的错误。幸运的是，Reactor 提供了几个优秀的选择。
- en: Hooks.onOperatorDebug()
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Hooks.onOperatorDebug()
- en: This is not to imply that troubleshooting reactive applications using existing
    stacktrace results is impossible, only that it could be significantly improved
    upon. As with most things, the proof is in the code—or in this case, the logged,
    post failure output.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着使用现有堆栈跟踪结果无法解决反应性应用程序的故障排除问题，只是可以显著改进。就像大多数事物一样，证据在于代码——或者在这种情况下，记录的失败输出。
- en: 'To simulate a failure in a reactive `Publisher` chain of operators, I revisit
    the `PositionControllerTest` class and change one line of code in the `setUp()`
    method run before each test’s execution:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟反应式 `Publisher` 操作链的故障，我重新访问了 `PositionControllerTest` 类，并在每次测试执行前运行的 `setUp()`
    方法中更改了一行代码：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'I replace the properly operating `Flux` produced by the mock `getAllAircraft()`
    method with one that includes an error in the resultant stream of values:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我用包含结果流中错误的方式替换了由模拟 `getAllAircraft()` 方法生成的正常运行的 `Flux`：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, I execute the test for `getCurrentACPositions()` to see the results of
    our intentional `Flux` sabotage (wrapped to fit page):'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我执行 `getCurrentACPositions()` 的测试，以查看我们故意对 `Flux` 进行破坏的结果（包装以适应页面）：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, the volume of information for a single bad value is quite difficult
    to digest. Useful information is present, but it’s overwhelmed by excessive, less-helpful
    data.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，单个错误值的信息量相当难以消化。存在有用的信息，但它被过多、不太有用的数据所淹没。
- en: Note
  id: totrans-120
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: I reluctantly but deliberately included the full output resulting from the preceding
    `Flux` error to show how difficult it can be to navigate the usual output when
    a `Publisher` encounters an error and to contrast it with how dramatically available
    tools reduce the noise and boost the signal of key information. Getting to the
    core of the problem reduces frustration in development, but it is absolutely critical
    when troubleshooting business-critical applications in production.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我勉强但有意地包含了上述 `Flux` 错误产生的完整输出，以显示当 `Publisher` 遇到错误时导航通常输出的困难，以及如何通过有效的工具显著降低噪音并增强关键信息的信号。找到问题的核心不仅减少了开发中的挫折感，而且在生产中故障排除业务关键应用程序时绝对至关重要。
- en: Project Reactor includes configurable life cycle callbacks called *hooks*, available
    via its `Hooks` class. One operator that is particularly useful for increasing
    the signal to noise ratio when things go awry is `onOperatorDebug()`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Project Reactor 包含可通过其 `Hooks` 类调用的可配置生命周期回调 *hooks*。其中一个特别有用的操作符，在事情出错时提高信噪比的是
    `onOperatorDebug()`。
- en: 'Calling `Hooks.onOperatorDebug()` prior to instantiation of the failing `Publisher`
    enables assembly-time instrumentation of all subsequent instances of type `Publisher`
    (and subtypes). In order to ensure capture of the necessary information at the
    necessary time(s), the call is usually placed in the application’s main method
    as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在实例化失败的`Publisher`之前调用`Hooks.onOperatorDebug()`使得所有后续`Publisher`类型（及其子类型）的汇编时间仪表化成为可能。为了确保在必要的时间捕获必要的信息，通常将调用放置在应用程序的主方法中，如下所示：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Since I am demonstrating this capability from a test class, I instead insert
    `Hooks.onOperatorDebug();` on the line immediately preceding assembly of the intentionally
    failing `Publisher`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我是从测试类演示此功能，我在故意失败的`Publisher`组装之前的一行插入了`Hooks.onOperatorDebug();`：
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This single addition doesn’t eliminate the somewhat voluminous stacktrace—there
    are still rare occasions in which any additional bit of data provided can be helpful—but
    for the vast majority of cases, the tree summary added to the log by `onOperatorDebug()`
    as a backtrace results in faster issue identification and resolution. The backtrace
    summary for the same error I introduced in the `getCurrentACPositions()` test
    is shown in [Figure 12-3](#debugging_backtrace) in order to preserve full details
    and formatting.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个单独的添加并没有消除有点冗长的堆栈跟踪—尽管还有偶尔提供任何额外数据的情况下可能有所帮助—但是对于大多数情况，由`onOperatorDebug()`添加到日志的树摘要结果使得更快地识别和解决问题。为了保留完整的细节和格式，我在`getCurrentACPositions()`测试中引入的相同错误的回溯摘要显示在图[12-3](#debugging_backtrace)中。
- en: '![sbur 1203](Images/sbur_1203.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![sbur 1203](Images/sbur_1203.png)'
- en: Figure 12-3\. Debugging backtrace
  id: totrans-129
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图12-3\. 调试回溯
- en: 'At the top of the tree is the incriminating evidence: a `Flux` error has been
    introduced using `concatWith` on line 68 of `PositionControllerTest.java`. Thanks
    to `Hooks.onOperatorDebug()`, the time it took to identify this issue and its
    specific location has been reduced from several minutes (or more) to a few seconds.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在树的顶部是证据：在`PositionControllerTest.java`的第68行使用`concatWith`引入了`Flux`错误。由于`Hooks.onOperatorDebug()`的帮助，识别此问题及其具体位置所花费的时间从几分钟（甚至更多）减少到几秒钟。
- en: Instrumenting all assembly instructions for all subsequent `Publisher` occurrences
    doesn’t come without a cost, however; using hooks to instrument your code is relatively
    runtime-expensive, as debug mode is global and impacts every chained operator
    of every reactive streams `Publisher` executed once enabled. Let’s consider another
    alternative.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了所有后续`Publisher`出现的所有汇编指令仪表化，这种单个添加并不是没有成本的；然而，使用钩子来仪表化您的代码在运行时相对昂贵，因为调试模式是全局的，并且在启用后会影响每个响应流`Publisher`的每个链接操作符。让我们考虑另一种选择。
- en: Checkpoints
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查点
- en: Rather than populate every possible backtrace of every possible `Publisher`,
    one can set checkpoints near key operators to assist with troubleshooting. Inserting
    a `checkpoint()` operator into the chain works like enabling a hook but only for
    that segment of that chain of operators.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 与其填充每个可能的`Publisher`的每个可能的回溯，不如在关键运算符附近设置检查点以协助故障排除。将`checkpoint()`运算符插入链中的工作方式类似于启用钩子，但仅适用于该操作符链的该段。
- en: 'There are three variants of checkpoints:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种检查点变体：
- en: Standard checkpoints that include a backtrace
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包括回溯的标准检查点
- en: Light checkpoints that accept a descriptive `String` parameter and do not include
    backtrace
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受描述性`String`参数并且不包括回溯的轻量检查点
- en: Standard checkpoints with backtrace that also accept a descriptive `String`
    parameter
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包括回溯的标准检查点，也接受描述性`String`参数
- en: Let’s see them in action.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它们的实际表现。
- en: 'First, I remove the `Hooks.onOperatorDebug()` statement before the mocked method
    for `PositionService::getAllAircraft` in the `setUp() method within `PositionControllerTest`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`PositionControllerTest`中的`setUp()`方法中为`PositionService::getAllAircraft`的模拟方法之前，我删除了`Hooks.onOperatorDebug()`语句：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Rerunning the test for `getCurrentACPositions()` produces the results shown
    in [Figure 12-4](#standard_checkpoint_output).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行`getCurrentACPositions()`的测试会生成图[12-4](#standard_checkpoint_output)中显示的结果。
- en: '![sbur 1204](Images/sbur_1204.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![sbur 1204](Images/sbur_1204.png)'
- en: Figure 12-4\. Standard checkpoint output
  id: totrans-143
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图12-4\. 标准检查点输出
- en: 'The checkpoint at the top of the list directs us to the problematic operator:
    the one immediately preceding the triggered checkpoint. Note that backtrace information
    is still being collected, as the checkpoint reflects the actual source code file
    and specific line number for the checkpoint I inserted on line 64 of the `PositionControllerTest`
    class.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 列表顶部的检查点指导我们找到了问题运算符：即触发检查点之前的那个。请注意，仍在收集回溯信息，因为检查点反映了我在`PositionControllerTest`类的第64行插入的实际源代码文件和特定行号。
- en: 'Switching to lightweight checkpoints replaces the collection of backtrace information
    with a useful `String` description specified by the developer. While backtrace
    collection for standard checkpoints is limited in scope, it still requires resources
    beyond the simple storage of a `String`. If done with sufficient detail, light
    checkpoints provide the same utility in locating problematic operators. Updating
    the code to leverage light checkpoints is a simple matter:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到轻量级检查点将回溯信息收集替换为开发者指定的有用的`String`描述。虽然标准检查点的回溯收集范围有限，但仍需要比简单存储`String`更多的资源。如果以足够详细的方式完成，轻量级检查点可以提供定位问题运算符的同样实用性。更新代码以利用轻量级检查点是一件简单的事情：
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Re-running the `getCurrentACPositions()` test produces the results shown in
    [Figure 12-5](#light_checkpoint_output).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行`getCurrentACPositions()`测试将产生如[图 12-5](#light_checkpoint_output)所示的结果。
- en: '![sbur 1205](Images/sbur_1205.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![sbur 1205](Images/sbur_1205.png)'
- en: Figure 12-5\. Light checkpoint output
  id: totrans-149
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-5\. 轻量级检查点输出
- en: Although file and line number coordinates are no longer present in the top-listed
    checkpoint, its clear description makes it easy to find the problem operator in
    the `Flux` assembly.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然文件和行号坐标不再出现在列表中排名第一的检查点中，但其清晰的描述使得在`Flux`组装中找到问题运算符变得容易。
- en: 'Occasionally there will be a requirement to employ an extremely complex chain
    of operators to build a `Publisher`. In those circumstances, it may be useful
    to include both a description and full backtrace information for troubleshooting.
    To demonstrate a very limited example, I refactor the mock method used for `PositionService::getAllAircraft`
    once more as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 偶尔会需要使用一系列极其复杂的运算符来构建一个`Publisher`。在这些情况下，包含故障排除的描述和完整的回溯信息可能会很有用。为了演示一个非常有限的例子，我再次重构了用于`PositionService::getAllAircraft`的模拟方法如下：
- en: '[PRE21]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Running the `getCurrentACPositions()` test once again results in the output
    shown in [Figure 12-6](#standard_checkpoint_with_description_output).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行`getCurrentACPositions()`测试将导致输出如[图 12-6](#standard_checkpoint_with_description_output)所示。
- en: '![sbur 1206](Images/sbur_1206.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![sbur 1206](Images/sbur_1206.png)'
- en: Figure 12-6\. Standard checkpoint with description output
  id: totrans-155
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-6\. 带有描述输出的标准检查点
- en: ReactorDebugAgent.init()
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ReactorDebugAgent.init()
- en: There is a way to realize the benefits of full backtracing for all `Publishers`
    within an application—like that produced using hooks—without the performance penalties
    imposed by enabling debugging using those same hooks.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种方法可以实现在应用程序中为所有`Publishers`获得完整回溯的好处，就像使用钩子生成的那样，而无需启用调试功能所带来的性能损失。
- en: Within the Reactor project is a library called `reactor-tools` that includes
    a separate Java agent used to instrument a containing application’s code. `reactor-tools`
    adds debugging information to the application and attaches to the running application
    (of which it is a dependency) to track and trace execution of every subsequent
    `Publisher`, providing the same kind of detailed backtrace information as hooks
    with nearly zero performance impact. As such, there are few if any downsides and
    numerous upsides to running reactive applications in production with `ReactorDebugAgent`
    enabled.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在Reactor项目中有一个名为`reactor-tools`的库，其中包括一个单独的Java代理用于为包含应用程序的代码添加调试信息。 `reactor-tools`向应用程序添加调试信息，并连接到运行中的应用程序（它是一个依赖项），以跟踪每个后续的`Publisher`的执行，提供几乎零性能影响的详细回溯信息，类似于使用钩子。因此，在生产环境中启用`ReactorDebugAgent`后，几乎没有什么坏处，而且有很多好处。
- en: 'As a separate library, `reactor-tools` must be manually added to an application’s
    build file. For the Aircraft Positions application’s Maven *pom.xml*, I add the
    following entry:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个独立的库，`reactor-tools`必须手动添加到应用程序的构建文件中。对于飞行器位置应用程序的Maven *pom.xml*，我添加了以下条目：
- en: '[PRE22]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: After saving the updated *pom.xml*, I refresh/reimport the dependencies to gain
    access to the `ReactorDebugAgent` within the project.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在保存更新的*pom.xml*后，我刷新/重新导入依赖项，以便在项目中使用`ReactorDebugAgent`。
- en: 'Like `Hooks.onOperatorDebug()`, the `ReactorDebugAgent` is typically initialized
    in the application’s main method prior to running the app. Since I will be demonstrating
    this within a test that doesn’t load the full application context, I insert the
    initialization call just as I did `Hooks.onOperatorDebug()`, immediately before
    constructing the `Flux` used to demonstrate a runtime execution error. I also
    remove the now-unnecessary calls to `checkpoint()`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于`Hooks.onOperatorDebug()`，`ReactorDebugAgent`通常在应用程序的主方法中初始化，然后再运行应用程序。由于我将在一个不加载完整应用程序上下文的测试中演示这一点，我会像之前使用`Hooks.onOperatorDebug()`一样在构建用于演示运行时执行错误的`Flux`之前立即插入初始化调用。我还删除了现在不再需要的`checkpoint()`调用：
- en: '[PRE23]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Returning once again to the `getCurrentACPositions()` test, I run it and am
    treated to the summary tree output shown in [Figure 12-7](#reactordebugagent_ouput_resulting_from_flux_error)
    , which is similar to that provided by `Hooks.onOperatorDebug()` but without runtime
    penalty:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 再次回到`getCurrentACPositions()`测试，我运行它并得到了类似于由`Hooks.onOperatorDebug()`提供的摘要树输出的总结，但没有运行时惩罚：
- en: '![sbur 1207](Images/sbur_1207.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![sbur 1207](Images/sbur_1207.png)'
- en: Figure 12-7\. ReactorDebugAgent output resulting from `Flux` error
  id: totrans-166
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图12-7\. 由`Flux`错误导致的ReactorDebugAgent输出
- en: Other tools are available that don’t directly help test or debug reactive applications
    but that nevertheless help to improve application quality. One example is [BlockHound](https://github.com/reactor/BlockHound),
    which, although outside the scope of this chapter, can be a useful tool for determining
    if blocking calls are hidden within your application’s code or its dependencies.
    And, of course, these and other tools are evolving and maturing rapidly to provide
    numerous ways to level up your reactive applications and systems.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他工具可用，虽然它们不直接帮助测试或调试响应式应用程序，但它们可以帮助提高应用程序质量。一个例子是[BlockHound](https://github.com/reactor/BlockHound)，尽管超出了本章的范围，但它可以成为确定应用程序代码或其依赖项中是否隐藏了阻塞调用的有用工具。当然，这些和其他工具正在快速演变和成熟，提供多种方式来提升您的响应式应用程序和系统。
- en: Code Checkout Checkup
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码检查
- en: For complete chapter code, please check out branch *chapter12end* from the code
    repository.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 对于完整的章节代码，请查看代码库中的*chapter12end*分支。
- en: Summary
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Reactive programming gives developers a way to make better use of resources
    in distributed systems, even extending powerful scaling mechanisms across application
    boundaries and into the communication channels. For developers with experience
    exclusively with mainstream Java development practices—often called *imperative*
    Java due to its explicit and sequential logic versus the more declarative approach
    generally used in reactive programming—these reactive capabilities may bear some
    undesired costs. In addition to the expected learning curve, which Spring helps
    flatten considerably due to parallel and complementary WebMVC and WebFlux implementations,
    there are also relative limitations in tooling, its maturity, and established
    practices for essential activities like testing, troubleshooting, and debugging.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程为开发人员提供了一种在分布式系统中更好地利用资源的方式，甚至将强大的扩展机制延伸到应用程序边界和通信渠道中。对于那些仅具有主流Java开发实践经验的开发人员——通常称为*命令式*Java，因为它采用显式和顺序逻辑，而不是响应式编程中通常使用的更声明式的方法——这些响应式能力可能带来一些不希望的成本。除了预期的学习曲线，Spring通过并行和互补的WebMVC和WebFlux实现大大降低了这些成本。此外，工具、成熟度和针对测试、故障排除和调试等基本活动的建立实践也存在相对限制。
- en: While it is true that reactive Java development is in its infancy relative to
    its imperative cousin, the fact that they are family has allowed a much faster
    development and maturation of useful tooling and processes. As mentioned, Spring
    builds similarly on established imperative expertise within its development and
    community to condense decades of evolution into production-ready components available
    *now*.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管响应式Java开发相对于其命令式兄弟处于起步阶段，但它们同属一个家族使得有可能更快地开发和成熟出有用的工具和流程。正如前文所述，Spring同样依赖于其在开发和社区中建立的成熟命令式专业知识，将数十年的演变凝结为现在可用的生产就绪组件。
- en: In this chapter, I introduced and elaborated on the current state of the art
    in testing and diagnosing/debugging issues you might encounter as you begin to
    deploy reactive Spring Boot applications. I then demonstrated how to put WebFlux/Reactor
    to work for you before and in production to test and troubleshoot reactive applications
    in various ways, showing relative advantages of each option available. You have
    a wealth of tools at your disposal even now, and the outlook is only getting better.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我介绍并详细阐述了测试、诊断和调试问题的当前技术状态，这些问题可能会在您开始部署响应式Spring Boot应用程序时遇到。我还演示了如何在生产环境中使用WebFlux/Reactor来为您工作，以多种方式测试和排查响应式应用程序，展示了每种可用选项的相对优势。即使现在，您已经有很多工具可供使用，而且前景只会变得更好。
- en: In this book, I had to choose which of the innumerable “best parts” of Spring
    Boot to cover in order to provide what I hope to be the best possible way to get
    up and running with Spring Boot. There is so much more, and I only wish I could
    have doubled (or trebled) the scope of the book to do so. Thank you for accompanying
    me on this journey; I hope to share more in future. Best to you in your continued
    Spring Boot adventures.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我不得不选择无数个“最佳部分”中的哪些来覆盖，以便以我希望的最佳方式入门并运行Spring Boot。还有很多内容，我只希望能将书的范围扩展一倍（或三倍）来涵盖更多内容。感谢您在这段旅程中的陪伴；我希望未来能分享更多。祝您在继续使用Spring
    Boot时一切顺利。
