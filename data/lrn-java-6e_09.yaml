- en: Chapter 9\. Threads
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章 线程
- en: We take for granted that modern computer systems can manage many applications
    and operating system (OS) tasks running concurrently and make it appear that all
    the software is running simultaneously. Most systems today have multiple processors
    or multiple cores or both, and they can achieve an impressive degree of concurrency.
    The OS still juggles applications at a higher level but turns its attention from
    one to the next so quickly that they also appear to run at once.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们理所当然地认为现代计算机系统可以同时管理许多应用程序和操作系统（OS）任务，并使所有软件看起来同时运行。今天大多数系统都配备了多个处理器或多个核心，有了这些，它们可以实现令人印象深刻的并发度。操作系统仍然在更高层次上调度应用程序，但是它的注意力转向下一个应用程序的速度如此之快，以至于它们也看起来在同时运行。
- en: Note
  id: totrans-2
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In programming, *concurrent* operation denotes multiple, typically unrelated
    tasks running at the same time. Think of a fast-food cook preparing multiple orders
    on a grill. *Parallel* operation usually involves breaking up a large task into
    related subtasks that can be run alongside each other to produce the final result
    more quickly. Our cook could prepare a bacon double cheeseburger “in parallel”
    by tossing two patties and some bacon on the grill at the same time. In either
    case, programmers talk more generally about these tasks and subtasks occurring
    *simultaneously*. That’s not to say everything starts and stops at the same exact
    instant, but it does mean that the execution times for those tasks overlap.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，*并发*操作表示多个通常不相关的任务同时运行。想象一下，一个快餐厨师在烤架上同时准备多份订单。*并行*操作通常涉及将一个大任务分解为相关的子任务，这些子任务可以并行运行以更快地产生最终结果。我们的厨师可以通过同时在烤架上放置两个肉饼和一些培根来“并行”准备一份双层芝士汉堡。无论哪种情况，程序员通常更广泛地讨论这些任务和子任务同时发生的情况。这并不意味着一切都在完全相同的瞬间开始和停止，但确实意味着这些任务的执行时间是重叠的。
- en: In the old days, the unit of concurrency for an operating system was the application
    or *process*. To the OS, a process was more or less a black box that decided what
    to do on its own. If an application required greater concurrency, it could get
    it only by running multiple processes and communicating between them, but this
    was a heavyweight approach and not very elegant.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在旧时，操作系统的并发单位是应用程序或*进程*。对于操作系统来说，一个进程或多或少是一个自行决定要做什么的黑盒子。如果一个应用程序需要更高的并发性，它只能通过运行多个进程并在它们之间进行通信来实现，但这是一种笨重的方法，不太优雅。
- en: Later, operating systems added the concept of threads. Conceptually, a *thread*
    is a flow of control within a program. (You may have heard of a “thread of execution,”
    for example.) Threads provide fine-grained concurrency within a process under
    the application’s own control. Threads have existed for a long time but have historically
    been tricky to use. The Java concurrency utilities address common patterns and
    practices in multithreaded applications and raise them to the level of tangible
    methods and classes. Collectively, this means that Java supports threading at
    both higher and lower levels.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 后来，操作系统引入了线程的概念。从概念上讲，*线程*是程序内的控制流。（例如，你可能听说过“执行线程”）线程在应用程序自己的控制下提供了细粒度的并发性。线程已经存在很长时间，但历来使用起来比较棘手。Java并发工具集解决了多线程应用程序中的常见模式和实践，并将它们提升到了可操作的方法和类的级别。总体来说，这意味着Java在更高和更低的层次上都支持线程。
- en: This broad support makes it easier for programmers to write multithreaded code,
    and for compilers and runtimes to optimize that code. It also means that Java’s
    APIs take full advantage of threading, so it’s important that you gain some degree
    of familiarity with these concepts early in your exploration of Java. Not all
    developers will need to write applications that explicitly use threads or concurrency,
    but most will use some feature that involves them.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这种广泛的支持使得程序员更容易编写多线程代码，并且使编译器和运行时可以对该代码进行优化。这也意味着Java的API充分利用了线程，因此在探索Java的早期阶段，熟悉这些概念至关重要。并非所有开发人员都需要编写明确使用线程或并发性的应用程序，但大多数人会使用涉及它们的某些功能。
- en: Threads are integral to the design of many Java APIs, especially those involved
    in client-side applications, graphics, and sound. For example, when we look at
    GUI programming in [Chapter 12](ch12.html#learnjava6-CHP-12), you’ll see that
    a component’s `paint()` method isn’t called directly by the application but rather
    by a separate drawing thread within the Java runtime system. At any given time,
    many such background threads may be performing activities alongside your application—yet
    you still get timely updates to your screen. On the server side, Java threads
    are there as well, servicing every request and running your application. It’s
    important to understand how your code fits into that environment.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 线程在许多 Java API 的设计中起着重要作用，特别是那些涉及客户端应用程序、图形和声音的部分。例如，在我们看 GUI 编程时的[第 12 章](ch12.html#learnjava6-CHP-12)，你会看到组件的`paint()`方法不是直接由应用程序调用，而是由
    Java 运行时系统内的一个单独的绘图线程调用。在任何给定时间，许多这样的后台线程可能会在你的应用程序旁边执行活动，但你仍然会及时更新屏幕。在服务器端，Java
    线程同样存在，为每个请求提供服务并运行你的应用程序。了解你的代码如何适应这种环境至关重要。
- en: In this chapter, we’ll talk about writing applications that create and use their
    own threads explicitly. We’ll talk about the low-level thread support built into
    the Java language first and then discuss the `java.util.concurrent` thread utilities
    package. We’ll also tackle the new virtual threads previewed in Java 19 under
    the moniker of Project Loom.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论编写显式创建和使用自己线程的应用程序。我们将首先讨论集成到Java语言中的低级线程支持，然后讨论`java.util.concurrent`线程实用工具包。我们还将讨论在Java
    19中预览的新虚拟线程，项目称为Project Loom。
- en: Introducing Threads
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入线程
- en: A thread is similar to the notion of a *process*, or running program, except
    that different threads within the same application are much more closely related
    and share much of the same state than different programs running on the same machine.
    It’s kind of like a golf course that many golfers use at the same time. The threads
    cooperate to share a working area. They take turns and wait for other threads.
    They have access to the same objects, including static and instance variables,
    within their application. However, threads have their own copies of local variables,
    just as players share the golf course or a golf cart but do not share clubs or
    balls.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 线程类似于*进程*或正在运行的程序的概念，不同的是，同一应用程序中的不同线程比同一台机器上运行的不同程序更密切相关，并且共享大部分相同的状态。这有点像许多高尔夫球手同时使用的高尔夫球场。线程协作以共享工作区域。它们轮流等待其他线程。它们可以访问相同的对象，包括其应用程序内的静态和实例变量。但是，线程拥有其自己的局部变量副本，就像球员共享高尔夫球场或高尔夫球车但不共享球棒或球一样。
- en: Multiple threads in an application have the same problems as golfers on a course—in
    a word, *synchronization*. Just as you can’t have two sets of players playing
    the same green at the same time, you can’t have several threads trying to access
    the same variables without some kind of coordination. Otherwise, someone is bound
    to get hurt. A thread can reserve the right to use an object until it’s finished
    with its task, just as a golf party gets exclusive rights to the green until each
    of that party’s players finishes. And a thread that is more important can raise
    its priority, asserting its right to “play through.”
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序中的多个线程面临与球场上高尔夫球手相同的问题，简言之，*同步*。就像不能同时有两组球员在同一绿地上打球一样，不能有多个线程尝试在没有某种协调的情况下访问相同的变量。否则，某些人可能会受伤。线程可以保留使用对象的权利，直到完成其任务，就像高尔夫聚会在每个球员完成比赛之前独占绿地。更重要的线程可以提高其优先级，断言其“优先通过”的权利。
- en: The devil is in the details, of course, and those details have long made threads
    difficult to use. Fortunately, Java makes creating, controlling, and coordinating
    threads simpler by integrating some of these concepts directly into the language.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，细节决定成败，长久以来，线程细节使其难以使用。幸运的是，Java通过直接将一些这些概念集成到语言中，使创建、控制和协调线程变得更简单。
- en: 'It’s common to stumble over threads when you first work with them. Creating
    a thread will exercise many of your new Java skills all at once. Just remember
    that two players are always involved in running a thread: a Java `Thread` object
    that represents the thread itself, and an arbitrary target object that contains
    the method the thread will execute. Later, we will see ways to combine these two
    roles, but those approaches just change the packaging, not the relationship.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次使用线程时，很容易会遇到困难。创建一个线程将同时练习你的新Java技能。只要记住在运行线程时始终涉及两个主要角色：一个Java `Thread`对象代表线程本身，以及一个包含线程将执行的方法的任意目标对象。稍后，我们将看到如何结合这两个角色，但这些方法只是改变了封装，而不是改变了它们的关系。
- en: The Thread Class and the Runnable Interface
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程类和可运行接口
- en: All execution in Java is associated with a `Thread` object, beginning with a
    “main” thread that the JVM starts to launch your application. A new thread is
    born when you create an instance of the `java.lang.Thread` class. The `Thread`
    object represents a real thread in the Java interpreter and serves as a handle
    for controlling and coordinating its execution. With it, you can start the thread,
    wait for it to complete, cause it to sleep for a time, or interrupt its activity.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，所有的执行都与一个`Thread`对象相关联，从JVM启动的“主”线程开始，用于启动你的应用程序。当你创建`java.lang.Thread`类的一个实例时，就会诞生一个新的线程。`Thread`对象表示Java解释器中的一个真实线程，并作为控制和协调其执行的句柄。通过它，你可以启动线程，等待它完成，使其休眠一段时间，或者中断其活动。
- en: The constructor for the `Thread` class accepts information about where the thread
    should begin its execution. We would like to tell it what method to run. There
    are a number of ways to do this. The classic approach uses the `java.lang.Runnable`
    interface to mark an object that contains a “runnable” method.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread`类的构造函数接受关于线程应该从哪里开始执行的信息。我们想告诉它要运行哪个方法。有很多方法可以做到这一点。经典的方法使用`java.lang.Runnable`接口来标记包含“可运行”方法的对象。'
- en: '`Runnable` defines a single, general-purpose `run()` method:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`Runnable`定义了一个单一的通用`run()`方法：'
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Every thread begins its life by executing the `run()` method in a `Runnable`
    object, which is the “target object” passed to the thread’s constructor. The `run()`
    method can contain any code, but it must be public, take no arguments, have no
    return value, and throw no checked exceptions.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 每个线程都通过执行`run()`方法来启动其生命周期，该方法位于一个`Runnable`对象中，这个对象是传递给线程构造函数的“目标对象”。`run()`方法可以包含任何代码，但必须是公共的，不接受任何参数，没有返回值，并且不会抛出已检查异常。
- en: Any class that contains an appropriate `run()` method can declare that it implements
    the `Runnable` interface. An instance of this class becomes a runnable object
    that can serve as the target of a new thread. If you don’t want to put the `run()`
    method directly in your object (and very often you don’t), you can always make
    an adapter class that serves as the `Runnable` for you. The adapter’s `run()`
    method can then call any method it wants after the thread is started. We’ll show
    examples of these options later.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 任何包含适当`run()`方法的类都可以声明实现`Runnable`接口。该类的一个实例成为一个可运行对象，可以作为新线程的目标。如果你不想直接将`run()`方法放在你的对象中（很多时候确实不想这样做），你总是可以创建一个作为你的`Runnable`的适配器类。适配器的`run()`方法可以在线程启动后调用任何它想要的方法。稍后我们会展示这些选项的示例。
- en: Creating and starting threads
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建和启动线程
- en: A newly born thread remains idle until we give it a figurative slap on the bottom
    by calling its `start()` method. The thread then wakes up and proceeds to execute
    the `run()` method of its target object. `start()` can be called only once in
    the lifetime of a thread. Once a thread starts, it continues running until the
    target object’s `run()` method either returns or throws an unchecked exception.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一个新生的线程保持空闲，直到我们通过调用其`start()`方法来唤醒它。线程随后醒来并继续执行其目标对象的`run()`方法。`start()`方法在线程的生命周期中只能调用一次。一旦线程启动，它会继续运行，直到目标对象的`run()`方法返回或抛出未检查异常。
- en: 'The following class, `Animator`, implements a `run()` method to drive a drawing
    loop. We could use something similar in our game to update the playing `Field`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的类`Animator`实现了一个`run()`方法来驱动绘图循环。我们可以在游戏中类似地使用它来更新游戏场地：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To use it, create a `Thread` object, pass it an instance of `Animator` as its
    target object, and invoke its `start()` method:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用它，创建一个`Thread`对象，将一个`Animator`的实例作为其目标对象传递给它，并调用其`start()`方法：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We created an instance of our `Animator` class and passed it as the argument
    to the constructor for `myThread`. As shown in [Figure 9-1](#learnjava6-CHP-9-FIG-1),
    when we call the `start()` method, `myThread` begins to execute `Animator`’s `run()`
    method.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了 `Animator` 类的一个实例，并将其作为参数传递给 `myThread` 的构造函数。正如在 [Figure 9-1](#learnjava6-CHP-9-FIG-1)
    中所示，当我们调用 `start()` 方法时，`myThread` 开始执行 `Animator` 的 `run()` 方法。
- en: '![ljv6 0901](assets/ljv6_0901.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0901](assets/ljv6_0901.png)'
- en: Figure 9-1\. Animator as an implementation of `Runnable`
  id: totrans-29
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-1\. 作为 `Runnable` 实现的动画师
- en: Let the show begin!
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让表演开始！
- en: A natural-born thread
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 天生的线程
- en: The `Runnable` interface lets you make an arbitrary object the target of a thread,
    as in the previous example. This is the most important general usage of the `Thread`
    class. In most situations where you need to use threads, you’ll create a class
    (possibly a simple adapter class) that implements the `Runnable` interface.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`Runnable` 接口允许你将任意对象作为线程的目标，就像前面的例子一样。这是 `Thread` 类最重要的通用用法。在大多数需要使用线程的情况下，你会创建一个类（可能是一个简单的适配器类），该类实现了
    `Runnable` 接口。'
- en: 'Another design option for creating a thread makes our target class a subclass
    of a type that is already runnable. As it turns out, the `Thread` class itself
    conveniently implements the `Runnable` interface; it has its own `run()` method,
    which we can override directly to do our bidding:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种创建线程的设计选项是使我们的目标类成为已经可运行的类型的子类。事实证明，`Thread` 类本身方便地实现了 `Runnable` 接口；它有自己的
    `run()` 方法，我们可以直接重写它来完成我们的任务：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The skeleton of our `Animator` class looks much the same as before, except that
    our class is now a subclass of `Thread`. To go along with this scheme, the default
    constructor of the `Thread` class makes itself the default target—that is, by
    default, the `Thread` executes its own `run()` method when we call the `start()`
    method, as shown in [Figure 9-2](#learnjava6-CHP-9-FIG-2). Now our subclass can
    just override the `run()` method in the `Thread` class. (`Thread` itself defines
    an empty `run()` method.)
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Animator` 类的骨架看起来与之前大致相同，只是现在我们的类是 `Thread` 的子类。为了配合这个方案，`Thread` 类的默认构造函数使自己成为默认目标——也就是说，默认情况下，当我们调用
    `start()` 方法时，`Thread` 执行它自己的 `run()` 方法，正如 [Figure 9-2](#learnjava6-CHP-9-FIG-2)
    中所示。现在我们的子类可以简单地重写 `Thread` 类中的 `run()` 方法。（`Thread` 本身定义了一个空的 `run()` 方法。）
- en: '![ljv6 0902](assets/ljv6_0902.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0902](assets/ljv6_0902.png)'
- en: Figure 9-2\. Animator as a subclass of `Thread`
  id: totrans-37
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-2\. 作为 `Thread` 子类的动画师
- en: 'Next, we create an instance of `Animator` and call its `start()` method (which
    it also inherited from `Thread`):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建了 `Animator` 的一个实例，并调用了它的 `start()` 方法（它也继承自 `Thread`）：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Extending `Thread` may seem like a convenient way to bundle a thread and its
    target `run()` method. However, this approach often isn’t the best design. If
    you extend `Thread` to implement a thread, you are saying you need a new type
    of object that is a kind of `Thread`, which exposes all of the public methods
    of the `Thread` class. While there is something satisfying about taking an object
    that’s primarily concerned with performing a task and making it a `Thread`, the
    actual situations where you’ll want to create a subclass of `Thread` should not
    be very common. In most cases, it is more natural to let the requirements of your
    program dictate the class structure and use `Runnable`s to connect the execution
    and logic of your program.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展 `Thread` 看起来可能是打包线程及其目标 `run()` 方法的便利方式。然而，这种方法通常不是最佳设计。如果你扩展 `Thread` 来实现一个线程，那么你是在说你需要一个新类型的对象，它是
    `Thread` 的一种，公开 `Thread` 类的所有公共方法。虽然将一个主要关注执行任务的对象变成 `Thread` 有一种满足感，但实际情况下，你需要创建
    `Thread` 子类的情况应该并不常见。在大多数情况下，更自然的做法是让程序的需求决定类结构，并使用 `Runnable` 来连接程序的执行和逻辑。
- en: Controlling Threads
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制线程
- en: 'Now that you have seen the `start()` method used to begin executing a new thread,
    let’s look at instance methods that let you explicitly control a thread’s behavior
    at runtime:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了使用 `start()` 方法来开始执行一个新线程，让我们来看看在运行时显式控制线程行为的实例方法：
- en: '`Thread.sleep()` method'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread.sleep()` 方法'
- en: Causes the currently executing thread to wait for a designated period of time
    (give or take), without consuming much (or possibly any) CPU time.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使当前正在执行的线程等待指定的一段时间（多多少少），而不消耗太多（或可能根本没有）CPU 时间。
- en: '`wait()` and `join()` methods'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`wait()` 和 `join()` 方法'
- en: Coordinate the execution of two or more threads. We’ll discuss them in detail
    when we talk about thread synchronization later in this chapter.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 协调两个或多个线程的执行。在本章后面讨论线程同步时，我们将详细讨论它们。
- en: '`interrupt()` method'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`interrupt()`方法'
- en: Wakes up a thread that is sleeping in a `sleep()` or `wait()` operation or is
    otherwise blocked on a long I/O operation.^([1](ch09.html#id1771))
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 唤醒正在执行`sleep()`或`wait()`操作中的线程，或者正在长时间I/O操作中被阻塞的线程。^([1](ch09.html#id1771))
- en: Deprecated methods
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 弃用的方法
- en: 'We should also mention three deprecated thread-control methods: `stop()`, `suspend()`,
    and `resume()`. The `stop()` method complements `start()`; it destroys the thread.
    `start()` and the deprecated `stop()` method can be called only once in the thread’s
    life cycle. By contrast, the deprecated `suspend()` and `resume()` methods arbitrarily
    pause and then restart the execution of a thread.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该提到三个已弃用的线程控制方法：`stop()`、`suspend()`和`resume()`。`stop()`方法与`start()`方法相辅相成；它销毁线程。`start()`方法和已弃用的`stop()`方法只能在线程生命周期中调用一次。相比之下，已弃用的`suspend()`和`resume()`方法会任意暂停然后重新启动线程的执行。
- en: Although these deprecated methods still exist in the latest version of Java
    (and will probably be there forever), they shouldn’t be used in new code development.
    The problem with both `stop()` and `suspend()` is that they seize control of a
    thread’s execution in an uncoordinated, harsh way.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些弃用的方法仍然存在于最新版本的Java中（而且可能会永远存在），但不应在新代码开发中使用。`stop()`和`suspend()`方法的问题在于它们以不协调和粗暴的方式控制线程的执行。
- en: You can create and monitor a few variables as a better way to affect the execution
    of a thread (if these variables are `boolean`, you might see them referred to
    as “flags”). The early thread examples in this book use this technique in one
    way or another. Later examples will introduce some of the other control features
    available through the concurrency classes.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以创建并监视一些变量作为影响线程执行的更好方式（如果这些变量是`boolean`类型，您可能会看到它们被称为“标志”）。本书中早期的线程示例在某种程度上使用了这种技术。后续示例将介绍并发类可用的其他一些控制特性。
- en: The sleep() method
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`sleep()`方法'
- en: 'Programmers often need to tell a thread to sit idle, or “sleep,” for some period
    of time. You may need to wait for some external resource to become available,
    for example. Even our simple animation threads takes small pauses between frames.
    While a thread is asleep, or otherwise blocked from input of some kind, it doesn’t
    consume CPU time or compete with other threads for processing. For such pauses,
    we can call the static method `Thread.sleep()`, which affects the currently executing
    thread. The call causes the thread to go idle for a specified number of milliseconds:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员通常需要告诉一个线程在一段时间内保持空闲或“睡眠”。例如，您可能需要等待某些外部资源变为可用。即使是我们简单的动画线程在帧之间也会有小的暂停。当一个线程在睡眠或其他方式被某种形式的输入阻塞时，它不会消耗CPU时间或与其他线程竞争处理。对于这样的暂停，我们可以调用静态方法`Thread.sleep()`，它会影响当前执行的线程。调用使得线程空闲指定的毫秒数：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `sleep()` method may throw an `InterruptedException` if it is interrupted
    by another thread via the `interrupt()` method (more below). As you saw in the
    previous code, the thread can catch this exception and take the opportunity to
    perform some action—such as checking a variable to determine whether or not the
    thread should exit—and then go back to sleep.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`sleep()`方法被`interrupt()`方法中断，可能会抛出`InterruptedException`异常（详见下文）。正如您在前面的代码中看到的那样，线程可以捕获此异常并利用这个机会执行某些操作——比如检查一个变量来确定线程是否应该退出——然后继续睡眠。
- en: The join(), wait(), and notify() methods
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`join()`、`wait()`和`notify()`方法'
- en: If you need to coordinate a thread’s activities by waiting for another thread
    to complete its task, you can use the `join()` method. Calling a thread’s `join()`
    method causes that thread to block until the target thread completes. Alternatively,
    you can call `join()` with a number of milliseconds to wait as an argument. In
    this form, the calling thread waits until either the target thread completes or
    the specified period elapses. This is a very coarse form of thread synchronization.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要通过等待另一个线程完成其任务来协调线程的活动，可以使用`join()`方法。调用线程的`join()`方法会导致该线程阻塞，直到目标线程完成为止。或者，可以将`join()`方法与等待的毫秒数作为参数一起调用。在这种形式下，调用线程会等待直到目标线程完成或指定的时间段过去。这是一种非常粗糙的线程同步方式。
- en: If you need to coordinate a thread’s activities with some other resource, such
    as checking the state of a file or network connection, you can use the `wait()`
    and `notify()` methods. Calling `wait()` on a thread will pause it, similar to
    using `join()`, but it will remain paused either until it gets `interrupt()`-ed
    by some other thread, or until you call `notify()` on the thread yourself.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要将线程的活动与其他资源协调起来，例如检查文件或网络连接的状态，则可以使用`wait()`和`notify()`方法。在线程上调用`wait()`将暂停它，类似于使用`join()`，但它会保持暂停状态，直到另一个线程通过`interrupt()`中断它，或者您自己在线程上调用`notify()`。
- en: Java supports more general and powerful mechanisms for coordinating thread activity
    in the `java.util.concurrent` package. We’ll show you more of this package later
    in the chapter.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Java支持更一般和更强大的机制来协调线程活动，位于`java.util.concurrent`包中。我们将在本章后面向您展示此包的更多内容。
- en: The interrupt() method
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`interrupt()` 方法'
- en: The `interrupt()` method does more or less what it says on the tin. It interrupts
    the normal flow of execution for a thread. If that thread was idle in a `sleep()`,
    `wait()`, or lengthy I/O operation, it will wake up. When you interrupt a thread,
    its *interrupt status* flag is set. You can test this flag with the `isInterrupted()`
    method. You can also use an alternate form, `isInterrupted(boolean)`, to indicate
    whether or not you want the thread to clear its interrupt status after retrieving
    the current value.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`interrupt()` 方法基本上做了它说的事情。它中断了线程的正常执行流程。如果该线程在`sleep()`、`wait()`或耗时的I/O操作中空闲，则会唤醒。当中断线程时，其*中断状态*标志将被设置。您可以使用`isInterrupted()`方法测试此标志。您还可以使用一个替代形式`isInterrupted(boolean)`来指示您是否希望线程在检索当前值后清除其中断状态。'
- en: While you probably won’t use `interrupt()` that often, it can definitely come
    in handy. If you have ever grown impatient while a desktop application tries—and
    fails—to connect to a server or database, you have experienced one of those moments
    where an interruption might be the right thing.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管您可能不经常使用`interrupt()`，但它绝对会派上用场。如果您曾经因桌面应用程序试图连接到服务器或数据库而变得不耐烦，但却失败了，那么您就经历过其中一个可能需要中断的时刻。
- en: Let’s simulate this scenario with a small graphical application. We’ll show
    a label on the screen and move it to a new, random location every five seconds.
    During that five-second pause, a click anywhere on the screen will interrupt the
    pause. We’ll change the message and then start the random move cycle again. You
    can run the full example from *ch09/examples/Interruption.java*, but [Figure 9-3](#learnjava6-CHP-9-FIG-interruption)
    highlights the flow and effect of calling `interrupt()`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个小型图形应用程序模拟这种情况。我们将在屏幕上显示一个标签，并将其移动到每五秒钟的新位置。在那五秒的暂停期间，屏幕上的任何位置的点击都会中断暂停。我们将更改消息，然后再次启动随机移动周期。您可以从*ch09/examples/Interruption.java*运行完整的示例，但[图 9-3](#learnjava6-CHP-9-FIG-interruption)突出了调用`interrupt()`的流程和效果。
- en: '![ljv6 0903](assets/ljv6_0903.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0903](assets/ljv6_0903.png)'
- en: Figure 9-3\. Interrupting a thread
  id: totrans-66
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-3\. 中断线程
- en: Revisiting Animation with Threads
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重温线程动画
- en: 'Managing animations is a common task in graphical interfaces. Sometimes the
    animations are subtle transitions; other times they are the focus of the application,
    as with our apple tossing game. We’ll look at two ways to handle the animation:
    using simple threads alongside the `sleep()` functions, and using a timer. Pairing
    one of those options with some type of stepping or “next frame” function is a
    popular approach that is also easy to understand.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 管理动画是图形界面中的常见任务。有时动画是微妙的过渡；其他时候，它们是应用程序的焦点，就像我们的苹果投掷游戏一样。我们将介绍处理动画的两种方式：在`sleep()`函数旁边使用简单的线程，以及使用计时器。将其中一种选项与某种类型的步进或“下一帧”函数配对是一种流行且易于理解的方法。
- en: 'You can use a thread similar to [“Creating and starting threads”](#learnjava6-CHP-9-SECT-1.1.1)
    to produce real animation. The basic idea is to paint or position all of your
    animated objects, pause, move them to their next spots, and then repeat. Let’s
    take a look at how we draw some pieces of our game field without animation first.
    We’ll include a new `List` for any active apples in addition to the existing lists
    for trees and hedges. You can pull up this code in your editor from the *ch09/examples/game*
    folder:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用类似于[“创建和启动线程”](#learnjava6-CHP-9-SECT-1.1.1)的线程来生成真实的动画。基本思想是绘制或定位所有动画对象，暂停，将它们移动到它们的下一个位置，然后重复。让我们首先看看如何在没有动画的情况下绘制游戏场地的一些部分。除了现有的树木和篱笆列表外，我们还将为任何活跃的苹果添加一个新的`List`。您可以从*ch09/examples/game*文件夹中的编辑器中检索此代码：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We start by painting the background field, then the trees and hedges, then our
    physicist, and finally any apples. Painting the apples last guarantees that they
    will show “on top” of the other elements.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先绘制背景场地，然后是树木和篱笆，然后是我们的物理学家，最后是任何苹果。最后绘制苹果可以确保它们显示在其他元素的上方。
- en: 'What changes on the screen as you play? There are really only two “moveable”
    items: the apple our physicist is aiming, and any apples actively flying after
    being tossed. The physicist aims in response to user input (by moving the mouse
    or clicking a button). That doesn’t require separate animation, so we’ll add this
    functionality in [Chapter 12](ch12.html#learnjava6-CHP-12). For now, we can concentrate
    on handling flying apples.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当您玩游戏时屏幕上发生了什么变化？真正可以移动的只有两个“可移动”物品：我们的物理学家瞄准的苹果，以及被投掷后正在飞行的任何苹果。物理学家响应用户输入（通过移动鼠标或单击按钮）来瞄准，这不需要单独的动画，所以我们将在[第12章](ch12.html#learnjava6-CHP-12)中添加这个功能。现在，我们可以专注于处理飞行的苹果。
- en: 'Our game’s animation step should move every apple that is active, according
    to the rules of gravity. First, we add a `toss()` method to our `Apple` class
    where we can set up the initial conditions for our apple using information from
    our physicist. (Since the physicist is not yet interactive, we’ll fake some data.)
    Then we make one move for a given apple in the `step()` method:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏的动画步骤应该根据重力规则移动每个处于活跃状态的苹果。首先，在我们的`Apple`类中添加一个`toss()`方法，我们可以使用来自我们物理学家的信息设置苹果的初始条件（因为物理学家目前还没有交互，我们将伪造一些数据）。然后，在`step()`方法中为给定的苹果进行一次移动：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We start by calculating how fast the apple will move (the `velocityX` and `velocityY`
    variables) in the `toss()` method. In our `step()` method, we update the apple’s
    position based on those two velocities, then adjust the vertical velocity based
    on how strong our gravity is. It’s not very fancy, but it will produce a nice
    arc for the apples. We then put that code in a loop that will do the update calculations,
    repaint the field and apples, pause, and repeat:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在`toss()`方法中计算苹果将移动的速度（`velocityX`和`velocityY`变量）。在我们的`step()`方法中，根据这两个速度更新苹果的位置，然后根据重力强度调整垂直速度。这不是很花哨，但它将为苹果产生一个不错的弧线。然后我们将该代码放入一个循环中，该循环将执行更新计算、重绘场地和苹果、暂停并重复：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We’ll use this implementation of `Runnable` in a simple thread. Our `Field`
    class will keep an instance of the thread around and contains the following simple
    `start` method:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在一个简单的线程中使用这个`Runnable`的实现。我们的`Field`类将保留一个线程的实例，并包含以下简单的`start`方法：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We’ll discuss events in [“Events”](ch12.html#learnjava6-CHP-12-SECT-3); you’ll
    use those events to launch an apple on command. For now, we’ll just launch one
    apple automatically, as shown in [Figure 9-4](#learnjava6-CHP-9-FIG-3).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[“事件”](ch12.html#learnjava6-CHP-12-SECT-3)中讨论事件；您将使用这些事件来命令启动一个苹果。现在，我们将自动启动一个苹果，如[图9-4](#learnjava6-CHP-9-FIG-3)所示。
- en: '![ljv6 0904](assets/ljv6_0904.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0904](assets/ljv6_0904.png)'
- en: Figure 9-4\. Tossable apples in action
  id: totrans-81
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9-4：动作中的可抛苹果
- en: It doesn’t look like much as a still screenshot, but it is amazing in person.
    ;^)
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 它作为静止截图看起来并不起眼，但实际上却令人惊叹。 ;^)
- en: Death of a Thread
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程的终结
- en: 'All good things come to an end. A thread continues to execute until one of
    the following three things happens:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一切美好的事情都有结束的时候。一个线程会一直执行，直到发生以下三种情况之一：
- en: It explicitly returns from its target `run()` method.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它明确地从其目标`run()`方法返回。
- en: It encounters an uncaught runtime exception.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它遇到了一个未捕获的运行时异常。
- en: The nasty, deprecated `stop()` method is called.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨厌的、已弃用的`stop()`方法被调用。
- en: What happens if none of these things occurs, and the `run()` method for a thread
    never terminates? The thread can live on, even after the code that created it
    has finished. You have to be aware of how threads eventually terminate, or your
    application can end up leaving orphaned threads running that consume resources
    unnecessarily, or even keep the application alive when it would otherwise quit.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些情况都不发生，线程的`run()`方法永远不会终止会发生什么？即使创建它的代码已经完成，线程仍然可以继续存在。您必须了解线程如何最终终止，否则您的应用程序可能会继续运行未必要地消耗资源，甚至在本应退出时仍保持应用程序的生存。
- en: In many cases, you want background threads that do simple, periodic tasks in
    an application. You can create one of these background workers using the `setDaemon()`
    method to mark a thread as a *daemon* thread. Daemon threads can terminate like
    other threads, but if the application that started them is quitting, they should
    be killed and discarded when no other nondaemon application threads remain.^([2](ch09.html#id1793))
    Normally, the Java interpreter continues to run until all threads have completed.
    But when daemon threads are the only threads still alive, the interpreter will
    exit.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，你需要在应用程序中执行简单周期任务的后台线程。你可以使用 `setDaemon()` 方法创建其中一个后台工作者，并将线程标记为*守护*线程。守护线程可以像其他线程一样终止，但如果启动它们的应用程序正在退出，当没有其他非守护应用程序线程存在时，它们应该被终止和丢弃。^([2](ch09.html#id1793))
    通常，Java 解释器会继续运行直到所有线程完成。但是当只有守护线程仍然存活时，解释器将退出。
- en: 'Here’s a “devilish” outline using daemon threads:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用守护线程的“恶魔式”大纲：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this example, the `Devil` thread sets its daemon status when it is created.
    If any `Devil` threads remain when our application is otherwise complete, the
    runtime system terminates them for us. We don’t have to worry about cleaning them
    up.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`Devil` 线程在创建时设置了它的守护进程状态。如果我们的应用程序在其他方面完成后仍有任何 `Devil` 线程存在，运行时系统会为我们终止它们。我们不需要担心清理它们。
- en: 'One final note about killing threads gracefully. New developers often encounter
    a common problem the first time they create an application using a graphical Swing
    component: their application never exits. The Java VM seems to hang indefinitely
    after everything is finished and the application window is closed. Java creates
    a UI thread to process input and painting events. This UI thread is not a daemon
    thread, so it doesn’t exit automatically when other application threads have completed.
    The developer must call `System.exit()` explicitly. If you think about it, this
    makes sense. Because most GUI applications are event-driven and wait for user
    input, they would otherwise exit after their startup code completes.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 关于优雅终止线程的最后一点说明。新的开发人员在第一次使用图形 Swing 组件创建应用程序时经常遇到一个常见问题：他们的应用程序永远不会退出。在一切都完成并且应用程序窗口关闭之后，Java
    VM 似乎会无限期地挂起。Java 创建一个 UI 线程来处理输入和绘画事件。这个 UI 线程不是守护线程，因此当其他应用程序线程完成时，它不会自动退出。开发人员必须显式调用
    `System.exit()`。如果你想想的话，这是有道理的。因为大多数 GUI 应用程序是事件驱动的并且等待用户输入，否则它们会在启动代码完成后退出。
- en: Virtual Threads
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟线程
- en: Previewed in Java 19 and finalized in Java 21, Project Loom^([3](ch09.html#id1797))
    brings lightweight, virtual threads to Java. One of the main goals of Project
    Loom is to improve the thread ecosystem in Java so that developers can put less
    energy into keeping multithreaded applications stable and more energy into solving
    higher-level problems.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 19 中预览，并在 Java 21 中最终确定，Project Loom^([3](ch09.html#id1797)) 为 Java 带来了轻量级虚拟线程。Project
    Loom 的主要目标之一是改进 Java 中的线程生态系统，使开发人员可以花更少的精力来保持多线程应用程序的稳定性，更多地解决高层次的问题。
- en: Preview Feature Tangent
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预览特性插曲
- en: What do we mean by “previewed in Java 19”? Starting with Java 12, Oracle began
    introducing some language features as *previews*. These preview features are well-specified
    and fully implemented but not wholly baked. Oracle may still make substantial
    modifications in future releases. Eventually, these features will either become
    permanent parts of the JDK or they will be removed. Oracle produces a language
    update page for each new release of Java that contains a nice history of recent
    changes to the language as well as an [overview of preview features](https://oreil.ly/5MuMw)
    in general.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: “在 Java 19 中预览”的意思是什么？从 Java 12 开始，Oracle 开始引入一些语言特性作为*预览*。这些预览特性有明确的规范并且完全实现，但并不完全成熟。Oracle
    可能在未来的版本中做出重大修改。最终，这些特性要么成为 JDK 的永久部分，要么被移除。Oracle 为每个新的 Java 发布版本制作语言更新页面，其中包含对语言最近更改的良好历史以及[预览特性概述](https://oreil.ly/5MuMw)。
- en: Because any given preview feature may end up being dropped from Java, Oracle
    requires you to include special flags when you compile or run an application that
    uses it. This requirement is a small guardrail to make sure you don’t accidentally
    use code that may not work with a future release of Java.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因为任何给定的预览特性最终可能被从 Java 中删除，Oracle 要求你在编译或运行使用它的应用程序时包含特殊标志。这个要求是一个小的防护栏，以确保你不会意外使用可能在将来的
    Java 版本中不起作用的代码。
- en: Configuring IDEs for preview features
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置 IDE 以使用预览特性
- en: If you use an IDE for the demos and exercises, you may need to configure it
    to support preview features. IntelliJ IDEA, for example, does not support preview
    features by default. You need to change a setting in the File → Project Structure
    dialog, as shown in [Figure 9-5](#learnjava6-CHP-9-FIG-idea-preview).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用 IDE 进行演示和练习，可能需要配置它以支持预览功能。例如，IntelliJ IDEA 默认情况下不支持预览功能。您需要在“File → Project
    Structure”对话框中更改设置，如[图 9-5](#learnjava6-CHP-9-FIG-idea-preview)所示。
- en: '![ljv6 0905](assets/ljv6_0905.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0905](assets/ljv6_0905.png)'
- en: Figure 9-5\. Enabling Java’s preview features in IntelliJ IDEA
  id: totrans-102
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-5\. 在 IntelliJ IDEA 中启用 Java 的预览功能
- en: After choosing the version of Java you want in the SDK drop-down, you can enable
    preview feature support by choosing the appropriate option under the Language
    level drop-down. (The features that IDEA lists next to the version numbers is
    not an exhaustive list.) Click OK after setting the language level, and IDEA should
    be ready to compile and run any code with preview features.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SDK 下拉菜单中选择您想要的 Java 版本后，您可以通过在“Language level”下拉菜单中选择适当选项来启用预览功能支持。（IDEA
    列出的特性与版本号旁边的特性不是详尽列表。）设置语言级别后，单击“OK”，IDEA 应该已准备好编译和运行任何具有预览功能的代码。
- en: Renaming preview source files
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重命名预览源文件
- en: The `VirtualDemo` class (*ch09/examples/VirtualDemo.java.preview*) uses a virtual
    thread to pause briefly before issuing our favorite “Hello Java” greeting. Before
    you can compile or run it, you’ll need to rename it. We added the *.preview* suffix
    to any file that includes a preview feature in the code. The suffix stops IDEs
    like IntelliJ IDEA from proactively compiling them until you’ve had a chance to
    configure preview support, as we mentioned in the previous section.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`VirtualDemo` 类（*ch09/examples/VirtualDemo.java.preview*）使用虚拟线程在发出我们最喜欢的“Hello
    Java”问候之前暂停片刻。在您可以编译或运行它之前，您需要将其重命名。我们在包含代码中的任何预览功能的文件上添加了 *.preview* 后缀。该后缀阻止像
    IntelliJ IDEA 这样的 IDE 在您配置预览支持之前积极地编译它们，就像我们在前一节中提到的那样。'
- en: 'You can use the context (right-click) menu in IntelliJ IDEA to rename the file
    under the Refactor menu item. You can also rename a file quickly from a terminal
    in Linux or macOS using the *mv* command:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 IntelliJ IDEA 中使用上下文（右键单击）菜单，在“重构”菜单项下重命名文件。您还可以在 Linux 或 macOS 终端中使用 *mv*
    命令快速重命名文件：
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In a Windows terminal or command prompt, you can use the *rename* command:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 终端或命令提示符中，您可以使用 *rename* 命令：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Compiling classes with preview features
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编译具有预览功能的类
- en: 'Oracle added a pair of command-line options for compiling code with preview
    features. If you try to compile our `VirtualDemo` source file with Java 19, for
    example, you’ll likely see an error similar to this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle 为使用预览功能编译代码添加了一对命令行选项。例如，如果您尝试使用 Java 19 编译我们的 `VirtualDemo` 源文件，您可能会看到类似于这样的错误：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The error gives us a hint as to how we should proceed. Let’s try adding the
    suggested flag and compiling again:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 错误为我们提供了一个关于我们应该如何继续的提示。让我们尝试添加建议的标志并再次编译：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Rats! Another, different error. At least it also includes some hints. To compile,
    you need to provide *two* flags: `--enable-preview` and then either `-source`
    or `--release`.^([4](ch09.html#id1810)) The compiler uses `-source` to specify
    which language rules apply to the source code being compiled. (The compiled bytecode
    is still targeted at the same version of Java as your JDK.) You can use the `--release`
    option to specify both the source version and the bytecode version.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 糟糕！又是另一个不同的错误。至少它也包含了一些提示。要编译，您需要提供*两个*标志：`--enable-preview`，然后是 `-source` 或
    `--release`。^([4](ch09.html#id1810)) 编译器使用 `-source` 来指定适用于正在编译的源代码的语言规则。（编译后的字节码仍针对与您的
    JDK 相同版本的 Java。）您可以使用 `--release` 选项来同时指定源版本和字节码版本。
- en: 'While there are many scenarios where you might need to compile for older systems,
    preview features are meant for use with the current version of the JDK. As such,
    when we use any preview features in the book, we’ll be pairing `--enable-preview`
    with `--release` and simply give the same release version as our version of Java.
    Returning to our virtual thread preview feature, for example, we can use Java
    19 to try it out. Our final, correct *javac* call looks like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有许多场景可能需要为旧系统编译，但预览功能是用于当前 JDK 版本的。因此，当我们在书中使用任何预览功能时，我们将使用 `--enable-preview`
    与 `--release` 并简单地给出与我们的 Java 版本相同的发布版本号。例如，返回到我们的虚拟线程预览功能，我们可以使用 Java 19 来尝试它。我们最终的正确
    *javac* 调用如下所示：
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The “notes” that appear after your compilation completes are purely informational.
    They remind you that your code relies on an unstable feature that may not be available
    in the future. The note is not meant to dissuade you from using these features,
    but if you are planning to share your code with other users or developers, you
    will have some extra compatibility contraints to remember.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '"notes"这个名词在编译完成后出现，纯粹是提供信息。它们提醒您的代码依赖于未来可能不再可用的不稳定功能。这些注释并非意在劝阻您使用这些功能，但如果您计划与其他用户或开发者共享代码，则需要记住一些额外的兼容性约束。'
- en: 'If you’re curious, you can use the `-Xlint:preview` option mentioned in the
    notes to see exactly what preview code caused the warning:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您好奇，您还可以使用注释中提到的`-Xlint:preview`选项来查看到底是哪些预览代码引起了警告：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: No surprises there, but then again, this is just a tiny demo program. With larger
    programs or code developed in teams, that extra `-Xlint:preview` flag can be very
    handy.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么意外的，但话说回来，这只是一个微小的演示程序。对于更大的程序或团队开发的代码来说，那额外的`-Xlint:preview`标志就非常方便了。
- en: Running preview class files
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行预览类文件
- en: 'Running Java classes that include preview features also requires the `--enable-preview`
    flag. If you try to run `VirtualDemo` with Java 19 as you would any other class,
    you’ll get an error like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 运行包含预览功能的Java类也需要`--enable-preview`标志。如果您尝试像运行任何其他类一样使用Java 19运行`VirtualDemo`，您将收到如下错误：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Again, you can use the flag mentioned in the error, `--enable-preview`, and
    you’re good to go:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，您可以使用错误中提到的`--enable-preview`标志，然后您可以开始：
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you want to play with a preview feature in *jshell*, you can also provide
    the same `--enable-preview` flag:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在*jshell*中尝试预览功能，也可以提供相同的`--enable-preview`标志：
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Including that flag would allow a Java 19 *jshell* session to use virtual threads,
    just as it allowed us to run our demo program above.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 包含该标志将允许Java 19的*jshell*会话使用虚拟线程，就像它允许我们运行上面的演示程序一样。
- en: A Quick Comparison
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速比较
- en: 'The Loom team designed its virtual threads to be easy to use if you already
    have some skill with Java threads. Let’s rework the trivial thread example that
    we used to test the `--enable-preview` flag to show both types of thread:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Loom团队设计了它的虚拟线程，以便在您已经具有一些Java线程技能的情况下易于使用。让我们重新设计我们用来测试`--enable-preview`标志的微不足道的线程示例，以展示两种类型的线程：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In this reworking, we expanded our anonymous `Runnable` inner class to do a
    little sleuthing on the current thread. We print out the thread’s identification
    number and whether or not it’s a virtual thread. But look how similar (and simple)
    the lines are that launch the two threads: they both accept our `runnable` object
    and “fit” in the `Thread` class. For developers with established code, switching
    to use these virtual threads should be straightforward. Here’s the output after
    compiling and running (with the appropriate preview flags, of course):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次重新编排中，我们扩展了我们的匿名`Runnable`内部类，对当前线程进行了一些侦查。我们打印出线程的标识号以及它是否是虚拟线程。但请看启动这两个线程的行代码多么相似（以及简单）：它们都接受我们的`runnable`对象并“适合”在`Thread`类中。对于已有代码的开发者来说，切换到使用这些虚拟线程应该很简单。编译并运行后的输出如下（当然要使用适当的预览标志）：
- en: '[PRE21]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Both threads run as expected. One thread does indeed report itself as a virtual
    thread. We use the word *platform* to describe the other thread, since that’s
    what the Oracle documentation calls them. Platform threads represent a direct,
    one-to-one relationship with the *native* threads your operating system (the platform)
    provides. Virtual threads, on the other hand, have an indirect, many-to-one relationship
    with native threads from the operating system, as shown in [Figure 9-6](#learnjava6-CHP-9-FIG-loom-threads).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 两个线程都如预期地运行。一个线程确实报告自己是虚拟线程。我们使用术语*平台*来描述另一个线程，因为这是Oracle文档称呼它们的方式。平台线程表示与操作系统（平台）提供的本机线程之间的直接一对一关系。另一方面，虚拟线程与来自操作系统的本机线程之间有间接的多对一关系，如[图9-6](#learnjava6-CHP-9-FIG-loom-threads)所示。
- en: '![ljv6 0906](assets/ljv6_0906.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0906](assets/ljv6_0906.png)'
- en: Figure 9-6\. Platform and virtual threads map differently to native threads
  id: totrans-137
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9-6。平台线程和虚拟线程在映射到本地线程时存在差异
- en: This separation is one of the key design features of virtual threads. It allows
    Java to have many (many!) threads going at once without the performance costs
    of creating and managing corresponding native threads. Virtual threads are designed
    to be inexpensive to create and highly performant once they are up and running.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分离是虚拟线程的关键设计特征之一。它允许Java同时运行许多（许多！）线程，而无需创建和管理相应的本机线程的性能成本。虚拟线程被设计为创建廉价且一旦运行起来非常高效。
- en: Synchronization
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步
- en: Every thread has a mind of its own. Normally, a thread goes about its business
    without any regard for what other threads in the application are doing. Threads
    may be *time-sliced*, which means they can run in arbitrary spurts and bursts
    as directed by the OS. On a multiprocessor or multicore system, it is even possible
    for many different threads to be running simultaneously on different CPUs. This
    section is about coordinating the activities of two or more threads so that they
    can work together and use the same variables and methods (without colliding, like
    players on the golf course).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 每个线程都有自己的思路。通常，线程在不考虑应用程序中其他线程的情况下进行操作。线程可以被*时间片*，这意味着它们可以按照操作系统的指示以任意的突发方式运行。在多处理器或多核系统上，许多不同的线程甚至可以同时在不同的CPU上运行。本节讨论协调两个或多个线程的活动，以便它们可以共同使用相同的变量和方法（而不会发生冲突，就像高尔夫球场上的球员一样）。
- en: Java provides a few simple structures for synchronizing the activities of threads.
    They are all based on the concept of monitors, a widely used synchronization scheme.
    You don’t have to know the details about how monitors work to be able to use them,
    but it may help you to have [Figure 9-7](#learnjava6-CHP-9-FIG-thread-monitor)
    in mind.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Java提供了一些简单的结构来同步线程的活动。它们都基于监视器的概念，这是一种广泛使用的同步方案。您不必了解监视器的工作细节即可使用它们，但牢记[图 9-7](#learnjava6-CHP-9-FIG-thread-monitor)可能会对您有所帮助。
- en: '![ljv6 0907](assets/ljv6_0907.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0907](assets/ljv6_0907.png)'
- en: Figure 9-7\. Synchronizing access with a monitor
  id: totrans-143
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9-7\. 使用监视器同步访问
- en: A *monitor* is essentially a lock. The lock is attached to a resource that many
    threads may need to access but that should be accessed by only one thread at a
    time. It’s very much like a restroom with a lock on the door; if it’s unlocked,
    you can enter, and you lock the door while you are using it. If the resource is
    not being used, a thread can acquire the lock and access the resource. When the
    thread is done, it relinquishes the lock, just as you unlock the restroom door
    and leave it open for the next person (or thread).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*监视器*本质上是一把锁。这把锁附加在一个资源上，许多线程可能需要访问该资源，但只能一次由一个线程访问。这很像带锁的卫生间门；如果门没锁，你可以进去，使用时把门锁上。如果资源未被使用，线程可以获取锁并访问资源。当线程完成时，它释放锁，就像你打开卫生间门留给下一个人（或线程）一样。'
- en: 'If another thread already has the lock for the resource, however, all other
    threads must wait until the current thread is done and releases the lock. This
    is just like when the restroom is occupied when you arrive: you have to wait until
    the current user is done and unlocks the door.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果另一个线程已经获取了资源的锁，则所有其他线程必须等待，直到当前线程完成并释放锁。这就像当你到达时卫生间已被占用一样：你必须等到当前用户完成并解锁门。
- en: Java makes it fairly easy to synchronize access to resources. The language handles
    setting up and acquiring locks; all you need to do is specify the resources to
    synchronize.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Java让资源访问同步变得相当容易。语言处理设置和获取锁；你只需指定需要同步的资源即可。
- en: Serializing Access to Methods
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法访问序列化
- en: The most common reason to synchronize threads in Java is to serialize their
    access to a resource (like an object or variable)—in other words, to make sure
    that only one thread at a time can manipulate that object.^([5](ch09.html#id1818))
    In Java, every class and every instance of a class has its own lock. The `synchronized`
    keyword marks places where a thread must acquire the lock before proceeding.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，同步线程的最常见原因是将它们对资源（如对象或变量）的访问序列化，换句话说，确保一次只有一个线程可以操作该对象。^([5](ch09.html#id1818))
    在Java中，每个类和类的每个实例都有自己的锁。`synchronized`关键字标记了线程必须在继续之前获取锁的地方。
- en: 'For example, suppose we implement a `SpeechSynthesizer` class that contains
    a `say()` method. We don’t want multiple threads calling `say()` at the same time
    because we wouldn’t be able to understand anything the synthesizer says. So we
    mark the `say()` method as `synchronized`, which means that a thread must acquire
    the lock on the `SpeechSynthesizer` object before it can speak:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 比如，假设我们实现了一个包含`say()`方法的`SpeechSynthesizer`类。我们不希望多个线程同时调用`say()`，因为我们将无法理解合成器说的内容。因此，我们将`say()`方法标记为`synchronized`，这意味着线程必须在发声之前获取`SpeechSynthesizer`对象上的锁：
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When `say()` has completed, the calling thread gives up the lock, which allows
    the next waiting thread to acquire the lock and run the method. It doesn’t matter
    whether the thread is owned by the `SpeechSynthesizer` itself or some other object;
    every thread must acquire the same lock from the `SpeechSynthesizer` instance.
    If `say()` were a class (static) method instead of an instance method, we could
    still mark it as `synchronized`. In this case, because no instance object is involved,
    the lock is on the `SpeechSynthesizer` class object itself.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当`say()`完成后，调用线程释放锁，这允许下一个等待的线程获取锁并运行方法。无论线程是属于`SpeechSynthesizer`本身还是其他对象，都必须从`SpeechSynthesizer`实例获取相同的锁。如果`say()`是类（静态）方法而不是实例方法，我们仍然可以将其标记为`synchronized`。在这种情况下，因为没有涉及实例对象，所以锁在`SpeechSynthesizer`类对象本身上。
- en: 'Often, you want to synchronize multiple methods of the same class so that only
    one method modifies or examines the data in the class at a time. All static synchronized
    methods in a class use the same class-object lock. By the same token, all instance
    methods in a class use the same instance-object lock. This guarantees that only
    one of a set of synchronized methods is running at a time. For example, a `SpreadSheet`
    class might contain several instance variables that represent cell values, as
    well as some methods that manipulate all of the cells in a row:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 经常情况下，您希望同步同一类的多个方法，以便一次只有一个方法修改或检查类中的数据。类中的所有静态同步方法都使用相同的类对象锁。同样，类中的所有实例方法都使用相同的实例对象锁。这保证了一次只有一组同步方法在运行。例如，一个`SpreadSheet`类可能包含表示单元格值的多个实例变量，以及一些操作整行单元格的方法：
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The methods `setRow()` and `sumRow()` both access the cell values. You can see
    that problems might arise if one thread was changing the values of the variables
    in `setRow()` at the same moment another thread was reading the values in `sumRow()`.
    To prevent this, we mark both methods as `synchronized`. When threads encounter
    synchronized resources, only one thread runs at a time. If a thread is in the
    middle of executing `setRow()` when another thread attempts to call `sumRow()`,
    the second thread must wait until the first one finishes executing `setRow()`
    before it runs `sumRow()`. This synchronization allows us to preserve the consistency
    of the `SpreadSheet`. The best part is that all this locking and waiting is handled
    by Java; it’s invisible to the programmer.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 方法`setRow()`和`sumRow()`都访问单元格值。您可以看到，如果一个线程在`setRow()`中更改变量的值的同时，另一个线程在`sumRow()`中读取值，可能会出现问题。为了防止这种情况发生，我们将这两个方法都标记为`synchronized`。当线程遇到同步资源时，只有一个线程运行。如果一个线程在执行`setRow()`时，另一个线程试图调用`sumRow()`，那么第二个线程必须等到第一个线程完成`setRow()`的执行，然后才能运行`sumRow()`。这种同步允许我们保持`SpreadSheet`的一致性。最好的部分是，所有这些锁定和等待都由Java处理；对程序员来说是不可见的。
- en: 'In addition to synchronizing entire methods, the `synchronized` keyword can
    be used in a special construct to guard smaller blocks of code inside a method.
    In this form, it also takes an explicit argument that specifies which object’s
    lock to acquire:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 除了同步整个方法外，`synchronized`关键字还可以用在特殊结构中，以保护方法内部的较小代码块。在这种形式下，它还需要一个明确的参数，指定要获取哪个对象的锁：
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This synchronized block can appear in any method. When a thread reaches it,
    the thread must acquire the lock on `myObject` before proceeding. In this way,
    we can synchronize methods (or parts of methods) in different classes in the same
    way as methods in the same class.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个同步块可以出现在任何方法中。当一个线程到达它时，线程必须在继续之前获取`myObject`上的锁。通过这种方式，我们可以像同一类中的方法那样同步不同类中的方法（或方法的部分）。
- en: 'This means that a synchronized instance method is equivalent to a method with
    its statements synchronized on the current object:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着同步实例方法等效于在当前对象上同步其语句的方法：
- en: '[PRE25]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'is equivalent to:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 等价于：
- en: '[PRE26]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can demonstrate the basics of synchronization with a classic “producer/consumer”
    scenario. Say we have some producers creating new resources and consumers grabbing
    and using those same resources: for instance a series of web crawlers picking
    up images online. The “producer” in this could be a thread (or multiple threads)
    doing the actual work of loading and parsing web pages to look for images and
    their URLs. We can tell it to place those URLs in a common queue. The “consumer”
    thread(s) would pick up the next URL in the queue and download the image to the
    filesystem or a database. We won’t try to do all of the real I/O here (more on
    URLs and networking in [Chapter 13](ch13.html#learnjava6-CHP-13)), but let’s set
    up some producing and consuming threads to show you how the synchronization works.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用经典的“生产者/消费者”场景来演示同步的基本原理。假设我们有一些生产者创建新的资源，而消费者获取并使用这些相同的资源：例如一系列网络爬虫收集在线图片。这里的“生产者”可以是一个或多个线程，实际上加载和解析网页以查找图像及其
    URL。我们可以让它将这些 URL 放入一个共享的队列中。“消费者”线程会从队列中获取下一个 URL，并将图像下载到文件系统或数据库中。我们不会在这里尝试进行所有的实际I/O操作（有关
    URL 和网络的更多信息请参见[第13章](ch13.html#learnjava6-CHP-13)），但让我们设置一些生产和消费线程来展示同步如何工作。
- en: Synchronizing a queue of URLs
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 同步队列中的 URL
- en: 'Let’s look first at the queue where the URLs will be stored. It’s just a list
    where we can append URLs (as `String`s) to the end and pull them off from the
    front. We’ll use a `LinkedList` similar to the `ArrayList` we saw in [Chapter 7](ch07.html#learnjava6-CHP-7).
    We want a structure designed for efficient access and manipulation:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看用于存储 URL 的队列。它只是一个列表，我们可以将 URL（作为字符串）追加到末尾并从前面取出。我们将使用`LinkedList`，类似于我们在[第7章](ch07.html#learnjava6-CHP-7)中看到的`ArrayList`。我们需要一个设计用于高效访问和操作的结构：
- en: '[PRE27]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that not every method is synchronized! Any thread can ask if the queue
    is empty without holding up other threads that might be adding or removing items.
    This *does* mean that `isEmpty()` might report a wrong answer—if the timing of
    different threads is exactly wrong. Fortunately, our system is somewhat fault-tolerant,
    so the efficiency of not locking the queue just to check its size wins out over
    more perfect knowledge.^([6](ch09.html#id1823))
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，并非每个方法都是同步的！任何线程都可以询问队列是否为空，而不会阻塞可能正在添加或删除项目的其他线程。这意味着`isEmpty()`可能会报告错误的答案
    —— 如果不同线程的时间恰好不对。幸运的是，我们的系统有一定的容错性，所以在不锁定队列的情况下检查其大小的效率胜过更完美的知识。^([6](ch09.html#id1823))
- en: 'Now that we know how we’ll be storing and retrieving the URLs, we can create
    the producer and consumer classes. The producer will run a loop to simulate a
    web crawler by making up fake URLs. It will prefix those URLs with a producer
    ID, and then store them in our queue. Here’s the `run()` method for `URLProducer`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何存储和检索 URL，我们可以创建生产者和消费者类。生产者将通过循环来模拟网络爬虫，制造假的 URL，并在 URL 前面加上生产者 ID，然后将它们存储在我们的队列中。这是`URLProducer`的`run()`方法：
- en: '[PRE28]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The consumer class is similar, with the obvious exception of taking URLs out
    of the queue. It will pull a URL out, prefix it with a consumer ID, and start
    over until the producers are done producing and the queue is empty:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者类类似，唯一的区别是从队列中取出 URL。它将取出一个 URL，加上消费者 ID，并在生产者完成生成并且队列为空时重新开始：
- en: '[PRE29]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can start by running our simulation with very small numbers: two producers
    and two consumers. Each producer will create only three URLs:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从很小的数字开始运行我们的模拟：两个生产者和两个消费者。每个生产者只会创建三个 URL：
- en: '[PRE30]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Even with these tiny numbers involved, you can still see the effects of using
    multiple threads to do the work:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 即使涉及到这些小数字，您仍然可以看到使用多个线程来完成工作的影响：
- en: '[PRE31]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The threads don’t take perfect, round-robin turns, but every thread does get
    at least some work time. And the consumers are not locked to specific producers.
    The idea is to make efficient use of limited resources. Producers can keep adding
    tasks without worrying about how long each task will take or whom to assign it
    to. Consumers, in turn, can grab a task without worry about other consumers. If
    one consumer gets handed a simple task and finishes before other consumers, it
    can go back and get a new task right away.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 线程不会完美地轮流执行，但每个线程都至少会有一些工作时间。消费者不会锁定到特定的生产者。我们的想法是有效利用有限的资源。生产者可以继续添加任务，而不必担心每个任务需要多长时间或分配给谁。消费者反过来可以获取任务，而不必担心其他消费者。如果一个消费者得到一个简单的任务并在其他消费者之前完成，它可以立即返回并获取一个新任务。
- en: Try running this example yourself and bump up some of those numbers. What happens
    with hundreds of URLs? What happens with hundreds of producers or consumers? At
    scale, this type of multitasking is almost required. You won’t find large programs
    out there that don’t use threads to manage at least some of their background work.
    Java’s own graphical package, Swing, needs a separate thread to keep the UI responsive
    and correct, no matter how small your application is.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试自己运行这个示例，并增加一些这些数字。当有数百个 URL 时会发生什么？当有数百个生产者或消费者时会发生什么？在规模上，这种类型的多任务处理几乎是必需的。你不会找到一个不使用线程来管理其后台工作的大型程序。即使你的应用程序很小，Java
    自己的图形包 Swing 也需要一个单独的线程来保持 UI 的响应和正确性。
- en: Synchronizing virtual threads
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 同步虚拟线程
- en: 'What about virtual threads? Do they have the same concurrency concerns? Mostly
    yes. Though lightweight, virtual threads still represent the standard “thread
    of execution” concept. They can still interrupt each other in messy ways and must
    still coordinate access to shared resources. But happily, the design goals of
    Project Loom come to the rescue. We can reuse all of our synchronizing tricks
    with virtual threads. In fact, to virtual thread-ify our URL producing-and-consuming
    demo, all we need to do is replace the chunk of code in the `main()` method that
    starts the threads:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 那虚拟线程呢？它们有相同的并发问题吗？大多数是的。虽然轻量级，虚拟线程仍代表标准的“执行线程”概念。它们仍然可以以混乱的方式相互中断，并且仍必须协调对共享资源的访问。但幸运的是，Project
    Loom 的设计目标拯救了我们。我们可以使用虚拟线程重用所有同步技巧。事实上，要使我们的 URL 生产和消费演示变为虚拟线程，我们只需要替换 `main()`
    方法中启动线程的代码块：
- en: '[PRE32]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The virtual threads honor the `synchronized` keyword in our `URLQueue` methods
    and understand the `join()` calls just like platform threads. If you compile `URLDemo2.java`
    and run it (don’t forget you may need to enable preview features), you will see
    the same output as before, with small variations from the random pauses, of course.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟线程遵守我们 `URLQueue` 方法中的 `synchronized` 关键字，并理解 `join()` 调用，就像平台线程一样。如果你编译并运行
    `URLDemo2.java`（不要忘记可能需要启用预览功能），你将看到与之前相同的输出，当然，会有一些来自随机暂停的小变化。
- en: We said virtual threads *mostly* have the same concurrency concerns as platform
    threads. We added that because creating and running virtual threads is a lot cheaper
    than managing a pool of platform threads so you don’t overwhelm the operating
    system. (Recall that each platform thread is mapped to one native thread.) You
    don’t pool virtual threads—you just make more.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说虚拟线程 *大多数情况* 下与平台线程具有相同的并发问题。我们之所以这样说是因为创建和运行虚拟线程比管理一组平台线程要便宜得多，因此你不会压垮操作系统。
    （请记住，每个平台线程都映射到一个本地线程。）你不需要对虚拟线程进行池化——你只需要创建更多。
- en: Accessing Class and Instance Variables from Multiple Threads
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从多个线程访问类和实例变量
- en: In the `SpreadSheet` example, we guarded access to a set of instance variables
    with a synchronized method in order to avoid a thread changing one of the variables
    while another thread was reading the others, to keep them coordinated.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `SpreadSheet` 示例中，我们通过一个同步方法保护对一组实例变量的访问，以避免一个线程在另一个线程读取其他变量时改变其中一个变量，以保持它们协调。
- en: 'But what about individual variable types? Do they need to be synchronized?
    Normally, no. Almost all operations on primitives and object reference types in
    Java happen *atomically*: that is, the JVM handles them in one step, with no opportunity
    for two threads to collide. This prevents threads from looking at references while
    other threads are accessing them.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 但是对于个别变量类型呢？它们需要同步吗？通常不需要。在 Java 中，几乎所有对基本类型和对象引用类型的操作都是 *原子的*：即 JVM 在一步中处理它们，没有两个线程会碰撞。这可以防止线程在其他线程访问它们时查看引用。
- en: Warning
  id: totrans-185
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Watch out—the JVM specification does not guarantee it will handle `double` and
    `long` primitive types atomically. Both of these types represent 64-bit values.
    The problem has to do with how the JVM’s stack works. You should synchronize access
    to your `double` and `long` instance variables through accessor methods or use
    an atomic wrapper class, which we’ll describe in [“Concurrency Utilities”](#learnjava6-CHP-9-SECT-7).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意——JVM 规范不保证会原子地处理 `double` 和 `long` 原始类型。这两种类型都表示 64 位值。问题在于 JVM 的堆栈工作方式。你应该通过访问器方法同步访问你的
    `double` 和 `long` 实例变量，或者使用原子包装类，我们将在[“并发工具”](#learnjava6-CHP-9-SECT-7)中描述。
- en: Scheduling and Priority
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调度和优先级
- en: Java makes few guarantees about how it schedules threads. Almost all thread
    scheduling is left up to the Java implementation and, to some degree, the application.
    Java’s designers could have specified a scheduling algorithm, but a single algorithm
    isn’t suitable for all the roles that Java can play. Instead, Java’s designers
    put the burden on you to write robust code that works no matter the scheduling
    algorithm, and let the implementation tune the algorithm for the best fit.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Java 对线程如何调度几乎没有任何保证。几乎所有的线程调度都留给了 Java 实现和在一定程度上的应用程序。Java 的设计者可以规定一个调度算法，但单一的算法并不适合
    Java 可以扮演的所有角色。相反，Java 的设计者让您编写能够在任何调度算法下都能正常工作的健壮代码，并且让实现调整算法以达到最佳适配。
- en: The priority rules in the Java language specification are carefully worded to
    be a general guideline for thread scheduling. You should be able to rely on this
    behavior overall (statistically), but it is not a good idea to write code that
    relies on very specific features of the scheduler to work properly. Instead, use
    the control and synchronization tools described in this chapter to coordinate
    your threads.^([7](ch09.html#id1843))
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Java 语言规范中的优先级规则被精心措辞为线程调度的一般指南。你应该能够在统计意义上依赖这种行为，但编写依赖调度器非常具体特性的代码并不是一个好主意。相反，请使用本章描述的控制和同步工具来协调您的线程。^([7](ch09.html#id1843))
- en: 'Every thread has a priority. In general, any time a thread of a higher priority
    than the current thread becomes runnable (is started, stops sleeping, or is notified),
    it preempts the lower-priority thread and begins executing. On some systems, threads
    with the same priority are scheduled *round-robin*, which means once a thread
    starts to run, it continues until it does one of the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 每个线程都有一个优先级。一般来说，只要高于当前线程优先级的线程变为可运行状态（启动、停止休眠或被通知），它将抢占低优先级线程并开始执行。在某些系统上，具有相同优先级的线程按*轮转法*调度，这意味着一旦线程开始运行，它将一直运行，直到执行以下操作之一：
- en: Sleeps, by calling `Thread.sleep()` or `wait()`
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调用`Thread.sleep()`或`wait()`来休眠
- en: Waits for a lock, in order to run a `synchronized` method
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待锁以运行`同步`方法
- en: Blocks an I/O, for example, in a `read()` or `accept()` call
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阻塞 I/O 操作，例如在`read()`或`accept()`调用中
- en: Explicitly yields control, by calling `yield()`
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调用`yield()`显式地让出控制权
- en: Terminates by completing its target method^([8](ch09.html#id1845))
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过完成其目标方法来终止^([8](ch09.html#id1845))
- en: This situation looks something like [Figure 9-8](#learnjava6-CHP-9-FIG-4).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 此情况类似于 [Figure 9-8](#learnjava6-CHP-9-FIG-4)。
- en: '![ljv6 0908](assets/ljv6_0908.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0908](assets/ljv6_0908.png)'
- en: Figure 9-8\. Priority-preemptive round-robin scheduling
  id: totrans-198
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-8\. 优先级抢占式轮转调度
- en: You can set a priority on a platform thread with the `setPriority()` method
    and you can see a thread’s current priority using the complementary `getPriority()`
    call. The priorities must fall within a range, bounded by the `Thread` class constants
    `MIN_PRIORITY` and `MAX_PRIORITY`. The default priority is held in the constant
    `NORM_PRIORITY`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`setPriority()`方法在平台线程上设置优先级，并且可以使用配套的`getPriority()`调用查看线程的当前优先级。优先级必须落在`Thread`类常量`MIN_PRIORITY`和`MAX_PRIORITY`定义的范围内。默认优先级存储在常量`NORM_PRIORITY`中。
- en: Note
  id: totrans-200
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Virtual threads all run with `NORM_PRIORITY`. If you call `setPriority()` on
    a virtual thread, the new priority you pass will simply be ignored.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟线程都以`NORM_PRIORITY`运行。如果在虚拟线程上调用`setPriority()`，则传递的新优先级将被简单忽略。
- en: Thread State
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程状态
- en: 'At any given time in its life cycle, a thread is in one of five general states.
    You can query them using the `getState()` method of the `Thread` class:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在其生命周期的任何时刻，线程处于五种一般状态之一。您可以使用`Thread`类的`getState()`方法来查询它们：
- en: '`NEW`'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`NEW`'
- en: The thread has been created but has not yet started.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 线程已创建但尚未启动。
- en: '`RUNNABLE`'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`RUNNABLE`'
- en: The thread is in its normal active state, even if it is blocked in an I/O operation,
    like a read or write to a file or a network connection.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 线程处于其正常的活动状态，即使它在执行 I/O 操作中被阻塞，例如读取或写入文件或网络连接。
- en: '`BLOCKED`'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`BLOCKED`'
- en: The thread is blocked, waiting to enter a synchronized method or code block.
    This includes times when a thread has been awakened by a `notify()` and is attempting
    to reacquire its lock after a `wait()`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 线程被阻塞，等待进入同步方法或代码块。这包括在调用`notify()`后被唤醒并试图在`wait()`后重新获取其锁的时候。
- en: '`WAITING, TIMED_WAITING`'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`WAITING, TIMED_WAITING`'
- en: The thread is waiting for another thread via a call to `wait()` or `join()`.
    In the case of `TIMED_WAITING`, the call has a timeout.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 线程正在等待另一个线程通过调用`wait()`或`join()`。在`TIMED_WAITING`情况下，调用具有超时。
- en: '`TERMINATED`'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`TERMINATED`'
- en: The thread has completed due to a return, an exception, or being stopped.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 线程由于返回、异常或停止而完成。
- en: 'You can show the state of all platform threads in the current thread group
    with the following snippet of code:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下代码片段显示当前线程组中所有平台线程的状态：
- en: '[PRE33]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `Thread.enumerate()` call will populate our `threads` array up to its length.
    You probably won’t use this method in general programming, but it is interesting
    and useful for experimenting and learning about Java threads.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread.enumerate()`调用将填充我们的`threads`数组，直到其长度。你可能不会在一般编程中使用这个方法，但它对于实验和学习Java线程非常有趣和有用。'
- en: Time-Slicing
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时间分片
- en: In addition to prioritization, all modern systems (with the exception of some
    embedded and “micro” Java environments) implement thread *time-slicing*. In a
    time-sliced system, thread processing is chopped up so that each thread runs for
    a short period of time before the context is switched to the next thread, as shown
    in [Figure 9-9](#learnjava6-CHP-9-FIG-5).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 除了优先级排序外，所有现代系统（除了一些嵌入式和“微”Java环境）都实现了线程*时间分片*。在时间分片系统中，线程处理被切割，以便每个线程在上下文切换到下一个线程之前运行一小段时间，如[图 9-9](#learnjava6-CHP-9-FIG-5)所示。
- en: '![ljv6 0909](assets/ljv6_0909.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0909](assets/ljv6_0909.png)'
- en: Figure 9-9\. Priority-preemptive time-sliced scheduling
  id: totrans-220
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-9\. 优先级抢占时间分片调度
- en: Higher-priority threads still preempt lower-priority threads in this scheme.
    Adding time-slicing mixes up the processing among threads of the same priority;
    on a multiprocessor machine, threads may even be run simultaneously. This can
    change the behavior of applications that don’t use threads and synchronization
    properly.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在此方案中，高优先级线程仍然可以抢占低优先级线程。添加时间分片会混合处理相同优先级的线程；在多处理器机器上，线程甚至可以同时运行。这可能会改变不正确使用线程和同步的应用程序的行为。
- en: 'Strictly speaking, because Java doesn’t guarantee time-slicing, you shouldn’t
    write code that relies on this type of scheduling; any software you write should
    function under round-robin scheduling. If you’re wondering what your particular
    flavor of Java does, try the following experiment:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，因为Java不保证时间分片，你不应该编写依赖这种调度类型的代码；你编写的任何软件都应该在轮转调度下正常运行。如果你想知道你的Java版本的行为，可以尝试以下实验：
- en: '[PRE34]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: When you run this example, you will see how your Java implementation does its
    scheduling. The `Thready` class starts up two `ShowThread` objects. `ShowThread`
    is a thread that goes into an unending loop^([9](ch09.html#id1854)) (generally
    bad form, but useful for this demonstration) and prints its message. Because we
    don’t specify a priority for either thread, they both inherit the priority of
    their creator, so they have the same priority. Under a round-robin scheme, only
    `Foo` should be printed; `Bar` should never appear. In a time-slicing implementation,
    you should occasionally see the `Foo` and `Bar` messages alternate.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此示例时，您将看到您的Java实现如何进行调度。`Thready`类启动两个`ShowThread`对象。`ShowThread`是一个进入无限循环^([9](ch09.html#id1854))（通常不好的形式，但对于此演示很有用）并打印其消息的线程。因为我们没有为任何线程指定优先级，它们都继承了它们创建者的优先级，所以它们具有相同的优先级。在轮转方案下，只应该打印`Foo`；`Bar`不应该出现。在时间分片实现中，您偶尔会看到`Foo`和`Bar`消息交替出现。
- en: The *ch09/examples* folder also contains a `VirtualThready` example if you want
    to see how virtual threads behave. They run with a “work-stealing” scheduler.
    (Feel free to dive into the [official Oracle docs](https://oreil.ly/qzfe0) on
    the fork/join framework where this algorithm is laid out.) We had to add some
    `join()` calls to the virtual thread version. Unlike the platform threads, virtual
    threads will not keep the JVM “awake” without these explicit requests to wait
    for the threads to complete.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '*ch09/examples*文件夹还包含一个`VirtualThready`示例，如果您想看看虚拟线程的行为。它们使用“工作窃取”调度程序运行。（请随意深入研究[官方Oracle文档](https://oreil.ly/qzfe0)，了解该算法在分支/合并框架中的实现。）我们必须向虚拟线程版本添加一些`join()`调用。与平台线程不同，虚拟线程在没有这些显式的等待请求时不会使JVM“保持唤醒”状态。'
- en: Priorities
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优先级
- en: Thread priorities are a general guideline for how the JVM should allocate time
    among competing threads. Unfortunately, Java platform threads are mapped to native
    threads in such complex ways that you can’t rely upon the exact meaning of priorities.
    Instead, consider them a hint to the JVM.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 线程优先级是JVM在竞争线程之间分配时间的一般指导原则。不幸的是，Java平台线程以复杂的方式映射到本机线程，以至于你不能依赖优先级的确切含义。相反，把它们视为JVM的一个提示。
- en: 'Let’s play with the priority of our threads:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来调整我们线程的优先级：
- en: '[PRE35]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You might expect that with this change to our `Thready2` class, the `Bar` thread
    will take over completely. If you run this code on an old Solaris implementation
    of Java 5.0, that’s exactly what happens. The same is not true on most modern
    versions of Java. Similarly, if you change the priorities to values other than
    min and max, you may not see any difference at all. The subtleties of priority
    and performance relate to how Java threads and priorities are mapped to real threads
    in the OS. For this reason, you should generally reserve adjusting thread priorities
    for system and framework development.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能期望通过这对我们的`Thready2`类的更改，`Bar`线程将完全接管。如果您在旧版 Solaris 实现的 Java 5.0 上运行此代码，确实会发生这种情况。但对于大多数现代版本的
    Java 并非如此。同样地，如果将优先级更改为除最小和最大之外的值，则可能根本看不到任何区别。优先级和性能的微妙之处与 Java 线程和优先级如何映射到操作系统中的实际线程有关。因此，通常应保留调整线程优先级的权利供系统和框架开发使用。
- en: Thread Performance
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程性能
- en: The use of threads has dictated the form and functionality of several Java packages.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 线程的使用决定了几个 Java 包的形式和功能。
- en: The Cost of Synchronization
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步的成本
- en: Acquiring locks to synchronize threads takes time, even when there is no contention.
    In older implementations of Java, this time could be significant. With newer JVMs,
    it is almost negligible. However, unnecessary low-level synchronization can still
    slow applications by blocking threads where concurrent access could be allowed.
    To avoid this penalty, two important APIs, the Java collections framework and
    the Swing API, were specifically crafted to put synchronization under the developer’s
    control.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 获取锁来同步线程需要时间，即使没有竞争。在旧版 Java 实现中，这段时间可能是显著的。使用较新的 JVM，这几乎可以忽略不计。然而，不必要的低级别同步仍然可能通过阻塞线程来减慢应用程序。为了避免这种惩罚，两个重要的
    API，Java 集合框架和 Swing API，特别设计为让开发人员控制同步。
- en: The `java.util` collections framework replaces earlier, simple Java aggregate
    types—namely, `Vector` and `Hashtable`—with more fully featured and, notably,
    unsynchronized types (`List` and `Map`). The collections framework instead defers
    to application code to synchronize access to collections when necessary, and provides
    special “fail fast” functionality to help detect concurrent access and throw an
    exception. It also provides synchronization “wrappers” that can provide safe access
    in the old style. Special concurrent-access-friendly implementations of the `Map`
    and `Queue` collections are included as part of the `java.util.concurrent` package.
    These implementations go even further and allow a high degree of concurrent access
    without any user synchronization.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util` 集合框架用更全面功能的未同步类型（`List` 和 `Map`）替代了早期简单的 Java 聚合类型，即`Vector` 和
    `Hashtable`。集合框架反而让应用程序代码来同步访问集合时必要的部分，并提供特殊的“快速失败”功能以帮助检测并发访问并抛出异常。它还提供同步“包装器”，可以以旧式风格提供安全访问。作为
    `java.util.concurrent` 包的一部分，特殊的支持并发访问的 `Map` 和 `Queue` 集合的实现进一步允许高度并发的访问，而无需用户同步。'
- en: 'The Java Swing API takes a different approach to providing speed and safety.
    Swing uses a single thread to modify its components, with an exception: the *event
    dispatch thread*, also called the event queue. Swing solves performance problems
    and any event ordering issues by forcing a single super-thread to control the
    GUI. The application accesses the event dispatch thread indirectly by pushing
    commands onto a queue through a simple interface. We’ll see how to do just that
    in [Chapter 12](ch12.html#learnjava6-CHP-12).'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Java Swing API 采用了一种不同的方法来提供速度和安全性。Swing 使用单个线程来修改其组件，有一个例外：*事件分发线程*，也称为事件队列。Swing
    通过强制一个超级线程控制 GUI 来解决性能问题和任何事件顺序问题。应用程序通过简单的接口间接地访问事件分发线程，通过将命令推送到队列中来实现。我们将在[第12章](ch12.html#learnjava6-CHP-12)中详细了解如何做到这一点。
- en: Thread Resource Consumption
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程资源消耗
- en: A fundamental pattern in Java is to start many threads to handle asynchronous
    external resources, such as socket connections. For maximum efficiency, a web
    developer might be tempted to create a thread for each client connection on a
    server. When each client has its own thread, I/O operations can block and resume
    as needed. But as efficient as this may be in terms of throughput for a given
    client, it is a very inefficient use of server resources.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: Java 中的一个基本模式是启动多个线程来处理异步外部资源，比如套接字连接。为了最大效率，Web 开发人员可能会诱惑创建每个客户端连接的线程。当每个客户端有自己的线程时，I/O
    操作可以根据需要阻塞和恢复。但尽管对于给定客户端的吞吐量而言这可能是高效的，但这是一种非常低效的服务器资源利用方式。
- en: Threads consume memory; each thread has its own “stack” for local variables,
    and switching between running threads (known as *context switching*) adds overhead
    to the CPU. Threads are relatively lightweight. It is possible to have hundreds
    or thousands running on a large server. But after a certain point, the cost of
    managing the existing threads starts to outweigh the benefits of starting more
    threads. Creating a thread per client is not always a scalable option.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 线程会消耗内存；每个线程都有自己的“栈”用于本地变量，并在运行线程之间切换时（称为*上下文切换*）会增加 CPU 开销。线程相对较轻量级。在大型服务器上可以运行数百或数千个线程是可能的。但在某一点之后，管理现有线程的成本开始超过启动更多线程的好处。为每个客户端创建一个线程并不总是可扩展的选择。
- en: An alternative approach is to create “thread pools” where a fixed number of
    threads pull tasks from a queue and return for more work when they are finished.
    This recycling of threads makes for solid scalability, but it has often been difficult
    to implement efficiently for servers in Java. Basic I/O (for things like sockets)
    in Java does not fully support nonblocking operations. The `java.nio` package,
    New I/O (or simply NIO), has asynchronous I/O channels. Channels can perform nonblocking
    reads and writes. They also have the ability to test the readiness of streams
    for moving data. Threads can close channels asynchronously, making for graceful
    interactions. We’ll discuss NIO in the coming chapters on working with files and
    network connections.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是创建“线程池”，在这里固定数量的线程从队列中拉取任务，并在完成后返回以继续工作。这种线程的重复使用使得系统具有良好的可伸缩性，但在 Java
    服务器上高效实现这一点通常较为困难。Java 的基本 I/O（如套接字）并不完全支持非阻塞操作。`java.nio` 包，即 New I/O（或简称 NIO），具有异步
    I/O 通道。通道可以执行非阻塞读写操作。它们还具有测试流准备好传输数据的能力。线程可以异步关闭通道，使交互更加优雅。我们将在接下来讨论与文件和网络连接工作的章节中讨论
    NIO。
- en: Java provides thread pools and job “executor” services as part of the `java.util.concurrent`
    package. This means you don’t have to write these yourself. We’ll summarize them
    when we discuss the concurrency utilities in Java.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Java 提供了线程池和作业“执行器”服务作为 `java.util.concurrent` 包的一部分。这意味着你不必自己编写这些功能。在讨论 Java
    的并发工具时，我们将对它们进行总结。
- en: Virtual Thread Performance
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚拟线程性能
- en: Project Loom set out to improve thread performance—especially when thousands
    or millions of threads are involved. The code of a `run()` method isn’t any faster
    or slower when you run it on a platform thread versus a virtual thread. What is
    faster, though, is creating and managing those threads.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Project Loom 的目标是提高线程性能——尤其是当涉及数千甚至数百万个线程时。在平台线程与虚拟线程上运行 `run()` 方法的速度没有任何差异。然而，创建和管理这些线程的速度更快。
- en: 'Let’s take another look at our `URLDemo` class. Rather than four threads total,
    let’s crank that number up to several thousand. We’ll drop our producers and prepopulate
    the queue with URLs so we can focus on our new consumers. We’ll make consumers
    whose only job is to consume one URL—no random, artificial delay before going
    back for another URL. This behavior mimics a real use case for virtual threads:
    a single server that handles millions of small requests in a short period. We’ll
    also modify our print statements to show up at milestones rather than after every
    single URL is consumed. Our new `URLDemo3` will take two optional command-line
    arguments: the number of URLs to create (default is 100,000) and whether to use
    platform or virtual threads (default is platform), so we can compare the difference
    in performance.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看看我们的`URLDemo`类。而不是总共四个线程，我们将这个数字提升到数千个。我们将取消生产者，并预先填充队列以便我们可以专注于我们的新消费者。我们将创建只需消耗一个URL的消费者——在获取另一个URL之前没有随机的、人为的延迟。这种行为模仿了虚拟线程的一个真实用例：一个单一的服务器在短时间内处理数百万个小请求。我们还将修改我们的打印语句，以便在里程碑出现而不是在每个URL被消耗后出现。我们的新`URLDemo3`将接受两个可选的命令行参数：要创建的URL数量（默认为100,000）以及是否使用平台线程还是虚拟线程（默认为平台），这样我们可以比较性能的差异。
- en: 'Check out the source code for `URLConsumer3` in the *ch09/examples* folder
    to see the tweaks we made for this new variation. Then let’s look more carefully
    at the processing loop in the `main()` method to see how it handles the new consumers.
    Here’s the relevant section:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`ch09/examples`文件夹中`URLConsumer3`的源代码，以查看我们为这个新变体所做的调整。然后让我们仔细看看`main()`方法中的处理循环，看看它如何处理新的消费者。这里是相关部分：
- en: '[PRE36]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This code doesn’t try to reuse consumers. There are valid reasons not to reuse
    threads in the real world, by the way. You have to manually clean up some shared
    data between uses, for example. Forget that bit of “administrivia” and you might
    leak sensitive information. (If you were processing bank transactions, you wouldn’t
    want to accidentally use the previous account number.) You can often simplify
    your code by assuming a single thread will do all of the work and then terminate.
    This is true whether or not you’re using virtual threads.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码并不尝试重用消费者。顺便说一句，在现实世界中不重用线程有一些有效的原因。例如，你必须在使用之间手动清理一些共享数据。忘记了这一点的“行政琐事”，你可能会泄露敏感信息。（如果你在处理银行交易，你不会想意外使用之前的账号。）你可以通过假设一个单一线程会完成所有工作然后终止来简化你的代码。无论你是否使用虚拟线程，这一点都是正确的。
- en: We tried this version with 1,000,000 URLs on a middling Linux desktop system.
    The platform threads cleared the queue in just under one minute (58.661 s according
    to the coarse `time` utility). Not bad! The virtual threads, on the other hand,
    cleared the queue in just under *2 seconds* (1.867 s). The testing for a milestone
    URL to print is trivial. It’s not the task each consumer does that slows things
    down. The real bottleneck with platform threads is asking the operating system
    for a new, expensive resource thousands of times. Project Loom removes a lot of
    that expense. Using virtual threads is not a guarantee of better performance,
    but in cases like this, it certainly can be a benefit!
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在中等的Linux桌面系统上使用1,000,000个URL测试了这个版本。平台线程在近一分钟内清除了队列（根据粗略的`time`实用程序为58.661秒）。效果不错！另一方面，虚拟线程在不到*2秒*（1.867秒）的时间内清除了队列。测试一个里程碑URL以打印是微不足道的。拖慢速度的不是每个消费者所做的任务。平台线程的真正瓶颈是数千次请求操作系统获取新的、昂贵的资源。Project
    Loom消除了许多这种开销。使用虚拟线程并不保证更好的性能，但在这种情况下，它肯定会有所好处！
- en: Concurrency Utilities
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发工具
- en: 'So far in this chapter, we’ve demonstrated how to create and synchronize threads
    at a low level, using Java language primitives. The `java.util.concurrent` package
    and subpackages build on this functionality, adding important threading utilities
    and codifying some common design patterns by supplying standard implementations.
    Roughly in order of generality, these areas include:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在这一章中，我们演示了如何使用Java语言基元创建和同步线程。`java.util.concurrent`包和子包在此基础上构建，添加了重要的线程实用程序，并通过提供标准实现来编码一些常见的设计模式。这些领域的通用性大致按照以下顺序排列：
- en: '*Thread-aware Collections implementations*'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '*线程感知的集合实现*'
- en: The `java.util.concurrent` package augments the Java Collections API in [Chapter 7](ch07.html#learnjava6-CHP-7)
    with several implementations for specific threading models. These include timed
    wait and blocking implementations of the `Queue` interface, as well as nonblocking,
    concurrent-access optimized implementations of the `Queue` and `Map` interfaces.
    The package also adds “copy on write” `List` and `Set` implementations for extremely
    efficient “almost always read” cases. These may sound complex, but they cover
    some common cases very well.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.concurrent`包在[第7章](ch07.html#learnjava6-CHP-7)中通过几种特定线程模型的实现增强了Java集合API。这些包括`Queue`接口的定时等待和阻塞实现，以及非阻塞、并发访问优化的`Queue`和`Map`接口实现。该包还为极其高效的“几乎总是读取”情况添加了“写时复制”`List`和`Set`实现。这些听起来可能很复杂，但它们很好地涵盖了一些常见情况。'
- en: '`Executors`'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`Executors`'
- en: '`Executor`s run tasks, including `Runnable`s, and abstract the concept of thread
    creation and pooling from the user (meaning you don’t have to write your own).
    `Executors` are intended to be a high-level replacement for creating new threads
    to service a series of jobs. Along with `Executor`, the `Callable` and `Future`
    interfaces allow management, value return, and exception handling.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`Executor`们运行任务，包括`Runnable`们，并将线程创建和池化的概念从用户抽象出来（这意味着你不需要自己编写）。`Executors`旨在作为一个高级别的替代品，用于创建新线程以处理一系列作业。与`Executor`一起，`Callable`和`Future`接口允许管理、返回值和异常处理。'
- en: '*Low-level synchronization constructs*'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '*低级别同步构造*'
- en: The `java.util.concurrent.locks` package holds a set of classes, including `Lock`
    and `Condition`, that parallels the Java language-level synchronization primitives
    and promotes them to the level of a concrete API. For example, the `LockSupport`
    helper class includes two methods, `park()` and `unpark()`, that replace the deprecated
    `suspend()` and `resume()` methods from the `Thread` class. The locks package
    also adds the concept of nonexclusive reader/writer locks, allowing for greater
    concurrency in synchronized data access.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.concurrent.locks`包包含一组类，包括`Lock`和`Condition`，这些类与Java语言级别的同步原语类似，并将它们提升到具体API的级别。例如，`LockSupport`辅助类包括两种方法，`park()`和`unpark()`，它们替代了`Thread`类中已弃用的`suspend()`和`resume()`方法。锁包还添加了非排他读/写锁的概念，允许在同步数据访问中实现更大的并发性。'
- en: '*High-level synchronization constructs*'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '*高级别同步构造*'
- en: This includes the classes `CyclicBarrier`, `CountDownLatch`, `Semaphore`, and
    `Exchanger`. These classes implement common synchronization patterns drawn from
    other languages and systems, and they can serve as the basis for new high-level
    tools.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这包括`CyclicBarrier`、`CountDownLatch`、`Semaphore`和`Exchanger`类。这些类实现了从其他语言和系统中借鉴的常见同步模式，并可以作为新高级工具的基础。
- en: '*Atomic operations (sounds very James Bond, doesn’t it?)*'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '*原子操作（听起来非常像詹姆斯·邦德，是吧？）*'
- en: The `java.util.concurrent.atomic` package provides wrappers and utilities for
    atomic, “all-or-nothing” operations on primitive types and references. This includes
    simple combination atomic operations like testing a value before setting it, and
    getting and incrementing a number in one operation.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.concurrent.atomic`包提供了对原始类型和引用执行原子“全有或全无”操作的包装器和实用程序。这包括简单组合原子操作，如在设置值之前测试值，并在一个操作中获取和增加数字。'
- en: With the possible exception of optimizations done by the Java VM for the `atomic`
    operations package, all of these utilities are implemented in pure Java, on top
    of the standard Java language synchronization constructs. This means that they
    are in a sense only convenience utilities and don’t truly add new capabilities
    to the language. Their main role is to offer standard patterns and idioms in Java
    threading, making them safer and more efficient to use. A good example of this
    is the `Executor` utility, which allows a user to manage a set of tasks in a predefined
    threading model without having to delve into creating threads at all. Higher-level
    APIs like this both simplify coding and allow for greater optimization of the
    common cases.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Java VM对`atomic`操作包的优化外，所有这些实用程序都是用纯Java实现的，基于标准的Java语言同步构造。这意味着它们从某种意义上说只是便利工具，并没有真正为语言添加新的功能。它们的主要作用是在Java线程编程中提供标准模式和习惯用法，使其更安全和高效。一个很好的例子是`Executor`实用程序，它允许用户在预定义的线程模型中管理一组任务，而无需深入创建线程。这样的高级API不仅简化了编码，还允许更大程度的优化常见情况。
- en: Upgrading Our Queue Demo
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 升级我们的队列演示
- en: 'Many of the concurrency features built into Java will be more useful to you
    on larger, more complex projects. But we can still upgrade our meager URL processing
    demo by using the thread-safe `ConcurrentLinkedQueue` class from the `java.util.concurrent`
    package. We can parameterize its type and do away with our custom `URLQueue` class
    entirely:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 许多内建到Java中的并发特性在大型、更复杂的项目中会更加有用。但我们可以通过使用`java.util.concurrent`包中的线程安全的`ConcurrentLinkedQueue`类来升级我们那个简陋的URL处理演示。我们可以对其类型进行参数化，并完全摒弃我们自定义的`URLQueue`类：
- en: '[PRE37]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We do have to tweak the consumer and producer code a little, but only a little,
    and mostly just to use the normal queue operation names of `add` and `poll` instead
    of our custom, URL-centric method names. But we don’t have to worry about the
    `URLQueue` class at all. Sometimes you will need custom data structures because
    the real world is messy. But if you can use one of the synchronized storage options
    built in, you know you’re getting robust storage and access that you can safely
    use in your multithreaded application.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要稍微调整消费者和生产者的代码，但只是一点点，并且主要是为了使用普通队列操作的名称`add`和`poll`，而不是我们自定义的、以URL为中心的方法名称。但我们根本不需要担心`URLQueue`类。有时候你会需要自定义数据结构，因为现实世界是混乱的。但如果你能使用其中一个内置的同步存储选项，你就知道你得到了可以安全在多线程应用中使用的健壮存储和访问。
- en: 'Another upgrade to consider is the atomic convenience classes. You might recall
    that our consumer class has a Boolean flag that can be set to false to end the
    consumer’s processing loop. Since it’s reasonable to assume that multiple threads
    might have access to our consumer, we can remake that flag as an instance of the
    `AtomicBoolean` class to make sure that warring threads can’t clobber our poor
    flag. (We could make our accessor method `synchronized`, of course, but we want
    to highlight some of the existing options already in the JDK.) Here’s a look at
    the interesting parts of `URLConsumer4`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个考虑的升级是原子便利类。您可能还记得我们的消费者类有一个布尔标志，可以设置为false以结束消费者的处理循环。由于我们可以合理地假设多个线程可能访问我们的消费者，我们可以将该标志重新制作为`AtomicBoolean`类的实例，以确保战斗中的线程不能摧毁我们可怜的标志。（当然，我们可以使我们的访问方法`synchronized`，但我们想要突出显示JDK中已经存在的一些选项。）以下是`URLConsumer4`的有趣部分的简要概述：
- en: '[PRE38]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Using `AtomicBoolean` requires a smidge more typing—calling set/get methods
    rather than simple assignments or comparisons—but you get all the safe handling
    you could wish for. When you have complex, multithreaded logic everywhere, you
    might do your own state management. In situations where you don’t have much other
    code that requires synchronization, though, these convenience classes can be very
    convenient indeed.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`AtomicBoolean`需要更多的打字工作——调用设置/获取方法而不是简单的赋值或比较——但您可以得到所有您希望的安全处理。当您在各处具有复杂的多线程逻辑时，您可能会进行自己的状态管理。然而，在没有太多其他需要同步的代码的情况下，这些便利类确实非常方便。
- en: Structured Concurrency
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构化并发
- en: Beyond the impressive improvements that virtual threads bring to highly concurrent
    applications, Project Loom also brings structured concurrency to Java. You may
    have heard about “parallel programming” in the threaded world. You have the option
    of pursuing a parallel programming solution when you can break a larger problem
    into smaller problems that can be solved separately and at the same time (in parallel,
    get it?).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 除了虚拟线程为高并发应用带来的令人印象深刻的改进之外，Project Loom还为Java引入了结构化并发。您可能听说过在线程世界中的“并行编程”。当您可以将一个较大的问题分解为可以分别解决且同时解决的更小问题（并行处理）时，您可以选择追求并行编程解决方案（明白了吧？）。
- en: This notion of a large task that can be turned into subtasks shares many similarities
    with our demo that uses producers and consumers, but the two types of problems
    are not entirely the same. One big difference lies in how to handle errors. If
    we failed to create a consumer in our `URLDemo` classes, for example, we could
    just create another one and continue on. But if a subtask fails in a parallel
    computation, it isn’t as obvious how to recover. Should all of the other subtasks
    be canceled? What if some of them have already completed? What if we want to cancel
    the larger “parent” task?
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 将大任务分解成子任务的这个概念与我们使用生产者和消费者的演示有许多相似之处，但这两种类型的问题并不完全相同。一个重大的区别在于如何处理错误。例如，如果我们在`URLDemo`类中创建消费者失败，我们可以简单地创建另一个并继续进行。但如果并行计算中的一个子任务失败，如何恢复就不那么明显了。应该取消所有其他子任务吗？如果其中一些已经完成了怎么办？如果我们想取消更大的“父”任务怎么办？
- en: Java 19 introduced an incubator feature, the `StructuredTaskScope` class, to
    better encapsulate the work done with subtasks. (If you were to call a preview
    feature like virtual threads a “beta” enhancement, incubator features would be
    an “alpha” enhancement.) You can read about the design goals and implementation
    details in [JEP 428](https://oreil.ly/HBbfE). We won’t work with structured concurrency
    or executors in this book, but it is important to know that Java has many tools
    available to developers who are working with parallel and concurrent applications.
    Indeed, the support it provides to developers in this arena is precisely why Java
    remains such a popular workhorse in production backends.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Java 19引入了一个孵化器特性，`StructuredTaskScope`类，用于更好地封装子任务的工作。 （如果您把像虚拟线程这样的预览功能称为“β”增强功能，那么孵化器特性将是“α”增强功能。）您可以在[JEP
    428](https://oreil.ly/HBbfE)中了解其设计目标和实现细节。虽然本书不会介绍结构化并发性或执行器，但重要的是要知道Java为开发人员在处理并行和并发应用程序时提供了许多工具。事实上，Java在这个领域为开发人员提供的支持正是为什么它仍然是生产后端的流行工具。
- en: So Many Threads to Pull
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 那么多要处理的线程
- en: While we won’t be looking any deeper at the concurrency packages in this chapter,
    we want you to know where you might dig next if concurrency is interesting to
    you or proves useful in the type of problems you encounter at work. As we (foot)noted
    in [“Synchronizing a queue of URLs”](#learnjava6-CHP-9-SECT-4.1.1), *[Java Concurrency
    In Practice](https://jcip.net)* by Brian Goetz, is required reading for real-world,
    multithreaded projects. We also want to give a shout-out to Doug Lea, the author
    of *Concurrent Programming in Java* (Addison-Wesley), who led the group that added
    these packages to Java and is largely responsible for creating them.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本章我们不会深入研究并发包，但如果并发对您有趣或在您遇到的问题类型中证明有用，我们希望您知道接下来可以深入了解的地方。正如我们在[“同步URL队列”](#learnjava6-CHP-9-SECT-4.1.1)中所注明的，*《Java并发编程实践》（https://jcip.net）*
    by Brian Goetz是实现真实世界多线程项目所必需的阅读材料。我们也要向Doug Lea致敬，他是*《Java并发编程》（Addison-Wesley）*的作者，领导了添加这些包到Java中的团队，并且在创建它们方面负有重大责任。
- en: Alongside threads, Java’s native support for basic file input and output (I/O)
    figures prominently in production applications. We’ll look at the main classes
    for typical I/O in the next chapter.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 除了线程之外，Java对基本文件输入和输出（I/O）的本机支持在生产应用程序中占据了重要位置。在下一章中，我们将查看典型I/O的主要类。
- en: Review Questions
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复习问题
- en: What is a thread?
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是线程？
- en: What keyword can you add to a method if you want threads to “take turns” when
    calling it? (Meaning no two threads should be executing the method at the same
    time to avoid corrupting shared data.)
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果要求线程“轮流”调用方法（意味着不能同时执行该方法的两个线程以避免损坏共享数据），可以向方法添加什么关键字？
- en: What flags allow you to compile a Java program that includes preview feature
    code?
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些标志允许您编译包含预览功能代码的Java程序？
- en: What flags allow you to run a Java program that includes preview feature code?
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些标志允许您运行包含预览功能代码的Java程序？
- en: How many platform threads can one native thread support?
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个本机线程支持多少平台线程？
- en: How many virtual threads can one native thread support?
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个本机线程支持多少虚拟线程？
- en: Is the statement `x = x + 1;` an atomic action for the variable `x`?
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 语句`x = x + 1;`对变量`x`来说是原子操作吗？
- en: What package includes thread-safe versions of popular collection classes like
    `Queue` and `Map`?
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个包包含流行集合类（如`Queue`和`Map`）的线程安全版本？
- en: Code Exercises
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码练习
- en: Let’s build a clock! Using a needle and thread—er, a `JLabel` and a `Thread`—make
    a small graphical clock application. The *Clock.java* file in the *ch09/exercises*
    folder contains a skeleton app that puts up a small window with a simple `JLabel`
    object. We bumped up the size of the label’s font to make things more readable.
    Your clock should show hours, minutes, and seconds, at a minimum. Create a thread
    that will sleep for one second and then increment the clock’s display. Feel free
    to revisit the date and time formatting examples from [“Formatting Dates and Times”](ch08.html#learnjava6-CHP-8-SECT-5.5).
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们建立一个时钟！使用一个`JLabel`和一个`Thread`（或者可以理解为一个指针和一个线程），制作一个小型图形时钟应用程序。*Clock.java*文件在*ch09/exercises*文件夹中包含一个骨架应用程序，它会在窗口中显示一个简单的`JLabel`对象。我们增加了标签字体的大小以提高可读性。您的时钟应该至少显示小时、分钟和秒。创建一个线程，让它睡眠一秒钟，然后增加时钟的显示。可以回顾一下[“格式化日期和时间”](ch08.html#learnjava6-CHP-8-SECT-5.5)中的日期和时间格式化示例。
- en: The apple tossing game in the *ch09/exercises/game* folder currently uses a
    platform thread for its first foray into the world of animation following the
    discussion in [“Revisiting Animation with Threads”](#learnjava6-CHP-9-SECT-1.3).
    Compile and run it to see an apple launch itself when the game starts. The apple
    won’t hit anything, but it will move in an arc as though tossed. We’ll make this
    animation more interesting and more interactive in [Chapter 12](ch12.html#learnjava6-CHP-12).
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*ch09/exercises/game* 文件夹中的苹果投掷游戏目前使用平台线程，按照[“重访线程动画”](#learnjava6-CHP-9-SECT-1.3)中的讨论，启动游戏时苹果会被抛出。苹果不会撞到任何东西，但会像被投掷一样弧线移动。我们将在[第12章](ch12.html#learnjava6-CHP-12)中使这个动画更有趣和更具互动性。'
- en: Once you have a feel for the intended animation, convert the platform thread
    to a virtual thread. Compile your new version and verify it still works as expected.
    (Remember that, depending on your version of Java, you may need to compile and
    run with the extra preview flags.)
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦你掌握了预期动画的感觉，将平台线程转换为虚拟线程。编译你的新版本并验证它仍然按预期工作。（请记住，根据你的Java版本，你可能需要使用额外的预览标志进行编译和运行。）
- en: ^([1](ch09.html#id1771-marker)) Historically, `interrupt()` has not worked consistently
    in all Java implementations.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch09.html#id1771-marker)) 从历史上看，`interrupt()` 在所有Java实现中并不一致。
- en: ^([2](ch09.html#id1793-marker)) The term daemon (often pronounced day-mun in
    Unix circles) was inspired by [Maxwell’s demon](https://oreil.ly/YGQMt) and refers
    to the Greek term for a lesser deity, not a malevolent spirit.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch09.html#id1793-marker)) “守护进程”一词（在Unix圈子里通常读作day-mun）灵感来自[Maxwell's
    demon](https://oreil.ly/YGQMt)，指的是希腊词汇中对较低神灵的称呼，而非恶意精灵。
- en: ^([3](ch09.html#id1797-marker)) Many Java enhancements start out as works-in-progress
    with spiffy names like “Loom.”
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch09.html#id1797-marker)) 许多Java增强功能最初都是带有“Loom”之类时髦名称的工作进展。
- en: '^([4](ch09.html#id1810-marker)) Sadly, the single- versus double-dash prefixes
    on these options are not typos. Command-line arguments have quite a storied history
    in their own right, and Java and its tools are old enough to have inherited some
    of the legacy patterns while still needing to accommodate modern approaches. Most
    options work with either prefix, but occasionally you have to obey what seems
    like an unwritten rule. When in doubt, tools like *javac* support another option:
    `-help` (or `--help`). Supplying that argument will print out a concise list of
    options and relevant details.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch09.html#id1810-marker)) 不幸的是，这些选项上的单破折号和双破折号前缀并非打字错误。命令行参数有着相当悠久的历史，Java及其工具足够古老，以至于继承了一些遗留模式，同时仍需适应现代方法。大多数选项支持任意前缀，但偶尔需要遵循看似未写下的规则。犹豫不决时，像*javac*这样的工具支持另一选项：`-help`（或
    `--help`）。提供该参数将打印出简明的选项列表和相关细节。
- en: ^([5](ch09.html#id1818-marker)) Don’t confuse the term *serialize* in this context
    with Java *object serialization*, which is a mechanism for making objects persistent.
    The underlying meaning (to place one thing after another) is the same, however.
    In the case of object serialization, the object’s data is laid out, byte for byte,
    in a certain order. With threads, each thread gets access to the synchronized
    resource in turn.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch09.html#id1818-marker)) 不要混淆此上下文中的“序列化”术语与Java中的“对象序列化”，后者是一种使对象持久化的机制。然而，基础含义（依次放置一件事物）是相同的。在对象序列化的情况下，对象的数据按照一定顺序逐字节布局。对于线程而言，每个线程依次访问同步资源。
- en: ^([6](ch09.html#id1823-marker)) Even with the ability to tolerate minor discrepancies
    in the state of objects, modern, multicore systems can wreak havoc without perfect
    knowledge of the application. And perfection is difficult! If you expect to work
    with threads in the real world, [*Java Concurrency in Practice*](https://jcip.net)
    by Brian Goetz et al. (Addison-Wesley) is *required* reading.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch09.html#id1823-marker)) 即使能够容忍对象状态的轻微差异，现代多核系统在没有完美应用知识的情况下可能会造成严重破坏。而实现完美是困难的！如果你打算在现实世界中使用线程，[*Java并发编程实战*](https://jcip.net)（由Brian
    Goetz等人编著，Addison-Wesley出版社）是*必读*之作。
- en: ^([7](ch09.html#id1843-marker)) *Java Threads* by Scott Oaks and Henry Wong
    (O’Reilly) includes a detailed discussion of synchronization, scheduling, and
    other thread-related issues.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch09.html#id1843-marker)) 《Java Threads》（由Scott Oaks和Henry Wong编著，O'Reilly出版社）详细讨论了同步、调度和其他与线程相关的问题。
- en: ^([8](ch09.html#id1845-marker)) Technically, a thread can also terminate with
    the [deprecated `stop()` call](https://oreil.ly/AbbQk), but as we noted at the
    start of the chapter, this is bad for myriad reasons.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](ch09.html#id1845-marker)) 从技术上讲，线程也可以通过[已废弃的 `stop()` 调用](https://oreil.ly/AbbQk)来终止，但正如我们在本章开头提到的那样，这种做法有很多问题。
- en: ^([9](ch09.html#id1854-marker)) You can type Control-C to exit the demo when
    you get tired of seeing `Foos` fly by.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: ^([9](ch09.html#id1854-marker)) 当你看腻了飞来飞去的`Foos`时，可以按 Control-C 退出演示。
