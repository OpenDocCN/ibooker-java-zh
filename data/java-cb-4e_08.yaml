- en: Chapter 8\. Object-Oriented Techniques
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。面向对象技术
- en: 8.0 Introduction
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.0 引言
- en: Java is an Object-Oriented (OO) language in the tradition of Simula-67, SmallTalk,
    and C++. It borrows syntax from C++ and ideas from SmallTalk. The Java API has
    been designed and built on the OO model. Design patterns (see the book of the
    same name), such as Factory and Delegate, are used throughout; an understanding
    of these patterns will help you better understand the use of the API and improve
    the design of your own classes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Java是一种面向对象（OO）语言，传承自Simula-67、SmallTalk和C++的传统。它借用了C++的语法和SmallTalk的思想。Java
    API是根据OO模型设计和构建的。设计模式（参见同名书籍），如工厂模式和委托模式，广泛应用；理解这些模式将帮助你更好地使用API并改进你自己类的设计。
- en: Advice, or Mantras
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 建议或者口头禅
- en: There are any number of short bits of advice that I could give. A few recurring
    themes arise when learning the basics of Java, and I suggest reviewing them when
    learning more Java.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以给你很多短小的建议。学习Java基础时会出现一些反复出现的主题，我建议在学习更多Java时复习一下它们。
- en: Use the API
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用API
- en: I can’t say this often enough. A lot of the things you need to do have already
    been done by the good folks who develop the standard Java library (and third-party
    libraries). And this grows with every release. Learning the API well is a good
    grounds for avoiding that deadly “reinventing the flat tire” syndrome—coming up
    with a second-rate equivalent of a first-rate product that was available to you
    the whole time. In fact, part of this book’s mission is to prevent you from reinventing
    what’s already there. One example of this is the Collections API in `java.util`,
    discussed in [Chapter 7](ch07.html#javacook-structure). The Collections API has
    a high degree of generality and regularity, so there is often no need to invent
    your own data structuring code.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我无法强调这一点的重要性。很多你需要做的事情已经被开发标准Java库（以及第三方库）的好人们做过了。随着每一个新版本的发布，这些事情也在不断增加。充分了解API是避免“重复造轮子”这种致命病的良好基础——也就是说，不要浪费时间去发明一个低劣的复制品，而那些一流产品早就为你准备好了。事实上，本书的部分使命就是防止你重新发明已经存在的东西。其中一个例子就是`java.util`中讨论的Collections
    API，见[第7章](ch07.html#javacook-structure)。Collections API 具有很高的通用性和规律性，所以通常没有必要发明你自己的数据结构代码。
- en: Exceptions to the rule
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 规则的例外
- en: 'There is one exception to the rule of using the API: the `clone()` method in
    `java.lang.Object` should generally *not* be used. If you need to copy an object,
    just write a copy method, or a *copy constructor*. Joshua Bloch’s arguments against
    the `clone()` method in the book *Effective Java* (Addison-Wesley) are persuasive
    and should be read by any dedicated Java programmer. While you’re at it, read
    that whole book.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个例外可以不使用API的规则：`java.lang.Object`中的`clone()`方法通常*不*应该使用。如果你需要复制一个对象，只需编写一个复制方法或者*复制构造函数*。Joshua
    Bloch在《Effective Java》（Addison-Wesley出版）中反对`clone()`方法的论点是有说服力的，任何专注于Java编程的人都应该阅读一下。顺便说一句，把整本书都读了吧。
- en: Another exception is the `finalize()` method in `java.lang.Object()`. Don’t
    use it. It has been deprecated since Java 9 because it isn’t guaranteed to be
    invoked; but because it might get invoked, it will cause your dead objects not
    to be garbage collected, resulting in a memory leak. If you need some kind of
    cleanup, you must take responsibility for defining a method and invoking it before
    you let any object of that class go out of reference. You might call such a method
    `cleanUp()`. For application-level cleanup, see [*https://darwinsys.com/java/shutdownhook.html*](https://darwinsys.com/java/shutdownhook.html).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例外是`java.lang.Object()`中的`finalize()`方法。不要使用它。自Java 9起已经被弃用，因为不能保证它会被调用；但是因为它可能被调用，它会导致你的死对象无法被垃圾收集，从而导致内存泄漏。如果需要某种清理工作，你必须负责定义一个方法并在让该类的任何对象引用失效之前调用它。你可以称这样的方法为`cleanUp()`。对于应用级别的清理，请参考[*https://darwinsys.com/java/shutdownhook.html*](https://darwinsys.com/java/shutdownhook.html)。
- en: Generalize
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 泛化
- en: There is a trade-off between generality (and the resulting reusability), which
    is emphasized here, and the convenience of application specificity. If you’re
    writing one small part of a very large application designed according to OO design
    techniques, you’ll have in mind a specific set of use cases. On the other hand,
    if you’re writing toolkit-style code, you should write classes with few assumptions
    about how they’ll be used. Making code easy to use from a variety of programs
    is the route to writing reusable code.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在通用性（及由此带来的重用性）与应用特定性便利性之间存在一种权衡。如果您正在按照面向对象设计技术设计非常大的应用程序的一部分，您会考虑一组特定的用例。另一方面，如果您正在编写工具包样式的代码，您应该编写具有少量假设的类。使代码易于从各种程序中使用是编写可重用代码的途径。
- en: Read and write javadoc
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 阅读和编写javadoc
- en: 'You’ve no doubt looked at the Java online documentation in a browser, in part
    because I just told you to learn the API well. Do you think Sun/Oracle hired millions
    of tech writers to produce all that documentation? No. That documentation exists
    because the developers of the API took the time to write javadoc comments, those
    funny `/**` comments you’ve seen in code. So, one more bit of advice: use javadoc.
    The standard JDK provides a good, standard mechanism for API documentation. And
    use it as you write the code—don’t think you’ll come back and write it in later.
    That kind of tomorrow never comes.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您无疑已经在浏览器中查看了Java在线文档，部分原因是我告诉您要充分了解API。您认为Sun/Oracle雇佣了数百万技术写作人员来生成所有这些文档吗？不。这些文档存在是因为API的开发者花时间编写了javadoc注释，您在代码中看到的那些有趣的`/**`注释。所以，再给您一个建议：使用javadoc。标准JDK提供了一个良好的、标准的API文档化机制。并且在编写代码时就要使用它——不要认为您会在以后回来再写。这种明天永远不会来的想法。
- en: See [Recipe 15.2](ch15.html#javacook-packages-javadoc) for details on using
    javadoc.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 详情请参见[食谱15.2](ch15.html#javacook-packages-javadoc)以获取有关使用javadoc的详细信息。
- en: Use subclassing and delegation
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用子类化和委托
- en: Use subclassing. But don’t overuse subclassing. It is one of the best ways not
    only for avoiding code duplication, but for developing software that works. See
    any number of good books on the topic of object-oriented design and programming
    for more details.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用子类化。但不要过度使用子类化。这不仅是避免代码重复的最佳方式之一，也是开发可工作软件的好方法。有关面向对象设计和编程的更多细节，请参阅任何一本优秀的书籍。
- en: There are several alternatives. One alternative to subclassing is delegation.
    Think about “is a” versus “has a.” For example, instead of subclassing `NameAndAddress`
    to make `BusinessPartner` and `Customer`, make `BusinessPartner` and `Customer`
    have instances of `NameAndAddress`. That is a clearer structure; having `BusinessPartner`
    *be a* `NameAndAddress` just because the partner *has a* name and address would
    not make sense. And delegation also makes it easier for a `Customer` to have both
    a billing address and a shipping address. Another alternative is Aspect-Oriented
    Programming (AOP), which allows you to bolt on extra functionality from the outside
    of your classes. AOP is provided by the Java EE using EJB Interception and by
    the Spring Framework AOP mechanism.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种替代方案。子类化的一个替代方案是委托。考虑“是一个”与“有一个”的区别。例如，不要通过子类化`NameAndAddress`来创建`BusinessPartner`和`Customer`，而是让`BusinessPartner`和`Customer`具有`NameAndAddress`的实例。这是一个更清晰的结构；仅仅因为合作伙伴有名称和地址而让`BusinessPartner`
    *是一个* `NameAndAddress`是没有意义的。委托还使得`Customer`能够更轻松地同时具有账单地址和送货地址。另一个替代方案是面向方面的编程（AOP），它允许您从类的外部附加额外的功能。Java
    EE使用EJB拦截和Spring Framework AOP机制提供了AOP。
- en: Use design patterns
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用设计模式
- en: In the [Preface](preface01.html#preface), I mentioned *Design Patterns* as one
    of the Very Important Books on object-oriented programming. Often called the “Gang
    of Four” (GoF) book for its four authors, it provides a powerful catalog of things
    that programmers often reinvent. Some people find the GoF book to be somewhat
    academic in tone; a less-formal presentation on patterns is *Head First Design
    Patterns* by Bert Bates et al. (O’Reilly); this covers the same two dozen patterns
    as the GoF book. A design pattern provides a statement of a problem and its solution(s),
    rather like the present book, but generally at a higher level of abstraction.
    It is as important for giving a standard vocabulary of design as it is for its
    clear explanations of how the basic patterns work and how they can be implemented.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在[序言](preface01.html#preface)中，我提到*设计模式*作为面向对象编程中非常重要的书籍之一。通常被称为“四人组”（GoF）书籍，因为它有四位作者，它提供了程序员经常重新发明的事物的强大目录。有些人认为GoF书籍的语调有些学术性；一本较为非正式的关于模式的介绍是Bert
    Bates等人的*Head First Design Patterns*（O’Reilly），它涵盖了与GoF书籍相同的两打模式。设计模式提供了问题及其解决方案的陈述，有点像本书，但通常在更高的抽象级别。它对于提供设计的标准词汇以及清楚解释基本模式如何工作及其如何实现同样重要。
- en: '[Table 8-1](#javacook-oo-intro-table) shows some example uses of design patterns
    in the standard API.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 8-1](#javacook-oo-intro-table) 展示了标准API中设计模式的一些示例用法。'
- en: Table 8-1\. Design patterns in the JavaSE API
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 表8-1\. JavaSE API中的设计模式
- en: '| Pattern name | Meaning | Examples in Java API |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 模式名称 | 意义 | Java API中的示例 |'
- en: '| --- | --- | --- |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Command | Encapsulate requests, allowing queues of requests, undoable operations,
    etc. | `javax.swing.Action; javax.swing.undo.UndoableEdit` |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 命令 | 封装请求，允许请求队列，可撤销操作等 | `javax.swing.Action; javax.swing.undo.UndoableEdit`
    |'
- en: '| Decorator | One class decorates another | Swing `Border`s |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 装饰器 | 一个类装饰另一个类 | Swing `Border`s |'
- en: '| Factory Method | One class makes up instances for you, controlled by subclasses
    | `getInstance` (in `Calendar`, `Format`, `Locale`…); `SocketFactory`; RMI `InitialContext`
    |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 工厂方法 | 一个类为您创建实例，由子类控制 | `getInstance`（在`Calendar`，`Format`，`Locale`中...）;
    `SocketFactory`; RMI `InitialContext` |'
- en: '| Iterator | Loop over all elements in a collection, visiting each exactly
    once | `Iterator`; older `Enumeration`; `java.sql.ResultSet` |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 迭代器 | 遍历集合中的所有元素，每个元素仅访问一次 | `Iterator`; 旧的`Enumeration`; `java.sql.ResultSet`
    |'
- en: '| Model-View-Controller | Model represents data; View is what the user sees;
    Controller responds to user requests | `ActionListener` and friends; `Observer/Observable`;
    used internally by all visible Swing components |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 模型-视图-控制器 | 模型代表数据; 视图是用户看到的内容; 控制器响应用户请求 | `ActionListener`和其它类; `Observer/Observable`;
    所有可见Swing组件内部使用 |'
- en: '| Proxy | One object stands in for another | RMI, AOP, Dynamic Proxy |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 代理 | 一个对象代替另一个对象 | RMI，AOP，动态代理 |'
- en: '| Singleton | Only one instance may exist | `java.lang.Runtime, java.awt.Toolkit`
    |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 单例 | 只允许一个实例存在 | `java.lang.Runtime, java.awt.Toolkit` |'
- en: I have written articles on the [State](https://blogs.oracle.com/javamagazine/the-state-pattern),
    [Proxy](https://blogs.oracle.com/javamagazine/the-proxy-pattern), [Command](https://blogs.oracle.com/javamagazine/the-command-pattern-in-depth),
    [Decorator](https://blogs.oracle.com/javamagazine/the-decorator-pattern-in-depth),
    and [Visitor](https://blogs.oracle.com/javamagazine/the-visitor-design-pattern-in-depth)
    patterns for *Oracle Java Magazine*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我为*Oracle Java Magazine*写了关于[状态](https://blogs.oracle.com/javamagazine/the-state-pattern)，[代理](https://blogs.oracle.com/javamagazine/the-proxy-pattern)，[命令](https://blogs.oracle.com/javamagazine/the-command-pattern-in-depth)，[装饰器](https://blogs.oracle.com/javamagazine/the-decorator-pattern-in-depth)和[访问者](https://blogs.oracle.com/javamagazine/the-visitor-design-pattern-in-depth)模式的文章。
- en: '8.1 Object Methods: Formatting Objects with toString(), Comparing with Equals'
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.1 对象方法：使用toString()格式化对象，使用equals()比较
- en: Problem
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want your objects to have a useful default format and to behave themselves
    when placed in `Collections` classes.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望你的对象具有有用的默认格式，并且在放置在`Collections`类中时行为正常。
- en: Solution
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: There are four overridable methods inherited from `java.lang.Object`; of these,
    `toString()` provides default formatting, while `equals()` and `hashCode()` provide
    equality testing and efficient usage in `Map` implementations. The fourth, `clone()`,
    is not recommended for general use.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 从`java.lang.Object`继承了四个可重写方法；其中，`toString()`提供了默认格式化，而`equals()`和`hashCode()`提供了相等性测试和在`Map`实现中的高效使用。第四个`clone()`不建议一般使用。
- en: Discussion
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: toString()
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: toString()
- en: 'Whenever you pass an object to `System.out.println()` or any equivalent method
    or involve it in string concatenation, Java automatically calls its `toString()`
    method. Java knows that every object has a `toString()` method because `java.lang.Object`
    has one and all classes are ultimately subclasses of `Object`. The default implementation,
    in `java.lang.Object`, is neither pretty nor interesting: it just prints the class
    name, an @ sign, and the object’s `hashCode()` value. For example, if you run
    the code'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你将对象传递给`System.out.println()`或任何等效方法，或者将其涉及到字符串连接中时，Java会自动调用它的`toString()`方法。Java知道每个对象都有一个`toString()`方法，因为`java.lang.Object`有一个，并且所有类最终都是`Object`的子类。默认实现在`java.lang.Object`中既不漂亮也不有趣：它只打印类名，一个@符号和对象的`hashCode()`值。例如，如果你运行以下代码
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'you might see this uninformative output:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会看到这种无信息的输出：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To make it print better, you should provide an implementation of `toString()`
    that prints the class name and some of the important states in all but the most
    trivial classes. This gives you formatting control in `println()`, in debuggers,
    and anywhere your objects get referred to in a `String` context. Here is the previous
    program rewritten with a `toString()` method:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要使其打印得更好，你应该提供一个`toString()`方法的实现，该方法打印类名和所有但最简单类中的一些重要状态。这为你在`println()`、调试器和任何将你的对象引用在`String`上下文中的地方提供了格式控制。下面是使用`toString()`方法重写的前一个程序：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This version produces the more useful output:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 此版本生成更有用的输出：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This example uses `String` concatenation, but you may also want to use `String.format()`
    or `StringBuilder`; see [Chapter 3](ch03.html#javacook-strings).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用了`String`连接，但你可能还想使用`String.format()`或`StringBuilder`；请参见[第3章](ch03.html#javacook-strings)。
- en: hashCode() and equals()
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: hashCode()和equals()
- en: To ensure your classes work correctly when any client code calls `equals()`
    or when these objects are stored in `Map` or other `Collection` classes, outfit
    your class with `equals()` and `hashCode()` methods.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要确保当任何客户端代码调用`equals()`或者这些对象被存储在`Map`或其他`Collection`类中时，你的类能够正常工作，请为你的类提供`equals()`和`hashCode()`方法。
- en: 'How do you determine equality? For arithmetic or Boolean operands, the answer
    is simple: you test with the equals operator (`==`). For object references, though,
    Java provides both `==` and the `equals()` method inherited from `java.lang.Object`.
    The `equals` operator can be confusing because it simply compares two object references
    to see if they refer to the same object. This is not the same as comparing the
    values of the objects themselves.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如何确定相等性？对于算术或布尔操作数，答案很简单：使用等号操作符（`==`）进行测试。但是对于对象引用，Java提供了`==`和继承自`java.lang.Object`的`equals()`方法。等号操作符可能会令人困惑，因为它只是比较两个对象引用，看它们是否引用同一个对象。这与比较对象本身的值不同。
- en: 'The inherited `equals()` method is also not as useful as you might imagine.
    Some people seem to start their lives as Java developers thinking that the default
    `equals()` magically does some kind of detailed, field-by-field or even binary
    comparison of objects. But it does *not* compare fields! It just does the simplest
    possible thing: it returns the value of an `==` comparison on the two objects
    involved! So, for any *value classes* you write, you probably have to write an
    `equals` method.^([1](ch08.html#idm45290664734344)) Note that both the `equals`
    and `hashCode` methods are used by `Map`s or hashes (such as `HashMap`; see [Recipe
    7.9](ch07.html#javacook-structure-SECT-6)). So if you think somebody using your
    class might want to create instances and put them into a `Map`, or even compare
    your objects, you owe it to them (and to yourself!) to implement both `equals()`
    and `hashCode()` and to implement them properly.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 继承的`equals()`方法并不像你想象的那样有用。有些人似乎开始他们作为Java开发者的生活时，认为默认的`equals()`可以神奇地进行详细的、逐字段甚至是二进制的对象比较。但是它*不会*比较字段！它只是做了可能的最简单的事情：返回两个对象之间`==`比较的值！所以，对于你编写的任何*值类*，你可能需要编写一个`equals`方法。^([1](ch08.html#idm45290664734344))
    注意，`Map`或哈希表（如`HashMap`）会使用`equals`和`hashCode`方法。因此，如果你认为可能有人会使用你的类创建实例并将它们放入`Map`，或者甚至比较你的对象，你应该为此（也为了自己！）实现`equals()`和`hashCode()`方法，并且要正确实现它们。
- en: Most IDEs know how to generate correct `equals()` and `hashCode()` methods,
    but it’s worth your while to understand what these are doing, for the occasional
    case where you need to tweak the generated code. The Eclipse IDE (see [Recipe
    1.3](ch01.html#javacook-getstarted-SECT-3)), for example, offers a `Source` menu
    item `Generate hashCode() and equals()`; it will only do both at the same time,
    not let you generate `equals()` without `hashCode()` nor vice versa.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数IDE知道如何生成正确的`equals()`和`hashCode()`方法，但值得你了解它们的功能，以应对偶尔需要调整生成代码的情况。例如，Eclipse
    IDE（参见[Recipe 1.3](ch01.html#javacook-getstarted-SECT-3)）提供了一个`Source`菜单项`Generate
    hashCode() and equals()`；它只会同时生成两者，而不会让你单独生成`equals()`或`hashCode()`。
- en: 'Here are the rules for a correct `equals()` method:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个正确的`equals()`方法的规则：
- en: It is reflexive
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 它是自反的。
- en: '`x.equals(x)` must be true.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`x.equals(x)`必须为真。'
- en: It is symmetrical
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 它是对称的。
- en: '`x.equals(y)` must be true if and only if `y.equals(x)` is also true.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`x.equals(y)`必须为真当且仅当`y.equals(x)`也为真。'
- en: It is transitive
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 它是传递的。
- en: If `x.equals(y)` is true and `y.equals(z)` is true, then `x.equals(z)` must
    also be true.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`x.equals(y)`为真且`y.equals(z)`为真，则`x.equals(z)`必须也为真。
- en: It is idempotent (repeatable)
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 它是幂等的（可重复的）。
- en: Multiple calls on `x.equals(y)` return the same value (unless state values used
    in the comparison are changed, as by calling a set method).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对`x.equals(y)`的多次调用返回相同的值（除非比较中使用的状态值已更改，例如通过调用设置方法）。
- en: It is cautious
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 它是谨慎的。
- en: '`x.equals(null)` must return false rather than accidentally throwing a `NullPointerException`.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`x.equals(null)`必须返回假，而不是意外抛出`NullPointerException`。'
- en: 'In addition, beware of one common mistake: the argument to `equals()` must
    be declared as `java.lang.Object`, not the class it is in; this is so that polymorphism
    will work correctly (some classes may not have an `equals()` method of their own).
    To prevent this mistake, the `@Override` annotation is usually added to the `equals()`
    override, as mentioned in [Recipe 15.3](ch15.html#javacook-packages-SECT-3).'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，要注意一个常见的错误：`equals()`的参数必须声明为`java.lang.Object`，而不是它所在的类；这是为了使多态性能够正确工作（某些类可能没有自己的`equals()`方法）。为了防止这种错误，通常会在`equals()`覆盖中添加`@Override`注解，如[Recipe
    15.3](ch15.html#javacook-packages-SECT-3)中所述。
- en: 'Here is a class that endeavors to implement these rules:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个努力实现这些规则的类：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[![1](assets/1.png)](#co_object_oriented_techniques_CO1-1)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_object_oriented_techniques_CO1-1)'
- en: 'Optimization: if same object, true by definition.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 优化：如果是同一个对象，根据定义为真。
- en: '[![2](assets/2.png)](#co_object_oriented_techniques_CO1-2)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_object_oriented_techniques_CO1-2)'
- en: If other object null, false by definition.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果其他对象为空，则根据定义为假。
- en: '[![3](assets/3.png)](#co_object_oriented_techniques_CO1-3)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_object_oriented_techniques_CO1-3)'
- en: Compare class descriptors using !=; see following paragraph.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`!=`比较类描述符；见下一段。
- en: '[![4](assets/4.png)](#co_object_oriented_techniques_CO1-4)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_object_oriented_techniques_CO1-4)'
- en: 'Optimization: compare primitives first. May or may not be worthwhile; may be
    better to order by those most likely to differ—depends on the data and the usage.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 优化：首先比较原始数据类型。可能值得，也可能不值得；可能更好的是按照最有可能不同的顺序排序——这取决于数据和使用情况。
- en: 'Another common mistake to avoid: note the use of class descriptor equality
    (i.e., `o.getClass() != EqualsDemo.class`) to ensure the correct class, rather
    than via `instanceof`, as is sometimes erroneously done. The reflexive requirement
    of the `equals()` method contract pretty much makes it impossible to compare a
    subclass with a superclass correctly, so we now use class equality (see [Chapter 17,
    *Reflection, or “A Class Named Class”*](ch17.html#javacook-reflection) for details
    on the class descriptor).'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个要避免的常见错误：注意使用类描述符相等性（即`o.getClass() != EqualsDemo.class`）来确保正确的类，而不是通过`instanceof`，有时会错误地这样做。`equals()`方法契约的自反要求几乎使得正确比较子类和超类几乎不可能，因此我们现在使用类相等性（详见[Chapter 17,
    *Reflection, or “A Class Named Class”*](ch17.html#javacook-reflection)中关于类描述符的详细信息）。
- en: 'Here is a basic JUnit test (see [Recipe 1.10](ch01.html#javacook-getstarted-junit))
    for the `EqualsDemo` class:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`EqualsDemo`类的基本JUnit测试（参见[Recipe 1.10](ch01.html#javacook-getstarted-junit)）：
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With all that testing, what could go wrong? Well, some things still need care.
    What if the object is a *subclass* of `EqualsDemo`? We should test that it returns
    false in this case.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过所有这些测试，可能会出现什么问题？嗯，有些事情仍然需要注意。如果对象是`EqualsDemo`的*子类*怎么办？我们应该测试在这种情况下返回假。
- en: What else could go wrong? Well, what if either `obj1` or `other.obj1` is null?
    You might have just earned a nice shiny new `NullPointerException`. So you also
    need to test for any possible null values. Good constructors can avoid these `NullPointerException`s,
    as I’ve tried to do in `EqualsDemo`, or else test for them explicitly.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 还有什么问题？嗯，如果 `obj1` 或 `other.obj1` 是空的呢？你可能刚刚获得了一个漂亮的新 `NullPointerException`。因此，你还需要测试任何可能为空的值。良好的构造函数可以避免这些
    `NullPointerException`，就像我在 `EqualsDemo` 中尝试做的那样，或者显式地测试它们。
- en: Finally, you should never override `equals()` without also overriding `hashCode()`,
    and the same fields must take part in both computations.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你不应该在不同时重写 `hashCode()` 的情况下重写 `equals()`，而且相同的字段必须参与两者的计算。
- en: hashCode()
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: hashCode()
- en: The `hashCode()` method is supposed to return an `int` that should uniquely
    identify any set of values in objects of its class.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`hashCode()` 方法应该返回一个 `int`，它应该唯一地标识其类中对象的任何一组值。'
- en: 'A properly written `hashCode()` method will follow these rules:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一个正确编写的 `hashCode()` 方法将遵循这些规则：
- en: It is repeatable
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 它是可重复的。
- en: '`hashCode(x)` must return the same `int` when called repeatedly, unless set
    methods have been called.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用多次时，`hashCode(x)` 必须返回相同的 `int`，除非调用了设置方法。
- en: It is consistent with equality
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 它与相等性一致
- en: If `x.equals(y)`, then `x.hashCode()` must == `y.hashCode()`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `x.equals(y)`，那么 `x.hashCode()` 必须等于 `y.hashCode()`。
- en: Distinct objects should produce distinct hashCodes
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的对象应该产生不同的哈希码
- en: If `!x.equals(y)`, it is not required that `x.hashCode()` != `y.hashCode()`,
    but doing so may improve performance of hash tables (i.e., hashes may call `hashCode()`
    before `equals()`).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `!x.equals(y)`，则不要求 `x.hashCode()` != `y.hashCode()`，但这样做可能会提高哈希表的性能（即在调用
    `equals()` 之前哈希可能会调用 `hashCode()`）。
- en: 'The default `hashCode()` on the standard JDK returns a machine address, which
    conforms to the first rule. Conformance to the second and third rules depends,
    in part, on your `equals()` method. Here is a program that prints the hashcodes
    of a small handful of objects:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 标准 JDK 上的默认 `hashCode()` 返回一个机器地址，这符合第一个规则。遵循第二和第三规则部分取决于你的 `equals()` 方法。以下是一个打印少量对象哈希码的程序：
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: What does it print?
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 它打印什么？
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The hashcode value for the `Color` object is interesting. It is actually computed
    as something like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`Color` 对象的哈希码值很有趣。它实际上是这样计算的：'
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this formula, `r`, `g`, and `b` are the red, green, and blue components,
    respectively, and `alpha` is the transparency. Each of these quantities is stored
    in 8 bits of a 32-bit integer. If the alpha value is greater than 128, the high
    bit in this word—having been set by shifting into the sign bit of the word—causes
    the integer value to appear negative when printed as a signed integer. Hashcode
    values are of type `int`, so they are allowed to be negative.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个公式中，`r`、`g` 和 `b` 分别是红色、绿色和蓝色分量，而 `alpha` 是透明度。每个量都存储在一个32位整数的8位中。如果 alpha
    值大于128，则这个字中的高位—通过将字节移入字的符号位而被设置—导致当作有符号整数打印时整数值显得负数。哈希码值是 `int` 类型的，所以它们可以是负数。
- en: Difficulties and Alternatives to Clone
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 克隆的困难和替代方案
- en: The `java.util.Observable` class (designed to implement the Model-View-Controller
    pattern with AWT or Swing applications) contains a private `Vector` but no clone
    method to deep-clone it. Thus, `Observable` objects cannot safely be cloned, ever!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.Observable` 类（设计用于在 AWT 或 Swing 应用程序中实现模型-视图-控制器模式）包含一个私有 `Vector`，但没有克隆方法来深度克隆它。因此，`Observable`
    对象永远不能安全地被克隆！'
- en: 'This and several other issues around `clone()`—such as the uncertainty of whether
    a given `clone()` implementation is deep or shallow—suggest that `clone()` was
    not as well thought out as might be. An alternative is simply to provide a copy
    constructor or similar method:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `clone()` 的这个问题以及其他几个问题——比如给定的 `clone()` 实现是深复制还是浅复制的不确定性——表明 `clone()` 可能没有想得那么周全。一个替代方案是简单地提供一个复制构造函数或类似的方法：
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 8.2 Using Inner Classes
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.2 使用内部类
- en: Problem
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to write a private class, or a class to be used in one other class
    at most.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要编写一个私有类，或最多在另一个类中使用一个类。
- en: Solution
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use a nonpublic class or an inner class.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用非公共类或内部类。
- en: Discussion
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: A nonpublic class can be written as part of another class’s source file, but
    not inside that class. An inner class is Java terminology for a class defined
    inside another class. Inner classes were first popularized with early Java for
    use as event handlers for GUI applications, but they have a much wider application.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 非公共类可以作为另一个类的源文件的一部分编写，但不能在该类内部。内部类是 Java 术语，用于定义在另一个类内部的类。内部类最初在早期的 Java 中因用于
    GUI 应用程序的事件处理而流行，但其应用范围更广。
- en: Inner classes can, in fact, be constructed in several contexts. An inner class
    defined as a member of a class can be instantiated anywhere in that class. An
    inner class defined inside a method can be referred to later only in the same
    method. Inner classes can also be named or anonymous. A named inner class has
    a full name that is compiler dependent; the standard JVM uses a name like `MainClass$InnerClass`
    for the resulting file. An anonymous inner class, similarly, has a compiler-dependent
    name; the JVM uses `MainClass$1`, `MainClass$2`, and so on.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上可以在多种上下文中构造内部类。作为类的成员定义的内部类可以在该类的任何位置实例化。在方法内部定义的内部类只能在同一方法中稍后引用。内部类还可以是命名的或匿名的。命名的内部类具有依赖于编译器的完整名称；标准
    JVM 使用类似 `MainClass$InnerClass` 的名称来表示生成的文件。类似地，匿名内部类具有依赖于编译器的名称；JVM 使用 `MainClass$1`、`MainClass$2`
    等。
- en: 'These classes cannot be instantiated in any other context; any explicit attempt
    to refer to, say, `OtherMainClass$InnerClass`, is caught at compile time:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类不能在任何其他上下文中实例化；对 `OtherMainClass$InnerClass` 等的显式引用在编译时被捕获：
- en: '*main/src/main/java/oo/AllClasses.java*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*main/src/main/java/oo/AllClasses.java*'
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[![1](assets/1.png)](#co_object_oriented_techniques_CO2-1)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_object_oriented_techniques_CO2-1)'
- en: This is an inner class, which can be used anywhere in class `AllClasses`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个内部类，在类 `AllClasses` 中可以随处使用。
- en: '[![2](assets/2.png)](#co_object_oriented_techniques_CO2-2)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_object_oriented_techniques_CO2-2)'
- en: This shows the anonymous inner class syntax, which uses `new` with a type followed
    by `(){`, a class body, and `}`. The compiler will assign a name; the class will
    extend or implement the given type, as appropriate.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了匿名内部类语法，它使用 `new` 后跟类型，然后是 `(){`，一个类体，和 `}`。编译器将分配一个名称；该类将根据需要扩展或实现给定的类型。
- en: '[![3](assets/3.png)](#co_object_oriented_techniques_CO2-3)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_object_oriented_techniques_CO2-3)'
- en: This is a nonpublic class; it can be used in the main class and (with warning)
    in other classes.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非公共类；可以在主类和（带有警告）其他类中使用。
- en: One issue is that the inner class retains a reference to the outer class. If
    you want to avoid memory leaks if the inner class will be held for a longer time
    than the outer, you can make the inner class `static`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一个问题是内部类保留了对外部类的引用。如果您希望在内部类的生命周期比外部类长时避免内存泄漏，可以将内部类设为 `static`。
- en: Inner classes implementing a single-method interface can be written in a much
    more concise fashion as lambda expressions (see [Chapter 9](ch09.html#javacook-fp)).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 实现单方法接口的内部类可以使用 lambda 表达式编写得更加简洁（参见 [第 9 章](ch09.html#javacook-fp)）。
- en: 8.3 Providing Callbacks via Interfaces
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.3 通过接口提供回调
- en: Problem
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to provide callbacks—that is, have unrelated classes call back into
    your code.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您想提供回调，即使无关的类也可以调用回您的代码。
- en: Solution
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: One way is to use a Java interface.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Java 接口是一种方式。
- en: Discussion
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'An interface is a class-like entity that can contain only abstract methods
    and final fields. As we’ve seen, interfaces are used a lot in Java! In the standard
    API, the following are a few of the commonly used interfaces:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接口是类似于类的实体，只能包含抽象方法和 final 字段。正如我们所见，接口在 Java 中被广泛使用！在标准 API 中，以下是一些常用的接口：
- en: '`Runnable`, `Comparable`, and `Cloneable` (in `java.lang`).'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Runnable`, `Comparable` 和 `Cloneable`（在 `java.lang` 中）。'
- en: '`List`, `Set`, `Map`, and `Enumeration/Iterator` (in the Collections API; as
    you’ll see in [Chapter 7](ch07.html#javacook-structure)).'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`List`、`Set`、`Map` 和 `Enumeration/Iterator`（在 Collections API 中；如您在 [第 7 章](ch07.html#javacook-structure)
    中所见）。'
- en: '`ActionListener`, `WindowListener`, and others in the GUI layer.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ActionListener`、`WindowListener` 和 GUI 层中的其他接口。'
- en: '`Driver`, `Connection`, `Statement`, and `ResultSet` in JDBC; see [*https://darwinsys.com/javadatabase*](https://darwinsys.com/javadatabase).'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Driver`、`Connection`、`Statement` 和 JDBC 中的 `ResultSet`；请参见 [*https://darwinsys.com/javadatabase*](https://darwinsys.com/javadatabase)。'
- en: The *remote interface*—the contact between the client and the server—is specified
    as an `Interface` (in RMI, CORBA, and EJB).
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*远程接口* —— 客户端和服务器之间的接口被指定为 `Interface`（在 RMI、CORBA 和 EJB 中）。'
- en: Suppose we are generating a building management system. To be energy efficient,
    we want to be able to remotely turn off (at night and on weekends) such things
    as room lights and computer monitors, which use a lot of energy. Assume we have
    some kind of remote control technology. It could be a commercial version of BSR’s
    house-light control technology X10, it could be Bluetooth or 802.11—it doesn’t
    matter. What matters is that we have to be very careful what we turn off. It would
    cause great ire if we turned off computer processors automatically—people often
    leave things running overnight. It would be a matter of public safety if we ever
    turned off the building emergency lighting.^([2](ch08.html#idm45290663675912))
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在生成一个建筑管理系统。为了节能，我们希望能够远程关闭（在夜间和周末）诸如室内灯光和计算机显示器这样大量消耗能源的设备。假设我们有某种远程控制技术。它可以是BSR的家庭灯光控制技术X10的商业版本，也可以是蓝牙或802.11——这并不重要。重要的是我们必须非常小心地选择关闭的对象。如果我们自动关闭计算机处理器，这将引起极大的愤怒——人们经常在夜间保持运行状态。如果我们关闭建筑应急照明，这将涉及公共安全问题。^([2](ch08.html#idm45290663675912))
- en: So we’ve come up with the design shown in [Figure 8-1](#javacook-oo-FIG-1).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们提出了[Figure 8-1](#javacook-oo-FIG-1)中显示的设计。
- en: '![jcb4 0801](assets/jcb4_0801.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![jcb4 0801](assets/jcb4_0801.png)'
- en: Figure 8-1\. Classes for a building management system
  id: totrans-135
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figure 8-1\. 建筑管理系统的类
- en: The code for these data classes is not shown (it’s pretty trivial), but it’s
    in the *oo/interfaces* directory of the online source. The top-level classes (i.e.,
    `BuildingLight` and `Asset`) are abstract classes. You can’t instantiate them,
    because they don’t have any specific functionality. To ensure—both at compile
    time and at runtime—that we can never switch off the emergency lighting, we need
    only ensure that the class representing it, `EmergencyLight`, does not implement
    the `PowerSwitchable` interface.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据类的代码没有显示（它非常琐碎），但它位于在线源码的*oo/interfaces*目录中。顶层类（例如`BuildingLight`和`Asset`）是抽象类。你无法实例化它们，因为它们没有任何具体功能。为了在编译时和运行时确保我们永远不能关闭应急照明，我们只需确保表示它的类`EmergencyLight`不实现`PowerSwitchable`接口。
- en: Note that we can’t very well use direct inheritance here. No common ancestor
    class includes both `ComputerMonitor` and `RoomLights` that doesn’t also include
    `ComputerCPU` and `EmergencyLight`. Use interfaces to define functionality in
    unrelated classes.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这里我们无法直接使用直接继承。没有一个共同的祖先类同时包括既有`ComputerMonitor`和`RoomLights`，又没有包括`ComputerCPU`和`EmergencyLight`。使用接口在不相关的类中定义功能。
- en: How we use these is demonstrated by the `BuildingManagement` class; this class
    is not part of the hierarchy shown in [Figure 8-1](#javacook-oo-FIG-1), but it
    *uses* a collection of `Asset` objects from that hierarchy.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过`BuildingManagement`类演示了它们的使用；这个类不是[Figure 8-1](#javacook-oo-FIG-1)所示层次结构的一部分，但它*使用*了来自该层次结构的一组`Asset`对象。
- en: 'Items that can’t be switched must nonetheless be in the database, for various
    purposes (auditing, insurance, etc.). In the method that turns things off, the
    code is careful to check whether each object in the database is an instance of
    the `PowerSwitchable` interface. If so, the object is casted to `PowerSwitchable`
    so that its `powerDown()` method can be called. If not, the object is skipped,
    thus preventing any possibility of turning out the emergency lights or shutting
    off a machine that is busy running SETI@Home, downloading a big MP3 playlist,
    or performing system backups. The following code shows this set of classes in
    action:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 即使不能被关闭的项目也必须在数据库中，用于各种目的（审计、保险等）。在关闭物品的方法中，代码小心地检查数据库中的每个对象是否是`PowerSwitchable`接口的实例。如果是，则将对象转换为`PowerSwitchable`，以便调用其`powerDown()`方法。如果不是，则跳过该对象，从而防止关闭应急照明或关闭正在运行SETI@Home、下载大型MP3播放列表或执行系统备份的机器的可能性。以下代码展示了这组类的实际应用：
- en: '[PRE11]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When you run this program, it shows all the items being added but only the
    `PowerSwitchable` ones being switched off:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行此程序时，它显示添加的所有项目，但只关闭了`PowerSwitchable`类型的项目：
- en: '[PRE12]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 8.4 Polymorphism/Abstract Methods
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.4 多态性/抽象方法
- en: Problem
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want each of a number of subclasses to provide its own version of one or
    more methods.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望每个子类都提供一个或多个方法的自己版本。
- en: Solution
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Make the method abstract in the parent class; this makes the compiler ensure
    that each subclass implements it.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在父类中将方法声明为抽象；这使得编译器确保每个子类都实现了它。
- en: Discussion
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'A hypothetical drawing program uses a `Shape` subclass for anything that is
    drawn. `Shape` has an abstract method called `computeArea()` that computes the
    exact area of the given shape:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一个假设的绘图程序使用`Shape`的子类来绘制任何东西。`Shape`有一个名为`computeArea()`的抽象方法，用于计算给定形状的确切面积：
- en: '[PRE13]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'A `Rectangle` subclass, for example, has a `computeArea()` that multiplies
    width times height and returns the result:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`Rectangle`子类具有一个`computeArea()`方法，将宽度乘以高度并返回结果：
- en: '[PRE14]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'A `Circle` subclass returns π*r*²:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`Circle`子类返回π*r*²：'
- en: '[PRE15]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This system has a high degree of generality. In the main program, we can iterate
    over a collection of `Shape` objects and—here’s the real beauty—call `computeArea()`
    on any `Shape` subclass object without having to worry about what kind of shape
    it is. Java’s polymorphic methods automatically call the correct `computeArea()`
    method in the class of which the object was originally constructed:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 该系统具有很高的通用性。在主程序中，我们可以迭代一个`Shape`对象的集合，并且这里真正的美妙之处在于，可以在任何`Shape`子类对象上调用`computeArea()`，而不必担心它是什么形状。Java的多态方法会自动调用对象最初构造时所属类中的正确`computeArea()`方法：
- en: '*main/src/main/java/oo//shapes/ShapeDriver.java*'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*main/src/main/java/oo//shapes/ShapeDriver.java*'
- en: '[PRE16]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Polymorphism is a great boon for software maintenance: if a new subclass is
    added, the code in the main program does not change. Further, all the code that
    is specific to, say, polygon handling, is all in one place: in the source file
    for the `Polygon` class. This is a big improvement over older languages, where
    type fields in a structure were used with case or switch statements scattered
    all across the software. Java makes software more reliable and maintainable with
    the use of polymorphism.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 多态对软件维护是一大利好：如果添加了一个新的子类，则主程序中的代码不会改变。此外，所有特定于多边形处理的代码都在一个地方：在`Polygon`类的源文件中。这比旧语言中使用结构中的类型字段配合分散在软件各处的case或switch语句要好得多。Java通过多态使软件更可靠和可维护。
- en: 8.5 Using Typesafe Enumerations
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.5 使用类型安全的枚举
- en: Problem
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to manage a small list of discrete values within a program.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在程序中管理一个离散值的小列表。
- en: Solution
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the Java `enum` mechanism.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Java的`enum`机制。
- en: Discussion
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'To enumerate means to list all the values. You often know that a small list
    of possible values is all that’s wanted in a variable, such as the months of the
    year, the suits or ranks in a deck of cards, or the primary and secondary colors.
    The C programming language provided an `enum` keyword:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举意味着列出所有值。通常您知道变量中只需要一个小列表的可能值，例如一年中的月份、一副牌中的花色或等级，或者主要和次要颜色。C编程语言提供了一个`enum`关键字：
- en: '[PRE17]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Java was criticized in its early years for its lack of enumerations, which many
    developers have wished for. Many have had to develop custom classes to implement
    the *typesafe enumeration pattern*.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期，Java因缺乏枚举而受到批评，许多开发人员希望有枚举。许多人不得不开发自定义类来实现*类型安全的枚举模式*。
- en: But C enumerations are not typesafe; they simply define constants that can be
    used in any integer context. For example, this code compiles without warning,
    even on *gcc* 3 with `-Wall` (all warnings), whereas a C++ compiler catches the
    error:^([3](ch08.html#idm45290663297016))
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 但是C枚举不是类型安全的；它们只是定义可以在任何整数上下文中使用的常量。例如，即使在带有`-Wall`（所有警告）的gcc 3上，此代码也可以编译而不会警告，而C++编译器会捕获错误：^([3](ch08.html#idm45290663297016))
- en: '[PRE18]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To replicate this mistake in Java, one needs only to define a series of `final
    int` values; it will still not be typesafe. By typesafe I mean that you cannot
    accidentally use values other than those defined for the given enumeration. The
    definitive statement on the typesafe enumeration pattern is probably the version
    defined in item 21 of Joshua Bloch’s book *Effective Java* (Addison-Wesley). All
    modern Java versions include enumerations in the language; it is no longer necessary
    to use the code from Bloch’s book. Bloch was one of the authors of the Typesafe
    Enumeration specification (`enum` keyword), so you can be sure that Java now does
    a good job of implementing his pattern. These `enum`s are implemented as classes,
    subclassed (transparently, by the compiler) from the class `java.lang.Enum`. Unlike
    C, and unlike a series of `final int`s, Java typesafe enumerations have the following
    qualities:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Java中复制此错误，只需定义一系列`final int`值；它仍然不是类型安全的。类型安全意味着您不能意外地使用除给定枚举定义之外的值。关于类型安全枚举模式的权威声明可能是在Joshua
    Bloch的书《Effective Java》（Addison-Wesley）的第21项中定义的版本。所有现代Java版本都在语言中包含枚举；不再需要使用Bloch书中的代码。布洛赫是类型安全枚举规范（`enum`关键字）的作者之一，因此可以确信Java现在很好地实现了他的模式。这些枚举被实现为类，从类`java.lang.Enum`中（由编译器透明地子类化）继承。与C不同，也不同于一系列`final
    int`，Java的类型安全枚举具有以下特点：
- en: They are printable (they print as the name, not as an underlying `int` implementation).
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是可打印的（它们打印为名称，而不是底层的`int`实现）。
- en: They are almost as fast as `int` constants, but the code is more readable.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们几乎和`int`常量一样快，但是代码更可读。
- en: They can be easily iterated over.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以轻松地进行迭代。
- en: They use a separate namespace for each `enum` type, which means you don’t have
    to prefix each with some sort of constant name, like `ACCOUNT_SAVINGS`, `ACCOUNT_CHECKING`,
    etc.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们为每个`enum`类型使用单独的命名空间，这意味着您不必为每个枚举常量添加某种常量名前缀，例如`ACCOUNT_SAVINGS`，`ACCOUNT_CHECKING`等。
- en: Enum constants are not compiled into clients, giving you the freedom to reorder
    the constants within your `enum` without recompiling the client classes. That
    does not mean you should, however; think about the case where objects that use
    them have been persisted, and the person designing the database mapping used the
    numeric values of the enums. Bad idea to reorder then!
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举常量不会编译到客户端中，因此您可以自由地重新排序`enum`中的常量，而无需重新编译客户端类。然而，并不意味着您应该这样做；请考虑那些已经持久化了使用它们的对象的情况，以及设计数据库映射的人员使用了枚举的数值。重新排序就是个坏主意！
- en: Additionally, an `enum` type is a class, so it can, for example, implement arbitrary
    interfaces; and you can add constructors, fields, and methods to an `enum` class.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`enum`类型也是一个类，因此它可以实现任意接口；您可以为`enum`类添加构造函数、字段和方法。
- en: 'Compared to Bloch’s Typesafe Enum pattern in the book:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 与布洛赫在书中的类型安全枚举模式相比：
- en: Java `enums` are simpler to use and more readable (those in the book require
    a lot of methods, making them cumbersome to write).
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java的`enum`使用起来更简单，更易读（书中的那些需要大量方法，使得编写它们变得麻烦）。
- en: Enums can be used in switch statements.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举可以在switch语句中使用。
- en: So there are many benefits and few pitfalls.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，它们有许多好处，但几乎没有坑。
- en: The `enum` keyword is at the same level as the keyword `class` in declarations.
    That is, an `enum` may be declared in its own file with public or default access.
    It may also be declared inside classes, much like nested or inner classes (see
    [Recipe 8.2](#javacook-oo-SECT-6)). *Media.java*, shown in [Example 8-1](#javacook-CHP-8-EX-7),
    is a code sample showing the definition of a typesafe `enum`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`enum`关键字在声明中与`class`关键字处于同一级别。也就是说，可以在其自己的文件中使用public或default访问权限声明`enum`，也可以像嵌套或内部类一样在类内部声明（参见[Recipe
    8.2](#javacook-oo-SECT-6)）。*Media.java*，在[示例 8-1](#javacook-CHP-8-EX-7)中展示了一个展示类型安全`enum`定义的代码示例。'
- en: Example 8-1\. structure/Media.java
  id: totrans-182
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-1\. structure/Media.java
- en: '[PRE19]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Notice that an `enum` class *is* a class; see what *javap* thinks of the `Media`
    class:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`enum`类*就是*一个类；查看*javap*对`Media`类的看法：
- en: '[PRE20]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Product.java*, shown in [Example 8-2](#javacook-CHP-8-EX-8), is a code sample
    that uses the `Media` enum.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*Product.java*，在[示例 8-2](#javacook-CHP-8-EX-8)中展示了一个使用`Media`枚举的代码示例。'
- en: Example 8-2\. main/src/main/java/structure/Product.java
  id: totrans-187
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-2\. main/src/main/java/structure/Product.java
- en: '[PRE21]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In [Example 8-3](#javacook-CHP-8-EX-9), `MediaFancy` shows how operations (methods)
    can be added to enumerations; the `toString()` method is overridden for the `Book`
    value of this enum.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 8-3](#javacook-CHP-8-EX-9)，`MediaFancy`展示了如何向枚举类型添加操作（方法）；为该枚举类型的`Book`值重写了`toString()`方法。
- en: Example 8-3\. main/src/main/java/structure/MediaFancy.java
  id: totrans-190
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-3\. main/src/main/java/structure/MediaFancy.java
- en: '[PRE22]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Running the `MediaFancy` program produces this output:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`MediaFancy`程序会产生这样的输出：
- en: '[PRE23]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: That is, the `Book` values print in a user-friendly way compared to the default
    way the other values print. In real life you’d want to extend this to all the
    values in the `enum`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，`Book`的值以用户友好的方式打印，与其他值的默认打印方式相比。在实际生活中，您可能希望将此扩展到枚举中的所有值。
- en: Finally, `EnumList`, in [Example 8-4](#javacook-CHP-8-EX-10), shows how to list
    all the possible values that a given `enum` can take on; simply iterate over the
    array returned by the enumeration class’s inherited `values()` method.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`EnumList`在[示例 8-4](#javacook-CHP-8-EX-10)中展示了如何列出给定枚举可以取的所有可能值；只需迭代枚举类继承的`values()`方法返回的数组即可。
- en: Example 8-4\. structure/EnumList.java
  id: totrans-196
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-4\. structure/EnumList.java
- en: '[PRE24]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output of the `EnumList` program is this, of course:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`EnumList`程序的输出当然是这样的：'
- en: '[PRE25]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 8.6 Avoiding NPEs with Optional
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.6 使用`Optional`避免NPEs
- en: Problem
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You worry about null references causing a `NullPointerException` (NPE) in your
    code.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你担心空引用会在代码中引发`NullPointerException`（NPE）。
- en: Solution
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use `java.util.Optional`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`java.util.Optional`。
- en: Discusssion
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The developer who invented the notion of null pointers, and a key early contributor
    to our discipline, has described the null reference as [“my billion-dollar mistake”](https://en.wikipedia.org/wiki/Tony_Hoare).
    However, use of `null` is not going away anytime soon.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 发明了空指针概念的开发者，并且是我们学科的早期重要贡献者，已经将空引用描述为[“我的十亿美元错误”](https://en.wikipedia.org/wiki/Tony_Hoare)。然而，使用`null`在短期内不会消失。
- en: What we can do is make clear that we worry about null pointers in certain contexts.
    For this purpose, Java 8 introduced the class `java.util.Optional`. The `Optional`
    is an object wrapper around a possibly-null object reference. The `Optional` wrapper
    has a long history; a similar construct is found in LLVM’s ADT, where its `Optional`
    describes itself in turn as “in the spirit of OCaml’s *opt* variant.”
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做的是明确表示我们在某些情境中担心空指针。为此，Java 8引入了`java.util.Optional`类。`Optional`是围绕可能为null的对象引用的对象包装器。`Optional`包装器有着悠久的历史；在LLVM的ADT中可以找到类似的构造，在那里它的`Optional`反过来描述为“在OCaml的*opt*变体精神中”。
- en: '`Optionals` can be created with one of the creational methods:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`Optional`可以使用其中一个创建方法来创建：'
- en: '`Optional.empty()`'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`Optional.empty()`'
- en: Returns an empty optional
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个空的可选值
- en: '`Optional.of(T obj)`'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`Optional.of(T obj)`'
- en: Returns a nonempty optional containing the given value
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 返回包含给定值的非空可选值
- en: '`Optional.ofNullable(T obj)`'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`Optional.ofNullable(T obj)`'
- en: Returns either an empty optional or one containing the given value
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个空的可选值或者包含给定值的可选值
- en: The basic operation of this class is to behave in one of two ways, depending
    on whether it is full or empty. Optional objects are immutable, so they cannot
    transition from one state to the other.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的基本操作是根据它是满还是空来表现出不同的行为。`Optional`对象是不可变的，因此它们不能从一种状态转换到另一种状态。
- en: 'The simplest use is to invoke `isEmpty()` or its opposite `isPresent()` and
    use program logic to behave differently. This is not much different from using
    an `if` statement to check for null, but it puts the choice in front of you, making
    it less likely that you’ll forget to check:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的用法是调用`isEmpty()`或其相反的`isPresent()`，并使用程序逻辑来以不同方式行事。这与使用`if`语句检查`null`并没有太大不同，但它将选择放在您面前，使您不太可能忘记检查：
- en: '[PRE26]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'A better form would use the `orElse` method:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的形式将使用`orElse`方法：
- en: '[PRE27]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: A useful use case is that of passing values into methods. The object can be
    wrapped in an `Optional` either before it is passed to a method or after; the
    latter is useful when migrating from code that didn’t use `Optional` from the
    start. The `Item` demo in [Example 8-5](#javacook-oo-ex-optional-item) might represent
    part of a shipments tracking program, a lending library manager, or anything else
    that has time-related data which might be missing.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有用的用例是将值传递到方法中。对象可以在传递给方法之前或之后包装在`Optional`中；当从一开始就没有使用`Optional`的代码迁移时，后者非常有用。[示例 8-5](#javacook-oo-ex-optional-item)中的`Item`演示可能代表了部分发货跟踪程序、借阅图书馆管理器或任何具有时间相关数据可能缺失的内容。
- en: Example 8-5\. main/src/main/java/oo/OptionalDemo.java
  id: totrans-221
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-5\. main/src/main/java/oo/OptionalDemo.java
- en: '[PRE28]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: There are methods that throw exceptions, that return null, and so on. There
    are also methods for interacting with the Streams mechanism (see [Recipe 9.3](ch09.html#javacook-fp-streams1-1)).
    A full list of `Optional`’s methods is at the start of the [javadoc page](https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/Optional.html).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 有抛出异常的方法，返回空等方法。还有与Streams机制交互的方法（见[配方 9.3](ch09.html#javacook-fp-streams1-1)）。`Optional`的所有方法列表在[javadoc页面的开头](https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/Optional.html)。
- en: 8.7 Enforcing the Singleton Pattern
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.7 强制执行单例模式
- en: Problem
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to be sure there is only one instance of your class in a given Java
    Virtual Machine, or at least within your application.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你想确保在给定的Java虚拟机中只有一个类的实例，或者至少在你的应用程序中只有一个类的实例。
- en: Solution
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'There are several methods of making your class enforce the Singleton pattern:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在类中实现单例模式有几种方法：
- en: Enum implementation
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举实现
- en: Having only a private constructor (or multiple) and a `getInstance()` method
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有私有构造函数（或多个）和一个`getInstance()`方法
- en: Use a framework such as Spring or CDI ([Recipe 8.9](#javacook-oo-SECT-di)) configured
    to give Singleton-style instantiation of plain classes
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring或CDI等框架（[配方 8.9](#javacook-oo-SECT-di)）配置为提供普通类的单例式实例化
- en: Discussion
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'It is often useful to ensure that only one instance of a class gets created,
    usually to funnel all requests for some resource through a single point. An example
    of a Singleton from the standard API is `java.lang.Runtime`: you cannot create
    instances of `Runtime`; you simply ask for a reference by calling the static method
    `Runtime.getRuntime()`. Singleton is also an example of a design pattern that
    can be easily implemented. In all forms, the point of the Singleton implementation
    is to provide an instance in which certain methods can run, typically to control
    access to some resource.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 通常有用的是确保只创建一个类的实例，通常是通过单一点来处理对某些资源的所有请求。标准API中的单例示例是`java.lang.Runtime`：你无法创建`Runtime`的实例；你只需调用静态方法`Runtime.getRuntime()`来获取引用。单例模式也是一个可以轻松实现的设计模式的示例。在所有形式中，单例实现的要点是提供一个实例，其中某些方法可以运行，通常用于控制对某些资源的访问。
- en: The easiest implementation uses a Java `enum` to provide Singleton-ness. The
    `enum` mechanism already guarantees that only one instance of each enum constant
    will exist in a given JVM context, so this technique piggy-backs on that, as shown
    in [Example 8-6](#javacook-oo-singleton-1).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的实现方法是使用Java的`enum`来提供单例性。`enum`机制已经保证了在给定的JVM上下文中每个枚举常量只存在一个实例，因此这种技术就利用了这一点，如[示例 8-6](#javacook-oo-singleton-1)所示。
- en: Example 8-6\. main/src/main/java/oo/EnumSingleton.java
  id: totrans-235
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-6\. main/src/main/java/oo/EnumSingleton.java
- en: '[PRE29]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Using it is simple:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 使用它很简单：
- en: '[PRE30]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The next easiest implementation consists of a private constructor and a field
    to hold its result, as well as a static accessor method with a name like `getInstance()`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个最简单的实现包括一个私有构造函数和一个保存其结果的字段，以及一个静态访问器方法，名称类似`getInstance()`。
- en: 'The private field can be assigned from within a static initializer block or,
    more simply, by using an initializer. The `getInstance()` method (which must be
    public) then simply returns this instance:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过静态初始化块或更简单的初始化器来为私有字段赋值。然后，`getInstance()`方法（必须是公共的）简单地返回这个实例：
- en: '[PRE31]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note that the method of using *lazy evaluation* in the `getInstance()` method
    (as in *Design Patterns*) is not necessary in Java because Java already uses *lazy
    loading*. Your `Singleton` class will probably not get loaded until its `getInstance()`
    is called, so there is no point in trying to defer the `Singleton` construction
    until it’s needed by having `getInstance()` test the `singleton` variable for
    null and creating the singleton there.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在`getInstance()`方法中使用*延迟评估*（如*设计模式*中）在Java中并不是必要的，因为Java已经使用*延迟加载*。直到调用`getInstance()`时，你的`Singleton`类可能都不会被加载，所以尝试通过让`getInstance()`测试`singleton`变量是否为空并在那里创建单例来推迟`Singleton`的构建是没有意义的。
- en: 'Using this class is equally simple: simply get the instance reference, and
    invoke methods on it:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个类同样简单：只需获取实例引用，然后调用其方法：
- en: '[PRE32]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Some commentators believe that a code-based Singleton should also provide a
    `public final clone()` method that just throws an exception, in order to avoid
    subclasses that cheat and `clone()` the Singleton. However, it is clear that a
    class with only a private constructor cannot be subclassed, so this paranoia does
    not appear to be necessary.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 一些评论员认为，基于代码的单例应该还提供一个`public final clone()`方法，只是抛出异常，以避免那些欺骗并`clone()`单例的子类。然而，很明显，只有私有构造函数的类不能被子类化，因此这种偏执似乎是没有必要的。
- en: See Also
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The `Collections` class in `java.util` has methods `singletonList()`, `singletonMap()`,
    and `singletonSet()`, which give out an immutable `List`, `Map`, or `Set`, respectively,
    containing only the one object that is passed to the method. This does not, of
    course, convert the object into a Singleton in the sense of preventing that object
    from being cloned or other instances from being constructed.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util`中的`Collections`类具有`singletonList()`、`singletonMap()`和`singletonSet()`方法，分别返回只包含传递给方法的一个对象的不可变`List`、`Map`或`Set`。当然，这并不会将对象转换为防止克隆该对象或构造其他实例的单例模式。'
- en: See page 127 of the original *Design Patterns* book.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 参见原著《*设计模式*》书第127页。
- en: 8.8 Roll Your Own Exceptions
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.8 自定义异常
- en: Problem
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You’d like to use an application-specific exception class or two.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望使用一个特定于应用程序的异常类或两个异常类。
- en: Solution
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Go ahead and subclass `Exception` or `RuntimeException`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 继续并对`Exception`或`RuntimeException`进行子类化。
- en: Discussion
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: In theory, you could subclass `Throwable` directly, but that’s considered rude.
    You normally subclass `Exception` (if you want a checked exception) or `RuntimeException`
    (if you want an unchecked exception). Checked exceptions are those that an application
    developer is required to catch or throw upward by listing them in the `throws`
    clause of the invoking method.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，您可以直接子类化`Throwable`，但这被认为是不礼貌的。通常情况下，您会子类化`Exception`（如果您想要一个受检异常）或`RuntimeException`（如果您想要一个未受检异常）。受检异常是应用程序开发人员需要通过在调用方法的`throws`子句中列出它们来捕获或向上抛出的异常。
- en: 'When subclassing either of these, it is customary to provide at least these
    constructors:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在子类化任何一个异常时，通常至少应提供以下构造函数：
- en: A no-argument constructor
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个无参数构造函数
- en: A one-string argument constructor
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个一个字符串参数的构造函数
- en: A two-argument constructor—a string message and a `Throwable` cause
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个两参数构造函数——一个字符串消息和一个`Throwable`原因
- en: The cause will appear if the code receiving the exception performs a stack trace
    operation on it, with the prefix “Root Cause is” or similar. [Example 8-7](#chessmoveexception)
    shows these three constructors for an application-defined exception, `ChessMoveException`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果接收异常的代码对其执行堆栈跟踪操作，则会显示原因，带有“根本原因是”或类似的前缀。[示例 8-7](#chessmoveexception)展示了应用程序定义的异常`ChessMoveException`的这三个构造函数。
- en: Example 8-7\. main/src/main/java/oo/ChessMoveException.java
  id: totrans-261
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-7\. main/src/main/java/oo/ChessMoveException.java
- en: '[PRE33]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: See Also
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The javadoc documentation for `Exception` lists a large number of subclasses;
    you might look there first to see if there is one you can use.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`Exception`的javadoc文档列出了大量的子类；您可以首先查看那里是否有您可以使用的子类。'
- en: 8.9 Using Dependency Injection
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.9 使用依赖注入
- en: Problem
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to avoid excessive coupling between classes, and you want to avoid
    excessive code dedicated to object creation/lookup.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望避免类之间的过度耦合，并且希望避免为对象创建/查找而专门编写的过多代码。
- en: Solution
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use a dependency injection framework.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 使用依赖注入框架。
- en: Discussion
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: A dependency injection framework allows you to have objects passed in to your
    code instead of making you either create them explicitly (which ties your code
    to the implementing class name, since you’re calling the constructor) or looking
    for them (which requires use of a possibly cumbersome lookup API, such as JNDI,
    the Java Naming and Directory Interface).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入框架允许您将对象传递给您的代码，而不是要求您显式地创建它们（这会将您的代码与实现类名绑定在一起，因为您正在调用构造函数）或查找它们（这可能需要使用可能繁琐的查找API，如JNDI，即Java命名和目录接口）。
- en: Three of the best-known dependency injection frameworks are the [Spring Framework](http://springframework.org),
    the [Java Enterprise Edition’s Context and Dependency Injection (CDI)](http://docs.oracle.com/javaee/6/tutorial/doc/giwhl.html),
    and [Google Guice](http://code.google.com/p/google-guice). Suppose we have three
    classes, a `Model`, a `View`, and a `Controller`, implementing the traditional
    MVC pattern. Given that we may want to have different versions of some of these,
    especially the `View`, we’ll define Java interfaces for simple versions of the
    Model (in [Example 8-8](#MVC_Model_interface)) and View (in [Example 8-9](#MVC_View_interface)).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 三个最知名的依赖注入框架分别是 [Spring Framework](http://springframework.org)、[Java Enterprise
    Edition’s Context and Dependency Injection (CDI)](http://docs.oracle.com/javaee/6/tutorial/doc/giwhl.html)
    和 [Google Guice](http://code.google.com/p/google-guice)。假设我们有三个类，`Model`、`View`
    和 `Controller`，实现传统的 MVC 模式。考虑到我们可能希望对其中一些类的不同版本进行管理，尤其是 `View`，我们将为 Model 的简单版本（在
    [Example 8-8](#MVC_Model_interface) 中）和 View 的简单版本（在 [Example 8-9](#MVC_View_interface)
    中）定义 Java 接口。
- en: Example 8-8\. MVC Model interface
  id: totrans-273
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-8\. MVC 模型接口
- en: '[PRE34]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Example 8-9\. main/src/main/java/di/View.java (MVC View interface)
  id: totrans-275
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-9\. main/src/main/java/di/View.java（MVC 视图接口）
- en: '[PRE35]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The implementations of these are not shown, because they’re so trivial, but
    they are online. The Controller in this example is a main program, no interface
    needed. First, let’s see a version of the main program *not* using dependency
    injection. Obviously the View requires the Model, to get the data to display:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这些的实现没有显示，因为它们非常简单，但是可以在线找到。在这个例子中，控制器是一个主程序，不需要接口。首先，让我们看一个 *不* 使用依赖注入的主程序版本。显然，View
    需要 Model 来获取要显示的数据：
- en: '*main/src/main/java/di/ControllerTightlyCoupled.java*'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '*main/src/main/java/di/ControllerTightlyCoupled.java*'
- en: '[PRE36]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here we have four tasks to undertake:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们有四个任务要完成：
- en: Create the Model.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 Model。
- en: Create the View.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 View。
- en: Tie the Model into the View.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Model 绑定到 View。
- en: Ask the View to display some data.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要求视图显示一些数据。
- en: 'Now a version using dependency injection:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用依赖注入的版本：
- en: '*main/src/main/java/di/spring/MainAndController.java - Spring Controller*'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '*main/src/main/java/di/spring/MainAndController.java - Spring 控制器*'
- en: '[PRE37]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In this version, we have only three tasks:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本中，我们只有三个任务：
- en: Set up the Spring context, which provides the dependency injection framework.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置 Spring 上下文，提供依赖注入框架。
- en: Get the View from the context; it already has the Model set into it!
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从上下文获取 View；它已经将 Model 设置到其中！
- en: Ask the View to display some data.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要求视图显示一些数据。
- en: Furthermore, we don’t depend on particular implementations of the interface.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们不依赖于接口的特定实现。
- en: 'How does Spring know to inject, or provide, a Model to the View? And how does
    it know what code to use for the View? There might be multiple implementations
    of the View interface. Of course we have to tell it these things, which we’ll
    do here with annotations:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 如何知道要向视图注入或提供一个 Model？它如何知道要为视图使用什么代码？可能会有多个视图接口的实现。当然，我们必须告诉它这些信息，我们将在这里使用注解来做到这一点：
- en: '[PRE38]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: While Spring has provided its own annotations, it will also accept the Java
    standard `@javax.annotation.Resource` annotation for injection and `@java.inject.Named`
    to specify the injectee.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Spring 提供了自己的注解，但也会接受 Java 标准的 `@javax.annotation.Resource` 注解进行注入和 `@java.inject.Named`
    来指定注入对象。
- en: Due to the persistence of information on the web, if you do a web search for
    Spring Injection, you will probably find zillions of articles that refer to the
    older Spring 2.x way of doing things, which is to use an XML configuration file.
    You can still use this, but modern Spring practice is generally to use Java annotations
    to configure the dependencies.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 由于信息在网络上的持久性，如果你搜索 Spring 注入，你可能会找到大量引用旧版 Spring 2.x 配置方法的文章，即使用 XML 配置文件的方法。你仍然可以使用这种方法，但现代
    Spring 实践通常是使用 Java 注解来配置依赖关系。
- en: 'Annotations are also used in the Java Enterprise Edition Contexts and Dependency
    Injection (CDI). Although this is most widely used in web applications, we’ll
    reuse the same example, using the open source Weld implementation of CDI. CDI
    is quite a bit more powerful than Spring’s DI; because in CDI we don’t even need
    to know the class from which a resource is being injected, we don’t even need
    the interfaces from the Spring example! First, the Controller, or main program,
    which requires a Weld-specific import or two because CDI was originally designed
    for use in enterprise applications:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java企业版（EE）上下文和依赖注入（CDI）中也使用了注解。虽然这在Web应用程序中最为广泛使用，我们将重复使用相同的示例，使用CDI的开源Weld实现。CDI比Spring的DI功能更强大；因为在CDI中，我们甚至不需要知道从哪个类注入资源，所以甚至不需要Spring示例中的接口！首先是控制器或主程序，它需要一些Weld特定的导入，因为CDI最初是为企业应用程序设计的：
- en: '[PRE39]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `View` interface is shared between both implementations. The `ConsoleViewer`
    implementation is similar too, except it isn’t coupled to the Model; it just asks
    to have a `String` injected. In this simple example there is only one `String`
    in the application; in a larger app you would need one additional annotation to
    specify which string to inject. Here is the CDI `ConsoleViewer`:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`View`接口被两个实现共享。`ConsoleViewer`的实现也类似，只是它不与模型耦合；它只是请求注入一个`String`。在这个简单的示例中，应用程序中只有一个`String`；在更大的应用程序中，您需要一个额外的注解来指定要注入的字符串。这里是CDI的`ConsoleViewer`：'
- en: '[PRE40]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Where does the injected `String` come from? From the Model, as before:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 注入的`String`来自哪里？仍然来自模型：
- en: '*main/src/main/java/di/cdi/ModelImpl.java*'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '*main/src/main/java/di/cdi/ModelImpl.java*'
- en: '[PRE41]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: See Also
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Spring DI, Java EE CDI, and Guice all provide powerful *dependency injection*.
    Spring’s is more widely used; Java EE’s has the same power and is built into every
    EE container. All three can be used standalone or in a web application, with minor
    variations. In the EE, Spring provides special support for web apps, and in EE
    containers, CDI is already set up so that the first statement in the `CDIMain`
    example is not needed in an EE app. There are many books on Spring. One book specifically
    treats Weld: *[JBoss Weld CDI for Java Platform](http://shop.oreilly.com/product/9781782160182.do)*
    by Ken Finnegan (O’Reilly).'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: Spring DI、Java EE CDI和Guice都提供强大的*依赖注入*。Spring的使用更广泛；Java EE具有相同的功能，并且内置于每个EE容器中。这三种方法可以独立使用，也可以在Web应用程序中使用，只需进行轻微调整即可。在EE中，Spring为Web应用程序提供了特别支持，在EE容器中，CDI已经设置好，因此在EE应用程序中不需要`CDIMain`示例中的第一条语句。关于Spring有很多书籍。有一本书专门介绍了Weld：*[JBoss
    Weld CDI for Java Platform](http://shop.oreilly.com/product/9781782160182.do)*，作者是Ken
    Finnegan（O'Reilly）。
- en: '8.10 Program: Plotter'
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.10 程序：绘图仪
- en: Not because it is very sophisticated, but because it is simple, this program
    serves as an example of some of the things we’ve covered in this chapter, and
    also, in its subclasses, provides a springboard for other discussions. This class
    describes a series of old-fashioned (i.e., common in the 1970s and 1980s) pen
    plotters. A pen plotter, in case you’ve never seen one, is a device that moves
    a pen around a piece of paper and draws things. It can lift the pen off the paper
    or lower it, and it can draw lines, letters, and so on. Before the rise of laser
    printers and ink-jet printers, pen plotters were the dominant means of preparing
    charts of all sorts, as well as presentation slides (this was, ah, well before
    the rise of programs like Harvard Presents and Microsoft PowerPoint). Today, few,
    if any, companies still manufacture pen plotters, but I use them here because
    they are simple enough to be well understood from this brief description. Today’s
    3D printers may be thought of as representing a resurgence of the pen plotter
    with just one additional axis of motion. And a fancier pen.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 不是因为它非常复杂，而是因为它很简单，这个程序作为我们在本章涵盖的一些内容的示例，同时，在它的子类中，它还提供了其他讨论的起点。这个类描述了一系列老式（即20世纪70年代和80年代常见的）钢笔绘图仪。钢笔绘图仪是一种将钢笔移动到纸张上并画图的设备。它可以抬起笔或放下笔，并且可以画线条、字母等。在激光打印机和喷墨打印机兴起之前，钢笔绘图仪是准备各种图表以及演示幻灯片的主要手段（这是在像Harvard
    Presents和Microsoft PowerPoint之类的程序兴起之前）。今天，几乎没有公司还在生产钢笔绘图仪，但我在这里使用它们是因为它们足够简单，可以从这个简短的描述中理解。今天的3D打印机可以被认为是钢笔绘图仪的一种复苏，只是增加了一个额外的运动轴。还有一个更高级的笔。
- en: 'I’ll present a high-level class that abstracts the key characteristics of a
    series of such plotters made by different vendors. It would be used, for example,
    in an analytical or data-exploration program to draw colorful charts showing the
    relationships found in data. But I don’t want my main program to worry about the
    gory details of any particular brand of plotter, so I’ll abstract into a `Plotter`
    class, whose source is as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我将介绍一个高级类，抽象出由不同供应商制造的一系列这样的绘图机的关键特征。例如，它将用于分析或数据探索程序中，绘制显示数据关系的彩色图表。但我不希望我的主程序担心任何特定品牌的细节，所以我将其抽象为一个
    `Plotter` 类，其源代码如下：
- en: '*main/src/main/java/plotter/Plotter.java*'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '*main/src/main/java/plotter/Plotter.java*'
- en: '[PRE42]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note the variety of abstract methods. Those related to motion, pen control,
    or drawing are left abstract, due to the number of different ways of implementing
    motion on radically different devices. However, the method for drawing a rectangle
    (`drawBox`) has a default implementation, which simply puts the currently selected
    pen onto the paper at the last-moved-to location, draws the four sides, and raises
    the pen. Subclasses for smarter plotters will likely override this method, but
    subclasses for less-evolved plotters will probably use the default version. This
    method also has two overloaded convenience methods for cases where the client
    has an AWT Dimension for the size or an AWT Rectangle for the location and size.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 注意抽象方法的多样性。与运动、笔控制或绘图相关的方法因实现运动方式在不同设备上的不同而被留在抽象状态。但是，绘制矩形的方法（`drawBox`）有一个默认实现，它简单地将当前选定的笔移动到上次移动到的位置，绘制四条边界，并抬起笔。更智能的绘图机的子类可能会重写这个方法，但是较低级的绘图机的子类可能会使用默认版本。这个方法还有两个重载的方便方法，用于客户端有AWT尺寸维度或AWT矩形位置和尺寸的情况。
- en: 'To demonstrate one of the subclasses of this program, consider the following
    simple driver program. This is intended to simulate a larger graphics application
    such as gnuplot. The `Class.forName()` near the beginning of `main` is discussed
    in [Recipe 17.2](ch17.html#javacook-reflection-SECT-2); for now, you can take
    my word that it simply creates an instance of the given subclass, which we store
    in a `Plotter` reference named `r` and use to draw the plot:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 要演示该程序的一个子类，请考虑以下简单的驱动程序。这旨在模拟更大的图形应用程序，如gnuplot。`main` 开头附近的 `Class.forName()`
    在 [Recipe 17.2](ch17.html#javacook-reflection-SECT-2) 中有讨论；暂时，你可以相信它只是创建给定子类的一个实例，我们将其存储在名为
    `r` 的 `Plotter` 引用中，并用它来绘制图表：
- en: '*main/src/main/java/plotter/PlotDriver.java*'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '*main/src/main/java/plotter/PlotDriver.java*'
- en: '[PRE43]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We don’t show any actual subclasses of this `Plotter` class in upcoming chapters,
    however there is a PlotterAWT proof-of-concept in the same source folder, and
    one could implement this for PostScript, PDF, or other output technologies.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在接下来的章节中并不展示该 `Plotter` 类的任何实际子类，但在同一源文件夹中有一个 `PlotterAWT` 的概念验证，可以为PostScript、PDF或其他输出技术实现它。
- en: '^([1](ch08.html#idm45290664734344-marker)) A value class is one used mainly
    to hold state, rather than logic: a `Person` is a value class, whereas `java.lang.Math`
    is not. Many classes are somewhere in between.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch08.html#idm45290664734344-marker)) 值类主要用于保存状态而不是逻辑：`Person` 是一个值类，而
    `java.lang.Math` 不是。许多类介于两者之间。
- en: ^([2](ch08.html#idm45290663675912-marker)) Of course these lights wouldn’t have
    remote power-off. But the computers might, for maintenance purposes.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch08.html#idm45290663675912-marker)) 当然，这些灯可能没有远程断电功能。但计算机可能会有，用于维护目的。
- en: ^([3](ch08.html#idm45290663297016-marker)) For Java folks not that familiar
    with C/C++, C is the older, non-OO language; C++ is an OO derivative of C; and
    Java is in part a portable, more strongly typesafe derivative of C++.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch08.html#idm45290663297016-marker)) 对于那些不太熟悉 C/C++ 的 Java 开发者来说，C 是旧的非面向对象语言；C++
    是 C 的面向对象衍生语言；Java 在某种程度上是 C++ 的便携式、更加类型安全的衍生语言。
