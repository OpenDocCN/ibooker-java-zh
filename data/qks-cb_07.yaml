- en: Chapter 7\. Persistence
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章 持久化
- en: The underlying persistence strategies used by Quarkus should already be familiar
    to you. Transactions, datasources, Java Persistence API (JPA), and so on are all
    standards that have existed for many years. Quarkus uses these and, in some cases,
    builds on top of them to make working with persistent stores easier. In this chapter,
    you will learn about working with persistent stores in Quarkus. We cover both
    traditional relational database management systems (RDBMS) and NoSQL databases.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus 使用的底层持久化策略应该已经很熟悉了。事务、数据源、Java Persistence API（JPA）等都是存在多年的标准。Quarkus
    使用这些标准，并在某些情况下在其基础上进行扩展，以便更轻松地处理持久化存储。在本章中，您将学习如何在 Quarkus 中处理持久化存储。我们涵盖传统的关系型数据库管理系统（RDBMS）和
    NoSQL 数据库。
- en: Quarkus has some additional gems if you’re using a traditional RDBMS or MongoDB
    in the form a Panache, an opinionated, entity or active record type API. Panache
    simplifies much of the standard JPA syntax, making your application easier to
    read and maintain—again, helping you to be more productive!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用传统的关系型数据库管理系统或 MongoDB，则 Quarkus 通过 Panache 提供了一些额外的宝贝，Panache 是一种基于实体或活动记录的
    API，具有明确的观点。Panache 简化了大部分标准 JPA 语法，使您的应用程序更易于阅读和维护，从而帮助您提高生产力！
- en: 'In this chapter, you’ll learn how to accomplish the following tasks:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何完成以下任务：
- en: Configure datasources
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置数据源
- en: Deal with transactions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理事务
- en: Manage database schema migrations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理数据库模式迁移
- en: Make use of the Panache API
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用 Panache API
- en: Interact with NoSQL data stores
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 NoSQL 数据存储交互
- en: 7.1 Defining a Datasource
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.1 定义数据源
- en: Problem
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to define and use a datasource.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望定义和使用数据源。
- en: Solution
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the Agroal extension and *application.properties*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Agroal 扩展和 *application.properties*。
- en: Discussion
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Agroal is the preferred datasource and connection pooling implementation in
    Quarkus. The Agroal extension has integrations with security, transaction management,
    and health metrics. While it does have its own extension, if you are using Hibernate
    ORM or Panache, the Agroal extension is pulled in transitively. You will also
    need a database driver extension. Currently, H2, PostgreSQL, MariaDB, MySQL, Microsoft
    SQL Server, and Derby all have supported extensions. You can add the correct database
    driver with the Maven `add-extension`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Agroal 是 Quarkus 中首选的数据源和连接池实现。Agroal 扩展与安全性、事务管理和健康指标集成。虽然它有自己的扩展，但如果您使用 Hibernate
    ORM 或 Panache，则 Agroal 扩展会通过传递方式引入。您还需要一个数据库驱动扩展。目前，H2、PostgreSQL、MariaDB、MySQL、Microsoft
    SQL Server 和 Derby 都有支持的扩展。您可以使用 Maven 的 `add-extension` 添加正确的数据库驱动：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Configuration for the datasource, just like all the other configurations for
    Quarkus, is done in the *src/main/resources/application.properties* file:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 数据源的配置，就像 Quarkus 的所有其他配置一样，在 *src/main/resources/application.properties* 文件中完成：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-19
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Sensitive data can be passed via system properties, environment properties,
    Kubernetes Secrets, or Vault, as you will see in later chapters.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 敏感数据可以通过系统属性、环境属性、Kubernetes Secrets 或 Vault 传递，稍后章节将详细介绍。
- en: 'Should you need access to the datasource, you can inject it as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要访问数据源，可以按以下方式注入它：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-23
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You can also use the `AgroalDataSource` type, which is a subtype of `DataSource`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用 `AgroalDataSource` 类型，它是 `DataSource` 的子类型。
- en: 7.2 Using Multiple Datasources
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.2 使用多个数据源
- en: Problem
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to use multiple datasources when more than one datasource is necessary
    for your application.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的应用程序需要多个数据源时，您可以使用多个数据源。
- en: Solution
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use named datasources.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命名数据源。
- en: 'Agroal allows for multiple datasources. They are configured exactly the same
    as the default, with one noteable exception—a name:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Agroal 允许多个数据源。它们的配置与默认配置完全相同，只有一个显著的例外——名称：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The format is as follows: `quarkus.*datasource*.[*optional name*.][*datasource
    property*]`.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 格式如下：`quarkus.*datasource*.[*optional name*.][*datasource property*]`。
- en: Discussion
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Injection works identically; however, you will need a qualifier (please see
    [Recipe 5.10](ch05.xhtml#named_qualifier) for more information about qualifiers):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注入的工作方式相同；但是，您需要一个限定符（请参阅 [Recipe 5.10](ch05.xhtml#named_qualifier) 获取有关限定符的更多信息）：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 7.3 Adding Datasource Health Check
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.3 添加数据源健康检查
- en: Problem
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to add a health check entry for the datasource(s).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望为数据源添加健康检查条目。
- en: Solution
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use both the `quarkus-agroal` and `quarkus-smallrye-health` extensions.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 同时使用 `quarkus-agroal` 和 `quarkus-smallrye-health` 扩展。
- en: Discussion
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The health check for datasources is automatically added when the `quarkus-smallrye-health`
    extension is in use. It can be disabled, if desired, with the `quarkus.datasource.health.enabled`
    (default to `true`) property in *application.properties*. To view the status,
    access the */health/ready* endpoint of your application. That endpoint is created
    from the `quarkus-smallrye-health` extension.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`quarkus-smallrye-health`扩展时，数据源的健康检查会自动添加。如果需要，可以通过`application.properties`中的`quarkus.datasource.health.enabled`属性（默认为`true`）禁用。要查看状态，请访问应用程序的`/health/ready`端点。该端点是从`quarkus-smallrye-health`扩展创建的。
- en: See Also
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'For more information, visit the following page on GitHub:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多信息，请访问GitHub上的以下页面：
- en: '[MicroProfile Health](https://oreil.ly/CDLOd)'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[MicroProfile Health](https://oreil.ly/CDLOd)'
- en: 7.4 Defining Transaction Boundaries Declaratively
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.4 声明事务边界
- en: Problem
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to define a transaction boundary using annotations.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望使用注解定义事务边界。
- en: Solution
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the `@javax.transaction.Transactional` annotation from the `quarkus-narayana-jta`
    extension.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`quarkus-narayana-jta`扩展中的`@javax.transaction.Transactional`注解。
- en: Discussion
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The `quarkus-narayana-jta` extension adds in the `@javax.transaction.Transactional`
    annotations, as well as the `TransactionManager` and `UserTransaction` classes.
    This extension is automatically added by any persistence extensions. Of course,
    this can be added manually if needed.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`quarkus-narayana-jta`扩展添加了`@javax.transaction.Transactional`注解，以及`TransactionManager`和`UserTransaction`类。该扩展会自动添加到任何持久性扩展中。当然，如果需要，也可以手动添加。'
- en: 'The `@Transactional` annotation can be added to any CDI bean at the method
    or class level to make those methods transactional—this also includes REST endpoints:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Transactional`注解可以添加到任何CDI bean的方法或类级别，使这些方法具有事务性，这也包括REST端点：'
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 7.5 Setting a Transaction Context
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.5 设置事务上下文
- en: Problem
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want a different transaction context.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一个不同的事务上下文。
- en: Solution
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: The `value` attribute on `@Transactional` allows the scope to be set for the
    transaction.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Transactional`的`value`属性允许设置事务的范围。'
- en: Discussion
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'The transaction context specified is propagated to all nested calls within
    the method that has been annotated. Unless a runtime exception is thrown in the
    stack, the transaction will commit at the end of the method call:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 指定的事务上下文将传播到已注释的方法内的所有嵌套调用。除非在堆栈中抛出运行时异常，否则事务将在方法调用结束时提交：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is overridable with the `dontRollbackOn` or `rollbackOn` attributes of
    `@⁠T⁠r⁠a⁠n⁠s​a⁠c⁠t⁠i⁠o⁠n⁠a⁠l`. You can also inject the `TransactionManager` if
    you need to manually roll back a transaction.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过`@⁠T⁠r⁠a⁠n⁠s​a⁠c⁠t⁠i⁠o⁠n⁠a⁠l`的`dontRollbackOn`或`rollbackOn`属性进行重写。如果需要手动回滚事务，还可以注入`TransactionManager`。
- en: 'Here is a list of available transactional contexts:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可用事务上下文的列表：
- en: '`@Transactional(REQUIRED)` (default)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Transactional(REQUIRED)`（默认）'
- en: Starts a transaction if none was started; otherwise, stays with the existing
    one
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有启动事务，则启动一个；否则，继续使用现有的事务。
- en: '`@Transactional(REQUIRES_NEW)`'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Transactional(REQUIRES_NEW)`'
- en: Starts a transaction if none was started; if an existing one was started, suspends
    it and starts a new one for the boundary of that method
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有启动事务，则启动一个；如果已经启动了现有事务，则将其挂起，并在该方法的边界内启动一个新事务。
- en: '`@Transactional(MANDATORY)`'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Transactional(MANDATORY)`'
- en: Fails if no transaction was started; otherwise, works within the existing transaction
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有启动事务，则失败；否则，在现有事务中工作。
- en: '`@Transactional(SUPPORTS)`'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Transactional(SUPPORTS)`'
- en: If a transaction was started, joins it; otherwise, works with no transaction
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果已经启动了事务，则加入它；否则，在没有事务的情况下工作。
- en: '`@Transactional(NOT_SUPPORTED)`'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Transactional(NOT_SUPPORTED)`'
- en: If a transaction was started, suspends it and works with no transaction for
    the boundary of the method; otherwise, works with no transaction
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果已经启动了事务，则暂停它，并在方法边界内没有事务地工作；否则，在没有事务的情况下工作。
- en: '`@Transactional(NEVER)`'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Transactional(NEVER)`'
- en: If a transaction was started, raises an exception; otherwise, works with no
    transaction
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果已经启动了事务，则会引发异常；否则，会在没有事务的情况下工作。
- en: 7.6 Programmatic Transaction Control
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.6 编程式事务控制
- en: Problem
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want more fine-grained control over transactions.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望更精细地控制事务。
- en: Solution
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Inject the `UserTransaction` and use the methods of that class.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注入`UserTransaction`并使用该类的方法。
- en: 'The `UserTransaction` class has a very simple API:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserTransaction`类具有非常简单的API：'
- en: '`begin()`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`begin()`'
- en: '`commit()`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`commit()`'
- en: '`rollback()`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rollback()`'
- en: '`setRollbackOnly()`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setRollbackOnly()`'
- en: '`getStatus()`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getStatus()`'
- en: '`setTransactionTimeout(int)`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setTransactionTimeout(int)`'
- en: The first three methods will be the main methods used. `getStatus()` is useful
    in determining where the transaction is in its life cycle. Lastly, you are able
    to set the timeout for a transaction.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 前三种方法将是主要使用的方法。`getStatus()`有助于确定事务在其生命周期中的位置。最后，您可以为事务设置超时时间。
- en: Note
  id: totrans-91
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If needed, you can also use the `javax.transaction.TransactionManager` by injecting
    it.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如有必要，您还可以通过注入来使用`javax.transaction.TransactionManager`。
- en: See Also
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'For more information, visit the following web page:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 欲获取更多信息，请访问以下网页：
- en: '[Jakarta EE 8 Specification APIs: Interface UserTransaction](https://oreil.ly/lmjR_)'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Jakarta EE 8 规范 API：接口 UserTransaction](https://oreil.ly/lmjR_)'
- en: 7.7 Setting and Modifying a Transaction Timeout
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.7 设置和修改事务超时时间
- en: Problem
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want a transaction to time out and roll back after a certain amount of time.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望在一定时间后使事务超时并回滚。
- en: Solution
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the `@io.quarkus.narayana.jta.runtime.TransactionConfiguration` annotation
    if using declarative transactions; otherwise, the transaction API can be used
    for programmatic transaction control. You can also change the global timeout for
    transactions with the `quarkus.transaction-manager.default-transaction-timeout`
    property, specified as a `java.time.Duration`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用声明性事务，请使用`@io.quarkus.narayana.jta.runtime.TransactionConfiguration`注解；否则，可以使用事务
    API 进行编程式事务控制。您还可以通过`quarkus.transaction-manager.default-transaction-timeout`属性更改全局事务超时时间，该属性以`java.time.Duration`格式指定。
- en: Modifying the timeout of a transaction for a one-off is very easy with the `@TransactionConfiguration`
    annotation. Use the `timeout` attribute to set the number of seconds for the timeout.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@TransactionConfiguration`注解非常容易修改事务的超时时间。使用`timeout`属性设置超时时间（以秒为单位）。
- en: Discussion
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Should every transaction in the application need a longer or shorter time, use
    the `quarkus.transaction-manager.default-transaction-timeout` property in *application.properties*.
    That property takes a `java.time.Duration`, which can be specified as a string
    parsable via `Duration#parse()`. You may also start the duration with an integer.
    Quarkus will then automatically prepend `PT` to the value to create the correct
    formatting.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序中的每个事务都需要更长或更短的时间，可以在*application.properties*中使用`quarkus.transaction-manager.default-transaction-timeout`属性。该属性接受`java.time.Duration`，可以作为可通过`Duration#parse()`解析的字符串指定。您也可以从整数开始持续时间。Quarkus
    将自动在值前面添加`PT`，以创建正确的格式。
- en: See Also
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'For more information, visit the following website:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 欲获取更多信息，请访问以下网站：
- en: '[Oracle: Java Platform, Standard Edition 8 API Specification: `parse`](https://oreil.ly/8gvMZ)'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Oracle: Java 平台，标准版 8 API 规范：`parse`](https://oreil.ly/8gvMZ)'
- en: 7.8 Setup with Persistence.xml
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.8 使用 Persistence.xml 进行设置
- en: Problem
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to use JPA with a *persistence.xml* file.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望使用带有*persistence.xml*文件的 JPA。
- en: Solution
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use JPA like you normally would; just set up the datasource in *application.properties*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以像平常一样使用 JPA；只需在*application.properties*中设置数据源即可。
- en: Discussion
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: JPA in Quarkus works exactly as it does in other settings, so there no changes
    are necessary.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Quarkus 中，JPA 的工作方式与其他设置完全相同，因此不需要进行任何更改。
- en: Note
  id: totrans-114
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You cannot use the `quarkus.hibernate-orm.*` properties if you are using *persistence.xml*.
    If you are, only the persistence units defined in the *persistence.xml* file will
    be available.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用*persistence.xml*，则不能使用`quarkus.hibernate-orm.*`属性。如果使用*persistence.xml*，则只能使用在*persistence.xml*文件中定义的持久单元。
- en: 7.9 Setup Without persistence.xml
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.9 在没有 persistence.xml 的情况下进行设置
- en: Problem
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to use JPA, but without a *persistence.xml* file.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您想使用 JPA，但不使用*persistence.xml*文件。
- en: Solution
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Add the `quarkus-hibernate-orm` extension, the JDBC driver for your RDBMS, configuration
    via *application.properties*, and finally annotate your entities with `@Entity`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 添加`quarkus-hibernate-orm`扩展，为您的关系型数据库（RDBMS）配置JDBC驱动程序，通过*application.properties*进行配置，最后使用`@Entity`注解您的实体。
- en: Discussion
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: There isn’t anything special to set up using Quarkus and JPA beyond database
    connectivity. Quarkus will make some opinionated choices, but don’t worry—they’re
    probably the choices you would have made anyway—and continue on with your entities.
    You will be able to inject and utilize an `EntityManager` just as your normally
    would.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Quarkus 和 JPA 并没有什么特别的设置，除了数据库连接。Quarkus 将做出一些主观选择，但不用担心——它们可能是您本来会选择的选项——然后继续使用您的实体。您可以像平常一样注入和使用`EntityManager`。
- en: In a nutshell, you continue as you usually would with standard JPA, but without
    all the additional configuration of a *persistence.xml*. This is the preferred
    way to use JPA in Quarkus.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，您可以像使用标准 JPA 一样继续进行，但不需要额外的 *persistence.xml* 配置。这是在 Quarkus 中使用 JPA 的首选方式。
- en: 7.10 Using Entities from a Different JAR
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用来自不同 JAR 的实体
- en: Problem
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to include entities from a different jar.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望包含来自不同 jar 的实体。
- en: Solution
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Include an empty *META-INF/beans.xml* file in the jar containing the entities.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含实体的 jar 中包含一个空的 *META-INF/beans.xml* 文件。
- en: Discussion
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Quarkus relies on compile-type bytecode enhancements to entities. If these entities
    are defined in the same project (jar) as the rest of the application, everything
    works as it should.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus 依赖于实体的编译时字节码增强。如果这些实体定义在与应用程序的其余部分（jar）相同的项目中，则一切都会正常工作。
- en: However, if other classes such as entities or other CDI beans are defined in
    an external library, that library must contain an empty *META-INF/beans.xml* file
    to be properly indexed and enhanced.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果其他类（如实体或其他 CDI bean）定义在外部库中，则该库必须包含一个空的 *META-INF/beans.xml* 文件，以便正确地被索引和增强。
- en: 7.11 Persisting Data with Panache
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Panache 持久化数据
- en: Problem
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to persist data with Hibernate and Panache.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望使用 Hibernate 和 Panache 持久化数据。
- en: Solution
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Call the `persist` method on a `PanacheEntity`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `PanacheEntity` 上调用 `persist` 方法。
- en: Naturally, you’ll need to add the `quarkus-hibernate-orm-panache` extension,
    and the corresponding JDBC extension for your data store. Next, you’ll need to
    define an entity. All that entails is creating a class, annotating it with `@javax.persistence.Entity`,
    and extending from `PanacheEntity`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您需要添加 `quarkus-hibernate-orm-panache` 扩展，并为您的数据存储添加相应的 JDBC 扩展。接下来，您需要定义一个实体。所有这些都包括创建一个类，用
    `@javax.persistence.Entity` 注解，并扩展自 `PanacheEntity`。
- en: Discussion
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Panache is an opinionated API built on top of a traditional JPA. It follows
    more of an active record approach to data entities; however, under the hood, it
    is done using traditional JPA.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Panache 是建立在传统 JPA 之上的一种主张 API。它更多地遵循一种活动记录的方法来处理数据实体；然而，在底层，它是使用传统的 JPA 来实现的。
- en: As you will find throughout the exploration of Panache, much of the functionality
    is passed on to your entities through the `PanacheEntity` or `PanacheEntityBase`
    parent class—`persist` is no exception to this. `PanacheEntityBase` contains both
    the `persist()` and `persistAndFlush()` methods. While the flush option will immediately
    send the data to the database, it is not the recommended way of persisting the
    data.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在探索 Panache 时将会发现的那样，很多功能都通过 `PanacheEntity` 或 `PanacheEntityBase` 父类传递给您的实体——`persist`
    也不例外。`PanacheEntityBase` 包含 `persist()` 和 `persistAndFlush()` 方法。虽然 flush 选项会立即将数据发送到数据库，但这不是推荐的持久化数据的方式。
- en: 'Persisting is very simple, as you can see in the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在以下所见，持久化是非常简单的：
- en: '[PRE8]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'For completion, here is the `Library` entity:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 作为补充，这里是 `Library` 实体：
- en: '[PRE9]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 7.12 Finding All Entity Instances with Panache listAll Method
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Panache 的 listAll 方法来查找所有实体实例
- en: Problem
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to find all entries of an entity.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要找到实体的所有条目。
- en: Solution
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the `listAll()` method from the `PanacheEntityBase` class.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `PanacheEntityBase` 类的 `listAll()` 方法。
- en: 'Just like the `persist()` method covered in the previous recipe, `listAll()`
    is a method from the `PanacheEntityBase` class. There isn’t anything special about
    it; it queries the database for all the entries of the given entity. It returns
    those entities in a `List`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 就像前一节中涵盖的 `persist()` 方法一样，`listAll()` 是 `PanacheEntityBase` 类的一个方法。它并没有什么特别之处；它查询给定实体的所有条目。它以
    `List` 的形式返回这些实体：
- en: '[PRE10]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-152
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This method is actually a shortcut for the `findAll().list()` chain. More info
    can be found in the `hibernate-orm-panache` code base.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是一个 `findAll().list()` 链的快捷方式。有关更多信息，请参阅 `hibernate-orm-panache` 代码库。
- en: 7.13 Finding Individual Entities with Panache findById Method
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Panache 的 findById 方法来查找单个实体对象
- en: Problem
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: I want to find and load an entity from the database based on its ID.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我想要根据其 ID 从数据库中找到并加载一个实体。
- en: Solution
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use `PanacheEntityBase.findById(Object)`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `PanacheEntityBase.findById(Object)`。
- en: 'Panache simplifies finding an entity by using the `findById(Object)` method.
    All you need to do is pass the ID of the object and you will be returned the correct
    instance from the database:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `findById(Object)` 方法简化了通过 Panache 查找实体的过程。您只需传递对象的 ID，就能从数据库中返回正确的实例：
- en: '[PRE11]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 7.14 Finding Entities Using Panache Find and List Methods
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Panache 查找和列出实体的方法
- en: Problem
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to query the database for a specific entity based on its properties.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望根据其属性查询数据库中的特定实体。
- en: Solution
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the various instances of the `find` and `list` methods from `PanacheEntityBase`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `PanacheEntityBase` 的各种 `find` 和 `list` 方法的实例。
- en: 'Depending on how you need the result returned, you will use either `list` or
    `find` from the `PanacheEntityBase`. Internally, `list` uses `find`, so they are
    essentially the same:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 根据结果返回的需要，您将使用 `PanacheEntityBase` 的 `list` 或 `find`。在内部，`list` 使用 `find`，因此它们本质上是相同的：
- en: '[PRE12]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'There are multiple overrides for both methods—they change based on the necessity
    of sorting and how you wish to send parameters. The following code is an example
    of using Hibernate Query Language (HQL) (or Java Persistence Query Language [JPQL])
    and using the `Parameters` class:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 两种方法都有多个重载版本——它们根据排序的必要性和您希望发送参数的方式而变化。以下代码是使用 Hibernate 查询语言（HQL）（或 Java 持久化查询语言
    [JPQL]）和使用 `Parameters` 类的示例：
- en: '[PRE13]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `Parameters` class override is available for both `find` and `list` methods.
    Consult the API for more information.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parameters` 类的覆盖可用于 `find` 和 `list` 方法。有关更多信息，请参考 API。'
- en: Note
  id: totrans-171
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You may be wondering, Why the full JPQL query? Put simply, it is to avoid serialization
    issues with the list. Using the left join, we are able to fetch the library and
    all the inventory for that library.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会问，为什么需要完整的 JPQL 查询？简而言之，这是为了避免与列表的序列化问题。通过左连接，我们能够获取图书馆及其所有库存。
- en: 7.15 Obtaining a Count of Entities Using the Panache count Method
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.15 使用 Panache 的 count 方法获取实体计数
- en: Problem
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to get a count of items for a resource.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要获取资源的项目计数。
- en: Solution
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the various `count` methods from `PanacheEntityBase`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `PanacheEntityBase` 的各种 `count` 方法。
- en: 'Just like the `find` methods discussed earlier, Panache has various `count`
    method overrides available to obtain the number of entities of a given type in
    the database:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前讨论的 `find` 方法一样，Panache 提供了各种 `count` 方法的重载，用于获取数据库中给定类型的实体数量：
- en: '[PRE14]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 7.16 Paginating Through Entity Lists Using the Panache page Method
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.16 使用 Panache 的 page 方法分页浏览实体列表
- en: Problem
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to use pagination.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望使用分页。
- en: Solution
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Quarkus, specifically Panache, has pagination built in. There are a number of
    methods on the `PanacheQuery` object that support pagination.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus，特别是 Panache，内置了分页功能。`PanacheQuery` 对象上有许多支持分页的方法。
- en: Discussion
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Pagination is very easy to get going. The first step is to get an instance
    of a `PanacheQuery`. This is as easy as using the `find` methods:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 分页非常容易上手。第一步是获取 `PanacheQuery` 的实例。这与使用 `find` 方法一样简单：
- en: '[PRE15]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[![1](Images/1.png)](#co_persistence_CO1-1)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_persistence_CO1-1)'
- en: Pages of 25 items, starting on page 3
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 每页显示 25 个项目，从第 3 页开始
- en: 'There are, of course, other methods such as `firstPage()`, `lastPage()`, `nextPage()`,
    and `previousPage()`. Boolean supporting methods exist as well: `hasNextPage()`,
    `hasPreviousPage()`, and `pageCount()`.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有其他方法，如 `firstPage()`、`lastPage()`、`nextPage()` 和 `previousPage()`。还存在支持布尔的方法：`hasNextPage()`、`hasPreviousPage()`
    和 `pageCount()`。
- en: See Also
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'For more information, see the following pages on GitHub:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多信息，请参阅 GitHub 上的以下页面：
- en: '[`Page` object](https://oreil.ly/KYlsJ)'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Page` 对象](https://oreil.ly/KYlsJ)'
- en: '[`PanacheQuery` interface](https://oreil.ly/BtgHK)'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`PanacheQuery` 接口](https://oreil.ly/BtgHK)'
- en: 7.17 Streaming Results via the Panache Stream Method
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.17 通过 Panache 的 Stream 方法流式处理结果
- en: Problem
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to use streams for data.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望使用数据流。
- en: Solution
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'All `list` methods have corresponding `stream` methods when using Panache.
    Below you will see how these are used, which isn’t any different than how `list`
    methods are used:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Panache 时，所有的 `list` 方法都有对应的 `stream` 方法。下面您将看到它们的使用方式，与 `list` 方法的使用方式没有任何不同：
- en: '[PRE16]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Each of the `stream` and `streamAll` methods return a `java.util.Stream` instance.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`stream` 和 `streamAll` 方法各自返回一个 `java.util.Stream` 实例。'
- en: Note
  id: totrans-202
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '`stream` methods require a transaction to work correctly.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`stream` 方法需要事务才能正常工作。'
- en: See Also
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'For more information, visit the following website:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多信息，请访问以下网站：
- en: '[io.quarkus: `PanacheEntityBase`](https://oreil.ly/OW2fV)'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[io.quarkus：`PanacheEntityBase`](https://oreil.ly/OW2fV)'
- en: 7.18 Testing Panache Entities
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.18 测试 Panache 实体
- en: Problem
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to use an embedded database for testing.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望在测试中使用嵌入式数据库。
- en: Solution
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Quarkus comes with helpers for the in-memory databases H2 and Derby to properly
    boot the database as a separate process.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus 提供了用于内存数据库 H2 和 Derby 的助手，以正确地将数据库作为单独的进程引导。
- en: Be sure to add either the `io.quarkus:quarkus-test-h2:1.4.1.Final` or the `i⁠o​.⁠q⁠u⁠a⁠r⁠k⁠u⁠s⁠:⁠q⁠u⁠a⁠r⁠k⁠u⁠s⁠-⁠t⁠e⁠s⁠t⁠-⁠d⁠e⁠r⁠b⁠y⁠:⁠1⁠.⁠4⁠.⁠1⁠.⁠F⁠i⁠n⁠a⁠l`
    artifacts to your build file.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将`io.quarkus:quarkus-test-h2:1.4.1.Final`或`i⁠o​.⁠q⁠u⁠a⁠r⁠k⁠u⁠s⁠:⁠q⁠u⁠a⁠r⁠k⁠u⁠s⁠-⁠t⁠e⁠s⁠t⁠-⁠d⁠e⁠r⁠b⁠y⁠:⁠1⁠.⁠4⁠.⁠1⁠.⁠F⁠i⁠n⁠a⁠l`这些构件添加到您的构建文件中。
- en: The next step is to annotate any test using the embedded database with `@⁠Q⁠u⁠a⁠r⁠k⁠u⁠s​T⁠e⁠s⁠t⁠R⁠e⁠s⁠o⁠u⁠r⁠c⁠e⁠(⁠H⁠2⁠D⁠a⁠t⁠a⁠b⁠a⁠s⁠e⁠T⁠e⁠s⁠t⁠R⁠e⁠s⁠o⁠u⁠r⁠c⁠e⁠.⁠c⁠l⁠a⁠s⁠s⁠)`
    or `@QuarkusTestResource(DerbyDatabaseTestResource.class)`. Lastly, be sure to
    set the correct database URL and driver for the chosen database in *src/test/resources/META-INF/application.properties*.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是对使用嵌入式数据库的任何测试进行注释，使用`@⁠Q⁠u⁠a⁠r⁠k⁠u⁠s​T⁠e⁠s⁠t⁠R⁠e⁠s⁠o⁠u⁠r⁠c⁠e⁠(⁠H⁠2⁠D⁠a⁠t⁠a⁠b⁠a⁠s⁠e⁠T⁠e⁠s⁠t⁠R⁠e⁠s⁠o⁠u⁠r⁠c⁠e⁠.⁠c⁠l⁠a⁠s⁠s⁠)`或`@QuarkusTestResource(DerbyDatabaseTestResource.class)`。最后，请确保在*src/test/resources/META-INF/application.properties*中为所选数据库设置正确的数据库URL和驱动程序。
- en: 'The following is an example for H2:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是H2的示例：
- en: '[PRE17]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-217
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This helper does not add the database into the native image, only the client
    code. However, feel free to use this for tests against your application in JVM
    mode or native image mode.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 此辅助程序仅将数据库添加到本机映像中，而不是客户端代码。但是，在JVM模式或本机映像模式下的应用程序测试中，可以自由使用此辅助程序。
- en: See Also
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'For more information, visit the following websites:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多信息，请访问以下网站：
- en: '[H2 Database Engine](https://oreil.ly/_MMus)'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[H2 Database Engine](https://oreil.ly/_MMus)'
- en: '[Apache Derby](https://oreil.ly/FUFeH)'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Apache Derby](https://oreil.ly/FUFeH)'
- en: 7.19 Using a Data Access Object (DAO) or Repository Pattern
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.19 使用数据访问对象（DAO）或存储库模式
- en: Problem
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to use the DAO or the repository pattern.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 欲使用DAO或存储库模式。
- en: Solution
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Quarkus doesn’t limit with Panache; you can use the Entity pattern as previously
    described, a DAO, or a repository pattern.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus不限于Panache；您可以像以前描述的那样使用实体模式，DAO或存储库模式。
- en: 'The two interfaces you’ll need to understand to use a repository are `PanacheRepository`
    and `PanacheRepositoryBase`. The base interface is necessary only if you have
    a primary key that isn’t a `Long`. All of the same operations available on `PanacheEntity`
    are available on `PanacheRepository`. A repository is a CDI bean, so it must be
    injected when it is being used. Here are some basic examples:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用存储库，您需要理解`PanacheRepository`和`PanacheRepositoryBase`这两个接口。只有在您的主键不是`Long`时，才需要基本接口。`PanacheEntity`上可用的所有操作在`PanacheRepository`上也都可以使用。存储库是一个CDI
    bean，在使用时必须注入它。以下是一些基本示例：
- en: '[PRE19]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: A DAO would work exactly as you would expect. You would need to inject an `EntityManager`
    and query as normal. There are a myriad of solutions and examples for using a
    DAO with Java that are available both online and in other books. Those examples
    will all function the same with Quarkus.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: DAO将按您的预期工作。您需要注入一个`EntityManager`并像平常一样查询。关于在Java中使用DAO的解决方案和示例非常多，可以在线或其他书籍中找到。所有这些示例在Quarkus中都将正常运行。
- en: See Also
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'For more information, visit the following website:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多信息，请访问以下网站：
- en: '[io.quarkus: `PanacheRepositoryBase`](https://oreil.ly/H6kTU)'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[io.quarkus: `PanacheRepositoryBase`](https://oreil.ly/H6kTU)'
- en: 7.20 Using Amazon DynamoDB
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.20 使用Amazon DynamoDB
- en: Problem
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to use DynamoDB with a Quarkus application.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 欲在Quarkus应用程序中使用DynamoDB。
- en: Solution
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use the DynamoDB extension and setup configuration. The DynamoDB extension
    allows both sync and async clients to make use of the Apache Amazon Web Service
    Software Development Kit (AWS SDK) client. There are a few things necessary to
    set up and enable in your project to get this running. The first is, of course,
    the dependency:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 使用DynamoDB扩展并设置配置。DynamoDB扩展允许同步和异步客户端使用Apache Amazon Web Service软件开发工具包（AWS
    SDK）客户端。在项目中启用并配置此功能需要一些必要的设置。首先当然是依赖项：
- en: '[PRE20]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-240
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: There is no Quarkus extension for the AWS connection client.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus没有AWS连接客户端的扩展。
- en: 'The extension uses the URLConnection HTTP client by default. You need to add
    the correct client (URLConnection, Apache, or Netty NIO) to your build script:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，扩展使用URLConnection HTTP客户端。您需要向构建脚本添加正确的客户端（URLConnection，Apache或Netty
    NIO）：
- en: '[PRE21]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[![1](Images/1.png)](#co_persistence_CO2-1)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_persistence_CO2-1)'
- en: You must exclude `commons-logging` to force the client to use the Quarkus logger
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须排除`commons-logging`以强制客户端使用Quarkus日志记录器
- en: 'If you are using the Apache client, you will also need to make an adjustment
    to the *application.properties* file because `url` is the default:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用Apache客户端，则还需要对*application.properties*文件进行调整，因为`url`是默认值：
- en: '[PRE22]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'There are also configurations for the client in *application.properties* (please
    see the [properties references](https://oreil.ly/HZ4A-) for more):'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *application.properties* 中还有客户端的配置（请参阅[属性引用](https://oreil.ly/HZ4A-)以获取更多信息）：
- en: '[PRE23]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[![1](Images/1.png)](#co_persistence_CO3-1)'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_persistence_CO3-1)'
- en: Useful if using a nonstandard endpoint, such as a local DynamoDB instance
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用非标准端点（例如本地 DynamoDB 实例），则很有用
- en: '[![2](Images/2.png)](#co_persistence_CO3-2)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_persistence_CO3-2)'
- en: Correct, and valid, region
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 正确且有效的地区
- en: '[![3](Images/3.png)](#co_persistence_CO3-3)'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_persistence_CO3-3)'
- en: '`static` or `default`'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`static` 或 `default`'
- en: 'The `default` credential type will look for credentials in order:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`default` 凭证类型将按顺序查找凭证：'
- en: System properties `aws.accessKeyId` and `aws.secretKey`
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统属性 `aws.accessKeyId` 和 `aws.secretKey`
- en: Environment variables `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY`
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境变量 `AWS_ACCESS_KEY_ID` 和 `AWS_SECRET_ACCESS_KEY`
- en: Credential profiles at the default location (*$HOME/.aws/credentials*)
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 凭证配置文件位于默认位置（*$HOME/.aws/credentials*）
- en: Credentials delivered through the Amazon EC2 container service
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 Amazon EC2 容器服务提供的凭据
- en: Instance profile credentials delivered through Amazon EC2 metadata service
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 Amazon EC2 元数据服务传递的实例配置凭据
- en: Discussion
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The following example is from [Recipe 7.11](#persisting_data_panache), but with
    DynamoDB as the persistence store.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例来自[Recipe 7.11](#persisting_data_panache)，但使用 DynamoDB 作为持久存储。
- en: 'Here are the two classes used to talk to DynamoDB and create an injectable
    service to be used in the REST endpoint:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是用于与 DynamoDB 通信并创建可注入服务以在 REST 端点中使用的两个类：
- en: '[PRE24]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following abstract class contains boilerplate code needed to talk to DynamoDB
    and persist and query `Book` instances:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的抽象类包含了与 DynamoDB 通信以及持久化和查询 `Book` 实例所需的样板代码：
- en: '[PRE25]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This last class is the class representing the `Book` entity:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最后的类是表示 `Book` 实体的类：
- en: '[PRE26]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[![1](Images/1.png)](#co_persistence_CO4-1)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_persistence_CO4-1)'
- en: Necessary to have reflection in a native application
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在本机应用程序中必须具有反射
- en: '[![2](Images/2.png)](#co_persistence_CO4-2)'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_persistence_CO4-2)'
- en: Required by DynamoDB client
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: DynamoDB 客户端所需
- en: Most of this is standard DynamoDB code, with the exception of the Quarkus annotation
    registering the `Book` class for reflection, which is necessary only if you are
    creating a native image.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分是标准的 DynamoDB 代码，唯一的例外是 Quarkus 注解为反射注册 `Book` 类，仅在创建本机镜像时才需要。
- en: As you can see, the skills you have already acquired while working previously
    with DynamoDB are still usable without much modification when working with Quarkus,
    which helps you be more productive.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，当使用 Quarkus 时，您以前使用 DynamoDB 时已经掌握的技能仍然可以在工作中使用，而无需进行太多修改，这有助于提高您的工作效率。
- en: 7.21 Working with MongoDB
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.21 使用 MongoDB
- en: Problem
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to use MongoDB as a persistent store.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望使用 MongoDB 作为持久存储。
- en: Solution
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: The Quarkus MongoDB extension makes use of the MongoDB Driver and Client.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus MongoDB 扩展使用了 MongoDB 驱动程序和客户端。
- en: Discussion
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: By now you should be familiar with the basics of a RESTful resource and Quarkus
    configuration. Here we’ll show the code and example configuration used to talk
    to a local MongoDB instance.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该对 RESTful 资源和 Quarkus 配置的基础知识很熟悉。在这里，我们将展示用于与本地 MongoDB 实例通信的代码和示例配置。
- en: 'Naturally, you’ll need to add the connection information to your application:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，您需要将连接信息添加到您的应用程序中：
- en: '[PRE27]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `Book` class is a representation of the document within MongoDB:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`Book` 类是 MongoDB 中文档的表示：'
- en: '[PRE28]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This service class acts as a DAO, a way into the MongoDB instance:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这个服务类充当 DAO，一种进入 MongoDB 实例的方式：
- en: '[PRE29]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Lastly, a RESTful resource makes use of the previous two classes:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，RESTful 资源利用了前面两个类：
- en: '[PRE30]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We’ll leave it as an exercise for the reader to create and use a BSON Codec.
    One of the other handy features of the MongoDB extension is an automatic health
    check that runs when using the `quarkus-smallrye-health` extension. The `quarkus-smallrye-health`
    extension will automatically create a readiness health check for your MongoDB
    connection. The readiness check, of course, is configurable.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其留给读者作为一个练习，来创建并使用 BSON 编解码器。MongoDB 扩展的另一个有用功能是，在使用 `quarkus-smallrye-health`
    扩展时自动运行的自动健康检查。当然，可读性检查是可配置的。
- en: The Quarkus MongoDB extension also includes a reactive client, which will be
    detailed in [Recipe 15.12](ch15.xhtml#using-reactive-mongodb-client-recipe).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus MongoDB 扩展还包括一个响应式客户端，将在[Recipe 15.12](ch15.xhtml#using-reactive-mongodb-client-recipe)中详细介绍。
- en: 7.22 Using Panache with MongoDB
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.22 使用Panache与MongoDB
- en: Problem
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to use Panache with MongoDB.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望使用Panache与MongoDB。
- en: Solution
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Add the `mongodb-panache` extension and use all the Panache abilities with `PanacheMongoEntity`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 添加`mongodb-panache`扩展，并使用`PanacheMongoEntity`的所有Panache能力。
- en: 'Panache for MongoDB works the same as Panache for Hibernate, which we saw in
    recipes [7.7](#setting-and-modifying-a-transaction-timeout) through [7.17](#streaming-results-via-panache-stream).
    It significantly simplifies your entity code:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB的Panache与Hibernate的Panache工作方式相同，我们在[7.7](#setting-and-modifying-a-transaction-timeout)到[7.17](#streaming-results-via-panache-stream)的示例中看到了。它显著简化了您的实体代码：
- en: '[PRE31]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[![1](Images/1.png)](#co_persistence_CO5-1)'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_persistence_CO5-1)'
- en: The optional `@MongoEntity` annotation allows you to customize the database
    and/or collection used
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的`@MongoEntity`注解允许您自定义使用的数据库和/或集合。
- en: '[![2](Images/2.png)](#co_persistence_CO5-2)'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_persistence_CO5-2)'
- en: The required part—add your fields as public fields
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 必需部分——将您的字段添加为公共字段
- en: '[![3](Images/3.png)](#co_persistence_CO5-3)'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_persistence_CO5-3)'
- en: Customize the serialized field name with `@BsonProperty`
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@BsonProperty`自定义序列化字段名。
- en: '[![4](Images/4.png)](#co_persistence_CO5-4)'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_persistence_CO5-4)'
- en: Query using PanacheQL (subset of JPQL), just like with JPA
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 使用PanacheQL（JPQL的子集）进行查询，就像使用JPA一样。
- en: Discussion
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The Panache MongoDB extension uses the `PojoCodecProvider` to map entites to
    a MongoDB `Document`. Besides `@BsonProperty`, you can also ignore fields with
    `@BsonIgnore`. You are also able to set up custom IDs with `@BsonId` and extend
    `PanacheMongoEntityBase`.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: Panache MongoDB扩展使用`PojoCodecProvider`将实体映射到MongoDB的`Document`。除了`@BsonProperty`，您还可以使用`@BsonIgnore`忽略字段。您还可以使用`@BsonId`设置自定义ID，并扩展`PanacheMongoEntityBase`。
- en: Of course, if you need to write accessor methods, Panache doesn’t stop you from
    doing that; in fact, at build time all the field calls are replaced with the corresponding
    accessor/mutator calls. Just like Panache for Hibernate, the MongoDB version supports
    pagination, sorting, streams, and the rest of the Panache API.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果您需要编写访问器方法，Panache并不会阻止您这样做；事实上，在构建时所有字段调用都会替换为相应的访问器/变异器调用。就像Hibernate的Panache一样，MongoDB版本支持分页、排序、流和Panache
    API的其余部分。
- en: The PanacheQL query you see in the previous example is easy to use and understand;
    but if you prefer to use regular MongoDB queries, those are also supported, provided
    that the query starts with `{`.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 您在前面的示例中看到的PanacheQL查询易于使用和理解；但如果您更喜欢使用常规的MongoDB查询，也是支持的，只要查询以`{`开头。
- en: 'A slight difference between the Hibernate and MongoDB Panache varieties is
    MongoDB’s ability to use Query Projection on the return of a `find()` method.
    This allows you to restrict which fields are returned from the database. Here
    is a very basic example with our `Book` entity:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 与Hibernate和MongoDB Panache变体之间的轻微差异在于MongoDB能够在`find()`方法的返回上使用查询投影。这允许您限制从数据库返回哪些字段。以下是我们的`Book`实体的一个非常基本的示例：
- en: '[PRE32]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If you have a hierarchy of projection classes, the parent class(es) will also
    need to be annotated with `@ProjectionFor`.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您具有投影类的层次结构，则父类（们）也需要使用`@ProjectionFor`进行注释。
- en: 7.23 Using Neo4j with Quarkus
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.23 使用Neo4j与Quarkus
- en: Problem
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to connect to and use Neo4j.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望连接并使用Neo4j。
- en: Solution
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the Quarkus Neo4j extension based on the Neo4j Java Driver.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于Neo4j Java Driver的Quarkus Neo4j扩展。
- en: The following examples make use of the asynchronous programming model (based
    on JDK’s completable futures). The driver also makes use of a blocking model,
    similar to JDBC, and a reactive model. The reactive model is available only to
    Neo4j 4+ versions.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用基于JDK的CompletableFuture的异步编程模型。驱动程序还使用类似于JDBC的阻塞模型和响应式模型。响应式模型仅适用于Neo4j
    4及以上版本。
- en: 'By now you’ve seen how to add additional extensions to your project, so we
    won’t cover that here. The following example also manages books, like others before
    it:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经看到如何向项目添加额外的扩展，因此我们这里不再详述。以下示例还管理书籍，就像之前的示例一样：
- en: '[PRE33]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Naturally, you will need to configure the client. This can be as easy as setting
    the `quarkus.neo4j.uri`, `quarkus.neo4j.authentication.username`, and `q⁠u⁠a⁠r⁠k⁠u⁠s​.⁠n⁠e⁠o⁠4⁠j⁠.⁠a⁠u⁠t⁠h⁠e⁠n⁠t⁠i⁠c⁠a⁠t⁠i⁠o⁠n⁠.⁠p⁠a⁠s⁠s⁠w⁠o⁠r⁠d`
    properties. You can consult the extension for more properties.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您需要配置客户端。这可以很简单，设置`quarkus.neo4j.uri`、`quarkus.neo4j.authentication.username`和`quarkus.neo4j.authentication.password`属性。您可以查阅扩展以获取更多属性信息。
- en: 'The first thing you will need to configure the client is the Neo4j Driver.
    The extension provides an injectable instance:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 配置客户端的第一件事是Neo4j驱动程序。该扩展提供了一个可注入的实例：
- en: '[PRE34]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, create a new REST resource and add the Driver injection point, then add
    the basic CRUD operations:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个新的REST资源并添加Driver注入点，然后添加基本的CRUD操作：
- en: '[PRE35]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[![1](Images/1.png)](#co_persistence_CO6-1)'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_persistence_CO6-1)'
- en: Gets an `AsyncSession` from the driver
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 从驱动程序获取`AsyncSession`
- en: '[![2](Images/2.png)](#co_persistence_CO6-2)'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_persistence_CO6-2)'
- en: Executes Cypher (Neo4j’s query language) to fetch the data
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 执行Cypher（Neo4j的查询语言）来获取数据
- en: '[![3](Images/3.png)](#co_persistence_CO6-3)'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_persistence_CO6-3)'
- en: Retrieves a cursor, creating `Book` instances from the nodes
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 检索游标，从节点创建`Book`实例
- en: '[![4](Images/4.png)](#co_persistence_CO6-4)'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_persistence_CO6-4)'
- en: Closes the session once we’re done
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成后关闭会话
- en: '[![5](Images/5.png)](#co_persistence_CO6-5)'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](Images/5.png)](#co_persistence_CO6-5)'
- en: Builds a JAX-RS response
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 构建JAX-RS响应
- en: 'The rest of the class/code follow the same pattern:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 类/代码的其余部分遵循相同的模式：
- en: '[PRE36]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This last one is a little different, in that it handles errors:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个有点不同，因为它处理错误：
- en: '[PRE38]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: See Also
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The [Neo4j Cypher Manual](https://oreil.ly/ITHPx) will come in handy as you
    learn and try new things with Cypher.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '[Neo4j Cypher手册](https://oreil.ly/ITHPx)在您学习和尝试Cypher的新功能时会很有帮助。'
- en: 7.24 Flyway at Startup
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.24 在启动时使用Flyway
- en: Problem
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to use Flyway to migrate my database schema.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望使用Flyway来迁移我的数据库架构。
- en: Solution
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the `quarkus-flyway` integration extension.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`quarkus-flyway`集成扩展。
- en: Discussion
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Quarkus has first-class support for schema migrations using Flyway. There are
    five things you need to do to use Flyway with Quarkus at application start:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus对使用Flyway进行模式迁移具有一流支持。您需要做五件事来在应用程序启动时使用Flyway与Quarkus：
- en: Add the Flyway extension.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加Flyway扩展。
- en: Add the JDBC driver for your database.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加适用于你的数据库的JDBC驱动程序。
- en: Setup the datasource(s).
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置数据源。
- en: Add migrations to *src/main/resources/db/migration*.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将迁移添加到*src/main/resources/db/migration*。
- en: Set the `quarkus.flyway.migrate-at-start` to `true`.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`quarkus.flyway.migrate-at-start`设置为`true`。
- en: The default naming schema for Flyway migrations is `V.<version>__<description>.sql`.
    Everything else is taken care of.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: Flyway迁移的默认命名模式是`V.<version>__<description>.sql`。其他所有事项都已处理。
- en: 'You can also use Flyway with multiple datasources. Any settings that need to
    be configured for each datasource are named with the same schema as datasource
    names: `quarkus.flyway.*datasource name*.*setting*`. For example, it might be
    `quarkus.flyway.users.migrate-at-start`.'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用多个数据源来使用Flyway。任何需要为每个数据源配置的设置都以与数据源名称相同的模式命名：`quarkus.flyway.*数据源名称*.*设置*`。例如，可能是`quarkus.flyway.users.migrate-at-start`。
- en: 7.25 Using Flyway Programmatically
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.25 以编程方式使用Flyway
- en: Problem
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to use Flyway programmatically. There may be times when you want to
    control when the schema is migrated instead of doing it at application startup.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望以编程方式使用Flyway。有时，您可能希望控制模式何时迁移，而不是在应用程序启动时进行迁移。
- en: Solution
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use the `quarkus-flyway` extension and inject the `Flyway` instance:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`quarkus-flyway`扩展并注入`Flyway`实例：
- en: '[PRE39]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Discussion
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'This will inject the default `org.flywaydb.core.Flyway` instance configured
    against the default datasource. If you have multiple datasources and Flyway instances,
    you can inject specific ones using either the `@FlywayDataSource` or `@Named`
    annotation. When using `@FlywayDataSource`, the value is the name of the datasource.
    If instead you use `@Named`, the value should be the name of the datasource with
    the `flyway_` prefix:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这将注入针对默认数据源配置的默认`org.flywaydb.core.Flyway`实例。如果您有多个数据源和Flyway实例，可以使用`@FlywayDataSource`或`@Named`注解来注入特定的实例。当使用`@FlywayDataSource`时，值是数据源的名称。如果改用`@Named`，则值应该是带有`flyway_`前缀的数据源名称：
- en: '[PRE40]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Naturally, you will be able to run all the standard Flyway operations such as
    `clean`, `migrate`, `validate`, `info`, `baseline`, and `repair`.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 自然而然，您将能够运行所有标准的Flyway操作，如`clean`，`migrate`，`validate`，`info`，`baseline`和`repair`。
