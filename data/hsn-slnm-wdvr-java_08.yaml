- en: Chapter 6\. Remote WebDriver
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章\. 远程 WebDriver
- en: So far, the examples explained in this book use web browsers locally installed
    on the machine that executes the tests. This chapter covers another relevant feature
    of the Selenium WebDriver API, i.e., the ability to use remote browsers (i.e.,
    installed in other hosts). First, we review the architecture that allows using
    remote browsers in Selenium WebDriver. Second, we study Selenium Grid, a networked
    infrastructure that provides remote browsers for Selenium WebDriver tests. Third,
    we analyze some of the most relevant cloud providers, i.e., companies that provide
    managed services for automated testing. Finally, we explore how to use Docker
    to support the browser infrastructure for Selenium.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本书中解释的示例都是在执行测试的机器上使用本地安装的 web 浏览器。本章涵盖了 Selenium WebDriver API 的另一个重要特性，即使用远程浏览器的能力（即安装在其他主机上）。首先，我们回顾了允许在
    Selenium WebDriver 中使用远程浏览器的架构。其次，我们研究了 Selenium Grid，这是一个为 Selenium WebDriver
    测试提供远程浏览器的网络基础设施。第三，我们分析了一些最重要的云提供商，即提供自动化测试托管服务的公司。最后，我们探讨了如何使用 Docker 来支持 Selenium
    的浏览器基础设施。
- en: Selenium WebDriver Architecture
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Selenium WebDriver 架构
- en: As introduced in [Chapter 1](ch01.html#ch01), Selenium WebDriver is a library
    that allows controlling web browsers programmatically. The automation is based
    on the native capabilities of each browser. Therefore, we need to place a binary
    file called a *driver* between the script (typically, a test) using the Selenium
    WebDriver API and the browser. The examples you have seen so far in this book
    use local browsers, i.e., browsers installed in the same machine that executes
    the test that uses the Selenium WebDriver API. [Figure 6-1](#remotewebdriver-local)
    illustrates this approach. In this case, and when using the Java language binding
    of the Selenium WebDriver API, we need to create an instance of `ChromeDriver`
    to control Chrome, `FirefoxDriver` for Firefox, etc.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第 1 章](ch01.html#ch01)中介绍的，Selenium WebDriver 是一个允许以编程方式控制 web 浏览器的库。自动化基于每个浏览器的本机功能。因此，我们需要在脚本（通常是测试）使用
    Selenium WebDriver API 和浏览器之间放置一个称为 *driver* 的二进制文件。本书中到目前为止看到的示例使用本地浏览器，即在执行使用
    Selenium WebDriver API 的测试的同一台机器上安装的浏览器。[图 6-1](#remotewebdriver-local) 说明了这种方法。在这种情况下，当使用
    Selenium WebDriver API 的 Java 语言绑定时，我们需要创建 `ChromeDriver` 实例来控制 Chrome，`FirefoxDriver`
    来控制 Firefox 等。
- en: '![hosw 0601](assets/hosw_0601.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![hosw 0601](assets/hosw_0601.png)'
- en: Figure 6-1\. Selenium WebDriver architecture using local browsers
  id: totrans-5
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-1\. 使用本地浏览器的 Selenium WebDriver 架构
- en: The communication protocol that supports this process is called W3C WebDriver.
    This standard protocol is based on JSON messages over HTTP. Thanks to this, the
    Selenium WebDriver architecture can be distributed to different interconnected
    computers (*hosts*). [Figure 6-2](#remotewebdriver-remote) shows a schematic representation
    of a remote architecture.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 支持此过程的通信协议称为 W3C WebDriver。这一标准协议基于 HTTP 上的 JSON 消息。多亏了这一点，Selenium WebDriver
    架构可以分布到不同的互联计算机（*主机*）。[图 6-2](#remotewebdriver-remote) 显示了远程架构的示意图。
- en: '![hosw 0602](assets/hosw_0602.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![hosw 0602](assets/hosw_0602.png)'
- en: Figure 6-2\. Selenium WebDriver architecture using remote browsers
  id: totrans-8
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-2\. 使用远程浏览器的 Selenium WebDriver 架构
- en: In this case, the Selenium WebDriver API sends W3C WebDriver messages to a server-side
    component usually called *Selenium Server*. This server acts as a proxy of the
    client requests to other hosts that provide web browsers where the automation
    happens. This remote architecture eases cross-browser testing (i.e., verifying
    web applications in multiple browser types, versions, or operating systems) and
    parallel test execution.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Selenium WebDriver API 将 W3C WebDriver 消息发送到通常称为 *Selenium Server* 的服务器端组件。该服务器充当客户端请求到其他提供发生自动化的
    web 浏览器的主机的代理。这种远程架构简化了跨浏览器测试（即在多种浏览器类型、版本或操作系统中验证 web 应用程序）和并行测试执行。
- en: Creation of RemoteWebDriver Objects
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 RemoteWebDriver 对象
- en: The Selenium WebDriver API provides the class `RemoteWebDriver` to control remote
    browsers. As shown in [Figure 2-2](ch02.html#webdriver-hierarchy), this class
    is the parent of the rest of the `WebDriver` classes that drive local browsers
    (i.e., `ChromeDriver`, `FirefoxDriver`, etc.). This way, you can use `RemoteWebDriver`
    objects in the same way we have previously studied in this book.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium WebDriver API 提供了 `RemoteWebDriver` 类来控制远程浏览器。正如[图 2-2](ch02.html#webdriver-hierarchy)
    所示，该类是驱动本地浏览器的其他 `WebDriver` 类的父类（即 `ChromeDriver`、`FirefoxDriver` 等）。通过这种方式，您可以像我们在本书中之前学习的那样使用
    `RemoteWebDriver` 对象。
- en: RemoteWebDriver Constructor
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RemoteWebDriver 构造函数
- en: 'There are different ways to instantiate a `RemoteWebDriver` object. The most
    common way is to invoke its constructor by passing two arguments: the URL of the
    Selenium Server and the required capabilities. As shown in [Figure 5-1](ch05.html#capabilities-hierarchy),
    these capabilities are objects that inherit from the `Capabilities` interface
    (e.g., `ChromeOptions`, `Firefox​Op⁠tions`, etc.). [Example 6-1](#remotewebdriver_creation_1)
    shows a test setup. You can find the complete test in this book’s [code repository](https://github.com/bonigarcia/selenium-webdriver-java).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化`RemoteWebDriver`对象的方法有多种。最常见的方法是通过传递两个参数调用其构造函数：Selenium 服务器的 URL 和所需的能力。正如[图 5-1](ch05.html#capabilities-hierarchy)所示，这些能力是从`Capabilities`接口继承的对象（例如`ChromeOptions`，`Firefox​Op⁠tions`等）。[示例 6-1](#remotewebdriver_creation_1)展示了一个测试设置。您可以在本书的[代码库](https://github.com/bonigarcia/selenium-webdriver-java)中找到完整的测试。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: There is a second `RemoteWebDriver` constructor, which accepts only one parameter
    for the desired capabilities. In this case, the Selenium Server URL is read from
    the Java system property `webdriver.remote.server`. You can find an example of
    this feature in the examples repository.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 还有第二种`RemoteWebDriver`构造函数，只接受一个参数用于指定的能力。在这种情况下，Selenium 服务器的 URL 是从 Java 系统属性`webdriver.remote.server`中读取的。您可以在示例库中找到此功能的示例。
- en: Example 6-1\. Instantiation of a RemoteWebDriver object using the constructor
  id: totrans-16
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-1\. 使用构造函数实例化 RemoteWebDriver 对象
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[![1](assets/1.png)](#co_remote_webdriver_CO1-1)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_remote_webdriver_CO1-1)'
- en: We create a Java `URL` object with the Selenium Server address.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个 Java `URL` 对象，其地址为 Selenium 服务器地址。
- en: '[![2](assets/2.png)](#co_remote_webdriver_CO1-2)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_remote_webdriver_CO1-2)'
- en: We assume this URL is online. For that, we create an AssertJ assumption by invoking
    the static method `isOnline` available on WebDriverManager. As a result, the test
    is skipped when the Selenium Server is offline.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设此 URL 是在线的。为此，我们通过在 WebDriverManager 上调用静态方法`isOnline`来创建 AssertJ 假设。因此，当
    Selenium 服务器脱机时，测试会被跳过。
- en: '[![3](assets/3.png)](#co_remote_webdriver_CO1-3)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_remote_webdriver_CO1-3)'
- en: We instantiate a `ChromeOptions` object to specify the required capabilities.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实例化一个`ChromeOptions`对象来指定所需的能力。
- en: '[![4](assets/4.png)](#co_remote_webdriver_CO1-4)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_remote_webdriver_CO1-4)'
- en: We invoke the `RemoteWebDriver` constructor using the Selenium Server URL and
    the Chrome options as arguments.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Selenium 服务器 URL 和 Chrome 选项作为参数调用`RemoteWebDriver`构造函数。
- en: We use a `ChromeOptions` object without any particular setup to specify the
    required capabilities in the previous example. In other words, we request to use
    a remote Chrome browser using its default behavior. Nevertheless, we could use
    this object to configure specific capabilities (e.g., headless browser, page loading
    strategies, device emulation, etc.) as explained in [Chapter 5](ch05.html#ch05).
    Moreover, since capabilities are internally handled using key-value pairs that
    encapsulate specific browser aspects, we can manage individual capabilities invoking
    the method `options.setCapability(key, value);`. The Selenium WebDriver API provides
    the class `CapabilityType` to specify the key of these capabilities. This class
    has a set of public attributes that can be used as a `key` in the `setCapability()`
    method. [Table 6-1](#capabilitytype-attributes) shows some of these attributes.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用一个没有特别设置的`ChromeOptions`对象来指定所需的能力。换句话说，我们请求使用远程 Chrome 浏览器的默认行为。尽管如此，我们可以使用这个对象来配置特定的能力（例如无头浏览器、页面加载策略、设备仿真等），如[第5章](ch05.html#ch05)中所述。此外，由于能力内部使用键-值对来封装特定的浏览器方面，我们可以通过调用方法`options.setCapability(key,
    value);`来管理各个能力。Selenium WebDriver API 提供了`CapabilityType`类来指定这些能力的键。该类有一组公共属性，可以作为`setCapability()`方法中的`key`使用。[表 6-1](#capabilitytype-attributes)展示了其中一些属性。
- en: Table 6-1\. CapabilityType attributes
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-1\. CapabilityType 属性
- en: '| Attribute | Capability name | Description |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 能力名称 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '|'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '|'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '| Browser name (e.g., `chrome`, `firefox`, or `msedge`) |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 浏览器名称（例如`chrome`，`firefox`或`msedge`） |'
- en: '|'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '|'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '| Platform name (e.g., `WINDOWS`, `LINUX`, `MAC`, `ANDROID`, `IOS`, among others)
    |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 平台名称（例如`WINDOWS`，`LINUX`，`MAC`，`ANDROID`，`IOS`等） |'
- en: '|'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '|'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '| Browser version |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 浏览器版本 |'
- en: '|'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '|'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '| Enable or disable JavaScript execution |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 启用或禁用 JavaScript 执行 |'
- en: '|'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '|'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '| Page loading strategy (`normal`, `eager`, or `none`) |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 页面加载策略（`normal`，`eager`或`none`） |'
- en: An alternative way to specify the required capabilities in a `RemoteWebDriver`
    object is using an instance of `DesiredCapabilities`. [Table 6-2](#desiredcapabilities-methods)
    summarizes the methods provided by these objects.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `RemoteWebDriver` 对象中指定所需功能的另一种方法是使用 `DesiredCapabilities` 的实例。[表 6-2](#desiredcapabilities-methods)
    总结了这些对象提供的方法。
- en: Table 6-2\. DesiredCapabilities methods
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-2\. DesiredCapabilities 方法
- en: '| Method | Return | Description |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 返回 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '|'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '|'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '| Specify the browser name |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 指定浏览器名称 |'
- en: '|'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '|'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '| Specify the browser version |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 指定浏览器版本 |'
- en: '|'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '|'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '| Specify the platform name |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 指定平台名称 |'
- en: '|'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '|'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '| Enable or disable JavaScript execution |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 启用或禁用 JavaScript 执行 |'
- en: '|'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '|'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '| Enable or disable loading insecure pages |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 启用或禁用加载不安全页面 |'
- en: '|'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE21]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '|'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '| Enable loading insecure pages |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 启用加载不安全页面 |'
- en: '|'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE23]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '|'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE24]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '| Merge with another capabilities object |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 与另一个功能对象合并 |'
- en: Note
  id: totrans-94
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '`DesiredCapabilities` is still supported by Selenium WebDriver 4 since there
    is a lot of existing code relying on this feature. Nevertheless, the recommended
    way to specify capabilities is using browser-specific options (e.g., `ChromeOptions`,
    `FirefoxOptions`, etc.).'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Selenium WebDriver 4 仍然支持 `DesiredCapabilities`，因为有很多现有的代码依赖于此功能。尽管如此，指定功能的推荐方式是使用特定于浏览器的选项（例如
    `ChromeOptions`、`FirefoxOptions` 等）。
- en: RemoteWebDriver Builder
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RemoteWebDriver 构建器
- en: A second way to create `RemoteWebDriver` objects is using the built-in builder
    available in the Selenium WebDriver API. [Example 6-2](#remotewebdriver_creation_2)
    demonstrates how, using Edge as the remote browser.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `RemoteWebDriver` 对象的第二种方式是使用 Selenium WebDriver API 中提供的内置构建器。[示例 6-2](#remotewebdriver_creation_2)
    演示了如何使用 Edge 作为远程浏览器。
- en: Example 6-2\. Instantiation of a RemoteWebDriver object using the builder
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-2\. 使用构建器实例化 RemoteWebDriver 对象
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: WebDriverManager Builder
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WebDriverManager 构建器
- en: Alternatively, we can also use WebDriverManager to create an instance of `RemoteWebDriver`.
    To that aim, we need to invoke the method `remoteAddress()` of a given manager
    to pass the Selenium Server URL. [Example 6-3](#remotewebdriver_creation_3) shows
    a test setup using this feature and Firefox as the remote browser.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，我们还可以使用 WebDriverManager 来创建 `RemoteWebDriver` 的实例。为此，我们需要调用给定管理器的 `remoteAddress()`
    方法以传递 Selenium 服务器 URL。[示例 6-3](#remotewebdriver_creation_3) 展示了使用此功能和 Firefox
    作为远程浏览器的测试设置。
- en: Example 6-3\. Instantiation of a RemoteWebDriver object using WebDriverManager
  id: totrans-102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-3\. 使用 WebDriverManager 实例化 RemoteWebDriver 对象
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Selenium-Jupiter
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Selenium-Jupiter
- en: 'As usual, Selenium-Jupiter uses the parameter resolution feature provided by
    Jupiter. This way, and concerning remote browsers, you need to declare a test
    (or constructor) parameter using the type `RemoteWebDriver`. Then, the following
    Selenium-Jupiter annotations allow configuring the remote browser:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，Selenium-Jupiter 使用 Jupiter 提供的参数解析功能。这样，就远程浏览器而言，您需要使用类型 `RemoteWebDriver`
    声明测试（或构造函数）参数。然后，以下 Selenium-Jupiter 注解允许配置远程浏览器：
- en: '`@DriverUrl`'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`@DriverUrl`'
- en: Annotation used to identify the Selenium Server URL. Alternatively, the annotation
    `@EnabledIfDriverUrlOnline` allows specifying this URL, and at the same time,
    disables the test if that URL is not responding.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 用于标识 Selenium 服务器 URL 的注解。另外，注解 `@EnabledIfDriverUrlOnline` 允许指定此 URL，并在该 URL
    无响应时禁用测试。
- en: '`@DriverCapabilities`'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`@DriverCapabilities`'
- en: Annotation used to configure the desired capabilities.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 用于配置所需功能的注解。
- en: '[Example 6-4](#remotewebdriver_creation_4) shows a Selenium-Jupiter test using
    a remote Chrome provided by a local Selenium Server. This test will be skipped
    when the URL `http://localhost:4444/` is offline.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6-4](#remotewebdriver_creation_4) 展示了使用本地 Selenium 服务器提供的远程 Chrome 的 Selenium-Jupiter
    测试。当 URL `http://localhost:4444/` 离线时，此测试将被跳过。'
- en: Example 6-4\. Using a RemoteWebDriver object in Selenium-Jupiter test
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-4\. 在 Selenium-Jupiter 测试中使用 RemoteWebDriver 对象
- en: '[PRE27]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-113
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The `RemoteWebDriver` instantiation modes described in this section are equivalent
    from a functional point of view. In other words, these objects work in the same
    way. The difference between them is the provided *syntactic sugar* (i.e., the
    style and expressiveness).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 从功能角度来看，本节中描述的 `RemoteWebDriver` 实例化模式是等效的。换句话说，这些对象的工作方式相同。它们之间的区别在于提供的 *语法糖*（即，样式和表现力）。
- en: Selenium Grid
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Selenium Grid
- en: 'As introduced in [Chapter 1](ch01.html#ch01), Selenium Grid is a subproject
    of the Selenium suite that allows creating a networked infrastructure for remote
    browsers accessible with the W3C WebDriver protocol. Selenium Grid allows running
    parallel tests across different machines and different browsers. To that aim,
    Selenium Grid provides a Selenium Server that you can control using an instance
    of `RemoteWebDriver`. There are three ways to run Selenium Grid:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如在 [第 1 章](ch01.html#ch01) 中介绍的，Selenium Grid 是 Selenium 套件的一个子项目，允许创建一个通过 W3C
    WebDriver 协议访问的远程浏览器的网络基础设施。 Selenium Grid 允许在不同的机器和不同的浏览器上并行运行测试。为此，Selenium
    Grid 提供了一个 Selenium 服务器，您可以使用 `RemoteWebDriver` 的实例进行控制。有三种运行 Selenium Grid 的方式：
- en: Standalone
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 独立运行
- en: A single host acts as Selenium Server and supplies the browsers in this mode.
    It provides a simple way to run Selenium WebDriver tests in remote browsers.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 单个主机充当 Selenium 服务器，并在此模式下提供浏览器。它提供了一种在远程浏览器中运行 Selenium WebDriver 测试的简单方法。
- en: Hub-nodes
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Hub-nodes
- en: A potential problem of the standalone mode is the scalability (since the Selenium
    Server and the browsers are executed in the same home). Thus, the hub-nodes architecture
    defines two types of components to solve this issue. First, one host acts as *hub*
    (or Selenium Server). Then, one or most hosts are registered as *nodes* in the
    hub, providing browsers to be controlled with Selenium WebDriver. This architecture
    was introduced in [Chapter 1](ch01.html#ch01) (see [Figure 1-2](ch01.html#selenium-grid-hub-node-arch)).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 独立模式的一个潜在问题是可伸缩性（因为 Selenium 服务器和浏览器在同一个主机上执行）。因此，hub-nodes 架构定义了两种组件类型来解决这个问题。首先，一个主机充当
    *hub*（或 Selenium 服务器）。然后，在 hub 中注册一个或多个主机作为 *node*，提供浏览器以便使用 Selenium WebDriver
    控制。这种架构在 [第 1 章](ch01.html#ch01) 中引入（参见 [图 1-2](ch01.html#selenium-grid-hub-node-arch)）。
- en: Fully distributed
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 完全分布式
- en: The standalone and the hub-nodes approaches are centralized architectures that
    can degrade performance when the number of incoming requests increases. As of
    Selenium 4, Selenium Grid provides a fully distributed mode that implements load
    balancing mechanisms to solve this bottleneck.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 独立模式和 hub-nodes 方法是集中式架构，当请求增加时可能会降低性能。截至 Selenium 4，Selenium Grid 提供了一个完全分布式模式，实现了负载均衡机制以解决这个瓶颈。
- en: The following subsections provide more details about these modes and explain
    how to set up each approach.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的子章节提供了关于这些模式的更多详细信息，并解释了如何设置每种方法。
- en: Standalone
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 独立运行
- en: The standalone is the simplest approach for a Selenium Grid infrastructure.
    We can execute this mode using the shell and Java code.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 独立模式是 Selenium Grid 基础架构的最简单方法。我们可以使用 shell 和 Java 代码执行此模式。
- en: From the shell
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从 shell 开始
- en: First, we can use the shell and the Selenium Grid binary distribution to launch
    it. Selenium Grid is developed in Java, and each release is distributed as a self-contained
    JAR file with all its dependencies (also known as *uber-JAR* or *fat-JAR*). You
    can download this fat-JAR from the [Selenium download page](https://www.selenium.dev/downloads).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以使用 shell 和 Selenium Grid 二进制发行版来启动它。 Selenium Grid 是用 Java 开发的，每个发布版都作为一个自包含的
    JAR 文件提供，包含了所有的依赖项（也称为 *uber-JAR* 或 *fat-JAR*）。您可以从[Selenium 下载页面](https://www.selenium.dev/downloads)下载这个
    fat-JAR。
- en: The Selenium Server automatically detects the drivers (e.g., chromedriver, geckodriver,
    etc.) available in the system in the standalone mode. To that aim, it looks for
    these drivers in the `PATH` environment variable. As usual, we can manage these
    driver managers manually. Nevertheless, it is recommended to use WebDriverManager
    to resolve the drivers automatically. Thus, and as explained in [Appendix B](app02.html#appendix02),
    WebDriverManager can be used as a CLI tool. WebDriverManager CLI is distributed
    as a fat-JAR, available for download on [GitHub](https://github.com/bonigarcia/webdrivermanager/releases).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在独立模式下，Selenium 服务器会自动检测系统中可用的驱动程序（例如 chromedriver、geckodriver 等）。为此，它会在 `PATH`
    环境变量中查找这些驱动程序。通常情况下，我们可以手动管理这些驱动程序管理器。然而，建议使用 WebDriverManager 自动解析这些驱动程序。因此，正如在
    [附录 B](app02.html#appendix02) 中解释的那样，WebDriverManager 可以用作 CLI 工具。WebDriverManager
    CLI 以 fat-JAR 的形式分发，并可在 [GitHub](https://github.com/bonigarcia/webdrivermanager/releases)
    上下载。
- en: To illustrate this, [Example 6-5](#standalone_cli) shows the shell commands
    required to resolve chromedriver and geckodriver in a Linux machine with WebDriverManager
    CLI. Then, we use the Selenium Grid fat-JAR to start a standalone grid. Notice
    that these commands are executed in the same folder. This way, the drivers downloaded
    with WebDriverManager are available for Selenium Grid.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，[示例 6-5](#standalone_cli) 显示了在具有 WebDriverManager CLI 的 Linux 机器上解决
    chromedriver 和 geckodriver 所需的 shell 命令。然后，我们使用 Selenium Grid 的 fat-JAR 来启动独立网格。请注意，这些命令是在相同的文件夹中执行的。这样，通过
    WebDriverManager 下载的驱动程序可供 Selenium Grid 使用。
- en: Example 6-5\. Commands to resolve drivers with WebDriverManager CLI and to start
    Selenium Grid in standalone mode using the shell
  id: totrans-130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-5\. 使用 WebDriverManager CLI 解决驱动程序并使用 shell 启动独立模式的 Selenium Grid 的命令
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[![1](assets/1.png)](#co_remote_webdriver_CO2-1)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_remote_webdriver_CO2-1)'
- en: We use WebDriverManager CLI to resolve chromedriver.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 WebDriverManager CLI 来解决 chromedriver。
- en: '[![2](assets/2.png)](#co_remote_webdriver_CO2-2)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_remote_webdriver_CO2-2)'
- en: We use WebDriverManager CLI to resolve geckodriver (the driver required for
    Firefox).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 WebDriverManager CLI 来解决 geckodriver（Firefox 所需的驱动程序）。
- en: '[![3](assets/3.png)](#co_remote_webdriver_CO2-3)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_remote_webdriver_CO2-3)'
- en: We start Selenium Grid in standalone mode in the same folder (which contains
    chromedriver and geckodriver).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在包含 chromedriver 和 geckodriver 的同一文件夹中以独立模式启动 Selenium Grid。
- en: 'After these commands, the standalone Selenium Server listens to incoming HTTP
    requests in port 4444 of the localhost. Therefore, we can create an instance of
    `RemoteWebDriver` using that URL (e.g., `http://localhost:4444/` if the test executes
    in the same host) and the required capabilities (for Chrome or Firefox, in this
    case). For instance, as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 执行这些命令后，独立的 Selenium 服务器将监听本地主机的端口 `4444` 上的传入 HTTP 请求。因此，我们可以使用该 URL（例如，如果测试在同一主机上执行，则为
    `http://localhost:4444/`）和所需的能力（在本例中为 Chrome 或 Firefox）创建 `RemoteWebDriver` 的实例。例如，如下所示：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note
  id: totrans-140
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In Selenium Grid 3, the default Selenium Server URL is `http://localhost:4444/wd/hub`.
    In Selenium Grid 4, although this URL should also work, the path `/wd/hub` is
    no longer required.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Selenium Grid 3 中，默认的 Selenium 服务器 URL 是 `http://localhost:4444/wd/hub`。在
    Selenium Grid 4 中，尽管此 URL 也应该有效，但不再需要路径 `/wd/hub`。
- en: Another helpful feature provided by Selenium Grid is its *web console*. This
    console is a web UI accessible in the Selenium Server URL that allows monitoring
    of the available browsers registered in the grid and the sessions in execution.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium Grid 提供的另一个有用功能是其*网页控制台*。该控制台是通过 Selenium 服务器 URL 访问的 Web UI，允许监视网格中注册的可用浏览器和正在执行的会话。
- en: '[Figure 6-3](#selenium-grid-ui) shows a screenshot of the console of the previous
    standalone grid. Notice that in this case, the standalone Selenium Server can
    serve up to eight concurrent sessions (the same number of the available processors
    in the machine running the grid) of Chrome and Firefox.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-3](#selenium-grid-ui) 显示了先前独立网格控制台的屏幕截图。请注意，在此情况下，独立的 Selenium 服务器可以为
    Chrome 和 Firefox 提供最多八个并发会话（与运行网格的机器上可用处理器数量相同）。'
- en: '![hosw 0603](assets/hosw_0603.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![hosw 0603](assets/hosw_0603.png)'
- en: Figure 6-3\. Selenium Grid console
  id: totrans-145
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-3\. Selenium Grid 控制台
- en: From Java code
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从 Java 代码
- en: An alternative way to start Selenium Grid is using Java. In addition to the
    fat-JAR, Selenium Grid is released to Maven Central using `org.seleniumhq.selenium`
    as `groupId` and `selenium-grid` as `artifactId`. This way, we need to resolve
    its coordinates in our project setup (Maven or Gradle) to use it in our Java project
    (see [Appendix B](app02.html#appendix02) for the configuration details). [Example 6-6](#standalone_grid_java)
    demonstrates how to start Selenium Grid in standalone mode from a Java test case.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 启动 Selenium Grid 的另一种方法是使用 Java。除了 fat-JAR 外，Selenium Grid 还使用 `org.seleniumhq.selenium`
    作为 `groupId` 和 `selenium-grid` 作为 `artifactId` 在 Maven 中央仓库发布。因此，我们需要在项目设置（Maven
    或 Gradle）中解析其坐标，以在我们的 Java 项目中使用它（有关配置详细信息，请参见 [附录 B](app02.html#appendix02)）。[示例 6-6](#standalone_grid_java)
    演示了如何从 Java 测试用例中启动独立模式的 Selenium Grid。
- en: Example 6-6\. Test starting Selenium Grid in standalone mode
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-6\. 在独立模式下启动 Selenium Grid 的测试
- en: '[PRE30]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[![1](assets/1.png)](#co_remote_webdriver_CO3-1)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_remote_webdriver_CO3-1)'
- en: We find a free port on the localhost. For that, we use the class `PortProber`,
    available on Selenium WebDriver API.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本地主机上找到一个空闲端口。为此，我们使用 Selenium WebDriver API 中可用的 `PortProber` 类。
- en: '[![2](assets/2.png)](#co_remote_webdriver_CO3-2)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_remote_webdriver_CO3-2)'
- en: We use WebDriverManager to resolve chromedriver since the standalone grid to
    be started will serve Chrome browsers.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 WebDriverManager 来解决 chromedriver，因为要启动的独立网格将为 Chrome 浏览器提供服务。
- en: '[![3](assets/3.png)](#co_remote_webdriver_CO3-3)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_remote_webdriver_CO3-3)'
- en: We start Selenium Grid in standalone mode, calling its `main` method.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以独立模式启动Selenium Grid，调用其`main`方法。
- en: '[![4](assets/4.png)](#co_remote_webdriver_CO3-4)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_remote_webdriver_CO3-4)'
- en: We create a Java `URL` using the port previously selected.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用之前选择的端口创建一个Java `URL`。
- en: '[![5](assets/5.png)](#co_remote_webdriver_CO3-5)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_remote_webdriver_CO3-5)'
- en: We create an instance of `RemoteWebDriver`. As usual, we use this object in
    the test logic to invoke the Selenium WebDriver API and control the browser (see
    the examples repository for the entire class).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个`RemoteWebDriver`的实例。像往常一样，我们在测试逻辑中使用这个对象来调用Selenium WebDriver API并控制浏览器（查看示例库以获取整个类的示例）。
- en: Hub-nodes
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Hub-nodes
- en: 'The classic architecture of Selenium Grid involves two types of hosts: the
    hub (i.e., the Selenium Server) and a group of nodes. Like in the standalone mode,
    we can use the Selenium Grid fat-JAR to start this mode in the shell. First, we
    start the hub in a host. Then, we register one or more nodes in the same or different
    host. [Example 6-7](#hub_nodes_cli) shows the execution of these commands in a
    Windows console.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium Grid的经典架构包括两种类型的主机：hub（即Selenium服务器）和一组节点。与独立模式类似，我们可以使用Selenium Grid的fat-JAR在shell中启动此模式。首先，在一个主机上启动hub。然后，在同一主机或不同主机上注册一个或多个节点。[示例 6-7](#hub_nodes_cli)展示了如何在Windows控制台中执行这些命令。
- en: Example 6-7\. Command to start Selenium Grid in hub-nodes mode using the shell
  id: totrans-162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-7\. 使用shell启动hub-nodes模式的Selenium Grid命令
- en: '[PRE31]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[![1](assets/1.png)](#co_remote_webdriver_CO4-1)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_remote_webdriver_CO4-1)'
- en: We start the hub. By default, this server listens to W3C WebDriver HTTP requests
    in port 4444 and TCP ports 4442 and 4443 for registering nodes.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们启动hub。默认情况下，此服务器在端口4444上监听W3C WebDriver HTTP请求，并在端口4442和4443上监听TCP端口以注册节点。
- en: '[![2](assets/2.png)](#co_remote_webdriver_CO4-2)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_remote_webdriver_CO4-2)'
- en: 'In a second console, we register the node(s). In this example, this command
    is executed in the same host as the hub. Moreover, it supposes that the required
    drivers (e.g., chromedriver and geckodriver) are already resolved (as in [Example 6-5](#standalone_cli)).
    To start nodes from another host, we would need to invoke the following command:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个控制台中，我们注册节点（们）。在这个示例中，此命令在与hub相同的主机上执行。此外，假定所需的驱动程序（例如chromedriver和geckodriver）已经解决（就像在[示例 6-5](#standalone_cli)中一样）。要从另一个主机启动节点，我们需要调用以下命令：
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note
  id: totrans-169
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In the same way as the standalone mode, you can start a hub-nodes grid using
    Java code. For that, you need to change the parameters to invoke the Selenium
    Grid main class following the same syntax of the CLI commands for hub and nodes.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 与独立模式相同，您可以使用Java代码启动hub-nodes网格。为此，您需要更改参数以调用Selenium Grid的主类，遵循hub和节点的CLI命令的相同语法。
- en: Fully Distributed
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完全分布式
- en: 'As of version 4, we can execute a Selenium Grid infrastructure following a
    fully distributed architecture. The decisive aspect of this approach is scalability.
    Specialized nodes take care of different automation and infrastructure management
    aspects in this mode. These nodes are:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本4开始，我们可以按照完全分布式的架构执行Selenium Grid基础架构。此方法的决定性方面是可伸缩性。专门的节点在此模式下处理不同的自动化和基础设施管理方面。这些节点包括：
- en: Router
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器
- en: Node acting as a single entry point to the Grid. This component listens to W3C
    WebDriver commands from Selenium scripts.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Grid的单一入口点的节点。此组件监听来自Selenium脚本的W3C WebDriver命令。
- en: Session Queue
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 会话队列
- en: Node that stores the new session requests. These incoming sessions wait to be
    read by the *Distributor*.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 存储新会话请求的节点。这些传入会话等待由*分发器*读取。
- en: Distributor
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 分发器
- en: Node aware of all nodes and their capabilities. It asks for new session requests
    to the *Session Queue* in regular intervals.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 节点了解所有节点及其能力。它定期向*会话队列*请求新的会话请求。
- en: Event Bus
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 事件总线
- en: Component that provides a message-oriented communication channel among several
    members of the Grid architecture. This communication is represented with dotted
    lines in Figures [6-4](#selenium-grid-distributed-arch-node-reg) and [6-5](#selenium-grid-distributed-arch-new-session).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在Grid架构的多个成员之间提供基于消息的通信渠道的组件。这种通信在图[6-4](#selenium-grid-distributed-arch-node-reg)和[6-5](#selenium-grid-distributed-arch-new-session)中用虚线表示。
- en: Session Map
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 会话映射
- en: It keeps the relation of the WebDriver sessions and the nodes where the sessions
    are being executed.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 它维护WebDriver会话和执行会话的节点之间的关系。
- en: Node(s)
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 节点（们）
- en: Hosts that provide web browsers (and their corresponding drivers) for automation
    based on Selenium WebDriver.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 提供基于 Selenium WebDriver 进行自动化的网络浏览器的主机及其对应的驱动程序。
- en: Note
  id: totrans-185
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In a hub-nodes architecture, the hub aggregates the responsibilities of the
    Router, Session Queue, Distributor, Event Bus, and Session Map of the fully distributed
    mode.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在中心节点架构中，中心节点汇聚了完全分布模式下的路由器、会话队列、分发器、事件总线和会话映射的责任。
- en: 'The following subsections provide details about the most relevant processes
    in a fully distributed Selenium Grid: node registration, new session, and other
    WebDriver commands.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的小节详细介绍了完全分布式 Selenium Grid 中最相关的流程：节点注册、新会话以及其他 WebDriver 命令。
- en: Node registration
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 节点注册
- en: 'The first process required to operate a distributed Selenium Grid is registering
    one or more nodes. To that aim, nodes need to register their capabilities in the
    Distributor. [Figure 6-4](#selenium-grid-distributed-arch-node-reg) illustrates
    this process, composed of three steps:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 操作分布式 Selenium Grid 所需的第一个过程是注册一个或多个节点。为此，节点需要在分发器中注册其能力。[图 6-4](#selenium-grid-distributed-arch-node-reg)
    说明了此过程，包括三个步骤：
- en: A node sends a message through the Event Bus to announce its capabilities.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 节点通过事件总线发送消息以宣布其能力。
- en: This message reaches the Distributor, which stores the relationship between
    nodes and capabilities.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此消息到达分发器，后者存储节点与能力之间的关系。
- en: The Distributor double-checks that the node exists by exchanging HTTP messages
    (solid line) with the source node.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分发器通过与源节点交换 HTTP 消息（实线）来确保节点存在。
- en: '![hosw 0604](assets/hosw_0604.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![hosw 0604](assets/hosw_0604.png)'
- en: Figure 6-4\. Node registration in a Selenium Grid distributed architecture
  id: totrans-194
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-4\. Selenium Grid 分布式架构中的节点注册
- en: New session
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新会话
- en: 'At some point, a script (typically a test case) will try to start a new session
    to drive a browser automatically. [Figure 6-5](#selenium-grid-distributed-arch-new-session)
    describes the communication required to carry out this process in a fully distributed
    Selenium Grid, namely:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时刻，一个脚本（通常是一个测试用例）会尝试自动启动一个新的会话来驱动浏览器。[图 6-5](#selenium-grid-distributed-arch-new-session)
    描述了在完全分布式 Selenium Grid 中执行此过程所需的通信，即：
- en: A script/test using the Selenium WebDriver API sends a request to the Router
    to create a new session (i.e., to drive a browser programmatically).
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Selenium WebDriver API 的脚本/测试向路由器发送请求以创建新会话（即通过编程方式驱动浏览器）。
- en: The Router creates a new entry in the Session Queue to store this new session
    request.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 路由器在会话队列中创建一个新条目以存储此新的会话请求。
- en: The Distributor asks the Session Queue for incoming new session requests in
    intervals.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分发器定期询问会话队列是否有新的会话请求。
- en: Once the Distributor discovers a new session request, it checks if a node can
    support this session. If the session is possible (i.e., a node previously registered
    in the Distributor offers the required capabilities), the Distributor creates
    a new session with the node.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦分发器发现新的会话请求，它会检查是否有节点能够支持此会话。如果会话是可能的（即分发器中之前注册的节点提供了所需的能力），分发器将与节点创建一个新会话。
- en: The Distributor sends an HTTP message to the Session Map to store the new session.
    The Session Map stores a unique session identifier (*session id*) that univocally
    associates the node executing the browser session.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分发器向会话映射发送 HTTP 消息以存储新会话。会话映射存储一个唯一的会话标识符（*session id*），该标识符唯一地关联执行浏览器会话的节点。
- en: '![hosw 0605](assets/hosw_0605.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![hosw 0605](assets/hosw_0605.png)'
- en: Figure 6-5\. New session in a Selenium Grid distributed architecture
  id: totrans-203
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-5\. Selenium Grid 分布式架构中的新会话
- en: WebDriver commands
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: WebDriver 命令
- en: 'Once the session is established, the Selenium WebDriver API script will continue
    sending W3C WebDriver commands to control the web browser in the remote node.
    [Figure 6-6](#selenium-grid-distributed-arch-webdriver-commands) shows how this
    communication occurs in a distributed Selenium Grid infrastructure following these
    steps:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦会话建立，Selenium WebDriver API 脚本将继续发送 W3C WebDriver 命令以控制远程节点中的网络浏览器。[图 6-6](#selenium-grid-distributed-arch-webdriver-commands)
    显示了在分布式 Selenium Grid 基础设施中执行这些通信步骤：
- en: The script/test exchanges W3C WebDriver commands to drive the browser (e.g.,
    open a web page, interact with web elements, etc.) in the current session.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 脚本/测试使用 W3C WebDriver 命令来驱动浏览器（例如打开网页、与网页元素交互等）当前会话中。
- en: Further requests to the same browser session use the same session id. The Router
    recognizes that a browser session is active by reading the Session Map.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对同一浏览器会话的进一步请求使用相同的会话 ID。路由器通过读取会话映射来识别浏览器会话是否活动。
- en: The Router forwards the subsequent commands of the same session directly to
    the assigned node.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 路由器直接将同一会话的后续命令转发到分配的节点。
- en: '![hosw 0606](assets/hosw_0606.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![hosw 0606](assets/hosw_0606.png)'
- en: Figure 6-6\. WebDriver commands in a Selenium Grid distributed architecture
  id: totrans-210
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-6\. 在 Selenium Grid 分布式架构中的 WebDriver 命令
- en: Setting up a distributed grid
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置分布式网格
- en: Like in the standalone and hub-nodes modes, we can use the Selenium Grid distribution
    (as a fat-JAR or regular Java dependency) to start the fully distributed architecture.
    [Example 6-8](#fully_distributed_cli) shows the shell command required to do this
    using the command line.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 像独立模式和中心节点模式一样，我们可以使用 Selenium Grid 分发（作为一个 fat-JAR 或常规 Java 依赖项）来启动完全分布式的架构。[示例 6-8](#fully_distributed_cli)
    显示了使用命令行执行此操作所需的 shell 命令。
- en: Example 6-8\. Command to start Selenium Grid in distributed mode using the shell
  id: totrans-213
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-8\. 使用 shell 启动分布式模式下的 Selenium Grid 的命令
- en: '[PRE33]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[![1](assets/1.png)](#co_remote_webdriver_CO5-1)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_remote_webdriver_CO5-1)'
- en: We start the Event Bus. By default, the Event Bus listens to TCP ports 4442
    and 4443.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们启动事件总线。默认情况下，事件总线监听 TCP 端口 4442 和 4443。
- en: '[![2](assets/2.png)](#co_remote_webdriver_CO5-2)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_remote_webdriver_CO5-2)'
- en: We start the Session Map. By default, this component listens to incoming HTTP
    messages in port 5556.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们启动会话映射。默认情况下，此组件在端口 5556 上侦听传入的 HTTP 消息。
- en: '[![3](assets/3.png)](#co_remote_webdriver_CO5-3)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_remote_webdriver_CO5-3)'
- en: We start the Session Queue. By default, this queue listens to HTTP in port 5559.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们启动会话队列。默认情况下，此队列在端口 5559 上侦听 HTTP。
- en: '[![4](assets/4.png)](#co_remote_webdriver_CO5-4)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_remote_webdriver_CO5-4)'
- en: We start the Distributor. For that, we need to specify the Session Map and Session
    Queue addresses. In addition, and since we already started the Event Bus independently,
    we set the flag `--bind-bus` to `false`. By default, the Distributor uses port
    5553 for the HTTP communication.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们启动分发器。为此，我们需要指定会话映射和会话队列地址。此外，由于我们已经独立启动了事件总线，我们将 `--bind-bus` 标志设置为 `false`。默认情况下，分发器使用端口
    5553 进行 HTTP 通信。
- en: '[![5](assets/5.png)](#co_remote_webdriver_CO5-5)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_remote_webdriver_CO5-5)'
- en: We start the Router. We need to specify the URLs of the Session Map, Session
    Queue, and Distributor.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们启动路由器。我们需要指定会话映射、会话队列和分发器的 URL。
- en: '[![6](assets/6.png)](#co_remote_webdriver_CO5-6)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_remote_webdriver_CO5-6)'
- en: We start the Nodes. We need to specify the ports where the Event Bus listens
    to publish-subscribe messages. Moreover, in this example, several drivers (chomedriver
    and geckodriver) are available in the same folder in which this command is executed.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们启动节点。我们需要指定事件总线用于发布-订阅消息的端口。此外，在此示例中，相同文件夹中有几个驱动程序（chomedriver 和 geckodriver）可供使用。
- en: Observability
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可观测性
- en: 'In software engineering, *observability* is a measure that determines the current
    state of a software system based on its external outputs or signals. This way,
    observability allows understanding the internal state of the system by leveraging
    its external indicators. Observability can be critical for maintaining complex
    software systems and determining the root cause of any issue. To that aim, the
    three pillars of observability are:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件工程中，*可观测性* 是根据软件系统的外部输出或信号确定其当前状态的一种度量。通过这种方式，可观测性允许利用其外部指标了解系统的内部状态。可观测性对于维护复杂的软件系统和确定任何问题的根本原因可能至关重要。为此目的，可观测性的三个支柱是：
- en: Metrics
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 指标
- en: Measures of system performance over time, such as response time, transactions
    per second, or memory usage, to name a few
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 随时间变化的系统性能指标，例如响应时间、每秒事务数或内存使用量等等
- en: Logs
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 日志
- en: Lines of text (typically timestamped) that a system produces when running a
    piece of code
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 系统在运行代码时生成的文本行（通常带有时间戳）
- en: Traces
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪
- en: Representation of causally related distributed events (such as selected logs)
    that characterize the request flow of a given operation in a software system
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 描述因果关系的分布式事件（例如选择的日志），其特征是给定操作在软件系统中的请求流
- en: Selenium Grid 4 provides different features for measuring observability. First,
    Selenium Grid allows tracing using the [OpenTelemetry](https://opentelemetry.io)
    API. Second, Selenium Grid provides a GraphQL endpoint to run queries against
    the grid.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium Grid 4提供了不同的功能来测量观测性。首先，Selenium Grid允许使用[OpenTelemetry](https://opentelemetry.io)
    API进行跟踪。其次，Selenium Grid提供了一个GraphQL端点来针对网格运行查询。
- en: Tracing with OpenTelemetry
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用OpenTelemetry进行跟踪
- en: '*Tracing* is an essential way of measuring observability based on the logs
    and metrics of a software system. Selenium Grid exposes tracing in two ways. First,
    we can check the log traces when executing a grid from the shell. By default,
    the logs at the `INFO` level are displayed. We can change the level using the
    argument `--log-level` in the shell command, for instance:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '*跟踪* 是基于软件系统的日志和度量标准的重要观测测量方式。Selenium Grid通过两种方式公开跟踪。首先，我们可以在Shell中执行网格时检查日志跟踪。默认情况下，显示`INFO`级别的日志。我们可以使用Shell命令中的参数
    `--log-level` 来更改级别，例如：'
- en: '[PRE34]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Furthermore, Selenium Grid supports *distributed tracing* via OpenTelemetry
    APIs. This feature allows tracing the commands flowing through a Selenium Grid
    infrastructure. Distributed tracing requires two activities in this order:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Selenium Grid支持通过OpenTelemetry API进行*分布式跟踪*。此功能允许跟踪通过Selenium Grid基础设施传递的命令。分布式跟踪需要按照以下顺序进行两项活动：
- en: 1\. Code instrumentation
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 代码仪器化
- en: Selenium Grid allows exporting tracing information using the OpenTelemetry API.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium Grid允许使用OpenTelemetry API导出跟踪信息。
- en: 2\. Data collection
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 数据收集
- en: For example, we can use [Jaeger](https://www.jaegertracing.io), an open source
    distributed tracing platform that provides seamless integration with OpenTelemetry.
    It allows querying, visualizing, and collecting tracing data.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用[Jaeger](https://www.jaegertracing.io)，一个开源的分布式跟踪平台，它与OpenTelemetry提供无缝集成。它允许查询、可视化和收集跟踪数据。
- en: 'The following commands show how to set up Selenium Grid to export data to Jaeger.
    First, we need a Jaeger backend up and running. For that, we can download the
    executable binaries for the [Jaeger download page](https://www.jaegertracing.io/download).
    Alternatively, we can start the server using Docker, as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令展示了如何设置Selenium Grid以将数据导出到Jaeger。首先，我们需要一个运行中的Jaeger后端。为此，我们可以从[Jaeger下载页面](https://www.jaegertracing.io/download)下载可执行二进制文件。或者，我们可以使用Docker启动服务器，如下所示：
- en: '[PRE35]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[![1](assets/1.png)](#co_remote_webdriver_CO6-1)'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_remote_webdriver_CO6-1)'
- en: We will use the URL `http://localhost:16686` to access the Jaeger UI.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用URL `http://localhost:16686` 来访问Jaeger UI。
- en: '[![2](assets/2.png)](#co_remote_webdriver_CO6-2)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_remote_webdriver_CO6-2)'
- en: We will use the URL `http://localhost:14250` to collect the data (exported by
    Selenium Grid).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用URL `http://localhost:14250` 来收集数据（由Selenium Grid导出）。
- en: 'Then, we start Selenium Grid as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们按如下方式启动Selenium Grid：
- en: '[PRE36]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[![1](assets/1.png)](#co_remote_webdriver_CO7-1)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_remote_webdriver_CO7-1)'
- en: We use a Jaeger endpoint to export the tracing data.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Jaeger端点来导出跟踪数据。
- en: '[![2](assets/2.png)](#co_remote_webdriver_CO7-2)'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_remote_webdriver_CO7-2)'
- en: We specify the service name `selenium-standalone`. We will look for this name
    in the Jaeger UI to visualize the gathered data (see [Figure 6-7](#jaeger)).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定服务名称为`selenium-standalone`。我们将在Jaeger UI中查找此名称，以可视化收集的数据（见[图6-7](#jaeger)）。
- en: '[![3](assets/3.png)](#co_remote_webdriver_CO7-3)'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_remote_webdriver_CO7-3)'
- en: We use [Coursier](https://get-coursier.io) to download and generate the classpath
    of two required dependencies (`opentelemetry-exporter-jaeger` and `grpc-netty`).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用[Coursier](https://get-coursier.io)来下载并生成两个所需依赖项（`opentelemetry-exporter-jaeger`
    和 `grpc-netty`）的类路径。
- en: '![hosw 0607](assets/hosw_0607.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![hosw 0607](assets/hosw_0607.png)'
- en: Figure 6-7\. Jaeger UI showing the data gathered from Selenium Grid
  id: totrans-259
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-7\. Jaeger UI显示从Selenium Grid收集的数据
- en: GraphQL queries
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GraphQL查询
- en: '[GraphQL](https://graphql.org) is an open source data query and manipulation
    language for APIs. GraphQL defines a syntax to ask for data, generally from an
    online service. Selenium Grid 4 provides a GraphQL endpoint (`http://localhost:4444/graphql`).
    A simple way to make GraphQL queries to this endpoint is using [curl](https://curl.se)
    from the shell. For example, and supposing that we have a Selenium Grid running
    in the localhost, we can send the following command to the GraphQL endpoint to
    get the maximum and the current number of sessions in the grid:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '[GraphQL](https://graphql.org) 是一个用于 API 的开源数据查询和操作语言。GraphQL 定义了一种从在线服务请求数据的语法。Selenium
    Grid 4 提供了一个 GraphQL 端点（`http://localhost:4444/graphql`）。通过 shell 使用 [curl](https://curl.se)
    对此端点进行 GraphQL 查询是一个简单的方法。例如，假设我们在本地主机上运行了一个 Selenium Grid，我们可以向 GraphQL 端点发送以下命令来获取网格中的最大会话数和当前会话数：'
- en: '[PRE37]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Configuration
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置
- en: 'You can find more details about Selenium Grid in its official [documentation](https://www.selenium.dev/documentation/grid).
    For advanced configuration, there are two ways to specify a custom setup for Selenium
    Grid:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在其官方[文档](https://www.selenium.dev/documentation/grid)中找到有关 Selenium Grid
    的更多详细信息。对于高级配置，有两种方式可以为 Selenium Grid 指定自定义设置：
- en: Using CLI options for the different aspects of Selenium Grid
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Selenium Grid 不同方面的 CLI 选项
- en: Some examples of these options are `--port` to change the default port through
    which the Selenium Server listens (4444 by default), or `--session-timeout`, which
    is the timeout in which nodes are terminated when there is no activity (three
    hundred seconds by default).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项的一些示例是 `--port` 用于更改 Selenium Server 监听的默认端口（默认为 4444），或者 `--session-timeout`，即在没有活动时终止节点的超时时间（默认为三百秒）。
- en: Using [TOML](https://toml.io) files
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [TOML](https://toml.io) 文件
- en: TOML (Tom’s Obvious Minimal Language) is a configuration format designed to
    be human-readable. Like the CLI options, these files allow configuring the Selenium
    Grid parameters but using TOML notation.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: TOML（Tom’s Obvious Minimal Language）是一种设计成易于阅读的配置格式。与 CLI 选项一样，这些文件允许使用 TOML
    表示法配置 Selenium Grid 参数。
- en: Cloud Providers
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云提供商
- en: 'As introduced in [Chapter 1](ch01.html#ch01), a *cloud provider* in the Selenium
    ecosystem is a company that provides managed services (usually commercial) for
    automated web and mobile testing. Common services offered by cloud providers include:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在[第1章](ch01.html#ch01)中介绍的，Selenium 生态系统中的*云提供商*是为自动化的 Web 和移动测试提供托管服务（通常是商业服务）的公司。云提供商通常提供的服务包括：
- en: Browsers *as a service*
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器作为服务
- en: To request on-demand web browsers hosted by the providers. These browsers are
    usually of different types, versions, and operating systems. This feature is typically
    used for cross-browser automated or live testing.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 可以请求由提供商托管的按需网页浏览器。这些浏览器通常是不同类型、版本和操作系统的。此功能通常用于跨浏览器的自动化或实时测试。
- en: Analysis capabilities
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 分析能力
- en: To monitor and debug automated tests. To that aim, cloud providers typically
    support session recordings or rich error-reporting features.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 为了监控和调试自动化测试。为此，云提供商通常支持会话录制或丰富的错误报告功能。
- en: Mobile testing
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 移动测试
- en: To request emulated (and real) mobile devices on different platforms, such as
    Android and iOS.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 可以请求在不同平台上仿真（和真实的）移动设备，例如 Android 和 iOS。
- en: Visual testing
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 视觉测试
- en: Automatically inspect the UI and ensure that end users have a correct visual
    experience.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 自动检查 UI 并确保最终用户拥有正确的视觉体验。
- en: Examples of current cloud providers for Selenium are [Sauce Labs](https://saucelabs.com),
    [BrowserStack](https://www.browserstack.com), [LambdaTest](https://www.lambdatest.com),
    [CrossBrowserTesting](https://crossbrowsertesting.com), [Moon Cloud](https://aerokube.com/moon-cloud),
    [TestingBot](https://testingbot.com), [Perfecto](https://www.perfecto.io), or
    [Testinium](https://testinium.com). All these companies offer specific services
    with different pricing plans. Their common aspect is that each cloud provider
    maintains a Selenium Server endpoint that we can use in `RemoteWebDriver` tests.
    [Example 6-9](#saucelabs_setup) illustrates how to use one of them (concretely,
    Sauce Labs) to create a `WebDriver` object. You can find equivalent tests for
    other cloud providers (BrowserStack, LambdaTest, CrossBrowserTesting, Perfecto,
    and Testinium) in the [examples repository](https://github.com/bonigarcia/selenium-webdriver-java).
    These tests allow using remote browsers managed by the cloud providers.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 目前 Selenium 的云提供商示例包括 [Sauce Labs](https://saucelabs.com), [BrowserStack](https://www.browserstack.com),
    [LambdaTest](https://www.lambdatest.com), [CrossBrowserTesting](https://crossbrowsertesting.com),
    [Moon Cloud](https://aerokube.com/moon-cloud), [TestingBot](https://testingbot.com),
    [Perfecto](https://www.perfecto.io) 或 [Testinium](https://testinium.com)。所有这些公司都提供具有不同定价计划的特定服务。它们的共同点是每个云提供商维护一个
    Selenium Server 终端节点，我们可以在 `RemoteWebDriver` 测试中使用。示例 6-9（见[saucelabs_setup](#saucelabs_setup)）说明了如何使用其中之一（具体来说，是
    Sauce Labs）创建 `WebDriver` 对象。您可以在 [示例存储库](https://github.com/bonigarcia/selenium-webdriver-java)
    中找到其他云提供商（BrowserStack、LambdaTest、CrossBrowserTesting、Perfecto 和 Testinium）的等效测试。这些测试允许使用由云提供商管理的远程浏览器。
- en: Example 6-9\. Test setup for using Sauce Labs
  id: totrans-280
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-9\. 使用 Sauce Labs 的测试设置
- en: '[PRE38]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[![1](assets/1.png)](#co_remote_webdriver_CO8-1)'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_remote_webdriver_CO8-1)'
- en: To use Sauce Labs, we need a valid account. In other words, we need credentials
    in the form of a username and access key. To avoid hardcoding these credentials
    in our test logic, I use Java system properties in this test. These properties
    can be informed in the execution command (e.g., `mvn test -DsauceLabsUsername​=myname
    -DsauceLabsAccessKey=mykey`). An alternative way to specify this data is using
    environment variables (e.g., `String username = Sys⁠tem.getenv​("SAU⁠CE​LABS_USERNAME");`).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Sauce Labs，我们需要一个有效的账户。换句话说，我们需要以用户名和访问密钥的形式拥有凭据。为了避免在测试逻辑中硬编码这些凭据，我在这个测试中使用了
    Java 系统属性。这些属性可以在执行命令时指定（例如，`mvn test -DsauceLabsUsername=myname -DsauceLabsAccessKey=mykey`）。指定这些数据的另一种方式是使用环境变量（例如，`String
    username = Sys⁠tem.getenv("SAU⁠CE⁠LABS_USERNAME");`）。
- en: '[![2](assets/2.png)](#co_remote_webdriver_CO8-2)'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_remote_webdriver_CO8-2)'
- en: We skip this test (using assumptions) when the username or the key is unavailable.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户名或密钥不可用时，我们跳过此测试（使用假设）。
- en: '[![3](assets/3.png)](#co_remote_webdriver_CO8-3)'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_remote_webdriver_CO8-3)'
- en: We need to include the username and the key as Selenium capabilities.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将用户名和密钥作为 Selenium 的能力包含在内。
- en: '[![4](assets/4.png)](#co_remote_webdriver_CO8-4)'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_remote_webdriver_CO8-4)'
- en: We can specify a custom label to identify this test in the Sauce Labs dashboard
    (see [Figure 6-8](#saucelabs)).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以指定一个自定义标签来在 Sauce Labs 仪表板中标识此测试（参见[图 6-8](#saucelabs)）。
- en: '[![5](assets/5.png)](#co_remote_webdriver_CO8-5)'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_remote_webdriver_CO8-5)'
- en: We use the latest version of a given browser (Chrome, as specified in the following
    line).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用给定浏览器的最新版本（如下一行所指定的 Chrome）。
- en: '[![6](assets/6.png)](#co_remote_webdriver_CO8-6)'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_remote_webdriver_CO8-6)'
- en: We use a custom label called `sauce:options` to select the required capabilities
    in the Sauce Labs cloud.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 Sauce Labs 云中使用一个名为`​​sauce:options`的自定义标签来选择所需的能力。
- en: '[![7](assets/7.png)](#co_remote_webdriver_CO8-7)'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_remote_webdriver_CO8-7)'
- en: We use the Sauce Labs public endpoint as a remote URL. Sauce Labs provides endpoints
    in different regions. In this example, I use the EU Central data center. Other
    possibilities are [US West](https://ondemand.us-west-1.saucelabs.com/wd/hub),
    [US East](https://ondemand.us-east-1.saucelabs.com/wd/hub), or [Asia-Pacific Southeast](https://ondemand.apac-southeast-1.saucelabs.com).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 Sauce Labs 的公共终端点用作远程 URL。Sauce Labs 在不同地区提供终端点。在此示例中，我使用的是 EU Central 数据中心。其他可能的包括
    [US West](https://ondemand.us-west-1.saucelabs.com/wd/hub)、[US East](https://ondemand.us-east-1.saucelabs.com/wd/hub)
    或 [Asia-Pacific Southeast](https://ondemand.apac-southeast-1.saucelabs.com)。
- en: '[![8](assets/8.png)](#co_remote_webdriver_CO8-8)'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_remote_webdriver_CO8-8)'
- en: We use both the URL and the capabilities to create an instance of `RemoteWebDriver`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 URL 和能力来创建 `RemoteWebDriver` 的实例。
- en: '![hosw 0608](assets/hosw_0608.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![hosw 0608](assets/hosw_0608.png)'
- en: Figure 6-8\. Sauce Labs dashboard showing an automated test result
  id: totrans-299
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-8\. Sauce Labs 仪表板显示的自动化测试结果
- en: Browsers in Docker Containers
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 容器中的浏览器
- en: '[Docker](https://www.docker.com) is an open source platform that allows creating,
    deploying, and running applications as lightweight, portable containers. The Docker
    platform is made up of two main components:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '[Docker](https://www.docker.com) 是一个开源平台，允许创建、部署和运行轻量级、便携式容器化应用程序。Docker 平台由两个主要组件组成：'
- en: '[Docker Engine](https://docs.docker.com/engine), an application that allows
    creating and running containers in a host. Docker Engine is a client-server application
    composed of three elements:'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Docker 引擎](https://docs.docker.com/engine)，一个允许在主机中创建和运行容器的应用程序。Docker 引擎是一个客户端-服务器应用程序，由三个元素组成：'
- en: A server implemented as a daemon process (`dockerd`)
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为守护进程实现的服务器（`dockerd`）
- en: A REST API used by application clients to instruct the daemon
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序客户端用于指导守护程序的 REST API
- en: A CLI tool (the `docker` command)
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 CLI 工具（`docker` 命令）
- en: '[Docker Hub](https://hub.docker.com), a cloud service for distributing containers.'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Docker Hub](https://hub.docker.com)，用于分发容器的云服务。'
- en: In Selenium, Docker can be a relevant technology to support the browser infrastructure
    required for automated tests based on Selenium WebDriver. The following subsections
    explain the alternatives for executing browsers in Docker containers.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Selenium 中，Docker 可以是支持基于 Selenium WebDriver 的自动化测试所需的浏览器基础设施的相关技术。以下子章节解释了在
    Docker 容器中执行浏览器的替代方案。
- en: Docker Images for Selenium Grid
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Selenium Grid 的 Docker 镜像
- en: An official subproject of the Selenium suite is [docker-selenium](https://github.com/SeleniumHQ/docker-selenium).
    This project maintains Docker images for the different Selenium Grid components
    (i.e., standalone, hub, nodes, router, distributor, session queue, etc.) and web
    browsers (Chrome, Firefox, and Edge). These Docker images are open source and
    released on [Docker Hub](https://hub.docker.com/u/selenium). A simple way to use
    these images is to start them using the shell (with the `docker` command) and
    use an instance of `RemoteWebDriver` to drive *dockerized* browsers. The following
    subsections explain how.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium 套件的官方子项目是[docker-selenium](https://github.com/SeleniumHQ/docker-selenium)。该项目维护了不同
    Selenium Grid 组件（如独立、中心、节点、路由器、分发器、会话队列等）和 Web 浏览器（Chrome、Firefox 和 Edge）的 Docker
    镜像。这些 Docker 镜像是开源的，并在[Docker Hub](https://hub.docker.com/u/selenium)上发布。使用这些镜像的简单方法是通过
    shell（使用 `docker` 命令）启动它们，并使用`RemoteWebDriver`的实例来驱动*dockerized*浏览器。以下子章节解释了如何执行这些操作。
- en: Note
  id: totrans-310
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The commands and tests presented in this section suppose Docker is available
    in your system. In other words, you need to have installed a Docker Engine in
    your machine to execute these examples properly.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 此节中展示的命令和测试假设您的系统中已安装了 Docker。换句话说，您需要在您的机器上安装 Docker 引擎，以便正确执行这些示例。
- en: Standalone
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 独立模式
- en: We can find Selenium images for standalone browsers (Chrome, Firefox, and Edge)
    in Docker Hub. The following command shows how to start Chrome in Docker using
    the shell.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 Docker Hub 中找到独立浏览器（Chrome、Firefox 和 Edge）的 Selenium 镜像。以下命令展示了如何在 Docker
    中使用 shell 启动 Chrome。
- en: '[PRE39]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This command starts the Docker image `selenium/standalone-chrome:latest`, i.e.,
    the latest version of Chrome available in Docker Hub. Alternatively, we can use
    a fixed Chrome version (e.g., `selenium/standalone-chrome:94.0`). The Docker container
    is started in detached mode (using the `-d` flag) using a shared memory of 2 GB
    (`--shm-size="2g"`). This figure is a value known to work well, although you can
    change it depending on your resources or specific needs. Finally, the internal
    container port `4444` is mapped to the same port of the host where the command
    is executed (`-p 4444:4444`). We can then use the following Java command to instantiate
    a `WebDriver` object that uses this dockerized Chrome:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令启动 Docker 镜像 `selenium/standalone-chrome:latest`，即 Docker Hub 中可用的最新版本的 Chrome。或者，我们可以使用固定的
    Chrome 版本（例如 `selenium/standalone-chrome:94.0`）。使用 `-d` 标志以分离模式启动 Docker 容器（使用共享内存
    2 GB `--shm-size="2g"`）。这个数值已知可用，但根据您的资源或特定需求，您可以更改它。最后，将容器的内部端口 `4444` 映射到执行命令的主机的同一端口（`-p
    4444:4444`）。然后，我们可以使用以下 Java 命令来实例化一个使用这个 dockerized Chrome 的 `WebDriver` 对象：
- en: '[PRE40]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Moreover, when using Selenium Grid, we can use Docker containers for registering
    nodes. The following command shows how to start a Selenium Grid in standalone
    mode using a node with Firefox in Docker:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当使用 Selenium Grid 时，我们可以使用 Docker 容器注册节点。以下命令展示了如何使用 Docker 中的 Firefox 启动独立模式的
    Selenium Grid：
- en: '[PRE41]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Hub-nodes
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 中心节点
- en: We can easily start Selenium Grid in the hub-nodes mode using the official Selenium
    Docker images. The following commands show how to do it in the shell.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地使用官方 Selenium Docker 镜像在中心节点模式下启动 Selenium Grid。以下命令展示了如何在 shell 中执行此操作。
- en: '[PRE42]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[![1](assets/1.png)](#co_remote_webdriver_CO9-1)'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_remote_webdriver_CO9-1)'
- en: First, we create a Docker network called `grid`. This network allows communication
    between hub and node(s) using their hostnames (e.g., `selenium-hub`).
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个名为 `grid` 的 Docker 网络。该网络允许 hub 和节点之间使用它们的主机名进行通信（例如，`selenium-hub`）。
- en: '[![2](assets/2.png)](#co_remote_webdriver_CO9-2)'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_remote_webdriver_CO9-2)'
- en: We start the Selenium Hub. We need to map ports 4444 (for the Selenium Server
    URL) and 4442-4443 (for registering nodes).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们启动 Selenium Hub。我们需要映射端口 4444（用于 Selenium 服务器 URL）和 4442-4443（用于注册节点）。
- en: '[![3](assets/3.png)](#co_remote_webdriver_CO9-3)'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_remote_webdriver_CO9-3)'
- en: We register nodes. In this command, we use Chrome (`selenium/node-chrome`).
    Other browsers can be registered in the hub using other Docker images (e.g., `selenium/node-firefox`
    or `selenium/node-edge`).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注册节点。在此命令中，我们使用 Chrome (`selenium/node-chrome`)。其他浏览器可以使用其他 Docker 镜像（例如，`selenium/node-firefox`
    或 `selenium/node-edge`）在 hub 中注册。
- en: '[![4](assets/4.png)](#co_remote_webdriver_CO9-4)'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_remote_webdriver_CO9-4)'
- en: If not required anymore, we can remove the `grid` network at the end.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不再需要，我们可以在最后删除 `grid` 网络。
- en: Further features
  id: totrans-330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多功能
- en: 'The project `docker-selenium` provides a wide variety of features. I recommend
    you take a look at its [README](https://github.com/SeleniumHQ/docker-selenium)
    for more details. Here is a summary of these features:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 项目 `docker-selenium` 提供了各种功能。我建议您查看其 [README](https://github.com/SeleniumHQ/docker-selenium)
    以获取更多详细信息。以下是这些功能的摘要：
- en: Docker Compose scripts
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose 脚本
- en: These scripts allow starting Selenium Grid hub-nodes and the fully distributed
    mode effortlessly.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这些脚本可以轻松启动 Selenium Grid hub-nodes 和完全分布模式。
- en: Video recording
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 视频录制
- en: We can record the desktop session of the browsers in the nodes using another
    Docker container.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用另一个 Docker 容器记录节点中浏览器的桌面会话。
- en: Dynamic grid
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 动态网格
- en: This allows us to start Docker containers on demand.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够按需启动 Docker 容器。
- en: Deploying to Kubernetes
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 部署到 Kubernetes
- en: '[Kubernetes](https://kubernetes.io) is an open source container-orchestration
    system that automates the deployment and management of containerized applications.
    We can use Kubernetes to deploy the Selenium Docker containers.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '[Kubernetes](https://kubernetes.io) 是一个开源的容器编排系统，自动化容器化应用程序的部署和管理。我们可以使用 Kubernetes
    来部署 Selenium Docker 容器。'
- en: Advanced container configuration
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 高级容器配置
- en: This can be used, for instance, to specify Selenium or Java custom configuration.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以用来指定 Selenium 或 Java 自定义配置，例如。
- en: Access to the remote session
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 访问远程会话
- en: This can be achieved using Virtual Network Computing (VNC) (a graphical desktop
    sharing system) and [noVNC](https://novnc.com) (an open source web-based VNC client).
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过使用虚拟网络计算（VNC）（一种图形桌面共享系统）和 [noVNC](https://novnc.com)（一个开源的基于 web 的 VNC
    客户端）来实现。
- en: Selenoid
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Selenoid
- en: '[Selenoid](https://aerokube.com/selenoid) is an open source Golang implementation
    of a Selenium Hub. Selenoid can be seen as a lightweight Selenium Server that
    provides a browser infrastructure based on Docker. The Selenoid team also maintains
    the Docker images used by Selenoid. These images include multiple web browsers
    and Android devices, such as Chrome, Firefox, Edge, Opera, Safari (WebKit engine),
    or Chrome Mobile.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '[Selenoid](https://aerokube.com/selenoid) 是 Selenium Hub 的一个开源 Golang 实现。Selenoid
    可以被视为基于 Docker 提供浏览器基础设施的轻量级 Selenium 服务器。Selenoid 团队还维护着 Selenoid 使用的 Docker
    镜像。这些镜像包括多个 web 浏览器和 Android 设备，例如 Chrome、Firefox、Edge、Opera、Safari（WebKit 引擎）或
    Chrome Mobile。'
- en: 'There are different ways to use Selenoid and its Docker images. A straightforward
    way is to use the configuration manager (a binary called `cm`) provided by the
    project. The following snippet shows how to start Selenoid and its UI (a web-based
    dashboard to monitor Selenoid):'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的方式来使用 Selenoid 及其 Docker 镜像。一个简单的方法是使用项目提供的配置管理器（一个名为 `cm` 的二进制文件）。以下代码段显示了如何启动
    Selenoid 及其 UI（一个基于 web 的仪表板，用于监控 Selenoid）：
- en: '[PRE43]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[![1](assets/1.png)](#co_remote_webdriver_CO10-1)'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_remote_webdriver_CO10-1)'
- en: We start Selenoid. The configuration manager downloads the Docker image for
    Selenoid and the two latest versions of several browsers (Chrome, Firefox, and
    Opera). Once it is started, Selenoid listens to Selenium WebDriver requests in
    the URL `http://localhost:4444/wd/hub`.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们启动 Selenoid。配置管理器下载 Selenoid 的 Docker 镜像和几个浏览器的最新两个版本（Chrome、Firefox 和 Opera）。一旦启动，Selenoid
    会监听 Selenium WebDriver 请求的 URL `http://localhost:4444/wd/hub`。
- en: '[![2](assets/2.png)](#co_remote_webdriver_CO10-2)'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_remote_webdriver_CO10-2)'
- en: Optionally, we can start the Selenoid UI. This UI is a web application accessible
    in the URL `http://localhost:8080/`. [Figure 6-9](#selenoid-ui) shows a screenshot
    of this UI during the execution of a Selenium WebDriver test. [Example 6-10](#selenoid_test_setup)
    shows the setup of a test that uses a Chrome browser served by Selenoid.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，我们可以启动 Selenoid UI。此 UI 是一个 Web 应用程序，可通过 URL `http://localhost:8080/` 访问。[图 6-9](#selenoid-ui)
    显示了执行 Selenium WebDriver 测试期间此 UI 的屏幕截图。[示例 6-10](#selenoid_test_setup) 显示了使用
    Selenoid 服务的 Chrome 浏览器的测试设置。
- en: '![hosw 0609](assets/hosw_0609.png)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![hosw 0609](assets/hosw_0609.png)'
- en: Figure 6-9\. Selenoid UI during a test execution using VNC
  id: totrans-353
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-9\. 使用 VNC 运行测试时的 Selenoid UI
- en: Example 6-10\. Instantiation of a RemoteWebDriver object using the constructor
  id: totrans-354
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-10\. 使用构造函数实例化 RemoteWebDriver 对象
- en: '[PRE44]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[![1](assets/1.png)](#co_remote_webdriver_CO11-1)'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_remote_webdriver_CO11-1)'
- en: The capability `enableVNC` is Selenoid-specific and allows us to start the dockerized
    browser with VNC support (this way, we can visualize the browser session in the
    Selenoid UI, as illustrated in [Figure 6-9](#selenoid-ui)).
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '`enableVNC` 功能是 Selenoid 特有的，允许我们启动带有 VNC 支持的 dockerized 浏览器（这样，我们可以在 Selenoid
    UI 中可视化浏览器会话，如 [图 6-9](#selenoid-ui) 所示）。'
- en: '[![2](assets/2.png)](#co_remote_webdriver_CO11-2)'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_remote_webdriver_CO11-2)'
- en: Since this capability is vendor-specific, the W3C WebDriver-compatible way to
    set this capability is using a custom namespace (`selenoid:options` in this case).
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此功能是特定供应商的，设置此功能的 W3C WebDriver 兼容方式是使用自定义命名空间（在本例中为 `selenoid:options`）。
- en: Further features
  id: totrans-360
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多功能
- en: Selenoid provides different features and configuration capabilities. You can
    check its [documentation](https://aerokube.com/selenoid/latest) for more details.
    These features include video recording, custom configuration, log management,
    or access to browser developer tools, to name a few.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: Selenoid 提供不同的功能和配置能力。您可以查看其 [文档](https://aerokube.com/selenoid/latest) 了解更多详情。这些功能包括视频录制、自定义配置、日志管理或访问浏览器开发者工具等。
- en: WebDriverManager
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WebDriverManager
- en: As of version 5, WebDriverManager allows the effortless use of web browsers
    in Docker containers. To that aim, each manager (e.g., `chromedriver()`, `firefoxdriver()`,
    etc.) provides the method `browserInDocker()`. WebDriverManager internally pulls
    the Docker images and runs the container, creating a `RemoteWebDriver` instance
    when invoking the method `create()`. WebDriverManager uses the Docker images maintained
    by the Selenoid team. This way, you can use Chrome (desktop and mobile), Firefox,
    Edge, Opera, and Safari as Docker containers out of the box through WebDriverManager.
    [Example 6-11](#wdm_chrome) illustrates a basic test using this feature.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 截至版本5，WebDriverManager 允许在 Docker 容器中轻松使用网页浏览器。为此，每个管理器（例如，`chromedriver()`、`firefoxdriver()`
    等）都提供了 `browserInDocker()` 方法。当调用 `create()` 方法时，WebDriverManager 内部会拉取 Docker
    镜像并运行容器，在需要时创建一个 `RemoteWebDriver` 实例。WebDriverManager 使用由 Selenoid 团队维护的 Docker
    镜像。通过 WebDriverManager，你可以直接使用 Chrome（桌面版和移动版）、Firefox、Edge、Opera 和 Safari 作为
    Docker 容器。[示例 6-11](#wdm_chrome)展示了使用此功能进行基本测试的情况。
- en: Example 6-11\. Complete test using WebDriverManager and Chrome in Docker
  id: totrans-364
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-11\. 使用 WebDriverManager 和 Docker 中的 Chrome 进行完整测试
- en: '[PRE45]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[![1](assets/1.png)](#co_remote_webdriver_CO12-1)'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_remote_webdriver_CO12-1)'
- en: We get an instance of the manager for Chrome (`chromedriver()`). Then, using
    the WebDriverManager fluent API, we specify that the future `WebDriver` objects
    created with this instance (called `wmd`) will use Docker to execute the corresponding
    browser (Chrome, in this case).
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获取 Chrome 的管理器实例（`chromedriver()`）。然后，使用 WebDriverManager 流畅的 API，我们指定使用该实例创建的未来
    `WebDriver` 对象（称为 `wmd`）将使用 Docker 执行相应的浏览器（在本例中为 Chrome）。
- en: '[![2](assets/2.png)](#co_remote_webdriver_CO12-2)'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_remote_webdriver_CO12-2)'
- en: We assume a Docker engine is available in the machine running this test. For
    that, we create an AssertJ assumption by invoking the static method `isDocker​A⁠vailable`
    on WebDriverManager. This way, when Docker is not available, the test is skipped.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设运行此测试的机器上有 Docker 引擎。为此，我们通过调用 WebDriverManager 的静态方法 `isDockerAvailable`
    创建一个 AssertJ 断言。这样，当 Docker 不可用时，测试将被跳过。
- en: '[![3](assets/3.png)](#co_remote_webdriver_CO12-3)'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_remote_webdriver_CO12-3)'
- en: In the test setup, we create the `WebDriver` instance. Internally, WebDriverManager
    will connect to Docker Hub to discover the latest version of Chrome available
    as a Docker image. This image is pulled to the local machine, the Docker container
    is executed, and the corresponding `RemoteWebDriver` instance is returned to the
    test logic.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试设置中，我们创建 `WebDriver` 实例。在内部，WebDriverManager 将连接到 Docker Hub，以发现可用作 Docker
    镜像的最新版本的 Chrome。然后将该镜像拉取到本地机器，执行 Docker 容器，并将相应的 `RemoteWebDriver` 实例返回给测试逻辑。
- en: '[![4](assets/4.png)](#co_remote_webdriver_CO12-4)'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_remote_webdriver_CO12-4)'
- en: WebDriverManager allows quitting the previously created `WebDriver` instances
    through the method `quit()`. This method has the same effect of directly quitting
    the instance (`driver.quit()` in this case), and the used Docker containers are
    gracefully terminated.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: WebDriverManager 允许通过 `quit()` 方法退出先前创建的 `WebDriver` 实例。这个方法的效果与直接退出实例相同（在这种情况下是
    `driver.quit()`），并且使用的 Docker 容器会优雅地终止。
- en: WebDriverManager provides a fluent API to configure different aspects of the
    dockerized web browsers. The following snippet shows several possibilities. As
    usual, you can find the complete tests using these features in the [examples repository
    for this book](https://github.com/bonigarcia/selenium-webdriver-java).
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: WebDriverManager 提供了一个流畅的 API 来配置 dockerized Web 浏览器的不同方面。以下代码片段展示了几个可能性。通常情况下，您可以在[本书的示例仓库](https://github.com/bonigarcia/selenium-webdriver-java)中找到使用这些功能的完整测试。
- en: '[PRE46]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[![1](assets/1.png)](#co_remote_webdriver_CO13-1)'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_remote_webdriver_CO13-1)'
- en: We select a given manager to use the corresponding dockerized browser (Firefox
    in this case). In addition to Chrome and Firefox, the other alternatives are Edge,
    Opera, Safari, and Chrome Mobile.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择一个指定的管理器来使用相应的 dockerized 浏览器（在本例中是 Firefox）。除了 Chrome 和 Firefox 外，其他可选项还包括
    Edge、Opera、Safari 和 Chrome Mobile。
- en: '[![2](assets/2.png)](#co_remote_webdriver_CO13-2)'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_remote_webdriver_CO13-2)'
- en: 'By default, WebDriverManager uses the latest version available in Docker Hub
    for the dockerized browser. Nevertheless, we can force the use of a given version
    (e.g., `94.0`). Moreover, different wildcards are valid for specifying the following
    versions, namely:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，WebDriverManager 在 Docker Hub 上使用最新版本的 dockerized 浏览器。尽管如此，我们可以强制使用指定的版本（例如，`94.0`）。此外，还可以使用不同的通配符来指定以下版本：
- en: '`latest`'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '`latest`'
- en: To use the latest version (default option).
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 使用最新版本（默认选项）。
- en: '`latest-N`'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '`latest-N`'
- en: To use a previous version to the stable release. For example, if we specify
    `latest-1` (i.e., latest version minus one), the former version to the stable
    release is used.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用稳定发布的先前版本。例如，如果我们指定 `latest-1`（即最新版本减一），则使用稳定发布之前的版本。
- en: '`beta`'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '`beta`'
- en: To use the beta version. This version is only available for Chrome and Firefox,
    using a fork of the Aerokube Docker images for these browsers maintained by [Twilio](https://hub.docker.com/r/twilio/selenoid).
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 beta 版本。此版本仅适用于 Chrome 和 Firefox，使用由 [Twilio](https://hub.docker.com/r/twilio/selenoid)
    维护的 Aerokube Docker 镜像分支。
- en: '`dev`'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '`dev`'
- en: To use the development version (again, for Chrome and Firefox).
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 使用开发版本（同样适用于 Chrome 和 Firefox）。
- en: '[![3](assets/3.png)](#co_remote_webdriver_CO13-3)'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_remote_webdriver_CO13-3)'
- en: Connect to the remote desktop session using VNC or noVNC. By default, WebDriverManager
    prints the noVNC URL in the log traces. In addition, this URL is accessible by
    invoking the method `wdm.getDockerNoVncUrl()`. [Figure 6-10](#wdm-novnc) shows
    a web browser that allows watching and interacting with a remote session with
    noVNC.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 VNC 或 noVNC 连接到远程桌面会话。默认情况下，WebDriverManager 在日志跟踪中打印 noVNC URL。此外，可以通过调用
    `wdm.getDockerNoVncUrl()` 方法访问此 URL。[Figure 6-10](#wdm-novnc) 展示了一个允许观看和与 noVNC
    远程会话进行交互的 Web 浏览器。
- en: '[![4](assets/4.png)](#co_remote_webdriver_CO13-4)'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_remote_webdriver_CO13-4)'
- en: To enable the session recording. At the end of the test, you can find the recording
    (in MP4 format) in the project root folder.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试结束时启用会话录制。您可以在项目根目录中找到录制文件（MP4 格式）。
- en: '![hosw 0610](assets/hosw_0610.png)'
  id: totrans-392
  prefs: []
  type: TYPE_IMG
  zh: '![hosw 0610](assets/hosw_0610.png)'
- en: Figure 6-10\. Remote desktop using noVNC of a dockerized browser started with
    WebDriverManager
  id: totrans-393
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-10\. 使用 WebDriverManager 启动的 dockerized 浏览器的 noVNC 远程桌面
- en: Further features
  id: totrans-394
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多功能
- en: As explained in its [documentation](https://bonigarcia.dev/webdrivermanager),
    you can configure WebDriverManager in multiple ways. For instance, you can specify
    fine-grained aspects of dockerized browsers, such as the time zone, network, shared
    memory, volumes, environment variables, screen resolution, or recording output,
    among others. In addition, WebDriverManager can be used as a Selenium Server.
    This server uses the container images pulled from Docker Hub to support the browser
    infrastructure.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其[文档](https://bonigarcia.dev/webdrivermanager)所述，您可以通过多种方式配置WebDriverManager。例如，您可以指定docker化浏览器的细粒度方面，如时区、网络、共享内存、卷、环境变量、屏幕分辨率或录制输出等。此外，WebDriverManager可以用作Selenium服务器。该服务器使用从Docker
    Hub拉取的容器映像来支持浏览器基础设施。
- en: Selenium-Jupiter
  id: totrans-396
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Selenium-Jupiter
- en: Selenium-Jupiter internally uses WebDriverManager to manage and handle web browsers
    in Docker containers. For dockerized browsers, Selenium-Jupiter provides the annotation
    `@DockerBrowser`. You can use this annotation with `WebDriver` or `RemoteWebDriver`
    parameters in test methods. [Example 6-12](#seljup_chrome) demonstrates this feature.
    In this example, we use Chrome in Docker.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium-Jupiter在Docker容器中使用WebDriverManager来管理和处理Web浏览器。对于docker化的浏览器，Selenium-Jupiter提供了注解`@DockerBrowser`。您可以在测试方法中使用这个注解，配合`WebDriver`或`RemoteWebDriver`参数使用。[示例 6-12](#seljup_chrome)演示了这个特性。在这个示例中，我们在Docker中使用Chrome。
- en: Example 6-12\. Complete test using Selenium-Jupiter and Chrome in Docker
  id: totrans-398
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-12\. 使用Selenium-Jupiter和Docker中的Chrome完成测试
- en: '[PRE47]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[![1](assets/1.png)](#co_remote_webdriver_CO14-1)'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_remote_webdriver_CO14-1)'
- en: We decorate the test class with the Selenium-Jupiter annotation `@EnabledIf​Dock⁠erAvailable`.
    This annotation disables the test when Docker is not installed in the machine
    running the test.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用Selenium-Jupiter的注解`@EnabledIf​Dock⁠erAvailable`装饰测试类。此注解在运行测试的机器上未安装Docker时会禁用测试。
- en: The annotation `@DockerBrowser` allows setting different aspects and features.
    The following snippet illustrates some of them.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 注解`@DockerBrowser`允许设置不同的方面和功能。下面的代码片段展示了其中一些。
- en: '[PRE48]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[![1](assets/1.png)](#co_remote_webdriver_CO15-1)'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_remote_webdriver_CO15-1)'
- en: We can change the browser using the `type` attribute. The accepted values are
    `CHROME`, `FIREFOX`, `OPERA`, `EDGE`, `SAFARI`, and `CHROME_MOBILE`.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`type`属性来更改浏览器。接受的值包括`CHROME`、`FIREFOX`、`OPERA`、`EDGE`、`SAFARI`和`CHROME_MOBILE`。
- en: '[![2](assets/2.png)](#co_remote_webdriver_CO15-2)'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_remote_webdriver_CO15-2)'
- en: We can change the browser version using the attribute `version`. Like WebDriverManager,
    Selenium-Jupiter allows specifying a fixed version value (e.g., `94.0`) and using
    the wildcards `latest` and `latest-N`, as well as `beta` and `dev` for Chrome
    and Firefox.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`version`属性更改浏览器版本。与WebDriverManager类似，Selenium-Jupiter允许指定固定版本值（例如`94.0`），并使用通配符`latest`和`latest-N`，以及`beta`和`dev`用于Chrome和Firefox。
- en: '[![3](assets/3.png)](#co_remote_webdriver_CO15-3)'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_remote_webdriver_CO15-3)'
- en: We enable access to the remote desktop session through VNC and noVNC using the
    attribute `vnc`.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过`vnc`属性启用对远程桌面会话的访问，使用VNC和noVNC。
- en: '[![4](assets/4.png)](#co_remote_webdriver_CO15-4)'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_remote_webdriver_CO15-4)'
- en: We enable the session recording with the `recording` attribute.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`recording`属性启用会话录制。
- en: You can find more details, examples, and configuration capabilities of Selenium-Jupiter
    in its [documentation](https://bonigarcia.dev/selenium-jupiter).
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在其[文档](https://bonigarcia.dev/selenium-jupiter)中找到有关Selenium-Jupiter更多详细信息、示例和配置能力。
- en: Summary and Outlook
  id: totrans-413
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结与展望
- en: 'Selenium WebDriver allows controlling remote web browsers. This feature is
    feasible because the underlying communication protocol (W3C WebDriver) is based
    on JSON messages over HTTP. This way, the components of the Selenium WebDriver
    architecture (Selenium Server, nodes, or client script) can be distributed (i.e.,
    executed in different hosts). To use this feature in Java, we need to create an
    instance of `RemoteWebDriver`, typically passing two arguments: the Selenium Server
    URL and the required capabilities. We can start a Selenium Server infrastructure
    using Selenium Grid (in standalone, hub-nodes, or fully distributed mode). Alternatively,
    we can use the managed services provided by a cloud provider (such as Sauce Labs,
    BrowserStack, LambdaTest, or CrossBrowserTesting, among others). Finally, we can
    use Docker to support a containerized infrastructure of web browsers.'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium WebDriver 允许控制远程 Web 浏览器。这一特性是可行的，因为底层通信协议（W3C WebDriver）基于 HTTP 上的
    JSON 消息。这样，Selenium WebDriver 架构的组件（如 Selenium Server、节点或客户端脚本）可以分布式部署（即在不同的主机上执行）。要在
    Java 中使用这一特性，我们需要创建一个 `RemoteWebDriver` 实例，通常传递两个参数：Selenium Server 的 URL 和所需的能力。我们可以使用
    Selenium Grid 启动 Selenium Server 基础设施（独立模式、集线器-节点模式或完全分布式模式）。另外，我们还可以使用云服务提供商提供的托管服务（例如
    Sauce Labs、BrowserStack、LambdaTest 或 CrossBrowserTesting 等）。最后，我们可以使用 Docker 支持容器化的
    Web 浏览器基础设施。
- en: This chapter concludes the second part of the book, in which you have discovered
    the main features of the Selenium WebDriver API. The next part of the book covers
    different aspects of developing end-to-end tests using the Selenium WebDriver
    API, starting with the Page Object Model (POM), a widely used design pattern for
    enhancing test maintenance and reducing code duplication in Selenium WebDriver.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束了本书的第二部分，其中您发现了 Selenium WebDriver API 的主要特性。本书的下一部分涵盖了使用 Selenium WebDriver
    API 开发端到端测试的不同方面，从页面对象模型（POM）开始，这是一种广泛使用的设计模式，用于增强测试维护和减少 Selenium WebDriver 中的代码重复。
