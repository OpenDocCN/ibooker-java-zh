- en: Chapter 4\. The Java Language
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。Java语言
- en: 'As humans, we learn the subtleties of spoken language through trial and error.
    We learn where to put the subject in relation to the verb and how to handle things
    like tenses and plurals. We certainly learn advanced language rules in school,
    but even the youngest students can ask their teachers intelligible questions.
    Computer languages have similar features: there are “parts of speech” that work
    as composable building blocks. There are ways of declaring facts and asking questions.
    In this chapter, we look at those fundamental programming units in Java. Trial
    and error remains a great teacher, so we’ll also look at how to play with these
    new units and practice your skills.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 作为人类，我们通过反复试验来学习口语的微妙之处。我们学会了在动词旁边放置主语以及如何处理时态和复数等问题。当然，我们在学校学习了高级语言规则，但即使是最年幼的学生也可以向老师提出可理解的问题。计算机语言也具有类似的特点：有作为可组合构建块的“词类”。有声明事实和提出问题的方式。在这一章中，我们将研究Java中的这些基本编程单元。试错仍然是一位伟大的老师，因此我们还将看看如何玩转这些新单元并练习您的技能。
- en: Since Java’s syntax is derived from C, we make some comparisons to features
    of that language, but no prior knowledge of C is necessary. [Chapter 5](ch05.html#learnjava6-CHP-5)
    builds on this chapter by talking about Java’s object-oriented side and completing
    the discussion of the core language. [Chapter 7](ch07.html#learnjava6-CHP-7) discusses
    generics and records, features that enhance the way types work in the Java language,
    allowing you to write certain kinds of classes more flexibly and safely.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Java的语法源自C语言，我们会对该语言的某些特性进行比较，但不需要事先了解C语言。[第五章](ch05.html#learnjava6-CHP-5)在此基础上讨论了Java的面向对象的一面，并完成了对核心语言的讨论。[第七章](ch07.html#learnjava6-CHP-7)讨论了泛型和记录，这些特性增强了Java语言中类型工作的方式，使您能够更灵活、更安全地编写某些类型的类。
- en: After that, we dive into the Java APIs and see what we can do with the language.
    The rest of this book is filled with brief examples that do useful things in a
    variety of areas. If you are left with any questions after these introductory
    chapters, we hope they’ll be answered as you look at the code. There is always
    more to learn, of course! We’ll try to point out other resources along the way
    that might benefit folks looking to continue their Java journey beyond the topics
    we cover.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将深入Java API，看看语言能做什么。本书的其余部分充满了在各种领域做有用事情的简短示例。如果在这些介绍性章节之后您有任何问题，我们希望您在查看代码时能得到解答。当然，总是有更多东西要学习！在此过程中，我们将尝试指出其他资源，这些资源可能有助于希望在我们覆盖的主题之外继续他们的Java学习旅程的人们。
- en: For readers just beginning their programming journey, the web will likely be
    a constant companion. Many, many sites, Wikipedia articles, blog posts, and, well,
    the entirety of [Stack Overflow](https://oreil.ly/XHO1v) can help you dig into
    particular topics or answer small questions that might arise. For example, while
    this book covers the Java language and how to start writing useful programs with
    Java and its tools, we don’t cover lower, core programming topics such as [algorithms](https://oreil.ly/hXXGL)
    in much detail. These programming fundamentals will naturally appear in our discussions
    and code examples, but you might enjoy a few hyperlink tangents to help cement
    certain ideas or fill in the gaps we must necessarily leave.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 对于刚开始编程旅程的读者来说，网络可能会是一个不断的伴侣。许多许多网站、维基百科文章、博客文章以及[Stack Overflow](https://oreil.ly/XHO1v)的整体都可以帮助您深入研究特定主题或回答可能出现的小问题。例如，虽然本书涵盖了Java语言及如何使用Java及其工具编写有用程序，但我们并未详细讨论像[算法](https://oreil.ly/hXXGL)这样的低级核心编程主题。这些编程基础将自然出现在我们的讨论和代码示例中，但您可能会喜欢一些超链接的支线，以帮助巩固某些想法或填补我们必然遗漏的空白。
- en: As we have mentioned before, many terms in this chapter will be unfamiliar.
    Don’t worry if you are occasionally a little confused. The sheer breadth of Java
    means we have to leave out explanations or background details from time to time.
    As you progress, we hope you’ll have the chance to revisit some of these early
    chapters. New information can work a bit like a jigsaw puzzle. It’s easier to
    fit a new piece if you already have some other, related pieces connected. When
    you’ve spent some time writing code and this book becomes more of a reference
    for you and less of a guide, you’ll find the topics in these first chapters make
    more sense.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，本章中许多术语可能会让您感到陌生。如果偶尔感到有些困惑，不必担心。由于Java的广泛应用，我们不得不偶尔省略解释或背景细节。随着您的学习进展，我们希望您有机会重新阅读一些早期章节。新的信息有点像拼图游戏。如果您已经连接了一些相关的知识点，那么添加新的知识点就会更容易。当您花时间编写代码，这本书逐渐成为您的参考书而不是指南时，这些早期章节的主题会更加容易理解。
- en: Text Encoding
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本编码
- en: 'Java is a language for the internet. Since individual users speak and write
    in many different human languages, Java must be able to handle a large number
    of languages as well. It handles internationalization through the Unicode character
    set, a worldwide standard that supports the scripts of most languages.^([1](ch04.html#id869))
    The latest version of Java bases its character and string data on the Unicode
    14.0 standard, which uses at least two bytes to represent each symbol internally.
    As you may recall from [“The Past: Java 1.0–Java 20”](ch01.html#learnjava6-CHP-1-SECT-7.1),
    Oracle endeavors to keep up with new releases of the Unicode standard. Your version
    of Java may include a newer version of Unicode.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Java是一种面向互联网的语言。由于各个用户使用多种不同的语言进行交流和书写，Java必须能够处理大量的语言。它通过Unicode字符集进行国际化处理，这是一个支持大多数语言文字的全球标准[^1]。Java的最新版本基于Unicode
    14.0标准，内部使用至少两个字节来表示每个符号。您可能还记得来自[《过去：Java 1.0–Java 20》](ch01.html#learnjava6-CHP-1-SECT-7.1)的内容，Oracle致力于跟踪最新的Unicode标准发布情况。您使用的Java版本可能包含更新的Unicode版本。
- en: Java source code can be written using Unicode and stored in any number of character
    encodings. This makes Java a fairly friendly language for including non-English
    content. Programmers can use Unicode’s rich set of characters not only for displaying
    information to the user but also in their own class, method, and variable names.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Java源代码可以使用Unicode编写，并以任意数量的字符编码进行存储。这使得Java相对友好，可以包含非英语内容。程序员可以在向用户显示信息的同时，还可以在其自己的类、方法和变量名称中使用Unicode丰富的字符集。
- en: The Java `char` type and `String` class natively support Unicode values. Internally,
    the text is stored using either character or byte arrays; however, the Java language
    and APIs make this transparent to you, and you generally will not have to think
    about it. Unicode is also very ASCII friendly (ASCII is the most common character
    encoding for English). The first 256 characters are defined to be identical to
    the first 256 characters in the ISO 8859-1 (Latin-1) character set, so Unicode
    is effectively backward compatible with the most common English character sets.
    Furthermore, one of the most common file encodings for Unicode, called UTF-8,
    preserves ASCII values in their single byte form. This encoding is used by default
    in compiled Java class files, so storage remains compact for English text.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Java的`char`类型和`String`类本地支持Unicode值。文本在内部使用字符数组或字节数组进行存储；但Java语言和API对您来说是透明的，通常您不需要考虑这些细节。Unicode对ASCII也非常友好（ASCII是英语中最常见的字符编码）。前256个字符被定义为与ISO
    8859-1（Latin-1）字符集中的前256个字符相同，因此Unicode实际上与最常见的英语字符集向后兼容。此外，Unicode的一种最常见的文件编码称为UTF-8，保留了ASCII值的单字节形式。编译后的Java类文件默认使用此编码，因此对于英语文本，存储保持紧凑。
- en: 'Most platforms can’t display all currently defined Unicode characters. As a
    workaround, Java programs can be written with special Unicode escape sequences.
    A Unicode character can be represented with this escape sequence:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数平台无法显示所有当前定义的Unicode字符。作为一种解决方法，Java程序可以使用特殊的Unicode转义序列进行编写。Unicode字符可以用以下转义序列表示：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*`xxxx`* is a sequence of one to four hexadecimal digits. The escape sequence
    indicates an ASCII-encoded Unicode character. This is also the form Java uses
    to output (print) Unicode characters in an environment that doesn’t otherwise
    support them. Java comes with classes to read and write Unicode character streams
    in specific encodings, including UTF-8.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*`xxxx`* 是一个包含一到四个十六进制数字的序列。转义序列表示一个ASCII编码的Unicode字符。这也是 Java 用来在不支持它们的环境中输出（打印）Unicode
    字符的形式。Java 附带了用于在特定编码中读写Unicode字符流的类，包括UTF-8。'
- en: As with many long-lived standards in the tech world, Unicode was originally
    designed with so much extra space that no conceivable character encoding could
    ever possibly require more than 64K characters. Sigh. Naturally we have sailed
    past that limit and some UTF-32 encodings are in popular circulation. Most notably,
    emoji characters scattered throughout messaging apps are encoded beyond the standard
    range of Unicode characters. (For example, the canonical smiley emoji has the
    Unicode value 1F600.) Java supports multibyte UTF-16 escape sequences for such
    characters. Not every platform that supports Java will support emoji output, but
    you can fire up *jshell* to find out if your environment can show emoji characters
    (see [Figure 4-1](#learnjava6-CHP-4-FIG-1)).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 与技术领域中许多长寿的标准一样，Unicode 最初设计时有很多额外的空间，以至于没有任何可想象的字符编码需要超过 64K 个字符。唉。自然，我们已经超越了这个限制，一些
    UTF-32 编码正在广泛流通。最值得注意的是，分散在消息应用程序中的表情符号字符超出了 Unicode 字符的标准范围。（例如，标准笑脸表情符号的 Unicode
    值为 1F600。）Java 支持这些字符的多字节UTF-16转义序列。并不是每个支持 Java 的平台都支持表情符号输出，但您可以启动 *jshell*
    来查看您的环境是否可以显示表情符号（参见 [图 4-1](#learnjava6-CHP-4-FIG-1)）。
- en: '![ljv6 0401](assets/ljv6_0401.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0401](assets/ljv6_0401.png)'
- en: Figure 4-1\. Printing emojis in the macOS Terminal app
  id: totrans-15
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-1\. 在 macOS Terminal 应用程序中打印表情符号
- en: 'Be careful about using such characters, though. We had to use a screenshot
    to make sure you could see the little cuties in *jshell* running on a Mac. You
    can use *jshell* to test your own system. You can put up a minimal graphical application
    similar to our `HelloJava` class from [“HelloJava”](ch02.html#learnjava6-CHP-2-SECT-2).
    Create a `JFrame`, add a `JLabel`, and make the frame visible:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，使用这些字符要小心。我们必须使用屏幕截图确保您可以在 Mac 上看到 *jshell* 中运行的这些可爱的小东西。您可以使用 *jshell*
    来测试您自己的系统。您可以创建一个与我们的 `HelloJava` 类似的最小图形应用程序，例如 [“HelloJava”](ch02.html#learnjava6-CHP-2-SECT-2)。创建一个
    `JFrame`，添加一个 `JLabel`，并使框架可见：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Hopefully you see the smiley, but it will depend on your system. [Figure 4-2](#learnjava6-CHP-4-FIG-2)
    shows the results we got when doing this exact test on macOS and Linux.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您看到笑脸，但这将取决于您的系统。[图 4-2](#learnjava6-CHP-4-FIG-2) 显示了我们在 macOS 和 Linux 上进行此精确测试时得到的结果。
- en: '![ljv6 0402](assets/ljv6_0402.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0402](assets/ljv6_0402.png)'
- en: Figure 4-2\. Testing emoji presentation on various systems
  id: totrans-20
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-2\. 在各种系统上测试表情符号的显示效果
- en: It’s not that you can’t use or support emoji in your applications, you just
    have to be aware of differences in output features. Make sure your users have
    a good experience wherever they are running your code.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 并不是说您不能在应用程序中使用或支持表情符号，只是您必须注意输出特性的差异。确保您的用户在运行您的代码时有良好的体验。
- en: Warning
  id: totrans-22
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: When importing the graphical components from the Swing package, be careful to
    use the correct `javax` prefix rather than the standard `java` prefix. More on
    all things Swing in [Chapter 12](ch12.html#learnjava6-CHP-12).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入 Swing 包中的图形组件时，要注意使用正确的 `javax` 前缀而不是标准的 `java` 前缀。有关 Swing 的所有内容，请参阅 [第
    12 章](ch12.html#learnjava6-CHP-12)。
- en: Comments
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注释
- en: 'Now that we know how the text of our programs is stored, we can concentrate
    on what to store! Programmers often include *comments* in their code to help explain
    complex bits of logic or to provide a guide to reading the code for other programmers.
    (Quite often the “other programmer” is yourself several months or years later.)
    The text in a comment is completely ignored by the compiler. Comments have no
    impact on the performance or functionality of your application. As such, we are
    big fans of writing good comments. Java supports both C-style *block comments*
    that can span multiple lines delimited by `/*` and `*/` and C++-style *line comments*
    indicated by `//`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道程序文本是如何存储的，我们可以专注于要存储的内容！程序员经常在代码中包含 *注释* 来帮助解释复杂的逻辑部分或为其他程序员提供阅读代码的指南。（很多时候，“其他程序员”是几个月或几年后的您自己。）注释中的文本完全被编译器忽略。注释对您的应用程序的性能或功能没有影响。因此，我们非常支持编写良好的注释。Java
    支持既可以跨多行的 C 风格 *块注释*，用 `/*` 和 `*/` 分隔，也可以跨一行的 C++ 风格 *行注释*，用 `//` 表示：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Block comments have both a beginning and end sequence and can cover large ranges
    of text. However, they cannot be “nested,” meaning that you can’t put a block
    comment inside of another block comment without running afoul of the compiler.
    Single-line comments have only a start sequence and are delimited by the end of
    a line; extra `//` indicators inside a single line have no effect. Line comments
    are useful for short comments within methods; they don’t conflict with block comments.
    You can still wrap larger chunks of code in which the single-line comments appear
    with a block comment. This is often called *commenting out* a section of code—a
    common trick for debugging large applications. Since the compiler ignores all
    comments, you can put comments on lines or around blocks of code to see how a
    program behaves when that code is removed.^([2](ch04.html#id889))
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 块注释具有起始和结束序列，并且可以覆盖大量文本。但是，它们不能“嵌套”，这意味着您不能将一个块注释放在另一个块注释内部，以免与编译器发生冲突。单行注释只有一个起始序列，并且由行的结束界定；单行内的额外
    `//` 指示符没有效果。行注释对于方法内的短注释非常有用；它们不与块注释冲突。您仍然可以将单行注释出现的代码块包裹在块注释中。这通常称为 *注释掉* 代码段的常用技巧——用于调试大型应用程序。由于编译器忽略所有注释，您可以在行或代码块周围放置注释，以查看在删除该代码时程序的行为如何。^([2](ch04.html#id889))
- en: Javadoc Comments
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Javadoc 注释
- en: 'A special block comment beginning with `/**` indicates a *doc comment*. A doc
    comment is designed to be extracted by automated documentation generators, such
    as the JDK’s own *javadoc* program or the context-aware tooltips in many IDEs.
    A doc comment is terminated by the next `*/`, just as with a regular block comment.
    Within the doc comment, lines beginning with `@` are interpreted as special instructions
    for the documentation generator, giving it information about the source code.
    By convention, each line of a doc comment begins with a `*`, as shown in the following
    example, but this is optional. Any leading spacing and the `*` on each line are
    ignored:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊的以 `/**` 开头的块注释表示 *文档注释*。文档注释旨在被自动化文档生成器提取，例如 JDK 自带的 *javadoc* 程序或许多集成开发环境中的上下文感知工具提示。文档注释以接下来的
    `*/` 结束，就像常规的块注释一样。在文档注释中，以 `@` 开头的行被解释为文档生成器的特殊指令，为其提供有关源代码的信息。按照惯例，文档注释的每一行都以
    `*` 开头，如下例所示，但这是可选的。文档注释中每行的前导空格和每行的 `*` 都会被忽略：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The *javadoc* command-line tool creates HTML documentation for classes by reading
    the source code and pulling out the embedded comments and `@` tags. In this example,
    the tags create author and version information in the class documentation. The
    `@see` tags produce hypertext links to the related class documentation.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*javadoc* 命令行工具通过读取源代码并提取嵌入的注释和 `@` 标签为类创建 HTML 文档。在此示例中，标签在类文档中创建作者和版本信息。`@see`
    标签生成到相关类文档的超文本链接。'
- en: The compiler also looks at the doc comments; in particular, it is interested
    in the `@deprecated` tag, which means that the method has been declared obsolete
    and should be avoided in new programs. The compiled class includes information
    on any deprecated methods so the compiler can warn you whenever you use a deprecated
    feature in your code (even if the source isn’t available).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器也会查看文档注释；特别是它对 `@deprecated` 标签感兴趣，这意味着该方法已被声明为过时，应在新程序中避免使用。编译后的类包含有关任何已弃用方法的信息，因此当您在代码中使用已弃用的功能时，编译器会警告您（即使源代码不可用）。
- en: Doc comments can appear above class, method, and variable definitions, but some
    tags may not apply to all of these. For example, the `@exception` tag can only
    be applied to methods. [Table 4-1](#learnjava6-CHP-4-TABLE-1) summarizes the tags
    used in doc comments.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 文档注释可以出现在类、方法和变量定义之上，但某些标签可能并不适用于所有这些情况。例如，`@exception` 标签只能应用于方法。[表 4-1](#learnjava6-CHP-4-TABLE-1)
    总结了文档注释中使用的标签。
- en: Table 4-1\. Doc comment tags
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 4-1\. 文档注释标签
- en: '| Tag | Description | Applies to |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: 标签 | 描述 | 适用于 |
- en: '| --- | --- | --- |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `@see` | Associated class name | Class, method, or variable |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `@see` | 相关的类名 | 类、方法或变量 |'
- en: '| `@code` | Source code content | Class, method, or variable |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `@code` | 源代码内容 | 类、方法或变量 |'
- en: '| `@link` | Associated URL | Class, method, or variable |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `@link` | 相关的 URL | 类、方法或变量 |'
- en: '| `@author` | Author name | Class |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `@author` | 作者姓名 | 类 |'
- en: '| `@version` | Version string | Class |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `@version` | 版本字符串 | 类 |'
- en: '| `@param` | Parameter name and description | Method |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `@param` | 参数名和描述 | 方法 |'
- en: '| `@return` | Description of return value | Method |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `@return` | 返回值的描述 | 方法 |'
- en: '| `@exception` | Exception name and description | Method |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `@exception` | 异常名称和描述 | 方法 |'
- en: '| `@deprecated` | Declares an item to be obsolete | Class, method, or variable
    |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `@deprecated` | 声明一个项目已过时 | 类、方法或变量 |'
- en: '| `@since` | Notes API version when item was added | Variable |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `@since` | 记录项目添加的 API 版本 | 变量 |'
- en: Javadoc tags in doc comments represent *metadata* about the source code; that
    is, they add descriptive information about the structure or contents of the code
    that is not, strictly speaking, part of the application. Some additional tools
    extend the concept of Javadoc-style tags to include other kinds of metadata about
    Java programs that are carried with the compiled code and can more readily be
    used by the application to affect its compilation or runtime behavior. The Java
    *annotations* facility provides a more formal and extensible way to add metadata
    to Java classes, methods, and variables. This metadata is also available at runtime.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Javadoc 注释中的标签代表关于源代码的*元数据*；换句话说，它们提供了关于代码结构或内容的描述信息，严格来说，这些信息并不是应用程序的一部分。一些额外的工具扩展了
    Javadoc 风格标签的概念，包括与 Java 程序相关的其他元数据，这些元数据与编译后的代码一起传递，并且可以更方便地被应用程序用来影响其编译或运行时行为。Java
    的*注解*功能提供了一种更正式和可扩展的方式，用于向 Java 类、方法和变量添加元数据。这些元数据在运行时也是可用的。
- en: Annotations
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注解
- en: The `@` prefix serves another role in Java that can look similar to tags. Java
    supports the notion of *annotations* as a means of marking certain content for
    special treatment. You apply annotations to code *outside* of comments. The annotation
    can provide information useful to the compiler or to your IDE. For example, the
    `@SuppressWarnings` annotation causes the compiler (and often your IDE as well)
    to hide warnings about potential problems such as unreachable code. As you get
    into creating more interesting classes in [“Advanced Class Design”](ch05.html#learnjava6-CHP-5-SECT-6),
    you may see your IDE add `@Overrides` annotations to your code. This annotation
    tells the compiler to perform some extra checks; these checks are meant to help
    you write valid code and catch errors before you (or your users) run your program.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`@` 前缀在 Java 中还有另一个作用，与标签类似。Java 支持 *注解* 的概念，作为标记某些内容以便进行特殊处理的一种方式。您将注解应用于代码*之外*的地方。注解可以提供对编译器或您的
    IDE 有用的信息。例如，`@SuppressWarnings` 注解会导致编译器（通常也包括您的 IDE）隐藏关于潜在问题（如无法访问的代码）的警告。当您开始在
    [“Advanced Class Design”](ch05.html#learnjava6-CHP-5-SECT-6) 中创建更有趣的类时，可能会看到您的
    IDE 向您的代码中添加 `@Overrides` 注解。此注解告诉编译器执行一些额外的检查；这些检查旨在帮助您编写有效的代码，并在您（或您的用户）运行程序之前捕捉错误。'
- en: You can even create custom annotations to work with other tools or frameworks.
    While a deeper discussion of annotations is beyond the scope of this book, we
    wanted you to know about them, as tags like `@Overrides` will show up both in
    our code and in examples or blog posts you might find online.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以创建自定义注解来与其他工具或框架一起使用。虽然深入讨论注解超出了本书的范围，但我们希望您了解它们，因为像 `@Overrides` 这样的标签将出现在我们的代码中，以及您可能在网上找到的示例或博客文章中。
- en: Variables and Constants
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量和常量
- en: 'While adding comments to your code is critical to producing readable, maintainable
    files, at some point you have to start writing some compilable content. Programming
    is the art of manipulating that content. In just about every language, such information
    is stored in variables and constants for easier use by the programmer. Java has
    both. *Variables* store information that you plan to change and reuse over time
    (or information that you don’t know ahead of time, such as a user’s email address).
    *Constants* store information that is, well, constant. We’ve seen examples of
    both elements even in our tiny starter programs. Recall our simple graphical label
    from [“HelloJava”](ch02.html#learnjava6-CHP-2-SECT-2):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管向代码添加注释对于生成可读性强、易于维护的文件至关重要，但在某些时候，你必须开始编写一些可编译的内容。编程是操纵这些内容的艺术。几乎所有语言中，此类信息存储在变量和常量中，以便程序员更轻松地使用。Java
    同时具备这两者。*变量*存储您计划随时间改变和重用的信息（或者是预先不知道的信息，如用户的电子邮件地址）。*常量*存储的是不会变化的信息。即使在我们的简单入门程序中，我们也已经看到了这两种元素的示例。回顾一下我们在
    [“HelloJava”](ch02.html#learnjava6-CHP-2-SECT-2) 中的简单图形标签：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this snippet, `frame` is a variable. We load it up in line 5 with a new instance
    of the `JFrame` class. Then we get to reuse that same instance in line 7 to add
    our label. We reuse the variable again to set the size of our frame in line 8
    and to make it visible in line 9\. All that reuse is exactly where variables shine.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，`frame`是一个变量。我们在第5行用`JFrame`类的新实例装载它。然后我们在第7行中再次使用同一个实例来添加我们的标签。我们再次重用变量在第8行中设置我们框架的大小，在第9行中使其可见。所有这些重用正是变量发挥作用的地方。
- en: 'Line 6 contains a constant: `JLabel.CENTER`. Constants contain a specific value
    that never changes throughout your program. Information that doesn’t change may
    seem like a strange thing to store—why not just use the information itself each
    time? Constants can be simpler to use than their data; `Math.PI` is probably easier
    to remember than the value `3.141592653589793` it represents. And since you get
    to select the name of the constants in your own code, another benefit is that
    you can describe the information in a useful way. `JLabel.CENTER` may seem a little
    opaque still, but the word `CENTER` at least gives you a hint about what’s happening.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 第6行包含一个常量：`JLabel.CENTER`。常量包含一个在程序执行过程中永远不会改变的特定值。不会改变的信息似乎奇怪地存储起来——为什么不每次都直接使用这些信息呢？常量比它们的数据更容易使用；`Math.PI`可能比它代表的值`3.141592653589793`更容易记住。而且，由于您可以在代码中选择常量的名称，另一个好处是您可以以有用的方式描述信息。`JLabel.CENTER`可能仍然有点难以理解，但至少单词`CENTER`至少给了您一些关于正在发生的事情的提示。
- en: Using named constants also allows for simpler changes down the road. If you
    code something like the maximum number of some resource you use, altering that
    limit is much easier if all you have to do is change the initial value given to
    the constant. If you use a literal number like 5, every time your code needs to
    check that maximum, you would have to hunt through all of your Java files to track
    down every occurrence of a 5 and change it as well—if that particular 5 was in
    fact referring to the resource limit. That type of manual search and replace is
    prone to error, quite above and beyond being tedious.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命名常量还允许更简单地进行未来的更改。如果您编写了某种资源的最大数量，如果只需更改给定给常量的初始值，那么修改该限制要容易得多。如果您使用像5这样的文字数字，每次代码需要检查最大值时，您都必须搜索所有的Java文件来跟踪每个5的出现并进行更改——如果那个特定的5确实是指资源限制的话。这种手动搜索和替换容易出错，也非常乏味。
- en: We’ll see more details on the types and initial values of variables and constants
    in the next section. As always, feel free to use *jshell* to explore and discover
    some of those details on your own! Due to interpreter limitations, you cannot
    declare your own top-level constants in *jshell*. You can still use constants
    defined for classes like `JLabel.CENTER` or define them in your own classes.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中详细了解变量和常量的类型和初始值。与往常一样，可以随意使用*jshell*自己探索和发现其中的一些细节！由于解释器的限制，您不能在*jshell*中声明自己的顶级常量。您仍然可以使用类似`JLabel.CENTER`定义的常量或在自己的类中定义它们。
- en: Try typing the following statements into *jshell* to calculate and store the
    area of a circle in a variable using `Math.PI`. This exercise also proves that
    reassigning constants won’t work. (And again, we have to introduce a few new concepts
    like *assignment*—putting a value into a variable—and the multiplication operator
    `*`. If these commands still feel strange, read on. We’ll go over all of the new
    elements in more detail throughout the rest of this chapter.)
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将以下语句输入*jshell*中，使用`Math.PI`计算并将圆的面积存储在变量中。这个练习还证明了重新分配常量是行不通的。（再次说明，我们必须介绍一些新概念，比如*赋值*——将一个值放入变量中——以及乘法运算符`*`。如果这些命令仍然感觉奇怪，请继续阅读。我们将在本章的其余部分更详细地讨论所有这些新元素。）
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice the compiler error when we try to set `Math.PI` to `3`. You could change
    `radius` and even `area` after you declare and initialize them. But variables
    hold only one value at a time, so the latest calculation is the only thing that
    remains in the variable `area`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注意当我们尝试将`Math.PI`设置为`3`时的编译器错误。在声明和初始化它们之后，您可以更改`radius`甚至`area`。但是变量一次只能保存一个值，所以最新的计算是仅存留在变量`area`中的东西。
- en: Types
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型
- en: The *type system* of a programming language describes how its *data elements*
    (the variables and constants we just touched on) are associated with storage in
    memory and how they are related to one another. In a *statically typed* language,
    such as C or C++, the type of a data element is a simple, unchanging attribute
    that often corresponds directly to some underlying hardware phenomenon, such as
    a register or a pointer value. In a *dynamically typed* language, such as Smalltalk
    or Lisp, variables can be assigned arbitrary elements and can effectively change
    their type throughout their lifetime. A considerable amount of overhead goes into
    validating what happens in these languages at runtime. Scripting languages, such
    as Perl, achieve ease of use by providing drastically simplified type systems
    in which only certain data elements can be stored in variables, and values are
    unified into a common representation, such as strings.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言的*类型系统*描述了它的*数据元素*（我们刚刚提到的变量和常量）如何与内存中的存储关联以及它们如何彼此关联。在*静态类型*语言中，如C或C ++，数据元素的类型是一个简单的、不变的属性，通常直接对应于一些底层的硬件现象，比如寄存器或指针值。在*动态类型*语言中，如Smalltalk或Lisp，变量可以被分配任意元素，并且可以在其生命周期内有效地改变它们的类型。在这些语言中，需要大量的开销来验证运行时发生的事情。脚本语言，如Perl，通过提供极其简化的类型系统来实现易用性，在这种类型系统中，只有特定的数据元素可以存储在变量中，并且值被统一到一个通用的表示形式中，比如字符串。
- en: Java combines many of the best features of both statically and dynamically typed
    languages. As in a statically typed language, every variable and programming element
    in Java has a type that is known at compile time, so the runtime system doesn’t
    normally have to check the validity of assignments between types while the code
    is executing. Unlike traditional C or C++, Java also maintains runtime information
    about objects and uses this to allow truly dynamic behavior. Java code may load
    new types at runtime and use them in fully object-oriented ways, allowing *casting*
    (converting between types) and full *polymorphism* (combining features from multiple
    types). Java code may also “reflect” upon or examine its own types at runtime,
    allowing advanced kinds of application behavior, such as interpreters that can
    interact with compiled programs dynamically.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Java结合了静态类型语言和动态类型语言的许多最佳特性。与静态类型语言一样，在Java中每个变量和编程元素都有一个在编译时已知的类型，因此运行时系统通常不必在代码执行时检查类型之间的赋值的有效性。与传统的C或C
    ++不同，Java还维护关于对象的运行时信息，并使用这些信息来允许真正的动态行为。Java代码可以在运行时加载新类型并以完全面向对象的方式使用它们，从而允许*强制转换*（在类型之间转换）和完整的*多态性*（将多个类型的特征结合在一起）。Java代码还可以在运行时“反射”或检查其自身的类型，从而允许高级的应用行为，如可以与编译程序动态交互的解释器。
- en: Java data types fall into two categories. *Primitive types* represent simple
    values that have built-in functionality in the language; they represent numbers,
    boolean (true or false) values, and characters. *Reference types* (or class types)
    include objects and arrays; they are called reference types because they “refer
    to” a large data type that is passed “by reference,” as we’ll explain shortly.
    *Generics* are reference types that refine an existing type while still providing
    compile-time type safety. For example, Java has a `List` class that can store
    a series of items. Using generics, you can create a `List<String>` which is a
    `List` that can only contain `String`s. Or we could create a list of `JLabel`
    objects with `List<JLabel>`. We’ll see much more of generics in [Chapter 7](ch07.html#learnjava6-CHP-7).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Java数据类型分为两类。*原始类型*表示语言中具有内置功能的简单值；它们表示数字、布尔（true或false）值和字符。*引用类型*（或类类型）包括对象和数组；它们被称为引用类型，因为它们“引用”一个大的数据类型，该数据类型是通过“引用”传递的，我们稍后会解释。*泛型*是对现有类型进行细化的引用类型，同时提供编译时类型安全性。例如，Java有一个`List`类，可以存储一系列项。使用泛型，您可以创建一个`List<String>`，它是一个只能包含`String`的`List`。或者我们可以创建一个包含`JLabel`对象的`List<JLabel>`的列表。我们将在[第7章](ch07.html#learnjava6-CHP-7)中看到更多关于泛型的内容。
- en: Primitive Types
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原始类型
- en: Numbers, characters, and boolean values are fundamental elements in Java. Unlike
    some other (perhaps more pure) object-oriented languages, they are not objects.
    For those situations where it’s desirable to treat a primitive value as an object,
    Java provides “wrapper” classes. (More on this later.) The major advantage of
    treating primitive values as special is that the Java compiler and runtime can
    more readily optimize their implementation. Primitive values and computations
    can still be mapped down to hardware, as they always have been in lower-level
    languages.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 数字、字符和布尔值是 Java 的基本元素。与一些其他（也许更纯粹的）面向对象语言不同，它们不是对象。对于那些希望将原始值视为对象的情况，Java 提供了“包装”类。（稍后详细介绍。）将原始值视为特殊值的主要优势在于，Java
    编译器和运行时可以更容易地优化它们的实现。原始值和计算仍然可以映射到硬件上，就像在低级语言中一直做的那样。
- en: An important portability feature of Java is that primitive types are precisely
    defined. For example, you never have to worry about the size of an `int` on a
    particular platform; it’s always a 32-bit, signed number. The “size” of a numeric
    type determines how big (or how precise) a value you can store. For example, the
    `byte` type is an 8-bit, signed value for storing small numbers, from -128 to
    127.^([3](ch04.html#id903)) The aforementioned `int` type can handle most numeric
    needs, storing values between (roughly) +/- two billion. [Table 4-2](#learnjava6-CHP-4-TABLE-2)
    summarizes Java’s primitive types and their capacities.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Java 的一个重要的可移植性特性是原始类型的精确定义。例如，你永远不用担心 `int` 在特定平台上的大小；它始终是一个32位的有符号数字。数值类型的“大小”决定了你可以存储的值有多大（或多精确）。例如，`byte`
    类型是一个8位的有符号值，用于存储从 -128 到 127 的小数字。^([3](ch04.html#id903)) 上述的 `int` 类型可以处理大部分数值需求，存储大约
    +/- 20 亿之间的值。[表 4-2](#learnjava6-CHP-4-TABLE-2) 总结了 Java 的原始类型及其容量。
- en: Table 4-2\. Java primitive data types
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 4-2\. Java 原始数据类型
- en: '| Type | Definition | Approximate range or precision |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 定义 | 大致范围或精度 |'
- en: '| --- | --- | --- |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `boolean` | Logical value | `true` or `false` |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `boolean` | 逻辑值 | `true` 或 `false` |'
- en: '| `char` | 16-bit, Unicode character | 64K characters |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `char` | 16位，Unicode 字符 | 64K 字符 |'
- en: '| `byte` | 8-bit, signed integer | -128 to 127 |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `byte` | 8位，有符号整数 | -128 到 127 |'
- en: '| `short` | 16-bit, signed integer | -32,768 to 32,767 |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `short` | 16位，有符号整数 | -32,768 到 32,767 |'
- en: '| `int` | 32-bit, signed integer | -2.1e9 to 2.1e9 |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `int` | 32位，有符号整数 | -2.1e9 到 2.1e9 |'
- en: '| `long` | 64-bit, signed integer | -9.2e18 to 9.2e18 |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `long` | 64位，有符号整数 | -9.2e18 到 9.2e18 |'
- en: '| `float` | 32-bit, IEEE 754, floating-point value | 6-7 significant decimal
    places |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `float` | 32位，IEEE 754，浮点数 | 6-7位有效十进制位数 |'
- en: '| `double` | 64-bit, IEEE 754 | 15 significant decimal places |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `double` | 64位，IEEE 754 | 15位有效十进制位数 |'
- en: Note
  id: totrans-79
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: Those of you with a C background may notice that the primitive types look like
    an idealization of C scalar types on a 32-bit machine, and you’re absolutely right.
    That’s how they’re supposed to look. Java’s designers made a few changes, such
    as supporting 16-bit characters for Unicode and dropping ad hoc pointers. But
    overall, the syntax and semantics of Java primitive types derive from C.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有 C 语言背景，可能会注意到原始类型看起来像是在32位机器上C标量类型的理想化，你是对的。这就是它们的设计初衷。Java 的设计者做了一些改变，比如支持16位字符用于Unicode，并且放弃了特定指针。但总体而言，Java
    原始类型的语法和语义源自于 C 语言。
- en: But why have sizes at all? Again, that goes back to efficiency and optimization.
    The number of goals in a soccer match rarely crest the single digits—they would
    fit in a `byte` variable. The number of fans watching that match, however, would
    need something bigger. The total amount of money spent by all of the fans at all
    of the soccer matches in all of the World Cup countries would need something bigger
    still. By picking the right size, you give the compiler the best chance at optimizing
    your code, thus making your application run faster, consume fewer system resources,
    or both.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么还要有大小？再次回到效率和优化。足球比赛中的进球数很少超过个位数 —— 它们可以放在一个 `byte` 变量中。然而，观看这场比赛的球迷人数则需要更大的东西。在所有世界杯国家的所有足球比赛中，所有球迷花费的总金额则需要更大的东西。通过选择合适的大小，你可以给编译器提供最佳的优化机会，从而使你的应用程序运行更快、消耗更少的系统资源，或者两者兼而有之。
- en: Some scientific or cryptographic applications require you to store and manipulate
    very large (or very small) numbers, and value accuracy over performance. If you
    need bigger numbers than the primitive types offer, you can check out the `BigInteger`
    and `BigDecimal` classes in the `java.math` package. These classes offer near-infinite
    size or precision. (If you want to see these big numbers in action, we use `BigInteger`
    to calculate factorial values in [“Creating a custom reducer”](ch11.html#learnjava6-CHP-11-SECT-3.5.2).)
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一些科学或密码应用程序需要您存储和操作非常大（或非常小）的数字，并且重视准确性而非性能。如果需要比原始类型提供的更大数字，请查看`java.math`包中的`BigInteger`和`BigDecimal`类。这些类提供接近无限大小或精度。（如果您想看到这些大数字的实际应用，我们在[“创建自定义约简器”](ch11.html#learnjava6-CHP-11-SECT-3.5.2)中使用`BigInteger`计算阶乘值。）
- en: Floating-point precision
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 浮点精度
- en: Floating-point operations in Java follow the [IEEE 754](https://oreil.ly/ssh7S)
    international specification, which means that the result of floating-point calculations
    is normally the same on different Java platforms. However, Java allows for extended
    precision on platforms that support it. This can introduce extremely small-valued
    and arcane differences in the results of high-precision operations. Most applications
    would never notice this, but if you want to ensure that your application produces
    *exactly* the same results on different platforms, you can use the special keyword
    `strictfp` as a class modifier on the class containing the floating-point manipulation
    (we cover classes in [Chapter 5](ch05.html#learnjava6-CHP-5)). The compiler then
    prohibits these platform-specific optimizations.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Java 中的浮点运算遵循[IEEE 754](https://oreil.ly/ssh7S)国际规范，这意味着浮点计算的结果通常在不同的 Java 平台上相同。但是，Java
    允许在支持的平台上进行扩展精度。这可能会导致高精度操作结果中出现极小值和晦涩的差异。大多数应用程序永远不会注意到这一点，但如果要确保应用程序在不同平台上产生*完全相同*的结果，可以在包含浮点操作的类上使用特殊关键字`strictfp`作为类修饰符（我们在[第
    5 章](ch05.html#learnjava6-CHP-5)中介绍类）。然后，编译器禁止这些特定于平台的优化。
- en: Variable declaration and initialization
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量声明和初始化
- en: 'You declare variables inside of methods and classes with a type name, followed
    by one or more comma-separated variable names. For example:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 您使用类型名称后跟一个或多个逗号分隔的变量名称在方法和类内部声明变量。例如：
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can optionally initialize a variable with an expression of the appropriate
    type when you declare it:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择在声明变量时使用适当类型的表达式进行初始化：
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Variables that are declared as members of a class are set to default values
    if they aren’t initialized (see [Chapter 5](ch05.html#learnjava6-CHP-5)). In this
    case, numeric types default to the appropriate flavor of zero, characters are
    set to the null character (`\0`), and boolean variables have the value `false`.
    (Reference types also get a default value, `null`, but more on that soon in [“Reference
    Types”](#learnjava6-CHP-4-SECT-4.2).)
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未初始化作为类成员声明的变量（参见[第 5 章](ch05.html#learnjava6-CHP-5)），这些变量将设置为默认值。在这种情况下，数值类型默认为适当类型的零，字符设置为空字符（`\0`），布尔变量的值为`false`。（引用类型也有默认值`null`，但我们很快会在[“引用类型”](#learnjava6-CHP-4-SECT-4.2)中详细讨论。）
- en: Local variables, which are declared inside a method and live only for the duration
    of a method call, on the other hand, must be explicitly initialized before they
    can be used. As we’ll see, the compiler enforces this rule, so there is no danger
    of forgetting.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，局部变量在方法内声明，仅在方法调用期间存在，必须在使用之前显式初始化。正如我们将看到的，编译器强制执行此规则，因此不会忘记。
- en: Integer literals
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 整数文字
- en: 'Integer literals can be specified in binary (base 2), octal (base 8), decimal
    (base 10), or hexadecimal (base 16). Binary, octal, and hexadecimal bases are
    mostly used when dealing with low-level file or network data. They represent useful
    groupings of individual bits: 1, 3, and 4 bits, respectively. Decimal values have
    no such mapping, but they are much more human friendly for most numeric information.
    A decimal integer is specified by a sequence of digits beginning with one of the
    characters 1–9:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 可以用二进制（基数 2）、八进制（基数 8）、十进制（基数 10）或十六进制（基数 16）指定整数文字。在处理低级文件或网络数据时，二进制、八进制和十六进制基数主要用于表示单个位的有用分组：1、3
    和 4 位。十进制值没有这样的映射，但对于大多数数字信息来说，它们更加人性化。十进制整数由以字符 1–9 开头的数字序列指定：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'A binary number is denoted by the leading characters `0b` or `0B` (zero “b”),
    followed by a combination of zeros and ones:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制数由前导字符`0b`或`0B`（零“b”）表示，后跟一组零和一：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Octal numbers are distinguished from decimal numbers by a simple leading zero:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 八进制数与十进制数的区别在于简单的前导零：
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'A hexadecimal number is denoted by the leading characters `0x` or `0X` (zero
    “x”), followed by a combination of digits and the characters a–f or A–F, which
    represent the decimal values 10–15:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 十六进制数以前导字符`0x`或`0X`（零“x”）开头，后面跟着一组数字和表示十进制值10到15的字符a-f或A-F：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Integer literals are of type `int` unless they are suffixed with an `L`, denoting
    that they are to be produced as a `long` value:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 整数字面值的类型是`int`，除非它们后缀为`L`，表示它们将作为`long`值产生：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: (The lowercase letter `l` will also work, but it should be avoided because it
    often looks like the number `1`.)
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: （小写字母`l`也可以工作，但应避免使用，因为它经常看起来像数字`1`。）
- en: When a numeric type is used in an assignment or an expression involving a “larger”
    type with a greater range, it can be *promoted* to the bigger type. In the second
    line of the previous example, the number `13` has the default type of `int`, but
    it’s promoted to type `long` for assignment to the `long` variable.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当数值类型在赋值或涉及“更大”范围的类型的表达式中使用时，它可以*提升*到更大的类型。在上一个示例的第二行中，数字`13`具有`int`的默认类型，但在赋值给`long`变量时被提升为`long`类型。
- en: 'Certain other numeric and comparison operations also cause this kind of arithmetic
    promotion, as do mathematical expressions involving more than one type. For example,
    when multiplying a `byte` value by an `int` value, the compiler promotes the `byte`
    to an `int` first:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 某些其他数值和比较操作也会导致这种算术提升，以及涉及多种类型的数学表达式。例如，当将`byte`值乘以`int`值时，编译器首先将`byte`提升为`int`：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can never go the other way and assign a numeric value to a type with a
    smaller range without an explicit *cast*, a special syntax you can use to tell
    the compiler exactly what type you need:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你永远不能反过来将数值赋给一个具有较小范围的类型而不进行显式*转换*，显式转换是一种特殊的语法，你可以使用它告诉编译器你需要什么类型：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The cast in the third line is the `(byte)` phrase before our variable `i`. Conversions
    from floating-point to integer types always require an explicit cast because of
    the potential loss of precision.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 第三行中括号中的`(byte)`短语是我们的变量`i`之前的内容。由于可能存在精度损失，从浮点数到整数类型的转换总是需要显式转换的。
- en: 'Last and maybe least, you can add a bit of formatting to your numeric literals
    by utilizing the “_” (underscore) character between digits. If you have particularly
    large strings of digits, you can break them up as in the following examples:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后也许是最不重要的，你可以通过在数字之间使用“_”（下划线）字符来为你的数字字面值添加一点格式。如果你有特别长的数字串，你可以像下面的例子一样分开它们：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Underscores may only appear between digits, not at the beginning or end of
    a number or next to the `L` long integer signifier. Try out some big numbers in
    *jshell*. Notice that if you try to store a `long` value without the `L` signifier,
    you’ll get an error. You can see how the formatting really is just for your convenience.
    It is not stored; only the actual value is kept in your variable or constant:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 下划线只能出现在数字之间，不能出现在数字的开头或结尾，也不能出现在`L`长整型标识符旁边。在*jshell*中试试一些大数字。注意，如果你试图存储一个`long`值而没有`L`标识符，你会得到一个错误。你可以看到格式化实际上只是为了方便你。它不会被存储；只有实际值被保留在你的变量或常量中：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Try some other examples. It can be useful to get a sense of what you find readable.
    It can also help you learn the kinds of promotions and castings that are available
    or required. Nothing like immediate feedback to drive home these subtleties!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一些其他例子。了解你认为可读性如何是有用的。这也可以帮助你学习可用或需要的促进和转换的类型。没有什么比立即反馈更能强调这些细微差别了！
- en: Floating-point literals
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 浮点字面值
- en: 'Floating-point values can be specified in decimal or scientific notation. Floating-point
    literals are of type `double` unless they are suffixed with an `f` or `F`, denoting
    that they are a smaller-precision `float` value. And just as with integer literals,
    you may use the underscore character to format floating-point numbers—but again,
    only between digits. You can’t place them at the beginning, at the end, next to
    the decimal point, or next to the `F` signifier of the number:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点值可以用十进制或科学计数法指定。浮点字面值的类型是`double`，除非它们后缀为`f`或`F`，表示它们是较小精度的`float`值。与整数字面值一样，你可以使用下划线字符来格式化浮点数，但同样，只能在数字之间使用。你不能把它们放在开头、结尾、小数点旁边或数字的`F`标识符旁边：
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Character literals
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符字面值
- en: 'A literal character value can be specified either as a single-quoted character
    or an escaped ASCII or Unicode sequence, also inside single quotes:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将文字符值指定为单引号字符或转义的ASCII或Unicode序列，同样在单引号内：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You’ll most often deal with characters collected into a `String`, but there
    are still places where individual characters are useful. For example, if you handle
    keyboard input in your application, you might need to process individual key presses
    one `char` at a time.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 通常你会处理收集到`String`中的字符，但仍然有些地方需要单个字符。例如，如果你在应用程序中处理键盘输入，可能需要逐个处理每个`char`键按。
- en: Reference Types
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用类型
- en: In an object-oriented language like Java, you create new, complex data types
    from simple primitives by creating a *class*. Each class then serves as a new
    type in the language. For example, if we create a new class called `Car` in Java,
    we are also implicitly creating a new type called `Car`. The type of an item governs
    how it’s used and where it can be assigned. As with primitives, an item of type
    `Car` can, in general, be assigned to a variable of type `Car` or passed as an
    argument to a method that accepts a `Car` value.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在像Java这样的面向对象语言中，通过创建*类*从简单的基本类型创建新的复杂数据类型。然后每个类作为语言中的新类型。例如，在Java中创建一个名为`Car`的新类，也隐式地创建了一个名为`Car`的新类型。项目的类型决定了它的使用方式和可以分配的位置。与基本类型一样，`Car`类型的项目通常可以分配给`Car`类型的变量或作为接受`Car`值的方法的参数传递。
- en: A type is not just a simple attribute. Classes can have relationships with other
    classes and so do the types that they represent. All classes in Java exist in
    a parent-child hierarchy, where a child class or *subclass* is a specialized kind
    of its parent class. The corresponding types have the same relationship, where
    the type of the child class is considered a subtype of the parent class. Because
    child classes inherit all of the functionality of their parent classes, an object
    of the child’s type is in some sense equivalent to or an extension of the parent
    type. An object of the child type can be used in place of an object of the parent’s
    type.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 类型不仅仅是一个简单的属性。类可以与其他类有关系，它们所代表的类型也一样。在Java中，所有类都存在于父子层次结构中，其中子类或*子类*是其父类的特殊化类型。相应的类型也具有相同的关系，其中子类的类型被视为父类的子类型。因为子类继承其父类的所有功能，子类类型的对象在某种意义上等同于或扩展了父类型。子类型的对象可以用来替换父类型的对象。
- en: For example, if you create a new class, `Dog`, that extends `Animal`, the new
    type, `Dog`, is considered a subtype of `Animal`. Objects of type `Dog` can then
    be used anywhere an object of type `Animal` can be used; an object of type `Dog`
    is said to be assignable to a variable of type `Animal`. This is called *subtype
    polymorphism* and is one of the primary features of an object-oriented language.
    We’ll look more closely at classes and objects in [Chapter 5](ch05.html#learnjava6-CHP-5).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你创建一个新的类，`Dog`，它继承自`Animal`，那么新类型`Dog`被视为`Animal`的子类型。`Dog`类型的对象可以在任何需要`Animal`类型对象的地方使用；`Dog`类型的对象可以被分配给`Animal`类型的变量。这被称为*子类型多态性*，是面向对象语言的主要特征之一。我们将在[第5章](ch05.html#learnjava6-CHP-5)更详细地研究类和对象。
- en: Primitive types in Java are used and passed “by value.” This means that when
    a primitive value like an `int` is assigned to a variable or passed as an argument
    to a method, its *value* is copied. Reference types (class types), on the other
    hand, are always accessed “by reference.” A *reference* is a handle or a name
    for an object. What a variable of a reference type holds is a “pointer” to an
    object of its type (or of a subtype, as described earlier). When you assign the
    reference to a variable or pass it to a method, only the reference is copied,
    not the object to which it’s pointing. A reference is like a pointer in C or C++,
    except that its type is strictly enforced. The reference value itself can’t be
    explicitly created or changed. You must assign an appropriate object to give a
    reference type variable a reference value.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Java中的基本类型被用作“按值”传递。这意味着当将像`int`这样的基本值分配给变量或作为参数传递给方法时，其*值*会被复制。另一方面，引用类型（类类型）始终通过“引用”访问。*引用*是对象的句柄或名称。引用类型变量保存的是指向其类型对象（或子类型，如前所述）的“指针”。当你将引用分配给变量或传递给方法时，只会复制引用，而不是对象本身。引用类似于C或C++中的指针，但其类型严格执行。引用值本身不能显式创建或更改。你必须分配一个适当的对象以给引用类型变量赋予引用值。
- en: Let’s run through an example. We declare a variable of type `Car`, called `myCar`,
    and assign it an appropriate object:^([4](ch04.html#id941))
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来运行。我们声明了一个名为 `myCar` 的类型为 `Car` 的变量，并将其赋值为一个合适的对象：^([4](ch04.html#id941))
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`myCar` is a reference-type variable that holds a reference to the newly constructed
    `Car` object. (For now, don’t worry about the details of creating an object; again,
    we’ll cover that in [Chapter 5](ch05.html#learnjava6-CHP-5).) We declare a second
    `Car` type variable, `anotherCar`, and assign it to the same object. There are
    now two identical references : `myCar` and `anotherCar`, but only one actual `Car`
    object instance. If we change things in the state of the `Car` object itself,
    we see the same effect by looking at it with either reference. We can see behind
    the scenes a little bit by trying this with *jshell*:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`myCar` 是一个引用类型的变量，它持有对新构造的 `Car` 对象的引用。（暂时不要担心创建对象的细节；我们将在[第五章](ch05.html#learnjava6-CHP-5)中介绍。）我们声明了第二个
    `Car` 类型的变量 `anotherCar`，并将其赋值给同一个对象。现在有两个相同的引用：`myCar` 和 `anotherCar`，但只有一个实际的
    `Car` 对象实例。如果我们改变 `Car` 对象本身的状态，无论使用哪个引用查看，都会看到相同的效果。我们可以通过 *jshell* 试一下看一些幕后情况：'
- en: '[PRE20]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Notice the result of the creation and assignments. Here you can see that Java
    reference types come with a pointer value (`21213b92`, the right side of the `@`)
    and their type (`Car`, the left side of the `@`). When we create a new `Car` object,
    `notMyCar`, we get a different pointer value. `myCar` and `anotherCar` point to
    the same object; `notMyCar` points to a second, separate object.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 注意创建和赋值的结果。在这里，您可以看到 Java 引用类型带有一个指针值（`21213b92`，`@` 的右侧）和它们的类型（`Car`，`@` 的左侧）。当我们创建一个新的
    `Car` 对象 `notMyCar` 时，我们得到一个不同的指针值。`myCar` 和 `anotherCar` 指向同一个对象；`notMyCar` 指向第二个独立的对象。
- en: Inferring types
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 推断类型
- en: 'Modern versions of Java have continually improved the ability to infer variable
    types in many situations. Starting with Java 10, you can use the `var` keyword
    in conjunction with the declaration and initiation of a variable, and allow the
    compiler to infer the correct type:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现代版本的 Java 在许多情况下不断改进了推断变量类型的能力。从 Java 10 开始，您可以在声明和初始化变量时使用 `var` 关键字，让编译器推断正确的类型：
- en: '[PRE21]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Notice the (admittedly ugly) output when you create `myCar3` in *jshell*. Although
    we did not explicitly give the type as we did for `myCar2`, the compiler can easily
    understand the correct type to use, and we do, in fact, get a `Car2` object.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在 *jshell* 中创建 `myCar3` 时的（确实有点丑陋的）输出。尽管我们没有像为 `myCar2` 那样明确给出类型，编译器可以轻松地理解要使用的正确类型，并且实际上我们得到了一个
    `Car2` 对象。
- en: Passing references
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传递引用
- en: 'Object references are passed to methods in the same way. In this case, either
    `myCar` or `anotherCar` would serve as equivalent arguments to some hypothetical
    method, called `myMethod()`, in our hypothetical class:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 对象引用以相同的方式传递给方法。在这种情况下，要么 `myCar` 要么 `anotherCar` 将作为某个假设类中某个假设方法 `myMethod()`
    的等效参数：
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: An important, but sometimes confusing, distinction is that the reference itself
    is a value (a memory address). That value is copied when you assign it to a variable
    or pass it in a method call. Given our previous example, the argument passed to
    a method (a local variable from the method’s point of view) is actually a third
    reference to the `Car` object, in addition to `myCar` and `anotherCar`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要但有时令人困惑的区别是，引用本身是一个值（一个内存地址）。当您将其分配给变量或在方法调用中传递时，该值会被复制。根据我们之前的例子，在方法中传递的参数（从方法的角度来看是一个局部变量）实际上是对
    `Car` 对象的第三个引用，除了 `myCar` 和 `anotherCar`。
- en: 'The method can alter the state of the `Car` object through that reference by
    calling the `Car` object’s methods or altering its variables. However, `myMethod()`
    can’t change the caller’s notion of the reference to `myCar`: that is, the method
    can’t change the caller’s `myCar` to point to a different `Car` object; it can
    change only its own reference. This will be more obvious when we talk about methods
    later.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法可以通过调用 `Car` 对象的方法或更改其变量来改变 `Car` 对象的状态。然而，`myMethod()` 无法改变调用者对 `myCar`
    引用的理解：也就是说，该方法无法将调用者的 `myCar` 指向不同的 `Car` 对象；它只能更改自己的引用。这在我们后面讨论方法时会更加明显。
- en: Reference types always point to objects (or `null`), and objects are always
    defined by classes. Similar to native types, if you don’t initialize an instance
    or class variable when you declare it, the compiler will assign it the default
    value of `null`. Also, like native types, local variables that have a reference
    type are *not* initialized by default so you must set your own value before using
    them. However, two special kinds of reference types—arrays and interfaces—specify
    the type of object they point to in a slightly different way.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 引用类型总是指向对象（或 `null`），对象总是由类定义的。与原生类型类似，如果在声明变量实例或类变量时未初始化，编译器将分配默认值 `null`。此外，像原生类型一样，具有引用类型的局部变量默认情况下
    *不* 初始化，因此必须在使用之前设置自己的值。然而，两种特殊类型的引用类型——数组和接口——在指定它们所指向的对象类型时有些微不同。
- en: '*Arrays* in Java are an interesting kind of object automatically created to
    hold a collection of some other type of object, known as the *base type*. An individual
    element in the array will have that base type. (So one element of an array of
    type `int[]` will be an `int`, and an element of an array of type `String[]` will
    be a `String`.) Declaring an array implicitly creates the new class type designed
    as a container for its base type, as you’ll see later in this chapter.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，*数组* 是一种有趣的对象类型，自动创建以容纳某种其他类型的对象集合，称为*基本类型*。数组中的单个元素将具有该基本类型。（因此，类型为
    `int[]` 的数组的一个元素将是 `int`，类型为 `String[]` 的数组的一个元素将是 `String`。）声明数组隐式创建了新的类类型，设计为其基本类型的容器，稍后在本章中您将看到。
- en: '*Interfaces* are a bit sneakier. An interface defines a set of methods and
    gives that set a corresponding type. An object that implements the methods of
    the interface can be referred to by that interface type, as well as its own type.
    Variables and method arguments can be declared to be of interface types, just
    like other class types, and any object that implements the interface can be assigned
    to them. This adds flexibility in the type system and allows Java to cross the
    lines of the class hierarchy and make objects that effectively have many types.
    We’ll cover interfaces in [Chapter 5](ch05.html#learnjava6-CHP-5) as well.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*接口* 稍微复杂些。接口定义了一组方法，并为该集合赋予了相应的类型。实现接口方法的对象可以用该接口类型引用，以及其自身的类型。变量和方法参数可以声明为接口类型，就像其他类类型一样，任何实现接口的对象都可以分配给它们。这增加了类型系统的灵活性，使Java能够跨越类层次结构的边界，并使对象有效地具有多种类型。我们还将在[第5章](ch05.html#learnjava6-CHP-5)中详细讨论接口。'
- en: '*Generic types* or *parameterized types*, as we mentioned earlier, are an extension
    of the Java class syntax that allows for additional abstraction in the way classes
    work with other Java types. Generics allow the programmer to specialize a class
    without changing any of that class’s code. We cover generics in detail in [Chapter 7](ch07.html#learnjava6-CHP-7).'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*泛型类型* 或 *参数化类型*，正如我们之前提到的，是Java类语法的一个扩展，允许在类与其他Java类型交互时进行额外的抽象。泛型允许程序员专门化一个类而不更改该类的任何代码。我们将在[第7章](ch07.html#learnjava6-CHP-7)中详细介绍泛型。'
- en: A Word About Strings
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于字符串的一点说明
- en: 'Strings in Java are objects; they are therefore a reference type. `String`
    objects do, however, have some special help from the Java compiler that makes
    them look more like primitive types. Literal string values in Java source code,
    a series of characters or escape sequences between double quotes, are turned into
    `String` objects by the compiler. You can use a `String` literal directly, pass
    it as an argument to methods, or assign it to a `String` type variable:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Java中的字符串是对象；因此它们属于引用类型。`String` 对象在Java编译器中有一些特殊的帮助，使它们看起来更像原始类型。在Java源代码中，字面字符串值（在双引号之间的一系列字符或转义序列）将由编译器转换为
    `String` 对象。您可以直接使用 `String` 字面值，将其作为方法的参数传递，或将其赋值给 `String` 类型变量：
- en: '[PRE23]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `+` symbol in Java is *overloaded* to work with strings as well as regular
    numbers. Overloading is a term used in languages that allow you to use the same
    method name or operator symbol when working with distinct data types. With numbers,
    `+` performs addition. With strings, `+` performs *concatenation*, which is what
    programmers call sticking two strings together. While Java allows arbitrary overloading
    of methods (more in [“Method Overloading”](ch05.html#learnjava6-CHP-5-SECT-2.7)),
    `+` is one of the few overloaded operators in Java:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，`+`符号被 *重载* 以处理字符串和常规数字。重载是一种在允许您使用相同方法名或操作符号处理不同数据类型的语言中使用的术语。对于数字，`+`执行加法。对于字符串，`+`执行
    *连接*，这是程序员称之为将两个字符串粘在一起的操作。虽然Java允许方法的任意重载（详见[“方法重载”](ch05.html#learnjava6-CHP-5-SECT-2.7)），`+`是Java中少数几个重载的运算符之一：
- en: '[PRE24]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Java builds a single `String` object from the concatenated string literals and
    provides it as the result of the expression. (More on all things `String` in [Chapter 8](ch08.html#learnjava6-CHP-8).)
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Java从串联的字符串文字构建单个`String`对象，并将其作为表达式的结果提供。（有关所有`String`的更多信息，请参见[第8章](ch08.html#learnjava6-CHP-8)。）
- en: Statements and Expressions
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语句和表达式
- en: 'Java *statements* appear inside methods and classes. They describe all activities
    of a Java program. Variable declarations and assignments, such as those in the
    previous section, are statements, as are basic language structures such as if/then
    conditionals and loops. (More on these structures later in this chapter.) Here
    are a few statements in Java:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Java的 *语句* 出现在方法和类中。它们描述Java程序的所有活动。变量声明和赋值，例如前一节中的内容，都是语句，基本的语言结构如if/then条件和循环也是语句。（在本章后面的部分中会进一步介绍这些结构。）以下是Java中的几个语句：
- en: '[PRE25]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Expressions* produce values; Java evaluates an expression to produce a result.
    That result can then be used as part of another expression or in a statement.
    Method calls, object allocations, and, of course, mathematical expressions are
    examples of expressions:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*表达式*产生值；Java评估表达式以生成结果。这个结果可以作为另一个表达式的一部分或者语句中使用。方法调用、对象分配和当然数学表达式都是表达式的例子：'
- en: '[PRE26]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: One of the tenets of Java is to keep things simple and consistent. To that end,
    when there are no other constraints, evaluations and initializations in Java always
    occur in the order in which they appear in the code—from left to right, top to
    bottom. You’ll see this rule used in the evaluation of assignment expressions,
    method calls, and array indexes, to name a few cases. In some other languages,
    the order of evaluation is more complicated or even implementation dependent.
    Java removes this element of danger by precisely and simply defining how the code
    is evaluated.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Java的一个原则是保持事情简单和一致。为此，在没有其他约束的情况下，Java中的评估和初始化总是按照它们在代码中出现的顺序进行——从左到右，从上到下。您将看到此规则用于赋值表达式的评估，方法调用和数组索引等多种情况。在其他一些语言中，评估的顺序更复杂，甚至是实现相关的。Java通过精确定义代码的评估方式，消除了这种危险因素。
- en: This doesn’t mean you should start writing obscure and convoluted statements,
    however. Relying on the order of evaluation of expressions in complex ways is
    a bad programming habit, even when it works. It produces code that is hard to
    read and harder to modify.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着你应该开始编写晦涩和复杂的语句。在复杂的方式中依赖表达式的评估顺序是一个不好的编程习惯，即使它能工作。它生成的代码难以阅读，更难修改。
- en: Statements
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语句
- en: 'In any program, statements perform the real magic. Statements help us implement
    those algorithms we mentioned at the beginning of this chapter. In fact, they
    don’t just help, they are precisely the programming ingredient we use; each step
    in an algorithm will correspond to one or more statements. Statements generally
    do one of four things:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何程序中，语句执行真正的魔法。语句帮助我们实现本章开头提到的那些算法。事实上，它们不仅仅是帮助，它们恰恰是我们使用的编程成分；算法中的每一步都对应一个或多个语句。语句通常做四件事中的一件：
- en: Gather input to assign to a variable
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集输入以分配给变量
- en: Write output (to your terminal, to a `JLabel`, etc.)
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写输出（到你的终端，到一个`JLabel`等等）
- en: Make a decision about which statements to execute
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 做出关于执行哪些语句的决定
- en: Repeat one or more other statements
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复一个或多个其他语句
- en: 'Statements and expressions in Java appear within a *code block*. A code block
    contains a series of statements surrounded by an open curly brace (`{`) and a
    close curly brace (`}`). The statements in a code block can include variable declarations
    and most of the other sorts of statements and expressions we mentioned earlier:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Java中的语句和表达式都出现在一个*代码块*中。代码块包含一系列由开放大括号（`{`）和闭合大括号（`}`）括起来的语句。代码块中的语句可以包括变量声明和我们之前提到的大多数其他类型的语句和表达式：
- en: '[PRE27]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In a sense, methods are just code blocks that take parameters and can be called
    by their names—for example, a hypothetical method `setUpDog()` might start out
    like this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 从某种意义上讲，方法只是带有参数并且可以通过其名称调用的代码块——例如，一个假设的方法`setUpDog()`可能会像这样开始：
- en: '[PRE28]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Variable declarations are *scoped* in Java. They are limited to their enclosing
    code block—that is, you cannot see or use a variable outside of the nearest set
    of braces:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 变量声明在Java中是*有作用域的*。它们仅限于其封闭的代码块内部——也就是说，你不能在最近的大括号外部看到或使用变量：
- en: '[PRE29]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this way, you can use code blocks to arbitrarily group statements and variables.
    The most common use of code blocks, however, is to define a group of statements
    for use in a conditional or iterative statement.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，你可以使用代码块任意分组语句和变量。然而，代码块最常见的用途是定义用于条件或迭代语句中的一组语句。
- en: if/else conditionals
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`if/else`条件语句'
- en: 'One of the key concepts in programming is the notion of making a decision.
    “If this file exists” or “If the user has a WiFi connection” are examples of the
    decisions computer programs and apps make all the time. Java uses the popular
    `if/else` statement for many of these types of decisions.^([5](ch04.html#id965))
    Java defines an `if/else` clause as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 编程中的一个关键概念是做出决策。“如果这个文件存在”或“如果用户有WiFi连接”都是计算机程序和应用程序经常做出的决策的示例。Java使用流行的`if/else`语句来进行许多此类决策。^([5](ch04.html#id965))
    Java将`if/else`子句定义如下：
- en: '[PRE30]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In English, you could read that `if/else` statement as “if the condition is
    true, perform `statement1`. Otherwise, perform `statement2`.”
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在英语中，你可以将`if/else`语句理解为“如果条件为真，则执行`statement1`。否则，执行`statement2`。”
- en: 'The `condition` is a Boolean expression and must be enclosed in parentheses.
    A *Boolean expression*, in turn, is either a *Boolean value* (`true` or `false`)
    or an expression that evaluates to one of those values.^([6](ch04.html#id967))
    For example, `i == 0` is a Boolean expression that tests whether the integer `i`
    holds the value `0`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`condition`是一个布尔表达式，必须用括号括起来。*布尔表达式*本身是一个*布尔值*（`true`或`false`）或者求值为这些值之一的表达式。^([6](ch04.html#id967))
    例如，`i == 0`是一个布尔表达式，用于测试整数`i`是否持有值`0`：'
- en: '[PRE31]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The whole of the preceding example is itself a statement and could be nested
    within another `if/else` clause. The `if` clause has the common functionality
    of taking two different forms: a “one-liner” or a block. We’ll see this same pattern
    with other statements like the loops discussed in the next section. If you only
    have one statement to execute (like the simple `println()` calls in the previous
    snippet), you can place that lone statement after the `if` test or after the `else`
    keyword. If you need to execute more than one statement, you use a block. The
    block form looks like this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 前面示例的整体本身就是一个语句，并且可以嵌套在另一个`if/else`子句中。`if`子句具有执行“一行代码”或一个代码块的常见功能。我们将在下一节讨论的循环中看到相同的模式。如果你只有一个语句要执行（就像前面片段中简单的`println()`调用一样），你可以在`if`测试或`else`关键字之后放置那个单独的语句。如果你需要执行多于一个语句，你可以使用一个代码块。代码块的形式如下：
- en: '[PRE32]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Here, all the enclosed statements in the block are executed for whichever branch
    is taken. We can use this form when we need to do more than just print a message.
    For example, we could guarantee that another variable, perhaps `j`, is not negative:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，对于被选中的任何分支，代码块中的所有语句都会执行。当我们需要做更多事情而不仅仅是打印一条消息时，我们可以使用这种形式。例如，我们可以保证另一个变量，也许是`j`，不是负数。
- en: '[PRE33]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Notice that we used curly braces for the `if` clause, with two statements, and
    for the `else` clause, which still has a single `println()` call. You can always
    use a block if you want. But if you only have one statement, the block with its
    braces is optional.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在`if`子句中使用了大括号，其中有两个语句，并在`else`子句中使用了一个单独的`println()`调用。如果你愿意，你总是可以使用一个代码块。但如果只有一个语句，那么带有大括号的代码块是可选的。
- en: switch statements
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: switch语句
- en: Many languages support a “one of many” conditional commonly known as a *switch*
    or *case* statement. Given one variable or expression, a `switch` statement provides
    multiple options that might match. And we do mean *might*. A value does not have
    to match any of the `switch` options; in that case nothing happens. If the expression
    does match a `case`, that branch is executed. If more than one `case` would match,
    the first match wins.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 许多语言支持常见的“多个之一”条件，通常称为*switch*或*case*语句。给定一个变量或表达式，`switch`语句提供多个可能匹配的选项。我们确实指的是*可能*。一个值不必匹配任何`switch`选项；在这种情况下什么也不发生。如果表达式确实匹配一个`case`，那么执行该分支。如果有多个`case`匹配，那么第一个匹配将获胜。
- en: The most common form of the Java `switch` statement takes an integer (or a numeric
    type argument that can be automatically promoted to an integer type) or a string,
    and selects among a number of alternative, constant `case` branches:^([7](ch04.html#id970))
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Java `switch`语句最常见的形式是接受一个整数（或可以自动提升为整数类型的数值类型参数）或字符串，并在多个常量`case`分支中选择：^（[7](ch04.html#id970)）
- en: '[PRE34]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The case expression for each branch must evaluate to a different constant integer
    or string value at compile time. Strings are compared using the `String` `equals()`
    method, which we’ll discuss in more detail in [Chapter 8](ch08.html#learnjava6-CHP-8).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 每个分支的 case 表达式必须在编译时评估为不同的常量整数或字符串值。字符串使用`String`的`equals()`方法进行比较，我们将在[第 8
    章](ch08.html#learnjava6-CHP-8)中详细讨论这个方法。
- en: 'You can specify an optional `default` case to catch unmatched conditions. When
    executed, the switch simply finds the branch matching its conditional expression
    (or the default branch) and executes the corresponding statement. But that’s not
    the end of the story. Perhaps counterintuitively, the `switch` statement then
    continues executing branches after the matched branch until it hits the end of
    the switch or a special statement called `break`. Here are a couple of examples:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以指定一个可选的`default`情况来捕获未匹配的条件。当执行时，switch简单地找到与其条件表达式匹配的分支（或默认分支）并执行相应的语句。但故事并没有结束。也许有些出乎意料的是，`switch`语句然后继续执行匹配分支后面的分支，直到达到switch的末尾或称为`break`的特殊语句。这里有几个例子：
- en: '[PRE35]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Using `break` to terminate each branch is more common:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`break`来终止每个分支更为常见：
- en: '[PRE36]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In this example, only one branch—`GOOD`, `BAD`, or the default—is executed.
    The “keep going” behavior of `switch` is justified when you want to cover several
    possible case values with the same statement(s) without resorting to duplicating
    a bunch of code:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，只执行一个分支——`GOOD`、`BAD`或默认值。`switch`的“继续进行”行为在你想用同一个语句（们）覆盖几种可能的情况值而不是复制大量代码时是合理的：
- en: '[PRE37]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This example effectively groups the six possible values into three cases. And
    this grouping feature can now appear directly in expressions. Java 12 offered
    *switch expressions* as a preview feature that was honed and made permanent with
    Java 14.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例有效地将六个可能的值分组为三个案例。并且这种分组功能现在可以直接出现在表达式中。Java 12以预览功能提供了*switch表达式*，并在Java
    14中经过完善后成为永久功能。
- en: 'For example, rather than printing out the size names in the example above,
    we could assign our size label directly to a variable:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，与上面示例中打印尺寸名称不同，我们可以直接将我们的尺寸标签分配给一个变量：
- en: '[PRE38]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note the new “arrow” (a hyphen followed by the greater-than symbol) syntax.
    You still use separate `case` entries, but with this expression syntax, the case
    values are given in one comma-separated list rather than as separate, cascading
    entries. You then use `->` between the list and the value to return. This form
    can make the `switch` expression a little more compact and (hopefully) more readable.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 注意新的“箭头”（一个连字符后跟大于符号）语法。您仍然使用单独的`case`条目，但是使用这种表达式语法，案例值以逗号分隔的列表形式给出，而不是作为单独的级联条目。然后在列表和返回值之间使用`->`。这种形式可以使`switch`表达式更加紧凑和（希望）更可读。
- en: do/while loops
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: do/while 循环
- en: The other major concept in controlling which statement gets executed next (*control
    flow* or *flow of control* in programmerese) is repetition. Computers are really
    good at doing things over and over. Repeating a block of code is done with a loop.
    There are a number of different loop statements in Java. Each type of loop has
    advantages and disadvantages. Let’s look at these different types now.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制哪个语句执行下一个（程序员术语中的控制流或流程控制）的另一个主要概念是重复。计算机非常擅长重复做事。使用循环来重复代码块。在Java中有许多不同类型的循环语句。每种类型的循环都有其优缺点。现在让我们来看看这些不同类型。
- en: 'The `do` and `while` iterative statements run as long as a Boolean expression
    (often referred to as the loop’s condition) returns a `true` value. The basic
    structure of these loops is straightforward:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`do` 和 `while` 迭代语句会持续运行，只要布尔表达式（通常称为循环的条件）返回`true`值。这些循环的基本结构很简单：'
- en: '[PRE39]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'A `while` loop is perfect for waiting on some external condition, such as getting
    new email:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环非常适合等待某些外部条件，例如获取新的电子邮件：'
- en: '[PRE40]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Of course, this hypothetical `wait()` method needs to have a limit (typically
    a time limit such as waiting for one second) so that it finishes and gives the
    loop another chance to run. But once you do have some email, you also want to
    process all of the messages that arrived, not just one. Again, a `while` loop
    is perfect. You can use a block of statements inside curly braces if you need
    to execute more than one statement in your loop. Consider a simple countdown printer:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个假设的`wait()`方法需要有一个限制（通常是时间限制，比如等待一秒钟），这样它就会完成并给循环另一个运行的机会。但一旦你有了一些电子邮件，你也希望处理所有到达的消息，而不仅仅是一个。同样，`while`循环是完美的。如果需要在循环中执行多于一个语句的代码块，可以使用花括号内的语句块。考虑一个简单的倒计时打印机：
- en: '[PRE41]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In this example, we use the `>` comparison operator to monitor our `count` variable.
    We want to keep working while the countdown is positive. Inside the body of the
    loop, we print out the current value of `count` and then reduce it by one before
    repeating. When we eventually reduce `count` to `0`, the loop will halt because
    the comparison returns `false`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用`>`比较运算符来监视我们的`count`变量。我们希望在倒计时为正时继续工作。在循环体内，我们打印出当前的`count`值，然后将其减少一再重复。当我们最终将`count`减少到`0`时，循环将停止，因为比较返回`false`。
- en: Unlike `while` loops which test their conditions first, a `do-while` loop (or
    more often just a `do` loop) always executes its statement body at least once.
    A classic example is validating input from a user. You know you need to get some
    information, so you request that information in the body of the loop. The loop’s
    condition can test for errors. If there’s a problem, the loop will start over
    and request the information again. That process can repeat until your request
    comes back without errors and you know you have good information.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 不同于`while`循环首先测试其条件，`do-while`循环（或更常见的仅`do`循环）总是至少执行其语句主体一次。一个典型的例子是验证用户输入。你知道你需要获取一些信息，所以你在循环的主体中请求该信息。循环的条件可以检测错误。如果有问题，循环将重新开始并再次请求信息。该过程可以重复，直到你的请求无错误返回，并且你知道你有了良好的信息。
- en: '[PRE42]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Again, the body of a `do` loop executes at least once. If the user gives us
    a valid email address the first time, we just don’t repeat the loop.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，`do` 循环的主体至少执行一次。如果用户第一次给出有效的电子邮件地址，我们就不重复循环。
- en: The for loop
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`for`循环'
- en: 'Another popular loop statement is the `for` loop. It excels at counting. The
    most general form of the `for` loop is also a holdover from the C language. It
    can look a little messy, but it compactly represents quite a bit of logic:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种流行的循环语句是`for`循环。它擅长计数。`for`循环的最一般形式也是来自于C语言的传统。它看起来可能有点凌乱，但却紧凑地表示了相当多的逻辑：
- en: '[PRE43]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The variable initialization section can declare or initialize variables that
    are limited to the scope of the `for` body. The `for` loop then begins a possible
    series of rounds in which the condition is first checked and, if true, the body
    statement (or block) is executed. Following each execution of the body, the incrementor
    expressions are evaluated to give them a chance to update variables before the
    next round begins. Consider a classic counting loop:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 变量初始化部分可以声明或初始化仅限于`for`主体范围内的变量。然后，`for`循环开始可能的一系列轮次，首先检查条件，如果为真，则执行主体语句（或块）。在每次执行主体后，评估增量表达式，以便在下一轮开始之前更新变量。考虑一个经典的计数循环：
- en: '[PRE44]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This loop will execute 100 times, printing values from 0 to 99\. We declare
    and initialize a variable, `i`, to zero. We use the condition clause to see if
    `i` is less than 100\. If it is, then Java executes the body of the loop. In the
    increment clause, we bump `i` up by one. (We’ll see more on the comparison operators
    like `<` and `>`, as well as the increment shortcut `++` in the next section,
    [“Expressions”](#learnjava6-CHP-4-SECT-5.2).) After `i` is incremented, the loop
    goes back to check the condition. Java keeps repeating these steps (condition,
    body, increment) until `i` reaches 100.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环将执行100次，打印从0到99的值。我们声明并初始化一个变量`i`为零。我们使用条件子句来检查`i`是否小于100。如果是，Java就执行循环体。在增量子句中，我们将`i`增加一。
    （我们将在下一节“表达式”中进一步讨论比较运算符如`<`和`>`，以及增量快捷方式`++`。）`i`增加后，循环回到条件检查。Java重复执行这些步骤（条件、循环体、增量），直到`i`达到100。
- en: Remember that the variable `j` is local to the block (visible only to statements
    within it) and will not be accessible to the code after the `for` loop. If the
    condition of a `for` loop returns `false` on the first check (for example, if
    we set `i` to 1,000 in the initialization clause), the body and incrementor section
    will never be executed.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住变量`j`只在块内可见（仅对其中的语句可见），并且在`for`循环后的代码中将无法访问。如果`for`循环的条件在第一次检查时返回`false`（例如，如果我们在初始化子句中将`i`设置为1000），则永远不会执行循环体和增量部分。
- en: 'You can use multiple comma-separated expressions in the initialization and
    incrementation sections of the `for` loop. For example:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`for`循环的初始化和增量部分中使用多个逗号分隔的表达式。例如：
- en: '[PRE45]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You can also initialize existing variables from outside the scope of the `for`
    loop within the initializer block. You might do this if you wanted to use the
    end value of the loop variable elsewhere. This practice is generally frowned upon:
    it’s prone to mistakes and can make your code difficult to reason about. Nonetheless,
    it is legal and you may hit a situation where this behavior makes the most sense
    to you:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在初始化块中从`for`循环外部初始化现有变量。如果希望在其他地方使用循环变量的结束值，则可能会这样做。这种做法通常不受欢迎：容易出错，使代码难以理解。尽管如此，它是合法的，你可能会遇到这种情况，它对你来说是最合理的：
- en: '[PRE46]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In fact, you can leave out the initialization step completely if you want to
    work with a variable that already has a good starting value:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，如果你想使用已经有一个良好起始值的变量，完全可以省略初始化步骤：
- en: '[PRE47]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note that you do still need the semicolon that normally separates the initialization
    step from the condition.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你仍然需要分号来分隔初始化步骤和条件。
- en: The enhanced for loop
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 增强的for循环
- en: 'Java’s auspiciously dubbed “enhanced `for` loop” acts like the `foreach` statement
    in some other languages, iterating over a series of values in an array or other
    type of collection:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Java的称为“增强的`for`循环”的特性类似于其他一些语言中的`foreach`语句，可以迭代数组或其他类型的集合中的一系列值：
- en: '[PRE48]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The enhanced `for` loop can be used to loop over arrays of any type as well
    as any kind of Java object that implements the `java.lang.Iterable` interface.
    (We’ll have more to say on arrays, classes, and interfaces in [Chapter 5](ch05.html#learnjava6-CHP-5).)
    This includes most of the classes of the Java Collections API (see [Chapter 7](ch07.html#learnjava6-CHP-7)).
    Here are a couple of examples:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 增强的`for`循环可以用来遍历任何类型的数组以及实现了`java.lang.Iterable`接口的任何Java对象。（我们将在[第5章](ch05.html#learnjava6-CHP-5)详细讨论数组、类和接口。）这包括Java集合API的大多数类（参见[第7章](ch07.html#learnjava6-CHP-7)）。以下是一些示例：
- en: '[PRE49]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Again, we haven’t discussed arrays or the `ArrayList` class and its special
    syntax in this example. What we’re showing here is the syntax of the enhanced
    `for` loop iterating over both an array and a list of string values. The brevity
    of this form makes it popular whenever you need to work with a collection of items.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例中，我们还未讨论数组或`ArrayList`类及其特殊语法。我们展示的是增强的`for`循环语法，它可以迭代数组和字符串值列表。这种形式的简洁性使得在需要处理项目集合时非常流行。
- en: break/continue
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: break/continue
- en: 'The Java `break` statement and its friend `continue` can also be used to cut
    a loop or conditional statement short by jumping out of it. A `break` causes Java
    to stop the current loop (or `switch`) statement and skip the rest of the body.
    Java picks up executing the code that comes after the loop. In the following example,
    the `while` loop goes on endlessly until the `watchForErrors()` method returns
    `true`, triggering a `break` statement that stops the loop and proceeds at the
    point marked “after the `while` loop”:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Java 的 `break` 语句及其朋友 `continue` 也可以通过跳出来缩短循环或条件语句。`break` 使 Java 停止当前循环（或 `switch`）语句并跳过其余部分。Java
    继续执行后续代码。在下面的示例中，`while` 循环无休止地进行，直到 `watchForErrors()` 方法返回 `true`，触发 `break`
    语句停止循环，并在标记为“`while` 循环后”处继续执行：
- en: '[PRE50]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'A `continue` statement causes `for` and `while` loops to move on to their next
    iteration by returning to the point where they check their condition. The following
    example prints the numbers 0 through 9, skipping the number 5:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`continue` 语句使 `for` 和 `while` 循环通过返回到它们检查条件的点来进行下一次迭代。以下示例打印数字 0 到 9，跳过数字
    5：'
- en: '[PRE51]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `break` and `continue` statements look like those in the C language, but
    Java’s forms have the additional ability to take a label as an argument and jump
    out multiple levels to the scope of the labeled point in the code. This usage
    is not very common in day-to-day Java coding but may be important in special cases.
    Here is what that looks like:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`break` 和 `continue` 语句看起来像 C 语言中的那些，但是 Java 的形式具有将标签作为参数并跳出代码多个级别到标记点作用域的额外能力。这种用法在日常
    Java 编码中并不常见，但在特殊情况下可能很重要。以下是具体表现：'
- en: '[PRE52]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Enclosing statements, such as code blocks, conditionals, and loops, can be labeled
    with identifiers like `labelOne` and `labelTwo`. In this example, a `break` or
    `continue` without an argument has the same effect as the earlier examples. A
    `break` causes processing to resume at the point labeled “after `labelTwo`“; a
    `continue` immediately causes the `labelTwo` loop to return to its condition test.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如代码块、条件和循环之类的封闭语句可以用像 `labelOne` 和 `labelTwo` 这样的标识符标记。在此示例中，没有参数的 `break`
    或 `continue` 具有与前面示例相同的效果。`break` 使处理恢复到标记为“`labelTwo` 后”的点；`continue` 立即导致 `labelTwo`
    循环返回到其条件测试。
- en: We could use the statement `break labelTwo` in the `smallProblem` statement.
    It would have the same effect as an ordinary `break`, but `break labelOne`, as
    seen with the `bigProblem` statement, breaks out of both levels and resumes at
    the point labeled “after `labelOne`.” Similarly, `continue labelTwo` would serve
    as a normal `continue`, but `continue labelOne` would return to the test of the
    `labelOne` loop. Multilevel `break` and `continue` statements remove the main
    justification for the much maligned `goto` statement in C/C++.^([8](ch04.html#id991))
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `smallProblem` 语句中使用 `break labelTwo` 语句。它与普通的 `break` 语句具有相同的效果，但是像在
    `bigProblem` 语句中看到的 `break labelOne` 语句会跳出两个级别并在标记为“`labelOne`之后”的点处继续。类似地，`continue
    labelTwo` 将作为正常的 `continue`，但 `continue labelOne` 将返回到 `labelOne` 循环的测试。多级 `break`
    和 `continue` 语句消除了对 C/C++ 中备受诟病的 `goto` 语句的主要理由。^([8](ch04.html#id991))
- en: There are a few Java statements we aren’t going to discuss right now. The `try`,
    `catch`, and `finally` statements are used in exception handling, as we’ll discuss
    in [Chapter 6](ch06.html#learnjava6-CHP-6). The `synchronized` statement in Java
    is used to coordinate access to statements among multiple threads of execution;
    see [Chapter 9](ch09.html#learnjava6-CHP-9) for a discussion of thread synchronization.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们不会讨论几个 Java 语句。 `try`、`catch` 和 `finally` 语句用于异常处理，正如我们将在 [第6章](ch06.html#learnjava6-CHP-6)
    中讨论的那样。Java 中的 `synchronized` 语句用于协调多个执行线程之间的访问语句；有关线程同步的讨论，请参阅 [第9章](ch09.html#learnjava6-CHP-9)。
- en: Unreachable statements
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不可达语句
- en: 'On a final note, we should mention that the Java compiler flags *unreachable
    statements* as compile-time errors. An unreachable statement is one that the compiler
    determines will never be called. Of course, many methods or bits of code may never
    actually be called in your program, but the compiler detects only those that it
    can “prove” are never called with some clever checking at compile time. For example,
    a method with an unconditional `return` statement in the middle of it causes a
    compile-time error, as does a method with a conditional that the compiler can
    tell will never be fulfilled:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 最后需要注意的是，Java 编译器会将*无法到达的语句*标记为编译时错误。无法到达的语句是指编译器判断永远不会被调用的语句。当然，你的程序中可能有很多方法或代码块实际上从未被调用过，但编译器仅检测那些可以在编译时“证明”永远不会被调用的部分。例如，一个在方法中有无条件`return`语句的方法会导致编译时错误，就像编译器能够判断永远不会被满足的条件语句一样：
- en: '[PRE53]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: You have to correct the unreachable errors before you can complete the compilation.
    Fortunately, most instances of this error are just typos that are easily fixed.
    On the rare occasion that this compiler check uncovers a fault in your logic and
    not your syntax, you can always rearrange or delete the code that cannot be executed.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成编译之前，您必须纠正无法到达的错误。幸运的是，大多数此类错误只是易于修复的拼写错误。在极少数情况下，此编译器检查揭示了逻辑而非语法上的错误，您总是可以重新排列或删除无法执行的代码。
- en: Expressions
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表达式
- en: An expression produces a result, or value, when it is evaluated. The value of
    an expression can be a numeric type, as in an arithmetic expression; a reference
    type, as in an object allocation; or the special type, `void`, which is the declared
    type of a method that doesn’t return a value. In the last case, the expression
    is evaluated only for its *side effects*; that is, the work it does aside from
    producing a value. The compiler knows the type of an expression. The value produced
    at runtime will either have this type or, in the case of a reference type, a compatible
    (assignable) subtype. (More on that compatibility in [Chapter 5](ch05.html#learnjava6-CHP-5).)
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式在评估时会产生一个结果或值。表达式的值可以是数值类型，如算术表达式；引用类型，如对象分配；或特殊类型`void`，这是一个不返回值的方法声明的类型。在最后一种情况下，表达式仅用于其*副作用*；即，它除了产生值之外还执行的工作。编译器知道表达式的类型。在运行时产生的值将具有这种类型，或者在引用类型的情况下，具有兼容的（可分配的）子类型。（关于此兼容性的更多内容，请参见[第5章](ch05.html#learnjava6-CHP-5)。）
- en: We’ve seen several expressions already in our example programs and code snippets.
    We’ll also see many more examples of expressions in the section [“Assignment”](#learnjava6-CHP-4-SECT-5.2.2).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在示例程序和代码片段中看到了几个表达式。在“赋值”一节中，我们还将看到更多表达式的例子（参见[#learnjava6-CHP-4-SECT-5.2.2](#learnjava6-CHP-4-SECT-5.2.2)）。
- en: Operators
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运算符
- en: Operators help you combine or alter expressions in various ways. They “operate”
    expressions. Java supports almost all standard operators from the C language.
    These operators also have the same precedence in Java as they do in C, as shown
    in [Table 4-3](#learnjava6-CHP-4-TABLE-3).^([9](ch04.html#id1000))
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符帮助您以各种方式组合或改变表达式。它们“操作”表达式。Java 支持几乎所有来自 C 语言的标准运算符。这些运算符在 Java 中的优先级与它们在
    C 中的优先级相同，如[表4-3](#learnjava6-CHP-4-TABLE-3)所示。^([9](ch04.html#id1000))
- en: Table 4-3\. Java operators
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-3\. Java 运算符
- en: '| Precedence | Operator | Operand type | Description |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| 优先级 | 运算符 | 操作数类型 | 描述 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 1 | ++, — | Arithmetic | Increment and decrement |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| 1 | ++, — | 算术 | 自增和自减 |'
- en: '| 1 | +, - | Arithmetic | Unary plus and minus |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| 1 | +, - | 算术 | 正负号 |'
- en: '| 1 | ~ | Integral | Bitwise complement |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| 1 | ~ | 整数 | 按位取反 |'
- en: '| 1 | ! | Boolean | Logical complement |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| 1 | ! | 布尔 | 逻辑非 |'
- en: '| 1 | `(` *`type`* `)` | Any | Cast |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| 1 | `(` *`类型`* `)` | 任意 | 强制类型转换 |'
- en: '| 2 | *, /, % | Arithmetic | Multiplication, division, remainder |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| 2 | *, /, % | 算术 | 乘法、除法、取余 |'
- en: '| 3 | +, - | Arithmetic | Addition and subtraction |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| 3 | +, - | 算术 | 加法和减法 |'
- en: '| 3 | + | String | String concatenation |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| 3 | + | 字符串 | 字符串连接 |'
- en: '| 4 | << | Integral | Left shift |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| 4 | << | 整数 | 左移 |'
- en: '| 4 | >> | Integral | Right shift with sign extension |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| 4 | >> | 整数 | 带符号右移 |'
- en: '| 4 | >>> | Integral | Right shift with no extension |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| 4 | >>> | 整数 | 无符号右移 |'
- en: '| 5 | <, <=, >, >= | Arithmetic | Numeric comparison |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| 5 | <, <=, >, >= | 算术 | 数值比较 |'
- en: '| 5 | `instanceof` | Object | Type comparison |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| 5 | `instanceof` | 对象 | 类型比较 |'
- en: '| 6 | ==, != | Primitive | Equality and inequality of value |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| 6 | ==, != | 原始类型 | 值的相等性和不等性 |'
- en: '| 6 | ==, != | Object | Equality and inequality of reference |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| 6 | ==, != | 对象 | 引用的相等性和不等性 |'
- en: '| 7 | & | Integral | Bitwise AND |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| 7 | & | 整型 | 按位与 |'
- en: '| 7 | & | Boolean | Boolean AND |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| 7 | & | 布尔 | 逻辑与 |'
- en: '| 8 | ^ | Integral | Bitwise XOR |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| 8 | ^ | 整型 | 按位异或 |'
- en: '| 8 | ^ | Boolean | Boolean XOR |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| 8 | ^ | 布尔 | 逻辑异或 |'
- en: '| 9 | &#124; | Integral | Bitwise OR |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| 9 | &#124; | 整型 | 按位或 |'
- en: '| 9 | &#124; | Boolean | Boolean OR |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| 9 | &#124; | 布尔 | 逻辑或 |'
- en: '| 10 | && | Boolean | Conditional AND |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| 10 | && | 布尔 | 条件与 |'
- en: '| 11 | &#124;&#124; | Boolean | Conditional OR |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| 11 | &#124;&#124; | 布尔 | 条件或 |'
- en: '| 12 | ?: | N/A | Conditional ternary operator |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| 12 | ?: | N/A | 条件三元操作符 |'
- en: '| 13 | = | Any | Assignment |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| 13 | = | 任意类型 | 赋值 |'
- en: 'We should also note that the percent (`%`) operator is not strictly a modulo
    but a remainder, and it can have a negative value. Try playing with some of these
    operators in *jshell* to get a better sense of their effects. If you’re somewhat
    new to programming, it is particularly useful to get comfortable with operators
    and their order of precedence. You’ll regularly encounter expressions and operators
    even when performing mundane tasks in your code:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应注意百分号（`%`）操作符不严格是模运算而是余数运算，它可能具有负值。尝试在*jshell*中玩一些这些操作符，以更好地理解它们的效果。如果你对编程有些陌生，熟悉运算符及其优先级顺序尤其有助于你。即使在代码中执行日常任务时，你也会经常遇到表达式和操作符：
- en: '[PRE54]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Java also adds some new operators. As we’ve seen, you can use the `+` operator
    with `String` values to perform string concatenation. Because all integer types
    in Java are signed values, you can use the `>>` operator to perform a right-arithmetic-shift
    operation with sign extension. The `>>>` operator treats the operand as an unsigned
    number^([10](ch04.html#id1007)) and performs a right-arithmetic-shift with no
    sign extension. As programmers, we don’t need to manipulate the individual bits
    in our variables nearly as much as we used to, so you likely won’t see these shift
    operators very often. If they do crop up in encoding or binary data parsing examples
    you read online, feel free to pop into *jshell* to see how they work. This type
    of play is one of our favorite uses for *jshell*!
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: Java 还添加了一些新的操作符。正如我们所见，你可以使用`+`操作符来进行`String`值的连接。因为Java中所有的整数类型都是有符号的，你可以使用`>>`操作符进行带符号右移操作。`>>>`操作符将操作数视为无符号数进行右移操作，不进行符号扩展。作为程序员，我们不需要像以前那样经常操纵变量中的各个位，因此你可能不经常看到这些移位操作符。如果它们确实出现在你阅读的在线编码或二进制数据解析示例中，请随时进入*jshell*查看它们的工作原理。这种玩法是我们对*jshell*最喜欢的用法之一！
- en: Assignment
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 赋值
- en: 'While declaring and initializing a variable is considered a statement with
    no resulting value, variable assignment alone is, in fact, an expression:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然声明和初始化变量被视为没有结果值的语句，但仅变量赋值实际上是一个表达式：
- en: '[PRE55]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Normally, we rely on assignment for its side effects alone, as in the first
    two lines above, but an assignment can be used as a value in another part of an
    expression. Some programmers will use this fact to assign a given value to multiple
    variables at once:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们仅依赖赋值的副作用，就像上面的前两行那样，但赋值也可以作为表达式的一部分的值使用。一些程序员会利用这一事实同时将给定值赋给多个变量：
- en: '[PRE56]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Relying on order of evaluation extensively (in this case, using compound assignments)
    can make code obscure and hard to read. We don’t recommend it, but this type of
    initialization does show up in online examples.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在大量依赖评估顺序（在这种情况下，使用复合赋值）可能会使代码变得晦涩和难以阅读。我们不推荐这样做，但这种类型的初始化确实在在线示例中出现过。
- en: The null value
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 空值
- en: The expression `null` can be assigned to any reference type. It means “no reference.”
    A `null` reference can’t be used to reference anything, and attempting to do so
    generates a `NullPointerException` at runtime. Recall from [“Reference Types”](#learnjava6-CHP-4-SECT-4.2)
    that `null` is the default value assigned to uninitialized class and instance
    variables; be sure to perform your initializations before using reference type
    variables to avoid that exception.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式`null`可以被赋给任何引用类型。它表示“无引用”。`null`引用不能用于引用任何东西，试图这样做会在运行时生成`NullPointerException`异常。请回顾来自[“引用类型”](#learnjava6-CHP-4-SECT-4.2)的内容，`null`是未初始化的类和实例变量的默认值；确保在使用引用类型变量之前执行初始化，以避免该异常。
- en: Variable access
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量访问
- en: 'The dot (`.`) operator is used to select members of a class or object instance.
    (We’ll talk about members in detail in the following chapters.) It can retrieve
    the value of an instance variable (of an object) or a static variable (of a class).
    It can also specify a method to be invoked on an object or class:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 点（`.`）运算符用于选择类或对象实例的成员（我们将在以下章节详细讨论成员）。它可以检索对象实例（对象）的实例变量的值或类的静态变量的值。它还可以指定要在对象或类上调用的方法：
- en: '[PRE57]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'A reference-type expression can be used in compound evaluations (multiple uses
    of the dot operation in one expression) by selecting further variables or methods
    on the result:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 引用类型表达式可以通过选择进一步的变量或方法来在复合评估中使用（在一个表达式中多次使用点操作）：
- en: '[PRE58]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The first line finds the length of our `name` variable by invoking the `length()`
    method of the `String` object. In the second case, we take an intermediate step
    and ask for a substring of the `name` string. The `substring` method of the `String`
    class also returns a `String` reference, for which we ask the length. Compounding
    operations like this is also called *chaining* method calls. One chained selection
    operation that we’ve used a lot already is calling the `println()` method on the
    variable `out` of the `System` class:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行通过调用`String`对象的`length()`方法找到我们的`name`变量的长度。在第二种情况下，我们采取了一个中间步骤，并要求`name`字符串的子字符串。`String`类的`substring`方法也返回一个`String`引用，我们要求其长度。像这样的连续操作也称为*链式*方法调用。我们已经经常使用的一种链式选择操作是在`System`类的变量`out`上调用`println()`方法：
- en: '[PRE59]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Method invocation
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法调用
- en: 'Methods are functions that live within a class and may be accessible through
    the class or its instances, depending on the kind of method. Invoking a method
    means to execute its body statements, passing in any required parameter variables
    and possibly getting a value in return. A method invocation is an expression that
    results in a value. The value’s type is the *return type* of the method:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 方法是存在于类中的函数，可以通过类或其实例访问，具体取决于方法的类型。调用方法意味着执行其主体语句，传入任何必需的参数变量，并可能返回一个值。方法调用是一个表达式，其结果是一个值。该值的类型是方法的*返回类型*：
- en: '[PRE60]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Here, we invoked the methods `println()` and `length()` on different objects.
    The `length()` method returned an integer value; the return type of `println()`
    is `void` (no value). It’s worth emphasizing that `println()` produces *output*,
    but no *value*. We can’t assign that method to a variable like we did above with
    `length()`:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在不同对象上调用了方法`println()`和`length()`。`length()`方法返回一个整数值；`println()`的返回类型是`void`（无返回值）。值得强调的是，`println()`产生*输出*，但没有*值*。我们无法像上面的`length()`那样将该方法赋给一个变量：
- en: '[PRE61]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Methods make up the bulk of a Java program. While you could write some trivial
    applications that exist entirely inside a lone `main()` method of a class, you
    will quickly find you need to break things up. Methods not only make your application
    more readable, they also open the doors to complex, interesting, and *useful*
    applications that simply are not possible without them. Indeed, look back at our
    graphical Hello World applications in [“HelloJava”](ch02.html#learnjava6-CHP-2-SECT-2).
    We used several methods defined for the `JFrame` class.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 方法占据了Java程序的大部分内容。虽然您可以编写一些完全存在于类的单个`main()`方法内的微不足道的应用程序，但很快您会发现需要分解它们。方法不仅使您的应用程序更易读，还为您打开了复杂、有趣和*有用*的应用程序的大门，这些应用程序如果没有方法，根本不可能实现。确实，请回顾我们在[“HelloJava”](ch02.html#learnjava6-CHP-2-SECT-2)中用于`JFrame`类的几种方法定义的图形化Hello
    World应用程序。
- en: These are simple examples, but in [Chapter 5](ch05.html#learnjava6-CHP-5) you’ll
    see that it gets a little more complex when there are methods with the same name
    but different parameter types in the same class, or when a method is redefined
    in a subclass.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是简单的示例，但在[第 5 章](ch05.html#learnjava6-CHP-5)中，当同一类中存在具有相同名称但参数类型不同的方法，或者当在子类中重新定义方法时，情况会变得更加复杂。
- en: Statements, expressions, and algorithms
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 语句、表达式和算法
- en: 'Let’s assemble a collection of statements and expressions of these different
    types to accomplish an actual goal. In other words, let’s write some Java code
    to implement an algorithm. A classic example of an algorithm is Euclid’s process
    for finding the greatest common denominator (GCD) of two numbers. It uses a simple
    (if tedious) process of repeated subtraction. We can use Java’s `while` loop,
    an `if/else` conditional, and some assignments to get the job done:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们组装一组不同类型的语句和表达式来实现一个实际目标。换句话说，让我们编写一些 Java 代码来实现一个算法。一个经典的算法示例是欧几里得算法，用于查找两个数的最大公约数（GCD）。它使用重复减法的简单（虽然乏味）过程。我们可以使用
    Java 的 `while` 循环、`if/else` 条件语句和一些赋值来完成这项工作：
- en: '[PRE62]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: It’s not fancy, but it works—and it is exactly the type of task computer programs
    are great at performing. This is what you’re here for! Well, you’re probably not
    here for the greatest common denominator of 2701 and 222 (37, by the way), but
    you are here to start formulating the solutions to problems as algorithms and
    translating those algorithms into executable Java code.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 它并不花哨，但它有效——这正是计算机程序擅长执行的任务类型。这就是你在这里的原因！嗯，你可能不是为了计算 2701 和 222 的最大公约数（顺便说一句，是
    37），但你确实在这里开始制定解决问题的算法，并将这些算法转化为可执行的 Java 代码。
- en: Hopefully a few more pieces of the programming puzzle are starting to fall into
    place. But don’t worry if these ideas are still fuzzy. This whole coding process
    takes a lot of practice. For one of the coding exercises in this chapter, we want
    you to try getting that block of code above into a real Java class inside the
    `main()` method. Try changing the values of `a` and `b`. In [Chapter 8](ch08.html#learnjava6-CHP-8)
    we’ll look at converting strings to numbers, so that you can find the GCD simply
    by running the program again, passing two numbers as parameters to the `main()`
    method, as shown in [Figure 2-10](ch02.html#learnjava6-CHP-2-FIG-9), without recompiling.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 希望编程难题的几个拼图能够逐渐形成完整的图景。但如果这些想法仍然模糊，不要担心。整个编码过程需要大量的实践。在本章的一个编码练习中，我们希望您尝试将上述代码块放入
    `main()` 方法内的一个真实的 Java 类中。尝试更改 `a` 和 `b` 的值。在 [第8章](ch08.html#learnjava6-CHP-8)
    中，我们将看到如何将字符串转换为数字，以便您可以再次运行程序，将两个数作为参数传递给 `main()` 方法，如 [图2-10](ch02.html#learnjava6-CHP-2-FIG-9)
    所示，而无需重新编译。
- en: Object creation
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象创建
- en: 'Objects in Java are allocated with the `new` operator:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: Java 中的对象是使用 `new` 操作符分配的：
- en: '[PRE63]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The argument to `new` is the *constructor* for the class. The constructor is
    a method that always has the same name as the class. The constructor specifies
    any required parameters to create an instance of the object. The value of the
    `new` expression is a reference of the type of the created object. Objects always
    have one or more constructors, though they may not always be accessible to you.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `new` 的参数是类的 *构造函数*。构造函数是一个与类名相同的方法，用于指定创建对象实例所需的任何参数。`new` 表达式的值是所创建对象类型的引用。对象总是有一个或多个构造函数，尽管它们可能不总是对您可见。
- en: 'We look at object creation in detail in [Chapter 5](ch05.html#learnjava6-CHP-5).
    For now, just note that object creation is also a type of expression and that
    the result is an object reference. A minor oddity is that the binding of `new`
    is “tighter” than that of the dot (`.`) selector. A popular side effect of this
    detail is that you can create a new object and invoke a method on it without assigning
    the object to a reference type variable. For example, you might need the current
    hour of the day—but not the rest of the information found in a `Date` object.
    You don’t need to retain a reference to the newly created date, you can simply
    grab the attribute you need through chaining:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们详细查看了对象创建的细节在 [第5章](ch05.html#learnjava6-CHP-5)。暂时只需注意对象创建也是一种类型的表达式，其结果是一个对象引用。一个小小的奇特之处是
    `new` 的绑定比点 (`.`) 选择器“更紧密”。这个细节的一个流行的副作用是，你可以创建一个新对象并在其上调用一个方法，而不必将对象分配给引用类型变量。例如，你可能只需要一天中的当前小时数，而不需要
    `Date` 对象中的其余信息。你不需要保留对新创建日期的引用，你可以简单地通过链式操作获取所需的属性：
- en: '[PRE64]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The `Date` class is a utility class that represents the current date and time.
    Here we create a new instance of `Date` with the `new` operator and call its `getHours()`
    method to retrieve the current hour as an integer value. The `Date` object reference
    lives long enough to service the `getHours()` method call and is then cut loose
    and eventually garbage-collected (see [“Garbage Collection”](ch05.html#learnjava6-CHP-5-SECT-4.1)).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`Date` 类是一个表示当前日期和时间的实用类。在这里，我们使用 `new` 运算符创建了 `Date` 的一个新实例，并调用其 `getHours()`
    方法来获取当前小时数作为整数值。`Date` 对象引用的生命周期足够长，以服务于 `getHours()` 方法调用，然后被释放并最终进行垃圾回收（参见[“垃圾回收”](ch05.html#learnjava6-CHP-5-SECT-4.1)）。'
- en: Calling methods from a fresh object reference in this way is a matter of style.
    It would certainly be clearer to allocate an intermediate variable of type `Date`
    to hold the new object and then call its `getHours()` method. However, combining
    operations like we did to get the hours above is common. As you learn Java and
    get comfortable with its classes and types, you’ll probably take up some of these
    patterns. Until then, however, don’t worry about being “verbose” in your code.
    Clarity and readability are more important than stylistic flourishes as you work
    through this book.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式从一个新对象引用调用方法是一种风格问题。显然，分配一个中间变量作为 `Date` 类型以保存新对象，然后调用其 `getHours()` 方法会更清晰。然而，像我们上面获取小时数那样结合操作是常见的。随着你学习
    Java 并熟悉其类和类型，你可能会采纳其中一些模式。但在此之前，不要担心在代码中“啰嗦”。在你阅读本书的过程中，清晰和可读性比风格华丽更重要。
- en: The instanceof operator
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: instanceof 运算符
- en: 'You use the `instanceof` operator to determine the type of an object at runtime.
    It tests to see if an object is of the same type or a subtype of the target type.
    (Again, more on this class hierarchy to come!) This is the same as asking if the
    object can be assigned to a variable of the target type. The target type may be
    a class, interface, or array type. `instanceof` returns a `boolean` value that
    indicates whether the object matches the type. Let’s try it in *jshell*:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `instanceof` 运算符来在运行时确定对象的类型。它测试一个对象是否与目标类型相同或是其子类型。（再次提醒，后续将详细介绍这个类层次结构！）这与询问对象是否可以分配给目标类型的变量相同。目标类型可以是类、接口或数组类型。`instanceof`
    返回一个 `boolean` 值，指示对象是否与类型匹配。让我们在 *jshell* 中尝试一下：
- en: '[PRE65]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Notice the final `instanceof` test returns an error. With its strong sense of
    types, Java can often catch impossible combinations at compile time. Similar to
    unreachable code, the compiler won’t let you proceed until you fix the issue.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的 `instanceof` 测试返回一个错误。由于其强大的类型感知能力，Java 在编译时经常能捕获到不可能的组合。与不可达代码类似，编译器在你修复问题之前不会让你继续进行。
- en: 'The `instanceof` operator also correctly reports whether the object is of the
    type of an array:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`instanceof` 运算符还能正确地报告对象是否是数组类型：'
- en: '[PRE66]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'It is also important to note that the value `null` is not considered an instance
    of any class. The following test returns `false`, no matter what type you give
    to the variable:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意 `null` 的值不被视为任何类的实例。无论你给变量什么类型，下面的测试都会返回 `false`：
- en: '[PRE67]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: So `null` is never an “instance of” any class, but Java still tracks the types
    of your variables and will not let you test (or cast) between incompatible types.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`null` 永远不是任何类的“实例”，但 Java 仍然跟踪变量的类型，并且不会让你在不兼容类型之间测试（或强制转换）。
- en: Arrays
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: An array is a special type of object that can hold an ordered collection of
    elements. The type of the elements of the array is called the *base type* of the
    array; the number of elements it holds is a fixed attribute called its *length*.
    Java supports arrays of all primitive types as well as reference types. To create
    an array with a base type of `byte`, for example, you could use the type `byte[]`.
    Similarly, you can create an array with the base type of `String` with `String[]`.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是一种特殊类型的对象，可以容纳有序的元素集合。数组元素的类型称为数组的*基本类型*；它包含的元素数量是其*长度*的固定属性。Java 支持所有基本类型和引用类型的数组。例如，要创建一个基本类型为
    `byte` 的数组，你可以使用 `byte[]` 类型。类似地，你可以使用 `String[]` 来创建基本类型为 `String` 的数组。
- en: If you have done any programming in C or C++, the basic syntax of Java arrays
    should look familiar. You create an array of a specified length and access the
    elements with the *index* operator, `[]`. Unlike those languages, however, arrays
    in Java are true, first-class objects. An array is an instance of a special Java
    `array` class and has a corresponding type in the type system. This means that
    to use an array, as with any other object, you first declare a variable of the
    appropriate type and then use the `new` operator to create an instance of it.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在 C 或 C++ 中做过任何编程，Java 数组的基本语法应该看起来很熟悉。您可以创建指定长度的数组，并使用*索引*运算符`[]`访问元素。然而，与这些语言不同，Java
    中的数组是真正的一流对象。数组是特殊的 Java `array`类的实例，并在类型系统中有对应的类型。这意味着要使用数组，就像使用任何其他对象一样，您首先声明适当类型的变量，然后使用`new`运算符创建其实例。
- en: 'Array objects differ from other objects in Java in three respects:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 数组对象在 Java 中与其他对象有三个不同之处：
- en: Java implicitly creates a special `Array` class type for us whenever we declare
    a new type of array. It’s not strictly necessary to know about this process in
    order to use arrays, but it will help in understanding their structure and their
    relationship to other objects in Java later.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们声明新类型的数组时，Java 隐式地为我们创建了一个特殊的`Array`类类型。要使用数组，不一定需要严格了解此过程，但后续了解其结构及其与 Java
    中其他对象的关系会有所帮助。
- en: Java lets us use the `[]` operator to access and assign array elements so that
    arrays look like many experienced programmers expect. We could implement our own
    classes that act like arrays, but we would have to settle for having methods such
    as `get()` and `set()` instead of using the special `[]` notation.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 允许我们使用`[]`运算符访问和分配数组元素，使得数组看起来像许多有经验的程序员所期望的样子。我们可以实现自己的类来模拟数组，但必须使用像`get()`和`set()`这样的方法，而不是使用特殊的`[]`符号。
- en: Java provides a corresponding special form of the `new` operator that lets us
    construct an instance of an array with a specified length with the `[]` notation
    or initialize it directly from a structured list of values.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 提供了一个相应的`new`运算符的特殊形式，让我们能够使用`[]`符号构造具有指定长度的数组实例，或直接从值的结构化列表初始化它。
- en: Arrays make it easy to work with chunks of related information, such as the
    lines of text in a file, or the words in one of those lines. We use them often
    in examples throughout the book; you’ll see many examples of creating and manipulating
    arrays with the `[]` notation in this and coming chapters.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 数组使得处理相关信息块变得容易，比如文件中的文本行或者这些行中的单词。我们在本书的示例中经常使用它们；在本章和接下来的章节中，您将看到许多使用`[]`符号创建和操作数组的示例。
- en: Array Types
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组类型
- en: An array variable is denoted by a base type followed by the empty brackets,
    `[]`. Alternatively, Java accepts a C-style declaration with the brackets placed
    after the array name.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 数组变量由基本类型后跟空括号`[]`表示。另外，Java 还接受括号放置在数组名称后的 C 风格声明。
- en: 'The following declarations are equivalent:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的声明是等效的：
- en: '[PRE68]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: In each case, we declare `arrayOfInts` as an array of integers. The size of
    the array is not yet an issue because we are only declaring a variable of an array
    type. We have not yet created an actual instance of the `array` class, nor its
    associated storage. It’s not even possible to specify the length of an array when
    declaring an array type variable. The size is strictly a function of the array
    object itself, not the reference to it.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，我们将`arrayOfInts`声明为整数数组。数组的大小尚不成问题，因为我们只是声明了一个数组类型的变量。我们还没有创建`array`类的实际实例，也没有与之关联的存储。甚至在声明数组类型变量时指定数组长度是不可能的。大小严格是数组对象本身的一个函数，而不是对它的引用。
- en: 'Arrays of reference types can be created in the same way:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 引用类型的数组可以以相同的方式创建：
- en: '[PRE69]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Array Creation and Initialization
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组的创建和初始化
- en: 'You use the `new` operator to create an instance of an array. After the `new`
    operator, we specify the base type of the array and its length with a bracketed
    integer expression. We can use this syntax to create array instances with actual
    storage for our recently declared variables. Since expressions are allowed, we
    can even do a little calculating inside the brackets:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`new`运算符创建数组的实例。在`new`运算符之后，我们用方括号括起来的整数表达式指定数组的基本类型及其长度。我们可以使用此语法为我们最近声明的变量创建具有实际存储的数组实例。由于允许表达式，我们甚至可以在括号内做一点计算：
- en: '[PRE70]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We can also combine the steps of declaring and allocating the array:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将声明和分配数组的步骤组合起来：
- en: '[PRE71]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Array indices start with zero. Thus, the first element of `someNumbers[]` has
    index `0`, and the last element has index `19`. After creation, the array elements
    themselves are initialized to the default values for their type. For numeric types,
    this means the elements are initially zero:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 数组索引从零开始。因此，`someNumbers[]` 的第一个元素索引为 `0`，最后一个元素索引为 `19`。创建后，数组元素本身被初始化为其类型的默认值。对于数值类型，这意味着元素最初为零：
- en: '[PRE72]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The elements of an array of objects are references to the objects—just like
    individual variables they point to—but they do not actually contain instances
    of the objects. The default value of each element is therefore `null` until we
    assign instances of appropriate objects:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 对象数组的元素是对象的引用 —— 就像个别变量指向的那样 —— 但它们实际上不包含对象的实例。因此，每个元素的默认值是 `null`，直到我们分配适当对象的实例为止：
- en: '[PRE73]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This is an important distinction that can cause confusion. In many other languages,
    the act of creating an array is the same as allocating storage for its elements.
    In Java, a newly allocated array of objects actually contains only reference variables,
    each with the value `null`.^([11](ch04.html#id1048)) That’s not to say that there
    is no memory associated with an empty array; memory is needed to hold those references
    (the empty “slots” in the array). [Figure 4-3](#learnjava6-CHP-4-FIG-3) illustrates
    the `names` array of the previous example.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个重要的区别，可能会导致混淆。在许多其他语言中，创建数组的行为与为其元素分配存储空间相同。在 Java 中，新分配的对象数组实际上只包含引用变量，每个变量的值为
    `null`。^([11](ch04.html#id1048)) 这并不意味着空数组没有关联的内存；内存用于保存这些引用（数组中的空“槽”）。[图 4-3](#learnjava6-CHP-4-FIG-3)
    描述了前述示例中 `names` 数组的情况。
- en: '![ljv6 0403](assets/ljv6_0403.png)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0403](assets/ljv6_0403.png)'
- en: Figure 4-3\. A Java array
  id: totrans-349
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-3\. 一个 Java 数组
- en: We build our `names` variable as an array of strings (`String[]`). This particular
    `String[]` object contains four `String` type variables. We have assigned `String`
    objects to the first three array elements. The fourth has the default value `null`.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `names` 变量构建为字符串数组（`String[]`）。这个特定的 `String[]` 对象包含四个 `String` 类型的变量。我们已经为前三个数组元素分配了
    `String` 对象。第四个元素具有默认值 `null`。
- en: 'Java supports the C-style curly braces `{}` construct for creating an array
    and initializing its elements:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: Java 支持 C 风格的花括号 `{}` 结构来创建数组并初始化其元素：
- en: '[PRE74]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: An array object of the proper type and length is implicitly created, and the
    values of the comma-separated list of expressions are assigned to its elements.
    Note that we did not use the `new` keyword or the array type here. Java infers
    the use of `new` from the assignment.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式创建了一个正确类型和长度的数组对象，并将逗号分隔的表达式列表的值分配给其元素。注意，我们没有在此处使用 `new` 关键字或数组类型。Java 推断从赋值中使用
    `new`。
- en: 'We can also use the `{}` syntax with an array of objects. In this case, each
    expression must evaluate to an object that can be assigned to a variable of the
    base type of the array or the value `null`. Here are some examples:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在对象数组中使用 `{}` 语法。在这种情况下，每个表达式必须评估为可以分配给数组基本类型或值 `null` 的对象。以下是一些示例：
- en: '[PRE75]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The following declaration and initialization statements are equivalent:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的声明和初始化语句是等价的：
- en: '[PRE76]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Obviously, the first example is better when you have a large number of things
    to store. Most programmers use the curly brace initialization only when they have
    real objects ready to store in the array.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，当您有大量要存储的内容时，第一个示例更好。大多数程序员只有在准备好要存储在数组中的真实对象时才使用花括号初始化。
- en: Using Arrays
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用数组
- en: 'The size of an array object is available in the public variable `length`:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 数组对象的大小可以通过公共变量 `length` 获得：
- en: '[PRE77]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '`length` is the only accessible field of an array; it is a variable, not a
    method as in many other languages. Happily, the compiler tells you when you accidentally
    use parentheses like `alphabet.length()`, as everyone does now and then.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`length` 是数组的唯一可访问字段；它是一个变量，不像许多其他语言中的方法。令人高兴的是，编译器会在您偶尔使用括号，比如 `alphabet.length()`
    时提醒您。'
- en: 'Array access in Java is just like array access in many other languages; you
    access an element by putting an integer-valued expression between brackets after
    the name of the array. This syntax works both for accessing individual, existing
    elements and for assigning new elements. We can get our second musketeer like
    this:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，数组访问就像许多其他语言中的数组访问一样；您通过在数组名称后放置整数值表达式来访问元素。此语法既适用于访问个别现有元素，也适用于分配新元素。我们可以这样获取我们的第二个火枪手：
- en: '[PRE78]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The following example creates an array of `JButton` objects called `keyPad`.
    It then fills the array with buttons, using our square brackets and the loop variable
    as the index:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例创建了一个名为`keyPad`的`JButton`对象数组。然后，使用我们的方括号和循环变量作为索引填充数组：
- en: '[PRE79]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Remember that we can also use the enhanced `for` loop to iterate over array
    values. Here we’ll use it to print all the values we just assigned:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们也可以使用增强型`for`循环来遍历数组值。在这里，我们将使用它来打印我们刚刚分配的所有值：
- en: '[PRE80]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Attempting to access an element that is outside the range of the array generates
    an `ArrayIndexOutOfBoundsException`. This is a type of `RuntimeException`, so
    you can either catch and handle it yourself if you really expect it, or ignore
    it, as we will discuss in [Chapter 6](ch06.html#learnjava6-CHP-6). Here’s a taste
    of the `try/catch` syntax Java uses to wrap such potentially problematic code:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试访问超出数组范围的元素会生成`ArrayIndexOutOfBoundsException`。这是一种`RuntimeException`，因此您可以自行捕获和处理它（如果确实预期会发生），或者像我们将在[第6章](ch06.html#learnjava6-CHP-6)中讨论的那样忽略它。这是Java用于包装此类可能有问题的代码的`try/catch`语法的一小段示例：
- en: '[PRE81]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'It’s a common task to copy a range of elements from one array into another.
    One way to copy arrays is to use the low-level `arraycopy()` method of the `System`
    class:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 复制一段元素从一个数组到另一个数组是一个常见的任务。一种复制数组的方法是使用`System`类的低级`arraycopy()`方法：
- en: '[PRE82]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The following example doubles the size of the `names` array from an earlier
    example:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将之前示例中的`names`数组的大小加倍：
- en: '[PRE83]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Here we allocate and assign a temporary variable, `tmpVar`, as a new array,
    twice the size of `names`. We use `arraycopy()` to copy the elements of `names`
    to the new array. Finally, we assign a temporary array to `names`. If there are
    no remaining references to the old array of names after assigning the new array
    to `names`, the old array will be garbage-collected on the next pass.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们分配并分配一个临时变量`tmpVar`作为一个新的数组，大小是`names`的两倍。我们使用`arraycopy()`将`names`的元素复制到新数组中。最后，我们将临时数组赋给`names`。如果在将新数组分配给`names`后没有剩余对旧数组`names`的引用，那么旧数组将在下一轮进行垃圾回收。
- en: 'Perhaps an easier way to accomplish the same task is to use the `copyOf()`
    or `copy` `OfRange()` methods from the `java.util.Arrays` class:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 或许更简单的完成相同任务的方法是使用`java.util.Arrays`类的`copyOf()`或`copy` `OfRange()`方法：
- en: '[PRE84]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The `copyOf()` method takes the original array and a target length. If the target
    length is larger than the original array length, then the new array is padded
    (with zeros or nulls) to the desired length. The `copyOfRange()` takes a starting
    index (inclusive) and an ending index (exclusive) and a desired length, which
    will also be padded, if necessary.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '`copyOf()`方法接受原始数组和目标长度。如果目标长度大于原始数组长度，则新数组将填充（用零或空值）。`copyOfRange()`接受起始索引（包含）和结束索引（不包含），以及所需的长度，如果需要还会填充。'
- en: Anonymous Arrays
  id: totrans-379
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匿名数组
- en: 'Often it is convenient to create *throwaway* arrays: arrays that are used in
    one place and never referenced anywhere else. Such arrays don’t need names because
    you never refer to them again in that context. For example, you may want to create
    a collection of objects to pass as an argument to some method. It’s easy enough
    to create a normal, named array, but if you don’t actually work with the array
    (if you use the array only as a holder for some collection), you shouldn’t need
    to name that temporary holder. Java makes it easy to create “anonymous” (unnamed)
    arrays.'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，创建*一次性*数组非常方便：即在一个地方使用并且不再在其他任何地方引用的数组。这样的数组不需要名称，因为在该上下文中再也不会引用它们。例如，您可能想创建一组对象以作为某个方法的参数传递。创建普通命名数组很容易，但如果您实际上不使用数组（如果您只将数组用作某个集合的容器），则不需要命名该临时容器。Java使创建“匿名”（无名称）数组变得非常容易。
- en: 'Let’s say you need to call a method named `setPets()`, which takes an array
    of `Animal` objects as arguments. Provided `Cat` and `Dog` are subclasses of `Animal`,
    here’s how to call `setPets()` using an anonymous array:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您需要调用一个名为`setPets()`的方法，该方法接受一个`Animal`对象数组作为参数。假设`Cat`和`Dog`是`Animal`的子类，下面是如何使用匿名数组调用`setPets()`的示例：
- en: '[PRE85]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The syntax looks similar to the initialization of an array in a variable declaration.
    We implicitly define the size of the array and fill in its elements using the
    curly brace notation. However, because this is not a variable declaration, we
    have to explicitly use the `new` operator and the array type to create the array
    object.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 语法看起来类似于变量声明中数组初始化。我们隐式定义数组的大小，并使用大括号符号填充其元素。但是，因为这不是变量声明，所以我们必须显式使用`new`运算符和数组类型来创建数组对象。
- en: Multidimensional Arrays
  id: totrans-384
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多维数组
- en: 'Java supports multidimensional arrays in the form of arrays of other arrays.
    You create a multidimensional array with C-like syntax, using multiple bracket
    pairs, one for each dimension. You also use this syntax to access elements at
    various positions within the array. Here’s an example of a multidimensional array
    that represents a hypothetical chessboard:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: Java支持以数组形式的多维数组。你可以使用类似C的语法创建多维数组，使用多个方括号对，每个维度一个。你还可以使用这种语法访问数组中各种位置的元素。以下是一个表示虚构棋盘的多维数组示例：
- en: '[PRE86]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[Figure 4-4](#learnjava6-CHP-4-FIG-chess-array) illustrates the array of arrays
    we create.'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-4](#learnjava6-CHP-4-FIG-chess-array)展示了我们创建的数组的数组。'
- en: '![ljv6 0404](assets/ljv6_0404.png)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0404](assets/ljv6_0404.png)'
- en: Figure 4-4\. An array of arrays of chess pieces
  id: totrans-389
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-4\. 一个棋子数组的数组
- en: Here, `chessBoard` is declared as a variable of type `ChessPiece[][]` (an array
    of `ChessPiece` arrays). This declaration implicitly creates the type `ChessPiece[]`
    as well. The example illustrates the special form of the `new` operator used to
    create a multidimensional array. It creates an array of `ChessPiece[]` objects
    and then, in turn, makes each element into an array of `ChessPiece` objects. We
    then index `chessBoard` to specify values for particular `ChessPiece` elements.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`chessBoard`被声明为`ChessPiece[][]`类型的变量（`ChessPiece`数组的数组）。这个声明隐式地创建了`ChessPiece[]`类型。该示例说明了用于创建多维数组的`new`操作符的特殊形式。它创建了一个`ChessPiece[]`对象的数组，然后依次将每个元素转换为`ChessPiece`对象的数组。然后我们通过索引`chessBoard`来指定特定`ChessPiece`元素的值。
- en: 'Of course, you can create arrays with more than two dimensions. Here’s a slightly
    impractical example:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以创建超过两个维度的数组。以下是一个略显不切实际的例子：
- en: '[PRE87]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'We can specify a partial index of a multidimensional array to get a subarray
    of array type objects with fewer dimensions. In our example, the variable `chessBoard`
    is of type `ChessPiece[][]`. The expression `chessBoard[0]` is valid and refers
    to the first element of `chessBoard`, which, in Java, is of type `ChessPiece[]`.
    For example, we can populate our chessboard one row at a time:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以指定多维数组的部分索引以获取具有较少维度的数组类型对象的子数组。在我们的示例中，变量`chessBoard`的类型为`ChessPiece[][]`。表达式`chessBoard[0]`是有效的，指的是`chessBoard`的第一个元素，它在Java中是`ChessPiece[]`类型的。例如，我们可以逐行填充我们的棋盘：
- en: '[PRE88]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: We don’t necessarily have to specify the dimension sizes of a multidimensional
    array with a single `new` operation. The syntax of the `new` operator lets us
    leave the sizes of some dimensions unspecified. The size of at least the first
    dimension (the most significant dimension of the array) has to be specified, but
    the sizes of any number of trailing, less significant array dimensions may be
    left undefined. We can assign appropriate array-type values later.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不一定需要使用单个`new`操作指定多维数组的维度大小。`new`操作符的语法允许我们留下某些维度的大小未指定。至少需要指定第一维（数组的最重要的维度）的大小，但可以将任意数量的尾部较次要的数组维度大小留空。我们可以稍后赋予适当的数组类型值。
- en: 'We can create a simplified board of Boolean values which could hypothetically
    track the occupied status of a given square using this technique:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这种技术创建一个布尔值的简化版棋盘，该棋盘可以假设跟踪给定方格的占用状态：
- en: '[PRE89]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Here, `checkerBoard` is declared and created, but its elements, the eight `boolean[]`
    objects of the next level, are left empty. With this type of initialization, `checkerBoard[0]`
    is `null` until we explicitly create an array and assign it, as follows:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`checkerBoard`被声明并创建，但其元素，下一级的八个`boolean[]`对象，保持为空。使用这种类型的初始化，直到我们显式创建一个数组并分配给它，`checkerBoard[0]`都是`null`，如下所示：
- en: '[PRE90]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The code of the previous two snippets is equivalent to:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个片段的代码等效于：
- en: '[PRE91]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: One reason you might want to leave dimensions of an array unspecified is so
    that you can store arrays given to us later.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望将数组的维度留空是为了能够存储稍后给我们的数组。
- en: Note that because the length of the array is not part of its type, the arrays
    in the checkerboard do not necessarily have to be of the same length; that is,
    multidimensional arrays don’t have to be rectangular. Consider the “triangular”
    array of integers shown in [Figure 4-5](#learnjava6-CHP-4-FIG-4) where row one
    has one column, row two has two columns, and so on.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于数组的长度不是其类型的一部分，棋盘中的数组不一定需要具有相同的长度；换句话说，多维数组不一定是矩形的。考虑下图所示的整数“三角形”数组，其中第一行有一列，第二行有两列，依此类推：[图 4-5](#learnjava6-CHP-4-FIG-4)。
- en: '![ljv6 0405](assets/ljv6_0405.png)'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0405](assets/ljv6_0405.png)'
- en: Figure 4-5\. A triangular array of arrays
  id: totrans-405
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-5。一个三角形的数组
- en: The exercises at the end of the chapter give you a chance to set up this array
    and initialize it yourself!
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 章节末尾的练习给了你机会设置和初始化这个数组！
- en: Types and Classes and Arrays, Oh My!
  id: totrans-407
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型、类和数组，哦，我的天啊！
- en: Java has a wide variety of types for storing information, each with its own
    way of representing literal bits of that information. Over time, you’ll gain familiarity
    and comfort with `int`s and `double`s and `char`s and `String`s. But don’t rush—these
    fundamental building blocks are exactly the kind of thing *jshell* was designed
    to help you explore. It’s always worth a moment to check your understanding of
    what a variable can store. Arrays in particular might benefit from a little experimentation.
    You can try out the different declaration techniques and confirm that you have
    a grasp of how to access the individual elements inside single-dimensional and
    multidimensional structures.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: Java有各种类型用于存储信息，每种类型都有自己表示信息字面量的方式。随着时间的推移，你会熟悉和适应`int`、`double`、`char`和`String`。但不要着急——这些基本构建块正是*jshell*设计用来帮助你探索的东西。检查你对变量可以存储什么的理解总是值得的。特别是数组可能会受益于一些实验。你可以尝试不同的声明技术，并确认你掌握了如何访问单维和多维结构中的各个元素。
- en: You can also play with simple flow-of-control statements in *jshell* like our
    `if` branching and `while` looping statements. It requires a little patience to
    type in the occasional multiline snippet, but we can’t overstate how useful play
    and practice are as you load more and more details of Java into your brain. Programming
    languages are certainly not as complex as human languages, but they still have
    many similarities. You can gain literacy in Java just as you have in English (or
    the language you’re using to read this book, if you have a translation). You will
    start to get a feel for what the code is meant to do even if you don’t immediately
    understand the particulars.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在*jshell*中玩耍，例如我们的`if`分支和`while`循环语句的简单控制流。在偶尔输入多行代码片段时需要一点耐心，但我们无法过分强调，随着你将更多Java细节加载到你的大脑中，玩耍和实践是多么有用。编程语言当然不像人类语言那样复杂，但它们仍然有许多相似之处。你可以像学习英语（或你用来阅读本书的语言，如果你有翻译的话）一样获得Java的读写能力。即使你不立即理解细节，你也会开始感受代码的意图。
- en: Some parts of Java, like arrays, are definitely full of particulars. We noted
    earlier that arrays are instances of special array classes in the Java language.
    If arrays have classes, where do they fit into the class hierarchy and how are
    they related? These are good questions, but we need to talk more about the object-oriented
    aspects of Java before answering them. That’s the subject of [Chapter 5](ch05.html#learnjava6-CHP-5).
    For now, take it on faith that arrays fit into the class hierarchy.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: Java的某些部分，如数组，显然是充满细节的。我们之前注意到数组在Java语言中是特殊数组类的实例。如果数组有类，它们在类层次结构中的位置以及它们如何相关呢？这些都是很好的问题，但在回答它们之前，我们需要更多地讨论Java的面向对象方面。这是[第5章](ch05.html#learnjava6-CHP-5)的主题。现在，只需相信数组适合于类层次结构即可。
- en: Review Questions
  id: totrans-411
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复习问题
- en: What text encoding format is used by default by Java in compiled classes?
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java在编译后的类中默认使用哪种文本编码格式？
- en: What characters are used to enclose a multiline comment? Can those comments
    be nested?
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用什么字符来包围多行注释？这些注释可以嵌套吗？
- en: Which looping constructs does Java support?
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java支持哪些循环结构？
- en: In a chain of `if/else if` tests, what happens if multiple conditions are true?
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一系列`if/else if`测试中，如果多个条件为真会发生什么？
- en: If you wanted to store the US stock market’s total capitalization (roughly $31
    trillion at the close of fiscal year 2022) as whole dollars, what primitive data
    type could you use?
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想将美国股市的总市值（大约在2022财年结束时为31万亿美元）以整数美元的形式存储，你可以使用什么原始数据类型？
- en: What does the expression `18 - 7 * 2` evaluate to?
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 表达式`18 - 7 * 2`的计算结果是什么？
- en: How would you create an array to hold the names of the days of the week?
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何创建一个数组来保存一周中每天的名称？
- en: Code Exercises
  id: totrans-419
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码练习
- en: 'For your coding practice, we’ll build on two of the examples from this chapter:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你的编码练习，我们将建立在本章的两个示例之上：
- en: 'Implement Euclid’s GCD algorithm as a full class named `Euclid`. Recall the
    basics of the algorithm:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将欧几里得的最大公约数算法实现为名为`Euclid`的完整类。回顾算法的基础：
- en: '[PRE92]'
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'For your output, can you think of a way to show the user the original values
    of `a` and `b` in addition to the common denominator? The ideal output would look
    something like this:'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了你的输出，你能想到一种方法来显示`a`和`b`的原始值以及共同的分母吗？理想的输出应该像这样：
- en: '[PRE93]'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Try creating the triangular array from the previous section into a simple class
    or in *jshell*. Here’s one way:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试将前一节的三角形数组扩展为一个简单的类或者在*jshell*中。下面是一种方法：
- en: '[PRE94]'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Now expand that code to print the contents of `triangle` to the screen. To
    help, recall that you can print the value of an array element with the `System.out.println()`
    method:'
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在扩展该代码以将`triangle`的内容打印到屏幕上。要帮助记忆，可以使用`System.out.println()`方法打印数组元素的值：
- en: '[PRE95]'
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Your output will probably be a long, vertical line of numbers like this:'
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你的输出可能会是一个长长的垂直数字列，像这样：
- en: '[PRE96]'
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Advanced Exercises
  id: totrans-431
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级练习
- en: 'If you’re up for a bit more of a challenge, try arranging the output in a visual
    triangle. The statement above prints one element on a line by itself. The built-in
    `System.out` object has another output method: `print()`. This method does not
    print a newline after it prints whatever argument was passed in. You can chain
    together several `System.out.print()` calls to produce one line of output:'
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想要更多挑战，尝试将输出排列成一个视觉三角形。上面的语句会将一个元素打印到一行。内置的`System.out`对象还有另一个输出方法：`print()`。这个方法在打印传入的参数后不会打印换行符。你可以链式调用几个`System.out.print()`来产生一行输出：
- en: '[PRE97]'
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Your final output should look similar to this:'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最终的输出应该类似于这样：
- en: '[PRE98]'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: ^([1](ch04.html#id869-marker)) Check out the official [Unicode site](http://www.unicode.org)
    for more information. Curiously, one of the scripts listed as “obsolete and archaic”
    and not currently supported by the Unicode standard is Javanese—a historical language
    of the people of the Indonesian island of Java.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch04.html#id869-marker)) 查看官方[Unicode网站](http://www.unicode.org)获取更多信息。有趣的是，作为“过时和古老”的列在Unicode标准中不再支持的脚本之一是爪哇语——印度尼西亚爪哇岛人的历史语言。
- en: ^([2](ch04.html#id889-marker)) Using a comment to “hide” code can be safer than
    simply deleting the code. If you want the code back, you just take out the comment
    delimiter(s).
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch04.html#id889-marker)) 使用注释来“隐藏”代码比简单删除代码更安全。如果你想要恢复代码，只需去掉注释分隔符。
- en: ^([3](ch04.html#id903-marker)) Java uses a technique called “two’s complement”
    to store integers. This technique uses one bit at the beginning of the number
    to determine whether it is a positive or negative value. A quirk of this technique
    is that the negative range is always larger by one.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch04.html#id903-marker)) Java使用一种称为“二进制补码”的技术来存储整数。这种技术使用数值开头的一位来确定它是正值还是负值。这种技术的一个怪癖是，负数范围总是比正数范围大一。
- en: '^([4](ch04.html#id941-marker)) The comparable code in C++ would be:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch04.html#id941-marker)) 在C++中的可比较代码如下：
- en: '`Car& myCar = *(new Car());`'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '`Car& myCar = *(new Car());`'
- en: '`Car& anotherCar = myCar;`'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '`Car& anotherCar = myCar;`'
- en: ^([5](ch04.html#id965-marker)) We say popular because many programming languages
    have this same conditional statement.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch04.html#id965-marker)) 我们说它流行是因为许多编程语言都有这个相同的条件语句。
- en: ^([6](ch04.html#id967-marker)) The word “Boolean” comes from the English mathematician,
    George Boole, who laid the groundwork for logic analysis. The word is rightly
    capitalized, but many computer languages have a “boolean” type that uses lowercase—including
    Java. You will invariably see both variations online.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch04.html#id967-marker)) “布尔”一词来自英国数学家乔治·布尔，他为逻辑分析奠定了基础。这个词应该是大写的，但许多计算机语言使用小写的“boolean”类型，包括Java。你无论在网上看到哪个版本都会看到两种变体。
- en: ^([7](ch04.html#id970-marker)) We won’t be covering other forms here, but Java
    also supports using enumeration types and class matching in `switch` statements.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch04.html#id970-marker)) 我们在这里不会涉及其他形式，但Java也支持在`switch`语句中使用枚举类型和类匹配。
- en: ^([8](ch04.html#id991-marker)) Jumping to named labels is [still considered
    bad form](https://oreil.ly/4M1Rm).
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](ch04.html#id991-marker)) 跳转到命名标签仍然被认为是不良形式。
- en: ^([9](ch04.html#id1000-marker)) You might remember the term *precedence*—and
    its cute mnemonic, “Please Excuse My Dear Aunt Sally”—from high school algebra.
    Java evaluates (p)arentheses first, then any (e)xponents, then (m)ultiplication
    and (d)ivision, and finally (a)ddition and (s)ubtraction.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: ^([9](ch04.html#id1000-marker)) 你可能还记得术语*优先级*——以及它的可爱记忆口诀，“请原谅我亲爱的舅舅萨利”——来自高中代数。Java首先计算(p)括号，然后计算(e)指数，接着是(m)乘法和(d)除法，最后是(a)加法和(s)减法。
- en: '^([10](ch04.html#id1007-marker)) Computers represent integers in one of two
    ways: signed integers, which allow negative numbers, and unsigned, which do not.
    A signed byte, for example, has the range -128…​127\. An unsigned byte has the
    range 0…​255.'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: ^([10](ch04.html#id1007-marker)) 计算机以两种方式表示整数：有符号整数允许负数，而无符号整数不允许。例如，有符号字节的范围是-128…​127。无符号字节的范围是0…​255。
- en: ^([11](ch04.html#id1048-marker)) The analog in C or C++ is an array of pointers.
    However, pointers in C or C++ are themselves two-, four-, or eight-byte values.
    Allocating an array of pointers is, in actuality, allocating the storage for some
    number of those pointer values. An array of references is conceptually similar,
    although references are not themselves objects. We can’t manipulate references
    or parts of references other than by assignment, and their storage requirements
    (or lack thereof) are not part of the high-level Java language specification.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: ^([11](ch04.html#id1048-marker)) 在C或C++中的类比是指针数组。然而，在C或C++中，指针本身是二、四或八字节的值。实际上，分配指针数组实际上是分配某些指针值的存储空间。概念上类似于引用数组，尽管引用本身不是对象。我们无法操作引用或引用的部分，除非通过赋值，它们的存储需求（或缺乏需求）不是高级Java语言规范的一部分。
