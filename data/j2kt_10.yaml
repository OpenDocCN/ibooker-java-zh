- en: Chapter 10\. Functions to Extension Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。从函数到扩展函数
- en: Kotlin has a special kind of procedure called an extension function, that is
    called like a method but is in fact (usually) a top-level function. It’s easy
    to convert from a normal function to an extension function and back. When should
    we prefer one to the other?
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Kotlin有一种特殊类型的程序称为扩展函数，它像方法一样被调用，但实际上（通常）是顶层函数。将普通函数转换为扩展函数以及反向转换都很容易。什么时候我们应该选择其中一种？
- en: Functions and Methods
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数和方法
- en: 'Object-oriented programming is the art of solving problems by sending messages
    to objects. Want to know the length of `myString`? Ask it by sending it a message
    `myString.length()`. Want to print that string to the console? Put the string
    in a message and ask another object representing the console to print it for you:
    `System.out.println(myString)`. In classic OO languages, we define how an object
    reacts to a message by defining methods on classes. Methods are bound to their
    class and have access to the members (fields and other methods) associated with
    a particular instance. When we invoke a method, the runtime arranges for the correct
    version to be called (depending on the runtime type of the object), and for it
    to have access to instance state.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程是通过向对象发送消息来解决问题的艺术。想知道`myString`的长度？通过发送消息`myString.length()`来询问它。想将该字符串打印到控制台？将字符串放入消息中，并向表示控制台的另一个对象询问以打印它：`System.out.println(myString)`。在经典的面向对象语言中，我们通过在类上定义方法来定义对象如何对消息作出响应。方法绑定到它们的类，并且可以访问与特定实例相关联的成员（字段和其他方法）。当我们调用方法时，运行时会安排调用正确的版本（取决于对象的运行时类型），并让其访问实例状态。
- en: 'In contrast, in functional programming, we solve problems by calling functions
    with values. We find the length of `myString` by passing it to a function: `length(myString)`.
    We print to the console with `println(myString)`, and if we wanted to print somewhere
    else, we would pass that to the function: `println(myString, System.err)`. Functions
    are not defined *on* a type; function parameters and results *have* a type.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，在函数式编程中，我们通过传递值调用函数来解决问题。我们通过将`myString`传递给函数来获取其长度：`length(myString)`。我们通过`println(myString)`将内容打印到控制台，如果想在其他地方打印，也可以将其传递给函数：`println(myString,
    System.err)`。函数并不是在类型上定义的，函数的参数和结果有一个类型。
- en: The paradigms have pros and cons, but for now let’s just consider discoverability
    and extensibility.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 范式各有利弊，但目前让我们只考虑可发现性和可扩展性。
- en: 'Here is a `Customer` type:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个`Customer`类型：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is a class, so straightaway we know that we can send messages to ask for
    the `id`, `givenName`, and `familyName`. What about other operations? In a class-based
    system, we only have to scroll down to see another message that we can send:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个类，因此我们立即知道可以发送消息来询问`id`、`givenName`和`familyName`。其他操作呢？在基于类的系统中，我们只需向下滚动查看我们可以发送的另一条消息：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Often we don’t even get as far as looking at the definition. If we have a variable
    `val customer: Customer`, we can type `customer.` and our IDE will eagerly tell
    us that we can call `id`, `givenName`, `familyName`, or `fullName`. In fact, this
    auto-complete is in many ways better than looking at the class definition, because
    it also shows us other operations (`equals`, `copy`, and so on) that are defined
    in supertypes or implicit in the language.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '我们通常甚至没有看定义的那么远。如果我们有一个变量`val customer: Customer`，我们可以输入`customer.`，我们的IDE将急切地告诉我们可以调用`id`、`givenName`、`familyName`或`fullName`。事实上，这种自动完成在许多方面比查看类定义更好，因为它还显示了在超类型中定义的其他操作（如`equals`、`copy`等）或语言中隐含的操作。'
- en: In a functional decomposition, `fullName` would be a function, and, if we suspect
    it exists, we would have to search our codebase for it. In this case it will be
    a function where the only argument is of type `Customer`. It’s surprisingly hard
    to get IntelliJ to help us. “Find Usages” grouped by parameter type will do the
    job, but it’s hardly convenient. In practice, we expect to find the definition
    of `Customer` and its fundamental operations close together in the source, perhaps
    in the same file or at least namespace, so we might navigate there and find the
    functions where we expect them, but our tools haven’t been very helpful.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在功能分解中，`fullName`将是一个函数，如果我们怀疑它存在，我们需要在代码库中搜索它。在这种情况下，它将是一个函数，其唯一参数的类型是`Customer`。让IntelliJ帮助我们是令人惊讶的难。按参数类型分组的“查找用途”将完成任务，但实际上并不方便。实际上，我们期望在源文件中找到`Customer`及其基本操作的定义，可能在同一个文件中或至少在相同的命名空间中，因此我们可以导航到那里并找到我们期望的函数，但我们的工具并不是非常有用。
- en: Score one to OO for discoverability then. What about extensibility? What happens
    when we want to add an operation to `Customer`? Marketing would like to render
    the name reversed with the `familyName` in uppercase for some report or other.
    (You may notice that whenever we need a simple but arbitrary example, we blame
    marketing.)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象的发现能力得分一分。那么可扩展性呢？当我们想要向`Customer`添加一个操作时会发生什么？营销部门希望以`familyName`大写的方式反向渲染名称以进行某些报告或其他操作。（您可能会注意到，每当我们需要一个简单但是任意的示例时，我们就会责怪营销部门。）
- en: 'If we own the code, we can just add a method:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们拥有代码，我们可以直接添加一个方法：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If we don’t own the code, then we can’t add a method, so we have to fall back
    on a function. In Java we might have a collection of these static functions in
    a class called `Marketing`, or `CustomerUtils`. In Kotlin we can make them top-level
    functions (see [Chapter 8](ch08.html#static-methods-to-top-level-functions)),
    but the principle is the same:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有拥有代码，那么我们就不能添加一个方法，所以我们必须退而求其次使用一个函数。在Java中，我们可以在名为`Marketing`或`CustomerUtils`的类中拥有这些静态函数的集合。在Kotlin中，我们可以将它们作为顶级函数（请参阅[第8章](ch08.html#static-methods-to-top-level-functions)），但原理是相同的：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'What of the functional solution? Well, this is the functional solution, too.
    So the functional solution is arguably better for extensibility, because extension
    operations are indistinguishable from those (like `fullName`) provided by the
    original authors, whereas the OO solution makes us look for two different types
    of implementation: methods and functions.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 那么函数式解决方案怎么样？嗯，这也是函数式解决方案。因此，从可扩展性的角度来看，函数式解决方案可能更好，因为扩展操作与原始作者提供的操作（如`fullName`）是不可区分的，而面向对象的解决方案则要求我们寻找两种不同类型的实现：方法和函数。
- en: Even if we *do* own the code for the `Customer` class, we should be wary of
    adding methods like `nameForMarketing`. If the class `Customer` is a fundamental
    domain class in our application, lots of other code will depend on it. Adding
    a report for marketing shouldn’t force us to recompile and retest everything,
    but it will if we add a method. So it’s better that we keep `Customer` as small
    as possible and have noncore operations as external functions, even if this means
    they are not as discoverable as methods.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们拥有`Customer`类的代码，我们也应该谨慎添加像`nameForMarketing`这样的方法。如果`Customer`类是我们应用程序中的基本领域类，那么许多其他代码将依赖于它。添加一个用于营销的报告不应该强制我们重新编译和重新测试所有内容，但如果我们添加了一个方法，则会这样做。因此，最好将`Customer`保持尽可能小，并将非核心操作作为外部函数，即使这意味着它们不像方法那样易于发现。
- en: In Kotlin, those functions don’t have to be as hard to find as we’ve made out,
    though; they can be extension functions.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中，这些函数不必像我们说的那么难找到；它们可以是扩展函数。
- en: Extension Functions
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展函数
- en: Kotlin’s extension functions look like methods, but are in fact just functions.
    (As we saw in [Chapter 8](ch08.html#static-methods-to-top-level-functions), technically
    they are *also* methods, because on the JVM all code has to be defined in a method.
    In [“Extension Functions as Methods”](#extension-functions-as-methods), we’ll
    see that extension functions can in fact also be nonstatic methods of another
    class.)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin的扩展函数看起来像方法，但实际上只是函数（正如我们在[第8章](ch08.html#static-methods-to-top-level-functions)中看到的，从技术上讲，它们也是方法，因为在JVM上所有代码都必须定义在方法中）。在["扩展函数作为方法"](扩展函数作为方法)中，我们将看到扩展函数实际上也可以是另一个类的非静态方法。
- en: As their name implies, extension functions give us the ability to *extend* the
    operations available on a type. They do this while supporting the intuitive, dot-means-send-a-message
    calling convention of methods, which allows them to be discoverable in the same
    Ctrl-Space way.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 正如它们的名字所示，扩展函数为我们提供了在类型上扩展操作的能力。它们支持直观的点号调用方法，这使得它们可以像方法那样易于发现，通过按下Ctrl-Space。
- en: 'So we can define an extension function:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以定义一个扩展函数：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then we can call it as if it is a method:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以像调用方法一样调用它：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: IntelliJ will auto-suggest extension functions along with the actual methods,
    even if they need to be imported to bring them into scope.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: IntelliJ将自动建议扩展函数以及实际的方法，即使它们需要导入以将它们引入范围内。
- en: 'Java isn’t quite so helpful—it just sees the extension function as a static
    function:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Java并不是那么有帮助——它只把扩展函数看作是静态函数：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`MarketingStuffKt` is the name of the class containing our top-level declarations
    as static methods; see [Chapter 8](ch08.html#static-methods-to-top-level-functions).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`MarketingStuffKt`是包含我们顶级声明作为静态方法的类的名称；请参阅[第8章](ch08.html#static-methods-to-top-level-functions)。'
- en: 'Interestingly, we can’t call the function in the same way from Kotlin:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，我们无法从Kotlin以同样的方式调用该函数：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This fails to compile, with the error:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致编译失败，出现以下错误：
- en: '`Unresolved reference. None of the following candidates is applicable because
    of receiver type mismatch: public fun Customer.nameForMarketing(): String ...`.'
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`未解析的引用。由于接收器类型不匹配，以下候选项均不适用：public fun Customer.nameForMarketing(): String
    ...`。'
- en: '*Receiver*, by the way, is the term that Kotlin uses for the object named `this`
    in an extension function (or normal method): the object that receives messages.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，*接收者*是 Kotlin 中用于扩展函数（或普通方法）中的名为`this`的对象的术语：接收消息的对象。
- en: Note that extension functions don’t have any special access to the private members
    of the class that they are extending; they only have the same privileges as normal
    functions in their scope.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，扩展函数没有对它们扩展的类的私有成员有任何特殊访问权限；它们只具有其作用域中普通函数的相同权限。
- en: Extensions and Function Types
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展和函数类型
- en: 'Although we can’t call extension functions as normal functions in Kotlin, we
    can assign them to normal function references. So the following compiles:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们不能在 Kotlin 中像普通函数一样调用扩展函数，但我们可以将它们分配给普通函数引用。因此以下内容编译通过：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can invoke these as expected:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按预期调用这些函数：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can also use the *with-receiver* references as if they took the receiver
    as the first argument:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将*with-receiver*引用视为接收者作为第一个参数：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We cannot, however, call the plain references as if they had a receiver. Both
    of these lines fail to compile, with an `Unresolved reference` error:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们无法将普通引用视为具有接收者的引用。这两行都无法编译通过，出现`未解析的引用`错误：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Extension Properties
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展属性
- en: Kotlin also supports extension properties. As we discuss in [Chapter 11](ch11.html#methods-to-properties),
    Kotlin property accessors are actually method calls. In the same way that extension
    functions are static functions that are called like methods, extension properties
    are static functions that are called like properties, which are in turn methods.
    Extension properties can’t store any data because they don’t really add fields
    to their class—their value can only be computed.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 还支持扩展属性。正如我们在[第 11 章](ch11.html#methods-to-properties)讨论的那样，Kotlin 属性访问器实际上是方法调用。与扩展函数像方法一样调用一样，扩展属性是像属性一样调用的静态函数，这些属性又是方法。扩展属性不能存储任何数据，因为它们实际上不会向其类添加字段——它们的值只能计算。
- en: 'The `nameForMarketing` function could have been defined as an extension *property*:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`nameForMarketing`函数可以被定义为一个扩展*属性*：'
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In fact, it probably *should* be a property, as we will discuss in [Chapter 11](ch11.html#methods-to-properties).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，它可能*应该*是一个属性，正如我们将在[第 11 章](ch11.html#methods-to-properties)中讨论的那样。
- en: Most of what we have to say about extension functions applies to extension properties
    unless we specifically distinguish between them.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们关于扩展函数的大部分内容都适用于扩展属性，除非我们明确区分它们。
- en: Extensions Are Not Polymorphic
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展不是多态的
- en: Although invoking an extension function looks like a method call, it is not,
    in fact, sending a message to an object. For polymorphic method calls, Kotlin
    uses the dynamic type of the receiver at runtime to select the method to execute.
    For extensions, Kotlin uses the static type of the receiver at compile time to
    select the function to call.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然调用扩展函数看起来像是方法调用，但实际上并不是发送消息给对象。对于多态方法调用，Kotlin 使用接收者的动态类型在运行时选择要执行的方法。对于扩展，Kotlin
    使用接收者的静态类型在编译时选择要调用的函数。
- en: If we need to use extensions in a polymorphic way, we can often achieve this
    by calling polymorphic methods from our extension functions.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要以多态方式使用扩展，我们通常可以通过从扩展函数调用多态方法来实现这一点。
- en: Conversions
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换
- en: So far, we have seen extension functions adding operations to a type. Conversions
    from one type to another are a common case. Travelator needs to convert customer
    details to and from JSON and XML. How should we convert from `JsonNode` to `Customer`?
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到扩展函数将操作添加到类型中。从一种类型到另一种类型的转换是一种常见情况。Travelator 需要将客户详细信息转换为 JSON
    和 XML，并从中转换。我们应该如何从`JsonNode`转换为`Customer`？
- en: 'We could add a constructor: `Customer(JsonNode)` that knows how to extract
    the relevant data, but it really doesn’t feel right to pollute our `Customer`
    class with dependencies on a specific JSON library, and then maybe an XML parser,
    and then what? The same argument applies to adding conversions to the `JsonNode`
    class. Even if we *could* change its code, pretty soon it would be unmanageable
    with all the `JsonNode.toMyDomainType()` methods.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加一个构造函数：`Customer(JsonNode)`，它知道如何提取相关数据，但是在我们的 `Customer` 类中污染具体的 JSON
    库的依赖感觉并不对劲，然后可能是 XML 解析器，然后呢？相同的论点适用于将转换添加到 `JsonNode` 类中。即使我们*可以*改变它的代码，很快它也将变得难以管理，带有所有
    `JsonNode.toMyDomainType()` 方法。
- en: 'In Java, we would write a class of utility functions of the form:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，我们会编写形式为实用函数的类：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Or with Nat and Duncan’s preferred naming convention:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 或者使用Nat和Duncan偏爱的命名约定：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Calling the conversions individually isn’t too horrible:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 分别调用转换并不是太可怕：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If we need to combine functions, though, things start to go awry:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们需要组合函数，事情开始变得混乱：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We’re all developers here, and used to reading function invocations. So it’s
    easy to underestimate the cognitive load of searching for the innermost call and
    working your way out through function and method calls to compute how an expression
    evaluates. Not what it evaluates to, just the order in which it evaluates. In
    Kotlin, we can write the conversion as an extension on `JsonNode` and enjoy a
    soothing flow from left to right:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都是开发人员，在阅读函数调用时很容易低估搜索内部调用并通过函数和方法调用从内到外计算表达式的认知负荷。不是它评估为什么，而是它评估的顺序。在 Kotlin
    中，我们可以将转换编写为 `JsonNode` 的扩展，并享受从左到右的流畅流程：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Ahh…that’s much more readable.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 啊…这样读起来更清晰了。
- en: Nullable Parameters
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可空参数
- en: 'Extensions really come into their own when we work with optional data. When
    we are sending messages to a potentially `null` object, we can use the safe-call
    operator `?.` that we saw in [Chapter 4](ch04.html#optional-to-nullable). That
    doesn’t help with parameters though; to pass a nullable reference as an argument
    to a function that takes a nonnull parameter, we have to wrap the call in conditional
    logic:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理可选数据时，扩展函数真正发挥作用。当我们向可能为`null`的对象发送消息时，我们可以使用我们在[第四章](ch04.html#optional-to-nullable)中看到的安全调用运算符`?.`。这对参数没有帮助；要将可为空的引用作为参数传递给接受非空参数的函数，我们必须将调用包装在条件逻辑中：
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Kotlin’s *scoping functions*, such as `let`, `apply`, and `also`, can help
    here. In particular, `let` converts its receiver into a lambda parameter:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin的*作用域函数*，例如 `let`，`apply` 和 `also`，可以在这里提供帮助。特别是 `let` 将其接收者转换为 lambda
    参数：
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here the `?.` ensures that `let` is only called when the customer is not `null`,
    meaning that the lambda parameter, `it`, is never null, and can be passed to the
    function within the lambda body. You can think of `?.let` as a safe-call operator
    for (single) arguments.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`?.` 确保仅当客户不为`null`时才调用 `let`，这意味着 lambda 参数 `it` 永不为 null，并且可以传递给 lambda
    体内的函数。您可以将 `?.let` 视为（单个）参数的安全调用运算符。
- en: 'If a function returns a nullable result, and we must pass that result to another
    function that expects a nonnull parameter, the scoping functions start to get
    cumbersome:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数返回可为空的结果，并且我们必须将该结果传递给期望非空参数的另一个函数，则作用域函数开始变得笨拙：
- en: '[PRE20]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Even when we can flatten nested null checks into a pipeline of calls to `let`,
    all this additional mechanism adds syntactic noise and obscures the *intent* of
    the code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们可以将嵌套的空检查展平为调用管道，所有这些额外的机制都会增加语法噪音并且遮蔽了代码的*意图*：
- en: '[PRE21]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If we convert the problematic parameters to extension function receivers, we
    can chain calls directly, bringing the application logic to the fore:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将有问题的参数转换为扩展函数的接收器，我们可以直接链式调用，将应用逻辑置于前端：
- en: '[PRE22]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When Nat and Duncan first adopted Kotlin, they soon found that extensions and
    nullability form a virtuous circle. It was easier to process optional data with
    extension functions, so they extracted extensions private to the file or refactored
    functions into extensions where it made logic easier to write. They found that
    the names of these extensions could be more concise than that of an equivalent
    function without obscuring intent. As a result, they wrote more extensions to
    make their application logic concise. Private extensions often proved to be useful
    elsewhere, so they moved them into common modules where they could easily be shared.
    This made it easier to use optional data in other parts of the application, which
    led them to write more extensions, which made application logic more concise…and
    so on.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Nat 和 Duncan 刚开始使用 Kotlin 时，他们很快发现扩展和可空性形成了一个良性循环。使用扩展函数处理可选数据更容易，因此他们将文件中私有的扩展或重构函数成扩展，使逻辑更易于编写。他们发现这些扩展的命名可以比等效的函数更简洁，而不会掩盖意图。因此，他们编写了更多的扩展来使应用逻辑更加简洁。私有扩展通常在其他地方也很有用，因此他们将它们移到了可以轻松共享的公共模块中。这使得在应用程序的其他部分使用可选数据变得更容易，从而导致他们编写了更多的扩展，从而使应用逻辑更加简洁……依此类推。
- en: Although extensions are promoted as a way to extend third-party types, the concise
    naming they allow, and nullability in the type system, encourage us to define
    extensions on our own types as well. Part of the grain of Kotlin is the way these
    features interact to smooth our way.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管推广扩展作为扩展第三方类型的一种方法，允许的简洁命名和类型系统中的可空性，鼓励我们也在自己的类型上定义扩展。Kotlin 的一部分是这些特性如何交互以平滑我们的道路。
- en: Nullable Receivers
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可空接收器
- en: One major difference between invoking a method and calling a function is in
    the treatment of `null` references. If we have a reference that is `null`, we
    can’t send a message to it, because there is nothing to send a message to—the
    JVM throws a `Null​Poin⁠terException` if we try. In contrast, we are able to have
    `null` *parameters*. We may not know what to do with them, but they don’t prevent
    the runtime from finding code to invoke.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 调用方法和调用函数之间的一个主要区别在于对 `null` 引用的处理方式。如果我们有一个 `null` 引用，我们不能向其发送消息，因为没有任何对象可以发送消息——如果我们尝试，JVM
    会抛出 `Null​Poin⁠terException`。相反，我们可以拥有 `null` *参数*。我们可能不知道如何处理它们，但它们并不妨碍运行时找到要调用的代码。
- en: Because the receiver in an extension function is actually a parameter, it *can*
    be `null`. So while `anObject.method()` and `anObject.extensionFunction()` look
    like equivalent calls, `method` can never be called if `anObject` is `null`, whereas
    `extensionFunction` can be called with `null`, if the receiver is nullable.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因为扩展函数中的接收器实际上是一个参数，它*可以*为 `null`。因此，虽然 `anObject.method()` 和 `anObject.extensionFunction()`
    看起来是等效的调用，但如果接收器可空，`method` 永远无法被调用，而 `extensionFunction` 可以在接收器可空时被调用。
- en: 'We could use this to extract out the steps that generate the reminder in the
    previous pipeline, into an extension on `Trip?`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用这一点，在 `Trip?` 的扩展中提取出生成前一个流水线中提醒的步骤：
- en: '[PRE23]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note that we have to use the safe-call operator to dereference `this` inside
    the extension. Although `this` is never `null` inside a method, it can be inside
    an extension of a nullable type. A `null` `this` can be surprising if you’re coming
    from Java, where it can never happen, but for extensions, Kotlin treats `this`
    as just another nullable parameter.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们必须使用安全调用操作符来解引用扩展中的 `this`。虽然 `this` 在方法中从不为 `null`，但在可空类型的扩展中，它可能为 `null`。如果你从
    Java 转到 Kotlin，`null` 的 `this` 可能会让人感到意外，因为在 Java 中这是不可能发生的，但对于扩展而言，Kotlin 将 `this`
    视为另一个可空参数。
- en: 'We can call this function on a nullable `Trip` without the noise of the `?.`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在可空的 `Trip` 上调用这个函数，而不需要使用 `?.` 的噪音：
- en: '[PRE24]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: On the other hand, we’ve made the flow of nullability in the calling function
    harder to understand, because although type-checked, it is not visible in the
    code of the pipelines that calls the extension.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们使调用函数中的空值流程更难理解，因为虽然经过类型检查，但在调用扩展的流水线代码中看不到它。
- en: '`Trip?.reminderAt` has another, more obtrusive, drawback: the return type is
    always the nullable `String?` even if called on a nonnullable `Trip`. In that
    case we will find ourselves writing code like:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`Trip?.reminderAt` 有另一个更显眼的缺点：即使在非空 `Trip` 上调用，返回类型始终是可空的 `String?`。在这种情况下，我们将会写出这样的代码：'
- en: '[PRE25]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This a bug waiting to happen when code around it changes, because we’ve made
    it impossible for the type checker to detect an incompatible change.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当周围的代码发生变化时，这是一个等待发生错误的bug，因为我们使得类型检查器无法检测到不兼容的更改。
- en: Tip
  id: totrans-95
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Don’t write extensions on nullable types that return `null` if the receiver
    is `null`. Write an extension on the nonnullable type and use the safe-call operator
    to invoke it.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在可空类型上编写返回`null`的扩展函数，如果接收器为`null`。请在非可空类型上编写扩展，并使用安全调用运算符来调用它。
- en: 'Extensions on nullable types can be useful though, when they return a nonnullable
    result. They act as an escape route from the realm of nullable values back to
    the realm of nonnullable values, terminating a pipeline of safe calls. For example,
    we can make the `reminderAt` extension return some meaningful text even when the
    customer doesn’t have a next trip:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在返回非空结果时，可空类型的扩展可以很有用。它们充当了从可空值的领域返回非可空值的逃逸路径，终止了安全调用的管道。例如，我们可以使`reminderAt`扩展即使客户没有下次旅行时也返回一些有意义的文本：
- en: '[PRE26]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Similarly, here are two extension functions that we probably should have introduced
    in [Chapter 4](ch04.html#optional-to-nullable). The first is defined on any nullable
    type, but always returns a nonnull result:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，在这里有两个扩展函数，我们可能应该在[第4章](ch04.html#optional-to-nullable)中引入。第一个是在任何可空类型上定义的，但始终返回非空结果：
- en: '[PRE27]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This neatly brings up the subject of generic extensions.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好地提出了通用扩展的主题。
- en: Generics
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型
- en: Just as with normal functions, extensions can have generic parameters, and things
    become really interesting when the receiver is generic.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 就像普通函数一样，扩展函数可以有泛型参数，当接收器是泛型时，事情变得非常有趣。
- en: 'Here’s a useful extension function that for some reason isn’t part of the standard
    library. It is defined as an extension on any type, including `null` references:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有用的扩展函数，因某种原因不是标准库的一部分。它被定义为在任何类型上的扩展，包括`null`引用：
- en: '[PRE28]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can use this when we want to debug the value of an expression in place.
    For example, remember this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要在原地调试表达式的值时，我们可以使用这个：
- en: '[PRE29]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If we need to see the value of the customer for debugging, we would normally
    need to pull out a variable:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要查看客户的值以进行调试，通常需要提取一个变量：
- en: '[PRE30]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'With `printed`, we have a function that prints the value of the receiver and
    returns it unchanged, so that we can write:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 有了`printed`，我们有一个打印接收器值并返回它的函数，这样我们就可以写：
- en: '[PRE31]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: which is much less disruption and easy to search for before we check in.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这比较少干扰，易于在提交前进行搜索。
- en: 'Note that even if we had been able to add a method to `Any?`, there is no way
    for a method to say that it returns the same type as its receiver. Had we written:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，即使我们能够为`Any?`添加方法，也没有办法让方法表明它返回与其接收器相同的类型。如果我们写过：
- en: '[PRE32]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: the return type would have been `Any`, so we could not then invoke `nameForMarketing()`
    etc. on the result.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型本来会是`Any`，所以我们无法在结果上调用`nameForMarketing()`等。
- en: 'We can also define extension functions for specialized generic types, for example,
    `Iterable<Customer>`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以为特殊的泛型类型定义扩展函数，例如，`Iterable<Customer>`：
- en: '[PRE33]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This extension function is applicable to any `Collection<Customer>` but not
    to collections of other types. This allows us to use collections to represent
    domain concepts rather than defining our own types, as we will see in [Chapter 15](ch15.html#encapsulated-collections-to-typealiases).
    We can also extract parts of collections pipelines into named operations; see
    [“Extracting Part of a Pipeline”](ch13.html#extracting-part-of-a-pipeline).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个扩展函数适用于任何`Collection<Customer>`，但不适用于其他类型的集合。这使我们能够使用集合来表示领域概念，而不是定义我们自己的类型，正如我们将在[第15章](ch15.html#encapsulated-collections-to-typealiases)中看到的那样。我们还可以将集合管道的部分提取为命名操作；参见[“提取管道的一部分”](ch13.html#extracting-part-of-a-pipeline)。
- en: Extension Functions as Methods
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展函数作为方法
- en: 'We normally define extension functions as top-level functions. They can, though,
    be defined *inside* a class definition. In this case they can access the members
    of their own class and *extend* another type:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，我们将扩展函数定义为顶层函数。不过，它们也可以*在*类定义内部定义。在这种情况下，它们可以访问其自身类的成员，并*扩展*另一个类型：
- en: '[PRE34]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here `Customer.toJson` has access to two values of `this`. It can refer to
    the `Customer` receiver of the extension function or the `JsonWriter` instance
    of the method. In longhand, the function is:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这里`Customer.toJson`可以访问两个值的`this`。它可以引用扩展函数的`Customer`接收器或方法的`JsonWriter`实例。详细写出来，该函数是：
- en: '[PRE35]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This isn’t a technique that we should use too often (it can be hard to interpret
    which receiver applies without IDE assistance), but it can simplify code by allowing
    the simple left-to-right reading of extension functions while hiding details that
    would complicate things. In particular, it allows DSLs to hide details (like the
    `ObjectMapper`) that clients shouldn’t be bothered by.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是我们应该经常使用的技术（没有IDE的帮助很难解释哪个接收者适用），但它可以通过允许简单的从左到右阅读扩展函数来简化代码，同时隐藏那些会使事情复杂化的细节。特别是它允许DSL隐藏客户端不应被打扰的细节（比如`ObjectMapper`）。
- en: Refactoring to Extension Functions
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构为扩展函数
- en: The actual mechanics of converting a static method to an extension function
    are simple, but we have to hone a sense for where an extension function will make
    things better. Let’s work our way through a part of Travelator and see how we
    do.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 将静态方法转换为扩展函数的实际机制很简单，但我们必须培养一种感觉，看看哪里可以用扩展函数让事情变得更好。让我们逐步完成一部分Travelator，看看我们的表现如何。
- en: 'Those clever people in marketing have come up with a spreadsheet that gives
    customers a score according to how valuable they are to the company: their expected
    future spending. They’re constantly tweaking the algorithm, so they don’t want
    us to automate that. Instead, they export a tab-separated file of customer data,
    score, and spend, and we produce a summary report from that file. Here are our
    tests:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 市场部的聪明人设计了一张电子表格，根据客户对公司的预期未来支出来评分，他们不断调整算法，因此不希望我们自动化这一过程。相反，他们导出一个以制表符分隔的客户数据、分数和支出文件，我们从中生成摘要报告。以下是我们的测试：
- en: '[PRE36]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[Example 10.1 [extensions.0:src/test/java/travelator/marketing/HighValueCustomersReportTests.java]](https://java-to-kotlin.dev/code.html?ref=10.1&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.1&show=diff)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 10.1 [extensions.0:src/test/java/travelator/marketing/HighValueCustomersReportTests.java]](https://java-to-kotlin.dev/code.html?ref=10.1&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.1&show=diff)'
- en: You can see that we haven’t gone to town on these, because the people in marketing
    do have a habit of changing their minds, but in essence the report needs to list
    the customers who have a score of 10 or more, sorted by spend, with a final total
    line.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们没有在这些上大动干戈，因为市场部的人有改变主意的习惯，但报告的本质是需要列出得分为10或更高的客户，按支出排序，并附带总计行。
- en: 'Here is the code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代码：
- en: '[PRE37]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[Example 10.2 [extensions.0:src/main/java/travelator/marketing/HighValueCustomersReport.java]](https://java-to-kotlin.dev/code.html?ref=10.2&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.2&show=diff)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 10.2 [extensions.0:src/main/java/travelator/marketing/HighValueCustomersReport.java]](https://java-to-kotlin.dev/code.html?ref=10.2&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.2&show=diff)'
- en: You can see that this is already quite a functional (as opposed to object-oriented)
    expression of the solution. This will make it easy to convert to top-level functions,
    and top-level functions are easy to convert to extension functions.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这已经是相当功能性的（而不是面向对象的）解决方案。这将使其易于转换为顶级函数，而顶级函数易于转换为扩展函数。
- en: 'But first, here is `CustomerData`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，这是`CustomerData`：
- en: '[PRE38]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[Example 10.3 [extensions.0:src/main/java/travelator/marketing/CustomerData.java]](https://java-to-kotlin.dev/code.html?ref=10.3&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.3&show=diff)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 10.3 [extensions.0:src/main/java/travelator/marketing/CustomerData.java]](https://java-to-kotlin.dev/code.html?ref=10.3&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.3&show=diff)'
- en: This isn’t trying to represent everything about a customer, just the data we
    care about for this report, which is why whoever wrote it just used fields. ([Chapter 11](ch11.html#methods-to-properties)
    discusses this trade-off.) I doubt we (erm, whoever wrote it) would even have
    bothered with `equals` and `hashCode` had it not been for the `emptySpendIs0`
    test. That `double` for spend looks suspicious too, but it hasn’t caused us any
    problems yet, so we’ll suspend our disbelief and just convert the whole thing
    to a Kotlin data class (see [Chapter 5](ch05.html#beans-to-values)) before we
    go on.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不试图代表客户的所有信息，只是我们在此报告中关心的数据，这就是为什么编写它的人只使用了字段。([第11章](ch11.html#methods-to-properties)讨论了这种权衡。)
    我怀疑我们（呃，写这个的人）如果不是因为`emptySpendIs0`测试，甚至可能都不会费事写`equals`和`hashCode`。支出的`double`看起来也有点可疑，但目前还没有引起任何问题，所以我们会暂时置之不理，然后将整个东西转换为Kotlin数据类（参见[第5章](ch05.html#beans-to-values)）再继续。
- en: 'Normally, that would be a really simple job because of the excellent interop,
    but it turns out that (at the time of writing) the converter cannot believe that
    anyone would stoop to raw field access. So it doesn’t update Java that accesses,
    for example, `customerData.score` to call `customerData.getScore()` (the Kotlin
    property), resulting in a slew of compile failures. Rather than fixing those,
    we revert, and use the “Encapsulate Fields” refactor to convert all the fields
    and field accesses in `Customer` to getters:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，由于出色的互操作性，这本来是一件非常简单的工作，但事实证明（在撰写本文时），转换器无法相信有人会屈服于原始字段访问。因此，它不会更新 Java 的访问，例如
    `customerData.score`，以调用 `customerData.getScore()`（Kotlin 属性），导致大量编译错误。与其修复这些问题，我们回退，并使用“封装字段”重构将
    `Customer` 中的所有字段和字段访问转换为获取器：
- en: '[PRE39]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[Example 10.4 [extensions.1:src/main/java/travelator/marketing/CustomerData.java]](https://java-to-kotlin.dev/code.html?ref=10.4&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.4&show=diff)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 10.4 [extensions.1:src/main/java/travelator/marketing/CustomerData.java]](https://java-to-kotlin.dev/code.html?ref=10.4&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.4&show=diff)'
- en: 'The refactoring has also updated the client code to call the getters:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 重构还更新了客户端代码以调用获取器：
- en: '[PRE40]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[Example 10.5 [extensions.1:src/main/java/travelator/marketing/HighValueCustomersReport.java]](https://java-to-kotlin.dev/code.html?ref=10.5&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.5&show=diff)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 10.5 [extensions.1:src/main/java/travelator/marketing/HighValueCustomersReport.java]](https://java-to-kotlin.dev/code.html?ref=10.5&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.5&show=diff)'
- en: 'The getters allow us to convert `CustomerData` to a Kotlin data class without
    breaking the Java. “Convert Java File to Kotlin File”, followed by adding the
    `data` modifier and deleting the `equals` and `hashCode` overrides, gives us:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 获取器使我们能够将 `CustomerData` 转换为 Kotlin 数据类，而不会破坏 Java。“将 Java 文件转换为 Kotlin 文件”，然后添加
    `data` 修饰符并删除 `equals` 和 `hashCode` 覆盖，我们得到：
- en: '[PRE41]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[Example 10.6 [extensions.2:src/main/java/travelator/marketing/CustomerData.kt]](https://java-to-kotlin.dev/code.html?ref=10.6&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.6&show=diff)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 10.6 [extensions.2:src/main/java/travelator/marketing/CustomerData.kt]](https://java-to-kotlin.dev/code.html?ref=10.6&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.6&show=diff)'
- en: 'Now we can go ahead and convert `HighValueCustomerReport` to Kotlin, too; it’s
    entirely self-contained. That doesn’t go brilliantly, because `customerDataFrom`
    doesn’t compile after the conversion:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以继续将 `HighValueCustomerReport` 转换为 Kotlin，因为它是完全自包含的。这并不顺利，因为转换后 `customerDataFrom`
    无法编译：
- en: '[PRE42]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[Example 10.7 [extensions.3:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.7&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.7&show=diff)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 10.7 [extensions.3:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.7&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.7&show=diff)'
- en: '[![1](assets/1.png)](#co_introduction_CO18-1)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_introduction_CO18-1)'
- en: '`The integer literal does not conform to the expected type Double`.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`整数文字不符合预期的 Double 类型`。'
- en: '[![2](assets/2.png)](#co_introduction_CO18-2)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_introduction_CO18-2)'
- en: Odd formatting.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 奇怪的格式化。
- en: 'The converter hasn’t been smart enough to know that Kotlin doesn’t coerce the
    integer 0 to double, leading to a compile error. Let’s help IntelliJ out by clicking
    the error and Alt-Entering to fix it, in the hope that it will return the favor
    when the machines rule the world. After a reformat, this gives us:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 转换器没有足够聪明，不知道 Kotlin 不会将整数 0 强制转换为 double，导致编译错误。让我们点击错误并使用 Alt-Enter 修复它，希望在机器统治世界时它也会回报。重新格式化后，我们得到：
- en: '[PRE43]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[Example 10.8 [extensions.4:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.8&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.8&show=diff)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 10.8 [extensions.4:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.8&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.8&show=diff)'
- en: As we discussed in [Chapter 8](ch08.html#static-methods-to-top-level-functions),
    the conversion has placed the functions into an `object HighValueCustomersReport`
    so that Java code can still find them. If we try to convert them to top-level
    functions using the techniques in that chapter, we find that dependencies between
    the methods mean that the code doesn’t compile at times. We can solve the problem
    either by moving the private methods first or by just ignoring the compiler until
    the `HighValueCustomersReport` is emptied and removed.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第8章](ch08.html#static-methods-to-top-level-functions)中讨论的那样，这些转换将函数放置在
    `object HighValueCustomersReport` 中，以便 Java 代码仍然能找到它们。如果我们尝试使用该章节中的技术将它们转换为顶级函数，我们会发现方法之间的依赖关系有时导致代码无法编译。我们可以通过先移动私有方法或者暂时忽略编译器直到
    `HighValueCustomersReport` 被清空和移除来解决这个问题。
- en: '[PRE44]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[Example 10.9 [extensions.5:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.9&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.9&show=diff)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[例子 10.9 [extensions.5:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.9&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.9&show=diff)'
- en: 'OK, it’s time to look for places where extension functions can improve the
    code. At the end is the `marketingNameFor` that we saw (a slightly different version
    of) earlier. If we Alt-Enter on the `customer` parameter, IntelliJ will offer
    to “Convert parameter to receiver”. This gives:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，现在是时候寻找可以改进代码的扩展函数的地方了。在末尾是我们之前看到的 `marketingNameFor`（稍微不同版本）。如果我们在 `customer`
    参数上按 Alt-Enter，IntelliJ 将提供“将参数转换为接收者”。这给出：
- en: '[PRE45]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[Example 10.10 [extensions.6:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.10&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.10&show=diff)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '[例子 10.10 [extensions.6:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.10&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.10&show=diff)'
- en: 'That `For` in `marketingNameFor` is confusing now that we’ve moved the parameter
    to be the receiver, because the `For` doesn’t have a subject. Let’s “Convert function
    to property” named `marketingName` ([Chapter 11](ch11.html#methods-to-properties)
    explains how and why) and then “Convert to expression body”. Oh, and “Convert
    concatenation to template” on both strings! Phew, that flurry of Alt-Entering
    gives:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `marketingNameFor` 中的 `For` 有点混乱，因为我们将参数移动为接收者，所以 `For` 没有主语。让我们“将函数转换为名为
    `marketingName` 的属性”（[第11章](ch11.html#methods-to-properties) 解释了如何以及为什么），然后“转换为表达式体”。哦，并且在两个字符串上都使用“转换为模板连接”。哇，这一连串的
    Alt-Enter 操作给出了：
- en: '[PRE46]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[Example 10.11 [extensions.7:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.11&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.11&show=diff)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[例子 10.11 [extensions.7:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.11&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.11&show=diff)'
- en: 'Now `formatMoney` is letting us down, so again we can “Convert parameter to
    receiver”, rename to `toMoneyString`, and “Convert to expression body”:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `formatMoney` 让我们失望了，所以我们可以再次“将参数转换为接收者”，重命名为 `toMoneyString`，并“转换为表达式体”：
- en: '[PRE47]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[Example 10.12 [extensions.8:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.12&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.12&show=diff)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[例子 10.12 [extensions.8:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.12&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.12&show=diff)'
- en: 'The `String.format` rankles a bit. Kotlin would allow us to write `"%#.2f".format(this)`,
    but we prefer swapping the parameter and receiver to give:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`String.format` 有点让人不舒服。Kotlin 允许我们写 `"%#.2f".format(this)`，但我们更喜欢交换参数和接收者以获得：'
- en: '[PRE48]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[Example 10.13 [extensions.9:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.13&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.13&show=diff)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[例子 10.13 [extensions.9:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.13&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.13&show=diff)'
- en: '`Double.formattedAs` is the first extension function we’ve written that had
    a parameter as well as its receiver. That’s because the others have been very
    specific conversions, but this one is more general. While we’re thinking general,
    `formattedAs` can equally well apply to any type, including `null`, so we can
    upgrade it to:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`Double.formattedAs` 是我们编写的第一个带有参数的扩展函数。这是因为其他函数一直都是非常具体的转换，但这一个更通用。在考虑通用性时，`formattedAs`
    同样可以应用于任何类型，包括 `null`，因此我们可以升级它为：'
- en: '[PRE49]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[Example 10.14 [extensions.10:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.14&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.14&show=diff)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 10.14 [extensions.10:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.14&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.14&show=diff)'
- en: It now feels like a good candidate for moving into our library of generally
    useful Kotlin functions.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在感觉很适合移入我们的通用Kotlin函数库。
- en: 'Next, `customerDataFrom` is in our sights. It is currently:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们关注`customerDataFrom`。目前是这样的：
- en: '[PRE50]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[Example 10.15 [extensions.11:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.15&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.15&show=diff)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 10.15 [extensions.11:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.15&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.15&show=diff)'
- en: Before we go on, let’s observe that `CharSequence.split()`, `String.toRegex()`,
    `Collection<T>.toTypedArray()`, `String.toDouble()`, and `String.toInt()` are
    all extension functions provided by the Kotlin standard library.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们观察一下`CharSequence.split()`，`String.toRegex()`，`Collection<T>.toTypedArray()`，`String.toDouble()`和`String.toInt()`都是Kotlin标准库提供的扩展函数。
- en: 'There’s a lot we can tidy up before we address the signature of `customerDataFrom`.
    Kotlin has a `CharSequence.split(delimiters)` that we can use in place of the
    regex. Then we can inline `spend`, followed by Alt-Enter and “Add names to call
    arguments” to help make sense of the constructor call:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们解决`customerDataFrom`签名之前，有很多可以整理的工作。Kotlin 提供了`CharSequence.split(delimiters)`可以替代正则表达式。然后我们可以内联`spend`，按下Alt-Enter，然后选择“添加名称以调用参数”，以帮助理解构造函数调用：
- en: '[PRE51]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[Example 10.16 [extensions.12:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.16&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.16&show=diff)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 10.16 [extensions.12:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.16&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.16&show=diff)'
- en: '[Chapter 9](ch09.html#multi-to-single-expression-functions) argues in favor
    of single-expression functions. This certainly doesn’t *need* to be a single expression,
    but let’s practice anyway:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[第9章](ch09.html#multi-to-single-expression-functions)主张支持单表达式函数。这当然不是*必须*是单表达式，但让我们练习一下：'
- en: '[PRE52]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[Example 10.17 [extensions.13:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.17&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.17&show=diff)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 10.17 [extensions.13:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.17&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.17&show=diff)'
- en: 'At last, we can get around to converting to an extension function. Again we
    change the name (to `toCustomerData`) to make sense at the call site:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以开始转换为扩展函数了。同样，我们将名称更改为`toCustomerData`以使调用站点有意义：
- en: '[PRE53]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[Example 10.18 [extensions.14:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.18&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.18&show=diff)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 10.18 [extensions.14:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.18&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.18&show=diff)'
- en: 'Note that the Java in our tests can still call this as a static method:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的测试中的Java仍然可以调用此方法作为静态方法：
- en: '[PRE54]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[Example 10.19 [extensions.14:src/test/java/travelator/marketing/HighValueCustomersReportTests.java]](https://java-to-kotlin.dev/code.html?ref=10.19&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.19&show=diff)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 10.19 [extensions.14:src/test/java/travelator/marketing/HighValueCustomersReportTests.java]](https://java-to-kotlin.dev/code.html?ref=10.19&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.19&show=diff)'
- en: 'Now let’s address `summaryFor`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来处理`summaryFor`：
- en: '[PRE55]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[Example 10.20 [extensions.15:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.20&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.20&show=diff)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 10.20 [extensions.15:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.20&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.20&show=diff)'
- en: 'That destructuring is odd, but we can get rid of it by hand-converting the
    stream to Kotlin. This isn’t a thing that IntelliJ can do when we wrote this,
    but we give guidance in [Chapter 13](ch13.html#streams-to-sequences). We’ll remove
    the string concatenation while we’re there:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 那个解构有点奇怪，但我们可以手动将流转换为Kotlin来摆脱它。当我们编写时，IntelliJ 无法完成此操作，但我们在[第13章](ch13.html#streams-to-sequences)中提供了指导。我们将同时移除字符串连接：
- en: '[PRE56]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[Example 10.21 [extensions.16:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.21&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.21&show=diff)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 10.21 [extensions.16:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.21&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.21&show=diff)'
- en: 'Now the familiar combination of converting to an appropriately named single-expression
    extension function:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们熟悉的组合转换为一个合适命名的单表达式扩展函数：
- en: '[PRE57]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[Example 10.22 [extensions.17:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.22&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.22&show=diff)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 10.22 [extensions.17:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.22&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.22&show=diff)'
- en: 'At this stage, only `generate` is left unimproved:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，只有 `generate` 还没有改进：
- en: '[PRE58]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[Example 10.23 [extensions.18:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.23&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.23&show=diff)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 10.23 [extensions.18:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.23&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.23&show=diff)'
- en: 'Again, we currently have to convert Java streams to Kotlin list operations
    by hand:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们目前必须手动将 Java 流转换为 Kotlin 列表操作：
- en: '[PRE59]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[Example 10.24 [extensions.19:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.24&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.24&show=diff)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 10.24 [extensions.19:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.24&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.24&show=diff)'
- en: '`Appendable.appendLine()` is another extension function that allows us to simplify
    the output stage:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`Appendable.appendLine()` 是另一个允许我们简化输出阶段的扩展函数：'
- en: '[PRE60]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[Example 10.25 [extensions.20:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.25&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.25&show=diff)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 10.25 [extensions.20:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.25&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.25&show=diff)'
- en: 'It feels like we should be able to remove that `// header` comment by extracting
    a function. [“Extracting Part of a Pipeline”](ch13.html#extracting-part-of-a-pipeline)
    details how to extract a function from a chain, but look at what happens when
    we try that technique but don’t convert `withoutHeader` to an extension function:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 感觉我们应该能够通过提取函数来移除 `// header` 注释。[“从流中提取部分”](ch13.html#extracting-part-of-a-pipeline)详细说明了如何从链中提取函数，但是当我们尝试该技术时，未将
    `withoutHeader` 转换为扩展函数时会发生什么：
- en: '[PRE61]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[Example 10.26 [extensions.21:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.26&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.26&show=diff)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 10.26 [extensions.21:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.26&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.26&show=diff)'
- en: 'We’ve lost the nice pipeline flow from left to right, top to bottom: `withoutHeader`
    comes before the `readLines` in the text but after it in execution order. Alt-Enter
    on the `list` parameter in `withoutHeader` and “Convert Parameter to Receiver”
    restores the flow:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们丢失了从左到右，从上到下的流水线流畅性：`withoutHeader` 在文本中的顺序在执行顺序中位于 `readLines` 之前但在其后。在 `withoutHeader`
    中的 `list` 参数上使用“Convert Parameter to Receiver”可恢复流畅性：
- en: '[PRE62]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[Example 10.27 [extensions.22:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.27&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.27&show=diff)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 10.27 [extensions.22:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.27&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.27&show=diff)'
- en: 'We can make this even more expressive with two more extensions, `List<String>.​to⁠Val⁠uableCustomers()`
    and `CustomerData.outputLine`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过两个额外的扩展函数使这更加表达，`List<String>.to⁠Val⁠uableCustomers()` 和 `CustomerData.outputLine`：
- en: '[PRE63]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[Example 10.28 [extensions.23:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.28&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.28&show=diff)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 10.28 [extensions.23:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.28&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.28&show=diff)'
- en: 'This still isn’t quite as sweet as we might like, but we’ve proved the point
    of extension functions. Chapters [20](ch20.html#performing-io-to-passing-data)
    and [21](ch21.html#exceptions-to-values) will complete this refactoring. In the
    meantime, here’s the whole file:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然不如我们所希望的那样甜美，但我们已经证明了扩展函数的观点。[第 20 章](ch20.html#performing-io-to-passing-data)和[第
    21 章](ch21.html#exceptions-to-values)将完成此重构。与此同时，这是整个文件：
- en: '[PRE64]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[Example 10.29 [extensions.23:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.29&show=file)
    [(diff)](https://java-to-kotlin.dev/code.html?ref=10.29&show=diff)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 10.29 [extensions.23:src/main/java/travelator/marketing/HighValueCustomersReport.kt]](https://java-to-kotlin.dev/code.html?ref=10.29&show=file)
    [(差异)](https://java-to-kotlin.dev/code.html?ref=10.29&show=diff)'
- en: Note that every function except the entry point is a single-expression extension
    function. We haven’t made `generate` an extension function because there isn’t
    a natural parameter to make the receiver; it doesn’t feel like a natural operation
    on `Reader` or `Writer`. That may change when we continue refactoring this code
    in [Chapter 20](ch20.html#performing-io-to-passing-data). Let’s see, shall we?
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，除入口点外的每个函数都是单表达式扩展函数。我们没有将 `generate` 定义为扩展函数，因为没有自然的参数可以作为接收器；它在 `Reader`
    或 `Writer` 上不像一个自然的操作。当我们在[第 20 章](ch20.html#performing-io-to-passing-data)中继续重构此代码时，这可能会改变。我们拭目以待，对吗？
- en: Moving On
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继续前进
- en: Extension functions and properties are the unsung heroes of the Kotlin language.
    Their canonical use is to add operations to types we cannot modify ourselves.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展函数和属性是 Kotlin 语言中不为人知的英雄。它们的典型用途是为我们无法自行修改的类型添加操作。
- en: However, Kotlin language features and tooling combine to encourage us—quite
    insistently—to write extension functions for our *own* types as well. Kotlin’s
    safe call operator makes it more convenient to call an extension function through
    a potentially null reference than to pass the reference to a function as a parameter
    when it is nonnull. The type of a freestanding generic extension can express relationships
    between the receiver and its result that cannot be expressed by open methods.
    Autocompletion in IntelliJ includes extension functions along with the methods
    that can call on a value, but it does not show you functions that you can pass
    the value to as a parameter.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Kotlin 语言的特性和工具结合起来，坚定地鼓励我们为我们*自己*的类型编写扩展函数。Kotlin 的安全调用运算符使通过潜在的空引用调用扩展函数比将引用传递给非空函数作为参数更加方便。独立的通用扩展的类型可以表达接收器与其结果之间的关系，这是无法通过开放方法表达的。在
    IntelliJ 中，自动补全会将扩展函数与可以调用值的方法一起显示，但不会显示您可以将值传递给的函数作为参数。
- en: As a result, extension functions allow us to write code that is more easily
    discovered, understood, and maintained. Many of the other techniques presented
    in this book build on extension functions, as we will see in [Chapter 15, *Encapsulated
    Collections to Type Aliases*](ch15.html#encapsulated-collections-to-typealiases),
    [Chapter 18, *Open to Sealed Classes*](ch18.html#open-to-sealed-classes), and
    others.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，扩展函数使我们能够编写更容易发现、理解和维护的代码。这本书中提出的许多其他技术都是基于扩展函数的，我们将在[第 15 章，*封装集合到类型别名*](ch15.html#encapsulated-collections-to-typealiases)，[第
    18 章，*从开放到密封类*](ch18.html#open-to-sealed-classes)等章节中看到。
