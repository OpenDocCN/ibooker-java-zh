- en: Chapter 3\. Travel Light on Your Pathway
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章  轻装上路
- en: He who would travel happily must travel light.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 欲望旅行愉快者，必先轻装上路。
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Antoine de Saint-Exupéry
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 圣埃克絮佩里
- en: 'In the last chapter, you built a microservices-based system, and we also showed
    you some migration steps from an existing application. But the challenge with
    all examples is that they remove complexity for the sake of easier understandability.
    What might seem clear for smaller examples becomes challenging with real business
    systems. In particular, think about complex legacy systems. As outlined in the
    first chapter, technologies and methodologies developed over the years have led
    to today’s best practices and tools to develop modern enterprise systems. Just
    because our industry now has a more extensive toolbox with shiny new things to
    work with doesn’t mean you should always use them. If you think about this and
    our growing number of frameworks, methodologies, and technologies, one question
    becomes more pressing: What tools and architecture should you use for your next
    system, and how and where will you run them? Before you can decide, you need to
    think a bit about the most prominent architectural styles that have emerged for
    enterprise applications in the last couple of years (Three-tier, Enterprise Integration,
    service-oriented architecture, microservices, and event-driven architecture).'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您构建了一个基于微服务的系统，并且我们还向您展示了从现有应用程序迁移的一些步骤。但是所有示例的挑战在于它们为了更易于理解而删除了复杂性。对于较小的示例来说可能很清晰的事情，但在实际的业务系统中变得具有挑战性。特别是，请考虑复杂的遗留系统。正如第一章概述的那样，多年来开发的技术和方法已经导致了今天用于开发现代企业系统的最佳实践和工具。仅仅因为我们的行业现在拥有了更广泛的工具箱，可以使用闪亮新东西来工作，并不意味着您应该总是使用它们。如果您考虑到这一点以及我们日益增长的框架、方法和技术的数量，那么一个问题变得更加紧迫：对于您的下一个系统，您应该使用什么工具和架构，以及您将如何在何处运行它们？在您做出决定之前，您需要对过去几年中出现的最突出的企业应用程序架构风格进行一些思考（三层架构、企业集成、面向服务架构、微服务和事件驱动架构）。
- en: Three-Tier or Distributed System
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 三层或分布式系统
- en: 'The Enterprise Java world is dominated by monolithic applications. They often
    are designed as single execution units that scale with server instances and clustering
    functionality. They are also often referred to as “Three-tier systems” to reflect
    the three main parts they are composed of: a client-side user interface, a server-side
    business logic implementation, and server-side data Persistence or Integration
    layer. The server-side parts are called a “monolith” since they are packaged as
    a single large executable. Any changes to the system typically involve building
    and deploying a new version.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 企业 Java 世界主要由单片应用程序所主导。它们通常被设计为随服务器实例和群集功能扩展的单一执行单元。它们也经常被称为“三层系统”，以反映它们由三个主要部分组成：客户端用户界面、服务器端业务逻辑实现和服务器端数据持久性或集成层。服务器端部分被称为“单体”，因为它们被打包为单个大型可执行文件。对系统的任何更改通常都涉及构建和部署新版本。
- en: Tip
  id: totrans-7
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Learn more about building microservices in [Sam Newman’s excellent book *Building
    Microservices* (O’Reilly)](https://oreil.ly/JZqsr), now in its second edition.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 了解更多关于构建微服务的信息，请参阅 [Sam Newman 的杰出著作 *Building Microservices*（O’Reilly）](https://oreil.ly/JZqsr)，目前已经推出第二版。
- en: A microservices-based architecture is an approach to developing a single application
    as a suite of small services, each of them running in its own process and communicating
    with lightweight mechanisms, often an HTTP resource API or as part of an event-driven
    architecture (EDA). These services are built around business capabilities and
    are independently deployable by fully automated deployment machinery. There is
    a bare minimum of centralized management of these services, which may be written
    in different programming languages and use different data storage technologies.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 基于微服务的架构是开发单个应用程序的一种方法，将其作为一套小型服务的集合，每个服务在自己的进程中运行，并使用轻量级机制进行通信，通常是 HTTP 资源
    API 或作为事件驱动架构（EDA）的一部分。这些服务围绕业务能力构建，并且可以通过完全自动化的部署机制独立部署。这些服务的集中管理最小化，它们可能是用不同的编程语言编写的，并且使用不同的数据存储技术。
- en: The difference between the monolithic and microservice styles can’t be more
    fundamental. And so are the nonfunctional requirements leading to the choice of
    one. The most critical requirements result from extremely flexible scaling scenarios.
    As an experienced developer and architect, you know how to evaluate functional
    and nonfunctional requirements to conclude your specific project. In this chapter,
    we will help you navigate your migration approach and target platform. Your journey
    starts by looking at the motivation for modernization. Let’s take a deeper look
    at what makes us think about modernization in general and where to start looking
    for opportunities.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 单体架构和微服务风格之间的差异可以说是根本性的。同样的，非功能性需求也决定了采用哪种架构风格。最关键的需求源于极其灵活的扩展场景。作为一名经验丰富的开发者和架构师，您知道如何评估功能和非功能需求，以确定您具体项目的最佳选择。在本章中，我们将帮助您制定迁移策略和目标平台。您的旅程始于审视现代化的动机。让我们深入探讨一下普遍的现代化动机以及寻找机会的起点。
- en: Technology Updates, Modernization, and Transformation
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术更新、现代化和转型
- en: Enterprise software is developed to put business value into code that can be
    executed within nonfunctional and functional requirements. Creating value depends
    on our ability to deliver applications quickly. Not only with better quality but
    also ready to be changed quickly, enabling businesses to respond to new challenges
    or regulatory changes in the market. And these challenges are multifaceted. First,
    you address scaling challenges with cloud native applications to handle bigger
    transaction volumes. New business cases will also require you to analyze data
    further and might be solved by artificial intelligence (AI) and machine learning
    (ML). And last but not least, our interconnected world generates more data from
    the Internet of Things (IoT). What might read like it is a natural progression
    of architectures isn’t. In fact, the evolving business requirements drive modernization
    and architectural evolution by changing functional and nonfunctional requirements.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 企业软件的开发旨在将业务价值转化为能够在非功能性和功能性需求内执行的代码。创造价值取决于我们快速交付应用程序的能力。不仅要提高质量，而且要快速响应变化，使企业能够应对市场上的新挑战或监管变化。而这些挑战是多方面的。首先，您通过云原生应用程序解决扩展挑战，以处理更大的交易量。新的业务案例还将要求您进一步分析数据，并可能通过人工智能（AI）和机器学习（ML）来解决。最后但同样重要的是，我们互联互通的世界从物联网（IoT）产生更多数据。从架构上看似乎是自然的进展，但实际上，不断变化的业务需求通过改变功能和非功能性需求来推动现代化和架构演进。
- en: Aditionally, you will find operational concerns influencing modernization needs.
    For example, expiring maintenance contracts or outdated technologies can drive
    technology updates. The continuously evolving Java language with the shortened
    release cycles can also influence modernization decisions. Modernization can happen
    at any level of your project, ranging from the execution environment (e.g., virtual
    machines to container) to the Java Virtual Machine (JVM version or vendor), individual
    dependencies, external interfaces, and services.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还会发现操作上的考虑在影响现代化需求方面起到了作用。例如，过期的维护合同或过时的技术可能促使技术更新。随着Java语言不断发展和缩短的发布周期，也会影响现代化决策。现代化可以发生在项目的任何层次，从执行环境（例如虚拟机到容器）到Java虚拟机（JVM版本或供应商）、个别依赖项、外部接口和服务。
- en: It is essential to distinguish between three different angles to modernization
    here. While the *technology updates* within existing processes and boundaries
    are a familiar and well-established challenge for software projects, modernization
    refers to something else. Often paired with the word “digital,” the term *modernization*
    refers to adopting new technology. It involves upgrading systems, platforms, and
    software with new functionality. It can be as simple as taking an existing paper-based
    process and turning it digital using new software and hardware, or more complex,
    such as phasing out existing infrastructure and moving to the cloud. Sometimes
    you’ll also hear *transformation* when someone talks about modern systems. Digital
    transformation means taking advantage of modern technology to reimagine an organization’s
    processes, culture, people, and customer experiences. It can result in new business
    models, revenue streams, policies, and values. Transformation is somewhat of a
    holistic lens into an organization with a clear focus to fundamentally change
    business performance. Modernization is embedded and becomes the centerpiece that
    software developers and architects need to navigate.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，区分现代化的三个不同角度至关重要。虽然在现有流程和边界内进行的技术更新对软件项目来说是一个熟悉且早已建立的挑战，但现代化涉及的是另一种事物。通常与“数字化”一词搭配使用，“现代化”一词指的是采用新技术。它涉及使用新功能升级系统、平台和软件。可以是简单的将现有的纸质流程转变为使用新软件和硬件的数字流程，也可以是更复杂的任务，例如逐步淘汰现有基础设施并转移到云端。有时您会在讨论现代系统时听到“转型”。数字化转型意味着利用现代技术重新构想组织的流程、文化、人员和客户体验。它可能导致新的商业模型、收入流、政策和价值观。转型是一个对组织进行全面审视的镜头，专注于从根本上改变业务绩效。现代化被内嵌并成为软件开发人员和架构师需要导航的核心。
- en: Despite your project-specific reasons to take the first step in modernizing
    your application, it is essential to remember that modernization itself does not
    carry any particular mandates for specific target environments or technologies.
    It is an ever-changing and growing set of candidate technologies that enable companies
    to compete and grow in their industry. You can find some of them in technology
    trend reports (e.g., the [ThoughtWorks Technology Radar](https://oreil.ly/SWvEH))
    or on hype cycles ([Gartner Hype Cycle](https://oreil.ly/JT4jE)). But as you’ve
    seen in the first chapter, two of the strongest motivations to constantly innovate
    are speed and cost pressure. Both are addressed by a modern, cloud native, microservices-based
    architecture.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管您在现代化应用程序的首要步骤中有项目特定的原因，但必须记住，现代化本身并不对特定目标环境或技术有任何特定的要求。它是一组不断变化和增长的候选技术，使公司能够在其行业中竞争和成长。您可以在技术趋势报告（例如，[ThoughtWorks
    技术雷达](https://oreil.ly/SWvEH)）或炒作周期（[Gartner 炒作周期](https://oreil.ly/JT4jE)）中找到其中一些。但正如您在第一章中看到的那样，持续创新的两个最强动力是速度和成本压力。现代化、云原生和基于微服务的架构都能解决这两个问题。
- en: The 6 Rs
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: The 6 Rs
- en: Now that you’ve learned the motivation behind application modernization, you
    want to identify general approaches to modernization and define a categorization
    for existing applications. Doing this helps you manage a variety of different
    applications, especially in a platform modernization project. Rather than looking
    at the details of a single application, consider the complete runtime architecture
    of traditional Enterprise Java applications. In that case, you’ll commonly identify
    on-premise hardware, which is usually virtualized and made available to projects
    via an individual set of instances. Given that individual projects are rarely
    treated as islands without any integrated systems, you get to a situation where
    a coordinated approach for more than just one project needs to be found.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了应用现代化背后的动机，您希望确定现代化的一般方法，并为现有应用程序定义分类。这样做有助于您管理各种不同的应用程序，特别是在平台现代化项目中。与查看单个应用程序的细节不同，考虑传统企业
    Java 应用程序的完整运行时架构。在这种情况下，您通常会识别出本地硬件，这些硬件通常是虚拟化的，并通过一组单独的实例提供给项目使用。鉴于很少有单个项目被视为没有任何集成系统的孤立岛屿，您需要找到一个协调的方法，来处理不止一个项目的情况。
- en: Let’s first have a look at what the 6 Rs are and where the concept comes from.
    Essentially, you can think of each “R” as an available migration strategy for
    your applications. Each strategy indicates a clear outcome for a transformed application,
    but not necessarily the actual migration steps to take. The concept was first
    [mentioned by the Gartner analyst Richard Watson](https://oreil.ly/tk08O) in 2011\.
    The five original strategies—namely Rehost, Refactor, Revise, Rebuild, and Replace—were
    revived and adapted in a [popular blog post](https://oreil.ly/CAalp) by Stephen
    Orban of AWS in 2016\. Orban kept some of Gartner’s strategies and added a new
    one. Thus, the 5 Rs became the 6 Rs. Today, the 6 Rs are used as a fundamental
    guideline for almost any cloud transformation. Although there are still disputes
    about whether further strategies should be added, and you can even find 7 Rs,
    we stick to the 6 Rs in this book as shown in [Figure 3-1](#fig3-2).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看看6个R是什么，以及这个概念的来源。基本上，您可以将每个“R”看作是应用程序可用的迁移策略。每种策略都表示转换后应用程序的明确结果，但不一定是实际的迁移步骤。这个概念最初由Gartner分析师Richard
    Watson在2011年提到。最初的五种策略——即重新主机化、重构、修改、重建和替换——在2016年由AWS的Stephen Orban在一篇流行的博客文章中进行了修订和适应。Orban保留了一些Gartner的策略，并添加了一个新的策略。因此，5个R变成了6个R。今天，这6个R被用作几乎任何云转型的基本指南。尽管对是否应该添加更多策略仍然存在争议，甚至可以找到7个R，但在本书中我们坚持使用6个R，如图3-1所示。
- en: '![Six ways to classify your existing applications](Images/moej_0301.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![分类现有应用程序的六种方法](Images/moej_0301.png)'
- en: Figure 3-1\. Six modernization approaches, an overview of the 6 Rs
  id: totrans-20
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-1。六种现代化方法，6个R的概述
- en: Retain—Modernize later or not at all
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保留-稍后或根本不进行现代化
- en: Everyone has heard the stereotypical story of a mainframe in the basement of
    some very well-known company, where all of its business secrets are stored. Oftentimes,
    these mainframes are programmed in CICS (Customer Information Control System,
    a family of mixed-language application servers that provide online transaction
    management and connectivity for applications on IBM mainframe systems) and the
    data is stored in IMS (IBM Information Management System, an early database).
    And this isn’t necessarily a bad thing. Maybe the existing system is a perfect
    fit for the business and does not need to participate in a modernization project.
    In order to correctly scope your transformation and modernization efforts, you
    need to identify those systems and omit them from the modernization process. Systems
    with this classification need a particular integration approach that needs to
    be explicitly designed. Imagine a highly scalable mobile application backend that
    connects directly to a mainframe. In this scenario, the requests from the potentially
    many mobile devices would overload the costly mainframe. Retain, in this case,
    does not mean “untouched” but rather “not moved.”
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 每个人都听过一个著名公司地下室里的大型机的刻板故事，那里存储了所有商业机密。这些大型机通常以CICS（客户信息控制系统，一系列混合语言应用服务器，为IBM大型机系统上的在线事务管理和连接提供支持）编程，并且数据存储在IMS（IBM信息管理系统，一种早期的数据库）中。这并不一定是件坏事。也许现有系统非常适合业务，并且不需要参与现代化项目。为了正确确定转型和现代化工作的范围，您需要识别这些系统并将其排除在现代化进程之外。这类系统需要一种特定的集成方法，需要明确设计。想象一下，一个高度可扩展的移动应用后端直接连接到大型机上。在这种情况下，来自可能众多移动设备的请求会过载昂贵的大型机。在这种情况下，“保留”并不意味着“不动”，而是意味着“不迁移”。
- en: Retire—Turn system off
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关闭系统-关闭系统
- en: Some candidates may clearly have reached end-of-life and are already migrated
    and replaced or just a relic that isn’t needed going forward. Travel light and
    make sure to flag these systems. Subsequent housekeeping is as equally essential
    as building new things. Investing time to validate and decide on retiring a system
    is as valuable as a redesign would be.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 有些候选人可能已经显然到达了生命周期的终点，已经迁移并替换，或者仅仅是一个未来不再需要的遗物。轻装前行，并确保标记这些系统。后续的清理工作与建设新事物同样重要。投入时间来验证并决定退役一个系统的价值，与重新设计同样宝贵。
- en: Repurchase—Buy new version
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重新购买-购买新版本
- en: In some cases, you can repurchase off-the-shelf software and get it ready made
    for a new execution environment. That sounds straightforward but will most likely
    include a migration project and reevaluation of feature lists, mostly because
    it is unlikely that you can update without changing the product version or its
    APIs. In some rare cases, you might even find missing integration documentation
    to be a blocker. This is why it is essential to treat this as a modernization
    project and not as a simple software update.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您可以重新购买现成的软件并为其新的执行环境做好准备。这听起来很简单，但很可能需要包括迁移项目和重新评估功能列表，主要是因为您不太可能在不更改产品版本或其API的情况下进行更新。在一些罕见的情况下，您甚至可能会发现缺失的集成文档成为一个阻碍因素。这就是为什么将其视为现代化项目而不是简单的软件更新至关重要的原因。
- en: Rehost—Put into containers
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重新托管—放入容器中
- en: Often referred to as “lift and shift,” one option for containerizing an application
    is to simply port the existing architecture as-is to run inside of a container.
    While this can be as simple as it sounds, there are some challenges on the way.
    In particular, there can be difficulties when it comes to optimizing the JVM for
    constrained container runtimes. Some existing middleware application servers come
    with their vendor-supported base images and make it convenient to switch runtimes.
    Particular focus should be placed on storage for stateful application runtimes.
    Java application servers require some data to survive container restarts and require
    persistent volume mappings. Transactions, load balancing, and in-memory session
    replication need extended configurations to ensure correct shutdown behavior and
    node communication. Plan for sufficient research and testing and make sure to
    adhere to the vendor recommendations. This step is addressing infrastructure modernization
    and not concerned with application code directly. Existing applications that qualify
    for such an approach are those that need to move to a container runtime before
    a refactoring can occur or as an interim step toward switching data center concepts.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通常称为“提升和迁移”的一种选项是将现有架构简单地移植到容器内运行。尽管这听起来很简单，但在实施过程中可能会遇到一些挑战。特别是在优化JVM以适应受限容器运行时时可能会遇到困难。一些现有的中间件应用服务器配备了供应商支持的基础镜像，使切换运行时变得更加便捷。对于有状态应用程序运行时，应重点关注存储。Java应用服务器需要一些数据在容器重新启动时保留，并需要持久卷映射。事务、负载平衡和内存会话复制需要扩展配置以确保正确的关闭行为和节点通信。计划充分的研究和测试，并确保遵循供应商的建议。此步骤解决的是基础设施现代化问题，并不直接涉及应用程序代码。符合此方法的现有应用程序是那些需要在重构之前或在切换数据中心概念的中间步骤之前移至容器运行时的应用程序。
- en: Note
  id: totrans-29
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Martin Fowler coined the term [“strangler pattern”](https://oreil.ly/0otPb)
    as a way to extract functionality out of a monolithic application. It is named
    after the Australian strangler figs that grow roots from seeds in the upper branches
    until they touch the ground.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Martin Fowler创造了术语[“strangler pattern”](https://oreil.ly/0otPb)，作为从单片应用中提取功能的一种方法。它以澳大利亚的勒死榕树为名，后者会从树枝上的种子生长根直至触及地面。
- en: Replatform—Make some slight adjustments
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重新平台化—进行轻微调整
- en: As an extension to rehosting, replatforming categorizes applications that undergo
    a conceptual or functional change while switching runtimes. It can also be referred
    to by its own “lift” name variation, “lift and adjust.” It can be related to a
    strangled functionality, which might be implemented on top of a new technology
    stack or a change in data storage or integration systems. We recommend using this
    approach as an initial step toward refactoring and decoupling a monolithic application.
    Prepending this step leads to smoother operations executing on subsequent extensions
    and decoupling stages. By choosing to replatform, you are allowing a gentle start
    to modernizing your applications and pragmatically evolving them.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 作为重新托管的延伸，重新平台化将经历概念或功能变化的应用程序分类为运行时切换。它也可以按照其“lift”名称变体，“提升和调整”进行引用。它可能与被勒死的功能相关联，后者可能在新技术堆栈上实现，或者在数据存储或集成系统中进行更改。我们建议将此方法用作重构和解耦合单片应用程序的初始步骤。在以下扩展和解耦合阶段执行时，通过在此步骤前加入重新平台化，可以实现更顺畅的操作。选择重新平台化，您正在为现代化应用程序和务实演化提供温和的起始。
- en: Refactor—Build new
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重构—建立新的
- en: '[Refactoring](https://refactoring.com) is a disciplined technique for restructuring
    an existing body of code, altering its internal structure without changing its
    external behavior. Refactoring is the most time-consuming and costly way to move
    existing applications onto a new runtime or platform. It may or may not include
    a switch to different architecture styles or on-premise or cloud hosting.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[重构](https://refactoring.com)是一种有纪律的技术，用于重构现有代码库，改变其内部结构而不改变其外部行为。重构是将现有应用程序迁移到新的运行时或平台上最耗时和昂贵的方式。它可能包括或不包括切换到不同的架构风格或本地或云主机。'
- en: Divide and Containerize
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分割和容器化
- en: Now that we have looked at different modernization strategies for existing applications,
    and we know how and when to apply them. It is time to think about other prerequisites
    for our target platform.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看过了现有应用程序的不同现代化策略，也知道如何何时应用它们。是时候考虑我们目标平台的其他先决条件了。
- en: Kubernetes as the New Application Server?
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes作为新的应用服务器？
- en: The word “platform” in the Enterprise Java world normally refers to the application
    server. Application servers follow a guardrailed software development approach
    with standardized APIs. The vertical layers are defined by what is commonly refered
    to as technical layers of a three-tier system. Presentation on top of business
    on top of data access and/or integration. Horizontally to this we usually find
    business components or domains. While the vertical layers are usually well separated
    and decoupled, it is common to find shared classess and violated access rules
    between the horizontal components. If this happens frequently across the code
    base, we talk about entangled designs that turn into unmaintainable monoliths
    over time. But no matter how entangled the application code is, it still profits
    from the standard application server functionalities addressing nonfunctional
    and functional requirements like security, isolation, fault tolerance, transaction
    management, configuration management, etc.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: “平台”一词在企业Java世界中通常指应用服务器。应用服务器遵循有保护栏的软件开发方法，具有标准化的API。垂直层次由通常被称为三层系统技术层的内容定义。在顶部是业务，下面是数据访问和/或集成。水平地，我们通常会找到业务组件或领域。虽然垂直层通常是良好分离和解耦的，但在水平组件之间通常会发现共享类和违反的访问规则。如果这种情况在代码库中频繁发生，我们称之为纠缠设计，随着时间的推移会变成难以维护的单块。但无论应用代码多么纠缠，它仍从标准应用服务器功能中受益，这些功能包括安全性、隔离、容错、事务管理、配置管理等。
- en: 'If we fast-forward to distributed architectures of today, where applications
    consist of many small services, we observe two things: there is no longer a shortcut
    to a good component design, and the standard application server features are no
    longer available to our components.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们快进到今天的分布式架构，应用程序由许多小服务组成，我们会观察到两件事：没有捷径可以获得良好的组件设计，标准应用服务器功能不再适用于我们的组件。
- en: The first observation leads to a mandatory requirement. Distributed services
    have to be well designed, loosely coupled, and strongly encapsulated components.
    We will talk more about design principles and approaches for modernizing monoliths
    in [Chapter 5](ch05.xhtml#beyond_lift_and_shift). The second observation holds
    a list of missing funcionalities in cloud native runtimes. If an application server
    isn’t providing support for commonly used functionalities like we mentioned, there
    are only two places left. One can be the microservices framework of choice (e.g.,
    Quarkus), and another one could be additional frameworks or products on top of
    Kubernetes.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个观察结果导致了一个强制性要求。分布式服务必须是设计良好、松耦合和强封装的组件。我们将在[第5章](ch05.xhtml#beyond_lift_and_shift)更多地讨论现代化单块的设计原则和方法。第二个观察结果列出了云原生运行时中缺失的功能清单。如果一个应用服务器不提供像我们提到的常用功能的支持，那么只剩下两个选择。一个可以是微服务框架的选择（例如Quarkus），另一个可能是基于Kubernetes的附加框架或产品。
- en: Let’s take a detailed look at some of the most critical functionalities needed
    in the following chapters. We call them *microservicilities*. The term refers
    to a list of cross-cutting concerns that a service must implement apart from the
    business logic to resolve these concerns as summarized in [Figure 3-2](#fig3-3).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在接下来的章节中详细查看一些最关键的功能需求。我们称它们为*微服务能力*。这个术语指的是除了业务逻辑外，一个服务必须实现的一系列横切关注点，以解决这些问题，如[图3-2](#fig3-3)所总结的。
- en: '![Microservicilities for distributed applications](Images/moej_0302.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![分布式应用程序的微服务化](Images/moej_0302.png)'
- en: Figure 3-2\. Microservicilities for distributed applications
  id: totrans-43
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-2。分布式应用程序的微服务化
- en: Discovery and configuration
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发现和配置
- en: Container images are immutable. Storing configuration options inside them for
    different environments or stages is discouraged. Instead, the configuration has
    to be externalized and configured by instance. An externalized configuration is
    also one of the critical principles of cloud native applications. Service discovery
    is one way to get configuration information from the runtime environment instead
    of being hardcoded in the application. Other approaches include using ConfigMaps
    and Secrets. Kubernetes provides service discovery out of the box, but this might
    not be sufficient for your application needs. While you can manage the environment
    settings for each runtime environment through YAML files, additional UIs or CLIs
    can make it easier for DevOps teams to share responsibility.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像是不可变的。在其内部存储不同环境或阶段的配置选项是不被鼓励的。相反，配置必须被外部化并通过实例进行配置。外部化配置也是云原生应用程序的关键原则之一。服务发现是从运行时环境获取配置信息的一种方式，而不是硬编码在应用程序中。其他方法包括使用
    ConfigMaps 和 Secrets。Kubernetes 提供开箱即用的服务发现，但这可能不足以满足您的应用程序需求。虽然您可以通过 YAML 文件管理每个运行时环境的环境设置，但额外的用户界面或命令行界面可以使
    DevOps 团队更轻松地共享责任。
- en: Basic invocation
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本调用
- en: Applications running inside containers are accessed through Ingress controllers.
    Ingress exposes HTTP and HTTPS routes from outside the cluster to services within
    the cluster. Traffic routing is controlled by rules defined on the Ingress resource.
    Traditionally, this can be compared with Apache HTTP-based load balancers. Other
    alternatives include projects like [HAProxy](http://www.haproxy.org) or Nginx.
    You can use the routing capabilities to do rolling deployments as the basis for
    a sophisticated CI/CD strategy. For one-time jobs, such as batch processes, Kubernetes
    provides job and cron-job functionality.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器内运行的应用程序通过 Ingress 控制器访问。Ingress 公开从集群外部到集群内部服务的 HTTP 和 HTTPS 路由。流量路由由在 Ingress
    资源上定义的规则控制。传统上，这可以与基于 Apache HTTP 的负载均衡器进行比较。其他替代方案包括像 [HAProxy](http://www.haproxy.org)
    或 Nginx 的项目。您可以利用路由能力来进行滚动部署，作为复杂 CI/CD 策略的基础。对于像批处理这样的一次性作业，Kubernetes 提供了作业和定时作业功能。
- en: Elasticity
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 弹性
- en: 'Kubernetes’s ReplicaSets control scaling of pods. It is a way to reconcile
    a desired state: you tell Kubernetes what state the system should be in so it
    can figure out how to reach the outcome. A ReplicaSet controls the number of replicas,
    or exact copies, of a container that should be running at any time. What sounds
    like a largely static operation can be automated. The Horizontal Pod Autoscaler
    scales the number of pods based on observed CPU utilization. It is possible to
    use a custom metric or almost any other application-provided metric as input.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 的 ReplicaSets 控制 pod 的扩展。这是一种协调期望状态的方式：你告诉 Kubernetes 系统应该处于什么状态，以便它能够确定如何达到预期结果。ReplicaSet
    控制容器的副本数量，即任何时候应该运行的确切副本或拷贝数量。听起来像是一个大部分静态操作的东西可以被自动化。水平 Pod 自动缩放器基于观察到的 CPU 利用率来调整
    pod 数量。可以使用自定义指标或几乎任何其他由应用程序提供的指标作为输入。
- en: Logging
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 日志
- en: One of the more challenging aspects of a distributed application is the correlation
    of logs from each active part. This is an area where the difference from traditional
    application servers becomes very visible because it used to be so simple and isn’t
    in the new world. Storing them individually, per container, is not recommended
    because you lose sight of the bigger picture and have a hard time debugging side
    effects and root causes for issues. There are various approaches to this, with
    most of them extensively using the [ELK](https://oreil.ly/XflXI) ([Elasticsearch](https://oreil.ly/FKoKx),
    [Logstash](https://oreil.ly/YLtNc), [Kibana](https://oreil.ly/h2nIX)) stack or
    a variant. In those stacks, Elasticsearch is the object store, where all logs
    are stored. Logstash gathers logs from nodes and feeds them to Elasticsearch.
    Kibana is the web UI for Elasticsearch, which is used to search the aggregated
    log files from various sources.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式应用程序中较具挑战性的一个方面是每个活动部分日志的相关性。这是一个区别于传统应用服务器非常显著的领域，因为过去它非常简单，而在新世界中并非如此。不建议单独存储每个容器的日志，因为这样会失去整体视野，难以调试副作用和问题的根本原因。有各种方法处理这个问题，其中大多数都广泛使用[ELK](https://oreil.ly/XflXI)（[Elasticsearch](https://oreil.ly/FKoKx)、[Logstash](https://oreil.ly/YLtNc)、[Kibana](https://oreil.ly/h2nIX)）堆栈或其变体。在这些堆栈中，Elasticsearch
    是对象存储，存储所有日志。Logstash 收集来自节点的日志并将其提供给 Elasticsearch。Kibana 是 Elasticsearch 的 Web
    UI，用于搜索来自各种来源的聚合日志文件。
- en: Monitoring
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 监控
- en: Monitoring in a distributed application is an essential ingredient to make sure
    all of the bits and pieces continue working. In contrast to logging, monitoring
    is an active observation often paired with alerting rather than simply recording
    events. [Prometheus](https://prometheus.io) is the de facto standard for storing
    the generated information. Essentially, it is a complete open source monitoring
    system that includes a time-series database. Prometheus’s web UI gives you access
    to metric querying, alerting, and visualizations and helps you gain insights into
    your systems.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式应用程序中，监控是确保所有部分持续工作的重要组成部分。与日志记录相比，监控是主动观察，通常与警报配对，而不仅仅是记录事件。[Prometheus](https://prometheus.io)
    是存储生成信息的事实标准。它实质上是一个完整的开源监控系统，包括时间序列数据库。Prometheus 的 Web UI 允许您访问指标查询、警报和可视化，帮助您深入了解系统。
- en: Build and deployment pipelines
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建和部署管道
- en: CI/CD (Continuous Integration/Continuous Delivery) isn’t anything new to Enterprise
    Java applications or distributed applications. As a good software development
    practice, every production code should follow a strict and automated release cycle.
    With a potentially large number of services that compose an application, the automation
    should at least aim for 100% coverage. Traditionally a job for the open source
    tool [Jenkins](https://www.jenkins.io), modern container platforms have moved
    away from a centralized build system and embrace a distributed approach to CI/CD.
    One example is [Tekton](https://tekton.dev). The goal is to create reliable software
    releases through build, test, and deployment. We dig deeper into this in [Chapter 4](ch04.xhtml#kubernetes_based_softw_dev_platform).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: CI/CD（持续集成/持续交付）对于企业 Java 应用程序或分布式应用程序并不新鲜。作为良好的软件开发实践，每个生产代码都应遵循严格的自动化发布周期。由于一个应用可能包含大量服务，自动化至少应该达到
    100% 的覆盖率。传统上由开源工具[Jenkins](https://www.jenkins.io)处理这些工作，现代容器平台已经摒弃了集中式构建系统，转向了分布式
    CI/CD 的方法。一个例子是[Tekton](https://tekton.dev)。其目标是通过构建、测试和部署创建可靠的软件发布。我们在[第四章](ch04.xhtml#kubernetes_based_softw_dev_platform)深入探讨了这一点。
- en: Resilience and fault tolerance
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 韧性和容错性
- en: Psychologists define “resilience” as the process of adapting well in the face
    of adversity, trauma, tragedy, threats, or significant sources of stress. In distributed
    applications, it is the concept of recovering from failure or load scenarios without
    human interaction. Kubernetes provides resilience options for the cluster itself,
    but only sparsely supports application resiliency and fault tolerance. For example,
    application-level resiliency can be facilitated through PersistentVolumes that
    support replicated volumes or with ReplicaSets ensuring a consistent number of
    pod replicas across the cluster. On an application level, there is resilience
    and fault-tolerance support through Istio or various frameworks like [Cloudstate](https://cloudstate.io).
    You want to use features such as retry rules, circuit breaker, and pool ejection.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 心理学家将“韧性”定义为在逆境、创伤、悲剧、威胁或重大压力来源面前适应良好的过程。在分布式应用程序中，这意味着在没有人为干预的情况下从失败或负载场景中恢复。Kubernetes
    为集群本身提供了韧性选项，但只零星支持应用程序的韧性和容错性。例如，可以通过支持复制卷的 PersistentVolumes 或确保集群中的 Pod 副本数量一致的
    ReplicaSets 来促进应用程序级的韧性。在应用程序级别，可以通过 Istio 或像 [Cloudstate](https://cloudstate.io)
    这样的各种框架来支持韧性和容错性。你可能会使用诸如重试规则、断路器和池摘除等功能。
- en: Note
  id: totrans-58
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '[Istio](https://istio.io) is an open source service mesh that layers transparently
    onto existing distributed applications. It is also a platform, including APIs
    that integrate into any logging platform, telemetry, or policy system.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '[Istio](https://istio.io) 是一个开源的服务网格，可透明地叠加到现有的分布式应用程序上。它还是一个平台，包括集成到任何日志平台、遥测或策略系统的
    API。'
- en: Security
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全
- en: Authentication or Authorization between services is not part of Kubernetes itself.
    There are two ways to implement it. Using Istio, each service is provided with
    a strong identity that represents its role and enables interoperability across
    clusters and clouds. It secures service-to-service communication, as well as providing
    a key management to automate key and certificate generation, distribution, rotation,
    and revocation. A more application-centric alternative can be to use a single-sign-on
    component like [Keycloak](https://www.keycloak.org) or relying on [Eclipse MicroProfile
    JSON Web Token](https://oreil.ly/bVETR) (JWT).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 本身不包括服务之间的身份验证或授权。有两种实现方式。使用 Istio，每个服务都提供了一个强身份，代表其角色，并支持跨集群和云的互操作性。它保护了服务与服务之间的通信，并提供了一个关键管理来自动化密钥和证书的生成、分发、旋转和吊销。一个更加应用程序中心的替代方案是使用类似
    [Keycloak](https://www.keycloak.org) 这样的单点登录组件，或依赖于 [Eclipse MicroProfile JSON
    Web Token](https://oreil.ly/bVETR) (JWT)。
- en: Tracing
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 追踪
- en: Tracing gives you a way to follow request paths and events throughout the system
    across individual application parts by still allowing you to trace back to an
    origin. You can find different approaches across the community today. Independent
    of languages, frameworks, or technologies you intend to use, Istio can enable
    distributed tracing. There are other commercial and open source projects available
    helping with distributed tracing across your application components. [Zipkin](https://zipkin.io)
    and [Jaeger](https://www.jaegertracing.io) are two possible solutions.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 追踪为你提供了一种通过追踪回到起源的方式跟踪系统中的请求路径和事件，跨越个别应用程序部分。今天，你可以在社区中找到不同的方法。与你打算使用的语言、框架或技术无关，Istio
    可以实现分布式追踪。还有其他商业和开源项目可用于帮助跨应用程序组件进行分布式追踪。[Zipkin](https://zipkin.io) 和 [Jaeger](https://www.jaegertracing.io)
    是两种可能的解决方案。
- en: Define Your Target Platform
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义目标平台
- en: 'It’s important to note that the nine elements mentioned previously are focused
    on application development and do not capture all the necessities of a modern
    container platform. Just looking at this narrow focus leaves important areas unaddressed.
    A container platform needs to provide features and capabilities for the complete
    team from Dev to Ops. Depending on specific needs, there is no one-size-fits-all
    solution. A comprehensive way to define your target platform is to start with
    the three main layers: Core, Customer Experience, and Integration, then build
    your application landscape on an optimized technology stack. What sounds like
    a ready-to-use checklist is anything but. Companies are different in culture,
    technologies, and requirements, and the following lists are a recommended starting
    point without any claim to comprehensiveness. We recommend using the bullet points
    as evaluation categories and defining the individual functional and nonfunctional
    requirements underneath with a fulfillment score from zero (not available) to
    three (fully supported) with a middle score of two (can make it work) as a medium
    evaluation. Finally, add weighting logic to it to reach a complete evaluation
    based on a product comparison. It can be the core framework for a direct product
    versus do-it-yourself (DIY) comparison and also the starting point for the platform
    documentation.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，前面提到的九个元素侧重于应用程序开发，并没有涵盖现代容器平台的所有必需品。仅仅看这个狭隘的焦点会忽略重要的领域。容器平台需要为从开发到运维的完整团队提供功能和能力。根据具体需求，没有一种一刀切的解决方案。定义目标平台的综合方法是从核心、客户体验和集成三个主要层面开始，然后在优化的技术栈上构建应用程序景观。听起来像一个可直接使用的检查表，但实际上并非如此。公司在文化、技术和需求方面各不相同，以下列表仅作为建议的起点，没有宣称全面性。我们建议将项目作为评估类别使用，并定义个别功能和非功能需求，根据从零（不可用）到三（完全支持）的满足评分，中间得分为二（可行），作为中等评估。最后，根据产品比较添加加权逻辑以达到完整评估。它可以作为直接产品与自主实施（DIY）比较的核心框架，并且也是平台文档的起点。
- en: Define the core
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义核心部分
- en: 'Start with evaluating the core part of the platform. This category includes
    basic capabilities like container orchestration, storage mapping, rolling upgrades,
    site reliability engineering (SRE) requirements, out-of-the-box support for the
    desired deployment models, and might even include further support for virtual
    machines. This category represents the technical foundation for your target platform:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 从评估平台的核心部分开始。此类别包括基本功能，如容器编排，存储映射，滚动升级，站点可靠性工程（SRE）要求，对所需部署模型的开箱即用支持，甚至可能包括对虚拟机的进一步支持。这一类别代表了目标平台的技术基础：
- en: Existing core capabilities
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现有的核心能力
- en: Functional gap assessment
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能差距评估
- en: Hybrid-cloud support
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合云支持
- en: Security integration
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全集成
- en: Managed services support
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理服务支持
- en: Operators/marketplace available (e.g., [OperatorHub](https://operatorhub.io),
    [Red Hat Marketplace](https://oreil.ly/sFuDg))
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用的运营商/市场（例如，[OperatorHub](https://operatorhub.io)，[Red Hat Marketplace](https://oreil.ly/sFuDg)）
- en: Available support levels
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用的支持级别
- en: Target deployment model
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标部署模型
- en: Core modernization approach
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心现代化方法
- en: Define the customer experience layer
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义客户体验层
- en: 'When thinking about platforms, one part gets too little attention: the customer
    experience layer, which contains a technical definition for the customer channels
    to the platform. A channel can be one of the B2X (business to something) portals
    or various other specific frontends. A cohesive platform that can host various
    applications also needs to include a clear definition for the technical composition
    of the individual services:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑平台时，有一个部分得到了太少的关注：客户体验层，其中包含对平台客户通道的技术定义。通道可以是 B2X（业务到某些东西）门户或其他特定的前端。一个完整的平台可以托管各种应用程序，还需要包括对个别服务技术组成的清晰定义：
- en: Define customer-centric requirements
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义客户中心需求
- en: Assess existing cx framework versus build
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估现有的 CX 框架与构建之间的差异
- en: Micro frontends (e.g., [Entando](https://dev.entando.org))
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微前端（例如，[Entando](https://dev.entando.org)）
- en: Integration requirements
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成需求
- en: Data gap analysis
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据差距分析
- en: Mobile support
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动支持
- en: Define the integration
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义集成
- en: 'In a containerized world, integration becomes a new challenge. Coming from
    a traditional enterprise landscape, it has either been a centralized solution
    (Enterprise Service Bus or similar) or been part of the individual applications
    using some common integration framework like Apache Camel. Neither approach fits
    perfectly into a stateless container-oriented platform. What you are looking for
    in a target platform is the smooth integration between messaging components, data
    transformation logic, and service integration. All the relevant parts need to
    scale well in a stateless environment for distributed systems, and it should be
    easy to extend a composed application with new capabilities:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器化的世界中，集成成为一个新的挑战。从传统的企业景观出发，集成通常是一个集中的解决方案（企业服务总线或类似的），或者是各个应用程序的一部分，使用类似
    Apache Camel 的某些常见集成框架。这两种方法都不完全适合于无状态容器导向的平台。在目标平台中，您寻找的是消息组件、数据转换逻辑和服务集成之间的无缝集成。所有相关部分都需要在分布式系统的无状态环境中良好地扩展，并且应该可以轻松地通过新功能扩展组合的应用程序：
- en: Existing integration capabilities
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现有的集成能力
- en: Evaluate partner solution ecosystem
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估合作伙伴解决方案生态系统
- en: Define integration requirements (data sources, service integration, messaging,
    APIs)
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义集成需求（数据源、服务集成、消息传递、API）
- en: Define standards and frameworks (e.g., [Camel K](https://oreil.ly/kfXw1))
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义标准和框架（例如，[骆驼K](https://oreil.ly/kfXw1)）
- en: Evaluate serverless/knative integration (e.g., Camel K)
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估无服务器/Knative 集成（例如 Camel K）
- en: Define the technology stack
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义技术栈
- en: 'The remaining category focuses on individual technologies and frameworks. Think
    of it as a blueprint repository defining the relevant technologies, services,
    and methodologies for a productive environment. An underestimated influence on
    the requirements in this category is the available development skill in an organization.
    With a traditional Enterprise Java background, it is not easy to completely switch
    to a reactive development approach and a stateless application design. Also, familiarity
    with existing APIs and time to productivity on a new platform play a crucial role
    in picking the most suitable technology stack:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余类别关注的是个别技术和框架。可以将其视为定义生产环境中相关技术、服务和方法论的蓝图存储库。在这一类别的需求中被低估的因素是组织中可用的开发技能。对于传统的企业
    Java 背景来说，完全转向反应式开发方法和无状态应用设计并不容易。此外，熟悉现有 API 并在新平台上提高生产力所需的时间在选择最合适的技术栈时起着至关重要的作用：
- en: Technology stack assessment across core, CX, and external services
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在核心、CX 和外部服务方面进行技术栈评估
- en: Microservices framework (e.g, Quarkus, Spring Boot)
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务框架（例如 Quarkus、Spring Boot）
- en: Implementation recommendation (reactive, imperative, message-driven, etc.)
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施建议（反应式，命令式，消息驱动等）
- en: Deployment model (IaaS, PaaS, hybrid)
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署模型（IaaS，PaaS，混合）
- en: Define target development platform
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义目标开发平台
- en: Development skills gap analysis
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发技能缺口分析
- en: After completing this assessment, you are well prepared for a journey to a containerized
    application platform. Next, you will need to map out and plan your containerization
    strategy.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此评估后，您将为迁移到容器化应用平台做好充分准备。接下来，您需要制定并计划您的容器化策略。
- en: Mandatory Migration Steps and Tools
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强制性迁移步骤和工具
- en: 'Following the basic assumption that you have an existing application landscape
    in place and cannot start everything as a green-field project, we emphasize moving
    existing applications into containers. Coming back to the 6 Rs from earlier, the
    first application you are taking a look at should fall into one of the following
    Rs: Rehost, Replatform, and Refactor ([Figure 3-3](#fig1-3)). While they look
    similar in their description, the most significant difference between the three
    approaches is business value versus migration time and cost.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循的基本假设是您已经有了现有的应用程序景观，不能将所有事情都作为全新项目开始。回顾之前的六个 R，您首先要考虑的应用程序应该属于以下几种 R 中的一种：重新托管（Rehost）、重新平台化（Replatform）和重构（Refactor）（[图
    3-3](#fig1-3)）。尽管它们在描述上看起来相似，但这三种方法之间最重要的区别在于业务价值与迁移时间及成本之间的平衡。
- en: '![Business value assesment](Images/moej_0303.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![业务价值评估](Images/moej_0303.png)'
- en: Figure 3-3\. Workload migration pattern
  id: totrans-104
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-3\. 工作负载迁移模式
- en: Which action to take and where to start modernizing depends on the application.
    While the concrete steps may vary, the first thing to identify is the correct
    candidates. Therefore, we need to analyze the existing applications, catalog them,
    and group them to assign them to the final migration pattern. The last step is
    to execute the individual migration projects.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 开始现代化的具体步骤和起点取决于应用程序。尽管具体步骤可能会有所不同，但首先要确定正确的候选者。因此，我们需要分析现有应用程序，进行目录分类，并将其分组以分配给最终的迁移模式。最后一步是执行各个迁移项目。
- en: Create an Application Portfolio
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建应用程序组合
- en: There are many ways to create such an application catalog or portfolio. And
    you most likely already have a way to select applications relevant for a certain
    business domain. If not, feel free to fast-forward to [Chapter 5](ch05.xhtml#beyond_lift_and_shift),
    where we talk about the [Konveyor project](https://oreil.ly/1wPUF).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这样一个应用程序目录或者组合的方法有很多种。你很可能已经有了一种方式来选择与某个业务领域相关的应用程序。如果没有，可以直接跳转到[第五章](ch05.xhtml#beyond_lift_and_shift)，我们在那里讨论了[Konveyor项目](https://oreil.ly/1wPUF)。
- en: Prepare for Big Things
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备迎接重大事务
- en: The most prestigious process in modernization is refactoring existing applications.
    For coverage of a proven method of transitioning an existing monolithic system
    to a microservice architecture, we recommend [*Monolith to Microservices*](https://oreil.ly/0x6oq)
    by Sam Newman (O’Reilly). While he walks you through a lot of different approaches
    and creates a detailed process for various situations, there are also simpler
    approaches, such as the one outlined by Brent Frye from the Software Engineering
    Institute at Carnegie Mellon University. His [approach to modularization](https://oreil.ly/YKYUY)
    of existing applications is a lot more generic. He recommends eight simple steps
    to break down the monolith. He focuses on components and component groups. *Components*
    are logical sets of data objects and the actions that the system performs on those
    objects. Component groups become what he calls *macroservices*. A macroservice
    is similar to a microservice with two primary differences. First, a macroservice
    may share the datastore with the legacy monolithic system or other macroservices.
    Second, unlike a microservice, a macroservice may provide access to multiple data
    objects. In the last step, the macroservices are decomposed further.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现代化中最负盛名的过程是重构现有应用程序。为了覆盖将现有单体系统转换为微服务架构的成熟方法，我们推荐Sam Newman的[*Monolith to Microservices*](https://oreil.ly/0x6oq)（O’Reilly）。虽然他向你展示了许多不同的方法，并为各种情况创建了详细的流程，但也有更简单的方法，比如卡内基梅隆大学软件工程研究所的Brent
    Frye提出的方法。他推荐了八个简单的步骤来拆分单体系统。他专注于组件和组件组。*组件*是逻辑数据对象集合及系统对这些对象执行的操作。组件组成了他所称的*宏服务*。宏服务与微服务类似，但有两个主要区别。首先，宏服务可能与遗留的单体系统或其他宏服务共享数据存储。其次，与微服务不同，宏服务可能提供对多个数据对象的访问。在最后一步，宏服务进一步分解。
- en: 'The logical steps to breaking down your monolith according to Frye are:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Frye拆分单体的逻辑步骤如下：
- en: Identify logical components.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定逻辑组件。
- en: Flatten and refactor components.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 平铺并重构组件。
- en: Identify component dependencies.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定组件依赖关系。
- en: Identify component groups.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定组件组。
- en: Create an API for a remote user interface.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为远程用户界面创建API。
- en: 'Migrate component groups to macroservices:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迁移组件组到宏服务：
- en: Move component groups to separate projects.
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将组件组移动到单独的项目中。
- en: Make separate deployments.
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行独立部署。
- en: Migrate macroservices to microservices.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将宏服务迁移到微服务。
- en: Repeat steps 6–7 until complete.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤6-7直到完成。
- en: This is also the more general recommendation from Chris Richardson. As he outlined
    in his [O’Reilly SACON London keynote](https://oreil.ly/CZn61) and many times
    after, he is looking for an incremental approach starting with the most promising
    functionality.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是Chris Richardson的更一般性建议。正如他在他的[O’Reilly SACON伦敦主题演讲](https://oreil.ly/CZn61)中概述的那样，他寻求一种从最有前途的功能开始的增量方法。
- en: Do it incrementally and repeat the extraction steps until the monolith is finally
    eliminated or the initial software delivery problems are solved as illustrated
    in [Figure 3-4](#fig3-4).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 逐步进行，并重复提取步骤，直到单体最终消除或解决初始软件交付问题，如[图3-4](#fig3-4)所示。
- en: '![Move functionality as long as necessary.](Images/moej_0304.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![移动功能，尽可能长。](Images/moej_0304.png)'
- en: Figure 3-4\. Moving monoliths to services over time by incrementally extracting
    them
  id: totrans-124
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-4. 逐步将单体架构移至服务的过程中，通过增量方式逐步提取它们
- en: 'The three approaches differ in depth, angle, and details. While Richardson
    talks about the most valuable functionality and focuses on extracting it first,
    Frye created a simple methodology that can be applied in all situations. Finally,
    Newman developed the most detailed handbook for various situations in a modernization
    journey. All three will be helpful on your personal journey. We are convinced,
    though, that the approach Richardson takes is the best starting point. What Thomas
    Huijskens said for data scientists is something we also strongly believe in: “The
    code you write is only useful if it is production code.”'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种方法在深度、角度和细节上有所不同。虽然理查德森谈论了最有价值的功能，并专注于首先提取它，弗莱创造了一种简单的方法论，可适用于所有情况。最后，纽曼为现代化旅程中的各种情况开发了最详细的手册。这三者对你的个人旅程都将有所帮助。然而，我们确信，理查德森采取的方法是最佳的起点。就像Thomas
    Huijskens对数据科学家说的那样，我们也坚信：“你编写的代码只有在成为生产代码时才有用。”
- en: Every modernization effort has to follow business requirements and support production
    functionality. Following this thought, the entire modernization project can only
    be successful if you identify the correct candidates.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 每一次现代化努力都必须遵循业务需求并支持生产功能。基于这一思路，只有当你确定了正确的候选者时，整个现代化项目才能成功。
- en: Summary
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter walked you through some basic definitions for migration strategies
    and showed you an evaluation path for the target development platform. We’ve looked
    at technical recommendations, and you now know how to assess existing applications
    for rehosting, replatforming, and refactoring.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了一些迁移策略的基本定义，并展示了目标开发平台的评估路径。我们已经看过技术建议，现在你知道如何评估现有应用程序以进行重新托管、重新平台化和重构。
