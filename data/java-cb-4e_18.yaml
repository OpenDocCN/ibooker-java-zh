- en: Chapter 18\. Using Java with Other Languages
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第18章。使用Java与其他语言
- en: 18.0 Introduction
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 18.0 介绍
- en: 'Java has several methods of running programs written in other languages. You
    can invoke a compiled program or executable script using `Runtime.exec()`, as
    I’ll describe in [Recipe 18.1](#javacook-otherlang-SECT-1). There is an element
    of system dependency here, because you can only run external applications under
    the operating system they are compiled for. Alternatively, you can invoke one
    of a number of scripting languages (or *dynamic languages*)—running the gamut:
    awk, bsh, Clojure, Ruby, Perl, Python, Scala—using `javax.script`, as illustrated
    in [Recipe 18.3](#javacook-otherlang-scripting). Or you can drop down to C level
    with Java’s *native code* mechanism and call compiled functions written in C/C++;
    see [Recipe 18.6](#javacook-otherlang-SECT-5). From native code, you can call
    to functions written in just about any language. Not to mention that you can contact
    programs written in any language over a socket (see [Chapter 13](ch13.html#javacook-netserver)),
    with HTTP services (see [Chapter 13](ch13.html#javacook-netserver)), or with Java
    clients in RMI or CORBA clients in a variety of languages.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Java 有几种运行其他语言编写的程序的方法。你可以使用`Runtime.exec()`来调用已编译的程序或可执行脚本，正如我将在[Recipe 18.1](#javacook-otherlang-SECT-1)中描述的那样。这里涉及系统依赖性，因为只能在编译为其操作系统的外部应用程序下运行它们。或者，你可以使用`javax.script`调用多种脚本语言（或*动态语言*），如：awk、bsh、Clojure、Ruby、Perl、Python、Scala，如[Recipe
    18.3](#javacook-otherlang-scripting)所示。或者你可以通过Java的*本地代码*机制下降到C级别，并调用用C/C++编写的编译函数，参见[Recipe
    18.6](#javacook-otherlang-SECT-5)。从本地代码，你可以调用几乎任何语言编写的函数。更不用说你可以通过套接字联系任何语言编写的程序（参见[Chapter 13](ch13.html#javacook-netserver)），使用HTTP服务（参见[Chapter 13](ch13.html#javacook-netserver)），或者使用Java客户端在RMI或CORBA客户端中使用各种语言。
- en: 'There is a wide range of other JVM languages, including these:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: JVM 还有许多其他语言，包括以下几种：
- en: BeanShell, a general scripting language for Java.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BeanShell，Java的一般脚本语言。
- en: '[Groovy](https://groovy-lang.org) is a Java-based scripting language that pioneered
    the use of closures in the Java language ecosystem. It also has a rapid-development
    web package called [Grails](http://grails.org) and a build tool called Gradle
    (see [Recipe 1.8](ch01.html#javacook-getstarted-gradle)). Gradle is also used
    as the build tool in modern Android development.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Groovy](https://groovy-lang.org)是一种基于Java的脚本语言，为Java语言生态系统中的闭包使用开创了先河。它还有一个快速开发的Web包叫做[Grails](http://grails.org)和一个叫做Gradle的构建工具（参见[Recipe
    1.8](ch01.html#javacook-getstarted-gradle)）。Gradle也被用作现代Android开发中的构建工具。'
- en: '[Jython](http://jython.org), a full Java implementation of Python.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Jython](http://jython.org)，Python的完整Java实现。'
- en: '[JRuby](http://jruby.org), a full Java implementation of the Ruby language.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[JRuby](http://jruby.org)，Ruby语言的完整Java实现。'
- en: '[Scala](http://scala-lang.org), a JVM language that claims to offer the “best
    of functional and OO” languages.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Scala](http://scala-lang.org)，一个声称提供“功能和面向对象语言的最佳结合”的JVM语言。'
- en: '[Clojure](http://clojure.org), a predominantly functional [Lisp-1](https://en.wikipedia.org/wiki/Common_Lisp#The_function_namespace)
    dialect for the JVM.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Clojure](http://clojure.org)，一种主要用于 JVM 的函数式[Lisp-1](https://en.wikipedia.org/wiki/Common_Lisp#The_function_namespace)方言。'
- en: '[Renjin](http://renjin.org) (pronounced “R engine”), a fairly complete open
    source clone of the R statistics package with the ability to scale to the cloud.
    See [Recipe 11.5](ch11.html#javacook-ds-r-within-java) for an example using Renjin.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Renjin](http://renjin.org)（发音为“R engine”），一个相当完整的开源R统计包克隆，具有扩展到云端的能力。参见[Recipe
    11.5](ch11.html#javacook-ds-r-within-java)中使用Renjin的示例。'
- en: These are JVM-centric, and some can be called directly from Java to script,
    or vice versa, without using `javax.script`. A list of these languages can be
    found on [Wikipedia](http://en.wikipedia.org/wiki/List_of_JVM_languages).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是以JVM为中心的，并且有些可以直接从Java调用脚本，反之亦然，而不使用`javax.script`。可以在[Wikipedia](http://en.wikipedia.org/wiki/List_of_JVM_languages)上找到这些语言的列表。
- en: 18.1 Running an External Program from Java
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 18.1 在 Java 中运行外部程序
- en: Problem
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to run an external program from within a Java program.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你想在Java程序中运行外部程序。
- en: Solution
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use one of the `exec()` methods in the `java.lang.Runtime` class. Or set up
    a `ProcessBuilder` and call its `start()` method.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`java.lang.Runtime`类中的`exec()`方法之一。或者设置一个`ProcessBuilder`并调用其`start()`方法。
- en: Discussion
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'The `exec()` method in the `Runtime` class lets you run an external program.
    The command line you give is broken into strings by a simple `StringTokenizer`
    (see [Recipe 3.1](ch03.html#javacook-strings-SECT-1)) and passed on to the operating
    system’s “execute a program” system call. As an example, here is a simple program
    that uses `exec()` to run *kwrite*, a windowed text editor program.^([1](ch18.html#idm45290622339272))
    On Windows, you’d have to change the name to `notepad` or `wordpad`, possibly
    including the full pathname, for example, *c:/windows/notepad.exe* (you can also
    use backslashes, but be careful to double them because the backslash is special
    in Java strings):'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`Runtime`类中的`exec()`方法允许你运行外部程序。你给出的命令行通过简单的`StringTokenizer`（参见 [Recipe 3.1](ch03.html#javacook-strings-SECT-1)）分解为字符串，并传递给操作系统的“执行程序”系统调用。例如，这里是一个使用`exec()`运行*
    kwrite *的简单程序，一个带窗口的文本编辑器程序。^([1](ch18.html#idm45290622339272)) 在Windows上，你可能需要将名称更改为`notepad`或`wordpad`，可能包括完整路径名，例如，*c:/windows/notepad.exe*（你也可以使用反斜杠，但要小心要双倍，因为反斜杠在Java字符串中是特殊字符）：'
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When you compile and run it, the appropriate editor window appears:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编译并运行它时，适当的编辑器窗口会出现：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This version of `exec()` assumes that the pathname contains no blanks because
    these break proper operation of the `StringTokenizer`. To overcome this potential
    problem, use an overloaded form of `exec()`, taking an array of strings as arguments.
    [Example 18-1](#javacook-otherlang-EX-1) runs the Windows or Unix version of the
    Firefox web browser, assuming that Firefox was installed in the default directory
    (or another directory that is on your `PATH`). It passes the name of a help file
    as an argument, offering a kind of primitive help mechanism, as displayed in [Figure 18-1](#javacook-otherlang-FIG-1).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的`exec()`假设路径名不包含空格，因为空格会破坏`StringTokenizer`的正常操作。为了克服这个潜在问题，使用`exec()`的一个重载形式，接受一个字符串数组作为参数。[Example 18-1](#javacook-otherlang-EX-1)
    运行Windows或Unix版本的Firefox网络浏览器，假设Firefox安装在默认目录（或另一个在你的`PATH`上的目录）。它传递一个帮助文件的名称作为参数，提供一种原始的帮助机制，如
    [Figure 18-1](#javacook-otherlang-FIG-1) 所示。
- en: Example 18-1\. main/src/main/java/otherlang/ExecDemoNS.java
  id: totrans-23
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例子 18-1\. main/src/main/java/otherlang/ExecDemoNS.java
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![jcb4 1801](assets/jcb4_1801.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![jcb4 1801](assets/jcb4_1801.png)'
- en: Figure 18-1\. ExecDemoNS in action
  id: totrans-26
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 18-1\. ExecDemoNS 在运行中
- en: A newer class, `ProcessBuilder`, replaces most nontrivial uses of `Runtime.exec()`.
    This `ProcessBuilder` uses generic collections to let you modify or replace the
    environment, as shown in [Example 18-2](#javacook-otherlang-EX-2).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更新的类，`ProcessBuilder`，替代了大多数非平凡使用`Runtime.exec()`的情况。这个`ProcessBuilder`使用通用集合允许你修改或替换环境，如示例
    [Example 18-2](#javacook-otherlang-EX-2) 所示。
- en: Example 18-2\. main/src/main/java/otherlang/ProcessBuilderDemo.java
  id: totrans-28
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例子 18-2\. main/src/main/java/otherlang/ProcessBuilderDemo.java
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[![1](assets/1.png)](#co_using_java_with_other_languages_CO1-1)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_using_java_with_other_languages_CO1-1)'
- en: 'Set up the command-line argument list: editor program name and filename.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 设置命令行参数列表：编辑器程序名称和文件名。
- en: '[![2](assets/2.png)](#co_using_java_with_other_languages_CO1-2)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_using_java_with_other_languages_CO1-2)'
- en: Use that to start configuring the `ProcessBuilder`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个来开始配置`ProcessBuilder`。
- en: '[![3](assets/3.png)](#co_using_java_with_other_languages_CO1-3)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_using_java_with_other_languages_CO1-3)'
- en: Configure the builder’s environment to a list of common MS Windows directories.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 配置构建器的环境到一组常见的MS Windows目录。
- en: '[![4](assets/4.png)](#co_using_java_with_other_languages_CO1-4)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_using_java_with_other_languages_CO1-4)'
- en: Set the initial directory to the user’s home, and start the process!
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 设置初始目录为用户的主目录，并启动进程！
- en: '[![5](assets/5.png)](#co_using_java_with_other_languages_CO1-5)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_using_java_with_other_languages_CO1-5)'
- en: I always wanted to be able to use this line in code.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我一直想在代码中使用这行。
- en: '[![6](assets/6.png)](#co_using_java_with_other_languages_CO1-6)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_using_java_with_other_languages_CO1-6)'
- en: Wait for the end of our little play.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 等待我们小戏的结束。
- en: For more on `ProcessBuilder`, see the javadoc for `java.lang.ProcessBuilder`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`ProcessBuilder`更多内容，请参阅`java.lang.ProcessBuilder`的javadoc。
- en: 18.2 Running a Program and Capturing Its Output
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 18.2 运行程序并捕获其输出
- en: Problem
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to run a program but also capture its output.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 想要运行一个程序，同时捕获其输出。
- en: Solution
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the `Process` object’s `getInputStream()`; read and copy the contents to
    `System.out` or wherever you want them.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Process`对象的`getInputStream()`；读取并复制内容到`System.out`或任何你想要的地方。
- en: Discussion
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'The original notion of standard output and standard error was that they would
    always be connected to the terminal; this notion dates from an earlier time when
    almost all computer users worked at the command line. Today, a program’s standard
    output and error output do not always automatically appear anywhere. Arguably
    there should be an automatic way to make this happen. But for now, you need to
    add a few lines of code to grab the program’s output and print it:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最初的标准输出和标准错误的概念是它们总是连接到终端；这个概念来自一个早期的时代，当时几乎所有的计算机用户都在命令行上工作。如今，一个程序的标准输出和错误输出并不总是自动出现在任何地方。可以说，应该有一种自动的方法使这种情况发生。但目前，您需要添加几行代码来获取程序的输出并打印它：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is such a common occurrence that I’ve packaged it up into a class called
    `ExecAndPrint`, which is part of my `com.darwinsys.lang` package. `ExecAndPrint`
    has several overloaded forms of its `run()` method (see the documentation for
    details), but they all take at least a command and optionally an output file to
    which the command’s output is written. [Example 18-3](#javacook-otherlang-EX-2ch24)
    shows the code for some of these methods.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况如此常见，以至于我将其封装为一个名为`ExecAndPrint`的类，它是我的`com.darwinsys.lang`包的一部分。 `ExecAndPrint`有几种重载形式的`run()`方法（有关详细信息，请参阅文档），但它们都至少需要一个命令，并且可选地需要一个输出文件，用于将命令的输出写入。
    [示例 18-3](#javacook-otherlang-EX-2ch24)显示了其中一些方法的代码。
- en: Example 18-3\. darwinsys-api/src/main/java/com/darwinsys/lang/ExecAndPrint.java
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 18-3\. darwinsys-api/src/main/java/com/darwinsys/lang/ExecAndPrint.java
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As a simple example of using `exec()` directly along with `ExecAndPrint`, I’ll
    create three temporary files, list them (directory listing), and then delete them.
    When I run the `ExecDemoFiles` program, it lists the three files it has created:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 作为直接使用`exec()`和`ExecAndPrint`的简单示例，我将创建三个临时文件，列出它们（目录列表），然后删除它们。当我运行`ExecDemoFiles`程序时，它会列出它已创建的三个文件：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Its source code is in [Example 18-4](#javacook-otherlang-EX-3).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 其源代码位于[示例 18-4](#javacook-otherlang-EX-3)。
- en: Example 18-4\. main/src/main/java/otherlang/ExecDemoFiles.java
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 18-4\. main/src/main/java/otherlang/ExecDemoFiles.java
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: A process isn’t necessarily destroyed when the Java program that created it
    exits or bombs out. Simple text-based programs will be, but window-based programs
    like *kwrite* Netscape, or even a Java-based `JFrame` application, will not. For
    example, our `ExecDemoNS` program started Netscape, and when `ExecDemoNS`’s Exit
    button is clicked, `ExecDemoNS` exits but Netscape stays running. What if you
    want to be sure a process has completed? The `Process` object has a `waitFor()`
    method that lets you do so, and an `exitValue()` method that tells you the return
    code from the process. Finally, should you wish to forcibly terminate the other
    process, you can do so with the `Process` object’s `destroy()` method, which takes
    no argument and returns no value. [Example 18-5](#javacook-otherlang-EX-4) is
    `ExecDemoWait`, a program that runs whatever program you name on the command line
    (along with arguments), captures the program’s standard output, and waits for
    the program to terminate.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建进程的Java程序退出或崩溃时，并不一定会销毁进程。简单的文本程序会销毁，但像*kwrite* Netscape，甚至是基于Java的`JFrame`应用程序等基于窗口的程序不会。例如，我们的`ExecDemoNS`程序启动了Netscape，当单击`ExecDemoNS`的退出按钮时，`ExecDemoNS`退出但Netscape仍在运行。如果你想要确保一个进程已经完成，该怎么办？`Process`对象有一个`waitFor()`方法，让你可以这样做，并且一个`exitValue()`方法，告诉你进程的返回码。最后，如果你希望强制终止另一个进程，你可以使用`Process`对象的`destroy()`方法，该方法不接受参数并且不返回值。[示例 18-5](#javacook-otherlang-EX-4)是`ExecDemoWait`，一个运行你在命令行中命名的任何程序（以及参数），捕获程序的标准输出，并等待程序终止的程序。
- en: Example 18-5\. main/src/main/java/otherlang/ExecDemoWait.java
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 18-5\. main/src/main/java/otherlang/ExecDemoWait.java
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: See Also
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: You wouldn’t normally use any form of `exec()` to run one Java program from
    another in this way; instead, you’d probably create it as a thread within the
    same process, because this is generally quite a bit faster (the Java interpreter
    is already up and running, so why wait for another copy of it to start up?). See
    [Chapter 16](ch16.html#javacook-threads).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常不会以这种方式使用任何形式的`exec()`来从一个Java程序运行另一个Java程序；相反，你可能会将其创建为同一进程中的一个线程，因为这通常要快得多（Java解释器已经启动运行，为什么要等待另一个副本启动？）。参见[第16章](ch16.html#javacook-threads)。
- en: When building industrial-strength applications, note the cautionary remarks
    in the Java API docs for the `Process` class concerning the danger of losing some
    of the I/O due to insufficient buffering by the operating system.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建工业级应用程序时，请注意Java API文档中关于`Process`类的警告性说明，因为操作系统的缓冲区不足可能导致部分I/O丢失的危险。
- en: 18.3 Calling Other Languages via javax.script
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 18.3 通过 javax.script 调用其他语言
- en: Problem
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to invoke a script written in some other language from within your
    Java program, running in the JVM, with the ability to pass variables directly
    to/from the other language.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望从 Java 程序中调用用其他语言编写的脚本，在 JVM 中运行，并能直接传递变量到/从其他语言。
- en: Solution
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: If the script you want is written in any of the two-dozen-plus supported languages,
    use `javax.script`. Those languages include awk, Perl, Python, Ruby, BeanShell,
    PNuts, Ksh/Bash, R (Renjin), and several implementations of JavaScript.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要的脚本是用支持的二十多种语言之一编写的，请使用 `javax.script`。这些语言包括 awk、Perl、Python、Ruby、BeanShell、PNuts、Ksh/Bash、R（Renjin）和几个
    JavaScript 的实现。
- en: Discussion
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: One of the first tasks when using this API is to find out the installed scripting
    engines, and then pick one that is available. The `ScriptEnginesDemo` program
    in [Example 18-6](#javacook-otherlang-scriptenginesdemo) lists the installed engines
    and runs a simple script in the default language, ECMAScript (aka JavaScript).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个 API 的一个最初的任务是找出安装的脚本引擎，然后选择一个可用的引擎。[示例 18-6](#javacook-otherlang-scriptenginesdemo)
    中的 `ScriptEnginesDemo` 程序列出了已安装的引擎，并运行了一个简单的脚本，使用默认语言 ECMAScript（又名 JavaScript）。
- en: Example 18-6\. main/src/main/java/otherlang/ScriptEnginesDemo.java
  id: totrans-72
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 18-6\. main/src/main/java/otherlang/ScriptEnginesDemo.java
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[Example 18-7](#javacook-otherlang-pythonfromjava) is a very simple demo of
    calling Python from Java using `javax.scripting`. We know the name of the scripting
    engine we want to use: Python. We’ll use the in-vm implementation known as `jython`,
    which was originally called JPython but was changed due to a trademark issue.
    Once we put the *jython-standalone-2.nnn.jar* onto our `CLASSPATH`, the script
    engine is automatically detected. Just in case it fails, we print a verbose message
    including a list of the engines that are available.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 18-7](#javacook-otherlang-pythonfromjava) 是一个非常简单的示例，展示了如何使用 `javax.scripting`
    从 Java 调用 Python。我们知道要使用的脚本引擎的名称是 Python。我们将使用在虚拟机中的实现，称为 `jython`，最初称为 JPython，但因商标问题而更改。一旦将
    *jython-standalone-2.nnn.jar* 加入到我们的 `CLASSPATH` 中，脚本引擎就会自动检测到。以防失败，我们会打印一个详细的消息，包括可用引擎的列表。'
- en: Example 18-7\. main/src/main/java/otherlang/PythonFromJava.java
  id: totrans-75
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 18-7\. main/src/main/java/otherlang/PythonFromJava.java
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: See Also
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Before Oracle dismantled java.net, there used to be a list of many languages
    (see [this archived list](https://web.archive.org/web/20140909141915/https://java.net/projects/scripting/sources/svn/show/trunk/engines);
    the links don’t work, but it shows the extent of the languages that were available).
    Back then, you could download the script engines from that site. I am not aware
    of a current official list of engines, unfortunately. However, the list maintained
    as part of the scripting project per se can be found in an unofficial source code
    repository, by viewing [*https://github.com/scijava/javax-scripting*](https://github.com/scijava/javax-scripting),
    from which it should in theory be possible to build the one you want. A dozen
    or so other engines are maintained by others outside this project; for example,
    there is a `Perl5` script engine from [Google Code](https://code.google.com/archive/p/javaperlscripting).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Oracle 拆除 java.net 之前，曾经有一个列出许多语言的列表（请参阅 [此存档列表](https://web.archive.org/web/20140909141915/https://java.net/projects/scripting/sources/svn/show/trunk/engines)；链接已经失效，但显示了可用的语言范围）。当时，您可以从该站点下载脚本引擎。不幸的是，我不知道目前有一个官方的引擎列表。然而，作为脚本项目的一部分维护的列表可以在一个非官方的源代码库中找到，通过查看
    [*https://github.com/scijava/javax-scripting*](https://github.com/scijava/javax-scripting)，在理论上应该能够构建您想要的列表。此项目外的其他十几个引擎由其他人维护；例如，有一个来自
    [Google Code](https://code.google.com/archive/p/javaperlscripting) 的 `Perl5` 脚本引擎。
- en: There is a also a [list of Java-compatible scripting languages](http://java-source.net/open-source/scripting-languages)
    (not necessarily all using `javax.script`).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个 [Java 兼容的脚本语言列表](http://java-source.net/open-source/scripting-languages)（不一定全部使用
    `javax.script`）。
- en: It is possible to roll your own scripting engine; see my write-up at [*https://darwinsys.com/java/scriptengines.html*](https://darwinsys.com/java/scriptengines.html).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以自行编写脚本引擎；参见我的介绍 [*https://darwinsys.com/java/scriptengines.html*](https://darwinsys.com/java/scriptengines.html)。
- en: 18.4 Mixing Languages with GraalVM
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 18.4 使用 GraalVM 混合语言
- en: Problem
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: GraalVM aims to be multilanguage, and you’d like to use different languages
    in the VM.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: GraalVM 的目标是多语言的，您希望在 VM 中使用不同的语言。
- en: Solution
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use *gu* (graal utility) to install additional language packs and call other
    languages.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *gu*（graal 实用工具）安装额外的语言包并调用其他语言。
- en: Discussion
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'While GraalVM positions itself as able to support a wide variety of programming
    languages, the number currently supported is small but growing. Let’s try invoking
    Python code from within Java. Assuming you’ve installed Graal itself as per [Recipe
    1.2](ch01.html#jcb-getstarted-graal), you should have *gu* on your executable
    path, so try the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然GraalVM自称能够支持各种编程语言，但目前支持的语言数量虽小，但正在增长。让我们尝试从Java内部调用Python代码。假设您已经按照[Recipe
    1.2](ch01.html#jcb-getstarted-graal)的说明安装了Graal本身，您的可执行路径上应该有*gu*，因此请尝试以下操作：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Then the code in [Example 18-8](#javacook-otherlang-graalpy) can be used.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以使用[示例 18-8](#javacook-otherlang-graalpy)中的代码。
- en: Example 18-8\. graal/src/JavaCallPython.java
  id: totrans-90
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 18-8\. graal/src/JavaCallPython.java
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 18.5 Marrying Java and Perl
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 18.5 将Java和Perl结合起来
- en: Problem
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to call Java from Perl, or vice versa.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望从Perl调用Java，或者反过来。
- en: Solution
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: To call Java from Perl, use the Perl `Inline::Java` module. To go the other
    way—calling Perl from Java—use `javax.script`, as in [Recipe 18.3](#javacook-otherlang-scripting).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要从Perl调用Java，请使用Perl的`Inline::Java`模块。要反过来——从Java调用Perl——请使用`javax.script`，就像在[Recipe
    18.3](#javacook-otherlang-scripting)中所示。
- en: Discussion
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Perl is often called a glue language that can be used to bring together diverse
    parts of the software world. But, in addition, it is a full-blown language for
    creating software. A wealth of extension modules provide ready-to-run solutions
    for quite diverse problems, and most of these modules are available free from
    CPAN, the [Comprehensive Perl Archive Network](http://www.cpan.org). Also, as
    a scripting language, it is ideally suited for rapid prototyping. On the other
    hand, although building graphical user interfaces is definitely possible in Perl,
    it is not exactly one of the language’s strengths. So you might want to construct
    your GUI using Java Swing, and, at the same time, reuse business logic implemented
    in Perl.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Perl通常被称为一种粘合语言，可以用来将软件世界的各种部分组合在一起。此外，它还是一个用于创建软件的完整语言。大量的扩展模块提供了就绪运行的解决方案，适用于相当多样化的问题，大多数这些模块可以从CPAN（[综合Perl存档网络](http://www.cpan.org)）免费获取。另外，作为一种脚本语言，它非常适合快速原型设计。然而，尽管Perl确实可以构建图形用户界面，但这并不是该语言的强项之一。因此，您可能希望使用Java
    Swing构建GUI，并同时重用在Perl中实现的业务逻辑。
- en: Fortunately, among the many CPAN modules, `Inline::Java` makes the integration
    of Perl and Java a breeze. Let’s assume first that you want to call into Java
    from Perl. For business logic, I have picked a CPAN module that measures the similarity
    of two strings (the so-called *Levenshtein edit distance*). [Example 18-9](#javacook-otherlang-EX-7)
    shows the complete source. You need at least version 0.44 of the module `Inline::Java`;
    previous versions did not support threaded applications properly, so use of Swing
    wasn’t possible.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在众多的CPAN模块中，`Inline::Java`使得Perl和Java的集成变得十分简便。首先假设您希望从Perl调用Java。为了业务逻辑，我选择了一个CPAN模块，用于测量两个字符串的相似度（所谓的*Levenshtein编辑距离*）。[示例 18-9](#javacook-otherlang-EX-7)展示了完整的源代码。您至少需要使用模块`Inline::Java`的0.44版本；早期版本不正确地支持了线程应用程序，因此不支持使用Swing。
- en: Using the module this way requires that the Java source be included in the Perl
    script with special delimiters, as shown in [Example 18-9](#javacook-otherlang-EX-7).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式使用该模块要求在Perl脚本中使用特殊分隔符包含Java源码，如[示例 18-9](#javacook-otherlang-EX-7)所示。
- en: Example 18-9\. Swinging.pl
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 18-9\. Swinging.pl
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Since this uses the `Text::Levenshtein` and the `Inline::Java` modules, you
    will have to install that. Here’s the standard way:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用了`Text::Levenshtein`和`Inline::Java`模块，您需要安装这些模块。以下是标准的安装方法：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'On some systems there may be an OS-specific module; for example, on OpenBSD
    Unix, it’s this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些系统上可能会有特定于操作系统的模块；例如，在OpenBSD Unix上，是这样的：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In a simple Perl+Java program like this, you don’t even need to write a separate
    Java source file: you combine all the code, Perl and Java alike, in one single
    file. You do not need to compile anything, either; just execute it by typing:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个简单的Perl+Java程序中，你甚至不需要编写单独的Java源文件：你可以将所有代码，无论是Perl还是Java，都放在一个单独的文件中。你不需要编译任何东西，只需键入以下命令来执行它：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '(You can also add a string argument.) After a little churning, a Java message
    box pops up, telling you that the distance between `Japh` and `Java` is 2\. At
    the same time, your console shows the string “Just another Perl hacker inside
    Java.” When you close the message box, you get the final result “matcher: 2 (displayed
    from Perl).”'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '（您也可以添加一个字符串参数。）稍作处理后，一个Java消息框弹出，告诉您`Japh`和`Java`之间的距离为2。与此同时，您的控制台显示字符串“Just
    another Perl hacker inside Java。”当您关闭消息框时，您将得到最终结果“matcher: 2（从Perl显示）。”'
- en: 'In between, your Perl program has created an instance of the Java class `Showit`
    by calling its constructor. It then called that object’s `show()` method to display
    a string from within Java. It then proceeded to call the `match()` method, but
    this time, something more complicated happens: the Java code calls back into Perl,
    accessing method `distance` of module `Text::Levenshtein` and passing it two strings
    as arguments. It receives the result, displays it in a message box, and finally,
    for good measure, returns it to the Perl main program that it had been called
    from.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这期间，你的 Perl 程序通过调用其构造函数创建了 Java 类 `Showit` 的一个实例。然后它调用该对象的 `show()` 方法在 Java
    中显示一个字符串。然后它继续调用 `match()` 方法，但这次发生了更复杂的事情：Java 代码回调 Perl，访问模块 `Text::Levenshtein`
    的 `distance` 方法，并将两个字符串作为参数传递给它。它接收结果，在消息框中显示它，最后，为了保险起见，将其返回给调用它的 Perl 主程序。
- en: Incidentally, the `eval { }` block around the method call is the Perlish way
    of catching exceptions. In this case, the exception is thrown from within Java.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，`eval { }` 块是捕获异常的 Perl 方法。在这种情况下，异常是从 Java 内部抛出的。
- en: If you restart the program, you will notice that startup time is much shorter,
    which is always good news. Why is that so? On the first call, `Inline::Java` took
    the input apart, precompiled the Java part, and saved it to disk (usually, in
    a subdirectory called *_Inline*). On subsequent calls, it just makes sure that
    the Java source has not changed and then calls the class file that is already
    on disk. (Of course, if you surreptitiously changed the Java code, it is recompiled
    just as automagically.) Behind the scenes, even stranger things are going on,
    however. When the Perl script is executed, a Java server is constructed and started
    unbeknownst to the user, and the Perl part and the Java bits communicate through
    a TCP socket (see [Chapter 13](ch13.html#javacook-netserver)).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果重新启动程序，您会注意到启动时间大大缩短，这总是一个好消息。为什么会这样？因为在第一次调用时，`Inline::Java` 拆分输入，预编译了 Java
    部分，并将其保存到磁盘上（通常在名为 *_Inline* 的子目录中）。在后续调用中，它只需确保 Java 源码没有更改，然后调用已经存在于磁盘上的类文件。（当然，如果您偷偷改变了
    Java 代码，它会像自动魔术般重新编译。）然而，在幕后，还发生了更奇怪的事情。当执行 Perl 脚本时，会构建并启动一个 Java 服务器，用户毫不知情，Perl
    部分和 Java 部分通过 TCP 套接字进行通信（见 [第13章](ch13.html#javacook-netserver)）。
- en: Marrying two platform-independent languages, like Perl and Java, in a portable
    way skirts many portability problems. When distributing inlined applications,
    be sure to supply not just the source files but also the contents of the *_Inline*
    directory. (It is advisable to purge that directory and to rebuild everything
    just before distribution time; otherwise, old compiled versions left lying around
    might make it into the distribution.) Each target machine needs to repeat the
    magic steps of `Inline::Java`, which requires a Java compiler. In any case, the
    `Inline::Java` module must be installed.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以一种可移植的方式将 Perl 和 Java 这样两种平台无关的语言结合在一起，可以避开许多可移植性问题。在分发内联应用程序时，确保不仅提供源文件，还提供
    *_Inline* 目录的内容。（建议在分发之前清除该目录并重新构建所有内容；否则，留在那里的旧编译版本可能会进入分发版。）每台目标机器都需要重复执行 `Inline::Java`
    的魔法步骤，这需要一个 Java 编译器。在任何情况下，都必须安装 `Inline::Java` 模块。
- en: Because Perl has `Inline` modules for a number of other languages (ordinary
    languages like C, but others as exotic as Befunge), one might even consider using
    Perl as glue for interoperation between those other languages, jointly or separately,
    and Java. I am sure many happy hours can be spent working out the intricacies
    of such interactions.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Perl 拥有 `Inline` 模块，可以用于许多其他语言（如普通的 C 语言，但也包括像 Befunge 这样的异国语言），所以你甚至可以考虑使用
    Perl 作为这些其他语言与 Java 之间或分别之间互操作的粘合剂。我相信你会在解决这些交互的复杂性时度过许多愉快的时光。
- en: See Also
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: You can find full information on `Inline::Java` on [CPAN](http://search.cpan.org)
    or in the POD (Plain Old Documentation) that is installed along with the module
    itself.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [CPAN](http://search.cpan.org) 上找到有关 `Inline::Java` 的完整信息，或者在模块本身安装时一同安装的
    POD（Plain Old Documentation）中找到。
- en: 18.6 Calling Other Languages via Native Code
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 18.6 通过本地代码调用其他语言
- en: Problem
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You wish to call native C/C++ functions from Java, either for efficiency or
    to access hardware- or system-specific features.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望从 Java 中调用本地的 C/C++ 函数，无论是为了提高效率还是访问硬件或特定系统功能。
- en: Solution
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use JNI, the Java Native Interface. Or, use GraalVM.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 JNI（Java Native Interface）。或者使用 GraalVM。
- en: Discussion
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Java lets you load native or compiled code into your Java program. Why would
    you want to do such a thing? The best reason would probably be to access OS-dependent
    functionality, or existing code written in another language. A less good reason
    would be speed: native code can sometimes run faster than Java, though this is
    becoming less important as computers get faster and more multicore. Like everything
    else in Java, the native code mechanism is subject to security restrictions; for
    example, applets were not allowed to access native code.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Java 允许你将本地或编译后的代码加载到你的 Java 程序中。为什么你要做这样的事情呢？最好的理由可能是为了访问依赖于操作系统的功能，或者是访问用另一种语言编写的现有代码。一个不太好的理由可能是速度：本地代码有时可能比
    Java 运行得更快，尽管随着计算机变得更快、更多核心，这变得不那么重要了。与 Java 中的其他一切一样，本地代码机制受到安全限制；例如，小程序不被允许访问本地代码。
- en: The native code language bindings are defined for code written in C or C++.
    If you need to access a language other than C/C++, write a bit of C/C++ and have
    it pass control to other functions or applications, using any mechanism defined
    by your operating system.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 本地代码语言绑定是为使用 C 或 C++ 编写的代码定义的。如果你需要访问除 C/C++ 之外的其他语言，编写一些 C/C++ 并让它通过任何由你的操作系统定义的机制控制其他函数或应用程序。
- en: Due to such system-dependent features as the interpretation of header files
    and the allocation of the processor’s general-purpose registers, your native code
    may need to be compiled by the same C compiler used to compile the Java runtime
    for your platform. For example, on Solaris you can use SunPro C or maybe gcc.
    On Win32 platforms, use Microsoft visual C++ Version 4.x or higher (32 bit). For
    Linux and macOS, you should be able to use the provided gcc-based compiler. For
    other platforms, see your Java vendor’s documentation.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由于诸如解释头文件和分配处理器的通用寄存器等系统相关特性，你的本地代码可能需要由用于编译你平台的 Java 运行时的相同的 C 编译器来编译。例如，在
    Solaris 上，你可以使用 SunPro C 或者也许是 gcc。在 Win32 平台上，使用 Microsoft Visual C++ 版本 4.x
    或更高版本（32 位）。对于 Linux 和 macOS，你应该能够使用提供的基于 gcc 的编译器。对于其他平台，请参阅你的 Java 供应商的文档。
- en: Also note that the details in this section are for the Java Native Interface
    (JNI) of Java 1.1 and later, which differs in some details from 1.0 and from Microsoft’s
    native interface.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，本节中的细节适用于 Java 1.1 及更高版本的 Java Native Interface (JNI)，与 1.0 版本以及 Microsoft
    的本地接口有一些细节上的不同。
- en: The first step is to write Java code that calls a native method. To do this,
    use the keyword `native` to indicate that the method is native, and provide a
    static code block that loads your native method using `System.loadLibrary()`.
    (The dynamically loadable module is created in step 5.) Static blocks are executed
    when the class containing them is loaded; loading the native code here ensures
    it is in memory when needed!
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是编写调用本地方法的 Java 代码。为此，请使用关键字 `native` 表示该方法是本地方法，并提供一个静态代码块，使用 `System.loadLibrary()`
    加载你的本地方法。（动态加载模块在第5步创建。）静态块在包含它们的类加载时执行；在这里加载本地代码可以确保在需要时它在内存中！
- en: Object variables that your native code may modify should carry the `volatile`
    modifier. The file *HelloJni.java*, shown in [Example 18-10](#javacook-otherlang-EX-10),
    is a good starting point.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你的本地代码可能会修改的对象变量应该带有 `volatile` 修饰符。[示例 18-10](#javacook-otherlang-EX-10) 中显示的
    *HelloJni.java* 文件是一个很好的起点。
- en: Example 18-10\. main/src/main/java/jni/HelloJni.java
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 18-10\. main/src/main/java/jni/HelloJni.java
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The second step is simple; just use *javac HelloJni.java* as you normally would.
    You probably won’t get any compilation errors on a simple program like this; if
    you do, correct them and try the compilation again.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步很简单；就像平常一样使用 *javac HelloJni.java*。对于像这样的简单程序，你可能不会遇到任何编译错误；如果有，纠正它们然后再次编译。
- en: 'Next, you need to create an *.h* file. Use *javah* to produce this file:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要创建一个 *.h* 文件。使用 *javah* 生成此文件：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The *.h* file produced is a glue file, not really meant for human consumption
    and particularly not for editing. But by inspecting the resulting *.h* file, you’ll
    see that the C method’s name is composed of the name `Java`, the package name
    (if any), the class name, and the method name:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 *.h* 文件是一个粘合文件，实际上不是为人类消费而设计的，尤其不适合编辑。但通过检查生成的 *.h* 文件，你会看到 C 方法的名称由 `Java`
    名称、包名称（如果有）以及类名称和方法名称组成：
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Then create a C function that does the work. You must use the same function
    signature as is used in the *.h* file.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然后创建一个执行工作的 C 函数。你必须使用与 *.h* 文件中使用的相同的函数签名。
- en: 'This function can do whatever it wants. Note that it is passed two arguments:
    a JVM environment variable and a handle for the `this` object. [Table 18-1](#javacook-otherlang-TABLE-2)
    shows the correspondence between Java types and the C types (JNI types) used in
    the C code.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数可以随意执行任何操作。请注意，它传递了两个参数：JVM环境变量和`this`对象的句柄。[表18-1](#javacook-otherlang-TABLE-2)
    显示了Java类型和在C代码中使用的C类型（JNI类型）之间的对应关系。
- en: Table 18-1\. Java and JNI types
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 表18-1\. Java和JNI类型
- en: '| Java type | JNI | Java array type | JNI |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| Java类型 | JNI | Java数组类型 | JNI |'
- en: '| --- | --- | --- | --- |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `byte` | `jbyte` | `byte[]` | `jbyteArray` |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `byte` | `jbyte` | `byte[]` | `jbyteArray` |'
- en: '| `short` | `jshort` | `short[]` | `jshortArray` |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `short` | `jshort` | `short[]` | `jshortArray` |'
- en: '| `int` | `jint` | `int[]` | `jintArray` |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `int` | `jint` | `int[]` | `jintArray` |'
- en: '| `long` | `jlong` | `long[]` | `jlongArray` |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `long` | `jlong` | `long[]` | `jlongArray` |'
- en: '| float | jfloat | float[] | jfloatArray |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| float | jfloat | float[] | jfloatArray |'
- en: '| `double` | `jdouble` | `double[]` | `jdoubleArray` |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `double` | `jdouble` | `double[]` | `jdoubleArray` |'
- en: '| `char` | `jchar` | `char[]` | `jcharArray` |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `char` | `jchar` | `char[]` | `jcharArray` |'
- en: '| `boolean` | `jboolean` | `boolean[]` | `jbooleanArray` |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `boolean` | `jboolean` | `boolean[]` | `jbooleanArray` |'
- en: '| `void` | `jvoid` |  |  |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `void` | `jvoid` |  |  |'
- en: '| `Object` | `jobject` | `Object[]` | `jobjectArray` |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `Object` | `jobject` | `Object[]` | `jobjectArray` |'
- en: '| `Class` | `jclass` |  |  |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `Class` | `jclass` |  |  |'
- en: '| `String` | `jstring` |  |  |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `String` | `jstring` |  |  |'
- en: '| `array` | `jarray` |  |  |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `array` | `jarray` |  |  |'
- en: '| `Throwable` | `jthrowable` |  |  |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `Throwable` | `jthrowable` |  |  |'
- en: '[Example 18-11](#javacook-otherlang-EX-11) is a complete C native implementation.
    Passed an object of type `Hel⁠lo​Jni.java`, it increments the integer `myNumber`
    contained in the object.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 18-11](#javacook-otherlang-EX-11) 是一个完整的C本地实现。传递一个类型为`Hel⁠lo​Jni.java`的对象，它会增加对象中包含的整数`myNumber`。'
- en: Example 18-11\. main/src/main/java/jni/HelloJni.c
  id: totrans-156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 18-11\. main/src/main/java/jni/HelloJni.c
- en: '[PRE20]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, you compile the C code into a loadable object. Naturally, the details
    depend on platform, compiler, etc. For example, on Windows, you could use this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将C代码编译成可加载对象。当然，具体细节取决于平台、编译器等。例如，在Windows上，您可以使用以下方法：
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And on Unix, you could use this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 并且在Unix上，您可以使用以下方法：
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[Example 18-12](#javacook-otherlang-EX-12) is a makefile for Unix.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 18-12](#javacook-otherlang-EX-12) 是Unix的一个makefile。'
- en: Example 18-12\. main/src/main/java/jni/Makefile (Unix version)
  id: totrans-163
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 18-12\. main/src/main/java/jni/Makefile（Unix版本）
- en: '[PRE23]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And you’re done! Just run the Java interpreter on the class file containing
    the main program. Assuming that you’ve set whatever system-dependent settings
    are necessary (possibly including both `CLASSPATH` and `LD_LIBRARY_PATH` or its
    equivalent), the program should run as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！只需在包含主程序的类文件上运行Java解释器。假设您已经设置了必要的系统相关设置（可能包括`CLASSPATH`和`LD_LIBRARY_PATH`或其等效项），程序应该像下面这样运行：
- en: '[PRE24]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Congratulations! You’ve called a native method. However, you’ve given up portability;
    the Java class file now requires you to build a loadable object for each operating
    system and hardware platform. Multiply {Windows, Mac OS X, Sun Solaris, HP/UX,
    Linux, OpenBSD, NetBSD, FreeBSD} times {Intel-32, Intel-64/AMD64, Arm, Arm-64,
    and maybe SPARC64, PowerPC, and HP-PA}, and you begin to see the portability issues.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 祝贺！您已经调用了一个本地方法。但是，您放弃了可移植性；Java类文件现在要求您为每个操作系统和硬件平台构建一个可加载对象。乘以{Windows，Mac
    OS X，Sun Solaris，HP/UX，Linux，OpenBSD，NetBSD，FreeBSD}乘以{Intel-32，Intel-64/AMD64，Arm，Arm-64，以及可能的SPARC64，PowerPC和HP-PA}，您开始看到可移植性问题。
- en: Beware that problems with your native code can and will crash the runtime process
    right out from underneath the Java Virtual Machine. The JVM can do nothing to
    protect itself from poorly written C/C++ code. Memory must be managed by the programmer;
    there is no automatic garbage collection of memory obtained by the system runtime
    allocator. You’re dealing directly with the operating system and sometimes even
    the hardware, so, be careful. Be very careful.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您的本地代码问题可能会导致运行时进程崩溃，从而使Java虚拟机无法保护自己。 JVM无法防止由于编写不良的C/C++代码而导致的问题。内存必须由程序员管理；系统运行时分配器获取的内存没有自动垃圾回收机制。您直接与操作系统甚至硬件打交道，所以，请小心。非常小心。
- en: See Also
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'If you need more information on Java native methods, you might be interested
    in the comprehensive treatment found in *Essential JNI: Java Native Interface*
    by Rob Gordon (Prentice Hall).'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '如果您需要更多关于Java本地方法的信息，您可能会对Rob Gordon的*Essential JNI: Java Native Interface*（Prentice
    Hall出版）中的全面处理感兴趣。'
- en: 18.7 Calling Java from Native Code
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 18.7 从本地代码调用Java
- en: Problem
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to go the other way, calling Java from C/C++ code.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要采用另一种方式，从C/C++代码调用Java。
- en: Solution
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use JNI again.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用 JNI。
- en: Discussion
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'JNI (Java Native Interface) provides an interface for calling Java from C,
    with calls to:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: JNI（Java Native Interface）提供了一个接口，用于从 C 调用 Java，包括以下调用：
- en: Create a JVM.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 JVM。
- en: Load a class.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 载入一个类。
- en: Find and call a method from that class (e.g., main).
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找并调用该类中的一个方法（例如 `main`）。
- en: JNI lets you add Java to legacy code. That can be useful for a variety of purposes
    and lets you treat Java code as an extension language.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: JNI 允许您将 Java 添加到遗留代码中。这对多种用途非常有用，并允许您将 Java 代码视为扩展语言。
- en: The code in [Example 18-13](#javacook-otherlang-javaFromC) takes a class name
    from the command line, starts up the JVM, and calls the `main()` method in the
    class.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 18-13](#javacook-otherlang-javaFromC) 中的代码从命令行获取一个类名，启动 JVM，并调用该类中的 `main()`
    方法。'
- en: Example 18-13\. main/src/main/java/jni/javafromc.c (Calling Java from C)
  id: totrans-183
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 18-13\. main/src/main/java/jni/javafromc.c（从 C 调用 Java）
- en: '[PRE25]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ====
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ====
- en: ^([1](ch18.html#idm45290622339272-marker)) *kwrite* is Unix-specific; it’s a
    part of the [K Desktop Environment (KDE)](http://www.kde.org).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch18.html#idm45290622339272-marker)) *kwrite* 是 Unix 特有的；它是 [K Desktop
    Environment (KDE)](http://www.kde.org) 的一部分。
