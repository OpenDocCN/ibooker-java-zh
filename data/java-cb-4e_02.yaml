- en: Chapter 2\. Interacting with the Environment
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章\. 与环境交互
- en: 2.0 Introduction
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.0 引言
- en: This chapter describes how your Java program can deal with its immediate surroundings
    with what we call the runtime environment. In one sense, everything you do in
    a Java program using almost any Java API involves the environment. Here we focus
    more narrowly on things that directly surround your program. Along the way we’ll
    be introduced to the `System` class, which knows a lot about your particular system.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了你的Java程序如何处理其即时环境，即我们所称的运行时环境。在某种意义上，几乎使用任何Java API在Java程序中进行的所有操作都涉及环境。在这里，我们更专注于直接围绕你的程序的事物。在这个过程中，我们将介绍
    `System` 类，它对你的特定系统了解甚深。
- en: Two other runtime classes deserve brief mention. The first, `java.lang.Runtime`,
    lies behind many of the methods in the `System` class. `System.exit()`, for example,
    just calls `Runtime.exit()`. `Runtime` is technically part of the environment,
    but the only time we use it directly is to run other programs, which is covered
    in [Recipe 18.1](ch18.html#javacook-otherlang-SECT-1).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个运行时类值得简要提及。第一个是 `java.lang.Runtime`，它在 `System` 类的许多方法背后起作用。例如，`System.exit()`
    只是调用 `Runtime.exit()`。`Runtime` 在技术上属于环境的一部分，但我们直接使用它的唯一时机是运行其他程序，这在 [Recipe 18.1](ch18.html#javacook-otherlang-SECT-1)
    中有涵盖。
- en: 2.1 Getting Environment Variables
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.1 获取环境变量
- en: Problem
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to get the value of environment variables from within your Java program.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望从你的Java程序内部获取环境变量的值。
- en: Solution
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use `System.getenv()`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `System.getenv()`。
- en: Discussion
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The seventh edition of Unix, released in 1979, had a new feature known as environment
    variables. Environment variables are in all modern Unix systems (including macOS)
    and in most later command-line systems, such as the DOS or Command Prompt in Windows,
    but they are not in some older platforms or other Java runtimes. Environment variables
    are commonly used for customizing an individual computer user’s runtime environment,
    hence the name. To take one familiar example, on Unix or DOS the environment variable
    `PATH` determines where the system looks for executable programs. So, of course
    people want to know how they access environment variables from their Java program.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 1979年发布的Unix第七版引入了一个称为环境变量的新功能。环境变量在所有现代Unix系统（包括macOS）和大多数后来的命令行系统（如Windows中的DOS或命令提示符）中都存在，但在一些旧平台或其他Java运行时中并不存在。环境变量通常用于自定义个人计算机用户的运行时环境，因此得名。举一个熟悉的例子，在Unix或DOS上，环境变量
    `PATH` 决定系统查找可执行程序的位置。因此，人们想知道如何从他们的Java程序中访问环境变量。
- en: The answer is that you can do this in all modern versions of Java, but you should
    exercise caution in depending on being able to specify environment variables because
    some rare operating systems may not provide them. That said, it’s unlikely you’ll
    run into such a system because all “standard” desktop systems provide them at
    present.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是，在所有现代版本的Java中都可以这样做，但是应该谨慎依赖能够指定环境变量，因为一些罕见的操作系统可能不提供它们。尽管如此，你不太可能遇到这样的系统，因为所有“标准”桌面系统目前都提供它们。
- en: In some ancient versions of Java, `System.getenv()` was deprecated and/or just
    didn’t work. Nowadays the `getenv()` method is no longer deprecated, though it
    still carries the warning that system properties (see [Recipe 2.2](#javacook-environ-SECT-2))
    should be used instead. Even among systems that support environment variables,
    their names are case sensitive on some platforms and case insensitive on others.
    The code in [Example 2-1](#javacook-environ-EX-1) is a short program that uses
    the `getenv()` method.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些古老版本的Java中，`System.getenv()` 被弃用或者根本无效。如今，`getenv()` 方法不再被弃用，尽管仍然警告应该使用系统属性（参见
    [Recipe 2.2](#javacook-environ-SECT-2)）。即使在支持环境变量的系统中，它们的名称在某些平台上是大小写敏感的，在其他平台上则是不敏感的。[Example 2-1](#javacook-environ-EX-1)
    中的代码是一个使用 `getenv()` 方法的简短程序。
- en: Example 2-1\. main/src/main/java/environ/GetEnv.java
  id: totrans-13
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-1\. main/src/main/java/environ/GetEnv.java
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Running this code will produce output similar to the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码将产生类似以下的输出：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The no-argument form of the method `System.getenv()` returns *all* the environment
    variables in the form of an immutable `String Map`. You can iterate through this
    map and access all the user’s settings or retrieve multiple environment settings.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.getenv()` 方法的无参数形式以不可变的 `String Map` 形式返回*所有*环境变量。你可以遍历这个映射并访问所有用户的设置或检索多个环境设置。'
- en: Both forms of `getenv()` require you to have permissions to access the environment,
    so they typically do not work in restricted environments such as applets.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`getenv()` 的两种形式都要求您具有访问环境的权限，因此它们通常不适用于受限制的环境，例如小程序。'
- en: 2.2 Getting Information from System Properties
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.2 从系统属性中获取信息
- en: Problem
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to get information from the system properties.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要从系统属性中获取信息。
- en: Solution
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use `System.getProperty()` or `System.getProperties()`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `System.getProperty()` 或 `System.getProperties()`。
- en: Discussion
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: What is a *property* anyway? A property is just a name and value pair stored
    in a `java.util.Properties` object, which we discuss more fully in [Recipe 7.10](ch07.html#javacook-structure-SECT-7).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是 *属性* 呢？属性只是存储在 `java.util.Properties` 对象中的名称和值对，我们在 [Recipe 7.10](ch07.html#javacook-structure-SECT-7)
    中会更详细地讨论它。
- en: 'The `System.Properties` object controls and describes the Java runtime. The
    `System` class has a static `Properties` member whose content is the merger of
    operating system specifics (`os.name`, for example), system and user tailoring
    (`java.class.path`), and properties defined on the command line (as we’ll see
    in a moment). Note that the use of periods in these names (like `os.arch`, `os.version`,
    `java.class.path`, and `java.lang.version`) makes it look as though there is a
    hierarchical relationship similar to that for package/class names. The `Properties`
    class, however, imposes no such relationships: each key is just a string, and
    dots are not special.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Properties` 对象控制并描述了 Java 运行时。`System` 类有一个静态的 `Properties` 成员，其内容是操作系统特定部分（例如
    `os.name`）、系统和用户定制部分（`java.class.path`）以及在命令行上定义的属性（我们稍后会看到）。请注意，这些名称中的句点（例如 `os.arch`、`os.version`、`java.class.path`
    和 `java.lang.version`）使其看起来好像存在类似于包/类名称的层次关系。然而，`Properties` 类并不强制这样的关系：每个键只是一个字符串，句点并不特殊。'
- en: To view all the defined system properties, you can iterate through the output
    of calling `System.getProperties()` as in [Example 2-2](#javacook-getstarted-EX-42).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看所有定义的系统属性，可以通过调用 `System.getProperties()` 的输出进行迭代，就像在 [Example 2-2](#javacook-getstarted-EX-42)
    中一样。
- en: Example 2-2\. jshell System.getProperties()
  id: totrans-28
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例子 2-2\. jshell System.getProperties()
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Remember that properties whose names begin with “sun” are unsupported and subject
    to change.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，以“sun”开头的属性是不受支持且可能会更改的。
- en: 'To retrieve one system-provided property, use `System.getProperty(propName)`.
    If I just wanted to find out if the `System Properties` had a property named `"pencil_color"`,
    I could say:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索一个系统提供的属性，使用 `System.getProperty(propName)`。如果我只想知道 `System Properties` 是否有一个名为
    `"pencil_color"` 的属性，我可以这样说：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: But what does that return? Surely Java isn’t clever enough to know about everybody’s
    favorite pencil color? Right you are! But we can easily tell Java about our pencil
    color (or anything else we want to tell it) using the `-D` argument.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 那么它返回什么呢？当然，Java 并不聪明到知道每个人最喜欢的铅笔颜色吧？你是对的！但是，我们可以使用 `-D` 参数轻松地告诉 Java 关于我们的铅笔颜色（或任何我们想告诉它的东西）。
- en: 'When starting a Java runtime, you can define a value in the system properties
    object using a `-D` option. Its argument must have a name, an equals sign, and
    a value, which are parsed the same way as in a properties file (see [Recipe 7.10](ch07.html#javacook-structure-SECT-7)).
    You can have more than one `-D` definition between the `java` command and your
    class name on the command line. At the Unix or Windows command line, type:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当启动 Java 运行时，可以使用 `-D` 选项在系统属性对象中定义一个值。它的参数必须包含名称、等号和值，这与属性文件中的解析方式相同（参见[Recipe
    7.10](ch07.html#javacook-structure-SECT-7)）。在 `java` 命令和命令行上的类名之间可以有多个 `-D` 定义。在
    Unix 或 Windows 命令行中，输入：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When running this under an IDE, put the variable’s name and value in the appropriate
    dialog box, for example, in Eclipse’s Run Configuration dialog under Program Arguments.
    You can also set environment variables and system properties using the build tools
    (Maven, Gradle, etc.).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IDE 下运行时，在适当的对话框中（例如，在 Eclipse 的运行配置对话框中的程序参数下），将变量的名称和值放入其中。您还可以使用构建工具（Maven、Gradle
    等）设置环境变量和系统属性。
- en: 'The `SysPropDemo` program has code to extract just one or a few properties,
    so you can run it like this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`SysPropDemo` 程序中的代码用于提取一个或多个属性，您可以像这样运行它：'
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you invoke the `SysPropDemo` program with no arguments, it outputs the same
    information as the `jshell` fragment in [Example 2-2](#javacook-getstarted-EX-42).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不带参数调用 `SysPropDemo` 程序，则输出与 [Example 2-2](#javacook-getstarted-EX-42) 中的
    `jshell` 片段相同的信息。
- en: Which reminds me—this is a good time to mention system-dependent code. [Recipe
    2.3](#javacook-environ-SECT-4) talks about OS-dependent code and release-dependent
    code.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这提醒我——现在是提及依赖系统的代码的好时机。[配方 2.3](#javacook-environ-SECT-4) 讨论了依赖操作系统和发布依赖代码。
- en: See Also
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Recipe 7.10](ch07.html#javacook-structure-SECT-7) lists more details on using
    and naming your own `Properties` files. The javadoc page for `java.util.Properties`
    lists the exact rules used in the `load()` method, as well as other details.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[配方 7.10](ch07.html#javacook-structure-SECT-7) 列出了关于使用和命名自己的`Properties`文件的更多细节。`java.util.Properties`的javadoc页面列出了`load()`方法使用的确切规则，以及其他细节。'
- en: 2.3 Dealing with Code That Depends on the Java Version or the Operating System
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.3 处理依赖于Java版本或操作系统的代码
- en: Problem
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to write code that adapts to the underlying operating system.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要编写适应底层操作系统的代码。
- en: Solution
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: You can use `System.Properties` to find out the Java version and the operating
    system, various features in the `File` class to find out some platform-dependent
    features, and `java.awt.TaskBar` to see if you can use the system-dependent Taskbar
    or Dock.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`System.Properties`来查找Java版本和操作系统，使用`File`类中的各种功能来查找一些平台相关的特性，以及`java.awt.TaskBar`来查看是否可以使用系统相关的任务栏或Dock。
- en: Discussion
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Some things depend on the version of Java you are running. Use `System.getProperty()`
    with an argument of `java.specification.version`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 有些东西取决于您正在运行的Java版本。使用`System.getProperty()`参数为`java.specification.version`。
- en: 'Alternatively, and with greater generality, you may want to test for the presence
    or absence of particular classes. One way to do this is with `Class.forName("class")`
    (see [Chapter 17](ch17.html#javacook-reflection)), which throws an exception if
    the class cannot be loaded—a good indication that it’s not present in the runtime’s
    library. [Example 2-3](#example02checkswing) shows code for this, from an application
    wanting to find out whether the common Swing UI components are available. The
    javadoc for the standard classes reports the version of the JDK in which this
    class first appeared, under the heading “Since.” If there is no such heading,
    it normally means that the class has been present since the beginnings of Java:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，更普遍地说，您可能想测试特定类的存在与否。一种方法是使用`Class.forName("class")`（参见[第17章](ch17.html#javacook-reflection)），如果无法加载类，则会抛出异常——这表明它在运行时库中不存在。[示例
    2-3](#example02checkswing) 展示了这种情况下的代码，来自希望查找常见Swing UI组件是否可用的应用程序。标准类的javadoc报告了此类首次出现的JDK版本，标题为“Since”。如果没有此标题，通常意味着该类从Java开始就存在：
- en: Example 2-3\. *main/src/main/java/starting/CheckForSwing.java*
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-3\. *main/src/main/java/starting/CheckForSwing.java*
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It’s important to distinguish between testing this code at compile time and
    at runtime. In both cases, it must be compiled on a system that includes the classes
    you are testing for: JDK >= 1.1 and Swing, respectively. These tests are only
    attempts to help the poor backwater Java runtime user trying to run your up-to-date
    application. The goal is to provide this user with a message more meaningful than
    the simple “class not found” error that the runtime gives. It’s also important
    to note that this test becomes unreachable if you write it inside any code that
    depends on the code you are testing. Put the test early in the main flow of your
    application, before any GUI objects are constructed. Otherwise the code just sits
    there wasting space on newer runtimes and never gets run on Java systems that
    don’t include Swing. Obviously this is a very early example, but you can use the
    same technique to test for any runtime feature added at any stage of Java’s evolution
    (see [Appendix A](app01.html#javacook-then_now) for an outline of the features
    added in each release of Java). You can also use this technique to determine whether
    a needed third-party library has been successfully added to your CLASSPATH.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要区分在编译时和运行时测试此代码。在两种情况下，必须在包含您要测试的类的系统上编译它：JDK >= 1.1 和 Swing，分别。这些测试只是试图帮助那些试图运行您更新的应用程序的Java运行时用户。目标是为这些用户提供比运行时简单的“类未找到”错误更有意义的消息。还要注意，如果将此测试编写在依赖于您正在测试的代码的任何代码内部，该测试将变得无法到达。在应用程序的主流程中尽早放置测试，在构造任何GUI对象之前。否则，该代码只会浪费在更新的运行时上的空间，而在不包含Swing的Java系统上永远不会运行。显然，这只是一个非常早期的示例，但您可以使用相同的技术测试Java演变的任何阶段添加的任何运行时特性（请参阅[附录
    A](app01.html#javacook-then_now) 了解Java每个发布版本中添加的功能概述）。您还可以使用此技术确定是否已成功将所需的第三方库添加到您的CLASSPATH中。
- en: 'Also, although Java is designed to be portable, some things aren’t. These include
    such variables as the filename separator. Everybody on Unix knows that the filename
    separator is a slash character (/) and that a backward slash, or backslash (\),
    is an escape character. Back in the late 1970s, a group at Microsoft was actually
    working on Unix—their version was called Xenix, later taken over by SCO—and the
    people working on DOS saw and liked the Unix filesystem model. The earliest versions
    of MS-DOS didn’t have directories; it just had user numbers like the system it
    was a clone of, Digital Research CP/M (itself a clone of various other systems).
    So the Microsoft developers set out to clone the Unix filesystem organization.
    Unfortunately, MS-DOS had already committed the slash character for use as an
    option delimiter, for which Unix had used a dash (`-`); and the `PATH` separator
    (:) was also used as a drive letter delimiter, as in `C`: or `A`:. So we now have
    commands like those shown in [Table 2-1](#javacook-environ-dirPaths).'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，尽管Java旨在实现可移植性，但有些情况并非如此。其中包括文件名分隔符等变量。Unix上的每个人都知道文件名分隔符是斜杠字符（/），反斜杠或反斜杠（\）是转义字符。回到20世纪70年代末，Microsoft的一个小组实际上正在研究Unix——他们的版本被称为Xenix，后来被SCO接管——并且DOS上的开发人员看到并喜欢了Unix的文件系统模型。最早期的MS-DOS没有目录；它只有像Digital
    Research CP/M（它本身是各种其他系统的克隆）那样的用户编号。因此，Microsoft的开发人员着手克隆Unix的文件系统组织。不幸的是，MS-DOS已经将斜杠字符用于用作选项分隔符，而Unix则使用破折号（`-`）；并且`PATH`分隔符（:)也用作驱动器号分隔符，如`C`:或`A`:。因此，我们现在有了像在[表 2-1](#javacook-environ-dirPaths)中所示的命令。
- en: Table 2-1\. Directory listing commands
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 表2-1\. 目录列表命令
- en: '| System | Directory list command | Meaning | Example PATH setting |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 系统 | 目录列表命令 | 含义 | 示例 PATH 设置 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Unix | *ls -R /* | Recursive listing of /, the top-level directory | *PATH=/bin:/usr/bin*
    |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| Unix | *ls -R /* | /的递归列表，顶级目录 | *PATH=/bin:/usr/bin* |'
- en: '| DOS | *dir/s \* | Directory with subdirectories option (i.e., recursive)
    of \, the top-level directory (but only of the current drive) | *PATH=C:\windows;D:\mybin*
    |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| DOS | *dir/s \* | 目录及其子目录选项（即递归）的顶级目录（但仅限当前驱动器） | *PATH=C:\windows;D:\mybin*
    |'
- en: 'Where does this get us? If we are going to generate filenames in Java, we may
    need to know whether to put a / or a \ or some other character. Java has two solutions
    to this. First, when moving between Unix and Microsoft systems, at least, it is
    *permissive*: either / or \ can be used,^([1](ch02.html#idm45290706287432)) and
    the code that deals with the operating system sorts it out. Second, and more generally,
    Java makes the platform-specific information available in a platform-independent
    way. For the file separator (and also the `PATH` separator), the `java.io.File`
    class makes available some static variables containing this information. Because
    the `File` class manages platform-dependent information, it makes sense to anchor
    this information here. The variables are shown in [Table 2-2](#javacook-environ-filesepstuff).'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这对我们有何帮助？如果我们要在Java中生成文件名，我们可能需要知道是放置/还是\或其他字符。Java有两种解决方案。首先，在移动到Unix和Microsoft系统之间时，至少是*宽容的*：可以使用/或\，^([1](ch02.html#idm45290706287432))，处理操作系统的代码会解决这个问题。其次，更普遍地，Java以与平台无关的方式提供平台特定的信息。对于文件分隔符（以及`PATH`分隔符），`java.io.File`类提供了一些包含此信息的静态变量。由于`File`类管理着与平台相关的信息，因此将此信息锚定在这里是有意义的。变量在[表 2-2](#javacook-environ-filesepstuff)中显示。
- en: Table 2-2\. Table 2-2\. File properties
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 表2-2\. 文件属性表
- en: '| Name | Type | Meaning |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 类型 | 含义 |'
- en: '| --- | --- | --- |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `separator` | `static String` | The system-dependent filename separator character
    (e.g., / or \) |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `separator` | `static String` | 系统相关的文件名分隔符字符（例如，/或\） |'
- en: '| `separatorChar` | `static char` | The system-dependent filename separator
    character (e.g., / or \) |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `separatorChar` | `static char` | 系统相关的文件名分隔符字符（例如，/或\） |'
- en: '| `pathSeparator` | `static String` | The system-dependent path separator character,
    represented as a string for convenience |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `pathSeparator` | `static String` | 系统相关的路径分隔符字符，以字符串形式表示以方便使用 |'
- en: '| `pathSeparatorChar` | `static char` | The system-dependent path separator
    character |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `pathSeparatorChar` | `static char` | 系统相关的路径分隔符字符 |'
- en: Both filename and path separators are normally characters, but they are also
    available in `String` form for convenience.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 文件名和路径分隔符通常是字符，但也以`String`形式提供以方便使用。
- en: 'A second, more general, mechanism is the `System` `Properties` object mentioned
    in [Recipe 2.2](#javacook-environ-SECT-2). You can use this to determine the operating
    system you are running on. Here is code that simply lists the system properties;
    it can be informative to run this on several different implementations:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个更一般的机制是提到的`System Properties`对象，它在[Recipe 2.2](#javacook-environ-SECT-2)中提到。您可以使用它来确定您正在运行的操作系统。以下是一个简单列出系统属性的代码；在几个不同的实现上运行这个代码可能很有启发性：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Some OSes, for example, provide a mechanism called the null device that can
    be used to discard output (typically used for timing purposes). Here is code that
    asks the system properties for the `os.name` and uses it to make up a name that
    can be used for discarding data (if no null device is known for the given platform,
    we return the name `jnk`, which means that on such platforms, we’ll occasionally
    create, well, junk files; I just remove these files when I stumble across them):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，某些操作系统提供了称为空设备的机制，可用于丢弃输出（通常用于计时目的）。以下是请求系统属性`os.name`的代码，并使用它来编制可以用于丢弃数据的名称（如果给定平台没有已知的空设备，我们返回名称`jnk`，这意味着在这些平台上，我们偶尔会创建，嗯，垃圾文件；我在偶然发现时删除这些文件）：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[![1](assets/1.png)](#co_interacting_with_the_environment_CO1-1)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_interacting_with_the_environment_CO1-1)'
- en: If `/dev/null` exists, use it.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`/dev/null`存在，请使用它。
- en: '[![2](assets/2.png)](#co_interacting_with_the_environment_CO1-2)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_interacting_with_the_environment_CO1-2)'
- en: If not, ask `System properties` if it knows the OS name.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，请询问`System properties`是否知道操作系统名称。
- en: '[![3](assets/3.png)](#co_interacting_with_the_environment_CO1-3)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_interacting_with_the_environment_CO1-3)'
- en: Nope, so give up, return `jnk`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 不行，所以放弃，返回`jnk`。
- en: '[![4](assets/4.png)](#co_interacting_with_the_environment_CO1-4)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_interacting_with_the_environment_CO1-4)'
- en: We know it’s Microsoft Windows, so use `NUL:`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道这是Microsoft Windows，所以使用`NUL:`。
- en: '[![5](assets/5.png)](#co_interacting_with_the_environment_CO1-5)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_interacting_with_the_environment_CO1-5)'
- en: All else fails, go with `jnk`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 除非所有其他方法都失败，否则使用`jnk`。
- en: Although Java’s Swing GUI aims to be portable, Apple’s implementation for macOS
    does not automatically do the right thing for everyone. For example, a `JMenuBar`
    menu container appears by default at the top of the application window. This is
    the norm on Windows and on most Unix platforms, but Mac users expect the menu
    bar for the active application to appear at the top of the screen. To enable normal
    behavior, you have to set the `System` property `apple.laf.useScreenMenuBar` to
    the value `true` before the Swing GUI starts up. You might want to set some other
    properties too, such as a short name for your application to appear in the menu
    bar (the default is the full class name of your main application class).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Java的Swing GUI旨在具有可移植性，但苹果在macOS上的实现并不会自动为每个人都正确处理。例如，`JMenuBar`菜单容器默认出现在应用程序窗口的顶部。这在Windows和大多数Unix平台上是正常的，但Mac用户希望活动应用程序的菜单栏出现在屏幕顶部。为了启用正常行为，您必须在Swing
    GUI启动之前将`System`属性`apple.laf.useScreenMenuBar`设置为`true`。您可能还想设置其他一些属性，例如在菜单栏中显示应用程序的短名称（默认为主应用程序类的完整类名）。
- en: There is an example of this in the book’s source code, at *src/main/java/gui/MacOsUiHints.java*.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 书中源代码的示例，在*src/main/java/gui/MacOsUiHints.java*中可以找到。
- en: 'There is probably no point in setting these properties unless you are, in fact,
    being run under macOS. How do you tell? Apple’s recommended way is to check for
    the system property `mrj.runtime` and, if so, assume you are on macOS:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 设置这些属性可能没有意义，除非实际上是在macOS下运行。如何判断？苹果推荐的方法是检查系统属性`mrj.runtime`，如果是，则假定您正在使用macOS：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: On the other hand, these properties are likely harmless on non-Mac systems,
    so you could just skip the test and set the two properties unconditionally.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在非Mac系统上这些属性可能无害，因此您可以跳过测试并无条件设置这两个属性。
- en: Finally, the Mac’s Dock or the Taskbar on most other systems can be accessed
    using the `java.awt.Taskbar` class that was added in Java 9. This is not discussed
    here, but there is an example `TaskbarDemo` in the `main/gui` subdirectory.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Mac的Dock或大多数其他系统上的任务栏可以使用在Java 9中添加的`java.awt.Taskbar`类访问。这里没有讨论，但在`main/gui`子目录中有一个名为`TaskbarDemo`的示例。
- en: 2.4 Using Extensions or Other Packaged APIs
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.4 使用扩展或其他打包的API
- en: Problem
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You have a JAR file of classes you want to use.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你有一个你想使用的类的JAR文件。
- en: Solution
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Simply add the JAR file to your `CLASSPATH`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 只需将JAR文件添加到您的`CLASSPATH`中。
- en: Discussion
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: As you build more sophisticated applications, you will need to use more and
    more third-party libraries. You can add these to your `CLASSPATH`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您构建更复杂的应用程序，您将需要使用越来越多的第三方库。您可以将它们添加到您的 `CLASSPATH` 中。
- en: It used to be recommended that you drop these JAR files into the Java Extensions
    mechanism directory, typically something like *\jdk1.x\jre\lib\ext*., instead
    of listing each JAR file in your `CLASSPATH` variable. However, this is no longer
    generally recommended and is no longer available in the latest JDKs. Instead,
    you may wish to use build tools like Maven (see [Recipe 1.7](ch01.html#javacook-getstarted-maven))
    or Gradle, as well as IDEs, to automate the addition of JAR files to your `CLASSPATH`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以前建议将这些 JAR 文件放入 Java 扩展机制目录，通常类似于 *\jdk1.x\jre\lib\ext*，而不是在 `CLASSPATH` 变量中列出每个
    JAR 文件。但是，现在一般不再推荐这样做，最新的 JDK 中也不再支持。相反，您可能希望使用像 Maven（参见 [Recipe 1.7](ch01.html#javacook-getstarted-maven)）或
    Gradle 这样的构建工具，以及集成开发环境（IDE），来自动添加 JAR 文件到您的 `CLASSPATH` 中。
- en: One reason I’ve never been fond of using the extensions directory is that it
    requires modifying the installed JDK or JRE, which can lead to maintenance issues
    and problems when a new JDK or JRE is installed.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我不喜欢使用扩展目录的一个原因是，它需要修改已安装的 JDK 或 JRE，这可能会导致维护问题，以及在安装新 JDK 或 JRE 时出现问题。
- en: Java 9 introduced a major change to Java, the Java 9 Modules system for program
    modularization, which we discuss in [Recipe 2.5](#javacook-environ-modules).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9 引入了对 Java 的重大改变，即 Java 9 模块系统用于程序模块化，我们在 [Recipe 2.5](#javacook-environ-modules)
    中进行了讨论。
- en: 2.5 Using the Java Modules System
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.5 使用 Java 模块系统
- en: Problem
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You are using Java 9 or later, and need to deal with the Modules mechanism.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您正在使用 Java 9 或更高版本，并且需要处理模块机制。
- en: Solution
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Read on.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 继续阅读。
- en: Discussion
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Java’s Modules system, formerly known as Project Jigsaw, was designed to handle
    the need to build large applications out of many small pieces. To an extent this
    problem had been solved by tools like Maven and Gradle, but the Modules system
    solves a slightly different problem than those tools. Maven or Gradle will find
    dependencies, download them, install them on your development and test runtimes,
    and package them into runnable JAR files. The Modules system is more concerned
    with the visbility of classes from one chunk of application code to another, typically
    provided by different developers who may not know or trust each other. As such,
    it is an admission that Java’s original set of access modifiers—such as `public`,
    `private`, `protected`, and default visibility—was not sufficient for building
    large-scale applications.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Java 模块系统，以前称为项目 Jigsaw，旨在解决构建大型应用程序所需的许多小部分的问题。在某种程度上，像 Maven 和 Gradle 这样的工具已经解决了这个问题，但模块系统解决的问题与这些工具略有不同。Maven
    或 Gradle 将找到依赖项，下载它们，在您的开发和测试运行时安装它们，并将它们打包成可运行的 JAR 文件。模块系统更关注于从一个应用程序代码块到另一个代码块的类的可见性，通常是由不同的开发人员提供，他们可能不了解或信任彼此。因此，这表明
    Java 最初的访问修饰符集（如 `public`、`private`、`protected` 和默认可见性）对于构建大型应用程序是不够的。
- en: 'What follows is a brief discussion of using JPMS, the Java Platform Module
    System, to import modules into your application. There is an introduction to creating
    your own modules in [Chapter 15](ch15.html#javacook-packages). For a more detailed
    presentation, you should refer to a book-length treatment such as [*Java 9 Modularity:
    Patterns and Practices for Developing Maintainable Applications*](http://shop.oreilly.com/product/0636920049494.do)
    by Sander Mak and Paul Bakker (O’Reilly).'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来简要讨论使用 JPMS，即 Java 平台模块系统，将模块导入到您的应用程序中。在 [第 15 章](ch15.html#javacook-packages)
    中介绍了创建自己的模块。如需更详细的介绍，您可以参考像 *Java 9 Modularity: Patterns and Practices for Developing
    Maintainable Applications* 这样的专著，作者是 Sander Mak 和 Paul Bakker（O’Reilly）。'
- en: 'Java has always been a language for large-scale development. Object orientation
    is one of the keys: classes and objects group methods, and access modifiers can
    be applied so that public and private methods are clearly separated. When developing
    large applications, having just a single flat namespace of classes is still not
    enough. Enter packages: they gather classes into logical groups within their own
    namespace. Access control can be applied at the package level as well so that
    some classes are only accessible inside a package. Modules are the next logical
    step up. A module groups some number of related packages, has a distinct name,
    and can restrict access to some packages while exposing other packages to different
    modules as public API.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Java一直是大规模开发的语言。面向对象是其中的关键之一：类和对象组合方法，访问修饰符可以应用，使得公共和私有方法清晰分离。在开发大型应用程序时，仅具有类的单一扁平命名空间仍然不够。进入包：它们将类收集到其自己的命名空间内的逻辑组中。同样可以在包级别应用访问控制，以便某些类仅在包内可访问。模块是更高一级的下一步。模块将一些相关的包组合在一起，具有明确的名称，并且可以限制对某些包的访问，同时将其他包作为公共API暴露给不同的模块。
- en: 'One thing to understand at the outset: JPMS is not a replacement for your existing
    build tool. Whether you use Maven, Gradle, Ant, or just dump all needed JAR files
    into a lib directory, you still need to do that. Also, don’t confuse Maven’s modules
    with JPMS modules; the former is the physical structuring of a project into subprojects,
    and the latter is something the Java platform (compiler, runtime) understands.
    Usually when working with Java modules, each Java module will equate to a single
    Maven module.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始要理解的一件事：JPMS并不是你现有构建工具的替代品。无论你使用Maven、Gradle、Ant，还是只是将所有需要的JAR文件倒入lib目录，你仍然需要这样做。同时，不要将Maven的模块与JPMS模块混淆；前者是将项目物理结构化为子项目，后者是Java平台（编译器、运行时）理解的内容。通常在使用Java模块时，每个Java模块将等同于一个单独的Maven模块。
- en: When you’re dealing with a tiny, self-contained program, you don’t need to be
    concerned with modules. Just put all the necessary JAR files on your `CLASSPATH`
    at compile time and runtime, and all will be well. Probably.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当你处理一个小而自包含的程序时，你不需要担心模块。只需在编译时和运行时将所有必要的JAR文件放在你的`CLASSPATH`上，一切都会很好。可能。
- en: 'You may see warning messages like this along the way:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在此过程中，你可能会看到类似以下的警告消息：
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The warning message comes about as a result of JPMS doing its job, checking
    that no types are accessed in encapsulated packages within a module. Such messages
    will go away over time as all public Java libraries and all apps being developed
    get modularized.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 警告消息是由于JPMS在执行其作业时产生的，检查在模块内封装的包中是否访问了任何类型。随着所有公共Java库和正在开发的所有应用程序逐步模块化，此类消息将逐渐消失。
- en: Why will all be well only “probably”? If you are using certain classes that
    were deprecated over the last few releases, things won’t compile. For that, you
    must make the requisite modules available. In the *unsafe* subdirectory (also
    a Maven module) under `javasrc`, there is a class called `LoadAverage`. The load
    average is a feature of Unix/Linux systems that gives a rough measure of system
    load or busyness, by reporting the number of processes that are waiting to be
    run. There are almost always more processes running than CPU cores to run them
    on, so some always have to wait. Higher numbers mean a busier system with slower
    response.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么仅“可能”一切都会很好？如果你使用了在过去几个版本中已被弃用的某些类，事情将无法编译。为此，你必须使相应的模块可用。在`javasrc`下的*unsafe*子目录（也是一个Maven模块）中，有一个名为`LoadAverage`的类。负载平均值是Unix/Linux系统的一个特性，通过报告等待运行的进程数，给出了系统负载或繁忙程度的粗略测量。几乎总是有更多的进程在运行，而CPU核心数却要少于它们，因此总有一些进程需要等待。更高的数字意味着一个更繁忙的系统，响应速度较慢。
- en: Sun’s unsupported `Unsafe` class has a method for obtaining the load average,
    on systems that support it. The code has to use the Reflection API (see [Chapter 17](ch17.html#javacook-reflection))
    to obtain the `Unsafe` object; if you try to instantiate `Unsafe` directly you
    will get a `SecurityException` (this was the case before the Modules system).
    Once the instance is obtained and casted to `Unsafe`, you can invoke methods such
    as `loadAverage()` ([Example 2-4](#javacook-environ-modules-1)).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Sun不支持的`Unsafe`类具有一个方法来获取负载平均值，仅在支持它的系统上。代码必须使用反射API（参见[第17章](ch17.html#javacook-reflection)）来获取`Unsafe`对象；如果尝试直接实例化`Unsafe`，将会得到`SecurityException`（这在模块系统之前是这样）。一旦获取了实例并将其转换为`Unsafe`，就可以调用诸如`loadAverage()`（[示例2-4](#javacook-environ-modules-1)）之类的方法。
- en: Example 2-4\. unsafe/src/main/java/unsafe/LoadAverage.java (use of Unsafe.java)
  id: totrans-115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-4\. unsafe/src/main/java/unsafe/LoadAverage.java（使用Unsafe.java）
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This code, which used to compile, gives warnings. If we are using Java Modules,
    we must modify our *module-info.java* file to tell the compiler and VM that we
    require use of the module with the semi-obvious name `jdk.unsupported`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码曾经编译通过，现在却产生了警告。如果我们正在使用Java模块，则必须修改我们的*module-info.java*文件，告诉编译器和VM我们需要使用半明显命名的模块`jdk.unsupported`。
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We’ll say more about the module file format in [Recipe 15.9](ch15.html#javacook-packages-creating-JPMS-modules).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[Recipe 15.9](ch15.html#javacook-packages-creating-JPMS-modules)中详细介绍模块文件格式。
- en: 'Now that we have the code in place and the module file in the top level of
    the source folder, we can build the project, run the program, and compare its
    output against the system-level tool for displaying the load average, `uptime`.
    We’ll still get the “internal proprietary API” warnings, but it works:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编写了代码并将模块文件放在了源文件夹的顶层，我们可以构建项目、运行程序，并将其输出与系统级工具*uptime*显示的负载平均值进行比较，例如，`uptime`。尽管我们仍然会收到“内部专有API”警告，但它确实有效：
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Thankfully, it works and gives the same numbers as the standard Unix *uptime*
    command. At least, it works on Java 11\. As the warnings imply, it *may* (i.e.,
    probably will) be removed in a later release.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，它确实有效，并且与标准Unix *uptime*命令给出相同的数字。至少在Java 11上有效。正如警告所示，它*可能*（即很可能）会在以后的版本中删除。
- en: 'If you are building a more complex app, you will probably need to put together
    a more complete *module-info.java* file. But at this stage it’s primarily a matter
    of requiring the modules you need. The standard Java API is divided into several
    modules, which you can list using the *java* command:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在构建一个更复杂的应用程序，您可能需要编写一个更完整的*module-info.java*文件。但在这个阶段，主要是需要的模块。标准Java API分为几个模块，您可以使用*java*命令列出它们：
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Of these, `java.base` is always available and doesn’t need to be listed in
    your module file, `java.desktop` adds AWT and Swing for graphics, and `java.se`
    includes basically all of what used to be public API in the Java SDK. If our load
    average program wanted to display the result in a Swing window, for example, it
    would need to add this into its module file:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，`java.base`始终可用且无需在模块文件中列出，`java.desktop`添加了用于图形的AWT和Swing，而`java.se`则包含了Java
    SDK中以前的几乎所有公共API。例如，如果我们的负载平均程序想要在Swing窗口中显示结果，就需要将其添加到模块文件中：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When your application is big enough to be divided into tiers or layers, you
    will probably want to describe these modules using JPMS. Since that topic comes
    under the heading of packaging, it is described in [Recipe 15.9](ch15.html#javacook-packages-creating-JPMS-modules).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的应用程序足够大，可以划分为多个层次或层次时，您可能希望使用JPMS描述这些模块。由于这个主题属于打包的范畴，它在[Recipe 15.9](ch15.html#javacook-packages-creating-JPMS-modules)中有描述。
- en: '^([1](ch02.html#idm45290706287432-marker)) When compiling strings for use on
    Windows, remember to double them because \ is an escape character in most places
    other than the MS-DOS command line: `String rootDir = "C:\\";`.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch02.html#idm45290706287432-marker)) 在为在Windows上使用的字符串编译时，请记住在大多数地方（除了MS-DOS命令行）\
    是转义字符：`String rootDir = "C:\\";`.
