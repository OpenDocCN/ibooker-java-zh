- en: Chapter 13\. Asynchronous Tasks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章 异步任务
- en: Modern workloads require more thought about how to use available system resources
    efficiently. Asynchronous tasks are an excellent tool for improving the responsiveness
    of your application by avoiding performance bottlenecks.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现代工作负载需要更多关于如何高效利用系统资源的考虑。异步任务是提高应用响应性的绝佳工具，可以避免性能瓶颈。
- en: Java 8 introduced the new type `CompletableFuture<T>`, which improved upon the
    previously available `Future<T>` type to create async tasks by utilizing a declarative
    and functional approach.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8引入了新类型`CompletableFuture<T>`，它在以前的`Future<T>`类型基础上进行了改进，通过声明式和函数式方法创建异步任务。
- en: This chapter explains why and how to utilize asynchronous programming and how
    `CompletableFuture<T>` is a more flexible and functional approach to asynchronous
    tasks than what was included in the JDK before.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了为什么以及如何利用异步编程，以及`CompletableFuture<T>`相比JDK之前的异步任务更灵活和功能更强的方法。
- en: Synchronous Versus Asynchronous
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步与异步
- en: The concept of synchronous and asynchronous tasks is not restricted to software
    development.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 同步和异步任务的概念并不局限于软件开发。
- en: For example, an in-person meeting or conference call is a synchronous activity,
    at least if you pay attention. You can’t do anything else except participate and
    maybe take notes. Every other task is *blocked* until the meeting/call is over.
    If the meeting/call would have been an e-mail instead — as most of my meetings
    could and should be — your current task isn’t interrupted by requiring immediate
    attention before you could resume your previous task. Therefore, an e-mail is
    *non-blocking* communication.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，面对面会议或电话会议是同步活动，至少是如果你专心的话。除了参与和可能做笔记外，你无法做其他任何事情。每个其他任务在会议/电话结束之前都被*阻塞*。如果会议/电话本应该是一封电子邮件——正如我大多数会议本应该的那样——则你当前的任务不会因需要立即注意而中断以前的任务。因此，电子邮件是*非阻塞*通信。
- en: The same principles are true for software development. Synchronously executed
    tasks run in sequence, blocking further work until they’re finished. From a single-threaded
    point of view, a blocking task means waiting for the result, possibly wasting
    resources by not doing anything else until the task is finished.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发中也适用同样的原则。同步执行的任务按顺序运行，阻塞后续工作直到它们完成。从单线程的角度看，阻塞任务意味着等待结果，可能会浪费资源，因为在任务完成之前不做任何其他事情。
- en: Asynchronous tasks are about starting a task that is processed “somewhere else”
    and you get notified when it’s done. Such tasks are non-blocking by using concurrency
    techniques to spin off their work — usually to another thread — so they don’t
    have to wait for them to finish. Therefore, the current thread isn’t blocked and
    can continue with other tasks, as illustrated in [Figure 13-1](#_02-completable-future_sync-vs-async).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 异步任务是启动一个在“其他地方”处理的任务，并在完成时得到通知。通过并发技术将它们的工作分发出去——通常是到另一个线程——以便它们不必等待完成。因此，当前线程不被阻塞，可以继续执行其他任务，正如[图13-1](#_02-completable-future_sync-vs-async)中所示。
- en: '![Comparison of synchronous and asynchronous execution](assets/afaj_1301.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![同步与异步执行的比较](assets/afaj_1301.png)'
- en: Figure 13-1\. Comparison of synchronous and asynchronous execution
  id: totrans-10
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图13-1 同步与异步执行的比较
- en: Parallel execution, as I’ve discussed in [Chapter 8](ch08.xhtml#_01-parallel-streams),
    strives for maximum throughput as its primary objective; the completion time of
    a single task is generally of lesser concern in the greater scheme of things.
    An asynchronous execution model like with `CompletableFuture`, on the other hand,
    is focused on the overall latency and responsiveness of the system. Spinning off
    tasks ensures a responsive system even in single-threaded or resource-constrained
    environments.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 并行执行，正如我在[第8章](ch08.xhtml#_01-parallel-streams)中讨论的，追求最大吞吐量作为其主要目标；单个任务的完成时间通常不是大计划中的重点。另一方面，像`CompletableFuture`这样的异步执行模型专注于系统的整体延迟和响应性。分发任务确保了响应迅速的系统，即使在单线程或资源受限的环境中也是如此。
- en: Java Futures
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java Futures
- en: Java 5 introduced the interface `java.util.concurrent.Future<T>` as a container
    type for an eventual result of an asynchronous computation. To create a `Future`,
    a task in the form of a `Runnable` or a `Callable<T>` gets submitted to an `ExecutorService`
    which starts the task in a separate thread but immediately returns a Future instance.
    This way, the current thread can continue to do more work without waiting for
    the eventual result of the `Future` computation.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Java 5 引入了接口 `java.util.concurrent.Future<T>` 作为异步计算结果的容器类型。要创建一个 `Future`，需要将任务以
    `Runnable` 或 `Callable<T>` 的形式提交给 `ExecutorService`，后者在单独的线程中启动任务，但立即返回一个 `Future`
    实例。这样，当前线程可以继续执行更多工作，而不必等待 `Future` 计算的最终结果。
- en: The result is retrievable by calling the `get` method on a `Future<T>` instance,
    which might block the current thread, though, if the computation hasn’t finished
    yet. A simple example of the general flow is visualized in [Example 13-1](#_02-completable-future_execution-flow).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在 `Future<T>` 实例上调用 `get` 方法来检索结果，如果计算尚未完成，可能会阻塞当前线程。通常的流程示例在 [示例 13-1](#_02-completable-future_execution-flow)
    中有所体现。
- en: Example 13-1\. `Future<T>` flow of execution
  id: totrans-15
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 13-1\. `Future<T>` 执行流程
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[![1](assets/1.png)](#co_asynchronous_tasks_CO1-1)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asynchronous_tasks_CO1-1)'
- en: An explicit `ExecutorService` is needed to spin-off a `Callable<T>` or `Runnable`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 需要显式的 `ExecutorService` 来启动 `Callable<T>` 或 `Runnable`。
- en: '[![2](assets/2.png)](#co_asynchronous_tasks_CO1-2)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asynchronous_tasks_CO1-2)'
- en: The `Callable<T>` interface has been available since before the introduction
    of lambdas of functional interfaces. Its intended use case is equivalent to `Supplier<T>`
    but it throws an `Exception` in its single abstract method.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`Callable<T>` 接口在函数接口引入 lambda 之前就已经存在了。它的预期用法相当于 `Supplier<T>`，但在其单一抽象方法中抛出
    `Exception`。'
- en: '[![3](assets/3.png)](#co_asynchronous_tasks_CO1-3)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_asynchronous_tasks_CO1-3)'
- en: The computation of `expensiveTask` starts immediately, reflected in the output.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`expensiveTask` 的计算立即开始，并反映在输出中。'
- en: '[![4](assets/4.png)](#co_asynchronous_tasks_CO1-4)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_asynchronous_tasks_CO1-4)'
- en: At this point, the calculation isn’t finished yet, so calling the `get` method
    on `future` blocks the current thread until it is finished.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此时计算尚未完成，因此在 `future` 上调用 `get` 方法会阻塞当前线程，直到完成为止。
- en: 'Although the `Future<T>` type achieves the essential requirement of being a
    *non-blocking* container for asynchronous computation, its feature set is limited
    to only a few methods: checking if the computation is done, canceling it, and
    retrieving its result.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `Future<T>` 类型达到了作为 *非阻塞* 异步计算容器的基本要求，但其功能集仅限于几种方法：检查计算是否完成、取消计算和检索结果。
- en: 'To have a versatile tool for asynchronous programming, there are a lot of features
    left to be desired:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了拥有一个多功能的异步编程工具，还有很多功能有待改进：
- en: Easier way of retrieving a result, like callbacks on completion or failure.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更容易地获取结果，如在完成或失败时的回调。
- en: Chaining and combining multiple tasks in the spirit of functional composition.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数组合的精神中链接和组合多个任务。
- en: Integrated error handling and recovery possibilities.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成错误处理和恢复可能性。
- en: Manual creation or completion of tasks without requiring an `ExecutorService`.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无需 `ExecutorService`，可以手动创建或完成任务。
- en: Java 8 improved upon Futures to remedy the lacking features by introducing the
    interface `CompletionStage<T>`, and its sole implementation, `CompletableFuture<T>`,
    in the same package `java.util.concurrent`. They’re versatile tools to build asynchronous
    task pipelines with a richer feature set than Futures before them. Where `Future<T>`
    is a container type for an asynchronous computation of an eventual value, `CompletionStage<T>`
    represents a single stage of an asynchronous pipeline with a massive API of over
    70 methods!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8 在 Futures 的基础上进行了改进，通过引入接口 `CompletionStage<T>` 和其唯一实现 `CompletableFuture<T>`
    来弥补缺失的功能。它们位于同一包 `java.util.concurrent` 中，是构建异步任务管道的多功能工具，功能集比它们之前的 Futures 更丰富。其中，`Future<T>`
    是一个异步计算最终值的容器类型，而 `CompletionStage<T>` 表示异步管道的单个阶段，具有超过 70 个方法的大量 API！
- en: Designing Asynchronous Pipelines with CompletableFuture<T>
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 CompletableFuture<T> 设计异步管道
- en: 'The general design philosophy of CompletableFutures is similar to Streams:
    both are task-based pipelines offering parameterized methods accepting common
    functional interfaces. The new API adds a myriad of coordination tools that return
    new instances of `CompletionStage<T>` or +CompletableFuture<T>. This amalgamation
    of a container for asynchronous computation and coordination tools provides all
    the previously missing features in a fluently composable and declarative API.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: CompletableFuture的一般设计哲学与Streams类似：两者都是基于任务的管道，提供接受常见函数接口的参数化方法。新的API添加了大量的协调工具，返回`CompletionStage<T>`或+CompletableFuture<T>的新实例。这种异步计算和协调工具的结合提供了以前缺失的所有功能，以流畅的组合和声明性API。
- en: 'Due to the massive `CompletableFuture<T>` API and the complex mental model
    of asynchronous programming in general, let’s start with a simple metaphor: *making
    breakfast*.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于庞大的`CompletableFuture<T>`API和异步编程的复杂思维模型，让我们从一个简单的比喻开始：*做早餐*。
- en: The imaginary breakfast consists of coffee, toast, and eggs. Preparing the breakfast
    in synchronous — or *blocking* — order doesn’t make much sense. Waiting for the
    coffee maker to finish or for the toast to be done before starting with the eggs
    is a poor use of available resources that will add unnecessarily to the total
    prep time, leaving you hungry by the time you sit down to eat. Instead, you can
    start frying the eggs while the coffee maker and toaster do their thing and only
    react to them when the toaster pops or the coffeemaker is done.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 想象的早餐由咖啡，面包和鸡蛋组成。按照同步 — 或*阻塞* — 顺序准备早餐并没有太多意义。在咖啡壶完成或面包机完成之前等待开始煎鸡蛋是对可用资源的浪费，这将不必要地增加总准备时间，让你在坐下来吃饭时已经饿了。相反，你可以在咖啡壶和烤面包机工作时开始煎鸡蛋，只有当烤面包机弹出或咖啡壶完成时才对它们做出反应。
- en: 'The same logic applies to programming. The available resources should be allocated
    as needed and not wasted by waiting for *expensive* and long-running tasks. The
    underlying concept of such asynchronous pipelines is available in many languages
    under a different, maybe more common name: *Promises*.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 编程也是如此。可用资源应根据需要分配，不要浪费在*昂贵*且耗时长的任务上等待。这种异步管道的基本概念在许多语言中都以不同的名称存在，也许更常见的是*Promises*。
- en: Promising a Value
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 承诺一个值
- en: '*Promises* are the building blocks for asynchronous pipelines with built-in
    coordination tools that allow chaining and combining multiple tasks, including
    error handling. Such a building block is either *pending* (not settled), *resolved*
    (settled and computation completed), or *rejected* (settled, but in the error
    state). Moving between states in the compositional pipeline is done by switching
    between two channels: *data* and *error*, as shown in [Figure 13-2](#_02-completable-future_channels).'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*Promises*是具有内置协调工具的异步管道的构建模块，允许链接和组合多个任务，包括错误处理。这样一个构建块要么是*pending*（未解决），要么是*resolved*（已解决且计算完成），要么是*rejected*（已解决，但处于错误状态）。在组合管道中在状态之间移动是通过在两个通道之间切换：*数据*和*错误*来完成的，如[图13-2](#_02-completable-future_channels)所示。'
- en: '![Promise data and error channels](assets/afaj_1302.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![Promise data and error channels](assets/afaj_1302.png)'
- en: Figure 13-2\. Promise data and error channels
  id: totrans-40
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图13-2. 承诺数据和错误通道
- en: The data channel is the “happy path” if everything goes right. However, if a
    promise fails, the pipeline switches to the error channel. This way, a failure
    doesn’t crash the whole pipeline, like with Streams, and can be handled gracefully,
    or even recover and switch the pipeline back to the data channel.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 数据通道是“快乐路径”，如果一切顺利的话。然而，如果一个承诺失败，管道将切换到错误通道。这样，失败就不会像流（Streams）那样使整个管道崩溃，可以优雅地处理，甚至可以恢复并将管道切换回数据通道。
- en: As you will see, the CompletableFuture API is a Promise by another name.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，CompletableFuture API就是另一个名字的Promise。
- en: Creating a CompletableFuture<T>
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个CompletableFuture<T>
- en: Like its predecessor, `Future<T>`, the new `CompletableFuture<T>` type doesn’t
    provide any constructors to create an instance. New `Future<T>` instances are
    created by submitting tasks to `java.util.concurrent.ExecutorService` which returns
    an instance with its task already started.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 与其前身`Future<T>`一样，新的`CompletableFuture<T>`类型不提供任何构造函数来创建实例。新的`Future<T>`实例是通过将任务提交给`java.util.concurrent.ExecutorService`来创建的，后者会返回一个已经启动了任务的实例。
- en: '`CompletableFuture<T>` follows the same principle. However, it doesn’t necessarily
    require an explicit `ExecutorService` to schedule tasks, thanks to its `static`
    factory methods:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompletableFuture<T>`遵循相同的原则。然而，它不一定需要一个显式的`ExecutorService`来调度任务，这要归功于它的`static`工厂方法：'
- en: '`CompletableFuture<Void> runAsync(Runnable runnable)`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompletableFuture<Void> runAsync(Runnable runnable)`'
- en: '`CompletableFuture<U> supplyAsync(Supplier<U> supplier)`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompletableFuture<U> supplyAsync(Supplier<U> supplier)`'
- en: Both methods are also available with a second argument, accepting a `java.util.concurrent.Executor`,
    which is the base interface of the `ExecutorService` type. If you choose the `Executor`-less
    variants, the common ForkJoinPool is used, just like for parallel Stream pipelines
    as explained in [“Streams as Parallel Functional Pipelines”](ch08.xhtml#_01-parallel-concurrent-async_parallel-streams).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法还支持第二个参数，接受一个`java.util.concurrent.Executor`，这是`ExecutorService`类型的基础接口。如果选择不带`Executor`的变体，就会使用通用的ForkJoinPool，就像在[“流作为并行功能管道”](ch08.xhtml#_01-parallel-concurrent-async_parallel-streams)中解释的并行流管道一样。
- en: Note
  id: totrans-49
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The most apparent difference to submitting tasks to an `ExecutorService` for
    creating a `Future<T>` is the use of `Supplier<T>` instead of `Callable<T>`. The
    latter explicitly throws an `Exception` in its method signature. Therefore, `supplyAsync`
    isn’t a drop-in replacement for submitting a `Callable<T>` to an `Executor`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 将任务提交给`ExecutorService`以创建`Future<T>`最明显的区别是使用`Supplier<T>`代替`Callable<T>`。后者在其方法签名中明确抛出异常。因此，`supplyAsync`不能完全替代将`Callable<T>`提交给`Executor`。
- en: Creating a `CompletableFuture<T>` instance is almost equivalent to creating
    a `Future<T>` one, as shown in [Example 13-2](#_02-completable-future_creation-vs-future).
    The example doesn’t use type inference, so the returning types are visible. Usually,
    you would prefer the `var` keyword instead of using the explicit type.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`CompletableFuture<T>`实例几乎等同于创建`Future<T>`实例，如[示例 13-2](#_02-completable-future_creation-vs-future)所示。示例没有使用类型推断，因此返回类型是可见的。通常情况下，你会更喜欢使用`var`关键字而不是显式类型。
- en: Example 13-2\. CompletableFuture creation with convenience methods
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 13-2\. 使用便捷方法创建`CompletableFuture`
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Even though the creation of instances is similar between `Future<T>` and `CompletableFuture<T>`,
    the latter is more concise by not necessarily requiring an `ExecutorService`.
    The bigger difference, though, is that a `CompletableFuture<T>` instance provides
    a starting point for a declarative and functional pipeline of `CompletionStage<T>`
    instances instead of a singular isolated async task in the case of a `Future<T>`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在`Future<T>`和`CompletableFuture<T>`的实例创建之间存在相似之处，但后者更为简洁，不一定需要`ExecutorService`。然而，更大的区别在于，`CompletableFuture<T>`实例提供了`CompletionStage<T>`实例的声明式和函数式管道的起点，而不是`Future<T>`的单一孤立的异步任务。
- en: Compositing and Combining Tasks
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合和合并任务
- en: After starting with a `CompletableFuture<T>` instance, it’s time to combine
    and compose them further to create a more complex pipeline.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`CompletableFuture<T>`实例开始后，可以进一步组合和组成它们，以创建更复杂的管道。
- en: 'The broad range of operations available to build your asynchronous pipelines
    is separable into three groups, depending on their accepted arguments and intended
    use cases:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 可用于构建异步管道的广泛操作可以根据其接受的参数和预期的使用案例分为三组：
- en: Transforming a result
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 转换结果
- en: Like the `map` operation of Streams and Optionals, the CompletableFuture API
    gives you the similar `thenApply` method, which uses a `Function<T, U>` to transform
    the previous result of type `T` and returns another `CompletionStage<U>`. If the
    transformation function returns another `CompletionStage`, using the `thenCompose`
    method prevents additional nesting, similar to Stream’s and Optional’s `flatMap`
    operation.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于流和可选项的`map`操作，CompletableFuture API提供了类似的`thenApply`方法，它使用`Function<T, U>`来转换类型为`T`的前一个结果，并返回另一个`CompletionStage<U>`。如果转换函数返回另一个`CompletionStage`，使用`thenCompose`方法可以防止额外的嵌套，类似于流和可选项的`flatMap`操作。
- en: Consuming a result
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 消费结果
- en: As its name suggests, the `thenAccept` method requires a `Consumer<T>` to work
    with the previous result of type `T` and returns a new `CompletionStage<Void>`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所示，`thenAccept`方法需要一个`Consumer<T>`来处理类型为`T`的前一个结果，并返回一个新的`CompletionStage<Void>`。
- en: Executing after finishing
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 执行完成后
- en: If you don’t require access to the previous result, the `thenRun` method executes
    a `Runnable` and returns a new `CompletionStage<Void>`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不需要访问前一个结果，`thenRun`方法会执行一个`Runnable`并返回一个新的`CompletionStage<Void>`。
- en: 'There are too many methods to discuss each one in detail, especially with the
    additional `-Async` methods. Most of these methods have two additional `-Async`
    variants: one matching the non-`Async` and another one with an additional `Executor`
    argument.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于存在太多方法，特别是额外的 `-Async` 方法，无法详细讨论每一个。其中大多数方法都有两个额外的 `-Async` 变体：一个与非 `-Async`
    匹配，另一个带有额外的 `Executor` 参数。
- en: The non-`Async` methods execute their task in the same thread as the previous
    task, even though that’s not guaranteed, as explained later in [“About Thread
    Pools and Timeouts”](#_02-completable-future_threads). The `-Async` variants will
    use a new thread, either created by the common `ForkJoinPool`, or by the provided
    `Executor`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 非 `-Async` 方法在与前一个任务相同的线程中执行其任务，尽管这并不保证，如后文 [“关于线程池和超时”](#_02-completable-future_threads)
    所述。 `-Async` 变体将使用一个新线程，由公共 `ForkJoinPool` 创建，或由提供的 `Executor` 创建。
- en: I will mostly discuss the non-`Async` variants to keep things simple.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持简单，我将主要讨论非 `-Async` 变体。
- en: Compositing Tasks
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组合任务
- en: Compositing tasks creates a serial pipeline of connected CompletionStages.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 组合任务创建了一个连接的 CompletionStages 串行管道。
- en: 'All compositing operations follow a general naming scheme:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 所有组合操作都遵循一个通用的命名方案：
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `<operation>` name derives from the type of operation and its arguments,
    mainly using the prefix `then` plus the name of the SAM of the functional interface
    they accept:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`<操作>` 名称来源于操作类型及其参数，主要使用功能接口的 SAM 前缀 `then` 加上它们接受的功能接口的名称：'
- en: '`CompletableFuture<Void> thenAccept(Consumer<? super T> action)`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompletableFuture<Void> thenAccept(Consumer<? super T> action)`'
- en: '`CompletableFuture<Void> thenRun(Runnable action)`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompletableFuture<Void> thenRun(Runnable action)`'
- en: '`CompletableFuture<U> thenApply(Function<? super T,? extends U> fn)`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompletableFuture<U> thenApply(Function<? super T,? extends U> fn)`'
- en: 'Thanks to the API’s proper naming scheme, using any of the operations results
    in a fluent and straightforward call chain. For example, imagine a bookmark manager
    that scrapes its websites for storing a permanent copy. The overall task could
    be run async so it won’t stop the UI thread. The task itself consists of three
    steps: downloading the website, preparing the content for offline consumption,
    and finally, storing it, as shown in [Example 13-3](#_02-completable-future_async-bookmark-manager_compositing).'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 API 的良好命名方案，使用任何操作都会产生流畅且简单的调用链。例如，想象一个书签管理器，它会扫描其网站以存储永久副本。整个任务可以异步运行，因此不会阻塞
    UI 线程。任务本身包括三个步骤：下载网站、准备内容以供离线使用，最后存储，如 [示例 13-3](#_02-completable-future_async-bookmark-manager_compositing)
    所示。
- en: Example 13-3\. Async bookmark manager workflow
  id: totrans-76
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 13-3\. 异步书签管理器工作流程
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Compositing operations are 1:1-only, meaning they take the result of the previous
    stage and do their intended job. If your task pipeline requires multiple flows
    to converge, you need to combine tasks.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 组合操作仅支持 1:1，意味着它们接受前一阶段的结果并执行其预期的工作。如果您的任务管道需要多个流汇聚，您需要组合任务。
- en: Combining Tasks
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组合任务
- en: Compositing interconnected futures to create a more complex task can be immensely
    helpful. Sometimes, however, the different tasks don’t need or can run in serial.
    In this case, you can combine `CompletionStage` instances by using operations
    that accept another stage in addition to their usual arguments.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 将互相连接的 futures 组合以创建更复杂的任务可能非常有帮助。然而，有时不同的任务不需要或可以串行运行。在这种情况下，您可以使用接受另一个阶段的操作来组合
    `CompletionStage` 实例。
- en: 'Their naming scheme is similar to the previous 1:1 compositing operations:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的命名方案类似于之前的 1:1 组合操作：
- en: '[PRE4]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The additional `restriction` indicates if the operation works on both stages,
    or either, using the aptly named suffixes `-Both` and `-Either`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的 `restriction` 表示操作是否对两个阶段或任一阶段有效，使用适当命名的后缀 `-Both` 和 `-Either`。
- en: '[Table 13-1](#_02-completable-future_combinational_ops) lists the available
    2:1 operations.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[表格 13-1](#_02-completable-future_combinational_ops) 列出了可用的 2:1 操作。'
- en: Table 13-1\. Combinational Operations
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 13-1\. 组合操作
- en: '| Method | Argument | Notes |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 参数 | 注意事项 |'
- en: '| --- | --- | --- |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `thenCombine` | `BiFunction<T, U, V>` | Applies the `BiFunction` after *both*
    stages completed normally. |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `thenCombine` | `BiFunction<T, U, V>` | 在 *两个* 阶段正常完成后应用 `BiFunction`。 |'
- en: '| `thenAcceptBoth` | `BiConsumer<T, U>` | Like `thenCombine`, but doesn’t produce
    any value. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `thenAcceptBoth` | `BiConsumer<T, U>` | 类似于 `thenCombine`，但不生成任何值。 |'
- en: '| `runAfterBoth` | `Runnable` | Evaluate the `Runnable` after both given stages
    have been completed normally. |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `runAfterBoth` | `Runnable` | 在两个给定阶段都正常完成后评估 `Runnable`。 |'
- en: '| `applyToEither` | `Function<T, U>` | Applies the `Function` to the first
    completed stage. |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `applyToEither` | `Function<T, U>` | 将`Function`应用于第一个完成的阶段。 |'
- en: '| `acceptEither` | `Consumer<T, U>` | Like `applyToEither`, but doesn’t produce
    any value. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `acceptEither` | `Consumer<T, U>` | 类似于`applyToEither`，但不生成任何值。 |'
- en: '| `runAfterEither` | `Runnable` | Evaluate the `Runnable` after either of the
    given stages has been completed normally. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `runAfterEither` | `Runnable` | 在给定阶段之一正常完成后评估`Runnable`。 |'
- en: Like with other functional Java features, the many different operations are
    owed to Java’s static type system and how generic types are resolved. Unlike other
    languages, like JavaScript, methods can’t accept multiple types in a single argument
    or as a return type.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他功能性Java特性一样，许多不同的操作归功于Java的静态类型系统及其如何解析通用类型。与JavaScript等其他语言不同，方法不能在单个参数或返回类型中接受多种类型。
- en: The composing operations can easily be mixed with the compositing ones, as illustrated
    in [Figure 13-3](#_01-completable-future_compositing-combining-flow).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 可以轻松混合组合操作，如[图 13-3](#_01-completable-future_compositing-combining-flow)所示。
- en: '![Compositing and combining tasks](assets/afaj_1303.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![组合和组合任务](assets/afaj_1303.png)'
- en: Figure 13-3\. Compositing and combining tasks
  id: totrans-97
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 13-3\. 组合和组合任务
- en: 'The available operations provide a variety of functionality for almost any
    use case. Still, there are certain blindspots in Java’s asynchronous API, especially
    a particular variant is missing: combining the result of two stages with a `BiFunction`
    returning another stage without creating a nested `CompletionStage`.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的操作提供了几乎所有用例的各种功能。但是，在Java的异步API中仍然存在一些盲点，特别是缺少特定变体：使用`BiFunction`组合两个阶段的结果，返回另一个阶段而不创建嵌套的`CompletionStage`。
- en: The `thenCombine` behavior is similar to other `map` operations in Java. In
    the case of a nested return value, a `flatMap`-like operation is required, which
    is missing for `CompletableFuture<T>`. Instead, you need an additional `thenCompose`
    operation to flatten the nested values, as shown in [Example 13-4](#_02-completable-future_thenCompose-combine).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`thenCombine`的行为类似于Java中的其他`map`操作。在嵌套返回值的情况下，需要类似于`flatMap`的操作，但对于`CompletableFuture<T>`而言，这种操作是缺失的。因此，您需要额外的`thenCompose`操作来展平嵌套的值，如[示例 13-4](#_02-completable-future_thenCompose-combine)所示。'
- en: Example 13-4\. Unwrapping nested stages
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 13-4\. 取消包装嵌套阶段
- en: '[PRE5]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[![1](assets/1.png)](#co_asynchronous_tasks_CO2-1)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asynchronous_tasks_CO2-1)'
- en: The two stages that should combine their results.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 应该组合其结果的两个阶段。
- en: '[![2](assets/2.png)](#co_asynchronous_tasks_CO2-3)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asynchronous_tasks_CO2-3)'
- en: The task consuming the combined results of the previous stage.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 消耗前一阶段组合结果的任务。
- en: '[![3](assets/3.png)](#co_asynchronous_tasks_CO2-4)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_asynchronous_tasks_CO2-4)'
- en: The return value of `task` is wrapped into another stage by `thenCombine`, resulting
    in an unwanted `CompletionStage<CompletionStage<Integer>>`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`task`的返回值通过`thenCombine`包装成另一个阶段，导致不需要的`CompletionStage<CompletionStage<Integer>>`。'
- en: '[![4](assets/4.png)](#co_asynchronous_tasks_CO2-5)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_asynchronous_tasks_CO2-5)'
- en: The `thenCompose` call with `Function.identity()` unwraps the nested stage and
    the pipeline is a `CompletionStage<Integer>` again.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Function.identity()`的`thenCompose`调用取消包装嵌套阶段，管道再次成为`CompletionStage<Integer>`。
- en: This approach is helpful if the task returns a `CompletableFuture` itself instead
    of relying on the caller to handle it asynchronously by wrapping it into a `CompletableFuture`
    if needed.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任务返回的是`CompletableFuture`本身，而不是依赖调用者通过必要时包装成`CompletableFuture`来异步处理它，则此方法很有帮助。
- en: Running More Two CompletableFuture<T> at Once
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 同时运行超过两个CompletableFuture<T>
- en: 'The previously discussed operations allow you to run up to two CompletableFutures
    to create a new one. Handling more than two, however, isn’t possible with combinational
    operations like `thenCombine` without creating a nested method-call nightmare.
    That’s why `CompletableFuture<T>` type has two `static` convenience methods for
    dealing with more than two instances at once:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 前面讨论的操作允许您运行最多两个CompletableFutures以创建一个新的CompletableFuture。然而，处理超过两个的情况，如使用`thenCombine`等组合操作而不创建嵌套方法调用的噩梦，是不可能的。这就是为什么`CompletableFuture<T>`类型具有两个用于同时处理多个实例的静态便利方法的原因：
- en: '`CompletableFuture<Void> allOf(CompletableFuture<?>…​ cfs)`'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompletableFuture<Void> allOf(CompletableFuture<?>…​ cfs)`'
- en: '`CompletableFuture<Object> anyOf(CompletableFuture<?>…​ cfs)`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompletableFuture<Object> anyOf(CompletableFuture<?>…​ cfs)`'
- en: The `allOf` and `anyOf` methods coordinate pre-existing instances. Therefore,
    both of them don’t provide matching `-Async` variants because each given `CompletableFuture`
    instance already has its designated `Executor`. Another aspect of the coordination-only
    nature is their restrictive return types. Because both accept any kind of `CompletableFuture`
    instances, signified by the generic bound `<?>`, no definitive `T` for the overall
    result is determinable, as the types can be mixed freely. The return type of the
    `allOf` is a `CompletableFuture<Void>`, so you don’t have access to any result
    of the given instances in later stages. However, it’s possible to create helper
    methods that support returning a result as an alternative. I’ll show you how to
    do that in [“Creating a CompletableFuture Helper”](#_02-completable-future_designing-helper),
    but for now, let’s go through the other operations of `CompletableFuture` first.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`allOf` 和 `anyOf` 方法协调预先存在的实例。因此，它们都不提供匹配的 `-Async` 变体，因为每个给定的 `CompletableFuture`
    实例已经有其指定的 `Executor`。协调性质的另一个方面是它们的限制性返回类型。因为两者都接受任何类型的 `CompletableFuture` 实例，由泛型边界
    `<?>` 表示，所以无法确定整体结果的明确 `T`，因为类型可以自由混合。`allOf` 的返回类型是 `CompletableFuture<Void>`，因此您无法在后续阶段访问给定实例的任何结果。但是，可以创建支持将结果作为备选项返回的辅助方法。我将向您展示如何在
    [“创建 CompletableFuture 辅助程序”](#_02-completable-future_designing-helper) 中执行此操作，但现在，让我们先通过
    CompletableFuture 的其他操作。'
- en: Exception Handling
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常处理
- en: So far, I’ve shown you pipelines that have only trotted along the “happy path”
    without any hiccups. However, a promise can be rejected, or as it is called in
    Java, *complete exceptionally*, if an exception occurs in the pipeline.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我已经向您展示了仅在“快乐路径”上行进而没有任何故障的管道。但是，如果在管道中发生异常，则承诺可能被拒绝，或者在 Java 中称为*异常完成*。
- en: 'Instead of blowing up the whole pipeline in the case of an Exception, as Streams
    or Optionals do, the CompletableFuture API sees Exceptions as first-class citizens
    and an essential part of its workflow. That’s why exception handling isn’t imposed
    on the tasks themselves, and there are multiple operations available to handle
    possibly rejected Promises:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 与流或可选项在异常情况下炸毁整个管道不同，CompletableFuture API 将异常视为一等公民，并且是其工作流程的重要部分。这就是为什么异常处理不强加于任务本身，并且有多个可用于处理可能被拒绝的
    Promise 的操作的原因：
- en: '`CompletionStage<T> exceptionally(Function<Throwable, T> fn)`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompletionStage<T> exceptionally(Function<Throwable, T> fn)`'
- en: '`CompletionStage<U> handle(BiFunction<T, Throwable, U> fn)`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompletionStage<U> handle(BiFunction<T, Throwable, U> fn)`'
- en: '`CompletionStage<T> whenComplete(BiConsumer<T, Throwable> action)`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompletionStage<T> whenComplete(BiConsumer<T, Throwable> action)`'
- en: Using the `exceptionally` operation adds an Exception hook into the pipeline,
    which will complete normally with the previous stage’s result if no Exception
    has occurred in any previous stage. In the case of a rejected stage, its Exception
    is applied to the hook’s `fn` for a recovery effort. To recover, `fn` needs to
    return any value of type `T`, which will switch the pipeline back to the data
    channel. If no recovery is possible, throwing a new Exception, or rethrowing the
    applied one, will keep the pipeline in the exceptionally completed state and on
    the error channel.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `exceptionally` 操作将异常钩子添加到管道中，如果之前的阶段没有发生异常，则会正常完成，并带有上一阶段的结果。在被拒绝的阶段，它的异常会应用到钩子的
    `fn` 上，进行恢复尝试。要进行恢复，`fn` 需要返回任何类型为 `T` 的值，这将把管道切换回数据通道。如果没有可能的恢复，抛出一个新的异常，或者重新抛出已应用的异常，将使管道保持在异常完成状态并在错误通道上。
- en: The more flexible `handle` operation combines the logic of `exceptionally` and
    `thenApply` into a single operation. The `BiFunction` arguments depend on the
    result of the previous stage. If it was rejected, the second argument of type
    `Throwable` is non-`null`. Otherwise, the first argument of type `T` has value.
    Be aware that it still might be a `null`-value.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 更灵活的 `handle` 操作将 `exceptionally` 和 `thenApply` 的逻辑合并为一个单独的操作。`BiFunction` 参数取决于前一阶段的结果。如果它被拒绝，那么第二个类型为
    `Throwable` 的参数是非 `null` 的。否则，类型为 `T` 的第一个参数具有值。请注意，它仍然可能是一个 `null` 值。
- en: The last operation, `whenComplete`, is similar to `handle` but doesn’t offer
    a way to recover a rejected Promise.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个操作 `whenComplete` 类似于 `handle` 但不提供一种恢复被拒绝 Promise 的方式。
- en: Data and Error Channel Revisited
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据和错误通道再访
- en: Even though I explained Promises have technically two channels, data and error,
    a CompletableFuture pipeline is actually a straight line of operations, like Streams.
    Each pipeline stage looks for the next compatible operation, depending on which
    state the current stage has completed. In case of completing normally, the next
    `then`/`run`/`apply`/etc. executes. These operations are “pass-through” for exceptionally
    completed stages, and the pipeline looks further for the next `exceptionally`/`handle`/`whenComplete`/etc.
    operation.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我解释了Promise实际上有两个通道，即数据和错误，但CompletableFuture管道实际上是操作的一条直线，就像Streams一样。每个管道阶段都寻找下一个兼容的操作，具体取决于当前阶段已完成的状态。在正常完成的情况下，下一个`then`/`run`/`apply`/等就会执行。对于异常完成的阶段，这些操作是“通过”操作，并且管道会进一步寻找下一个`exceptionally`/`handle`/`whenComplete`/等操作。
- en: A CompletableFuture pipeline might be a straight line created by a fluent call,
    visualizing it as two channels, though, as done previously in [Figure 13-2](#_02-completable-future_channels),
    gives you a better overview of what’s happening. Each operation exists in either
    the data or error channel, except the `handle` and `whenComplete` operations,
    which exist in between, as they’re executed regardless of the pipeline’s state.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: CompletableFuture管道可能是通过流畅调用创建的一条直线，将其视为两个通道，如以前在[图 13-2](#_02-completable-future_channels)中所做的那样，可以更好地了解发生了什么。每个操作存在于数据通道或错误通道中的一个，除了`handle`和`whenComplete`操作，它们存在于中间，因为它们无论管道的状态如何都会执行。
- en: Rejected Either Tasks
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 被拒绝的Either任务
- en: A straight pipeline might get another CompletableFuture injected by using a
    combinatorial operation. You might think the suffix `-Either` might imply that
    *either* pipelines might complete normally to create a new, non-rejected stage.
    Well, you’re in for a surprise!
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用组合操作注入另一个CompletableFuture，可以获得一个直线管道。您可能会认为后缀`-Either`可能意味着*要么*管道可能正常完成以创建一个新的非拒绝阶段。嗯，您会感到惊讶！
- en: If the previous stage is rejected, the `acceptEither` operation remains rejected
    regardless of whether the other stage is completed normally, as shown in [Example 13-5](#_02-completable-future_either).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果先前的阶段被拒绝，那么`acceptEither`操作将保持被拒绝状态，无论另一个阶段是否正常完成，如[示例 13-5](#_02-completable-future_either)所示。
- en: Example 13-5\. Either operations and rejected stages
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 13-5\. Either操作和被拒绝的阶段
- en: '[PRE6]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The gist to remember is that all operations, except the error-handling ones,
    require a non-rejected previous stage to work properly, even for `-Either` operations.
    If in doubt, use an error-handling operation to ensure a pipeline is still on
    the data channel.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 记住的要点是，除了错误处理操作之外的所有操作都需要一个非拒绝的前一个阶段才能正常工作，即使对于`-Either`操作也是如此。如果有疑问，请使用错误处理操作来确保管道仍处于数据通道上。
- en: Terminal operations
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 终端操作
- en: Up to this point, any operation returns another `CompletionStage<T>` to extend
    the pipeline further. The `Consumer`-based operations might fulfill many use cases,
    but at some point, you need the actual value even if it might block the current
    thread.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，任何操作都会返回另一个`CompletionStage<T>`以进一步扩展管道。基于`Consumer`的操作可能满足许多用例，但是在某些时候，即使可能阻塞当前线程，您也需要实际的值。
- en: 'The `CompletionStage<T>` type itself doesn’t provide any additional retrieval
    methods compared to the `Future<t>` type. Its implementation `CompletableFuture<T>`,
    though, gives you two options: the `getNow` and `join` methods. This ups the number
    of terminal operations to four, as listed in [Table 13-2](#_02-completable-future_terminal).'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Future<t>`类型相比，`CompletionStage<T>`类型本身不提供任何额外的检索方法。但是，它的实现`CompletableFuture<T>`提供了两个选项：`getNow`和`join`方法。这将终端操作数量增加到四个，如[表 13-2](#_02-completable-future_terminal)中所列。
- en: Table 13-2\. Getting a value from a pipeline
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 表 13-2\. 从管道获取值
- en: '| Method signature | Use-case | Exceptions |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 方法签名 | 用例 | 异常 |'
- en: '| --- | --- | --- |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `T get()` | Blocks the current thread until the pipeline is completed. |
    `InterruptedException` (checked) `ExecutionException` (checked)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '| `T get()` | 阻塞当前线程直到管道完成。 | `InterruptedException`（已检查）`ExecutionException`（已检查）'
- en: '`CancellationException` (unchecked) |'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`CancellationException`（未检查）|'
- en: '| `T get(long timeout, TimeUnit unit)` | Blocks the current thread until the
    pipeline is completed but throws an Exception after the `timeout` is reached.
    | `TimeoutException` (checked) `InterruptedException` (checked)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '| `T get(long timeout, TimeUnit unit)` | 阻塞当前线程直到管道完成，但在达到`timeout`后抛出异常。 |
    `TimeoutException`（已检查）`InterruptedException`（已检查）'
- en: '`ExecutionException` (checked)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExecutionException`（已检查）'
- en: '`CancellationException` (unchecked) |'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`CancellationException`（未检查）|'
- en: '| `T getNow(T valueIfAbsent)` | Returns the pipeline’s result if completed
    normally or throws an `CompletionException`. If the result is still pending, the
    provided fallback value `T` is returned immediately without canceling the pipeline.
    | `CompletionException` (unchecked) `CancellationException` (unchecked) |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `T getNow(T valueIfAbsent)` | 如果正常完成则返回管道的结果，或者抛出`CompletionException`。如果结果仍然挂起，则立即返回提供的回退值`T`而不取消管道。
    | `CompletionException`（未检查） `CancellationException`（未检查） |'
- en: '| `join()` | Blocks the current thread until the pipeline is done. | If it
    completes exceptionally, the corresponding exception is wrapped into a `CompletionException`.
    |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `join()` | 阻塞当前线程直到管道完成。 | 如果发生异常完成，对应的异常会被包装成`CompletionException`。 |'
- en: The `CompletableFuture<T>` type also adds another pipeline coordination method,
    `isCompletedExceptionally`, giving you a total of four methods for affecting or
    retrieving the pipeline’s state, as listed in [Table 13-3](#_02-completable-future_coordination).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 类型`CompletableFuture<T>`还添加了另一个管道协调方法，`isCompletedExceptionally`，给你总共四个影响或检索管道状态的方法，如[表13-3](#_02-completable-future_coordination)所列。
- en: Table 13-3\. Coordination methods
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 表13-3\. 协调方法
- en: '| Method Signature | Returns |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 方法签名 | 返回 |'
- en: '| --- | --- |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `boolean cancel(boolean mayInterruptIfRunning)` | Completes a not already
    completed stage exceptionally with a `CancellationException`. The argument `mayInterruptIfRunning`
    is ignored because interrupts aren’t used for control, unlike in `Future<T>`.
    |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `boolean cancel(boolean mayInterruptIfRunning)` | 用`CancellationException`异常异常完成尚未完成的阶段。参数`mayInterruptIfRunning`被忽略，因为与`Future<T>`不同，中断不用于控制。
    |'
- en: '| `boolean isCancelled()` | Returns `true` if the stage was canceled before
    it has completed. |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `boolean isCancelled()` | 如果阶段在完成之前被取消，则返回`true`。 |'
- en: '| `boolean isDone()` | Returns `true` if the stage has been completed in any
    state. |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `boolean isDone()` | 如果阶段已经以任何状态完成，则返回`true`。 |'
- en: '| `boolean isCompletedExceptionally()` | Returns `true` if the stage has been
    completed exceptionally, or is already in the rejected state. |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `boolean isCompletedExceptionally()` | 返回`true`如果阶段已经异常完成，或者已经处于拒绝状态。 |'
- en: That’s quite a humongous API, covering a lot of use cases. Still, depending
    on your requirements, some edge cases might be missing. But adding your helper
    to fill any gaps is easy, so let’s do it.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常庞大的API，涵盖了许多用例。尽管如此，根据您的要求，可能会缺少一些边缘案例。但是，添加您的辅助程序以填补任何差距是很容易的，所以让我们来做吧。
- en: Creating a CompletableFuture Helper
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个CompletableFuture Helper
- en: Although the CompletableFuture API is massive, it’s still missing certain use
    cases. For example, as mentioned earlier in [“Combining Tasks”](#_02-completable-future_combining-tasks),
    the return type of the `static` helper `allOf` is `CompletableFuture<Void>`, so
    you don’t have access to any result of the given instances in later stages. It’s
    a flexible coordination-only method that accepts any kind of `CompletableFuture<?>`
    as its arguments but with the trade-off of not having access to any of the results.
    To make up for this, you can create a helper to complement the existing API as
    needed.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然CompletableFuture API非常庞大，但仍然缺少某些用例。例如，如前文所述在[“组合任务”](#_02-completable-future_combining-tasks)中，静态辅助程序`allOf`的返回类型是`CompletableFuture<Void>`，因此您无法在后续阶段访问给定实例的任何结果。它是一种灵活的仅协调方法，接受任何类型的`CompletableFuture<?>`作为其参数，但是以不访问任何结果的代价来弥补这一点。为此，您可以根据需要创建一个辅助程序来补充现有的API。
- en: 'Let’s create a helper in the vein of `allOf`, running more than two `CompletableFuture`
    instances at once, but still giving access to their results:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个类似于`allOf`的辅助程序，一次运行多个`CompletableFuture`实例，但仍然可以访问它们的结果：
- en: '[PRE7]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The proposed helper `eachOf` runs all of the given `CompletableFuture` instances,
    like `allOf`. However, unlike `allOf`, the new helper uses the Generic type `T`
    instead of `?` (question mark). This restriction to a singular type makes it possible
    that the `eachOf` method can actually return a `CompletableFuture<List<T>>` instead
    of a result-less `CompletableFuture<Void>`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 提议的辅助`eachOf`运行所有给定的`CompletableFuture`实例，就像`allOf`一样。然而，与`allOf`不同的是，新的辅助程序使用了泛型类型`T`而不是`?`（问号）。将此限制为单一类型使`eachOf`方法实际上可以返回一个`CompletableFuture<List<T>>`而不是无结果的`CompletableFuture<Void>`。
- en: The Helper Scaffold
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 辅助支架
- en: A convenience `class` is needed to hold any helper methods. Such helper methods
    are useful for particular edge cases that aren’t possible to solve otherwise in
    a concise way, or even at all, with the provided API. The most idiomatic and safe
    way is to use a `class` with a `private` constructor as shown as follows to prevent
    anyone from accidentally extending or instantiating the type.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 需要一个方便的`class`来保存任何辅助方法。这些辅助方法对于一些特定边缘情况非常有用，否则无法以简洁的方式或者根本无法解决。最惯用且安全的方式是使用一个带有`private`构造函数的`class`，如下所示，以防止任何人意外扩展或实例化该类型。
- en: '[PRE8]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-164
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Helper classes with a `private` default constructor don’t have to be `final`
    per se to prevent extendability. The extending class won’t compile without a visible
    implicit `super` constructor. Nevertheless, making the helper class `final` signifies
    the desired intent without relying on implicit behavior.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 具有`private`默认构造函数的辅助类本身不必`final`，以防止其可扩展性。扩展类在没有可见的隐式`super`构造函数的情况下无法编译。然而，将辅助类设为`final`表明了所需的意图，而不依赖隐式行为。
- en: Designing eachOf
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计`eachOf`
- en: 'The goal of `eachOf` is almost identical to `allOf`. Both methods coordinate
    one or more `CompletableFuture` instances. However, `eachOf` is going further
    by managing the results, too. This leads to the following requirements:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`eachOf`的目标几乎与`allOf`相同。这两种方法都协调一个或多个`CompletableFuture`实例。然而，`eachOf`进一步管理结果。这导致以下要求：'
- en: Returning a `CompletableFuture` containing all the given instances, like `allOf`.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回包含所有给定实例的`CompletableFuture`，就像`allOf`一样。
- en: Giving access to the results of successfully completed instances.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给予对成功完成实例结果的访问。
- en: The first requirement is fulfilled by the `allOf` method. The second one, however,
    requires additional logic. It requires you to inspect the given instances individually
    and aggregate their results.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个要求由`allOf`方法实现。然而，第二个要求需要额外的逻辑。需要你检查给定的实例并聚合它们的结果。
- en: 'The simplest way of running any logic after a previous stage completes in any
    way is using the `thenApply` operation as shown as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 任何逻辑在前一个阶段以任何方式完成后运行的最简单方法是使用`thenApply`操作，如下所示：
- en: '[PRE9]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Using what you’ve learned so far in the book, the aggregation of the results
    of successfully completed `CompletableFuture` instances can be done by creating
    a Stream data processing pipeline.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 利用你在本书中学到的知识，可以通过创建一个流数据处理管道来聚合成功完成的`CompletableFuture`实例的结果。
- en: Let’s go through the steps needed to create such a pipeline.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步进行创建这样一个管道所需的步骤。
- en: 'First, the Stream must be created from the given `CompletableFuture<T>` instances.
    It’s an `vararg` method argument so it corresponds to an array. The helper `Arrays#stream(T[]
    arrays)` is the obvious choice when dealing with a `vararg`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，必须从给定的`CompletableFuture<T>`实例创建流。它是一个`vararg`方法参数，因此对应一个数组。当处理`vararg`时，辅助方法`Arrays#stream(T[]
    arrays)`是明显的选择：
- en: '[PRE10]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, the successfully completed instances are filtered. There is no explicit
    method to ask an instance if it is completed normally, but you can ask the inverse
    thanks to `Predicate.not`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，过滤成功完成的实例。虽然没有显式方法询问实例是否正常完成，但由于`Predicate.not`，可以询问其相反情况：
- en: '[PRE11]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'There are two methods for getting a result immediately from a `CompletableFuture`:
    `get()` and `join()`. In this case, the latter is preferable, because it doesn’t
    throw a checked Exception, simplifying the Stream pipeline as discussed in [Chapter 10](ch10.xhtml#_02-exception-handling):'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以立即从`CompletableFuture`中获取结果：`get()` 和 `join()`。在这种情况下，后者更可取，因为它不会抛出已检查异常，简化了流管道，如[第10章](ch10.xhtml#_02-exception-handling)所讨论的那样：
- en: '[PRE12]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Using the `join` method blocks the current thread to get the result. However,
    the Stream pipeline is run after `allOf` is completed anyway, so all results are
    already available. And by filtering non-successfully completed elements beforehand,
    no Exception is thrown that might implode the pipeline.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`join`方法会阻塞当前线程以获取结果。然而，流管道在`allOf`完成后运行，因此所有结果已经可用。并且通过预先过滤非成功完成的元素，不会抛出可能导致管道崩溃的异常。
- en: 'Finally, the results are aggregated into a `List<T>`. This can be either done
    with a `collect` operation, or if you’re using Java 16+, the `Stream<T>` type’s
    `toList` method:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，结果被聚合到一个`List<T>`中。这可以通过`collect`操作完成，或者如果使用Java 16+，可以使用`Stream<T>`类型的`toList`方法完成：
- en: '[PRE13]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The Stream pipeline can now be used to gather the results in the `thenApply`
    call. The full implementation of `CompletableFutures` and its `eachOf` helper
    method is shown in [Example 13-6](#_02-completable-future_futures-eachof-complete).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以使用流水线在 `thenApply` 调用中收集结果。`CompletableFutures` 及其 `eachOf` 辅助方法的完整实现如 [示例 13-6](#_02-completable-future_futures-eachof-complete)
    所示。
- en: Example 13-6\. Complete implementation of `eachOf`
  id: totrans-185
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 13-6\. `eachOf` 的完整实现
- en: '[PRE14]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[![1](assets/1.png)](#co_asynchronous_tasks_CO3-1)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asynchronous_tasks_CO3-1)'
- en: The `Predicate` for testing successful completion isn’t bound to a specific
    `CompletableFuture` instance and, therefore, reusable as a `final static` field.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 用于测试成功完成的 `Predicate` 不绑定到特定的 `CompletableFuture` 实例，因此可重用为 `final static` 字段。
- en: '[![2](assets/2.png)](#co_asynchronous_tasks_CO3-2)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asynchronous_tasks_CO3-2)'
- en: The result gathering action is represented by `Function<Void, List<T>>`, which
    matches the inner types of the return type of `allOf` and the intended return
    type of `eachOf`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 结果收集操作由 `Function<Void, List<T>>` 表示，该函数与 `allOf` 的返回类型的内部类型和 `eachOf` 的预期返回类型相匹配。
- en: '[![3](assets/3.png)](#co_asynchronous_tasks_CO3-3)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_asynchronous_tasks_CO3-3)'
- en: The overall task is merely calling the pre-existing `allOf` and combining it
    with the result aggregating pipeline.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 整体任务仅仅是调用预先存在的 `allOf` 并将其与结果聚合管道组合。
- en: That’s it! We’ve created an alternative to `allOf` for certain use cases when
    the results should be easily accessible.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！我们为某些用例创建了 `allOf` 的替代方案，以便轻松访问结果。
- en: The final implementation is an example of the functional approach to solving
    problems. Each task in itself is isolated and could be used on its own. By combining
    them, though, you create a more complex solution built of smaller parts.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 最终实现是解决问题的功能方法的示例。每个任务本身都是独立的，可以单独使用。但是通过组合它们，您可以创建由较小部分构建的更复杂的解决方案。
- en: Improving the CompletableFutures Helper
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 改进 `CompletableFutures` 助手
- en: The `eachOf` method works as you would expect it as a complementary method to
    `allOf`. If any of the given `CompletableFuture` instances fails, the returned
    `CompletableFuture<List<T>>` has also completed exceptionally.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`eachOf` 方法与 `allOf` 互为补充，其工作方式与预期相同。如果给定的任何 `CompletableFuture` 实例失败，返回的 `CompletableFuture<List<T>>`
    也将异常完成。'
- en: Still, there are “fire & forget” use cases, where you are only interested in
    the successfully completed tasks and don’t care about any failures. A failed `CompletableFuture`,
    though, will throw an Exception if you try to extract its value with `get` or
    similar methods. So let’s add a `bestEffort` helper method based on `eachOf` that
    always completes successfully and only returns the successful results.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 对于“fire & forget”用例，您可能只关注成功完成的任务，而不关心任何失败。但是，如果尝试使用 `get` 或类似方法提取其值，则失败的 `CompletableFuture`
    将抛出异常。因此，让我们添加一个基于 `eachOf` 的 `bestEffort` 辅助方法，始终成功完成并仅返回成功的结果。
- en: 'The main goal is almost identical to `eachOf`, except if the `allOf` call returns
    an exceptionally completed `CompletableFuture<Void>`, it must recover. Adding
    an Exception hook by interjecting an `exceptionally` operation is the obvious
    choice:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 主要目标与 `eachOf` 几乎相同，除非 `allOf` 调用返回了异常完成的 `CompletableFuture<Void>`，必须恢复。通过插入
    `exceptionally` 操作添加异常钩子是显而易见的选择：
- en: '[PRE15]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `exceptionally` lambda `ex -> null` might look weird at first. But if you
    check out the underlying method signature, its intention becomes clearer.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始，`exceptionally` lambda `ex -> null` 看起来可能有些奇怪。但是如果您检查其底层方法签名，其意图会变得更清晰。
- en: In this case, the `exceptionally` operation requires a `Function<Throwable,
    Void>` to recover the `CompletableFuture` by returning a value of type `Void`
    instead of throwing an Exception. This is achieved by returning `null`. After
    that, the aggregation Stream pipeline from `eachOf` is used to gather the results.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`exceptionally` 操作需要一个 `Function<Throwable, Void>` 来通过返回 `Void` 类型的值而不是抛出异常来恢复
    `CompletableFuture`。这通过返回 `null` 来实现。之后，从 `eachOf` 到聚合流水线的聚合流水线被使用来收集结果。
- en: Tip
  id: totrans-202
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: The same behavior could be achieved with the `handle` operation and handle both
    states, success or rejection, in a singular `BiFunction`. Still, handling the
    states in separate steps makes a more readable pipeline.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `handle` 操作也可以实现相同的行为，并在单个 `BiFunction` 中处理成功或拒绝的两种状态。不过，将状态分开处理可以使管道更具可读性。
- en: Now that we have two helper methods with shared logic, it might make sense to
    extract common logic into their own methods. This underlies the functional approach
    of combining isolated logic to create a more complex and complete task. A possible
    refactored implementation of `Futures` is shown in [Example 13-7](#_02-completable-future_futures-eachof-complete-refactored).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个具有共享逻辑的辅助方法，将共同逻辑提取到它们自己的方法中可能是合理的。这基于将孤立逻辑组合在一起以创建更复杂和完整任务的功能方法。`Futures`的可能重构实现在[示例13-7](#_02-completable-future_futures-eachof-complete-refactored)中展示。
- en: Example 13-7\. Refactored implementation of Futures with `eachOf` and `bestEffort`
  id: totrans-205
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 13-7\. 使用`eachOf`和`bestEffort`重构的Futures实现
- en: '[PRE16]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[![1](assets/1.png)](#co_asynchronous_tasks_CO4-1)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asynchronous_tasks_CO4-1)'
- en: The `Predicate` is unchanged.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`Predicate`未更改。'
- en: '[![2](assets/2.png)](#co_asynchronous_tasks_CO4-2)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asynchronous_tasks_CO4-2)'
- en: The result-gathering logic is refactored into a `private` factory method to
    ensure consistent handling across both `eachOf` and `bestEffort`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 结果收集逻辑被重构为一个`private`工厂方法，以确保在`eachOf`和`bestEffort`中的一致处理。
- en: '[![3](assets/3.png)](#co_asynchronous_tasks_CO4-3)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_asynchronous_tasks_CO4-3)'
- en: Both `public` helper methods are reduced to the absolute minimum.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 两个`public`辅助方法都简化到最低限度。
- en: The refactored `CompletableFutures` helper is simpler and more robust than before.
    Any sharable complex logic is reused so it provides consistent behavior throughout
    its method and minimizes the required documentation that should definitely add
    to communicate the intended functionality to any caller.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 重构后的`CompletableFutures`辅助程序比以前更简单、更健壮。任何可共享的复杂逻辑都得到重用，因此它提供了始终保持一致行为并最小化所需文档的方法，这些文档肯定应该添加以将预期功能沟通给任何调用方。
- en: Manual Creation and Completion
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动创建和完成
- en: The only way to create `Future<T>` instances besides implementing the interface
    yourself is by submitting a task to an `ExecutorService`. The `static` convenience
    factory methods `runAsync` or `supplyAsync` of `CompletableFuture<T>` are quite
    similar. Unlike its predecessor, they’re not the only way to create instances,
    though.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`Future<T>`实例的唯一方式（除了自己实现接口）是向`ExecutorService`提交任务。`CompletableFuture<T>`的`static`方便工厂方法`runAsync`或`supplyAsync`非常相似。与其前身不同，它们不是唯一创建实例的方式。
- en: Manual Creation
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手动创建
- en: 'Thanks to being an actual implementation and not an interface, the `CompletableFuture<T>`
    type has a constructor that you can use to create an unsettled instance as shown
    as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`CompletableFuture<T>`类型是一个实际的实现而不是一个接口，它有一个构造函数，您可以使用它来创建一个未完成的实例，如下所示：
- en: '[PRE17]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Without an attached task, however, it will never be completed or fail. Instead,
    you need to complete such a task manually.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，没有附加任务，它将永远不会完成或失败。相反，您需要手动完成这样的任务。
- en: Manual Completion
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手动完成
- en: 'There are a couple of ways to settle an existing `CompletableFuture<T>` instance
    and kickstart the attached pipeline:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以安排现有的`CompletableFuture<T>`实例并启动附加的管道：
- en: '`boolean complete(T value)`'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean complete(T value)`'
- en: '`boolean completeExceptionally(Throwable ex)`'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean completeExceptionally(Throwable ex)`'
- en: Both methods return `true` if the call transitions the stage to the expected
    state.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 两种方法如果调用成功将返回`true`，将阶段转换为期望状态。
- en: 'Java 9 introduced additional `complete` methods for normally completed stages,
    in the form of `-Async` variants, and a timeout-based one:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9引入了额外的`complete`方法，用于正常完成的阶段，形式为`-Async`变体，以及基于超时的一个：
- en: '`CompletableFuture<T> completeAsync(Supplier<T> supplier)`'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompletableFuture<T> completeAsync(Supplier<T> supplier)`'
- en: '`CompletableFuture<T> completeAsync(Supplier<T> supplier, Executor executor)`'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompletableFuture<T> completeAsync(Supplier<T> supplier, Executor executor)`'
- en: '`CompletableFuture<T> completeOnTimeout(T value, long timeout, TimeUnit unit)`'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompletableFuture<T> completeOnTimeout(T value, long timeout, TimeUnit unit)`'
- en: The `-Async` variants complete the current stage with the result of the `supplier`
    in a new asynchronous task.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`-Async`变体使用新的异步任务，以`supplier`的结果完成当前阶段。'
- en: The other method, `completeOnTimeout`, settles the current stage with the given
    `value` if the stage doesn’t complete otherwise before the `timeout` is reached.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`completeOnTimeout`这种方法在达到`timeout`之前，如果该阶段未能完成，就使用给定的`value`完成当前阶段。'
- en: 'Instead of creating a new instance and then manually completing it, you can
    also create an already completed instance with one of these `static` convenience
    factory methods:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是创建一个新实例然后手动完成它，您也可以使用以下这些`static`方便的工厂方法之一创建一个已经完成的实例：
- en: '`CompletableFuture<U> completedFuture(U value)`'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompletableFuture<U> completedFuture(U value)`'
- en: '`CompletableFuture<U> failedFuture(Throwable ex)` (Java 9+)'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompletableFuture<U> failedFuture(Throwable ex)`（Java 9+）'
- en: '`CompletionStage<U> completedStage(U value)` (Java 9+)'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompletionStage<U> completedStage(U value)`（Java 9+）'
- en: '`CompletionStage<U> failedStage(Throwable ex)` (Java 9+)'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompletionStage<U> failedStage(Throwable ex)`（Java 9+）'
- en: Such already completed futures can then be used in any of the combinatorial
    operations, or as a starting point for a CompletableFutures pipeline, as I’m going
    to discuss in the next section.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这些已经完成的未来对象可以用于任何组合操作中，或者作为 CompletableFutures 流水线的起点，正如我将在下一节中讨论的那样。
- en: Use-Cases for Manually Created and Completed Instances
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手动创建和完成实例的用例
- en: In essence, the CompletableFuture API provides an easy way to create an asynchronous
    task pipeline with multiple steps. By creating and completing a stage manually,
    you gain fine-grained control over how the pipeline is executed afterward. For
    example, you can circumvent spinning off a task if the result is already known.
    Or you can create a partial pipeline factory for common tasks.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，CompletableFuture API 提供了一种简单的方法来创建具有多个步骤的异步任务流水线。通过手动创建和完成阶段，您可以对之后如何执行流水线进行精细控制。例如，如果已知结果，则可以避免启动任务。或者，您可以为常见任务创建部分流水线工厂。
- en: Let’s look at a few possible use cases.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看几个可能的用例。
- en: CompletableFuture as Return Value
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CompletableFuture 作为返回值
- en: '`CompletableFuture` makes an excellent return value for possible costly or
    long-running tasks.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompletableFuture` 作为可能昂贵或长时间运行任务的出色返回值。'
- en: Imagine a weather report service that calls a REST API to return a `WeatherInfo`
    object. Even though weather changes over time, it makes sense to cache the `WeatherInfo`
    for a particular place for some time before updating them with another REST call.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个天气报告服务，调用 REST API 返回一个 `WeatherInfo` 对象。尽管天气随时间变化，但有意义的是在更新之前缓存某个地方的 `WeatherInfo`
    一段时间。
- en: 'A REST call is naturally costlier and requires more time than a simple cache
    lookup, and therefore might block the current thread too long to be acceptable.
    Wrapping it in a `CompletabaleFuture` provides an easy way to offload the task
    from the current thread, leading to the following general `WeatherService` with
    a singular `public` method:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: REST 调用自然比简单的缓存查找更昂贵，并且需要更长时间，因此可能会阻塞当前线程太长时间，以至于无法接受。将其包装在 `CompletableFuture`
    中提供了一种简单的方法，将任务从当前线程中卸载，导致以下通用的带有单一 `public` 方法的 `WeatherService`：
- en: '[PRE18]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Adding a cache requires two methods, one for storing any result, and one for
    retrieving existing ones, as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 添加缓存需要两种方法，一种用于存储任何结果，另一种用于检索现有结果，如下所示：
- en: '[PRE19]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Using `Optional<WeatherInfo>` provides you with a functional launchpad to connect
    each part later. The actual implementation of the caching mechanism doesn’t matter
    for the purpose and intent of the example.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Optional<WeatherInfo>` 为您提供了一个功能性的起点，以稍后连接每个部分。缓存机制的实际实现对示例的目的和意图并不重要。
- en: 'The actual API call should be refactored, too, to create smaller logic units,
    leading to a singular `public` method and three `private` distinct operations.
    The logic to store a result in the cache can be added as a `CompletableFuture`
    operation by using `thenApply` with the `storeInCache` method:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的 API 调用也应进行重构，以创建更小的逻辑单元，从而导致一个公共方法和三个私有的独立操作。通过使用 `thenApply` 方法和 `storeInCache`
    方法，可以将将结果存储在缓存中的逻辑添加为 `CompletableFuture` 操作：
- en: '[PRE20]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now all parts can be combined to fulfill the task of providing a cached weather
    service, as shown in [Example 13-8](#_02-completable-future_weather-service).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有部分都可以组合起来完成提供缓存天气服务的任务，如示例 [Example 13-8](#_02-completable-future_weather-service)
    所示。
- en: Example 13-8\. Cached WeatherService with CompletableFutures
  id: totrans-251
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 13-8\. 使用 CompletableFutures 的缓存 WeatherService
- en: '[PRE21]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[![1](assets/1.png)](#co_asynchronous_tasks_CO5-1)'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asynchronous_tasks_CO5-1)'
- en: The cache lookup returns an `Optional<WeatherInfo>` to provide a fluent and
    functional jump-off point. The `storeInCache` method returns the stored `WeatherInfo`
    object to be usable as a method reference.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存查找返回一个 `Optional<WeatherInfo>`，提供一个流畅和功能性的起点。 `storeInCache` 方法返回存储的 `WeatherInfo`
    对象，可用作方法引用。
- en: '[![2](assets/2.png)](#co_asynchronous_tasks_CO5-3)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asynchronous_tasks_CO5-3)'
- en: The `restCall` method combines the REST call itself and stores the result if
    successfully completed, in the cache.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`restCall` 方法将 REST 调用本身与成功完成后的结果存储在缓存中结合在一起。'
- en: '[![3](assets/3.png)](#co_asynchronous_tasks_CO5-4)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_asynchronous_tasks_CO5-4)'
- en: The `check` method combines the other methods by looking in the cache first.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`check` 方法通过首先查找缓存来组合其他方法。'
- en: '[![4](assets/4.png)](#co_asynchronous_tasks_CO5-5)'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_asynchronous_tasks_CO5-5)'
- en: If a `WeatherInfo` is found, it returns an already completed `CompletableFuture<WeatherInfo>`
    immediately.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找到 `WeatherInfo`，它会立即返回一个已完成的 `CompletableFuture<WeatherInfo>`。
- en: '[![5](assets/5.png)](#co_asynchronous_tasks_CO5-6)'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_asynchronous_tasks_CO5-6)'
- en: If no `WeahterInfo` object is found, the Optional’s `orElseGet` executes the
    `reastCall` method lazily.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未找到 `WeahterInfo` 对象，则 Optional 的 `orElseGet` 懒执行 `reastCall` 方法。
- en: The advantage of combining CompletableFutures with Optionals this way is that
    it doesn’t matter what happens behind the scenes for the caller, whether the data
    is loaded via REST or is coming directly from a cache. Each `private` method does
    a singular task most efficiently, with the sole `public` method combining them
    as an asynchronous task pipeline only doing its expensive work if absolutely required.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 将CompletableFutures与Optionals结合的优势在于，对于调用者来说，后台发生了什么并不重要，无论数据是通过REST加载还是直接来自缓存。每个
    `private` 方法都以最高效的方式执行单一任务，而 `public` 方法只在绝对需要时将它们组合为异步任务管道执行昂贵的工作。
- en: Pending CompletableFuture Pipelines
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 未决的 CompletableFuture 管道
- en: A pending CompletableFuture instance never completes by itself with any state.
    Similar to Streams that won’t start their data processing until a terminal operation
    is connected, a CompletableFuture task pipeline won’t do any work until the first
    stage completes. Therefore, it provides a perfect starting point as the first
    stage of a more intricate task pipeline or even a scaffold for a pre-defined task
    to be executed on demand later.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 未决的 CompletableFuture 实例永远不会自行完成任何状态。类似于流，直到连接终端操作，CompletableFuture 任务管道不会执行任何工作。因此，它作为更复杂任务管道的第一阶段提供了一个完美的起点，甚至是稍后按需执行的预定义任务的脚手架。
- en: Imagine you want to process image files. There are multiple independent steps
    involved that might fail. Instead of processing the files directly, a factory
    provides unsettled `CompletedFuture` instances, as shown in [Example 13-9](#_02-completable-future_image-process-01).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想处理图像文件。涉及多个独立步骤可能失败。与直接处理文件不同，工厂提供未决的 `CompletedFuture` 实例，如 [Example 13-9](#_02-completable-future_image-process-01)
    所示。
- en: Example 13-9\. ImageProcessor with unsettled CompletableFuture
  id: totrans-267
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 13-9\. 带有未决 CompletableFuture 的 ImageProcessor
- en: '[PRE22]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[![1](assets/1.png)](#co_asynchronous_tasks_CO6-1)'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asynchronous_tasks_CO6-1)'
- en: The caller needs access to the unsettled first stage to start the pipeline,
    but also requires the stage to access the final result.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 调用者需要访问未决的第一阶段来启动管道，但还需要阶段来访问最终结果。
- en: '[![2](assets/2.png)](#co_asynchronous_tasks_CO6-2)'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asynchronous_tasks_CO6-2)'
- en: The Generic type of the returned CompletableFuture instance must match the type
    you want the caller to provide when they actually execute the pipeline. In this
    case, the `Path` to an image file is used.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的 CompletableFuture 实例的通用类型必须与实际执行管道时调用者提供的类型匹配。在本例中，使用 `Path` 到图像文件。
- en: '[![3](assets/3.png)](#co_asynchronous_tasks_CO6-3)'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_asynchronous_tasks_CO6-3)'
- en: The task pipeline starts with an unsettled instance so the required processing
    operations can be added lazily.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 任务管道始于一个未决实例，以便可以懒加载添加所需的处理操作。
- en: '[![4](assets/4.png)](#co_asynchronous_tasks_CO6-4)'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_asynchronous_tasks_CO6-4)'
- en: The `Task` record is returned to provide easy access to the first and last stages.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`Task` 记录返回，以便轻松访问第一个和最后一个阶段。'
- en: 'Running the task pipeline is done by calling any of the `complete` methods
    on the first stage `start`. Afterward, the last stage is used to retrieve a potential
    result, as shown below:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 运行任务管道是通过调用第一阶段 `start` 上的任意 `complete` 方法完成的。然后，最后一个阶段用于检索可能的结果，如下所示：
- en: '[PRE23]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Just like a Stream pipeline without a terminal operation creates a lazy processing
    pipeline for multiple items, a pending CompletableFuture pipeline is a lazily
    usable task pipeline for a singular item.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 就像没有终端操作的流管道会为多个项创建一个延迟处理管道一样，未决的 CompletableFuture 管道是一个延迟可用的单个项任务管道。
- en: About Thread Pools and Timeouts
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于线程池和超时
- en: 'Two last aspects of concurrent programming shouldn’t be ignored: timeouts and
    thread pools.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 并发编程的另外两个方面不容忽视：超时和线程池。
- en: By default, all `-Async` `CompletableFuture` operations use the JDK’s common
    `ForkJoinPool`. It’s a highly optimized thread pool based on runtime settings
    with sensible defaults^([1](ch13.xhtml#idm45115216237728)). As its name implies,
    the “common” pool is a shared one also used by other parts of the JDK, like parallel
    Streams. Unlike parallel Streams, though, the async operations can use a custom
    `Executor` instead. That allows you to use a thread pool fitting your requirements^([2](ch13.xhtml#idm45115216235488))
    without affecting the common pool.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，所有`-Async`的`CompletableFuture`操作使用JDK的公共`ForkJoinPool`。这是一个基于运行时设置具有合理默认值的高度优化的线程池^([1](ch13.xhtml#idm45115216237728))。顾名思义，“common”池是一个共享池，也被JDK的其他部分如并行流使用。然而，与并行流不同，异步操作可以使用自定义的`Executor`。这使您可以使用适合您需求的线程池^([2](ch13.xhtml#idm45115216235488))，而不影响公共池。
- en: Daemon Threads
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 守护线程
- en: An important difference between using Threads via the `ForkJoinPool` and user-created
    ones via an `Executor` is their ability to outlive the main thread. By default,
    user-created Threads are non-daemon, which means they outlive the main thread
    and prevent the JVM from exiting, even if the main thread has finished all its
    work. Using Threads via the `ForkJoinPool`, however, might get killed with the
    main thread. See this [blog post](https://bazlur.com/2021/07/be-sure-of-using-fork/join-common-pool-they-are-daemon-threads/)
    by Java Champion A N M Bazlur Rahman for more details on the topic.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ForkJoinPool`通过线程与通过`Executor`创建的用户线程之间的一个重要区别是它们能够比主线程生存更久。默认情况下，用户创建的线程是非守护线程，这意味着它们会比主线程更长时间地存活，并阻止JVM退出，即使主线程已完成所有工作。然而，通过`ForkJoinPool`使用线程可能会随着主线程的结束而被终止。有关该主题的更多详细信息，请参阅Java冠军A
    N M Bazlur Rahman的这篇[博文](https://bazlur.com/2021/07/be-sure-of-using-fork/join-common-pool-they-are-daemon-threads/)。
- en: Running your tasks on the most efficient thread is only the first half of the
    equation; thinking about timeouts is the other half. A `CompletableFuture` that
    never completes or times out will remain pending for eternity, blocking its thread.
    If you try to retrieve its value, for example, by calling `get()`, the current
    thread is blocked, too. Choosing appropriate timeouts can prevent eternally blocked
    threads. However, using timeouts means that you also have to deal with a possible
    `TimeoutException` now.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在最高效的线程上运行任务只是方程式的一半；考虑超时也是另一半。一个永不完成或超时的`CompletableFuture`将保持永远挂起，阻塞其线程。例如，如果尝试通过调用`get()`检索其值，则当前线程也会被阻塞。选择适当的超时可以防止永远阻塞的线程。然而，使用超时意味着现在也必须处理可能的`TimeoutException`。
- en: There are multiple operations available, both intermediate and terminal, as
    listed in [Table 13-4](#_02-completable-future_timeout).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 提供多种操作，包括中间操作和终端操作，如[表 13-4](#_02-completable-future_timeout)所列。
- en: Table 13-4\. Timeout-related operations
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 表13-4\. 与超时相关的操作
- en: '| Method signature | Use-case |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: 方法签名 | 用例 |
- en: '| --- | --- |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `CompletableFuture<T> completeOnTimeout(T value, long timeout, TimeUnit unit)`
    | Completes the stage normally with the provided value after the timeout is reached.
    (Java 9+) |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| `CompletableFuture<T> completeOnTimeout(T value, long timeout, TimeUnit unit)`
    | 在超时后使用提供的值正常完成阶段。（Java 9+） |'
- en: '| `CompletableFuture<T> orTimeout(long timeout, TimeUnit unit)` | Completes
    the stage exceptionally after the timeout is reached. (Java 9+) |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| `CompletableFuture<T> orTimeout(long timeout, TimeUnit unit)` | 在超时后异常地完成阶段。（Java
    9+） |'
- en: '| `T get(long timeout, TimeUnit unit)` | Blocks the current thread until the
    end of the computation. If the `timeout` is reached, a `TimeoutException` is thrown.
    |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| `T get(long timeout, TimeUnit unit)` | 阻塞当前线程直到计算结束。如果超时，则抛出`TimeoutException`异常。
    |'
- en: The intermediate operations `completeOnTimeout` and `orTimeout` provide an interceptor-like
    operation to handle timeouts at any position of a `CompletableFuture` pipeline.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 中间操作`completeOnTimeout`和`orTimeout`提供了一种类似拦截器的操作，用于处理`CompletableFuture`管道中任何位置的超时情况。
- en: An alternative to timeouts is canceling a running stage by calling `boolean
    cancel(boolean mayInterruptIfRunning)`. It cancels an unsettled stage and its
    dependents, so it might require some coordination and keeping track of what’s
    happening to cancel the right one.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 超时的替代方案是通过调用`boolean cancel(boolean mayInterruptIfRunning)`取消正在运行的阶段。它取消一个未解决的阶段及其依赖项，因此可能需要一些协调和跟踪正在取消的正确阶段。
- en: Final Thoughts on Asynchronous Tasks
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于异步任务的最终思考
- en: Asynchronous programming is an important aspect of concurrent programming to
    achieve better performance and responsiveness. However, it can be difficult to
    reason about asynchronous code execution, because it’s no longer obvious *when*
    and on *which thread* a task is executed.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程是并发编程的一个重要方面，以实现更好的性能和响应能力。然而，要理解异步代码执行的时间和在哪个线程上执行并不明显。
- en: Coordinating different threads is nothing new to Java. It can be a hassle and
    is hard to do right and efficiently, especially if you’re not used to multi-threaded
    programming. That’s where the `CompletableFuture` API really shines. It combines
    the creation of intricate asynchronous possibly multi-step tasks and their coordination
    into an extensive, consistent, and easy-to-use API. This allows you to incorporate
    asynchronous programming into your code way easier than before. Furthermore, you
    don’t require the common boilerplate and “handrails” normally associated with
    multi-threaded programming.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 协调不同线程在 Java 中并不是什么新鲜事。如果你不习惯多线程编程，这可能是一件麻烦且难以高效完成的事情。这正是`CompletableFuture`
    API 的闪光之处。它将复杂的异步、可能是多步骤任务的创建与协调结合到一个广泛、一致且易于使用的 API 中。这使得你可以比以往更轻松地将异步编程纳入你的代码中。此外，你不需要通常与多线程编程相关的常见样板和“扶手”。
- en: Still, like with all programming techniques, there’s an *optimal problem context*.
    If used indiscriminately, asynchronous tasks might achieve the opposite of their
    intended goal.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，就像所有编程技术一样，存在一个*最佳问题上下文*。如果不加区分地使用，异步任务可能会达不到预期的目标。
- en: 'Running tasks asynchronously is a good fit for any of these criteria:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 异步运行任务适用于以下任何情况：
- en: Many tasks need to be done simultaneously with at least one being able to make
    progress.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多任务需要同时进行，至少其中一个能够取得进展。
- en: Tasks performing heavy I/O, long-running computations, network calls, or any
    kind of blocking operation.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理重 I/O、长时间运算、网络调用或任何类型的阻塞操作的任务。
- en: Tasks are mostly independent and don’t have to wait for another one to complete.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务大多数是独立的，不必等待另一个任务完成。
- en: Even with such a quite high-level abstraction like `CompletableFuture`, multi-threaded
    code trades simplicity for possible efficiency.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是像`CompletableFuture`这样的高级抽象，多线程代码也是以可能的效率为代价的简单交换。
- en: Like other concurrent or parallel high-level APIs, such as the parallel Stream
    API I discussed in [Chapter 8](ch08.xhtml#_01-parallel-streams), there are non-obvious
    costs involved in coordinating multiple threads. Such APIs should be chosen deliberately
    as an optimization technique, not as a one-size-fits-all solution to hopefully
    use the available resources more efficiently.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 像其他并发或并行高级 API 一样，比如我在[第 8 章](ch08.xhtml#_01-parallel-streams)中讨论的并行流 API，协调多个线程涉及非明显的成本。应该有意选择这些
    API 作为优化技术，而不是作为一种希望更有效地利用可用资源的一揽子解决方案。
- en: If you’re interested in the finer details of how to navigate multi-threaded
    environments safely, I recommend the book *Java Concurrency in Practice* by Brian
    Goetz^([3](ch13.xhtml#idm45115216152080)), the Java Language Architect at Oracle.
    Even with all the new concurrent features introduced since its release in 2006,
    this book is still the de-facto reference manual on the topic.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对如何安全地在多线程环境中导航的细节感兴趣，我推荐由 Oracle 的 Java 语言架构师 Brian Goetz^([3](ch13.xhtml#idm45115216152080))
    所著的 *Java Concurrency in Practice* 这本书。即使自 2006 年发布以来引入了所有新的并发功能，这本书仍然是该主题的事实参考手册。
- en: Takeaways
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要点
- en: Java 5 introduced the type `Future<T>` as a container type for asynchronous
    tasks with an eventual result.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 5 引入了类型`Future<T>`作为异步任务的容器类型，具有最终结果。
- en: The CompletableFuture API improves upon the `Future<T>` type by providing many
    desirable features previously unavailable. It’s a declarative, reactive, lambda-based
    coordination API with 70+ methods.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CompletableFuture API 在提供了许多以前不可用的理想特性的基础上，改进了`Future<T>`类型。它是一个声明式的、反应式的、基于
    Lambda 的协调 API，拥有 70 多个方法。
- en: Tasks can be easily chained or merged into a more complex pipeline that runs
    each task in a new thread if required.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务可以轻松地链式或合并成一个更复杂的管道，如果需要的话，每个任务都在新线程中运行。
- en: Exceptions are *first-class-citizens* and you can recover within the functional
    fluent call, unlike the Streams API.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常是*头等公民*，你可以在函数流畅调用中恢复，不像 Streams API。
- en: '`CompletableFuture<T>` instances can be created manually with either a preexisting
    value without requiring any threads or other coordination, or as a pending instance
    to provide an on-demand starting point for its attached operations.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompletableFuture<T>`实例可以手动创建，无需任何线程或其他协调即可使用预先存在的值，或者作为挂起实例，以提供其附加操作的按需启动点。'
- en: As the `CompletableFuture` API is a concurrency tool, the usual concurrency-related
    aspects and issues need to be considered, too, like timeouts and thread pools.
    Like parallel Streams, running tasks asynchronously should be considered an optimization
    technique, not necessarily the first option to go to.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于`CompletableFuture` API是一个并发工具，因此还需要考虑通常与并发相关的方面和问题，如超时和线程池。与并行流一样，异步运行任务应被视为一种优化技术，而不一定是首选选项。
- en: ^([1](ch13.xhtml#idm45115216237728-marker)) The default settings of the common
    `ForkJoinPool` and how to change them is explained in [its documentation](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/ForkJoinPool.xhtml)
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch13.xhtml#idm45115216237728-marker)) 通用的`ForkJoinPool`的默认设置及其如何更改的解释可在[其文档](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/ForkJoinPool.xhtml)中找到。
- en: '^([2](ch13.xhtml#idm45115216235488-marker)) The excellent book *Java Concurrency
    in Practice* by Josh Bloch et.al. (ISBN 9780321349606) has all the information
    you might need in *Part II: Chapter 8\. Applying Thread Pools* to better understand
    how thread pools work and are utilized best.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch13.xhtml#idm45115216235488-marker)) 优秀的书籍*Java并发实战*由Josh Bloch等人编写（ISBN
    9780321349606），在*第二部分：第8章 应用线程池*中，提供了更好地理解线程池工作及其最佳应用的所有信息。
- en: ^([3](ch13.xhtml#idm45115216152080-marker)) Goetz, Brian. 2006\. “Java Concurrency
    in Practice.” Addison-Wesley. ISBN 978-0321349606.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch13.xhtml#idm45115216152080-marker)) Goetz, Brian. 2006\. “Java Concurrency
    in Practice.” Addison-Wesley. ISBN 978-0321349606.
