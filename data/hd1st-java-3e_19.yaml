- en: 'Chapter 17\. Make a Connection: Networking and Threads'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第17章。建立连接：网络和线程
- en: '![image](Images/f0587-01.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0587-01.png)'
- en: '**Connect with the outside world.** Your Java program can talk to a program
    on another machine. It’s easy. All the low-level networking details are taken
    care of by the built-in Java libraries. One of Java’s big benefits is that sending
    and receiving data over a network can be just I/O with a slightly different connection
    at the end of the I/O chain. In this chapter we’ll connect to the outside world
    with *channels*. We’ll make *client* channels. We’ll make *server* channels. We’ll
    make *clients* and *servers*, and we’ll make them talk to each other. And we’ll
    also have to learn how to do more than one thing at once. Before the chapter’s
    done, you’ll have a fully functional, multithreaded chat client. Did we just say
    *multithreaded*? Yes, now you *will* learn the secret of how to talk to Bob while
    simultaneously listening to Suzy.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**与外界建立连接。** 你的Java程序可以与另一台机器上的程序交流。这很容易。所有底层网络细节都由内置的Java库处理。Java的一个重要优点是，在网络上发送和接收数据可以仅仅是I/O，只是在I/O链的末端有一个稍微不同的连接而已。在本章中，我们将用*通道*连接到外部世界。我们将创建*客户端*通道。我们将创建*服务器*通道。我们将创建*客户端*和*服务器*，并使它们互相交流。我们还需要学习如何同时做多件事情。在本章完成之前，你将拥有一个完全功能的多线程聊天客户端。我们刚刚说过*多线程*吗？是的，现在你*将*学会如何在与Bob交谈的同时听Suzy的秘密。'
- en: Real-time BeatBox chat
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实时BeatBox聊天
- en: '![image](Images/f0588-01.png)![image](Images/f0588-02.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0588-01.png)![image](Images/f0588-02.png)'
- en: You’re working on a computer game. You and your team are doing the sound design
    for each part of the game. Using a “chat” version of the BeatBox, your team can
    collaborate—you can send a beat pattern along with your chat message, and everybody
    in the BeatBox Chat gets it. So you don’t just get to *read* the other participants’
    messages; you get to load and *play* a beat pattern simply by clicking the message
    in the incoming messages area.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在做一款电脑游戏。你和你的团队为游戏的每个部分做声音设计。使用BeatBox的“聊天”版本，你的团队可以协作——你可以发送一个节奏模式以及你的聊天消息，BeatBox聊天中的每个人都可以得到它。所以你不仅可以*阅读*其他参与者的消息；你还可以通过点击传入消息区域中的消息，加载和*播放*一个节奏模式。
- en: In this chapter we’re going to learn what it takes to make a chat client like
    this. We’re even going to learn a little about making a chat *server*. We’ll save
    the full BeatBox Chat for the Code Kitchen, but in this chapter you *will* write
    a Ludicrously Simple Chat Client and Very Simple Chat Server that send and receive
    text messages.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何制作类似于这样的聊天客户端。我们甚至将学习一点关于制作聊天*服务器*。我们将把完整的 BeatBox 聊天留给代码工作坊，但在本章中，你*将*编写一个非常简单的聊天客户端和非常简单的聊天服务器，用于发送和接收文本消息。
- en: '**Chat program overview**'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**聊天程序概述**'
- en: Note
  id: totrans-8
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Each Client has to know about the Server.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 每个客户端都必须了解服务器。
- en: The Server has to know about ALL the Clients.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器必须了解所有客户端。
- en: '![image](Images/f0589-01.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0589-01.png)'
- en: '**How it works:**'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**工作原理：**'
- en: '![Images](Images/1circle.png) Client connects to the server'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Images](Images/1circle.png) 客户端连接到服务器'
- en: '![image](Images/f0589-02.png)'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0589-02.png)'
- en: '![Images](Images/2circle.png) The server makes a connection and adds the client
    to the list of participants'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Images](Images/2circle.png) 服务器建立连接，并将客户端加入参与者列表。'
- en: '![image](Images/f0589-03.png)'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0589-03.png)'
- en: '![Images](Images/3circle.png) Another client connects'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Images](Images/3circle.png) 另一个客户端连接'
- en: '![image](Images/f0589-04.png)'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0589-04.png)'
- en: '![Images](Images/4circle.png) Client A sends a message to the chat service'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Images](Images/4circle.png) 客户端A向聊天服务发送消息'
- en: '![image](Images/f0589-05.png)'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0589-05.png)'
- en: '![Images](Images/5circle.png) The server distributes the message to ALL participants
    (including the original sender)'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_IMG
  zh: '![Images](Images/5circle.png) 服务器将消息分发给所有参与者（包括原始发送者）'
- en: '![image](Images/f0589-06.png)'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0589-06.png)'
- en: Connecting, sending, and receiving
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接、发送和接收
- en: 'The three things we have to learn to get the client working are:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要学习的三件事来使客户端工作：
- en: How to establish the initial **connection** between the client and server
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在客户端和服务器之间建立初始**连接**。
- en: How to **receive** messages *from* the server
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何从服务器**接收**消息*的方式
- en: How to **send** messages *to* the server
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何**发送**消息*到*服务器
- en: There’s a lot of low-level stuff that has to happen for these things to work.
    But we’re lucky, because the Java APIs make it a piece of cake for programmers.
    You’ll see a lot more GUI code than networking and I/O code in this chapter.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这些事情起作用，需要进行许多底层工作。但我们很幸运，因为Java API使得这对程序员来说非常简单。在本章中，你会看到比网络和I/O代码更多的GUI代码。
- en: And that’s not all.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这还不是全部。
- en: 'Lurking within the simple chat client is a problem we haven’t faced so far
    in this book: doing two things at the same time. Establishing a connection is
    a one-time operation (that either works or fails). But after that, a chat participant
    wants to *send outgoing messages* and **simultaneously** *receive incoming messages*
    from the other participants (via the server). Hmm...that one’s going to take a
    little thought, but we’ll get there in just a few pages.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的聊天客户端中，隐藏着我们在本书中迄今为止还没有面对过的问题：同时做两件事情。建立连接是一次性操作（要么成功要么失败）。但之后，聊天参与者希望**发送出去的消息**和**同时**从其他参与者（通过服务器）*接收传入的消息*。嗯...这需要花点时间思考，但我们将在几页内解决这个问题。
- en: '![Images](Images/1circle.png) **Connect**'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图像](Images/1circle.png) **连接**'
- en: Client **connects** to the server
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 客户端**连接到服务器**
- en: '![image](Images/f0590-01.png)'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图像](Images/f0590-01.png)'
- en: '![Images](Images/2circle.png) **Receive**'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图像](Images/2circle.png) **接收**'
- en: Client **reads** a message from the server
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 客户端**从服务器读取消息**
- en: '![image](Images/f0590-02.png)'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图像](Images/f0590-02.png)'
- en: '![Images](Images/3circle.png) **Send**'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图像](Images/3circle.png) **发送**'
- en: Client **writes** a message to the server
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 客户端**向服务器写入**消息
- en: '![image](Images/f0590-03.png)'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图像](Images/f0590-03.png)'
- en: 1\. Connect
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1. 连接
- en: To talk to another machine, we need an object that represents a network connection
    between two machines. We can open a java.nio.channels.SocketChannel to give us
    this connection object.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要与另一台机器通信，我们需要一个代表两台机器之间的网络连接的对象。我们可以打开一个java.nio.channels.SocketChannel来得到这个连接对象。
- en: What’s a connection? A *relationship* between two machines, where **two pieces
    of software know about each other**. Most importantly, those two pieces of software
    know how to *communicate* with each other. In other words, how to send *bits*
    to each other.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是连接？是两台机器之间的*关系*，两个**软件组件了解对方**的方式。最重要的是，这两个软件组件知道如何*相互通信*。换句话说，如何向*彼此发送*位。
- en: We don’t care about the low-level details, thankfully, because they’re handled
    at a much lower place in the “networking stack.” If you don’t know what the “networking
    stack” is, don’t worry about it. It’s just a way of looking at the layers that
    information (bits) must travel through to get from a Java program running in a
    JVM on some OS, to physical hardware (Ethernet cables, for example), and back
    again on some other machine.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们不必关心低级细节，因为它们在“网络堆栈”的更低层次上处理。如果你不知道“网络堆栈”是什么，不用担心。这只是一种查看信息（位）必须通过的层次的方式，从运行在某个操作系统上的JVM中的Java程序，到物理硬件（例如以太网电缆），再返回到另一台机器。
- en: The part that you have to worry about is high-level. You just have to create
    an object for the server’s address and then open a channel to that server. Ready?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要担心的部分是高级的。你只需要为服务器的地址创建一个对象，然后打开一个通道到该服务器。准备好了吗？
- en: Note
  id: totrans-45
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'To make a connection, you need to know two things about the server: where it
    is and which port it’s running on.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要建立连接，您需要了解服务器的两件事情：它在哪里以及它运行在哪个端口上。
- en: In other words,
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，
- en: Note
  id: totrans-48
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**IP address and TCP port number.**'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**IP地址和TCP端口号。**'
- en: '![image](Images/f0591-01.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Images/f0591-01.png)'
- en: Note
  id: totrans-51
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A connection means the two machines have information about each other, including
    network location (IP address) and TCP port.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 连接意味着两台机器彼此了解，包括网络位置（IP地址）和TCP端口。
- en: '**A TCP port is just a number... a 16-bit number that identifies a specific
    program on the server**'
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**TCP端口只是一个数字...一个16位数，用于标识服务器上特定的程序**'
- en: Your internet web (HTTP) server runs on port 80\. That’s a standard. If you’ve
    got a Telnet server, its running on port 23\. FTP? 20\. POP3 mail server? 110\.
    SMTP? 25\. The Time server sits at 37\. Think of port numbers as unique identifiers.
    They represent a logical connection to a particular piece of software running
    on the server. That’s it. You can’t spin your hardware box around and find a TCP
    port. For one thing, you have 65,536 of them on a server (0–65535). So they obviously
    don’t represent a place to plug in physical devices. They’re just a number representing
    an application.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你的互联网Web（HTTP）服务器运行在80端口。这是一个标准。如果你有Telnet服务器，它运行在23端口。FTP？20。POP3邮件服务器？110。SMTP？25。时间服务器位于37端口。把端口号想象成唯一的标识符。它们代表了与服务器上运行的特定软件的逻辑连接。就是这样。你不能转动你的硬件盒子然后找到一个TCP端口。首先，服务器上有65536个端口（0-65535）。所以显然它们不代表插入物理设备的地方。它们只是代表一个应用程序的数字。
- en: 'Well-known TCP port numbers for common server applications:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '常见服务器应用程序的众所周知的TCP端口号:'
- en: '![image](Images/f0592-01.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0592-01.png)'
- en: Without port numbers, the server would have no way of knowing which application
    a client wanted to connect to. And since each application might have its own unique
    protocol, think of the trouble you’d have without these identifiers. What if your
    web browser, for example, landed at the POP3 mail server instead of the HTTP server?
    The mail server won’t know how to parse an HTTP request! And even if it did, the
    POP3 server doesn’t know anything about servicing the HTTP request.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 没有端口号，服务器将无法知道客户端想连接到哪个应用程序。由于每个应用程序可能有自己独特的协议，如果没有这些标识符，你会遇到什么麻烦呢？例如，如果你的网络浏览器着陆在了POP3邮件服务器而不是HTTP服务器上会怎么样？邮件服务器将不知道如何解析HTTP请求！即使知道了，POP3服务器也不知道如何处理HTTP请求。
- en: When you write a server program, you’ll include code that tells the program
    which port number you want it to run on (you’ll see how to do this in Java a little
    later in this chapter). In the Chat program we’re writing in this chapter, we
    picked 5000\. Just because we wanted to. And because it met the criteria that
    it be a number between 1024 and 65535\. Why 1024? Because 0 through 1023 are reserved
    for the well-known services like the ones we just talked about.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写一个服务器程序时，你将包含告诉程序要在哪个端口号上运行的代码（稍后在本章的Java部分中将会看到如何做到这一点）。在我们在本章中编写的聊天程序中，我们选择了5000。仅仅是因为我们想要这样做。还因为它符合的标准是必须是一个在1024到65535之间的数字。为什么是1024？因为0到1023是为像我们刚刚谈到的那些众所周知的服务而保留的。
- en: And if you’re writing services (server programs) to run on a company network,
    you should check with the sysadmins to find out which ports are already taken.
    Your sysadmins might tell you, for example, that you can’t use any port number
    below, say, 3000\. In any case, if you value your limbs, you won’t assign port
    numbers with abandon. Unless it’s your *home* network. In which case you just
    have to check with your *kids*.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在编写要在公司网络上运行的服务（服务器程序），你应该与系统管理员核实哪些端口已经被占用。例如，你的系统管理员可能会告诉你，你不能使用低于3000的端口号。无论如何，如果你重视自己的生命安全，你不会随意分配端口号。除非是你的*家庭*网络。在这种情况下，你只需要与你的*孩子*核实。
- en: Note
  id: totrans-60
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The TCP port numbers from 0 to 1023 are reserved for well-known services. Don’t
    use them for your own server programs!*
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: TCP端口号从0到1023是为众所周知的服务保留的。不要用它们来运行你自己的服务器程序！*
- en: The chat server we’re writing uses port 5000\. We just picked a number between
    1024 and 65535.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在编写的聊天服务器使用5000端口。我们只是选择了一个在1024到65535之间的数字。
- en: '*Well, you *might* be able to use one of these, but the sysadmin where you
    work will write you a strongly worded message and CC your boss.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*嗯，也许*你*能*用其中一个，但是你工作的系统管理员会给你写一封措辞强烈的邮件，并抄送给你的老板。'
- en: '![image](Images/f0593-01.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0593-01.png)'
- en: 2\. Receive
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2\. 接收
- en: To communicate over a remote connection, you can use regular old I/O streams,
    just like we used in the previous chapter. One of the coolest features in Java
    is that most of your I/O work won’t care what your high-level chain stream is
    actually connected to. In other words, you can use a **BufferedReader** just like
    you did when you were reading from a file; the difference is that the underlying
    connection stream is connected to a *Channel* rather than a *File*!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过远程连接进行通信，你可以使用正常的I/O流，就像我们在上一章节中使用的那样。Java中最酷的功能之一是，大多数的I/O工作都不关心你的高级链流实际连接到了什么。换句话说，你可以像从文件中读取时那样使用**BufferedReader**；不同之处在于底层连接流连接到了一个*Channel*而不是一个*File*！
- en: '![image](Images/f0594-01.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0594-01.png)'
- en: Reading from the network with BufferedReader
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用BufferedReader从网络读取
- en: '![image](Images/f0594-02.png)![image](Images/f0594-03.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0594-02.png)![image](Images/f0594-03.png)'
- en: 3\. Send
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3\. 发送
- en: In the previous chapter, we used BufferedWriter. We have a choice here, but
    when you’re writing one String at a time, **PrintWriter** is a standard choice.
    And you’ll recognize the two key methods in PrintWriter, print() and println()!
    Just like good ol’ System.out.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们使用了BufferedWriter。在这里我们有一个选择，但当你一次写入一个String时，**PrintWriter**是一个标准选择。你会认出PrintWriter中的两个关键方法，print()和println()！就像我们熟悉的System.out一样。
- en: Writing to the network with PrintWriter
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用PrintWriter写入网络
- en: '![image](Images/f0595-01.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0595-01.png)'
- en: There’s more than one way to make a connection
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有多种方法建立连接
- en: '![image](Images/f0596-01.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0596-01.png)'
- en: If you look at real life code that talks to a remote machine, you’ll probably
    see a number of different ways to make connections and to read from and write
    to a remote computer.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看与远程机器通信的实际代码，可能会看到许多不同的建立连接和读写远程计算机的方法。
- en: Which approach you use depends on a number of things, including (but not limited
    to) the version of Java you’re using and the needs of the application (for example,
    how many clients connect at once, the size of messages sent, frequency or message,
    etc). One of the simplest approaches is to use a **java.net.Socket** instead of
    a Channel.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用哪种方法取决于许多因素，包括（但不限于）你使用的Java版本以及应用程序的需求（例如，同时连接的客户端数量，发送消息的大小，消息的频率等）。其中一种最简单的方法是使用**java.net.Socket**而不是Channel。
- en: Using a Socket
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Socket
- en: You can get an *InputStream* or *OutputStream* from a Socket, and read and write
    from it in a very similar way to what we’ve already seen.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从Socket获取*InputStream*或*OutputStream*，并且以非常类似于我们已经看到的方式读取和写入。
- en: '![image](Images/f0596-02.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0596-02.png)'
- en: Note
  id: totrans-81
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The java.net.Socket class is available in all versions of Java.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: java.net.Socket类在所有Java版本中都可用。
- en: It supports simple network I/O via the I/O streams we’ve already used for file
    I/O.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过我们已经用于文件I/O的I/O流支持简单的网络I/O。
- en: '![image](Images/f0597-01.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0597-01.png)'
- en: '**As we’ve become an increasingly connected world, Java has evolved to offer
    more ways to work with remote machines.**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**随着我们成为一个日益连接的世界，Java已经进化到提供更多与远程机器通信的方式。**'
- en: Remember that Channels are in the java.**nio**.channels package? The java.nio
    package (NIO) was introduced in Java 1.4, and there were more changes and additions
    made (sometimes called NIO.2) in Java 7.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 记住Channels在java.**nio**.channels包中？java.nio包（NIO）在Java 1.4中引入，Java 7中进行了更多的变更和添加（有时称为NIO.2）。
- en: There are ways to use Channels and NIO to get better performance when you’re
    working with lots of network connections, or lots of data coming over those connections.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当你处理大量网络连接或大量数据通过这些连接时，使用Channels和NIO可以获得更好的性能。
- en: '**In this chapter, we’re using Channels to provide the same very basic connection
    functionality we could get from Sockets**. However, if our application needed
    to work well with a very busy network connection (or lots of them!), we could
    configure our Channels differently and use them to their full potential, and our
    program would cope better with a high network I/O load.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**在这一章中，我们使用Channels提供与使用Sockets获取相同基本连接功能。然而，如果我们的应用程序需要与繁忙的网络连接（或大量连接）很好地配合工作，我们可以不同配置我们的Channels，并充分利用它们，这样我们的程序能更好地处理高网络I/O负载。**'
- en: We’ve chosen to teach you the **simplest way to get started** with network I/O
    using *Channels* so that if you need to “level up” to working with more advanced
    features, it shouldn’t be such a big step.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择教你使用*Channels*来开始网络I/O的**最简单方式**，这样如果你需要升级到使用更高级特性，就不会是一个很大的跨越。
- en: If you do want to learn more about NIO, read *Java NIO* by Ron Hitchens and
    *Java I/O, NIO and NIO.2* by Jeff Friesen.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确实想要了解更多关于NIO的知识，可以阅读Ron Hitchens的*Java NIO*和Jeff Friesen的*Java I/O, NIO
    and NIO.2*。
- en: The DailyAdviceClient
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DailyAdviceClient
- en: Before we start building the Chat app, let’s start with something a little smaller.
    The Advice Guy is a server program that offers up practical, inspirational tips
    to get you through those long days of coding.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始构建Chat应用之前，让我们从一些小的东西开始。Advice Guy是一个服务器程序，提供实用的灵感提示，帮助你度过编码的漫长时光。
- en: We’re building a client for The Advice Guy program, which pulls a message from
    the server each time it connects.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在为Advice Guy程序构建一个客户端，每次连接时从服务器获取一条消息。
- en: What are you waiting for? Who *knows* what opportunities you’ve missed without
    this app.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你在等什么？没有这个应用，你可能错过了什么*机会*。
- en: '![image](Images/f0598-01.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0598-01.png)'
- en: Figure 17-1\. The Advice Guy
  id: totrans-96
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图17-1\. 顾问人物
- en: '![Images](Images/1circle.png) **Connect**'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/1circle.png) **连接**'
- en: Client connects to the server
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 客户端连接到服务器
- en: '![image](Images/f0598-02.png)'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](Images/f0598-02.png)'
- en: '![Images](Images/2circle.png) **Read**'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/2circle.png) **读取**'
- en: Client gets a Reader for the Channel, and reads a message from the server
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 客户端为通道获取了一个Reader，并从服务器读取了一条消息
- en: '![image](Images/f0598-03.png)'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](Images/f0598-03.png)'
- en: DailyAdviceClient code
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DailyAdviceClient 代码
- en: This program makes a SocketChannel, makes a BufferedReader (with the help of
    the channel’s Reader), and reads a single line from the server application (whatever
    is running at port 5000).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序创建了一个SocketChannel，创建了一个BufferedReader（通过通道的Reader帮助），并从服务器应用程序（在5000端口上运行的任何内容）读取一行。
- en: '![image](Images/f0599-01.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0599-01.png)'
- en: Writing a simple server application
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写一个简单的服务器应用程序
- en: So what’s it take to write a server application? Just a couple of Channels.
    Yes, a couple as in two. A ServerSocketChannel, which waits for client requests
    (when a client connects) and a SocketChannel to use for communication with the
    client. If there’s more than one client, we’ll need more than one channel, but
    we’ll get to that later.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，编写服务器应用程序需要什么？只需要几个通道。是的，几个通道，即两个。一个ServerSocketChannel，用于等待客户端请求（当客户端连接时），以及一个用于与客户端通信的SocketChannel。如果有多个客户端，我们将需要多个通道，但我们稍后再讨论这个问题。
- en: '**How it works:**'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**工作原理：**'
- en: '![Images](Images/1circle.png) Server application makes a ServerSocketChannel
    and binds it to a specific port'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/1circle.png) 服务器应用程序创建了一个ServerSocketChannel，并将其绑定到特定端口'
- en: '[PRE0]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This starts the server application listening for client requests coming in for
    port 5000.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将使服务器应用程序开始监听传入端口5000的客户端请求。
- en: '![image](Images/f0601-01.png)'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](Images/f0601-01.png)'
- en: '![Images](Images/2circle.png) Client makes a SocketChannel connected to the
    server application'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/2circle.png) 客户端创建了一个连接到服务器应用程序的SocketChannel'
- en: '`**SocketChannel svr = SocketChannel.open(new InetSocketAddress("190.165.1.103",
    5000));**`'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`**SocketChannel svr = SocketChannel.open(new InetSocketAddress("190.165.1.103",
    5000));**`'
- en: Client knows the IP address and port number (published or given to them by whomever
    configures the server app to be on that port).
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 客户端知道IP地址和端口号（由配置服务器应用程序的人员发布或提供给他们）。
- en: '![image](Images/f0601-02.png)'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](Images/f0601-02.png)'
- en: '![Images](Images/3circle.png) Server makes a new SocketChannel to communicate
    with this client'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/3circle.png) 服务器创建了一个新的SocketChannel来与该客户端通信'
- en: '`**SocketChannel clientChannel = serverChannel.accept();**`'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`**SocketChannel clientChannel = serverChannel.accept();**`'
- en: The accept() method blocks (just sits there) while it’s waiting for a client
    connection. When a client finally connects, the method returns a SocketChannel
    that knows how to communicate with this client.
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: accept() 方法在等待客户端连接时会阻塞（即仅等待）。当客户端最终连接时，该方法将返回一个SocketChannel，该通道知道如何与该客户端通信。
- en: The ServerSocketChannel can go back to waiting for other clients. The server
    has just one ServerSocketChannel, and a SocketChannel per client.
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ServerSocketChannel 可以回到等待其他客户端连接的状态。服务器只有一个ServerSocketChannel，并为每个客户端创建一个SocketChannel。
- en: '![image](Images/f0601-03.png)'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](Images/f0601-03.png)'
- en: DailyAdviceServer code
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DailyAdviceServer 代码
- en: This program makes a ServerSocketChannel and waits for client requests. When
    it gets a client request (i.e., client created a new SocketChannel to this server),
    the server makes a new SocketChannel to that client. The server makes a PrintWriter
    (using a Writer created from the SocketChannel) and sends a message to the client.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序创建了一个ServerSocketChannel，并等待客户端请求。当它收到客户端请求（即客户端创建了一个新的SocketChannel到这个服务器），服务器将创建一个新的SocketChannel到该客户端。服务器创建了一个PrintWriter（使用从SocketChannel创建的Writer）并向客户端发送一条消息。
- en: '![image](Images/f0602-01.png)![image](Images/f0603-01.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0602-01.png)![图片](Images/f0603-01.png)'
- en: Yes, that’s right, **the server can’t accept a request from a client until it
    has finished with the current client.** At which point, it starts the next iteration
    of the infinite loop, sitting, waiting, at the accept() call until a new request
    comes in, at which point it makes a SocketChannel to send data to the new client
    and starts the process over again.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，没错，**服务器在完成当前客户端请求之前无法接受来自其他客户端的请求。** 在此期间，它将进入无限循环的下一次迭代中，并在accept()调用处等待，直到有新请求到来。然后，它将创建一个SocketChannel来向新客户端发送数据，并重新启动整个过程。
- en: To get this to work with multiple clients *at the same time*, we need to use
    separate threads.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要使其能够同时处理多个客户端，我们需要使用单独的线程。
- en: We’d give each new client’s SocketChannel to a new thread, and each thread can
    work independently.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将每个新客户端的SocketChannel交给一个新的线程，每个线程可以独立工作。
- en: We’re just about to learn how to do that!
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们就要学习如何做到这一点了！
- en: Writing a Chat Client
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写聊天客户端
- en: We’ll write the Chat Client application in two stages. First we’ll make a send-only
    version that sends messages to the server but doesn’t get to read any of the messages
    from other participants (an exciting and mysterious twist to the whole chat room
    concept).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分两个阶段编写聊天客户端应用程序。首先，我们将制作一个仅发送消息但不读取其他参与者消息的版本（这对整个聊天室概念来说是一个令人兴奋和神秘的转折）。
- en: Then we’ll go for the full chat monty and make one that both sends *and* receives
    chat messages.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将全面展示如何制作一个既发送*又*接收聊天消息的版本。
- en: '**Version One: send-only**'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**第一个版本：仅发送**'
- en: '![image](Images/f0604-01.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0604-01.png)'
- en: '**Code outline**'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码大纲**'
- en: Here’s an outline of the main functionality the chat client needs to provide.
    The full code is on the next page.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这是聊天客户端需要提供的主要功能概述。完整代码在下一页。
- en: '[PRE1]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![image](Images/f0605-01.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0605-01.png)'
- en: The really, really simple Chat Server
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非常，非常简单的聊天服务器
- en: '![image](Images/f0606-01.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0606-01.png)'
- en: You can use this server code for all versions of the Chat Client. Every possible
    disclaimer ever disclaimed is in effect here. To keep the code stripped down to
    the bare essentials, we took out a lot of parts that you’d need to make this a
    real server. In other words, it works, but there are at least a hundred ways to
    break it. If you want to really sharpen your skills after you’ve finished this
    book, come back and make this server code more robust.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这个服务器代码来运行所有版本的聊天客户端。这里适用于所有可能的免责声明。为了使代码保持精简，我们删除了许多使其成为真正服务器所需的部分。换句话说，它可以工作，但至少有一百种方法可以使其崩溃。如果你在完成本书后想要真正提升你的技能，就回来把这个服务器代码变得更加健壮。
- en: After you finish this chapter, you should be able to annotate this code yourself.
    You’ll understand it much better if *you* work out what’s happening than if we
    explained it to you. Then again, this is Ready-Bake Code, so you really don’t
    have to understand it at all. It’s here just to support the two versions of the
    Chat Client.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，你应该能够自己注释此代码。如果*你*能弄清楚发生了什么，那你就会更好地理解它，而不是我们向你解释。但另一方面，这是现成的代码，所以你真的不必完全理解它。它在这里只是为了支持聊天客户端的两个版本。
- en: '[PRE2]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![image](Images/f0607-01.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0607-01.png)'
- en: '**Version Two: send and receive**'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**第二个版本：发送和接收**'
- en: '![image](Images/f0608-01.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0608-01.png)'
- en: '**Big Question: *HOW* do you get messages from the server?**'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要问题：*如何*从服务器接收消息？**'
- en: Should be easy; when you set up the networking, make a Reader as well. Then
    read messages using `**readLine**`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 应该很简单；当你设置网络时，也要创建一个Reader。然后使用`**readLine**`读取消息。
- en: '**Bigger Question: *WHEN* do you get messages from the server?**'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**更重要的问题：*何时*会收到服务器的消息？**'
- en: Think about that. What are the options?
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细考虑一下。有什么选项？
- en: '![Images](Images/1.png) **Option One: Read something in from the server each
    time the user sends a message.**'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/1.png) **选项一：每次用户发送消息时从服务器中读取内容。**'
- en: '**Pros:** Doable, very easy.'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**优点：** 可行，非常简单。'
- en: '**Cons:** Stupid. Why choose such an arbitrary time to check for messages?
    What if a user is a lurker and doesn’t send anything?'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**缺点：** 愚蠢。为什么选择如此任意的时间来检查消息？如果用户是潜水者并且不发送任何内容会怎么样？'
- en: '![Images](Images/2.png) **Option Two: Poll the server every 20 seconds.**'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/2.png) **选项二：每20秒轮询服务器。**'
- en: '**Pros:** It’s doable, and it fixes the lurker problem.'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**优点：** 可行，并且解决了潜水者问题。'
- en: '**Cons:** How does the server know what you’ve seen and what you haven’t? The
    server would have to store the messages, rather than just doing a distribute-and-forget
    each time it gets one. And why 20 seconds? A delay like this affects usability,
    but as you reduce the delay, you risk hitting your server needlessly. Inefficient.'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**缺点：** 服务器如何知道你看过什么，还有什么没看过？服务器必须存储消息，而不是每次接收到消息就执行分发和忘记。而且为什么是20秒？这样的延迟会影响可用性，但是当你减少延迟时，你会不必要地增加对服务器的访问。低效。'
- en: '![Images](Images/3.png) **Option Three: Read messages as soon as they’re sent
    from the server.**'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/3.png) **选项三：一旦从服务器发送，立即读取消息。**'
- en: '**Pros:** Most efficient, best usability.'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**优点：** 最高效，最好的可用性。'
- en: '**Cons:** How do you do two things at the same time? Where would you put this
    code? You’d need a loop somewhere that was always waiting to read from the server.
    But where would that go? Once you launch the GUI, nothing happens until an event
    is fired by a GUI component.'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**缺点：** 如何同时做两件事？把这段代码放在哪里？你需要一个循环，总是等待从服务器读取。但是这应该放在哪里？一旦启动 GUI，除非 GUI 组件触发事件，否则什么也不会发生。'
- en: '![image](Images/f0609-01.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0609-01.png)'
- en: Note
  id: totrans-160
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In Java you really CAN walk and chew gum at the same time.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，你确实可以一边走一边嚼口香糖。
- en: '**You know by now that we’re going with option three**'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**你现在已经知道我们选择了第三个选项**'
- en: We want something to run continuously, checking for messages from the server,
    but *without interrupting the user’s ability to interact with the GUI!* So while
    the user is happily typing new messages or scrolling through the incoming messages,
    we want something *behind the scenes* to keep reading in new input from the server.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望有些东西可以持续运行，不断地从服务器检查消息，但*不会打断用户与 GUI 交互的能力*！因此，当用户愉快地输入新消息或浏览传入消息时，我们希望*在幕后*不断读取来自服务器的新输入。
- en: That means we finally need a new thread. A new, separate stack.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们最终需要一个新的线程。一个新的、独立的栈。
- en: We want everything we did in the Send-Only version (version one) to work the
    same way, while a new *process* runs alongside that reads information from the
    server and displays it in the incoming text area.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在只发送版本（第一版）中所做的一切都能以同样的方式工作，同时运行一个新的*进程*，该进程并行地从服务器读取信息并在传入文本区域中显示。
- en: Well, not quite. Each new Java thread is not actually a separate process running
    on the OS. But it almost *feels* as though it is.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，并不完全是这样。每个新的 Java 线程实际上不是在操作系统上运行的单独进程。但它几乎*感觉*像是。
- en: We’re going to take a break from the chat application for a bit while we explore
    how this works. Then we’ll come back and add it to our chat client at the end
    of the chapter.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索它是如何工作的时候，我们将暂时离开聊天应用程序一会儿。然后我们会回来，在本章的最后将其添加到我们的聊天客户端中。
- en: '**Multithreading in Java**'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java 中的多线程**'
- en: 'Java has support for multiple threads built right into the fabric of the language.
    And it’s a snap to make a new thread of execution:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Java 在语言结构中直接支持多线程。而且创建新的执行线程非常简单：
- en: '[PRE3]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: That’s it. By creating a new Thread *object*, you’ve launched a separate *thread
    of execution*, with its very own call stack.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。通过创建一个新的 Thread *对象*，你启动了一个单独的*执行线程*，它有自己的调用栈。
- en: '***Except for one problem.***'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '***除了一个问题。***'
- en: That thread doesn’t actually *do* anything, so the thread “dies” virtually the
    instant it’s born. When a thread dies, its new stack disappears again. End of
    story.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 那个线程实际上什么都不做，所以线程在出生的瞬间就“死”了。当一个线程死亡时，它的新栈也会再次消失。故事结束。
- en: So we’re missing one key component—the thread’s *job*. In other words, we need
    the code that you want to have run by a separate thread.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们缺少一个关键组成部分——线程的 *任务*。换句话说，我们需要在单独的线程中运行你希望运行的代码。
- en: Multiple threading in Java means we have to look at both the *thread* and the
    *job* that’s *run* by the thread. In fact, **there’s more than one way to run
    multiple jobs in Java**, not just with the Thread *class* in the java.lang package.
    (Remember, java.lang is the package you get imported for free, implicitly, and
    it’s where the classes most fundamental to the language live, including String
    and System.)
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中的多线程意味着我们必须看看 *线程* 和 *线程运行的任务*。事实上，**在 Java 中运行多个任务的方式不止一种**，不仅仅是 java.lang
    包中的 Thread *类*。（记住，java.lang 是你免费隐式导入的包，它包含语言最基础的类，包括 String 和 System。）
- en: Java has multiple threads but only one Thread class
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 有多个线程，但只有一个 Thread 类。
- en: We can talk about *thread* with a lowercase “t” and **Thread** with a capital
    “T.” When you see *thread*, we’re talking about a separate thread of execution.
    In other words, a separate call stack. When you see **Thread**, think of the Java
    naming convention. What, in Java, starts with a capital letter? Classes and interfaces.
    In this case, **Thread** is a class in the java.lang package. A **Thread** object
    represents a *thread of execution*. In older versions of Java, you always had
    to create an instance of class **Thread** each time you wanted to start up a new
    *thread* of execution. Java has evolved over time, and now using the **Thread**
    class directly is not the only way. We’ll see this in more detail as we go through
    the rest of the chapter.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用小写字母“thread”来讨论*线程*，用大写字母“Thread”来讨论**Thread**。当你看到*thread*时，我们指的是一个独立的执行线程，换句话说，是一个独立的调用堆栈。当你看到**Thread**时，请考虑Java的命名约定。在Java中，以大写字母开头的是什么？类和接口。在这种情况下，**Thread**是java.lang包中的一个类。**Thread**对象表示一个*执行线程*。在旧版本的Java中，每次想启动新的*执行线程*时，都必须创建**Thread**类的一个实例。Java随着时间的推移发生了变化，现在直接使用**Thread**类并非唯一的方法。随着我们继续学习本章的内容，我们将更详细地了解这一点。
- en: Note
  id: totrans-178
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**A thread is a separate “thread of execution,” a separate call stack.**'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**线程是一个独立的“执行线程”，一个单独的调用堆栈。**'
- en: '**A Thread is a Java class that represents a thread.**'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**Thread是表示线程的Java类。**'
- en: '**Using the Thread class is not the only way to do multithreading in Java.**'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**在Java中不仅使用Thread类来实现多线程。**'
- en: '| **thread** | **Thread** |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| **线程** | **Thread** |'
- en: '| ![image](Images/f0610-01.png) | ![image](Images/f0610-02.png) |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| ![image](Images/f0610-01.png) | ![image](Images/f0610-02.png) |'
- en: '| A *thread* (lowercase “t”) is a separate thread of execution. That means
    a separate call stack. Every Java application starts up a main thread—the thread
    that puts the main() method on the bottom of the stack. The JVM is responsible
    for starting the main thread (and other threads, as it chooses, including the
    garbage collection thread). As a programmer, you can write code to start other
    threads of your own. | `**Thread**` (capital “T”) is a class that represents a
    thread of execution. It has methods for starting a thread, joining one thread
    with another, putting a thread to sleep, and more. |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| *线程*（小写“t”）是一个独立的执行线程。这意味着一个单独的调用堆栈。每个Java应用程序都启动一个主线程 - 将main()方法放在堆栈底部的线程。JVM负责启动主线程（以及其他线程，如选择，包括垃圾收集线程）。作为程序员，你可以编写代码启动自己的其他线程。
    | `**Thread**`（大写“T”）是表示一个执行线程的类。它有启动线程、将一个线程与另一个线程连接、使线程休眠等方法。 |'
- en: What does it mean to have more than one call stack?
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是拥有多个调用堆栈的含义？
- en: With more than one call stack, you can have multiple things happen at the same
    time. If you’re running on a multiprocessor system (like most modern computers
    and phones), you can actually do more than one thing at a time. With Java threads,
    even if you’re not running on a multiprocessor system or if you’re running more
    processes than available cores, it can *appear* that you’re doing all these things
    simultaneously. In other words, execution can move back and forth between stacks
    so rapidly that you feel as though all stacks are executing at the same time.
    Remember, Java is just a process running on your underlying OS. So first, Java
    *itself* has to be “the currently executing process” on the OS. But once Java
    gets its turn to execute, exactly *what* does the JVM *run*? Which bytecodes execute?
    Whatever is on the top of the currently running stack! And in 100 milliseconds,
    the currently executing code might switch to a *different* method on a *different*
    stack.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 有了多个调用堆栈，你可以同时发生多件事情。如果你在多处理器系统上运行（像大多数现代计算机和手机一样），实际上可以同时做多件事情。使用Java线程，即使你不在多处理器系统上运行或者运行的进程比可用核心多，看起来也可以*同时*做多件事情。换句话说，执行可以在不同的堆栈之间迅速切换，以至于你感觉所有的堆栈都在同时执行。请记住，Java只是在底层操作系统上运行的一个进程。因此，首先，Java
    *本身*必须是操作系统上“当前正在执行的进程”。但是一旦Java获得执行的机会，JVM *运行*什么？哪些字节码执行？无论当前运行堆栈的顶部是什么！在100毫秒内，当前执行的代码可能会切换到*不同*的方法，位于*不同*的堆栈上。
- en: One of the things a thread must do is keep track of which statement (of which
    method) is currently executing on the thread’s stack.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 一个线程必须做的事情之一是跟踪当前在线程堆栈上执行的语句（属于哪个方法）。
- en: 'It might look something like this:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能看起来像这样：
- en: '![image](Images/f0611-01.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0611-01.png)'
- en: To create a new call stack you need a job to run
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要创建一个新的调用堆栈，你需要一个要运行的任务
- en: '![image](Images/f0612-01.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0612-01.png)'
- en: Note
  id: totrans-192
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**Runnable is to a thread what a job is to a worker. A Runnable is the job
    a thread is supposed to run.**'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**`Runnable` 对于线程来说就像工人的工作一样。`Runnable` 是线程应该运行的工作。**'
- en: '**A Runna ble holds t he method t hat goes on the bottom of the new call stack:
    run().**'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**一个 `Runnable` 持有的方法是放在新调用栈底部的方法：`run()`。**'
- en: 'To start a new call stack the thread needs a job—a job the thread will run
    when it’s started. That job is actually the first method that goes on the new
    thread’s stack, and it must always be a method that looks like this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动一个新的调用栈，线程需要一个工作——线程启动时要运行的工作。这个工作实际上是新线程栈中的第一个方法，它必须始终是一个看起来像这样的方法：
- en: '[PRE4]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How does the thread know which method to put at the bottom of the stack? Because
    Runnable defines a contract. Because Runnable is an interface. A thread’s job
    can be defined in any class that implements the Runnable interface, or a lambda
    expression that is the right shape for the run method.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 线程如何知道将方法放在栈的底部？因为 `Runnable` 定义了一个约定。因为 `Runnable` 是一个接口。线程的任务可以在实现 `Runnable`
    接口的任何类中定义，或者是一个符合 `run` 方法形状的 lambda 表达式。
- en: Once you have a Runnable class or lambda expression, you can tell the JVM to
    run this code in a separate thread; you’re giving the thread its job.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了一个 `Runnable` 类或 lambda 表达式，你可以告诉 JVM 在一个单独的线程中运行这段代码；你正在给线程分配它的工作。
- en: Note
  id: totrans-199
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The Runnable interface defines only one method, public void run(). Since it
    has only a single method, it’s a SAM type, a Functional Interface, and you can
    use a lambda instead of creating a whole class that implements Runnable if you
    want.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`Runnable` 接口仅定义了一个方法，`public void run()`。因为它只有一个方法，所以它是一个 SAM 类型，也是一个函数式接口，如果你想要的话，可以使用
    lambda 表达式代替创建实现 `Runnable` 接口的整个类。'
- en: To make a job for your thread, implement the Runnable interface
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要为你的线程创建一个工作，实现 `Runnable` 接口。
- en: '![image](Images/f0613-01.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0613-01.png)'
- en: How NOT to run the Runnable
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何**不**运行 `Runnable`
- en: It may be tempting to create a new instance of the Runnable and call the run
    method, but that’s **not enough to create a new call stack**.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 或许会有诱惑去创建 `Runnable` 的新实例并调用 `run` 方法，但这**不足以创建新的调用栈**。
- en: '[PRE5]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-206
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This will NOT do what we want!
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做**不会**达到我们想要的效果！
- en: '**The run() method was called directly from inside the main() method, so it’s
    part of the call stack of the main thread.**'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**`run()` 方法是直接从 `main()` 方法中调用的，因此它是主线程调用栈的一部分。**'
- en: '![image](Images/f0613-02.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0613-02.png)'
- en: How we used to launch a new thread
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们过去如何启动新线程
- en: The simplest way to launch a new thread is with the Thread class that we mentioned
    earlier. This method has been around in Java since the very beginning, but **it
    is no longer the recommended approach to use**. We’re showing it here because
    a) it’s simple, and b) you’ll see it in the Real World. We will talk later about
    why it might not be the best approach.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 启动一个新线程的最简单方法是使用我们之前提到的 `Thread` 类。这个方法从 Java 的最开始就存在了，但**不再建议使用**。我们在这里展示它是因为：a）它很简单，b）你会在现实世界中看到它。稍后我们会讨论为什么它可能不是最佳的方法。
- en: '![image](Images/f0614-01.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0614-01.png)'
- en: 'A better alternative: don’t manage the Threads at all'
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更好的替代方案：根本不管理线程
- en: Creating and starting a new Thread gives you a lot of control over that Thread,
    but the downside is you *have* to control it. You have to keep track of all the
    Threads and make sure they’re shut down at the end. Wouldn’t it be better to have
    something else that starts, stops, and even reuses the Threads so you don’t have
    to?
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 创建和启动新线程能够让你对那个线程有很多控制，但缺点是你*必须*对它进行控制。你必须追踪所有线程，并确保它们在结束时关闭。有没有更好的方法来启动、停止甚至重用线程，以至于你不必再控制它们呢？
- en: Allow us to introduce an interface in java.util.concurrent, **`ExecutorService`**.
    Implementations of this interface will *execute* jobs (Runnables). Behind the
    scenes the ExecutorService will create, reuse, and kill threads in order to run
    these jobs.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来介绍一个在 `java.util.concurrent` 中的接口，**`ExecutorService`**。这个接口的实现将*执行*工作（`Runnable`）。在幕后，`ExecutorService`
    将创建、重用和终止线程来运行这些工作。
- en: Note
  id: totrans-216
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Static factory methods can be used instead of constructors.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 静态工厂方法可以代替构造函数。
- en: Factory methods return exactly the implementation of an interface that we need.
    We don’t need to know the concrete classes or how to create them.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂方法返回我们需要的接口的确切实现。我们不需要知道具体的类或如何创建它们。
- en: The **`java.util.concurrent.Executors`** class has *factory methods* to create
    the ExecutorService instances we’ll need.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**`java.util.concurrent.Executors`** 类有*工厂方法*来创建我们需要的 `ExecutorService` 实例。'
- en: Executors have been around since Java 5 and so should be available to you even
    if you’re working with quite an old version of Java. There’s no real need to use
    Thread directly at all these days.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 自从Java 5以来，执行器一直存在，因此即使您使用的是相当旧的Java版本，也应该可以使用。如今基本上不需要直接使用Thread。
- en: Running one job
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行一个任务
- en: For the simple cases we’re going to get started with, we’ll want to run only
    one job in addition to our main class. There’s a *single thread executor* that
    we can use to do this.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们即将开始的简单案例，我们将只想运行一个任务以及我们的主类。这里有一个*单线程执行器*可以用来实现这一点。
- en: '![image](Images/f0615-01.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0615-01.png)'
- en: The three states of a new thread
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新线程的三种状态
- en: Whether you create a new Thread and pass it the Runnable, or use an Executor
    to execute the Runnable, the job will still be running on a Thread. A Thread will
    move through a number of different states during its life, and understanding these
    states, and the transitions between them, helps us to better understand multithreaded
    programming.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您是创建一个新的Thread并传递给它一个Runnable，还是使用执行器执行该Runnable，作业仍将在一个Thread上运行。线程在其生命周期中将会经历许多不同的状态，了解这些状态及其之间的转换有助于我们更好地理解多线程编程。
- en: '![image](Images/f0616-01.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0616-01.png)'
- en: '**But there’s more. Once the thread becomes runnable, it can move back and
    forth between runnable, running, and an additional state: *temporarily not runnable*.**'
  id: totrans-227
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**但这还不是全部。一旦线程变为可运行，它可以在可运行、运行和另一个状态之间来回移动：*暂时不可运行*。**'
- en: '**Typical runnable/running loop**'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**典型的可运行/运行循环**'
- en: Typically, a thread moves back and forth between runnable and running, as the
    JVM thread scheduler selects a thread to run and then kicks it back out so another
    thread gets a chance.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，线程在可运行状态和运行状态之间来回移动，作为JVM线程调度器选择要运行的线程，然后将其剔除以便另一个线程有机会运行。
- en: '![image](Images/f0617-01.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0617-01.png)'
- en: '**A thread can be made temporarily not-runnable**'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**一个线程可以暂时不可运行**'
- en: The thread scheduler can move a running thread into a blocked state, for a variety
    of reasons. For example, the thread might be executing code to read from an input
    stream, but there isn’t any data to read. The scheduler will move the thread out
    of the running state until something becomes available. Or the executing code
    might have told the thread to put itself to sleep (sleep()). Or the thread might
    be waiting because it tried to call a method on an object, and that object was
    “locked.” In that case, the thread can’t continue until the object’s lock is freed
    by the thread that has it.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 线程调度器可以将正在运行的线程移动到阻塞状态，原因有多种。例如，线程可能正在执行读取输入流的代码，但没有可读取的数据。调度器会将线程移出运行状态，直到某些数据可用。或者执行的代码可能已经告诉线程将自己置于休眠状态（sleep()）。或者线程可能正在等待，因为它试图调用对象的方法，而该对象被“锁定”。在这种情况下，线程无法继续，直到持有锁的线程释放它。
- en: All of those conditions (and more) cause a thread to become temporarily not-runnable.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些条件（及更多）都会导致线程暂时不可运行。
- en: '![image](Images/f0617-02.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0617-02.png)'
- en: The thread scheduler
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程调度器
- en: The thread scheduler makes all the decisions about who moves from runnable to
    running, and about when (and under what circumstances) a thread leaves the running
    state. The scheduler decides who runs, for how long, and where the threads go
    when it decides to kick them out of the currently running state.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 线程调度器决定了谁从可运行状态转为运行状态，以及在何时（以及在什么情况下）线程离开运行状态。调度器决定谁运行、运行多久，以及当它决定将它们从当前运行状态中剔除时线程去哪里。
- en: '![image](Images/f0618-01.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0618-01.png)'
- en: You can’t control the scheduler. There is no API for calling methods on the
    scheduler. Most importantly, there are no guarantees about scheduling! (There
    are a few *almost*-guarantees, but even those are a little fuzzy.)
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 您无法控制调度器。没有API可以调用调度器上的方法。最重要的是，调度安排没有任何保证！（虽然有一些*几乎*保证，但即使这些也有些模糊。）
- en: 'The bottom line is this: ***do not base your program’s correctness on the scheduler
    working in a particular way!*** The scheduler implementations are different for
    different JVMs, and even running the same program on the same machine can give
    you different results. One of the worst mistakes new Java programmers make is
    to test their multithreaded program on a single machine, and assume the thread
    scheduler will always work that way, regardless of where the program runs.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于：***不要将程序的正确性建立在调度程序以特定方式工作上！*** 不同的JVM具有不同的调度程序实现，即使在同一台机器上运行相同的程序也可能得到不同的结果。新手Java程序员常犯的最严重的错误之一是在单台机器上测试他们的多线程程序，并假设线程调度程序无论程序在何处运行时都会始终工作。
- en: So what does this mean for write-once-run-anywhere? It means that to write platform-independent
    Java code, your multithreaded program must work no matter *how* the thread scheduler
    behaves. That means you can’t be dependent on, for example, the scheduler making
    sure all the threads take nice, perfectly fair, and equal turns at the running
    state. Although highly unlikely today, your program might end up running on a
    JVM with a scheduler that says, “OK, thread five, you’re up, and as far as I’m
    concerned, you can stay here until you’re done, when your run() method completes.”
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这对于“编写一次，随处运行”意味着什么？这意味着为了编写独立于平台的Java代码，您的多线程程序必须无论*线程调度程序*如何工作都能正常工作。这意味着您不能依赖于例如调度程序确保所有线程在运行状态下都能良好、完全公平和平等地轮流运行。虽然今天这种情况可能性极小，但您的程序可能最终在具有说：“好的，线程五，轮到你了，只要你完成run()方法，你可以一直留在这里”的调度程序的JVM上运行。
- en: Note
  id: totrans-241
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**The thread scheduler makes all the decisions about who runs and who doesn’t.
    It usually makes the threads take turns, nicely. But there’s no guarantee about
    that. It might let one thread run to its heart’s content while the other threads
    “starve.”**'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**线程调度程序决定谁运行和谁不运行。它通常让线程轮流运行，很好地。但这并不能保证。它可能让一个线程尽情运行，而其他线程“挨饿”。**'
- en: '**An example of how unpredictable the scheduler can be...**'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '**线程调度程序的不可预测性的一个例子...**'
- en: '![image](Images/f0619-01.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0619-01.png)'
- en: How did we end up with different results?
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们是如何得到不同的结果的？
- en: Multithreaded programs are *not deterministic*; they don’t run the same way
    every time. The thread scheduler can schedule each thread differently each time
    the program runs.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程程序*不是确定性的*；它们每次运行时都不会以相同的方式运行。线程调度程序可以每次以不同的方式调度每个线程。
- en: '**Sometimes it runs like this:**'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**有时它会像这样运行：**'
- en: '![image](Images/f0620-01.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0620-01.png)'
- en: '**And sometimes it runs like this:**'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**有时它会像这样运行：**'
- en: '![image](Images/f0620-02.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0620-02.png)'
- en: Note
  id: totrans-251
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**Even if the new thread is tiny, if it has only one line of code to run like
    our lambda expression, it can still be interrupted by the thread scheduler.**'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '**即使新线程很小，如果它只有一行代码要运行，就像我们的lambda表达式一样，它仍然可能会被线程调度程序中断。**'
- en: Putting a thread to sleep
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使线程进入睡眠
- en: '![image](Images/f0622-01.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0622-01.png)'
- en: One way to help your threads take turns is to put them to sleep periodically.
    All you need to do is call the static sleep() method, passing it the amount of
    time you want the thread to sleep for, in milliseconds.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 帮助您的线程轮流运行的一种方法是定期让它们进入睡眠状态。您只需调用静态的sleep()方法，将要使线程进入睡眠状态的时间量以毫秒为单位传递给它即可。
- en: 'For example:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE6]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: will knock a thread out of the running state and keep it out of the runnable
    state for two seconds. The thread *can’t* become the running thread again until
    after at least two seconds have passed.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个线程击倒，使其离开运行状态，并将其保持在不可运行状态至少两秒钟。线程*不能*再次成为运行线程，直到至少两秒钟已经过去。
- en: 'A bit unfortunately, the sleep method throws an InterruptedException, a checked
    exception, so all calls to sleep must be wrapped in a try/catch (or declared).
    So a sleep call really looks like this:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 有点不幸的是，sleep方法会抛出一个InterruptedException，这是一个受检异常，因此所有对sleep的调用都必须包装在try/catch中（或者声明）。因此，sleep调用实际上看起来像这样：
- en: '[PRE7]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now you know that your thread won’t wake up *before* the specified duration,
    but is it possible that it will wake up some time *after* the “timer” has expired?
    Effectively, yes. The thread won’t automatically wake up at the designated time
    and become the currently running thread. When a thread wakes up, the thread is
    once again at the mercy of the thread scheduler; therefore, there are no guarantees
    about how long the thread will be out of action.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道你的线程在指定的持续时间之前不会唤醒，但是它是否可能会在“定时器”到期后一段时间内唤醒？实际上是可以的。线程不会自动在指定的时间唤醒并成为当前运行的线程。当线程唤醒时，线程再次受线程调度器控制；因此，无法保证线程停止活动的时间。
- en: Note
  id: totrans-262
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**Putting a thread to sleep gives the other threads a chance to run.**'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '**让一个线程睡眠给其他线程运行的机会。**'
- en: '**When the thread wakes up, it always goes back to the runnable state and waits
    for the thread scheduler to choose it to run again.**'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**当线程唤醒时，它总是回到可运行状态并等待线程调度器再次选择它来运行。**'
- en: Using sleep to make our program more predictable
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用sleep使我们的程序更可预测
- en: 'Remember our earlier example that kept giving us different results each time
    we ran it? Look back and study the code and the sample output. Sometimes main
    had to wait until the new thread finished (and printed “top o’ the stack”), while
    other times the new thread would be sent back to runnable before it was finished,
    allowing the main thread to come back in and print out “back in main.” How can
    we fix that? Stop for a moment and answer this question: “Where can you put a
    sleep() call, to make sure that “back in main” always prints before “top o’ the
    stack”?'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 记住我们早些时候的例子，每次运行时都给出不同的结果？回头看代码和示例输出。有时主线程必须等到新线程完成（并打印“top o' the stack”），而其他时候新线程在完成之前就会返回可运行状态，允许主线程回来并打印“back
    in main”。我们如何解决这个问题？停下来，回答这个问题：“你可以在哪里放一个sleep()调用，以确保“back in main”总是在“top o'
    the stack”之前打印？”
- en: '![image](Images/f0623-01.png)![image](Images/f0623-02.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0623-01.png)![图片](Images/f0623-02.png)'
- en: There are downsides to forcing the thread to sleep
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强制线程睡眠也有缺点。
- en: '![Images](Images/1.png) **The program has to wait for at least that amount
    of time.**'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/1.png) **程序必须至少等待那么长时间。**'
- en: If we put the thread to sleep for two seconds, the thread will be non-runnable
    for that time. When it wakes up, it won’t automatically become the currently running
    thread. When a thread wakes up, the thread is once again at the mercy of the thread
    scheduler. Our application is going to be hanging around for at least those two
    seconds, probably more. This might not sound like a big deal, but imagine a bigger
    program full of these pauses *intentionally* slowing down the application.
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们让线程睡眠两秒钟，线程将在那段时间内无法运行。当它唤醒时，它不会自动成为当前运行的线程。当线程唤醒时，线程再次受线程调度器控制。我们的应用程序将至少停留这两秒钟，可能更长。这听起来可能不是什么大问题，但想象一下一个充满这些故意减慢应用程序速度的暂停的大型程序。
- en: '![Images](Images/2.png) **How do you know the other job will finish in that
    time?**'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](Images/2.png) **你怎么知道另一个任务会在那个时间内完成？**'
- en: We put the new thread to sleep for two seconds, assuming that the main thread
    would be the running thread, and complete its work in that time. But what if the
    main thread took longer to finish than that? What if another thread, running a
    longer job, was scheduled instead? One of the ways people deal with this is to
    set sleep times that are much longer than they’d expect a job to take, but then
    our first problem becomes even more of a problem.
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们让新线程睡眠两秒钟，假设主线程将成为运行线程，并在那段时间内完成其工作。但是如果主线程花费更长时间来完成呢？如果另一个线程运行了一个更长的任务，而不是它呢？人们处理这个问题的一种方法是设置比预期作业时间长得多的睡眠时间，但这样一来，我们的第一个问题就变得更加严重了。
- en: '![image](Images/f0624-01.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0624-01.png)'
- en: '**A better alternative: wait for the perfect time.**'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**更好的选择：等待最佳时机。**'
- en: What we really wanted in our example was to wait until a specific thing had
    happened in our main thread before carrying on with our new thread. Java supports
    a number of different mechanisms to do this, like Future, CyclicBarrier, Semaphore,
    and CountDownLatch.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们真正想要的是在我们的主线程中等待特定事件发生后才继续我们的新线程。Java支持多种不同的机制来实现这一点，如Future、CyclicBarrier、Semaphore和CountDownLatch。
- en: Note
  id: totrans-276
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**To coordinate events happening on multiple threads, one thread may need to
    wait for a specific signal from another thread before it can continue.**'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '**为了协调在多个线程上发生的事件，一个线程可能需要等待另一个线程发送的特定信号，然后才能继续。**'
- en: Counting down until ready
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 倒数直到准备好
- en: You can make threads *count down* when significant events have happened. A thread
    (or threads) can wait for all these events to complete before continuing. You
    might be counting down until a minimum number of clients have connected, or a
    number of services have been started.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生重要事件时，您可以使线程*倒数*。一个线程（或多个线程）可以等待所有这些事件完成后再继续。您可能正在倒数，直到最少数量的客户端连接，或者一些服务已启动。
- en: This is what `**java.util.concurrent.CountDownLatch**` is for. You set a number
    to count down from. Then any thread can tell the latch to count down when a relevant
    event has happened.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`**java.util.concurrent.CountDownLatch**`的用途。您设置一个要从中倒数的数字。然后任何线程可以在发生相关事件时告诉latch倒数。
- en: In our example, we have only one thing we want to count—our new thread should
    wait until the main thread has printed “back in main” before it can continue.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们只有一件事要计数——我们的新线程应该等到主线程打印“back in main”后才能继续。
- en: Note
  id: totrans-282
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**CountDownLatch is a barrier synchronizer. Barriers are mechanisms to allow
    threads to coordinate with each other.**'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '**CountDownLatch是一个屏障同步器。屏障是允许线程协调的机制。**'
- en: '**Other examples are CyclicBarrier and Phaser.**'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '**其他示例包括CyclicBarrier和Phaser。**'
- en: '![image](Images/f0625-01.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0625-01.png)'
- en: The code is really similar to the code that performs a sleep; the main difference
    is the latch.countDown in the main method. The performance difference is significant,
    though. Instead of having to wait *at least* two seconds to make sure main has
    printed its message, the new thread waits only until the main method has printed
    its “back in main” message.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 代码与执行sleep操作的代码非常相似；主要区别在于主方法中的latch.countDown。尽管性能差异显著。与必须等待*至少*两秒以确保主线程已打印其消息不同，新线程仅等到主方法打印其“back
    in main”消息。
- en: To get an idea of the performance difference this might make on a real system,
    when this latch code was run on a MacBook 100 times, it took around 50 milliseconds
    to finish *all* one hundred runs, and the output was in the correct order *every
    time*. If running the sleep() version just one time takes over 2 seconds (2000
    milliseconds), imagine how long it took to run 100 times*....
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解这可能对实际系统性能的影响，当此latch代码在MacBook上运行100次时，它大约需要50毫秒才能完成*所有*一百次运行，并且输出每次都是正确的顺序。如果仅运行sleep()版本一次需要超过2秒（2000毫秒），想象一下运行100次需要多长时间*....。
- en: Making and starting two threads (or more!)
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建并启动两个线程（或更多！）
- en: What happens if we want to start more than one job in addition to our main thread?
    Clearly, we can’t use Executors.newSingleThreadExecutor() if we want to run more
    than one thread. What else is available?
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要启动多个作业以及我们的主线程，会发生什么？显然，如果我们想运行多个线程，我们不能使用Executors.newSingleThreadExecutor()。还有什么其他选择？
- en: '![image](Images/f0626-01.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0626-01.png)'
- en: Note
  id: totrans-291
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**These ExecutorServices use some form of Thread Pool. This is a collection
    of Thread instances that can be used (and reused) to perform jobs.**'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '**这些ExecutorServices使用某种形式的线程池。这是一组Thread实例，可用于（并且可以重复使用）执行作业。**'
- en: '**How many threads are in the pool, and what to do if there are more jobs to
    run than threads available, depends on the ExecutorService implementation.**'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '**池中有多少线程以及如果要运行的作业多于可用的线程数，取决于ExecutorService的实现。**'
- en: Pooling Threads
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程池
- en: Using a pool of resources, especially ones that are expensive to create like
    Threads or database connections, is a common pattern in application code.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 使用资源池，特别是像线程或数据库连接这样昂贵的资源，在应用程序代码中是一种常见模式。
- en: '![image](Images/f0627-01.png)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0627-01.png)'
- en: When you create a new ExecutorService, its pool may be started with some threads
    to begin with, or the pool may be empty.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新的ExecutorService时，其线程池可以从一开始就启动一些线程，或者线程池可能为空。
- en: You can create an ExecutorService with a thread pool using one of the helper
    methods from the Executors class.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用Executors类的helper方法之一创建带有线程池的ExecutorService。
- en: '[PRE8]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '* * *'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '![image](Images/f0627-02.png)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0627-02.png)'
- en: You can use the pool’s threads to run your job by giving the job to the ExecutorService.
    The ExecutorService can then figure out if there’s a free Thread to run the job.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用池中的线程来运行作业，将作业交给ExecutorService。ExecutorService然后可以找出是否有空闲的线程来运行作业。
- en: '[PRE9]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This means an ExecutorService can **reuse** threads; it doesn’t just create
    and destroy them.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着ExecutorService可以**重复使用**线程；它不仅仅是创建和销毁它们。
- en: '* * *'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '![image](Images/f0627-03.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0627-03.png)'
- en: As you give the ExecutorService more jobs to run, it *may* create and start
    new Threads to handle the jobs. It *may* store the jobs in a queue if there are
    more jobs than Threads.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 当您给ExecutorService更多作业运行时，它*可能*会创建并启动新的线程来处理作业。如果作业数量超过线程数量，它*可能*会将作业存储在队列中。
- en: How an ExecutorService deals with additional jobs depends on how it is set up.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: ExecutorService如何处理额外的作业取决于它的设置方式。
- en: '[PRE10]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The ExecutorService may also **terminate** Threads that have been idle for some
    period of time. This can help to minimize the amount of hardware resources (CPU,
    memory) your application needs.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: ExecutorService也可能会**终止**一些空闲一段时间的线程。这有助于最小化应用程序需要的硬件资源（CPU、内存）数量。
- en: Running multiple threads
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行多个线程
- en: 'The following example runs two jobs, and uses a fixed-sized thread pool to
    create two threads to run the jobs. Each thread has the same job: run in a loop,
    printing the currently running thread’s name with each iteration.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例运行两个作业，并使用固定大小的线程池创建两个线程来运行这些作业。每个线程都有相同的作业：在循环中运行，每次迭代时打印当前运行线程的名称。
- en: '![image](Images/f0628-01.png)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0628-01.png)'
- en: What will happen?
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发生什么了？
- en: Will the threads take turns? Will you see the thread names alternating? How
    often will they switch? With each iteration? After five iterations?
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 线程会轮流进行吗？您会看到线程名称交替吗？它们会多久切换一次？每次迭代后？五次迭代后？
- en: '![image](Images/f0628-02.png)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0628-02.png)'
- en: 'You already know the answer: *we don’t know!* It’s up to the scheduler. And
    on your OS, with your particular JVM, on your CPU, you might get very different
    results.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经知道答案：*我们不知道！* 这取决于调度程序。在您的操作系统、特定的JVM和CPU上，您可能会得到非常不同的结果。
- en: Running this on a modern multicore system, the two jobs will likely run in parallel,
    but there’s no guarantee that this means they will complete in the same amount
    of time or output values at the same rate.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代多核系统上运行此示例，这两个作业可能会并行运行，但不能保证它们将以相同的时间完成或以相同的速率输出值。
- en: Closing time at the thread pool
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程池的关闭时间
- en: You may have noticed that our examples have a `**threadPool.shutdown**()` at
    the end of the main methods. Although the thread pools will take care of our individual
    Threads, we do need to be responsible adults and close the pool when we’re finished
    with it. That way, the pool can empty its job queue and shut down all of its threads
    to free up system resources.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到我们的示例在主方法的末尾有一个`**threadPool.shutdown**()`。虽然线程池会处理我们的各个线程，但我们确实需要成为负责任的成年人，并在完成后关闭线程池。这样，线程池可以清空其作业队列并关闭所有线程以释放系统资源。
- en: 'ExecutorService has two shutdown methods. You can use either, but to be safe
    we’d use both:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: ExecutorService有两种关闭方法。您可以使用任一方法，但为了安全起见，我们建议两者都使用：
- en: '![Images](Images/1.png) **ExecutorService.shutdown()**'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Images](Images/1.png) **ExecutorService.shutdown()**'
- en: Calling shutdown() asks the ExecutorService nicely if it wouldn’t mind awfully
    wrapping things up so everyone can go home.
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 调用shutdown()礼貌地要求ExecutorService整理好一切，这样每个人都可以回家。
- en: All of the Threads that are currently running jobs are allowed to finish those
    jobs, and any jobs waiting in the queue will also be finished off. The ExecutorService
    will reject any new jobs too.
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所有当前运行作业的线程都可以完成这些作业，并且队列中等待的任何作业也将被完成。ExecutorService还将拒绝任何新作业。
- en: If you need your code to wait until all of those things are finished, you can
    use `**awaitTermination**` to sit and wait until it’s finished. You give awaitTermination
    a maximum amount of time to wait for everything to end, so awaitTermination will
    hang around until either the ExecutorService has finished everything or the timeout
    has been reached, whichever is earlier.
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您需要等到所有这些事情都完成，可以使用`**awaitTermination**`来等待直到它完成。您可以给awaitTermination一个最长等待时间，以等待所有事情结束，因此awaitTermination将等待，直到ExecutorService完成所有工作或达到超时时间为止。
- en: '![Images](Images/2.png) **ExecutorService.shutdownNow()**'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Images](Images/2.png) **ExecutorService.shutdownNow()**'
- en: Everybody out! When this is called, the ExecutorService will try to stop any
    Threads that are running, will not run any waiting jobs, and definitely won’t
    let anyone else into the pool.
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 大家都出来！当调用这个方法时，ExecutorService将尝试停止任何正在运行的线程，不会运行任何等待中的作业，绝对不会让任何人进入线程池。
- en: Use this if you need to put a stop to everything. This is sometimes used after
    first calling shutdown() to give the jobs a chance to finish before pulling the
    plug entirely.
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您需要停止所有事情，请使用此功能。这有时在首先调用shutdown()后使用，以便给作业完成的机会，然后再完全切断它们。
- en: '![image](Images/f0629-01.png)![image](Images/f0630-01.png)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0629-01.png)![image](Images/f0630-01.png)'
- en: Um, yes. There IS a dark side. Multithreading can lead to concurrency “issues.”
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嗯，是的。有一个黑暗面。多线程可能导致并发“问题”。
- en: Concurrency issues lead to race conditions. Race conditions lead to data corruption.
    Data corruption leads to fear...you know the rest.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 并发问题导致竞态条件。竞态条件导致数据损坏。数据损坏带来恐惧……你知道剩下的。
- en: 'It all comes down to one potentially deadly scenario: two or more threads have
    access to a single object’s *data*. In other words, methods executing on two different
    stacks are both calling, say, getters or setters on a single object on the heap.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 一切归结为一个潜在的致命场景：两个或更多线程可以访问单个对象的*数据*。换句话说，执行在两个不同堆栈上的方法都在调用同一个堆上单个对象的获取器或设置器。
- en: It’s a whole “left-hand-doesn’t-know-what-the-right-hand-is-doing” thing. Two
    threads, without a care in the world, humming along executing their methods, each
    thread thinking that he is the One True Thread. The only one that matters. After
    all, when a thread is not running, and in runnable (or blocked) it’s essentially
    knocked unconscious. When it becomes the currently running thread again, it doesn’t
    know that it ever stopped.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这完全是一个“左手不知道右手在做什么”的事情。两个线程，毫不在意地轻松地执行它们的方法，每个线程都认为自己是唯一真正的线程。是唯一重要的线程。毕竟，当一个线程不在运行时，并且在可运行（或阻塞）时，它实际上是昏迷的。当它再次成为当前运行的线程时，它不知道它曾经停止过。
- en: Exercise
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: '![image](Images/exercise.png)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/exercise.png)'
- en: Who Am I?
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Who Am I?
- en: (from [“Exercise”](#exercise-id000027))
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: (来自[“练习”](#exercise-id000027))
- en: '![image](Images/eye1.png)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/eye1.png)'
- en: A bunch of Java and network terms, in full costume, are playing a party game,
    “Who am I?” They’ll give you a clue—you try to guess who they are based on what
    they say. Assume they always tell the truth about themselves. If they happen to
    say something that could be true for more than one attendee, then write down all
    for whom that sentence applies. Fill in the blanks next to the sentence with the
    names of one or more attendees.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 一堆 Java 和网络术语，穿着全套服装，正在玩一个派对游戏，“我是谁？”他们会给你一个线索 —— 你尝试根据他们说的来猜测他们是谁。假设他们总是对自己说实话。如果他们碰巧说出对多位参与者都可能成立的话，那么请把这些可能性填写到句子旁边的空白处，附上一个或多个参与者的名字。
- en: '**Tonight’s attendees:**'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '**今晚的参与者：**'
- en: '**InetSocketAddress, SocketChannel, IP address, host name, port, Socket, ServerSocketChannel,
    Thread, thread pool, Executors, ExecutorService, CountDownLatch, Runnable, InterruptedException,
    Thread.sleep()**'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '**InetSocketAddress、SocketChannel、IP 地址、主机名、端口、Socket、ServerSocketChannel、Thread、线程池、Executors、ExecutorService、CountDownLatch、Runnable、InterruptedException、Thread.sleep()**'
- en: '| **I need to be shut down or I might live forever** | ______________________________________________
    |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| **我需要被关闭，否则我可能会永远存在** | ______________________________________________ |'
- en: '| **I let you talk to a remote machine** | ______________________________________________
    |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| **我让你可以与远程机器通信** | ______________________________________________ |'
- en: '| **I might be thrown by sleep() and await()** | ______________________________________________
    |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| **我可能会被 sleep() 和 await() 所抛出** | ______________________________________________
    |'
- en: '| **If you want to reuse Threads, you should use me** | ______________________________________________
    |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| **如果你想重用线程，你应该使用我** | ______________________________________________ |'
- en: '| **You need to know me if you want to connect to another machine** | ______________________________________________
    |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| **如果你想连接到另一台机器，你需要知道我** | ______________________________________________
    |'
- en: '| **I’m like a separate process running on the machine** | ______________________________________________
    |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| **我就像在机器上运行的一个独立进程** | ______________________________________________ |'
- en: '| **I can give you the ExecutorService you need** | ______________________________________________
    |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| **我可以给你所需的 ExecutorService** | ______________________________________________
    |'
- en: '| **You need one of me if you want clients to connect to me** | ______________________________________________
    |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| **如果你想让客户端连接到我，你需要我之一** | ______________________________________________
    |'
- en: '| **I can help you make your multithreaded code more predictable** | ______________________________________________
    |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| **我可以帮助您使您的多线程代码更可预测** | ______________________________________________ |'
- en: '| **I represent a job to run** | ______________________________________________
    |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| **我代表一个要运行的作业** | ______________________________________________ |'
- en: '| **I store the IP address and port of the server** | ______________________________________________
    |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| **我存储服务器的 IP 地址和端口** | ______________________________________________ |'
- en: '![Images](Images/arr.png) **Answers in [“Who Am I?”](#who_am_iquestion_mark_left_par).**'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '![Images](Images/arr.png) **答案在 [“我是谁？”](#who_am_iquestion_mark_left_par)。**'
- en: New and improved SimpleChatClient
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新的改进版 SimpleChatClient
- en: 'Way back near the beginning of the chapter, we built the SimpleChatClient that
    could *send* outgoing messages to the server but couldn’t receive anything. Remember?
    That’s how we got onto this whole thread topic in the first place, because we
    needed a way to do two things at once: send messages *to* the server (interacting
    with the GUI) while simultaneously reading incoming messages *from* the server,
    displaying them in the scrolling text area.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开始，我们建立了SimpleChatClient，它可以向服务器发送出站消息，但不能接收任何消息。记得吗？这就是我们首次讨论线程主题的原因，因为我们需要一种方法同时执行两个任务：与GUI交互发送消息到服务器，并同时读取服务器的传入消息，将其显示在滚动文本区域中。
- en: This is the New Improved chat client that can both send and receive messages,
    thanks to the power of multithreading! Remember, you need to run the chat server
    first to run this code.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这是新改进的聊天客户端，可以发送和接收消息，多亏了多线程的强大支持！请记住，你需要先运行聊天服务器才能运行此代码。
- en: '![image](Images/f0632-01.png)![image](Images/f0633-01.png)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0632-01.png)![image](Images/f0633-01.png)'
- en: Exercise
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: '![image](Images/exercise.png)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/exercise.png)'
- en: Code Magnets
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码磁铁
- en: '![image](Images/common-1.png)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/common-1.png)'
- en: A working Java program is scrambled up on the fridge (see the next page). Can
    you reconstruct the code snippets on the next page to make a working Java program
    that produces the output listed below?
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 一个工作的Java程序在冰箱上被打乱了（见下一页）。你能否重组下一页的代码片段，使其成为一个能够产生下面输出的工作Java程序？
- en: To get it to work, you will need to be running the `**SimpleChatServer**` from
    [“The really, really simple Chat Server”](#the_reallycomma_really_simple_chat_serve).
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 要使其正常工作，你需要先运行来自[“真的，真的简单的聊天服务器”](#the_reallycomma_really_simple_chat_serve)的`**SimpleChatServer**`。
- en: '![image](Images/f0634-02.png)![image](Images/f0634-01.png)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0634-02.png)![image](Images/f0634-01.png)'
- en: '![Images](Images/arr.png) **Answers in [“Code Magnets”](#code_magnets_left_parenthesisfrom_p-idd).**'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '![Images](Images/arr.png) **答案在[“代码磁铁”](#code_magnets_left_parenthesisfrom_p-idd)中。**'
- en: '![image](Images/f0635-01.png)'
  id: totrans-366
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0635-01.png)'
- en: Exercise Solutions
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习解答
- en: '![image](Images/exercise.png)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/exercise.png)'
- en: Who Am I?
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我是谁？
- en: '| I need to be shut down or I might live forever | *ExecutorService* |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| 如果不关闭我，我可能会永远存在 | *ExecutorService* |'
- en: '| I let you talk to a remote machine | *SocketChannel, Socket* |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '| 我让你与远程机器通信 | *SocketChannel, Socket* |'
- en: '| I might be thrown by sleep() and await() | *InterruptedException* |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| sleep() 和 await() 可能会抛出我 | *InterruptedException* |'
- en: '| If you want to reuse Threads, you should use me | *Thread pool, ExecutorService*
    |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '| 如果你想重复使用线程，你应该使用我 | *线程池，ExecutorService* |'
- en: '| You need to know me if you want to connect to another machine | *IP Address,
    Host name, port* |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| 如果你想连接到另一台机器，你需要知道我 | *IP地址，主机名，端口* |'
- en: '| I’m like a separate process running on the machine | *Thread* |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| 我就像是在机器上运行的一个单独进程 | *线程* |'
- en: '| I can give you the ExecutorService you need | *Executors* |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '| 我可以给你所需的ExecutorService | *Executors* |'
- en: '| You need one of me if you want clients to connect to me | *ServerSocketChannel*
    |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '| 如果你想让客户端连接到我，你需要一个我 | *ServerSocketChannel* |'
- en: '| I can help you make your multithreaded code more predictable | *Thread.sleep(),
    CountDownLatch* |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '| 我可以帮助你使多线程代码更可预测 | *Thread.sleep()，CountDownLatch* |'
- en: '| I represent a job to run | *Runnable* |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '| 我代表一个要运行的作业 | *Runnable* |'
- en: '| I store the IP address and port of the server | *InetSocketAddress* |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '| 我存储服务器的IP地址和端口 | *InetSocketAddress* |'
- en: Code Magnets
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码磁铁
- en: (from [“Code Magnets”](#code_magnets-id000007))
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: (来源于[“代码磁铁”](#code_magnets-id000007))
- en: '![image](Images/f0636-01.png)'
  id: totrans-383
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0636-01.png)'
- en: Code Kitchen
  id: totrans-384
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码厨房
- en: '![image](Images/f0637-01.png)'
  id: totrans-385
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0637-01.png)'
- en: '**Now you’ve seen how to build a chat client, we have the last version of the
    BeatBox!**'
  id: totrans-386
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**现在你已经看到如何构建聊天客户端，我们有BeatBox的最终版本！**'
- en: '**It connects to a simple MusicServer so that you can send and receive beat
    patterns with other clients.**'
  id: totrans-387
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**它连接到一个简单的MusicServer，使你能够与其他客户端发送和接收节奏模式。**'
- en: '**The code is really long, so the complete listing is actually in [Appendix A](app01.xhtml#appendix_a_final_code_kitchen).**'
  id: totrans-388
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**代码非常长，所以完整列表实际上在[附录 A](app01.xhtml#appendix_a_final_code_kitchen)中。**'
