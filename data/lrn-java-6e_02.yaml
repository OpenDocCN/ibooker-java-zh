- en: Chapter 2\. A First Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章。第一个应用程序
- en: Before diving into our full discussion of the Java language, let’s get our feet
    wet with some working code and splash around a bit. In this chapter, we’ll build
    a friendly little application that illustrates many of the concepts used throughout
    the book. We’ll take this opportunity to introduce general features of the Java
    language and applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入讨论 Java 语言之前，让我们先通过一些工作代码来熟悉一下。在本章中，我们将构建一个友好的小应用程序，展示本书中使用的许多概念。我们将利用这个机会介绍
    Java 语言和应用程序的一般特性。
- en: This chapter also serves as a brief introduction to the object-oriented and
    multithreaded aspects of Java. If these concepts are new to you, we hope that
    encountering them here in Java for the first time will be a straightforward and
    pleasant experience. If you have worked with another object-oriented or multithreaded
    programming environment, you should especially appreciate Java’s simplicity and
    elegance. This chapter is intended only to give you a bird’s eye view of the Java
    language and a feel for how it is used. If you have trouble with any of the concepts
    introduced here, rest assured they will be covered in greater detail later in
    the book.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章还作为 Java 面向对象和多线程方面的简要介绍。如果这些概念对你来说是新的，我们希望在这里首次接触 Java 时能够有一个简单而愉快的体验。如果你已经在其他面向对象或多线程编程环境中工作过，你应该会特别欣赏
    Java 的简洁和优雅。本章仅旨在为你提供 Java 语言的概览和它的使用感受。如果你在这里介绍的任何概念上有困难，可以放心，它们将在本书的后面更详细地介绍。
- en: 'We can’t stress enough the importance of experimentation as you learn new concepts
    here and throughout the book. Don’t just read the examples—run them. Where we
    can, we’ll show you how to use *jshell* (more on that in [“Trying Java”](ch03.html#learnjava6-CHP-3-SECT-6))
    to try things in real time. The source code for the examples in this book can
    be found on [GitHub](https://github.com/l0y/learnjava6e). Compile the programs
    and try them. Then, turn our examples into your examples: play with them, change
    their behavior, break them, fix them, and hopefully have some fun along the way.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法过分强调在学习新概念时进行实验的重要性，无论是在这里还是在整本书中。不要只是阅读示例——运行它们。在可以的情况下，我们将向你展示如何使用 *jshell*（详见[“尝试
    Java”](ch03.html#learnjava6-CHP-3-SECT-6)）实时尝试。本书示例的源代码可以在 [GitHub](https://github.com/l0y/learnjava6e)
    找到。编译这些程序并尝试运行它们。然后，将我们的示例变成你的示例：玩弄它们，改变它们的行为，打破它们，修复它们，并希望在此过程中享受一些乐趣。
- en: Java Tools and Environment
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 工具和环境
- en: Although it’s possible to write, compile, and run Java applications with nothing
    more than Oracle’s open source Java Development Kit (OpenJDK) and a simple text
    editor (such as vi or Notepad), today the vast majority of Java code is written
    with the benefit of an Integrated Development Environment (IDE). The benefits
    of using an IDE include an all-in-one view of Java source code with syntax highlighting,
    navigation help, source control, integrated documentation, building, refactoring,
    and deployment all at your fingertips. Therefore, we are going to skip an academic
    command-line treatment and start with a popular, free IDE—IntelliJ IDEA CE (Community
    Edition). If you are adverse to using an IDE, feel free to use the command-line
    commands **`javac HelloJava.java`** for compilation and **`java HelloJava`** to
    run the upcoming examples.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然只需使用 Oracle 的开源 Java 开发工具包（OpenJDK）和一个简单的文本编辑器（如 vi 或 Notepad）就可以编写、编译和运行
    Java 应用程序，但今天绝大多数 Java 代码都是使用集成开发环境（IDE）编写的。使用 IDE 的好处包括将 Java 源代码的一切功能集中到一个视图中，具有语法高亮显示、导航帮助、源代码控制、集成文档、构建、重构和部署等功能。因此，我们将跳过学术性的命令行处理，从一个流行的免费
    IDE — IntelliJ IDEA CE（社区版）开始。如果你不喜欢使用 IDE，可以使用命令行命令 **`javac HelloJava.java`**
    进行编译，**`java HelloJava`** 运行即将出现的示例。
- en: IntelliJ IDEA requires Java to be installed. This book covers Java 21 language
    features, so although the examples in this chapter will work with older versions,
    it’s best to have JDK 21 installed to ensure that all examples in the book compile.
    (Java 19 does have all of the most important features available as well, although
    many are technically in “preview” mode.) The JDK includes several developer tools
    that we’ll discuss in [Chapter 3](ch03.html#learnjava6-CHP-3). You can check to
    see which version, if any, you have installed by typing **`java -version`** at
    the command line. If Java isn’t present, or if it’s a version older than JDK 19,
    you will want to install a newer version, as discussed in [“Installing the JDK”](#learnjava6-CHP-2-SECT-1.1).
    All you’ll need for the examples in this book is the basic JDK.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: IntelliJ IDEA需要安装Java。本书涵盖Java 21语言功能，因此尽管本章的示例可以与旧版本一起使用，但最好安装JDK 21以确保本书中的所有示例都能编译通过。（Java
    19也有所有最重要的功能可用，尽管其中许多技术上处于“预览”模式。）JDK包含几个开发工具，我们将在[第3章](ch03.html#learnjava6-CHP-3)中讨论这些工具。你可以通过在命令行中输入**`java
    -version`**来检查已安装的版本。如果没有安装Java，或者版本旧于JDK 19，你应该安装一个更新的版本，如在[“安装JDK”](#learnjava6-CHP-2-SECT-1.1)中讨论的那样。本书示例所需的仅仅是基本的JDK。
- en: Installing the JDK
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装JDK
- en: It should be said at the outset that you are free to download and use the official,
    commercial [JDK from Oracle](https://oreil.ly/sYaZm) for personal use. The versions
    available on Oracle’s download page include the latest version and the most recent
    long-term support version (both are version 21 at the time of this writing), with
    links to older versions if legacy compatibility is something you must manage.
    Both Java 8 and Java 11, for example, remain workhorses on the backends of large
    organizations.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 需要在开头声明的是，你可以自由下载和使用Oracle的官方商业[JDK](https://oreil.ly/sYaZm)用于个人使用。Oracle下载页面提供了最新版本和最新的长期支持版本（目前版本都是21），并附有旧版本的链接，以便管理遗留兼容性。例如，Java
    8和Java 11仍然是许多大型组织后端的重要版本。
- en: If you plan to use Java in any commercial or shared capacity, however, the Oracle
    JDK now comes with strict (and paid) licensing terms. For this and other more
    philosophical reasons, we primarily use the OpenJDK mentioned previously in [“Growing
    Up”](ch01.html#learnjava6-CHP-1-SECT-1.2). Regrettably, this open source version
    does not include installers for all the different platforms. Being open source,
    however, means other groups are welcome to step in and provide any missing pieces,
    and several OpenJDK installer-based packages do exist. Amazon has consistently
    released timely installers under the [Corretto](https://oreil.ly/W7noE) moniker.
    We’ll go through Corretto’s basic installation steps on Windows, Mac, and Linux
    in this chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果计划在任何商业或共享环境中使用Java，Oracle JDK现在带有严格的（并且付费的）许可条款。因此，基于此等理由，我们主要使用之前提到的OpenJDK，如在[“成长”](ch01.html#learnjava6-CHP-1-SECT-1.2)中所述。不幸的是，这个开源版本并不包括所有不同平台的安装程序。但由于是开源的，其他团体可以介入并提供任何缺失的部分，事实上已经有几个基于OpenJDK的安装程序包存在。亚马逊一直以[Corretto](https://oreil.ly/W7noE)名义发布及时的安装程序。我们将在本章中介绍Corretto在Windows、Mac和Linux上的基本安装步骤。
- en: For those who want the latest release and don’t mind a little configuration
    work, you should take a look at installing the OpenJDK. While not as simple as
    using typical native installers, installing the OpenJDK on your chosen operating
    system is usually just a matter of uncompressing the downloaded file into a folder
    and making sure a few environment variables (`JAVA_HOME` and `PATH`) are correctly
    set. Regardless of which operating system you use, if you are going to use the
    OpenJDK, you’ll head to [Oracle’s OpenJDK download page](http://jdk.java.net).
    There they list the current releases as well as any early access versions that
    are available.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些希望使用最新版本且不介意进行一些配置工作的用户，可以考虑安装OpenJDK。虽然不像使用典型的本地安装程序那样简单，但在你选择的操作系统上安装OpenJDK通常只需解压下载的文件到一个文件夹，并确保几个环境变量（`JAVA_HOME`和`PATH`）设置正确。无论你使用哪种操作系统，如果要使用OpenJDK，你需要前往[Oracle的OpenJDK下载页面](http://jdk.java.net)。在那里，他们列出了当前的版本以及任何可用的早期访问版本。
- en: Installing Corretto on Linux
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Linux上安装Corretto
- en: For the popular Debain and Red Hat distros, you can download the appropriate
    file (*.deb* or *.rpm*, respectively) and use your usual package manager to install
    the JDK. The file for generic Linux systems is a compressed tar file (*tar.gz*)
    that can be unpacked in any shared directory of your choice. We’ll go through
    the steps to unpack and configure this compressed `tar` file since it works on
    most Linux distros. These steps use version 17 of Java, but they apply to all
    of the current and LTS Corretto downloads.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于流行的 Debian 和 Red Hat 发行版，你可以下载相应的文件（*.deb* 或 *.rpm*），然后使用你通常的包管理器安装 JDK。用于通用
    Linux 系统的文件是一个可以在你选择的任何共享目录中解压的压缩 tar 文件（*tar.gz*）。我们将介绍解压和配置这个压缩的`tar`文件的步骤，因为它适用于大多数
    Linux 发行版。这些步骤使用 Java 的 17 版本，但适用于所有当前和 LTS 版本的 Corretto 下载。
- en: 'Decide where you want to install the JDK. We’ll store ours in */usr/lib/jvm*,
    but other distros might use other locations, such as */opt*, */usr/share*, or
    */usr/local*. If you will be the only one using Java on your system, you can even
    unpack the file under your home directory. Using your favorite terminal app, change
    to the directory where you downloaded the file and run the following commands
    to install Java:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 决定你想要安装 JDK 的位置。我们将把我们的存储在 */usr/lib/jvm* 中，但其他发行版可能使用其他位置，如 */opt*、*/usr/share*
    或 */usr/local*。如果你是系统上唯一使用 Java 的用户，你甚至可以在你的家目录下解压文件。使用你喜欢的终端应用程序，切换到你下载文件的目录，并运行以下命令来安装
    Java：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can see that the first line of the version information ends with the `LTS`
    initials. This is an easy way to determine if you are using a long-term support
    version. With Java successfully unpacked, you can configure your terminal to use
    this version by setting the `JAVA_HOME` and `PATH` environment variables:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到版本信息的第一行以`LTS`结尾。这是确定你是否使用长期支持版本的简单方法。Java 成功解压后，你可以通过设置`JAVA_HOME`和`PATH`环境变量来配置终端以使用该版本：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can test that this setup is working by checking the version of the Java
    using the `-version` flag, as shown in [Figure 2-1](#learnjava6-CHP-2-FIG-linux-java-version).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `-version` 标志来检查 Java 的版本，如 [图 2-1](#learnjava6-CHP-2-FIG-linux-java-version)
    中所示，以测试这个设置是否工作。
- en: You’ll want to make those `JAVA_HOME` and `PATH` changes permanent by updating
    the startup or rc scripts for your shell. For example, if you use `bash` as your
    shell, you could add both of the `export` lines in [Figure 2-1](#learnjava6-CHP-2-FIG-linux-java-version)
    to your *.bashrc* file.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要通过更新启动或 rc 脚本来使`JAVA_HOME`和`PATH`的更改永久化。例如，如果你使用`bash`作为你的 shell，你可以将 [图 2-1](#learnjava6-CHP-2-FIG-linux-java-version)
    中的两行`export`命令添加到你的 *.bashrc* 文件中。
- en: '![ljv6 0201](assets/ljv6_0201.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0201](assets/ljv6_0201.png)'
- en: Figure 2-1\. Verifying your Java version in Linux
  id: totrans-20
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-1\. 在 Linux 上验证你的 Java 版本
- en: Installing Corretto on macOS
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 macOS 上安装 Corretto
- en: For users on macOS systems, the [Corretto download](https://oreil.ly/W7noE)
    and installation process is straightforward. Select the version of the JDK you
    want to use, then select the *.pkg* link from the subsequent download page. Double-click
    the downloaded file to start the wizard.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 macOS 系统的用户，[Corretto 下载](https://oreil.ly/W7noE) 和安装过程非常简单。选择你想使用的 JDK 版本，然后从随后的下载页面中选择
    *.pkg* 链接。双击下载的文件以启动向导。
- en: The installation wizard shown in [Figure 2-2](#learnjava6-CHP-2-FIG-mac-corretto)
    does not allow much real customization. The JDK will be installed on the disk
    running macOS in its own folder under the */Library/Java/JavaVirtualMachines*
    directory. It will be symbolically linked to */usr/bin/java*. While you can select
    an alternate installation location if you have separate hard disks with macOS,
    the defaults work well for the purposes of this book.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 2-2](#learnjava6-CHP-2-FIG-mac-corretto) 中显示的安装向导并不允许进行太多的实际定制。JDK 将被安装在运行
    macOS 的磁盘上，其文件夹位于 */Library/Java/JavaVirtualMachines* 目录下，并将以符号链接形式链接到 */usr/bin/java*。虽然你可以选择备用的安装位置，例如在具有独立硬盘的
    macOS 上，但默认设置适用于本书的目的。
- en: '![ljv6 0202](assets/ljv6_0202.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0202](assets/ljv6_0202.png)'
- en: Figure 2-2\. Corretto installation wizard in macOS
  id: totrans-25
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-2\. macOS 中的 Corretto 安装向导
- en: After you complete the installation, you can test Java by opening the *Terminal*
    app typically found in the *Utilities* folder under the global *Applications*
    folder. Type **`java -version`** and you should see output similar to [Figure 2-3](#learnjava6-CHP-2-FIG-mac-java-version).
    We installed version 19 on this system, but you should see whatever version you
    downloaded reflected in the output.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，您可以通过打开通常位于全局*应用程序*文件夹下*实用工具*文件夹中的*终端*应用程序来测试Java。键入**`java -version`**，您应该看到类似于[图2-3](#learnjava6-CHP-2-FIG-mac-java-version)的输出。我们在此系统上安装了版本19，但您应该在输出中看到您下载的版本号。
- en: '![ljv6 0203](assets/ljv6_0203.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0203](assets/ljv6_0203.png)'
- en: Figure 2-3\. Verifying your Java version in macOS
  id: totrans-28
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-3\. 在macOS中验证您的Java版本
- en: Installing Corretto on Windows
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Windows上安装Corretto
- en: The Corretto installer for Windows (download the *.msi* file from [Amazon’s
    site](https://oreil.ly/W7noE)) follows typical Windows install wizards, as seen
    in [Figure 2-4](#learnjava6-CHP-2-FIG-corretto-win). You can accept the defaults
    as you go through the short prompts, or tweak things if you are familiar with
    administrative tasks, such as configuring environment variables and registry entries.
    If you are prompted to allow the installer to make changes to your system, go
    ahead and say yes.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Windows上的Corretto安装程序（从[亚马逊的网站](https://oreil.ly/W7noE)下载*.msi*文件）遵循典型的Windows安装向导，如[图2-4](#learnjava6-CHP-2-FIG-corretto-win)所示。您可以按照简短的提示接受默认设置，或者如果熟悉管理任务（如配置环境变量和注册表条目），也可以进行微调。如果提示允许安装程序对系统进行更改，请继续选择是。
- en: '![ljv6 0204](assets/ljv6_0204.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0204](assets/ljv6_0204.png)'
- en: Figure 2-4\. Corretto installation wizard in Windows
  id: totrans-32
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-4\. Windows中的Corretto安装向导
- en: Perhaps you don’t use a command line regularly in Windows, but the *Terminal*
    application in new versions of Windows (or *Command Prompt* application in older
    versions) serves the same purpose as similar apps in macOS or Linux. From your
    Windows menu, you can search for `term` or `cmd`, as shown in [Figure 2-5](#learnjava6-CHP-2-FIG-terminal-win).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 或许您不经常在Windows中使用命令行，但新版本的Windows中的*终端*应用程序（或旧版本中的*命令提示符*应用程序）具有与macOS或Linux中类似应用程序相同的功能。从Windows菜单中，您可以搜索`term`或`cmd`，如[图2-5](#learnjava6-CHP-2-FIG-terminal-win)所示。
- en: '![ljv6 0205](assets/ljv6_0205.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0205](assets/ljv6_0205.png)'
- en: Figure 2-5\. Locating a terminal application in Windows
  id: totrans-35
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-5\. 在Windows中定位终端应用程序
- en: Click the appropriate result to start your terminal, and check for the version
    of Java by typing **`java -version`**. In our example, we were running version
    19; you should see something similar to [Figure 2-6](#learnjava6-CHP-2-FIG-java-version)
    but with your version number.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 单击相应的结果以启动您的终端，并通过键入**`java -version`**来检查Java的版本。在我们的示例中，我们运行的是版本19；您应该看到与[图2-6](#learnjava6-CHP-2-FIG-java-version)类似的输出，但带有您的版本号。
- en: '![ljv6 0206](assets/ljv6_0206.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0206](assets/ljv6_0206.png)'
- en: Figure 2-6\. Checking the Java version in Windows
  id: totrans-38
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-6\. 在Windows中检查Java版本
- en: You can continue using the terminal, of course, but now you are also free to
    point other applications such as IntelliJ IDEA at your installed JDK and simply
    work with those tools. And speaking of IntelliJ IDEA, let’s look at its installation
    steps in more detail.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您可以继续使用终端，但现在您还可以将其他应用程序（如IntelliJ IDEA）指向已安装的JDK，并简单地使用这些工具。说到IntelliJ IDEA，让我们更详细地看一下其安装步骤。
- en: Installing IntelliJ IDEA and Creating a Project
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装IntelliJ IDEA并创建项目
- en: 'IntelliJ IDEA is an IDE available at the [JetBrains website](https://oreil.ly/Lo9Xk).
    For the purposes of this book, and getting started with Java in general, the Community
    Edition is sufficient. The download is an executable installer or compressed archive:
    *.exe* for Windows, *.dmg* for macOS, and *.tar.gz* on Linux. The installers (and
    archives) all follow standard procedures and should feel familiar. If you want
    a little extra guidance, the [installation guide](https://oreil.ly/wjooh) on the
    JetBrains site is a great resource.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: IntelliJ IDEA是一款IDE，可以在[JetBrains的网站](https://oreil.ly/Lo9Xk)上找到。对于本书的目的和一般开始使用Java，Community
    Edition就足够了。下载是一个可执行安装程序或压缩存档：在Windows上是*.exe*，在macOS上是*.dmg*，在Linux上是*.tar.gz*。安装程序（和存档）都遵循标准程序，应该感觉很熟悉。如果您需要一点额外的指导，JetBrains网站上的[安装指南](https://oreil.ly/wjooh)是一个很好的资源。
- en: Let’s create a new project. Select File → New → Project from the application
    menu, and type **`Learning Java`** in the “Name” field at the top of the dialog,
    as shown in [Figure 2-7](#learnjava6-CHP-2-FIG-6). Select a JDK (version 19 or
    later will suffice) and make sure the “Add sample code” checkbox is selected.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新项目。在应用程序菜单中选择 文件 → 新建 → 项目，并在对话框顶部的“名称”字段中输入 **`Learning Java`**，如 [图 2-7](#learnjava6-CHP-2-FIG-6)
    所示。选择一个 JDK（版本 19 或更高版本），确保选中“添加示例代码”复选框。
- en: '![ljv6 0207](assets/ljv6_0207.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0207](assets/ljv6_0207.png)'
- en: Figure 2-7\. New Java project dialog
  id: totrans-44
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-7\. 新建 Java 项目对话框
- en: You may notice the list of generators on the left side of the dialog. The default
    “New Project” is perfect for our needs. But you can start other projects with
    templates for things like Kotlin or Android. The default includes a minimal Java
    class with a `main()` method that can be executed. The coming chapters will go
    into much more detail about the structure of Java programs and the commands and
    statements you can place in those programs. With the default option selected on
    the left, go ahead and click the Create button. (If you notice a prompt to download
    shared indexes, go ahead and say yes. The shared indexes are not critical, but
    they will make IDEA run a little faster.) You should end up with a simple project
    that includes a *Main.java* file, as shown in [Figure 2-8](#learnjava6-CHP-2-FIG-7).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到对话框左侧的生成器列表。默认的“新项目”非常适合我们的需求。但您可以使用 Kotlin 或 Android 等模板启动其他项目。默认包括一个带有可执行
    `main()` 方法的最小 Java 类。接下来的章节将更详细地介绍 Java 程序的结构以及可以放置在这些程序中的命令和语句。在左侧选择默认选项后，点击“创建”按钮。（如果看到下载共享索引的提示，请选择“是”。共享索引并不是必需的，但会让
    IDEA 运行得更快。）您应该会得到一个包含 *Main.java* 文件的简单项目，如 [图 2-8](#learnjava6-CHP-2-FIG-7)
    所示。
- en: '![ljv6 0208](assets/ljv6_0208.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0208](assets/ljv6_0208.png)'
- en: Figure 2-8\. The `Main` class in IDEA
  id: totrans-47
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-8\. IDEA 中的 `Main` 类
- en: Congratulations! You now have a Java program. You’ll run this example and then
    expand on it to give it a little more flair. The coming chapters will present
    more interesting examples piecing together more and more elements of Java. We’ll
    always build these examples in a similar setup, though. These starting steps are
    good ones to get under your belt.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！现在您有一个 Java 程序。您将运行此示例，并在此基础上增加一些特色。接下来的章节将展示更多有趣的示例，逐步组合更多 Java 元素。尽管如此，我们始终会在类似的设置中构建这些示例。这些起步步骤是您的良好开始。
- en: Running the Project
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行项目
- en: Starting from the simple template provided by IDEA should leave you in good
    shape to run your first program. Glance back at [Figure 2-8](#learnjava6-CHP-2-FIG-7).
    Notice the green triangles at lines 1 and 2 along the left side of the code editor,
    next to both the `Main` class as well as the `main()` method. IDEA understands
    that `Main` can be executed. You can click either of those buttons to run your
    code. (The `Main` class listed under the *src* folder in the project outline on
    the left has a tiny green “play” button as well.) You can right-click that class
    entry and select the `Run ‘Main.main()’` option, as shown in [Figure 2-9](#learnjava6-CHP-2-FIG-8).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 从 IDEA 提供的简单模板开始，这样可以让您顺利运行您的第一个程序。回顾 [图 2-8](#learnjava6-CHP-2-FIG-7)。注意代码编辑器左侧第
    1 和第 2 行旁边的绿色三角形，分别位于 `Main` 类和 `main()` 方法旁边。IDEA 理解 `Main` 可以被执行。您可以单击任何这些按钮来运行您的代码。（在左侧项目大纲中的
    *src* 文件夹下列出的 `Main` 类也有一个小绿色“播放”按钮。）您可以右键单击该类条目，并选择 `Run ‘Main.main()’` 选项，如
    [图 2-9](#learnjava6-CHP-2-FIG-8) 所示。
- en: '![ljv6 0209](assets/ljv6_0209.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0209](assets/ljv6_0209.png)'
- en: Figure 2-9\. Running your Java project
  id: totrans-52
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-9\. 运行您的 Java 项目
- en: Whether you use the editor margin buttons or the context menu, go ahead and
    run your code now. You should see your “Hello World!” message show up in the Run
    tab along the bottom of the editor, similar to [Figure 2-10](#learnjava6-CHP-2-FIG-9).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您使用编辑器边栏按钮还是上下文菜单，现在可以运行您的代码了。您应该能在编辑器底部的运行选项卡中看到“Hello World!”消息显示，类似于 [图 2-10](#learnjava6-CHP-2-FIG-9)。
- en: '![ljv6 0210](assets/ljv6_0210.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0210](assets/ljv6_0210.png)'
- en: Figure 2-10\. Our first output from a Java program
  id: totrans-55
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-10\. 我们的第一个 Java 程序输出
- en: IDEs also include a handy terminal option. This allows you to open a tab or
    window that has a command prompt available. You may not need this option very
    often, but it can definitely come in handy. In IDEA, for example, you can open
    the terminal tab from the View → Tool Windows → Terminal menu option or by clicking
    the Terminal shortcut along the bottom of the main window, as shown in [Figure 2-11](#learnjava6-CHP-2-FIG-terminal-IDEA).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: IDE 也包括一个方便的终端选项。这允许你打开一个具有命令提示符的标签或窗口。你可能不经常需要这个选项，但它绝对会派上用场。例如，在 IDEA 中，你可以从
    View → Tool Windows → Terminal 菜单选项中打开终端标签，或者通过点击主窗口底部的 Terminal 快捷方式来打开，如 [Figure 2-11](#learnjava6-CHP-2-FIG-terminal-IDEA)
    所示。
- en: '![ljv6 0211](assets/ljv6_0211.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0211](assets/ljv6_0211.png)'
- en: Figure 2-11\. The Terminal tab in IntelliJ IDEA
  id: totrans-58
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figure 2-11\. IntelliJ IDEA 中的终端标签
- en: In VS Code, you can use the Terminal → New Terminal menu option to pull up a
    similar portion of the IDE, as shown in [Figure 2-12](#learnjava6-CHP-2-FIG-terminal-VS).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在 VS Code 中，你可以使用 Terminal → New Terminal 菜单选项来打开一个类似的 IDE 部分，如 [Figure 2-12](#learnjava6-CHP-2-FIG-terminal-VS)
    所示。
- en: '![ljv6 0212](assets/ljv6_0212.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0212](assets/ljv6_0212.png)'
- en: Figure 2-12\. The Terminal tab in Microsoft’s VS Code
  id: totrans-61
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figure 2-12\. Microsoft 的 VS Code 中的终端标签
- en: Feel free to try out the terminal yourself. With a terminal window open in your
    IDE, navigate to the *Learning Java* folder. (Most IDEs will open the terminal
    at the base directory for your project automatically.) Use the *java* command
    to run our `Main` program, as shown in [Figure 2-13](#learnjava6-CHP-2-FIG-terminal-run).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 随时可以自行尝试终端。在 IDE 中打开终端窗口后，导航至 *Learning Java* 文件夹。（大多数 IDE 会自动在项目的基本目录下打开终端。）使用
    *java* 命令来运行我们的 `Main` 程序，如 [Figure 2-13](#learnjava6-CHP-2-FIG-terminal-run)
    所示。
- en: '![ljv6 0213](assets/ljv6_0213.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0213](assets/ljv6_0213.png)'
- en: Figure 2-13\. Running a Java program in a terminal tab
  id: totrans-64
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figure 2-13\. 在终端标签中运行 Java 程序
- en: Whichever route you chose, congratulations are due again—you have now run your
    first Java program!
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择哪种方式，再次祝贺你！你现在已经成功运行了你的第一个 Java 程序！
- en: Grabbing the Examples
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抓取示例
- en: The code examples and exercise solutions are available online at the book’s
    [GitHub repository](https://github.com/l0y/learnjava6e). GitHub has become the
    de facto cloud repository site for open source projects available to the public,
    as well as private, closed source projects. GitHub has many helpful tools beyond
    simple source-code storage and versioning. If you go on to develop an application
    or library that you want to share with others, it is worth setting up an account
    with GitHub and exploring it deeper. Happily, you can also just grab ZIP files
    of public projects without logging in, as shown in [Figure 2-14](#learnjava6-CHP-2-FIG-10).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 代码示例和练习解决方案可以在线获取，位于本书的 [GitHub 仓库](https://github.com/l0y/learnjava6e)。GitHub
    已成为公共及私有开源项目的事实标准云存储库站点。GitHub 除了简单的源代码存储和版本控制外，还有许多有用的工具。如果你打算开发一个希望与他人共享的应用程序或库，值得在
    GitHub 上设置一个账户并深入探索。幸运的是，你也可以仅仅通过下载公共项目的 ZIP 文件来使用它，如 [Figure 2-14](#learnjava6-CHP-2-FIG-10)
    所示。
- en: '![ljv6 0214](assets/ljv6_0214.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0214](assets/ljv6_0214.png)'
- en: Figure 2-14\. Downloading a ZIP file from GitHub
  id: totrans-69
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figure 2-14\. 从 GitHub 下载 ZIP 文件
- en: You should get a file called *learnjava6e-main.zip* (since you are grabbing
    an archive of the “main” branch of this repository). If you’re familiar with GitHub
    from other projects, please feel free to clone the repository, but the static
    ZIP file contains everything you need to try the examples as you read through
    the rest of this book. When you unzip the download, you’ll find folders for all
    of the chapters that have examples as well as a completed *game* folder that contains
    a fun, lighthearted apple tossing game to help illustrate many of the programming
    concepts presented throughout the book in one cohesive application. We’ll go into
    more details on the examples and the game in coming chapters.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该获得一个名为 *learnjava6e-main.zip* 的文件（因为你正在抓取这个仓库的“main”分支的存档）。如果你熟悉 GitHub 的其他项目，可以随意克隆该仓库，但静态
    ZIP 文件包含了你阅读本书其余部分时尝试示例所需的一切内容。当你解压下载时，你会找到所有包含示例的章节文件夹，以及一个完成的 *game* 文件夹，其中包含一个有趣、轻松的苹果投掷游戏，以帮助在整本书中展示的许多编程概念统一应用。在接下来的章节中，我们将详细介绍示例和游戏。
- en: As mentioned previously, you can compile and run the examples from the ZIP file
    right from the command line. You can also import the code into your favorite IDE.
    [Appendix A](app01.html#learnjava6-APP-A) contains detailed information on how
    to best import these examples into IntelliJ IDEA, but other popular IDEs such
    as Microsoft’s VS Code will also work.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，您可以从ZIP文件中的命令行直接编译和运行示例。您也可以将代码导入到您喜欢的IDE中。[附录 A](app01.html#learnjava6-APP-A)详细介绍了如何将这些示例最佳地导入到IntelliJ
    IDEA中，但其他流行的IDE，如微软的VS Code，也可以工作。
- en: HelloJava
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HelloJava
- en: In the tradition of introductory programming texts, we will begin with Java’s
    equivalent of the archetypal “Hello World” application, `HelloJava`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了遵循介绍性编程文本的传统，我们将从Java的“Hello World”应用程序等效开始，即`HelloJava`。
- en: 'We’ll end up taking a few passes at this example before we’re done (`HelloJava`,
    `HelloJava2`, etc.), adding features and introducing new concepts along the way.
    But let’s start with the minimalist version. Create a new file named *HelloJava.java*
    in your workspace. (If you are using IDEA, you can do this from the menus: File
    → New → Java Class. Then give it the name *HelloJava* with no suffix—the *.java*
    extension will be added to the filename automatically.) Go ahead and fill in the
    same `main()` method from the `Main` demo provided when creating the new project:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成之前，我们会对这个示例进行几次修改（`HelloJava`，`HelloJava2`等），添加功能并介绍新概念。但让我们从最简版本开始。在您的工作空间中创建一个名为*HelloJava.java*的新文件（如果您使用的是IDEA，可以从菜单中操作：文件
    → 新建 → Java类。然后给它一个名字*HelloJava*，不要带后缀，文件名后缀*.java*会自动添加）。接着，填写与创建新项目时提供的`Main`演示相同的`main()`方法即可。
- en: '[PRE2]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This five-line program declares a class called `HelloJava` and that all-important
    `main()` method. It uses a predefined method called `println()` to write some
    text as output. This is a *command-line program*, which means that it runs in
    a terminal or DOS window and prints its output there. This approach is a bit old-school,
    so before we go any further, we’re going to give `HelloJava` a graphical user
    interface (GUI). Don’t worry about the code yet; just follow along with the progression
    here, and we’ll come back for explanations in a moment.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个五行程序声明了一个名为`HelloJava`的类和非常重要的`main()`方法。它使用了一个预定义的方法`println()`来输出一些文本。这是一个*命令行程序*，意味着它在终端或DOS窗口中运行，并在那里打印输出。这种方法有点老派，所以在进一步之前，我们将为`HelloJava`添加一个图形用户界面（GUI）。现在不要担心代码；只需跟着这里的进展走，稍后我们会回来解释。
- en: 'In place of the line containing the `println()` method, we’re going to use
    a `JFrame` object to put a window on the screen. We can start by replacing the
    `println` line with the following three lines:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 替换包含`println()`方法的行，我们将使用一个`JFrame`对象将窗口显示在屏幕上。我们可以用以下三行代码替换`println`行：
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This snippet creates a `JFrame` object with the title “Hello, Java!” `JFrame`
    represents a graphical window. To display it, we simply configure its size on
    the screen using the `setSize()` method and make it visible by calling the `setVisible()`
    method.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一个标题为“Hello, Java!”的`JFrame`对象。`JFrame`代表一个图形窗口。为了显示它，我们简单地通过调用`setSize()`方法配置它在屏幕上的大小，并通过调用`setVisible()`方法使其可见。
- en: 'If we stopped here, we would see an empty window on the screen with our “Hello,
    Java!” banner as its title. But we’d like our message inside the window, not just
    at the top. To put something in the window, we need a couple more lines. The following
    complete example adds a `JLabel` object to display the text centered in our window.
    The additional `import` line at the top is necessary to tell the Java compiler
    where to find the definitions of the `JFrame` and `JLabel` objects that we’re
    using:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们停在这里，我们会在屏幕上看到一个空窗口，窗口的标题是“Hello, Java!”。但我们想要的是把我们的消息放在窗口里，而不只是在顶部。为了把东西放在窗口里，我们需要再加几行代码。以下完整的示例添加了一个`JLabel`对象，在我们的窗口中心显示文本。顶部额外的`import`行是必需的，告诉Java编译器在哪里找到我们使用的`JFrame`和`JLabel`对象的定义：
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, to compile and run this source, either right-click your *HelloJava.java*
    class from the package explorer along the left and use the context menu, or click
    one of the green arrows in the left margin of the editor. See [Figure 2-15](#learnjava6-CHP-2-FIG-11).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要编译和运行这个源代码，可以右键单击你的*HelloJava.java*类，然后使用上下文菜单，或者在编辑器左边的绿色箭头之一上单击。参见[图 2-15](#learnjava6-CHP-2-FIG-11)。
- en: '![ljv6 0215](assets/ljv6_0215.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0215](assets/ljv6_0215.png)'
- en: Figure 2-15\. Running the HelloJava application
  id: totrans-84
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-15\. 运行HelloJava应用程序
- en: You should see the proclamation shown in [Figure 2-16](#learnjava6-CHP-2-FIG-12).
    Congratulations again, you have now run your second Java application! Take a moment
    to bask in the glow of your monitor.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到在[图 2-16](#learnjava6-CHP-2-FIG-12)中显示的声明。再次祝贺，你现在已经运行了你的第二个Java应用程序！花点时间沉浸在你的显示器的光辉中。
- en: '![ljv6 0216](assets/ljv6_0216.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0216](assets/ljv6_0216.png)'
- en: Figure 2-16\. The output of the HelloJava application
  id: totrans-87
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-16\. HelloJava应用程序的输出
- en: Be aware that when you click on the window’s close box, the window goes away,
    but your program is still running. (We’ll fix this shutdown behavior soon.) To
    stop the Java application in IDEA, click the red square “stop” button to the right
    of the green play button we used to run the program. If you are running the example
    on the command line, type Ctrl-C.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当您点击窗口的关闭按钮时，窗口会关闭，但您的程序仍在运行。（我们很快将修复此关闭行为。）要停止IDEA中的Java应用程序，请单击绿色播放按钮右侧的红色方形“停止”按钮。如果您在命令行上运行示例，请键入Ctrl-C。
- en: '`HelloJava` may be a small program, but there is quite a bit going on behind
    the scenes. Those few lines represent the tip of an impressive iceberg. What lies
    under the surface are the layers of functionality provided by the Java language
    and its Swing libraries. Remember that in this chapter, we’re going to cover a
    lot of ground quickly in an effort to show you the big picture. We’ll try to offer
    enough detail for a good understanding of what is happening in each example, but
    we’ll defer detailed explanations until the appropriate chapters. This holds for
    both elements of the Java language and the object-oriented concepts that apply
    to them. With that said, let’s take a look now at what’s going on in our first
    example.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`HelloJava`可能是一个小程序，但背后的工作却不少。这几行代码代表了一个令人印象深刻的冰山尖端。表面下的是Java语言及其Swing库提供的功能层级。请记住，在本章中，我们将快速涵盖大量内容，以便向您展示整体情况。我们将尽量提供足够的细节，以便深入理解每个示例中发生的事情，但将详细说明推迟到适当的章节。这既适用于Java语言的元素，也适用于适用于它们的面向对象概念。说了这么多，现在让我们来看看我们第一个示例中正在发生的事情。'
- en: Classes
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类
- en: 'The first example defines a class named `HelloJava`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例定义了一个名为`HelloJava`的类：
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Classes are the fundamental building blocks of most object-oriented languages.
    A *class* is a group of data items with associated functions that can perform
    operations on that data. The data items in a class are called *variables*, or
    sometimes *fields*; in Java, functions are called *methods*. The primary benefits
    of an object-oriented language are this association between data and functionality
    in class units and the ability of classes to *encapsulate* or hide details, freeing
    the developer from worrying about low-level details. We’ll expand on these benefits
    in [Chapter 5](ch05.html#learnjava6-CHP-5) where we fill out the structure of
    classes.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 类是大多数面向对象语言的基本构建块。*类*是一组具有关联功能的数据项，可以对这些数据执行操作。类中的数据项称为*变量*或有时称为*字段*；在Java中，函数称为*方法*。面向对象语言的主要好处在于类单元中数据和功能的关联以及类能够*封装*或隐藏细节，使开发人员不必担心低级细节。我们将在[第5章](ch05.html#learnjava6-CHP-5)中详细展开这些优点，填充类的结构。
- en: In an application, a class might represent something concrete, such as a button
    on a screen or the information in a spreadsheet, or something more abstract, such
    as a sorting algorithm or perhaps the sense of ennui in a video game character.
    A class representing a spreadsheet might, for example, have variables that represent
    the values of its individual cells and methods that perform operations on those
    cells, such as “clear a row” or “compute values.”
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中，一个类可以表示具体的东西，比如屏幕上的一个按钮或电子表格中的信息，也可以表示更抽象的东西，比如排序算法或视频游戏角色的无聊感。例如，代表电子表格的类可能具有表示其各个单元格值的变量，并且执行对这些单元格的操作的方法，如“清除行”或“计算值”。
- en: 'Our `HelloJava` class is an entire Java application in a single class. It defines
    just one method, `main()` , which holds the body of our program:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`HelloJava`类是一个完整的Java应用程序，全部定义在一个类中。它只定义了一个方法，`main()`，其中包含了我们程序的主体：
- en: '[PRE6]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It is this `main()` method that is called first when the application is started.
    The bit labeled `String [] args` allows us to pass *command-line arguments* to
    the application. We’ll walk through the `main()` method in the next section.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序启动时，首先调用的是`main()`方法。标记为`String [] args`的部分允许我们向应用程序传递*命令行参数*。我们将在下一节中详细讨论`main()`方法。
- en: Finally, although this version of `HelloJava` does not define any variables
    as part of its class, it does use two variables, `frame` and `label`, inside its
    `main()` method. We’ll have more to say about variables soon as well.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，虽然这个版本的 `HelloJava` 没有将任何变量定义为其类的一部分，但它确实在其 `main()` 方法中使用了两个变量，`frame` 和
    `label`。我们以后还会详细介绍变量。
- en: The main() Method
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: main() 方法
- en: As you saw when we ran our example, running a Java application means picking
    a particular class and passing its name as an argument to the Java virtual machine.
    When we did this, the `java` command looked in our `HelloJava` class to see if
    it contained the special method named `main()` with just the right form. It did,
    and the method was executed. If `main()` had not been there, we would have received
    an error message. The `main()` method is the entry point for applications. Every
    standalone Java application includes at least one class with a `main()` method
    that performs the necessary actions to start the rest of the program.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行示例时，可以看到运行 Java 应用程序意味着选择一个特定的类，并将其名称作为参数传递给 Java 虚拟机。当我们这样做时，`java` 命令会查找我们的
    `HelloJava` 类，看它是否包含了具有恰当形式的特殊方法名为 `main()`。它有，这个方法就会被执行。如果 `main()` 方法不存在，我们将收到一个错误消息。`main()`
    方法是应用程序的入口点。每个独立的 Java 应用程序都包含至少一个具有 `main()` 方法的类，该方法执行启动程序其余部分所需的操作。
- en: Our `main()` method sets up a window (a `JFrame`) to hold the visual output
    of the `HelloJava` class. Right now, `main()` is doing all the work in the application.
    But in an object-oriented application, we normally delegate responsibilities to
    many different classes. In the next incarnation of our example, we’re going to
    perform just such a split—creating a second class—and we’ll see that as the example
    subsequently evolves, the `main()` method remains more or less the same, simply
    holding the startup procedure.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `main()` 方法设置了一个窗口（一个 `JFrame`）来容纳 `HelloJava` 类的可视输出。现在，`main()` 在应用程序中承担着所有工作。但在面向对象的应用程序中，我们通常将责任委托给许多不同的类。在我们示例的下一个版本中，我们将执行这样的拆分——创建第二个类——我们将看到随着示例的演变，`main()`
    方法保持不变，仅保持启动过程。
- en: 'Let’s quickly walk through our `main()` method, just so you know what it does.
    First, `main()` creates a `JFrame`, the window that will hold our example:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速浏览一下我们的 `main()` 方法，这样你就知道它的作用。首先，`main()` 创建了一个 `JFrame`，这个窗口将容纳我们的示例：
- en: '[PRE7]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The word `new` in this line of code is very important. `JFrame` is the name
    of a class that represents a window on the screen, but the class itself is just
    a template, like a building plan. The `new` keyword tells Java to allocate memory
    and actually create a particular `JFrame` object. In this case, the argument inside
    the parentheses tells the `JFrame` what to display in its title bar. We could
    have left out the “Hello, Java!” text and used empty parentheses to create a `JFrame`
    with no title, but only because the `JFrame` specifically allows us to do that.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中这一行的 `new` 关键字非常重要。`JFrame` 是一个代表屏幕上窗口的类的名称，但这个类本身只是一个模板，就像一个建筑计划一样。`new`
    关键字告诉 Java 分配内存并实际创建一个特定的 `JFrame` 对象。在这种情况下，括号内的参数告诉 `JFrame` 在其标题栏中显示什么。我们本可以省略“Hello,
    Java!”文本，并使用空括号创建一个没有标题的 `JFrame`，但这仅仅是因为 `JFrame` 明确允许我们这样做。
- en: 'When frame windows are first created, they are very small. Before we show the
    `JFrame`, let’s set its size to something reasonable:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当框架窗口首次创建时，它们非常小。在显示 `JFrame` 之前，让我们将其大小设置为合理的值：
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is an example of invoking a method on a particular object. In this case,
    the `setSize()` method is defined by the `JFrame` class, and it affects the particular
    `JFrame` object we’ve placed in the variable `frame`. Like the frame, we also
    create an instance of `JLabel` to hold our text inside the window:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在特定对象上调用方法的一个例子。在这种情况下，`setSize()` 方法由 `JFrame` 类定义，并影响我们放置在变量 `frame` 中的特定
    `JFrame` 对象。与框架一样，我们还创建了 `JLabel` 的实例来在窗口内部保存我们的文本：
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`JLabel` is much like a physical label. It holds some text at a particular
    position—in this case, on our frame. This is a very object-oriented concept: using
    an object to hold some text, instead of simply invoking a method to “draw” the
    text and moving on. The rationale for this will become clearer later.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`JLabel` 很像一个实际的标签。它在特定位置保存一些文本——在我们的框架上，在这种情况下。这是一个非常面向对象的概念：使用对象来保存一些文本，而不是简单地调用一个方法来“绘制”文本并继续。这背后的原理将在稍后变得更清楚。'
- en: 'Next, we have to place the label into the frame we created:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须将标签放入我们创建的框架中：
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here, we’re calling a method named `add()` to place our label inside the `JFrame`.
    The `JFrame` is a kind of container that can hold things. We’ll talk more about
    that later. `main()`’s final task is to show the frame window and its contents,
    which otherwise would be invisible. An invisible window makes for a pretty boring
    application:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们调用一个名为`add()`的方法，将我们的标签放在`JFrame`内。`JFrame`是一种可以容纳物件的容器。稍后我们会详细讨论这个。`main()`的最后任务是显示窗体窗口及其内容，否则它们将是不可见的。一个看不见的窗口会使应用程序变得非常无聊：
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: That’s the whole `main()` method. As we progress through the examples in this
    chapter, it will remain mostly unchanged as the `HelloJava` class evolves around
    it.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是整个`main()`方法。当我们在本章的示例中继续前进时，它将在其周围进化的`HelloJava`类基本保持不变。
- en: Classes and Objects
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类和对象
- en: A class is a blueprint for a part of an application; it holds methods and variables
    that make up that component. Many individual working copies of a given class can
    exist while an application is active. These individual incarnations are called
    *instances* of the class, or *objects*. Two instances of a given class may contain
    different data, but they always have the same methods.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 类是应用程序部分的蓝图；它包含组成该组件的方法和变量。在应用程序运行时，可以存在许多给定类的个体工作副本。这些个体化的实例被称为该类的*实例*或*对象*。给定类的两个实例可能包含不同的数据，但它们始终具有相同的方法。
- en: As an example, consider a `Button` class. There is only one `Button` class,
    but an application can create many different `Button` objects, each one an instance
    of the same class. Furthermore, two `Button` instances might contain different
    data, perhaps giving each a different appearance and performing a different action.
    In this sense, a class can be considered a mold for making the object it represents,
    something like a cookie cutter stamping out working instances of itself in the
    memory of the computer. As you’ll see later, there’s a bit more to it than that—a
    class can in fact share information among its instances—but this explanation suffices
    for now. [Chapter 5](ch05.html#learnjava6-CHP-5) has the whole story on classes
    and objects.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以`Button`类为例。只有一个`Button`类，但一个应用程序可以创建许多不同的`Button`对象，每个都是同一类的一个实例。此外，两个`Button`实例可能包含不同的数据，也许给每个提供不同的外观和执行不同的操作。在这个意义上，类可以被认为是制造它所代表的对象的模具，就像一个曲奇饼干切割机在计算机的内存中制造它的工作实例一样。正如你后来会看到的，类实际上可以在其实例之间共享信息，但现在这个解释足够了。[第五章](ch05.html#learnjava6-CHP-5)中有关类和对象的完整内容。
- en: The term *object* in Java is very general and is sometimes used almost interchangeably
    with *class*. Objects are the abstract entities that all object-oriented languages
    refer to in one form or another. We will use *object* as a generic term for an
    instance of a class. We might, therefore, refer to an instance of the `Button`
    class as a button, a `Button` object, or, indiscriminately, as an object. You
    will see the term used frequently in the coming chapters, and [Chapter 5](ch05.html#learnjava6-CHP-5)
    will go into much more detail on both classes and objects.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，术语*对象*非常通用，有时几乎可以与*类*互换使用。对象是所有面向对象语言中以某种形式引用的抽象实体。我们将*对象*用作类的实例的通用术语。因此，我们可能会将`Button`类的一个实例称为按钮，一个`Button`对象，或者不加区分地称为对象。在接下来的章节中，你会经常看到这个术语，并且[第五章](ch05.html#learnjava6-CHP-5)会更详细地讨论类和对象。
- en: The `main()` method in the previous example creates a single instance of the
    `JLabel` class and shows it in an instance of the `JFrame` class. You could modify
    `main()` to create many instances of `JLabel`, perhaps each in a separate window.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，`main()`方法创建了`JLabel`类的一个实例，并在`JFrame`类的一个实例中显示它。你可以修改`main()`以创建许多`JLabel`的实例，也许每个在一个单独的窗口中。
- en: Variables and Class Types
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量和类类型
- en: In Java, every class defines a new *type* (data type). You can declare a variable
    of this type and then it can hold instances of that class. A variable could, for
    example, be of type `Button` and hold an instance of the `Button` class, or of
    type `SpreadSheetCell` and hold a `SpreadSheetCell` object, just as it could be
    any of the simpler types, such as `int` or `char`. The fact that variables have
    types and cannot simply hold any kind of object is another important feature of
    Java that ensures the safety and correctness of code.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，每个类都定义了一个新的*类型*（数据类型）。你可以声明这种类型的变量，然后它可以保存该类的实例。例如，变量可以是`Button`类型，并保存`Button`类的实例，或者是`SpreadSheetCell`类型，并保存`SpreadSheetCell`对象，就像它可以是更简单的类型之一，比如`int`或`char`。变量具有类型并且不能简单地保存任何类型的对象，这是Java的另一个重要特性，确保了代码的安全性和正确性。
- en: 'Setting aside the variables used inside the `main()` method for the moment,
    only one other variable is declared in our simple `HelloJava` example. It’s found
    in the declaration of the `main()` method itself:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 暂时不考虑`main()`方法中使用的变量，我们的简单`HelloJava`示例中只声明了另一个变量。它出现在`main()`方法的声明中：
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Just like functions in other languages, a method in Java declares a list of
    *parameters* (variables) that it accepts as *arguments*, and it specifies the
    types of those parameters. In this case, the main `method` is requiring that when
    it is invoked, it be passed an array of `String` objects in the variable named
    `args`. The `String` is the fundamental object representing text in Java. As we
    hinted at earlier, Java uses the `args` parameter to pass any command-line arguments
    supplied to the Java virtual machine into your application. (We don’t use them
    here, but we will later.)
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 就像其他语言中的函数一样，Java中的方法声明一个接受*参数*（变量）的列表作为*参数*，并指定这些参数的类型。在这种情况下，主`method`要求在调用时，传递一个名为`args`的`String`对象数组作为参数。`String`是Java中表示文本的基本对象。正如我们早些时候暗示的那样，Java使用`args`参数将任何提供给Java虚拟机的命令行参数传递到你的应用程序中（我们这里没有使用它们，但稍后会用到）。
- en: Up to this point, we have loosely talked about variables as holding objects.
    In reality, variables that have class types don’t hold objects—they refer to them.
    A *reference* is a pointer to or a handle for an object. If you declare a class-type
    variable without assigning it an object, it doesn’t point to anything. It’s assigned
    the default value of `null`, meaning “no value.” If you try to use a variable
    with a null value as if it were pointing to a real object, a runtime error, `NullPointerException`,
    occurs.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们宽泛地讨论变量保存对象的问题。实际上，具有类类型的变量不会保存对象——它们只是引用对象。*引用*是指向对象的指针或句柄。如果你声明一个类类型的变量但没有为其分配对象，它将被赋予默认值`null`，表示“无值”。如果你尝试像操作指向真实对象一样使用具有`null`值的变量，将会发生运行时错误，即`NullPointerException`。
- en: Of course, object references have to come from somewhere. In our example, we
    created two objects using the `new` operator. We’ll examine object creation in
    more detail a little later in the chapter.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，对象引用必须来自某处。在我们的例子中，我们使用`new`运算符创建了两个对象。稍后在本章节，我们会更详细地讨论对象的创建。
- en: HelloComponent
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HelloComponent
- en: Thus far, our `HelloJava` example has contained itself in a single class. In
    fact, because of its simple nature, it has really just served as a single, large
    method. Although we have used a couple of objects to display our GUI message,
    our own code does not illustrate any object-oriented structure.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的`HelloJava`示例一直包含在一个单独的类中。实际上，因为它的简单性，它真的只是一个大方法。尽管我们已经使用了一些对象来显示我们的GUI消息，但我们自己的代码并没有展示任何面向对象的结构。
- en: 'Well, we’re going to correct that right now by adding a second class. To give
    us something to build on throughout this chapter, we’re going to take over the
    job of the `JLabel` class (bye-bye, `JLabel`!) and replace it with our own graphical
    class: `HelloComponent`. Our `HelloComponent` class will start simple, just displaying
    our “Hello, Java!” message at a fixed position. We’ll add capabilities later.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，我们现在要通过添加第二个类来修正这个问题。为了在本章节中有所建树，我们将接管`JLabel`类的工作（再见，`JLabel`！），并将其替换为我们自己的图形类：`HelloComponent`。我们的`HelloComponent`类将从简单开始，只在固定位置显示我们的“Hello,
    Java!”消息。稍后我们会添加更多功能。
- en: 'The code for our new class is simple; we only need a few more lines. First
    we need another `import` statement at the top of the *HelloJava.java* file:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新类代码很简单；我们只需要几行代码。首先，我们需要在*HelloJava.java*文件的顶部加上另一个`import`语句：
- en: '[PRE13]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This line tells the compiler where to find the extra classes we need to fill
    out the logic of `HelloComponent`. And here’s that logic:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此行告诉编译器在哪里找到我们需要填充`HelloComponent`逻辑的额外类。这就是那个逻辑：
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `HelloComponent` class definition can go either above or below our `HelloJava`
    class. Then, to use our new class in place of the `JLabel`, simply replace the
    two lines referencing the label in the `main()` method with:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`HelloComponent`类定义可以放在我们的`HelloJava`类的上方或下方。然后，要在`main()`方法中使用我们的新类来替换引用标签的两行代码：'
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This time when you compile *HelloJava.java*, take a look at the generated *.class*
    files. (These files will be located in either your current directory if you are
    using a terminal or in the *Learn Java/out/production/Learn Java* folder where
    you chose to put IDEA projects. In IDEA itself, you can also expand the *out*
    folder in the project navigation pane on the left side.) Regardless of how you
    arranged the classes in your source, you should see two binary class files: *HelloJava.class*
    and *HelloComponent.class*. Running the code should look much like the `JLabel`
    version, but if you resize the window, you’ll notice that our new component does
    not automatically adjust to center the text.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这次当您编译*HelloJava.java*时，请查看生成的*.class*文件。（这些文件将位于您当前目录（如果您正在使用终端）或您选择放置 IDEA
    项目的*Learn Java/out/production/Learn Java*文件夹中。在 IDEA 中，您也可以在项目导航窗格的左侧展开*out*文件夹。）无论您如何安排源代码中的类，您都应该看到两个二进制类文件：*HelloJava.class*和*HelloComponent.class*。运行代码应该看起来很像`JLabel`版本，但是如果您调整窗口大小，您会注意到我们的新组件不会自动调整以使文本居中。
- en: So what have we done, and why have we gone to such lengths to insult the perfectly
    good `JLabel` component? We’ve created our new `HelloComponent` class, extending
    a generic graphical class called `JComponent`. To *extend* a class simply means
    to add functionality to an existing class, creating a new one. We’ll get into
    that process more in the next section.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们到底做了什么，为什么要如此费力地侮辱完全正常的`JLabel`组件？我们创建了我们的新`HelloComponent`类，扩展了一个称为`JComponent`的通用图形类。*扩展*一个类只是指向现有类添加功能，从而创建一个新类。我们将在下一节更详细地介绍这个过程。
- en: In our current example, we have created a new kind of `JComponent` that contains
    a method called `paintComponent()`, which is responsible for drawing our message.
    The `paintComponent()` method takes one argument named (somewhat tersely) `g`,
    which is of type `Graphics`. When the `paintComponent()` method is invoked, a
    `Graphics` object is assigned to `g`, which we use in the body of the method.
    We’ll say more about `paintComponent()` and the `Graphics` class in a moment.
    As for why, you’ll understand when we add all sorts of new features to our new
    component later on.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们当前的示例中，我们创建了一种新的`JComponent`类型，其中包含一个称为`paintComponent()`的方法，负责绘制我们的消息。`paintComponent()`方法接受一个名为（有些简洁）`g`的参数，类型为`Graphics`。当调用`paintComponent()`方法时，将一个`Graphics`对象分配给`g`，我们在方法体中使用它。稍后我们会详细介绍`paintComponent()`和`Graphics`类。至于为什么这样做，待我们稍后为我们的新组件添加各种新功能时，您就会理解。
- en: Inheritance
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承
- en: Java classes are arranged in a parent-child hierarchy in which the parent and
    child are known as the *superclass* and *subclass*, respectively. We’ll explore
    these concepts more in [Chapter 5](ch05.html#learnjava6-CHP-5). In Java, every
    class has exactly one superclass (a single parent), but possibly many subclasses.
    The only exception to this rule is the `Object` class, which sits atop the entire
    class hierarchy; it has no superclass. (Feel free to peek ahead at the tiny slice
    of the Java class hierarchy shown in [Figure 2-17](#learnjava6-CHP-2-FIG-class-hierarchy).)
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Java 类以父子层次结构排列，其中父类和子类分别称为*超类*和*子类*。我们将在[第5章](ch05.html#learnjava6-CHP-5)中更深入地探讨这些概念。在
    Java 中，每个类都恰好有一个超类（一个单一的父类），但可能有许多子类。唯一的例外是`Object`类，它位于整个类层次结构的顶端；它没有超类。（可以提前查看在[图2-17](#learnjava6-CHP-2-FIG-class-hierarchy)中显示的
    Java 类层次结构的一个小片段。）
- en: 'The declaration of our class in the previous example uses the keyword `extends`
    to specify that `HelloComponent` is a subclass of the `JComponent` class:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面示例中声明我们的类时，使用关键字`extends`指定`HelloComponent`是`JComponent`类的一个子类：
- en: '[PRE16]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: A subclass may *inherit* some or all of the variables and methods of its superclass.
    Inheritance provides the subclass access to the variables and methods of its superclass
    as if it has declared them itself. A subclass can add variables and methods of
    its own, and it can also *override* or change the meaning of inherited methods.
    When we use a subclass, overridden methods are hidden (replaced) by the subclass’s
    own versions of them. In this way, inheritance provides a powerful mechanism whereby
    a subclass can refine or extend the functionality of its superclass.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 子类可以*继承*其超类的一些或所有变量和方法。继承使得子类可以访问其超类的变量和方法，就像它自己声明了它们一样。子类可以添加自己的变量和方法，并且还可以*覆盖*或改变继承方法的含义。当我们使用子类时，被覆盖的方法被子类自己的版本所隐藏（替换）。通过这种方式，继承提供了一个强大的机制，使得子类可以改进或扩展其超类的功能。
- en: For example, the hypothetical spreadsheet class might be subclassed to produce
    a new scientific spreadsheet class with special built-in constants. In this case,
    the source code for the scientific spreadsheet might declare variables for the
    special constants, but the new scientific class still has all of the variables
    (and methods) that constitute the normal functionality of a spreadsheet. Again,
    those standard elements are inherited from the parent spreadsheet class. This
    also means that the scientific spreadsheet maintains its identity as a spreadsheet;
    it can still do everything the simpler spreadsheet could do. That idea, that a
    more specific class can still perform all of the duties of a more general parent
    or ancestor, has profound implications. We call this idea *polymorphism*, and
    we’ll continue to explore it throughout the book. Polymorphism is one of the foundations
    of object-oriented programming.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设电子表格类可以派生为新的科学电子表格类，其中内置了特殊的常量。在这种情况下，科学电子表格的源代码可能声明了用于特殊常量的变量，但新的科学类仍然具有构成标准电子表格正常功能的所有变量（和方法）。同样，这些标准元素是从父电子表格类继承而来。这也意味着科学电子表格保持其作为电子表格的身份；它仍然可以执行较简单电子表格的所有功能。这个想法，即更具体的类仍然可以执行更一般的父类或祖先的所有职责，具有深远的意义。我们称这个想法为*多态性*，我们将在整本书中继续探讨它。多态性是面向对象编程的基础之一。
- en: Our `HelloComponent` class is a subclass of the `JComponent` class and inherits
    many variables and methods not explicitly declared in our source code. This is
    what allows our tiny class to serve as a component in a `JFrame`, with just a
    few customizations.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `HelloComponent` 类是 `JComponent` 类的一个子类，并继承了许多在我们源代码中没有明确声明的变量和方法。这使得我们微小的类能够在
    `JFrame` 中作为组件使用，仅需少量定制。
- en: The JComponent Class
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`JComponent` 类'
- en: The `JComponent` class provides the framework for building all kinds of UI components.
    Particular components—such as buttons, labels, and list boxes—are implemented
    as subclasses of `JComponent`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`JComponent` 类提供了构建各种 UI 组件的框架。特定的组件，如按钮、标签和列表框，都作为 `JComponent` 的子类来实现。'
- en: We mentioned that subclasses can take an inherited method and override it to
    implement some particular behavior. But why would we want to change the behavior
    of something that presumably already works for the superclass? Many classes start
    with minimal functionality. The original programmers expect someone else to come
    along and add the interesting parts. `JComponent` is just such a class. It handles
    a great deal of the communication with the computer’s windowing system for you,
    but it leaves room for you to add the specific details of presentation and behavior.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到子类可以继承一个方法并重写它以实现某些特定行为。但是为什么我们要改变已经对超类有效的东西的行为呢？许多类从最小功能开始。最初的程序员希望其他人来添加有趣的部分。`JComponent`
    就是这样的一个类。它为您处理与计算机窗口系统的大量通信，但它留下了空间让您添加特定的呈现和行为细节。
- en: The `paintComponent()` method is an important method of the `JComponent` class;
    we override it to implement the way our particular component displays itself on
    the screen. The default behavior of `paintComponent()` doesn’t do any drawing
    at all. If we hadn’t overridden it in our subclass, our component would simply
    have been empty. Here, we’re overriding `paintComponent()` to do something only
    slightly more interesting. We don’t override any of the other inherited members
    of `JComponent` because they provide basic functionality and reasonable defaults
    for this (trivial) example. As `HelloJava` grows, we’ll delve deeper into the
    inherited members and use additional methods. We will also add some application-specific
    methods and variables specifically for the needs of `HelloComponent`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`paintComponent()` 方法是 `JComponent` 类的一个重要方法；我们重写它来实现我们特定组件在屏幕上的显示方式。`paintComponent()`
    的默认行为根本不进行任何绘制。如果我们在子类中没有重写它，我们的组件将会是空的。在这里，我们重写 `paintComponent()` 来做一些稍微有趣的事情。我们不重写
    `JComponent` 的任何其他继承成员，因为它们提供了基本功能和合理的默认值，适用于这个（微不足道的）示例。随着 `HelloJava` 的发展，我们将深入研究继承成员并使用额外的方法。我们还会添加一些特定于应用程序的方法和变量，以满足
    `HelloComponent` 的需求。'
- en: '`JComponent` is really the tip of another iceberg called Swing. Swing is Java’s
    UI toolkit, represented in our example by the `import` statement at the top; we’ll
    discuss Swing in more detail in [Chapter 12](ch12.html#learnjava6-CHP-12).'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`JComponent` 实际上是另一个被称为 Swing 的冰山的顶端。Swing 是 Java 的 UI 工具包，在我们的示例中通过顶部的 `import`
    语句表示；我们将在 [第12章](ch12.html#learnjava6-CHP-12) 中详细讨论 Swing。'
- en: Relationships and Finger-Pointing
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关系和指向
- en: You can think of subclassing as creating an “is a” relationship, in which the
    subclass “is a” kind of its superclass. `HelloComponent` is therefore a kind of
    `JComponent`. When we refer to a kind of object, we mean *any instance of that
    object’s class or any of its subclasses*. Later, we will look more closely at
    the Java class hierarchy and see that `JComponent` is itself a subclass of the
    `Container` class, which is further derived from a class called `Component`, and
    so on, as shown in [Figure 2-17](#learnjava6-CHP-2-FIG-class-hierarchy).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将子类化视为创建一个“is a”关系，其中子类“is a”其超类的一种。因此，`HelloComponent` 是 `JComponent` 的一种。当我们提到对象的一种类型时，我们指的是该对象类的任何实例或其任何子类的任何实例。稍后，我们将更详细地查看
    Java 类层次结构，并看到 `JComponent` 本身是 `Container` 类的子类，后者进一步派生自一个称为 `Component` 的类，如
    [图2-17](#learnjava6-CHP-2-FIG-class-hierarchy) 所示。
- en: In this sense, a `HelloComponent` object is a kind of `JComponent`, which is
    a kind of `Container`, and all of these can ultimately be considered to be a kind
    of `Component`. It’s from these classes that `HelloComponent` inherits its basic
    GUI functionality and (as we’ll discuss later) the ability to have other graphical
    components embedded within it as well.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个意义上，`HelloComponent` 对象是 `JComponent` 的一种，而 `JComponent` 又是 `Container` 的一种，所有这些最终都可以被认为是
    `Component` 的一种。正是从这些类中，`HelloComponent` 继承了它的基本 GUI 功能，以及（稍后我们将讨论的）嵌入在其中的其他图形组件的能力。
- en: '![ljv6 0217](assets/ljv6_0217.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0217](assets/ljv6_0217.png)'
- en: Figure 2-17\. Part of the Java class hierarchy
  id: totrans-155
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-17\. Java 类层次结构的部分
- en: '`Component` is a subclass of the top-level `Object` class, so all these classes
    are types of `Object`. Every other class in the Java API inherits behavior from
    `Object`, which defines a few basic methods, as you’ll see in [Chapter 5](ch05.html#learnjava6-CHP-5).
    We’ll continue to use the word *object* (lowercase *o*) in a generic way to refer
    to an instance of any class; we’ll use `Object` to refer specifically to the type
    of that class.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`Component` 是顶级 `Object` 类的一个子类，因此所有这些类都是 `Object` 的类型。Java API 中的每个其他类都从 `Object`
    继承行为，`Object` 定义了一些基本方法，正如你将在 [第5章](ch05.html#learnjava6-CHP-5) 中看到的。我们将继续使用 *object*（小写
    *o*）一词以通用方式指代任何类的实例；我们将使用 `Object` 来具体指代这个类的类型。'
- en: Packages and Imports
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包和导入
- en: 'We mentioned earlier that the first line of our example tells Java where to
    find some of the classes that we’ve been using:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到我们示例的第一行告诉 Java 在哪里找到我们使用的一些类：
- en: '[PRE17]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Specifically, it tells the compiler that we are going to be using classes from
    the Swing GUI toolkit (in this case, `JFrame`, `JLabel`, and `JComponent`). These
    classes are organized into a Java *package* called `javax.swing`. In Java, a package
    is a group of classes that are related by purpose or by application. Classes in
    the same package have special access privileges with respect to one another and
    may be designed to work together closely.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，它告诉编译器我们将使用来自Swing GUI工具包的类（在本例中是`JFrame`、`JLabel`和`JComponent`）。这些类组织成一个名为`javax.swing`的Java
    *包*。在Java中，包是按目的或应用程序相关联的一组类。同一包中的类彼此之间具有特殊的访问权限，并且可能被设计为紧密协作。
- en: 'Packages are named in a hierarchical fashion with dot-separated components,
    such as `java.util` and `java.util.zip`. Classes in a package typically live in
    nested folders matching their package name. They also take on the name of the
    package as part of their “full name” or, to use the proper terminology, their
    *fully qualified name*. For example, the fully qualified name of the `JComponent`
    class is `javax.swing.JComponent`. We could have referred to it by that name directly,
    in lieu of using the `import` statement:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 包名称采用点分隔的分层方式命名，例如`java.util`和`java.util.zip`。包中的类通常存储在匹配其包名称的嵌套文件夹中。它们的“全名”或正确术语称为*完全限定名称*中也包含包的名称作为其一部分。例如，`JComponent`类的完全限定名称是`javax.swing.JComponent`。我们本可以直接用这个名字引用它，而不使用`import`语句：
- en: '[PRE18]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Using fully qualified names can get tiresome. The statement `import javax.swing.*`
    enables us to refer to all the classes in the `javax.swing` package by their simple
    names. We don’t have to use fully qualified names to refer to the `JComponent`,
    `JLabel`, and `JFrame` classes.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用完全限定名称可能会令人厌烦。语句`import javax.swing.*`使我们能够通过它们的简单名称引用`javax.swing`包中的所有类。我们不必使用完全限定名称来引用`JComponent`、`JLabel`和`JFrame`类。
- en: As we saw when we added our second example class, there may be one or more `import`
    statements in a given Java source file. The `import`s effectively create a “search
    path” that tells Java where to look for classes that we refer to by their simple,
    unqualified names. (It’s not really a path, but it avoids ambiguous names that
    can create errors.) The `import`s we’ve seen use the dot star (`.*`) notation
    to indicate that the entire package should be imported. But you can also specify
    just a single class. For example, our current example uses only the `Graphics`
    class from the `java.awt` package. We could have used `import java.awt.Graphics`
    instead of using the wildcard `*` to import all the Abstract Window Toolkit (AWT)
    package’s classes. However, we are anticipating using several more classes from
    this package later.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们添加第二个示例类时，我们看到在给定的Java源文件中可能会有一个或多个`import`语句。这些`import`语句有效地创建了一个“搜索路径”，告诉Java在何处寻找我们用简单、未限定名称引用的类。（实际上它并不是路径，但它避免了可能导致错误的模糊名称。）我们已经看到的`import`使用点星(`.*`)符号来指示整个包应该被导入。但你也可以指定单个类。例如，我们当前的示例只使用了`java.awt`包中的`Graphics`类。我们本可以使用`import
    java.awt.Graphics`而不是使用通配符`*`来导入所有抽象窗口工具包（AWT）的类。但是，我们预计稍后会使用此包中的几个其他类。
- en: The `java.` and `javax.` package hierarchies are special. Any package that begins
    with `java.` is part of the core Java API and is available on any platform that
    supports Java. The `javax.` package normally denotes a standard extension to the
    core platform, which may or may not be installed. However, in recent years, many
    standard extensions have been added to the core Java API without renaming them.
    The `javax.swing` package is an example; it is part of the core API in spite of
    its name. [Figure 2-18](#learnjava6-CHP-2-FIG-core-packages) illustrates some
    of the core Java packages, showing a representative class or two from each.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.`和`javax.`包层次结构是特殊的。任何以`java.`开头的包都是核心Java API的一部分，并且在支持Java的任何平台上都可用。`javax.`包通常表示核心平台的标准扩展，可能已安装或未安装。然而，近年来，许多标准扩展已添加到核心Java
    API中而未重命名。`javax.swing`包就是一个例子；尽管其名称如此，它仍然是核心API的一部分。[Figure 2-18](#learnjava6-CHP-2-FIG-core-packages)展示了一些核心Java包，展示了每个包中的一个或两个典型类。'
- en: '![ljv6 0218](assets/ljv6_0218.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0218](assets/ljv6_0218.png)'
- en: Figure 2-18\. Some core Java packages
  id: totrans-167
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-18\. 一些核心Java包
- en: '`java.lang` contains fundamental classes needed by the Java language itself;
    this package is imported automatically, and that is why we didn’t need an `import`
    statement to use class names such as `String` or `System` in our examples. The
    `java.awt` package contains classes of the older, graphical windowing system;
    `java.net` contains the networking classes; and so on.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.lang` 包含 Java 语言本身所需的基本类； 这个包被自动导入，这就是为什么在我们的示例中使用 `String` 或 `System`
    等类名时不需要 `import` 语句的原因。 `java.awt` 包含较旧的图形窗口系统的类； `java.net` 包含网络类； 依此类推。'
- en: As you gain more experience with Java, you will realize that having a command
    of the packages available to you, what they do, and when and how to use them is
    a critical part of becoming a successful Java developer.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您对 Java 的经验越来越丰富，您将意识到熟练掌握可用于您的包、它们的作用以及何时以及如何使用它们是成为成功的 Java 开发人员的关键部分。
- en: The paintComponent() Method
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`paintComponent()` 方法'
- en: 'The source for our `HelloComponent` class defines a method, `paintComponent()`,
    that overrides the `paintComponent()` method of the `JComponent` class:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `HelloComponent` 类的源代码定义了一个方法，`paintComponent()`，它重写了 `JComponent` 类的 `paintComponent()`
    方法：
- en: '[PRE19]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `paintComponent()` method is called when it’s time for our example to draw
    itself on the screen. It takes a single argument, a `Graphics` object, and doesn’t
    return any type of value (`void`) to its caller.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的示例需要在屏幕上绘制自己时，将调用 `paintComponent()` 方法。 它接受一个参数，一个 `Graphics` 对象，并且不会向其调用者返回任何类型的值（`void`）。
- en: '*Modifiers* are keywords placed before classes, variables, and methods to alter
    their accessibility, behavior, or semantics. Here `paintComponent()` is declared
    as `public`, which means it can be invoked (called) by methods in classes other
    than `HelloComponent`. In this case, it’s the Java windowing environment that
    is calling our `paintComponent()` method. A method or variable declared as `private`,
    by contrast, is accessible only from its own class.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '*修饰符* 是放置在类、变量和方法之前的关键字，用于改变它们的可访问性、行为或语义。 在这里 `paintComponent()` 被声明为 `public`，这意味着它可以被除了
    `HelloComponent` 之外的类中的方法调用。 在这种情况下，是 Java 窗口环境调用我们的 `paintComponent()` 方法。 相比之下，被声明为
    `private` 的方法或变量只能从它自己的类中访问。'
- en: The `Graphics` object, an instance of the `Graphics` class, represents a particular
    graphical drawing area. (It is also called a *graphics context*.) It contains
    methods that can be used to draw in this area, and variables that represent characteristics
    such as clipping or drawing modes. The particular `Graphics` object we are passed
    in the `paintComponent()` method corresponds to our `HelloComponent`’s area of
    the screen, inside our frame.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`Graphics` 对象，`Graphics` 类的一个实例，表示特定的图形绘制区域。（它也被称为*图形上下文*。） 它包含可以用于在此区域绘制的方法，以及表示特征的变量，如剪切或绘图模式。
    我们在 `paintComponent()` 方法中收到的特定 `Graphics` 对象对应于我们的 `HelloComponent` 屏幕上的区域，位于我们的框架内部。'
- en: The `Graphics` class provides methods for rendering shapes, images, and text.
    In `HelloComponent`, we invoke the `drawString()` method of our `Graphics` object
    to scrawl our message at the specified coordinates.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`Graphics` 类提供了用于呈现形状、图像和文本的方法。 在 `HelloComponent` 中，我们调用我们的 `Graphics` 对象的
    `drawString()` 方法来在指定的坐标上书写我们的消息。'
- en: 'As we’ve seen earlier, we access a method of an object by appending a dot (`.`)
    and its name to the object that holds it. We invoked the `drawString()` method
    of the `Graphics` object (referenced by our `g` variable) in this way:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所见，我们通过将一个点（`.`）和其名称附加到持有它的对象上来访问对象的方法。 我们以这种方式调用了 `Graphics` 对象（由我们的
    `g` 变量引用）的 `drawString()` 方法：
- en: '[PRE20]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here we can see how overriding an inherited method provides new functionality.
    On its own, an instance of `JComponent` has no idea what information to show the
    user or how to respond to things like mouse clicks. We extended `JComponent` and
    added a tiny bit of custom logic: we show a bit of text on the screen. But we
    can do much more!'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到如何重写继承的方法提供了新的功能。 单独看，`JComponent` 的实例不知道要向用户显示什么信息，也不知道如何响应鼠标点击等操作。
    我们扩展了 `JComponent` 并添加了一点自定义逻辑：我们在屏幕上显示一点文本。 但是我们还可以做得更多！
- en: 'HelloJava2: The Sequel'
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'HelloJava2: 续集'
- en: Now that we’ve got some basics down, let’s make our application a little more
    interactive. The following minor upgrade allows us to drag the message text around
    with the mouse. If you’re new to programming, though, the upgrade may not seem
    so minor. Fear not! We will look closely at all of the topics covered in this
    example in later chapters. For now, enjoy playing with the example and use it
    as an opportunity to get more comfortable creating and running Java programs,
    even if you don’t feel as comfortable with the code inside.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了一些基础知识，让我们让我们的应用程序更加交互。以下小升级允许我们用鼠标拖动消息文本。如果你是新手程序员，这个升级可能并不那么小。不要担心！我们将在后面的章节中仔细查看这个示例中涉及的所有主题。现在，享受玩这个例子，并将其用作创建和运行Java程序的机会，即使你对代码内部感觉不那么自在。
- en: We’ll call this example `HelloJava2` rather than cause confusion by continuing
    to expand the old one, but the primary changes here and further on lie in adding
    capabilities to the `HelloComponent` class and simply making the corresponding
    changes to the names to keep them straight (e.g., `HelloComponent2`, `HelloComponent3`,
    and so on). Having just seen inheritance at work, you might wonder why we aren’t
    creating a subclass of `HelloComponent` and exploiting inheritance to build upon
    our previous example and extend its functionality. Well, in this case, that would
    not provide much advantage, so for clarity we simply start over.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个示例称为`HelloJava2`，而不是通过继续扩展旧示例来引起混淆，但这里和以后的主要变化在于向`HelloComponent`类添加功能，并简单地对名称进行相应的更改，以保持它们的清晰性（例如，`HelloComponent2`，`HelloComponent3`等）。刚刚看到继承的作用，你可能会想知道为什么我们不创建`HelloComponent`的子类，并利用继承来构建我们之前示例的基础上扩展其功能。嗯，在这种情况下，这并没有提供太多优势，所以为了清晰起见，我们简单地重新开始。
- en: 'Two slashes in a row indicate that the rest of the line is a comment. We’ve
    added a few comments to `HelloJava2` to help you keep track of everything:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 连续两个斜杠表示该行的其余部分是注释。我们已经向`HelloJava2`添加了一些注释，以帮助你跟踪一切：
- en: '[PRE21]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If you are using IDEA, create a new Java class named *HelloJava2* and copy the
    code above. If you are sticking with the terminal, place the text of this example
    in a new file called *HelloJava2.java*. Either way, you want to compile it as
    before. You should get new class files, *HelloJava2.class* and *HelloComponent2.class*,
    as a result.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用IDEA，请创建一个名为*HelloJava2*的新Java类，并复制上面的代码。如果你继续使用终端，请将此示例的文本放入一个名为*HelloJava2.java*的新文件中。无论哪种方式，你都希望像以前一样进行编译。你应该得到新的类文件*HelloJava2.class*和*HelloComponent2.class*作为结果。
- en: 'If you are following in IDEA, click the Run button next to `HelloJava2`. If
    you are using a terminal, run the example using the following command:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在IDEA中进行跟进，请点击`HelloJava2`旁边的运行按钮。如果你使用终端，请使用以下命令运行示例：
- en: '[PRE22]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Feel free to substitute your own victorious comment for the “Hello, Java!” message
    and enjoy many hours of fun, dragging the text around with your mouse. Notice
    that now when you click the window’s close button, the application exits properly;
    we’ll explain that later when we talk about events. Let’s dive in and see what
    has changed.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 随意用你自己的胜利性评论替换“Hello, Java!”消息，并享受用鼠标拖动文本多个小时的乐趣。注意，现在当你点击窗口的关闭按钮时，应用程序会正常退出；当我们讨论事件时，我们将在稍后解释这一点。让我们深入了解一下发生了什么变化。
- en: Instance Variables
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实例变量
- en: 'We have added some variables to the `HelloComponent2` class in our example:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的示例中向`HelloComponent2`类添加了一些变量：
- en: '[PRE23]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`messageX` and `messageY` are integers that hold the current coordinates of
    our movable message. We have set them to default values that should place the
    message roughly near the center of the window. Java integers are 32-bit signed
    numbers, so they can easily hold our coordinate values. The variable `theMessage`
    is of type `String` and can hold instances of the `String` class.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`messageX`和`messageY`是保存我们可移动消息的当前坐标的整数。我们已经将它们设置为默认值，应该将消息放置在窗口的大致中心。Java整数是32位有符号数，因此它们可以轻松保存我们的坐标值。变量`theMessage`是`String`类型，可以保存`String`类的实例。'
- en: You should note that these three variables are declared inside the braces of
    the class definition but not inside any particular method in that class. These
    variables are called *instance* variables, and they belong to the object as a
    whole. Specifically, separate copies of them appear in each separate instance
    of the class. Instance variables are always visible to (and usable by) all the
    methods inside their class. Depending on their modifiers, they may also be accessible
    from outside the class.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该注意，这三个变量声明在类定义的大括号内，但不是在该类的任何特定方法内。这些变量称为*实例*变量，它们属于整个对象。每个类的各个实例中都会有它们的独立副本。实例变量始终对它们所属类内的所有方法可见（并可用）。根据其修饰符，它们也可能可以从类外部访问。
- en: Unless otherwise initialized (programmer jargon for setting the first value
    on something), instance variables are set to a default value of `0`, `false`,
    or `null`, depending on their type. Numeric types are set to `0`, Boolean variables
    are set to `false`, and class type variables always have their value set to `null`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 除非另有初始化（程序员术语表示设置某物的第一个值），否则实例变量将被设置为其类型的默认值：`0`、`false`或`null`，具体取决于其类型。数值类型被设置为`0`，布尔变量被设置为`false`，类类型变量始终具有`null`值。
- en: Instance variables differ from method arguments and other variables that are
    declared inside the scope of a particular method. The latter are called *local*
    variables. They are effectively private variables that can be seen only by code
    inside a method or other code block. Java doesn’t initialize local variables,
    so you must assign values yourself. If you try to use a local variable that has
    not yet been assigned a value, your code generates a compile-time error. Local
    variables live only as long as the method is executing and then disappear, unless
    something else saves their value. Each time the method is invoked, its local variables
    are recreated and must be assigned values.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 实例变量与方法参数和其他在特定方法作用域内声明的变量不同。后者称为*局部*变量。它们实际上是只能被方法内部代码看到的私有变量。Java不会初始化局部变量，因此您必须自行分配值。如果尝试使用尚未分配值的局部变量，您的代码将生成编译时错误。局部变量只在方法执行期间存在，然后消失，除非其他内容保存了它们的值。每次调用方法时，都会重新创建其局部变量，并且必须为其分配值。
- en: We have used the new variables to make our previously stodgy `paintComponent()`
    method more dynamic. Now all the arguments in the call to `drawString()` are determined
    by these variables.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用了新的变量来使我们之前单调的`paintComponent()`方法更加动态。现在`drawString()`调用中的所有参数都由这些变量确定。
- en: Constructors
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造方法
- en: The `HelloComponent2` class includes a special kind of a method called a *constructor*.
    A constructor is called to set up a new instance of a class. When a new object
    is created, Java allocates storage for it, sets instance variables to their default
    values, and calls the constructor method for the class to do whatever application-level
    setup is required.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`HelloComponent2`类包含一种特殊类型的方法，称为*构造方法*。构造方法用于设置类的新实例。当创建一个新对象时，Java为其分配存储空间，将实例变量设置为它们的默认值，并调用类的构造方法来执行任何应用级别的设置。'
- en: A constructor always has the same name as its class. For example, the constructor
    for the `HelloComponent2` class is called `HelloComponent2()`. Constructors don’t
    have a return type, but you can think of them as creating an object of their class’s
    type. Like other methods, constructors can have parameters. Their sole mission
    in life is to configure and initialize newly born class instances, possibly using
    information passed to them in these parameters.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 构造方法的名称始终与其类的名称相同。例如，`HelloComponent2`类的构造方法称为`HelloComponent2()`。构造方法没有返回类型，但您可以将它们视为创建其类类型对象的方法。与其他方法一样，构造方法可以有参数。它们的唯一使命是配置和初始化新创建的类实例，可能使用传递给它们的参数中的信息。
- en: 'An object is created with the `new` operator specifying the constructor for
    the class and any necessary arguments.^([1](ch02.html#id787)) The resulting object
    instance is returned as a value. In our example, a new `HelloComponent2` instance
    is created in the `main()` method by this line:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`new`运算符创建对象时，需指定类的构造方法和任何必要的参数。^([1](ch02.html#id787)) 创建的对象实例作为返回值返回。在我们的示例中，`main()`方法中通过以下行创建了一个新的`HelloComponent2`实例：
- en: '[PRE24]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This line actually does two things. To make that clearer, we could write them
    as two separate lines that are a little easier to understand:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行实际上做了两件事情。为了更清楚地表达，我们可以将它们写成两个单独的行，这样更容易理解：
- en: '[PRE25]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The first line is the important one, where a new `HelloComponent2` object is
    created. The `HelloComponent2` constructor takes a `String` as an argument and,
    as we have arranged things, uses that argument to set the message that is displayed
    in the window. With a little magic from the Java compiler, quoted text in Java
    source code is turned into a `String` object. (See [Chapter 8](ch08.html#learnjava6-CHP-8)
    for a deeper discussion of the `String` class.) The second line simply adds our
    new component to the frame to make it visible, as we did in the previous examples.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行是重要的一行，这里创建了一个新的`HelloComponent2`对象。`HelloComponent2`的构造函数接受一个`String`作为参数，并且按照我们的安排使用该参数来设置在窗口中显示的消息。通过Java编译器的一些魔法，Java源代码中的引号文本被转换为一个`String`对象（参见[第八章](ch08.html#learnjava6-CHP-8)对`String`类的更深入讨论）。第二行简单地将我们的新组件添加到框架中，以使其可见，就像我们在前面的示例中所做的那样。
- en: 'While we’re on the topic, if you’d like to make our message configurable, you
    can change the constructor call to the following:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，如果你想让我们的消息可配置，你可以将构造函数调用改为以下形式之一：
- en: '[PRE26]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now you can pass the text on the command line when you run the application
    using the following command:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以在运行应用程序时通过以下命令在命令行传递文本：
- en: '[PRE27]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`args[0]` refers to the first command-line parameter. Its meaning will become
    clearer when we discuss arrays in [Chapter 4](ch04.html#learnjava6-CHP-4). If
    you are using an IDE, you will need to configure it to accept your parameters
    before running it. IntelliJ IDEA has something called a *run configuration* that
    you can edit from the same menus that pop up when you click the green play buttons.
    The run configuration has a number of options, but our interest is in the text
    field for “Program Arguments,” as shown in [Figure 2-19](#learnjava6-CHP-2-FIG-15).
    Note that on both the command line and in the IDE, you must enclose your phrase
    in double quotes to make sure the text is considered one argument. If you leave
    off the quotes, `Hello,` and `Java!` would be two separate arguments.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`args[0]`指的是第一个命令行参数。在我们讨论数组时，它的意义会变得更清晰（参见[第四章](ch04.html#learnjava6-CHP-4)）。如果你在使用IDE，你需要配置它以接受你的参数然后再运行它。IntelliJ
    IDEA 有一个叫做*run configuration*的东西，你可以在点击绿色播放按钮时从弹出的菜单中编辑它。Run configuration有很多选项，但我们关注的是“Program
    Arguments”文本框，如[图2-19](#learnjava6-CHP-2-FIG-15)所示。请注意，在命令行和IDE中，你必须用双引号将你的短语括起来，以确保文本被视为一个参数。如果你不加引号，`Hello,`和`Java!`会被视为两个独立的参数。'
- en: '![ljv6 0219](assets/ljv6_0219.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0219](assets/ljv6_0219.png)'
- en: Figure 2-19\. IDEA dialog for giving command-line parameters
  id: totrans-211
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-19\. IDEA对话框用于提供命令行参数
- en: '`HelloComponent2`’s constructor then does two things: it sets the text of `theMessage`
    instance variable and calls `addMouseMotionListener()`. This method is part of
    the event mechanism, which we’ll discuss next. It tells the system, “Hey, I’m
    interested in anything that happens involving mouse motion”:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`HelloComponent2`的构造函数接着做了两件事情：它设置了`theMessage`实例变量的文本，并调用了`addMouseMotionListener()`。这个方法是事件机制的一部分，我们接下来会讨论它。它告诉系统：“嘿，我对任何涉及鼠标移动的事情感兴趣”：'
- en: '[PRE28]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The special, read-only variable called `this` is used to explicitly refer to
    our object (the “current” object context) in the call to `addMouseMotionListener()`.
    A method can use `this` to refer to the instance of the object that holds it.
    The following two statements are therefore equivalent ways of assigning the value
    to `theMessage` instance variable:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊的只读变量`this`用于显式地引用我们的对象（“当前”对象上下文）在调用`addMouseMotionListener()`时。一个方法可以使用`this`来引用持有它的对象的实例。因此，以下两个语句是将值赋给`theMessage`实例变量的等效方式：
- en: '[PRE29]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'or:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE30]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We’ll normally use the shorter, implicit form to refer to instance variables,
    but we’ll need `this` when we have to explicitly pass a reference to our object
    to a method in another class. We often pass such references so that methods in
    other classes can invoke our public methods or use our public variables.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们会使用更短的、隐式形式来引用实例变量，但当我们必须显式地将对象的引用传递给另一个类中的方法时，我们会需要使用`this`。我们经常传递这样的引用，以便其他类中的方法可以调用我们的公共方法或使用我们的公共变量。
- en: Events
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件
- en: The last two methods of `HelloComponent2`, `mouseDragged()` and `mouseMoved()`,
    tell Java to pass along any information it might get from the mouse. Each time
    the user performs an action, such as pressing a key on the keyboard, moving the
    mouse, or perhaps banging their head against a touch screen, Java generates an
    *event*. An event represents an action that has occurred; it contains information
    about the action, such as its time and location. Most events are associated with
    a particular GUI component in an application. A keystroke, for instance, can correspond
    to a character being typed into a particular text entry field. Clicking a mouse
    button can activate a particular button on the screen. Even just moving the mouse
    within a certain area of the screen can trigger effects such as highlighting text
    or changing the cursor’s shape.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`HelloComponent2`的最后两个方法，`mouseDragged()`和`mouseMoved()`，告诉Java传递任何可能从鼠标获取的信息。每当用户执行操作，比如在键盘上按键，移动鼠标，或者可能在触摸屏上撞击头部时，Java就会生成一个*事件*。事件代表发生的动作；它包含关于动作的信息，比如时间和位置。大多数事件与应用程序中特定的GUI组件相关联。例如，按下键盘可以对应将字符输入到特定的文本输入字段中。点击鼠标按钮可以激活屏幕上的特定按钮。甚至只是在屏幕的某个区域内移动鼠标也可以触发效果，如突出显示文本或更改光标的形状。'
- en: To work with these events, we’ve imported a new package, `java.awt.event`, which
    provides specific `Event` objects that we use to get information from the user.
    (Notice that importing `java.awt.*` doesn’t automatically import the `event` package.
    Imports are not recursive. Packages don’t really contain other packages, even
    if the hierarchical naming scheme would imply that they do.)
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理这些事件，我们已经导入了一个新的包，`java.awt.event`，它提供了特定的`Event`对象，我们用这些对象来从用户那里获取信息。（请注意，导入`java.awt.*`并不会自动导入`event`包。导入不是递归的。包实际上并不包含其他包，即使层次命名方案会暗示它们包含。）
- en: There are dozens of event classes, including `MouseEvent`, `KeyEvent`, and `Action​E⁠vent`.
    For the most part, the meaning of these events is fairly intuitive. A `MouseEvent`
    occurs when the user does something with the mouse, a `KeyEvent` occurs when the
    user presses or releases a key, and so on. `ActionEvent` is a little special;
    we’ll see it at work in [Chapter 12](ch12.html#learnjava6-CHP-12). For now, we’ll
    focus on dealing with `MouseEvent`s.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 其中有数十种事件类，包括`MouseEvent`、`KeyEvent`和`Action​E⁠vent`。在大多数情况下，这些事件的含义相当直观。当用户使用鼠标时，会发生`MouseEvent`，当用户按下或释放键时会发生`KeyEvent`，等等。`ActionEvent`有点特殊；我们将在[第12章](ch12.html#learnjava6-CHP-12)中看到它的运作。现在，我们将专注于处理`MouseEvent`。
- en: GUI components in Java generate events for specific kinds of user actions. For
    example, if you click the mouse inside a component, the component generates a
    mouse event. Objects can ask to receive the events from one or more components
    by registering a *listener* with the event source. For example, to declare that
    a listener wants to receive a component’s mouse-motion events, you invoke that
    component’s `addMouseMotionListener()` method, specifying the listener object
    as an argument. That’s what our example is doing in its constructor. In this case,
    the component is calling its own `addMouseMotionListener()` method, with the argument
    `this`, meaning “I want to receive my own mouse-motion events.”
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Java中的GUI组件为特定类型的用户操作生成事件。例如，如果您在组件内部点击鼠标，组件将生成鼠标事件。对象可以请求从一个或多个组件接收事件，方法是通过将事件源的*监听器*注册到该组件。例如，要声明监听器希望接收组件的鼠标移动事件，可以调用该组件的`addMouseMotionListener()`方法，并将监听器对象作为参数传递。这就是我们示例在其构造函数中正在执行的操作。在这种情况下，组件调用其自己的`addMouseMotionListener()`方法，并将参数`this`传递进去，意思是“我希望接收自己的鼠标移动事件”。
- en: That’s how we register to receive events. But how do we actually get them? That’s
    what the two mouse-related methods in our class are for. The `mouseDragged()`
    method is called automatically on a listener to receive the events generated when
    the user drags the mouse—that is, moves the mouse with any button clicked. The
    `mouseMoved()` method is called whenever the user moves the mouse over the area
    without clicking a button.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们注册以接收事件的方式。但是我们如何实际获取它们呢？这就是我们类中两个与鼠标相关的方法的作用。`mouseDragged()`方法在监听器上自动调用以接收用户拖动鼠标时生成的事件，即移动鼠标并点击任意按钮。当用户在未点击按钮的情况下移动鼠标时，`mouseMoved()`方法被调用。
- en: In this case, we’ve placed these methods in our `HelloComponent2` class and
    had it register itself as the listener. This is entirely appropriate for our new
    text-dragging component. More generally, good design usually dictates that event
    listeners be implemented as *adapter classes* that provide better separation of
    GUI and “business logic.” An adapter class is a convenient intermediate class
    that implements all of the methods of an interface with some default behavior.
    We’ll discuss events, listeners, and adapters in detail in [Chapter 12](ch12.html#learnjava6-CHP-12).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将这些方法放在我们的`HelloComponent2`类中，并让它注册自己作为监听器。这对于我们的新文本拖动组件来说是完全适当的。更普遍地说，良好的设计通常规定事件监听器应该作为*适配器类*来实现，这样可以更好地分离GUI和“业务逻辑”。适配器类是一个方便的中间类，它实现了接口的所有方法并提供一些默认行为。我们将在[第12章](ch12.html#learnjava6-CHP-12)中详细讨论事件、监听器和适配器。
- en: 'Our `mouseMoved()` method is boring: it doesn’t do anything. We ignore simple
    mouse motions and reserve our attention for dragging. But we have to supply some
    kind of implementation—even an empty one—since the `MouseMotionListener` interface
    includes it. Our `mouseDragged()` method, on the other hand, has some meat to
    it. This method is called repeatedly by the windowing system to give us updates
    on the position of the mouse as the user drags it around. Here it is:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`mouseMoved()`方法很无聊：它什么也不做。我们忽略简单的鼠标移动，保留我们的注意力在拖动上。但是我们必须提供某种实现——即使是空实现——因为`MouseMotionListener`接口包含它。另一方面，我们的`mouseDragged()`方法有一些内容。窗口系统会重复调用此方法，以向我们提供用户拖动鼠标时鼠标位置的更新。这是它的工作方式：
- en: '[PRE31]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The lone parameter to `mouseDragged()` is a `MouseEvent` object, `e`, that contains
    all the information we need to know about this event. We ask the `MouseEvent`
    to tell us the `x` and `y` coordinates of the mouse’s current position by calling
    its `getX()` and `getY()` methods. We save these in the `messageX` and `messageY`
    instance variables for use elsewhere.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`mouseDragged()`的唯一参数是一个`MouseEvent`对象，`e`，它包含关于此事件的所有信息。我们通过调用它的`getX()`和`getY()`方法询问`MouseEvent`来告诉我们鼠标当前位置的`x`和`y`坐标。我们将这些保存在`messageX`和`messageY`实例变量中，以便在其他地方使用。'
- en: The beauty of the event model is that you have to handle only the kinds of events
    you want. If you don’t care about keyboard events, you just don’t register a listener
    for them; the user can type all they want and you won’t be bothered. If there
    are no listeners for a particular kind of event, Java won’t even generate it.
    The result is that event handling is quite efficient.^([2](ch02.html#id805))
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 事件模型的美妙之处在于您只需要处理您想要的事件类型。如果您不关心键盘事件，您就不会为它们注册监听器；用户可以随心所欲地输入，而您则不会受到干扰。如果没有特定类型事件的监听器，Java甚至不会生成它。结果是，事件处理非常高效。^([2](ch02.html#id805))
- en: 'While we’re discussing events, we should mention another small addition we
    slipped into `HelloJava2`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论事件时，我们应该提到我们在`HelloJava2`中添加的另一个小的补充：
- en: '[PRE32]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This line tells the frame to exit the application when its Close button is clicked.
    It’s called the “default” close operation because this operation, like almost
    every other GUI interaction, is governed by events. We could register a window
    listener to be notified when the user clicks on the Close button and take whatever
    action we like, but this convenience method handles the common cases.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 此行告诉框架在单击其关闭按钮时退出应用程序。它被称为“默认”关闭操作，因为这种操作像几乎每个其他GUI交互一样，都受事件控制。我们可以注册一个窗口监听器来在用户单击关闭按钮时通知我们，并采取任何我们喜欢的操作，但这种方便的方法处理了常见情况。
- en: Finally, we’ve danced around a couple of other questions here. How does the
    system know that our class contains the necessary `mouseDragged()` and `mouseMoved()`
    methods? Where do these names come from? And why do we have to supply a `mouseMoved()`
    method that doesn’t do anything? The answer to these questions has to do with
    interfaces. We’ll touch on interfaces after clearing up some unfinished business
    with `repaint()`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在这里绕了几个其他问题。系统如何知道我们的类包含必要的`mouseDragged()`和`mouseMoved()`方法？这些名称从哪里来？为什么我们必须提供一个不做任何事情的`mouseMoved()`方法？这些问题的答案与接口有关。在处理完`repaint()`的一些未完成的事务后，我们将涉及接口。
- en: The repaint() Method
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`repaint()`方法'
- en: Because we change the coordinates for the message when we drag the mouse, we
    would like `HelloComponent2` to redraw itself. We do this by calling `repaint()`,
    which asks the system to redraw the screen at a later time. We can’t call `paintComponent()`
    directly, even if we wanted to, because we don’t have a graphics context to pass
    to it.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们在拖动鼠标时更改消息的坐标，所以我们希望`HelloComponent2`重新绘制自己。我们通过调用`repaint()`来实现这一点，这会请求系统在稍后的时间重新绘制屏幕。我们不能直接调用`paintComponent()`，即使我们想这样做，因为我们没有要传递给它的图形上下文。
- en: We can use the `repaint()` method of the `JComponent` class to request that
    our component be redrawn. `repaint()` causes the Java windowing system to schedule
    a call to our `paintComponent()` method at the next possible time; Java supplies
    the necessary `Graphics` object, as shown in [Figure 2-20](#learnjava6-CHP-2-FIG-16).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`JComponent`类的`repaint()`方法来请求重新绘制我们的组件。`repaint()`会导致 Java 窗口系统在下一个可能的时间调用我们的`paintComponent()`方法；Java会提供必要的`Graphics`对象，如[图 2-20](https://learnjava6-CHP-2-FIG-16)所示。
- en: '![ljv6 0220](assets/ljv6_0220.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 0220](assets/ljv6_0220.png)'
- en: Figure 2-20\. Invoking the `repaint()` method
  id: totrans-238
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-20\. 调用`repaint()`方法
- en: This mode of operation isn’t just an inconvenience brought about by not having
    the right graphics context handy. Its biggest advantage is that the repainting
    behavior is handled by something else, while we are free to go about our business.
    The Java system has a separate, dedicated thread of execution that handles all
    `repaint()` requests. It can schedule and consolidate `repaint()` requests as
    necessary, which helps to prevent the windowing system from being overwhelmed
    during painting-intensive situations like scrolling. Another advantage is that
    all the painting functionality must be encapsulated through our `paintComponent()`
    method; we aren’t tempted to spread it throughout the application (which could
    make maintenance difficult).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这种操作模式不仅仅是因为没有正确的图形上下文而带来的不便。它的最大优势在于重绘行为由其他部分处理，而我们可以自由地继续进行我们的业务。Java 系统有一个单独的专用执行线程来处理所有的`repaint()`请求。它可以根据需要调度和合并`repaint()`请求，这有助于防止在像滚动这样的绘图密集型场景中使窗口系统不堪重负。另一个优点是，所有的绘图功能必须通过我们的`paintComponent()`方法封装；我们不会被诱惑将它分散到应用程序的各个部分（这可能会增加维护的难度）。
- en: Interfaces
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口
- en: 'Now it’s time to tackle some of the questions we avoided earlier: how does
    the system know to call `mouseDragged()` when a mouse event occurs? Is it simply
    a matter of knowing that `mouseDragged()` is some magic name that our event-handling
    method must have? Not quite; the answer touches on the discussion of interfaces,
    which are one of the most important features of the Java language.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候解决我们之前避开的一些问题了：系统如何知道在鼠标事件发生时调用`mouseDragged()`？它仅仅是知道`mouseDragged()`是我们事件处理方法必须具有的某种魔法名称吗？不完全是；答案涉及到接口的讨论，这是
    Java 语言中最重要的特性之一。
- en: 'The first sign of an interface comes on the line of code that introduces the
    `HelloComponent2` class. We say that the class *implements* the `MouseMotionListener`
    interface:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 接口的第一个迹象出现在引入`HelloComponent2`类的代码行上。我们说这个类*实现*了`MouseMotionListener`接口：
- en: '[PRE33]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Essentially, an *interface* is a list of methods that the class must have; this
    particular interface requires our class to have methods called `mouseDragged()`
    and `mouseMoved()`. The interface doesn’t say what these methods have to do; indeed,
    our `mouseMoved()` doesn’t do anything at all. It does say that the methods must
    take a `MouseEvent` as an argument and return no value (that’s what `void` means).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，*接口*是类必须具有的方法列表；这个特定的接口要求我们的类具有称为`mouseDragged()`和`mouseMoved()`的方法。接口并不规定这些方法必须做什么；事实上，我们的`mouseMoved()`根本什么也不做。它确实指出这些方法必须以`MouseEvent`作为参数并且返回无值（这就是`void`的含义）。
- en: An interface is a contract between you, the code developer, and the compiler.
    By saying that your class implements the `MouseMotionListener` interface, you’re
    saying that these methods will be available for other parts of the system to call.
    If you don’t provide them, a compilation error will occur. That’s why we need
    a `mouseMoved()` method; even though the one we supplied doesn’t do anything,
    the `MouseMotionListener` interface says we must have one.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 接口是您、代码开发人员和编译器之间的契约。通过声明您的类实现`MouseMotionListener`接口，您表示这些方法将供系统的其他部分调用。如果您没有提供它们，将会发生编译错误。这就是为什么我们需要一个`mouseMoved()`方法的原因；即使我们提供的这个方法什么也不做，`MouseMotionListener`接口也要求我们必须有一个。
- en: The Java distribution comes with many interfaces that define what classes have
    to do. This idea of a contract between the compiler and a class is very important.
    There are many situations like the one we just saw where you don’t care what class
    something is; you just care that it has some capability, such as listening for
    mouse events. Interfaces give us a way of acting on objects based on their capabilities
    without knowing or caring about their actual type. They are a tremendously important
    concept in how we use Java as an object-oriented language. We’ll talk about them
    in detail in [Chapter 5](ch05.html#learnjava6-CHP-5).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Java 分发版附带许多定义类必须执行的接口。编译器与类之间的这种契约概念非常重要。有许多情况，如我们刚刚看到的，您并不关心某个东西的具体类别；您只关心它具备某些功能，例如监听鼠标事件。接口为我们提供了一种根据对象能力而不知道或不关心其实际类型来操作对象的方式。在我们作为面向对象语言使用
    Java 方面，它们是一个极其重要的概念。我们将在[第 5 章](ch05.html#learnjava6-CHP-5)中详细讨论它们。
- en: '[Chapter 5](ch05.html#learnjava6-CHP-5) also discusses how interfaces provide
    a sort of escape clause to the Java rule that any new class can extend only a
    single class (“single inheritance”). A class in Java can extend only one class
    but can implement as many interfaces as it wants. Interfaces can be used as data
    types, can extend other interfaces (but not classes), and can be inherited by
    classes (if class A implements interface B, subclasses of A also implement B).
    The crucial difference is that classes don’t actually inherit methods from interfaces;
    the interfaces merely specify the methods the class must have.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 5 章](ch05.html#learnjava6-CHP-5) 还讨论了接口如何为 Java 规则提供了某种逃脱口，即任何新类只能扩展一个类（“单继承”）。在
    Java 中，一个类只能扩展一个类，但可以实现任意多个接口。接口可以用作数据类型，可以扩展其他接口（但不能扩展类），并且可以被类继承（如果类 A 实现了接口
    B，则 A 的子类也实现了 B）。关键的区别在于，类并不实际从接口继承方法；接口仅仅指定了类必须拥有的方法。'
- en: Goodbye and Hello Again
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 再见和再见
- en: Well, it’s time to say goodbye to `HelloJava`. We hope that you have developed
    a feel for some of the features of the Java language and the basics of writing
    and running a Java program. This brief introduction should help you as you explore
    the details of programming with Java. If you are a bit bewildered by some of the
    material presented here, take heart. We’ll be covering all the major topics presented
    here again in their own chapters throughout the book. This tutorial was meant
    to be something of a “trial by fire” to get the important concepts and terminology
    into your brain so that the next time you hear them you’ll have a head start.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，是时候告别 `HelloJava` 了。我们希望您已经对 Java 语言的一些特性以及编写和运行 Java 程序的基础有了一定的了解。这个简短的介绍应该有助于您探索使用
    Java 进行编程的详细内容。如果您对这里介绍的一些材料感到有些困惑，不要灰心。我们将在整本书中的各自章节中再次详细讨论这里介绍的所有主要内容。这个教程旨在通过让您理解重要的概念和术语，使您的大脑为下次听到它们时有所准备。
- en: We will be getting to know the tools of the Java world better in the next chapter.
    We’ll see details on the commands we have already introduced, such as *javac*,
    as well as go over other important utilities. Read on to say hello to several
    of your new best friends as a Java developer!
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更好地了解 Java 世界的工具。我们将详细了解我们已经介绍的命令，比如 *javac*，以及其他重要的实用程序。继续阅读，向 Java
    开发人员中的几位新朋友打招呼！
- en: Review Questions
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复习问题
- en: 'Here are a few review questions to make sure you caught the key topics in this
    chapter:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些复习问题，以确保您掌握了本章的关键内容：
- en: What command do you use to compile a Java source file?
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您用什么命令来编译 Java 源文件？
- en: How does the JVM know where to start when you run a Java class?
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当运行 Java 类时，JVM 如何知道从何处开始？
- en: Can you extend more than one class when creating a new class?
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建新类时，能够扩展多个类吗？
- en: Can you implement more than one interface when creating a new class?
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建新类时，能够实现多个接口吗？
- en: Which class represents the main window in a graphical application?
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个类代表图形应用程序中的主窗口？
- en: Code Exercises
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码练习
- en: And for your first programming exercise,^([3](ch02.html#id817)) create a `GoodbyeJava`
    class that works just like the first HelloJava program from [“Running the Project”](#learnjava6-CHP-2-SECT-1.3),
    but displays the message “Goodbye, Java!” instead. Try either the command-line
    version or the graphical version—or both! Feel free to copy as much of the original
    program as you like. Be sure to compile and run your `GoodbyeJava` class to help
    practice the process of executing a Java application. You will certainly get more
    practice along the way, but gathering a little more familiarity with either your
    IDE or the *javac* and *java* commands now will help as you read the next several
    chapters.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你的第一个编程练习，^([3](ch02.html#id817)) 创建一个`GoodbyeJava`类，它的功能与第一个HelloJava程序一样，只是显示“Goodbye,
    Java!”的消息而已。尝试命令行版本或图形版本——或两者都试试！随意复制原始程序的尽可能多的部分。记得编译并运行你的`GoodbyeJava`类，以帮助练习执行Java应用程序的过程。在接下来的几章中，你肯定会得到更多的练习，但是现在更多地熟悉你的IDE或者*javac*和*java*命令将有助于你阅读接下来的几章。
- en: ^([1](ch02.html#id787-marker)) The terms *parameter* and *argument* often get
    used interchangeably. That’s mostly fine, but technically you provide parameters
    with a type and a name when defining methods or constructors. You supply arguments
    to fill those parameters when you call the method or constructor.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch02.html#id787-marker)) *参数*和*参数*这两个术语经常被交替使用。这大多数情况下都没问题，但从技术上讲，当定义方法或构造函数时，你提供参数的类型和名称。在调用方法或构造函数时，你提供参数来填充这些参数。
- en: ^([2](ch02.html#id805-marker)) Event handling in Java 1.0 was a very different
    story. Early on, Java did not have a notion of event listeners, and all event
    handling happened by overriding methods in base GUI classes. This was inefficient
    and led to poor design, with a proliferation of highly specialized components.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch02.html#id805-marker)) Java 1.0中的事件处理是一个完全不同的故事。在早期，Java没有事件监听器的概念，所有的事件处理都是通过覆盖基础GUI类中的方法来完成的。这种做法效率低下，导致设计不佳，高度专业化的组件层出不穷。
- en: ^([3](ch02.html#id817-marker)) You can find the solutions to the programming
    challenges from each chapter in the *exercises* folder of the source code. [Appendix A](app01.html#learnjava6-APP-A)
    contains details on downloading and using the source code. [Appendix B](app02.html#learnjava6-APP-B)
    contains answers to the end-of-chapter questions as well as hints on code solutions
    for each chapter.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch02.html#id817-marker)) 你可以在源代码的*exercises*文件夹中找到每章编程挑战的解决方案。 [附录 A](app01.html#learnjava6-APP-A)
    包含了关于下载和使用源代码的详细信息。 [附录 B](app02.html#learnjava6-APP-B) 包含了每章末尾问题的答案以及对每章代码解决方案的提示。
