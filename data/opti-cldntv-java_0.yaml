- en: Chapter 1\. Optimization and Performance Defined
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章 优化与性能定义
- en: Optimizing the performance of Java (or any other sort of code) is often seen
    as a Dark Art. There’s a mystique about performance analysis—it’s commonly viewed
    as a craft practiced by the “lone hacker, who is tortured and deep thinking” (one
    of Hollywood’s favorite tropes about computers and the people who operate them).
    The image is one of a single individual who can see deeply into a system and come
    up with a magic solution that makes the system work faster.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 优化Java（或任何其他类型的代码）的性能通常被视为黑魔法。关于性能分析有一种神秘感——它通常被视为一种由“独行侠黑客，思考深刻”的技艺（好莱坞对计算机及其操作者最喜欢的题材之一）。这种形象是一个能深入了解系统并提出魔法解决方案使系统更快运行的个人形象。
- en: This image is often coupled with the unfortunate (but all-too-common) situation
    where performance is a second-class concern of the software teams. This sets up
    a scenario where analysis is only done once the system is already in trouble,
    and so needs a performance “hero” to save it. The reality, however, is a little
    different.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况经常伴随着不幸的（但却太常见）情况，即性能成为软件团队的次要关注点。这种情况造成了一个场景，即只有在系统陷入困境时才进行分析，因此需要一个性能“英雄”来拯救它。然而，现实却有些不同。
- en: The truth is that performance analysis is a weird blend of hard empiricism and
    squishy human psychology. What matters is, at one and the same time, the absolute
    numbers of observable metrics and how the end users and stakeholders *feel* about
    them. The resolution of this apparent paradox is the subject of the rest of this
    book.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 真相是，性能分析是一种奇怪的硬经验主义和软的人类心理学的结合体。重要的是，同时关注可观测指标的绝对数值以及最终用户和利益相关者的感受。解决这一明显悖论的方式是本书其余部分的主题。
- en: Since the publication of the First Edition, this situation has only sharpened.
    As more and more workloads move into the cloud, and as systems become ever-more
    complicated, the strange brew that combines very different factors has become
    even more important and prevalent. The “domain of concern” that an engineer who
    cares about performance needs to operate in has continued to broaden.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 自第一版出版以来，这种情况变得更加尖锐。随着越来越多的工作负载转移到云中，并且系统变得越来越复杂，将非常不同的因素结合在一起的奇怪混合物变得更加重要和普遍。关注性能的工程师需要操作的“关注领域”继续扩展。
- en: This is because production systems have become even more complicated. More of
    them now have aspects of distributed systems to consider in addition to the performance
    of individual application processes. As system architectures become larger and
    more complex, the number of engineers who must concern themselves with performance
    has also increased.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为生产系统变得更加复杂。现在更多的系统除了要考虑单个应用程序进程的性能外，还具有分布式系统的方面。随着系统架构变得更大更复杂，必须关注性能的工程师的数量也在增加。
- en: 'The new edition of this book responds to these changes in our industry by providing
    four things:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的新版本通过提供四个内容来回应我们行业中的这些变化：
- en: A necessary deep-dive on the performance of application code running within
    a single-JVM
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要深入探讨单个JVM内运行的应用代码的性能
- en: A discussion of JVM internals
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JVM内部的讨论
- en: Details of how the modern cloud stack interacts with Java / JVM applications
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代云堆栈与Java/JVM应用程序的互动细节
- en: A first look at the behavior of Java applications running on a cluster in a
    cloud environment
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首次查看在云环境中运行的Java应用程序集群行为
- en: In this chapter, we will get going by setting the stage with some definitions
    and establishing a framework for *how* we talk about performance—​starting with
    some problems and pitfalls that plague many discussions of Java performance.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过一些定义来开始，建立一个关于性能讨论的框架——从一些问题和常见的Java性能讨论陷阱开始。
- en: Java Performance—The Wrong Way
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java性能——错误的方式
- en: For many years, one of the top three hits on Google for “Java performance tuning”
    was an article from 1997–8, which had been ingested into the index very early
    in Google’s history. The page had presumably stayed close to the top because its
    initial ranking served to actively drive traffic to it, creating a feedback loop.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，“Java性能调优”在Google的前三大热门搜索中之一是一篇来自1997-1998年的文章，这篇文章早在Google历史早期就被纳入了索引。这篇页面显然一直保持在前列，因为其初始排名积极地吸引流量，从而形成了一个反馈循环。
- en: The page housed advice that was completely out of date, no longer true, and
    in many cases detrimental to applications. However, its favored position in the
    search engine results caused many, many developers to be exposed to terrible advice.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 页面上的建议完全过时，不再正确，并且在许多情况下对应用程序有害。然而，它在搜索引擎结果中的优势位置导致许多开发人员接受了糟糕的建议。
- en: For example, very early versions of Java had terrible method dispatch performance.
    As a workaround, some Java developers advocated avoiding small methods and instead
    writing monolithic methods. Of course, over time, the performance of virtual dispatch
    greatly improved.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，早期版本的 Java 存在糟糕的方法调度性能。作为解决方法，一些 Java 开发人员主张避免小方法，而是编写单块方法。当然，随着时间的推移，虚拟分派的性能显著改善。
- en: Not only that, but with modern JVM technologies (especially automatic managed
    inlining), virtual dispatch has now been eliminated at a large number—​perhaps
    even the majority—​of call sites. Code that followed the “lump everything into
    one method” advice is now at a substantial disadvantage, as it is very unfriendly
    to modern Just-in-Time (JIT) compilers.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅如此，但是通过现代 JVM 技术（特别是自动管理的内联），在大量——甚至是多数——调用站点上，虚拟分派现在已经被消除了。遵循“将所有内容整合到一个方法中”的建议的代码现在处于明显的劣势，因为对现代即时编译器（JIT）非常不友好。
- en: There’s no way of knowing how much damage was done to the performance of applications
    that were subjected to the bad advice, but this case neatly demonstrates the dangers
    of not using a quantitative and verifiable approach to performance. It also provides
    yet another excellent example of why you shouldn’t believe everything you read
    on the internet.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法知道应用程序的性能受到了多大程度的损害，但这个案例清楚地展示了不使用定量和可验证的方法来处理性能的危险。这也再次非常好地说明了为什么不应该相信互联网上的所有内容。
- en: Note
  id: totrans-18
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The execution speed of Java code is highly dynamic and fundamentally depends
    on the underlying Java Virtual Machine. An old piece of Java code may well execute
    faster on a more recent JVM, even without recompiling the Java source code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Java 代码的执行速度非常动态，基本上取决于底层的 Java 虚拟机。即使是一段老旧的 Java 代码，在更新的 JVM 上也可能会执行得更快，即使没有重新编译
    Java 源代码。
- en: 'As you might imagine, for this reason (and others we will discuss later) this
    book is not a cookbook of performance tips to apply to your code. Instead, we
    focus on a range of aspects that come together to produce good performance engineering:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想象，出于这个原因（以及我们稍后将讨论的其他原因），这本书不是性能技巧的烹饪书，适用于您的代码。相反，我们专注于一系列因素，这些因素共同作用以产生良好的性能工程：
- en: Performance methodology within the overall software lifecycle
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整个软件生命周期内的性能方法论
- en: Theory of testing as applied to performance
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试理论在性能上的应用
- en: Measurement, statistics, and tooling
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量、统计和工具
- en: Analysis skills (both systems and data)
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析技能（系统和数据）
- en: Underlying technology and mechanisms
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 底层技术和机制
- en: By bringing these aspects together, the intention is to help you build an understanding
    that can be broadly applied to whatever performance circumstances that you may
    face.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将这些方面综合起来，意图是帮助您建立一个可以广泛应用于您可能面对的各种性能情况的理解。
- en: Later in the book, we will introduce some heuristics and code-level techniques
    for optimization, but these all come with caveats and tradeoffs that the developer
    should be aware of before using them.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 书中稍后我们将介绍一些启发式和代码级优化技术，但这些都伴随着开发人员在使用之前应该了解的注意事项和权衡。
- en: Tip
  id: totrans-28
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Please do not skip ahead to those sections and start applying the techniques
    detailed without properly understanding the context in which the advice is given.
    All of these techniques are capable of doing more harm than good if you lack a
    proper understanding of how they should be applied.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 请不要跳过这些部分，并开始应用详细描述的技术，而不正确地理解给出建议的背景。如果缺乏正确的应用理解，所有这些技术都可能带来更多的伤害而不是好处。
- en: 'In general, there are:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，有：
- en: No magic “go faster” switches for the JVM
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JVM 没有魔法“加速”开关
- en: No “tips and tricks” to make Java run faster
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有“技巧和窍门”可以让 Java 运行更快
- en: No secret algorithms that have been hidden from you
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有被隐藏的秘密算法
- en: As we explore our subject, we will discuss these misconceptions in more detail,
    along with some other common mistakes that developers often make when approaching
    Java performance analysis and related issues.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们探索我们的主题时，我们将详细讨论这些误解，以及开发人员在接近 Java 性能分析和相关问题时经常犯的一些其他常见错误。
- en: 'Our “No Tips and Tricks” approach extends to our coverage of cloud techniques.
    You will not find virtually any discussion of the vendor-specific techniques present
    on the cloud hyperscalars (AWS, Azure, GCP, OpenShift, and so on). This is for
    two main reasons:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的“无提示和技巧”方法延伸到了我们对云技术的覆盖。你几乎找不到关于云超大规模（AWS、Azure、GCP、OpenShift等）上的特定供应商技术的讨论。这有两个主要原因：
- en: It would expand the scope of the book and make it unmanageably long
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这会扩展书籍的范围，并使其变得难以管理。
- en: It is impossible to stay current with such a large topic area
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在如此广阔的主题领域中保持最新是不可能的。
- en: The progress made by teams working on those products would make any detailed
    information about them out-of-date by the time the book is published. So, instead,
    in the cloud chapters, we focus on fundamentals and patterns, which remain effective
    regardless of which hyperscalar your applications are deployed upon.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 那些产品开发团队的进展会使得任何关于它们的详细信息在书籍出版时都已经过时。因此，在云章节中，我们侧重于基础知识和模式，而这些无论应用程序部署在哪个超大规模云平台上都有效。
- en: Still here? Good. Then let’s talk about performance.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你还在这里？很好。那么让我们谈谈性能。
- en: Java Performance Overview
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java性能概述
- en: 'To understand why Java performance is the way that it is, let’s start by considering
    a classic quote from James Gosling, the creator of Java:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解为什么Java性能是这样的，让我们从考虑Java的创始人詹姆斯·高斯林的经典语录开始：
- en: Java is a blue collar language. It’s not PhD thesis material but a language
    for a job.^([1](ch01.xhtml#id93))
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Java是一门蓝领语言。它不是博士论文的材料，而是为了工作的语言。^([1](ch01.xhtml#id93))
- en: ''
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: James Gosling
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 詹姆斯·高斯林
- en: That is, Java has always been an extremely practical language. Its attitude
    to performance was initially that as long as the environment was *fast enough*,
    then raw performance could be sacrificed if developer productivity benefited.
    It was therefore not until relatively recently, with the increasing maturity and
    sophistication of JVMs such as HotSpot, that the Java environment became suitable
    for high-performance computing applications.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，Java一直是一门极其实用的语言。它最初对性能的态度是，只要环境足够*快*，那么如果开发者的生产力得到提升，就可以牺牲原始性能。因此，直到相对最近，随着HotSpot等JVM（如Java虚拟机）日益成熟和复杂，Java环境才适合高性能计算应用。
- en: This practicality manifests itself in many ways in the Java platform, but one
    of the most obvious is the use of *managed subsystems*. The idea is that the developer
    gives up some aspects of low-level control in exchange for not having to worry
    about some of the details of the capability under management.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实用性在Java平台上以多种方式显现，但其中最明显的之一是使用*管理子系统*。这个想法是，开发者放弃了低级控制的一些方面，换取不必担心管理能力的某些细节。
- en: The most obvious example of this is, of course, memory management. The JVM provides
    automatic memory management in the form of a pluggable *garbage collection* subsystem
    (usually referred to as GC), so that memory does not have to be manually tracked
    by the programmer.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最明显的例子当然是内存管理。JVM通过可插拔的*垃圾收集*子系统（通常称为GC）提供自动内存管理，这样程序员就不必手动跟踪内存。
- en: Note
  id: totrans-48
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Managed subsystems occur throughout the JVM and their existence introduces extra
    complexity into the runtime behavior of JVM applications.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 管理子系统遍布JVM的各个部分，并且它们的存在在JVM应用的运行时行为中引入了额外的复杂性。
- en: As we will discuss in the next section, the complex runtime behavior of JVM
    applications requires us to treat our applications as experiments under test.
    This leads us to think about the statistics of observed measurements, and here
    we make an unfortunate discovery.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在下一节讨论的那样，JVM应用的复杂运行时行为要求我们将应用视为正在测试的实验。这导致我们考虑观察测量的统计学，而在这里我们做出了一个不幸的发现。
- en: The observed performance measurements of JVM applications are very often not
    normally distributed. This means that elementary statistical techniques (especially
    *standard deviation* and *variance* for example) are ill-suited for handling results
    from JVM applications. This is because many basic statistics methods contain an
    implicit assumption about the normality of results distributions.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: JVM应用的观察性能测量很多时候不是正态分布的。这意味着基本的统计技术（尤其是*标准偏差*和*方差*等）不适合处理来自JVM应用的结果。这是因为许多基本的统计方法对结果分布的正态性有隐含的假设。
- en: One way to understand this is that for JVM applications outliers can be very
    significant—for a low-latency trading application, for example. This means that
    sampling of measurements is also problematic, as it can easily miss the exact
    events that have the most importance.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这一点的一种方法是，对于 JVM 应用程序来说，异常值可能非常重要—例如，对于低延迟交易应用程序。这意味着测量的抽样也是有问题的，因为很容易错过最重要的事件。
- en: Finally, a word of caution. It is very easy to be misled by Java performance
    measurements. The complexity of the environment means that it is very hard to
    isolate individual aspects of the system.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，警告一句。通过 Java 的性能测量很容易被误导。环境的复杂性意味着很难分离系统的各个方面。
- en: Measurement also has an overhead, and frequent sampling (or recording every
    result) can have an observable impact on the performance numbers being recorded.
    The nature of Java performance numbers requires a certain amount of statistical
    sophistication, and naive techniques frequently produce incorrect results when
    applied to Java/JVM applications.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 测量也会带来开销，频繁采样（或记录每个结果）可能会对记录的性能数字产生明显影响。Java 性能数字的本质需要一定的统计学技术，而天真的技术在应用于 Java/JVM
    应用程序时经常会产生错误结果。
- en: These concerns also resonate into the domain of cloud native applications. Automatic
    management of applications has very much become part of the cloud native experience—​especially
    with the rise of technologies such as Kubernetes. The need to balance the cost
    of collecting data with the need to collect enough to make conclusions is also
    an important architectural concern for cloud native apps—​we will have more to
    say about that in Chapter 10.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题也对云原生应用程序领域产生影响。自动管理应用程序已经成为云原生体验的一部分—特别是随着诸如 Kubernetes 等技术的兴起。在云原生应用程序的架构中，平衡数据收集成本和收集足够数据以得出结论的需要也非常重要—我们将在第10章进一步讨论这一点。
- en: Performance as an Experimental Science
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能作为一门实验科学
- en: Java/JVM software stacks are, like most modern software systems, very complex.
    In fact, due to the highly optimizing and adaptive nature of the JVM, production
    systems built on top of the JVM can have some subtle and intricate performance
    behavior. This complexity has been made possible by Moore’s Law and the unprecedented
    growth in hardware capability that it represents.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Java/JVM 软件堆栈，就像大多数现代软件系统一样，非常复杂。事实上，由于 JVM 的高度优化和自适应特性，建立在 JVM 之上的生产系统可能具有一些微妙而复杂的性能行为。这种复杂性得益于摩尔定律及其代表的硬件能力的前所未有的增长。
- en: The most amazing achievement of the computer software industry is its continuing
    cancellation of the steady and staggering gains made by the computer hardware
    industry.
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 计算机软件行业最令人惊讶的成就是其不断抵消计算机硬件行业所取得的稳定而惊人的进步。
- en: ''
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Henry Petroski (attr)
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 亨利·彼得罗斯基（归属性）
- en: While some software systems have squandered the historical gains of the industry,
    the JVM represents something of an engineering triumph. Since its inception in
    the late 1990s the JVM has developed into a very high-performance, general-purpose
    execution environment that puts those gains to very good use.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一些软件系统已经浪费了行业的历史收益，但 JVM 则代表了工程上的一种胜利。自从 1990 年代末问世以来，JVM 已经发展成为一个非常高性能的通用执行环境，充分利用了这些收益。
- en: The tradeoff, however, is that like any complex, high-performance system, the
    JVM requires a measure of skill and experience to get the absolute best out of
    it.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与任何复杂的高性能系统一样，JVM 需要一定的技能和经验才能发挥其最佳性能。
- en: A measurement not clearly defined is worse than useless.^([2](ch01.xhtml#id94))
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果目标没有明确定义，则测量就比没有用的还糟糕。^([2](ch01.xhtml#id94))
- en: ''
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Eli Goldratt
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[埃利·戈德拉特](https://en.wikipedia.org/wiki/Eliyahu_M._Goldratt)'
- en: 'JVM performance tuning is therefore a synthesis between technology, methodology,
    measurable quantities, and tools. Its aim is to effect measurable outputs in a
    manner desired by the owners or users of a system. In other words, performance
    is an experimental science—it achieves a desired result by:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: JVM 性能调优因此是技术、方法论、可测量数量和工具的综合体。它的目标是以系统的所有者或用户期望的方式产生可衡量的输出。换句话说，性能是一门实验科学—它通过以下方式实现期望的结果：
- en: Defining the desired outcome
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义期望的结果
- en: Measuring the existing system
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量现有系统
- en: Determining what is to be done to achieve the requirement
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定如何实现要求
- en: Undertaking an improvement exercise
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行改进练习
- en: Retesting
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新测试
- en: Determining whether the goal has been achieved
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定是否已经达到目标
- en: The process of defining and determining desired performance outcomes builds
    a set of quantitative objectives. It is important to establish what should be
    measured and record the objectives, which then form part of the project’s artifacts
    and deliverables. From this, we can see that performance analysis is based upon
    defining, and then achieving, nonfunctional requirements.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 确定和定义期望的性能结果的过程建立了一组定量目标。建立应该测量的内容并记录这些目标是重要的，这些目标随后成为项目成果和交付物的一部分。从中，我们可以看到性能分析是基于定义，然后实现非功能性需求。
- en: This process is, as has been previewed, not one of reading chicken entrails
    or another divination method. Instead, we rely upon statistics and an appropriate
    handling (and interpretation) of results.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这个过程并不是读取鸡肠或其他占卜方法的过程。相反，我们依靠统计数据和对结果的适当处理（和解释）。
- en: In this chapter, we discuss these techniques as they apply to a single JVM.
    In [Chapter 2](ch02.xhtml#pracjavaperf-CHP-2) we will introduce a primer on the
    basic statistical techniques that are required for accurate handling of data generated
    from a JVM performance analysis project. Later on, primarily in Chapter 10, we
    will discuss how these techniques generalize to a clustered application and give
    rise to the notion of Observability.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论这些技术如何应用于单个 JVM。在[第二章](ch02.xhtml#pracjavaperf-CHP-2)中，我们将介绍一些基本的统计技术，这些技术对于准确处理从
    JVM 性能分析项目中生成的数据是必需的。稍后，主要在第 10 章中，我们将讨论这些技术如何推广到一个集群应用程序，并产生可观察性的概念。
- en: It is important to recognize that, for many real-world projects, a more sophisticated
    understanding of data and statistics will undoubtedly be required. You are therefore
    encouraged to view the statistical techniques found in this book as a starting
    point, rather than a definitive statement.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 需要认识到，对于许多现实世界的项目来说，对数据和统计的更复杂的理解无疑是必需的。因此，建议将本书中找到的统计技术视为一个起点，而不是一个明确的陈述。
- en: A Taxonomy for Performance
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能的分类
- en: In this section, we introduce some basic observable quantities for performance
    analysis. These provide a vocabulary for performance analysis and will allow you
    to frame the objectives of a tuning project in quantitative terms. These objectives
    are the nonfunctional requirements that define performance goals. Note that these
    quantities are not necessarily directly available in all cases, and some may require
    some work to obtain from the raw numbers obtained from our system.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了一些性能分析的基本可观察量。这些提供了性能分析的词汇，并将允许您以定量术语框定调整项目的目标。这些目标是定义性能目标的非功能性要求。请注意，这些量并不一定在所有情况下直接可用，有些可能需要一些工作才能从我们系统得到的原始数据中获得。
- en: 'One common basic set of performance observables is:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的基本性能可观察集是：
- en: Throughput
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 吞吐量
- en: Latency
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延迟
- en: Capacity
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容量
- en: Utilization
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用率
- en: Efficiency
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 效率
- en: Scalability
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可伸缩性
- en: Degradation
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 退化
- en: We will briefly discuss each in turn. Note that for most performance projects,
    not every metric will be optimized simultaneously. The case of only a few metrics
    being improved in a single performance iteration is far more common, and this
    may be as many as can be tuned at once. In real-world projects, it may well be
    the case that optimizing one metric comes at the detriment of another metric or
    group of metrics.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将依次简要讨论每个问题。请注意，对于大多数性能项目，不会同时优化每个指标。在单个性能迭代中仅改善少数指标的情况更为常见，这可能是可以同时调整的指标数量。在现实世界的项目中，优化一个指标很可能会损害另一个指标或一组指标。
- en: Throughput
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 吞吐量
- en: Throughput is a metric that represents the rate of work a system or subsystem
    can perform. This is usually expressed as number of units of work in some time
    period. For example, we might be interested in how many transactions per second
    a system can execute.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 吞吐量是一个表示系统或子系统可以执行的工作速率的指标。这通常表示为某个时间段内的工作单位数量。例如，我们可能对系统每秒执行多少个事务感兴趣。
- en: For the throughput number to be meaningful in a real performance exercise, it
    should include a description of the reference platform it was obtained on. For
    example, the hardware spec, OS, and software stack are all relevant to throughput,
    as is whether the system under test is a single server or a cluster. In addition,
    transactions (or units of work) should be the same between tests. Essentially,
    we should seek to ensure that the workload for throughput tests is kept consistent
    between runs.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在真实的性能测试中，吞吐量数值的意义在于应包括所获得的参考平台的描述。例如，硬件规格、操作系统和软件堆栈都与吞吐量相关，以及测试系统是单服务器还是集群。此外，事务（或工作单位）在测试之间应保持一致。基本上，我们应该努力确保吞吐量测试的工作负载在运行之间保持一致。
- en: Performance metrics are sometimes explained via metaphors that evoke plumbing.
    If we adopt this view point then, if a water pipe can produce 100 liters per second,
    then the volume produced in 1 second (100 liters) is the throughput. Note that
    this value is a function of the speed of the water and the cross-sectional area
    of the pipe.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有时会通过引用管道等隐喻来解释性能指标。如果我们采纳这个观点，那么如果水管每秒可以产生100升水，则在1秒钟内产生的体积（100升）就是吞吐量。请注意，此值取决于水的速度和管道的横截面积。
- en: Latency
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 延迟
- en: To continue the metaphor of the previous section—​latency is how long it takes
    a given liter to traverse the pipe. This is a function of both the length of the
    pipe and how quickly the water is moving through it. It is not, however, a function
    of the diameter of the pipe.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 继续上一节的隐喻，延迟是指给定升数通过管道的时间。这取决于管道的长度和水流速度。然而，它与管道直径无关。
- en: In software, latency is normally quoted as an end-to-end time—​the time taken
    to process a single transaction and see a result. It is dependent on workload,
    so a common approach is to produce a graph showing latency as a function of increasing
    workload. We will see an example of this type of graph in [“Reading Performance
    Graphs”](#pracjavaperf-CHP-1-SECT-5).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件中，延迟通常被引用为端到端时间，即处理单个事务并查看结果所需的时间。它取决于工作负载，因此常见的方法是生成一个显示延迟作为增加工作负载函数的图表。我们将在[“阅读性能图表”](#pracjavaperf-CHP-1-SECT-5)中看到这种类型的图表示例。
- en: Capacity
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容量
- en: The capacity is the amount of work parallelism a system possesses—that is, the
    number of units of work (e.g., transactions) that can be simultaneously ongoing
    in the system.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 容量是系统拥有的工作并行性的量度，即可以同时进行的工作单位（例如，事务）的数量。
- en: Capacity is obviously related to throughput, and we should expect that as the
    concurrent load on a system increases, throughput (and latency) will be affected.
    For this reason, capacity is usually quoted as the processing available at a given
    value of latency or throughput.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 容量显然与吞吐量相关，我们应该期望随着系统的并发负载增加，吞吐量（和延迟）会受到影响。因此，通常会引用在给定延迟或吞吐量值时可用的处理能力。
- en: Utilization
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用率
- en: One of the most common performance analysis tasks is to achieve efficient use
    of a system’s resources. Ideally, CPUs should be used for handling units of work,
    rather than being idle (or spending time handling OS or other housekeeping tasks).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 性能分析中最常见的任务之一是实现系统资源的有效利用。理想情况下，CPU应该用于处理工作单元，而不是空闲（或者花时间处理操作系统或其他管理任务）。
- en: Depending on the workload, there can be a huge difference between the utilization
    levels of different resources. For example, a computation-intensive workload (such
    as graphics processing or encryption) may be running at close to 100% CPU but
    only be using a small percentage of available memory.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 根据工作负载的不同，不同资源的利用率水平可能存在巨大差异。例如，计算密集型工作负载（如图形处理或加密）可能接近100%的CPU使用率，但只使用了少量可用内存。
- en: As well as CPU, other resources types—​such as network, memory, and (sometimes)
    the storage I/O subsystem—​are becoming important resources to manage in cloud-native
    applications. For many applications, more memory than CPU is “wasted”, and for
    many microservices network traffic has become the real bottleneck.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 除了CPU之外，其他类型的资源，如网络、内存和（有时候）存储I/O子系统，在云原生应用中成为管理的重要资源。对于许多应用程序来说，内存的浪费比CPU更多，对于许多微服务来说，网络流量已成为真正的瓶颈。
- en: Efficiency
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 效率
- en: Dividing the throughput of a system by the utilized resources gives a measure
    of the overall efficiency of the system. Intuitively, this makes sense, as requiring
    more resources to produce the same throughput is one useful definition of being
    less efficient.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 将系统的吞吐量除以利用的资源可以衡量系统的整体效率。直观地讲，这是有道理的，因为为了产生相同的吞吐量而需要更多资源是对效率低下的一个有用定义。
- en: It is also possible, when one is dealing with larger systems, to use a form
    of cost accounting to measure efficiency. If solution A has a total cost of ownership
    (TCO) twice that of solution B for the same throughput then it is, clearly, half
    as efficient.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 处理较大系统时，也可以使用一种成本会计来衡量效率。如果解决方案A的总拥有成本（TCO）是解决方案B的两倍，但吞吐量相同，则显然效率是后者的一半。
- en: Scalability
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可扩展性
- en: The throughput or capacity of a system of course depends upon the resources
    available for processing. The scalability of a system or application can be defined
    in several ways—​but one useful one is as the change in throughput as resources
    are added. The holy grail of system scalability is to have throughput change exactly
    in step with resources.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一个系统的吞吐量或容量当然取决于可用于处理的资源。系统或应用程序的可扩展性可以用多种方式来定义，但其中一个有用的方式是随着资源的增加而吞吐量的变化。系统可扩展性的圣杯是让吞吐量与资源的变化完全同步。
- en: Consider a system based on a cluster of servers. If the cluster is expanded,
    for example, by doubling in size, then what throughput can be achieved? If the
    new cluster can handle twice the volume of transactions, then the system is exhibiting
    “perfect linear scaling.” This is very difficult to achieve in practice, especially
    over a wide range of possible loads.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个基于服务器集群的系统。例如，如果扩展集群，使其大小加倍，那么可以实现什么样的吞吐量？如果新的集群能处理两倍于原来的交易量，那么系统就表现出“完美的线性扩展”。这在实践中非常难以实现，尤其是在可能的负载范围很广的情况下。
- en: System scalability is dependent upon a number of factors, and is not normally
    a simple linear relationship. It is very common for a system to scale close to
    linearly for some range of resources, but then at higher loads to encounter some
    limitation that prevents perfect scaling.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 系统可扩展性取决于许多因素，并且通常不是简单的线性关系。一个系统在某些资源范围内通常会接近线性地扩展，但是在更高的负载下会遇到某种限制，阻止了完美的扩展。
- en: Degradation
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 退化
- en: If we increase the load on a system, either by increasing the rate at which
    requests arrive or the size of the individual requests, then we may see a change
    in the observed latency and/or throughput.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们增加系统的负载，无论是增加请求到达的速率还是增加单个请求的大小，都可能导致观察到的延迟和/或吞吐量发生变化。
- en: Note that this change is dependent on utilization. If the system is underutilized,
    then there should be some slack before observables change, but if resources are
    fully utilized then we would expect to see throughput stop increasing, or latency
    increase. These changes are usually called the degradation of the system under
    additional load.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这种变化取决于利用率。如果系统利用率不足，那么在观察值发生变化之前应该有一些余地，但如果资源已被充分利用，则我们预期会看到吞吐量停止增加或延迟增加。这些变化通常称为系统在额外负载下的退化。
- en: Correlations Between the Observables
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 观察值之间的相关性
- en: The behavior of the various performance observables is usually connected in
    some manner. The details of this connection will depend upon whether the system
    is running at peak utility. For example, in general, the utilization will change
    as the load on a system increases. However, if the system is underutilized, then
    increasing load may not appreciably increase utilization. Conversely, if the system
    is already stressed, then the effect of increasing load may be felt in another
    observable.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 各种性能观察指标的行为通常以某种方式相互关联。这种连接的细节取决于系统是否运行在峰值效用。例如，通常情况下，当系统负载增加时，利用率会发生变化。然而，如果系统利用率不足，则增加负载可能不会明显增加利用率。相反，如果系统已经受到压力，则增加负载的影响可能会体现在其他观察值中。
- en: As another example, scalability and degradation both represent the change in
    behavior of a system as more load is added. For scalability, as the load is increased,
    so are available resources, and the central question is whether the system can
    make use of them. On the other hand, if load is added but additional resources
    are not provided, degradation of some performance observable (e.g., latency) is
    the expected outcome.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，可扩展性和退化都代表系统在增加负载时行为的变化。对于可扩展性而言，随着负载的增加，可用资源也在增加，核心问题是系统是否能够利用它们。另一方面，如果增加负载但未提供额外资源，则某些性能观察值（例如延迟）的退化是预期的结果。
- en: Note
  id: totrans-115
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In rare cases, additional load can cause counterintuitive results. For example,
    if the change in load causes some part of the system to switch to a more resource-intensive
    but higher-performance mode, then the overall effect can be to reduce latency,
    even though more requests are being received.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在罕见情况下，额外的负载可能导致出乎意料的结果。例如，如果负载的变化导致系统的某部分切换到资源消耗更多但性能更高的模式，则总体效果可能是降低延迟，即使接收到更多请求。
- en: To take one example, in Chapter 6 we will discuss HotSpot’s JIT compiler in
    detail. To be considered eligible for JIT compilation, a method has to be executed
    in interpreted mode “sufficiently frequently.” So it is possible at low load to
    have key methods stuck in interpreted mode, but for those to become eligible for
    compilation at higher loads due to increased calling frequency on the methods.
    This causes later calls to the same method to run much, much faster than earlier
    executions.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，在第6章中我们将详细讨论HotSpot的JIT编译器。要考虑作为JIT编译的候选方法，“必须在解释模式下执行足够频繁”。因此，在低负载下，关键方法可能会停留在解释模式，但随着方法调用频率的增加，这些方法可能在更高负载时变得适合编译。这导致对同一方法的后续调用比早期执行快得多。
- en: Different workloads can have very different characteristics. For example, a
    trade on the financial markets, viewed end to end, may have an execution time
    (i.e., latency) of hours or even days. However, millions of them may be in progress
    at a major bank at any given time. Thus, the capacity of the system is very large,
    but the latency is also large.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的工作负载可能具有非常不同的特性。例如，金融市场上的一项交易从开始到结束可能需要几小时甚至几天的执行时间（即延迟）。然而，在任何给定时间，一家主要银行可能有数百万个交易正在进行。因此，系统的容量非常大，但延迟也很大。
- en: However, let’s consider only a single subsystem within the bank. The matching
    of a buyer and a seller (which is essentially the parties agreeing on a price)
    is known as *order matching*. This individual subsystem may have only hundreds
    of pending orders at any given time, but the latency from order acceptance to
    completed match may be as little as 1 millisecond (or even less in the case of
    “low-latency” trading).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，让我们只考虑银行内的单个子系统。买方和卖方的匹配（本质上是各方就价格达成一致）被称为*订单匹配*。这个单独的子系统在任何给定时间可能只有数百个待处理订单，但是从接受订单到完成匹配的延迟可能只有1毫秒（或者在“低延迟”交易的情况下甚至更少）。
- en: In this section we have met the most frequently encountered performance observables.
    Occasionally slightly different definitions, or even different metrics, are used,
    but in most cases these will be the basic system numbers that will normally be
    used to guide performance tuning, and act as a taxonomy for discussing the performance
    of systems of interest.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们遇到了最常见的性能观察值。偶尔会使用稍有不同的定义，甚至不同的指标，但在大多数情况下，这些将是通常用来指导性能调整的基本系统数字，并作为讨论感兴趣系统性能的分类法。
- en: Reading Performance Graphs
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阅读性能图表
- en: To conclude this chapter, let’s look at some common patterns of behavior that
    occur in performance tests. We will explore these by looking at graphs of real
    observables, and we will encounter many other examples of graphs of our data as
    we proceed.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 总结本章，让我们来看看在性能测试中经常出现的一些行为模式。我们将通过查看实际可观察的图表来探索这些模式，随着进一步的进行，我们还将遇到许多其他数据图表的例子。
- en: The graph in [Figure 1-1](#pracjavaperf-CHP-1-FIG-1) shows sudden, unexpected
    degradation of performance (in this case, latency) under increasing load—commonly
    called a *performance elbow*.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图中的[图 1-1](#pracjavaperf-CHP-1-FIG-1)显示了在增加负载时（通常称为*性能拐点*）性能（在本例中是延迟）突然而意外的下降。
- en: '![ocnj2 0101](assets/ocnj2_0101.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![ocnj2 0101](assets/ocnj2_0101.png)'
- en: Figure 1-1\. A performance elbow
  id: totrans-125
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-1\. 性能拐点
- en: By contrast, [Figure 1-2](#pracjavaperf-CHP-1-FIG-2) shows the much happier
    case of throughput scaling almost linearly as machines are added to a cluster.
    This is close to ideal behavior, and is only likely to be achieved in extremely
    favorable circumstances—e.g., scaling a stateless protocol with no need for session
    affinity with a single server.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，[图 1-2](#pracjavaperf-CHP-1-FIG-2)展示了通过向集群添加机器来几乎线性扩展的吞吐量的更加愉快的情况。这接近理想行为，并且只有在极其有利的情况下才可能实现——例如，使用单个服务器扩展无需会话亲和性的无状态协议。
- en: '![ocnj2 0102](assets/ocnj2_0102.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![ocnj2 0102](assets/ocnj2_0102.png)'
- en: Figure 1-2\. Near-linear scaling
  id: totrans-128
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-2\. 近线性扩展
- en: In Chapter 13 we will meet Amdahl’s Law, named for the famous computer scientist
    (and “father of the mainframe”) Gene Amdahl of IBM. [Figure 1-3](#pracjavaperf-CHP-1-FIG-3)
    shows a graphical representation of his fundamental constraint on scalability;
    it shows the maximum possible speedup as a function of the number of processors
    devoted to the task.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在第13章中，我们将会遇到阿姆达尔定律，这个定律以著名计算机科学家（“大型机之父”）IBM 的基因·阿姆达尔命名。[图 1-3](#pracjavaperf-CHP-1-FIG-3)
    展示了他关于可伸缩性的基本限制的图形表示；它展示了作为处理器数量函数的最大可能加速度。
- en: '![ocnj2 0103](assets/ocnj2_0103.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![ocnj2 0103](assets/ocnj2_0103.png)'
- en: Figure 1-3\. Amdahl’s Law
  id: totrans-131
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-3\. 阿姆达尔定律
- en: 'We display three cases: where the underlying task is 75%, 90%, and 95% parallelizable.
    This clearly shows that whenever the workload has any piece at all that must be
    performed serially, linear scalability is impossible, and there are strict limits
    on how much scalability can be achieved. This justifies the commentary around
    [Figure 1-2](#pracjavaperf-CHP-1-FIG-2)—even in the best cases linear scalability
    is all but impossible to achieve.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们展示了三种情况：底层任务的可并行性分别为75%、90%和95%。这清楚地表明，每当工作负载有必须串行执行的部分时，线性可伸缩性就不可能存在，并且对可实现的可伸缩性有严格的限制。这证实了对[图 1-2](#pracjavaperf-CHP-1-FIG-2)的评论——即使在最好的情况下，线性可伸缩性几乎不可能实现。
- en: The limits imposed by Amdahl’s Law are surprisingly restrictive. Note in particular
    that the x-axis of the graph is logarithmic, and so even with an algorithm that
    is 95% parallelizable (and thus only 5% serial), 32 processors are needed for
    a factor-of-12 speedup. Even worse, no matter how many cores are used, the maximum
    speedup is only a factor of 20 for that algorithm. In practice, many algorithms
    are far more than 5% serial, and so have a more constrained maximum possible speedup.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 阿姆达尔定律施加的限制令人惊讶地严格。特别注意图的 x 轴是对数刻度，因此即使是一个95%可并行化的算法（因此只有5%串行化），也需要32个处理器才能实现12倍的加速。更糟糕的是，无论使用多少核心，该算法的最大加速度仅为20倍。在实践中，许多算法的串行部分远远超过5%，因此其最大可能的加速度更为受限。
- en: Another common source of performance graphs in software systems is memory utilization.
    As we will see in Chapter 4, the underlying technology in the JVM’s garbage collection
    subsystem naturally gives rise to a “sawtooth” pattern of memory used for healthy
    applications that aren’t under stress. We can see an example in [Figure 1-4](#pracjavaperf-CHP-1-FIG-4)
    --which is a close-up of a screenshot from the Mission Control tool (JMC) provided
    by Eclipse Adoptium.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 软件系统中性能图的另一个常见来源是内存利用率。正如我们将在第四章中看到的那样，JVM 的垃圾收集子系统中的底层技术自然地导致了健康应用程序中内存使用的“锯齿”模式。我们可以在[图 1-4](#pracjavaperf-CHP-1-FIG-4)中看到一个示例——这是来自由
    Eclipse Adoptium 提供的 Mission Control 工具（JMC）的截图的近距离观察。
- en: '![ocnj2 0104](assets/ocnj2_0104.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![ocnj2 0104](assets/ocnj2_0104.png)'
- en: Figure 1-4\. Healthy memory usage
  id: totrans-136
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-4\. 健康的内存使用
- en: One key performance metric for JVM is the allocation rate—​effectively how quickly
    it can create new objects (in bytes per second). We will have a great deal to
    say about this aspect of JVM performance in Chapter 4 and Chapter 5.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: JVM 的一个关键性能指标是分配率——即它可以多快地创建新对象（以字节每秒计）。我们将在第四章和第五章详细讨论 JVM 性能的这一方面。
- en: In [Figure 1-5](#pracjavaperf-CHP-1-FIG-5), we can see a zoomed-in view of allocation
    rate, also captured from JMC. This has been generated from a benchmark program
    that is deliberately stressing the JVM’s memory subsystem—​we have tried to make
    the JVM achieve 8GiB/s of allocation, but as we can see, this is beyond the capability
    of the hardware, and instead the maximum allocation rate of the system is between
    4 and 5GiB/s.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 1-5](#pracjavaperf-CHP-1-FIG-5)中，我们可以看到分配率的放大视图，也是从 JMC 捕获的。这是从一个故意对 JVM
    内存子系统施加压力的基准程序生成的。我们尝试让 JVM 达到每秒8GiB的分配，但正如我们所见，这超出了硬件的能力，因此系统的最大分配率在4到5GiB/s之间。
- en: '![ocnj2 0105](assets/ocnj2_0105.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![ocnj2 0105](assets/ocnj2_0105.png)'
- en: Figure 1-5\. Sample problematic allocation rate
  id: totrans-140
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-5\. 样本问题的分配率
- en: Note that tapped-out allocation is a different problem to the system having
    a resource leak. In that case, it is common for it to manifest in a manner like
    that shown in [Figure 1-6](#pracjavaperf-CHP-1-FIG-6), where an observable (in
    this case latency) slowly degrades as the load is ramped up, before hitting an
    inflection point where the system rapidly degrades.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，分配达到极限与系统存在资源泄漏是不同的问题。在这种情况下，它常常表现为类似于[图1-6](#pracjavaperf-CHP-1-FIG-6)所示的方式，其中一个可观察指标（在本例中是延迟）随着负载增加而逐渐恶化，然后在达到一个拐点后系统迅速恶化。
- en: '![ocnj2 0106](assets/ocnj2_0106.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![ocnj2 0106](assets/ocnj2_0106.png)'
- en: Figure 1-6\. Degrading latency under higher load
  id: totrans-143
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-6\. 在高负载下延迟恶化
- en: Let’s move on to discuss some extra things to consider when working with cloud
    systems.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续讨论一些在处理云系统时需要考虑的额外事项。
- en: Performance in Cloud Systems
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云系统性能
- en: Modern cloud systems are nearly always distributed systems in that they are
    comprised of a cluster of nodes (JVM instances) interoperating via shared network
    resources. This means that, in addition to all the complexity of single-node systems,
    there is another level of complexity that must be addressed.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现代云系统几乎总是由节点集群（JVM实例）通过共享网络资源进行交互操作的分布式系统。这意味着除了单节点系统的所有复杂性外，还必须解决另一个层次的复杂性。
- en: 'Operators of distributed systems have to think about things such as:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式系统的运营人员必须考虑以下问题：
- en: How is work shared out among the nodes in the cluster?
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作如何在集群中的节点之间分配？
- en: How do we roll out a new version of the software to the cluster (or new config)?
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何将软件的新版本（或新配置）推广到集群？
- en: What happens when a node leaves the cluster?
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当节点离开集群时会发生什么？
- en: What happens when a new node joins the cluster?
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当新节点加入集群时会发生什么？
- en: What happens if the new node is misconfigured in some way?
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果新节点在某些方面配置错误会发生什么？
- en: What happens if the new node behaves differently in some way, compared to the
    rest of the cluster?
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果新节点在某些方面与集群中的其余部分行为不同会发生什么？
- en: What happens if there is a problem with the code that controls the cluster itself?
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果控制集群本身的代码出现问题会怎样？
- en: What happens if there is a catastrophic failure of the entire cluster, or some
    infrastructure that it depends upon?
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果整个集群或其依赖的某些基础设施发生灾难性故障会怎样？
- en: What happens if a component in the infrastructure the cluster depends upon is
    a limited resource and becomes a bottleneck to scalability?
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果基础设施中支持集群的某个组件是有限资源并且成为可扩展性的瓶颈会怎么样？
- en: These concerns, which we will explore fully later in the book, have a major
    impact on how cloud systems behave. They affect the key performance observables
    such as throughput, latency, efficiency and utilization.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题我们稍后会在本书中全面探讨，它们对云系统的行为有重大影响。它们影响关键性能指标，如吞吐量、延迟、效率和利用率。
- en: Not only that, but there are two very important aspects—​which differ from the
    single-JVM case—​that may not be obvious at first sight to newcomers to cloud
    systems. First is that many possible impacts are caused by the internal behavior
    of a cluster, which may be opaque to the performance engineer.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅如此，还有两个非常重要的方面——与单个JVM情况不同——可能对初接触云系统的新手不明显。第一个是由集群的内部行为引起的许多可能影响，这对性能工程师可能是不透明的。
- en: We will discuss this in detail in Chapter 10 when we tackle the topic of Observability
    in modern systems, and how to implement solutions to this visibility problem.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在第10章详细讨论现代系统中的可观察性及如何实施解决方案以解决这一可见性问题时，我们会深入探讨这一点。
- en: The second is that the efficiency and utilization of how a service uses cloud
    providers has a direct effect on the cost of running that service. Inefficiencies
    and misconfigurations can show up in the cost base of a service in a far more
    direct way. In fact, this is one way to think about the rise of cloud.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 第二点是，服务在使用云提供商时的效率和利用率直接影响运行该服务的成本。低效和配置错误可能会直接体现在服务的成本基础上。事实上，这是考虑云兴起的一种方式。
- en: In the old days, teams would often own actual physical servers in dedicated
    areas (usually called *cages*) in datacenters. Purchasing these servers represented
    *capital expenditure*, and the servers were tracked as an asset. When we use cloud
    providers, such as AWS or Azure, we are renting time on machines actually owned
    by companies such as Amazon or Microsoft. This is *operational expenditure*, and
    it is a cost (or liability). This shift means that the computational requirements
    of our systems are now much more open to scrutiny by the financial folks.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，团队通常会拥有位于数据中心专用区域（通常称为*cages*）内的实际物理服务器。购买这些服务器代表了*资本支出*，这些服务器被视为资产。当我们使用云服务提供商（如AWS或Azure）时，我们租用的是实际由亚马逊或微软等公司拥有的机器时间。这是*运营支出*，是一种成本（或责任）。这种转变意味着我们系统的计算需求现在更容易被财务人员审查。
- en: Overall, it is important to recognize that cloud systems fundamentally consist
    clusters of processes (in our case, JVMs) that dynamically change over time. The
    clusters can grow or shrink in size, but even if they do not, over time the participating
    processes will change. This stands in sharp contrast to traditional host-based
    systems where the processes forming a cluster are usually much more long-lived
    and belong to a known, and stable, collection of hosts.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，重要的是要认识到云系统在根本上是由进程集群（在我们的情况下是JVM）组成的，这些集群会随时间动态变化。这些集群可以增长或缩小，但即使不这样做，参与的进程随时间也会发生变化。这与传统基于主机的系统形成鲜明对比，那些形成集群的进程通常更长寿，并且属于已知且稳定的主机集合。
- en: Summary
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter we have started to discuss what Java performance is and is not.
    We have introduced the fundamental topics of empirical science and measurement,
    and the basic vocabulary and observables that a good performance exercise will
    use. We have introduced some common cases that are often seen within the results
    obtained from performance tests. Finally, we have introduced the very basics of
    the sorts of additional issues that can arise in cloud systems.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始讨论Java性能的真实情况。我们介绍了经验科学和测量的基本主题，以及良好性能练习中将使用的基本词汇和可观察现象。我们介绍了从性能测试中常见的一些案例。最后，我们介绍了在云系统中可能出现的各种基本问题。
- en: Let’s move on and begin discussing some major aspects of performance testing,
    as well as how to handle the numbers that are generated by those tests.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续讨论性能测试的一些重要方面，以及如何处理这些测试生成的数据。
- en: '^([1](ch01.xhtml#id93-marker)) J. Gosling, “The feel of Java,” *Computer*,
    vol. 30, no. 6 (June 1997): 53-57'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch01.xhtml#id93-marker)) J. Gosling，《The feel of Java》，*Computer*，第30卷，第6号（1997年6月）：53-57
- en: ^([2](ch01.xhtml#id94-marker)) E. Goldratt and J. Cox, “The Goal,” (Gower Publishing,
    1984)
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch01.xhtml#id94-marker)) E. Goldratt 和 J. Cox，《The Goal》，（Gower Publishing，1984）
