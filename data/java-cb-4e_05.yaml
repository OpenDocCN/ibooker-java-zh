- en: Chapter 5\. Numbers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章。数字
- en: 5.0 Introduction
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.0 简介
- en: Numbers are basic to just about any computation. They’re used for array indices,
    temperatures, salaries, ratings, and an infinite variety of things. Yet they’re
    not as simple as they seem. With floating-point numbers, how accurate is accurate?
    With random numbers, how random is random? With strings that should contain a
    number, what actually constitutes a number?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 数字是几乎所有计算的基础。它们用于数组索引、温度、薪水、评分以及各种各样的事情。然而，它们并不像它们看起来那么简单。对于浮点数，精度有多精确？对于随机数，随机有多随机？对于应该包含数字的字符串，什么才算是数字？
- en: Java has several built-in, or *primitive*, types that can be used to represent
    numbers, summarized in [Table 5-1](#javacook-numbers-TABLE-1) with their *wrapper*
    (object) types, as well as some numeric types that do not represent primitive
    types. Note that unlike languages such as C or Perl, which don’t specify the size
    or precision of numeric types, Java—with its goal of portability—specifies these
    exactly and states that they are the same on all platforms.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Java 有几种内置的或 *原始* 类型可用于表示数字，总结在 [Table 5-1](#javacook-numbers-TABLE-1) 中，以及它们的
    *包装*（对象）类型，以及一些不表示原始类型的数值类型。请注意，与诸如 C 或 Perl 等不指定数值类型的大小或精度的语言不同，Java —— 其目标是可移植性
    —— 精确地指定了这些，并声明它们在所有平台上都是相同的。
- en: Table 5-1\. Numeric types
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5-1。数值类型
- en: '| Built-in type | Object wrapper | Size of built-in (bits) | Contents |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '| 内置类型 | 对象包装器 | 内置大小（位） | 内容 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `byte` | `Byte` | 8 | Signed integer |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| `byte` | `Byte` | 8 | 有符号整数 |'
- en: '| `short` | `Short` | 16 | Signed integer |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| `short` | `Short` | 16 | 有符号整数 |'
- en: '| `int` | `Integer` | 32 | Signed integer |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| `int` | `Integer` | 32 | 有符号整数 |'
- en: '| `long` | `Long` | 64 | Signed integer |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| `long` | `Long` | 64 | 有符号整数 |'
- en: '| `float` | `Float` | 32 | IEEE-754 floating point |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| `float` | `Float` | 32 | IEEE-754 浮点数 |'
- en: '| `double` | `Double` | 64 | IEEE-754 floating point |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| `double` | `Double` | 64 | IEEE-754 浮点数 |'
- en: '| `char` | `Character` | 16 | Unsigned Unicode character |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| `char` | `Character` | 16 | 无符号 Unicode 字符 |'
- en: '| n/a | `BigInteger` | unlimited | Arbitrary-size immutable integer value |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| n/a | `BigInteger` | 无限制 | 任意大小的不可变整数值 |'
- en: '| n/a | `BigDecimal` | unlimited | Arbitrary-size-and-precision immutable floating-point
    value |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| n/a | `BigDecimal` | 无限制 | 任意大小和精度的不可变浮点值 |'
- en: As you can see, Java provides a numeric type for just about any purpose. There
    are four sizes of signed integers for representing various sizes of whole numbers.
    There are two sizes of floating-point numbers to approximate real numbers. There
    is also a type specifically designed to represent and allow operations on Unicode
    characters. The primitive numeric types are discussed here. The “Big” value types
    are described in [Recipe 5.12](#javacook-numbers-SECT-19).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Java 提供了几乎任何目的的数字类型。有四种大小的有符号整数，用于表示各种大小的整数。有两种大小的浮点数来近似实数。还有一种类型专门设计用于表示和允许对
    Unicode 字符进行操作。这里讨论了原始数值类型。大数值类型在 [Recipe 5.12](#javacook-numbers-SECT-19) 中描述。
- en: When you read a string representing a number from user input or a text file,
    you need to convert it to the appropriate type. The object wrapper classes in
    the second column have several functions, one of which is to provide this basic
    conversion functionality—replacing the C programmer’s *atoi*/*atof* family of
    functions and the numeric arguments to *scanf*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从用户输入或文本文件中读取表示数字的字符串时，你需要将其转换为适当的类型。第二列中的对象包装类有几个函数，其中之一是提供此基本转换功能的—替换 C
    程序员的 *atoi*/*atof* 函数系列和 *scanf* 的数值参数。
- en: Going the other way, you can convert any number (indeed, anything at all in
    Java) to a string just by using string concatenation. If you want a little bit
    of control over numeric formatting, [Recipe 5.5](#javacook-numbers-SECT-8) shows
    you how to use some of the object wrappers’ conversion routines. And if you want
    full control, that recipe also shows the use of `NumberFormat` and its related
    classes to provide full control of formatting.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是，你可以通过使用字符串连接来将任何数字（事实上，Java 中的任何东西）转换为字符串。如果你想对数字格式进行一点控制，[Recipe 5.5](#javacook-numbers-SECT-8)
    展示了如何使用一些对象包装器的转换例程。如果你想要完全控制，该配方还展示了使用 `NumberFormat` 及其相关类来提供完全控制格式的方法。
- en: As the name *object wrapper* implies, these classes are also used to wrap a
    number in a Java object, as many parts of the standard API are defined in terms
    of objects. Later on, [“Solution”](ch12.html#javacook-netclient-SECT-5.2) shows
    using an `Integer` object to save an `int`’s value to a file using object serialization
    and retrieving the value later.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 正如 *对象包装* 这个名字所暗示的，这些类也用于在 Java 对象中包装一个数字，因为标准 API 的许多部分都是以对象的形式定义的。稍后的 [“解决方案”](ch12.html#javacook-netclient-SECT-5.2)
    展示了如何使用 `Integer` 对象将 `int` 的值保存到文件中，并稍后检索该值。
- en: 'But I haven’t yet mentioned the issues of floating point. Real numbers, you
    may recall, are numbers with a fractional part. There is an infinite number of
    real numbers. A floating-point number—what a computer uses to approximate a real
    number—is not the same as a real number. The number of floating-point numbers
    is finite, with only 2^32 different bit patterns for `float`s, and 2^64 for `double`s.
    Thus, most real values have only an approximate correspondence to floating point.
    The result of printing the real number 0.3 works correctly, like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 但我还没有提到浮点数的问题。实数，你可能记得，是带有小数部分的数字。实数有无限多个。计算机用来近似实数的浮点数并非与实数相同。浮点数的数量是有限的，`float`
    有 2^32 个不同的位模式，`double` 有 2^64 个。因此，大多数实数值与浮点数只有近似对应关系。打印实数 0.3 的结果是正确的，如下所示：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'That code results in this printout:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码的输出是：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'But the difference between a real value and its floating-point approximation
    can accumulate if the value is used in a computation; this is often called a *rounding
    error*. Continuing the previous example, the real 0.3 multiplied by 3 yields:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果将值用于计算，实际值与其浮点数近似值之间的差异可能会累积；这通常称为 *舍入误差*。继续前面的例子，实数 0.3 乘以 3 的结果是：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Surprised? Not only is it off by a bit from what you might expect, but you will
    of course get the same output on any conforming Java implementation. I ran it
    on machines as disparate as an AMD/Intel PC with OpenBSD, a PC with Windows and
    the standard JDK, and on macOS. Always the same answer.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 惊讶吗？它不仅比你预期的偏了一点，而且在任何符合 Java 实现上都会得到相同的输出。我在不同的机器上运行过它，如 AMD/Intel PC 上的 OpenBSD、带有标准
    JDK 的 Windows PC 和 macOS 上。始终得到相同的答案。
- en: 'And what about random numbers? How random are they? You have probably heard
    the term *Pseudorandom Number Generator*, or PRNG. All conventional random number
    generators, whether written in Fortran, C, or Java, generate pseudorandom numbers.
    That is, they’re not truly random! True randomness comes only from specially built
    hardware: an analog source of Brownian noise connected to an analog-to-digital
    converter, for example.^([1](ch05.html#idm45290682381560)) Your average PC of
    today may have some good sources of entropy, or even hardware-based sources of
    randomness (which have not been widely used or tested yet). However, pseudorandom
    number generators are good enough for most purposes, so we use them. Java provides
    one random generator in the base library `java.lang.Math`, and several others;
    we’ll examine these in [Recipe 5.9](#javacook-numbers-SECT-13).'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 随机数又如何呢？它们有多随机？你可能听说过 *伪随机数生成器* 或 PRNG 这个术语。所有传统的随机数生成器，无论是用 Fortran、C 还是 Java
    编写的，都生成伪随机数。也就是说，它们并非真正随机！真正的随机性只能来自专门构建的硬件：例如连接到模拟至数字转换器的布朗噪声的模拟源。^([1](ch05.html#idm45290682381560))
    如今的普通 PC 可能具有一些良好的熵源，甚至是硬件基础的随机源（尚未广泛使用或测试）。然而，对于大多数目的，伪随机数生成器已经足够好，因此我们使用它们。Java
    在基础库 `java.lang.Math` 中提供了一个随机生成器和其他几个；我们将在 [食谱 5.9](#javacook-numbers-SECT-13)
    中详细讨论这些。
- en: The class `java.lang.Math` contains an entire math library in one class, including
    trigonometry, conversions (including degrees to radians and back), rounding, truncating,
    square root, minimum, and maximum. It’s all there. Check the javadoc for `java.lang.Math`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 类 `java.lang.Math` 包含一个完整的数学库，包括三角函数、转换（包括度数到弧度和反向转换）、四舍五入、截断、平方根、最小值和最大值。所有这些功能都在这个类中。查看
    `java.lang.Math` 的 javadoc 获取更多信息。
- en: The package `java.math` contains support for *big numbers*—those larger than
    the normal built-in long integers, for example. See [Recipe 5.12](#javacook-numbers-SECT-19).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 包 `java.math` 包含对 *大数* 的支持 —— 即大于普通内置长整数的数字。参见 [食谱 5.12](#javacook-numbers-SECT-19)。
- en: Java works hard to ensure that your programs are reliable. The usual ways you’d
    notice this are in the common requirement to catch potential exceptions—all through
    the Java API—and in the need to *cast*, or convert, when storing a value that
    might or might not fit into the variable you’re trying to store it in. I’ll show
    examples of these.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Java 通过确保程序的可靠性而闻名。您通常会在 Java API 中注意到这一点，常见的体现是需要捕获潜在异常，并在尝试存储可能不适合的值时进行 *强制转换*
    或转换。我将展示这些的示例。
- en: Overall, Java’s handling of numeric data fits well with the ideals of portability,
    reliability, and ease of programming.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，Java 对数值数据的处理非常符合可移植性、可靠性和编程便利性的理念。
- en: See Also
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The [Java Language Specification](https://docs.oracle.com/javase/specs), and
    the javadoc page for `java.lang.Math`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[Java 语言规范](https://docs.oracle.com/javase/specs)，以及 `java.lang.Math` 的 javadoc
    页面。'
- en: 5.1 Checking Whether a String Is a Valid Number
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.1 检查字符串是否为有效数字
- en: Problem
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to check whether a given string contains a valid number, and, if so,
    convert it to binary (internal) form.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要检查给定的字符串是否包含有效的数字，如果是，则将其转换为二进制（内部）形式。
- en: Solution
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'To accomplish this, use the appropriate wrapper class’s conversion routine
    and catch the `NumberFormatException`. This code converts a string to a `double`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现此目标，使用适当的包装类转换程序，并捕获 `NumberFormatException`。以下代码将字符串转换为 `double`：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Discussion
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: This code lets you validate only numbers in the format that the designers of
    the wrapper classes expected. If you need to accept a different definition of
    numbers, you could use regular expressions (see [Chapter 4](ch04.html#javacook-regex))
    to make the determination.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码允许您仅验证符合包装类设计者期望格式的数字。如果需要接受不同定义的数字，可以使用正则表达式（参见 [第4章](ch04.html#javacook-regex)）进行判断。
- en: 'There may also be times when you want to tell if a given number is an integer
    number or a floating-point number. One way is to check for the characters ., `d`,
    `e`, or `f` in the input; if one of these characters is present, convert the number
    as a `double`. Otherwise, convert it as an `int`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您可能想知道给定的数字是整数还是浮点数。一种方法是检查输入中是否包含 .、`d`、`e` 或 `f` 字符；如果存在其中一个字符，则将数字转换为 `double`。否则，将其作为
    `int` 转换：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: See Also
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: A more involved form of parsing is offered by the `DecimalFormat` class, discussed
    in [Recipe 5.5](#javacook-numbers-SECT-8).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`DecimalFormat` 类提供了更复杂的解析形式，详见 [Recipe 5.5](#javacook-numbers-SECT-8)。'
- en: There is also the `Scanner` class; see [Recipe 10.6](ch10.html#javacook-io-SECT-5).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`Scanner` 类也存在；参见 [Recipe 10.6](ch10.html#javacook-io-SECT-5)。'
- en: 5.2 Converting Numbers to Objects and Vice Versa
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.2 将数字转换为对象和反之亦然
- en: Problem
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to convert numbers to objects and objects to numbers.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要将数字转换为对象，以及对象转换为数字。
- en: Solution
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the object wrapper classes listed in [Table 5-1](#javacook-numbers-TABLE-1)
    at the beginning of this chapter.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本章开头列出的对象包装类，请参见 [表格 5-1](#javacook-numbers-TABLE-1)。
- en: Discussion
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Often you have a primitive number and you need to pass it into a method where
    an `Object` is required, or vice versa. Long ago you had to invoke the conversion
    routines that are part of the `wrapper` classes, but now you can generally use
    automatic conversion (called *auto-boxing*/*auto-unboxing*). See [Example 5-1](#javacook-CHP-8-EX-6)
    for examples of both.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您经常有一个原始数字，需要将其传递给需要 `Object` 的方法，或者反之亦然。很久以前，您必须调用包装类的转换程序，但现在通常可以使用自动转换（称为
    *自动装箱*/*自动拆箱*）。参见 [示例 5-1](#javacook-CHP-8-EX-6) 中的示例。
- en: Example 5-1\. main/src/main/java/structure/AutoboxDemo.java
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-1\. main/src/main/java/structure/AutoboxDemo.java
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[![1](assets/1.png)](#co_numbers_CO1-1)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_numbers_CO1-1)'
- en: 'Auto-boxing: `int 42` is converted to `Integer(42)`. Also auto-unboxing: the
    `Integer` returned from `foo()` is auto-unboxed to assign to `int result`.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 自动装箱：`int 42` 被转换为 `Integer(42)`。还有自动拆箱：从 `foo()` 返回的 `Integer` 被自动拆箱以赋值给 `int
    result`。
- en: '[![2](assets/2.png)](#co_numbers_CO1-2)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_numbers_CO1-2)'
- en: 'No auto-boxing: `valueOf()` returns `Integer`. If the line said `return Integer.intValueOf(123)`,
    then it would be a second example of auto-boxing because the method return value
    is `Integer`.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 没有自动装箱：`valueOf()` 返回 `Integer`。如果行中写成 `return Integer.intValueOf(123)`，那么这将是自动装箱的第二个示例，因为方法返回值是
    `Integer`。
- en: 'To explicitly convert between an `int` and an `Integer` object, or vice versa,
    you can use the `wrapper` class methods:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要显式地在 `int` 和 `Integer` 对象之间进行转换，或者反之亦然，可以使用包装类的方法：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 5.3 Taking a Fraction of an Integer Without Using Floating Point
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.3 在不使用浮点数的情况下取整数的分数
- en: Problem
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to multiply an integer by a fraction without converting the fraction
    to a floating-point number.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望将整数乘以分数而不将分数转换为浮点数。
- en: Solution
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Multiply the integer by the numerator and divide by the denominator.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 将整数乘以分子然后除以分母。
- en: This technique should be used only when efficiency is more important than clarity
    because it tends to detract from the readability—and therefore the maintainability—of
    your code.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 仅当效率比清晰更重要时，才应使用此技术，因为它倾向于减弱代码的可读性—因此也降低了代码的可维护性。
- en: Discussion
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Because integers and floating-point numbers are stored differently, it may
    sometimes be desirable and feasible, for efficiency purposes, to multiply an integer
    by a fractional value without converting the values to floating point and back,
    and without requiring a cast:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 因为整数和浮点数的存储方式不同，有时为了效率的目的，可能希望以整数乘以分数值而不将值转换为浮点数并返回，也不需要强制转换：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Running the code looks like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码如下：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You should beware of the possibility of numeric overflow and avoid this optimization
    if you cannot guarantee that the multiplication by the numerator will not overflow.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不能保证通过分子的乘法不会溢出，应该注意可能发生的数值溢出，并避免此优化。
- en: 5.4 Working with Floating-Point Numbers
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.4 使用浮点数
- en: Problem
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to be able to compare and round floating-point numbers.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望能够比较和四舍五入浮点数。
- en: Solution
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Compare with the `INFINITY` constants, and use `isNaN()` to check for `NaN`
    (not a number).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `INFINITY` 常量进行比较，并使用 `isNaN()` 检查是否为 `NaN`（非数值）。
- en: Compare floating values with an epsilon value.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 用一个 epsilon 值比较浮点数值。
- en: Round floating point values with `Math.round()` or custom code.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 用 `Math.round()` 或自定义代码四舍五入浮点数值。
- en: Discussion
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Comparisons can be a bit tricky: fixed-point operations that can do things
    like divide by zero result in Java notifying you abruptly by throwing an exception.
    This is because integer division by zero is considered a *logic error*.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 比较可能有些棘手：固定点操作可以做诸如除以零的事情，导致 Java 通过抛出异常来突然通知您。这是因为整数除以零被视为*逻辑错误*。
- en: 'Floating-point operations, however, do not throw an exception because they
    are defined over an (almost) infinite range of values. Instead, they signal errors
    by producing the constant `POSITIVE_INFINITY` if you divide a positive floating-point
    number by zero, the constant `NEGATIVE_INFINITY` if you divide a negative floating-point
    value by zero, and `NaN` if you otherwise generate an invalid result. Values for
    these three public constants are defined in both the `Float` and the `Double`
    wrapper classes. The value `NaN` has the unusual property that it is not equal
    to itself (i.e., `NaN` != `NaN`). Thus, it would hardly make sense to compare
    a (possibly suspect) number against `NaN`, because the following expression can
    never be true:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，浮点操作不会抛出异常，因为它们在（几乎）无限的值范围内定义。相反，如果您将正浮点数除以零，则会生成常量 `POSITIVE_INFINITY`；如果将负浮点值除以零，则会生成常量
    `NEGATIVE_INFINITY`；如果以其他方式生成无效结果，则会生成 `NaN`。这三个公共常量的值在 `Float` 和 `Double` 包装类中都有定义。值
    `NaN` 具有不同寻常的属性，即它不等于自身（即 `NaN` != `NaN`）。因此，将一个（可能可疑的）数字与 `NaN` 进行比较几乎没有意义，因为以下表达式永远不会为真：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Instead, the methods `Float.isNaN(float)` and `Double.isNaN(double)` must be
    used:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 而应使用方法 `Float.isNaN(float)` 和 `Double.isNaN(double)`：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Note that this, by itself, is not sufficient to ensure that floating-point
    calculations have been done with adequate accuracy. For example, the following
    program demonstrates a contrived calculation—Heron’s formula for the area of a
    triangle—both in `float` and in `double`. The double values are correct, but the
    floating-point value comes out as zero due to rounding errors. This happens because,
    in Java, operations involving only `float` values are performed as 32-bit calculations.
    Related languages such as C automatically promote these to double during the computation,
    which can eliminate some loss of accuracy. Let’s take a look:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，仅此本身并不足以确保浮点数计算具有足够的精度。例如，以下程序演示了一种构造的计算——海伦公式用于三角形的面积——分别使用 `float` 和 `double`。双精度值是正确的，但由于舍入误差，浮点值为零。这是因为在
    Java 中，仅涉及 `float` 值的操作是以 32 位计算的。相关的语言如 C 在计算过程中会自动将这些值提升为 double，从而可以消除一些精度损失。让我们来看一下：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now let’s run it:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们运行它：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If in doubt, use `double`!
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有疑问，使用 `double`！
- en: To ensure consistency of very large-magnitude double computations on different
    Java implementations, Java provides the keyword `strictfp`, which can apply to
    classes, interfaces, or methods within a class.^([2](ch05.html#idm45290681215064))
    If a computation is Strict-FP, then it must always, for example, return the value
    `INFINITY` if a calculation would overflow the value of `Double.MAX_VALUE` (or
    underflow the value `Double.MIN_VALUE`). Non-Strict-FP calculations—the default—are
    allowed to perform calculations on a greater range and can return a valid final
    result that is in range even if the interim product was out of range. This is
    pretty esoteric and affects only computations that approach the bounds of what
    fits into a double.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保在不同的 Java 实现上对非常大幅度的双精度计算保持一致，Java 提供了关键字 `strictfp`，它可以应用于类、接口或类中的方法。^([2](ch05.html#idm45290681215064))
    如果计算是 Strict-FP，那么如果计算会使 `Double.MAX_VALUE` 的值溢出（或者使值 `Double.MIN_VALUE` 的值下溢），它必须始终返回值
    `INFINITY`。非 Strict-FP 计算（默认情况下）允许在更大范围内执行计算，并且可以返回在范围内的有效最终结果，即使中间产品超出范围。这非常神秘，仅影响接近双精度范围的计算。
- en: Comparing floating-point values
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较浮点值
- en: Based on what we’ve just discussed, you probably won’t just go comparing two
    floats or doubles for equality. You might expect the floating-point wrapper classes,
    `Float` and `Double`, to override the `equals()` method, which they do. The `equals()`
    method returns `true` if the two values are the same bit for bit (i.e., if and
    only if the numbers are the same or are both `NaN`). It returns `false` otherwise,
    including if the argument passed in is null, or if one object is +0.0 and the
    other is –0.0.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们刚刚讨论的内容，你可能不会只是简单地比较两个浮点数或双精度数的相等性。你可能期望浮点包装类 `Float` 和 `Double` 重写 `equals()`
    方法，它们确实如此。`equals()` 方法在这两个值在位上完全相同时返回 `true`（即这两个数相同或都是 `NaN`）。否则返回 `false`，包括传入的参数为
    null，或者一个对象是 +0.0 而另一个是 -0.0。
- en: 'I said earlier that `NaN != Nan`, but if you compare with `equals()`, the result
    is true:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前说过 `NaN != NaN`，但是如果使用 `equals()` 进行比较，结果是 true：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If this sounds weird, remember that the complexity comes partly from the nature
    of doing real number computations in the less-precise floating-point hardware.
    It also comes partly from the details of the IEEE Standard 754, which specifies
    the floating-point functionality that Java tries to adhere to so that underlying
    floating-point processor hardware can be used even when Java programs are being
    interpreted.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这听起来有些奇怪，请记住，这种复杂性部分来自于在较不精确的浮点硬件中进行实数计算的性质。它也部分来自于 IEEE 标准 754 的细节，该标准指定了
    Java 尝试遵循的浮点功能，以便即使在解释 Java 程序时也可以使用底层浮点处理器硬件。
- en: 'To actually compare floating-point numbers for equality, it is generally desirable
    to compare them within some tiny range of allowable differences; this range is
    often regarded as a tolerance or as *epsilon*. [Example 5-2](#javacook-numbers-EX-1)
    shows an `equals()` method you can use to do this comparison, as well as comparisons
    on values of `NaN`. When run, it prints that the first two numbers are equal within
    epsilon:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际比较浮点数是否相等，通常希望在某个允许误差范围内进行比较；这个范围通常被称为容差或*epsilon*。[示例 5-2](#javacook-numbers-EX-1)
    展示了一个你可以用来进行这种比较的 `equals()` 方法，以及对 `NaN` 值的比较。运行时，它打印出前两个数字在 epsilon 范围内相等：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Example 5-2\. main/src/main/java/numbers/FloatCmp.java
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-2\. main/src/main/java/numbers/FloatCmp.java
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that neither of the `System.err` messages about incorrect returns prints.
    The point of this example with `NaN`s is that you should always make sure values
    are not `NaN` before entrusting them to `Double.equals()`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，关于不正确返回的 `System.err` 消息，没有任何打印。这个带有 `NaN` 的例子的重点在于，在将值委托给 `Double.equals()`
    之前，你应该始终确保这些值不是 `NaN`。
- en: Rounding
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 舍入
- en: 'If you simply cast a floating value to an integer value, Java truncates the
    value. A value like 3.999999 cast to an `int` or `long` becomes 3, not 4\. To
    round floating-point numbers properly, use `Math.round()`. It has two overloads:
    if you give it a `double`, you get a `long` result; if you give it a `float`,
    you get an `int`.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你简单地将浮点值强制转换为整数值，Java 会截断该值。像 3.999999 这样的值，被转换为 `int` 或 `long` 就变成了 3，而不是
    4。要正确地四舍五入浮点数，请使用 `Math.round()`。它有两个重载：如果给它一个 `double`，你会得到一个 `long` 结果；如果给它一个
    `float`，你会得到一个 `int`。
- en: 'What if you don’t like the rounding rules used by `round`? If, for some bizarre
    reason, you wanted to round numbers greater than 0.54 instead of the normal 0.5,
    you could write your own version of `round()`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不喜欢`round`使用的舍入规则怎么办？如果由于某种奇怪的原因，您想要将大于0.54的数字四舍五入而不是正常的0.5，您可以编写自己版本的`round()`：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If, on the other hand, you simply want to display a number with less precision
    than it normally gets, you probably want to use a `DecimalFormat` object or a
    `Formatter` object, which we look at in [Recipe 5.5](#javacook-numbers-SECT-8).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果您只想显示一个比它通常更少精确度的数字，您可能希望使用一个`DecimalFormat`对象或一个`Formatter`对象，我们在[Recipe
    5.5](#javacook-numbers-SECT-8)中看看它。
- en: 5.5 Formatting Numbers
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.5 格式化数字
- en: Problem
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to format numbers.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要格式化数字。
- en: Solution
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use a `NumberFormat` subclass.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`NumberFormat`子类。
- en: Java did not originally provide C-style `printf/scanf` functions because they
    tend to mix together formatting and input/output in a very inflexible way. Programs
    using `printf/scanf` can be hard to internationalize, for example. Of course,
    by popular demand, Java did eventually introduce `printf()`, which along with
    `String.format()` is now standard in Java; see [Recipe 10.4](ch10.html#javacook-io-SECT-3).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最初Java并没有提供类似C语言的`printf/scanf`函数，因为它们往往以一种非常不灵活的方式混合了格式化和输入/输出。例如，使用`printf/scanf`的程序很难国际化。当然，由于广泛需求，Java最终引入了`printf()`，现在和`String.format()`一起成为Java的标准；参见[Recipe
    10.4](ch10.html#javacook-io-SECT-3)。
- en: Java has an entire package, `java.text`, full of formatting routines as general
    and flexible as anything you might imagine. As with `printf`, it has an involved
    formatting language, described in the javadoc page. Consider the presentation
    of long numbers. In North America, the number one thousand twenty-four and a quarter
    is written 1,024.25; in most of Europe it is 1 024,25; and in some other part
    of the world it might be written 1.024,25\. Not to mention how currencies and
    percentages are formatted! Trying to keep track of this yourself would drive the
    average small software shop around the bend rather quickly.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Java有一个完整的包`java.text`，提供了像您可以想象的任何一样通用和灵活的格式化例程。与`printf`类似，它有一个复杂的格式化语言，在javadoc页面中有描述。考虑长数字的呈现方式。在北美，一千零二十四点二五写作1,024.25；在大多数欧洲地区，写作1
    024,25；而在世界其他地方，可能写作1.024,25。更不用说货币和百分比的格式化了！试图自己跟踪这些将会迅速让普通的小软件店崩溃。
- en: 'Fortunately, the `java.text` package includes a `Locale` class; and, furthermore,
    the Java runtime automatically sets a default `Locale` object based on the user’s
    environment (on the Macintosh and Windows, the user’s preferences, and on Unix,
    the user’s environment variables). To provide a nondefault locale in code, see
    [Recipe 3.12](ch03.html#javacook-i18n-SECT-8). To provide formatters customized
    for numbers, currencies, and percentages, the `NumberFormat` class has static
    *factory methods* that normally return a `DecimalFormat` with the correct pattern
    already instantiated. A `DecimalFormat` object appropriate to the user’s locale
    can be obtained from the factory method `NumberFormat.getInstance()` and manipulated
    using `set` methods. Surprisingly, the method `setMinimumIntegerDigits()` turns
    out to be the easy way to generate a number format with leading zeros. Here is
    an example:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`java.text`包包括一个`Locale`类；此外，Java运行时根据用户的环境自动设置默认的`Locale`对象（在Macintosh和Windows上是用户的偏好设置，在Unix上是用户的环境变量）。要在代码中提供非默认的语言环境，请参见[Recipe
    3.12](ch03.html#javacook-i18n-SECT-8)。为了提供针对数字、货币和百分比定制的格式化程序，`NumberFormat`类具有静态的*工厂方法*，通常返回一个已经实例化了正确模式的`DecimalFormat`。可以从工厂方法`NumberFormat.getInstance()`获取适合用户区域设置的`DecimalFormat`对象，并使用`set`方法进行操作。令人惊讶的是，方法`setMinimumIntegerDigits()`竟然是生成带有前导零的数字格式的简便方法。以下是一个例子：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This prints the contents of the array using the `NumberFormat` instance `form`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用`NumberFormat`实例`form`打印数组内容：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can also construct a `DecimalFormat` with a particular pattern or change
    the pattern dynamically using `applyPattern()`. Some of the more common pattern
    characters are shown in [Table 5-2](#javacook-numbers-TABLE-2).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用特定模式构造或使用`applyPattern()`动态更改`DecimalFormat`。一些更常见的模式字符在[Table 5-2](#javacook-numbers-TABLE-2)中显示。
- en: Table 5-2\. DecimalFormat pattern characters
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 表5-2\. DecimalFormat模式字符
- en: '| Character | Meaning |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 字符 | 含义 |'
- en: '| --- | --- |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `#` | Numeric digit (leading zeros suppressed) |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `#` | 数字（不包含前导零） |'
- en: '| `0` | Numeric digit (leading zeros provided) |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `0` | 数字（包含前导零） |'
- en: '| . | Locale-specific decimal separator (decimal point) |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| . | 区域特定的十进制分隔符（小数点） |'
- en: '| , | Locale-specific grouping separator (comma in English) |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| , | 区域特定的分组分隔符（英文逗号） |'
- en: '| `-` | Locale-specific negative indicator (minus sign) |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `-` | 区域特定的负数指示符（减号） |'
- en: '| `%` | Shows the value as a percentage |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `%` | 将值显示为百分比 |'
- en: '| `;` | Separates two formats: the first for positive and the second for negative
    values |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `;` | 分隔两种格式：第一种是正数，第二种是负数 |'
- en: '| '' | Escapes one of the above characters so it appears |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| '' | 转义上述字符中的一个以使其显示 |'
- en: '| Anything else | Appears as itself |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 其他任何字符 | 仍然显示为它本身 |'
- en: 'The `NumFormatDemo` program uses one `DecimalFormat` to print a number with
    only two decimal places and a second to format the number according to the default
    locale:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`NumFormatDemo`程序使用一个`DecimalFormat`来仅打印带有两位小数的数字，并使用第二个根据默认区域设置格式化数字：'
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This program prints the given pattern and then formats the same number using
    several formats:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序打印给定的模式，然后使用几种格式化方法格式化同一个数字：
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Human-readable number formatting
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 人类可读的数字格式化
- en: To print a number in what Linux/Unix calls “human readable format” (many display
    commands accept `a -h` argument for this format), use the Java 12 `CompactNumberFormat`,
    as shown in [Example 5-3](#javacook-numbers-EX-cnf).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要以Linux/Unix中称为“人类可读格式”打印数字（许多显示命令接受`a -h`参数以此格式），使用Java 12的`CompactNumberFormat`，如[示例 5-3](#javacook-numbers-EX-cnf)中所示。
- en: Example 5-3\. nmain/src/main/java/numbers/CompactFormatDemo.java
  id: totrans-138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-3\. nmain/src/main/java/numbers/CompactFormatDemo.java
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Roman numeral formatting
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 罗马数字格式化
- en: 'To work with roman numerals, use my `RomanNumberFormat` class, as in this demo:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理罗马数字，使用我的`RomanNumberFormat`类，如此演示：
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Running `RomanNumberSimple` in 2020 produces this output:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在2020年运行`RomanNumberSimple`会产生以下输出：
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The source of the `RomanNumberFormat` class is in *src/main/java/numbers/RomanNumberFormat.java*.
    Several of the public methods are required because I wanted it to be a subclass
    of `Format`, which is abstract. This accounts for some of the complexity, like
    having three different format methods.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`RomanNumberFormat`类的源代码位于*src/main/java/numbers/RomanNumberFormat.java*。多个公共方法是必需的，因为我希望它是`Format`的子类，而`Format`是抽象的。这就解释了一些复杂性，比如有三种不同的格式化方法。'
- en: Note that the `RomanNumberFormat.parseObject( )` method is also required, but
    the code doesn’t implement parsing in this version.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`RomanNumberFormat.parseObject( )`方法也是必需的，但此版本的代码不实现解析。
- en: See Also
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*[Java I/O](http://shop.oreilly.com/product/9780596527501.do)* by Elliotte
    Harold (O’Reilly) includes an entire chapter on `NumberFormat` and develops the
    subclass `ExponentialNumberFormat`.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*[Java I/O](http://shop.oreilly.com/product/9780596527501.do)* 由Elliotte Harold（O’Reilly）包含了一个关于`NumberFormat`的整章内容，并开发了`ExponentialNumberFormat`的子类。'
- en: 5.6 Converting Among Binary, Octal, Decimal, and Hexadecimal
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.6 将二进制、八进制、十进制和十六进制相互转换
- en: Problem
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to display an integer as a series of bits—for example, when interacting
    with certain hardware devices—or in some alternative number base (binary is base
    2, octal is base 8, decimal is 10, hexadecimal is 16). You want to convert a binary
    number or a hexadecimal value into an integer.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要以一系列位的形式显示整数时——例如与某些硬件设备交互时——或以其他数制（二进制是基数2，八进制是基数8，十进制是10，十六进制是16）显示整数时，你想要将二进制数或十六进制值转换为整数。
- en: Solution
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: The class `java.lang.Integer` provides the solutions. Most of the time you can
    use `Integer.parseInt(String input, int radix)` to convert from any type of number
    to an `Integer`, and `Integer.toString(int input, int radix)` to go the other
    way. [Example 5-4](#javacook-recipe-FILE) shows some examples of using the `Integer`
    class.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.lang.Integer`类提供了解决方案。大多数情况下，您可以使用`Integer.parseInt(String input, int
    radix)`将任何类型的数字转换为`Integer`，并使用`Integer.toString(int input, int radix)`完成反向操作。[示例 5-4](#javacook-recipe-FILE)展示了一些使用`Integer`类的示例。'
- en: Example 5-4\. main/src/main/java/numbers/IntegerBinOctHexEtc.java
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-4\. main/src/main/java/numbers/IntegerBinOctHexEtc.java
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This program prints the binary string as an integer in various bases, and the
    integer 42 in those same number bases:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序将二进制字符串打印为各种数制中的整数，并将整数42在相同的数制中显示：
- en: '[PRE25]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Discussion
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: There are also specialized versions of `toString(int)` that don’t require you
    to specify the radix, for example, `toBinaryString()` to convert an integer to
    binary, `toHexString()` for hexadecimal, `toOctalString()`, and so on. The javadoc
    page for the `Integer` class is your friend here.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 也有专门的`toString(int)`版本，不需要指定基数，例如，`toBinaryString()`将整数转换为二进制，`toHexString()`转换为十六进制，`toOctalString()`等等。`Integer`类的Javadoc页面是你的好帮手。
- en: The `String` class itself includes a series of static methods—`valueOf(int)`,
    `val⁠ue​Of(double)`, and so on—that also provide default formatting. That is,
    they return the given numeric value formatted as a string.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`String`类本身包含一系列静态方法——`valueOf(int)`、`valueOf(double)`等等，它们还提供默认格式化。也就是说，它们将给定的数值格式化为字符串并返回。'
- en: 5.7 Operating on a Series of Integers
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.7 操作整数序列
- en: Problem
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to work on a range of integers.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要处理一系列整数。
- en: Solution
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: For a contiguous set, use `IntStream::range` and `rangeClosed`, or the older
    `for` loop.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 对于连续的集合，请使用`IntStream::range`和`rangeClosed`，或者旧的`for`循环。
- en: For discontinuous ranges of numbers, use a `java.util.BitSet`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不连续的数字范围，使用`java.util.BitSet`。
- en: Discussion
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'To process a contiguous set of integers, Java provides both `range()` / `rangeClosed()`
    methods in the `IntStream` and `LongStream` classes. These take a starting and
    ending number; `range()` excludes the ending number while `rangeClosed()` closes
    on, or includes, the ending number. You can also iterate over a range of numbers
    using the traditional `for` loop. Loop control for the `for` loop is in three
    parts: initialize, test, and change. If the test part is initially false, the
    loop will never be executed, not even once. You can iterate over the elements
    of an array or collection (see [Chapter 7](ch07.html#javacook-structure)) using
    a for-each loop.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理连续的整数集合，Java提供了`IntStream`和`LongStream`类中的`range()` / `rangeClosed()`方法。它们接受起始和结束数字；`range()`排除结束数字，而`rangeClosed()`包含结束数字。你还可以使用传统的`for`循环迭代一系列数字。`for`循环的循环控制有三个部分：初始化、测试和更改。如果测试部分最初为false，则循环永远不会执行，即使一次也不会执行。你可以使用for-each循环来迭代数组或集合的元素（参见[第7章](ch07.html#javacook-structure)）。
- en: The program in [Example 5-5](#javacook-numbers-EX-NUMBER) demonstrates these
    techniques.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 5-5](#javacook-numbers-EX-NUMBER)中的程序演示了这些技术。'
- en: Example 5-5\. main/src/main/java/numbers/NumSeries.java
  id: totrans-170
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-5\. main/src/main/java/numbers/NumSeries.java
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 5.8 Formatting with Correct Plurals
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.8 使用正确的复数格式化
- en: Problem
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You’re printing something like `"We used " + n + " items"`, but in English,
    “We used 1 items” is ungrammatical. You want “We used 1 item.”
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在打印类似于`"We used " + n + " items"`的内容，但在英语中，“We used 1 items”是不符合语法的。你想要的是“We
    used 1 item。”
- en: Solution
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use a `ChoiceFormat` or a conditional statement.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ChoiceFormat`或条件语句。
- en: 'Use Java’s ternary operator (`cond ? trueval` : `falseval`) in a string concatenation.
    Both zero and plurals get an “s” appended to the noun in English (“no books, one
    book, two books”), so we test for `n==1`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '在字符串连接中使用Java的三元运算符（`cond ? trueval` : `falseval`）。在英语中，零和复数的名词都会附加“s”（“no
    books, one book, two books”），因此我们测试`n==1`：'
- en: '[PRE27]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Does it work?
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 它有效吗？
- en: '[PRE28]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The final `println` statement is effectively equivalent to the following:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的`println`语句与以下内容实际上等效：
- en: '[PRE29]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This is a lot longer, so the ternary conditional operator is worth learning.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这样写会更长，所以学会使用三元条件运算符是值得的。
- en: 'The `ChoiceFormat` is ideal for this. It is actually capable of much more,
    but here I’ll show only this simplest use. I specify the values 0, 1, and 2 (or
    more), and the string values to print corresponding to each number. The numbers
    are then formatted according to the range they fall into:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个问题，`ChoiceFormat`非常理想。实际上，它能做的远不止这些，但我只展示最简单的用法。我指定了值0、1和2（或更多）以及对应于每个数字的要打印的字符串值。然后根据它们所属的范围来格式化数字：
- en: '[PRE30]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This generates the same output as the basic version. It is slightly longer,
    but more general, and lends itself better to internationalization.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这与基本版本生成的输出相同。它略长一些，但更通用，更适合国际化。
- en: See Also
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: In addition to `ChoiceFormat`, the same result can be achieved with a `MessageFormat`.
    The online source in file *main/src/main/java/i18n/MessageFormatDemo.java* has
    an example.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用`ChoiceFormat`，还可以通过`MessageFormat`达到相同的效果。文件*main/src/main/java/i18n/MessageFormatDemo.java*中有一个示例。
- en: 5.9 Generating Random Numbers
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.9 生成随机数
- en: Problem
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to generate pseudorandom numbers in a hurry.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要快速生成伪随机数。
- en: Solution
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use `java.lang.Math.random()` to generate random numbers. There is no claim
    that the random values it returns are very *good* random numbers, however. Like
    most software-only implementations, these are *Pseudorandom Number Generators*
    (PRNGs), meaning that the numbers are not totally random, but devised from an
    algorithm. That said, they are adequate for casual use. This code exercises the
    `random()` method:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`java.lang.Math.random()`来生成随机数。不能保证它返回的随机值非常*好*，然而。像大多数仅软件实现一样，这些都是*伪随机数生成器*（PRNGs），意味着这些数字不是完全随机的，而是根据算法设计的。尽管如此，它们对于日常使用是足够的。这段代码演示了`random()`方法：
- en: '[PRE31]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Note that this method only generates double values. If you need integers, construct
    a `java.util.Random` object and call its `nextInt()` method; if you pass it an
    integer value, this will become the upper bound. Here I generate integers from
    1 to 10:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这种方法只生成双精度浮点数。如果需要整数，请构造一个`java.util.Random`对象并调用其`nextInt()`方法；如果传递整数值，这将成为上限。这里我生成了从1到10的整数：
- en: '[PRE32]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To see if my `RandomInt` demo was really working well, I used the Unix tools
    *sort* and *uniq*, which together give a count of how many times each value was
    chosen. For 1,000 integers, each of 10 values should be chosen about 100 times.
    I ran it twice to get a better idea of the distribution:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看我的`RandomInt`演示是否真的运行良好，我使用了Unix工具*sort*和*uniq*，它们一起给出每个值被选择多少次的计数。对于1,000个整数，每个值应该被选择大约100次。我运行了两次以更好地了解分布情况：
- en: '[PRE33]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The next step is to run these through a statistical program to see how really
    random they are; we’ll return to this in a minute.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是通过统计程序运行这些数据，看看它们真的有多随机；我们将在一分钟内返回这个问题。
- en: 'In general, to generate random numbers, you need to construct a `java.util.Random`
    object (not just any old random object) and call its `next*()` methods. These
    methods include `nextBoolean()`, `nextBytes()` (which fills the given array of
    bytes with random values), `nextDouble()`, `nextFloat()`, `nextInt()`, and `nextLong()`.
    Don’t be confused by the capitalization of `Float`, `Double`, etc. They return
    the primitive types `boolean`, `float`, `double`, etc., not the capitalized wrapper
    objects. Clear enough? Maybe an example will help:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，要生成随机数，您需要构造一个`java.util.Random`对象（不只是任意的随机对象）并调用其`next*()`方法。这些方法包括`nextBoolean()`、`nextBytes()`（它用随机值填充给定的字节数组）、`nextDouble()`、`nextFloat()`、`nextInt()`和`nextLong()`。不要被`Float`、`Double`等的大写所迷惑。它们返回基本类型`boolean`、`float`、`double`等，而不是大写的包装对象。清楚了吗？也许一个例子会有所帮助：
- en: '[PRE34]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: A fixed value (*starting seed*) can be provided to generate repeatable values,
    as for testing. You can also use the `java.util.Random nextGaussian()` method,
    as shown next. The `nextDouble()` methods try to give a flat distribution between
    0 and 1.0, in which each value has an equal chance of being selected. A Gaussian
    or normal distribution is a bell curve of values from negative infinity to positive
    infinity, with the majority of the values around zero (0.0).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 可以提供一个固定值（*起始种子*）以生成可重复的值，例如用于测试。您还可以使用`java.util.Random nextGaussian()`方法，如下所示。`nextDouble()`方法试图在0到1.0之间提供一个平坦的分布，其中每个值被选择的机会相等。高斯或正态分布是一个从负无穷到正无穷的钟形曲线，大多数值围绕着零（0.0）。
- en: '[PRE35]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: To illustrate the different distributions, I generated 10,000 numbers using
    `nextRandom()` first and then using `nextGaussian()`. The code for this is in
    *Random4.java* (not shown here) and is a combination of the previous programs
    with code to print the results into files. I then plotted histograms using the
    R statistics package (see [Chapter 11](ch11.html#javacook-ds) and [*http://www.r-project.org*](http://www.r-project.org)).
    The R script used to generate the graph, *randomnesshistograms.r*, is in *javasrc*
    under *main/src/main/resources*. The results are shown in [Figure 5-1](#javacook-numbers-FIG-1).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明不同的分布，我首先使用`nextRandom()`生成了10,000个数字，然后使用`nextGaussian()`。这个代码在*Random4.java*中（这里未显示），是前几个程序的组合，并包含将结果打印到文件的代码。然后使用R统计包绘制了直方图（参见[第11章](ch11.html#javacook-ds)和[*http://www.r-project.org*](http://www.r-project.org)）。用于生成图表的R脚本*randomnesshistograms.r*位于*javasrc*下的*main/src/main/resources*中。结果显示在[图5-1](#javacook-numbers-FIG-1)中。
- en: Looks like both PRNGs do their job!
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来两个PRNG都在做它们的工作！
- en: '![jcb4 0501](assets/jcb4_0501.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![jcb4 0501](assets/jcb4_0501.png)'
- en: Figure 5-1\. Flat (left) and Gaussian (right) distributions
  id: totrans-207
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-1。平坦（左）和高斯（右）分布
- en: See Also
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The javadoc documentation for `java.util.Random`, and the warning in [Recipe
    5.0](#javacook-numbers-intro) about pseudorandomness versus real randomness.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.Random`的javadoc文档，以及[Recipe 5.0](#javacook-numbers-intro) 中关于伪随机性与真随机性的警告。'
- en: For cryptographic use, see class `java.security.SecureRandom`, which provides
    cryptographically strong pseudorandom number generators.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 对于加密用途，请参阅`java.security.SecureRandom`类，它提供了具有密码强度的伪随机数生成器。
- en: 5.10 Multiplying Matrices
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.10 矩阵相乘
- en: Problem
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to multiply a pair of two-dimensional arrays, as is common in mathematical
    and engineering applications.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要计算一对二维数组的乘积，这在数学和工程应用中很常见。
- en: Solution
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the following code as a model.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码作为模型。
- en: Discussion
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: It is straightforward to multiply an array of a numeric type. In real life you
    would probably use a full-blown package such as the [Efficient Java Matrix Library
    (EJML)](http://ejml.org/wiki/index.php?title=Main_Page) or DeepLearning4Java’s
    [ND4J package](https://deeplearning4j.org/docs/latest/nd4j-overview). However
    a simple implementation can serve to show the concepts involved; the code in [Example 5-6](#javacook-numbers-EX-3)
    implements matrix multiplication.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在数值类型的数组中进行乘法运算是很直接的。在实际应用中，您可能会使用完整的包，比如[Efficient Java Matrix Library (EJML)](http://ejml.org/wiki/index.php?title=Main_Page)或DeepLearning4Java的[ND4J
    package](https://deeplearning4j.org/docs/latest/nd4j-overview)。然而，一个简单的实现可以展示所涉及的概念；[示例 5-6](#javacook-numbers-EX-3)
    中的代码实现了矩阵乘法。
- en: Example 5-6\. Matrix.java
  id: totrans-218
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-6\. Matrix.java
- en: '[PRE36]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here is a program that uses the `Matrix` class to multiply two arrays of `int`s:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个使用`Matrix`类来计算两个`int`数组乘积的程序：
- en: '[PRE37]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: See Also
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Consult a book on numerical methods for more things to do with matrices; one
    of our reviewers recommends the series of *Numerical Recipes* books, available
    from [*http://nrbook.com*](http://nrbook.com). (Note that this site has a link
    to their new web presence, [*https://numerical.recipes*](https://numerical.recipes)
    however, that site requires Adobe Flash, which most browsers no longer support
    due to security concerns.) There are several translations of the book’s code into
    various languages, including [Java](http://numerical.recipes/aboutJava.html).
    Pricing varies by package.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 查阅数值方法书籍以获取更多有关矩阵的操作；我们的一位评论员推荐系列书籍*《数值秘籍》*，可在[*http://nrbook.com*](http://nrbook.com)获取。
    （请注意，该站点有链接到他们的新网站，[*https://numerical.recipes*](https://numerical.recipes)，但该站点需要Adobe
    Flash，大多数浏览器由于安全原因不再支持。）书中的代码有多种语言的翻译版本，包括[Java](http://numerical.recipes/aboutJava.html)。价格因套餐而异。
- en: Commercial software packages can do some of these calculations for you; for
    one example, see the numeric libraries available from [Rogue Wave Software](http://www.roguewave.com).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 商业软件包可以为您执行一些计算；例如，您可以查看[Rogue Wave Software](http://www.roguewave.com)提供的数值库。
- en: 5.11 Using Complex Numbers
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.11 使用复数
- en: Problem
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to manipulate complex numbers, as is common in mathematical, scientific,
    or engineering applications.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要处理复数，这在数学、科学或工程应用中很常见。
- en: Solution
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Java does not provide any explicit support for dealing with complex numbers.
    You could keep track of the real and imaginary parts and do the computations yourself,
    but that is not a very well-structured solution.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Java没有提供专门支持处理复数的功能。你可以跟踪实部和虚部并自行计算，但这不是一个很好的解决方案。
- en: 'A better solution, of course, is to use a class that implements complex numbers.
    I once wrote just such a class, but now I recommend using the Apache Commons Math
    library for this. The build coordinates for this are `org.apache.commons:commons-math3:3.6.1`
    (or later). First, an example of using Apache’s library:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，更好的解决方案是使用实现复数的类。我曾经写过这样的一个类，但现在我建议使用Apache Commons Math库。这个库的构建坐标是`org.apache.commons:commons-math3:3.6.1`（或更新版本）。首先，让我们看一个使用Apache库的例子：
- en: '[PRE38]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Running this demo program produces the following output:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个演示程序会产生以下输出：
- en: '[PRE39]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[Example 5-7](#javacook-numbers-EX-4) is the source for my version of the `Complex`
    class and shouldn’t require much explanation. The Apache one is admittedly more
    sophisticated, but I leave mine here just to demystify the basic operation of
    complex numbers.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 5-7](#javacook-numbers-EX-4) 是我版本的`Complex`类的源代码，不需要过多解释。尽管Apache版本更加复杂，但我留下我的版本只是为了解释复数的基本操作。'
- en: To keep the API general, I provide—for each of add, subtract, and multiply—both
    a static method that works on two complex objects and a nonstatic method that
    applies the operation to the given object and one other object.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持 API 的通用性，我为每个 add、subtract 和 multiply 操作都提供了一个静态方法，用于两个复杂对象，以及一个非静态方法，将操作应用于给定对象和另一个对象。
- en: Example 5-7\. main/src/main/java/numbers/Complex.java
  id: totrans-236
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-7\. main/src/main/java/numbers/Complex.java
- en: '[PRE40]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 5.12 Handling Very Large Numbers
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.12 处理非常大的数字
- en: Problem
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to handle integer numbers larger than `Long.MAX_VALUE` or floating-point
    values larger than `Double.MAX_VALUE`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要处理大于 `Long.MAX_VALUE` 的整数或大于 `Double.MAX_VALUE` 的浮点数值。
- en: Solution
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the `BigInteger` or `BigDecimal` values in package `java.math`, as shown
    in [Example 5-8](#javacook-recipe-BigNums).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `java.math` 包中使用 `BigInteger` 或 `BigDecimal` 值，如 [示例 5-8](#javacook-recipe-BigNums)
    所示。
- en: Example 5-8\. main/src/main/java/numbers/BigNums.java
  id: totrans-243
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-8\. main/src/main/java/numbers/BigNums.java
- en: '[PRE41]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note that the constructor takes the number as a string. Obviously you couldn’t
    just type the numeric digits because, by definition, these classes are designed
    to represent numbers larger than will fit in a Java `long`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 注意构造函数将数字作为字符串。显然，您不能只键入数值数字，因为按定义，这些类设计用于表示超过 Java `long` 能容纳的数字。
- en: Discussion
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Both `BigInteger` and `BigDecimal` objects are immutable; that is, once constructed,
    they always represent a given number. That said, a number of methods return new
    objects that are mutations of the original, such as `negate()`, which returns
    the negative of the given `BigInteger` or `BigDecimal`. There are also methods
    corresponding to most of the Java language built-in operators defined on the base
    types `int`/`long` and `float`/`double`. The division method makes you specify
    the rounding method; consult a book on numerical analysis for details. [Example 5-9](#javacook-numbers-EX-5)
    is a simple stack-based calculator using `BigDecimal` as its numeric data type.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`BigInteger` 和 `BigDecimal` 对象都是不可变的；也就是说，一旦构造完成，它们始终表示一个给定的数字。尽管如此，许多方法会返回原始对象的新对象，例如
    `negate()` 方法，它返回给定 `BigInteger` 或 `BigDecimal` 的负数。还有许多方法对应于 Java 语言中基本类型 `int`/`long`
    和 `float`/`double` 上定义的大多数内置运算符。除法方法需要指定舍入方法；有关详细信息，请参阅数值分析书籍。[示例 5-9](#javacook-numbers-EX-5)
    是一个简单的基于堆栈的计算器，使用 `BigDecimal` 作为其数值数据类型。'
- en: Example 5-9\. main/src/main/java/numbers/BigNumCalc.java
  id: totrans-248
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-9\. main/src/main/java/numbers/BigNumCalc.java
- en: '[PRE42]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Running this produces the expected (very large) value:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此程序将生成预期的（非常大的）值：
- en: '[PRE43]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The current version has its inputs hardcoded, as does the JUnit test program,
    but in real life you can use regular expressions to extract words or operators
    from an input stream (as in [Recipe 4.5](ch04.html#javacook-regex-SECT-5)), or
    you can use the `StreamTokenizer` approach of the simple calculator (see [Recipe
    10.5](ch10.html#javacook-io-SECT-4)). The stack of numbers is maintained using
    a `java.util.Stack` (see [Recipe 7.16](ch07.html#javacook-structure-SECT-14)).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当前版本的输入是硬编码的，JUnit 测试程序也是如此，但在实际应用中，您可以使用正则表达式从输入流中提取单词或操作符（如 [Recipe 4.5](ch04.html#javacook-regex-SECT-5)
    中所述），或者可以使用简单计算器的 `StreamTokenizer` 方法（请参阅 [Recipe 10.5](ch10.html#javacook-io-SECT-4)）。数字堆栈是使用
    `java.util.Stack` 维护的（请参阅 [Recipe 7.16](ch07.html#javacook-structure-SECT-14)）。
- en: '`BigInteger` is mainly useful in cryptographic and security applications. Its
    method `isProbablyPrime()` can create prime pairs for public key cryptography.
    `BigDecimal` might also be useful in computing the size of the universe.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`BigInteger` 主要用于加密和安全应用。其方法 `isProbablyPrime()` 可以为公钥密码生成素数对。`BigDecimal`
    在计算宇宙大小时也可能很有用。'
- en: '5.13 Program: TempConverter'
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.13 程序：TempConverter
- en: The program shown in [Example 5-10](#javacook-numbers-EX-6) prints a table of
    Fahrenheit temperatures (still used in daily weather reporting in the US and its
    territories, Liberia, and some countries in the Caribbean) and the corresponding
    Celsius temperatures (used in science everywhere and in daily life in the rest
    of the world).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 5-10](#javacook-numbers-EX-6) 中显示的程序打印了华氏温度表（仍然在美国及其领土、利比里亚和一些加勒比国家的日常天气报告中使用），以及相应的摄氏温度（在全球科学界和其他地方的日常生活中使用）。'
- en: Example 5-10\. main/src/main/java/numbers/TempConverter.java
  id: totrans-256
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-10\. main/src/main/java/numbers/TempConverter.java
- en: '[PRE44]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This works, but these numbers print with about 15 digits of (useless) decimal
    fractions! The second version of this program subclasses the first and uses `printf`
    (see [Recipe 10.4](ch10.html#javacook-io-SECT-3)) to control the formatting of
    the converted temperatures (see [Example 5-11](#javacook-numbers-EX-7)). It will
    now look right, assuming you’re printing in a monospaced font.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这有效，但这些数字打印时带有约15位（无用的）小数部分！此程序的第二个版本是第一个版本的子类，并使用`printf`（参见[配方 10.4](ch10.html#javacook-io-SECT-3)）控制转换后温度的格式（参见[示例 5-11](#javacook-numbers-EX-7)）。现在它看起来正常，假设您正在等宽字体中打印。
- en: Example 5-11\. main/src/main/java/numbers/TempConverter2.java
  id: totrans-259
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-11\. main/src/main/java/numbers/TempConverter2.java
- en: '[PRE45]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '5.14 Program: Number Palindromes'
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.14 程序：数字回文
- en: 'My wife, Betty, recently reminded me of a theorem that I must have studied
    in high school but whose name I have long since forgotten: that any positive integer
    number can be used to generate a palindrome by adding to it the number comprised
    of its digits in reverse order. Palindromes are sequences that read the same in
    either direction, such as the name “Anna” or the phrase “Madam, I’m Adam” (ignoring
    spaces and punctuation). We normally think of palindromes as composed of text,
    but the concept can be applied to numbers: 13,531 is a palindrome. Start with
    the number 72, for example, and add to it the number 27\. The results of this
    addition is 99, which is a (short) palindrome. Starting with 142, add 241, and
    you get 383\. Some numbers take more than one try to generate a palindrome. 1,951
    + 1,591 yields 3,542, which is not palindromic. The second round, however, 3,542
    + 2,453, yields 5,995, which is. The number 17,892, which my son Benjamin picked
    out of the air, requires 12 rounds to generate a palindrome, but it does terminate:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我的妻子贝蒂最近提醒我一个定理，我高中时肯定学过，但其名称我早已忘记：任何正整数都可以通过将其与其数字逆序构成的数相加来生成一个回文数。回文数是指在任何方向上都读取相同的序列，例如姓名“安娜”或短语“Madam,
    I’m Adam”（忽略空格和标点）。我们通常认为回文是由文本组成的，但这个概念也可以应用于数字：13,531是一个回文数。例如，从数字72开始，加上其反向数字27。这个加法的结果是99，是一个（短）回文数。从142开始，加上241，得到383。有些数字需要多次尝试才能生成回文数。例如，1,951
    + 1,591得到3,542，不是回文的。然而，第二轮，3,542 + 2,453得到5,995，是回文的。我儿子本杰明随意挑选了17,892，需要12轮才能生成一个回文数，但最终还是成功了：
- en: '[PRE47]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If this sounds to you like a natural candidate for recursion, you are correct.
    *Recursion* involves dividing a problem into simple and identical steps that can
    be implemented by a function that calls itself and provides a way of termination.
    Our basic approach, as shown in method `findPalindrome`, is this:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对您来说这听起来像是递归的一个自然候选项，那么您是正确的。*递归*涉及将问题分解为简单且相同的步骤，可以由调用自身的函数实现，并提供终止的方式。如我们所示的`findPalindrome`方法的基本方法如下：
- en: '[PRE48]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: That is, if the starting number is already a palindromic number, return it;
    otherwise, add it to its reverse, and try again. The version of the code shown
    here handles simple cases directly (single digits are always palindromic, for
    example). We won’t think about negative numbers because these have a character
    at the front that loses its meaning if placed at the end, and hence are not strictly
    palindromic. Further, palindromic forms of certain numbers are too long to fit
    in Java’s 64-bit `long` integer. These cause underflow, which is trapped. As a
    result, an error message like “too big” is reported.^([3](ch05.html#idm45290676556776))
    Having said all that, [Example 5-12](#javacook-numbers-EX-9) shows the code.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，如果起始数字已经是回文数，返回它；否则，将它加到它的反向数字上，并再次尝试。此处显示的代码版本直接处理简单情况（例如单个数字始终是回文的）。我们不考虑负数，因为这些负数有一个位于末尾时会失去意义的字符，并且因此不严格是回文的。此外，某些数字的回文形式太长，无法适应Java的64位`long`整数。这会导致下溢，被捕获。因此，会报告“太大”的错误消息。^([3](ch05.html#idm45290676556776))说了这么多，[示例 5-12](#javacook-numbers-EX-9)展示了这段代码。
- en: Example 5-12\. main/src/main/java/numbers/Palindrome.java
  id: totrans-268
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-12\. main/src/main/java/numbers/Palindrome.java
- en: '[PRE49]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'While it’s not strictly a numerical solution, Daniel Hinojosa noted that you
    can use `StringBuilder` to do the reversal portion, resulting in shorter, more
    elegant code that is only fractionally slower:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它不严格是一个数值解决方案，但丹尼尔·伊诺霍萨指出，您可以使用`StringBuilder`来执行反转部分，从而得到更短、更优雅的代码，只有稍微慢一点：
- en: '[PRE50]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: A full version of his code is in the file *PalindromeViaStringBuilder.java*.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 他的完整代码版本在文件*PalindromeViaStringBuilder.java*中。
- en: See Also
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: People using Java in scientific or large-scale numeric computing may wish to
    check out the value types forthcoming from [“Project Valhalla” in Java](https://wiki.openjdk.java.net/display/valhalla/Main).
    See also a 2019 presentation titled [“Vectors and Numerics on the JVM”](https://www.youtube.com/watch?v=UlnoCj4B8pU).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Java 进行科学或大规模数值计算的人士可能希望关注即将推出的值类型，来自 [Java 的“Valhalla 项目”](https://wiki.openjdk.java.net/display/valhalla/Main)。另请参阅2019年的演示标题为
    [“JVM 上的向量和数值计算”](https://www.youtube.com/watch?v=UlnoCj4B8pU)。
- en: ^([1](ch05.html#idm45290682381560-marker)) For a low-cost source of randomness,
    check out the now-defunct [Lavarand](http://en.wikipedia.org/wiki/Lavarand). The
    process used digitized video of 1970s lava lamps to provide “hardware-based” randomness.
    Fun!
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch05.html#idm45290682381560-marker)) 低成本的随机源，请查看现已停止运行的 [Lavarand](http://en.wikipedia.org/wiki/Lavarand)。该过程利用了1970年代的熔岩灯视频进行“硬件基础”的随机性提供。有趣！
- en: ^([2](ch05.html#idm45290681215064-marker)) Note that an expression consisting
    entirely of compile-time constants, like `Math.PI \* 2.1e17`, is also considered
    to be Strict-FP.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch05.html#idm45290681215064-marker)) 请注意，完全由编译时常量组成的表达式，如 `Math.PI \*
    2.1e17`，也被视为 Strict-FP。
- en: ^([3](ch05.html#idm45290676556776-marker)) Certain values do not work; for example,
    Ashish Batia reported that this version gets an exception on the value 8,989 (which
    it does).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch05.html#idm45290676556776-marker)) 某些数值不适用；例如，Ashish Batia 报告说这个版本在数值
    8,989 上会抛出异常（确实如此）。
