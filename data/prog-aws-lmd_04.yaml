- en: Chapter 4\. Operating AWS Lambda Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章 运行 AWS Lambda 函数
- en: This chapter will introduce a more advanced method of building and packaging
    Java-based AWS Lambda functions. We’ll also go into more detail on the serverless-oriented
    version of AWS’s infrastructure-as-code tool, SAM, which you first used in [Chapter 2](ch02.html#ch02).
    Finally, we’ll go over how Lambda functions and serverless applications are affected
    by AWS’s security model and how to use SAM to automatically enforce a least-privilege
    security model for our serverless application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍一种更高级的构建和打包基于 Java 的 AWS Lambda 函数的方法。我们还将更详细地介绍面向无服务器的 AWS 基础设施即代码工具 SAM
    的版本，您在[第2章](ch02.html#ch02)中首次使用过。最后，我们将讨论 Lambda 函数和无服务器应用如何受 AWS 安全模型的影响，以及如何使用
    SAM 自动实施无服务器应用的最小特权安全模型。
- en: Before proceeding, we recommend that if you haven’t done so already that you
    download this book’s [code examples](https://oreil.ly/t0Bgg).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们建议您如果尚未这样做，请下载本书的[代码示例](https://oreil.ly/t0Bgg)。
- en: Build and Package
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和打包
- en: The Lambda platform expects all user-provided code to be in the form of a [ZIP](https://oreil.ly/aECWk)
    archive file. Depending on which runtime you’re using and your actual business
    logic, that ZIP file may consist of source code, or code and libraries, or, in
    the case of Java, compiled byte code (class files) and libraries.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 平台期望所有用户提供的代码以 [ZIP](https://oreil.ly/aECWk) 归档文件的形式提供。根据您使用的运行时和实际业务逻辑，该
    ZIP 文件可能包含源代码，或代码和库，或者在 Java 的情况下，已编译的字节码（类文件）和库。
- en: In the Java ecosystem, we often package our code into JAR (Java ARchive) files,
    to be run via the `java -jar` command, or to be used as libraries by other applications.
    It turns out that a JAR file is simply a ZIP file with some additional metadata.
    The Lambda platform doesn’t perform any special handling of JAR files—it treats
    them as ZIP files, just as it does for the other Lambda language runtimes.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 生态系统中，我们经常将代码打包成 JAR（Java ARchive）文件，通过 `java -jar` 命令运行，或者被其他应用程序用作库。事实证明，JAR
    文件只是带有一些附加元数据的 ZIP 文件。Lambda 平台不会对 JAR 文件执行任何特殊处理——它将它们视为 ZIP 文件，就像对其他 Lambda
    语言运行时一样。
- en: Using a tool like Maven, we can specify the other libraries that our code depends
    on and have Maven download the right versions of those libraries (and any transitive
    dependencies that they might have), compile our code into Java class files, and
    package everything up into a single JAR file (often called an *uberjar*).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像 Maven 这样的工具，我们可以指定代码依赖的其他库，并让 Maven 下载这些库的正确版本（以及它们可能具有的任何传递依赖关系），将我们的代码编译成
    Java 类文件，并将所有内容打包到一个单独的 JAR 文件中（通常称为*uberjar*）。
- en: Uberjars
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超级JAR
- en: Despite using the uberjar approach in Chapters [2](ch02.html#ch02) and [3](ch03.html#ch03),
    there are a few problems with it that are worth calling out before we go any further.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在[第2章](ch02.html#ch02)和[第3章](ch03.html#ch03)中使用了超级jar方法，但在我们继续之前，值得指出一些它存在的问题。
- en: First, the uberjar approach unpacks and then overlays libraries on top of each
    other in the target uberjar file. In the following example, Library A contains
    a class file and a properties file. Library B contains a different class file
    and a properties file with the same name as the properties file from Library A.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，超级jar方法会在目标超级jar文件中解压并叠加库。在以下示例中，库 A 包含一个类文件和一个属性文件。库 B 包含一个不同的类文件和一个与库 A
    的属性文件同名的属性文件。
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If these JAR files were used to create an uberjar (as we did in prior chapters),
    the result would contain two class files and one properties file—but the properties
    file from which source JAR?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些 JAR 文件用于创建超级jar（正如我们在之前的章节中所做的那样），则结果将包含两个类文件和一个属性文件——但是该属性文件来源于哪个源 JAR？
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Because the JAR files are unpacked and overlaid, only one of those properties
    files will make it into the final uberjar, and it can be difficult to know which
    one will win without delving into the dark arts of Maven resource transformers.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 JAR 文件被解压和叠加，所以只有一个属性文件会进入最终的超级 JAR 文件，而且如果不深入了解 Maven 资源转换器的黑暗艺术，很难知道哪一个会获胜。
- en: The second major issue with the uberjar approach is oriented around creating
    a JAR file—the fact that JAR files are also ZIP files that can be used by the
    Lambda runtime is incidental from the perspective of the Maven build process.
    Two specific issues arise from this JAR versus ZIP situation. One is that any
    JAR-specific metadata is unused (and in fact, ignored) by the Lambda runtime.
    Things like a `Main-Class` attribute in a *MANIFEST.MF* file—a piece of metadata
    common to JAR files—are meaningless in the context of a Lambda function.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 超级JAR方法的第二个主要问题与创建JAR文件有关——事实上，从Maven构建过程的角度来看，JAR文件也是可以被Lambda运行时使用的ZIP文件的一个附属品。从这个JAR与ZIP的角度来看，有两个特定的问题。其中一个是JAR特定的元数据在Lambda运行时是无用的（实际上会被忽略）。例如，*MANIFEST.MF*文件中的`Main-Class`属性——这是JAR文件常见的元数据，在Lambda函数的上下文中是毫无意义的。
- en: Furthermore, the JAR creation process itself introduces a certain amount of
    non-determinism into the build process. For example, tool versions and build timestamps
    are recorded in *MANIFEST.MF* and *pom.properties* files—and that makes it impossible
    to reproducibly build the same JAR file from the same source code every time.
    This nonreproducibility wreaks havoc on downstream caching, deployment, and security
    processes, so we want to avoid it when possible.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，JAR 文件创建过程本身会在构建过程中引入一定程度的非确定性。例如，工具版本和构建时间戳记录在*MANIFEST.MF*和*pom.properties*文件中，这使得无法每次都从相同的源代码可重现地构建相同的JAR文件。这种不可重复性会对下游的缓存、部署和安全流程造成严重影响，因此我们希望在可能的情况下避免这种情况。
- en: Since we’re not actually interested in the JAR-ness of an uberjar file, it makes
    sense for us to consider not using the uberjar process at all. Of course, the
    uberjar process itself isn’t necessarily the only source of nondeterminism in
    our build process, but we’ll deal with the rest of it later.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们实际上并不关心超级JAR文件的JAR 特性，所以考虑根本不使用超级JAR 过程对我们来说是有意义的。当然，超级JAR 过程本身并不一定是构建过程中唯一的非确定性源，但我们将稍后处理其余部分。
- en: Despite these drawbacks, the uberjar process is simpler to configure and use
    for simple cases, especially when a Lambda function has few (or no) third-party
    dependencies. This was the case in the examples in Chapters [2](ch02.html#ch02)
    and [3](ch03.html#ch03), which is why we used the uberjar technique up until this
    point, but for any real-world use of Java and Lambda of any significant scale,
    we recommend the ZIP file approach that we describe next.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在这些缺点，对于简单情况，特别是当Lambda函数几乎没有（或没有）第三方依赖时，超级JAR过程更简单配置和使用。这在第[2](ch02.html#ch02)章和第[3](ch03.html#ch03)章的示例中就是这种情况，这也是我们在这一点上使用超级JAR技术的原因，但对于任何规模较大的Java和Lambda的实际用途，我们建议采用接下来我们描述的ZIP文件方法。
- en: Assembling a ZIP File
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组装ZIP文件
- en: So, in the Java world, our alternative to using an uberjar file is to fall back
    to a trusty old ZIP file. In this scenario, the archive layout is going to be
    a little different, but we’ll see how a careful approach can avoid the issues
    with the uberjar and give us an artifact that the Lambda platform can use. We’ll
    discuss how to achieve this using Maven, but of course you should feel free to
    translate this method to your preferred build tool—the outcome is more important
    than the process itself.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在Java世界中，我们使用ZIP文件作为超级JAR文件的替代方案。在这种情况下，归档布局会有所不同，但我们将看到如何通过谨慎的方法避免超级JAR的问题，并为Lambda平台提供一个可用的工件。我们将讨论如何使用Maven来实现这一点，但当然，你可以随意将这种方法翻译成你喜欢的构建工具——结果比过程本身更重要。
- en: To make a more interesting example, first we’ll add a dependency on the AWS
    SDK for DynamoDB to our Maven build for the Lambda function from [“Lambda Hello
    World (the Proper Way)”](ch02.html#java-hello-world).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了举一个更有趣的例子，首先我们将在我们的Maven构建中为Lambda函数添加对AWS SDK for DynamoDB的依赖，参见[“Lambda
    Hello World (the Proper Way)”](ch02.html#java-hello-world)。
- en: 'Add a `dependencies` section to the *pom.xml* file:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 向*pom.xml*文件添加一个`dependencies`部分：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'With that dependency added, here’s what the desired ZIP file layout looks like
    for our simple Lambda function and dependencies:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个依赖项，对于我们简单的Lambda函数及其依赖项，期望的ZIP文件布局如下：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In addition to our application code (*book/HelloWorld.class*), we see a *lib*
    directory full of JAR files, one for the AWS DynamoDB SDK, and one for each of
    its transitive dependencies.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们的应用程序代码（*book/HelloWorld.class*）之外，我们还看到一个包含多个JAR文件的*lib*目录，其中包括AWS DynamoDB
    SDK的一个文件以及每个传递依赖项的文件。
- en: We can build that ZIP output using the Maven Assembly plug-in. This plug-in
    allows us to add some special behavior to a specific part of the Maven build (in
    this case, the `package` phase where the results of the Java compilation process
    are packaged up alongside other resources into a set of output files).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Maven Assembly插件构建这个ZIP输出。这个插件允许我们向Maven构建的特定部分（在这种情况下是`package`阶段，在这个阶段中，Java编译过程的结果会与其他资源一起打包成一组输出文件）添加一些特殊的行为。
- en: 'First, we’ve configured the Maven Assembly plug-in in the *pom.xml* file for
    the project, in the `build` section:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在项目的*pom.xml*文件中为Maven Assembly插件进行了配置，在`build`部分：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The two most important parts of this configuration are the assembly `descriptor`,
    which is a path to another XML file in our project, and the `finalName`, which
    instructs the plug-in to name our output file *lambda.zip* instead of something
    else. We’ll see later how picking a simple `finalName` will aid in rapid iteration
    of our project, especially after we start using Maven submodules.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配置的两个最重要的部分是装配`descriptor`，它是项目中另一个XML文件的路径，以及`finalName`，它指示插件将我们的输出文件命名为*lambda.zip*而不是其他名称。稍后我们会看到，选择一个简单的`finalName`将有助于快速迭代我们的项目，特别是在我们开始使用Maven子模块之后。
- en: 'Most of the configuration for our ZIP file is actually located in the assembly
    `descriptor` file, which was referenced in the *pom.xml* file earlier. This `assembly`
    configuration is a description of exactly which contents to include in our output
    file:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们ZIP文件的大部分配置实际上位于装配`descriptor`文件中，这在之前的*pom.xml*文件中已经引用过。这个`assembly`配置描述了确切要包含在输出文件中的内容：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[![1](assets/1.png)](#co_operating_aws_lambda_functions_CO1-1)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_operating_aws_lambda_functions_CO1-1)'
- en: We’ve given the assembly a unique name, `lambda-zip`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们给这个装配取了一个唯一的名称，`lambda-zip`。
- en: '[![2](assets/2.png)](#co_operating_aws_lambda_functions_CO1-2)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_operating_aws_lambda_functions_CO1-2)'
- en: The output format itself will be of type `zip`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 输出格式本身将是`zip`类型。
- en: '[![3](assets/3.png)](#co_operating_aws_lambda_functions_CO1-3)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_operating_aws_lambda_functions_CO1-3)'
- en: The output file will not have a base directory—this means that when extracted,
    our ZIP file’s contents will be unpacked into the current directory rather than
    into a new subdirectory.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 输出文件将不会有基本目录 — 这意味着当我们解压缩时，ZIP文件的内容将被解压到当前目录而不是新的子目录中。
- en: '[![4](assets/4.png)](#co_operating_aws_lambda_functions_CO1-4)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_operating_aws_lambda_functions_CO1-4)'
- en: The first `dependencySet` section explicitly includes our application code,
    by referencing the project’s `groupId` and `artifactId` properties. When we start
    using Maven submodules, this will need to be altered. Our application code will
    be “unpacked.” That is, it won’t be contained in a JAR file; rather, it will just
    be a normal directory structure and Java *.class* files. We’ve also explicitly
    excluded the unnecessary *META-INF* directory.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`dependencySet`部分明确包含了我们的应用代码，通过引用项目的`groupId`和`artifactId`属性。当我们开始使用Maven子模块时，这将需要进行修改。我们的应用代码将会被“解包”。也就是说，它不会被包含在一个JAR文件中；而是普通的目录结构和Java的`.class`文件。我们还明确地排除了不必要的*META-INF*目录。
- en: '[![5](assets/5.png)](#co_operating_aws_lambda_functions_CO1-5)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_operating_aws_lambda_functions_CO1-5)'
- en: The second `dependencySet` section handles our application’s dependencies. We
    exclude the project’s artifact (as it was handled in the first `dependencySet`
    section). We only include dependencies that are in the `runtime` scope. We don’t
    unpack the dependencies; rather, we just leave them packaged as JAR files.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个`dependencySet`部分处理我们应用的依赖项。我们排除了项目的构件（因为它在第一个`dependencySet`部分已经处理过了）。我们只包括`runtime`范围内的依赖项。我们不会解包依赖项，而是将它们作为JAR文件保留。
- en: '[![6](assets/6.png)](#co_operating_aws_lambda_functions_CO1-6)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_operating_aws_lambda_functions_CO1-6)'
- en: Finally, instead of including all of the JAR files in the root of our output
    file, we’ll put them all into a *lib* directory.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们不会在输出文件的根目录中包含所有的JAR文件，而是将它们全部放入一个*lib*目录中。
- en: So how does this complicated new Maven configuration help us avoid the issues
    with uberjars?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这种复杂的新Maven配置如何帮助我们避免与uberjar相关的问题？
- en: First, we’ve stripped out some of the unnecessary META-INF information. You’ll
    notice we’ve been a bit selective—there are some cases where having META-INF information
    (like “services”) is still valuable, so we don’t want to get rid of it completely.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们剥离了一些不必要的META-INF信息。你会注意到我们有点选择性地做了一些处理 — 有些情况下保留META-INF信息（比如“services”）仍然很有价值，因此我们不希望完全摆脱它。
- en: Second, we’ve included all of our dependencies, but as individual JAR files
    in a *lib* directory. This avoids the file and path overwriting issue completely.
    Each dependency JAR remains self-contained. According to the AWS Lambda [best
    practices documentation](https://oreil.ly/euF1U), this approach also pays some
    performance dividends in that it’s faster for the Lambda platform to unpack a
    ZIP file and faster for the JVM to load classes from JAR files.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们已经包含了所有的依赖项，但是作为一个 *lib* 目录中的独立JAR文件。这样可以完全避免文件和路径覆盖问题。每个依赖JAR保持自包含。根据AWS
    Lambda的[最佳实践文档](https://oreil.ly/euF1U)，这种方法在某种程度上还带来了性能的提升，因为Lambda平台解压ZIP文件更快，JVM从JAR文件加载类也更快。
- en: Reproducible Builds
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可重现的构建
- en: When our source code or dependencies change, we expect the contents of the deployment
    package (the uberjar or ZIP file) to change too (after running our build and packaging
    process). However, when our source code and dependencies don’t change, the contents
    of the deployment package should remain the same even if the build and packaging
    process is executed again. The output of the build should be reproducible (e.g.,
    deterministic). This is important because downstream processes (like deployment
    pipelines) are often triggered based on whether a deployment package has changed
    as indicated by the MD5 hash of the contents, and we want to avoid triggering
    those processes unnecessarily.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的源代码或依赖关系发生变化时，我们期望部署包（uberjar或ZIP文件）的内容也会随之变化（在运行构建和打包过程后）。然而，当我们的源代码和依赖关系不变时，即使再次执行构建和打包过程，部署包的内容也应保持不变。构建的输出应该是可重复的（例如，确定性的）。这一点很重要，因为下游过程（如部署流水线）通常根据内容的MD5哈希是否改变来触发，我们希望避免不必要地触发这些过程。
- en: Even though we’ve eliminated the autogenerated *MANIFEST.MF* and *pom.properties*
    files using the `lambda-zip` assembly descriptor, we still haven’t removed all
    of the potential sources of nondeterminism in the build process. For example,
    when we build our application code (e.g., `HelloWorld`), the timestamp on the
    compiled Java class files may change. These altered timestamps are propagated
    into the ZIP file, and then the hash of the ZIP file’s contents changes even though
    the source code didn’t.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们使用 `lambda-zip` 组件描述符已经去除了自动生成的 *MANIFEST.MF* 和 *pom.properties* 文件，但我们仍然没有消除构建过程中所有潜在的不确定性来源。例如，当我们构建我们的应用代码（例如
    `HelloWorld`）时，编译的Java类文件的时间戳可能会更改。这些更改后的时间戳会传播到ZIP文件中，然后ZIP文件内容的哈希值会更改，即使源代码没有变化。
- en: 'Fortunately, a simple Maven plug-in exists to strip these sources of nondeterminism
    from our build process. The `reproducible-build-maven-plugin` can be executed
    during the build process and will render our output ZIP file completely deterministic.
    It can be configured as a `plugin` in the `build` section of our *pom.xml* file:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们的构建过程存在一个简单的Maven插件，可以消除这些源中的不确定性。`reproducible-build-maven-plugin` 可以在构建过程中执行，并且将我们的输出ZIP文件完全变为确定性的。它可以配置为
    *pom.xml* 文件中 `build` 部分的一个 `plugin`：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, when we rebuild our deployment packages multiple times using the same unchanged
    source code, the hash is always the same. You’ll see how this affects the deployment
    process in the next section.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们多次使用相同的未更改源代码重新构建部署包时，哈希值始终保持不变。您将在下一节中看到这如何影响部署过程。
- en: Deploy
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署
- en: There are many options for deploying Lambda code. Before we dive in, however,
    it’s worth clarifying what we mean by *deploy*. In this case, we’re simply talking
    about updating the code or configuration for a particular Lambda function, or
    a group of Lambda functions and related AWS resources, through the use of APIs
    or other services. We’re not extending the definition to include deployment orchestration
    (like AWS CodeDeploy).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多部署Lambda代码的选项。然而，在我们深入探讨之前，值得澄清一下我们所说的 *部署* 是什么意思。在这种情况下，我们仅仅是指通过API或其他服务更新特定Lambda函数或一组Lambda函数及相关AWS资源的代码或配置。我们没有将其定义扩展到包括部署编排（如AWS
    CodeDeploy）。
- en: 'In no particular order, the methods of deploying Lambda code are as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda代码的部署方法无特定顺序，如下所示：
- en: AWS Lambda web console
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS Lambda Web控制台
- en: AWS CloudFormation/Serverless Application Model (SAM)
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS CloudFormation/Serverless Application Model（SAM）
- en: AWS CLI (which uses the AWS API)
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS CLI（使用AWS API）
- en: AWS Cloud Development Kit (CDK)
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS Cloud开发工具包（CDK）
- en: Other AWS-developed frameworks, like Amplify and Chalice
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他由AWS开发的框架，如Amplify和Chalice
- en: Third-party frameworks targeting serverless components that build primarily
    on top of CloudFormation, like the Serverless Framework
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 针对主要基于 CloudFormation 构建的无服务器组件的第三方框架，例如 Serverless Framework
- en: Third-party tools and frameworks targeting serverless components that build
    primarily on top of the AWS API, like Claudia.js and `lambda-maven-plugin` from
    Maven
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 针对主要基于 AWS API 构建的无服务器组件的第三方工具和框架，例如 Claudia.js 和 `lambda-maven-plugin`（来自 Maven）
- en: General-purpose third-party infrastructure tools, like Ansible or Terraform
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像 Ansible 或 Terraform 这样的通用第三方基础设施工具
- en: In this book, we’ll address the first two (and indeed have already touched upon
    the AWS Lambda web console and SAM in Chapters [2](ch02.html#ch02) and [3](ch03.html#ch03)).
    We also use the AWS CLI, although not as a deployment tool. With a solid understanding
    of those methods, you should be able to evaluate the other options and decide
    whether one of them is a better fit for your environment and use case.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将讨论前两者（事实上，在[第2章](ch02.html#ch02)和[第3章](ch03.html#ch03)中我们已经涉及了 AWS Lambda
    Web 控制台和 SAM）。我们还使用 AWS CLI，尽管不是作为部署工具。通过对这些方法有坚实的了解，您应该能够评估其他选项，并决定其中之一是否更适合您的环境和用例。
- en: Infrastructure as Code
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础设施即代码
- en: When we interact with AWS via the web console or the CLI, we’re creating, updating,
    and destroying infrastructure manually. For example, if we create a Lambda function
    using the AWS Web Console, the next time we want to create a Lambda function with
    the same parameters, we still have to perform the same manual actions via the
    web console. This same characteristic applies to the CLI as well.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过 Web 控制台或 CLI 与 AWS 进行交互时，我们是手动创建、更新和销毁基础设施。例如，如果我们使用 AWS Web 控制台创建一个 Lambda
    函数，下次我们想要使用相同参数创建 Lambda 函数时，我们仍然必须通过 Web 控制台执行相同的手动操作。这一特性也适用于 CLI。
- en: For initial development and experimentation, this is a reasonable approach.
    However, when our projects begin building momentum, this manual approach to infrastructure
    management will turn into a roadblock. A well-proven way to address this issue
    is called *infrastructure as code*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于初步开发和实验，这是一个合理的方法。但是，当我们的项目开始积累动力时，手动管理基础设施的方法将成为一种障碍。解决这个问题的一个经过良好验证的方法称为*基础设施即代码*。
- en: 'Rather than manually interacting with AWS via the web console or CLI, we can
    declaratively specify our desired infrastructure in a JSON or YAML file and submit
    that file to AWS’s infrastructure-as-code service: CloudFormation. The CloudFormation
    service takes our input file and makes the necessary changes to AWS infrastructure
    on our behalf, taking into account resource dependencies, the current state of
    previously deployed versions of our app, and the idiosyncrasies and specific requirements
    of the various AWS services. A set of AWS resources created from a CloudFormation
    template file is called a *stack*.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必通过 Web 控制台或 CLI 手动与 AWS 交互，而是可以在 JSON 或 YAML 文件中声明性地指定我们期望的基础设施，并将该文件提交给
    AWS 的基础设施即代码服务：CloudFormation。CloudFormation 服务接受我们的输入文件，并代表我们对 AWS 基础设施进行必要的更改，考虑资源依赖关系、先前部署的应用程序版本的当前状态以及各种
    AWS 服务的特殊要求和特性。从 CloudFormation 模板文件创建的一组 AWS 资源称为*堆栈*。
- en: CloudFormation is AWS’s proprietary infrastructure-as-code service, but it’s
    not the only option in this area. Other popular choices that work with AWS are
    Terraform, Ansible, and Chef. Each service has its own configuration languages
    and patterns, but all achieve essentially the same outcome—cloud infrastructure
    provisioned from configuration files.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: CloudFormation 是 AWS 的专有基础设施即代码服务，但这并不是该领域的唯一选择。与 AWS 兼容的其他热门选择包括 Terraform、Ansible
    和 Chef。每个服务都有自己的配置语言和模式，但都实现了基本相同的结果——从配置文件中提供云基础设施。
- en: A key benefit of using configuration files (rather than pointing and clicking
    in the console) is that those files, which represent our application infrastructure,
    can be version-controlled alongside our application source code. We can see a
    complete timeline of changes to our infrastructure, using the same version-control
    tools we use for the other pieces of our application. Furthermore, we can incorporate
    those configuration files into our continuous deployment pipelines, so when we
    make changes to our application infrastructure, those changes can be rolled out
    safely using industry-standard tools, alongside our application code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用配置文件（而不是在控制台上点点点）的一个关键好处是，这些文件代表了我们的应用基础设施，可以与我们的应用源代码一起进行版本控制。我们可以使用与应用的其他部分相同的版本控制工具，查看我们基础设施的完整变更时间线。此外，我们可以将这些配置文件纳入我们的持续部署流水线中，因此当我们对应用基础设施进行更改时，这些更改可以使用行业标准工具安全地部署，与我们的应用代码一起。
- en: CloudFormation and the Serverless Application Model
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CloudFormation和Serverless应用程序模型
- en: While there are obvious benefits to an infrastructure-as-code approach, CloudFormation
    itself has a reputation for being verbose, unwieldy, and inflexible. Configuration
    files for even the simplest application architectures can easily run into the
    hundreds or thousands of lines of JSON or YAML. When dealing with an existing
    CloudFormation stack of that size, there’s an understandable temptation to fall
    back to using the AWS Web Console or CLI.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管基础设施即代码方法有明显的好处，但CloudFormation本身以冗长、笨重和不灵活而闻名。即使是最简单的应用架构的配置文件也很容易超过数百或数千行的JSON或YAML。当处理一个这样大小的现有CloudFormation堆栈时，不可避免地会有一种诱惑，即退回到使用AWS
    Web控制台或CLI。
- en: Fortunately, as AWS serverless developers, we have the good fortune to be able
    to use a different “flavor” of CloudFormation called the Serverless Application
    Model (SAM), which we used in Chapters [2](ch02.html#ch02) and [3](ch03.html#ch03).
    This is essentially a superset of CloudFormation, which allows us to use some
    special resource types and shortcuts to represent common serverless components
    and application architectures. It also includes some special CLI commands to ease
    development, testing, and deployment.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，作为AWS无服务器开发人员，我们有幸能够使用称为Serverless应用程序模型（SAM）的CloudFormation的不同“口味”，我们在[第2章](ch02.html#ch02)和[第3章](ch03.html#ch03)中使用过。这本质上是CloudFormation的一个超集，允许我们使用一些特殊的资源类型和快捷方式来表示常见的无服务器组件和应用架构。它还包括一些特殊的CLI命令，以简化开发、测试和部署。
- en: 'Here’s the SAM template we first used in [“Creating the Lambda Function”](ch02.html#creating_the_lambda_function),
    updated to use our new ZIP deployment package (note that the `CodeUri` suffix
    has changed from `.jar` to `.zip`):'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们首次在[“创建Lambda函数”](ch02.html#creating_the_lambda_function)中使用的SAM模板，已更新为使用我们的新ZIP部署包（请注意，`CodeUri`后缀已从`.jar`更改为`.zip`）：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can deploy the new ZIP-based Lambda function using the same SAM command
    you learned in [Chapter 2](ch02.html#ch02):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用[第2章](ch02.html#ch02)中学到的相同SAM命令部署新的基于ZIP的Lambda函数：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`sam deploy` starts by uploading our deployment package to S3, but only if
    the contents of that package have changed. Earlier in the chapter, we spent some
    time setting up a reproducible build so that operations like this upload process
    don’t have to execute if nothing has actually changed.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`sam deploy`首先将我们的部署包上传到S3，但仅在该包的内容发生更改时才执行此操作。在本章的早些时候，我们花了一些时间设置可重现的构建，以便像此上传过程这样的操作不必在实际上没有发生更改时执行。'
- en: Behind the scenes `sam deploy` also creates a modified version of our template
    (also stored in S3) to reference the newly uploaded S3 locations of our artifact(s),
    rather than the local ones. This step is necessary because CloudFormation requires
    any referenced artifacts within a template to be available in S3 at deployment
    time.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，`sam deploy`还创建了我们模板的修改版本（也存储在S3中），以引用新上传的S3位置的工件，而不是本地位置。这一步是必要的，因为CloudFormation要求模板中引用的任何工件在部署时都可在S3中使用。
- en: Tip
  id: totrans-80
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: The files that `s3 deploy` stores in S3 should be considered merely staging
    versions as part of a deployment process, rather than application artifacts to
    be kept. Because of this, we recommend that you set a “Lifecycle Policy” on your
    SAM S3 bucket, if it isn’t being used for anything else, that will automatically
    delete the deployment artifacts after a period of time—we usually set it to a
    week.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在S3中的`s3 deploy`文件应仅视为部署过程中的临时版本，而不是要保留的应用程序工件。因此，如果您的SAM S3存储桶没有用于其他用途，我们建议您在其中设置“生命周期策略”，以便在一段时间后自动删除部署工件——通常我们将其设置为一周。
- en: After the upload step, the `sam deploy` command creates a new CloudFormation
    stack if one doesn’t already exist with the provided name in this AWS account
    and region. If the stack already exists, the `sam deploy` command will create
    a CloudFormation *change set*, which lists which resources will be created, updated,
    or deleted *before* taking action. The `sam deploy` command will then apply the
    change set to update the CloudFormation stack.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在上传步骤之后，如果在此AWS账户和区域中尚不存在具有提供名称的CloudFormation堆栈，则`sam deploy`命令将创建一个新的CloudFormation堆栈。如果堆栈已经存在，`sam
    deploy`命令将创建一个CloudFormation *变更集*，其中列出了在执行操作之前将创建、更新或删除的资源。然后，`sam deploy`命令将应用变更集以更新CloudFormation堆栈。
- en: 'Listing the stack resources, we can see that not only did CloudFormation create
    our Lambda function, but it also created the supporting IAM roles and policies
    (which we’ll explore later) without our having to specify them explicitly:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 列出堆栈资源时，我们可以看到CloudFormation不仅创建了我们的Lambda函数，还创建了支持的IAM角色和策略（稍后我们将进一步探讨），而无需显式指定它们：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In addition to Lambda functions, SAM includes resource types for DynamoDB tables
    (`AWS::Serverless::SimpleTable`) and API Gateways (`AWS::Serverless::Api`). These
    resource types are focused on popular use cases and may not be usable for all
    application architectures. However, because SAM is a superset of CloudFormation,
    we can use plain old CloudFormation resource types in our SAM templates. That
    means we can mix and match serverless and “normal” AWS components in our architectures,
    gaining the benefits of both approaches, and the idempotent CLI semantics of SAM’s
    `sam deploy` command. You’ll see examples of combining SAM and CloudFormation
    resources in one template in [Chapter 5](ch05.html#ch05).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Lambda函数外，SAM还包括用于DynamoDB表（`AWS::Serverless::SimpleTable`）和API网关（`AWS::Serverless::Api`）的资源类型。这些资源类型专注于流行的使用案例，可能无法适用于所有应用程序架构。然而，由于SAM是CloudFormation的超集，我们可以在SAM模板中使用普通的CloudFormation资源类型。这意味着我们可以在架构中混合和匹配无服务器和“普通”AWS组件，从而获得两种方法的好处，以及SAM的`sam
    deploy`命令的幂等CLI语义。您将在[第5章](ch05.html#ch05)中看到将SAM和CloudFormation资源结合在一个模板中的示例。
- en: Security
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全性
- en: Security permeates every aspect of AWS. As you learned in [Chapter 2](ch02.html#ch02),
    we must deal with AWS’s security layer, called Identity and Access Management
    (IAM), from the very beginning. However, rather than gloss over the details by
    simply running everything with the broadest, least-secure set of IAM permissions
    possible, we’re going to dive a little deeper in this section and explain how
    access to the Lambda platform is controlled by IAM, how that affects our functions’
    interactions with other AWS resources, and how SAM makes it a bit easier to build
    secure applications.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 安全问题贯穿AWS的各个方面。正如您在[第2章](ch02.html#ch02)中学到的那样，我们必须从一开始就处理AWS的安全层，称为身份和访问管理（IAM）。然而，我们不打算简单地以最广泛、最不安全的IAM权限集运行所有内容来概述细节，而是在本节中稍微深入讲解Lambda平台如何由IAM控制，以及这如何影响我们的函数与其他AWS资源的交互，以及SAM如何使构建安全应用程序变得更加简单。
- en: The Principle of Least Privilege
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最小权限原则
- en: Unlike in a traditional monolithic application, a serverless application could
    potentially have hundreds of individual AWS components, each with different behavior
    and access to different pieces of information. If we simply applied the broadest
    security permissions possible, then every component would have access to every
    other component and piece of information in our AWS account. Every gap we leave
    in a security policy is an opportunity for information to leak or be lost or be
    altered or for our application’s behavior to be changed. And, if a single component
    is compromised, the entire AWS account (and any other applications deployed in
    it) is at risk as well.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统的单体应用程序不同，在无服务器应用程序中，可能会有数百个独立的AWS组件，每个组件具有不同的行为和访问不同的信息的能力。如果我们简单地应用最广泛的安全权限，则每个组件都可以访问AWS账户中的每个其他组件和信息。我们在安全策略中留下的每一个漏洞都是信息泄露、丢失、修改或应用程序行为改变的机会。而且，如果一个组件被入侵，整个AWS账户（以及其中部署的任何其他应用程序）都面临风险。
- en: We can address this risk by applying the principle of “least privilege” to our
    security model. In a nutshell, this principle states that every application and
    indeed every component of an application should have the least possible access
    it needs to perform its function. For example, let’s consider a Lambda function
    that reads from a DynamoDB table. The broadest possible permissions would allow
    that Lambda function to read, write, or otherwise interact with every other component
    and piece of information in the AWS account. It could read from S3 buckets, create
    new Lambda functions, or even launch EC2 instances. If the Lambda code had a bug
    or vulnerability (in parsing user input, for example), its behavior could be altered
    to do those things, and it wouldn’t be constrained by its IAM role.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将“最小权限”原则应用于我们的安全模型来解决这种风险。简而言之，该原则指出每个应用程序，实际上是每个应用程序的组成部分都应该具有执行其功能所需的最少访问权限。例如，让我们考虑一个从DynamoDB表中读取数据的Lambda函数。最广泛的权限将允许该Lambda函数读取、写入或以其他方式与AWS账户中的每个其他组件和信息进行交互。它可以从S3存储桶中读取数据，创建新的Lambda函数，甚至启动EC2实例。如果Lambda代码存在错误或漏洞（例如，在解析用户输入时），其行为可能会被改变，并且不受其IAM角色的限制。
- en: The principle of least privilege, applied to this particular Lambda function,
    would lead to an IAM role that allows the function to only access the DynamoDB
    service. Going a step further, we might only allow the function to read data from
    DynamoDB and remove its ability to write data or to create or delete tables. We
    can go even further in this case and restrict the function’s read-only access
    to the single DynamoDB table it requires. Taken to the logical extreme, we can
    even restrict which items in the table the function can read, based on the user
    who has executed the function in the first place.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 将最小权限原则应用于此特定Lambda函数，将会导致一个IAM角色，该角色只允许函数访问DynamoDB服务。进一步地，我们可能只允许该函数从DynamoDB中读取数据，并移除其写入数据或创建或删除表格的能力。在这种情况下，我们甚至可以进一步限制函数只能基于执行该函数的用户读取单个DynamoDB表中的哪些条目。
- en: Having applied the principle of least privilege to our Lambda function, we’ve
    now limited its access to only the specific resources that it needs to perform
    its job. If the Lambda function was compromised or hacked in some way, its security
    policy would still constrain it to reading specific items from a single DynamoDB
    table. That said, the principle of least privilege is not only applicable to preventing
    compromises. It’s also an effective means of limiting the “blast radius” of bugs
    in your application code.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 将最小权限原则应用到我们的Lambda函数上后，我们现在将其访问权限限制为仅能执行其工作所需的特定资源。如果Lambda函数在某种方式上被攻击或者被入侵，其安全策略仍会限制它仅能读取单个DynamoDB表中的特定条目。然而，最小权限原则不仅适用于防止妥协。它也是限制应用程序代码中错误“爆炸半径”的有效手段。
- en: Let’s consider a situation in which our Lambda function has a bug that, for
    example, uses the wrong value to delete data. In a wide-open security model, that
    bug could result in the Lambda function deleting data for the wrong user! However,
    because we’ve limited the “blast radius” of bugs by applying the principle of
    least privilege for our Lambda function, this particular issue will result in
    it simply doing nothing or throwing an error.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的 Lambda 函数存在一个 bug，例如使用错误的值来删除数据。在一个开放的安全模型中，这个 bug 可能导致 Lambda 函数删除错误用户的数据！然而，通过为我们的
    Lambda 函数应用最小权限原则，我们已经限制了 bug 的“爆炸半径”，因此这个特定问题可能会导致它仅仅无作为或抛出错误。
- en: Identity and Access Management
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 身份与访问管理
- en: A working knowledge of IAM is critical to successfully building any kind of
    application on AWS, and as we discussed in the previous section, effectively applying
    the principle of least privilege is even more important when building a serverless
    application. IAM is a complex, multifaceted service, and we’re not going to come
    close to covering all of it here. Rather, in this section, we’re just going to
    dive into IAM from the perspective of building serverless applications. Where
    IAM most commonly and frequently comes into play for serverless applications is
    in execution roles, in the policies attached to those roles, and in policies attached
    to specific AWS resources.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于成功在 AWS 上构建任何类型的应用程序来说，IAM 的工作知识至关重要。正如我们在前一节讨论的那样，在构建无服务器应用程序时，有效地应用最小权限原则更为重要。IAM
    是一个复杂且多方面的服务，在这里我们不可能详尽覆盖所有内容。相反，在本节中，我们只是从构建无服务器应用程序的角度深入探讨 IAM。IAM 在无服务器应用程序中最常见和频繁地发挥作用的地方是执行角色、附加到这些角色的策略，以及附加到特定
    AWS 资源的策略。
- en: Roles and policies
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 角色与策略
- en: An IAM role is an identity that can be assumed by an AWS component (like a Lambda
    function). A role differs from an IAM user in that a role is assumable by anyone
    (or anything) who needs it, and a role doesn’t have long-term access credentials.
    With that in mind, we can define an IAM role as an assumable identity, with an
    attached set of permissions.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: IAM 角色是可以被 AWS 组件（如 Lambda 函数）扮演的身份。与 IAM 用户不同，角色可以被任何需要它的人（或事物）扮演，并且角色没有长期访问凭证。基于此，我们可以定义
    IAM 角色为一个可扮演的身份，并附加一组权限。
- en: 'The phrase *assumable identity* might make it sound like anyone or anything
    can assume an IAM role. If that were the case, then using roles wouldn’t really
    provide any benefit because there would be no restrictions on assuming a role
    and therefore no restrictions on what actions any given user or component could
    undertake. Fortunately, IAM roles are not assumable by just anyone. When building
    a role, we must specify who (or what) can assume that role. For example, if we’re
    building a role for use by a Lambda function, we must explicitly grant the Lambda
    service (in this case the data plane) permission to assume that role, by specifying
    the following “trust relationship”:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: “可扮演的身份”这个短语可能让人觉得任何人或任何事物都可以扮演 IAM 角色。如果是这样的话，使用角色就不会真正提供任何好处，因为对于扮演角色或任何给定用户或组件可以承担的操作不会有任何限制。幸运的是，IAM
    角色并不是任何人都可以扮演的。在构建角色时，我们必须明确指定谁（或什么）可以扮演该角色。例如，如果我们正在为 Lambda 函数构建一个角色，我们必须明确授予
    Lambda 服务（在这种情况下是数据平面）扮演该角色的权限，通过指定以下“信任关系”：
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This statement specifies an effect (`Allow`), which applies to an action (`sts:Assume​Role`).
    Most important, however, it specifies a principal, which is the identity that
    is allowed to assume the role. In this case, we’re allowing the Lambda service’s
    data plane (`lambda.amazonaws.com`) to assume this role. If we tried to use this
    role with a different service, like EC2 or ECS, it wouldn’t work unless we changed
    the principal.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此声明指定了一个效果（`Allow`），适用于一个操作（`sts:AssumeRole`）。然而，更重要的是，它指定了一个主体，即被允许扮演该角色的身份。在这种情况下，我们允许
    Lambda 服务的数据平面（`lambda.amazonaws.com`）扮演这个角色。如果我们尝试将此角色与不同的服务，如 EC2 或 ECS，一起使用，除非我们更改主体，否则将无法正常工作。
- en: 'Now that we’ve established who can assume the role, we need to add permissions.
    IAM roles don’t inherently have any permissions to access resources or perform
    actions. Also, IAM’s default behavior is to deny permission, unless that permission
    is explicitly allowed in a policy. Those permissions are contained in policies,
    which state permissions using the following constructs:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确定了谁可以承担角色，我们需要添加权限。IAM 角色本身不具备访问资源或执行操作的任何权限。此外，IAM 的默认行为是拒绝权限，除非在策略中显式允许。这些权限在策略中使用以下结构说明：
- en: An *effect* (like `Allow` or `Deny`)
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个*效果*（如 `Allow` 或 `Deny`）。
- en: A set of *actions*, which are generally namespaced to a specific AWS service
    (like `logs:PutLogEvents`)
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组*操作*，通常是命名空间到特定的 AWS 服务（比如 `logs:PutLogEvents`）。
- en: A set of *resources*, which are generally Amazon Resource Names (ARNs) that
    define specific AWS components. Different services support varying levels of specificity
    for resources. For example, DynamoDB policies can apply down to the level of a
    table.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组*资源*，通常是定义特定 AWS 组件的 Amazon 资源名称（ARN）。不同的服务支持不同级别的资源特定性。例如，DynamoDB 策略可以应用到表级别。
- en: 'Here’s an example policy that allows a set of actions against the “logs” service
    (aka CloudWatch Logs) and doesn’t restrict those actions to any particular “logs”
    resource:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个允许一组操作针对“logs”服务（即 CloudWatch Logs）的策略示例，并且不限制这些操作对任何特定的“logs”资源：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We established earlier who can assume the role (the Lambda service’s data plane,
    as specified by the principal identifier `lambda.amazonaws.com`) and what permissions
    the role has. By itself, however, this role isn’t used until it’s attached to
    a Lambda function, which we would need to explicitly configure. That is, we need
    to tell the Lambda service to use this role when executing a particular Lambda
    function.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前确定了谁可以承担角色（Lambda 服务的数据平面，由主体标识符 `lambda.amazonaws.com` 指定），以及角色具有的权限。然而，这个角色本身直到附加到
    Lambda 函数时才会被使用，我们需要显式配置。也就是说，我们需要告诉 Lambda 服务在执行特定 Lambda 函数时使用这个角色。
- en: Lambda resource policies
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Lambda 资源策略。
- en: 'As if the world of security and IAM weren’t complex enough, AWS also occasionally
    uses IAM policies applied to resources (rather than identities) to control actions
    and access. Resource policies invert control compared to an identity-based IAM
    policy: a resource policy states what other principals can do to the resource
    in question. In particular, this is useful for allowing principals in different
    accounts access to certain resources (like Lambda functions or S3 buckets).'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 就像安全和 IAM 的世界还不够复杂一样，AWS 偶尔也使用应用于资源（而不是身份）的 IAM 策略来控制操作和访问。资源策略与基于身份的 IAM 策略相比反转了控制：资源策略说明了其他主体可以对所涉及的资源做什么。特别是，这对于允许不同账户中的主体访问某些资源（如
    Lambda 函数或 S3 存储桶）非常有用。
- en: 'A Lambda function invocation resource policy consists of a series of statements,
    each of which specifies a principal, a list of actions, and a list of resources.
    These policies are used by the Lambda data plane to determine whether to allow
    a caller (e.g., a principal) to successfully invoke a function. Here’s an example
    Lambda resource policy (also called a *function policy*) that allows the API Gateway
    service to invoke a particular function:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 函数调用资源策略由一系列语句组成，每个语句指定了一个主体、一组操作和一组资源。这些策略由 Lambda 数据平面使用，用于确定是否允许调用者（例如主体）成功调用函数。这里是一个示例
    Lambda 资源策略（也称为*函数策略*），允许 API 网关服务调用特定函数：
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this policy, we’ve also added a condition, which more specifically limits
    the allowed source of the action to only API Gateway deployments with an ID of
    “xxx” that include the “/GET/locations” path. Conditions are service-specific
    and depend on what information the caller makes available.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个策略中，我们还添加了一个条件，更具体地限制了允许的操作来源，只允许具有 ID “xxx” 的 API 网关部署包含 “/GET/locations”
    路径。条件是服务特定的，取决于调用者提供的信息。
- en: Let’s work through the scenario in which API Gateway invokes a Lambda function,
    using [Figure 4-1](#lambda-and-iam-security).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过 API 网关调用 Lambda 函数的场景来详细讨论，使用 [图 4-1](#lambda-and-iam-security)。
- en: '![images/ch04_image01.png](assets/awsl_0401.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![images/ch04_image01.png](assets/awsl_0401.png)'
- en: Figure 4-1\. Overview of Lambda and IAM security
  id: totrans-115
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-1\. Lambda 和 IAM 安全概述。
- en: Did the caller have permission to call the API? For this scenario, we’ll assume
    the answer is yes. Please see the [API Gateway documentation](https://oreil.ly/Sb6N2)
    for more information.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用者是否有权限调用 API？对于这种情况，我们假设答案是肯定的。有关更多信息，请参阅 [API Gateway 文档](https://oreil.ly/Sb6N2)。
- en: The API Gateway API is attempting to invoke the Lambda function. Does the Lambda
    service allow this? This is controlled by a Lambda function invocation resource
    policy.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: API Gateway API 正试图调用 Lambda 函数。Lambda 服务允许这样吗？这由 Lambda 函数调用资源策略控制。
- en: What permissions should the Lambda function code have when it executes? This
    is controlled by the Lambda execution role, and that role is assumed through a
    trust relationship with the Lambda service.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 Lambda 执行时，函数代码应具有什么权限？这由 Lambda 执行角色控制，并且该角色通过与 Lambda 服务的信任关系来假定。
- en: The Lambda code is trying to put an item into a DynamoDB table. Can it do that?
    This is controlled by a permission, which comes from an IAM policy attached to
    the Lambda execution role.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Lambda 代码正在尝试将项目放入 DynamoDB 表中。它可以做到吗？这由一个权限控制，它来自附加到 Lambda 执行角色的 IAM 策略。
- en: DynamoDB doesn’t use resource policies, so calls from anyone (including Lambda
    functions) are permitted, as long as their role (e.g., the Lambda execution role)
    permits it.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DynamoDB 不使用资源策略，因此任何人（包括 Lambda 函数）的调用都是允许的，只要它们的角色（例如 Lambda 执行角色）允许。
- en: SAM IAM
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SAM IAM
- en: Unfortunately, the complexity of IAM puts its effective use somewhat at odds
    with a rapid prototyping workflow. Throw a serverless application architecture
    into the mix, and it’s no wonder so many Lambda execution roles have completely
    open policies, allowing all forms of access to every resource in the AWS account.
    Even though it’s easy to agree that the principle of least privilege provides
    valuable benefits, when faced with the somewhat daunting task of implementing
    it using IAM for dozens or hundreds of AWS resources, many otherwise conscientious
    engineers choose to forgo security for simplicity.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，IAM 的复杂性使其在快速原型设计工作流程中的有效使用有些不协调。将无服务器应用架构加入其中，难怪如此多的 Lambda 执行角色完全开放策略，允许对
    AWS 账户中的每个资源进行各种形式的访问。尽管我们很容易认同最小权限原则提供了宝贵的好处，但面对使用 IAM 为数十甚至数百个 AWS 资源实施它的任务，许多本来很有责任心的工程师选择为简单起见放弃安全性。
- en: Autogenerated execution roles and resource policies
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自动创建的执行角色和资源策略
- en: Fortunately, the Serverless Application Model addresses this issue in a few
    different ways. In the simplest of cases, it will automatically create the appropriate
    Lambda execution roles and function policies, based on the various functions and
    event sources configured in the SAM infrastructure template. This neatly handles
    permissions for executing Lambda functions and allowing them to be invoked by
    other AWS services.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Serverless Application Model 通过几种不同的方式解决了这个问题。在最简单的情况下，它将根据 SAM 基础设施模板中配置的各种函数和事件源自动创建适当的
    Lambda 执行角色和函数策略。这样一来，能够执行 Lambda 函数并允许其他 AWS 服务调用它们的权限问题就能很好地解决。
- en: For example, if you configured a single Lambda function with no triggers, SAM
    will automatically generate a Lambda execution role for that function, which would
    allow it to write to CloudWatch Logs. If you then added an API Gateway trigger
    to that Lambda function, SAM will generate a Lambda function invocation resource
    policy, which allows the Lambda function to be invoked by the API Gateway platform.
    This will make our lives a little easier in the next chapter!
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您配置了一个没有触发器的单个 Lambda 函数，SAM 将自动生成一个 Lambda 执行角色，使该函数能够写入 CloudWatch 日志。如果然后将
    API Gateway 触发器添加到该 Lambda 函数中，SAM 将生成一个 Lambda 函数调用资源策略，允许 API Gateway 平台调用 Lambda
    函数。这将在下一章中为我们的生活带来一些便利！
- en: Common policy templates
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 常见的策略模板
- en: Of course, if your Lambda function needs to interact with other AWS services
    in code (for example, to write to a DynamoDB table), it will likely require additional
    permissions. For these situations, SAM provides a selection of common IAM policy
    templates that allow us to concisely specify permissions and resources. Those
    templates are then expanded during the SAM deployment process and become fully
    specified IAM policy statements. Here we’ve added a DynamoDB table to our SAM
    template. We’ve used a SAM policy template to allow our Lambda function to perform
    create, read, update, and delete actions (aka CRUD) against that DynamoDB table.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果您的Lambda函数需要在代码中与其他AWS服务交互（例如向DynamoDB表写入数据），它可能需要额外的权限。对于这些情况，SAM提供了一些常见的IAM策略模板，允许我们简明地指定权限和资源。这些模板在SAM部署过程中会扩展，并成为完全指定的IAM策略语句。在这里，我们在SAM模板中添加了一个DynamoDB表。我们使用了一个SAM策略模板来允许我们的Lambda函数对该DynamoDB表执行创建、读取、更新和删除操作（也称为CRUD操作）。
- en: '[PRE13]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[![1](assets/1.png)](#co_operating_aws_lambda_functions_CO2-1)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_operating_aws_lambda_functions_CO2-1)'
- en: Here we’ve used the CloudFormation Intrinsic Function [`Ref`](https://oreil.ly/ScQ9Q),
    which allows us to use the logical ID of a resource (in this case `HelloWorldTable`)
    as a placeholder for the physical ID of the resource (which would be something
    like `stack-name-HelloWorldTable-ABC123DEF`). The CloudFormation service will
    resolve logical IDs to physical IDs when a stack is created or updated.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了CloudFormation内部函数 [`Ref`](https://oreil.ly/ScQ9Q)，它允许我们使用资源的逻辑ID（在本例中为
    `HelloWorldTable`）作为资源的物理ID的占位符（例如 `stack-name-HelloWorldTable-ABC123DEF`）。CloudFormation服务将在创建或更新堆栈时解析逻辑ID为物理ID。
- en: Summary
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we covered building and packaging Lambda code and dependencies
    in a reproducible, deterministic way. We started to use AWS’s SAM to specify our
    infrastructure (e.g., our Lambda function and later a DynamoDB table) as YAML
    code—we’ll explore this much further in [Chapter 5](ch05.html#ch05). We then explored
    the two different kinds of IAM constructs that affect Lambda functions: execution
    roles and resource policies. Finally, using SAM instead of raw CloudFormation
    meant that we didn’t have to add very much additional YAML code to apply the principle
    of least privilege to the IAM roles and policies for our Lambda function.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了以可复制、确定性方式构建和打包Lambda代码及其依赖项。我们开始使用AWS的SAM来以YAML代码指定基础设施（例如Lambda函数，稍后是DynamoDB表）——我们将在[第5章](ch05.html#ch05)中进一步探讨这一点。然后，我们探讨了影响Lambda函数的两种不同IAM构造：执行角色和资源策略。最后，使用SAM而不是原始CloudFormation意味着我们不必添加太多额外的YAML代码来将最小权限原则应用于Lambda函数的IAM角色和策略。
- en: We now have nearly all the basic building blocks in place to create complete
    applications using Lambda and associated tools. In [Chapter 5](ch05.html#ch05)
    we’ll show how to tie Lambda functions to event sources and then build two example
    applications.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们几乎已经准备好使用Lambda和相关工具创建完整的应用程序的基本构建模块。在[第5章](ch05.html#ch05)中，我们将展示如何将Lambda函数与事件源绑定，然后构建两个示例应用程序。
- en: Exercises
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Deliberately misconfigure the Lambda function in this chapter by setting the
    `Handler` property to `book.HelloWorld::foo`. What happens when the function is
    deployed? What happens when you invoke the function?
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本章中，通过将`Handler`属性设置为`book.HelloWorld::foo`来故意配置Lambda函数。当函数部署时会发生什么？当您调用函数时会发生什么？
- en: Read the [IAM reference guide](https://oreil.ly/nBdd9) to learn which AWS services
    (and actions) can have granular IAM permissions.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 阅读[IAM参考指南](https://oreil.ly/nBdd9)以了解哪些AWS服务（和操作）可以具有细粒度的IAM权限。
- en: If you’d like an extra challenge, replace `AWS::Serverless::Function` with `AWS::Lambda::Function`
    in the *template.yaml* file. What other changes do you have to make for CloudFormation
    to deploy your function? If you get stuck, you can look at the post-transform
    template (for the original stack) via the CloudFormation web console.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您想要额外的挑战，在*template.yaml*文件中将`AWS::Serverless::Function`替换为`AWS::Lambda::Function`。为了CloudFormation能够部署您的函数，您还需要进行哪些其他更改？如果遇到困难，您可以通过CloudFormation
    Web控制台查看原始堆栈的后转换模板。
