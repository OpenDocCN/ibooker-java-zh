- en: Chapter 12\. Desktop Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 12 章。桌面应用程序
- en: Java leapt to fame and glory on the power of applets—amazing, *interactive*
    elements on a web page. Sounds mundane these days, but at the time it was nothing
    short of a marvel. Java also had cross-platform support up its sleeve and could
    run the same code on Windows, Unix, and macOS systems. The early JDKs had a rudimentary
    set of graphical components collectively known as the Abstract Window Toolkit
    (AWT). The “abstract” in AWT comes from the use of common classes (`Button`, `Window`,
    etc.) with native implementations. You write AWT applications with abstract, cross-platform
    code; your computer runs your application and provides concrete, native components.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Java 凭借 applet 的力量一跃成名——这些在网页上的惊人的 *交互式* 元素。现在听起来很普通，但在当时，这简直是一个奇迹。Java 还具有跨平台支持，并且可以在
    Windows、Unix 和 macOS 系统上运行相同的代码。早期的 JDK 具有一组基本的图形组件，统称为抽象窗口工具包（AWT）。AWT 中的“抽象”来自于使用通用类（`Button`、`Window`
    等）与本地实现。你使用抽象的、跨平台的代码编写 AWT 应用程序；你的计算机运行你的应用程序并提供具体的、本地的组件。
- en: Unfortunately, that nifty combination of abstract and native comes with some
    pretty serious limitations. In the abstract realm, you encounter “lowest common
    denominator” designs that only give you access to features available on every
    platform supported by the JDK. In the native implementations, even some features
    roughly available everywhere were distinctly different when actually rendered
    on the screen. Many desktop developers working with Java in those early days joked
    that the “write once, run everywhere” tagline was really “write once, debug everywhere.”
    The Java Swing package set out to ameliorate this woeful state. While Swing didn’t
    solve every problem of cross-platform application delivery, it did make serious
    desktop application development possible in Java. You can find many quality open
    source projects and even some commercial applications written in Swing. Indeed,
    the IDE we detail in [Appendix A](app01.html#learnjava6-APP-A), IntelliJ IDEA,
    is a Swing application! It clearly goes toe-to-toe with native IDEs on both performance
    and usability.^([1](ch12.html#id2307))
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这种抽象和本地结合的巧妙组合带来了一些相当严重的限制。在抽象领域，你会遇到“最低公共分母”设计，这些设计只能让你访问 JDK 支持的每个平台上可用的功能。在本地实现中，即使某些功能在各平台上大致可用，但在实际渲染屏幕时，它们也有显著的差异。许多早期使用
    Java 的桌面开发人员开玩笑说，“一次编写，到处运行”的标语实际上是“一次编写，到处调试”。Java Swing 套件旨在改善这种令人遗憾的状态。虽然 Swing
    没有解决跨平台应用程序交付的所有问题，但它确实使得在 Java 中进行严肃的桌面应用程序开发成为可能。你可以找到许多优质的开源项目，甚至一些商业应用程序是用
    Swing 编写的。确实，在附录 [A](app01.html#learnjava6-APP-A) 中详细介绍的集成开发环境 IntelliJ IDEA 就是一个
    Swing 应用程序！它在性能和可用性上显然可以与本地集成开发环境媲美。^([1](ch12.html#id2307))
- en: If you look at the documentation for the `javax.swing`^([2](ch12.html#id2309))
    package, you will see it contains a multitude of classes. You will still need
    some pieces of the original `java.awt` realm as well. There are entire books on
    AWT ([*Java AWT Reference*](https://oreil.ly/ppyCu), Zukowski, O’Reilly) and on
    Swing ([*Java Swing*](https://oreil.ly/bO7g6), Loy, et al., O’Reilly), and even
    on subpackages of the AWT, such as 2D graphics ([*Java 2D Graphics*](https://oreil.ly/o3YxN),
    Knudsen, O’Reilly). In this chapter, we’ll stick to covering some popular components
    like buttons and text fields. We’ll look at how to lay them out in your application
    window and how to interact with them. You may be surprised by how sophisticated
    your application can get with these simple starting topics. If you do more desktop
    development after reading this book, you may also be surprised by how much more
    graphical user interface (GUI, or just UI) content is out there for Java. We want
    to whet your appetite while acknowledging that there are many, *many* more UI
    discussions we must leave for you to discover later. With that said, let the whirlwind
    tour commence!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 `javax.swing`^([2](ch12.html#id2309)) 包的文档，你会发现它包含大量的类。你仍然需要一些原始的 `java.awt`
    领域的内容。有关 AWT 的整本书籍（[*Java AWT Reference*](https://oreil.ly/ppyCu)，Zukowski，O’Reilly）以及关于
    Swing 的书籍（[*Java Swing*](https://oreil.ly/bO7g6)，Loy 等人，O’Reilly），甚至关于 AWT 子包，如
    2D 图形的书籍（[*Java 2D Graphics*](https://oreil.ly/o3YxN)，Knudsen，O’Reilly）。在本章中，我们将专注于介绍一些流行的组件，如按钮和文本字段。我们将讨论如何在应用程序窗口中布局它们以及如何与它们交互。通过这些简单的起步主题，你可能会惊讶于你的应用程序可以变得多么复杂。如果你在阅读本书后继续进行桌面开发，你可能也会对
    Java 中有多少更多的图形用户界面（GUI）内容感到惊讶。我们希望在激起你的兴趣的同时，也承认有许多 *很多* 更多的 UI 讨论是我们必须留给你以后发现的。话虽如此，让旋风之旅开始吧！
- en: Buttons and Sliders and Text Fields, Oh My!
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按钮、滑块和文本字段，哦！
- en: 'So where to begin? We have a bit of a “chicken and the egg” problem: we need
    to discuss the “things” to put on the screen, such as the `JLabel` objects we
    used in [“HelloJava”](ch02.html#learnjava6-CHP-2-SECT-2). But we also need to
    discuss what you put those things into. And *where* you put those things also
    merits discussion, as it’s a nontrivial process. We actually seem to have a chicken,
    egg, and brunch problem. Grab a cup of coffee or a mimosa, and we’ll get started.
    We will cover some popular components (the “things”) first, then their containers,
    and finally the topic of laying out your components in those containers. Once
    you can put a nice set of widgets on the screen, we’ll discuss how to interact
    with them as well as how to handle user interfaces in a multithreaded world.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 那么从哪里开始呢？我们有点“先有鸡还是先有蛋”的问题：我们需要讨论要放在屏幕上的“东西”，比如我们在[“HelloJava”](ch02.html#learnjava6-CHP-2-SECT-2)中使用的`JLabel`对象。但我们还需要讨论你把那些东西放在哪里。而且你把那些东西放在哪里也值得讨论，因为这是一个非平凡的过程。实际上，我们似乎有一个先有鸡、再有蛋，然后是早午餐的问题。拿杯咖啡或者一杯香槟，我们就开始吧。我们将首先介绍一些流行的组件（“东西”），然后介绍它们的容器，最后讨论如何在这些容器中布置组件的话题。一旦你能在屏幕上放置一个漂亮的小部件集，我们将讨论如何与它们进行交互以及如何在多线程世界中处理用户界面。
- en: Component Hierarchies
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件层次结构
- en: As we’ve discussed in previous chapters, Java classes are designed and extended
    in a hierarchical fashion. `JComponent` and `JContainer` sit at the top of the
    Swing class hierarchy, as shown in [Figure 12-1](#learnjava6-CHP-12-FIG-1). We
    won’t cover these two classes in much detail, but remember their names. You will
    find several common attributes and methods in these classes as you read the Swing
    documentation. As you advance in your programming endeavors, you’ll likely want
    to build your own component. `JComponent` is a great starting point. We used `JComponent`
    when building our graphical `Hello` `Component` back in [Chapter 2](ch02.html#learnjava6-CHP-2).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前几章中讨论的那样，Java 类是以分层方式设计和扩展的。`JComponent` 和 `JContainer` 位于 Swing 类层次结构的顶部，如[图 12-1](#learnjava6-CHP-12-FIG-1)所示。我们不会详细介绍这两个类，但请记住它们的名称。当你阅读
    Swing 文档时，你会在这些类中找到几个常见的属性和方法。随着你在编程方面的进步，你可能会想要构建自己的组件。`JComponent` 是一个很好的起点。我们在[第
    2 章](ch02.html#learnjava6-CHP-2)中构建图形 `Hello` `Component` 时使用了 `JComponent`。
- en: '![ljv6 1201](assets/ljv6_1201.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 1201](assets/ljv6_1201.png)'
- en: Figure 12-1\. Partial (very partial) Swing class hierarchy
  id: totrans-9
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-1\. 部分（非常部分）Swing 类层次结构
- en: We will be covering most of the other classes mentioned in the abridged hierarchy
    above, but you will definitely want to visit the [online documentation](https://oreil.ly/H7KhT)
    to see the many components we had to leave out.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖上述简化层次结构中提到的大多数其他类，但你肯定会想访问[在线文档](https://oreil.ly/H7KhT)来查看我们不得不遗漏的许多组件。
- en: Model View Controller Architecture
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型视图控制器架构
- en: At the base of Swing’s notion of “things” is a design pattern known as Model
    View Controller (MVC). The Swing package authors worked hard to consistently apply
    this pattern so that when you encounter new components, their behavior and usage
    should feel familiar. MVC architecture aims to compartmentalize what you see (the
    view) from the behind-the-scenes state (the model) and from the collection of
    interactions (the controller) that change those parts. This separation of concerns
    allows you to concentrate on getting each piece right. Network traffic can update
    the model behind the scenes. The view can be synchronized at regular intervals
    that feel smooth and responsive to the user. MVC provides a powerful yet manageable
    framework to use when building any desktop application.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Swing 对“东西”的基础是一种被称为模型视图控制器（MVC）的设计模式。Swing 包的作者们努力确保一致地应用这种模式，以便当你遇到新的组件时，它们的行为和使用应该感觉熟悉。MVC
    架构旨在将你所看到的（视图）与幕后状态（模型）以及改变这些部分的交互集合（控制器）分离开来。这种关注点的分离使你能够专注于每个部分的正确性。网络流量可以在幕后更新模型。视图可以在感觉顺畅并且对用户响应迅速的正常间隔同步。MVC
    为构建任何桌面应用程序提供了一个强大而易于管理的框架。
- en: 'As we look at our small selection of components, we’ll highlight the model
    and the view elements. We’ll then go into more detail on the controllers in [“Events”](#learnjava6-CHP-12-SECT-3).
    If you find the notion of programming patterns intriguing, [*Design Patterns:
    Elements of Reusable Object-Oriented Software*](https://oreil.ly/gt4Pt) (Addison-Wesley)
    by Gamma, Helm, Johnson, and Vlissides (the renowned Gang of Four) is the classic
    work. For more details on the use of the MVC pattern in Swing specifically, see
    the introductory chapter of [*Java Swing*](https://oreil.ly/ADKQq), by Loy et
    al.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看我们的一小部分组件时，我们将突出显示模型和视图元素。然后我们将更详细地讨论[“事件”](#learnjava6-CHP-12-SECT-3)中的控制器。如果您对编程模式的概念感兴趣，[*可重用面向对象软件的设计模式*](https://oreil.ly/gt4Pt)（Addison-Wesley）由Gamma、Helm、Johnson和Vlissides（著名的四人帮）是经典之作。关于在
    Swing 中特别使用 MVC 模式的更多细节，请参阅Loy等人的[*Java Swing*](https://oreil.ly/ADKQq)的介绍章节。
- en: Labels and Buttons
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标签和按钮
- en: The simplest UI component is not surprisingly one of the most popular. Labels
    are used all over the place to indicate functionality, display status, and draw
    focus. We used a label for our first graphical application back in [Chapter 2](ch02.html#learnjava6-CHP-2).
    We’ll use many more labels as we continue building more interesting programs.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的 UI 组件不出所料地也是最受欢迎的之一。标签(label)被广泛用于指示功能、显示状态和聚焦。我们在[第2章](ch02.html#learnjava6-CHP-2)中的第一个图形应用程序中使用了一个标签。在构建更有趣的程序时，我们将会使用更多的标签。
- en: 'The `JLabel` component is a versatile tool. Let’s look at some examples of
    how to use `JLabel` and customize its many attributes. We’ll start by revisiting
    our “Hello, Java” program with a few preparatory tweaks:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`JLabel` 组件是一个多功能工具。让我们看看如何使用 `JLabel` 并自定义其许多属性的一些示例。我们将从对我们的“Hello, Java”程序进行一些准备性调整开始：'
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Briefly, the interesting parts are:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 简言之，有趣的部分包括：
- en: '[![1](assets/1.png)](#co_desktop_applications_CO1-1)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_desktop_applications_CO1-1)'
- en: Setting the layout manager for use by the frame.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 设置框架使用的布局管理器。
- en: '[![2](assets/2.png)](#co_desktop_applications_CO1-2)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_desktop_applications_CO1-2)'
- en: Setting the action taken when using the operating system’s “close” button (in
    this case, the red dot in the upper-left corner of the window). The action we
    selected here exits the application.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 设置在使用操作系统的“关闭”按钮时采取的操作（在本例中，是窗口左上角的红点）。我们在这里选择的操作是退出应用程序。
- en: '[![3](assets/3.png)](#co_desktop_applications_CO1-3)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_desktop_applications_CO1-3)'
- en: Creating our simple label and adding it to the frame.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 创建我们的简单标签并将其添加到框架中。
- en: You declare and initialize the label, then add it to the frame. That should
    be familiar. What is likely new is our use of a `FlowLayout` instance, which helps
    us produce the screenshot shown in [Figure 12-2](#learnjava6-CHP-12-FIG-2).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您声明和初始化标签，然后将其添加到框架中。这应该是很熟悉的操作。可能新的是我们使用了`FlowLayout`实例，它帮助我们生成了[图12-2](#learnjava6-CHP-12-FIG-2)中显示的屏幕截图。
- en: '![ljv6 1202](assets/ljv6_1202.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 1202](assets/ljv6_1202.png)'
- en: Figure 12-2\. A single, simple `JLabel`
  id: totrans-27
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图12-2\. 一个简单的 `JLabel`
- en: We’ll go over layout managers in much more detail in [“Containers and Layouts”](#learnjava6-CHP-12-SECT-2),
    but we need something to get us off the ground that also allows us to add multiple
    components to a single container. The `FlowLayout` class fills a container by
    horizontally centering components at the top, adding from left to right until
    that “row” runs out of room, then continuing on a new row below. This type of
    arrangement won’t be of much use in larger applications, but it is ideal for getting
    several things on the screen quickly.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[“容器和布局”](#learnjava6-CHP-12-SECT-2)中更详细地讨论布局管理器，但我们需要一些东西来让我们起步，同时还允许将多个组件添加到单个容器中。`FlowLayout`类通过水平居中组件顶部来填充容器，从左到右添加，直到该“行”用完空间，然后继续在下一行上添加。这种排列方式在较大的应用程序中可能不太实用，但对于快速在屏幕上显示几件事物而言是理想的。
- en: 'Let’s prove that point by adding a few more labels to the frame. Check out
    the results shown in [Figure 12-3](#learnjava6-CHP-12-FIG-3):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过向框架添加几个更多的标签来证明这一点。查看[图12-3](#learnjava6-CHP-12-FIG-3)中显示的结果：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![ljv6 1203](assets/ljv6_1203.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 1203](assets/ljv6_1203.png)'
- en: Figure 12-3\. Several basic `JLabel` objects
  id: totrans-32
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图12-3\. 几个基本的 `JLabel` 对象
- en: 'Neat, right? Again, this simple layout is not meant for most types of content
    you find in production applications, but it’s definitely useful as you get started.
    One more point about layouts that we want to make, as you’ll encounter this idea
    later: `FlowLayout` also deals with the size of the labels. That can be hard to
    notice in this example because labels have a transparent background by default.
    If we import the `java.awt.Color` class, we can use that class to help make them
    opaque and give them a specific background color:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 不错，对吧？再次强调，这种简单的布局并不适用于大多数生产应用程序中的内容，但对于您开始时肯定是有用的。关于布局，我们还想提一点，因为您以后会遇到这个想法：`FlowLayout`也处理标签的大小。在这个示例中很难注意到这一点，因为标签默认具有透明背景。如果我们导入`java.awt.Color`类，我们可以使用该类来帮助使它们不透明并赋予它们特定的背景颜色：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If we do the same for all of our labels, we can now see their true sizes and
    the gaps between them in [Figure 12-4](#learnjava6-CHP-12-FIG-4). But if we can
    control the background color of labels, what else can we do? Can we change the
    foreground color? (Yes.) Can we change the font? (Yes.) Can we change the alignment?
    (Yes.) Can we add icons? (Yes.) Can we create self-aware labels that eventually
    build Skynet and bring about the end of humanity? (Maybe, but probably not, and
    certainly not easily. Just as well.) [Figure 12-5](#learnjava6-CHP-12-FIG-5) shows
    some of these possible tweaks.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对我们所有的标签都做同样的操作，我们现在可以看到它们的真实大小和它们之间的间隙在[图 12-4](#learnjava6-CHP-12-FIG-4)中。但是如果我们可以控制标签的背景颜色，我们还能做什么呢？我们可以改变前景色吗？（可以。）我们可以改变字体吗？（可以。）我们可以改变对齐方式吗？（可以。）我们可以添加图标吗？（可以。）我们可以创建最终构建Skynet并导致人类灭绝的自我意识标签吗？（也许，但可能不太容易。也好。）[图 12-5](#learnjava6-CHP-12-FIG-5)展示了其中一些可能的调整。
- en: '![ljv6 1204](assets/ljv6_1204.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 1204](assets/ljv6_1204.png)'
- en: Figure 12-4\. Opaque, colored labels
  id: totrans-37
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图12-4\. 不透明，彩色标签
- en: '![ljv6 1205](assets/ljv6_1205.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 1205](assets/ljv6_1205.png)'
- en: Figure 12-5\. More labels with fancier options
  id: totrans-39
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图12-5\. 更多带有花哨选项的标签
- en: 'And here is the relevant source code that built this added variety:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是构建这种多样性的相关源代码：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We used a few other classes to help out, such as `java.awt.Font` and `javax.swing.ImageIcon`.
    We could review many more options, but we need to look at some other components.
    If you want to play around with these labels and try out more of the options you
    see in the Java documentation, try importing a helper we built for *jshell* and
    playing around.^([3](ch12.html#id2325)) The results of our few lines are shown
    in [Figure 12-6](#learnjava6-CHP-12-FIG-6):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一些其他类来帮助，例如`java.awt.Font`和`javax.swing.ImageIcon`。我们可以回顾更多选项，但我们需要查看一些其他组件。如果您想玩转这些标签，并尝试更多您在Java文档中看到的选项，请尝试导入我们为*jshell*构建的助手并玩耍。我们的几行代码的结果显示在[图 12-6](#learnjava6-CHP-12-FIG-6)中：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![ljv6 1206](assets/ljv6_1206.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 1206](assets/ljv6_1206.png)'
- en: Figure 12-6\. Using our `Widget` class in *jshell*
  id: totrans-45
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图12-6\. 在*jshell*中使用我们的`Widget`类
- en: We hope you see how easy it is now to create a label (or other components, such
    as the buttons that we’ll be exploring next) and tweak its parameters interactively.
    This is a great way to familiarize yourself with the building blocks you have
    at your disposal for creating Java desktop applications. If you use our `Widget`
    much, you may find its `reset()` method handy. This method removes all of the
    current components and refreshes the window so you can start over quickly.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望您现在能够看到创建标签（或其他组件，例如我们将要探索的按钮）并交互式地调整其参数是多么容易。这是熟悉用于创建Java桌面应用程序的可用构建块的绝佳方式。如果您经常使用我们的`Widget`，您可能会发现其`reset()`方法很方便。此方法会移除所有当前组件并刷新窗口，以便您可以快速重新开始。
- en: Buttons
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 按钮
- en: The other near-universal component you’ll need for graphical applications is
    the button. The `JButton` class is your go-to button in Swing. (You’ll also find
    other popular button types, such as `JCheckbox` and `JToggleButton`, in the documentation.)
    Creating a button is very similar to creating a label, as shown in [Figure 12-7](#learnjava6-CHP-12-FIG-7).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图形应用程序中您将需要的另一个几乎通用组件是按钮。`JButton`类是Swing中您的首选按钮。（您还会在文档中找到其他流行的按钮类型，例如`JCheckbox`和`JToggleButton`。）创建按钮与创建标签非常相似，如[图 12-7](#learnjava6-CHP-12-FIG-7)所示。
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![ljv6 1207](assets/ljv6_1207.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 1207](assets/ljv6_1207.png)'
- en: Figure 12-7\. A simple `JButton`
  id: totrans-51
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图12-7\. 一个简单的`JButton`
- en: You can control the colors, text and image alignment, font, and so on for buttons
    in much the same way as you do for labels. The difference, of course, is that
    you can click on a button and react to that click in your program, whereas labels
    are mostly static displays. Try running this example and clicking on the button.
    It should change color and feel “pressed,” even though it does not perform any
    other function in our program yet. We want to go through a few more components
    before tackling that notion of “reacting” to a button click (an “event” in Swing-speak),
    but you can jump to [“Events”](#learnjava6-CHP-12-SECT-3) if you can’t wait!
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以像处理标签一样控制按钮的颜色、文本和图像对齐、字体等。当然，不同之处在于您可以单击按钮并在程序中做出反应，而标签大多是静态显示。尝试运行此示例并单击按钮。即使在我们的程序中它不执行任何其他功能，它应该会改变颜色并感觉“按下”。在我们讨论“对按钮点击做出反应”的概念之前（在
    Swing 中称为“事件”），我们希望再介绍几个组件，但如果您等不及了，可以跳到 [“Events”](#learnjava6-CHP-12-SECT-3)！
- en: Text Components
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文本组件
- en: 'It would be impossible to imagine a desktop or web application today without
    the text input fields. These input elements allow for free-form entry of information
    and are nearly ubiquitous in online forms. You can grab names, email addresses,
    phone numbers, and credit card numbers. You can do all that in languages that
    compose their characters, or others that read from right to left. Swing has three
    big text components: `JTextField`, `JTextArea`, and `JTextPane`; all extended
    from a common parent, `JTextComponent`. `JTextField` is a classic text field meant
    for brief, single-word or single-line input. `JTextArea` allows for much more
    input spread across multiple lines. `JTextPane` is a specialized component meant
    for editing rich text.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在今天的桌面或Web应用程序中，几乎无法想象没有文本输入字段。这些输入元素允许自由输入信息，并且在在线表单中几乎无处不在。您可以输入姓名、电子邮件地址、电话号码和信用卡号码。您可以在组成其字符的语言中执行所有这些操作，也可以在从右到左读取的其他语言中执行这些操作。Swing
    有三个主要的文本组件：`JTextField`、`JTextArea` 和 `JTextPane`；它们都是从共同的父类 `JTextComponent`
    扩展而来。`JTextField` 是一个经典的文本字段，用于简短的单词或单行输入。`JTextArea` 允许跨多行输入更多内容。`JTextPane`
    是一个专门用于编辑富文本的组件。
- en: Text fields
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文本字段
- en: 'Let’s get an example of text input running in our simple, flowing application.
    We’ll pare things back to two labels and corresponding text fields:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们简单流动的应用程序中运行一个文本输入的例子。我们将简化到两个标签和相应的文本字段：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Notice in [Figure 12-8](#learnjava6-CHP-12-FIG-8) that the size of a text field
    is dictated by the number of columns we specify in its constructor. That’s not
    the only way to initialize a text field, but it is useful when there are no other
    layout mechanisms dictating the width of the field. (Here, the `FlowLayout` failed
    us a bit—the `“Email:”` label did not stay on the same line as the email text
    field. We’ll fix that soon as we learn more about layouts.) Go ahead and type
    something! You can enter and delete text; highlight stuff inside the field with
    your mouse; and cut, copy, and paste as you’d expect.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在 [Figure 12-8](#learnjava6-CHP-12-FIG-8) 中，文本字段的大小由我们在其构造函数中指定的列数决定。这不是初始化文本字段的唯一方式，但在没有其他布局机制决定字段宽度时是很有用的。（在这里，`FlowLayout`
    在一定程度上让我们失望了——“电子邮件：”标签没有与电子邮件文本字段保持在同一行上。随着我们了解更多有关布局的信息，我们将很快修复它。）继续输入一些内容吧！您可以输入和删除文本；用鼠标在字段内部突出显示内容；以及按预期的方式剪切、复制和粘贴。
- en: '![ljv6 1208](assets/ljv6_1208.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 1208](assets/ljv6_1208.png)'
- en: Figure 12-8\. Simple labels and `JTextField`s
  id: totrans-60
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-8\. 简单标签和 `JTextField`
- en: If you add a text field to our demo app in *jshell*, as shown in [Figure 12-9](#learnjava6-CHP-12-FIG-9),
    you can call its `getText()` method to see that the content is indeed available
    to you.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您向我们的演示应用程序添加一个文本字段，就像在 *jshell* 中显示的 [Figure 12-9](#learnjava6-CHP-12-FIG-9)
    那样，您可以调用它的 `getText()` 方法来查看内容确实可用。
- en: '![ljv6 1209](assets/ljv6_1209.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 1209](assets/ljv6_1209.png)'
- en: Figure 12-9\. Retrieving the contents of a `JTextField`
  id: totrans-63
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-9\. 检索 `JTextField` 的内容
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that the `text` property is read-write. You can call `setText()` on your
    text field to change its content programmatically. This can be great for setting
    default values, auto-formatting things like phone numbers, or prefilling a form
    from information you gather over the network. Try it out in *jshell*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`text` 属性是可读写的。您可以在文本字段上调用 `setText()` 来程序化地更改其内容。这对于设置默认值、自动格式化诸如电话号码或从网络收集信息填充表单非常有用。在
    *jshell* 中试试吧。
- en: Text areas
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文本区域
- en: 'When you need room for more than simple words or even long URL entries, you’ll
    likely turn to `JTextArea` to give the user multiple lines of input space. You
    can create an empty text area with a constructor similar to `JTextField`. For
    `JTextArea`, you specify the number of rows in addition to the number of columns.
    Take a look at the code to add a text area to our text input demo app:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要的空间不仅限于简单的单词甚至长的 URL 输入时，您可能会转向 `JTextArea`，以便为用户提供多行输入空间。您可以使用类似 `JTextField`
    的构造函数创建一个空文本区域。对于 `JTextArea`，您除了指定列数外，还要指定行数。看一下我们添加文本区域到我们的文本输入演示应用的代码：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The results are shown in [Figure 12-10](#learnjava6-CHP-12-FIG-10). You can
    see we have room for multiple lines of text. Go ahead and run this new version
    and try it yourself. What happens if you type past the end of a line? What happens
    when you press the Return key? Do you get the behaviors you’re familiar with?
    You still have access to its content just like you do with a text field.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示在 [图 12-10](#learnjava6-CHP-12-FIG-10) 中。您可以看到我们有多行文本的空间。请运行这个新版本并自己尝试一下。当您超过一行的末尾时会发生什么？按下
    Return 键时会发生什么？您会得到您熟悉的行为吗？您仍然可以像使用文本字段一样访问其内容。
- en: '![ljv6 1210](assets/ljv6_1210.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 1210](assets/ljv6_1210.png)'
- en: Figure 12-10\. Adding a `JTextArea`
  id: totrans-71
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-10\. 添加 `JTextArea`
- en: 'Let’s add a text area to our widget in *jshell* so that we can play with its
    properties:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 *jshell* 中将一个文本区域添加到我们的小部件中，这样我们就可以玩转它的属性：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Great! We can see that the Return key we typed to produce our three lines in
    [Figure 12-11](#learnjava6-CHP-12-FIG-11) gets encoded as the `\n` character in
    the string we retrieve.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们可以看到我们在 [图 12-11](#learnjava6-CHP-12-FIG-11) 中键入的 Return 键被编码为我们检索到的字符串中的
    `\n` 字符。
- en: '![ljv6 1211](assets/ljv6_1211.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 1211](assets/ljv6_1211.png)'
- en: Figure 12-11\. Retrieving the contents of a `JTextArea`
  id: totrans-76
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-11\. 检索 `JTextArea` 的内容
- en: But what happens if you try to type a long, run-on sentence that runs past the
    end of the line? You may get an odd text area that expanded to the size of your
    window and beyond, as shown in [Figure 12-12](#learnjava6-CHP-12-FIG-12).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您尝试输入一个长的、无法停止的句子，使其超过行末会发生什么？您可能会得到一个奇怪的文本区域，它会扩展到您的窗口大小甚至更大，如 [图 12-12](#learnjava6-CHP-12-FIG-12)
    所示。
- en: '![ljv6 1212](assets/ljv6_1212.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 1212](assets/ljv6_1212.png)'
- en: Figure 12-12\. An overly long line in a simple `JTextArea`
  id: totrans-79
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-12\. 简单 `JTextArea` 中的过长行
- en: We can fix that incorrect sizing behavior by looking at a pair of properties
    of `JText``Area`, shown in [Table 12-1](#learnjava6-CHP-12-TABLE-1).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过查看 `JText``Area` 的一对属性来修复不正确的大小行为，如 [表 12-1](#learnjava6-CHP-12-TABLE-1)
    所示。
- en: Table 12-1\. Wrap properties of `JTextArea`
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 表 12-1\. `JTextArea` 的换行属性
- en: '| Property | Default | Description |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 默认值 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `lineWrap` | `false` | Whether lines longer than the table should wrap at
    all |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `lineWrap` | `false` | 表中的行是否应该完全换行 |'
- en: '| `wrapStyleWord` | `false` | If lines do wrap, whether the line breaks should
    be on word or character boundaries |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `wrapStyleWord` | `false` | 如果行有换行，是否应该在单词或字符边界上换行 |'
- en: So let’s start fresh and turn on the word wrap. We can use `setLineWrap(true)`
    to make sure the text wraps. But that’s probably not enough. We’ll add a call
    to `setWrapStyleWord(true)` to make sure the text area doesn’t just break words
    in the middle. That should look similar to [Figure 12-13](#learnjava6-CHP-12-FIG-13).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们重新开始并启用单词换行。我们可以使用 `setLineWrap(true)` 来确保文本换行。但这可能还不够。我们将添加一个调用 `setWrapStyleWord(true)`
    来确保文本区域不仅仅在单词中断。这应该看起来类似于 [图 12-13](#learnjava6-CHP-12-FIG-13)。
- en: '![ljv6 1213](assets/ljv6_1213.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 1213](assets/ljv6_1213.png)'
- en: Figure 12-13\. A wrapping line in a simple `JTextArea`
  id: totrans-88
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-13\. 在简单 `JTextArea` 中的包装行
- en: You can try that yourself in *jshell* or in your own app. When you retrieve
    the text from the `bodyArea` object, you should *not* see a line break (`\n`)
    in line three between the second “on” and the “but.”
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 *jshell* 中或您自己的应用中尝试。当您从 `bodyArea` 对象中检索文本时，您不应该在第三行中看到一个换行符（`\n`）在第二个“on”和“but”之间。
- en: Text scrolling
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文本滚动
- en: What happens if we have too many rows? On its own, `JTextArea` does that odd
    “grow until it can’t” trick, as shown in [Figure 12-14](#learnjava6-CHP-12-FIG-14).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有太多行会发生什么？独立使用 `JTextArea` 时，它会采用一个奇怪的“增长直到无法”技巧，如 [图 12-14](#learnjava6-CHP-12-FIG-14)
    所示。
- en: '![ljv6 1214](assets/ljv6_1214.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 1214](assets/ljv6_1214.png)'
- en: Figure 12-14\. Too many lines in a simple `JTextArea`
  id: totrans-93
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-14\. 在简单的 `JTextArea` 中有太多行
- en: 'To fix this problem, we need to call in some support from a standard Swing
    helper component: `JScrollPane`. This is a general-purpose container that makes
    it easy to present large components in confined spaces. To show you just how easy
    this is, let’s fix our text area:^([4](ch12.html#id2349))'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这个问题，我们需要调用标准的 Swing 辅助组件： `JScrollPane`。这是一个通用的容器，可以轻松地在有限的空间中展示大组件。为了向您展示这有多简单，让我们来修复我们的文本区域：^([4](ch12.html#id2349))。
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can see in [Figure 12-15](#learnjava6-CHP-12-FIG-15) that the text area
    no longer grows beyond the bounds of the frame. You can also see the standard
    scroll bars along the side and bottom. If you just need simple scrolling, you’re
    done! But like most other components in Swing, `JScrollPane` has many fine details
    you can adjust as needed. We won’t cover most of those here, but we do want to
    show you how to tackle a common setup for text areas: line wrapping (breaking
    on words) with vertical scrolling—meaning no horizontal scrolling.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [图 12-15](#learnjava6-CHP-12-FIG-15) 中看到，文本区域不再超出帧的边界。您还可以看到侧面和底部的标准滚动条。如果您只需要简单的滚动，您已经完成了！但是，与
    Swing 中的大多数其他组件一样，`JScrollPane` 有许多细节可以根据需要进行调整。我们不会在这里覆盖大部分内容，但我们确实想向您展示如何处理一个常见的设置：文本区域的换行（按单词换行）与垂直滚动，即不水平滚动。
- en: '![ljv6 1215](assets/ljv6_1215.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 1215](assets/ljv6_1215.png)'
- en: Figure 12-15\. Too many lines in a `JTextArea` embedded in a `JScrollPane`
  id: totrans-98
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-15\. 在 `JScrollPane` 中嵌入 `JTextArea` 的行数过多
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You should end up with a text area like the one shown in [Figure 12-16](#learnjava6-CHP-12-FIG-16).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会得到一个类似于 [图 12-16](#learnjava6-CHP-12-FIG-16) 中所示的文本区域。
- en: '![ljv6 1216](assets/ljv6_1216.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 1216](assets/ljv6_1216.png)'
- en: Figure 12-16\. A well-formed `JTextArea` in a `JScrollPane`
  id: totrans-102
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-16\. 在 `JScrollPane` 中的良好形式的 `JTextArea`
- en: Hooray! You now have a taste of the most common Swing components, including
    labels, buttons, and text fields. But we really have just scratched the surface
    of these components. Look over the Java documentation and play around with each
    of these components in *jshell* or in your own mini applications.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！您现在已经体验到了最常见的 Swing 组件，包括标签、按钮和文本字段。但是，我们实际上只是浅尝辄止了这些组件的功能。请查阅 Java 文档，并在
    *jshell* 或您自己的小型应用程序中玩耍，以更深入地了解每个组件。
- en: Getting comfortable with UI design takes practice. We encourage you to look
    up other books and online resources if you will be building desktop applications,
    but nothing beats time spent at the keyboard.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 习惯于 UI 设计需要实践。如果您将要构建桌面应用程序，我们建议您查阅其他书籍和在线资源，但是在键盘上的实践时间是无可替代的。
- en: Other Components
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他组件
- en: If you’ve already looked at the documentation on the `javax.swing` package,
    you know several dozen other components are available. Within that large list,
    there are a few that we want to highlight.^([5](ch12.html#id2356))
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经查看了 `javax.swing` 包的文档，您会知道还有几十种其他组件可供使用。在这个大列表中，有几个我们想要强调的^([5](ch12.html#id2356))。
- en: JSlider
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JSlider
- en: 'Sliders are a nifty, efficient input component when you want the user to choose
    from a range of values: for instance, things like font size selectors, color pickers,
    and zoom selectors. Sliders are perfect for the angle and force values we need
    in our apple tossing game. Our angles range from 0 to 180, and our force value
    ranges from 0 to 20 (an arbitrary maximum). [Figure 12-17](#learnjava6-CHP-12-FIG-17)
    shows these sliders in place (ignore how we achieved the layout for now).'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当您希望用户从一系列值中进行选择时，滑块是一个巧妙且高效的输入组件：例如，字体大小选择器、颜色选择器和缩放选择器等。对于我们苹果投掷游戏中所需的角度和力量值，滑块非常合适。我们的角度范围从
    0 到 180，力量值范围从 0 到 20（一个任意的最大值）。[图 12-17](#learnjava6-CHP-12-FIG-17) 展示了这些滑块的位置（暂时忽略我们如何实现布局）。
- en: '![ljv6 1217](assets/ljv6_1217.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 1217](assets/ljv6_1217.png)'
- en: Figure 12-17\. Using `JSlider` in our apple tossing game
  id: totrans-110
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-17\. 在我们的苹果投掷游戏中使用 `JSlider`
- en: 'To create a new slider, you provide three values: the minimum (`0` for our
    angle slider), the maximum (`180`), and the initial value (start in the middle
    for the game at `90`). You can add such a slider to our *jshell* playground like
    this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的滑块，您需要提供三个值：最小值（我们的角度滑块为 `0`），最大值（`180`）和初始值（游戏中为 `90` 中间位置）。您可以像这样将这样的滑块添加到我们的
    *jshell* 游乐场：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Scoot the slider around like you see in [Figure 12-18](#learnjava6-CHP-12-FIG-18),
    then look at its current value using the `getValue()` method:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 将滑块移动到像[图 12-18](#learnjava6-CHP-12-FIG-18) 中所示的位置，然后使用 `getValue()` 方法查看其当前值：
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '![ljv6 1218](assets/ljv6_1218.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 1218](assets/ljv6_1218.png)'
- en: Figure 12-18\. A simple `JSlider` in *jshell*
  id: totrans-116
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-18\. *jshell* 中简单的 `JSlider`
- en: In [“Events”](#learnjava6-CHP-12-SECT-3), we’ll see how to receive those values
    in real time as the user changes them.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“事件”](#learnjava6-CHP-12-SECT-3)中，我们将看到如何在用户更改这些值时实时接收它们。
- en: 'The `JSlider` constructors use integers for the minimum and maximum values,
    and `getValue()` returns an integer. If you need fractional values, that falls
    to you. The force slider in our game, for example, would benefit from supporting
    more than 21 discrete levels. We can address that by building the slider with
    a larger range of integers, then dividing the current value by an appropriate
    scale factor:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`JSlider`构造函数使用整数作为最小和最大值，并且`getValue()`返回一个整数。 如果您需要分数值，则需要自行处理。 例如，在我们的游戏中的力量滑块将受益于支持超过21个离散级别。
    我们可以通过使用较大范围的整数构建滑块，然后将当前值除以适当的比例因子来解决这个问题：'
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: JList
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JList
- en: If you have a discrete set of values but those values are not a simple, contiguous
    range of numbers, the “list” UI element is a great choice. `JList` is the Swing
    implementation of this input type. You can set it to allow single or multiple
    selections, and if you dig deeper into Swing’s features, you can produce custom
    views that display the items in your list with extra information or details. (For
    example, you can make lists of icons, or icons and text, or multiline text, and
    so on.)
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一组离散的值，但这些值不是简单的连续数字范围，则“列表”UI元素是一个很好的选择。 `JList`是此输入类型的Swing实现。 您可以设置它以允许单个或多个选择，并且如果您深入研究Swing的功能，您可以生成自定义视图，显示列表中的项目及其额外信息或详细信息。（例如，您可以制作图标列表，或图标和文本，或多行文本等）。
- en: Unlike the other components we’ve seen so far, `JList` requires a little more
    information to get started. To make a useful list component, you need to use one
    of the constructors that takes the data you intend to show. The simplest such
    constructor accepts an `Object` array. While you can pass an array of objects
    of any type, the default behavior of `JList` will be to show the output of your
    objects’ `toString()` method in the list. Using an array of `String` objects is
    very common and produces the expected results. [Figure 12-19](#learnjava6-CHP-12-FIG-19)
    shows a simple list of cities.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们迄今看到的其他组件不同，`JList`需要更多信息才能启动。 要创建一个有用的列表组件，您需要使用接受您打算显示的数据的构造函数之一。 最简单的这种构造函数接受一个`Object`数组。
    虽然您可以传递任何类型的对象数组，但`JList`的默认行为是显示列表中对象的`toString()`方法的输出。 使用`String`对象数组非常常见且产生预期结果。
    [图 12-19](#learnjava6-CHP-12-FIG-19)显示了一个简单的城市列表。
- en: '![ljv6 1219](assets/ljv6_1219.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 1219](assets/ljv6_1219.png)'
- en: Figure 12-19\. A simple `JList` of four cities in *jshell*
  id: totrans-124
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-19\. *jshell*中四个城市的简单`JList`
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We use the same `<String>` type information with the constructor as we do when
    creating parameterized collection objects, such as `ArrayList` (see [“Type Limitations”](ch07.html#learnjava6-CHP-7-SECT-2)).
    As Swing was added well before generics, you may encounter examples online or
    in books that do not add the type information. Omitting it doesn’t stop your code
    from compiling or running, but you will receive the same `unchecked` warning message
    at compile time that you saw with the collection classes.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在构造函数中使用与创建参数化集合对象（例如`ArrayList`，请参见[“类型限制”](ch07.html#learnjava6-CHP-7-SECT-2)）时相同的`<String>`类型信息。
    由于Swing是在泛型之前添加的，因此您可能会在在线或书籍示例中找到未添加类型信息的示例。 省略它不会阻止代码编译或运行，但是您会在编译时收到与集合类相同的`unchecked`警告消息。
- en: 'Similar to getting the current value of a slider, you can retrieve the selected
    item or items in a list at any time using one of four methods:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 与获取滑块当前值类似，您可以随时使用四种方法之一检索列表中选择的项目或项目：
- en: '`getSelectedIndex()`'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`getSelectedIndex()`'
- en: For single-select lists, returns an `int`
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单选列表，返回一个`int`
- en: '`getSelectedIndices()`'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`getSelectedIndices()`'
- en: For multiselect lists, returns an array of `int`
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于多选列表，返回一个`int`数组
- en: '`getSelectedValue()`'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`getSelectedValue()`'
- en: For single-select lists, returns an object
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单选列表，返回一个对象
- en: '`getSelectedValues()`'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`getSelectedValues()`'
- en: For multiselect lists, returns an array of objects
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于多选列表，返回一个对象数组
- en: 'The main difference is whether the index of the selected item(s) or the actual
    value(s) is more useful to you. Playing with our city list in *jshell*, we can
    pull out a selected city like so:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 主要区别在于选择项目的索引还是实际值对您更有用。 在*jshell*中操作我们的城市列表时，我们可以这样提取出所选城市：
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: For large lists, you’ll probably want a scroll bar. Swing promotes reusability
    in its code, so you can use a `JScrollPane` with `JList` just like we did for
    text areas.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大列表，您可能希望有一个滚动条。 Swing在其代码中促进了可重用性，因此您可以像对文本区域一样使用`JScrollPane`与`JList`。
- en: Containers and Layouts
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器和布局
- en: That formidable list of components is only a subset of the widgets available.
    In this section, you’ll be laying out the components we’ve discussed into useful
    arrangements. Those arrangements happen inside a *container*, which is Java’s
    term for a component that can have (or “contain”) other components. Let’s start
    by looking at the most common containers.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 那些组件的庞大列表只是可用部件的子集。在本节中，您将把我们讨论过的组件布局到有用的排列中。这些排列发生在一个*容器*内，这是 Java 中用于可以包含其他组件的组件的术语。让我们从查看最常见的容器开始。
- en: Frames and Windows
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 框架和窗口
- en: Every desktop application needs at least one window. This term predates Swing
    and is used by most graphical interfaces available on the three big operating
    systems—including Windows (no relation). Swing does provide a low-level `JWindow`
    class if you need it, but most likely you will build your application inside a
    `JFrame`. [Figure 12-20](#learnjava6-CHP-12-FIG-20) illustrates the class hierarchy
    of `JFrame`. We will stick to its basic features, but as your applications become
    richer, you may want to create customized windows using elements higher up in
    the hierarchy.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 每个桌面应用程序至少需要一个窗口。这个术语早于 Swing 并且被大多数三大操作系统的图形界面使用，包括 Windows（无关）。如果您需要，Swing
    确实提供了一个低级别的 `JWindow` 类，但最有可能您会在 `JFrame` 中构建您的应用程序。图 12-20 展示了 `JFrame` 的类层次结构。我们将坚持其基本特性，但随着您的应用程序变得更加丰富，您可能希望使用层次结构中更高级的元素创建定制窗口。
- en: '![ljv6 1220](assets/ljv6_1220.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 1220](assets/ljv6_1220.png)'
- en: Figure 12-20\. The `JFrame` class hierarchy
  id: totrans-144
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-20\. `JFrame` 类的层次结构
- en: 'Let’s revisit the creation of that first graphical application from [Chapter 2](ch02.html#learnjava6-CHP-2)
    and focus a bit more on the `JFrame` object:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新审视来自[第 2 章](ch02.html#learnjava6-CHP-2)中的第一个图形应用程序的创建，并更加关注 `JFrame` 对象：
- en: '[PRE17]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The string we pass to the `JFrame` constructor becomes the title of the window.
    We then set a few specific properties on our object. We make sure that when the
    user closes the window, we quit our program. (That might seem obvious, but complex
    applications might have multiple windows, such as tool palettes or support for
    multiple documents. Closing one window in these applications may not mean “quit.”)
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递给 `JFrame` 构造函数的字符串将成为窗口的标题。然后我们在对象上设置一些特定的属性。确保当用户关闭窗口时，我们退出程序。（这似乎是显而易见的，但是复杂的应用可能会有多个窗口，例如工具面板或支持多文档。在这些应用中关闭一个窗口可能并不意味着“退出”。）
- en: We then pick a starting size for the window and add our actual label component
    to the frame (which in turn places the label in its *content pane*, more on that
    in a minute). Once the component is added, we make the window visible, and the
    result is [Figure 12-21](#learnjava6-CHP-12-FIG-21).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们选择窗口的起始大小，并将实际的标签组件添加到框架中（这将标签放置在其*内容面板*中，稍后会详细介绍）。一旦组件被添加，我们会使窗口可见，结果是[图 12-21](#learnjava6-CHP-12-FIG-21)。
- en: '![ljv6 1221](assets/ljv6_1221.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 1221](assets/ljv6_1221.png)'
- en: Figure 12-21\. A simple `JFrame` with an added label
  id: totrans-150
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-21\. 一个简单的 `JFrame`，带有一个添加的标签
- en: This basic process is the foundation of every Swing application. The interesting
    part of your application comes from what you do with that content pane.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基本过程是每个 Swing 应用程序的基础。您的应用程序的有趣部分来自于您如何处理那个内容面板。
- en: But what *is* that content pane? The frame uses its own set of containers that
    hold various parts of typical applications. You can set your own content pane
    to be any object descended from `java.awt.Container`, but we’ll be sticking with
    the default for now.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 那么*内容面板*是什么？框架使用其自己的一组容器来持有典型应用程序的各种部分。您可以将自己的内容面板设置为任何继承自 `java.awt.Container`
    的对象，但是我们暂时将坚持使用默认的内容面板。
- en: 'We are also using a shortcut to add our label. The `JFrame` version of `add()`
    will delegate to the content pane’s `add()`. The following snippet shows how to
    add the label without the shortcut:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了一个快捷方式来添加我们的标签。`JFrame` 版本的 `add()` 将委托给内容面板的 `add()`。以下片段显示了如何在没有快捷方式的情况下添加标签：
- en: '[PRE18]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `JFrame` class does not have shortcuts for everything, however. Read the
    documentation and use a shortcut if it exists. If not, don’t hesitate to grab
    a reference via `getContentPane()` and then configure or tweak that container
    as needed.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`JFrame` 类并不是所有功能都有快捷方式。阅读文档并使用存在的快捷方式。如果没有，不要犹豫，通过 `getContentPane()` 获取引用，然后根据需要配置或调整该容器。'
- en: JPanel
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JPanel
- en: The default content pane is a `JPanel`, the go-to container in Swing. It is
    a component just like `JButton` or `JLabel`, so your panels can contain other
    panels. Such nesting often plays a big role in application layout. For example,
    you could create a `JPanel` to house the formatting buttons of a text editor in
    a “toolbar,” then add that toolbar to the content pane. This arrangement makes
    it easy for users to show, hide, or move it around.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 默认内容面板是一个 `JPanel`，在 Swing 中通常用作容器。它像 `JButton` 或 `JLabel` 一样是一个组件，因此您的面板可以包含其他面板。这种嵌套在应用程序布局中通常起着重要作用。例如，您可以创建一个
    `JPanel` 来容纳文本编辑器中的格式化按钮，然后将该工具栏添加到内容面板。这种安排使用户可以轻松显示、隐藏或移动它。
- en: '`JPanel` lets you add and remove components from the screen. (The methods are
    inherited from the `Container` class, but we access them through our `JPanel`
    objects.) You can also `repaint()` a panel if something has changed and you want
    to update your UI.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`JPanel` 允许您向屏幕添加和移除组件。（这些方法从 `Container` 类继承，但我们通过 `JPanel` 对象访问它们。）如果有什么变化并且您想更新您的
    UI，还可以使用 `repaint()` 方法重绘面板。'
- en: 'We can see the effects of the `add()` and `remove()` methods shown in [Figure 12-22](#learnjava6-CHP-12-FIG-22)
    using our playground widget in *jshell*:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 *jshell* 中的 playground 小部件来看到 `add()` 和 `remove()` 方法的效果，如 [图 12-22](#learnjava6-CHP-12-FIG-22)
    所示：
- en: '[PRE19]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Try it yourself! Most applications don’t add and remove components willy-nilly.
    You’ll usually build your interface by adding what you need and then leave it
    alone. You might enable or disable some buttons along the way, but try not to
    surprise the user with disappearing parts or new elements popping up.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 请尝试自己操作！大多数应用程序不会随意添加和移除组件。通常，您会通过添加所需的内容来构建界面，然后让它保持不变。沿途可能会启用或禁用一些按钮，但请尽量避免让用户感到意外，出现部分组件消失或新元素弹出的情况。
- en: '![ljv6 1222](assets/ljv6_1222.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 1222](assets/ljv6_1222.png)'
- en: Figure 12-22\. Adding and removing components in a `JPanel`
  id: totrans-163
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-22\. 在 `JPanel` 中添加和移除组件
- en: Layout Managers
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布局管理器
- en: Containers like `JPanel` are responsible for laying out the components you add.
    Java provides several *layout managers* to help you achieve your desired results.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 类似 `JPanel` 的容器负责布置您添加的组件。Java 提供了多个 *布局管理器* 来帮助您实现所需的结果。
- en: BorderLayout
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: BorderLayout
- en: 'You’ve already seen the `FlowLayout` in action. You were using another layout
    manager without really knowing it: the content pane of a `JFrame` uses `BorderLayout`
    by default. [Figure 12-23](#learnjava6-CHP-12-FIG-23) shows the five areas controlled
    by `BorderLayout`, along with their regions. Notice that the `NORTH` and `SOUTH`
    regions are as wide as the application window but only as tall as required to
    fit the label. Similarly, the `EAST` and `WEST` regions fill the vertical gap
    between the `NORTH` and `SOUTH` regions but are only as wide as required, leaving
    the remaining space to be filled both horizontally and vertically by the `CENTER`
    region:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到 `FlowLayout` 的效果。在不知不觉中，您使用了另一个布局管理器：`JFrame` 的内容面板默认使用 `BorderLayout`。[图 12-23](#learnjava6-CHP-12-FIG-23)
    展示了 `BorderLayout` 控制的五个区域及其区域。请注意，`NORTH` 和 `SOUTH` 区域与应用程序窗口一样宽，但只有足够容纳标签的高度。同样，`EAST`
    和 `WEST` 区域填充了 `NORTH` 和 `SOUTH` 区域之间的垂直间隙，但仅宽到足够容纳，留下剩余空间由 `CENTER` 区域横向和纵向填充：
- en: '[PRE20]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![ljv6 1223](assets/ljv6_1223.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 1223](assets/ljv6_1223.png)'
- en: Figure 12-23\. The regions available with `BorderLayout`
  id: totrans-170
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-23\. 使用 `BorderLayout` 可用的区域
- en: The `add()` method in this case takes an extra argument and passes it to the
    layout manager. (Not all managers need this argument, as you saw with `FlowLayout`.)
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`add()` 方法需要额外的参数，并将其传递给布局管理器。（并非所有的管理器都需要此参数，就像您在 `FlowLayout` 中看到的那样。）
- en: '[Figure 12-24](#learnjava6-CHP-12-FIG-24) shows an example of nesting `JPanel`
    objects within an application. We use a text area for a large message in the center
    and then add some action buttons to a panel along the bottom. Again, without the
    events we’ll cover in the next section, none of these buttons do anything, but
    we want to show you how to work with multiple containers. And you could continue
    nesting `JPanel` objects if you wanted.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 12-24](#learnjava6-CHP-12-FIG-24) 展示了在应用程序中嵌套 `JPanel` 对象的示例。我们在中心使用文本区域显示了一个大消息，然后在底部的面板上添加了一些操作按钮。同样，在接下来的部分中我们会涵盖的事件中，这些按钮目前并不起作用，但我们想向您展示如何使用多个容器。如果需要，您可以继续嵌套
    `JPanel` 对象。'
- en: 'Sometimes a better top-level layout choice makes your app both more maintainable
    and more performant:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，更好的顶层布局选择可以使您的应用程序更易维护，性能更佳：
- en: '[PRE21]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '![ljv6 1224](assets/ljv6_1224.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 1224](assets/ljv6_1224.png)'
- en: Figure 12-24\. A simple nested container example
  id: totrans-176
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-24\. 一个简单的嵌套容器示例
- en: Two things to note in this example. First, you might see that we did not specify
    the number of rows or columns when creating our `JTextArea` object. Unlike `FlowLayout`,
    `BorderLayout` will set the size of its components when possible. For the top
    and bottom, this means using the component’s own height, similar to how `FlowLayout`
    works, but then setting the width of the component to fill the frame. The sides
    use their components’ width, but the layout manager sets the height. `BorderLayout`
    sets both the width and height of the component in the center.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中有两点需要注意。首先，当我们创建 `JTextArea` 对象时没有指定行数或列数，与 `FlowLayout` 不同，`BorderLayout`
    会在可能的情况下设置组件的大小。对于顶部和底部，这意味着使用组件自身的高度，类似于 `FlowLayout` 的工作方式，然后设置组件的宽度以填充框架。侧边使用它们的组件宽度，但布局管理器设置高度。`BorderLayout`
    在中心设置组件的宽度和高度。
- en: Second, when we add the `messageArea` and `buttonPanel` objects to the `frame`,
    we specify the extra “where” argument to the frame’s `add()` method. However,
    when we are adding the buttons themselves to `buttonPanel`, we use the simpler
    version of `add()` with only the component argument. The container’s layout manager
    dictates which variation of `add()` we need. So even though the `buttonPanel`
    is in the `SOUTH` region of the frame using `BorderLayout`, the `saveButton` and
    its compatriots are in an enclosing container of their own and don’t know or care
    about what is happening outside that container.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，在将 `messageArea` 和 `buttonPanel` 对象添加到 `frame` 时，我们在 `frame` 的 `add()` 方法中指定了额外的“where”参数。然而，当我们将按钮本身添加到
    `buttonPanel` 时，我们使用了更简单的 `add()` 版本，只有组件参数。容器的布局管理器决定我们需要使用 `add()` 的哪个变体。因此，尽管
    `buttonPanel` 在使用 `BorderLayout` 的 `SOUTH` 区域，`saveButton` 及其同伴位于它们自己的封闭容器中，不知道也不关心容器外部发生的事情。
- en: GridLayout
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GridLayout
- en: 'Many times you need (or want) your components or labels to occupy symmetric
    spaces. Think of the Yes, No, and Cancel buttons along the bottom of a confirmation
    dialog. (Swing can make those dialogs, too; more on that in [“Modals and Pop-Ups”](#learnjava6-CHP-12-SECT-5.2).)
    The `GridLayout` class can help with such even spacing. Let’s try using `GridLayout`
    for those buttons in our previous example. All we have to do is change one line:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 许多时候，你需要（或希望）你的组件或标签占据对称的空间。想想确认对话框底部的“是”，“否”和“取消”按钮。（Swing 也可以制作这些对话框；详见 [“模态和弹出窗口”](#learnjava6-CHP-12-SECT-5.2)。）`GridLayout`
    类可以帮助实现这样均匀的间距。让我们尝试在前面的例子中使用 `GridLayout` 来排列这些按钮。我们只需要改变一行代码：
- en: '[PRE22]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The calls to `add()` remain exactly the same; no separate constraint argument
    is needed.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `add()` 的调用保持完全相同；不需要单独的约束参数。
- en: As you can see in [Figure 12-25](#learnjava6-CHP-12-FIG-25), the `GridLayout`
    buttons are the same size, even though the text of the Cancel button is a bit
    longer than the others.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在 [图 12-25](#learnjava6-CHP-12-FIG-25) 中所看到的，`GridLayout` 的按钮尺寸相同，尽管“取消”按钮的文本比其他按钮稍长。
- en: '![ljv6 1225](assets/ljv6_1225.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 1225](assets/ljv6_1225.png)'
- en: Figure 12-25\. Using `GridLayout` for a row of buttons
  id: totrans-185
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-25\. 使用 `GridLayout` 布局一行按钮
- en: In creating the layout manager, we told it we want exactly one row, with no
    restrictions on how many columns `(1, 0)`. Grids can also be two-dimensional with
    multiple rows and columns. [Figure 12-26](#learnjava6-CHP-12-FIG-26) shows the
    classic phone-keypad layout as an example.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建布局管理器时，我们告诉它我们只想要一行，没有列数的限制 `(1, 0)`。网格也可以是二维的，具有多行和多列。[图 12-26](#learnjava6-CHP-12-FIG-26)
    以手机键盘布局为例。
- en: '[PRE23]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Adding the buttons in order from left to right, top to bottom, should result
    in the app you see in [Figure 12-26](#learnjava6-CHP-12-FIG-26).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 从左到右，从上到下依次添加按钮，应该能看到 [图 12-26](#learnjava6-CHP-12-FIG-26) 中的应用程序。
- en: '![ljv6 1226](assets/ljv6_1226.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 1226](assets/ljv6_1226.png)'
- en: Figure 12-26\. A two-dimensional grid layout for a phone pad
  id: totrans-190
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-26\. 手机键盘的二维网格布局
- en: Very handy and very easy if you need perfectly symmetric elements. But what
    if you want a *mostly* symmetric layout? Think of popular web forms with a column
    of labels on the left and a column of text fields on the right. `GridLayout` could
    handle a basic, two-column form like that, but many times your labels are short
    and simple, while your text fields are wider, giving the user more space to type.
    How does Java accommodate those layouts?
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要完全对称的元素，这非常方便且非常简单。但如果你想要一个*大部分*对称的布局呢？想象一下流行的网页表单，左侧是标签列，右侧是文本字段列。`GridLayout`
    可以处理类似这样的基本两列表单，但很多时候你的标签简短简单，而文本字段却较宽，给用户更多输入空间。Java 如何适应这些布局？
- en: GridBagLayout
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GridBagLayout
- en: If you need a more interesting layout but don’t want to nest lots of panels,
    consider `GridBagLayout`. It’s more complex to set up, but it allows for intricate
    layouts that still keep elements aesthetically aligned and sized. Similar to `BorderLayout`,
    you add components with an extra argument. The argument for `GridBagLayout`, however,
    is a rich `GridBagConstraints` object rather than a simple `String`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要更有趣的布局，但又不想嵌套大量面板，考虑使用`GridBagLayout`。它设置更复杂，但允许创建复杂的布局，仍然可以使元素在视觉上对齐和大小合适。与`BorderLayout`类似，您需要使用额外的参数添加组件。然而，`GridBagLayout`的参数是丰富的`GridBagConstraints`对象，而不是简单的字符串。
- en: The “grid” in `GridBagLayout` is exactly that, a rectangular container divvied
    up into various rows and columns. The “bag” part, though, comes from a grab-bag
    notion of how you use the cells created by those rows and columns. The rows and
    columns can have their own height or width, and components can occupy any rectangular
    collection of cells. We can take advantage of this flexibility to build out our
    game interface with a single `JPanel` rather than with several nested panes. [Figure 12-27](#learnjava6-CHP-12-FIG-27)
    shows one way of carving up the screen into four rows and three columns, and then
    placing the components.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`GridBagLayout`中的“grid”确实是这样，一个被分成各种行和列的矩形容器。“bag”的部分来自于如何使用这些行和列创建的单元格的“抓袋”概念。行和列可以有自己的高度或宽度，并且组件可以占据任何矩形的一系列单元格。我们可以利用这种灵活性，通过单个`JPanel`构建出我们的游戏界面，而不是使用几个嵌套的面板。[图 12-27](#learnjava6-CHP-12-FIG-27)展示了将屏幕分为四行三列的一种方式，并放置组件。'
- en: '![ljv6 1227](assets/ljv6_1227.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 1227](assets/ljv6_1227.png)'
- en: Figure 12-27\. An example grid for use with `GridBagLayout`
  id: totrans-196
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-27\. `GridBagLayout`使用的示例网格
- en: You can see the different row heights and column widths. Some components occupy
    more than one cell. This type of arrangement won’t work for every application,
    but it is powerful and works for many UIs that need more than simple layouts.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到不同的行高和列宽。有些组件占用多个单元格。这种类型的布局不适用于每个应用程序，但对于需要更复杂布局的许多用户界面来说是强大且有效的。
- en: 'To build an application with a `GridBagLayout`, you need to keep a couple of
    references around as you add components. Let’s set up the grid first:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`GridBagLayout`构建应用程序，您需要在添加组件时保留几个引用。让我们首先设置网格：
- en: '[PRE24]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This step requires a little planning on your part, but it’s easy to adjust
    once you get a few components on the screen. To add those components, you need
    to create and configure a `GridBagConstraints` object. Fortunately, you can reuse
    the same object for all of your components—you just need to repeat the configuration
    portion before adding each element. Here’s an example of how you could add the
    main playing field component:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步需要您进行一些计划，但一旦您在屏幕上放置了几个组件，就很容易调整。要添加这些组件，您需要创建和配置`GridBagConstraints`对象。幸运的是，您可以重用相同的对象来配置所有组件——您只需要在添加每个元素之前重复配置部分。这里是如何添加主游戏场组件的示例：
- en: '[PRE25]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Notice how we set which cells the field will occupy. We specify the upper-left
    corner of a rectangle by giving the row (`gridy`) and column (`gridx`). Then we
    specify how many rows our field will occupy (`gridheight`) and how many columns
    (`gridwidth`). This is the core of configuring grid bag constraints.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何设置字段将占用的单元格。我们通过指定左上角的矩形来指定一个矩形，即给出行（`gridy`）和列（`gridx`）。然后我们指定我们的字段将占用的行数（`gridheight`）和列数（`gridwidth`）。这是配置网格包约束的核心。
- en: You can also adjust things like how a component will fill the cells it occupies
    (`fill`) and how much of a margin each component gets. We’ve settled on simply
    filling all of the space available in a group of cells (“both” a horizontal fill
    and a vertical fill), but you can read about more options in the [documentation
    for `GridBagConstraints`](https://oreil.ly/XwdXt).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以调整诸如组件如何填充其占用的单元格（`fill`）以及每个组件获得多少边距等内容。我们已经决定简单地填充一组单元格中的所有可用空间（水平和垂直填充），但您可以在[`GridBagConstraints`的文档](https://oreil.ly/XwdXt)中了解更多选项。
- en: 'Let’s add a scorekeeping label at the top:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在顶部添加一个记分标签：
- en: '[PRE26]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'For this second component, do you see how similar the setup of the constraints
    is to how we handled the game field? Any time you see similarities like this,
    consider pulling those similar steps into a function you can reuse:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二个组件，您是否看到约束设置如何与处理游戏场类似？每当看到这种类似性时，考虑将这些相似的步骤提取到一个可以重用的函数中：
- en: '[PRE27]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then you could rewrite the earlier blocks of code for the score label and game
    field, like this:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以像这样重写先前的记分标签和游戏字段代码块：
- en: '[PRE28]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'With that function in place, you can quickly add the various other components
    and labels to complete the game interface. For example, the toss button in the
    lower-right corner of [Figure 12-27](#learnjava6-CHP-12-FIG-27) can be set up
    like this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个功能，您可以快速添加各种其他组件和标签，以完成游戏界面。例如，右下角的[图12-27](#learnjava6-CHP-12-FIG-27)中的投掷按钮可以设置如下：
- en: '[PRE29]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Much cleaner! We simply continue creating our components and placing them on
    the correct row and column, with the appropriate spans. In the end we have a reasonably
    interesting set of components laid out in a single container.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 更干净！我们只需继续创建我们的组件并将它们放置在正确的行和列上，具有适当的跨度。最后，我们在单个容器中拥有一组相当有趣的组件。
- en: As with other sections in this chapter, we don’t have time to cover every layout
    manager, or even every feature of the layout managers we do discuss. Be sure to
    check the Java documentation and try creating a few dummy apps to play with the
    different layouts. As a starting point, `BoxLayout` is a nice upgrade to the grid
    idea, and `GroupLayout` can produce data-entry forms. For now, though, we’re going
    to move on. Time to get all these components “hooked up” and responding to all
    the typing and clicking and button pushing—actions that are encoded in Java as
    events.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章的其他部分一样，我们没有时间涵盖每个布局管理器，甚至不涵盖我们讨论的每个布局管理器的每个功能。请务必查阅Java文档，并尝试创建一些虚拟应用程序来测试不同的布局。作为起点，`BoxLayout`是对网格概念的良好升级，而`GroupLayout`可以生成数据输入表单。不过，现在我们要继续前进。现在是将所有这些组件“连接”起来，并响应所有键入、点击和按钮推送的时间了——这些在Java中被编码为事件。
- en: Events
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件
- en: As discussed in [“Model View Controller Architecture”](#learnjava6-CHP-12-SECT-1.2),
    the model and view elements of MVC designs are straightforward. But what about
    the controller aspect? In Swing (and Java more generally), interaction between
    users and components is communicated via events. An *event* contains general information,
    such as when the interaction occurred, as well as information specific to the
    event type, such as the point on your screen where you clicked your mouse, or
    which key you typed on your keyboard. A *listener* (or *handler*) picks up the
    message and can respond in some useful way. Connecting components to listeners
    is what allows users to control your application.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如在[“模型-视图-控制器架构”](#learnjava6-CHP-12-SECT-1.2)中讨论的那样，MVC设计中的模型和视图元素是直接的。但是控制器方面呢？在Swing（以及更广泛的Java应用中），用户与组件之间的交互通过事件进行通信。*事件*包含一般信息，例如交互发生的时间，以及事件类型特有的信息，例如您点击鼠标的屏幕上的点，或者您在键盘上输入的键。*监听器*（或*处理程序*）接收消息并可以以某种有用的方式响应。将组件连接到监听器就允许用户控制您的应用程序。
- en: Mouse Events
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 鼠标事件
- en: The easiest way to get started is just to generate and handle an event. Let’s
    follow in the footsteps of our first, quick applications with a `HelloMouse` application
    and focus on handling mouse events. When we click our mouse, we’ll use that click
    event to determine the position of our `JLabel`. (This will require removing the
    layout manager, by the way. We want to set the coordinates of our label manually.)
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的开始方法就是生成和处理事件。让我们跟随我们第一个快速应用程序的脚步，使用`HelloMouse`应用程序并专注于处理鼠标事件。当我们点击鼠标时，我们将使用该点击事件确定我们的`JLabel`的位置。（顺便说一句，这将需要移除布局管理器。我们希望手动设置标签的坐标。）
- en: 'As you look at the source code for this example, pay attention to a few particular
    items, noted with the numbered callouts:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当您查看此示例的源代码时，请注意一些特定项，如下所示：
- en: '[PRE30]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[![1](assets/1.png)](#co_desktop_applications_CO2-1)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_desktop_applications_CO2-1)'
- en: As you click, Java picks up low-level events from your hardware (computer, mouse,
    keyboard) and hands them to an appropriate listener. Listeners are interfaces.
    You can make special classes just to implement the interface, or you can implement
    listeners as part of your main application class, like we did here. Where you
    choose to handle events really depends on what actions you need to take in response
    to them. You’ll see a number of examples of both approaches throughout the rest
    of this book.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当您点击时，Java会从硬件（计算机、鼠标、键盘）捕获低级事件并将其交给适当的监听器。监听器是接口。您可以创建特殊的类来实现接口，或者您可以将监听器作为主应用程序类的一部分实现，就像我们在这里所做的那样。您选择处理事件的位置确实取决于您需要对其响应的操作。在本书的其余部分中，您将看到许多这两种方法的示例。
- en: '[![2](assets/2.png)](#co_desktop_applications_CO2-3)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_desktop_applications_CO2-3)'
- en: 'We implemented the `MouseListener` interface in addition to extending `JFrame`.
    We had to provide a body for every method listed in `MouseListener`, but we do
    our real work in `mouseClicked()`. This method takes the coordinates of the click
    from the `event` object and uses them to change the position of the label. The
    `MouseEvent` class contains a wealth of information about the event: when it occurred,
    which component it occurred on, which mouse button was involved, the (x,y) coordinate
    where the event occurred, and so on. Try printing some of that information in
    some of the unimplemented methods, such as `mouseDown()`.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 除了扩展`JFrame`，我们还实现了`MouseListener`接口。我们必须为`MouseListener`中列出的每个方法提供一个方法体，但我们在`mouseClicked()`中完成了真正的工作。此方法从`event`对象中获取点击的坐标，并使用它们来更改标签的位置。`MouseEvent`类包含关于事件的丰富信息：发生时间，发生在哪个组件上，涉及哪个鼠标按钮，事件发生的(x,y)坐标等等。尝试在某些未实现的方法中打印一些信息，如`mouseDown()`。
- en: '[![3](assets/3.png)](#co_desktop_applications_CO2-4)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_desktop_applications_CO2-4)'
- en: We added quite a few methods for other types of mouse events that we didn’t
    use. That’s common with lower-level events, such as mouse and keyboard events.
    The listener interfaces are designed to give you a central collecting point for
    related events. You have to implement every method in the interface, but you can
    respond to the particular events you care about and leave the other methods empty.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了许多其他类型的鼠标事件方法，但我们没有使用。这在低级事件（如鼠标和键盘事件）中很常见。监听器接口旨在为相关事件提供一个集中的收集点。您必须实现接口中的每个方法，但可以响应您关心的特定事件，并将其他方法留空。
- en: '[![4](assets/4.png)](#co_desktop_applications_CO2-2)'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_desktop_applications_CO2-2)'
- en: The other critical bit of new code is the call to `addMouseListener()` for our
    content pane. The syntax may look a little odd, but it’s a standard approach.
    Using `getContentPane()` says “this is the component generating events,” and using
    `this` as the argument says “this is the class receiving (handling) the events.”
    In this example, the events from the frame’s content pane will be delivered back
    to the same class, which is where we put all of the mouse-handling code.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 新代码的另一个关键部分是为我们的内容窗格调用`addMouseListener()`。语法可能看起来有点奇怪，但这是一种标准方法。使用`getContentPane()`表示“这是生成事件的组件”，并将`this`作为参数表示“这是接收（处理）事件的类”。在这个例子中，来自框架内容窗格的事件将返回给相同的类，这是我们放置所有鼠标处理代码的地方。
- en: Go ahead and run the application. You’ll get a variation on the familiar “Hello,
    World” graphical application, shown in [Figure 12-28](#learnjava6-CHP-12-FIG-28).
    The friendly message should follow your mouse as you click around.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行应用程序。你将得到一个变体的熟悉的“Hello, World”图形应用程序，如[图 12-28](#learnjava6-CHP-12-FIG-28)所示。友好的消息应该会随着你点击而跟随鼠标移动。
- en: '![ljv6 1228](assets/ljv6_1228.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 1228](assets/ljv6_1228.png)'
- en: Figure 12-28\. Using a `MouseEvent` to position a label
  id: totrans-230
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图12-28\. 使用`MouseEvent`定位标签
- en: Mouse adapters
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 鼠标适配器
- en: 'If you want to try the helper-class approach, you could add a separate class
    to the file and implement `MouseListener` in that class. If so, you can take advantage
    of a shortcut Swing provides for many listeners. The `MouseAdapter` class is a
    simple implementation of the `MouseListener` interface, with empty methods written
    for every event. When you `extend` this class, you override only the methods you
    care about. That makes for a clean, concise handler:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想尝试辅助类方法，可以向文件添加一个单独的类并在该类中实现`MouseListener`。如果是这样，您可以利用Swing为许多侦听器提供的一种快捷方式。`MouseAdapter`类是`MouseListener`接口的简单实现，其中为每个事件编写了空方法。当您`extend`此类时，您只需要覆盖您关心的方法。这样可以使处理程序变得干净而简洁：
- en: '[PRE31]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Remember that helper classes need to have a reference to every object they touch.
    We passed our label to the constructor of our adapter. That’s a popular way to
    establish the necessary connections, but you could certainly add the required
    access later—as long as the handler has a reference to every object it needs before
    it starts receiving events.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，辅助类需要引用它们所接触的每个对象。我们将标签传递给了我们适配器的构造函数。这是建立必要连接的一种流行方式，但只要处理程序在开始接收事件之前具有对其所需每个对象的引用即可随时添加所需的访问。
- en: Action Events
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动作事件
- en: While low-level mouse and keyboard events are available on just about every
    Swing component, they can be a little tedious. Most UI libraries provide higher-level
    events that are simpler to think about. Swing is no exception. The `JButton` class,
    for example, supports an `ActionEvent` that lets you know the button has been
    clicked. Most of the time this is exactly what you want. But the mouse events
    are still available if you need some special behavior, such as reacting to clicks
    from different mouse buttons or distinguishing between a long and a short press
    on a touch screen.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然几乎每个Swing组件上都可以获得低级别的鼠标和键盘事件，但这可能有点乏味。大多数UI库都提供更简单思考的高级事件，Swing也不例外。例如，`JButton`类支持一个`ActionEvent`，让你知道按钮已被点击。大多数情况下，这正是你想要的。但如果需要特殊行为，比如响应来自不同鼠标按钮的点击或在触摸屏上区分长按和短按，仍然可以使用鼠标事件。
- en: 'A popular way to demonstrate the button click event is to build a simple counter,
    like the one you see in [Figure 12-29](#learnjava6-CHP-12-FIG-29). Each time you
    click the button, the program updates the label. This simple proof of concept
    shows that you can receive and respond to UI events. Let’s see the wiring required
    for this demo:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 用于演示按钮点击事件的一种流行方式是构建一个简单的计数器，就像你在[图 12-29](#learnjava6-CHP-12-FIG-29)中看到的那样。每次点击按钮时，程序会更新标签。这个简单的概念验证显示了你可以接收和响应UI事件。让我们看看这个演示所需的连接：
- en: '[PRE32]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '![ljv6 1229](assets/ljv6_1229.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 1229](assets/ljv6_1229.png)'
- en: Figure 12-29\. Using `ActionEvent` to increment a counter
  id: totrans-240
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-29\. 使用`ActionEvent`来增加一个计数器
- en: We update a simple counter variable and display the result inside the `actionPerformed()`
    method, which is where `ActionListener` objects receive their events. We used
    the direct listener implementation approach, but we could just as easily have
    created a helper class as we did with the `LabelMover` example in [“Mouse Events”](#learnjava6-CHP-12-SECT-3.1).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`actionPerformed()`方法内更新一个简单的计数器变量，并在其中显示结果，这是`ActionListener`对象接收其事件的地方。我们使用了直接的监听器实现方法，但我们也可以像在[“鼠标事件”](#learnjava6-CHP-12-SECT-3.1)中的`LabelMover`示例中所做的那样创建一个帮助类。
- en: Action events are straightforward; they don’t have as many details available
    as mouse events, but they do carry a “command” property. The command in question
    is just an arbitrary string. It doesn’t mean anything to Java, but you can customize
    this property for your own use. For buttons, Java defaults to using the text of
    the button’s label. The `JTextField` class also generates an action event if you
    press the Return key while typing in the text field. In this case, however, the
    text currently in the field is used for the command. [Figure 12-30](#learnjava6-CHP-12-FIG-30)
    shows how to hook up a button and a text field to a label.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 动作事件很直接；它们没有像鼠标事件那样多的细节可用，但它们确实携带一个“命令”属性。所涉及的命令只是一个任意字符串。对于Java而言，这并不意味着什么，但你可以根据自己的需求自定义此属性。对于按钮而言，Java默认使用按钮标签的文本。如果在`JTextField`类中按下回车键输入文本，则也会生成一个动作事件。但在这种情况下，字段中当前的文本用作命令。[图 12-30](#learnjava6-CHP-12-FIG-30)展示了如何将按钮和文本字段连接到标签上。
- en: '![ljv6 1230](assets/ljv6_1230.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 1230](assets/ljv6_1230.png)'
- en: Figure 12-30\. Using `ActionEvent`s from different sources
  id: totrans-244
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-30\. 来自不同来源的`ActionEvent`的使用
- en: '[PRE33]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Notice we used one `ActionListener` object to handle the events for *both*
    the button and the text field. This is a great feature of Swing’s listener approach
    to handling events: any component that generates a given type of event can report
    to any listener that receives that type. Sometimes your event handlers are unique
    and you’ll build a separate handler for each component. But many applications
    offer multiple ways to accomplish the same task. You can often handle those different
    input sources with a single listener. And the less code you have, the less that
    can go wrong!'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用一个`ActionListener`对象来处理*按钮和文本字段*的事件。这是Swing处理事件的监听器方法的一个很好的特性：生成给定类型事件的任何组件都可以向接收该类型事件的任何监听器报告。有时你的事件处理程序是唯一的，你会为每个组件构建一个单独的处理程序。但许多应用程序提供多种完成相同任务的方式。你通常可以用单个监听器处理这些不同的输入来源。而且你的代码越少，出错的可能性就越小！
- en: Change Events
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变更事件
- en: Another event type that appears in several Swing components is `ChangeEvent`.
    This is a simple event that lets you know something has, well, changed. The `JSlider`
    class uses this mechanism to report changes to the position of the slider. The
    `ChangeEvent` class has a reference to the component that changed (the event’s
    *source*) but no details on what might have changed within that component. It’s
    up to you to go ask the component for those details. That listen-then-query process
    might seem tedious, but it does allow for efficient notifications that updates
    are necessary, without creating hundreds of classes with thousands of methods
    to cover all the event variations that might come up.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 出现在几个Swing组件中的另一种事件类型是`ChangeEvent`。这是一个简单的事件，用于通知您某些事情已经发生了变化。`JSlider`类使用此机制报告滑块位置的更改。`ChangeEvent`类引用了发生变化的组件（事件的*源*），但没有关于可能在该组件内部发生的具体变化的详细信息。您需要询问组件以获取这些详细信息。这种监听-查询的过程可能看起来很繁琐，但它确实允许高效地通知需要更新，而无需创建成百上千的方法来覆盖可能出现的所有事件变化。
- en: 'We won’t reproduce the entire application here, but let’s take a look at how
    the `AppleToss` class uses `ChangeListener` to map the aiming slider to our physicist:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在这里复制整个应用程序，但让我们看看`AppleToss`类如何使用`ChangeListener`将瞄准滑块映射到我们的物理学家：
- en: '[PRE34]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this snippet, we use a factory pattern to create our slider and return it
    for use in the `add()` method of our `gamePane` container. We create a simple
    anonymous inner class. Changing our aiming slider has one effect, and there is
    only one way to aim the apple. Since there is no possibility of class reuse, we
    chose an anonymous inner class. There is nothing wrong with creating a complete
    helper class and passing it the `player1` and `field` elements as arguments to
    a constructor or initialization method, but you will find the approach used above
    quite often in the wild.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们使用工厂模式创建我们的滑块，并将其返回供`gamePane`容器的`add()`方法使用。我们创建了一个简单的匿名内部类。更改我们的瞄准滑块会产生一定的影响，而且只有一种方法可以瞄准苹果。由于无法重用类，我们选择了一个匿名内部类。创建一个完整的辅助类，并将`player1`和`field`元素作为参数传递给构造函数或初始化方法并没有错，但您会经常发现上述方法在实践中经常使用。
- en: We want to point out one other option for handling simple events like `ChangeEvent`
    and `ActionEvent`. The listeners for these events have a single abstract method.
    Does that phrase ring a bell? That’s how Oracle describes its functional interfaces.
    So we can use a lambda!
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想指出处理简单事件如`ChangeEvent`和`ActionEvent`的另一种选项。这些事件的监听器具有单个抽象方法。这个短语听起来熟悉吗？这是Oracle描述其函数式接口的方式。所以我们可以使用lambda！
- en: '[PRE35]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Unfortunately, many listeners handle a spectrum of related events. You can’t
    use a lambda with any listener interface that has more than one method. But lambdas
    work with buttons and menu items, so they can still play a big role in your graphical
    application if you find them appealing.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，许多侦听器处理一系列相关事件。对于具有多个方法的任何侦听器接口，都无法使用lambda。但是，如果您喜欢它们，lambda可以与按钮和菜单项一起使用，因此在您的图形应用程序中仍然可以发挥重要作用。
- en: Our `Widget` isn’t really good for trying event-related code in *jshell*. While
    you certainly can write an anonymous inner class or a multiline lambda at a command
    line, it can be tedious and prone to errors that are not easy to fix from that
    same command line. It’s usually simpler to write small, focused demo apps, like
    many of the examples in this chapter. While we encourage you to fire up the apple
    tossing game to play with the slider shown in the code above, you should also
    try your hand at a few original apps.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在*jshell*中，我们的`Widget`并不适合尝试与事件相关的代码。虽然您可以在命令行上编写匿名内部类或多行lambda表达式，但这可能很繁琐，并且很难从同一命令行修复错误。通常情况下，编写小而专注的演示应用程序会更简单，就像本章的许多示例一样。虽然我们鼓励您启动苹果投掷游戏，以玩耍并调整上述代码中显示的滑块，但您也应该尝试几个原创应用程序。
- en: Other Events
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他事件
- en: There are dozens of other events and listeners spread across the `java.awt.event`
    and `javax.swing.event` packages. It’s worth peeking at the documentation just
    to get a sense of the other types of events you might run into. [Table 12-2](#learnjava6-CHP-12-TABLE-2)
    shows the events and listeners associated with the components we’ve discussed
    so far in this chapter, as well as a few that are worth checking out as you work
    more with Swing.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在`java.awt.event`和`javax.swing.event`包中分布着数十种其他事件和监听器。浏览文档只是为了了解您可能会遇到的其他类型的事件是值得的。[表 12-2](#learnjava6-CHP-12-TABLE-2)展示了到目前为止在本章中讨论过的组件相关的事件和监听器，以及一些在更多使用Swing时值得查看的内容。
- en: Table 12-2\. Swing and AWT events and associated listeners
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 12-2\. Swing 和 AWT 事件及其关联的监听器
- en: '| S/A | Event class | Listener interface | Generating components |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| S/A | 事件类 | 监听器接口 | 生成组件 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| A | `ActionEvent` | `ActionListener` | `JButton`, `JMenuItem`, `JTextField`
    |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| A | `ActionEvent` | `ActionListener` | `JButton`, `JMenuItem`, `JTextField`
    |'
- en: '| S | `ChangeEvent` | `ChangeListener` | `JSlider` |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| S | `ChangeEvent` | `ChangeListener` | `JSlider` |'
- en: '| A | `ItemEvent` | `ItemListener` | `JCheckBox`, `JRadioButton` |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| A | `ItemEvent` | `ItemListener` | `JCheckBox`, `JRadioButton` |'
- en: '| A | `KeyEvent` | `KeyListener` | Descendants of `Component` |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| A | `KeyEvent` | `KeyListener` | 组件的后代 |'
- en: '| S | `ListSelectionEvent` | `ListSelectionListener` | `JList` |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| S | `ListSelectionEvent` | `ListSelectionListener` | `JList` |'
- en: '| A | `MouseEvent` | `MouseListener` | Descendants of `Component` |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| A | `MouseEvent` | `MouseListener` | 组件的后代 |'
- en: '| A | `MouseMotionEvent` | `MouseMotionListener` | Descendants of `Component`
    |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| A | `MouseMotionEvent` | `MouseMotionListener` | 组件的后代 |'
- en: '| AWT events (A) from `java.awt.event`, Swing events (S) from `javax.swing.event`
    |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| AWT 事件（A）来自 `java.awt.event`，Swing 事件（S）来自 `javax.swing.event` |'
- en: If you’re unsure what events a particular component supports, check its documentation
    for methods that look like `addXYZListener()`. Whatever stands in for `XYZ` is
    a clue about where else in the documentation to look. Recall that our slider uses
    `addChangeListener()`. So that `XYZ` is `Change` in this case. You can infer the
    event name (`ChangeEvent`) and the listener interface (`ChangeListener`) from
    that clue. Once you have the documentation for the listener, try implementing
    every method and simply printing which event is reported. You can learn a lot
    about how the various Swing components react to keyboard and mouse events this
    way.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不确定特定组件支持哪些事件，请查看其文档以查找类似 `addXYZListener()` 的方法。`XYZ` 代表需要查看文档其他位置的提示。回想一下，我们的滑块使用了
    `addChangeListener()`。因此，`XYZ` 在这种情况下是 `Change`。您可以推断事件名称（`ChangeEvent`）和监听器接口（`ChangeListener`）从这个提示。一旦您有了监听器的文档，请尝试实现每个方法并简单打印报告的事件。通过这种方式，您可以了解各种
    Swing 组件如何响应键盘和鼠标事件。
- en: Threading Considerations
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程注意事项
- en: If you have read any of the JDK documentation on Swing as you’ve been working
    through this chapter, you may have come across a warning that Swing components
    are not thread-safe. As you learned in [Chapter 9](ch09.html#learnjava6-CHP-9),
    Java supports multiple threads of execution to take advantage of modern computer
    processing power. Multithreaded applications run the risk of allowing two threads
    to fight over the same resource or update the same variable at the same time but
    with different values. Not knowing if your data is correct can severely decrease
    your ability to debug a program or even just trust its output. For Swing components,
    this warning reminds programmers that their UI elements could be subject to this
    type of corruption.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在阅读本章节时阅读了任何关于 Swing 的 JDK 文档，可能会注意到一个警告：Swing 组件不是线程安全的。正如您在[第 9 章](ch09.html#learnjava6-CHP-9)中学到的，Java
    支持多线程执行以利用现代计算机的处理能力。多线程应用程序可能允许两个线程竞争相同的资源或同时更新相同变量但具有不同的值。不知道数据是否正确可能会严重降低调试程序或甚至只是信任其输出的能力。对于
    Swing 组件，此警告提醒程序员其 UI 元素可能受到此类破坏的影响。
- en: To help maintain a consistent UI, Swing encourages you to update your components
    on the AWT *event dispatch thread*. This is the thread that naturally handles
    things like button clicks. If you update a component in response to an event (such
    as our counter button and label in [“Action Events”](#learnjava6-CHP-12-SECT-3.2)),
    you are all set. The idea is that if every other thread in your application sends
    UI updates to the sole event dispatch thread, no component can be adversely affected
    by simultaneous, possibly conflicting changes.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助保持一致的 UI，Swing 鼓励您在 AWT *事件分发线程* 上更新组件。这是自然处理按钮点击等事物的线程。如果您响应事件（例如我们在[“动作事件”](#learnjava6-CHP-12-SECT-3.2)中的计数按钮和标签）更新组件，那么您就已经设置好了。这个想法是，如果应用程序中的每个其他线程将
    UI 更新发送到唯一的事件分发线程，则没有组件可以受到同时可能发生冲突的更改的不利影响。
- en: A common example of threading in graphical applications is the animated spinner
    that sits on your screen while you wait for a large file to download. But what
    if you get impatient? What if it seems like the download has failed but the spinner
    is still going? If your long-running task is using the event dispatch thread,
    your user won’t be able to click a Cancel button or take any action at all. Long-running
    tasks should be handled by separate threads that can run in the background, leaving
    your application responsive and available. But then how do we update the UI when
    that background thread finishes? Swing has a helper class ready for you.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图形应用程序中线程的一个常见例子是动画旋转器，它在你等待大文件下载时显示在屏幕上。但是如果你变得不耐烦呢？如果看起来下载失败了，但旋转器仍在运行呢？如果你的长时间运行的任务使用事件分发线程，你的用户将无法点击取消按钮或采取任何行动。长时间运行的任务应由可以在后台运行的单独线程处理，使你的应用程序响应和可用。但是当后台线程完成时，我们如何更新UI呢？Swing为你准备了一个辅助类。
- en: SwingUtilities and Component Updates
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SwingUtilities 和组件更新
- en: 'You can use the `SwingUtilities` class from any thread to perform updates to
    your UI components in a safe, stable manner. There are two static methods you
    can use to communicate with your UI:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从任何线程使用`SwingUtilities`类以安全、稳定的方式更新你的UI组件。有两个静态方法可用于与你的UI通信：
- en: '`invokeAndWait()`'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`invokeAndWait()`'
- en: '`invokeLater()`'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`invokeLater()`'
- en: As their names imply, the first method runs some UI update code and makes the
    current thread wait for that update to finish before continuing. The second method
    hands off some UI update code to the event dispatch thread and then immediately
    resumes executing on the current thread. (The event dispatch thread is sometimes
    called the *event dispatch queue*. You can append events or updates and the event
    dispatch thread will get to them in roughly the order they were added, like in
    a queue.) Which one you use really depends on whether your background thread needs
    to know the state of the UI before continuing. For example, if you are adding
    a new button to your interface, you might want to use `invokeAndWait()` so that
    by the time your background thread continues, it can be sure that future updates
    will actually have a button to update.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 如它们的名称所示，第一个方法运行一些UI更新代码，并使当前线程在继续之前等待该更新完成。第二个方法将一些UI更新代码交给事件分发线程，然后立即在当前线程上继续执行。（事件分发线程有时称为*事件分发队列*。你可以附加事件或更新，事件分发线程将按照它们被添加的顺序大致处理它们，就像在队列中一样。）你使用哪一个方法取决于你的后台线程是否需要在继续之前知道UI的状态。例如，如果你要向接口添加一个新按钮，你可能希望使用`invokeAndWait()`，这样在后台线程继续执行之前，它可以确保未来的更新实际上有一个按钮来更新。
- en: If you aren’t as concerned about when something gets updated, but still want
    it to be handled safely by the dispatch thread, `invokeLater()` is perfect. Think
    about updating a progress bar as a large file is downloading. Your code might
    fire off several updates as more and more of the download completes. You don’t
    need to wait for those graphical updates to finish before resuming your download.
    If a progress update gets delayed or runs very close to a second update, there’s
    no real harm. But you don’t want a busy graphical interface to interrupt your
    download—especially if the server is sensitive to pauses.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太关心何时更新某些内容，但仍希望它被事件分发线程安全处理，`invokeLater()` 是完美的选择。想象一下在下载大文件时更新进度条。你的代码可能会在下载完成的过程中触发多次更新。在恢复下载之前，你不需要等待这些图形更新完成。如果进度更新被延迟或非常接近第二次更新，没有真正的危害。但你不希望忙碌的图形界面打断你的下载，特别是如果服务器对暂停敏感的情况下。
- en: 'We’ll see several examples of this type of network/UI interaction in [Chapter 13](ch13.html#learnjava6-CHP-13),
    but let’s fake some network traffic and update a small label to show off `SwingUtilities`.
    We can set up a Start button that will update a status label with a simple percentage
    display and kick off a background thread that sleeps for one second, then increments
    the progress. Each time the thread wakes up, it will update the label using `invokeLater()`
    to correctly set the label’s text. First, let’s set up our demo:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第13章](ch13.html#learnjava6-CHP-13)看到几个此类网络/UI交互的示例，但让我们假装一些网络流量并更新一个小标签来展示`SwingUtilities`。我们可以设置一个开始按钮，它将用一个简单的百分比显示更新一个状态标签，并启动一个后台线程，该线程每秒休眠一次，然后增加进度。每次线程唤醒时，它将使用`invokeLater()`正确设置标签的文本。首先，让我们设置我们的演示：
- en: '[PRE36]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Most of this should look familiar, but look at how we create our thread. We
    pass a `new ProgressPretender()` as the argument to our `Thread` constructor.
    We could have broken that call into separate parts, but since we do not refer
    directly to our `ProgressPretender` object again, we can stick with this tidier,
    denser approach. We *do* refer to the thread itself, however, so we make a proper
    variable for it. We can then start our thread running in the `ActionListener`
    for our button. We also disable our Start button at that point. We don’t want
    the user trying to (re)start a thread that is already running!
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分内容应该看起来很熟悉，但请看我们如何创建我们的线程。我们将 `new ProgressPretender()` 作为参数传递给我们的 `Thread`
    构造函数。我们本可以将该调用分解为单独的部分，但由于我们不再直接引用我们的 `ProgressPretender` 对象，我们可以坚持使用这种更整洁、更密集的方法。然而，我们确实引用了线程本身，因此我们为它创建了一个适当的变量。然后，我们可以在按钮的
    `ActionListener` 中启动我们的线程运行。此时，我们还禁用了我们的“开始”按钮。我们不希望用户尝试（重新）启动已经运行的线程！
- en: We added a text field for you to type in. While the progress is being updated,
    your application should continue responding to user input like typing. Try it!
    The text field isn’t connected to anything, but you should be able to enter and
    delete text while watching the progress counter slowly climb up, as shown in [Figure 12-31](#learnjava6-CHP-12-FIG-35).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为您添加了一个文本字段供您输入。在更新进度的同时，您的应用程序应继续响应用户输入，如键入。试试看！虽然文本字段与任何内容都没有连接，但您应该能够在观看进度计数器缓慢上升的同时输入和删除文本，如
    [图 12-31](#learnjava6-CHP-12-FIG-35) 所示。
- en: '![ljv6 1231](assets/ljv6_1231.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 1231](assets/ljv6_1231.png)'
- en: Figure 12-31\. Thread-safe updates to a progress label
  id: totrans-285
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-31\. 线程安全更新进度标签
- en: 'So how did we update that label without locking up the application? Let’s look
    at the `ProgressPretender` class and inspect the `run()` method:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们是如何在不锁定应用程序的情况下更新标签的呢？让我们看看 `ProgressPretender` 类并检查 `run()` 方法：
- en: '[PRE37]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In this class, we store the label passed to our constructor so we know where
    to display our updated progress. The `run()` method has three basic steps: 1)
    update the label, 2) sleep for 1,000 milliseconds, and 3) increment our progress.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，我们存储了传递给构造函数的标签，这样我们就知道在哪里显示我们更新后的进度。`run()` 方法有三个基本步骤：1）更新标签，2）睡眠 1,000
    毫秒，3）增加我们的进度。
- en: In step 1, the lambda argument we pass to `invokeLater()` is based on the `Runnable`
    interface in [Chapter 9](ch09.html#learnjava6-CHP-9). We could have used an inner
    class or an anonymous inner class, but for such a simple task, a lambda is perfect.
    The lambda body updates the label with our current progress value. The event dispatch
    thread will execute the lambda. This is the magic that leaves the text field responsive
    even though our “progress” thread is sleeping most of the time.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 1 步中，我们传递给 `invokeLater()` 的 lambda 参数是基于 [第 9 章](ch09.html#learnjava6-CHP-9)
    中的 `Runnable` 接口。我们可以使用内部类或匿名内部类，但对于这样一个简单的任务，lambda 是完美的选择。lambda 主体更新标签与当前进度值。事件分派线程将执行
    lambda。这就是使文本字段保持响应性的神奇之处，尽管我们的“进度”线程大部分时间都在睡眠。
- en: Step 2 is standard-issue thread sleeping. The `sleep()` method knows it can
    be interrupted, so the compiler will make sure you supply a `try/catch` block
    like we’ve done above. There are many ways to handle the interruption, but in
    this case we chose to simply `break` out of the loop.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 第 2 步是标准的线程睡眠。`sleep()` 方法知道它可以被中断，所以编译器会确保你像我们上面做的那样提供一个 `try/catch` 块。处理中断的方法有很多种，但在这种情况下，我们选择简单地`break`出循环。
- en: Finally, we increment our progress counter and start the whole process over.
    Once we hit 100, the loop ends and our progress label should stop changing. If
    you wait patiently, you’ll see that final value. The app itself should remain
    active, though. You can still type in the text field. Our download is complete
    and all is well with the world!
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们增加我们的进度计数器并重新启动整个过程。一旦达到 100，循环就结束了，我们的进度标签应该停止变化。如果您耐心等待，您将看到最终值。应用程序本身应该保持活动状态。您仍然可以在文本字段中输入内容。我们的下载完成了，世界万事大吉！
- en: Timers
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定时器
- en: The Swing library includes a timer that is designed to work in the UI space.
    The `javax.swing.Timer` class is fairly straightforward. It waits a specified
    period of time and then fires off an action event (the same type of event as clicking
    a button). It can fire that action once or repeatedly. You’ll find many reasons
    to use timers with graphical applications. Besides providing an alternative way
    to drive an animation loop, you might want to automatically cancel some action,
    like loading a network resource if it is taking too long. Conversely, you might
    put up a little “please wait” spinner or dialog to let the user know the operation
    is ongoing. You might want to take down a dialog prompt if the user doesn’t respond
    within a specified time span. Swing’s `Timer` can handle all of these scenarios.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: Swing库包括一个设计用于UI空间的计时器。`javax.swing.Timer`类非常直观。它等待指定的时间段，然后触发一个动作事件（与点击按钮相同类型的事件）。它可以一次性或重复性地触发该动作。您将发现许多理由在图形应用程序中使用计时器。除了提供另一种驱动动画循环的方式外，您可能希望自动取消某些操作，例如加载网络资源如果时间太长。反之，您可能希望显示一个小的“请稍候”旋转器或对话框，让用户知道操作正在进行中。您可能希望在用户在指定时间内没有响应时关闭对话框提示。Swing的`Timer`可以处理所有这些场景。
- en: Animation with Timer
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用计时器进行动画
- en: 'Let’s modify our flying apples from [“Revisiting Animation with Threads”](ch09.html#learnjava6-CHP-9-SECT-1.3)
    and try implementing the animation with an instance of `Timer`. The `Timer` class
    takes care of that detail for us. We can still use our `step()` method in the
    `Apple` class from our first pass at animation. We just need to alter the start
    method and keep a suitable variable around for the timer:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改来自[“使用线程重新访问动画”](ch09.html#learnjava6-CHP-9-SECT-1.3)的飞行苹果，并尝试使用`Timer`实现动画。`Timer`类会为我们处理这些细节。我们仍然可以使用我们第一次尝试动画时`Apple`类中的`step()`方法。我们只需修改启动方法，并保持一个适当的变量用于计时器：
- en: '[PRE38]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: There are two nice things about this approach. It’s definitely easier to read
    because we are not responsible for the pauses between actions. We create the `Timer`
    by passing to the constructor the time interval between events and an `ActionListener`
    to receive the events—our `Field` class in this case. We give the timer a simple
    but unique action command, make it a repeating timer, and start it up!
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有两个好处。它确实更易读，因为我们不需要负责动作之间的暂停。我们通过将事件之间的时间间隔和接收事件的`ActionListener`（在这种情况下是我们的`Field`类）传递给构造函数来创建`Timer`。我们为计时器提供一个简单但唯一的动作命令，使其成为重复计时器，并启动它！
- en: 'The other nice thing is specific to Swing and graphical applications: `javax.swing.Timer`
    fires its action events *on the event dispatch thread*. You do not need to wrap
    any of your response in `invokeAndWait()` or `invokeLater()`. Just put your timer-based
    code in the `actionPerformed()` method of an attached listener and you are good
    to go!'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个好处特定于Swing和图形应用程序：`javax.swing.Timer`在*事件调度线程*上触发其动作事件。您无需将任何响应包装在`invokeAndWait()`或`invokeLater()`中。只需将基于计时器的代码放在附加监听器的`actionPerformed()`方法中，一切都搞定！
- en: Because several components generate `ActionEvent` objects, we did take a little
    precaution against collisions by setting the `actionCommand` attribute for our
    timer. This step is not strictly necessary in our case, but it leaves room for
    the `Field` class to handle other events down the road without breaking our animation.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 因为有几个组件会生成`ActionEvent`对象，所以我们通过为我们的计时器设置`actionCommand`属性来预防碰撞。在我们的情况下，这一步并非必须，但这样做可以让`Field`类在不破坏我们的动画的情况下处理其他事件。
- en: Other Timer uses
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他计时器用途
- en: 'Mature, polished applications have a variety of small moments where it helps
    to have a one-time timer. Our apple game is simple by comparison to most commercial
    apps or games, but even here we can add a little “realism” with a timer: after
    tossing an apple, we can pause before allowing the physicist to fire another apple.
    Maybe the physicist has to bend down and grab another apple from a bucket before
    aiming or tossing. This kind of delay is another perfect spot for a `Timer`.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 成熟、精练的应用程序在许多小细节上都会受益于一次性计时器。与大多数商业应用或游戏相比，我们的苹果游戏显得比较简单，但即使在这里，我们也可以通过计时器增加一些“真实感”：在扔苹果后，我们可以暂停一下，然后让物理学家再扔一个苹果。也许物理学家需要弯下腰从桶里拿另一个苹果再瞄准或扔。这种延迟正是另一个`Timer`的完美应用场景。
- en: 'We can add this pause to the bit of code in the `Field` class where we toss
    the apple:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`Field`类中扔苹果的代码中加入这个暂停：
- en: '[PRE39]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Notice this time that we set the timer to run only once with the `setRepeats(false)`
    call. This means that after a little less than a second, a single event will be
    fired off to our physicist. The `Physicist` class, in turn, needs to add the `implements
    Action` `Listener` portion to the class definition and include an appropriate
    `actionPerformed()` function, like so:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这次我们通过调用 `setRepeats(false)` 将定时器设置为仅运行一次。这意味着不到一秒钟后，将向我们的物理学家发送一个事件。物理学家类反过来需要在类定义中添加
    `implements Action` `Listener` 部分，并包括适当的 `actionPerformed()` 函数，如下所示：
- en: '[PRE40]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Using `Timer` isn’t the only way to accomplish such tasks, but in Swing, the
    combination of efficient timed events and automatic use of the event dispatch
    thread make it worth considering. If nothing else, it makes prototyping easy.
    You can always come back and refactor your application to use custom threading
    code, if needed.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swing 中，使用 `Timer` 并不是完成此类任务的唯一方式，但是高效定时事件的结合和自动使用事件分发线程使其值得考虑。至少，它使原型设计变得容易。如果需要，您随时可以返回并重构应用程序以使用自定义线程代码。
- en: But Wait, There’s More
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 但等等，还有更多
- en: As we noted at the beginning of the chapter, there are many, many more discussions
    and topics and explorations available in the world of Java graphical applications.
    Java has an entire package devoted to storing [user preferences](https://oreil.ly/Vrbfz),
    for example. And O’Reilly has an entire book by Jonathan Knudsen devoted to [*Java
    2D Graphics*](https://oreil.ly/4xYdN). We’ll leave it to you to do that exploring
    but wanted to go through at least a few key topics worth focusing on first if
    you have plans for a desktop app.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章开头提到的那样，Java 图形应用程序的世界中有更多更多的讨论、主题和探索可供参考。例如，Java 有一个专门用于存储[用户偏好设置](https://oreil.ly/Vrbfz)的整个包。而且，O’Reilly
    出版了一本由 Jonathan Knudsen 撰写的[*Java 2D 图形*](https://oreil.ly/4xYdN)的整本书。我们将让你自行探索，但是如果你计划开发桌面应用程序，我们想首先讨论一些值得关注的关键主题。
- en: Menus
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 菜单
- en: 'While not technically required, most desktop applications have an application-wide
    menu of common tasks, such as saving changed files or setting preferences. Apps
    with specific features, like spreadsheets, might have menus for sorting the data
    in a column or selection. The `JMenu`, `JMenuBar`, and `JMenuItem` classes help
    you add this functionality to your Swing apps. Menus go inside a menu bar, and
    menu items go inside menus. Swing has three prebuilt menu item classes: `JMenuItem`
    for basic menu entries, `JCheckBoxMenuItem` for option items, and `JRadioButtonMenuItem`
    for grouped menu items like the currently selected font or color theme. The `JMenu`
    class is itself a valid menu item so you can build nested menus. `JMenuItem` behaves
    like a button (as do its radio and checkbox compatriots), and you can catch menu
    events using the same listeners.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在技术上不是必需的，但大多数桌面应用程序都有一个应用程序范围的菜单，用于常见任务，例如保存更改后的文件或设置首选项。具有特定功能的应用程序（例如电子表格）可能具有用于对列或选择数据进行排序的菜单。`JMenu`、`JMenuBar`
    和 `JMenuItem` 类帮助您向 Swing 应用程序添加此功能。菜单位于菜单栏内部，菜单项位于菜单内部。Swing 有三个预构建的菜单项类：`JMenuItem`
    用于基本菜单条目，`JCheckBoxMenuItem` 用于选项条目，`JRadioButtonMenuItem` 用于像当前选定的字体或颜色主题之类的分组菜单项。`JMenu`
    类本身是一个有效的菜单项，因此您可以构建嵌套菜单。`JMenuItem` 的行为类似按钮（其单选框和复选框伙伴也是如此），您可以使用相同的侦听器捕获菜单事件。
- en: '[Figure 12-32](#learnjava6-CHP-12-FIG-36) shows an example of a simple menu
    bar populated with some menus and items.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 12-32](#learnjava6-CHP-12-FIG-36) 显示了一个简单菜单栏的示例，其中包含一些菜单和菜单项。'
- en: '![ljv6 1232](assets/ljv6_1232.png)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 1232](assets/ljv6_1232.png)'
- en: Figure 12-32\. `JMenu` and `JMenuItem` on macOS and Linux
  id: totrans-313
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-32\. `JMenu` 和 `JMenuItem` 在 macOS 和 Linux 上
- en: 'Here’s the source code for this demonstration:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是此演示的源代码：
- en: '[PRE41]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We obviously don’t do much with the menu item actions here, but they illustrate
    how you can start building out the expected parts of a professional application.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在这里我们没有涉及菜单项动作，但它们说明了您如何开始构建专业应用程序的预期部分。
- en: Modals and Pop-Ups
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弹出窗口和弹出式窗口
- en: Events let the user get your attention, or at least the attention of some method
    in your application. But what if you need to get the user’s attention? A popular
    UI mechanism for this task is the pop-up window. You’ll often hear such a window
    referred to as a *modal* or *dialog* or even *modal dialog*. The term *dialog*
    comes from the fact that these pop-ups present some information to the user and
    expect—or require—a response. Perhaps this quick question and answer process is
    not as lofty as a Socratic symposium, but still. The *modal* name refers to the
    fact that some of those dialogs that require a response will actually disable
    the rest of the application—putting it in a restricted mode—until you provide
    that response. You may have experienced such a dialog yourself in other desktop
    applications. If your software requires you to stay up-to-date with the latest
    release, for example, it might “gray out” the application, indicating you can’t
    use it, and then show you a modal dialog with a button that initiates the update
    process.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 事件让用户吸引到你的注意，或者至少是你应用程序中的某个方法的注意。但如果你需要引起用户的注意呢？这项任务的流行UI机制是弹出窗口。你经常会听到这样的窗口被称为*模态*或*对话框*甚至*模态对话框*。术语*对话框*来自于这样一个事实，即这些弹出窗口向用户展示一些信息，并期望或者要求用户做出回应。也许这种快速问答过程并不像苏格拉底的座谈会那样高深，但仍然。*模态*的名称指的是一些需要回应的对话框实际上会禁用应用程序的其余部分——将其置于受限模式中——直到你提供回应为止。也许你在其他桌面应用程序中已经体验过这样的对话框。例如，如果你的软件要求你保持最新版本，它可能会“灰掉”应用程序，表示你无法使用它，然后显示一个模态对话框，其中包含一个按钮以启动更新过程。
- en: The term *pop-up* is more general. While you can certainly have modal pop-ups,
    you can also have plain (“modeless”) pop-ups that do not block you from using
    the rest of the application. Think of a search dialog in a word-processing application
    that you can leave available and just scoot off to the side of your main window.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*弹出*更加通用。尽管你当然可以有模态弹出，但你也可以有不阻止你使用应用程序其他部分的普通（“非模态”）弹出。想象一下在文字处理应用程序中的搜索对话框，你可以将其保持可用，并且只需将其移至主窗口的一侧。
- en: Swing provides a bare `JDialog` class that you can use to create custom dialog
    windows. For typical pop-up interactions with your users, including alerts, confirmations,
    and input dialogs, the `JOptionPane` class has some really handy shortcuts. For
    simple alerts and error messages, you can use the `showMessageDialog()` call.
    This type of dialog includes a customizable title, some text, and a button to
    acknowledge (and dismiss) the pop-up. If you need the user to make a yes-or-no
    choice, `showConfirmDialog()` is perfect. And if you need short, text-based answers
    from the user, you’ll want to use `showInputDialog()`. [Figure 12-33](#learnjava6-CHP-12-FIG-modals)
    shows an example of these three dialogs.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: Swing提供了一个基本的`JDialog`类，你可以用它来创建自定义对话框窗口。对于与用户的典型弹出交互，包括警报、确认和输入对话框，`JOptionPane`类具有一些非常方便的快捷方式。对于简单的警报和错误消息，可以使用`showMessageDialog()`调用。这种类型的对话框包括可定制的标题、一些文本和一个确认（和关闭）弹出的按钮。如果你需要用户做出是或否选择，`showConfirmDialog()`非常适合。如果你需要从用户那里得到简短的基于文本的答案，你将想要使用`showInputDialog()`。[图 12-33](#learnjava6-CHP-12-FIG-modals)展示了这三个对话框的示例。
- en: '![ljv6 1233](assets/ljv6_1233.png)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 1233](assets/ljv6_1233.png)'
- en: Figure 12-33\. The main variations of JOptionPane pop-up windows
  id: totrans-322
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-33\. JOptionPane弹出窗口的主要变体
- en: 'To create a message dialog, you have to supply four arguments. The first argument
    refers to the frame or window “owning” the pop-up. `JOptionPane` will attempt
    to center the dialog over its owner when shown. You can also specify `null` for
    this argument, which tells `JOptionPane` there is no primary window, so center
    the pop-up on the user’s screen. The second and third arguments are `String`s
    for the dialog’s message and title, respectively. The final argument indicates
    the “type” of pop-up, which mostly affects the icon you see. You can specify several
    types:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个消息对话框，你必须提供四个参数。第一个参数是指“拥有”弹出窗口的框架或窗口。当显示时，`JOptionPane`会尝试将对话框居中于其拥有者上。你也可以为此参数指定`null`，这告诉`JOptionPane`没有主要窗口，因此在用户屏幕上居中弹出。第二个和第三个参数是对话框消息和标题的`String`。最后一个参数指示弹出窗口的“类型”，这主要影响你看到的图标。你可以指定几种类型：
- en: '`ERROR_MESSAGE`, red Stop icon'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ERROR_MESSAGE`，红色停止图标'
- en: '`INFORMATION_MESSAGE`, Duke^([6](ch12.html#id2462)) icon'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INFORMATION_MESSAGE`，杜克^([6](ch12.html#id2462)) 图标'
- en: '`WARNING_MESSAGE`, yellow triangle icon'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WARNING_MESSAGE`，黄色三角形图标'
- en: '`QUESTION_MESSAGE`, Duke icon'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QUESTION_MESSAGE`，杜克图标'
- en: '`PLAIN_MESSAGE`, no icon'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PLAIN_MESSAGE`，无图标'
- en: 'Head back to your *jshell* and try creating a message pop-up. You can use the
    handy `null` option for the owner:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 返回*jshell*，尝试创建一个消息弹出窗口。您可以使用方便的`null`选项作为所有者：
- en: '[PRE42]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Another common task for pop-ups is verifying the user’s intent. Many applications
    ask if you’re sure you want to quit or delete something. `JOptionPane` has you
    covered. You can try out this confirmation dialog in *jshell*:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 弹出窗口的另一个常见任务是验证用户的意图。许多应用程序会询问您是否确定要退出或删除某些内容。`JOptionPane`已经为您考虑到了这一点。您可以在*jshell*中尝试这个确认对话框：
- en: '[PRE43]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The two-argument version of the `showConfirmDialog()` method produces a pop-up
    with Yes, No, and Cancel buttons. You can determine which answer the user selected
    by keeping the return value (an `int`). We clicked the Yes button, which returns
    `0`, but you don’t have to memorize the return values. `JOptionPane` has constants
    covering the various responses:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`showConfirmDialog()`方法的两个参数版本会生成一个带有“是”、“否”和“取消”按钮的弹出窗口。您可以通过保留返回值（一个`int`）来确定用户选择的答案。我们点击了“是”按钮，它返回`0`，但您不必记住返回值。`JOptionPane`提供了涵盖各种响应的常量：'
- en: '`YES_OPTION`'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`YES_OPTION`'
- en: '`NO_OPTION`'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NO_OPTION`'
- en: '`CANCEL_OPTION`'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CANCEL_OPTION`'
- en: '`OK_OPTION`'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OK_OPTION`'
- en: '`CLOSED_OPTION`'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CLOSED_OPTION`'
- en: '`JOptionPane` returns the `CLOSED_OPTION` value if the user closes the dialog
    using the window controls rather than clicking on any of the available buttons
    within the dialog. You also have a modicum of control over those buttons. You
    can use a four-argument version that takes a title and a button choice with one
    of the following values:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户使用窗口控件关闭对话框而不是单击对话框中的任何可用按钮，则`JOptionPane`返回`CLOSED_OPTION`值。此外，您对这些按钮有一些控制权。您可以使用带有标题和按钮选择之一的四个参数版本：
- en: '`YES_NO_OPTION`'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`YES_NO_OPTION`'
- en: '`OK_CANCEL_OPTION`'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OK_CANCEL_OPTION`'
- en: '`YES_NO_CANCEL_OPTION`'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`YES_NO_CANCEL_OPTION`'
- en: 'In most situations, having both a “No” and a “Cancel” in the same dialog confuses
    users. We recommend using one of the first two options. (The user can always close
    the dialog using the standard window controls if they do not want to make a selection.)
    Let’s try creating a Yes/No dialog:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，同一个对话框中同时包含“否”和“取消”选项会让用户感到困惑。我们建议使用前两个选项中的一个。如果用户不想做出选择，他们可以使用标准窗口控件关闭对话框。让我们尝试创建一个Yes/No对话框：
- en: '[PRE44]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Some pop-ups ask for a quick bit of input. You can use the `showInputDialog()`
    method to ask a question and allow the user to type in an answer. That answer
    (a `String`) can be stored the same way you keep the confirmation choice. Let’s
    try one more pop-up in *jshell*:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 一些弹出窗口要求快速输入。您可以使用`showInputDialog()`方法提问并允许用户输入答案。这个答案（一个`String`）可以像保存确认选项一样保存。让我们在*jshell*中再试一个弹出窗口：
- en: '[PRE45]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Input dialogs are handy for one-off requests, but we don’t recommend them if
    you have a series of questions to ask the user. You should keep modals confined
    to quick, infrequent tasks. They interrupt the user—by design. Sometimes that
    interruption is exactly what you need. If you abuse the user’s attention, however,
    you’re likely to annoy the user, and they’ll learn to simply ignore every pop-up
    from your application.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 对话框适用于一次性请求，但如果您需要向用户询问一系列问题，则不建议使用它们。您应该将模态对话框限制在快速且不频繁的任务中。它们通过设计中断用户。有时候这种中断正是您所需要的。然而，如果您滥用用户的注意力，很可能会惹恼用户，他们会学会简单地忽略您应用程序的每一个弹出窗口。
- en: The file *ch12/examples/ModalDemo.java* contains a small application that can
    create a variety of modal dialogs. Feel free to play around with it and try out
    the different message types or confirmation button options. And don’t be afraid
    of modifying these example applications! Sometimes tweaking a simple app and recompiling
    is easier than trying to type multiline examples into *jshell*.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 文件*ch12/examples/ModalDemo.java*包含一个可以创建各种模态对话框的小应用程序。随意玩弄它，并尝试不同的消息类型或确认按钮选项。并且不要害怕修改这些示例应用程序！有时修改简单的应用程序并重新编译比尝试在*jshell*中输入多行示例更容易。
- en: User Interface and User Experience
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户界面和用户体验
- en: This was a whirlwind tour of some of the more common UI elements for desktop
    applications, such as `JButton`, `JLabel`, and `JTextField`. We discussed how
    to arrange those components using layout managers in containers and introduced
    several other components.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对桌面应用程序中一些更常见的UI元素（如`JButton`、`JLabel`和`JTextField`）的快速介绍。我们讨论了如何使用布局管理器在容器中排列这些组件，并介绍了几个其他组件。
- en: Of course, desktop applications are only part of the story. [Chapter 13](ch13.html#learnjava6-CHP-13)
    covers networking basics, including getting content from the web and simple client/server
    applications.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，桌面应用程序只是一个方面。[第13章](ch13.html#learnjava6-CHP-13)介绍了网络基础知识，包括从网络获取内容和简单的客户端/服务器应用程序。
- en: Review Questions
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复习问题
- en: Which component would you use to display some text to the user?
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您会使用哪个组件向用户显示一些文本？
- en: Which component(s) would you use to allow the user to enter text?
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您会使用哪个组件（或组件）允许用户输入文本？
- en: What event does clicking a button generate?
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击按钮会生成什么事件？
- en: Which listener should you attach to `JList` if you want to know when the user
    changes the selected item?
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您想知道用户何时更改所选项，应该附加哪个侦听器到`JList`？
- en: What is the default layout manager for `JPanel`?
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`JPanel`的默认布局管理器是什么？'
- en: Which thread is responsible for processing events in Java?
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java中负责处理事件的线程是哪一个？
- en: What method would you use to update a component like `JLabel` after a background
    task completes?
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在后台任务完成后，您将使用什么方法来更新像`JLabel`这样的组件？
- en: What container holds `JMenuItem` objects?
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么容器包含`JMenuItem`对象？
- en: Code Exercises
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码练习
- en: Create a calculator interface with buttons and a text display. You can use the
    starter `Calculator` class in the *ch12/exercises* folder. It extends `JFrame`
    and implements the `ActionListener` interface. The display element should go at
    the top of the calculator and show right-justified text. The buttons should include
    the digits 0-9, a decimal point, addition, subtraction, multiplication, division,
    and an “equals” for showing the results. You can see what it should look like
    in [Figure 12-34](#learnjava6-CHP-12-FIG-calc-ui).
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有按钮和文本显示的计算器界面。您可以使用*ch12/exercises*文件夹中的起始`Calculator`类。它扩展了`JFrame`并实现了`ActionListener`接口。显示元素应位于计算器的顶部，并显示右对齐文本。按钮应包括数字0-9，小数点，加法，减法，乘法，除法以及用于显示结果的“等于”按钮。您可以在[图12-34](#learnjava6-CHP-12-FIG-calc-ui)中看到它的样子。
- en: '![ljv6 1234](assets/ljv6_1234.png)'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![ljv6 1234](assets/ljv6_1234.png)'
- en: Figure 12-34\. An example calculator interface
  id: totrans-364
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图12-34\. 一个示例计算器界面
- en: Don’t worry about hooking up the buttons to make the calculator work—yet. We’ll
    tackle that in the advanced exercise.
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 暂时不要担心连接按钮使计算器工作——暂时。我们将在高级练习中解决这个问题。
- en: The apple tossing game in the *ch12/exercises/game* folder has sliders and buttons
    to aim and toss apples. Right now those apples simply fly in an arc and eventually
    go outside the bounds of our window. Add the necessary code to catch collisions
    between an apple and an obstacle, like a tree or a hedge. Your solution should
    remove both the apple and the obstacle and then refresh the screen.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*ch12/exercises/game* 文件夹中的苹果投掷游戏具有滑块和按钮，用于瞄准和投掷苹果。目前这些苹果只是以弧线飞行，最终超出窗口的边界。添加必要的代码来捕捉苹果与障碍物（如树或篱笆）之间的碰撞。您的解决方案应该移除苹果和障碍物，然后刷新屏幕。'
- en: Advanced Exercises
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级练习
- en: Take the visual shell you created for a calculator in the first code exercise
    and connect the buttons to make it functional. Clicking number buttons should
    put the corresponding digit in the display. Clicking an operation button (like
    addition or division) should store the operation to perform and allow the user
    to enter a second number. Clicking the “=” button should show the results of the
    operation.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您在第一个代码练习中为计算器创建的视觉外壳连接起来，使其功能化。点击数字按钮应将相应的数字显示在显示器上。点击操作按钮（如加法或除法）应存储要执行的操作，并允许用户输入第二个数字。点击“=”按钮应显示操作的结果。
- en: This exercise pulls together several discussions from past chapters. Make incremental
    changes and don’t be afraid to look in [“Advanced Exercises”](app02.html#learnjava6-APP-B-SECT-12.2)
    for hints on how to proceed.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 此练习整合了前几章的几次讨论。进行渐进式更改，不要害怕查看[“高级练习”](app02.html#learnjava6-APP-B-SECT-12.2)以获取进一步操作的提示。
- en: ^([1](ch12.html#id2307-marker)) If you are curious about this topic and want
    to see behind the curtains of a commercial, desktop Java application, JetBrains
    publishes the [source code](https://oreil.ly/YleE5) for the Community Edition.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch12.html#id2307-marker)) 如果您对这个主题感兴趣，并希望了解商业桌面Java应用程序的幕后情况，JetBrains发布了[社区版](https://oreil.ly/YleE5)的源代码。
- en: ^([2](ch12.html#id2309-marker)) The `javax` package prefix was introduced early
    by Sun to accommodate packages that were distributed with Java but were not “core.”
    The decision was modestly controversial, but `javax` has stuck and has been used
    with other packages as well.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch12.html#id2309-marker)) `javax`包前缀早期由Sun引入，以适应Java中分发但不属于“核心”的包。这一决定引起了一定的争议，但`javax`已经成为惯例，并且还与其他包一起使用。
- en: ^([3](ch12.html#id2325-marker)) You’ll need to start *jshell* from the top-level
    directory containing the compiled examples for the book. If you are using IntelliJ
    IDEA, you can start its terminal and switch directories using **`cd out/production/LearningJava6e`**,
    and then start *jshell*.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch12.html#id2325-marker)) 你需要从包含编译示例的顶级目录开始启动*jshell*。如果你使用的是IntelliJ
    IDEA，可以启动它的终端并使用**`cd out/production/LearningJava6e`**切换目录，然后启动*jshell*。
- en: ^([4](ch12.html#id2349-marker)) As we create Swing components for use in these
    *jshell* examples, we’ll be omitting much of the resulting output for the sake
    of space. *jshell* prints a lot of information about each component, although
    it also uses ellipses when things get too extreme. Don’t be alarmed if you see
    extra details about an element’s attributes while you’re experimenting.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch12.html#id2349-marker)) 在这些*jshell*示例中，我们创建Swing组件时，为了节省空间，我们将省略大部分输出。*jshell*会打印有关每个组件的大量信息，但在情况过于极端时也会使用省略号。在你进行实验时，如果看到有关元素属性的额外细节，不必惊慌。
- en: ^([5](ch12.html#id2356-marker)) We should also note that there are many open
    source projects with even fancier components for handling things like syntax highlighting
    in text, various selection helpers, graphs and charts, and composite inputs like
    date or time pickers.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch12.html#id2356-marker)) 我们还应该注意，有许多开源项目具有更复杂的组件，用于处理文本中的语法高亮显示，各种选择辅助工具，图表，复合输入（如日期或时间选择器）等功能。
- en: ^([6](ch12.html#id2462-marker)) “Duke” is the official Java mascot. You can
    find out more at [the OpenJDK wiki](https://oreil.ly/jahxA).
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch12.html#id2462-marker)) “杜克”是官方的Java吉祥物。你可以在[OpenJDK wiki](https://oreil.ly/jahxA)上了解更多信息。
