- en: 'Chapter 8\. Serious Polymorphism: Interfaces and Abstract Classes'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章\. 严肃的多态性：接口和抽象类
- en: '![image](Images/f0199-01.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0199-01.png)'
- en: '**Inheritance is just the beginning.** To exploit polymorphism, we need interfaces
    (and not the GUI kind). We need to go beyond simple inheritance to a level of
    flexibility and extensibility you can get only by designing and coding to interface
    specifications. Some of the coolest parts of Java wouldn’t even be possible without
    interfaces, so even if you don’t design with them yourself, you still have to
    use them. But you’ll *want* to design with them. You’ll *need* to design with
    them. ***You’ll*** wonder how you ever lived without them. What’s an interface?
    It’s a 100% abstract class. What’s an abstract class? It’s a class that can’t
    be instantiated. What’s that good for? You’ll see in just a few moments. But if
    you think about the end of the previous chapter, and how we used polymorphic arguments
    so that a single Vet method could take Animal subclasses of all types, well, that
    was just scratching the surface. Interfaces are the ***poly*** in polymorphism.
    The ***ab*** in abstract. The ***caffeine*** in Java.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**继承仅仅是开始。** 要利用多态性，我们需要接口（而不是GUI类型）。我们需要超越简单的继承，达到只有通过设计和编码接口规范才能达到的灵活性和可扩展性的水平。Java的一些最酷的部分甚至没有接口是不可能实现的，所以即使你自己不设计它们，你仍然必须使用它们。但你会
    *想要* 设计它们。你会 *需要* 设计它们。***你***会想知道你以前怎么活过的。什么是接口？它是一个100%抽象的类。什么是抽象类？它是一个不能被实例化的类。这对你有什么好处？你马上就会看到。但是如果你想一想上一章的结尾，以及我们如何使用多态参数，使得单个Vet方法可以接受所有类型的Animal子类，那只是揭开表面。接口是多态性中的***poly***。抽象类中的***ab***。Java中的***咖啡因***。'
- en: Did we forget about something when we designed this?
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们在设计这个时有没有遗漏什么？
- en: '![image](Images/f0200-01.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0200-01.png)'
- en: The class structure isn’t too bad. We’ve designed it so that duplicate code
    is kept to a minimum, and we’ve overridden the methods that we think should have
    subclass-specific implementations. We’ve made it nice and flexible from a polymorphic
    perspective, because we can design Animal-using programs with Animal arguments
    (and array declarations) so that any Animal subtype—***including those we never
    imagined at the time we wrote our code***—can be passed in and used at runtime.
    We’ve put the common protocol for all Animals (the four methods that we want the
    world to know all Animals have) in the Animal superclass, and we’re ready to start
    making new Lions and Tigers and Hippos.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 类结构并不算太糟糕。我们设计它以使重复代码最小化，并重写了我们认为应该具有特定子类实现的方法。从多态的角度来看，我们使其变得灵活，因为我们可以用Animal参数（和数组声明）设计使用Animal的程序，以便在运行时可以传入和使用任何Animal子类型—***包括我们在编写代码时从未想象过的那些***。我们将所有动物的共同协议（我们希望全世界都知道的四种方法）放在Animal超类中，我们准备开始制作新的Lion、Tiger和Hippo。
- en: '**We know we can say:**'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们知道我们可以说：**'
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![image](Images/f0201-01.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0201-01.png)'
- en: '**And we know we can say:**'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**而我们知道我们可以说：**'
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![image](Images/f0201-02.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0201-02.png)'
- en: '**But here’s where it gets weird:**'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**但事情变得奇怪的地方在这里：**'
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![image](Images/f0201-03.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0201-03.png)'
- en: '**What does a new Animal() object *look* like?**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**一个新的Animal()对象 *是* 什么样子？**'
- en: '![image](Images/f0202-01.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0202-01.png)'
- en: '**What are the instance variable values?**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**实例变量的值是什么？**'
- en: '**Some classes just should *not* be instantiated!**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**有些类根本不应该被实例化！**'
- en: It makes sense to create a Wolf object or a Hippo object or a Tiger object,
    but what exactly *is* an Animal object? What shape is it? What color, size, number
    of legs...
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个Wolf对象或Hippo对象或Tiger对象是有意义的，但是究竟*什么是*Animal对象？它是什么形状？什么颜色、大小、几条腿……
- en: Trying to create an object of type Animal is like **a nightmare Star Trek™ transporter
    accident.** The one where somewhere in the beam-me-up process something bad happened
    to the buffer.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试创建Animal类型的对象就像是**噩梦般的星际迷航™传输事故**。在“我要上去”的过程中，缓冲区发生了不良反应。
- en: But how do we deal with this? We *need* an Animal class, for inheritance and
    polymorphism. But we want programmers to instantiate only the less abstract *subclasses*
    of class Animal, not Animal itself. We want Tiger objects and Lion objects, ***not
    Animal objects.***
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们如何处理这个问题呢？我们 *需要* 一个Animal类，用于继承和多态。但我们希望程序员只实例化类Animal的较少抽象的*子类*，而不是Animal本身。我们希望Tiger对象和Lion对象，***而不是Animal对象***。
- en: Fortunately, there’s a simple way to prevent a class from ever being instantiated.
    In other words, to stop anyone from saying “`**new**`” on that type. By marking
    the class as `**abstract**`, the compiler will stop any code, anywhere, from ever
    creating an instance of that type.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一种简单的方法可以阻止一个类被实例化。换句话说，阻止任何人对该类型使用“`**new**`”。通过将类标记为`**abstract**`，编译器将阻止任何地方的代码创建该类型的实例。
- en: You can still use that abstract type as a reference type. In fact, that’s a
    big part of why you have that abstract class in the first place (to use it as
    a polymorphic argument or return type, or to make a polymorphic array).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你仍然可以将该抽象类型用作引用类型。事实上，这是你首次创建抽象类的一个重要原因（将其用作多态参数或返回类型，或者创建一个多态数组）。
- en: When you’re designing your class inheritance structure, you have to decide which
    classes are *abstract* and which are *concrete*. Concrete classes are those that
    are specific enough to be instantiated. A *concrete* class just means that it’s
    OK to make objects of that type.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计类的继承结构时，你必须决定哪些类是*抽象的*，哪些是*具体的*。具体类是那些具体到可以实例化的类。*具体*类意味着可以创建该类型的对象。
- en: 'Making a class abstract is easy—put the keyword `**abstract**` before the class
    declaration:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个类声明为抽象很容易——在类声明前加上关键字`**abstract**`：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The compiler won’t let you instantiate an abstract class
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译器不允许你实例化一个抽象类。
- en: An abstract class means that nobody can ever make a new instance of that class.
    You can still use that abstract class as a declared reference type, for the purpose
    of polymorphism, but you don’t have to worry about somebody making objects of
    that type. The compiler *guarantees* it.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类意味着任何人都无法创建该类的新实例。你仍然可以将该抽象类用作声明的引用类型，以实现多态，但你不必担心有人创建该类型的对象。编译器*保证*这一点。
- en: '![image](Images/f0203-01.png)![image](Images/f0203-02.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0203-01.png)![image](Images/f0203-02.png)'
- en: An **abstract class** has virtually* no use, no value, no purpose in life, unless
    it is ***extended.***
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**抽象类**在没有被***扩展***的情况下几乎没有用途、价值或生存的目的。'
- en: With an abstract class, it’s the **instances of a *subclass*** of your abstract
    class that’s doing the work at runtime
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用抽象类时，是你的抽象类的**子类的实例**在运行时执行工作。
- en: '*There is an exception to this—an abstract class can have static members (see
    [Chapter 10](ch10.xhtml#numbers_matter_numbers_and_statics)).'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*但也有例外情况——抽象类可以拥有静态成员（见[第10章](ch10.xhtml#numbers_matter_numbers_and_statics)）。*'
- en: Abstract vs. Concrete
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象 vs. 具体
- en: '![image](Images/f0204-01.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0204-01.png)'
- en: A class that’s not abstract is called a *concrete* class. In the Animal inheritance
    tree, if we make Animal, Canine, and Feline abstract, that leaves Hippo, Wolf,
    Dog, Tiger, Lion, and Cat as the concrete subclasses.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 非抽象的类称为*具体*类。在动物继承树中，如果我们将Animal、Canine和Feline设为抽象类，则Hippo、Wolf、Dog、Tiger、Lion和Cat将作为具体的子类。
- en: Flip through the Java API and you’ll find a lot of abstract classes, especially
    in the GUI library. What does a GUI Component look like? The Component class is
    the superclass of GUI-related classes for things like buttons, text areas, scrollbars,
    dialog boxes, you name it. You don’t make an instance of a generic *Component*
    and put it on the screen; you make a JButton. In other words, you instantiate
    only a *concrete subclass* of Component, but never Component itself.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 翻阅Java API，你会发现很多抽象类，特别是在GUI库中。GUI组件是什么样子？Component类是与GUI相关的类的超类，用于按钮、文本区域、滚动条、对话框等。你不会实例化一个通用的*Component*并将其放在屏幕上；你会创建一个JButton。换句话说，你只实例化Component的一个*具体子类*，但从不实例化Component本身。
- en: Abstract methods
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象方法
- en: '![image](Images/f0205-02.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0205-02.png)'
- en: Besides classes, you can mark *methods* abstract, too. An abstract class means
    the class must be *extended*; an abstract method means the method must be *overridden*.
    You might decide that some (or all) behaviors in an abstract class don’t make
    any sense unless they’re implemented by a more specific subclass. In other words,
    you can’t think of any generic method implementation that could possibly be useful
    for subclasses. What would a generic eat() method look like?
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 除了类外，你也可以将*方法*标记为抽象。抽象类意味着该类必须*扩展*；抽象方法意味着该方法必须*重写*。你可能会决定某些（或全部）抽象类中的行为在没有更具体的子类实现时没有任何意义。换句话说，你不能想象出任何通用的方法实现对子类可能有用。一个通用的eat()方法会是什么样子？
- en: '**An abstract method has no body!**'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**抽象方法没有方法体！**'
- en: Because you’ve already decided there isn’t any code that would make sense in
    the abstract method, you won’t put in a method body. So no curly braces— just
    end the declaration with a semicolon.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你已经决定在抽象方法中没有任何有意义的代码，所以你不会加入方法体。所以没有花括号——声明只以分号结束。
- en: '![image](Images/f0205-01.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0205-01.png)'
- en: '**If you declare an abstract *method*, you MUST mark the *class* abstract as
    well. You can’t have an abstract method in a non-abstract class.**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果你声明了一个抽象*方法*，你*必须*将*类*标记为抽象。你不能在非抽象类中拥有抽象方法。**'
- en: If you put even a single abstract method in a class, you have to make the class
    abstract. But you *can* mix both abstract and non-abstract methods in the abstract
    class.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个类中放入了一个抽象方法，那么你必须将这个类标记为抽象。但是你*可以*在抽象类中混合使用抽象和非抽象方法。
- en: You MUST implement all abstract methods
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你*必须*实现所有抽象方法
- en: '![image](Images/f0206-01.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0206-01.png)'
- en: '***Implementing* an abstract method is just like *overriding* a method.**'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '***实现*一个抽象方法就像*重写*一个方法一样。**'
- en: Abstract methods don’t have a body; they exist solely for polymorphism. That
    means the first concrete class in the inheritance tree must implement *all* abstract
    methods.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象方法没有方法体；它们存在只为了多态性。这意味着继承树中的第一个具体类必须实现*所有*抽象方法。
- en: You can, however, pass the buck by being abstract yourself. If both Animal and
    Canine are abstract, for example, and both have abstract methods, class Canine
    does not have to implement the abstract methods from Animal. But as soon as we
    get to the first concrete subclass, like Dog, that subclass must implement *all*
    of the abstract methods from both Animal and Canine.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以通过自己成为抽象来推卸责任。例如，如果Animal和Canine都是抽象的，并且都有抽象方法，类Canine就不必实现Animal的抽象方法。但是一旦我们到达第一个具体的子类，比如Dog，那么这个子类必须实现Animal和Canine的*所有*抽象方法。
- en: But remember that an abstract class can have both abstract and *non*-abstract
    methods, so Canine, for example, could implement an abstract method from Animal,
    so that Dog didn’t have to. But if Canine says nothing about the abstract methods
    from Animal, Dog has to implement all of Animal’s abstract methods.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 但请记住，抽象类既可以有抽象方法，也可以有*非*抽象方法，因此Canine可以实现Animal的抽象方法，这样Dog就不需要实现它。但是如果Canine对Animal的抽象方法一言不发，Dog就必须实现Animal的所有抽象方法。
- en: When we say “you must implement the abstract method,” that means you *must provide
    a body.* That means you must create a non-abstract method in your class with the
    same method signature (name and arguments) and a return type that is compatible
    with the declared return type of the abstract method. What you put *in* that method
    is up to you. All Java cares about is that the method is *there*, in your concrete
    subclass.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说“你必须实现抽象方法”，这意味着你*必须提供一个方法体*。这意味着你必须在你的类中创建一个与抽象方法具有相同方法签名（名称和参数）且返回类型与声明的返回类型兼容的非抽象方法。你要在方法中放*什么*是由你决定的。Java只关心的是这个方法*存在*，在你的具体子类中。
- en: Polymorphism in action
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多态的实现
- en: Let’s say that we want to write our *own* kind of list class, one that will
    hold Dog objects, but pretend for a moment that we don’t know about the ArrayList
    class. For the first pass, we’ll give it just an add() method. We’ll use a simple
    Dog array (Dog[]) to keep the added Dog objects, and give it a length of 5\. When
    we reach the limit of 5 Dog objects, you can still call the add() method, but
    it won’t do anything. If we’re *not* at the limit, the add() method puts the Dog
    in the array at the next available index position and then increments that next
    available index (nextIndex).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想写一个*自己*的列表类，这个类将保存Dog对象，但是暂且假设我们不知道ArrayList类。首先，我们只给它一个add()方法。我们将使用一个简单的Dog数组（Dog[]）来保存添加的Dog对象，并将其长度设置为5。当我们达到5个Dog对象的限制时，你仍然可以调用add()方法，但它不会做任何事情。如果我们*还没有*达到限制，add()方法会将Dog放入数组中的下一个可用索引位置，然后增加该索引（nextIndex）。
- en: '**Building our own Dog-specific list**'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**构建我们自己的针对Dog的特定列表**'
- en: '**(Perhaps the world’s worst attempt at making our own ArrayList kind of class,
    from scratch.)**'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**（也许是世界上最糟糕的尝试之一，从头开始制作我们自己的ArrayList类。）**'
- en: '![image](Images/f0208-01.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0208-01.png)'
- en: Uh-oh, now we need to keep Cats, too
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哎呀，现在我们还需要保存Cats
- en: 'We have a few options here:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里有几个选择：
- en: 1\. Make a separate class, MyCatList, to hold Cat objects. Pretty clunky.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 创建一个单独的类MyCatList，用来保存Cat对象。相当笨重。
- en: '2\. Make a single class, DogAndCatList, that keeps two different arrays as
    instance variables and has two different add() methods: addCat(Cat c) and addDog(Dog
    d). Another clunky solution.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 创建一个单一的类DogAndCatList，将两个不同的数组作为实例变量，并且有两个不同的add()方法：addCat(Cat c)和addDog(Dog
    d)。另一个笨拙的解决方案。
- en: 3\. Make a heterogeneous AnimalList class that takes *any* kind of Animal subclass
    (since we know that if the spec changed to add Cats, sooner or later we’ll have
    some *other* kind of animal added as well). We like this option best, so let’s
    change our class to make it more generic, to take Animals instead of just Dogs.
    We’ve highlighted the key changes (the logic is the same, of course, but the type
    has changed from Dog to Animal everywhere in the code).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 创建一个异构的AnimalList类，接受*任何*动物子类（因为我们知道如果规格变更以添加猫，迟早还会添加*其他*种类的动物）。我们最喜欢这个选项，所以让我们更改我们的类，使其更通用，接受动物而不仅仅是狗。我们已经突出显示了关键更改（逻辑当然是一样的，但代码中的类型从Dog到Animal的变化）。
- en: '**Building our own Animal-specific list**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**构建我们自己的动物特定列表**'
- en: '![image](Images/f0209-01.png)![image](Images/f0209-02.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0209-01.png)![image](Images/f0209-02.png)'
- en: What about non-Animals? Why not make a class generic enough to take anything?
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 那么非动物类呢？为什么不创建一个足够通用以接受任何东西的类？
- en: '![image](Images/f0210-01.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0210-01.png)'
- en: You know where this is heading. We want to change the type of the array, along
    with the add() method argument, to something *above* Animal. Something even *more*
    generic, *more* abstract than Animal. But how can we do it? We don’t *have* a
    superclass for Animal.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道这将引向何方。我们想要改变数组的类型，还有add()方法的参数，改成某种比Animal更上层、更通用、更抽象的东西。但是我们该如何做呢？我们没有Animal的超类。
- en: Then again, maybe we do...
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 但是话又说回来，也许我们有……
- en: '**Every class in Java extends class Object.**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java中的每个类都扩展自类Object。**'
- en: Class Object is the mother of all classes; it’s the superclass of *everything.*
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Object类是所有类的母类；它是*一切*的超类。
- en: Even if you take advantage of polymorphism, you still have to create a class
    with methods that take and return *your* polymorphic type. Without a common superclass
    for everything in Java, there’d be no way for the developers of Java to create
    classes with methods that could take *your* custom types...*types they never knew
    about when they wrote the library class.*
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你利用多态性，你仍然必须创建一个带有接受和返回*你的*多态类型的方法的类。如果在Java中没有一种通用的超类，Java的开发人员就无法创建可以接受*你*自定义类型的方法的类……*在编写库类时他们根本不知道这些类型*。
- en: 'So you were making subclasses of class Object from the very beginning and you
    didn’t even know it. ***Every class you write extends Object,*** without your
    ever having to say it. But you can think of it as though a class you write looks
    like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 所以从一开始你就在为类Object的子类编写代码，而你甚至都不知道。***你编写的每个类都扩展自Object，*** 而无需你说它。但你可以把你编写的类想象成是这样的：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: But wait a minute, Dog *already* extends something, *Canine*. That’s OK. The
    compiler will make *Canine* extend Object instead. Except *Canine* extends Animal.
    No problem, then the compiler will just make *Animal* extend Object.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 等等，但是Dog *已经*扩展了某个东西，*Canine*。没问题。编译器将会使*Canine*扩展Object。虽然*Canine*扩展了Animal。那也没问题，编译器会直接使Animal扩展Object。
- en: '**Any class that doesn’t *explicitly* extend another class, *implicitly* extends
    Object.**'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**任何没有*显式*扩展其他类的类，默认都会扩展Object。**'
- en: So, since Dog extends Canine, it doesn’t *directly* extend Object (although
    it does extend it indirectly), and the same is true for Canine, but Animal *does*
    directly extend Object.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，由于Dog扩展了Canine，它并没有*直接*扩展Object（尽管它间接扩展了它），Canine也是如此，但是Animal *确实*直接扩展了Object。
- en: So what’s in this ultra-super-megaclass Object?
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 那么这个超级超级超级大类Object里面都有什么？
- en: '![image](Images/f0211-01.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0211-01.png)'
- en: If you were Java, what behavior would you want *every* object to have? Hmmmm...let’s
    see...how about a method that lets you find out if one object is equal to another
    object? What about a method that can tell you the actual class type of that object?
    Maybe a method that gives you a hashcode for the object, so you can use the object
    in hashtables (we’ll talk about Java’s hashtables later). Oh, here’s a good one—a
    method that prints out a String message for that object.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是Java，你希望*每个*对象具有什么行为呢？嗯……让我们看看……要不要一个方法来判断一个对象是否等于另一个对象？还要不要一个方法来告诉你该对象的实际类类型？或许还要一个方法，为对象生成一个哈希码，这样你就可以在哈希表中使用该对象（稍后我们会讨论Java的哈希表）。哦，这里还有一个好方法——一个方法，打印出该对象的字符串消息。
- en: And what do you know? As if by magic, class Object does indeed have methods
    for those four things. That’s not all, though, but these are the ones we really
    care about.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你猜怎么着？就像魔术一样，Object 类确实拥有这四种方法。不过，这还不是全部，但我们确实关心这些。
- en: '![Images](Images/1.png) **equals(Object o)**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '![Images](Images/1.png) **equals(Object o)**'
- en: '![image](Images/f0211-02.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0211-02.png)'
- en: '![Images](Images/2.png) **getClass()**'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![Images](Images/2.png) **getClass()**'
- en: '![image](Images/f0211-03.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0211-03.png)'
- en: '![Images](Images/3.png) **hashCode()**'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '![Images](Images/3.png) **hashCode()**'
- en: '![image](Images/f0211-04.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0211-04.png)'
- en: '![Images](Images/4.png) **toString()**'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![Images](Images/4.png) **toString()**'
- en: '![image](Images/f0211-05.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0211-05.png)'
- en: Using polymorphic references of type Object has a price...
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类型为 Object 的多态引用是有代价的…
- en: Before you run off and start using type Object for all your ultra-flexible argument
    and return types, you need to consider a little issue of using type Object as
    a reference. And keep in mind that we’re not talking about making instances of
    type Object; we’re talking about making instances of some other type, but using
    a reference of type Object.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在你忙着为所有的超灵活的参数和返回类型使用类型 Object 之前，你需要考虑一个小问题：使用类型 Object 作为引用可能会带来一些问题。记住，我们不是在讨论如何制作类型
    Object 的实例；我们讨论的是制作某些其他类型的实例，但使用类型 Object 的引用。
- en: 'When you put an object into an ArrayList**<Dog>**, it goes in as a Dog and
    comes out as a Dog:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当你把一个对象放入 ArrayList**<Dog>** 中时，它以 Dog 形式放进去，并以 Dog 形式出来：
- en: '![image](Images/f0213-01.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0213-01.png)'
- en: 'But what happens when you declare it as ArrayList**<Object>**? If you want
    to make an ArrayList that will literally take any kind of Object, you declare
    it like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 但是当你将其声明为 ArrayList**<Object>** 时会发生什么？如果你想制作一个可以真正接受任何类型对象的 ArrayList，你可以这样声明：
- en: '![image](Images/f0213-02.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0213-02.png)'
- en: But what happens when you try to get the Dog object and assign it to a Dog reference?
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 但是当你试图获取 Dog 对象并将其分配给 Dog 引用时会发生什么？
- en: '![image](Images/f0213-03.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0213-03.png)'
- en: '***Everything comes out of an ArrayList<Object> as a reference of type Object,
    regardless of what the actual object is or what the reference type was when you
    added the object to the list.***'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '***无论实际对象是什么，或者当你将对象添加到列表时引用类型是什么，所有东西都会作为类型为 Object 的引用从 ArrayList<Object>
    中出来。***'
- en: '![image](Images/f0213-04.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0213-04.png)'
- en: When a Dog won’t act like a Dog
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当一只狗不像一只狗时
- en: The problem with having everything treated polymorphically as an Object is that
    the objects *appear* to lose (but not permanently) their true essence. *The Dog
    appears to lose its dogness*. Let’s see what happens when we pass a Dog to a method
    that returns a reference to the same Dog object, but declares the return type
    as type Object rather than Dog.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 把一切都当作 Object 处理的问题在于，对象们 *似乎* 失去了它们的真正本质（尽管不是永久性的）。*狗似乎失去了它的狗性*。让我们看看当我们把一个
    Dog 对象传递给一个方法，该方法返回相同 Dog 对象的引用，但声明返回类型为 Object 而不是 Dog 时会发生什么。
- en: '![image](Images/f0214-01.png)![image](Images/f0214-02.png)![image](Images/f0214-03.png)![image](Images/f0214-04.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0214-01.png)![image](Images/f0214-02.png)![image](Images/f0214-03.png)![image](Images/f0214-04.png)'
- en: Objects don’t bark
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象不会吠
- en: '![image](Images/f0215-01.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0215-01.png)'
- en: 'So now we know that when an object is referenced by a variable declared as
    type Object, it can’t be assigned to a variable declared with the actual object’s
    type. And we know that this can happen when a return type or argument is declared
    as type Object, as would be the case, for example, when the object is put into
    an ArrayList of type Object using ArrayList<Object>. But what are the implications
    of this? Is it a problem to have to use an Object reference variable to refer
    to a Dog object? Let’s try to call Dog methods on our Dog-That-Compiler-Thinks-Is-An-Object:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道，当一个对象被引用为类型 Object 的变量时，它不能被分配给声明为实际对象类型的变量。我们知道，当返回类型或参数声明为类型 Object
    时，这种情况可能发生，例如当对象被放入类型为 Object 的 ArrayList 中时，使用 ArrayList<Object>。但这会带来什么后果呢？当我们试图在一个被编译器认为是
    Object 的 Dog 上调用 Dog 方法时会发生什么呢？
- en: '![image](Images/f0215-02.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0215-02.png)'
- en: Note
  id: totrans-105
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**The compiler decides whether you can call a method based on the *reference*
    type, not the actual object type.**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**编译器根据 *引用* 类型来决定是否可以调用方法，而不是实际对象类型。**'
- en: Even if you *know* the object is capable (“...but it really *is* a Dog, honest...”),
    the compiler sees it only as a generic Object. For all the compiler knows, you
    put a Button object out there. Or a Microwave object. Or some other thing that
    really doesn’t know how to bark.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你*知道*对象是有能力的（“...但它真的*是*一只狗，诚实的...”），编译器只能将其视为一个通用的`Object`。对于编译器来说，你放了一个按钮对象出来。或者一个微波炉对象。或者一些其他完全不知道如何吠叫的东西。
- en: The compiler checks the class of the *reference* type—not the *object* type—to
    see if you can call a method using that reference.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器检查*引用*类型的类，而不是*对象*类型，以确定是否可以使用该引用调用方法。
- en: '![image](Images/f0215-03.png)![image](Images/f0216-01.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0215-03.png)![image](Images/f0216-01.png)'
- en: Get in touch with your inner Object
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 激发你内在的`Object`
- en: An object contains *everything* it inherits from each of its superclasses. That
    means *every* object—regardless of its actual class type—is *also* an instance
    of class Object. That means any object in Java can be treated not just as a Dog,
    Button, or Snowboard, but also as an Object. When you say `**new Snowboard()**`,
    you get a single object on the heap—a Snowboard object—but that Snowboard wraps
    itself around an inner core representing the Object (capital “O”) portion of itself.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对象包含从其每个超类继承的*所有*内容。这意味着*每个*对象——无论其实际的类类型如何——也是`Object`类的一个实例。这意味着在Java中，任何对象不仅可以被视为一只狗、按钮或雪板，还可以被视为一个`Object`。当你说`**new
    Snowboard()**`时，你在堆上得到一个单独的对象——一个`Snowboard`对象——但是该`Snowboard`包裹着代表其内部核心的`Object`（大写“O”）部分。
- en: '![image](Images/f0216-02.png)![image](Images/f0216-03.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0216-02.png)![image](Images/f0216-03.png)'
- en: '*Polymorphism* means “many forms.”'
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*多态*意味着“多种形式”。'
- en: '**You can treat a Snowboard as a Snowboard or as an Object.**'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**你可以将`Snowboard`视为`Snowboard`或`Object`。**'
- en: If a reference is like a remote control, the remote control takes on more and
    more buttons as you move down the inheritance tree. A remote control (reference)
    of type Object has only a few buttons— the buttons for the exposed methods of
    class Object. But a remote control of type Snowboard includes all the buttons
    from class Object, plus any new buttons (for new methods) of class Snowboard.
    The more specific the class, the more buttons it may have.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个引用就像一个遥控器，那么随着你沿着继承树向下移动，遥控器会拥有越来越多的按钮。类型为`Object`的遥控器（引用）只有几个按钮——类`Object`的暴露方法的按钮。但是类型为`Snowboard`的遥控器包括来自类`Object`的所有按钮，以及类`Snowboard`的任何新按钮（用于新方法）。类别越具体，按钮可能越多。
- en: Of course that’s not always true; a subclass might not add any new methods,
    but simply override the methods of its superclass. The key point is that even
    if the object is of type Snowboard, an Object *reference* to the Snowboard *object*
    can’t see the Snowboardspecific methods.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这并非总是如此；子类可能并不添加任何新方法，而只是重写其超类的方法。关键点在于，即使对象的类型是`Snowboard`，指向该`Snowboard`对象的`Object`*引用*也无法看到`Snowboard`特定的方法。
- en: '![image](Images/f0217-02.png)![image](Images/f0218-01.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0217-02.png)![image](Images/f0218-01.png)'
- en: Casting an object reference back to its *real* type.
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将对象引用强制转换回其*真实*类型。
- en: '![image](Images/f0218-03.png)![image](Images/f0218-02.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0218-03.png)![image](Images/f0218-02.png)'
- en: It’s really still a Dog *object*, but if you want to call Dogspecific methods,
    you need a *reference* declared as type Dog. If you’re *sure** the object is really
    a Dog, you can make a new Dog reference to it by copying the Object reference,
    and forcing that copy to go into a Dog reference variable, using a cast (Dog).
    You can use the new *Dog* reference to call *Dog* methods.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 它仍然是一只狗*对象*，但是如果你想调用`Dog`特定的方法，你需要声明为`Dog`类型的*引用*。如果你确信对象确实是一只狗，你可以通过复制对象引用，并强制将该副本放入`Dog`引用变量中，使用强制转换`(Dog)`来创建一个新的*Dog*引用。你可以使用新的*Dog*引用调用*Dog*方法。
- en: '![image](Images/f0218-04.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0218-04.png)'
- en: '*If you’re *not* sure it’s a Dog, you can use the `instanceof` operator to
    check. Because if you’re wrong when you do the cast, you’ll get a ClassCastException
    at runtime and come to a grinding halt.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你不确定它是一只狗，可以使用`instanceof`运算符进行检查。因为如果你在强制转换时出错，运行时将抛出`ClassCastException`并彻底停止。*'
- en: '[PRE5]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**So now you’ve seen how much Java cares about the methods in the class of
    the reference variable.**'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**所以现在你已经看到Java在引用变量的类中多么关心方法。**'
- en: '**You can call a method on an object only if the class of the reference variable
    has that method.**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**你只能在对象上调用方法，如果引用变量的类具有该方法。**'
- en: '**Think of the public methods in your class as your contract, your promise
    to the outside world about the things you can do.**'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**将你类中的公共方法视为你的合同，向外界承诺你能做的事情。**'
- en: '![image](Images/f0219-01.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0219-01.png)'
- en: When you write a class, you almost always *expose* some of the methods to code
    outside the class. To *expose* a method means you make a method *accessible*,
    usually by marking it public.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写一个类时，你几乎总是向外部代码*公开*一些方法。*公开*方法意味着你使方法*可访问*，通常通过将其标记为public。
- en: 'Imagine this scenario: you’re writing code for a small business accounting
    program. A custom application for Simon’s Surf Shop. The good re-user that you
    are, you found an Account class that appears to meet your needs perfectly, according
    to its documentation, anyway. Each account instance represents an individual customer’s
    account with the store. So there you are minding your own business invoking the
    *credit()* and *debit()* methods on an Account object when you realize you need
    to get a balance on an account. No problem—there’s a *getBalance()* method that
    should do nicely.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 想象这样的场景：你正在为一个小型企业会计程序编写代码。为Simon's Surf Shop定制的应用程序。作为一个良好的重用者，你找到了一个Account类，看起来完全符合你的需求，至少根据它的文档来看是这样的。每个账户实例代表店铺中一个客户的账户。所以你在忙着调用Account对象的*credit()*和*debit()*方法时，突然意识到你需要获取账户的余额。没问题——应该有一个*getBalance()*方法可以满足你的需求。
- en: '![image](Images/f0219-02.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0219-02.png)'
- en: Except...when you invoke the *getBalance()* method, the whole thing blows up
    at runtime. Forget the documentation, the class does not have that method. Yikes!
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 除了……当你调用*getBalance()*方法时，整个事情在运行时崩溃了。忘掉文档吧，这个类根本没有那个方法。哎呀！
- en: But that won’t happen to you, because every time you use the dot operator on
    a reference (a.doStuff()), the compiler looks at the *reference* type (the type
    “a” was declared to be) and checks that class to guarantee the class has the method,
    and that the method does indeed take the argument you’re passing and return the
    kind of value you’re expecting to get back.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 但这不会发生在你身上，因为每当你在引用上使用点运算符（a.doStuff()），编译器都会查看*引用*类型（变量"a"声明的类型）并检查该类以保证该方法存在，并且确实接受你传递的参数并返回你期望得到的类型的值。
- en: '**Just remember that the compiler checks the class of the *reference* variable,
    not the class of the actual *object* at the other end of the reference.**'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**请记住，编译器检查的是*引用*变量的类，而不是引用另一端的*对象*的类。**'
- en: What if you need to change the contract?
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如果你需要更改合同怎么办？
- en: OK, pretend you’re a Dog. Your Dog class isn’t the *only* contract that defines
    who you are. Remember, you inherit accessible (which usually means *public*) methods
    from all of your superclasses.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，假装你是一只狗。你的Dog类并不是*唯一*定义你是谁的合同。记住，你从所有超类继承了可访问（通常意味着*public*）的方法。
- en: True, your Dog class defines a contract.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，你的Dog类定义了一个合同。
- en: But not *all* of your contract.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 但不是*所有*你的合同。
- en: '**Everything in class *Canine* is part of your contract.**'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**类*Canine*中的所有内容都是你合同的一部分。**'
- en: '**Everything in class *Animal* is part of your contract.**'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**类*Animal*中的所有内容都是你合同的一部分。**'
- en: '**Everything in class *Object* is part of your contract.**'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**类*Object*中的所有内容都是你合同的一部分。**'
- en: According to the IS-A test, you *are* each of those things—Canine, Animal, and
    Object.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 根据IS-A测试，你*是*每一个这些东西——Canine、Animal和Object。
- en: But what if the person who designed your class had in mind the Animal simulation
    program, and now he wants to use you (class Dog) for a Science Fair Tutorial on
    Animal objects.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果设计你的类的人心中有一个动物仿真程序，现在他想要使用你（Dog类）来做一个关于动物对象的科学展示教程。
- en: That’s OK, you’re probably reusable for that.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 没关系，你很可能对此是可重用的。
- en: But what if later he wants to use you for a PetShop program? *You don’t have
    any **Pet** behaviors.* A Pet needs methods like *beFriendly()* and *play()*.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果后来他想要把你用在PetShop程序中呢？*你没有任何**Pet**行为。* 宠物需要像*beFriendly()*和*play()*这样的方法。
- en: OK, now pretend you’re the Dog class programmer. No problem, right? Just add
    some more methods to the Dog class. You won’t be breaking anyone else’s code by
    *adding* methods, since you aren’t touching the *existing* methods that someone
    else’s code might be calling on Dog objects.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假装你是Dog类的程序员。没问题，对吧？只需向Dog类添加更多方法。通过*添加*方法，你不会破坏其他人可能在Dog对象上调用的*现有*方法。
- en: Can you see any drawbacks to that approach (adding Pet methods to the Dog class)?
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你能看到这种方法的任何缺点吗（在Dog类中添加Pet方法）？
- en: Let’s explore some design options for reusing some of our existing classes in
    a PetShop program
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们探索一些设计选项，以重用一些我们现有类在PetShop程序中
- en: On the next few pages, we’re going to walk through some possibilities. We’re
    not yet worried about whether Java can actually *do* what we come up with. We’ll
    cross that bridge once we have a good idea of some of the trade-offs.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几页中，我们将探讨一些可能性。我们暂时不担心Java是否实际*能够*实现我们想要的功能。我们会在明确了一些权衡之后再解决这个问题。
- en: '**So what we REALLY need is:**'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**所以我们真正需要的是：**'
- en: '![Images](Images/enter.png) A way to have pet behavior in **just** the pet
    classes'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Images](Images/enter.png) 一种让宠物类中*只有*宠物行为的方法'
- en: '![Images](Images/enter.png) A way to guarantee that all pet classes have all
    of the same methods defined (same name, same arguments, same return types, no
    missing methods, etc.), without having to cross your fingers and hope all the
    programmers get it right'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Images](Images/enter.png) 一种保证所有宠物类都定义了相同方法（同名、同参数、同返回类型，没有缺失方法等）的方式，而不必交叉双手，希望所有程序员都能做对'
- en: '![Images](Images/enter.png) A way to take advantage of polymorphism so that
    all pets can have their pet methods called, without having to use arguments, return
    types, and arrays for each and every pet class'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Images](Images/enter.png) 一种利用多态性的方式，使得所有宠物都能调用它们的宠物方法，而不需要为每个宠物类使用参数、返回类型和数组。'
- en: '**It looks like we need TWO superclasses at the top.**'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**看起来我们需要顶层的两个超类。**'
- en: '![image](Images/f0224-01.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0224-01.png)'
- en: There’s just one problem with the “two superclasses” approach...
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: “两个超类”的方法也有一个问题……
- en: '**It’s called “multiple inheritance,” and it can be a Really Bad Thing.**'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**这就是“多重继承”，它可能是一件真正糟糕的事情。**'
- en: That is, if it were possible to do in Java.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，如果在Java中有可能实现的话。
- en: But it isn’t, because multiple inheritance has a problem known as The Deadly
    Diamond of Death.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 但它并不是这样，因为多重继承有一个称为死亡之钻石的问题。
- en: '**Deadly Diamond of Death**'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**死亡之钻石**'
- en: '![image](Images/f0225-01.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0225-01.png)'
- en: A language that allows the Deadly Diamond of Death can lead to some ugly complexities,
    because you have to have special rules to deal with the potential ambiguities.
    And extra rules means extra work for you both in *learning* those rules and watching
    out for those “special cases.” Java is supposed to be *simple* , with consistent
    rules that don’t blow up under some scenarios. So Java (unlike C++) protects you
    from having to think about the Deadly Diamond of Death. But that brings us back
    to the original problem! *How do we handle the Animal/Pet thing?*
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 一种允许死亡之钻石的语言可能会导致一些复杂的问题，因为你必须有特殊的规则来处理潜在的歧义。而额外的规则意味着你不仅要*学习*这些规则，还要注意这些“特殊情况”。Java本应是*简单*的，具有一致的规则，不会在某些场景下出现问题。因此，Java（不像C++）保护你免受需要考虑死亡之钻石的困扰。但这又把我们带回到最初的问题！*我们如何处理动物/宠物这件事？*
- en: Interface to the rescue!
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口来拯救！
- en: Java gives you a solution. An *interface* . Not a *GUI* interface, not the generic
    use of the *word* interface as in, “That’s the public interface for the Button
    class API,” but the Java *keyword* `interface`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Java为你提供了一个解决方案。一个*接口*。不是*GUI*界面，也不是像“这是Button类API的公共接口”中的接口的通用用法，而是Java的*关键字*`interface`。
- en: A Java interface solves your multiple inheritance problem by giving you much
    of the polymorphic *benefits* of multiple inheritance without the pain and suffering
    from the Deadly Diamond of Death (DDD).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Java接口通过提供多态的*好处*来解决多重继承问题，而不会引入死亡之钻石（DDD）的痛苦和困扰。
- en: 'The way in which interfaces side-step the DDD is surprisingly simple: ***make
    all the methods abstract!*** That way, the subclass ***must*** implement the methods
    (remember, abstract methods *must* be implemented by the first concrete subclass),
    so at runtime the JVM isn’t confused about *which* of the two inherited versions
    it’s supposed to call.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 接口绕过DDD的方式非常简单：***将所有方法都定义为抽象方法！*** 这样子类***必须***实现这些方法（记住，抽象方法*必须*由第一个具体的子类实现），因此在运行时，JVM不会困惑于调用*哪一个*继承版本。
- en: '![image](Images/f0226-01.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0226-01.png)'
- en: '**A Java interface is like a 100% pure abstract class.**'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java接口就像一个100%纯抽象类。**'
- en: Note
  id: totrans-168
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: All methods in an interface are abstract, so any class that IS-A Pet MUST implement
    (i.e., override) the methods of Pet.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 接口中的所有方法都是抽象的，因此任何IS-A Pet的类都必须实现（即覆盖）Pet的方法。
- en: '**To DEFINE an interface:**'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义接口的方法：**'
- en: '![image](Images/f0226-02.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0226-02.png)'
- en: '**To IMPLEMENT an interface:**'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**实现接口：**'
- en: '![image](Images/f0226-03.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0226-03.png)'
- en: Making and implementing the Pet interface
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作并实现Pet接口
- en: '![image](Images/f0227-01.png)![image](Images/f0227-02.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0227-01.png)![图片](Images/f0227-02.png)'
- en: '**Classes from *different* inheritance trees can implement the same interface.**'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**来自*不同*继承树的类可以实现相同的接口。**'
- en: '![image](Images/f0228-01.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0228-01.png)'
- en: When you use a *class* as a polymorphic type (like an array of type Animal or
    a method that takes a Canine argument), the objects you can stick in that type
    must be from the same inheritance tree. But not just anywhere in the inheritance
    tree; the objects must be from a class that is a subclass of the polymorphic type.
    An argument of type Canine can accept a Wolf and a Dog, but not a Cat or a Hippo.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个*类*用作多态类型（例如一个Animal类型的数组或一个接受Canine参数的方法），你可以放入该类型的对象必须来自相同的继承树。但不仅仅是继承树的任何地方；这些对象必须来自于一个是多态类型的子类。一个Canine类型的参数可以接受一个Wolf和一个Dog，但不能接受一个Cat或者Hippo。
- en: But when you use an ***interface*** as a polymorphic type (like an array of
    Pets), the objects can be from *anywhere* in the inheritance tree. The only requirement
    is that the objects are from a class that *implements* the interface. Allowing
    classes in different inheritance trees to implement a common interface is crucial
    in the Java API. Do you want an object to be able to save its state to a file?
    Implement the Serializable interface. Do you need objects to run their methods
    in a separate thread of execution? Implement Runnable. You get the idea. You’ll
    learn more about Serializable and Runnable in later chapters, but for now, remember
    that classes from *any* place in the inheritance tree might need to implement
    those interfaces. Nearly *any* class might want to be saveable or runnable.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 但是当你将一个***接口***用作多态类型（例如一个Pets数组），对象可以来自继承树*任何地方*。唯一的要求是这些对象来自一个实现了接口的类。允许来自不同继承树的类实现共同的接口，在Java
    API中至关重要。需要一个对象能够将其状态保存到文件吗？实现Serializable接口。需要对象在单独的线程中运行其方法吗？实现Runnable接口。你明白了吧。稍后的章节中你将了解更多关于Serializable和Runnable的内容，但是现在要记住，来自继承树*任何地方*的类可能需要实现这些接口。几乎*任何*类都可能希望成为可保存或可运行的对象。
- en: '**Better still, a class can implement *multiple* interfaces!**'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**更好的是，一个类可以实现*多个*接口！**'
- en: 'A Dog object IS-A Canine, and IS-A Animal, and IS-A Object, all through inheritance.
    But a Dog IS-A Pet through interface implementation, and the Dog might implement
    other interfaces as well. You could say:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Dog对象通过继承是一个Canine，是一个Animal，是一个Object。但是通过接口实现，一个Dog是一个Pet，并且Dog可能实现其他接口。你可以说：
- en: '[PRE6]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![image](Images/f0229-01.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0229-01.png)'
- en: '**How do you know whether to make a class, a subclass, an *abstract* class,
    or an interface?**'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**如何判断是应该创建一个类、一个子类、一个*抽象*类还是一个接口？**'
- en: Make a class that doesn’t extend anything (other than Object) when your new
    class doesn’t pass the IS-A test for any other type.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你的新类对于任何其他类型都不能通过IS-A测试时（除了Object之外），才创建一个不扩展任何东西的类。
- en: Make a subclass (in other words, *extend* a class) only when you need to make
    a ***more specific*** version of a class and need to override or add new behaviors.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你需要创建一个***更具体***版本的类并且需要重写或添加新行为时，才创建一个子类（换句话说，*扩展*一个类）。
- en: Use an abstract class when you want to define a ***template*** for a group of
    subclasses, and you have at least *some* implementation code that all subclasses
    could use. Make the class abstract when you want to guarantee that nobody can
    make objects of that type.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你想为一组子类定义一个***模板***，并且这些子类至少有*一些*实现代码可以共用时，使用一个抽象类。当你希望确保没有人可以创建该类型的对象时，将类声明为抽象类。
- en: Use an interface when you want to define a ***role*** that other classes can
    play, regardless of where those classes are in the inheritance tree.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你想定义其他类可以扮演的一个***角色***时，使用一个接口，无论这些类在继承树的哪个位置。
- en: Invoking the superclass version of a method
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用一个方法的超类版本
- en: Exercise
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: '![image](Images/f0418-01.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0418-01.png)'
- en: Here’s your chance to demonstrate your artistic abilities. On the left you’ll
    find sets of class and interface declarations. Your job is to draw the associated
    class diagrams on the right. We did the first one for you. Use a dashed line for
    “implements” and a solid line for “extends.”
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是展示你艺术能力的机会。在左边，你会找到一些类和接口声明的集合。你的任务是在右边绘制相应的类图。我们已经为你做了第一个。使用虚线表示“实现”关系，实线表示“继承”关系。
- en: '![image](Images/f0232-02.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0232-02.png)'
- en: '![Images](Images/arr1.png) **Answers in [“What’s the Picture ?”](#whatapostrophes_the_picture_question_mar).**'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](Images/arr1.png) **“What’s the Picture ?”中的答案。**'
- en: '![image](Images/f0418-01.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0418-01.png)'
- en: On the left you’ll find sets of class diagrams. Your job is to turn these into
    valid Java declarations. We did number 1 for you (and it was a tough one).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧，你将找到一组类图。你的任务是将它们转换为有效的Java声明。我们已经为你完成了第1个（它很难）。
- en: '![image](Images/f0233-01.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0233-01.png)'
- en: '![Images](Images/arr1.png) **Answers in [“What’s the Declaration?”](#whatapostrophes_the_declaration_question).**'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](Images/arr1.png) **答案在 [“声明是什么？”](#whatapostrophes_the_declaration_question)
    中。**'
- en: '![image](Images/f0234-01.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0234-01.png)'
- en: Pool Puzzle
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 池谜题
- en: '![image](Images/f0234-02.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0234-02.png)'
- en: Your ***job*** is to take code snippets from the pool and place them into the
    blank lines in the code and output. You **may** use the same snippet more than
    once, and you won’t need to use all the snippets. Your ***goal*** is to make a
    set of classes that will compile and run and produce the output listed.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你的***工作***是从池中获取代码片段，并将它们放入代码和输出的空白行中。你**可以**多次使用同一片段，而且不需要使用所有片段。你的***目标***是创建一组可以编译运行并产生列出输出的类。
- en: '![image](Images/f0234-03.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0234-03.png)'
- en: '![Images](Images/arr1.png) **Answers in [“Pool Puzzle”](#pool_puzzle_left_parenthesis_from_page_2).**'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](Images/arr1.png) **答案在 [“池谜题”](#pool_puzzle_left_parenthesis_from_page_2)
    中。**'
- en: Exercise Solutions
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习解答
- en: '![image](Images/f0418-01.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0418-01.png)'
- en: What’s the Picture ?
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 这是什么图？
- en: (from [“Exercise”](#exercise-id000013))
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: (来自 [“练习”](#exercise-id000013))
- en: '![image](Images/f0235-01.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0235-01.png)'
- en: What’s the Declaration?
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明是什么？
- en: (from [Figure ](#id00110001))
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: (来自 [“图 ”](#id00110001))
- en: '**2.** public abstract class Top { }'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**2.** 公共抽象类 Top { }'
- en: public class Tip extends Top { }
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 公共类 Tip 扩展自 Top { }
- en: '**3.** public abstract class Fee { }'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**3.** 公共抽象类 Fee { }'
- en: public abstract class Fi extends Fee { }
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 公共抽象类 Fi 扩展自 Fee { }
- en: '**4.** public interface Foo { }'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**4.** 公共接口 Foo { }'
- en: public class Bar implements Foo { }
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 公共类 Bar 实现 Foo { }
- en: public class Baz extends Bar { }
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 公共类 Baz 扩展自 Bar { }
- en: '**5.** public interface Zeta { }'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**5.** 公共接口 Zeta { }'
- en: public class Alpha implements Zeta { }
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 公共类 Alpha 实现 Zeta { }
- en: public interface Beta { }
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 公共接口 Beta { }
- en: public class Delta extends Alpha implements Beta { }
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 公共类 Delta 扩展自 Alpha 并实现 Beta { }
- en: '**key**'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键**'
- en: '![image](Images/f0235-02.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0235-02.png)'
- en: Pool Puzzle
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 池谜题
- en: (from [“Pool Puzzle”](#pool_puzzle-id00004))
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: (来自 [“池谜题”](#pool_puzzle-id00004))
- en: '![image](Images/f0236-01.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0236-01.png)'
- en: '[PRE7]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**Output**'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出**'
- en: '![image](Images/f0236-03.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0236-03.png)'
