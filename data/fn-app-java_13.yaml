- en: Chapter 11\. Lazy Evaluation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 11 章\. 惰性评估
- en: Although *laziness* is often seen as a character flaw in people, it can be considered
    a favorable feature in some programming languages. In computer science terms,
    *laziness* is the antagonist to *strictness* —  or *eagerness* — of code evaluation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然*懒惰*在人们看来经常是性格缺陷，但在一些编程语言中可以被视为有利特性。在计算机科学术语中，*懒惰*是代码评估的对手，与*严格性* — 或*渴望性* — 相对立。
- en: This chapter will show you how being lazy can improve performance. You will
    learn about the difference between strict and lazy evaluation and its impact on
    your code’s design.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向您展示如何通过懒惰提高性能。您将了解严格和惰性评估之间的区别及其对代码设计的影响。
- en: Laziness Versus Strictness
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 懒惰与严格性
- en: The strictness of a language describes the semantics of how your code is evaluated.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 语言的严格性描述了代码评估的语义。
- en: '*Strict* evaluation happens as soon as possible, such as declaring or setting
    a variable or passing an expression as an argument. *Non-strict* evaluation, however,
    happens when the result of an expression is actually needed. This way, expressions
    can have a value even if one or more subexpressions fail to evaluate.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*严格*评估尽可能快地发生，例如在声明或设置变量或将表达式作为参数传递时。然而，*非严格*评估发生在实际需要表达式结果时。这样，即使一个或多个子表达式无法评估，表达式仍然可以具有值。'
- en: For example, *Haskell* is a functional programming language with *non-strict*
    semantics by default, evaluating expressions from the outermost to the inner ones.
    This allows you to create control structures or infinite data sequences due to
    the separation of the *creation* and *consumption* of expressions.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，*Haskell* 是一种函数式编程语言，默认具有*非严格*语义，从最外层到最内层评估表达式。这允许您创建控制结构或无限数据序列，因为表达式的*创建*和*消费*分离。
- en: 'Let’s take a look at the following *strict* Java code of a simple method accepting
    two arguments but using only one for its logic:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个简单方法的*严格* Java 代码，它接受两个参数，但只使用一个来进行逻辑处理：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The *non-strict* Haskell-equivalent function declaration looks more like a
    variable assignment:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*非严格* Haskell 等效函数声明更像变量赋值：'
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This function also uses only its first argument and doesn’t evaluate the second
    argument, `y`, at all. That’s why the following Haskell code still yields a result:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数也仅使用其第一个参数，并且根本不评估第二个参数`y`。这就是为什么以下 Haskell 代码仍然产生结果：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you call the Java equivalent of this function with the same arguments, the
    value `1` and the expression `(1/0)`, it will throw an exception:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用相同的参数调用此函数的 Java 等效项，值为`1`和表达式`(1/0)`，它将抛出异常：
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Even though the second parameter of the `add` call isn’t used in any capacity,
    Java, as a *strict* language, evaluates the expression immediately. Method arguments
    are *passed-by-value*, which means they’re evaluated before being passed to the
    method, which in this case throws an `ArithmeticException`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 即使`add`调用的第二个参数在任何情况下都未被使用，作为*严格*语言的 Java 立即评估表达式。方法参数是*按值传递*的，这意味着它们在传递给方法之前会被评估，这在这种情况下会抛出`ArithmeticException`。
- en: Note
  id: totrans-16
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Java’s method arguments are always pass-by-value. In the case of non-primitive
    types, arguments are passed as *object-handles* by the JVM with a special type
    called `references`. These are technically still passed-by-value, making the general
    terminology and semantics quite confusing.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Java 的方法参数始终是按值传递的。对于非原始类型，在 JVM 中，参数作为*对象句柄*传递，使用一种称为`引用`的特殊类型。这在技术上仍然是按值传递，这使得一般术语和语义相当混乱。
- en: Conversely, lazy evaluation is defined as evaluating expressions only when their
    result is needed. That means the declaration of an expression doesn’t trigger
    its immediate evaluation, which makes Java lambda expressions the perfect match
    for lazy evaluation, as seen in [Example 11-1](#_02-lazy-evaluation_lazy).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，惰性评估被定义为仅在需要其结果时评估表达式。这意味着表达式的声明不会立即触发其评估，这使得 Java lambda 表达式成为惰性评估的完美匹配，正如在[示例 11-1](#_02-lazy-evaluation_lazy)中所见。
- en: Example 11-1\. Lazy Evaluation with Java and Suppliers
  id: totrans-19
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-1\. Java 和 Suppliers 实现的惰性评估
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The declaration of the `IntSupplier` instances, or their inline equivalents,
    is a strict statement and is evaluated immediately. The actual lambda body, however,
    doesn’t evaluate until it’s explicitly called with `getAsInt`, preventing the
    `ArithmeticException` in this case.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`IntSupplier` 实例的声明，或其内联等效项，是一个严格语句，并立即评估。然而，实际 lambda 体在没有显式调用`getAsInt`时不会评估，因此在这种情况下避免了`ArithmeticException`。'
- en: In essence, *strictness* is about “doing things,” but *laziness* is about “considering
    things to do.”
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，*严格性* 是关于“做事情”，但 *惰性* 是关于“考虑要做的事情”。
- en: How Strict Is Java?
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 有多严格？
- en: Most programming languages are neither fully lazy nor strict. Java is considered
    a strict language, but with some noteworthy lazy exceptions on a language level
    and in the available types of the JDK.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言既不是完全惰性也不是完全严格。Java 被认为是一种严格的语言，但在语言级别和 JDK 提供的类型中具有一些值得注意的惰性异常。
- en: Let’s go through them.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看它们。
- en: Short-Circuit Evaluation
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 短路求值
- en: Language-integrated laziness is available in Java in the form of the logical
    *short-circuit evaluation* with the logical operators `&&` (double ampersand)
    and `||` (double pipe) for `AND` and `OR`. These operators evaluate their operands
    left to right and only as required. If the logical expression is satisfied by
    the expression left of the operator, the right operand isn’t evaluated at all,
    as seen in [Table 11-1](#_02-lazy-evaluation_logical-operators_table).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Java 中提供了语言集成的惰性，采用逻辑运算符 `&&`（双与）和 `||`（双或）进行逻辑 *短路求值*。这些运算符从左到右评估其操作数，仅在必要时进行评估。如果逻辑表达式由运算符左侧的表达式满足，则根本不会评估右侧的操作数，如[表 11-1](#_02-lazy-evaluation_logical-operators_table)中所示。
- en: Table 11-1\. Evaluation of logical short-circuit operators
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11-1\. 逻辑短路运算符的评估
- en: '| Operations | Value of `leftExpr` | Is `rightExpr` evaluated? |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | `leftExpr` 的值 | 是否评估 `rightExpr`？ |'
- en: '| --- | --- | --- |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `leftExpr && rightExpr` | `true` | yes |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `leftExpr && rightExpr` | `true` | 是 |'
- en: '| `false` | no |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `false` | 否 |'
- en: '| `leftExpr &#124;&#124; rightExpr` | `true` | no |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `leftExpr &#124;&#124; rightExpr` | `true` | 否 |'
- en: '| `false` | yes |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `false` | 是 |'
- en: Bitwise Logical Operators
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 位运算逻辑运算符
- en: The similar bitwise operators `&` (single ampersand) and `|` (single pipe) evaluate
    *eagerly* and serve a different purpose than their logical brethren. Bitwise operators
    compare individual bits of integer types, resulting in an integer result.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的位运算符 `&`（单与）和 `|`（单或）进行 *急切评估*，并且具有与其逻辑兄弟不同的目的。位运算符比较整数类型的单个位，导致整数结果。
- en: Despite functioning similarly to a control structure, these logical operands
    can’t exist in a vacuum. They must always be part of another statement, like a
    condition for an `if`-block or a variable assignment, as seen in [Example 11-2](#_02-lazy-evaluation_logical-operators_existence).
    Another advantage of short-circuit evaluation for assignments is that they create
    (effectively) `final`⁠^([1](ch11.xhtml#idm45115222435312)) references, making
    them a perfect fit to use with Java’s functional approach.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管与控制结构类似，这些逻辑操作数不能单独存在。它们必须始终作为另一个语句的一部分，例如 `if`-block 的条件或变量赋值，如[示例 11-2](#_02-lazy-evaluation_logical-operators_existence)所示。对于赋值的短路求值的另一个优势是它们创建（实际上）`final`
    参考，使它们成为与 Java 的功能方法完美匹配的选择。
- en: Example 11-2\. Usage of logical short-circuit operators
  id: totrans-38
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-2\. 逻辑短路运算符的使用
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Omitting the evaluation of right-side operand evaluation is extremely helpful
    if the expression is costly or has any side effects, or doesn’t need to be evaluated
    if the left-side was. However, it also might be the source of not evaluating a
    required expression if the statement is short-circuited and the expression necessary
    is on the right side. If you make them a part of decision-making, make sure to
    design them carefully.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果表达式耗时或具有任何副作用，或者如果左侧无需评估则无需评估右侧表达式，则忽略右侧操作数的评估将非常有用。然而，它也可能是不评估所需表达式的来源，如果语句被短路，则需要的表达式在右侧。如果将它们作为决策的一部分，请务必仔细设计它们。
- en: Any decision-making code benefits immensely from pure functions. The intended
    behavior is straightforward and easily understandable, without any lurking side
    effects that might get unnoticed during redesigning or refactoring your code,
    introducing subtle bugs that are often hard to pin down. You should make sure
    that there are either no side effects at all, which in my opinion, is too absolute
    and generally an unrealistic goal, or name your methods to reflect their repercussions.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 任何决策性代码都会因为纯函数而受益匪浅。预期行为简单直接，易于理解，没有任何潜在的副作用可能在重新设计或重构代码时被忽视，引入难以解决的微妙错误。您应该确保要么根本没有副作用，我认为这太绝对且通常是不现实的目标，要么命名您的方法以反映其后果。
- en: Control Structures
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制结构
- en: Control structures are responsible for changing the path taken through the instructions
    of your code. An `if`-`else` construct, for example, is a conditional branch with
    one (`if`-only) or more (`if`-`else`) blocks of code. These blocks are only evaluated
    depending on their corresponding condition, which is a lazy trait. Strictly evaluating
    any part of an `if`-`else` construct on declaration would defeat its purpose of
    using it as a conditional branch. This “lazy exception to the eager rules” applies
    to all branching and loop structures, as listed in [Table 11-2](#_02-lazy-evaluation_control-structures-table).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 控制结构负责改变通过代码指令的路径。例如，`if`-`else`结构是一个条件分支，有一个（仅`if`）或多个（`if`-`else`）代码块。这些块根据其相应条件进行评估，这是一种惰性特性。在声明时严格评估`if`-`else`结构的任何部分将破坏其作为条件分支的目的。这种“怠惰例外于急切规则”的应用适用于所有分支和循环结构，如[表 11-2](#_02-lazy-evaluation_control-structures-table)所列。
- en: Table 11-2\. Lazy structures in Java
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 表11-2\. Java中的惰性结构
- en: '| Branching control structures | Looping structures |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 分支控制结构 | 循环结构 |'
- en: '| --- | --- |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `if`-`else` `? :` (ternary operator)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '| `if`-`else` `? :`（三元运算符）'
- en: '`switch`'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`'
- en: '`catch` | `for` `while`'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`catch` | `for` `while`'
- en: '`do-while` |'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`do-while` |'
- en: An absolutely strict language with non-lazy control structures is hard to imagine,
    if not impossible.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 严格的非惰性控制结构语言很难想象，甚至可能不可能。
- en: Lazy Types in the JDK
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JDK中的惰性类型
- en: So far, I’ve talked about how Java’s laziness was built directly into the language
    in the form of operators and control structures. The JDK, however, also provides
    multiple built-in types and data structures with a certain degree of laziness
    at runtime as well.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我已经讲述了Java的惰性如何直接内建到语言中，以操作符和控制结构的形式。然而，JDK还提供了多种内置类型和数据结构，在运行时也具有一定程度的惰性。
- en: Lazy Maps
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 惰性映射
- en: 'A common task for Maps is checking if a key already has a mapped value, and
    providing one if it’s missing. The related code requires multiple checks and non
    (effectively) `final` variables, as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 地图的常见任务是检查键是否已经有映射值，并在缺少时提供一个。相关的代码需要多次检查和非（有效地）`final`变量，如下所示：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The code might vary depending on the actual `Map` implementation, but the gist
    should be clear.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可能会因实际的`Map`实现而有所不同，但主要思想应该是清晰的。
- en: In general, this is already a lazy approach, delaying loading a user until necessary.
    In the course of retrofitting functional additions to many types in JDK 8, the
    `Map` type received a more concise and functional alternative with its `computeIf…​`
    methods.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，这已经是一种懒惰的方法，直到必要时才延迟加载用户。在JDK 8的多种类型中添加功能性增强的过程中，`Map`类型使用其`computeIf…​`方法获得了更简洁和功能性的替代方法。
- en: 'There are two methods available based on the existence of a mapped value for
    a key:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 根据键的映射值的存在性有两种可用的方法：
- en: '`V computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction)`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`V computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction)`'
- en: '`V computeIfPresent(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction)`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`V computeIfPresent(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction)`'
- en: 'The first one is an ideal replacement for the code of the previous example,
    as such:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方法是前一个示例代码的理想替代品，如下所示：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It requires the desired key as its first argument and a mapper `Function<K,
    V>` as its second argument that provides the new mapped value for the key if absent.
    The `computeIfPresent` is the antagonist for remapping values only if one’s present.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 它需要所需的键作为其第一个参数，并且需要一个映射器`Function<K, V>`作为其第二个参数，如果键不存在，则为其提供新的映射值。`computeIfPresent`是仅在存在时重新映射值的对手。
- en: A combination of both methods is also available in the form of the `V compute(K
    key, BiFunction<? super K, ? super V, ? extends V> remappingFunction)` method.
    It’s able to update and even delete mapped values depending on the result of the
    `remapping` function, as illustrated in [Figure 11-1](#_02-lazy-evaluation_map-compute).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以以`V compute(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction)`方法的形式结合两种方法。它能够根据`remapping`函数的结果更新甚至删除映射值，如[图 11-1](#_02-lazy-evaluation_map-compute)所示。
- en: '![Lazy remapping with Map#compute](assets/afaj_1101.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![Map#compute进行延迟重映射](assets/afaj_1101.png)'
- en: Figure 11-1\. Lazy remapping with Map#compute
  id: totrans-67
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11-1\. 使用Map#compute进行延迟重映射
- en: The general theme of a functional approach is clearly visible in Maps’ lazy
    additions. Instead of requiring you to write the verbose and repetitive code of
    *how* to work with the Map and its mapped values, now you can concentrate on *what*
    is happening and how to deal with keys and values.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式方法的一般主题在 Maps 的惰性添加中清晰可见。现在，不再需要编写冗长和重复的代码来 *处理* Map 及其映射值，而是可以集中精力于 *发生什么*
    以及如何处理键和值。
- en: Streams
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Streams
- en: Java Streams are the perfect example of lazy functional pipelines. You can define
    an intricate Stream scaffold filled with expensive functional operations that
    will only start evaluation after calling a terminal operation. The number of processed
    elements solely depends on the design of the pipeline, allowing you to minimize
    the required work as much as possible by separating the definition of an expression
    and its actual evaluation in a data processing pipeline.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Java Streams 是惰性功能流水线的完美示例。您可以定义一个复杂的 Stream 框架，其中包含昂贵的功能操作，这些操作只有在调用终端操作后才开始评估。处理的元素数量完全取决于管道设计，通过将表达式的定义与其实际评估分开，在数据处理管道中最大限度地减少所需的工作。
- en: '[Chapter 6](ch06.xhtml#_02-data-processing) explains Streams and their lazy
    approach to data processing in detail.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[第六章](ch06.xhtml#_02-data-processing) 详细解释了 Streams 及其对数据处理的惰性方法。'
- en: Optionals
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Optionals
- en: Optionals are a non-lazy way of handling `null` values. Their general approach
    is similar to Streams, but they evaluate strictly compared to Streams. There are
    lazy operations available, for example, the `T orElseGet(Supplier<? extends T>
    supplier)` method that utilizes a `Supplier` to delay the execution to when it’s
    absolutely necessary.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Optionals 是处理 `null` 值的一种非惰性方式。它们的一般方法类似于 Streams，但相对于 Streams，它们是严格评估的。有一些延迟操作可用，例如使用
    `Supplier` 的 `T orElseGet(Supplier<? extends T> supplier)` 方法，将执行延迟到绝对必要时。
- en: '[Chapter 9](ch09.xhtml#_02-optionals) gives a detailed introduction to Optionals
    and more information on how to use them.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[第九章](ch09.xhtml#_02-optionals)详细介绍了 Optionals，以及如何使用它们的更多信息。'
- en: Lambdas and Higher-Order Functions
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambdas 和高阶函数
- en: Lambdas are a great way to introduce laziness on a code level. Their declaration
    is a statement and, therefore, strictly evaluated. Their body — the *single abstract
    method* --⁠, however, encapsulates the actual logic and evaluates at your discretion.
    That makes them a simple way to store and transfer expressions for later evaluation.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Lambdas 是在代码层面引入惰性的好方法。它们的声明是一个语句，因此是严格评估的。它们的主体——*单抽象方法*——封装了实际的逻辑，并在您的决定下进行评估。这使它们成为存储和传输表达式以供以后评估的简单方法。
- en: Let’s look at some eager code for providing an argument to a method and how
    it can be made lazy with the help of lambdas.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些急切的代码，为方法提供参数，并展示如何利用 lambda 使其变为惰性。
- en: An Eager Approach
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个急切的方法
- en: In [Example 11-3](#_01-laziness_eager), a hypothetical `User` is updated with
    a list of roles. The update isn’t always done and depends on the inner logic of
    the `update` method. The arguments are provided *eagerly*, requiring a pretty
    expensive lookup call through the *DAO*⁠^([2](ch11.xhtml#idm45115222180992)).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [示例 11-3](#_01-laziness_eager) 中，一个假想的 `User` 被一系列角色更新。这种更新并非总是发生，而是取决于 `update`
    方法的内部逻辑。参数是 *急切* 提供的，需要通过 *DAO*⁠^([2](ch11.xhtml#idm45115222180992)) 进行昂贵的查找调用。
- en: Example 11-3\. Updating a `User` with eager method arguments
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-3\. 使用急切方法参数更新 `User`
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[![1](assets/1.png)](#co_lazy_evaluation_CO1-1)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_lazy_evaluation_CO1-1)'
- en: The `updateUser` method requires the `user` and a list of all available roles.
    The update itself depends on the inner logic and might not need the roles after
    all.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`updateUser` 方法需要 `user` 和所有可用角色的列表。更新本身依赖内部逻辑，可能实际上并不需要这些角色。'
- en: '[![2](assets/2.png)](#co_lazy_evaluation_CO1-2)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_lazy_evaluation_CO1-2)'
- en: The `loadAllAvailableRoles(user)` is called regardless of the `updateUser` method
    requiring the roles. This results in a costly trip to the database that might
    be unnecessary.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadAllAvailableRoles(user)` 被调用，无论 `updateUser` 方法是否需要角色。这导致了一个可能是不必要的昂贵的数据库访问。'
- en: '[![3](assets/3.png)](#co_lazy_evaluation_CO1-3)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_lazy_evaluation_CO1-3)'
- en: All arguments are already evaluated at the time of the method call.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 所有参数在方法调用时已经评估完成。
- en: Providing `updateUser` with the roles, even if they aren’t necessary for every
    use-case, creates unnecessary database calls and wastes performance.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在每种用例中角色并非必需，为 `updateUser` 提供角色会导致不必要的数据库调用和性能浪费。
- en: So how can you make the call non-mandatory if it’s not always required? By introducing
    laziness.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 那么如果这个调用并不总是必需的，你如何使它成为非强制性的呢？通过引入惰性。
- en: A Lazier Approach
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更懒的方法
- en: In a strict language like Java, all method arguments are provided upfront and
    as-is. The method has no choice but to accept them, even if an argument isn’t
    actually needed. This is especially a problem when it comes to executing expensive
    operations to create such arguments beforehand, such as database calls, which
    can be a drain on your available resources and performance.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在像Java这样严格的语言中，所有方法参数都是提前提供的。即使一个参数实际上并不需要，方法也别无选择而必须接受它们。这在涉及执行昂贵的操作来预先创建这些参数（例如数据库调用）时尤为成问题，这可能会消耗您可用的资源和性能。
- en: 'The naïve approach to remedy unnecessary database calls is to change `updateUser`
    to accept the DAO directly, so it can only use it if necessary:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 解决不必要的数据库调用的幼稚方法是将`updateUser`更改为直接接受DAO，因此只有在必要时才能使用它：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `updateUser` method now has all the tools necessary to load the available
    roles by itself. On a superficial level, the initial problem of non-lazy data
    access is solved, but this “solution” creates a new problem: cohesion.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`updateUser`方法具有加载可用角色所需的所有工具。从表面上看，非惰性数据访问的初始问题得到了解决，但这种“解决方案”却引发了一个新的问题：内聚性。
- en: The `updateUser` method now uses the DAO directly and is no longer isolated
    from *how* the roles are acquired. This approach will make the method *impure*,
    as accessing the database is considered a side-effect and makes it harder to verify
    and test. Thanks to possible API boundaries, it gets even more complicated if
    the `updateUser` method doesn’t know the DAO type at all. So you need to create
    another abstraction to retrieve the roles. Instead of creating an additional abstract
    layer to bridge the gap between the DAO and the `updateUser` method, you can make
    `updateUser` a higher-order function and accept a lambda expression.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`updateUser`方法直接使用DAO，并不再与角色获取方式隔离。这种方法会使方法变得不纯，因为访问数据库被视为副作用，并使得验证和测试变得更加困难。如果`updateUser`方法根本不知道DAO类型，可能的API边界会使情况变得更加复杂。因此，您需要创建另一个抽象来检索角色。与创建一个额外的抽象层来弥合DAO和`updateUser`方法之间的差距不同，您可以将`updateUser`变成高阶函数并接受一个lambda表达式。
- en: A Functional Approach
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个功能性的方法
- en: To create a functional abstraction for the retrieving of the required user roles
    in [Example 11-3](#_01-laziness_eager), you must first dissect the problem into
    a more abstract representation, finding out *what* is actually needed as an argument
    and not *how* the argument’s value came to be.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要为在[示例 11-3](#_01-laziness_eager)中检索所需用户角色的功能抽象化，首先必须将问题分解为更抽象的表示，找出实际需要作为参数的内容，而不是如何获得参数值。
- en: The `updateUser` method needs access to the available roles, as it is reflected
    in the original method signature. And that’s exactly the point in your code where
    introducing laziness will give you the most flexible solution.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`updateUser`方法需要访问可用角色，这反映在原始方法签名中。这正是在代码中引入惰性将为您提供最灵活的解决方案的地方。'
- en: The `Supplier<T>` type is the most low-level possibility to encapsulate certain
    logic to retrieve a value at your discretion. Instead of providing `updateUser`
    directly with the DAO, a lambda expression is the lazy intermediate construct
    for loading the roles, as seen in [Example 11-4](#_01-laziness_lazy).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`Supplier<T>`类型是封装某些逻辑以按您的意愿检索值的最低级别可能性。与直接向`updateUser`提供DAO不同，lambda表达式是惰性中间构造，用于加载角色，正如[示例 11-4](#_01-laziness_lazy)中所见。'
- en: Example 11-4\. Updating a `User` with a lambda
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-4\. 使用lambda更新`User`
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[![1](assets/1.png)](#co_lazy_evaluation_CO2-1)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_lazy_evaluation_CO2-1)'
- en: The `updateUser` method signature has to be changed to accept a `Supplier<List<Role>>`
    instead of the already loaded `List<Role>` or the DAO itself.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`updateUser`方法签名必须更改为接受`Supplier<List<Role>>`，而不是已加载的`List<Role>`或DAO本身。'
- en: '[![2](assets/2.png)](#co_lazy_evaluation_CO2-2)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_lazy_evaluation_CO2-2)'
- en: The logic of how to acquire the roles is now encapsulated in a method reference.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如何获取角色的逻辑已封装在一个方法引用中。
- en: Making `updateUser` a higher-order function by accepting a `Supplier` creates
    a superficial new layer without requiring an additional custom type wrapping the
    role-loading process.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通过接受`Supplier`将`updateUser`变成高阶函数，可以创建一个表面上的新层，而无需额外的自定义类型来包装角色加载过程。
- en: 'Using the `DAO` directly as an argument eliminates the downsides:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 直接将`DAO`作为参数使用可以消除这些不利因素：
- en: There’s no longer a connection between the `DAO` and the `updateUser` method,
    creating the possibility of a pure, side-effect-free method.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DAO`和`updateUser`方法之间不再存在连接，从而可能产生一个纯粹的、无副作用的方法。'
- en: You don’t need an additional type to represent the abstraction. The already
    available `Supplier<T>` functional interface is the simplest and most compatible
    form of abstraction possible.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不需要额外的类型来表示这个抽象。已经可用的`Supplier<T>`函数接口是可能的最简单和最兼容的抽象形式。
- en: Testability is restored without requiring the possibly complicated mocking of
    a DAO.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以恢复测试性，而不需要可能复杂的DAO的模拟。
- en: Costly operations, like database queries, can benefit immensely from a lazy
    approach if the call is avoidable. That doesn’t mean, though, that making all
    method arguments lazy without a real need is the right approach, either. There
    are other solutions, too, like caching the result of costly calls, that might
    be simpler to use than designing your method calls to accept lazy arguments.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 昂贵的操作，比如数据库查询，如果调用可以避免，可以极大地从延迟执行中受益。但这并不意味着，没有真正的需要，就将所有方法参数都延迟执行是正确的方法。还有其他解决方案，比如缓存昂贵调用的结果，可能比设计方法调用来接受延迟参数更简单。
- en: Delayed Executions with Thunks
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用**Thunk**进行延迟执行
- en: 'Lambda expressions are a simple and low-level way to encapsulate an expression
    for later evaluation. One missing thing, though, is storing the result after evaluation — *memoization* — so
    you don’t re-evaluate an expression if called twice. There’s an easy way to remedy
    this omission: *Thunks*.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式是封装表达式以供以后评估的一种简单而低级的方式。不过，有一件事情是缺失的，那就是在评估后存储结果 — *记忆化* — 这样如果调用两次就不需要重新评估表达式了。有一种简单的方法可以弥补这个缺失：**Thunk**。
- en: A Thunk is a wrapper around a computation that is delayed until the result is
    needed. Unlike a `Supplier<T>`, which also delays a computation, a Thunk only
    evaluates once and directly returns the result on subsequent calls.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 **Thunk** 是一个对计算进行包装的延迟执行，直到需要结果为止。与`Supplier<T>`不同，后者也延迟执行计算，但 **Thunk**
    仅在第一次评估后直接返回结果，并在后续调用中不再进行评估。
- en: 'Thunks fall into the general category of *lazy loading/initialization*, a design
    pattern often found in object-oriented code. Both techniques — lazy loading and
    lazy initialization — are similar mechanisms for achieving the same goal: non-strict
    evaluation and caching the result. Where a `Supplier<T>` just defers the evaluation,
    a Thunk also caches its result.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**Thunk** 属于*延迟加载/初始化*的一般类别，这是在面向对象的代码中经常发现的设计模式。延迟加载和延迟初始化两种技术都是实现相同目标的类似机制：非严格评估和缓存结果。`Supplier<T>`只是延迟评估，而
    **Thunk** 也缓存其结果。'
- en: Let’s create a simple Thunk that follows the *virtual proxy* design-pattern^([3](ch11.xhtml#idm45115221832208))
    to be a drop-in replacement for `Supplier<T>`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的 **Thunk** ，遵循*虚拟代理*设计模式^([3](ch11.xhtml#idm45115221832208))以成为`Supplier<T>`的可替换解决方案。
- en: Creating a Simple Thunk
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个简单的 **Thunk**
- en: The most straightforward approach is wrapping a `Supplier<T>` instance and storing
    its result after its first evaluation. By also implementing the `Supplier<T>`
    interface, the Thunk becomes a drop-in replacement, as shown in [Example 11-5](#_01-lazy_thunk_01).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是包装一个`Supplier<T>`实例，并在第一次评估后存储其结果。通过还实现`Supplier<T>`接口， **Thunk** 变成了一个可替换的解决方案，如[示例11-5](#_01-lazy_thunk_01)所示。
- en: Example 11-5\. A simple `Thunk<T>`
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-5\. 一个简单的`Thunk<T>`
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[![1](assets/1.png)](#co_lazy_evaluation_CO3-1)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_lazy_evaluation_CO3-1)'
- en: '`Thunk<T>` implements `Supplier<T>` to serve as a drop-in replacement.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thunk<T>`实现了`Supplier<T>`以充当一种可替换的解决方案。'
- en: '[![2](assets/2.png)](#co_lazy_evaluation_CO3-2)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_lazy_evaluation_CO3-2)'
- en: The actual `Supplier<T>` needs to be stored to delay evaluation.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的`Supplier<T>`需要存储以延迟评估。
- en: '[![3](assets/3.png)](#co_lazy_evaluation_CO3-3)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_lazy_evaluation_CO3-3)'
- en: The result must be stored after evaluation.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 必须在评估后存储结果。
- en: '[![4](assets/4.png)](#co_lazy_evaluation_CO3-4)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_lazy_evaluation_CO3-4)'
- en: If not evaluated yet, the expression gets resolved, and its result is stored.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尚未评估，则解析表达式，并存储其结果。
- en: '[![5](assets/5.png)](#co_lazy_evaluation_CO3-5)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_lazy_evaluation_CO3-5)'
- en: A convenience factory method to create a `Thunk` without needing `new` or generic
    type information, so the only constructor can be `private`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一个方便的工厂方法，用于创建一个`Thunk`，而不需要`new`或泛型类型信息，所以唯一的构造函数可以是`private`。
- en: '[![6](assets/6.png)](#co_lazy_evaluation_CO3-6)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_lazy_evaluation_CO3-6)'
- en: No need to create a `Thunk<T>` for a `Thunk<T>`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要为`Thunk<T>`创建一个`Thunk<T>`。
- en: 'This Thunk implementation is simple yet powerful. It adds memoization by calling
    a factory method with any `Supplier<T>` to create a drop-in replacement. Updating
    a `User`, like in the previous section, requires wrapping the method reference
    in the `Thunk.of` method:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这种Thunk实现简单而强大。通过使用任何`Supplier<T>`调用工厂方法添加记忆功能，以创建一个可替换的组件。像前一节中更新`User`那样，需要将方法引用包装在`Thunk.of`方法中：
- en: '[PRE12]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The functional additions to `Thunk<T>` don’t have to stop here. You can easily
    add “glue methods,” as I discussed in [Chapter 2](ch02.xhtml#_01-functional-java),
    to support functional composition, as shown in [Example 11-6](#_01-lazy_thunk_02)
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Thunk<T>`的功能性增强并不止于此。您可以轻松添加“粘合方法”，正如我在[第2章](ch02.xhtml#_01-functional-java)中讨论的那样，以支持函数组合，如[Example 11-6](#_01-lazy_thunk_02)所示。
- en: Example 11-6\. Functional additions to `Thunk<T>`
  id: totrans-136
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-6。对`Thunk<T>`的功能性增强
- en: '[PRE13]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[![1](assets/1.png)](#co_lazy_evaluation_CO4-1)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_lazy_evaluation_CO4-1)'
- en: Factory method for creating a `Thunk<T>` of a single value instead of an `Supplier<T>`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`Thunk<T>`的工厂方法，用于创建单个值，而不是`Supplier<T>`。
- en: '[![2](assets/2.png)](#co_lazy_evaluation_CO4-2)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_lazy_evaluation_CO4-2)'
- en: Creates a new `Thunk<R>` including the `mapper` function.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包括`mapper`函数的新的`Thunk<R>`。
- en: '[![3](assets/3.png)](#co_lazy_evaluation_CO4-3)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_lazy_evaluation_CO4-3)'
- en: Creates a new `Thunk<R>` from a function that returns a+Thunk<T>+ without needlessly
    wrapping it in another `Thunk`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 从返回a+Thunk<T>+的函数创建一个新的`Thunk<R>`，而不需要无谓地将其包装在另一个`Thunk`中。
- en: '[![4](assets/4.png)](#co_lazy_evaluation_CO4-4)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_lazy_evaluation_CO4-4)'
- en: Consumes a Thunks’ result.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 消耗一个Thunk的结果。
- en: With the addition of “glue” methods, the `Thunk<T>` type becomes a more versatile
    utility type for creating lazy pipelines for single expressions.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加“粘合”方法，`Thunk<T>`类型变得更加多功能，用于创建单表达式的惰性管道。
- en: 'One general problem remains, though: *thread-safety*.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还存在一个一般性问题：*线程安全*。
- en: A Thread-Safe Thunk
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程安全的Thunk
- en: For single-threaded environments, the `Thunk<T>` implementation I discussed
    in the previous section works as intended. However, if it’s accessed from another
    thread while the expression evaluates, a race condition might lead to re-evaluation.
    The only way to prevent this is to synchronize it across all accessing threads.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单线程环境，在前一节中讨论的`Thunk<T>`实现可以正常工作。但是，如果在表达式评估时从另一个线程访问它，可能会导致竞态条件重新评估。唯一可以防止这种情况发生的方法是在所有访问线程中同步它。
- en: The most straightforward approach would be to add the keyword `synchronized`
    to its `get` method. However, it has the obvious downside of *always* requiring
    `synchronized` access and the associated overhead, even if the evaluation is already
    finished. Synchronization might not be as slow as it used to be, but it’s still
    an overhead for *every* call to the `get` method and definitely will slow down
    your code unnecessarily.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最直接的方法是将关键字`synchronized`添加到其`get`方法中。然而，这样做的明显缺点是*始终*需要`synchronized`访问以及相关的开销，即使评估已经完成。同步可能不像过去那样慢，但对于每次调用`get`方法来说仍然是一种开销，并且肯定会不必要地减慢代码速度。
- en: So how do you change the implementation to eliminate the race condition without
    affecting the overall performance more than necessary? You do a risk analysis
    of *where* and *when* a race condition can occur.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，您如何改变实现以消除竞态条件，同时又尽可能不影响总体性能？您需要对*何时*和*何处*竞态条件可能发生进行风险分析。
- en: The risk of the evaluation-related race condition exists only until the expression
    is evaluated. After that, no double evaluation can happen, as the result is returned
    instead. That allows you to only synchronize the evaluation itself, not each call
    to the `get` method.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 评估相关的竞态条件风险仅存在于表达式评估之前。之后，不会发生双重评估，因为结果已返回。这使您只需同步评估本身，而不是每次调用`get`方法。
- en: '[Example 11-7](#_01-lazy_think-cas-01) shows the introduction of a dedicated
    and `synchronized` `evaluate` method. The actual implementation of it, and how
    to access its result will be explained shortly.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[Example 11-7](#_01-lazy_think-cas-01)展示了引入专门的和`synchronized`的`evaluate`方法。将会很快解释它的实际实现及如何访问其结果。'
- en: Example 11-7\. `Thunk<T>` with synchronized evaluation
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-7。带有同步评估的`Thunk<T>`
- en: '[PRE14]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The previous version of the `Thunk` used an additional field, `value`, to determine
    if the `expression` was already evaluated. The new, thread-safe variant, however,
    replaces the stored `value` and its checks with a dedicated abstraction that holds
    the value, as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 先前版本的`Thunk`使用了额外的`value`字段来确定`expression`是否已经评估。然而，新的线程安全变体用专用的抽象替换了存储的`value`及其检查，其持有值，如下所示：
- en: '[PRE15]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `Holder<T>` does two things:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`Holder<T>`执行两件事：'
- en: Hold the evaluated value
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持有评估值
- en: Implement `Supplier<T>`
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现`Supplier<T>`
- en: Thanks to being a drop-in replacement for the field `expression`, a technique
    known as *compare & swap* (CAS). It’s used for designing concurrent algorithms,
    by comparing the value of a variable with an expected value, and if they are equal,
    swapping out the value for the new value. The operation has to be *atomic*, meaning
    it’s all-or-nothing for accessing the underlying data. That’s why the `evaluate`
    method has to be `synchronized`. Any thread can either see the data before or
    after, but never in-between evaluation and, therefore, eliminating the race condition.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 由于作为`expression`字段的插拔式替换，一种称为*比较与交换*（CAS）的技术得以实现。它用于设计并发算法，通过将变量的值与期望值进行比较，如果它们相等，则将该值交换为新值。该操作必须是*原子的*，这意味着访问底层数据要么完全成功，要么完全失败。这就是为什么`evaluate`方法必须是`synchronized`的原因。任何线程都可以在评估之前或之后看到数据，但从不会在评估过程中，从而消除竞态条件。
- en: In [Example 11-8](#_01-lazy_think-cas-02), you see a CAS implementation of `evaluate`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 11-8](#_01-lazy_think-cas-02)中，您可以看到`evaluate`的CAS实现。
- en: Now, the `private` field +expression can be replaced by the new type, as shown
    in [Example 11-7](#_01-lazy_think-cas-01).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`private`字段`+expression`可以被新类型替换，如[示例 11-7](#_01-lazy_think-cas-01)所示。
- en: Example 11-8\. Using `Holder<T>` instead of `Supplier<T>`
  id: totrans-164
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-8。使用`Holder<T>`而不是`Supplier<T>`
- en: '[PRE16]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[![1](assets/1.png)](#co_lazy_evaluation_CO5-1)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_lazy_evaluation_CO5-1)'
- en: The field gets renamed to better reflect its usage, and also made non-`final`,
    as it has swapped out after the expression is evaluated.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 该字段被重命名以更好地反映其用途，并且在表达式评估后也被设置为非`final`。
- en: '[![2](assets/2.png)](#co_lazy_evaluation_CO5-2)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_lazy_evaluation_CO5-2)'
- en: The expression only gets evaluated if the `holder` field currently isn’t a `Holder`
    instance, but the expression created in the constructor.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当`holder`字段当前不是`Holder`实例时，表达式才会被评估，而是在构造函数中创建的表达式。
- en: '[![3](assets/3.png)](#co_lazy_evaluation_CO5-3)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_lazy_evaluation_CO5-3)'
- en: The `holder` field, at this point holding the original lambda to evaluate the
    initial expression, gets swapped out for a `Holder` instance with the evaluated
    result.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，`holder`字段持有原始的lambda表达式以评估初始表达式，并将其替换为带有评估结果的`Holder`实例。
- en: '[![4](assets/4.png)](#co_lazy_evaluation_CO5-4)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_lazy_evaluation_CO5-4)'
- en: The un-`synchronized` `get` method uses the `holder` field directly to access
    the value, as it always references a `Supplier`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 非`synchronized`的`get`方法直接使用`holder`字段访问值，因为它总是引用一个`Supplier`。
- en: The improved `Thunk<T>` implementation isn’t as simple as before, but it eliminates
    the race condition by decoupling the evaluation of the expression from accessing
    it.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 改进后的`Thunk<T>`实现不再像以前那样简单，但通过将表达式的评估与访问解耦，消除了竞态条件。
- en: On first access, the `holder` field will call `evaluate`, which is `synchronized`,
    and therefore thread-safe. Any additional calls while the expression is evaluated
    will call to `evaluate`, too. Instead of a re-evaluation, the type-check of the
    `holder` field skips directly to returning the result of `this.holder.get()`.
    Any access after the `holder` is re-assigned will skip any `synchronized` entirely.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 首次访问时，`holder`字段将调用`synchronized`的`evaluate`方法，因此是线程安全的。在评估表达式时，任何额外的调用也将调用`evaluate`方法。而不是重新评估，`holder`字段的类型检查直接跳过，返回`this.holder.get()`的结果。在重新分配`holder`之后的任何访问都将完全跳过任何`synchronized`。
- en: That’s it, you now have a thread-safe, lazily evaluated `Supplier<T>` drop-in
    that only evaluates once.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，您现在拥有一个线程安全的、惰性评估的`Supplier<T>`插入，只评估一次。
- en: Our `Thunk` implementation uses `synchronized`, but there are multiple approaches
    to implementing a *compare & swap* algorithm. The same general behavior can be
    accomplished using one of the `java.util.concurrent.atomic.Atomic…​` types in
    the JDK, or even use a `ConcurrentHashMap#computeIfAbsent` to prevent the race
    condition. The book “Java Concurrency” by Brian Goetz^([4](ch11.xhtml#idm45115220668960))
    provides a good starting point for better understanding atomic variables, non-blocking
    synchronization, and Java’s concurrency model in general.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Thunk`实现使用`synchronized`，但有多种实现*比较与交换*算法的方法。可以使用JDK中的`java.util.concurrent.atomic.Atomic…​`类型之一，或者甚至使用`ConcurrentHashMap#computeIfAbsent`来防止竞态条件。Brian
    Goetz的书籍“Java Concurrency”^([4](ch11.xhtml#idm45115220668960))为更好理解原子变量、非阻塞同步和Java的并发模型提供了一个良好的起点。
- en: Final Thoughts on Laziness
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 惰性的最终思考
- en: At its core, the idea of laziness boils down to deferring required work until
    a point in time when it’s indispensable. The separation of *creating* and *consuming*
    expressions gives you a new axis of modularity in your code. This approach can
    improve performance immensely if an operation is optional and not required for
    each use case. Lazy evaluation also means, though, that you have to give up a
    certain degree of control over the exact time of evaluation.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，惰性的核心思想是推迟所需的工作，直到它变得不可或缺的时刻。将*创建*和*消耗*表达式分离给了您的代码一个新的模块化轴线。如果一个操作是可选的，并且不是每种用例都需要，这种方法可以极大地提高性能。然而，惰性评估也意味着您必须放弃对评估确切时间的某种程度控制。
- en: The perceived and actual *loss of control* makes it much harder to reason about
    the required performance and memory characteristics of your code. The total performance
    requirement is the sum of all evaluated parts. Eager evaluation allows for quite
    linear and compositional performance assessment. Laziness shifts the actual computational
    cost from where expressions are defined to when they are used, with the possibility
    of code not being run at all. That’s why idiomatic lazy performance is harder
    to assess because the perceived performance would most likely improve immediately
    compared to eager evaluation, especially if your code has many costly but maybe
    optional code paths. The total performance requirements may vary on the general
    context and what code is actually evaluated. You’d have to analyze your lazy code’s
    “average” usage patterns and estimate the performance characteristics required
    under different scenarios, making straightforward benchmarking quite hard.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 感知和实际*控制丧失*使得对代码所需性能和内存特性的推理变得更加困难。总体性能需求是所有评估部分的总和。急切评估允许相当线性和组合性能评估。惰性将实际的计算成本从表达式定义的地方转移到使用它们的时候，有可能根本不运行代码。这就是为什么习惯性的惰性性能更难评估，因为与急切评估相比，感知的性能可能会立即改善，特别是如果您的代码有许多昂贵但可能是可选的代码路径。总体性能需求可能会根据一般情况和实际评估的代码而变化。您必须分析您的惰性代码的“平均”使用模式，并在不同场景下估计所需的性能特性，使得直接的基准测试变得非常困难。
- en: Software development is a constant battle of *effectively utilizing scarce resources*
    to reach the desired, or required, performance. Lazy techniques, like delayed
    evaluation, or Streams for data processing, are low-hanging fruits^([5](ch11.xhtml#idm45115220665120))
    to improve your code’s performance that is easy to integrate into an existing
    codebase. It definitely will reduce the required work to a minimum, maybe even
    zero, freeing up precious performance for other tasks. If some expression or costly
    computation can be avoided, making it lazy will most definitely be a worthwhile
    endeavor in the long run.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发是一个持续的战斗，要*有效利用稀缺资源*以达到所需或必需的性能。像延迟评估或数据处理中的流这样的惰性技术，是改进代码性能的低成本^([5](ch11.xhtml#idm45115220665120))，易于集成到现有代码库中的有效方法。它绝对会将所需工作降至最低，甚至可能为其他任务释放宝贵的性能。如果可以避免某些表达式或昂贵的计算，将其设为惰性绝对是一项值得长远努力的事业。
- en: Takeaways
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Strict evaluation means expressions and method arguments evaluate immediately
    on declaration.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 严格评估意味着表达式和方法参数在声明时立即评估。
- en: Lazy evaluation separates *creating* and *consuming* expressions by deferring
    their evaluation until their result is necessary, maybe even not evaluating them
    at all.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 惰性评估通过推迟或甚至完全不评估表达式的结果，将*创建*和*消耗*表达式分离，从而实现。
- en: '*Strictness* is about “doing things”; *laziness* is about “considering things
    to do.”'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*严格性*是关于“做事情”; *惰性*是关于“考虑要做的事情”。'
- en: Java is a “strict” language regarding expressions and method arguments, although
    certain *lazy* operators and control structures exist.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 在表达式和方法参数方面是一种“严格”的语言，尽管存在某些 *惰性* 操作符和控制结构。
- en: Lambas encapsulate expressions, making them lazy wrappers to be evaluated at
    your discretion.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambas 封装表达式，使它们成为可在您自行决定时进行评估的惰性包装器。
- en: The JDK has several lazy runtime constructs and helper methods. For example,
    Streams are lazy functional pipelines, `Optional` and `Map` provide *lazy* additions
    to their general interfaces.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDK 中有多个懒加载运行时结构和辅助方法。例如，流（Streams）是惰性的功能管道，`Optional` 和 `Map` 在其一般接口中提供了 *惰性*
    的扩展。
- en: The `Supplier<T>` interface is the simplest way to create a lazy calculation.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Supplier<T>` 接口是创建延迟计算的最简单方式。'
- en: Memoization, in the form of a `Thunk`, helps to avoid re-evaluation and can
    be used as a drop-in replacement for `Supplier<T>`.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Memoization，以 `Thunk` 的形式，有助于避免重新评估，可以用作 `Supplier<T>` 的即插即用替代方案。
- en: Laziness is a performance optimization powerhouse. The best code is the one
    that’s not run at all. The next best alternative is to run it only lazily “on-demand.”
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 懒加载是性能优化的重要手段。最好的代码是根本不运行的代码。其次好的选择是仅在“按需”时运行它。
- en: The assessment of performance requirements for lazy code is difficult and might
    conceal performance problems if tested in environments not matching a “real-world”
    use case.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于延迟代码的性能需求评估较为困难，如果在不符合“真实世界”使用情况的环境中进行测试，可能会掩盖性能问题。
- en: ^([1](ch11.xhtml#idm45115222435312-marker)) See [“Effectively final”](ch02.xhtml#_01-functions_lambdas_effectively-final)
    for the definition and requirements of *effectively* `final` variables.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch11.xhtml#idm45115222435312-marker)) 参见[“有效地 final”](ch02.xhtml#_01-functions_lambdas_effectively-final)以了解
    *有效* `final` 变量的定义和要求。
- en: ^([2](ch11.xhtml#idm45115222180992-marker)) A *DAO* (data access object) is
    a pattern to provide an abstract interface to a persistence layer like a database.
    It translates application calls to specific operations on the underlying persistence
    layer without exposing details of it.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch11.xhtml#idm45115222180992-marker)) *DAO*（数据访问对象）是一种模式，提供了与数据库等持久化层的抽象接口。它将应用程序调用转换为对底层持久化层特定操作的操作，而不会暴露其详细信息。
- en: ^([3](ch11.xhtml#idm45115221832208-marker)) Wikipedia entry on [proxies](https://en.wikipedia.org/wiki/Proxy_pattern)
    provides an overview of the different kinds of proxies and their usage.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch11.xhtml#idm45115221832208-marker)) 维基百科关于[代理模式](https://zh.wikipedia.org/wiki/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F)提供了不同种类代理及其用途的概述。
- en: ^([4](ch11.xhtml#idm45115220668960-marker)) Goetz, Brian. 2006\. “Java Concurrency
    in Practice.” Addison-Wesley. ISBN 978-0321349606.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch11.xhtml#idm45115220668960-marker)) Brian Goetz. 2006年. “Java并发编程实践.”
    Addison-Wesley. ISBN 978-0321349606.
- en: ^([5](ch11.xhtml#idm45115220665120-marker)) The concept of a *low-hanging fruit*
    describes a goal that is easy to achieve or taken advantage of, compared to the
    alternatives, like re-designing or refactoring your whole codebase.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch11.xhtml#idm45115220665120-marker)) “低 hanging fruit” 的概念描述了一个易于实现或利用的目标，相比于重新设计或重构整个代码库的替代方案。
