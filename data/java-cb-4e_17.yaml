- en: Chapter 17\. Reflection, or “A Class Named Class”
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第17章 反射，或“一个名为Class的类”
- en: 17.0 Introduction
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 17.0 简介
- en: The class `java.lang.Class` and the reflection package `java.lang.reflect` provide
    a number of mechanisms for gathering information from the Java Virtual Machine.
    Known collectively as *reflection*, these facilities allow you to load classes
    on the fly, to find methods and fields in classes, to generate listings of them,
    and to invoke methods on dynamically loaded classes. There is even a mechanism
    to let you construct a class from scratch (well, actually, from an array of bytes)
    while your program is running. This is about as close as Java lets you get to
    the magic, secret internals of the Java machine.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 类`java.lang.Class`和反射包`java.lang.reflect`提供了许多机制，用于从Java虚拟机中收集信息。这些设施被统称为*反射*，允许您在运行时动态加载类，查找类中的方法和字段，生成它们的列表，并调用动态加载类的方法。甚至有一种机制可以让您在程序运行时从头开始构造一个类（实际上是从字节的数组）。这是Java让您接近其神奇、秘密的内部机制的方式。
- en: The JVM itself is a large program, normally written in C and/or C++, that implements
    the Java Virtual Machine abstraction. You can get the source for OpenJDK and other
    JVMs via the internet, which you could study for months. Here we concentrate on
    just a few aspects, and only from the point of view of a programmer using the
    JVM’s facilities, not how it works internally; that is an implementation detail
    that could vary from one vendor’s JVM to another.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: JVM本身是一个大型程序，通常用C和/或C++编写，实现Java虚拟机抽象。您可以通过互联网获取OpenJDK和其他JVM的源代码，这可能需要几个月的学习时间。在这里，我们仅集中在几个方面，并且只从使用JVM设施的程序员的角度来看待，而不涉及其内部工作原理；这是一个实现细节，可能会因供应商的JVM而异。
- en: 'I’ll start with loading an existing class dynamically, move on to listing the
    fields and methods of a class and invoking methods, and end by creating a class
    on the fly using a `ClassLoader`. One of the more interesting aspects of Java,
    and one that accounts for its flexibility (applets in days of yore, servlets,
    web services, and other dynamic APIs) while also once being part of its perceived
    speed problem, is the notion of *dynamic loading*. For example, even the simplest
    “Hello, Java” program has to load the class file for your `HelloJava` class, the
    class file for its parent (usually `java.lang.Object`), the class for `PrintStream`
    (because you used `System.out`), the class for `PrintStream`’s parent, and `IOException`,
    and its parent, and so on. To see this in action, try something like this:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从动态加载现有类开始，继续列出类的字段和方法以及调用方法，最后通过使用`ClassLoader`动态创建类来结束。Java的一个更有趣的方面之一，也是其灵活性的原因（昔日的小程序、Servlet、Web服务和其他动态API），同时也曾是其被认为速度问题的一部分，是*动态加载*的概念。例如，即使是最简单的“Hello,
    Java”程序也必须加载您的`HelloJava`类的类文件，其父类的类文件（通常是`java.lang.Object`），`PrintStream`类（因为您使用了`System.out`），`PrintStream`的父类，以及`IOException`及其父类等。要看到这个过程，请尝试类似于以下的东西：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To take another example, when applets were popular, a browser would download
    an applet’s bytecode file over the internet and run it on your desktop. How does
    it load the class file into the running JVM? We discuss this little bit of Java
    magic in [Recipe 17.4](#javacook-reflection-SECT-3). The chapter ends with replacement
    versions of the JDK tools *javap* and a cross-reference tool that you can use
    to become a famous Java author by publishing your very own reference to the complete
    Java API.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，当小程序流行时，浏览器会通过互联网下载小程序的字节码文件并在您的桌面上运行它。它如何将类文件加载到正在运行的JVM中？我们在[第17.4节](#javacook-reflection-SECT-3)中讨论了这部分Java的魔法。本章以JDK工具的替换版本*javap*和交叉引用工具结束，您可以使用它们来成为一位著名的Java作者，通过发布自己对完整Java
    API的参考。
- en: 17.1 Getting a Class Descriptor
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 17.1 获取类描述符
- en: Problem
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to get a `Class` object from a class name or instance.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您想从类名或实例中获取一个`Class`对象。
- en: Solution
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: If the type name is known at compile time, you can get the class instance using
    the compiler keyword `.class`, which works on any type that is known at compile
    time, even the eight primitive types.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类型名称在编译时已知，可以使用编译器关键字`.class`获取类实例，该关键字适用于任何在编译时已知的类型，甚至是八种基本类型。
- en: 'Otherwise, if you have an object (an instance of a class), you can call the
    `java.lang.Object` method `getClass()`, which returns the `Class` object for the
    object’s class (now that was a mouthful!):'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，如果您有一个对象（一个类的实例），您可以调用`java.lang.Object`类的`getClass()`方法，它将返回该对象的类的`Class`对象（现在这是一个冗长的说法！）：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When we run it, we see this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行它时，我们看到这个：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Nothing fancy, but as you can see, you can get the `Class` object for almost
    anything known at compile time, whether it’s part of a package or not.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 没什么花哨的，但正如你所见，你可以获取几乎任何在编译时已知的`Class`对象，无论它是否是包的一部分。
- en: 17.2 Finding and Using Methods and Fields
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 17.2 查找和使用方法和字段
- en: Problem
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to find arbitrary method or field names in arbitrary classes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在任意类中找到任意方法或字段名称。
- en: Solution
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the reflection package `java.lang.reflect`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用反射包`java.lang.reflect`。
- en: Discussion
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: If you just wanted to find fields and methods in one particular class, you wouldn’t
    need this recipe; you could simply create an instance of the class using `new`
    and refer to its fields and methods directly. But this allows you to find methods
    and fields in any class, even classes that have not yet been written! Given a
    class object created as in [Recipe 17.1](#javacook-reflection-SECT-1), you can
    obtain a list of constructors, a list of methods, or a list of fields. The method
    `getMethods()` lists the methods available for a given class as an array of `Method`
    objects. Similarly, `getFields()` returns a list of `Field` objects. Because constructor
    methods are treated specially by Java, there is also a `getConstructors()` method,
    which returns an array of `Constructor` objects. Even though `Class` is in the
    package `java.lang`, the `Constructor`, `Method`, and `Field` objects it returns
    are in `java.lang.``reflect`, so you need an import of this package. The `ListMethods`
    class (see [Example 17-1](#javacook-reflection-EX-1)) shows how get a list of
    methods in a class whose name is known at runtime.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想在一个特定的类中查找字段和方法，你不需要这个技巧；你可以简单地使用`new`创建一个类的实例，并直接引用它的字段和方法。但这允许你在任何类中查找方法和字段，即使是尚未编写的类！如同[Recipe
    17.1](#javacook-reflection-SECT-1)中创建的类对象一样，你可以获得构造函数列表、方法列表或字段列表。方法`getMethods()`列出了一个给定类的方法作为`Method`对象数组。类似地，`getFields()`返回一个`Field`对象列表。因为构造方法在Java中被特殊对待，还有一个`getConstructors()`方法，它返回一个`Constructor`对象数组。尽管`Class`在包`java.lang`中，但它返回的`Constructor`、`Method`和`Field`对象在`java.lang.``reflect`中，所以你需要导入这个包。`ListMethods`类（参见[示例 17-1](#javacook-reflection-EX-1)）展示了如何在运行时已知类名的类中获取方法列表。
- en: Example 17-1\. main/src/main/java/reflection/ListMethods.java
  id: totrans-24
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-1\. main/src/main/java/reflection/ListMethods.java
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For example, you could run [Example 17-1](#javacook-reflection-EX-1) on a class
    like `java.lang.String` and get a fairly lengthy list of methods; I’ll only show
    part of the output so you can see what it looks like:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以在类似于`java.lang.String`的类上运行[示例 17-1](#javacook-reflection-EX-1)，并得到一个相当长的方法列表；我只展示部分输出，让你看看它是什么样子的：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can see that this could be extended (almost literally) to write a `BeanMethods`
    class that would list only the set/get methods defined in a JavaBean (see [Recipe
    15.4](ch15.html#javacook-packages-SECT-8)).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，这可以扩展（几乎字面意义上）以编写一个`BeanMethods`类，该类仅列出在JavaBean中定义的set/get方法（参见[Recipe
    15.4](ch15.html#javacook-packages-SECT-8)）。
- en: Alternatively, you can find a particular method and invoke it, or find a particular
    field and refer to its value. Let’s start by finding a given field, because that’s
    the easiest. [Example 17-2](#javacook-reflection-EX-2) is code that, given an
    `Object` and the name of a field, finds the field (gets a `Field` object) and
    then retrieves and prints the value of that `Field` as an `int`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以找到一个特定的方法并调用它，或者找到一个特定的字段并引用它的值。让我们首先找到一个给定的字段，因为这是最简单的。[示例 17-2](#javacook-reflection-EX-2)是一段代码，给定一个`Object`和一个字段的名称，找到该字段（获取一个`Field`对象），然后检索并打印该字段的值作为一个`int`。
- en: Example 17-2\. main/src/main/java/reflection/FindField.java
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-2\. main/src/main/java/reflection/FindField.java
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'What if we need to find a method? The simplest way is to use the methods `getMethod()`
    and `invoke()`. But this is not altogether trivial. Suppose that somebody gives
    us a reference to an object. We don’t know its class but have been told that it
    should have this method:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要找到一个方法怎么办？最简单的方法是使用方法`getMethod()`和`invoke()`。但这并不是完全微不足道的。假设有人给了我们一个对象的引用。我们不知道它的类，但被告知它应该有这个方法：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We wish to invoke `work()`. To find the method, we must make an array of `Class`
    objects, one per item in the parameter list. So, in this case, we make an array
    containing only a reference to the class object for `String`. Because we know
    the name of the class at compile time, we’ll use the shorter invocation `String.class`
    instead of `Class.forName()`. This, plus the name of the method as a string, gets
    us entry into the `getMethod()` method of the `Class` object. If this succeeds,
    we have a `Method` object. But guess what? In order to invoke the method, we have
    to construct yet another array, this time an array of `Object` references actually
    containing the data to be passed to the invocation. We also, of course, need an
    instance of the class in whose context the method is to be run. For this demonstration
    class, we need to pass only a single string, because our array consists only of
    the string. [Example 17-3](#javacook-reflection-EX-3) is the code that finds the
    method and invokes it.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望调用`work()`方法。要找到这个方法，我们必须创建一个`Class`对象的数组，每个数组项对应于参数列表中的一个项目。因此，在这种情况下，我们创建一个仅包含对`String`类对象的引用的数组。因为我们在编译时知道类的名称，所以我们将使用较短的调用`String.class`，而不是`Class.forName()`。这样加上方法名称作为字符串，就可以让我们进入`Class`对象的`getMethod()`方法。如果成功，我们就会得到一个`Method`对象。但你知道吗？为了调用这个方法，我们必须构造另一个数组，这次是一个包含实际传递给调用的数据的`Object`引用数组。当然，我们还需要这个类的实例，在这个实例的上下文中运行方法。对于这个演示类，我们只需要传递一个字符串，因为我们的数组只包含这个字符串。[示例 17-3](#javacook-reflection-EX-3)
    是找到方法并调用它的代码。
- en: Example 17-3\. main/src/main/java/reflection/GetAndInvokeMethod.java
  id: totrans-35
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-3\. main/src/main/java/reflection/GetAndInvokeMethod.java
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Not tiny, but it’s still not bad. In most programming languages, you couldn’t
    do that in the 40 lines it took us here.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不算微不足道，但也算不上糟糕。在大多数编程语言中，你无法在这里花费的40行内完成这项工作。
- en: 'A word of caution: when the arguments to a method are of a primitive type,
    such as `int`, you do not pass `Integer.class` into `getMethod()`. Instead, you
    must use the class object representing the primitive type `int`. The easiest way
    to find this class is in the `Integer` class, as a public constant named `TYPE`,
    so you’d pass `Integer.TYPE`. The same is true for all the primitive types; for
    each, the corresponding wrapper `class` has the primitive `class` referred to
    as `TYPE`.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意：当方法的参数是原始类型（例如`int`）时，不要将`Integer.class`传递给`getMethod()`。相反，您必须使用表示原始类型`int`的类对象。找到这个类的最简单方法是在`Integer`类中，有一个名为`TYPE`的公共常量，所以你应该传递`Integer.TYPE`。对于所有原始类型，情况都是如此；每个对应的包装类都有一个称为`TYPE`的原始类引用。
- en: Java also includes a mechanism called a `MethodHandle` that was intended both
    to simplify and to generalize use of Reflection to invoke methods; we do not cover
    it here because in practice it has not shown to be a significant improvement over
    using the Reflection API.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Java还包括一个称为`MethodHandle`的机制，旨在简化和泛化Reflection API用于调用方法；我们在这里不涉及它，因为在实践中它并未显示出显著改进。
- en: 17.3 Accessing Private Methods and Fields via Reflection
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 17.3 通过Reflection访问私有方法和字段
- en: Problem
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to access private fields and have heard you can do so using the Reflection
    API.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要访问私有字段，并且听说可以使用Reflection API来实现。
- en: Solution
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: It’s generally a bad idea to access private fields. But if you have to, and
    the `SecurityManager` allows you to use Reflection, you can.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通常访问私有字段是一个坏主意。但如果确实需要，并且`SecurityManager`允许您使用Reflection，那么您可以做到。
- en: Discussion
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: There is occasionally a need to access private fields in other classes. For
    example, I did so recently in writing a JUnit test case that needed to see all
    the fields of a target class. The secret is to call the `Field` or `Method` descriptor’s
    `setAccessible()` method passing the value `true` before trying to get the value
    or invoke the method. It really is that easy, as shown in [Example 17-4](#javacook-reflection-defeatPrivacy).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候需要访问其他类中的私有字段。例如，最近我写了一个JUnit测试案例，需要查看目标类的所有字段。秘密在于在尝试获取值或调用方法之前，调用`Field`或`Method`描述符的`setAccessible()`方法并传递值`true`。就像在[示例 17-4](#javacook-reflection-defeatPrivacy)中展示的那样，它确实如此简单。
- en: Example 17-4\. main/src/main/java/reflection/DefeatPrivacy.java
  id: totrans-47
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-4\. main/src/main/java/reflection/DefeatPrivacy.java
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Warning
  id: totrans-49
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Use this with *extreme care*, because it can defeat some of the most cherished
    principles of Java programming.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用时要*极度小心*，因为它可能违背Java编程中最珍视的一些原则。
- en: 17.4 Loading and Instantiating a Class Dynamically
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 17.4 加载和动态实例化类
- en: Problem
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to load classes dynamically, just like web servers load your servlets.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要动态加载类，就像Web服务器加载您的Servlet一样。
- en: Solution
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use `class.forName("ClassName");` and the class’s `newInstance( )` method.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `class.forName("ClassName");` 和类的 `newInstance( )` 方法。
- en: Discussion
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Suppose you are writing a Java application and want other developers to be able
    to extend your application by writing Java classes that run in the context of
    your application. In other words, these developers are, in essence, using Java
    as an extension language, in the same way that applets are an extension of a web
    browser. You would probably want to define a small set of methods that these extension
    programs would have and that you could call for such purposes as initialization,
    operation, and termination. The best way to do this is, of course, to publish
    a given, possibly abstract, class that provides those methods and get the developers
    to subclass from it. Sound familiar? It should. This is just how web browsers
    such as Netscape allow the deployment of applets.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您正在编写一个Java应用程序，并希望其他开发人员能够通过编写在您应用程序上下文中运行的Java类来扩展您的应用程序。换句话说，这些开发人员实质上是使用Java作为扩展语言，就像小程序是Web浏览器的扩展一样。您可能希望定义一小组这些扩展程序将具有的方法，您可以调用这些方法进行初始化、操作和终止等目的。当然，最好的方法是发布一个给定的、可能是抽象的类，提供这些方法，并让开发人员从中继承。听起来耳熟能详吗？应该是的。这正是像网景这样的Web浏览器允许小程序部署的方式。
- en: We’ll leave the thornier issues of security and of loading a class file over
    a network socket for now and assume that the user can install the classes into
    the application directory or into a directory that appears in the `CLASSPATH`
    at the time the program is run. First, let’s define our class. We’ll call it `Cooklet`
    (see [Example 17-5](#javacook-reflection-EX-4)) to avoid infringing on the overused
    word *applet*. Pretend each subclass will represent the code to drive some elaborate
    kind of food-preparing-and-cooking appliance through the steps of one traditional
    recipe. And we’ll initially take the easiest path from ingredients to cookies
    before we complicate it.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 暂且不论安全性和通过网络套接字加载类文件的复杂问题，并假设用户可以将类安装到应用程序目录或在程序运行时出现在 `CLASSPATH` 中的目录中。首先，让我们定义我们的类。我们将其称为
    `Cooklet`（参见 [示例 17-5](#javacook-reflection-EX-4)），以避免侵犯过度使用的 *applet* 这个词。假设每个子类都代表了驱动某种复杂食品准备和烹饪设备的代码，通过传统食谱的步骤制作饼干。在复杂化之前，我们将最初从成分到饼干的最简单路径开始。
- en: Example 17-5\. Cooklet.java
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-5\. Cooklet.java
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, because we’ll be baking, er, making this available to other people, we’ll
    probably want to cook up a demonstration version too; see [Example 17-6](#javacook-reflection-EX-5).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，因为我们将要为其他人提供这个，我们可能也想做一个演示版本；参见 [示例 17-6](#javacook-reflection-EX-5)。
- en: Example 17-6\. main/src/main/java/reflection/DemoCooklet.java
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-6\. main/src/main/java/reflection/DemoCooklet.java
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: But how does our application use it? Once we have the name of the user’s class,
    we need to create a `Class` object for that class. This can be done easily using
    the static method `Class.forName()`. Then we can create an instance of it using
    the `Class` object’s `newInstance()` method; this calls the class’s no-argument
    constructor. Then we simply cast the newly constructed object to our `Cooklet`
    class, and we can call its methods! It actually takes longer to describe this
    code than to look at the code, so let’s do that now; see [Example 17-7](#javacook-reflection-EX-6).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们的应用程序如何使用它呢？一旦我们有了用户类的名称，我们需要为该类创建一个 `Class` 对象。这可以通过静态方法 `Class.forName()`
    轻松完成。然后我们可以使用 `Class` 对象的 `newInstance()` 方法创建它的实例；这将调用类的无参构造函数。然后我们只需将新构造的对象强制转换为我们的
    `Cooklet` 类，并且我们就可以调用它的方法了！实际上，描述这段代码比看代码要花更长的时间，所以现在让我们来看看代码；参见 [示例 17-7](#javacook-reflection-EX-6)。
- en: Example 17-7\. main/src/main/java/reflection/Cookies.java
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-7\. main/src/main/java/reflection/Cookies.java
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: And if we run it?
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行它呢？
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Of course, this version has rather limited error handling. But you already know
    how to fix that. Your `ClassLoader` can also place classes into a package by constructing
    a `Package` object; you should do this if loading any medium-sized set of application
    classes.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个版本的错误处理能力相对较弱。但您已经知道如何解决这个问题。如果要加载任何中等规模的应用程序类集合，您的 `ClassLoader` 还可以通过构建一个
    `Package` 对象将类放入包中。
- en: 17.5 Constructing a Class from Scratch with a ClassLoader
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 17.5 使用类加载器从头构建类
- en: Problem
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to load a class from a nonstandard location and run its methods.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要从非标准位置加载类并运行其方法。
- en: Solution
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Examine the existing loaders such as `java.net.URLClassLoader`. If none is suitable,
    write and use your own `ClassLoader`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 检查现有的加载器，例如`java.net.URLClassLoader`。如果没有合适的加载器，可以编写并使用自己的`ClassLoader`。
- en: Discussion
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: A `ClassLoader`, of course, is a program that loads classes. One `ClassLoader`
    is built into the Java Virtual Machine, but your application can create others
    as needed. Learning to write and run a working `ClassLoader` and using it to load
    a class and run its methods is a nontrivial exercise. In fact, you rarely need
    to write a `ClassLoader`, but knowing how is helpful in understanding how the
    JVM finds classes, creates objects, and calls methods.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`ClassLoader`是一个加载类的程序。Java虚拟机内置了一个`ClassLoader`，但你的应用程序可以根据需要创建其他`ClassLoader`。学习编写和运行工作中的`ClassLoader`，并使用它来加载类并运行其方法，是一项非常不平凡的任务。事实上，你很少需要编写`ClassLoader`，但了解如何编写是有助于理解JVM如何查找类、创建对象和调用方法的过程。
- en: '`ClassLoader` itself is abstract; you must subclass it, presumably providing
    a `loadClass()` method that loads classes as you wish. It can load the bytes from
    a network connection, a local disk, RAM, a serial port, or anywhere else. Or you
    can construct the class file in memory yourself, if you have access to a compiler.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClassLoader`本身是抽象的；你必须派生它，通常提供一个按你希望的方式加载类的`loadClass()`方法。它可以从网络连接、本地磁盘、RAM、串口或任何其他位置加载字节。或者，如果你有编译器的访问权限，你可以自己在内存中构造类文件。'
- en: There is a general-purpose loader called `java.net.URLClassLoader` that can
    be used if all you need is to load classes via the web protocol (or, more generally,
    from one or more URLs).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只需通过Web协议（或更广泛地通过一个或多个URL）加载类，则可以使用名为`java.net.URLClassLoader`的通用加载器。
- en: You must call the `ClassLoader` `loadClass()` method for any classes you wish
    to explicitly load from it. Note that this method is called to load all classes
    required for classes you load (superclasses that aren’t already loaded, for example).
    However, the JVM still loads classes that you instantiate with the `new` operator
    normally via classpath.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须调用`ClassLoader`的`loadClass()`方法来显式加载任何你希望加载的类。请注意，此方法用于加载你加载的所有类所需的所有类（例如尚未加载的超类）。然而，JVM仍会正常通过类路径加载使用`new`运算符实例化的类。
- en: When writing a `ClassLoader`, your `loadClass()` method needs to get the class
    file into a byte array (typically by reading it), convert the array into a `Class`
    object, and return the result.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写`ClassLoader`时，你的`loadClass()`方法需要将类文件读入字节数组（通常是通过读取），将数组转换为`Class`对象，并返回结果。
- en: What? That sounds a bit like “And Then a Miracle Occurs…” And it is. The miracle
    of class creation, however, happens down inside the JVM, where you don’t have
    access to it. Instead, your `ClassLoader` has to call the `protected defineClass()`
    method in your superclass (which is `java.lang.ClassLoader`). This is illustrated
    in [Figure 17-1](#javacook-reflection-FIG-1), where a stream of bytes containing
    a hypothetical `Chicken` class is converted into a ready-to-run `Chicken` class
    in the JVM by calling the `defineClass()` method.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 什么？听起来有点像“然后奇迹发生了……”确实如此。然而，类创建的奇迹发生在JVM内部，在那里你无法访问它。相反，你的`ClassLoader`必须调用其超类（即`java.lang.ClassLoader`）中的`protected
    defineClass()`方法。这在[Figure 17-1](#javacook-reflection-FIG-1)中有所示，其中一个包含假想`Chicken`类的字节流通过调用`defineClass()`方法在JVM中被转换为一个准备运行的`Chicken`类。
- en: '![jcb4 1701](assets/jcb4_1701.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![jcb4 1701](assets/jcb4_1701.png)'
- en: Figure 17-1\. ClassLoader in action
  id: totrans-83
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图17-1\. `ClassLoader`的实际应用
- en: What next?
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接下来怎么办？
- en: To use your `ClassLoader` subclass, you need to instantiate it and call its
    `loadClass()` method with the name of the class you want to load. This gives you
    a `Class` object for the named class; the `Class` object in turn lets you construct
    instances, find and call methods, etc. Refer back to [Recipe 17.2](#javacook-reflection-SECT-2).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用你的`ClassLoader`子类，你需要实例化它，并调用其`loadClass()`方法，提供你想要加载的类的名称。这将为你提供一个命名类的`Class`对象；`Class`对象反过来让你构造实例、查找和调用方法等。参见[Recipe
    17.2](#javacook-reflection-SECT-2)。
- en: 17.6 Constructing a Class from Scratch with JavaCompiler
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 17.6 使用JavaCompiler从头构建类
- en: Problem
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You’d rather construct a class dynamically by generating source code and compiling
    it.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能更喜欢通过生成源代码并编译来动态构建类。
- en: Solution
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the `JavaCompiler` from `javax.tools`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`javax.tools`中的`JavaCompiler`。
- en: Discussion
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: There are many cases where you might need to generate code on the fly. If you’re
    writing a framework, you might want to introspect on a model class to find its
    fields, and generate accessors for them on the fly. As we’ve seen in [Recipe 17.2](#javacook-reflection-SECT-2),
    you can do this with the `Field` class. However, for a high-volume operation it
    may well be more efficient to generate direct access code.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多情况下，您可能需要动态生成代码。如果您正在编写一个框架，可能希望内省模型类以找到其字段，并动态生成访问器。正如我们在[Recipe 17.2](#javacook-reflection-SECT-2)中看到的那样，可以使用`Field`类实现此目的。然而，对于高容量操作，生成直接访问代码可能更有效。
- en: 'The Java Compiler API has been around since Java 1.6 and is fairly easy to
    use for simple cases. Here are the basic steps:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Java编译器API自Java 1.6就存在，对于简单情况相当易于使用。以下是基本步骤：
- en: Get the `JavaCompiler` object for your current Java Runtime. If it’s not available,
    either give up altogether, or fall back to using reflection.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取当前Java运行时的`JavaCompiler`对象。如果不可用，要么完全放弃，要么退回到使用反射。
- en: Get a `CompilerTask` (which is also a `Callable`) to run the compilation, passing
    input and outputs.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取一个`CompilerTask`（也是`Callable`）来运行编译，传递输入和输出。
- en: Invoke the `Callable`, either directly or by using an `ExecutorService`.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`Callable`，可以直接调用或使用`ExecutorService`。
- en: Check the results. If true, invoke the class.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查结果。如果为true，则调用该类。
- en: This is demonstrated in [Example 17-8](#javacook-reflection-EX-javacompilerdemo).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这在[Example 17-8](#javacook-reflection-EX-javacompilerdemo)中有所展示。
- en: Example 17-8\. main/src/main/java/reflection/JavaCompilerDemo.java
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-8\. main/src/main/java/reflection/JavaCompilerDemo.java
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[![1](assets/1.png)](#co_reflection__or__a_class_named_class__CO1-1)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_reflection__or__a_class_named_class__CO1-1)'
- en: The source code that we want to compile. In real life it would probably be dynamically
    generated, maybe using a `StringBuffer`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要编译的源代码。在实际应用中，它可能是动态生成的，可能使用`StringBuffer`。
- en: '[![2](assets/2.png)](#co_reflection__or__a_class_named_class__CO1-2)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_reflection__or__a_class_named_class__CO1-2)'
- en: Get a reference to the default `JavaCompiler` object.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 获取默认的`JavaCompiler`对象的引用。
- en: '[![3](assets/3.png)](#co_reflection__or__a_class_named_class__CO1-3)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_reflection__or__a_class_named_class__CO1-3)'
- en: Ask the compiler to create a `CompilerTask` to do the compilation. `CompilerTask`
    is also `Callable` and we save it under that type. The `-d` and `.` are standard
    *javac* arguments. `MySource` extends the compiler-provided API class `SimpleJavaFileObject`
    to give access to a file by creating a *file://* URL.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要求编译器创建一个`CompilerTask`来执行编译。`CompilerTask`也是`Callable`，我们将其保存为该类型。`-d`和`.`是标准的*javac*参数。`MySource`扩展了编译器提供的API类`SimpleJavaFileObject`，通过创建*file://*
    URL来访问文件。
- en: '[![4](assets/4.png)](#co_reflection__or__a_class_named_class__CO1-4)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_reflection__or__a_class_named_class__CO1-4)'
- en: A `Callable` can be put into a thread pool (`ExecutorService`) (see [Recipe
    16.1](ch16.html#javacook-threads-SECT-1)); we don’t need this capability but the
    Compiler API returns it. We invoke the `Callable` directly.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将`Callable`放入线程池（`ExecutorService`）（参见[Recipe 16.1](ch16.html#javacook-threads-SECT-1)）；虽然我们不需要此功能，但编译器API返回它。我们直接调用`Callable`。
- en: '[![5](assets/5.png)](#co_reflection__or__a_class_named_class__CO1-5)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_reflection__or__a_class_named_class__CO1-5)'
- en: Assuming the `result` was `true` indicating success, we load the class with
    `Class.forName()`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`result`为`true`，表示成功，我们使用`Class.forName()`加载该类。
- en: '[![6](assets/6.png)](#co_reflection__or__a_class_named_class__CO1-6)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_reflection__or__a_class_named_class__CO1-6)'
- en: We have to find the `main()` method in the generated class. We reuse the `String[].class`
    type from args, since all `main` methods have the same argument.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须找到生成类中的`main()`方法。我们重用`String[].class`类型来传递args，因为所有的`main`方法都有相同的参数。
- en: '[![7](assets/7.png)](#co_reflection__or__a_class_named_class__CO1-7)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_reflection__or__a_class_named_class__CO1-7)'
- en: Finally, we can invoke the `main` method, reusing the incoming `args` array
    to pass any *welcome* message along.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以调用`main`方法，重用传入的`args`数组来传递任何*欢迎*消息。
- en: 'Running this program with and without an argument shows that the argument passed
    to the `JavaCompilerDemo` is being passed correctly to the generated `AnotherDemo`
    class:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此程序时，带参数和不带参数都显示参数正确传递给生成的`AnotherDemo`类：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There is a lot to explore in the Compiler API, including the `JavaFileManager`
    that lets you control the placement of class files (other than by using `-d` as
    we did here), listeners to monitor compilation, and control of output and error
    streams. Consult the `javax.tools.JavaCompiler` [documentation](https://docs.oracle.com/javase/8/docs/api/javax/tools/JavaCompiler.html)
    for details.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器API中有很多值得探索的内容，包括`JavaFileManager`，它允许您控制类文件的放置（除了像我们在此处使用`-d`一样），监听器以监视编译过程，以及控制输出和错误流。有关详细信息，请参阅`javax.tools.JavaCompiler`的[文档](https://docs.oracle.com/javase/8/docs/api/javax/tools/JavaCompiler.html)。
- en: 17.7 Performance Timing
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 17.7 性能计时
- en: Problem
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Slow performance?
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 性能慢？
- en: Solution
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use a *profiler*, or time individual methods using `System.currentTimeMillis()`
    before and after invoking the target method; the difference is the time that method
    took.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*分析工具*，或者在调用目标方法之前和之后使用`System.currentTimeMillis()`来计时单个方法；差异即为该方法所需的时间。
- en: Discussion
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Profilers
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分析工具
- en: Profiling tools—profilers—have a long history as one of the important tools
    in a programmer’s toolkit. A commercial profiling tool will help find bottlenecks
    in your program by showing both the number of times each method was called and
    the amount of time in each.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 分析工具——分析器——作为程序员工具包中的重要工具，拥有悠久的历史。商业分析工具将通过显示每个方法被调用的次数和每次调用所需的时间来帮助找出程序中的瓶颈。
- en: Quite a bit of useful information can be obtained from a Java application by
    use of the `VisualVM` tool, which was part of the Oracle JDK up until Java 8.
    With Java 9 this tool was open-sourced, and it’s now available from the [VisualVM
    project](https://visualvm.github.io/index.html).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`VisualVM`工具可以从Java应用程序中获得大量有用的信息，该工具是Oracle JDK直到Java 8的一部分。从Java 9开始，该工具已开源，现在可以从[VisualVM项目](https://visualvm.github.io/index.html)中获取。
- en: Another tool that is part of the JDK is [Java Flight Recorder](https://en.wikipedia.org/wiki/JDK_Flight_Recorder),
    which is now open-sourced and built into the JDK. Its data is meant to be analyzed
    by [Java Mission Control](https://en.wikipedia.org/wiki/JDK_Mission_Control).
    There are also third-party profilers that will give more detailed information;
    a web search will find current commercial offerings.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: JDK 的另一个工具是[Java Flight Recorder](https://en.wikipedia.org/wiki/JDK_Flight_Recorder)，现在已开源并内置于JDK中。其数据旨在由[Java
    Mission Control](https://en.wikipedia.org/wiki/JDK_Mission_Control)分析。还有第三方分析工具将提供更详细的信息；在网上搜索将找到当前的商业产品。
- en: Measuring a single method
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测量单个方法
- en: The simplest technique is to save the JVM’s accumulated time before and after
    dynamically loading a main program and then calculate the difference between those
    times. Code to do just this is presented in [Example 17-11](#javacook-reflection-EX-7);
    for now, just remember that we have a way of timing a given Java class.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的技术是在动态加载主程序之前和之后保存JVM累积时间，然后计算这些时间的差异。要做到这一点的代码在[Example 17-11](#javacook-reflection-EX-7)中有所呈现；现在只需记住我们有一种计时给定Java类的方法。
- en: One way of measuring the efficiency of a particular operation is to run it many
    times in isolation. The overall time the program takes to run thus approximates
    the total time of many invocations of the same operation. Gross numbers like this
    can be compared if you want to know which of two ways of doing something is more
    efficient. Consider the case of string concatenation versus `println()`. The code
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 衡量特定操作效率的一种方式是在隔离环境中多次运行它。因此，程序运行所需的总时间大致相当于多次调用相同操作的总时间。如果您想知道两种方法哪种更有效率，可以比较这些粗略的数字。考虑字符串连接与`println()`的情况。代码
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'will probably work by creating a `StringBuilder`; appending the string `"Time
    is"`, the value of `n` as a string, and `"seconds"`; and finally converting the
    finished `StringBuilder` to a `String` and passing that to `println()`. Suppose
    you have a program that does a lot of this, such as a Java servlet that creates
    a lot of HTML this way, and you expect (or at least hope) your website to be sufficiently
    busy so that doing this efficiently will make a difference. There are two ways
    of thinking about this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会通过创建一个`StringBuilder`来工作；附加字符串`"Time is"`，值为`n`的字符串和`"seconds"`；最后将完成的`StringBuilder`转换为`String`并传递给`println()`。假设您有一个执行大量此操作的程序，例如创建大量HTML的Java
    servlet，并且您期望（或至少希望）您的网站足够繁忙，以便有效地执行此操作将产生差异。有两种思考方式：
- en: 'Theory A: this string concatenation is inefficient.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理论A：这种字符串连接效率低下。
- en: 'Theory B: string concatenation doesn’t matter; `println()` is inefficient,
    too.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理论B：字符串连接并不重要；`println()`也效率低下。
- en: A proponent of Theory A might say that because `println()` just puts stuff into
    a buffer, it is very fast and that string concatenation is the expensive part.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 支持理论 A 的人可能会说，因为 `println()` 只是把内容放入缓冲区，所以非常快，而字符串连接才是昂贵的部分。
- en: How to decide between Theory A and Theory B? Assume you are willing to write
    a simple test program that tests both theories. Let’s just write a simple program
    both ways and time it. [Example 17-9](#stringprintA) is the timing program for
    Theory A.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如何在理论 A 和理论 B 之间做出决定？假设你愿意编写一个简单的测试程序来测试这两个理论。我们可以分别用两种方法编写一个简单的程序并计时。[示例 17-9](#stringprintA)
    是理论 A 的计时程序。
- en: Example 17-9\. main/src/main/java/performance/StringPrintA.java
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 17-9\. main/src/main/java/performance/StringPrintA.java
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`StringPrintAA` (in the *javasrc* repo but not printed here) is the same but
    explicitly uses a `StringBuilder` for the string concatenation. [Example 17-10](#stringprintb)
    is the tester for Theory B.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`StringPrintAA`（在 *javasrc* 仓库中但此处未列出）与 `StringBuilder` 明确用于字符串连接是相同的。[示例 17-10](#stringprintb)
    是理论 B 的测试程序。'
- en: Example 17-10\. main/src/main/java/performance/StringPrintB.java
  id: totrans-140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-10\. main/src/main/java/performance/StringPrintB.java
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Timing results
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计时结果
- en: 'I ran `StringPrintA`, `StringPrintAA`, and `StringPrintB` twice each on the
    same computer. To eliminate JVM startup times, I ran them from a program called
    `TimeNoArgs`, which takes a class name and invokes its `main()` method, using
    the Reflection API. `TimeNoArgs` and a shell script to run it, *stringprinttimer.sh*,
    are in the *performance* folder of the *javasrc* source repository. Here are the
    results:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我在同一台计算机上两次运行了 `StringPrintA`、`StringPrintAA` 和 `StringPrintB`。为了消除 JVM 启动时间，我从一个名为
    `TimeNoArgs` 的程序中运行它们，该程序通过 Reflection API 调用类名并调用其 `main()` 方法。`TimeNoArgs` 和一个用于运行它的
    shell 脚本 *stringprinttimer.sh*，位于 *javasrc* 源代码库的 *performance* 文件夹中。以下是结果：
- en: '| 2004 program | Seconds |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 2004 年程序 | 秒 |'
- en: '| --- | --- |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `StringPrintA` | 17.23, 17.20 seconds |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `StringPrintA` | 17.23, 17.20 秒 |'
- en: '| `StringPrintAA` | 17.23, 17.23 seconds |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `StringPrintAA` | 17.23, 17.23 秒 |'
- en: '| `StringPrintB` | 27.59, 27.60 seconds |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `StringPrintB` | 27.59, 27.60 秒 |'
- en: '| 2014 program | Seconds |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 2014 年程序 | 秒 |'
- en: '| --- | --- |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `StringPrintA` | 0.714, 0.525 seconds |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `StringPrintA` | 0.714, 0.525 秒 |'
- en: '| `StringPrintAA` | 0.616, 0.561 seconds |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `StringPrintAA` | 0.616, 0.561 秒 |'
- en: '| `StringPrintB` | 1.091, 1.039 seconds |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `StringPrintB` | 1.091, 1.039 秒 |'
- en: 'Although the times went down by a factor of roughly 20 over a decade due to
    both JVM improvements and faster hardware, the ratios remain remarkably consistent:
    `StringPrintB`, which calls `print()` and `println()` multiple times, takes roughly
    twice as long.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管由于 JVM 的改进和更快的硬件，十年来时间已经减少了大约 20 倍，但比率仍然保持了显著的一致性：`StringPrintB` 多次调用 `print()`
    和 `println()`，大约需要两倍的时间。
- en: 'Moral: don’t guess. If it matters, time it.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 教训：不要猜测。如果重要，就计时。
- en: 'Another moral: multiple calls to `System.out.print()` cost more than the same
    number of calls to a `StringBuilder`’s `append()` method, by a factor of roughly
    1.5 (or 150%). Theory B wins; the extra `println` calls appear to save a string
    concatenation but make the program take substantially longer.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个教训：多次调用 `System.out.print()` 比同样次数调用 `StringBuilder` 的 `append()` 方法成本更高，大约是
    1.5 倍（或 150%）。理论 B 胜出；额外的 `println` 调用似乎节省了字符串连接，但使程序运行时间显著延长。
- en: 'Other aspects of performance: GC'
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 性能的其他方面：GC
- en: There are many other aspects of software performance. One that is fundamental
    to Java is garbage collection behavior. Sun/Oracle usually discusses this at JavaOne.
    For example, see the 2003 JavaOne presentation [“Garbage Collection in the Java
    HotSpot Virtual Machine”](http://www.oracle.com/technetwork/java/javase/tech/ts-3153-coomes-19899-dsf-150093.pdf).
    See also the 2007 JavaOne talk by the same GC development team, [“Garbage Collection-Friendly
    Programming,” TS-2906](https://docs.huihoo.com/javaone/2007/java-se/TS-2906.pdf).
    JavaOne 2010 featured an updated presentation entitled [“The Garbage Collection
    MythBusters”](https://oreil.ly/java-world-the-garbage-collection-mythbusters).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 软件性能的其他方面很多。在 Java 中，其中一个基本方面是垃圾回收行为。Sun/Oracle 通常在 JavaOne 上讨论这个问题。例如，参见 2003
    年 JavaOne 展示文档 [“Java HotSpot 虚拟机中的垃圾收集”](http://www.oracle.com/technetwork/java/javase/tech/ts-3153-coomes-19899-dsf-150093.pdf)。还可以查看由相同
    GC 开发团队在 2007 年 JavaOne 上的演讲 [“垃圾收集友好的编程”](https://docs.huihoo.com/javaone/2007/java-se/TS-2906.pdf)。JavaOne
    2010 展示了更新的演示文稿 [“垃圾收集神话破除者”](https://oreil.ly/java-world-the-garbage-collection-mythbusters)。
- en: A timing program
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个计时程序
- en: It’s pretty easy to build a simplified `time` command in Java, given that you
    have `System.currentTimeMillis()` to start with. Run my `Time` program, and, on
    the command line, specify the name of the class to be timed, followed by the arguments
    (if any) that class needs for running. The program is shown in [Example 17-11](#javacook-reflection-EX-7).
    The time that the class took is displayed. But remember that `System.currentTimeMillis()`
    returns clock time, not necessarily CPU time. So you must run it on a machine
    that isn’t running a lot of background processes. And note also that I use dynamic
    loading (see [Recipe 17.4](#javacook-reflection-SECT-3)) to let you put the Java
    class name on the command line.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中构建一个简化的 `time` 命令非常容易，只要您有 `System.currentTimeMillis()` 就可以开始了。运行我的 `Time`
    程序，在命令行上指定要计时的类的名称，后面跟上该类运行所需的参数（如果有的话）。程序显示在 [示例 17-11](#javacook-reflection-EX-7)
    中。显示出类所花费的时间。但请记住，`System.currentTimeMillis()` 返回的是时钟时间，不一定是CPU时间。因此，您必须在一台没有运行大量后台进程的机器上运行它。还要注意，我使用动态加载（参见
    [配方 17.4](#javacook-reflection-SECT-3)）允许您在命令行上放置Java类名。
- en: Example 17-11\. main/src/main/java/performance/Time.java
  id: totrans-161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-11\. main/src/main/java/performance/Time.java
- en: '[PRE18]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Of course, you can’t directly compare the results from the operating system
    `time` command with results from running this program. There is a rather large,
    but fairly constant, initialization overhead—the JVM startup and the initialization
    of `Object` and `System.out`, for example—that is included in the former and excluded
    from the latter. One could even argue that my `Time` program is more accurate
    because it excludes this constant overhead. But, as noted, it must be run on a
    single-user machine to yield repeatable results. And no fair running an editor
    in another window while waiting for your timed program to complete!
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您不能直接将操作系统 `time` 命令的结果与运行此程序的结果进行比较。存在一个相当大但是相当恒定的初始化开销——例如JVM启动和 `Object`
    以及 `System.out` 的初始化——前者包含在内，后者排除在外。甚至可以说我的 `Time` 程序更加准确，因为它排除了这种恒定的开销。但是，正如前面提到的，必须在单用户机器上运行才能产生可重复的结果。而且，在等待计时程序完成时，在另一个窗口中运行编辑器是不公平的！
- en: See Also
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*[Java Performance](http://shop.oreilly.com/product/0636920272250.do)* by Scott
    Oaks (O’Reilly) provides information on tuning Java performance.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*[Java性能](http://shop.oreilly.com/product/0636920272250.do)* 由斯科特·奥克斯（O’Reilly）编著，提供了调优Java性能的信息。'
- en: 17.8 Printing Class Information
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 17.8 打印类信息
- en: Problem
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to print all the information about a class, similar to the way *javap*
    does.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要打印类的所有信息，类似于 *javap* 的方式。
- en: Solution
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Get a `Class` object, call its `getFields()` and `getMethods()`, and print the
    results.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 获取一个 `Class` 对象，调用其 `getFields()` 和 `getMethods()` 方法，并打印结果。
- en: Discussion
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The JDK includes a program called *javap*, the Java Printer. Sun’s JDK version
    normally prints the outline of a class file—a list of its methods and fields—but
    can also print out the Java bytecodes or machine instructions. The Kaffe package
    did not include a version of *javap*, so I wrote one and contributed it (see [Example 17-12](#javacook-reflection-EX-8)).
    The Kaffe folks have expanded it somewhat, but it still works basically the same.
    My version doesn’t print the bytecodes; it behaves rather like Sun’s behaves when
    you don’t give its version any command-line options.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: JDK包含一个名为 *javap* 的程序，即Java打印机。Sun的JDK版本通常打印类文件的大纲——方法和字段列表——但也可以打印Java字节码或机器指令。Kaffe软件包没有包含
    *javap* 的版本，因此我编写了一个并贡献了它（见 [示例 17-12](#javacook-reflection-EX-8)）。Kaffe的开发人员稍作扩展，但基本上与我的版本相同。我的版本不打印字节码；它的行为类似于在没有给出命令行选项的情况下Sun的行为。
- en: The `getFields()` and `getMethods()` methods return arrays of `Field` and `Method`,
    respectively; these are both in package `java.lang.reflect`. I use a `Modifiers`
    object to get details on the permissions and storage attributes of the fields
    and methods. In many Java implementations, you can bypass this and simply call
    `toString()` in each `Field` and `Method` object (as I do here for `Constructors`).
    Doing it this way gives me a bit more control over the formatting.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`getFields()` 和 `getMethods()` 方法分别返回 `Field` 和 `Method` 的数组；它们都位于 `java.lang.reflect`
    包中。我使用 `Modifiers` 对象获取字段和方法的权限和存储属性的详细信息。在许多Java实现中，您可以跳过这一步骤，并简单地对每个 `Field`
    和 `Method` 对象调用 `toString()` 方法（正如我在这里对 `Constructors` 所做的那样）。这样做使我能够更加控制格式。'
- en: Example 17-12\. main/src/main/java/reflection/MyJavaP.java
  id: totrans-174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-12\. main/src/main/java/reflection/MyJavaP.java
- en: '[PRE19]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 17.9 Listing Classes in a Package
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 17.9 列出包中的类
- en: Problem
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to get a list of all the classes in a package.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 想要获取一个包中所有类的列表。
- en: Solution
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: You can’t, in the general case. There are some limited approaches, most involving
    `CLASSPATH` scanning.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常无法在一般情况下做到这一点。有一些有限的方法，大多涉及`CLASSPATH`扫描。
- en: Discussion
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: There is no way to find out all the classes in a package, in part because, as
    we just saw in [Recipe 17.5](#javacook-reflection-SECT-4), you can add classes
    to a package at any time! And, for better or for worse, the JVM and standard classes
    such as `java.lang.Package` do not even allow you to enumerate the classes currently
    in a given package.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 没有办法找出包中的所有类，部分原因是，正如我们在[Recipe 17.5](#javacook-reflection-SECT-4)中看到的，您可以随时向包中添加类！而且，不管好坏，JVM和标准类（例如`java.lang.Package`）甚至不允许您枚举当前给定包中的类。
- en: The nearest you can come is to look through the `CLASSPATH`. And this will surely
    work only for local directories and JAR files; if you have locally defined or
    network-loaded classes, this is not going to help. In other words, it will find
    compiled classes, but not dynamically loaded ones. There are several libraries
    that can automate this for you, and you’re welcome to use them. The code to scan
    the `CLASSPATH` is fairly simple at heart, though, so classy developers with heart
    will want to examine it. [Example 17-13](#javacook-reflection-EX-8X) shows my
    `ClassesInPackage` class with its one static method. The code works but is rather
    short on error handling, and it will crash on nonexistent packages and other failures.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 最接近的方法是查看`CLASSPATH`。但这仅适用于本地目录和JAR文件；如果有本地定义或网络加载的类，则无法帮助。换句话说，它会找到编译后的类，但不包括动态加载的类。有几个库可以为您自动化此过程，欢迎使用。扫描`CLASSPATH`的代码本质上非常简单，所以具有热情的优秀开发人员将希望仔细研究它。[示例 17-13](#javacook-reflection-EX-8X)展示了我的`ClassesInPackage`类及其一个静态方法。该代码可以运行，但对错误处理非常短，遇到不存在的包或其他失败情况将崩溃。
- en: The code goes through a few gyrations to get the `CLASSPATH` as an enumeration
    of URLs, then looks at each element.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码经历了一些变动，将`CLASSPATH`作为URL枚举进行检查，然后查看每个元素。
- en: file
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 文件
- en: URLs will contain the pathname of the file containing the *.class* file, so
    we can just list it.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: URL将包含包含*.class*文件的文件路径名，因此我们可以直接列出它。
- en: jar
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: jar
- en: URLs contain the filename as “file:/path_to_jar_file!package/name,” so we have
    to pull this apart; the “package name” suffix is slightly redundant in this case
    because it’s the package we asked the `ClassLoader` to give us.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: URL包含文件名，格式为“file:/path_to_jar_file!package/name”，因此我们需要将其分开；在这种情况下，“包名称”后缀稍显冗余，因为它是我们要求`ClassLoader`给出的包。
- en: Example 17-13\. main/src/main/java/reflection/ClassesInPackage.java
  id: totrans-189
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-13\. main/src/main/java/reflection/ClassesInPackage.java
- en: '[PRE20]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note that if you run this application in the *javasrc* project, it will list
    the members of the demonstration package (`com.darwinsys.io`) twice, because it
    will find them both in the build directory and in the JAR file. If this is an
    issue, change the `List` to a `Set` (see [Recipe 7.3](ch07.html#javacook-structure-collections)).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果在*javasrc*项目中运行此应用程序，它将两次列出演示包（`com.darwinsys.io`）的成员，因为它将在构建目录和JAR文件中找到它们。如果这是一个问题，请将`List`更改为`Set`（参见[Recipe
    7.3](ch07.html#javacook-structure-collections)）。
- en: 17.10 Using and Defining Annotations
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 17.10 使用和定义注解
- en: Problem
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to know how to use annotations in code or to define your own annotations.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要知道如何在代码中使用注解或定义自己的注解。
- en: Solution
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Apply annotations in your code using `@``AnnotationName` before a class, method,
    field, etc. Define annotations with `@interface` at the same level as `class`,
    `interface`, etc.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的代码中使用`@``AnnotationName`来标注类、方法、字段等。使用`@interface`在与`class`、`interface`等相同级别定义注解。
- en: Discussion
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Annotations are a way of adding additional information beyond what the source
    code conveys. Annotations may be directed at the compiler or at runtime examination.
    Their syntax was somewhat patterned after javadoc annotations (such as `@author`,
    `@version` inside doc comments). Annotations are what I call *class-like things*
    (so they have initial-cap names) but are prefixed by `@` sign where used (e.g.,
    `@Override`). You can place them on classes, methods, fields, and a few other
    places; they must appear immediately before what they annotate (ignoring space
    and comments). A given annotation may only appear once in a given position (this
    is relaxed in Java 8 or 9).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 注解是一种在源代码之外添加额外信息的方法。注解可以针对编译器或运行时检查。它们的语法在某种程度上模仿了javadoc注解（如文档注释内的`@author`、`@version`）。注解是我所谓的*类似类的东西*（因此它们有首字母大写的名称），但在使用时前缀为`@`号（例如`@Override`）。你可以将它们放在类、方法、字段和少数其他位置；它们必须出现在它们注释的东西之前（忽略空格和注释）。在给定位置，给定注解只能出现一次（在Java
    8或9中放宽了这一限制）。
- en: 'As an example of the benefits of a compile-time annotation, consider the common
    error made when overriding: as shown in [Example 17-14](#myclassjavaanno), a small
    error in the method signature can result it an overload when an override was intended.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 作为编译时注解的一个例子，考虑覆盖时常见的错误：如[Example 17-14](#myclassjavaanno)所示，方法签名的小错误可能导致意外的重载。
- en: Example 17-14\. MyClass.java (an example of why we need annotations)
  id: totrans-200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 17-14\. MyClass.java（为何我们需要注解的示例）
- en: '[PRE21]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The code will compile just fine on any release of Java, but it is incorrect.
    The standard contract of the `equals()` method (see [Recipe 8.1](ch08.html#javacook-oo-SECT-1))
    requires a method whose solitary argument is of type `java.lang.Object`. The preceding
    version creates an accidental overload. Because the main use of `equals()` (and
    its buddy method `hashCode()`; see [Recipe 8.1](ch08.html#javacook-oo-SECT-1))
    is in the Collections classes (see [Chapter 7](ch07.html#javacook-structure)),
    this overloaded method will never get called, resulting both in dead code and
    in incorrect operation of your class within `Set`s and `Map`s.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码在任何版本的Java上都能编译通过，但是它是错误的。`equals()`方法的标准契约（见[Recipe 8.1](ch08.html#javacook-oo-SECT-1)）要求其唯一参数为`java.lang.Object`类型。前述版本创建了一个意外的重载。因为`equals()`方法（及其伴侣方法`hashCode()`；见[Recipe
    8.1](ch08.html#javacook-oo-SECT-1)）的主要用途是在集合类（见[Chapter 7](ch07.html#javacook-structure)）中，这个重载方法永远不会被调用，导致代码无效，并且在`Set`和`Map`中的操作是错误的。
- en: 'The solution is very simple: using the annotation `java.lang.Override`, as
    in [Example 17-15](#myclassjavaoverride), informs the compiler that the annotated
    method is required to override a method inherited from a supertype (such as a
    superclass or an interface). If not, the code will not compile.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方法非常简单：使用注解`java.lang.Override`，例如[Example 17-15](#myclassjavaoverride)，告知编译器注解的方法需要覆盖从超类型（如超类或接口）继承的方法。如果没有，则代码将无法编译通过。
- en: Example 17-15\. MyClass.java with @Override annotation
  id: totrans-204
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 17-15\. 带有 @Override 注解的 MyClass.java
- en: '[PRE22]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This version of `equals()`, while still incorrect, will be flagged as erroneous
    at compile time, potentially avoiding a lot of debugging time. This annotation,
    on your own classes, will help both at the time you write new code and as you
    maintain your codebase; if a method is removed from a superclass, all the subclasses
    that still attempt to override it *and* have the `@Override` annotation will cause
    an error message, allowing you to remove a bunch of dead code.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`equals()`版本虽然仍然是错误的，但会在编译时标记为错误，潜在地避免了大量的调试时间。在你自己的类上使用这种注解，在编写新代码时和维护代码库时都会有帮助；如果从超类中删除了一个方法，所有尝试覆盖它的子类
    *并且* 带有`@Override`注解的方法将导致一个错误消息，让你能够删除一堆死代码。
- en: The second major use of annotations is to provide metadata at runtime. For example,
    the Java Persistence API (JPA, see [*https://darwinsys.com/db_in_java*](https://darwinsys.com/db_in_java))
    uses its own set of annotations from the package `javax.persistence` to mark up
    entity classes to be loaded and/or persisted. A JPA entity class might look like
    [Example 17-16](#personjavajpa).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 注解的第二个主要用途是在运行时提供元数据。例如，Java持久性API（JPA，见[*https://darwinsys.com/db_in_java*](https://darwinsys.com/db_in_java)）使用其自己的一组来自`javax.persistence`包的注解来标记要加载和/或持久化的实体类。一个JPA实体类可能看起来像[Example 17-16](#personjavajpa)。
- en: Example 17-16\. main/src/main/java/domain/Person.java (JPA annotations)
  id: totrans-208
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 17-16\. main/src/main/java/domain/Person.java（JPA注解）
- en: '[PRE23]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `@Entity` annotation at class level directs JPA to treat this as a data
    object to be mapped into the database. The `@Id` informs JPA that this `id` is
    the primary key property, and the `@GeneratedValue` tells it how to assign the
    primary key values for newly created objects. The `@Column` annotation is only
    needed when the column name in the relational database differs from the expected
    name based on the property; in this case, the SQL database designer has used `surname`,
    whereas the Java developer wants to use `lastName`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在类级别上的`@Entity`注解指示JPA将其视为要映射到数据库中的数据对象。`@Id`告知JPA这个`id`是主键属性，而`@GeneratedValue`告诉它如何为新创建的对象分配主键值。只有在关系数据库中的列名与基于属性的预期名称不同时，才需要`@Column`注解；在这种情况下，SQL数据库设计者使用了`surname`，而Java开发者想使用`lastName`。
- en: I said that annotations are class-like things, and therefore, you can define
    your own. The syntax here is a bit funky; you use `@interface`. It is rumored
    that the team developing this feature was either told not to, or was afraid to,
    introduce a new keyword into the language, due to the trouble that doing so had
    caused when the `enum` keyword was introduced in Java SE 1.4. Or, maybe they just
    wanted to use a syntax that was more reminiscent of the annotation’s usage. At
    any rate, [Example 17-17](#trivialannot) is a trivial example of a custom annotation.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾说过注解是类似类的东西，因此你可以自定义。这里的语法有点古怪；你使用`@interface`。据传说，开发这一特性的团队要么被告知不要，要么是因为在Java
    SE 1.4引入`enum`关键字时造成的麻烦而害怕引入新的关键字。又或许，他们只是想使用更符合注解使用情况的语法。无论如何，[示例 17-17](#trivialannot)
    是一个自定义注解的简单示例。
- en: Example 17-17\. Trivial annotation defined
  id: totrans-212
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-17\. 定义的简单注解
- en: '[PRE24]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Annotations are class-like things, so they should be named the same way—that
    is, names that begin with a capital letter and, if public, are stored in a source
    file of the same name (e.g, *MyToyAnnotation.java*).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 注解是类似类的东西，因此它们的命名应该相同——即以大写字母开头，并且如果是公共的，应存储在同名的源文件中（例如，*MyToyAnnotation.java*）。
- en: Compile the [Example 17-17](#trivialannot) with *javac* and you’ll see there’s
    a new *MyToyAnnotation.class* file. In [Example 17-18](#runningjavap), we examine
    this with *javap*, the standard JDK class inspection tool.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*javac*编译[示例 17-17](#trivialannot)，你会看到一个新的*MyToyAnnotation.class*文件。在[示例 17-18](#runningjavap)中，我们使用*javap*，标准的JDK类检查工具来检查它。
- en: Example 17-18\. Running javap on trivial annotation
  id: totrans-216
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-18\. 运行javap查看简单注解
- en: '[PRE25]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As it says, an `Annotation` is represented in the class file format as just
    an interface that `extends Annotation` (to answer the obvious question, you could
    write simple interfaces this way, but it would be a truly terrible idea). In [Example 17-19](#annotation),
    we take a quick look at `Annotation` itself.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 正如它所说，注解在类文件格式中表示为只是扩展了`Annotation`接口的接口（回答显而易见的问题，你可以这样编写简单接口，但这真是个糟糕的主意）。在[示例 17-19](#annotation)中，我们快速看一下`Annotation`本身。
- en: Example 17-19\. The Annotation Interface in Detail
  id: totrans-219
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-19\. 注解接口详解
- en: '[PRE26]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Annotations can be made such that the compiler will only allow them in certain
    points in your code. [Example 17-20](#annotation-classes) is one that can only
    go on classes or interfaces.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 注解可以被设计成编译器只允许在代码中的某些点上使用。[示例 17-20](#annotation-classes) 是一个只能用于类或接口的注解。
- en: Example 17-20\. Sample Annotation for Classes, Interfaces, etc.
  id: totrans-222
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-20\. 类、接口等的样本注释
- en: '[PRE27]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `@Target` specifies where the annotation can be used: `ElementType.TYPE`
    makes it usable on classes, interfaces, class-like things such as enums, even
    annotations! To restrict it to use just on annotations, there is `ElementType.ANNOTATION_TYPE`.
    Other types include `METHOD`, `FIELD`, `CONSTRUCTOR`, `LOCAL_VARIABLE`, `PACKAGE`,
    and `PARAMETER`. So, this annotation is itself annotated with two `@ANNOTATION_TYPE`-targeted
    annotations.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Target`指定了注解可以使用的位置：`ElementType.TYPE`使其可用于类、接口、类似类的东西（如枚举），甚至是注解！要将其限制在仅注解使用上，有`ElementType.ANNOTATION_TYPE`。其他类型包括`METHOD`、`FIELD`、`CONSTRUCTOR`、`LOCAL_VARIABLE`、`PACKAGE`和`PARAMETER`。因此，这个注解本身被两个`@ANNOTATION_TYPE`目标注解注释。'
- en: Usage of annotations with an existing framework requires consulting their documentation.
    Using annotations for your own purpose at runtime requires use of the Reflection
    API, as shown in [Example 17-21](#javacook-reflection-Ex-AnnotationDemo).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 使用现有框架的注解需要查阅其文档。在运行时使用自定义注解需要使用反射API，如[示例 17-21](#javacook-reflection-Ex-AnnotationDemo)所示。
- en: One more thing to note about annotations is that they may have attributes. These
    are defined as methods in the annotation source code but used as attributes where
    the annotation is used. [Example 17-21](#javacook-reflection-Ex-AnnotationDemo)
    is an annotated annotation with one such attribute.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 关于注解还有一件事需要注意，那就是它们可能具有属性。这些属性在注解源代码中定义为方法，但在使用注解时用作属性。[Example 17-21](#javacook-reflection-Ex-AnnotationDemo)展示了一个具有此类属性的注解注解。
- en: Example 17-21\. main/src/main/java/lang/AnnotationDemo.java
  id: totrans-227
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 17-21\. main/src/main/java/lang/AnnotationDemo.java
- en: '[PRE28]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`AnnotationDemo` has the meta-annotation `@Target(ElementType.TYPE)` to indicate
    that it can annotate user-defined types (such as classes). Other `ElementType`
    choices include `METHOD`, `FIELD`, and `PARAMETER`. If more than one is needed,
    use array initializer syntax.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`AnnotationDemo` 具有元注解 `@Target(ElementType.TYPE)`，表明它可以注解用户定义的类型（例如类）。其他 `ElementType`
    选项包括 `METHOD`、`FIELD` 和 `PARAMETER`。如果需要多个选项，请使用数组初始化语法。'
- en: '`AnnotationDemo` also has the `@Retention(RetentionPolicy.RUNTIME)` annotation
    to request that it be preserved until runtime. This is obviously required for
    any annotation that will be examined by a framework at runtime.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`AnnotationDemo` 还具有 `@Retention(RetentionPolicy.RUNTIME)` 注解，请求在运行时保留它。显然，任何在运行时被框架检查的注解都需要此注解。'
- en: These two meta-annotations are common on user-defined annotations that will
    be examined at runtime.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个元注解通常用于运行时检查的用户定义注解。
- en: The class `FancyClassJustToShowAnnotation` shows using the `AnnotationDemo`
    annotation, along with a standard Java one (the `@Resource` annotation).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 类 `FancyClassJustToShowAnnotation` 展示了如何使用 `AnnotationDemo` 注解，以及一个标准的 Java
    注解（`@Resource` 注解）。
- en: Refer to [Recipe 17.11](#javacook-reflection-pluginViaAnnotations) for a full
    example of using this mechanism.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 参考 [Recipe 17.11](#javacook-reflection-pluginViaAnnotations) 以查看如何完整使用此机制的示例。
- en: 17.11 Finding Plug-In-Like Classes via Annotations
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 17.11 通过注解查找类似插件的类
- en: Problem
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to do plug-in-like things without using an explicit plug-in API.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望执行类似插件的操作，但又不想使用显式的插件 API。
- en: Solution
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Define an annotation for the purpose, and use it to mark the plug-in classes.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 为此目的定义一个注解，并使用它来标记插件类。
- en: Discussion
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Suppose we want to model how the Java EE standard `javax.annotations.Named`
    or `javax.faces.ManagedBean` annotations work; for each class that is so annotated,
    convert the class name to an instance-like name (e.g, lowercase the first letter),
    and do something special with it. You’d want to do something like the following:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想建模 Java EE 标准中的 `javax.annotations.Named` 或 `javax.faces.ManagedBean` 注解的工作方式；对于每个使用这些注解的类，将类名转换为类似实例的名称（例如，将首字母小写），并进行特殊处理。您可能希望像以下这样做：
- en: Get the list of classes in the given package(s) (see [Recipe 17.9](#javacook-reflection-classesInPackage)).
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取给定包中的类列表（参见[Recipe 17.9](#javacook-reflection-classesInPackage)）。
- en: Check if the class is annotated.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查类是否已注解。
- en: If so, save the name and `Class` descriptor for later use.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是这样，请保存名称和稍后使用的 `Class` 描述符。
- en: This is implemented in [Example 17-22](#javacook-reflection-EX-8Y).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这在 [Example 17-22](#javacook-reflection-EX-8Y) 中实现。
- en: Example 17-22\. main/src/main/java/reflection/PluginsViaAnnotations
  id: totrans-245
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 17-22\. main/src/main/java/reflection/PluginsViaAnnotations
- en: '[PRE29]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can take this one step further and support particular method annotations,
    similar to `javax.annotations.PostCreate`, which is meant to decorate a method
    that is to be called after an instance of the bean has been instantiated by the
    framework. Our flow is now something like this, and the code is shown in [Example 17-23](#javacook-reflection-EX-8Z):'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进一步支持特定方法注解，类似于 `javax.annotations.PostCreate`，用于装饰在框架实例化 bean 后调用的方法。我们的流程现在类似于这样，并且代码显示在[Example
    17-23](#javacook-reflection-EX-8Z)中：
- en: Get the list of classes in the given package(s) (again, see [Recipe 17.9](#javacook-reflection-classesInPackage)).
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取给定包中的类列表（参见[Recipe 17.9](#javacook-reflection-classesInPackage)）。
- en: If you are using a class-level annotation, check if the class is annotated.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果使用类级别的注解，请检查该类是否已注解。
- en: If this class is still of interest, get a list of its methods.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果此类仍然感兴趣，请获取其方法列表。
- en: For each method, see if it contains a given method-specific annotation.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个方法，查看其是否包含给定的特定方法注解。
- en: If so, add the class and method to a list of invocable methods.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是这样，请将该类和方法添加到可调用方法列表中。
- en: Example 17-23\. main/src/main/java/reflection/PluginsViaAnnotations (find annotated
    methods)
  id: totrans-253
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 17-23\. main/src/main/java/reflection/PluginsViaAnnotations（查找带注解方法）
- en: '[PRE30]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: See Also
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 17.10](#javacook-reflection-annotations) and the rest of this chapter.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '[第17.10节](#javacook-reflection-annotations)及本章剩余内容。'
- en: '17.12 Program: CrossRef'
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 17.12 程序：交叉引用
- en: 'You’ve probably seen those other Java books that consist entirely of listings
    of the Java API for version thus-and-such of the JDK. I don’t suppose you thought
    the authors of these works sat down and typed the entire contents from scratch.
    As a programmer, you would have realized, I hope, that there must be a way to
    obtain that information from Java. But you might not have realized how easy it
    is! If you’ve read this chapter faithfully, you now know that there is one true
    way: make the computer do the walking. [Example 17-24](#javacook-reflection-EX-9)
    is a program that puts most of the techniques together. This version generates
    a cross-reference listing, but by overriding the last few methods, you could easily
    convert it to print the information in any format you like, including an API reference
    book. You’d need to deal with the details of this or that publishing software—FrameMaker,
    troff, T[E]X, or whatever—but that’s the easy part.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能见过那些完全由Java API列表组成的其他Java书籍，这些书籍针对JDK的某个版本。我不认为你会认为这些作品的作者坐下来从头开始键入整个内容。作为一个程序员，希望你意识到，必须有一种方法从Java获取这些信息。但你可能没有意识到这是多么容易！如果你忠实地阅读了这一章，现在你知道有一种真正的方法：让计算机来走这条路。[示例 17-24](#javacook-reflection-EX-9)
    是一个将大部分技术结合在一起的程序。这个版本生成了一个交叉引用列表，但通过重写最后几个方法，你可以轻松地将其转换为以任何你喜欢的格式打印信息，包括API参考书。你需要处理这些或那些发布软件的细节——FrameMaker、troff、T[E]X，或者其他——但这是简单的部分。
- en: This program makes fuller use of the Reflection API than did `MyJavaP` in [Recipe
    17.8](#javacook-reflection-SECT-6). It also uses the `java.util.zip` classes (see
    [Recipe 10.15](ch10.html#javacook-io-SECT-20)) to crack the JAR archive containing
    the class files of the API. Each class file found in the archive is loaded and
    listed; the listing part is similar to `MyJavaP`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序比[第17.8节](#javacook-reflection-SECT-6)的`MyJavaP`更充分地利用了反射API。它还使用了`java.util.zip`类（参见[第10.15节](ch10.html#javacook-io-SECT-20)），以破解包含API类文件的JAR存档。加载并列出存档中找到的每个类文件；列表部分类似于`MyJavaP`。
- en: Example 17-24\. main/src/main/java/reflection/CrossRef.java
  id: totrans-260
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-24\. main/src/main/java/reflection/CrossRef.java
- en: '[PRE31]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You probably noticed the methods `startClass()` and `endClass()`, which are
    null. These methods are placeholders designed to make subclassing easy for when
    you need to write something at the start and end of each class. One example might
    be a fancy text formatting application in which you need to output a bold header
    at the beginning of each class. Another would be XML, where you’d want to write
    a tag like `<class>` at the front of each class and `</class>` at the end. [Example 17-25](#javacook-reflection-EX-10)
    is an XML-specific subclass that generates (limited) XML for each field and method.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了`startClass()`和`endClass()`这两个方法，它们是空的。这些方法是为了在每个类的开始和结束时方便子类化而设计的占位符。一个例子可能是一个高级文本格式化应用程序，在每个类的开头输出粗体标题。另一个例子可能是XML，你需要在每个类的前面写一个像`<class>`这样的标签，以及类的末尾写一个`</class>`。[示例 17-25](#javacook-reflection-EX-10)
    是一个特定于XML的子类，为每个字段和方法生成（有限的）XML。
- en: Example 17-25\. main/src/main/java/reflection/CrossRefXML.java
  id: totrans-263
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-25\. main/src/main/java/reflection/CrossRefXML.java
- en: '[PRE32]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: By the way, if you publish a book using either of these and get rich, “Remember,
    remember me!”
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，如果你用这些方法出书赚大钱了，“记得，记得我！”
- en: See Also
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: We have not investigated all the ins and outs of reflection or the `ClassLoader`
    mechanism, but by now you should have a basic idea of how it works.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有探讨反射或`ClassLoader`机制的方方面面，但现在你应该对其工作原理有一个基本的了解。
- en: Perhaps the most important omissions are `SecurityManager` and `ProtectionDomain`.
    Only one `SecurityManager` can be installed in a given instance of the JVM (e.g.,
    to prevent malicious code from providing its own!). A browser running the old
    Java Applet API, for example, provides a `SecurityManager` that is far more restrictive
    than the standard one. Writing such a `SecurityManager` is left as an exercise
    for the reader—an important exercise for anyone planning to load classes over
    the internet! (For more information about security managers and the Java Security
    APIs, see *[Java Security](http://oreil.ly/java-security-2nd)* by Scott Oaks (O’Reilly).
    A `ProtectionDomain` can be provided with a `ClassLoader` to specify all the permissions
    needed for the class to run.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 可能最重要的遗漏是 `SecurityManager` 和 `ProtectionDomain`。在给定的 JVM 实例中只能安装一个 `SecurityManager`（例如，防止恶意代码提供自己的
    `SecurityManager`！）。例如，运行旧的 Java Applet API 的浏览器提供的 `SecurityManager` 比标准的要严格得多。编写这样的
    `SecurityManager` 留给读者作为一个重要练习，特别是计划从互联网加载类的任何人！（有关安全管理器和 Java 安全 API 的更多信息，请参阅
    *[Java Security](http://oreil.ly/java-security-2nd)*，作者 Scott Oaks（O'Reilly）。`ProtectionDomain`
    可以通过 `ClassLoader` 提供给指定类运行所需的所有权限。
- en: I’ve also left unexplored many topics in the JVM; see the (somewhat dated) O’Reilly
    books *[Java Virtual Machine](http://shop.oreilly.com/product/9781565921948.do)*
    by Troy Downing and Jon Meyer, and *[Java Language Reference](http://shop.oreilly.com/product/9781565923263.do)*
    by Mark Grand. You can also read the Sun/Oracle *Java Language Specification*
    and *JVM Specification* documents (both updated with new releases, available [online](https://docs.oracle.com/en/java/javase/13/docs)),
    for a lifetime of reading enjoyment and edification!
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我还没有深入探讨 JVM 中的许多主题；可以参考（有些过时的）O'Reilly 图书 *[Java Virtual Machine](http://shop.oreilly.com/product/9781565921948.do)*，作者
    Troy Downing 和 Jon Meyer，以及 *[Java Language Reference](http://shop.oreilly.com/product/9781565923263.do)*，作者
    Mark Grand。你也可以阅读 Sun/Oracle 的 *Java 语言规范* 和 *JVM 规范* 文档（随新版本更新，可在线获取），享受和提高阅读的乐趣！
- en: The Apache Software Foundation maintains a vast array of useful software packages
    that are free to get and use. Source code is always available without charge from
    its website. Two packages you might want to investigate include the Commons BeanUtils
    and the Byte Code Engineering Library (BCEL). The [Commons BeanUtils](http://commons.apache.org/beanutils)
    claims to provide easier-to-use wrappers around some of the Reflection API. BCEL
    is a third-party toolkit for building and manipulating bytecode class files. Written
    by Markus Dahm, BCEL has become part of the [Apache Commons Project](http://commons.apache.org/bcel).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: Apache 软件基金会维护了一系列非常有用的软件包，可以免费获取和使用。源代码始终可以在其网站上免费获取。你可能想调查的两个包括 Commons BeanUtils
    和 Byte Code Engineering Library (BCEL)。[Commons BeanUtils](http://commons.apache.org/beanutils)
    声称提供了一些对反射 API 更易使用的包装器。BCEL 是一个第三方工具包，用于构建和操作字节码类文件。由 Markus Dahm 编写的 BCEL 已成为
    [Apache Commons 项目](http://commons.apache.org/bcel) 的一部分。
