- en: Chapter 10\. Beyond Selenium
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第十章。超越 Selenium
- en: 'This chapter closes this book by presenting several complementary technologies
    to Selenium. First, we analyze the basics of mobile apps and introduce Appium,
    a popular testing framework for mobile testing. Then, you will learn how to test
    REST (REpresentational State Transfer) services with an open source Java library
    called REST Assured. Finally, you will be introduced to alternative tools to Selenium
    WebDriver for implementing end-to-end tests for web applications, namely: Cypress,
    WebDriverIO, TestCafe, Puppeteer, and Playwright.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章通过介绍几种与 Selenium 互补的技术来结束本书。首先，我们分析了移动应用程序的基础并介绍了 Appium，这是一个流行的用于移动测试的测试框架。然后，您将学习如何使用名为
    REST Assured 的开源 Java 库测试 REST（表现状态转移）服务。最后，您将介绍用于实施 Web 应用程序端到端测试的 Selenium WebDriver
    的替代工具，即：Cypress、WebDriverIO、TestCafe、Puppeteer 和 Playwright。
- en: Mobile Apps
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动应用程序
- en: 'Mobile applications (usually called mobile apps, or simply apps) are software
    applications designed to run on mobile devices, such as smartphones, tablets,
    or wearables. There are two principal operating systems for mobile devices:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 移动应用程序（通常称为移动应用程序或简称为应用程序）是专为运行在移动设备上设计的软件应用程序，例如智能手机、平板电脑或可穿戴设备。移动设备的两个主要操作系统为：
- en: '[Android](https://www.android.com)'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[安卓](https://www.android.com)'
- en: An open source (Apache 2.0 license) mobile operating system based on a modified
    version of Linux. It was initially developed by a startup named Android, acquired
    by Google in 2005.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 基于修改版 Linux 的开源（Apache 2.0 许可）移动操作系统。最初由名为 Android 的初创公司开发，于 2005 年被 Google
    收购。
- en: '[iOS](https://www.apple.com/ios)'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '[iOS](https://www.apple.com/ios)'
- en: A proprietary mobile operating system created by Apple exclusively for its hardware
    (e.g., iPhone, iPad, or Watch).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 由苹果专门为其硬件（例如 iPhone、iPad 或 Watch）创建的专有移动操作系统。
- en: 'A common way to classify mobile apps is as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对移动应用程序进行分类的一种常见方式如下：
- en: Native apps
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本地应用程序
- en: Mobile apps developed for a particular mobile operating system (e.g., Android
    or iOS).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 针对特定移动操作系统（例如 Android 或 iOS）开发的移动应用程序。
- en: Web-based apps
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 Web 的应用程序
- en: Web applications rendered into a mobile browser (e.g., Chrome, Safari, or Firefox
    Mobile). These apps are typically designed to be *responsive* (i.e., adaptable
    to different screen sizes and viewports).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动浏览器（例如 Chrome、Safari 或 Firefox Mobile）中渲染的 Web 应用程序。这些应用程序通常设计为 *响应式*（即可适应不同的屏幕大小和视口）。
- en: Hybrid apps
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 混合应用程序
- en: Mobile applications developed using client-side web standards (i.e., HTML, CSS,
    and JavaScript) and deployed to mobile devices using a native container called
    *webview*. Examples of frameworks that enable the development of hybrid apps are
    [Ionic](https://ionicframework.com), [React Native](https://reactnative.dev),
    or [Flutter](https://flutter.dev).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用客户端 Web 标准（即 HTML、CSS 和 JavaScript）开发的移动应用程序，并使用称为 *webview* 的本地容器部署到移动设备上。支持混合应用程序开发的框架示例包括
    [Ionic](https://ionicframework.com)、[React Native](https://reactnative.dev) 或
    [Flutter](https://flutter.dev)。
- en: Progressive web apps (PWAs)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 渐进式 Web 应用程序（PWA）
- en: Web applications built with modern web standard APIs (for installability, responsiveness,
    etc.) intended to work on multiple platforms, including desktop and mobile devices.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用现代 Web 标准 API 构建的 Web 应用程序（用于可安装性、响应性等），旨在在多个平台上运行，包括桌面和移动设备。
- en: Mobile Testing
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动测试
- en: 'Testing is an essential process in the development of mobile apps. Mobile testing
    involves different challenges such as hardware compatibility, network connectivity,
    or operating system specifics. Different approaches to carry out mobile testing
    include:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是移动应用程序开发中的重要流程。移动测试涉及诸如硬件兼容性、网络连接性或操作系统特定性等不同挑战。执行移动测试的不同方法包括：
- en: Using desktop browsers with mobile emulation
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用桌面浏览器进行移动仿真
- en: We can use Selenium WebDriver for this type of mobile testing. To that aim,
    you can use browser-specific features (as explained in [“Device Emulation”](ch05.html#sect-caps-device-emulation))
    or use the CDP with Chromium-based browsers (as explained in [“Device emulation”](ch05.html#sect-cdp-device-emulation)).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Selenium WebDriver 进行此类移动测试。为此，您可以使用特定于浏览器的功能（如[“设备仿真”](ch05.html#sect-caps-device-emulation)中所述），或者使用基于
    Chromium 的浏览器中的 CDP（如[“设备仿真”](ch05.html#sect-cdp-device-emulation)中所述）。
- en: Using virtual devices
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用虚拟设备
- en: 'There are two types of virtual mobile devices:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的虚拟移动设备：
- en: Emulators
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟器
- en: Desktop applications that virtualize all aspects of mobile devices, including
    the hardware and the operating system.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 桌面应用程序，虚拟化移动设备的所有方面，包括硬件和操作系统。
- en: Simulators
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟器
- en: Desktop apps that mimic certain features of a mobile operating system. They
    are primarily intended for iOS since Android devices are emulated easily.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 模仿移动操作系统某些功能的桌面应用程序。它们主要用于 iOS，因为 Android 设备很容易模拟。
- en: Using real devices
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用真实设备
- en: Using actual devices and their native Android or iOS APIs in real conditions.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用实际设备及其在真实条件下的本机 Android 或 iOS API。
- en: Appium
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Appium
- en: '[Appium](https://appium.io) is an open source test automation framework for
    mobile apps. Appium provides a cross-platform API that allows testing native,
    hybrid, and mobile web apps for iOS and Android on virtual or real devices. Furthermore,
    Appium enables automated testing for desktop applications on Windows and macOS.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[Appium](https://appium.io) 是一个用于移动应用的开源测试自动化框架。Appium 提供了一个跨平台的 API，允许在虚拟或真实设备上测试
    iOS 和 Android 的本地、混合和移动 Web 应用程序。此外，Appium 还能够在 Windows 和 macOS 上对桌面应用程序进行自动化测试。'
- en: The story of Appium started in 2011 when Dan Cuellar created an automation tool
    for iOS applications developed in C# called iOSAuto. He met Jason Huggins (the
    co-creator of Selenium) during the SeleniumConf 2012 in London. Jason contributed
    to the project by adding a web server and using the WebDriver wire protocol over
    HTTP, making iOSAuto compatible with any Selenium WebDriver client. They changed
    the project name to Appium (the *Selenium for Apps*). In January 2013, Sauce Labs
    decided to support Appium and provide more developer power. The new team rewrote
    Appium using Node.js since it is a well-known, efficient framework for the server
    side.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Appium 的故事始于 2011 年，当时 Dan Cuellar 创建了一个名为 iOSAuto 的用于 C# 开发的 iOS 应用程序自动化工具。他在
    2012 年的伦敦 SeleniumConf 上遇到了 Selenium 的共同创始人 Jason Huggins。Jason 通过添加一个 Web 服务器，并使用基于
    HTTP 的 WebDriver wire 协议，使 iOSAuto 兼容任何 Selenium WebDriver 客户端。他们将项目更名为 Appium（*适用于应用程序的
    Selenium*）。2013 年 1 月，Sauce Labs 决定支持 Appium 并提供更多开发者力量。新团队使用 Node.js 重写了 Appium，因为它是服务器端的知名高效框架。
- en: As depicted in [Figure 10-1](#appium-arch), Appium follows a client-server architecture.
    Appium is a web server that exposes a REST API that carries out an automated session
    on mobile or desktop apps. To that aim, the Appium server receives incoming requests
    from clients, executes those commands on target devices/apps, and responds with
    an HTTP response representing the command execution result. Appium client libraries
    communicate with the Appium server using the Mobile JSON Wire Protocol (an official
    draft extension to the original WebDriver protocol). The Appium server and its
    client also use the W3C Webdriver specification. There are different Appium client
    libraries. [Table 10-1](#appium-clients) summarizes these libraries, both officially
    maintained by the Appium project and community.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [图 10-1](#appium-arch) 所示，Appium 遵循客户端-服务器架构。Appium 是一个 Web 服务器，暴露了一个 REST
    API，用于在移动或桌面应用上执行自动化会话。因此，Appium 服务器接收来自客户端的传入请求，在目标设备/应用上执行这些命令，并以 HTTP 响应形式返回代表命令执行结果的信息。Appium
    客户端库使用移动 JSON Wire Protocol（作为原始 WebDriver 协议的官方扩展草案）。Appium 服务器及其客户端还使用 W3C WebDriver
    规范。Appium 项目和社区维护了不同的 Appium 客户端库。[表 10-1](#appium-clients) 总结了这些官方维护的和社区维护的库。
- en: '![hosw 1001](assets/hosw_1001.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![hosw 1001](assets/hosw_1001.png)'
- en: Figure 10-1\. Appium architecture
  id: totrans-34
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-1\. Appium 架构
- en: Table 10-1\. Appium client libraries
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 10-1\. Appium 客户端库
- en: '| Name | Language | License | Maintainer | Website |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 语言 | 许可证 | 维护者 | 网站 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| Appium java-client | Java | Apache 2.0 | Appium team | [*https://github.com/appium/java-client*](https://github.com/appium/java-client)
    |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| Appium java-client | Java | Apache 2.0 | Appium 团队 | [*https://github.com/appium/java-client*](https://github.com/appium/java-client)
    |'
- en: '| Appium ruby_lib | Ruby | Apache 2.0 | Appium team | [*https://github.com/appium/ruby_lib*](https://github.com/appium/ruby_lib)
    |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| Appium ruby_lib | Ruby | Apache 2.0 | Appium 团队 | [*https://github.com/appium/ruby_lib*](https://github.com/appium/ruby_lib)
    |'
- en: '| Appium Python Client | Python | Apache 2.0 | Appium team | [*https://github.com/appium/python-client*](https://github.com/appium/python-client)
    |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| Appium Python 客户端 | Python | Apache 2.0 | Appium 团队 | [*https://github.com/appium/python-client*](https://github.com/appium/python-client)
    |'
- en: '| appium-dotnet-driver | C# | Apache 2.0 | Appium team | [*https://github.com/appium/appium-dotnet-driver*](https://github.com/appium/appium-dotnet-driver)
    |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| appium-dotnet-driver | C# | Apache 2.0 | Appium 团队 | [*https://github.com/appium/appium-dotnet-driver*](https://github.com/appium/appium-dotnet-driver)
    |'
- en: '| WebdriverIO | JavaScript (Node.js) | MIT | WebdriverIO team | [*https://webdriver.io*](https://webdriver.io)
    |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| WebdriverIO | JavaScript（Node.js） | MIT | WebdriverIO 团队 | [*https://webdriver.io*](https://webdriver.io)
    |'
- en: '| web2driver | JavaScript (browser) | Apache 2.0 | HeadSpin | [*https://github.com/projectxyzio/web2driver*](https://github.com/projectxyzio/web2driver)
    |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| web2driver | JavaScript（浏览器） | Apache 2.0 | HeadSpin | [*https://github.com/projectxyzio/web2driver*](https://github.com/projectxyzio/web2driver)
    |'
- en: '| Appium library for RobotFramework | Python | Apache 2.0 | Serhat Bolsu |
    [*https://github.com/serhatbolsu/robotframework-appiumlibrary*](https://github.com/serhatbolsu/robotframework-appiumlibrary)
    |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| RobotFramework 的 Appium 库 | Python | Apache 2.0 | Serhat Bolsu | [*https://github.com/serhatbolsu/robotframework-appiumlibrary*](https://github.com/serhatbolsu/robotframework-appiumlibrary)
    |'
- en: In Appium, the support for the automation of a particular platform is provided
    by a component called *driver* in Appium jargon. These drivers were tightly coupled
    with the Appium Server in version 1\. Nevertheless, in Appium 2 (the latest version
    of Appium at the time of this writing), these drivers are segregated from the
    Appium Server (see [Figure 10-1](#appium-arch)) and are installed separately.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Appium 中，对特定平台的自动化支持是由 Appium 行话中称为 *driver* 的组件提供的。这些驱动程序在版本 1 中与 Appium
    服务器紧密耦合。然而，在本文撰写时的最新版本 Appium 2 中，这些驱动程序与 Appium 服务器分开（参见 [图 10-1](#appium-arch)）并单独安装。
- en: Table 10-2\. Appium drivers
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Appium 驱动程序表格 10-2
- en: '| Name | Target | Description | Repository |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 目标 | 描述 | 存储库 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| XCUITest Driver | iOS and tvOS apps | Leverages Apple’s XCUITest libraries
    to enable automation | [*https://github.com/appium/appium-xcuitest-driver*](https://github.com/appium/appium-xcuitest-driver)
    |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| XCUITest 驱动程序 | iOS 和 tvOS 应用程序 | 利用 Apple 的 XCUITest 库实现自动化 | [*https://github.com/appium/appium-xcuitest-driver*](https://github.com/appium/appium-xcuitest-driver)
    |'
- en: '| Espresso Driver | Android apps | Enables automation through Espresso (a testing
    framework for Android) | [*https://github.com/appium/appium-espresso-driver*](https://github.com/appium/appium-espresso-driver)
    |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| Espresso 驱动程序 | Android 应用程序 | 通过 Espresso（Android 的测试框架）实现自动化 | [*https://github.com/appium/appium-espresso-driver*](https://github.com/appium/appium-espresso-driver)
    |'
- en: '| UiAutomator2 Driver | Android apps | Leverages Google UiAutomator2 technology
    to enable automation on an Android device or emulator | [*https://github.com/appium/appium-uiautomator2-driver*](https://github.com/appium/appium-uiautomator2-driver)
    |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| UiAutomator2 驱动程序 | Android 应用程序 | 利用 Google UiAutomator2 技术在 Android 设备或模拟器上实现自动化
    | [*https://github.com/appium/appium-uiautomator2-driver*](https://github.com/appium/appium-uiautomator2-driver)
    |'
- en: '| Windows Driver | Windows desktop apps | Uses WinAppDriver, a WebDriver server
    for Windows desktop apps | [*https://github.com/appium/appium-windows-driver*](https://github.com/appium/appium-windows-driver)
    |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| Windows 驱动程序 | Windows 桌面应用程序 | 使用 WinAppDriver，Windows 桌面应用程序的 WebDriver
    服务器 | [*https://github.com/appium/appium-windows-driver*](https://github.com/appium/appium-windows-driver)
    |'
- en: '| Mac Driver | macOS desktop apps | Uses Apple’s XCTest framework for automating
    macOS applications | [*https://github.com/appium/appium-mac2-driver*](https://github.com/appium/appium-mac2-driver)
    |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| Mac 驱动程序 | macOS 桌面应用程序 | 使用 Apple 的 XCTest 框架自动化 macOS 应用程序 | [*https://github.com/appium/appium-mac2-driver*](https://github.com/appium/appium-mac2-driver)
    |'
- en: A basic Appium test
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个基本的 Appium 测试
- en: 'This section presents a basic test case using Appium server 2 and the Appium
    Java client. For simplicity, I use the UiAutomator2 Driver and an emulated Android
    device. The SUT will be a web application, concretely, the practice site used
    throughout this book. The calls to the Appium Java clients are embedded in the
    different unit testing frameworks used in the rest of the examples (i.e., JUnit
    4 and 5, TestNG, and Selenium-Jupiter). As usual, you can find the complete source
    code in the examples repository. The requisites for running this test are:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了使用 Appium 服务器 2 和 Appium Java 客户端的基本测试用例。为了简单起见，我使用了 UiAutomator2 驱动程序和一个模拟的
    Android 设备。SUT 将是一个 Web 应用程序，具体来说，是本书中始终使用的练习站点。对 Appium Java 客户端的调用嵌入在其他示例中使用的不同单元测试框架中（即
    JUnit 4 和 5、TestNG 和 Selenium-Jupiter）。如往常一样，您可以在示例存储库中找到完整的源代码。运行此测试的要求如下：
- en: Install Appium server 2.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 Appium 服务器 2。
- en: Install UiAutomator2 Driver.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 UiAutomator2 驱动程序。
- en: Install Android SDK (i.e., the official software development kit for Android).
    You can easily install this SDK by installing [Android Studio](https://developer.android.com/studio)
    on your computer.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 Android SDK（即 Android 的官方软件开发工具包）。您可以通过在计算机上安装[Android Studio](https://developer.android.com/studio)来轻松安装此
    SDK。
- en: Create an Android Virtual Device (AVD) using the AVD Manager in Android Studio.
    [Figure 10-2](#android-studio) shows the menu option to open this tool, and [Figure 10-3](#avd)
    shows the virtual device used in the test (a Nexus 5 mobile phone using the Android
    API level 30).
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Android Studio 中的 AVD 管理器创建 Android 虚拟设备（AVD）。[图 10-2](#android-studio) 显示了打开此工具的菜单选项，[图
    10-3](#avd) 显示了测试中使用的虚拟设备（使用 Android API 级别 30 的 Nexus 5 手机）。
- en: Start the virtual device and Appium server.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动虚拟设备和 Appium 服务器。
- en: '![hosw 1002](assets/hosw_1002.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![hosw 1002](assets/hosw_1002.png)'
- en: Figure 10-2\. Android Studio
  id: totrans-62
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-2\. Android Studio
- en: '![hosw 1003](assets/hosw_1003.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![hosw 1003](assets/hosw_1003.png)'
- en: Figure 10-3\. AVD Manager
  id: totrans-64
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-3\. AVD 管理器
- en: 'As explained previously, the Appium server is a Node.js application. Therefore,
    you need Node.js installed in your system to run Appium. The following commands
    summarize how to install the Appium server 2 and the UiAutomator2 Driver, and
    how to start the Appium server:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Appium 服务器是一个 Node.js 应用程序。因此，您需要在系统中安装 Node.js 才能运行 Appium。以下命令概述了如何安装
    Appium 服务器 2 和 UiAutomator2 驱动程序，以及如何启动 Appium 服务器：
- en: '[PRE0]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[![1](assets/1.png)](#co_beyond_selenium_CO1-1)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_beyond_selenium_CO1-1)'
- en: We use npm (the default package manager for Node.js) to install Appium 2.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 npm（Node.js 的默认软件包管理器）安装 Appium 2。
- en: '[![2](assets/2.png)](#co_beyond_selenium_CO1-2)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_beyond_selenium_CO1-2)'
- en: We use Appium to install the UiAutomator2 Driver.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Appium 安装 UiAutomator2 驱动程序。
- en: '[![3](assets/3.png)](#co_beyond_selenium_CO1-3)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_beyond_selenium_CO1-3)'
- en: We start the Appium server (by default, it listens to port 4723). We include
    a flag to let Appium manage the required browser drivers (e.g., chromedriver)
    for automating web applications (just like in Selenium WebDriver).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们启动 Appium 服务器（默认情况下，它监听端口 4723）。我们包含一个标志，让 Appium 管理所需的浏览器驱动程序（例如，chromedriver）以自动化
    Web 应用程序（就像在 Selenium WebDriver 中一样）。
- en: '[Example 10-1](#appium-java-client-test) shows a complete test using the Appium
    Java client. As you can see, this test is quite similar to the regular Selenium
    WebDriver tests explained in this book. The main difference, in this case, is
    that we use an instance of `AppiumDriver`, a class provided by the Appium Java
    client. This class extends to the `RemoteWebDriver` class of the Selenium WebDriver
    API. Therefore, we can leverage the Selenium WebDriver API to test web applications
    on mobile devices. [Figure 10-4](#android-device) shows the emulated mobile device
    (a Nexus 5) during this test.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 10-1](#appium-java-client-test) 展示了使用 Appium Java 客户端进行完整测试的示例。正如你所见，这个测试与本书中解释的常规
    Selenium WebDriver 测试非常相似。在这种情况下的主要区别是，我们使用了 `AppiumDriver` 的一个实例，这是 Appium Java
    客户端提供的一个类。该类扩展了 Selenium WebDriver API 的 `RemoteWebDriver` 类。因此，我们可以利用 Selenium
    WebDriver API 来测试移动设备上的 Web 应用程序。[图 10-4](#android-device) 展示了在此测试期间的模拟移动设备（Nexus
    5）。'
- en: '![hosw 1004](assets/hosw_1004.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![hosw 1004](assets/hosw_1004.png)'
- en: Figure 10-4\. Android device
  id: totrans-75
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-4\. Android 设备
- en: Example 10-1\. Test using Appium Java client
  id: totrans-76
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-1\. 使用 Appium Java 客户端进行测试
- en: '[PRE1]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[![1](assets/1.png)](#co_beyond_selenium_CO2-1)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_beyond_selenium_CO2-1)'
- en: We specify the Appium server URL.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定了 Appium 服务器 URL。
- en: '[![2](assets/2.png)](#co_beyond_selenium_CO2-2)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_beyond_selenium_CO2-2)'
- en: We make an assumption using the endpoint `/status` of the Appium server URL.
    If this URL is not online, the test is skipped.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设使用 Appium 服务器 URL 的端点 `/status`。如果此 URL 不在线，则跳过测试。
- en: '[![3](assets/3.png)](#co_beyond_selenium_CO2-3)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_beyond_selenium_CO2-3)'
- en: We use Chrome options to specify capabilities.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Chrome 选项来指定功能。
- en: '[![4](assets/4.png)](#co_beyond_selenium_CO2-4)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_beyond_selenium_CO2-4)'
- en: The first mandatory capability when using Appium is the platform name (`Android`
    in this case).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Appium 时的第一个强制性功能是平台名称（在本例中为 `Android`）。
- en: '[![5](assets/5.png)](#co_beyond_selenium_CO2-5)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_beyond_selenium_CO2-5)'
- en: The following required capability is the device name. This name must match the
    name defined in the AVD manager (see [Figure 10-3](#avd)).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是设备名称。此名称必须与 AVD 管理器中定义的名称匹配（参见 [图 10-3](#avd)）。
- en: '[![6](assets/6.png)](#co_beyond_selenium_CO2-6)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_beyond_selenium_CO2-6)'
- en: The last mandatory capability is the driver name (`UiAutomator2` in this case).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个强制性功能是驱动程序名称（在本例中为 `UiAutomator2`）。
- en: '[![7](assets/7.png)](#co_beyond_selenium_CO2-7)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_beyond_selenium_CO2-7)'
- en: We create an instance of `AppiumDriver` using the Appium server URL and the
    browser options.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Appium 服务器 URL 和浏览器选项创建了一个 `AppiumDriver` 的实例。
- en: '[![8](assets/8.png)](#co_beyond_selenium_CO2-8)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_beyond_selenium_CO2-8)'
- en: We use the `driver` object to exercise the SUT as usual.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们像往常一样使用 `driver` 对象来执行 SUT。
- en: REST Services
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST 服务
- en: REST (REpresentational State Transfer) is an architectural style for designing
    distributed services. Roy Fielding coined this term in his 2000 doctoral dissertation.
    REST is a popular way of creating web services on top of the HTTP protocol.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: REST（表现状态转移）是一种用于设计分布式服务的架构风格。Roy Fielding 在他的 2000 年博士论文中创造了这个术语。REST 是在 HTTP
    协议之上创建 Web 服务的流行方式。
- en: REST follows a client-server architecture. The server handles a set of *resources*,
    listening for incoming requests made by clients. These resources are the building
    blocks of REST services and define the type of information transferred. Each resource
    is identified uniquely. In HTTP, we use URLs (also known as *endpoints*) for accessing
    individual resources. Each resource has a representation, a machine-readable explanation
    of the current state of a resource. We use a data-interchange format for defining
    representations, such as JSON, YAML, or XML. REST services expose a set of *actions*
    on the resources, such as CRUD (create, retrieve, update, and delete). We can
    use the HTTP methods (the so-called *verbs*) to map REST actions. [Table 10-3](#http-method-rest)
    summarizes the HTTP methods used to create REST services. Finally, we can use
    the HTTP status codes to identify the response associated with REST actions. [Table 10-4](#http-status-rest)
    summarizes the typical HTTP status codes used in REST. [Figure 10-5](#rest-example)
    shows a sequence of requests and responses of an example REST service that uses
    different HTTP methods and response codes.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: REST 遵循客户端-服务器架构。服务器处理一组*资源*，监听客户端发出的传入请求。这些资源是 REST 服务的构建块，并定义了传输的信息类型。每个资源都有唯一的标识。在
    HTTP 中，我们使用 URL（也称为*端点*）来访问单个资源。每个资源都有一个表示形式，即资源当前状态的机器可读说明。我们使用数据交换格式来定义表示，如
    JSON、YAML 或 XML。REST 服务公开一组对资源执行的*操作*，例如 CRUD（创建、检索、更新和删除）。我们可以使用 HTTP 方法（也称为*动词*）来映射
    REST 操作。[表 10-3](#http-method-rest) 总结了用于创建 REST 服务的 HTTP 方法。最后，我们可以使用 HTTP 状态码来识别与
    REST 操作相关联的响应。[表 10-4](#http-status-rest) 总结了在 REST 中使用的典型 HTTP 状态码。[图 10-5](#rest-example)
    显示了一个示例 REST 服务的请求和响应序列，该服务使用了不同的 HTTP 方法和响应代码。
- en: Table 10-3\. HTTP methods for creating REST services
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10-3\. 用于创建 REST 服务的 HTTP 方法
- en: '| HTTP Method | Description |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| HTTP 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `GET` | Read a resource |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 读取资源 |'
- en: '| `POST` | Send a new resource to the server |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | 将新资源发送到服务器 |'
- en: '| `PUT` | Update a resource |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` | 更新资源 |'
- en: '| `DELETE` | Eliminate a resource |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | 删除资源 |'
- en: '| `PATCH` | Partially update a resource |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `PATCH` | 部分更新资源 |'
- en: '| `HEAD` | Ask if a given resource exists without returning any of its representations
    |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `HEAD` | 询问给定资源是否存在，而不返回其任何表示形式 |'
- en: '| `OPTIONS` | Retrieve the available verbs for a given resource |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `OPTIONS` | 检索给定资源的可用动词 |'
- en: Table 10-4\. HTTP status codes for creating REST services
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10-4\. 用于创建 REST 服务的 HTTP 状态码
- en: '| Status Code | Description |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 状态码 | 描述 |'
- en: '| --- | --- |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `200 OK` | The request was successful, and the content requested was returned
    (e.g., in a `GET` request). |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `200 OK` | 请求成功，返回请求的内容（例如在 `GET` 请求中）。 |'
- en: '| `201 Created` | The resource was created (e.g., in a `POST` or `PUT` request).
    |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `201 Created` | 已创建资源（例如在 `POST` 或 `PUT` 请求中）。 |'
- en: '| `204 No content` | The action was successful, but no content was returned.
    This status code is useful in actions that do not require a response body (e.g.,
    in a DELETE request). |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `204 No content` | 操作成功，但未返回内容。此状态码在不需要响应主体的操作中很有用（例如在 DELETE 请求中）。 |'
- en: '| `301 Moved permanently` | The resource was moved to another location. |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `301 Moved permanently` | 资源已移动到另一个位置。 |'
- en: '| `400 Bad request` | The request has some problems (e.g., missing parameters).
    |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `400 Bad request` | 请求存在问题（例如，缺少参数）。 |'
- en: '| `401 Unauthorized` | The requested resource is not accessible for the user
    that made the request. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `401 Unauthorized` | 请求的资源对于发出请求的用户不可访问。 |'
- en: '| `403 Forbidden` | The resource is not accessible, but unlike `401`, authentication
    will not affect the response. |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `403 Forbidden` | 资源不可访问，但与 `401` 不同，身份验证不会影响响应。 |'
- en: '| `404 Not found` | The provided endpoint does not identify any resource. |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `404 Not found` | 提供的端点未标识任何资源。 |'
- en: '| `405 Method not allowed` | The used verb is not allowed (e.g., when using
    `PUT` in a read-only resource). |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `405 Method not allowed` | 不允许使用的动词（例如在只读资源中使用 `PUT`）。 |'
- en: '| `500 Internal server error` | Generic unexpected condition in the server
    side. |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `500 Internal server error` | 服务器端发生一般性意外情况。 |'
- en: '![hosw 1005](assets/hosw_1005.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![hosw 1005](assets/hosw_1005.png)'
- en: Figure 10-5\. Example of a REST service
  id: totrans-121
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figure 10-5\. REST 服务示例
- en: REST Assured
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: REST Assured
- en: REST APIs are ubiquitous. As usual, it is highly recommended to implement automated
    tests for verifying these services, for instance, by using [REST Assured](https://rest-assured.io).
    REST Assured is a popular open source (Apache 2.0 license) Java library for testing
    REST services. It provides a fluent API for testing and validating REST services.
    A convenient way to create readable assertions with REST Assured is to generate
    POJOs (Plain Old Java Objects) to map the REST responses (e.g., in JSON format)
    as Java classes. Then, we can use a library like AssertJ to verify the expected
    conditions using the accessors (i.e., the getter methods) of these POJOs. [Example 10-2](#rest-assured-test)
    shows a test case using this approach. [Example 10-3](#rest-assured-pojo) contains
    the POJO used in this test.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: REST API 是无处不在的。通常情况下，强烈建议为验证这些服务实现自动化测试，例如使用 [REST Assured](https://rest-assured.io)。REST
    Assured 是一个流行的开源（Apache 2.0 许可）Java 库，用于测试 REST 服务。它提供了一个流畅的 API 用于测试和验证 REST
    服务。使用 REST Assured 创建可读断言的便捷方法是生成 POJOs（Plain Old Java Objects），将 REST 响应（例如 JSON
    格式）映射为 Java 类。然后，我们可以使用像 AssertJ 这样的库，通过这些 POJOs 的访问器（即 getter 方法）来验证预期条件。示例 [Example 10-2](#rest-assured-test)
    展示了使用这种方法的测试用例。示例 [Example 10-3](#rest-assured-pojo) 包含了此测试中使用的 POJO。
- en: Example 10-2\. Test using REST Assured
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 10-2\. 使用 REST Assured 进行测试
- en: '[PRE2]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[![1](assets/1.png)](#co_beyond_selenium_CO3-1)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_beyond_selenium_CO3-1)'
- en: We use REST Assured to request an online public REST service using the `GET`
    HTTP method. This line also verifies the expected status code (`200`) and converts
    the response payload (in JSON) to a Java class (shown in [Example 10-3](#rest-assured-pojo)).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 REST Assured 使用 `GET` HTTP 方法请求在线公共 REST 服务。此行还验证了预期的状态码（`200`），并将响应有效负载（以
    JSON 形式）转换为 Java 类（如示例 [Example 10-3](#rest-assured-pojo) 所示）。
- en: '[![2](assets/2.png)](#co_beyond_selenium_CO3-2)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_beyond_selenium_CO3-2)'
- en: We assert the header list (using the corresponding accessor method) contains
    a given key value.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们断言头部列表（使用相应的访问器方法）包含给定的键值对。
- en: '[![3](assets/3.png)](#co_beyond_selenium_CO3-3)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_beyond_selenium_CO3-3)'
- en: We assert that the origin is not blank.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们断言原点不为空。
- en: Example 10-3\. POJO class for testing a REST service
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 10-3\. 用于测试 REST 服务的 POJO 类
- en: '[PRE3]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[![1](assets/1.png)](#co_beyond_selenium_CO4-1)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_beyond_selenium_CO4-1)'
- en: This POJO defines a set of attributes to map the JSON response payload using
    Java.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 此 POJO 定义了一组属性，用于将 JSON 响应有效载荷映射到 Java 中。
- en: '[![2](assets/2.png)](#co_beyond_selenium_CO4-2)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_beyond_selenium_CO4-2)'
- en: We define accessors (getters) and mutators (setters) for each class attribute.
    Modern IDEs allow generating these methods automatically from the class attributes.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为每个类属性定义访问器（getter）和修改器（setter）。现代 IDE 允许从类属性自动生成这些方法。
- en: Alternatives to Selenium
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Selenium 的替代方案
- en: Selenium is currently the leading technology for implementing end-to-end tests.
    Nevertheless, it is not the only alternative available. This section provides
    an overview of other frameworks and libraries that also allow implementing end-to-end
    tests for web applications. In addition, the following subsections also review
    the main pros and cons of each of these alternatives. In my opinion, Selenium
    is still the reference solution for end-to-end testing since it is built to promote
    web standards (i.e., the W3C WebDriver and WebDriver BiDi) to support the automation
    process and, therefore, it guarantees cross-browser compatibility.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium 目前是实现端到端测试的领先技术。尽管如此，它并非唯一的可用选择。本节提供了其他框架和库的概述，这些框架和库同样允许为 Web 应用程序实现端到端测试。此外，以下小节还审视了每个这些替代方案的主要优缺点。在我看来，Selenium
    仍然是端到端测试的参考解决方案，因为它是为促进 Web 标准（即 W3C WebDriver 和 WebDriver BiDi）而构建，以支持自动化过程，从而确保跨浏览器兼容性。
- en: Cypress
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cypress
- en: '[Cypress](https://www.cypress.io) is a JavaScript end-to-end automated testing
    framework. As illustrated in [Figure 10-6](#cypress-arch), the Cypress architecture
    consists of a Node.js process plus a tool called *Test Runner* executed in a browser.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[Cypress](https://www.cypress.io) 是一个 JavaScript 端到端自动化测试框架。如 [Figure 10-6](#cypress-arch)
    所示，Cypress 架构包括一个 Node.js 进程以及在浏览器中执行的 *Test Runner* 工具。'
- en: '![hosw 1006](assets/hosw_1006.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![hosw 1006](assets/hosw_1006.png)'
- en: Figure 10-6\. Cypress architecture
  id: totrans-143
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figure 10-6\. Cypress 架构
- en: The Test Runner is an interactive web application that embeds a test based on
    [Mocha](https://mochajs.org) (a JavaScript unit testing framework) plus the web
    application under test as two iframes. Test code and the application code run
    in the same browser tab (i.e., in the same JavaScript loop). The Node.js process
    communicates with the Test Runner using a WebSocket. Finally, the Node.js process
    is a proxy for the HTTP traffic between the Test Runner and the web application
    under test.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 测试运行器是一个交互式的 Web 应用，它包含基于 [Mocha](https://mochajs.org)（一个 JavaScript 单元测试框架）的测试和被测试的
    Web 应用作为两个 iframe。测试代码和应用程序代码在同一个浏览器标签页中运行（即在同一个 JavaScript 循环中）。Node.js 进程使用
    WebSocket 与测试运行器进行通信。最后，Node.js 进程是测试运行器和被测试的 Web 应用之间 HTTP 流量的代理。
- en: The Cypress Test Runner is open source, licensed under the terms of the MIT
    license. The Cypress team also provides commercial support for advanced features.
    One of them is the Cypress Dashboard, a cloud-managed web application that allows
    tracking the tests executed in Test Runner. [Table 10-5](#cypress-pros-cons) summarizes
    some of the most relevant pros and cons of Cypress.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Cypress 测试运行器是开源的，根据 MIT 许可证授权。Cypress 团队还提供商业支持以获取高级功能。其中之一是 Cypress Dashboard，一个云管理的
    Web 应用，用于跟踪在测试运行器中执行的测试。[表格 10-5](#cypress-pros-cons) 总结了 Cypress 的一些最相关的优缺点。
- en: Table 10-5\. Cypress pros and cons
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 10-5\. Cypress 的优缺点
- en: '| Pros | Cons |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 优点 | 缺点 |'
- en: '| --- | --- |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Automatic waiting and fast execution, since the test and the application run
    in the same browser
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动等待和快速执行，因为测试和应用程序在同一个浏览器中运行。
- en: Live reload (the Test Runner automatically keeps track of changes in the tests)
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实时重载（测试运行器自动跟踪测试中的变化）
- en: '|'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Only some browsers supported: Firefox and Chromium-based (including Chrome,
    Edge, and Electron), but not other browsers like Safari or Opera'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅支持一些浏览器：Firefox 和基于 Chromium 的浏览器（包括 Chrome、Edge 和 Electron），但不支持其他浏览器如 Safari
    或 Opera。
- en: Since the application is executed in a browser iframe, certain operations are
    not allowed (e.g., drive different browsers or multiple tabs)
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于应用程序在浏览器 iframe 中执行，某些操作是不允许的（例如驱动不同的浏览器或多个标签页）。
- en: '|'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: The following commands show how to install Cypress locally and execute it. After
    executing these commands, you will see the Cypress GUI (like in [Figure 10-7](#cypress-process)).
    You can use this GUI to execute tests with Cypress.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令展示如何在本地安装 Cypress 并执行它。执行完这些命令后，你会看到 Cypress 的 GUI（类似于 [图 10-7](#cypress-process)）。你可以使用这个
    GUI 来执行 Cypress 的测试。
- en: '[PRE4]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[![1](assets/1.png)](#co_beyond_selenium_CO5-1)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_beyond_selenium_CO5-1)'
- en: We can use `npm` (the default package manager in Node.js) for installing Cypress.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `npm`（Node.js 中的默认包管理器）来安装 Cypress。
- en: '[![2](assets/2.png)](#co_beyond_selenium_CO5-2)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_beyond_selenium_CO5-2)'
- en: We can use `npx` (an `npm` package runner) for running the Cypress process.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `npx`（一个 `npm` 包运行器）来运行 Cypress 进程。
- en: '![hosw 1007](assets/hosw_1007.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![hosw 1007](assets/hosw_1007.png)'
- en: Figure 10-7\. Cypress GUI
  id: totrans-163
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-7\. Cypress GUI
- en: By default, in the Cypress GUI, you can find introductory test examples in the
    folders `1-getting-started` and `2-advanced-examples`. In addition, we can create
    new tests using the button New Spec File. For instance, [Example 10-4](#cypress-helloworld)
    shows a brand-new basic test using Cypress (i.e., a *hello world* in Cypress).
    This test is called `hello-world-cypress.spec.js` (the extension `spec.js` is
    used by default in Mocha tests), and it is stored in the path `cypress/integration`
    of the Cypress installation. [Figure 10-8](#cypress-test-runner) shows a screenshot
    of the Cypress Test Runner during the execution of this test.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Cypress GUI 中，默认情况下可以在 `1-getting-started` 和 `2-advanced-examples` 文件夹中找到入门测试示例。此外，我们可以使用
    New Spec File 按钮创建新的测试。例如，[示例 10-4](#cypress-helloworld) 展示了使用 Cypress 的全新基础测试（即
    Cypress 中的 *hello world*）。这个测试被称为 `hello-world-cypress.spec.js`（默认在 Mocha 测试中使用
    `.spec.js` 扩展名），并存储在 Cypress 安装路径的 `cypress/integration` 中。[图 10-8](#cypress-test-runner)
    展示了在执行此测试时的 Cypress 测试运行器的截图。
- en: Example 10-4\. Hello world test using Cypress
  id: totrans-165
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-4\. 使用 Cypress 进行的 Hello world 测试
- en: '[PRE5]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[![1](assets/1.png)](#co_beyond_selenium_CO6-1)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_beyond_selenium_CO6-1)'
- en: We open the login page in the practice site.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在实践站点中打开登录页面。
- en: '[![2](assets/2.png)](#co_beyond_selenium_CO6-2)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_beyond_selenium_CO6-2)'
- en: We type the correct credentials (username and password).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们输入正确的凭据（用户名和密码）。
- en: '[![3](assets/3.png)](#co_beyond_selenium_CO6-3)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_beyond_selenium_CO6-3)'
- en: We click on the Submit button.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们点击提交按钮。
- en: '[![4](assets/4.png)](#co_beyond_selenium_CO6-4)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_beyond_selenium_CO6-4)'
- en: We verify the resulting page contains the message for successful login.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们验证结果页面包含成功登录的消息。
- en: '[![5](assets/5.png)](#co_beyond_selenium_CO6-5)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_beyond_selenium_CO6-5)'
- en: We make a browser screenshot.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进行浏览器截图。
- en: '![hosw 1008](assets/hosw_1008.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![hosw 1008](assets/hosw_1008.png)'
- en: Figure 10-8\. Cypress Test Runner
  id: totrans-178
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-8\. Cypress测试运行器
- en: WebDriverIO
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WebDriverIO
- en: '[WebDriverIO](https://webdriver.io) is an automated testing framework for web
    and mobile applications. It is entirely open source (MIT license) and based on
    web standards such as the W3C WebDriver protocol. [Figure 10-9](#webdriverio-arch)
    illustrates its architecture. WebDriverIO is written in JavaScript and runs on
    Node.js. It uses several *services* to support automation: chromedriver (for local
    Chrome browsers), Selenium Server (for other browsers), Appium Server (for mobile
    devices), Chrome DevTools (for Chromium-based local browsers using the CDP), and
    cloud providers (such as Sauce Labs, BrowserStack, or TestingBot). These services
    manipulate the corresponding browsers and mobile devices. [Table 10-6](#webdriverio-pros-cons)
    summarizes some of the pros and cons of WebDriverIO.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[WebDriverIO](https://webdriver.io)是用于Web和移动应用程序的自动化测试框架。它完全开源（MIT许可证），基于诸如W3C
    WebDriver协议之类的Web标准。[图 10-9](#webdriverio-arch)展示了它的架构。WebDriverIO是用JavaScript编写的，运行在Node.js上。它使用几个*服务*来支持自动化：chromedriver（用于本地Chrome浏览器）、Selenium
    Server（用于其他浏览器）、Appium Server（用于移动设备）、Chrome DevTools（用于使用CDP的基于Chromium的本地浏览器）以及云提供商（如Sauce
    Labs、BrowserStack或TestingBot）。这些服务操作相应的浏览器和移动设备。[表 10-6](#webdriverio-pros-cons)总结了WebDriverIO的一些优缺点。'
- en: '![hosw 1009](assets/hosw_1009.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![hosw 1009](assets/hosw_1009.png)'
- en: Figure 10-9\. WebDriverIO architecture
  id: totrans-182
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-9\. WebDriverIO架构
- en: Table 10-6\. WebDriverIO pros and cons
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 10-6\. WebDriverIO的优缺点
- en: '| Pros | Cons |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| 优点 | 缺点 |'
- en: '| --- | --- |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Support for multiple browsers and mobile devices
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持多个浏览器和移动设备
- en: Works with different testing and reporting frameworks
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用于不同的测试和报告框架
- en: Based on web standards
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于Web标准
- en: '|'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Only available using JavaScript
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅支持JavaScript
- en: '|'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'The following `npm` command installs WebDriverIO locally. This installer displays
    a command-line wizard that asks for several options, such as the services (chomedriver,
    Selenium Server, Appium Server, CDP, or cloud providers), testing framework (Mocha,
    Jasmine, or Cucumber), or reporter tool (JUnit or Allure, among others):'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的`npm`命令在本地安装WebDriverIO。此安装程序显示一个命令行向导，询问几个选项，例如服务（chomedriver、Selenium Server、Appium
    Server、CDP或云提供商）、测试框架（Mocha、Jasmine或Cucumber）或报告工具（JUnit或Allure等）：
- en: '[PRE6]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When the previous command finishes, we can create our custom tests. For instance,
    [Example 10-5](#webdriverio-helloworld) shows a basic WebDriverIO using Mocha.
    We locate this test under the folder `test` of the project scaffolding and run
    it through the following command:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当前命令完成后，我们可以创建自定义测试。例如，[示例 10-5](#webdriverio-helloworld)展示了一个基本的使用Mocha的WebDriverIO测试。我们将此测试放在项目脚手架的`test`文件夹下，并通过以下命令运行它：
- en: '[PRE7]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Example 10-5\. Hello world test using WebDriverIO
  id: totrans-197
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-5\. 使用WebDriverIO的Hello world测试
- en: '[PRE8]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: TestCafe
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TestCafe
- en: '[TestCafe](https://testcafe.io) is an open source (MIT license) cross-browser
    automation testing tool. The core idea of TestCafe is to avoid external drivers
    to support the automation process and emulate the user actions using a hybrid
    client-server architecture (see [Figure 10-10](#testcafe-arch)). The server side
    is implemented in Node.js and contains a *proxy* that intercepts the HTTP traffic
    with the web application under test. TestCafe tests are also written as Node.js
    scripts and are executed on the server side. The *automation scripts* that emulate
    the user activity run on the client side on the tested page in the browser. [Table 10-7](#testcafe-pros-cons)
    summarizes some advantages and limitations of TestCafe.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '[TestCafe](https://testcafe.io)是一个开源的跨浏览器自动化测试工具（MIT许可证）。TestCafe的核心思想是避免使用外部驱动程序来支持自动化过程，而是使用混合的客户端-服务器架构模拟用户操作（参见[图 10-10](#testcafe-arch)）。服务器端采用Node.js实现，并包含一个*代理*，用于拦截与测试中的Web应用程序的HTTP流量。TestCafe测试也是作为Node.js脚本编写并在服务器端执行的。在浏览器中测试页上运行模拟用户活动的*自动化脚本*在客户端上运行。[表 10-7](#testcafe-pros-cons)总结了TestCafe的一些优势和局限性。'
- en: '![hosw 1010](assets/hosw_1010.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![hosw 1010](assets/hosw_1010.png)'
- en: Figure 10-10\. TestCafe architecture
  id: totrans-202
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-10\. TestCafe架构
- en: Table 10-7\. TestCafe pros and cons
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 10-7\. TestCafe优缺点
- en: '| Pros | Cons |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| 优点 | 缺点 |'
- en: '| --- | --- |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Full cross-browser support (since TestCafe only launches browsers, it can automate
    any browser)
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全跨浏览器支持（由于TestCafe仅启动浏览器，因此可以自动化任何浏览器）
- en: '|'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: It supports only JavaScript and TypeScript
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅支持JavaScript和TypeScript
- en: Some actions cannot be automated since it is not possible with JavaScript
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于 JavaScript 的限制，某些操作无法自动化
- en: '|'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'We can install TestCafe easily using `npm`. Then, we can use the TestCafe CLI
    tool to run TestCafe scripts from the command line. The following snippet illustrates
    how:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `npm` 轻松安装 TestCafe。然后，我们可以使用 TestCafe CLI 工具从命令行运行 TestCafe 脚本。以下代码段说明了如何操作：
- en: '[PRE9]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[![1](assets/1.png)](#co_beyond_selenium_CO7-1)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_beyond_selenium_CO7-1)'
- en: We install TestCafe globally.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们全局安装 TestCafe。
- en: '[![2](assets/2.png)](#co_beyond_selenium_CO7-2)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_beyond_selenium_CO7-2)'
- en: We start a TestCafe basic script ([Example 10-6](#testcafe-helloworld)) using
    Chrome as a browser.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们启动一个使用 Chrome 作为浏览器的 TestCafe 基本脚本（[示例 10-6](#testcafe-helloworld)）。
- en: Example 10-6\. Hello world test using TestCafe
  id: totrans-218
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-6\. 使用 TestCafe 的 Hello world 测试
- en: '[PRE10]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Puppeteer
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Puppeteer
- en: '[Puppeteer](https://pptr.dev) is an open source (MIT license) Node.js library
    that provides a high-level API to control Chromium-based browsers over the DevTools
    Protocol. Puppeteer is maintained by the Chrome DevTools team at Google. [Figure 10-11](#puppeter-arch)
    illustrates the architecture of Puppeteer. [Table 10-8](#puppeter-pros-cons) presents
    the main advantages and drawbacks of Puppeteer.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '[Puppeteer](https://pptr.dev) 是一个开源（MIT 许可）的 Node.js 库，提供了一个高级 API 来通过 DevTools
    协议控制基于 Chromium 的浏览器。Puppeteer 由 Google 的 Chrome DevTools 团队维护。[图 10-11](#puppeter-arch)
    展示了 Puppeteer 的架构。[表 10-8](#puppeter-pros-cons) 展示了 Puppeteer 的主要优缺点。'
- en: '![hosw 1011](assets/hosw_1011.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![hosw 1011](assets/hosw_1011.png)'
- en: Figure 10-11\. Puppeteer architecture
  id: totrans-223
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-11\. Puppeteer 架构
- en: Table 10-8\. Puppeteer pros and cons
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 10-8\. Puppeteer 的优缺点
- en: '| Pros | Cons |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| 优点 | 缺点 |'
- en: '| --- | --- |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Fast execution and comprehensive automation capabilities (due to direct communication
    with the browser using CDP)
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速执行和全面的自动化能力（由于使用 CDP 与浏览器直接通信）
- en: '|'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Limited cross-browser support (only Chromium-based browsers, although there
    is experimental Firefox support at the time of writing)
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅支持有限的跨浏览器（仅基于 Chromium 的浏览器，尽管在撰写时有试验性的 Firefox 支持）
- en: Supports only JavaScript and TypeScript
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅支持 JavaScript 和 TypeScript
- en: '|'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'We can install Puppeteer using `npm`. Then, we need to use Node.js to run Puppeteer
    tests (for instance, [Example 10-7](#puppeter-helloworld)). The following snippet
    shows these commands:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `npm` 安装 Puppeteer。然后，我们需要使用 Node.js 运行 Puppeteer 测试（例如，[示例 10-7](#puppeter-helloworld)）。以下代码段显示了这些命令：
- en: '[PRE11]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Example 10-7\. Hello world test using Puppeteer
  id: totrans-235
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-7\. 使用 Puppeteer 的 Hello world 测试
- en: '[PRE12]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[![1](assets/1.png)](#co_beyond_selenium_CO8-1)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_beyond_selenium_CO8-1)'
- en: 'Puppeteer runs browsers in headless mode by default. It can be configured to
    use nonheadless browsers simply by changing this statement to:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: Puppeteer 默认以无头模式运行浏览器。可以通过将此语句更改为以下内容来配置为使用非无头浏览器：
- en: '[PRE13]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Playwright
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Playwright
- en: '[Playwright](https://playwright.dev) is an open source (Apache 2.0 license)
    library for browser automation supported by Microsoft. Playwright originally started
    as a Node.js library. In addition to JavaScript, it now supports other programming
    languages, namely Python, Java, and .NET C#.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '[Playwright](https://playwright.dev) 是由微软支持的开源（Apache 2.0 许可）的浏览器自动化库。Playwright
    最初是一个 Node.js 库。除了 JavaScript，它现在还支持其他编程语言，包括 Python、Java 和 .NET C#。'
- en: 'Playwright supports three types of web engines: Chromium, Firefox, and WebKit
    (i.e., the web browser engine used by Safari). The idea of supporting these engines
    is that they cover most of the browser market. Thus, the Playwright team maintains
    a patched version of these browsers that expose the necessary capabilities to
    enable the automation. These patched versions provide an event-driven architecture
    to access different internal browser processes (e.g., the render, network, browser,
    or service worker processes). [Figure 10-12](#playwright-arch) illustrates this
    architecture. [Table 10-9](#playwright-pros-cons) contains some of the most relevant
    pros and cons for Playwright.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: Playwright 支持三种类型的 Web 引擎：Chromium、Firefox 和 WebKit（即 Safari 使用的 Web 浏览器引擎）。支持这些引擎的想法是它们涵盖了大部分的浏览器市场。因此，Playwright
    团队维护了这些浏览器的补丁版本，以公开必要的功能来实现自动化。这些补丁版本提供了一个事件驱动的架构，以访问不同的内部浏览器进程（例如，渲染、网络、浏览器或服务工作进程）。[图 10-12](#playwright-arch)
    说明了这种架构。[表 10-9](#playwright-pros-cons) 包含了 Playwright 的一些最重要的优缺点。
- en: '![hosw 1012](assets/hosw_1012.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![hosw 1012](assets/hosw_1012.png)'
- en: Figure 10-12\. Playwright architecture
  id: totrans-244
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-12\. Playwright 架构
- en: Table 10-9\. Playwright pros and cons
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 10-9\. Playwright 的优缺点
- en: '| Pros | Cons |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| 优点 | 缺点 |'
- en: '| --- | --- |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Autowaiting for elements to be ready
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动等待元素准备就绪
- en: Multilanguage API
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多语言 API
- en: Provides a test generator by recording user actions in the browser
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过记录浏览器中的用户操作来提供测试生成器
- en: Allows browser session recording
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许浏览器会话记录
- en: Intercepts network traffic for stubbing and mocking
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拦截网络流量以进行存根和模拟
- en: '|'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Uses patched browser versions instead of actual releases
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用修补过的浏览器版本而不是实际发布版本
- en: '|'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'To use Playwright, we need first to install the patched browser binaries. We
    can use `npm` to that aim. The following command downloads the proper browser
    binaries for Chromium, Firefox, and WebKit for the operating system running this
    command (Windows, Linux, and macOS are supported):'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Playwright，我们首先需要安装修补过的浏览器二进制文件。我们可以使用 `npm` 来实现这一目标。以下命令将下载适用于运行此命令的操作系统（支持
    Windows、Linux 和 macOS）的 Chromium、Firefox 和 WebKit 的正确浏览器二进制文件：
- en: '[PRE14]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then we can implement Playwright scripts using one supported API. For instance,
    when using the JavaScript API, we can use a third-party test runner (e.g., Jest,
    Jasmine, Mocha, etc.) or use the Playwright Test (i.e., the test runner provided
    by the Playwright team). To use the latter, we need to install it as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用一个支持的 API 实现 Playwright 脚本。例如，当使用 JavaScript API 时，我们可以使用第三方测试运行器（例如
    Jest、Jasmine、Mocha 等），或者使用 Playwright 测试（即由 Playwright 团队提供的测试运行器）。要使用后者，我们需要按照以下方式安装它：
- en: '[PRE15]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[Example 10-8](#webdriverio-playwright) contains a basic Playwright JavaScript
    test to be executed with the Playwright runner. This command supposes that this
    test (called `helloworld-playwright.spec.mjs`) is located under the `tests` directory.
    We can invoke the Playwright runner as shown in the following snippet to run this
    test. This command runs Playwright tests in headless mode by default. To run browsers
    in nonheadless mode, you need to include the flag `--headed` at the of the command:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 10-8](#webdriverio-playwright) 包含一个基本的 Playwright JavaScript 测试，可以使用 Playwright
    运行器执行。这个命令假设这个测试（称为 `helloworld-playwright.spec.mjs`）位于 `tests` 目录下。我们可以像下面的片段所示调用
    Playwright 运行器来运行这个测试。这个命令默认以无头模式运行 Playwright 测试。要在非无头模式下运行浏览器，您需要在命令的末尾包含 `--headed`
    标志：'
- en: '[PRE16]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Example 10-8\. Hello world test using Playwright
  id: totrans-263
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-8\. 使用 Playwright 进行的 Hello world 测试
- en: '[PRE17]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Summary and Final Remarks
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要和最终说明
- en: 'Web development is a heterogeneous discipline that involves many different
    technologies, such as client side, server side, or integration with external services,
    to name a few. For this reason, this chapter introduced two complementary technologies
    for Selenium that can be helpful in testing web applications: Appium (an open
    source test automation framework for mobile apps) and REST Assured (an open source
    Java library for testing REST services). You also learned the basics of alternative
    tools for implementing end-to-end tests for web applications, namely Cypress,
    WebDriverIO, TestCafe, Puppeteer, and Playwright. Although these alternatives
    deliver remarkable advantages compared to Selenium (e.g., automated waiting),
    in my opinion, Selenium provides a more comprehensive automation model since it
    is built on top of web standards, such as the W3C WebDriver and WebDriver BiDi.
    In addition, the Selenium project actively participates in the deelopment of these
    specifications.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: Web 开发是一个涉及许多不同技术的异构学科，例如客户端、服务器端或者与外部服务集成等。因此，本章介绍了两种对 Selenium 有帮助的补充技术，用于测试
    Web 应用程序：Appium（用于移动应用程序的开源测试自动化框架）和 REST Assured（用于测试 REST 服务的开源 Java 库）。您还学习了用于实现
    Web 应用程序端到端测试的替代工具的基础知识，包括 Cypress、WebDriverIO、TestCafe、Puppeteer 和 Playwright。虽然这些替代方案与
    Selenium 相比具有显著的优势（例如自动等待），但在我看来，由于 Selenium 是基于 Web 标准构建的（例如 W3C WebDriver 和
    WebDriver BiDi），因此提供了更全面的自动化模型。此外，Selenium 项目还积极参与这些规范的开发。
- en: 'This chapter concludes your journey through the development of end-to-end tests
    with Selenium. The next step is to put all the knowledge presented in this book
    into practice in your projects. This way, you can build your custom automation
    framework for your team, project, company, etc. There are many decisions you need
    to make, such as the project setup (e.g., Maven, Gradle), unit testing framework
    (e.g., JUnit, TestNG), browser infrastructure (e.g., Docker, cloud providers),
    and integration with third-party utilities. To deal with all of this complexity,
    as a final word, I recommend you play with the provided examples in this book.
    In other words: clone the repository, run the tests, and edit the code to fulfill
    your needs. I will maintain the GitHub repo after the book is published. And remember:
    it is an open source software project, so feel free to create a pull request to
    improve it if you want to contribute.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节总结了你通过使用 Selenium 开发端到端测试的旅程。下一步是将本书中提供的所有知识付诸实践到你的项目中。这样，你可以为你的团队、项目、公司等构建定制的自动化框架。你需要做出许多决策，比如项目设置（如
    Maven、Gradle）、单元测试框架（如 JUnit、TestNG）、浏览器基础设施（如 Docker、云服务提供商）以及与第三方工具的集成。为了应对所有这些复杂性，作为最后一句话，我建议你在本书中提供的示例中进行实践。换句话说：克隆仓库，运行测试，并编辑代码以满足你的需求。书籍发布后，我会维护
    GitHub 仓库。还要记住：这是一个开源软件项目，所以如果你想做出贡献，随时可以提交 pull request 来改进它。
