- en: Chapter 10\. File Input and Output
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章\. 文件输入和输出
- en: The ability to store data in files and retrieve it later is crucial to desktop
    and enterprise applications. In this chapter, we’ll look at some of the most popular
    classes in the `java.io` and `java.nio` packages. These packages offer a rich
    set of tools for basic input and output (I/O) and also provide the framework on
    which all file and network communication in Java is built. [Figure 10-1](#learnjava6-CHP-10-FIG-io-classes)
    shows the breadth of the `java.io` package.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据存储在文件中并在以后检索是桌面和企业应用程序至关重要的功能。在本章中，我们将介绍`java.io`和`java.nio`包中一些最受欢迎的类。这些包为基本输入和输出（I/O）提供了丰富的工具集，并为Java中所有文件和网络通信的框架提供支持。[图 10-1](#learnjava6-CHP-10-FIG-io-classes)展示了`java.io`包的广度。
- en: We’ll start by looking at the stream classes in `java.io`, which are subclasses
    of the basic `InputStream`, `OutputStream`, `Reader`, and `Writer` classes. Then
    we’ll examine the `File` class and discuss how you can read and write files using
    classes in `java.io`. We also take a quick look at data compression and serialization.
    Along the way, we introduce the `java.nio` package. The “new” I/O package (or
    NIO) adds significant functionality tailored for building high-performance services.
    NIO centers on working with *buffers* (where you store stuff to make more efficient
    use of other resources) and *channels* (where you can efficiently put stuff that
    can be just as efficiently picked up by others). In some cases, NIO also provides
    better APIs that can be used in place of some `java.io` features.^([1](ch10.html#id1908))
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先来看看`java.io`中的流类，这些类是基本`InputStream`、`OutputStream`、`Reader`和`Writer`类的子类。然后我们将检查`File`类，并讨论如何使用`java.io`中的类来读取和写入文件。我们还快速浏览一下数据压缩和序列化。在此过程中，我们介绍了`java.nio`包。这个“新”I/O包（或NIO）增加了专门用于构建高性能服务的重要功能。NIO主要关注使用*缓冲区*（你可以在其中存储数据以更有效地利用其他资源）和*通道*（你可以高效地将数据放入其中，其他程序同样高效地从中读取数据）。在某些情况下，NIO还提供了更好的API，可以替代一些`java.io`功能。^([1](ch10.html#id1908))
- en: '![ljv6 1001](assets/ljv6_1001.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 1001](assets/ljv6_1001.png)'
- en: Figure 10-1\. The `java.io` class hierarchy
  id: totrans-4
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10-1\. `java.io`类层次结构
- en: Streams
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流
- en: 'Most I/O in Java is based on streams. Conceptually, a *stream* represents a
    flow of data with a *writer* at one end and a *reader* at the other. When you
    are working with the `java.io` package to perform terminal input and output, reading
    or writing files, or communicating through network sockets in Java (more on networking
    in [Chapter 13](ch13.html#learnjava6-CHP-13)), you are using various types of
    streams. When we look at the NIO package, we’ll find a similar concept called
    a *channel*. The main difference between the two is that streams are oriented
    around bytes or characters, while channels are oriented around “buffers” containing
    those data types. A *buffer* is typically a fast, temporary storage for data that
    makes it easier to optimize throughput. They both perform roughly the same job.
    Let’s start with streams. Here’s a quick overview of the most popular stream classes:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Java中大多数I/O操作都是基于流的。在概念上，*流*表示一种数据的流动，其中一个*写入器*位于一端，一个*读取器*位于另一端。当你使用`java.io`包执行终端输入和输出、读取或写入文件或通过Java网络套接字进行通信时（更多关于网络的内容请参阅[第13章](ch13.html#learnjava6-CHP-13)），你将使用各种类型的流。当我们研究NIO包时，我们将发现一个类似的概念叫做*通道*。两者的主要区别在于流是围绕字节或字符而设计的，而通道则是围绕包含这些数据类型的“缓冲区”而设计的。*缓冲区*通常是用于数据的快速临时存储，从而更容易优化吞吐量。它们都大致完成相同的工作。让我们从流开始。以下是最受欢迎的流类的快速概述：
- en: '`InputStream`, `OutputStream`'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '`InputStream`、`OutputStream`'
- en: Abstract classes that define the basic functionality for reading or writing
    an unstructured sequence of bytes. All other byte streams in Java are built on
    top of the basic `InputStream` and `OutputStream`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类定义了读取或写入无结构字节序列的基本功能。Java中的所有其他字节流都建立在基本`InputStream`和`OutputStream`之上。
- en: '`Reader`, `Writer`'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reader`、`Writer`'
- en: Abstract classes that define the basic functionality for reading or writing
    a sequence of character data, with support for Unicode. All other character streams
    in Java are built on top of `Reader` and `Writer`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类定义了读取或写入字符数据序列的基本功能，支持Unicode。Java中的所有其他字符流都建立在`Reader`和`Writer`之上。
- en: '`InputStreamReader`, `OutputStreamWriter`'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`InputStreamReader`、`OutputStreamWriter`'
- en: 'Classes that bridge byte and character streams by converting according to a
    specific character-encoding scheme such as ASCII or Unicode. (Remember: in Unicode,
    a character is not necessarily one byte!)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 通过按照特定字符编码方案（如ASCII或Unicode）进行转换，将字节流和字符流进行桥接的类。请记住：在Unicode中，一个字符不一定是一个字节！
- en: '`DataInputStream`, `DataOutputStream`'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataInputStream`、`DataOutputStream`'
- en: Specialized stream filters that add the ability to read and write multibyte
    data types, such as numeric primitives and `String` objects in a standardized
    format.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 专门的流过滤器增加了读写多字节数据类型（如数值原始数据和`String`对象）的能力，以标准化格式进行。
- en: '`ObjectInputStream`, `ObjectOutputStream`'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`ObjectInputStream`、`ObjectOutputStream`'
- en: Specialized stream filters that are capable of writing whole groups of serialized
    Java objects and reconstructing them.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 专门的流过滤器，能够写入整组序列化的Java对象并重新构造它们。
- en: '`BufferedInputStream`, `BufferedOutputStream`, `BufferedReader`, `BufferedWriter`'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`BufferedInputStream`、`BufferedOutputStream`、`BufferedReader`、`BufferedWriter`'
- en: Specialized stream filters that add buffering for additional efficiency. For
    real-world I/O, a buffer is almost always used.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 专门的流过滤器增加了缓冲以提高效率。在真实的I/O操作中，几乎总是会使用缓冲。
- en: '`PrintStream`, `PrintWriter`'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`PrintStream`、`PrintWriter`'
- en: Specialized streams that simplify printing text.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 简化文本打印的专门流。
- en: '`PipedInputStream`, `PipedOutputStream`, `PipedReader`, `PipedWriter`'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`PipedInputStream`、`PipedOutputStream`、`PipedReader`、`PipedWriter`'
- en: Paired classes that move data within an application. Data written into a `PipedOutputStream`
    or `PipedWriter` is read from its corresponding `PipedInputStream` or `PipedReader`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序内移动数据的配对类。写入`PipedOutputStream`或`PipedWriter`的数据将从其对应的`PipedInputStream`或`PipedReader`中读取。
- en: '`FileInputStream`, `FileOutputStream`, `FileReader`, `FileWriter`'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileInputStream`、`FileOutputStream`、`FileReader`、`FileWriter`'
- en: Implementations of `InputStream`, `OutputStream`, `Reader`, and `Writer` that
    read from and write to files on the local filesystem.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 实现了从本地文件系统读取和写入文件的`InputStream`、`OutputStream`、`Reader`和`Writer`。
- en: Streams in Java are one-way streets. The `java.io` input and output classes
    represent only the ends of a simple stream. For bidirectional conversations, you’ll
    use one of each type of stream.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Java中的流是单向的。`java.io`输入和输出类只代表简单流的两端。对于双向对话，您将使用每种类型的一个流。
- en: '`InputStream` and `OutputStream`, as shown in [Figure 10-2](#learnjava6-CHP-10-FIG-1),
    are abstract classes that define the lowest-level interface for all byte streams.
    They contain methods for reading or writing an unstructured flow of byte-level
    data. Because these classes are abstract, you can’t create a generic input or
    output stream.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`InputStream`和`OutputStream`，如[图 10-2](#learnjava6-CHP-10-FIG-1)所示，是定义所有字节流的最底层接口的抽象类。它们包含用于读取或写入无结构的字节级数据的方法。由于这些类是抽象的，你不能创建通用的输入或输出流。'
- en: '![ljv6 1002](assets/ljv6_1002.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 1002](assets/ljv6_1002.png)'
- en: Figure 10-2\. Basic input and output stream functionality
  id: totrans-28
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-2\. 基本输入和输出流功能
- en: Java implements subclasses of these for activities such as reading from and
    writing to files or communicating with network connections. Because all byte streams
    inherit the structure of `InputStream` or `OutputStream`, the various kinds of
    byte streams can be used interchangeably. A method specifying an `InputStream`
    as an argument can accept any subclass of `InputStream`. Specialized types of
    streams can also be layered or wrapped around basic streams to add features such
    as buffering, filtering, compression, or handling higher-level data types.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Java为诸如从文件读取和写入或与网络连接通信等活动实现了这些类的子类。由于所有字节流都继承自`InputStream`或`OutputStream`的结构，因此可以互换使用各种类型的字节流。还可以在基本流周围堆叠或包装特定类型的专门流，以添加缓冲、过滤、压缩或处理更高级别数据类型等功能。
- en: '`Reader` and `Writer` are very much like `InputStream` and `OutputStream`,
    except that they deal with characters instead of bytes. As true character streams,
    these classes correctly handle Unicode characters, which is not always the case
    with byte streams. Often, a bridge is needed between these character streams and
    the byte streams of physical devices, such as disks and networks. `InputStreamReader`
    and `OutputStreamWriter` are special classes that use a character-encoding scheme
    like ASCII or UTF-8 to translate between character and byte streams.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reader`和`Writer`与`InputStream`和`OutputStream`非常相似，不同之处在于它们处理的是字符而不是字节。作为真正的字符流，这些类可以正确处理Unicode字符，而字节流则并非总是如此。通常需要在这些字符流和物理设备（如磁盘和网络）的字节流之间进行桥接。`InputStreamReader`和`OutputStreamWriter`是特殊的类，它们使用像ASCII或UTF-8这样的字符编码方案来在字符流和字节流之间进行转换。'
- en: This section describes several stream types, with the exception of `FileInputStream`,
    `FileOutputStream`, `FileReader`, and `FileWriter`. We postpone the discussion
    of file streams until the next section, where we cover accessing the filesystem
    in Java.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了几种流类型，但不包括`FileInputStream`、`FileOutputStream`、`FileReader`和`FileWriter`。我们将在下一节中讨论文件流，在那里我们将涵盖如何在Java中访问文件系统。
- en: Basic I/O
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本输入/输出
- en: 'The prototypical example of an `InputStream` object is the *standard input*
    of a Java application. Like `stdin` in C or `cin` in C++, this is the source of
    input to a command-line (non-GUI) program. It is an input stream from the environment—usually
    a terminal window or possibly the output of another command. The `java.lang.System`
    class, a general repository for system-related resources, provides a reference
    to the standard input stream in the static variable `System.in`. It also provides
    a *standard output stream* and a *standard error stream* in the `out` and `err`
    variables, respectively.^([2](ch10.html#id1946)) The following example shows the
    correspondence:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`InputStream`对象的典型示例是Java应用程序的*标准输入*。与C语言中的`stdin`或C++中的`cin`类似，这是命令行（非GUI）程序的输入来源。它是来自环境的输入流，通常是一个终端窗口或可能是另一个命令的输出。`java.lang.System`类是系统相关资源的通用存储库，在静态变量`System.in`中提供了对标准输入流的引用。它还在`out`和`err`变量中分别提供了*标准输出流*和*标准错误流*。^([2](ch10.html#id1946))以下示例显示了它们之间的对应关系：'
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This snippet hides the fact that `System.out` and `System.err` aren’t just `OutputStream`
    objects but more specialized and useful `PrintStream` objects. We’ll explain these
    later in [“PrintWriter and PrintStream”](#learnjava6-CHP-10-SECT-1.3.3), but for
    now we can reference `out` and `err` as `OutputStream` objects because they are
    derived from `OutputStream`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码隐藏了`System.out`和`System.err`不仅仅是`OutputStream`对象，而是更专门和有用的`PrintStream`对象的事实。我们稍后会在[“PrintWriter
    and PrintStream”](#learnjava6-CHP-10-SECT-1.3.3)中解释这些内容，但目前我们可以将`out`和`err`引用为`OutputStream`对象，因为它们都是从`OutputStream`派生出来的。
- en: 'You can read a single byte at a time from standard input with the `InputStream`’s
    `read()` method. If you look closely at the [online documentation](https://oreil.ly/GSEj0),
    you’ll see that the `read()` method of the base `InputStream` class is an abstract
    method. What lies behind `System.in` is a particular implementation of `InputStream`
    that provides the real implementation of the `read()` method:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`InputStream`的`read()`方法从标准输入一次读取一个字节。如果您仔细查看[在线文档](https://oreil.ly/GSEj0)，您会发现基础`InputStream`类的`read()`方法是一个抽象方法。`System.in`背后是`InputStream`的特定实现，它提供了`read()`方法的实际实现：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Although we said that the `read()` method reads a byte value, the return type
    in the example is `int`, not `byte`. That’s because the `read()` method of basic
    input streams in Java uses a convention carried over from the C language to indicate
    the end of a stream with a special value. Byte values are returned in the range
    0 to 255, and the special value of `-1` is used to indicate that the end of the
    stream has been reached. You test for this condition when using the simple `read()`
    method. You can then cast the value to a byte, if needed. The following example
    reads each byte from an input stream and prints its value:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们说`read()`方法读取字节值，但示例中的返回类型是`int`而不是`byte`。这是因为Java中基本输入流的`read()`方法使用了从C语言继承过来的约定，用特殊值指示流的结束。字节值在0到255之间返回，并且特殊值`-1`用于指示已到达流的结尾。在使用简单的`read()`方法时，您可以测试这种条件。然后，如果需要，可以将值转换为字节。以下示例从输入流中读取每个字节并打印其值：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As we’ve shown in the examples, the `read()` method can also throw an `IOException`
    if there is an error reading from the underlying stream source. Various subclasses
    of `IOException` may indicate that a source (such as a file or network connection)
    has had an error. Additionally, higher-level streams that read data types more
    complex than a single byte may throw `EOFException` (“end of file”), which indicates
    an unexpected or premature end of a stream.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在示例中所示，`read()` 方法也可能抛出 `IOException`，如果在底层流源中读取时出现错误。`IOException` 的各种子类可能表示源（如文件或网络连接）发生了错误。此外，读取比单个字节更复杂数据类型的高级流可能会抛出
    `EOFException`（“文件结尾”），这表明流的意外或过早结束。
- en: 'An overloaded form of `read()` fills a byte array with as much data as possible
    up to the capacity of the array and returns the number of bytes read:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`read()` 的重载形式会将字节数组填充为可能的最大数据，并返回读取的字节数：'
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In theory, we can also check the number of bytes available for reading at a
    given time on an `InputStream` using the `available()` method. With that information,
    we could create an array of exactly the right size:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，我们还可以使用 `available()` 方法在给定时间内检查 `InputStream` 上可用于读取的字节数。有了这些信息，我们可以创建一个恰好大小的数组：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: However, the reliability of this technique depends on whether the underlying
    stream implementation can detect how much data it can retrieve. It generally works
    for files but should not be relied upon for all types of streams.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这种技术的可靠性取决于底层流实现是否能够检测到可以检索多少数据。它通常适用于文件，但不应该依赖于所有类型的流。
- en: These `read()` methods block until at least some data is read (at least one
    byte). You must, in general, check the returned value to determine how much data
    you got and if you need to read more. (We look at nonblocking I/O later in this
    chapter.) The `skip()` method of `InputStream` provides a way of jumping over
    a number of bytes. Depending on the implementation of the stream, skipping bytes
    may be more efficient than reading them.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 `read()` 方法会阻塞，直到读取到至少一些数据（至少一个字节）。一般来说，您必须检查返回的值，以确定您读取了多少数据，并且是否需要继续读取。
    （我们在本章后面将介绍非阻塞 I/O。）`InputStream` 的 `skip()` 方法提供了一种跳过一定数量字节的方法。根据流的实现方式，跳过字节可能比读取它们更有效率。
- en: The `close()` method shuts down the stream and frees up any associated system
    resources. It’s important for performance to remember to close most types of streams
    when you are finished using them. In some cases, streams may close automatically
    when objects are garbage-collected, but it is not a good idea to rely on this
    behavior. The `try`*-with-resources* feature discussed in [“try with Resources”](ch06.html#learnjava6-CHP-6-SECT-1.9)
    makes automatically closing streams and other closeable entities easier. We’ll
    see some examples of that in [“File Streams”](#learnjava6-CHP-10-SECT-1.5). The
    interface `java.io.Closeable` identifies all types of stream, channel, and related
    utility classes that can be closed.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`close()` 方法关闭流并释放任何关联的系统资源。在使用完流后记得关闭大多数类型的流对性能很重要。在某些情况下，当对象被垃圾回收时，流可能会自动关闭，但依赖这种行为并不是一个好主意。`try`*-with-resources*
    功能在 [“try with Resources”](ch06.html#learnjava6-CHP-6-SECT-1.9) 中讨论，可以更容易地自动关闭流和其他可关闭实体。我们将在
    [“File Streams”](#learnjava6-CHP-10-SECT-1.5) 中看到一些示例。接口 `java.io.Closeable` 标识了所有可以关闭的流、通道和相关实用类。'
- en: Character Streams
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符流
- en: In early versions of Java, some `InputStream` and `OutputStream` types included
    methods for reading and writing strings, but most of them operated by naively
    assuming that a 16-bit Unicode character was equivalent to an 8-bit byte in the
    stream. This works for Latin-1 (ISO 8859-1) characters, but not for the world
    of other encodings used with different languages.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期的 Java 版本中，一些 `InputStream` 和 `OutputStream` 类型包含了用于读取和写入字符串的方法，但大多数情况下它们是通过天真地假设
    16 位 Unicode 字符等同于流中的 8 位字节来操作的。这对于拉丁-1（ISO 8859-1）字符有效，但对于与不同语言一起使用的其他编码的世界则不适用。
- en: The `java.io Reader` and `Writer` character stream classes were introduced as
    streams that handle character data only. When you use these classes, you think
    only in terms of characters and string data. You allow the underlying implementation
    to handle the conversion of bytes to a specific character encoding. As you’ll
    see, there are some direct implementations of `Reader` and `Writer`, such as those
    for reading and writing files.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.io Reader`和`Writer`字符流类被引入为仅处理字符数据的流。当您使用这些类时，您仅考虑字符和字符串数据。您允许底层实现处理字节到特定字符编码的转换。正如您将看到的，有一些`Reader`和`Writer`的直接实现，例如用于读取和写入文件的实现。'
- en: More generally, two special classes, `InputStreamReader` and `OutputStreamWriter`,
    bridge the gap between character streams and byte streams. These are, respectively,
    a `Reader` and a `Writer` that can be wrapped around any underlying byte stream
    to make it a character stream. An encoding scheme converts between the bytes (which
    may come in groups representing multibyte characters) and Java’s two-byte characters.
    An encoding scheme can be specified by name in the constructor of `InputStreamReader`
    or `OutputStreamWriter`. For convenience, the default constructor uses the system’s
    default encoding scheme.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 更一般地说，两个特殊类`InputStreamReader`和`OutputStreamWriter`弥合了字符流和字节流之间的差距。它们分别是`Reader`和`Writer`，可以包装在任何底层字节流周围，使其成为字符流。编码方案在字节（可能以表示多字节字符的组形式出现）和Java的双字节字符之间进行转换。编码方案可以在`InputStreamReader`或`OutputStreamWriter`的构造函数中通过名称指定。为方便起见，默认构造函数使用系统的默认编码方案。
- en: 'Let’s see how to use readers and the `java.text.NumberFormat` class to retrieve
    numeric input from the user at the command line. We’ll assume that the bytes coming
    from `System.in` use the system’s default encoding scheme:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用读取器和`java.text.NumberFormat`类从命令行中的用户检索数字输入。我们假设来自`System.in`的字节使用系统的默认编码方案：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: First, we wrap an `InputStreamReader` around `System.in`. This reader converts
    the incoming bytes of `System.in` to characters using the default encoding scheme.
    Then, we wrap a `BufferedReader` around the `InputStreamReader`. `BufferedReader`
    adds the `readLine()` method, which we can use to grab a full line of text (up
    to a platform-specific, line-terminator character combination) into a `String`.
    The string is then parsed into an integer using the techniques described in [Chapter 8](ch08.html#learnjava6-CHP-8).
    Try it yourself. When prompted, try providing different input. What happens if
    you enter a “0”? What if you only enter your first name?
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在`System.in`周围包装一个`InputStreamReader`。该读取器使用默认编码方案将`System.in`的传入字节转换为字符。然后，我们在`InputStreamReader`周围包装一个`BufferedReader`。`BufferedReader`添加了`readLine()`方法，我们可以使用该方法将一整行文本（最多到达平台特定的行终止符字符组合）读入`String`中。然后，使用[第8章](ch08.html#learnjava6-CHP-8)中描述的技术将字符串解析为整数。自己试试看。提示时，尝试提供不同的输入。如果输入“0”会发生什么？如果只输入您的名字会发生什么？
- en: 'We have just taken a byte-oriented input stream, `System.in`, and safely converted
    it to a `Reader` for reading characters. If we wished to use an encoding other
    than the system default, we could have specified it in the `InputStreamReader`’s
    constructor, like so:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚采取了面向字节的输入流`System.in`，并安全地将其转换为`Reader`以读取字符。如果我们希望使用与系统默认值不同的编码，则可以在`InputStreamReader`的构造函数中指定它，如下所示：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: For each character that is read from the reader, the `InputStreamReader` reads
    one or more bytes and performs the necessary conversion to Unicode.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对于从读取器读取的每个字符，`InputStreamReader`读取一个或多个字节，并执行必要的Unicode转换。
- en: We’ll return to the topic of character encodings in [“The New I/O File API”](#learnjava6-CHP-10-SECT-2)
    when we discuss the `java.nio.charset` package, which allows you to find and use
    encoders and decoders. Both `InputStreamReader` and `OutputStreamWriter` can accept
    a `Charset` codec object as well as a character-encoding name.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论`java.nio.charset`包时，我们将回到字符编码的主题[“新I/O文件API”](#learnjava6-CHP-10-SECT-2)，该包允许您查找和使用编码器和解码器。`InputStreamReader`和`OutputStreamWriter`都可以接受`Charset`编解码器对象以及字符编码名称。
- en: Stream Wrappers
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流包装器
- en: 'What if you want to do more than read and write a sequence of bytes or characters?
    We can use a *filter stream*, which is a type of `InputStream`, `OutputStream`,
    `Reader`, or `Writer` that wraps another stream and adds new features. A filter
    stream takes the target stream as an argument in its constructor, does some additional
    processing of its own, and then delegates calls to the target. For example, we
    can construct a `BufferedInputStream` to wrap the system standard input:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要做的不仅仅是读取和写入字节或字符序列怎么办？我们可以使用 *过滤流*，它是 `InputStream`、`OutputStream`、`Reader`
    或 `Writer` 的一种类型，它包装另一个流并添加新功能。过滤流将目标流作为其构造函数的参数，并进行一些额外的处理，然后将调用委托给目标。例如，我们可以构造一个
    `BufferedInputStream` 来包装系统标准输入：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `BufferedInputStream` reads ahead and buffers a certain amount of data.
    It wraps an additional layer of functionality around the underlying stream. [Figure 10-3](#learnjava6-CHP-10-FIG-2)
    shows this arrangement for a `DataInputStream`, which can read higher-level data
    types, such as Java primitives and strings.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`BufferedInputStream` 预先读取并缓冲一定量的数据。它在底层流周围包装了一个额外的功能层。[Figure 10-3](#learnjava6-CHP-10-FIG-2)
    显示了 `DataInputStream` 的这种排列方式，它可以读取更高级别的数据类型，如 Java 的基本类型和字符串。'
- en: '![ljv6 1003](assets/ljv6_1003.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 1003](assets/ljv6_1003.png)'
- en: Figure 10-3\. Layered streams
  id: totrans-64
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-3\. 层叠流
- en: As you can see from the previous code snippet, the `BufferedInputStream` filter
    is a type of `InputStream`. Because filter streams are themselves subclasses of
    the basic stream types, they can be used as arguments to the construction of other
    filter streams. This allows filter streams to be layered on top of one another
    to provide different combinations of features. For example, we could first wrap
    our `System.in` with a `BufferedInputStream` to benefit from buffering our input,
    and then wrap the `BufferedInputStream` with a `DataInputStream` for reading special
    data types with buffering.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您从前面的代码片段中看到的那样，`BufferedInputStream` 过滤器是 `InputStream` 的一种类型。因为过滤流本身是基本流类型的子类，所以它们可以作为其他过滤流的构造参数。这使得可以将过滤流层叠在一起，以提供不同的功能组合。例如，我们可以首先用
    `BufferedInputStream` 包装我们的 `System.in` 来获得输入缓冲，然后再用 `DataInputStream` 包装 `BufferedInputStream`
    来读取带缓冲区的特殊数据类型。
- en: 'Java provides base classes for creating new types of filter streams: `FilterInputStream`,
    `FilterOutputStream`, `FilterReader`, and `FilterWriter`. These superclasses provide
    the basic machinery for a filter by delegating all their method calls to their
    underlying stream. To create your own filter stream, you can extend these classes
    and override various methods to add the additional processing you need.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Java 提供了用于创建新类型过滤流的基类：`FilterInputStream`、`FilterOutputStream`、`FilterReader`
    和 `FilterWriter`。这些超类通过将它们所有的方法调用委托给它们的底层流来提供过滤的基本机制。要创建自己的过滤流，可以扩展这些类并重写各种方法以添加所需的额外处理。
- en: Data streams
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据流
- en: '`DataInputStream` and `DataOutputStream` are filter streams that let you read
    or write strings (as opposed to individual characters) and primitive data types
    composed of more than a single byte. `DataInputStream` and `DataOutputStream`
    implement the `DataInput` and `DataOutput` interfaces, respectively. These interfaces
    define methods for reading or writing strings and all of the Java primitive types,
    including numbers and Boolean values. `DataOutputStream` encodes these values
    in a way that can be read back correctly on any machine and then writes them to
    its underlying byte stream. `DataInputStream` picks up the encoded data from its
    underlying byte stream and decodes it into its original types and values.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataInputStream` 和 `DataOutputStream` 是过滤流，允许您读取或写入字符串（而不是单个字符）和由多个字节组成的原始数据类型。`DataInputStream`
    和 `DataOutputStream` 分别实现了 `DataInput` 和 `DataOutput` 接口。这些接口定义了用于读取或写入字符串以及所有
    Java 原始类型的方法，包括数字和布尔值。`DataOutputStream` 对这些值进行编码，以便在任何机器上正确读取，然后将它们写入其底层的字节流。`DataInputStream`
    从其底层字节流中获取编码的数据并将其解码为原始类型和值。'
- en: 'You can construct a `DataInputStream` from an `InputStream` and then use a
    method such as `readDouble()` to read a primitive data type:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从 `InputStream` 构造一个 `DataInputStream`，然后使用诸如 `readDouble()` 这样的方法来读取原始数据类型：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This snippet wraps the standard input stream in a `DataInputStream` and uses
    it to read a `double` value. The `readDouble()` method reads bytes from the stream
    and constructs a `double` from them. The `DataInputStream` methods expect the
    bytes of numeric data types to be in *network byte order*, a standard that specifies
    that the high-order bytes of any multibyte values are sent first (also known as
    *big-endian*; see [“Byte order”](#learnjava6-CHP-10-SECT-3.5.3)).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 此片段将标准输入流包装在 `DataInputStream` 中，并使用它来读取一个 `double` 值。`readDouble()` 方法从流中读取字节，并从中构造一个
    `double` 值。`DataInputStream` 方法期望数字数据类型的字节采用*网络字节顺序*，这是一种标准，指定多字节值的高阶字节先发送（也称为*大端序*；参见[“字节顺序”](#learnjava6-CHP-10-SECT-3.5.3)）。
- en: 'The `DataOutputStream` class provides write methods that correspond to the
    read methods in `DataInputStream`. The complement to our input snippet looks like
    this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataOutputStream` 类提供了与 `DataInputStream` 的读取方法对应的写入方法。我们输入片段的补充如下：'
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Warning
  id: totrans-74
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: '`DataOutputStream` and `DataInputStream` work with binary data, not human-readable
    text. Typically, you would use a `DataInputStream` to read content that was produced
    by a `DataOutputStream`. These filter streams are perfect for working directly
    with things like image files.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataOutputStream` 和 `DataInputStream` 处理二进制数据，而不是人类可读的文本。通常，您会使用 `DataInputStream`
    来读取由 `DataOutputStream` 生成的内容。这些过滤流非常适合直接处理像图像文件之类的内容。'
- en: The `readUTF()` and `writeUTF()` methods of `DataInputStream` and `DataOutputStream`
    read and write a Java `String` of Unicode characters using the UTF-8 character
    encoding. As discussed in [Chapter 8](ch08.html#learnjava6-CHP-8), UTF-8 is an
    ASCII-compatible encoding of Unicode characters that is very widely used. Not
    all encodings are guaranteed to preserve all Unicode characters, but UTF-8 does.
    You can also use UTF-8 with `Reader` and `Writer` streams by specifying it as
    the encoding name.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataInputStream` 和 `DataOutputStream` 的 `readUTF()` 和 `writeUTF()` 方法使用 UTF-8
    字符编码读取和写入 Java `String`，该编码使用 Unicode 字符。正如在[第 8 章](ch08.html#learnjava6-CHP-8)中讨论的那样，UTF-8
    是一种广泛使用的 ASCII 兼容的 Unicode 字符编码。并非所有编码都保证能够保存所有 Unicode 字符，但 UTF-8 可以。您还可以通过将
    UTF-8 指定为编码名称，将其与 `Reader` 和 `Writer` 流一起使用。'
- en: Buffered streams
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缓冲流
- en: The `BufferedInputStream`, `BufferedOutputStream`, `BufferedReader`, and `BufferedWriter`
    classes add a data buffer of a specified size to the stream path. A buffer can
    increase efficiency by reducing the number of physical read or write operations
    that correspond to `read()` or `write()` method calls, as seen in [Figure 10-4](#learnjava6-CHP-10-FIG-buffered).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`BufferedInputStream`、`BufferedOutputStream`、`BufferedReader` 和 `BufferedWriter`
    类在流路径中添加了一个指定大小的数据缓冲区。缓冲区可以通过减少与 `read()` 或 `write()` 方法调用相对应的物理读取或写入操作次数来提高效率，如[图 10-4](#learnjava6-CHP-10-FIG-buffered)所示。'
- en: '![ljv6 1004](assets/ljv6_1004.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![ljv6 1004](assets/ljv6_1004.png)'
- en: Figure 10-4\. Reading data with and without a buffer
  id: totrans-80
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-4\. 使用缓冲区和不使用缓冲区读取数据
- en: 'You create a buffered stream with an appropriate input or output stream and
    a buffer size. (You can also wrap another stream around a buffered stream so that
    it benefits from the buffering.) Here’s a simple buffered input stream:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过适当的输入或输出流和缓冲区大小创建一个缓冲流。（您也可以将另一个流包装在缓冲流中，以便它从缓冲中获益。）以下是一个简单的缓冲输入流示例：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this example, we specify a buffer size of 32 KB. If we leave off the size
    of the buffer in the constructor, Java creates a reasonably sized buffer for us.
    (Currently the default is 8 KB.) On our first call to `read()`, `bis` tries to
    fill our entire 32 KB buffer with data, if it’s available. Thereafter, calls to
    `read()` retrieve data from the buffer, which is refilled as necessary.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们指定了一个 32 KB 的缓冲区大小。如果在构造函数中没有指定缓冲区的大小，Java 会为我们创建一个合理大小的缓冲区（当前默认为 8
    KB）。在我们第一次调用 `read()` 方法时，`bis` 会尝试用数据填充整个 32 KB 的缓冲区（如果数据可用）。之后，对 `read()` 的调用会从缓冲区中检索数据，并在必要时重新填充缓冲区。
- en: A `BufferedOutputStream` works in a similar way. Calls to `write()` store the
    data in a buffer; data is actually written to the underlying stream only when
    the buffer fills up. You can also use the `flush()` method to write out the contents
    of a `BufferedOutputStream` at any time. The `flush()` method is actually a method
    of the `OutputStream` class itself. It allows you to be sure that all data in
    any underlying streams has been saved or sent.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`BufferedOutputStream` 的工作方式类似。调用 `write()` 方法将数据存储在缓冲区中；只有当缓冲区填满时，数据才实际写入到底层流中。你也可以使用
    `flush()` 方法随时将 `BufferedOutputStream` 的内容写出。`flush()` 方法实际上是 `OutputStream` 类本身的方法。它允许你确保所有底层流中的数据已保存或发送。'
- en: The `BufferedReader` and `BufferedWriter` classes work just like their byte-based
    counterparts, except that they operate on characters instead of bytes.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`BufferedReader`和`BufferedWriter`类的工作方式与它们的基于字节的对应类相同，不同之处在于它们操作的是字符而不是字节。'
- en: PrintWriter and PrintStream
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PrintWriter和PrintStream
- en: Another useful wrapper is `java.io.PrintWriter`. This class provides a suite
    of overloaded `print()` methods that turn their arguments into strings and push
    them out the stream. A complementary set of `println()` convenience methods appends
    a new line to the end of the strings. For formatted text output, `printf()` and
    the identical `format()` methods allow you to write C `printf`-style formatted
    text to the stream.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的包装类是`java.io.PrintWriter`。这个类提供了一系列重载的`print()`方法，将它们的参数转换为字符串并将它们推送到流中。一组补充的`println()`便捷方法在字符串末尾添加了一个新行。对于格式化文本输出，`printf()`和完全相同的`format()`方法允许您向流中写入C
    `printf`风格的格式化文本。
- en: '`PrintWriter` is an unusual character stream because it can wrap either an
    `OutputStream` or another `Writer`. `PrintWriter` is the more capable big brother
    of the legacy `PrintStream` byte stream. The `System.out` and `System.err` streams
    are `PrintStream` objects, which you have already seen throughout this book:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`PrintWriter`是一个不同寻常的字符流，因为它可以包装`OutputStream`或另一个`Writer`。`PrintWriter`是传统的`PrintStream`字节流的更强大的大哥。`System.out`和`System.err`流都是`PrintStream`对象，这一点在本书中已经多次见识过：'
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When you create a `PrintWriter` object, you can pass an additional Boolean
    value to the constructor, specifying whether it should “auto-flush.” If this value
    is `true`, the `PrintWriter` automatically performs a `flush()` on the underlying
    `OutputStream` or `Writer` each time it sends a newline:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`PrintWriter`对象时，可以在构造函数中传递一个额外的布尔值，指定是否“自动刷新”。如果这个值为`true`，`PrintWriter`在每次发送换行符时会自动执行`flush()`操作，刷新底层的`OutputStream`或`Writer`：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When you use this technique with a buffered output stream, it acts like a terminal
    that outputs data line by line.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将此技术与缓冲输出流一起使用时，它就像一个终端，逐行输出数据。
- en: 'The other big advantage that `PrintStream` and `PrintWriter` have over regular
    character streams is that they shield you from exceptions thrown by the underlying
    streams. Unlike methods in other stream classes, the methods of `PrintWriter`
    and `PrintStream` do not throw `IOException`s. Instead, they provide a method
    to explicitly check for errors, if required. This makes the common operation of
    printing text a lot easier. You can check for errors with the `checkError()` method:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`PrintStream`和`PrintWriter`相比常规字符流的另一个重大优势在于，它们可以屏蔽底层流抛出的异常。与其他流类的方法不同，`PrintWriter`和`PrintStream`的方法不会抛出`IOException`。相反，它们提供了一个方法来显式检查错误（如果需要的话）。这使得打印文本的常见操作变得更加容易。您可以使用`checkError()`方法来检查错误：'
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This feature of `PrintStream` and `PrintWriter` means you can generally output
    text to a variety of destinations without wrapping every print statement in a
    `try` block. But it still gives you access to any errors that occur if you are
    writing important information and want to guarantee that nothing went wrong.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`PrintStream`和`PrintWriter`的这个特性意味着您通常可以将文本输出到各种目标，而无需将每个打印语句都包装在`try`块中。但如果您正在写入重要信息并希望确保没有任何错误发生，它仍然会让您访问到发生的任何错误。'
- en: The java.io.File Class
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: java.io.File类
- en: A popular destination for printed output is a file. The `java.io.File` class
    encapsulates access to information about a file or directory. You can use `File`
    to get attribute information about a file, list the entries in a directory, and
    perform basic filesystem operations, such as deleting a file or making a new directory.
    While the `File` object handles these “meta” operations, it doesn’t provide the
    API for reading and writing file data; you’ll need file streams for that.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 打印输出的一个流行目标是文件。`java.io.File`类封装了关于文件或目录的信息访问。您可以使用`File`获取文件的属性信息，列出目录中的条目，并执行基本的文件系统操作，比如删除文件或创建新目录。虽然`File`对象处理这些“元”操作，但它不提供读写文件数据的API；您需要使用文件流来完成这些操作。
- en: File constructors
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件构造函数
- en: 'You can create an instance of `File` from a `String` pathname:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从`String`路径名创建`File`的实例：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can also create a file with a relative path that starts in the current
    working directory of the JVM:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用以JVM当前工作目录为起点的相对路径来创建文件：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can determine the current working directory by reading the `user.dir` property
    in the `System` properties list:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过读取`System`属性列表中的`user.dir`属性来确定当前工作目录：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'An overloaded version of the `File` constructor lets you specify the directory
    path and filename as separate `String` objects:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`File` 构造函数的重载版本允许你将目录路径和文件名指定为单独的 `String` 对象：'
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'With yet another variation, you can specify the directory with a `File` object
    and the filename with a `String`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种变化，你可以使用 `File` 对象指定目录，用 `String` 指定文件名：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: None of these `File` constructors actually creates a file or directory, and
    it is not an error to create a `File` object for a nonexistent file. The `File`
    object is just a handle for a file or directory whose properties you may wish
    to read, write, or test. For example, you can use the `exists()` instance method
    to learn whether the file or directory exists. Many applications perform this
    test prior to saving to a file, for example. If the chosen file doesn’t exist,
    hooray! The application can safely save its data. If the file does already exist,
    you often get an overwrite warning to make sure you want to replace the old file.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 `File` 构造函数实际上都不创建文件或目录，并且为不存在的文件创建 `File` 对象不会报错。`File` 对象只是文件或目录的句柄，你可能希望读取、写入或测试其属性。例如，你可以使用
    `exists()` 实例方法来了解文件或目录是否存在。许多应用程序在保存文件之前执行此测试。如果所选文件不存在，太好了！应用程序可以安全地保存其数据。如果文件已经存在，则通常会收到一个覆盖警告，以确保你确实要替换旧文件。
- en: Path localization
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 路径本地化
- en: In Java, pathnames are expected to follow the conventions of the local filesystem.
    The Windows filesystem uses distinct *roots* (top-level directories) with drive
    letters (for example, “C:”) and a backslash (\) instead of the single root and
    forward slash (/) path separator that is used in Linux and macOS systems.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，路径名应遵循本地文件系统的约定。Windows 文件系统使用具有驱动器号的不同*根*（顶级目录）（例如，“C:”）和反斜线 (\)，而不是
    Linux 和 macOS 系统中使用的单个根和正斜线 (/) 路径分隔符。
- en: Java tries to compensate for this difference. For example, on Windows platforms,
    it accepts paths with either forward slashes or backslashes. On macOS and Linux,
    however, it only accepts forward slashes.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Java 尝试弥补这种差异。例如，在 Windows 平台上，它接受斜线或反斜线的路径。然而，在 macOS 和 Linux 上，它只接受斜线。
- en: Your best bet is to make sure you follow the filename conventions of the host
    filesystem. If your application has a GUI that is opening and saving files at
    the user’s request, you should be able to handle that functionality with the Swing
    `JFileChooser` class. This class encapsulates a graphical file-selection dialog
    box. The methods of the `JFileChooser` take care of system-dependent filename
    features for you.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你最好确保你遵循主机文件系统的文件名约定。如果你的应用程序有一个 GUI，它可以根据用户的请求打开和保存文件，那么你应该能够使用 Swing 的 `JFileChooser`
    类来处理这个功能。这个类封装了一个图形文件选择对话框。`JFileChooser` 的方法会为你处理系统相关的文件名特性。
- en: If your application needs to deal with files on its own behalf, however, things
    get a little more complicated. The `File` class contains a few `static` variables
    to make this task easier. `File.separator` defines a `String` that specifies the
    file separator on the local host (e.g., `/` on Unix and macOS systems, and `\`
    on Windows systems); `File.separatorChar` provides the same information as a `char`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序需要代表自己处理文件，那么事情就会变得有点复杂。`File` 类包含一些 `static` 变量，以使这项任务更加简单。`File.separator`
    定义了一个 `String`，指定了本地主机上的文件分隔符（例如，在 Unix 和 macOS 系统上是 `/`，在 Windows 系统上是 `\`）；`File.separatorChar`
    提供了相同的信息，但以一个 `char` 的形式提供。
- en: 'You can use this system-dependent information in several ways. Probably the
    simplest way to localize pathnames is to pick a convention that you use internally,
    such as the forward slash (/), and do a `String` replace to substitute for the
    localized separator character:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以以几种方式使用这些与系统相关的信息。可能最简单的本地化路径名的方法是选择一个你在内部使用的约定，比如正斜线 (/)，然后使用 `String` 的替换方法来替换本地化的分隔符字符：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Alternatively, you could work with the components of a pathname and build the
    local pathname when you need it:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用路径名的组件并在需要时构建本地路径名：
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-119
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Remember that Java interprets backslash characters (`\`) in source code as
    escape characters when they’re used in a `String`. To get a literal backslash,
    you have to double up: `\\`.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在 Java 中，当反斜杠字符 (`\`) 在源代码中用作 `String` 时，Java 会将其解释为转义字符。要获得一个字面上的反斜杠，你必须使用双反斜杠：`\\`。
- en: 'To grapple with the issue of filesystems with multiple “roots” (for example,
    `C:\` on Windows), the `File` class provides the static method `listRoots()`,
    which returns an array of `File` objects corresponding to the filesystem root
    directories. You can try this out in *jshell*:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决具有多个“根目录”（例如，在Windows上是`C:\`）的文件系统的问题，`File`类提供了静态方法`listRoots()`，它返回一个`File`对象数组，对应于文件系统根目录。你可以在*jshell*中尝试这个：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Again, in a GUI application, a graphical file chooser dialog generally shields
    you from this problem.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在GUI应用程序中，图形文件选择对话框通常会屏蔽您免受这个问题的影响。
- en: File operations
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件操作
- en: 'Once we have a `File` object, we can use it to perform a number of standard
    operations on the file or directory it represents. Several methods let us ask
    questions about the `File`. For example, `isFile()` returns `true` if the `File`
    represents a regular file, while `isDirectory()` returns `true` if it’s a directory.
    `isAbsolute()` indicates whether the `File` encapsulates an absolute or relative
    path specification. A *relative path* is relative to the application’s working
    directory. An *absolute path* is a system-dependent notion that means that the
    path isn’t tied to the working directory or current drive. In Unix and macOS,
    an absolute path starts with a forward slash: */Users/pat/foo.txt*. In Windows,
    it is a full path including the drive letter: *C:\Users\pat\foo.txt* (and, again,
    it can be on a different drive letter than the working directory if there are
    multiple drives in the system).'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了一个`File`对象，我们就可以使用它对其表示的文件或目录执行许多标准操作。几个方法让我们向`File`询问问题。例如，如果`File`表示一个普通文件，则`isFile()`返回`true`，而如果它是一个目录，则`isDirectory()`返回`true`。`isAbsolute()`指示`File`是否封装了绝对或相对路径规范。*相对路径*是相对于应用程序的工作目录的。*绝对路径*是一个系统相关的概念，表示该路径不与工作目录或当前驱动器绑定。在Unix和macOS中，绝对路径以斜杠开头：*/Users/pat/foo.txt*。在Windows中，它是包括驱动器号的完整路径：*C:\Users\pat\foo.txt*（而且，再次强调，如果系统中有多个驱动器，则它可以位于与工作目录不同的驱动器上）。
- en: Components of the pathname are available through the methods `getName()`, `getPath()`,
    `getAbsolutePath()`, and `getParent()`. The `getName()` method returns a `String`
    for the filename without any directory information. If the `File` has an absolute
    path specification, `getAbsolutePath()` returns that path. Otherwise, it returns
    the relative path appended to the current working directory (attempting to make
    it an absolute path). The `getParent()` method returns the parent directory of
    the file or directory.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`getName()`、`getPath()`、`getAbsolutePath()`和`getParent()`方法可以获得路径名的各个组成部分。`getName()`方法返回一个没有任何目录信息的文件名的`String`。如果`File`具有绝对路径规范，则`getAbsolutePath()`返回该路径。否则，它会返回相对路径附加到当前工作目录（尝试将其转换为绝对路径）。`getParent()`方法返回文件或目录的父目录。
- en: The string returned by `getPath()` or `getAbsolutePath()` may not follow the
    same case conventions as the underlying filesystem. You can retrieve the filesystem’s
    own (or “canonical”) version of the file’s path by using the method `getCanonicalPath()`.
    In Windows, for example, you can create a `File` object whose `getAbsolutePath()`
    is *C:\Autoexec.bat* but whose `getCanonicalPath()` is *C:\AUTOEXEC.BAT*; both
    actually point to the same file. This is useful for comparing filenames or for
    showing them to the user.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`getPath()`或`getAbsolutePath()`返回的字符串可能不遵循与底层文件系统相同的大小写约定。你可以通过使用`getCanonicalPath()`方法来检索文件系统自己的（或“规范的”）版本的文件路径。例如，在Windows中，你可以创建一个`File`对象，它的`getAbsolutePath()`是*C:\Autoexec.bat*，但它的`getCanonicalPath()`是*C:\AUTOEXEC.BAT*；两者实际上指向同一个文件。这对于比较文件名或向用户显示文件名很有用。'
- en: 'You can get or set the modification time of a file or directory with the `lastModified()`
    and `setLastModified()` methods. The value is a `long` that is the number of milliseconds
    since the *epoch* (the name for the “first” date in Unix: January 1, 1970, 00:00:00
    GMT). We can also get the size of the file, in bytes, with `length()`.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`lastModified()`和`setLastModified()`方法获取或设置文件或目录的修改时间。该值是一个`long`，表示自Unix纪元（Unix中的“第一个”日期的名称：1970年1月1日00:00:00
    GMT）以来的毫秒数。我们还可以使用`length()`方法获取文件的大小，以字节为单位。
- en: 'Here’s a fragment of code that prints some information about a file:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一段打印文件信息的代码片段：
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If the `File` object corresponds to a directory, we can list the files in the
    directory with the `list()` method or the `listFiles()` method:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`File`对象对应的是一个目录，我们可以使用`list()`方法或`listFiles()`方法列出目录中的文件：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`list()` returns an array of `String` objects that contains filenames. `listFiles()`
    returns an array of `File` objects. Note that in neither case are the files guaranteed
    to be in any kind of order (alphabetical, for example). You can use the Collections
    API to sort strings alphabetically, like so:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`list()`返回一个`String`对象数组，其中包含文件名。`listFiles()`返回一个`File`对象数组。请注意，在任何情况下文件都不保证以任何形式（例如按字母顺序）排序。您可以使用集合API按字母顺序对字符串进行排序，如下所示：'
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If the `File` refers to a nonexistent directory, we can create the directory
    with `mkdir()` or `mkdirs()`. The `mkdir()` method creates at most a single directory
    level, so any intervening directories in the path must already exist. `mkdirs()`
    creates all directory levels necessary to create the full path of the `File` specification.
    In either case, if the directory cannot be created, the method returns `false`.
    Use `renameTo()` to rename a file or directory, and `delete()` to delete a file
    or directory.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`File`引用不存在的目录，我们可以使用`mkdir()`或`mkdirs()`创建目录。`mkdir()`方法最多创建单个目录级别，因此路径中的任何中间目录都必须已经存在。`mkdirs()`创建必要的所有目录级别以创建`File`规范的完整路径。在任何情况下，如果无法创建目录，则该方法返回`false`。使用`renameTo()`重命名文件或目录，使用`delete()`删除文件或目录。
- en: Although you can create a directory using the `File` object, you don’t typically
    use `File` to create a file; that’s normally done implicitly when you write data
    to it with a `FileOutputStream` or `FileWriter`, as we’ll discuss in a moment.
    The exception is the `createNewFile()` method, which you can use to create a new
    zero-length file at the `File`’s location.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以使用`File`对象创建目录，但通常不使用`File`来创建文件；这通常是在使用`FileOutputStream`或`FileWriter`写入数据时隐含完成的，稍后我们会讨论。例外是`createNewFile()`方法，您可以使用它在`File`位置创建一个新的零长度文件。
- en: The `createNewFile()` operation is guaranteed to be atomic^([3](ch10.html#id2038))
    with respect to all other file creation in the filesystem. Java returns a Boolean
    value from `createNewFile()` that tells you whether the file was created or not.
    Creating a new file this way is useful when you also use `deleteOnExit()`, which
    flags the file to be automatically removed when the Java VM exits. This combination
    allows you to guard resources or make an application that can only be run in a
    single instance at a time.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 从文件系统的所有其他文件创建操作方面来看，`createNewFile()`操作是原子的^([3](ch10.html#id2038))。Java从`createNewFile()`返回一个布尔值，告诉您文件是否已创建。以这种方式创建新文件在您还使用`deleteOnExit()`的情况下特别有用，后者标记文件在Java虚拟机退出时自动删除。此组合允许您保护资源或创建一次只能在单个实例中运行的应用程序。
- en: Another file creation method that is related to the `File` class itself is the
    static method `createTempFile()`, which creates a file in a specified location
    using an automatically generated, unique name. You typically use `createTempFile()`
    in conjunction with `deleteOnExit()`. Network applications use this combination
    frequently to create short-lived files for storing requests or building responses.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 与`File`类本身相关的另一种文件创建方法是静态方法`createTempFile()`，它使用自动生成的唯一名称在指定位置创建文件。通常与`deleteOnExit()`结合使用`createTempFile()`。网络应用程序经常使用这种组合来创建临时文件，用于存储请求或构建响应。
- en: The `toURL()` method converts a file path to a `file:` URL object. URLs are
    a kind of abstraction that allow you to point to any kind of object anywhere on
    a network. Converting a `File` reference to a URL may be useful for consistency
    with more general utilities that deal with URLs. Java’s NIO, for example, uses
    URLs to reference new types of filesystems that are implemented directly in Java
    code.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`toURL()`方法将文件路径转换为`file:` URL对象。URL是一种抽象，允许您指向网络上任何类型的对象。将`File`引用转换为URL可能对与处理URL的更一般实用程序保持一致性有用。例如，Java的NIO使用URL引用直接在Java代码中实现的新类型的文件系统。'
- en: '[Table 10-1](#learnjava6-CHP-10-TABLE-1) summarizes the methods provided by
    the `File` class.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 10-1](#learnjava6-CHP-10-TABLE-1)总结了`File`类提供的方法。'
- en: Table 10-1\. File methods
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10-1\. 文件方法
- en: '| Method | Return type | Description |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 返回类型 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `canExecute()` | `boolean` | Is the file executable? |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `canExecute()` | `boolean` | 文件是否可执行？ |'
- en: '| `canRead()` | `boolean` | Is the file (or directory) readable? |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `canRead()` | `boolean` | 文件（或目录）是否可读？ |'
- en: '| `canWrite()` | `boolean` | Is the file (or directory) writable? |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `canWrite()` | `boolean` | 文件（或目录）是否可写？ |'
- en: '| `createNewFile()` | `boolean` | Creates a new file. |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `createNewFile()` | `boolean` | 创建一个新文件。 |'
- en: '| `createTempFile (String` *`pfx`*, `String`*`sfx`*`)` | `File` | Static method
    to create a new file, with the specified prefix and suffix, in the default temp
    file directory. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `createTempFile (String` *`pfx`*, `String`*`sfx`*`)` | `File` | 静态方法，在默认临时文件目录中创建一个带有指定前缀和后缀的新文件。
    |'
- en: '| `delete()` | `boolean` | Deletes the file (or directory). |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `delete()` | `boolean` | 删除文件（或目录）。 |'
- en: '| `deleteOnExit()` | `Void` | When it exits, the Java runtime system deletes
    the file. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `deleteOnExit()` | `Void` | Java运行时系统在退出时删除文件。 |'
- en: '| `exists()` | `boolean` | Does the file (or directory) exist? |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `exists()` | `boolean` | 文件（或目录）是否存在？ |'
- en: '| `getAbsolutePath()` | `String` | Returns the absolute path of the file (or
    directory). |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `getAbsolutePath()` | `String` | 返回文件（或目录）的绝对路径。 |'
- en: '| `getCanonicalPath()` | `String` | Returns the absolute, case-correct, and
    relative-element-resolved path of the file (or directory). |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `getCanonicalPath()` | `String` | 返回文件（或目录）的绝对路径，大小写正确，并且解析了相对元素。 |'
- en: '| `getFreeSpace()` | `long` | Gets the number of bytes of unallocated space
    on the partition holding this path or 0 if the path is invalid. |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `getFreeSpace()` | `long` | 获取包含此路径的分区上未分配空间的字节数，如果路径无效则返回0。 |'
- en: '| `getName()` | `String` | Returns the name of the file (or directory). |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `getName()` | `String` | 返回文件（或目录）的名称。 |'
- en: '| `getParent()` | `String` | Returns the name of the parent directory of the
    file (or directory). |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `getParent()` | `String` | 返回文件（或目录）的父目录名称。 |'
- en: '| `getPath()` | `String` | Returns the path of the file (or directory). (Not
    to be confused with `toPath()`.) |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `getPath()` | `String` | 返回文件（或目录）的路径。（不要与`toPath()`混淆。） |'
- en: '| `getTotalSpace()` | `long` | Gets the size of the partition that contains
    the file path, in bytes, or 0 if the path is invalid. |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `getTotalSpace()` | `long` | 获取包含文件路径的分区的大小（以字节为单位），如果路径无效则返回0。 |'
- en: '| `getUseableSpace()` | `long` | Gets the number of bytes of user-accessible
    unallocated space on the partition holding this path or 0 if the path is invalid.
    This method attempts to take into account user write permissions. |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `getUseableSpace()` | `long` | 获取包含此路径的分区上用户可访问的未分配空间的字节数，如果路径无效则返回0。此方法试图考虑用户的写权限。
    |'
- en: '| `isAbsolute()` | `boolean` | Is the filename (or directory name) absolute?
    |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `isAbsolute()` | `boolean` | 文件名（或目录名）是否是绝对的？ |'
- en: '| `isDirectory()` | `boolean` | Is the item a directory? |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `isDirectory()` | `boolean` | 该项是否为目录？ |'
- en: '| `isFile()` | `boolean` | Is the item a file? |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `isFile()` | `boolean` | 该项是否为文件？ |'
- en: '| `isHidden()` | `boolean` | Is the item hidden? (System dependent.) |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `isHidden()` | `boolean` | 该项是否隐藏？（依赖于系统。） |'
- en: '| `lastModified()` | `long` | Returns the last modification time of the file
    (or directory). |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `lastModified()` | `long` | 返回文件（或目录）的最后修改时间。 |'
- en: '| `length()` | `long` | Returns the length of the file. |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `length()` | `long` | 返回文件的长度。 |'
- en: '| `list()` | `String []` | Returns a list of files in the directory. |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `list()` | `String []` | 返回目录中文件的列表。 |'
- en: '| `listFiles()` | `File[]` | Returns the contents of the directory as an array
    of `File` objects. |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `listFiles()` | `File[]` | 返回目录内容作为`File`对象数组。 |'
- en: '| `listRoots()` | `File[]` | Returns an array of root filesystems, if any (e.g.,
    C:/, D:/). |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `listRoots()` | `File[]` | 返回根文件系统的数组，如果有的话（例如，C:/，D:/）。 |'
- en: '| `mkdir()` | `boolean` | Creates the directory. |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `mkdir()` | `boolean` | 创建目录。 |'
- en: '| `mkdirs()` | `boolean` | Creates all directories in the path. |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `mkdirs()` | `boolean` | 创建路径中的所有目录。 |'
- en: '| `renameTo(File` *`dest`* `)` | `boolean` | Renames the file (or directory).
    |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `renameTo(File` *`dest`* `)` | `boolean` | 重命名文件（或目录）。 |'
- en: '| `setExecutable()` | `boolean` | Sets execute permissions for the file. |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `setExecutable()` | `boolean` | 设置文件的执行权限。 |'
- en: '| `setLastModified()` | `boolean` | Sets the last-modified time of the file
    (or directory). |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `setLastModified()` | `boolean` | 设置文件（或目录）的最后修改时间。 |'
- en: '| `setReadable()` | `boolean` | Sets read permissions for the file. |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `setReadable()` | `boolean` | 设置文件的读权限。 |'
- en: '| `setReadOnly()` | `boolean` | Sets the file to read-only status. |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `setReadOnly()` | `boolean` | 设置文件为只读状态。 |'
- en: '| `setWriteable()` | `boolean` | Sets the write permissions for the file. |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `setWriteable()` | `boolean` | 设置文件的写权限。 |'
- en: '| `toPath()` | `java.nio.file.Path` | Convert the file to an NIO file path.
    (Not to be confused with `getPath()`.) |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `toPath()` | `java.nio.file.Path` | 将文件转换为NIO文件路径。（不要与`getPath()`混淆。） |'
- en: '| `toURL()` | `java.net.URL` | Generates a URL object for the file (or directory).
    |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `toURL()` | `java.net.URL` | 生成文件（或目录）的URL对象。 |'
- en: File Streams
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: File Streams
- en: 'You’re probably sick of hearing about files already—and we haven’t even written
    a byte yet! Well, now the fun begins. Java provides two fundamental streams for
    reading from and writing to files: `FileInputStream` and `FileOutputStream`. These
    streams provide the basic byte-oriented `InputStream` and `OutputStream` functionality
    that is applied to reading and writing files. They can be combined with the filter
    streams described earlier to work with files in the same way as other stream communications.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经对文件听得耳朵生茧了，但我们甚至还没有写一个字节呢！现在，让我们开始享受乐趣吧。Java 提供了两种基本流用于从文件中读取和写入：`FileInputStream`
    和 `FileOutputStream`。这些流提供了基本的字节导向 `InputStream` 和 `OutputStream` 功能，用于读取和写入文件。它们可以与前面描述的过滤流结合使用，以与其他流通信方式相同的方式处理文件。
- en: 'You can create a `FileInputStream` from a `String` pathname or a `File` object:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从 `String` 路径名或 `File` 对象创建 `FileInputStream`：
- en: '[PRE25]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When you create a `FileInputStream`, the Java runtime system attempts to open
    the specified file. Thus, the `FileInputStream` constructors can throw a `FileNotFoundException`
    if the specified file doesn’t exist, or an `IOException` if some other I/O error
    occurs. You must catch these exceptions in your code. Wherever possible, it’s
    a good idea to get in the habit of using the `try`-with-resources construct to
    automatically close files for you when you are finished with them:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `FileInputStream` 时，Java 运行时系统尝试打开指定的文件。因此，如果指定的文件不存在，`FileInputStream` 构造函数可能会抛出
    `FileNotFoundException`，或者在发生其他 I/O 错误时抛出 `IOException`。你必须在代码中捕获这些异常。在可能的情况下，习惯上使用
    `try`-with-resources 结构来自动关闭文件是一个好习惯：
- en: '[PRE26]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: When you first create the stream, its `available()` method and the `File` object’s
    `length()` method should return the same value.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当你首次创建流时，它的 `available()` 方法和 `File` 对象的 `length()` 方法应该返回相同的值。
- en: To read characters from a file as a `Reader`, you can wrap an `InputStreamReader`
    around a `FileInputStream`. You can also use the `FileReader` class, which is
    provided as a convenience. `FileReader` is just a `FileInputStream` wrapped in
    an `InputStreamReader` with some defaults.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要将文件中的字符作为 `Reader` 读取，可以将 `InputStreamReader` 包装在 `FileInputStream` 周围。你也可以使用提供的便利类
    `FileReader`。`FileReader` 实际上只是一个带有一些默认值的 `InputStreamReader` 包装在 `FileInputStream`
    中。
- en: 'The following class, `ListIt`, is a small utility that prints the contents
    of a file or directory to standard output:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的类 `ListIt` 是一个小型实用程序，将文件或目录的内容打印到标准输出：
- en: '[PRE27]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`ListIt` constructs a `File` object from its first command-line argument and
    tests the `File` to see whether it exists and is readable. If the `File` is a
    directory, `ListIt` outputs the names of the files in the directory. Otherwise,
    `ListIt` reads and outputs the file, line by line. Give it a try! Can you use
    `ListIt` on *ListIt.java*?'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListIt` 从其第一个命令行参数构造一个 `File` 对象，并测试该 `File` 是否存在且可读。如果 `File` 是一个目录，`ListIt`
    输出目录中文件的名称。否则，`ListIt` 按行读取并输出文件内容。试试看！你能在 *ListIt.java* 上使用 `ListIt` 吗？'
- en: For writing files, you can create a `FileOutputStream` from a `String` pathname
    or a `File` object. Unlike `FileInputStream`, however, the `FileOutputStream`
    constructors don’t throw a `FileNotFoundException`. If the specified file doesn’t
    exist, the `FileOutputStream` creates the file. The `FileOutputStream` constructors
    can throw an `IOException` if some other I/O error occurs, so you still need to
    handle this exception.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 对于写入文件，可以从 `String` 路径名或 `File` 对象创建 `FileOutputStream`。然而，与 `FileInputStream`
    不同的是，`FileOutputStream` 构造函数不会抛出 `FileNotFoundException`。如果指定的文件不存在，`FileOutputStream`
    将创建文件。`FileOutputStream` 构造函数可能会在发生其他 I/O 错误时抛出 `IOException`，因此仍然需要处理此异常。
- en: 'If the specified file does exist, the `FileOutputStream` opens it for writing.
    When you subsequently call the `write()` method, the new data overwrites the current
    contents of the file. If you need to append data to an existing file, you can
    use a form of the constructor that accepts a Boolean `append` flag:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指定的文件存在，`FileOutputStream` 将打开它进行写入。随后调用 `write()` 方法时，新数据将覆盖文件的当前内容。如果需要向现有文件追加数据，可以使用一个接受布尔型
    `append` 标志的构造函数形式：
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Another way to append data to files is with `RandomAccessFile`, which we’ll
    discuss shortly.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种向文件追加数据的方式是使用 `RandomAccessFile`，我们将稍后讨论。
- en: Just as with reading, to write characters (instead of bytes) to a file, you
    can wrap an `OutputStreamWriter` around a `FileOutputStream`. If you want to use
    the default character-encoding scheme, you can use the `FileWriter` class instead,
    which is provided as a convenience.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 与读取一样，如果要向文件写入字符（而不是字节），可以在 `FileOutputStream` 周围包装一个 `OutputStreamWriter`。如果要使用默认的字符编码方案，可以使用
    `FileWriter` 类，这是一个方便的选择。
- en: 'The following snippet reads a line of data from standard input and writes it
    to the file */tmp/foo.txt*:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码从标准输入读取一行数据，并将其写入文件 */tmp/foo.txt*：
- en: '[PRE29]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Notice how we wrapped the `FileWriter` in a `PrintWriter` to facilitate writing
    the data. Also, to be a good filesystem citizen, call the `close()` method when
    you’re done. Here, closing the `PrintWriter` closes the underlying `Writer` for
    us.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何将 `FileWriter` 包装在 `PrintWriter` 中以便写入数据。此外，作为一个良好的文件系统使用者，在完成操作后调用 `close()`
    方法。在这里，关闭 `PrintWriter` 也会关闭底层的 `Writer`。
- en: RandomAccessFile
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RandomAccessFile
- en: The `java.io.RandomAccessFile` class provides the ability to read *and* write
    data at any location in a file. `RandomAccessFile` implements both the `DataInput`
    and `DataOutput` interfaces, so you can use it to read and write strings and primitive
    types anywhere in the file just as if it were a `DataInputStream` and `DataOutputStream`.
    However, because the class provides random, rather than sequential, access to
    file data, it’s not a subclass of either `InputStream` or `OutputStream`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.io.RandomAccessFile` 类提供了在文件中任意位置读取和写入数据的能力。`RandomAccessFile` 实现了 `DataInput`
    和 `DataOutput` 接口，因此你可以像使用 `DataInputStream` 和 `DataOutputStream` 一样在文件中任意位置读取和写入字符串和基本类型数据。但是，因为这个类提供对文件数据的随机访问而不是顺序访问，所以它不是
    `InputStream` 或 `OutputStream` 的子类。'
- en: 'You can create a `RandomAccessFile` from a `String` pathname or a `File` object.
    The constructor also takes a second `String` argument that specifies the mode
    of the file. Use the string `"r"` for a read-only file or `"rw"` for a read/write
    file:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 可以根据 `String` 路径名或 `File` 对象创建 `RandomAccessFile`。构造函数还接受第二个 `String` 参数，指定文件的模式。使用字符串
    `"r"` 表示只读文件，使用 `"rw"` 表示读/写文件：
- en: '[PRE30]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When you create a `RandomAccessFile` in read-only mode, Java tries to open the
    specified file. If the file doesn’t exist, `RandomAccessFile` throws an `IOException`.
    If, however, you’re creating a `RandomAccessFile` in read/write mode, the object
    creates the file if it doesn’t exist. The constructor can still throw an `IOException`
    if some other I/O error occurs, so you still need to handle this exception.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当以只读模式创建 `RandomAccessFile` 时，Java 尝试打开指定的文件。如果文件不存在，`RandomAccessFile` 会抛出
    `IOException`。然而，如果以读/写模式创建 `RandomAccessFile`，如果文件不存在，对象会创建该文件。构造函数仍然可能因为其他 I/O
    错误而抛出 `IOException`，因此你仍然需要处理这个异常。
- en: After you have created a `RandomAccessFile`, you can call any of the normal
    reading and writing methods, just as you would with a `DataInputStream` or `DataOutputStream`.
    If you try to write to a read-only file, the write method throws an `IOException`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了 `RandomAccessFile` 后，你可以调用任何常规的读取和写入方法，就像使用 `DataInputStream` 或 `DataOutputStream`
    一样。如果尝试向只读文件写入数据，写入方法会抛出 `IOException`。
- en: What makes a `RandomAccessFile` special is the `seek()` method. This method
    takes a `long` value and uses it to set the location for reading and writing in
    the file. You can use the `getFilePointer()` method to get the current location.
    If you need to append data to the end of the file, use `length()` to determine
    that location, then `seek()` to it. You can write or seek beyond the end of a
    file, but you can’t read beyond the end of a file. The `read()` method throws
    an `EOFException` if you try to do this.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`RandomAccessFile` 的特殊之处在于 `seek()` 方法。这个方法接受一个 `long` 值，并将其用于设置文件中的读写位置。你可以使用
    `getFilePointer()` 方法来获取当前位置。如果需要向文件末尾追加数据，可以使用 `length()` 确定位置，然后 `seek()` 到该位置。你可以写入或定位到文件末尾以外的位置，但不能从文件末尾以外读取。如果尝试这样做，`read()`
    方法会抛出 `EOFException` 异常。'
- en: 'Here’s an example of writing data for a simple database:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个简单数据库写入数据的示例：
- en: '[PRE31]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this snippet, we assume that the `String` length for `userName`, along with
    any data that comes after it, fits within the specified record size.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们假设 `userName` 的 `String` 长度以及其后的任何数据都适合指定的记录大小内。
- en: The New I/O File API
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新 I/O 文件 API
- en: We are now going to turn our attention from the original, “classic” Java File
    API to the NIO File API. As we mentioned earlier, the NIO File API can be thought
    of as either a replacement for or a complement to the classic API. The new API
    moves Java toward a higher performance and more flexible style of I/O supporting
    *selectable* and asynchronously interruptible *channels*. (More on selecting and
    using channels soon.) When working with files, the new API’s strength is providing
    a fuller abstraction of the filesystem in Java.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将注意力从原始的“经典”Java文件 API 转向 NIO 文件 API。正如我们前面提到的，NIO 文件 API 可以被视为经典 API 的替代或补充。新
    API 将 Java 移向更高性能和更灵活的 I/O 风格，支持可选择的和异步可中断的*通道*（后面将详细讨论选择和使用通道）。在处理文件时，新 API 的优势在于在
    Java 中提供了更完整的文件系统抽象。
- en: In addition to better support for existing, real-world filesystem types—including
    the new and welcomed ability to copy and move files, manage links, and get detailed
    file attributes like owners and permissions—NIO allows you to implement entirely
    new types of filesystems directly in Java. The best example of this is the ZIP
    filesystem provider. You can “mount” a ZIP archive file as a filesystem. You can
    work with the files within the archive directly using the standard APIs, just
    like any other filesystem.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 除了更好地支持现有的、真实世界中的文件系统类型——包括新的和受欢迎的复制和移动文件、管理链接以及获取详细文件属性如所有者和权限的能力——NIO 允许您直接在
    Java 中实现全新类型的文件系统。最好的例子是 ZIP 文件系统提供者。您可以将 ZIP 归档文件“挂载”为文件系统。您可以使用标准 API 直接在归档文件中处理文件，就像处理任何其他文件系统一样。
- en: The NIO File package also provides some utilities that would have saved Java
    developers a lot of repeated code over the years, including directory tree change
    monitoring, filesystem traversal, filename “globbing” (the jargon for using wildcards
    in filenames), and convenience methods to read entire files directly into memory.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: NIO 文件包还提供了一些工具，这些工具多年来可以节省 Java 开发人员大量重复的代码，包括目录树变更监视、文件系统遍历、文件名“匹配”（使用通配符匹配文件名的行话）以及直接将整个文件读取到内存的便利方法。
- en: We’ll cover the basic NIO File API in this section and return to the topic of
    buffers and channels at the end of the chapter. In particular, we’ll talk about
    `ByteChannel`s and `FileChannel`, which you can think of as alternate, buffer-oriented
    streams for reading and writing files and other types of data.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本节介绍基本的 NIO 文件 API，并在章节末回到缓冲区和通道的主题。特别是，我们将讨论`ByteChannel`和`FileChannel`，您可以将其视为用于读取和写入文件和其他类型数据的备选、基于缓冲区的流。
- en: FileSystem and Path
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FileSystem 和 Path
- en: 'There are three main players in the `java.nio.file` package:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.nio.file` 包中有三个主要角色：'
- en: '`FileSystem`'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileSystem`'
- en: An underlying storage mechanism and serves as a factory^([4](ch10.html#id2069))
    for `Path` objects.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`Path` 是底层存储机制并且作为`Path`对象的工厂。'
- en: '`FileSystems`'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileSystems`'
- en: A factory for `FileSystem` objects.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileSystem` 对象的工厂。'
- en: '`Path`'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`Path`'
- en: The location of a file or directory within the filesystem.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统中文件或目录的位置。
- en: '`Files`'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`Files`'
- en: A utility class that contains a rich set of static methods for manipulating
    `Path` objects to perform all of the basic file operations analogous to the classic
    API.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 一个实用类，包含一组丰富的静态方法，用于操作 `Path` 对象以执行与经典 API 类似的所有基本文件操作。
- en: 'The `FileSystems` (plural) class is our starting point. Let’s create a couple
    of filesystems:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileSystems`（复数形式）类是我们的起点。让我们创建几个文件系统：'
- en: '[PRE32]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As shown in this snippet, we ask for the default filesystem to manipulate files
    in the host computer’s environment. We also use the `FileSystems` class to construct
    another `FileSystem` by taking a *uniform resource identifier* (or URI, a special
    identifier similar to a URL) that references a custom filesystem type. We use
    `jar:file` as our URI protocol to indicate we are working with a JAR or ZIP file.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本代码片段所示，我们请求默认的文件系统来在主机环境中操作文件。我们还使用`FileSystems`类来构建另一个`FileSystem`，通过一个*统一资源标识符*（或
    URI，类似于 URL 的特殊标识符），该标识符引用自定义文件系统类型。我们使用`jar:file`作为我们的 URI 协议，以指示我们正在处理 JAR 或
    ZIP 文件。
- en: '`FileSystem` implements `Closeable`, and when a `FileSystem` is closed, all
    open file channels and other streaming objects associated with it are closed as
    well. Attempting to read or write to those channels will throw an exception at
    that point. Note that the default filesystem (associated with the host computer)
    cannot be closed.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileSystem` 实现了 `Closeable`，当关闭一个 `FileSystem` 时，所有与其关联的打开文件通道和其他流对象也将被关闭。在那时尝试读取或写入这些通道将抛出异常。请注意，默认文件系统（与主机计算机关联）无法关闭。'
- en: 'Once you have a `FileSystem`, you can use it as a factory for `Path` objects
    that represent files or directories. You can obtain a `Path` using a string representation
    just like the classic `File` class. Subsequently, you can use that `Path` object
    with methods of the `Files` utility to create, read, write, or delete the item:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦有了`FileSystem`，就可以将其用作代表文件或目录的`Path`对象的工厂。您可以使用字符串表示法获取`Path`，就像经典的`File`类一样。随后，您可以使用`Files`实用程序的方法创建、读取、写入或删除该项：
- en: '[PRE33]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This example opens an `OutputStream` to write to the file *foo.txt*. By default,
    if the file does not exist, it will be created, and if it does exist, it will
    be truncated (set to zero length) before new data is written—but you can change
    these results using options. We’ll talk more about `Files` methods in the next
    section.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例打开一个`OutputStream`以写入文件*foo.txt*。默认情况下，如果文件不存在，它将被创建；如果文件已存在，则在写入新数据之前将其截断（设置为零长度）—但您可以使用选项更改这些结果。我们将在下一节中详细讨论`Files`方法。
- en: The `Path` class implements the `java.lang.Iterable` interface, which can be
    used to iterate through its literal path components, such as the slash-separated
    `tmp` and `foo.txt` in the preceding snippet. (If you want to traverse the path
    to find other files or directories, you might be more interested in the `DirectoryStream`
    and `FileVisitor` that we’ll discuss later.) `Path` also implements the `java.nio.file.Watchable`
    interface, which allows it to be monitored for changes.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`Path`类实现了`java.lang.Iterable`接口，可用于迭代其字面路径组件，例如前面片段中的斜杠分隔的`tmp`和`foo.txt`。（如果要遍历路径以查找其他文件或目录，则可能更感兴趣的是我们稍后将讨论的`DirectoryStream`和`FileVisitor`。）`Path`还实现了`java.nio.file.Watchable`接口，允许对其进行监视以进行更改。'
- en: '`Path` has convenience methods for resolving paths relative to a file or directory:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`Path`具有方便的方法来解析相对于文件或目录的路径：'
- en: '[PRE34]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this snippet, we’ve shown the `Path` methods `resolve()` and `resolveSibling()`
    used to find files or directories relative to a given `Path` object. The `resolve()`
    method is generally used to append a relative path to an existing `Path` representing
    a directory. If the argument provided to the `resolve()` method is an absolute
    path, it will just yield the absolute path (it acts kind of like the Unix or DOS
    `cd` command). The `resolveSibling()` method works the same way, but it is relative
    to the parent of the target `Path`; this method is useful for describing the target
    of a `move()` operation.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在此片段中，我们展示了`Path`方法`resolve()`和`resolveSibling()`用于查找相对于给定`Path`对象的文件或目录。`resolve()`方法通常用于将相对路径附加到表示目录的现有`Path`。如果提供给`resolve()`方法的参数是绝对路径，则仅会生成绝对路径（它的工作方式类似于Unix或DOS的`cd`命令）。`resolveSibling()`方法的工作方式相同，但是它相对于目标`Path`的父级；此方法对于描述`move()`操作的目标非常有用。
- en: Path to classic files and back
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 经典文件路径和返回
- en: 'To bridge the classic and new APIs, corresponding `toPath()` and `toFile()`
    methods have been provided in `java.io.File` and `java.nio.file.Path`, respectively,
    to convert to the other form. Of course, the only types of `Path`s that can be
    produced from `File` are paths representing files and directories in the default
    host filesystem:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 为了连接经典和新API，分别在`java.io.File`和`java.nio.file.Path`中提供了相应的`toPath()`和`toFile()`方法，以将其转换为另一种形式。当然，从`File`生成的`Path`类型只能是默认主机文件系统中表示文件和目录的路径：
- en: '[PRE35]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: NIO File Operations
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NIO 文件操作
- en: Once we have a `Path`, we can operate on it with static methods of the `Files`
    utility to create the path as a file or directory, read and write to it, and interrogate
    and set its properties. We’ll list the bulk of them and then discuss some of the
    more important ones as we proceed.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦有了`Path`，我们可以使用`Files`实用程序的静态方法对其进行操作，以将路径创建为文件或目录，读取和写入它，并查询和设置其属性。我们将列出大部分方法，然后在进一步讨论一些更重要的方法。
- en: '[Table 10-2](#learnjava6-CHP-10-TABLE-2) summarizes these methods of the `java.nio.file.Files`
    class. As you might expect, because the `Files` class handles all types of file
    operations, it contains a large number of methods. To make the table more readable,
    we have elided overloaded forms of the same method (those taking different kinds
    of arguments), and we grouped corresponding and related types of methods together.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 10-2](#learnjava6-CHP-10-TABLE-2)总结了`java.nio.file.Files`类的这些方法。由于`Files`类处理所有类型的文件操作，因此它包含大量方法。为了使表格更易读，我们省略了相同方法的重载形式（接受不同类型参数的方法），并将对应及相关类型的方法组合在一起。'
- en: Table 10-2\. NIO Files methods
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10-2\. NIO Files 方法
- en: '| Method | Return type | Description |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 返回类型 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `copy()` | long or `Path` | Copy a stream to a file path, file path to stream,
    or path to path. Returns the number of bytes copied or the target `Path`. A target
    file may optionally be replaced if it exists (the default is to fail if the target
    exists). Copying a directory results in an empty directory at the target (the
    contents are not copied). Copying a symbolic link copies the linked file’s data
    (producing a regular file copy). |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| `copy()` | long 或 `Path` | 将流复制到文件路径、文件路径到流，或路径到路径。返回复制的字节数或目标 `Path`。如果目标文件存在，可以选择替换（默认为存在时操作失败）。复制目录将在目标处生成空目录（不复制内容）。复制符号链接会复制链接文件的数据（产生常规文件复制）。
    |'
- en: '| `createDirectory()`, `createDirectories()` | `Path` | Create a single directory
    or all directories in a specified path. `createDirectory()` throws an exception
    if the directory already exists. `createDirectories()` will ignore existing directories
    and only create as needed. |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| `createDirectory()`, `createDirectories()` | `Path` | 创建单个目录或指定路径中的所有目录。如果目录已存在，`createDirectory()`
    会抛出异常。`createDirectories()` 则会忽略已存在的目录，仅在需要时创建。 |'
- en: '| `createFile()` | `Path` | Create an empty file. The operation is atomic and
    will only succeed if the file does not exist. (This property can be used to create
    flag files to guard resources, etc.) |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| `createFile()` | `Path` | 创建一个空文件。此操作是原子性的，只有在文件不存在时才会成功。（此属性可用于创建标志文件以保护资源等。）
    |'
- en: '| `createLink()`, `createSymbolicLink()`, `isSymbolicLink()`, `readSymbolicLink()`,
    `createLink()` | boolean or `Path` | Create a hard or symbolic link, test to see
    if a file is a symbolic link, or read the target file pointed to by the symbolic
    link. Symbolic links are files that reference other files. Regular (“hard”) links
    are low-level mirrors of a file where two filenames point to the same underlying
    data. If you don’t know which to use, use a symbolic link. |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| `createLink()`, `createSymbolicLink()`, `isSymbolicLink()`, `readSymbolicLink()`,
    `createLink()` | boolean 或 `Path` | 创建硬链接或符号链接，检测文件是否为符号链接，或读取符号链接指向的目标文件。符号链接是指引用其他文件的文件。普通（“硬”）链接是文件的低级镜像，其中两个文件名指向相同的底层数据。如果不确定使用哪种，建议使用符号链接。
    |'
- en: '| `createTempDirectory()`, `createTempFile()` | `Path` | Create a temporary,
    guaranteed, uniquely named directory or file with the specified prefix. Optionally,
    place it in the system default temp directory. |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| `createTempDirectory()`, `createTempFile()` | `Path` | 创建一个带有指定前缀的临时目录或文件，确保名称唯一。可选择将其放置在系统默认的临时目录中。
    |'
- en: '| `delete()`, `deleteIfExists()` | void | Delete a file or an empty directory.
    `delete``IfExists()` will not throw an exception if the file does not exist. |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| `delete()`, `deleteIfExists()` | void | 删除文件或空目录。`deleteIfExists()` 如果文件不存在则不会抛出异常。
    |'
- en: '| `exists()`, `notExists()` | boolean | Determine whether the file exists (`notExists()`
    simply returns the opposite). Optionally, specify whether links should be followed
    (by default they are). |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| `exists()`, `notExists()` | boolean | 判断文件是否存在（`notExists()` 返回其相反值）。可选择是否跟踪链接（默认是跟踪）。
    |'
- en: '| `getAttribute()`, `set​Attri⁠bute()`, `getFile​Attri⁠buteView()`, `readAttributes()`
    | `Object`, `Map`, or `FileAttributeView` | Get or set filesystem-specific file
    attributes such as access and update times, detailed permissions, and owner information
    using implementation-specific names. |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| `getAttribute()`, `set​Attri⁠bute()`, `getFile​Attri⁠buteView()`, `readAttributes()`
    | `Object`, `Map` 或 `FileAttributeView` | 获取或设置特定于文件系统的文件属性，如访问和更新时间、详细权限和所有者信息，使用实现特定的名称。
    |'
- en: '| `getFileStore()` | `FileStore` | Get a `FileStore` object that represents
    the device, volume, or other type of partition of the filesystem on which the
    path resides. |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| `getFileStore()` | `FileStore` | 获取表示路径所在文件系统上的设备、卷或其他类型分区的 `FileStore` 对象。
    |'
- en: '| `getLastModifiedTime()`, `setLastModifiedTime()` | `FileTime` or `Path` |
    Get or set the last modified time of a file or directory. |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| `getLastModifiedTime()`, `setLastModifiedTime()` | `FileTime` 或 `Path` |
    获取或设置文件或目录的最后修改时间。 |'
- en: '| `getOwner()`, `setOwner()` | `UserPrincipal` | Get or set a `UserPrincipal`
    object representing the owner of the file. Use `toString()` or `getName()` to
    get a string representation of the username. |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| `getOwner()`, `setOwner()` | `UserPrincipal` | 获取或设置代表文件所有者的 `UserPrincipal`
    对象。使用 `toString()` 或 `getName()` 获取用户名的字符串表示形式。 |'
- en: '| `getPosixFile​Permis⁠sions()`, `setPosixFilePermissions()` | `Set` or `Path`
    | Get or set the full POSIX user-group-other style read and write permissions
    for the path as a Set of `PosixFile​Per⁠mission` enum values. |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| `getPosixFile​Permis⁠sions()`, `setPosixFilePermissions()` | `Set` 或 `Path`
    | 获取或设置路径的完整 POSIX 用户-组-其他样式读写权限，作为 `PosixFile​Per⁠mission` 枚举值的集合。 |'
- en: '| `isDirectory()`, `isExecutable()`, `isHidden()`, `isReadable()`, `isRegularFile()`,
    `isWriteable()` | boolean | Test file features such as whether the path is a directory
    and other basic attributes. |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| `isDirectory()`, `isExecutable()`, `isHidden()`, `isReadable()`, `isRegularFile()`,
    `isWritable()` | boolean | 测试文件特性，如路径是否为目录和其他基本属性。 |'
- en: '| `isSameFile()` | boolean | Test to see whether the two paths reference the
    same file (which may potentially be true even if the paths are not identical).
    |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| `isSameFile()` | boolean | 检查两个路径是否引用同一个文件（即使路径不完全相同也可能为真）。 |'
- en: '| `move()` | `Path` | Move a file or directory by renaming or copying it, optionally
    specifying whether to replace any existing target. Rename will be used unless
    a copy is required to move a file across file stores or filesystems. Directories
    can be moved using this method only if the simple rename is possible or if the
    directory is empty. If a directory move requires copying files across file stores
    or filesystems, the method throws an `IOException`. (In this case, you must copy
    the files yourself. See `walkFileTree()`.) |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| `move()` | `Path` | 通过重命名或复制移动文件或目录，可选择是否替换现有目标。通常使用重命名，但如果需要在文件存储或文件系统之间复制文件以移动文件，则必须进行复制。仅当简单重命名可能或目录为空时，才能使用此方法移动目录。如果目录移动需要跨文件存储或文件系统复制文件，则方法会抛出
    `IOException`。（在这种情况下，您必须自行复制文件。参见 `walkFileTree()`。） |'
- en: '| `newBufferedReader()`, `newBufferedWriter()` | `BufferedReader` or `BufferedWriter`
    | Open a file for reading via a `BufferedReader`, or create and open a file for
    writing via a `BufferedWriter`. In both cases, a character encoding is specified.
    |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| `newBufferedReader()`, `newBufferedWriter()` | `BufferedReader` 或 `BufferedWriter`
    | 通过 `BufferedReader` 打开文件进行读取，或通过 `BufferedWriter` 创建并打开文件进行写入。在两种情况下都要指定字符编码。
    |'
- en: '| `newByteChannel()` | `SeekableByteChannel` | Create a new file or open an
    existing file as a seekable byte channel. (See the full discussion of NIO later
    in this chapter.) Consider using `FileChannel``open()` as an alternative. |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| `newByteChannel()` | `SeekableByteChannel` | 创建一个新文件或打开一个现有文件作为可寻址的字节通道。（请参见本章后面有关
    NIO 的完整讨论。）考虑使用 `FileChannel.open()` 作为替代方案。 |'
- en: '| `newDirectoryStream()` | `DirectoryStream` | Return a `DirectoryStream` for
    iterating over a directory hierarchy. Optionally, supply a glob pattern or filter
    object to match files. |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| `newDirectoryStream()` | `DirectoryStream` | 返回用于遍历目录层次结构的 `DirectoryStream`。可选择提供
    glob 模式或过滤器对象以匹配文件。 |'
- en: '| `newInputStream()`, `newOutputStream()` | `InputStream` or `OutputStream`
    | Open a file for reading via an `InputStream`, or create and open a file for
    writing via an `OutputStream`. Optionally, specify file truncation for the output
    stream; if overwriting, the default is to truncate the existing file. |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| `newInputStream()`, `newOutputStream()` | `InputStream` 或 `OutputStream`
    | 通过 `InputStream` 打开文件进行读取，或通过 `OutputStream` 创建并打开文件进行写入。可选择指定输出流的文件截断；如果要覆盖写入，则默认为截断现有文件。
    |'
- en: '| `probeContentType()` | `String` | Return the MIME type of the file if it
    can be determined by installed `FileTypeDetector` services or `null` if unknown.
    |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| `probeContentType()` | `String` | 如果能够通过安装的 `FileTypeDetector` 服务确定文件的 MIME
    类型，则返回该类型；否则返回 `null`。 |'
- en: '| `readAllBytes()`, `readAllLines()` | byte[] or `List`<`String`> | Read all
    data from the file as a byte [] or all characters as a list of strings using a
    specified character encoding. |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| `readAllBytes()`, `readAllLines()` | byte[] 或 `List<String>` | 使用指定的字符编码从文件中读取所有数据为字节数组或所有字符作为字符串列表。
    |'
- en: '| `size()` | long | Get the size, in bytes, of the file at the specified path.
    |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| `size()` | long | 获取指定路径文件的字节大小。 |'
- en: '| `walkFileTree()` | `Path` | Apply a `FileVisitor` to the specified directory
    tree, optionally specifying whether to follow links and a maximum depth of traversal.
    |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| `walkFileTree()` | `Path` | 将 `FileVisitor` 应用于指定的目录树，可选择是否跟随链接以及遍历的最大深度。
    |'
- en: '| `write()` | `Path` | Write an array of bytes or a collection of strings (with
    a specified character encoding) to the file at the specified path and close the
    file, optionally specifying append and truncation behavior. The default is to
    truncate and write the data. |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| `write()` | `Path` | 将字节数组或字符串集合（使用指定的字符编码）写入到指定路径的文件中，并关闭文件，可选择追加和截断行为。默认情况下是截断并写入数据。
    |'
- en: With these methods, we can fetch input or output streams, or buffered readers
    and writers, to a given file. We can also create paths as files and directories,
    and iterate through file hierarchies. We’ll discuss directory operations in the
    next section.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些方法，我们可以获取给定文件的输入或输出流，或者使用缓冲读写器和写入器。我们还可以将路径创建为文件和目录，并遍历文件层次结构。我们将在下一节讨论目录操作。
- en: 'As a reminder, the `resolve()` and `resolveSibling()` methods of `Path` are
    useful for constructing targets for the `copy()` and `move()` operations:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，`Path`的`resolve()`和`resolveSibling()`方法对于构建`copy()`和`move()`操作的目标非常有用：
- en: '[PRE36]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'For quickly reading and writing the contents of files without streaming, we
    can use the various `readAll…​` and `write` methods that move byte arrays or strings
    in and out of files in a single operation:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 为了快速读取和写入文件内容而不使用流，我们可以使用各种`readAll…​`和`write`方法，在单个操作中移动字节数组或字符串进出文件：
- en: '[PRE37]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: These are convenient for files that easily fit into memory.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对于容易适应内存的文件非常方便。
- en: The NIO Package
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NIO 包
- en: Let’s return to the `java.nio` package and round out our discussion of core
    Java I/O. One aspect of NIO is simply to update and enhance features of the classic
    `java.io` package. Much of the general NIO functionality does indeed overlap with
    existing APIs. However, NIO was first introduced to address specific issues of
    scalability for large systems, especially in networked applications. The following
    sections outline the basic elements of NIO.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到`java.nio`包，完善我们关于核心 Java I/O 的讨论。NIO 的一个方面就是简单地更新和增强经典的`java.io`包的功能。实际上，许多通用的
    NIO 功能确实与现有的 API 重叠。然而，NIO 首先引入是为了解决大系统的可伸缩性问题，特别是在网络应用中。接下来的几节概述了 NIO 的基本要素。
- en: Asynchronous I/O
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步 I/O
- en: Most of the need for the NIO package was driven by the desire to add *nonblocking*
    and *selectable* I/O to Java. Prior to NIO, most read and write operations in
    Java were bound to threads and were forced to block for unpredictable amounts
    of time. Although certain APIs, such as Sockets (which we’ll see in [“Sockets”](ch13.html#learnjava6-CHP-13-SECT-5)),
    provided specific means to limit how long an I/O call could take, this was a workaround
    to compensate for the lack of a more general mechanism. In many languages, even
    those without threading, I/O could still be done efficiently by setting I/O streams
    to a nonblocking mode and testing them for their readiness to send or receive
    data. In a nonblocking mode, a read or write does only as much work as can be
    done immediately—filling or emptying a buffer and then returning. Combined with
    the ability to test for readiness, this allows a single-threaded application to
    continuously service many channels efficiently. The main thread “selects” a channel
    that is ready, works with it until it blocks, and then moves on to another. On
    a single-processor system, this is fundamentally equivalent to using multiple
    threads.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数对 NIO 包的需求驱动力来自于希望在 Java 中添加*非阻塞*和*可选择*的 I/O。在 NIO 出现之前，Java 中的大多数读写操作都绑定到线程，并被迫阻塞不确定的时间。尽管某些
    API（如套接字，我们将在[“套接字”](ch13.html#learnjava6-CHP-13-SECT-5)中看到）提供了特定的方法来限制 I/O 调用的持续时间，但这只是一种弥补缺乏更一般机制的权宜之计。在许多语言中，即使没有线程，也可以通过将
    I/O 流设置为非阻塞模式并测试它们是否准备好发送或接收数据来高效地进行 I/O。在非阻塞模式下，读取或写入只完成可以立即执行的工作——填充或清空缓冲区然后返回。结合测试准备就绪的能力，这使得单线程应用程序可以高效地连续服务许多通道。主线程“选择”一个准备好的通道，与之协作直到它阻塞，然后转移到另一个通道。在单处理器系统上，这与使用多线程基本上是等效的。
- en: In addition to nonblocking and selectable I/O, the NIO package enables closing
    and interrupting I/O operations asynchronously. As discussed in [Chapter 9](ch09.html#learnjava6-CHP-9),
    prior to NIO there was no reliable way to stop or wake up a thread blocked in
    an I/O operation. With NIO, threads blocked in I/O operations always wake up when
    interrupted or when another thread closes the channel. Additionally, if you interrupt
    a thread while it is blocked in an NIO operation, its channel is automatically
    closed. (Closing the channel because the thread is interrupted might seem too
    strong, but usually it’s the right thing to do. Leaving it open could result in
    unexpected behavior or subject the channel to unwanted manipulation.)
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 除了非阻塞和可选择的 I/O 外，NIO 包还能够异步关闭和中断 I/O 操作。正如在[第9章](ch09.html#learnjava6-CHP-9)讨论的那样，在
    NIO 出现之前，没有可靠的方法来停止或唤醒在 I/O 操作中阻塞的线程。使用 NIO 后，被阻塞在 I/O 操作中的线程总是在被中断或另一个线程关闭通道时唤醒。此外，如果在线程阻塞在
    NIO 操作时中断该线程，其通道将自动关闭。（因为线程中断而关闭通道可能看起来过于严格，但通常这样做是正确的。保持通道打开可能导致意外行为或使通道受到不必要的操纵。）
- en: Performance
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能
- en: Channel I/O is designed around the concept of buffers, which are a sophisticated
    form of array, tailored to communication tasks. The NIO package supports the concept
    of *direct buffers*—buffers that maintain their memory outside the Java VM in
    the host operating system. Because all real I/O operations ultimately have to
    work with the host OS by maintaining the buffer space there, using direct buffers
    can make many operations more efficient. Data moving between two external endpoints
    can be transferred without first copying it into Java and back out.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: I/O 通道设计围绕缓冲区的概念，这是一种专门用于通信任务的复杂数组形式。NIO 包支持*直接缓冲区*的概念 —— 这些缓冲区在主机操作系统中维护它们的内存而不是在
    Java 虚拟机内部。因为所有真实的 I/O 操作最终都必须通过在主机操作系统中维护缓冲区空间来工作，使用直接缓冲区可以使许多操作更有效率。在两个外部端点之间传输的数据可以在不先复制到
    Java 中再返回的情况下进行转移。
- en: Mapped and Locked Files
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 映射和锁定文件
- en: 'NIO provides two general-purpose file-related features not found in `java.io`:
    memory-mapped files and file locking. A *memory-mapped* file behaves as if all
    of its content is in an array in memory rather than on a disk. Memory-mapped files
    are beyond the scope of this chapter, but if you work with lots of data and occasionally
    need really fast read/write access, look up the [`MappedByteBuffer` documentation](https://oreil.ly/yNLMn)
    online.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: NIO 提供了两个在`java.io`中找不到的通用文件相关功能：内存映射文件和文件锁定。*内存映射*文件表现得好像它的所有内容都在内存中的数组中而不是在磁盘上。内存映射文件超出了本章的范围，但如果你处理大量数据并且偶尔需要非常快的读/写访问，请在线查阅[`MappedByteBuffer`文档](https://oreil.ly/yNLMn)。
- en: File locking supports both shared and exclusive locks on regions of files—useful
    for concurrent access by multiple applications. We’ll look at file locking in
    [“File locking”](#learnjava6-CHP-10-SECT-3.7.2).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 文件锁支持文件区域上的共享和排他锁 —— 对于多个应用程序的并发访问非常有用。我们将在[“文件锁定”](#learnjava6-CHP-10-SECT-3.7.2)中讨论文件锁定。
- en: Channels
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通道
- en: 'While `java.io` deals with streams, `java.nio` works with channels. A *channel*
    is an endpoint for communication. Although in practice channels are similar to
    streams, the underlying notion of a channel is simultaneously more abstract and
    more primitive. Whereas streams in `java.io` are defined in terms of input or
    output with methods to read and write bytes, the basic channel interface says
    nothing about how communications happen. It simply has the notion of being open
    or closed, supported via the methods `isOpen()` and `close()`. Implementations
    of channels for files, network sockets, or arbitrary devices then add their own
    methods for operations, such as reading, writing, or transferring data. NIO provides
    the following channels:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`java.io`处理流，`java.nio`处理通道。*通道*是通信的端点。虽然实际上通道与流类似，但通道的基本概念同时更抽象和更原始。`java.io`中的流根据读取或写入字节的方法定义，而基本通道接口并不涉及通信的方式。它只是具有打开或关闭的概念，通过`isOpen()`和`close()`方法支持。然后为文件、网络套接字或任意设备的通道实现添加自己的操作方法，如读取、写入或传输数据。NIO
    提供以下通道：
- en: '`FileChannel`'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileChannel`'
- en: '`Pipe.SinkChannel`, `Pipe.SourceChannel`'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pipe.SinkChannel`, `Pipe.SourceChannel`'
- en: '`SocketChannel`, `ServerSocketChannel`, `DatagramChannel`'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SocketChannel`, `ServerSocketChannel`, `DatagramChannel`'
- en: 'We’ll cover `FileChannel` and its asynchronous cousin, `AsynchronousFileChannel`,
    in [“FileChannel”](#learnjava6-CHP-10-SECT-3.7). (The asynchronous version essentially
    buffers all of its operations through a thread pool and reports results back through
    an asynchronous API.) The `Pipe` channels are simply the channel equivalents of
    the `java.io Pipe` facilities. The socket and datagram channels play in Java’s
    networking world, which we’ll look at in [Chapter 13](ch13.html#learnjava6-CHP-13).
    The network-related channels have asynchronous versions as well: `AsynchronousSocketChannel`,
    `AsynchronousServerSocketChannel`, and `AsynchronousDatagramChannel`.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[“文件通道”](#learnjava6-CHP-10-SECT-3.7)中涵盖`FileChannel`及其异步姊妹`AsynchronousFileChannel`。（异步版本通过线程池缓冲其所有操作，并通过异步
    API 报告结果。）`Pipe`通道只是`java.io Pipe`工具的通道等价物。套接字和数据报通道参与 Java 的网络世界，我们将在[第13章](ch13.html#learnjava6-CHP-13)中进行讨论。与网络相关的通道也有异步版本：`AsynchronousSocketChannel`,
    `AsynchronousServerSocketChannel` 和 `AsynchronousDatagramChannel`。
- en: All these basic channels implement the `ByteChannel` interface, designed for
    channels that have read and write methods like I/O streams. `ByteChannel`s, however,
    read and write `ByteBuffer`s, as opposed to plain byte arrays.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些基本通道都实现了`ByteChannel`接口，该接口设计用于具有读取和写入方法（如 I/O 流）的通道。然而，`ByteChannel`读取和写入`ByteBuffer`，而不是简单的字节数组。
- en: In addition to these channel implementations, you can bridge channels with `java.io`
    I/O streams and readers and writers for interoperability. However, if you mix
    these features, you may not get the full benefits and performance NIO offers.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些通道实现外，您还可以使用`java.io` I/O流和读写器与通道进行桥接，以实现互操作性。然而，如果混合使用这些功能，您可能无法获得NIO提供的全部好处和性能。
- en: Buffers
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓冲区
- en: 'Most of the utilities of the `java.io` and `java.net` packages operate on byte
    arrays. The corresponding tools of the NIO package are built around `ByteBuffer`s
    (with a character-based buffer, `CharBuffer`, for text). Byte arrays are simple,
    so why are buffers necessary? They serve several purposes:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数`java.io`和`java.net`包的实用程序操作的是字节数组。NIO包的对应工具是围绕`ByteBuffer`（对于文本，还有一个基于字符的缓冲区`CharBuffer`）构建的。字节数组很简单，为什么需要缓冲区？它们具有几个目的：
- en: They formalize the usage patterns for buffered data, provide for things like
    read-only buffers, and keep track of read/write positions and limits within a
    large buffer space. They also provide a mark/reset facility like that of `java.io​.BufferedInputStream`.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们规范了缓冲数据的使用模式，提供了诸如只读缓冲区之类的功能，并跟踪大缓冲区空间内的读/写位置和限制。它们还提供了类似于`java.io​.BufferedInputStream`的标记/重置功能。
- en: They provide additional APIs for working with raw data representing primitive
    types. You can create buffers that “view” your byte data as a series of larger
    primitives, such as `short`s, `int`s, or `float`s. The most general type of data
    buffer, `ByteBuffer`, includes methods that let you read and write all primitive
    types just like `DataInputStream` and `DataOutputStream` do for streams.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们提供了用于处理表示原始类型的原始数据的附加API。您可以创建“查看”您的字节数据为一系列较大原始类型（如`short`，`int`或`float`）的缓冲区。最通用的数据缓冲区类型`ByteBuffer`包括让您像`DataInputStream`和`DataOutputStream`对流所做的那样读取和写入所有原始类型的方法。
- en: They abstract the underlying storage of the data, allowing Java to optimize
    throughput. Specifically, buffers may be allocated as direct buffers that use
    native buffers of the host operating system instead of arrays in Java’s memory.
    The NIO `Channel` facilities that work with buffers can recognize direct buffers
    automatically and try to optimize their interactions with them. For example, a
    read from a file channel into a Java byte array normally requires Java to copy
    the data for the read from the host operating system into Java’s memory. With
    a direct buffer, the data can remain in the host operating system, outside Java’s
    normal memory space, until and unless it is needed.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们抽象了数据的底层存储，允许Java优化吞吐量。具体而言，缓冲区可以分配为直接缓冲区，这些直接缓冲区使用主机操作系统的本机缓冲区，而不是Java内存中的数组。与缓冲区一起工作的NIO`Channel`工具可以自动识别直接缓冲区，并尝试优化与它们的交互。例如，从文件通道读取到Java字节数组通常需要Java将数据复制为从主机操作系统到Java内存的读取。使用直接缓冲区，数据可以保留在主机操作系统中，超出Java正常内存空间，直到需要为止。
- en: Buffer operations
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缓冲区操作
- en: 'The base `java.nio.Buffer` class is something like an array with state. It
    does not specify what type of elements it holds (that is for subtypes to decide),
    but it does define functionality that is common to all data buffers. A `Buffer`
    has a fixed size, called its *capacity*. Although all the standard `Buffer`s provide
    “random access” to their contents, a `Buffer` generally expects to be read and
    written sequentially, so `Buffer`s maintain the notion of a *position* where the
    next element is read or written. In addition to position, a `Buffer` can maintain
    two other pieces of state information: a *limit*, which typically denotes the
    available data in read mode and the capacity of the file in write mode, and a
    *mark*, which can be used to remember an earlier position for future recall.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 基本`java.nio.Buffer`类有点像具有状态的数组。它不指定它保存的元素类型（由子类型决定），但它确实定义了所有数据缓冲区通用的功能。缓冲区具有固定大小，称为*容量*。尽管所有标准缓冲区都提供对其内容的“随机访问”，但缓冲区通常期望按顺序读取和写入，因此缓冲区维护下一个元素被读取或写入的*位置*的概念。除了位置，缓冲区还可以维护另外两个状态信息：*限制*，在读模式下通常表示可用数据，在写模式下表示文件的容量；以及一个*标记*，可用于记住未来回忆的早期位置。
- en: Implementations of `Buffer` add specific, typed get and put methods that read
    and write the buffer contents. For example, `ByteBuffer` is a buffer of bytes
    and it has `get()` and `put()` methods that read and write bytes and arrays of
    bytes (along with many other useful methods we’ll discuss later). Getting from
    and putting to the `Buffer` changes the position marker, so the `Buffer` keeps
    track of its contents somewhat like a stream. Attempting to read or write past
    the limit marker generates a `BufferUnderflowException` or `BufferOverflowException`,
    respectively.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`Buffer`的实现添加了特定的类型化获取和放置方法，用于读取和写入缓冲区内容。例如，`ByteBuffer`是字节的缓冲区，它有`get()`和`put()`方法用于读取和写入字节及字节数组（以及许多其他有用的方法，稍后我们将讨论）。从`Buffer`获取或放置数据会改变位置标记，因此`Buffer`类似于流一样跟踪其内容。试图读取或写入超出限制标记的数据会生成`BufferUnderflowException`或`BufferOverflowException`异常。'
- en: 'The mark, position, limit, and capacity values always obey the following formula:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 标记、位置、限制和容量的值始终遵守以下公式：
- en: '[PRE38]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The position for reading and writing the `Buffer` is always between the mark,
    which serves as a lower bound, and the limit, which serves as an upper bound.
    The capacity represents the physical extent of the buffer space.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`Buffer`的读写位置始终在标记（mark）和限制（limit）之间，其中标记作为下界，限制作为上界。容量表示缓冲区空间的物理范围。'
- en: You can set the position and limit markers explicitly with the `position()`
    and `limit()` methods. Several convenience methods are provided for common usage
    patterns. The `reset()` method sets the position back to the mark. If no mark
    has been set, an `InvalidMarkException` is thrown. The `clear()` method resets
    the position to `0` and makes the limit the capacity, readying the buffer for
    new data (the mark is discarded). Note that the `clear()` method does not actually
    do anything to the data in the buffer; it simply changes the position markers.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`position()`和`limit()`方法显式设置位置和限制标记。提供了几个便利方法用于常见的使用模式。`reset()`方法将位置重置为标记。如果未设置标记，则会抛出`InvalidMarkException`异常。`clear()`方法将位置重置为`0`，并将限制设置为容量，准备好接收新数据（标记被丢弃）。请注意，`clear()`方法实际上并不对缓冲区中的数据执行任何操作；它只是改变位置标记。
- en: 'The `flip()` method is used for the common pattern of writing data into the
    buffer and then reading it back out. `flip` makes the current position the limit
    and then resets the current position to `0` (any mark is thrown away), which saves
    having to keep track of how much data was read. Another method, `rewind()`, simply
    resets the position to `0`, leaving the limit alone. You might use it to write
    the same size of data again. Here is a snippet of code that uses these methods
    to read data from a channel and write it to two channels:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`flip()`方法用于常见模式，将数据写入缓冲区，然后再读取出来。`flip`方法将当前位置设置为限制，并将当前位置重置为`0`（任何标记都被丢弃），这样就不需要跟踪读取了多少数据。另一个方法`rewind()`简单地将位置重置为`0`，但保持限制不变。您可以使用它再次写入相同大小的数据。以下是使用这些方法从一个通道读取数据并写入两个通道的代码片段：'
- en: '[PRE39]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This might be confusing the first time you look at it because here, the read
    from the `Channel` is actually a write to the `Buffer` and vice versa. Because
    this example writes all the available data up to the limit, either `flip()` or
    `rewind()` have the same effect in this case.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次看可能会让人困惑，因为在这里，从`Channel`读取实际上是向`Buffer`写入，反之亦然。因为此示例将所有可用数据写入限制，所以在这种情况下，`flip()`或`rewind()`具有相同的效果。
- en: Buffer types
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缓冲区类型
- en: 'The various buffer implementations add get and put methods for reading and
    writing specific data types. Each of the Java primitive types has an associated
    buffer type: `ByteBuffer`, `CharBuffer`, `ShortBuffer`, `IntBuffer`, `LongBuffer`,
    `FloatBuffer`, and `DoubleBuffer`. Each provides get and put methods for reading
    and writing its type and arrays of its type. Of these, `ByteBuffer` is the most
    flexible. Because it has the “finest grain” of all the buffers, it has been given
    a full complement of get and put methods for reading and writing all the other
    data types as well as `byte`. Here are some `ByteBuffer` methods:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 各种缓冲区实现添加了用于读写特定数据类型的获取和放置方法。每个Java原始类型都有一个关联的缓冲区类型：`ByteBuffer`、`CharBuffer`、`ShortBuffer`、`IntBuffer`、`LongBuffer`、`FloatBuffer`和`DoubleBuffer`。每个类型都提供了用于读取和写入其类型及其类型数组的获取和放置方法。其中，`ByteBuffer`是最灵活的，因为它具有所有缓冲区中最细粒度的"get"和"put"方法，用于读写除`byte`外的所有其他数据类型。以下是一些`ByteBuffer`的方法：
- en: '[PRE40]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'All the standard buffers also support random access. For each of the aforementioned
    methods of `ByteBuffer`, an additional form takes an index, for example:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 所有标准缓冲区也支持随机访问。对于`ByteBuffer`的上述每种方法，还有一个带索引的额外形式，例如：
- en: '[PRE41]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: But that’s not all! `ByteBuffer` can also provide “views” of itself as any of
    the coarse-grained types. For example, you can fetch a `ShortBuffer` view of a
    `ByteBuffer` with the `asShortBuffer()` method. The `ShortBuffer` view is *backed*
    by the `ByteBuffer`, which means that they work on the same data, and changes
    to either one affect the other. The view buffer’s extent starts at the `ByteBuffer`’s
    current position, and its capacity is a function of the remaining number of bytes,
    divided by the new type’s size. (For example, `short`s consume two bytes each,
    `float`s four, and `long`s and `double`s take eight.) View buffers are convenient
    for reading and writing large blocks of a contiguous type within a `ByteBuffer`.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 但这还不是全部！`ByteBuffer`还可以提供它自己的“视图”，作为任何粗粒度类型。例如，你可以用`asShortBuffer()`方法从`ByteBuffer`获取一个`ShortBuffer`视图。`ShortBuffer`视图是由`ByteBuffer`支持的，这意味着它们在相同的数据上工作，对其中一个的更改会影响另一个。视图缓冲区的范围从`ByteBuffer`的当前位置开始，其容量是剩余字节数除以新类型的大小。
    （例如，每个`short`占两个字节，每个`float`占四个字节，每个`long`和`double`占八个字节。）视图缓冲区对于在`ByteBuffer`内读取和写入大块连续类型数据非常方便。
- en: '`CharBuffer`s are interesting as well, primarily because of their integration
    with `String`s. Both `CharBuffer`s and `String`s implement the `java.lang.CharSequence`
    interface. This is the interface that provides the standard `charAt()` and `length()`
    methods. Many other parts of Java (such as the `java.util.regex` package) allow
    you to use a `CharBuffer` or a `String` interchangeably. In this case, the `CharBuffer`
    acts like a modifiable `String` with user-configurable, logical start and end
    positions.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`CharBuffer`也很有趣，主要是因为它们与`String`的集成。`CharBuffer`和`String`都实现了`java.lang.CharSequence`接口。这个接口提供了标准的`charAt()`和`length()`方法。Java的许多其他部分（比如`java.util.regex`包）允许你可以互换地使用`CharBuffer`或`String`。在这种情况下，`CharBuffer`就像一个可修改的`String`，具有用户可配置的逻辑起始和结束位置。'
- en: Byte order
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字节顺序
- en: 'Because we’re talking about reading and writing types larger than a byte, the
    question arises: in what order do the bytes of multibyte values (like `short`s
    and `int`s) get written? There are two camps in this world: *big-endian* and *little-endian*.^([5](ch10.html#id2150))
    Big-endian means that the most significant bytes come first; little-endian is
    the reverse. If you’re writing binary data for consumption by some native application,
    this is important. Intel-compatible computers use little-endian, and many workstations
    that run Unix use big-endian. The `ByteOrder` class encapsulates the choice. You
    can specify the byte order to use with the `ByteBuffer order()` method, using
    the identifiers `ByteOrder.BIG_ENDIAN` and `ByteOrder.LITTLE_ENDIAN`, like so:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们正在讨论大于一个字节的类型的读写，所以问题就来了：多字节值（比如`short`和`int`）的字节写入顺序是什么？在这个世界上有两个派别：*大端序*和*小端序*。[^5]
    大端序意味着最重要的字节首先出现；小端序则相反。如果你要写入某些本地应用程序消费的二进制数据，这一点非常重要。兼容Intel的计算机使用小端序，许多运行Unix的工作站使用大端序。`ByteOrder`类封装了这个选择。你可以通过`ByteBuffer
    order()`方法指定要使用的字节顺序，使用标识符`ByteOrder.BIG_ENDIAN`和`ByteOrder.LITTLE_ENDIAN`，例如：
- en: '[PRE42]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You can retrieve the native ordering for your platform using the static `ByteOrder.nativeOrder()`
    method. We know you’re curious:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用静态方法`ByteOrder.nativeOrder()`获取你的平台的本地字节顺序。我们知道你很好奇：
- en: '[PRE43]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We ran this on a Linux desktop with an Intel chip. Give it a try on your own
    system!
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在一台装有英特尔芯片的Linux桌面上运行了这个程序。你也可以在自己的系统上试试看！
- en: Allocating buffers
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分配缓冲区
- en: 'You can create a buffer either by allocating it explicitly using `allocate()`
    or by wrapping an existing plain Java array type. Each buffer type has a static
    `allocate()` method that takes a capacity (size), and a `wrap()` method that takes
    an existing array:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过显式分配使用`allocate()`或者通过包装现有的普通Java数组类型来创建缓冲区。每种缓冲区类型都有一个静态的`allocate()`方法，接受一个容量（大小），以及一个`wrap()`方法，接受一个现有的数组：
- en: '[PRE44]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'A direct buffer is allocated in the same way, with the `allocateDirect()` method:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 直接缓冲区的分配方式与`allocateDirect()`方法相同：
- en: '[PRE45]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As we described earlier, direct buffers can use operating system memory structures
    that are optimized for use with some kinds of I/O operations. The trade-off is
    that allocating a direct buffer is a little slower and heavier-weight operation
    than a plain buffer, so you should try to use them for longer-term buffers.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前描述的那样，直接缓冲区可以使用操作系统的内存结构，这些结构针对某些类型的 I/O 操作进行了优化。这样做的权衡是，分配直接缓冲区比普通缓冲区的操作稍慢且更重量级，因此您应该尽量将它们用于长期缓冲区。
- en: Character Encoders and Decoders
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符编码器和解码器
- en: Character encoders and decoders turn characters into raw bytes and vice versa,
    mapping from the Unicode standard to particular encoding schemes. Encoders and
    decoders have long existed in Java for use by `Reader` and `Writer` streams and
    in the methods of the `String` class that work with byte arrays. However, early
    on there was no API for working with encoding explicitly; you simply referred
    to encoders and decoders wherever necessary by name as a `String`. The `java.nio.charset`
    package formalized the idea of a Unicode character set encoding with the `Charset`
    class.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 字符编码器和解码器将字符转换为原始字节，反之亦然，将 Unicode 标准映射到特定的编码方案。在 Java 中，编码器和解码器早已存在，供 `Reader`
    和 `Writer` 流使用，并在 `String` 类的处理字节数组的方法中使用。然而，早期并没有用于显式处理编码的 API；您只需按名称将编码器和解码器引用到需要的地方作为
    `String`。`java.nio.charset` 包使用 `Charset` 类正式化了 Unicode 字符集编码的概念。
- en: 'The `Charset` class is a factory for `Charset` instances, which know how to
    encode character buffers to byte buffers and decode byte buffers to character
    buffers. You can look up a character set by name with the static `Charset.forName()`
    method and use it in conversions:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`Charset` 类是一个 `Charset` 实例的工厂，它们知道如何将字符缓冲区编码为字节缓冲区，并解码字节缓冲区为字符缓冲区。您可以使用静态
    `Charset.forName()` 方法按名称查找字符集并在转换中使用它：'
- en: '[PRE46]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: You can also test to see if an encoding is available with the static `Charset.isSupported()`
    method.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用静态 `Charset.isSupported()` 方法测试编码是否可用。
- en: 'The following character sets are guaranteed to be supplied:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 以下字符集是保证提供的：
- en: US-ASCII
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: US-ASCII
- en: ISO-8859-1
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ISO-8859-1
- en: UTF-8
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UTF-8
- en: UTF-16BE (big-endian)
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UTF-16BE（大端序）
- en: UTF-16LE (little-endian)
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UTF-16LE（小端序）
- en: UTF-16
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UTF-16
- en: 'You can list all the encoders available on your platform using the static `availableCharsets()`
    method:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用静态 `availableCharsets()` 方法列出平台上提供的所有编码器：
- en: '[PRE47]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The result of `availableCharsets()` is a map, because character sets may have
    “aliases” and appear under more than one name.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '`availableCharsets()` 的结果是一个映射，因为字符集可能具有“别名”并且可能出现在多个名称下。'
- en: In addition to the buffer-oriented classes of the `java.nio` package, the `InputStreamReader`
    and `OutputStreamWriter` bridge classes of the `java.io` package work with `Charset`
    as well. You can specify the encoding as a `Charset` object or by name.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `java.nio` 包的面向缓冲区的类之外，`java.io` 包的 `InputStreamReader` 和 `OutputStreamWriter`
    桥接类也与 `Charset` 一起工作。您可以指定编码作为 `Charset` 对象或名称。
- en: CharsetEncoder and CharsetDecoder
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CharsetEncoder 和 CharsetDecoder
- en: You can get more control over the encoding and decoding process by creating
    an instance of `CharsetEncoder` or `CharsetDecoder` (a codec) with the `Charset
    newEncoder()` and `newDecoder()` methods. In the previous snippet, we assumed
    that all the data was available in a single buffer. More often, however, we might
    have to process data as it arrives in chunks. The encoder/decoder API allows for
    this by providing more general `encode()` and `decode()` methods that take a flag
    specifying whether more data is expected. The codec needs to know this because
    it might have been left hanging in the middle of a multibyte character conversion
    when the data ran out. If it knows that more data is coming, it does not throw
    an error on this incomplete conversion.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `Charset newEncoder()` 和 `newDecoder()` 方法创建 `CharsetEncoder` 或 `CharsetDecoder`（一个编解码器），您可以更加控制编码和解码过程。在前面的片段中，我们假设所有数据都在单个缓冲区中可用。然而，更常见的情况是我们可能需要按块处理数据。编码器/解码器
    API 通过提供更一般的 `encode()` 和 `decode()` 方法来允许这样做，这些方法接受一个标志，指定是否期望更多数据。编解码器需要知道这一点，因为在数据耗尽时可能会中断多字节字符转换。如果它知道还有更多数据要到来，它不会因为这种不完整的转换而抛出错误。
- en: 'In the following snippet, we use a decoder to read from a `ByteBuffer bbuff`
    and accumulate character data into a `CharBuffer cbuff`:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下片段中，我们使用解码器从 `ByteBuffer bbuff` 中读取并将字符数据累积到 `CharBuffer cbuff` 中：
- en: '[PRE48]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Here, we look for the end of input condition on the `in` channel to set the
    flag `done`. Note that we take advantage of the `flip()` method on `ByteBuffer`
    to set the limit to the amount of data read and reset the position, setting us
    up for the decode operation in one step. In case of problems, both `encode()`
    and `decode()` return a result object, `CoderResult`, that can determine the progress
    of encoding. The methods `isError()`, `isUnderflow()`, and `isOverflow()` on the
    `CoderResult` specify why encoding stopped: for an error, a lack of bytes on the
    input buffer, or a full output buffer, respectively.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在`in`通道上寻找输入结束条件来设置`done`标志。注意，我们利用`ByteBuffer`的`flip()`方法来设置数据读取的限制并重置位置，以便一步完成解码操作。在遇到问题时，`encode()`和`decode()`方法都会返回一个结果对象`CoderResult`，它可以确定编码的进度。`CoderResult`的`isError()`、`isUnderflow()`和`isOverflow()`方法分别指定编码停止的原因：错误、输入缓冲区中字节不足或输出缓冲区已满。
- en: FileChannel
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FileChannel
- en: Now that we’ve covered the basics of channels and buffers, it’s time to look
    at a real channel type. The `FileChannel` is the NIO equivalent of the `java.io.RandomAccessFile`,
    but it provides several enhanced features in addition to some performance optimizations.
    In particular, you can use a `FileChannel` in place of a plain `java.io` file
    stream if you wish to use file locking, memory-mapped file access, or highly optimized
    data transfer between files or between file and network channels. These are all
    fairly advanced use cases, but if you do backend work or handle large quantities
    of data, they will definitely come in handy.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了通道和缓冲区的基础知识，是时候看一看真正的通道类型了。`FileChannel`是NIO中`java.io.RandomAccessFile`的等效物，但它除了性能优化外，还提供了几个增强功能。特别是，如果需要使用文件锁定、内存映射文件访问或高度优化的文件和网络通道之间的数据传输，可以使用`FileChannel`代替简单的`java.io`文件流。这些都是相当高级的用例，但如果你从事后端工作或处理大量数据，它们肯定会派上用场。
- en: 'You can create a `FileChannel` for a `Path` using the static `FileChannel.open()`
    method:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 使用静态的`FileChannel.open()`方法可以为`Path`创建一个`FileChannel`：
- en: '[PRE49]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: By default, `open()` creates a read-only channel for the file. We can open a
    channel for writing or appending and control other, more advanced features such
    as atomic create and data syncing by passing additional options, as shown in the
    second part of the previous example. [Table 10-3](#learnjava6-CHP-10-TABLE-3)
    summarizes these options.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`open()`创建一个文件的只读通道。我们可以通过传递额外的选项来打开写入或追加通道，并控制其他更高级的特性，如前面示例的第二部分所示。[表格 10-3](#learnjava6-CHP-10-TABLE-3)总结了这些选项。
- en: Table 10-3\. `java.nio.file.StandardOpenOption`
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 10-3\. `java.nio.file.StandardOpenOption`
- en: '| Option | Description |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| Option | Description |'
- en: '| --- | --- |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `APPEND` | Open the file for writing; all writes are positioned at the end
    of the file. |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| `APPEND` | 打开文件以进行写入；所有写操作定位于文件末尾。 |'
- en: '| `CREATE` | Use with `WRITE` to open the file and create it if needed. |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| `CREATE` | 与`WRITE`一起使用，打开文件并在需要时创建它。 |'
- en: '| `CREATE_NEW` | Use with `WRITE` to create a file atomically; failing if the
    file already exists. |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| `CREATE_NEW` | 与`WRITE`一起使用，原子性地创建文件；如果文件已存在，则操作失败。 |'
- en: '| `DELETE_ON_CLOSE` | Attempt to delete the file when it is closed or, if open,
    when the VM exits. |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE_ON_CLOSE` | 尝试在关闭文件时或在虚拟机退出时删除文件（如果文件已打开）。 |'
- en: '| `READ`, `WRITE` | Open the file for read-only or write-only (default is read-only).
    Use both for read-write. |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| `READ`, `WRITE` | 以只读或只写（默认为只读）模式打开文件。使用两者可进行读写操作。 |'
- en: '| `SPARSE` | Use when creating a new file; requests the file be sparse. On
    filesystems where this is supported, a sparse file handles very large, mostly
    empty files without allocating as much real storage for empty portions. |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| `SPARSE` | 在创建新文件时使用；请求文件是稀疏的。在支持的文件系统上，稀疏文件可以处理非常大且大部分为空的文件，而不会为空部分分配太多实际存储空间。
    |'
- en: '| `SYNC`, `DSYNC` | Wherever possible, guarantee that write operations block
    until all data is written to storage. `SYNC` does this for all file changes including
    data and metadata (attributes), whereas `DSYNC` adds this requirement only for
    the data content of the file. |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| `SYNC`, `DSYNC` | 在可能的情况下，保证写操作阻塞，直到所有数据写入存储介质。`SYNC`会对所有文件更改（包括数据和元数据（属性））执行此操作，而`DSYNC`仅对文件的数据内容添加此要求。
    |'
- en: '| `TRUNCATE_EXISTING` | Use `WRITE` on an existing file; set the file length
    to zero upon opening it. |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| `TRUNCATE_EXISTING` | 对现有文件使用`WRITE`；在打开文件时将文件长度设为零。 |'
- en: 'A `FileChannel` can also be constructed from a classic `FileInputStream`, `FileOutputStream`,
    or `RandomAccessFile`:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileChannel`也可以通过经典的`FileInputStream`、`FileOutputStream`或`RandomAccessFile`构造：'
- en: '[PRE50]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '`FileChannel`s created from these file input and output streams are read-only
    or write-only, respectively. To get a read/write `FileChannel`, you must construct
    a `RandomAccessFile` with read/write options, as in the previous example.'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些文件输入流和输出流创建的`FileChannel`分别是只读或只写的。要获取读/写`FileChannel`，必须像前面的示例一样使用读/写选项构造`RandomAccessFile`。
- en: 'Using a `FileChannel` is just like a `RandomAccessFile`, but it works with
    a `ByteBuffer` instead of byte arrays:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`FileChannel`就像使用`RandomAccessFile`一样，但它使用`ByteBuffer`而不是字节数组：
- en: '[PRE51]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'You can control how much data is read and written either by setting buffer
    position and limit markers or using another form of read/write that takes a buffer
    starting position and length. You can also read and write to a random position
    by supplying indexes with the read and write methods:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过设置缓冲区的位置和限制标记或使用另一种接受缓冲区起始位置和长度的读/写形式来控制读取和写入的数据量。您还可以通过提供索引与读写方法来随机读写到某个位置：
- en: '[PRE52]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In each case, the actual number of bytes read or written depends on several
    factors. The operation tries to read or write to the limit of the buffer, and
    the vast majority of the time, that is what happens with local file access. The
    operation is guaranteed to block only until at least one byte has been processed.
    Whatever happens, the number of bytes processed is returned and the buffer position
    is updated accordingly, preparing you to repeat the operation until it is complete,
    if needed. This is one of the conveniences of working with buffers; they can manage
    the count for you. Like standard streams, the channel `read()` method returns
    `-1` upon reaching the end of input.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，实际读取或写入的字节数取决于几个因素。该操作试图读取或写入缓冲区的限制，绝大多数情况下，这就是本地文件访问的情况。该操作仅保证阻塞，直到至少处理了一个字节。无论发生什么，返回处理的字节数并相应更新缓冲区位置，准备重复操作直到完成（如果需要）。这是使用缓冲区的便利之一；它们可以为您管理计数。与标准流一样，通道的`read()`方法在达到输入结束时返回`-1`。
- en: The size of the file is always available with the `size()` method. It can change
    if you write past the end of the file. Conversely, you can truncate the file to
    a specified length with the `truncate()` method.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`size()`方法始终可以获取文件的大小。如果您写入超出文件末尾，文件大小可能会更改。反之，您可以使用`truncate()`方法将文件截断为指定的长度。
- en: Concurrent access
  id: totrans-371
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 并发访问
- en: '`FileChannel`s are safe for use by multiple threads and guarantee a consistent
    view of that data across channels in the same VM. Unless you specify the `SYNC`
    or `DSYNC` options, however, channels do not guarantee how quickly writes are
    propagated to the storage mechanism. If you only intermittently need to be sure
    that data is safe before moving on, you can use the `force()` method to flush
    changes to disk. This method takes a Boolean argument indicating whether file
    metadata, including timestamp and permissions, must be included. Some systems
    keep track of reads on files as well as writes, so you can save a lot of updates
    if you set the flag to `false`, which indicates that you don’t care about syncing
    that metadata immediately.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileChannel`可安全地供多个线程使用，并保证在同一虚拟机中的通道之间对数据的一致视图。但是，除非指定了`SYNC`或`DSYNC`选项，否则通道不保证写入的传播速度。如果您只偶尔需要确保数据在继续之前是安全的，可以使用`force()`方法将更改刷新到磁盘。此方法接受一个布尔参数，指示是否必须包括文件元数据，包括时间戳和权限。某些系统跟踪文件的读取以及写入，因此，如果将标志设置为`false`，表示您不关心立即同步该元数据，则可以节省大量更新。'
- en: As with all `Channel`s, any thread may close a `FileChannel`. Once closed, all
    the channel’s read/write and position-related methods throw a `ClosedChannelException`.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有`Channel`一样，任何线程都可以关闭`FileChannel`。一旦关闭，所有通道的读/写和位置相关方法都会抛出`ClosedChannelException`。
- en: File locking
  id: totrans-374
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件锁定
- en: '`FileChannel`s support exclusive and shared locks on regions of files through
    the `lock()` method:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`lock()`方法，`FileChannel`支持对文件区域进行独占锁定和共享锁定。
- en: '[PRE53]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Locks may be either shared or exclusive. An *exclusive* lock prevents others
    from acquiring a lock of any kind on the specified file or file region. A *shared*
    lock allows others to acquire overlapping shared locks but not exclusive locks.
    These are useful as write and read locks, respectively. When you are writing,
    you don’t want others to be able to write until you’re done, but when reading,
    you need only to block others from writing, not from reading.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 锁可以是共享的或独占的。*独占* 锁可阻止其他人在指定文件或文件区域上获取任何类型的锁。*共享* 锁允许其他人获取重叠的共享锁，但不允许获取独占锁。这些分别用作写锁和读锁。在写入时，您不希望其他人能够写入直到您完成，但在读取时，您只需要阻止其他人写入，而不是阻止其他人读取。
- en: 'The `lock()` method with no arguments in the previous example attempts to acquire
    an exclusive lock for the whole file. The second form accepts starting and length
    parameters, as well as a flag indicating whether the lock should be shared (`true`)
    or exclusive (`false`). The `FileLock` object returned by the `lock()` method
    can be used to release the lock:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`lock()` 方法没有参数尝试获取整个文件的独占锁。第二种形式接受起始和长度参数，以及指示锁定是共享（`true`）还是独占（`false`）的标志。`lock()`
    方法返回的 `FileLock` 对象可用于释放锁定：
- en: '[PRE54]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Warning
  id: totrans-380
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: File locks are only guaranteed to be *cooperative*. They work when all threads
    honor them; they do not necessarily prevent a non-cooperating thread from reading
    or writing a locked file. In general, the only way to guarantee that locks are
    obeyed is for both parties to attempt to acquire the lock and proceed only if
    that attempt is successful.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 文件锁仅能保证是*协作*的。它们仅在所有线程都遵守它们时起作用；它们不一定能阻止非协作线程读取或写入已锁定的文件。一般而言，保证锁被遵守的唯一方法是双方尝试获取锁，并仅在尝试成功后继续。
- en: Also, shared locks are not implemented on some systems, in which case all requested
    locks are exclusive. You can test whether a lock is shared with the `isShared()`
    method.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，某些系统上未实现共享锁定，此时所有请求的锁都将是独占的。您可以使用 `isShared()` 方法测试锁是否为共享的。
- en: '`FileChannel` locks are held until the channel is closed or interrupted, so
    performing locks within a `try`-with-resources statement will help ensure that
    locks are released more robustly:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileChannel` 锁定持有直到通道关闭或中断，因此在 `try`-with-resources 语句中执行锁定将有助于更可靠地释放锁定：'
- en: '[PRE55]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: FileChannel Example
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FileChannel 示例
- en: Let’s see some concrete usage of our channels and buffers. We’ll create a small
    text file that includes a count of how many times it has been accessed by our
    program. Our program, then, will open the file, read the current count, increment
    that count, and then write (well, overwrite) the count back to the file. You can
    try out a complete version of the snippets below in the *AccessNIO.java* file
    in the *ch10/examples* folder.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些通道和缓冲区的具体用法。我们将创建一个小型文本文件，其中包含我们的程序访问该文件的次数计数。然后，我们将打开文件，读取当前计数，增加该计数，然后将计数重新写入（实际上是覆盖）文件。您可以在
    *ch10/examples* 文件夹中的 *AccessNIO.java* 文件中尝试下面片段的完整版本。
- en: Note
  id: totrans-387
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You could absolutely tackle this project using the standard I/O classes in `java.io`.
    The NIO suite is not meant to replace the old classes wholesale, but to add functionality
    that is missing in the standard classes without breaking any code that relies
    on those classes. If you find NIO a little complex or dense, feel free to ignore
    it until you need some of those missing features, like file locking or manipulating
    metadata.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 您完全可以使用 `java.io` 中的标准 I/O 类来处理此项目。NIO 套件并非旨在完全替换旧类，而是在不破坏依赖这些类的代码的情况下添加缺失的功能。如果您觉得
    NIO 有点复杂或密集，可以在需要使用文件锁定或操作元数据等缺失功能时再考虑使用。
- en: 'Our first task is to see if our access-counting file exists (*access.txt* in
    this example, but the name is arbitrary). If not, we need to create it (and set
    the internal access counter to 1). We can use a `Path` object with the `Files`
    static helper methods to get going:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个任务是查看我们的计数文件是否存在（本例中为 *access.txt*，但名称是任意的）。如果不存在，我们需要创建它（并将内部访问计数器设置为
    1）。我们可以使用 `Path` 对象和 `Files` 静态帮助方法来开始：
- en: '[PRE56]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If the file doesn’t exist yet, we can write out an initial message (“This file
    has been accessed 0 times.”) and then rewind to the beginning of the new file.
    This gives us the same baseline to work from as though the file had existed all
    along:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件尚不存在，我们可以写入一个初始消息（“此文件已访问 0 次。”），然后倒回到新文件的开头。这样我们就有了从一开始文件就存在的基准：
- en: '[PRE57]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'If the file does exist, we need to make sure we can read from and write to
    it. We can gather this information with the `accessChannel` object we created
    in the constructor. We could certainly add other tests and more verbose error
    messages, but these minimal checks are useful:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件已经存在，我们需要确保能够从中读取并向其中写入。我们可以通过构造函数中创建的 `accessChannel` 对象收集这些信息。当然，我们可以添加其他测试和更详细的错误消息，但这些最小的检查非常有用：
- en: '[PRE58]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now we come to our primary use case. The file exists and has some content.
    We have the appropriate permissions for everything we want to do. We’ll start
    by opening the file in a read/write mode and reading its contents into a string:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来到我们的主要用例。文件已经存在并且具有一些内容。我们拥有我们想做的一切适当的权限。我们将以读/写模式打开文件，并将其内容读入字符串中：
- en: '[PRE59]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We want the file to be human-readable on its own, so we won’t take advantage
    of `FileChannel`’s ability to read and write binary data. We can use our knowledge
    of how the single line of text is structured to parse our access count:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望文件本身是人类可读的，因此我们不会利用 `FileChannel` 读写二进制数据的能力。我们可以利用我们对单行文本结构的了解来解析我们的访问计数：
- en: '[PRE60]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Finally, we can reset our position and overwrite the previous line with our
    new, updated line. Notice that we also truncate our file to the end of the saved
    message. We gave ourselves extra room to accommodate a bigger number, but we don’t
    want excess space in the actual file:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以重置位置并用新的更新行覆盖前一行。请注意，我们还截断文件以保存消息的末尾。我们留出了额外的空间以容纳更大的数字，但我们不希望实际文件中存在多余的空间：
- en: '[PRE61]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Try compiling and running this example a few times. Does the count go up as
    expected? What happens if you open the file in another program like a text editor?
    Unfortunately, Java NIO only *feels* like magic. Accessing the file using any
    other program will not necessarily change its contents according to the rules
    of our little example.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试多次编译和运行此示例。计数是否按预期增加？如果您在另一个程序（如文本编辑器）中打开文件会发生什么？不幸的是，Java NIO 只是 *感觉* 像魔术。使用任何其他程序访问文件不一定会按照我们小例子的规则更改其内容。
- en: wrap() Up
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: wrap() 完成
- en: Almost any application bound for distribution will need to handle file I/O.
    Java has robust support for working efficiently with local files, including access
    to metadata for both files and directories. Java’s commitment to a broad compatibility
    shows up in the range of character encodings available when working with text
    files. Java is certainly known for working with nonlocal files, as well. We’ll
    tackle network I/O and web resources in [Chapter 13](ch13.html#learnjava6-CHP-13).
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎任何准备发布的应用程序都需要处理文件 I/O。Java 在高效处理本地文件方面提供了强大的支持，包括对文件和目录的元数据访问。Java 在处理文本文件时提供了多种字符编码选项，显示了其广泛兼容性的承诺。Java
    在处理非本地文件方面也是众所周知的。我们将在[第13章](ch13.html#learnjava6-CHP-13)中探讨网络 I/O 和 web 资源。
- en: Review Questions
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复习问题
- en: How could you check to see if a given file already exists?
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何检查给定文件是否已经存在？
- en: If you have to work with a legacy text file using an old encoding scheme, such
    as ISO 8859, how might you set up a reader to properly convert that content to
    something like UTF-8?
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果必须使用旧的编码方案（例如 ISO 8859）处理遗留文本文件，您如何设置读取器以正确将其内容转换为类似 UTF-8 的内容？
- en: Which package has the best classes for nonblocking file I/O?
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个包中的类最适合非阻塞文件 I/O？
- en: Which type of input stream might you use to parse a binary file, such as a JPEG-compressed
    image?
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你需要解析诸如 JPEG 压缩图像之类的二进制文件时，你可能会使用哪种类型的输入流？
- en: What are the three standard text streams built into the `System` class?
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`System` 类中有哪三个标准文本流？'
- en: Absolute paths begin at a root (*/* or *C:\*, for example). Where do relative
    paths begin? More specifically, where are relative paths relative to?
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绝对路径从根目录开始（例如 */* 或 *C:\*）。相对路径从哪里开始？更具体地说，相对路径相对于什么？
- en: How do you retrieve a NIO channel from an existing `FileInputStream`?
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何从现有的 `FileInputStream` 获取 NIO 通道？
- en: Code Exercises
  id: totrans-412
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码练习
- en: 'For these exercises, a skeleton `Count.java` file is in the *ch10/exercises*
    folder, but feel free to start with your own class. We iterate on a single project,
    so you can use your solution from the first exercise as the starting point for
    the second, and so on. Because testing the program requires supplying different
    files on the command line, you may find it easier to run this program from a terminal
    or command window. You can certainly use the terminal tab in your IDE, too:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些练习，一个骨架`Count.java`文件位于*ch10/exercises*文件夹中，但可以随意从自己的类开始。我们在一个项目上进行迭代，因此您可以将第一个练习的解决方案作为第二个的起点，依此类推。因为测试程序需要在命令行上提供不同的文件，所以您可能会发现从终端或命令窗口运行此程序更容易。您当然也可以使用IDE中的终端选项卡：
- en: 'Using the classes of the `java.io` package, create a small program that will
    print the size of a file specified on the command line. For example:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`java.io`包的类，创建一个小程序，将打印出命令行中指定的文件的大小。例如：
- en: '[PRE62]'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: If no file argument is given, print an error message to `System.err`.
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果没有给出文件参数，则向`System.err`打印错误消息。
- en: Expand on the previous exercise to open the given file and count the number
    of lines. (For these simple exercises, it’s OK to assume the file being analyzed
    is a text file.) If you want a little practice with some of the tools from [Chapter 8](ch08.html#learnjava6-CHP-8),
    split each line based on whitespace and include a word count in the output. (You
    can use regular expressions to split words on fancier patterns such as punctuation,
    but that’s not required.)
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展上一个练习，打开给定的文件并计算行数。（对于这些简单的练习，可以假设正在分析的文件是文本文件。）如果您想要练习一些来自[第8章](ch08.html#learnjava6-CHP-8)的工具，可以根据空白拆分每一行，并在输出中包含单词计数。（您可以使用正则表达式在更复杂的模式上拆分单词，如标点符号，但这不是必需的。）
- en: '[PRE63]'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: As before, if no file argument is given, print an error message to `System.err`.
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与之前一样，如果没有给出文件参数，则向`System.err`打印错误消息。
- en: Convert your previous solution to use NIO classes like `Path` and `Files` instead
    of readers. You can use any part of the `java.nio` and `java.nio.file` packages
    that you like. You will almost certainly still need the `java.io.IOException`
    class from the “old” I/O, of course.
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您之前的解决方案转换为使用 NIO 类，如`Path`和`Files`，而不是读取器。您可以使用`java.nio`和`java.nio.file`包中的任何部分。当然，你几乎肯定还需要“旧”I/O中的`java.io.IOException`类。
- en: Advanced Exercises
  id: totrans-421
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级练习
- en: 'Accept a second command-line containing the name of a statistics log file.
    Rather than printing the various counts back to the terminal, append a line containing
    the current timestamp, the name of the file, and its three counts. The exact format
    of the line isn’t really important, but it should look something like this:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接受第二个命令行，其中包含统计日志文件的名称。而不是将各种计数打印回终端，而是追加一行，其中包含当前时间戳、文件名和其三个计数。该行的确切格式并不重要，但应该看起来像这样：
- en: '[PRE64]'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: You can use either your NIO or your old I/O (OIO?) solution as your starting
    point. If you go with the NIO version, try to use a `ByteBuffer` and a `FileChannel`
    to do the writing.
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以使用NIO或旧的I/O（OIO？）解决方案中的任何一个作为起点。如果选择NIO版本，请尝试使用`ByteBuffer`和`FileChannel`进行写入。
- en: If only one command-line argument is provided, revert to printing the stats
    out to the screen as before. If no arguments are provided, or if the second argument
    is not writable, print an error to `System.err`.
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果只提供一个命令行参数，则恢复以前将统计信息打印到屏幕上的方式。如果没有提供参数，或者第二个参数不可写，则向`System.err`打印错误信息。
- en: Run this version a few times on a few files. Check your log to make sure each
    new result is correctly appended to the end of the log file and is not overwriting
    it.
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行此版本几次，对几个文件进行测试。检查您的日志，确保每个新结果都正确追加到日志文件的末尾，而不是覆盖它。
- en: ^([1](ch10.html#id1908-marker)) While NIO was introduced with Java 1.4—so not
    very new anymore—it was newer than the original, basic package and the name has
    stuck.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch10.html#id1908-marker)) 虽然NIO是在Java 1.4中引入的——因此不再很新了——但它比原始的基本包要新，而且这个名称已经固定下来了。
- en: ^([2](ch10.html#id1946-marker)) Standard error (`stderr`) is a stream usually
    reserved for error-related text messages that should be shown to the user of a
    command-line application. It is different from standard output (`stdout`), which
    is often redirected to a log file or another application and not seen by the user.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch10.html#id1946-marker)) 标准错误（`stderr`）通常是保留给与命令行应用程序的用户显示有关的错误相关文本消息的流。它与标准输出（`stdout`）不同，后者通常被重定向到日志文件或另一个应用程序，并且不被用户看到。
- en: '^([3](ch10.html#id2038-marker)) The term is borrowed from the world of threads
    and means the same thing: an atomic file creation cannot be interrupted by another
    thread.'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch10.html#id2038-marker)) 这个术语来源于线程的世界，意味着同样的事情：原子文件创建不会被其他线程中断。
- en: ^([4](ch10.html#id2069-marker)) In OO programming, the term *factory* typically
    refers to a static helper that can construct and tailor some object. A factory
    (or factory method) is similar to a constructor, but that additional tailoring
    can add details to the new object that might be difficult (or impossible) to specify
    in a constructor.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch10.html#id2069-marker)) 在面向对象编程中，*工厂*这个术语通常指静态帮助器，可以构造和定制某些对象。工厂（或工厂方法）类似于构造函数，但额外的定制可以为新对象添加细节，这些细节可能在构造函数中很难（或不可能）指定。
- en: '^([5](ch10.html#id2150-marker)) The terms *big-endian* and *little-endian*
    come from Jonathan Swift’s novel *Gulliver’s Travels*, where they denoted two
    camps of Lilliputians: those who eat eggs from the big end and those who eat them
    from the little end.'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch10.html#id2150-marker)) *大端序*和*小端序*这两个术语源自乔纳森·斯威夫特的小说*格列佛游记*，在小说中它们分别指代利利普特人的两个阵营：一个从大头吃蛋，一个从小头吃蛋。
