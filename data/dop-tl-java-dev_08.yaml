- en: Chapter 8\. Deploying for Developers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。开发者部署
- en: Ana-Maria Mihalceanu
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 安娜-玛丽亚·米哈尔切亚努
- en: However beautiful the strategy, you should occasionally look at the results.
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 不管战略多么美丽，偶尔你也应该看看结果。
- en: ''
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Sir Winston Churchill
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 温斯顿·丘吉尔爵士
- en: When computers were extremely large and expensive, manufacturers often bundled
    together the software with the hardware. With the development of mass-market software,
    this type of operation was time-consuming, and new forms of software distribution
    emerged. Today’s development processes focus on decoupling build and deployment
    activities to facilitate fast software distribution and parallel activities in
    teams.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当计算机非常庞大且昂贵时，制造商经常将软件与硬件捆绑在一起。随着大众市场软件的发展，这种操作方式变得耗时，出现了新形式的软件分发。如今的开发过程专注于解耦构建和部署活动，以便快速进行软件分发和团队内的并行活动。
- en: The deployment of an application represents the transformation of that software
    from a packaged artifact to an operational working state. Modern development days
    require this transformation to happen as fast as possible in order to get rapid
    feedback about the running state of our system.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的部署代表了将该软件从打包的工件转化为运行状态的过程。现代开发日要求这种转化尽可能快地发生，以便快速获取关于系统运行状态的反馈。
- en: 'As a developer, your focus is mainly on writing performant application code.
    Yet DevOps is collaboration centric, and your work should flawlessly blend within
    the infrastructure. While looking at your deployment process, you should continuously
    ask yourself, “What instructions would a machine need to execute this deployment
    as I envisioned it?” and share those with the colleagues or experts in charge
    of the infrastructure and automation. When planning a deployment process, you
    can make a wish list that you can later scale to more components of the distributed
    system:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，你的重点主要是编写高效的应用程序代码。然而，DevOps 是以协作为中心，你的工作应无缝地融入基础设施中。在审视你的部署过程时，你应不断地问自己，“机器需要执行我设想的部署的哪些指令？”并将这些分享给负责基础设施和自动化的同事或专家。在规划部署过程时，你可以制定一个愿望清单，稍后可以将其扩展到分布式系统的更多组件：
- en: To gradually extend the functionalities of your system, conduct small deployments
    often. Using this approach, you can easily roll back to a previously working state
    in case of failures.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了逐步扩展系统的功能，经常进行小规模的部署。采用这种方法，你可以在失败时轻松回滚到先前的工作状态。
- en: Isolate deployment of each microservice, as you should be able to scale or replace
    it individually.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隔离每个微服务的部署，这样你就能够单独扩展或替换它。
- en: You should be able to reuse in another environment an already deployed microservice.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你应该能够在另一个环境中重复使用已部署的微服务。
- en: Automate infrastructure deployment and evolve it with your application features.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化基础设施部署，并随着应用程序功能的演变而进行更新。
- en: 'Regardless of the container orchestration platform where you will deploy any
    of your microservices, you likely will start by packaging the application and
    continue with the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 无论在哪个容器编排平台上部署你的任何微服务，你可能都会从打包应用程序开始，然后继续进行以下操作：
- en: Building and pushing a container image
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建和推送容器镜像
- en: Choosing and implementing a deployment strategy
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择和实施部署策略
- en: 'As the application deployment progresses throughout various stages or environments,
    is likely for you to get involved in the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用程序部署在各种阶段或环境中的推进，你可能会涉及以下内容：
- en: Workload management
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 工作负载管理
- en: Refine health checks and the amount of CPU and memory used to avoid slow or
    nonresponsive functionalities.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 优化健康检查、CPU和内存使用量，以避免功能缓慢或无响应。
- en: Observability aspects
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 观察性方面
- en: Use metrics, logs, and traces to provide visibility into internals of your distributed
    systems and measure its outputs.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用度量、日志和跟踪来查看你的分布式系统内部，并测量其输出。
- en: This chapter walks you through these activities and explores their impact at
    scale.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将带您完成这些活动，并探讨它们在规模上的影响。
- en: Building and Pushing Container Images
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和推送容器镜像
- en: Deploying applications to containers requires creating the Java application
    artifacts and building container images. By leveraging the recommended artifact
    formats and practices shared in [Chapter 6](ch06.xhtml#package_management), we
    can focus on producing container images.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序部署到容器需要创建 Java 应用程序工件并构建容器镜像。通过利用[第6章](ch06.xhtml#package_management)中分享的推荐工件格式和实践，我们可以专注于生成容器镜像。
- en: Starting with Docker’s appearance in 2013, building container images using Dockerfiles
    became popular. A *Dockerfile* is a standardized image format consisting of the
    base operating system, application artifacts to be added, and required runtime
    configurations. Essentially, this file is the blueprint for how your future container
    will behave. As explained in [Chapter 3](ch03.xhtml#thinking_in_containers), besides
    Docker, you can build container images with tools like [Podman](https://podman.io),
    [Buildah](https://buildah.io), and [kaniko](https://oreil.ly/X1A8A).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 自2013年Docker出现以来，使用Dockerfile构建容器镜像变得流行起来。*Dockerfile*是一种标准化的镜像格式，包含基本操作系统、要添加的应用程序构件以及所需的运行时配置。本质上，这个文件是描述未来容器行为方式的蓝图。正如在[第三章](ch03.xhtml#thinking_in_containers)中所解释的，除了Docker，您还可以使用工具如[Podman](https://podman.io)、[Buildah](https://buildah.io)和[kaniko](https://oreil.ly/X1A8A)来构建容器镜像。
- en: As DevOps methodology relies on good communication among application developers
    and infrastructure engineers, some teams find it best to keep the Dockerfiles
    at the repository root. Moreover, scripts or pipelines can further use that location
    when instrumenting a container image build. In addition to writing your Dockerfile,
    Java-specific options can help you make container images part of your standard
    build processes, such as Eclipse JKube or Jib.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由于DevOps方法依赖于应用程序开发人员和基础设施工程师之间的良好沟通，一些团队认为最好将Dockerfiles保留在仓库根目录。此外，在为容器镜像构建工具化或管道化时，可以进一步使用该位置。除了编写您的Dockerfile外，Java特定的选项可以帮助您将容器镜像作为标准构建过程的一部分，例如Eclipse
    JKube或Jib。
- en: Tip
  id: totrans-25
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Using Java-specific tools to generate and push container images might tempt
    you to control the entire runtime from application code. To avoid tight coupling
    between infrastructure and application code, you should configure those tools
    with parameters that can be overwritten at build or runtime. Modern Java frameworks
    provide customization of configuration files under *src/main/resources*. The examples
    from this chapter use parameters in project configuration files to showcase this
    approach.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Java特定工具生成和推送容器镜像可能会诱使您从应用程序代码控制整个运行时。为了避免基础设施与应用程序代码之间的紧密耦合，您应该使用可以在构建或运行时重写的参数配置这些工具。现代Java框架提供了在*src/main/resources*下自定义配置文件的功能。本章的示例使用项目配置文件中的参数展示了这种方法。
- en: Managing Container Images by Using Jib
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Jib管理容器镜像
- en: Google’s [Jib](https://oreil.ly/nWoWY) is one of the tools that you can use
    to containerize Java applications without writing a Dockerfile. It provides a
    Java library, and Maven and Gradle plug-ins for creating OCI-compatible container
    images. Additionally, the tool does not require running the Docker daemon locally
    in order to produce a container image.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Google的[Jib](https://oreil.ly/nWoWY)是您可以使用的一种工具，用于将Java应用程序容器化，而无需编写Dockerfile。它提供了一个Java库，以及用于创建OCI兼容容器镜像的Maven和Gradle插件。此外，该工具不需要在本地运行Docker守护程序即可生成容器镜像。
- en: Jib takes advantage of image layering and registry caching to achieve fast,
    incremental builds. The tool can create reproducible build images as long as the
    inputs remain the same.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Jib利用镜像分层和注册表缓存实现快速、增量构建。只要输入保持不变，该工具可以创建可重现的构建镜像。
- en: 'To begin using Jib within your Maven project, set up the authentication method
    for the target container registry by using any of the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始在您的Maven项目中使用Jib，请通过以下任一方式设置目标容器注册表的身份验证方法：
- en: System properties `jib.to.auth.username` and `jib.to.auth.password`
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统属性`jib.to.auth.username`和`jib.to.auth.password`
- en: '`<to>` section in the plug-in configuration with `username` and `password`
    elements'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在插件配置中的`<to>`部分，包含`username`和`password`元素
- en: A `<server>` configuration in *~/.m2/settings.xml*
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*~/.m2/settings.xml*中的`<server>`配置'
- en: Previous login into a registry with Docker login (credentials in a credential
    helper or in *~/.docker/config.json*)
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 先前使用Docker登录到注册表（凭据在凭据助手或*~/.docker/config.json*中）
- en: Caution
  id: totrans-35
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you are using a specific base image registry, you can set up its credentials
    by using the `<from>` section in the plug-in configuration or `jib.from.auth.username`
    and `jib.from.auth.password` system properties.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用特定的基础镜像注册表，可以通过插件配置中的`<from>`部分或`jib.from.auth.username`和`jib.from.auth.password`系统属性设置其凭据。
- en: 'Next, let’s configure the Maven plug-in in your *pom.xml*:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在您的*pom.xml*中配置Maven插件：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The image tag configuration is mandatory and is the target path in the container
    registry. Now you can build the image to a container registry with a single command:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像标签配置是强制的，并且是容器注册表中的目标路径。现在，您可以使用单个命令将镜像构建到容器注册表：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you would like to build and push the container image by using Gradle, you
    can configure the authentication in one of these ways:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果希望使用 Gradle 构建和推送容器镜像，可以通过以下任一方式配置认证：
- en: Use the `to` and `from` section in the plug-in configuration in *build.gradle*.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *build.gradle* 的插件配置中使用 `to` 和 `from` 部分。
- en: Connect into a registry with a Docker login command (store credentials in a
    credential helper or in *~/.docker/config.json*).
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Docker 登录命令连接到注册表（将凭据存储在凭据助手或 *~/.docker/config.json* 中）。
- en: 'Next, add the plug-in to your *build.gradle*:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在您的 *build.gradle* 中添加插件：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And invoke the following command in a terminal window:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 并在终端窗口中调用以下命令：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To simplify container image customization when using Jib, some frameworks have
    integrated the plug-in as a dependency library. For example, Quarkus provides
    the *quarkus-container-image-jib* extension for personalizing the container image
    build process. Using this extension, we can revisit the Quarkus example from [Chapter 4](ch04.xhtml#dissecting_the_monolith)
    and add it using the following Maven command:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化使用 Jib 时的容器镜像定制，一些框架已将插件集成为依赖库。例如，Quarkus 提供了 *quarkus-container-image-jib*
    扩展来个性化容器镜像构建过程。使用此扩展，我们可以重新访问 [第四章](ch04.xhtml#dissecting_the_monolith) 中的 Quarkus
    示例，并使用以下 Maven 命令添加它：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Furthermore, you can customize the image details in *src/main/resources/application.properties*:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可以在 *build.gradle* 中的插件配置的 *src/main/resources/application.properties* 中自定义镜像详细信息。
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[![1](Images/1.png)](#co_deploying_for_developers_CO1-1)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '![1](Images/1.png)：[#co_deploying_for_developers_CO1-1](#co_deploying_for_developers_CO1-1)'
- en: The extension used for building (and pushing) container images.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 用于构建（和推送）容器镜像的扩展。
- en: '[![2](Images/2.png)](#co_deploying_for_developers_CO1-2)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '![2](Images/2.png)：[#co_deploying_for_developers_CO1-2](#co_deploying_for_developers_CO1-2)'
- en: The container registry to use.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用的容器注册表。
- en: '[![3](Images/3.png)](#co_deploying_for_developers_CO1-3)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![3](Images/3.png)：[#co_deploying_for_developers_CO1-3](#co_deploying_for_developers_CO1-3)'
- en: The container image will be part of this group.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像将作为此组的一部分。
- en: '[![4](Images/4.png)](#co_deploying_for_developers_CO1-4)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '![4](Images/4.png)：[#co_deploying_for_developers_CO1-4](#co_deploying_for_developers_CO1-4)'
- en: The name of the container image is optional; if not set, it defaults to the
    application name.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像的名称是可选的；如果未设置，则默认为应用程序名称。
- en: '[![5](Images/5.png)](#co_deploying_for_developers_CO1-5)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![5](Images/5.png)：[#co_deploying_for_developers_CO1-5](#co_deploying_for_developers_CO1-5)'
- en: The tag of the container image is also optional; if not set, it defaults to
    the application version.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像的标签也是可选的；如果未设置，则默认为应用程序版本。
- en: 'Finally, you can build and push the container image:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以构建并推送容器镜像：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In [Chapter 3](ch03.xhtml#thinking_in_containers), you read about keeping the
    container images small. The size of a container image influences the time spent
    by the orchestrating platform to pull that image from the registry. Often, the
    size of the base image used by the `FROM` instruction influences the size of your
    container image, and Jib allows you to control it by changing the `baseImage`
    configuration. Moreover, when using Jib, you can also control the ports you expose
    or the entry point of your container image.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第三章](ch03.xhtml#thinking_in_containers) 中，您了解到保持容器镜像的小型化。容器镜像的大小影响编排平台从注册表中拉取镜像所需的时间。通常情况下，`FROM`
    指令使用的基础镜像大小会影响您的容器镜像大小，而 Jib 允许您通过更改 `baseImage` 配置来控制它。此外，在使用 Jib 时，您还可以控制要暴露的端口或容器镜像的入口点。
- en: Tip
  id: totrans-65
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Changing the JVM base image is also helpful when performing JDK upgrades. In
    addition, the Quarkus extension supports customization of the JVM base image (`quarkus.jib.base-jvm-image`)
    and the native base image (`quarkus.jib.base-native-image`) used for the native
    binary build.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行 JDK 升级时，更改 JVM 基础镜像也很有帮助。此外，Quarkus 扩展支持自定义 JVM 基础镜像（`quarkus.jib.base-jvm-image`）和用于本机二进制构建的本机基础镜像（`quarkus.jib.base-native-image`）。
- en: The code sample referenced in this section is available on [GitHub](https://oreil.ly/AshKo).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此节引用的代码示例可在 [GitHub](https://oreil.ly/AshKo) 上找到。
- en: Building Container Images with Eclipse JKube
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Eclipse JKube 构建容器镜像
- en: An alternative tool that a Java developer can use to containerize Java applications
    without writing Dockerfiles is [Eclipse JKube](https://oreil.ly/Fp5xx). This community
    project, supported by the Eclipse Foundation and Red Hat, can help you build container
    images and cooperate with Kubernetes. The project contains a Maven plug-in that
    is the refactored and rebranded version of the [Fabric8 Maven plug-in](https://oreil.ly/dHtw8).
    At the time of writing this chapter, Gradle plug-ins are available for technical
    preview, and support is planned for the future.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一种 Java 开发者可以使用的替代工具来将 Java 应用程序容器化，而无需编写 Dockerfile，即 [Eclipse JKube](https://oreil.ly/Fp5xx)。这个由
    Eclipse Foundation 和 Red Hat 支持的社区项目可以帮助您构建容器镜像并与 Kubernetes 协作。该项目包含一个 Maven
    插件，这是 [Fabric8 Maven 插件](https://oreil.ly/dHtw8) 的重构和重新品牌版本。在撰写本章时，Gradle 插件可以进行技术预览，并计划未来提供支持。
- en: 'To start using the Eclipse JKube Maven plug-in within your project, please
    add the Kubernetes Maven plug-in to your *pom.xml*:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要在项目中开始使用 Eclipse JKube Maven 插件，请将 Kubernetes Maven 插件添加到您的 *pom.xml* 中：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Let’s add the snippet to the sample Spring Boot application from [Chapter 4](ch04.xhtml#dissecting_the_monolith).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在来自 [第 4 章](ch04.xhtml#dissecting_the_monolith) 的示例 Spring Boot 应用程序中添加这个片段。
- en: Example 8-1\. pom.xml configuration file for sample Spring Boot project
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-1\. Spring Boot 项目的 *pom.xml* 配置文件示例
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[![1](Images/1.png)](#co_deploying_for_developers_CO2-1)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_deploying_for_developers_CO2-1)'
- en: You can provide a default value for the container registry property and override
    it at build time.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以为容器注册表属性提供默认值，并在构建时进行覆盖。
- en: '[![2](Images/2.png)](#co_deploying_for_developers_CO2-2)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_deploying_for_developers_CO2-2)'
- en: You can provide a default value for the repository property and override it
    at build time.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以为仓库属性提供默认值，并在构建时进行覆盖。
- en: '[![3](Images/3.png)](#co_deploying_for_developers_CO2-3)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_deploying_for_developers_CO2-3)'
- en: You can provide a default value for the tag property and override it at build
    time. The default image name will be the project name.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以为标签属性提供默认值，并在构建时进行覆盖。默认图像名称将是项目名称。
- en: 'To produce a container image for that application, run the following at the
    command line:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要为该应用程序生成一个容器镜像，请在命令行中运行以下命令：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: JKube selects opinionated defaults like base images and handcrafted startup
    scripts, depending on the type of technology stack you are using. For this case,
    JKube uses the current local Docker build context for pulling and pushing the
    container images.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您使用的技术栈类型，JKube 会选择主观的默认设置，如基础镜像和手工制作的启动脚本。在这种情况下，JKube 使用当前本地 Docker 构建上下文来拉取和推送容器镜像。
- en: 'In addition, the image name results from concatenating the values of the Maven
    properties `${jkube.docker.registry}`, `${repository}`, `${project.name}`, and
    ​`$⁠{tag}` : `registry.hub.docker.com/myuser/demo:0.0.1-SNAPSHOT`.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，镜像名称由 Maven 属性 `${jkube.docker.registry}`、`${repository}`、`${project.name}`
    和 `${tag}` 的值连接而成：`registry.hub.docker.com/myuser/demo:0.0.1-SNAPSHOT`。
- en: 'Yet, in order to separate the development part from the operational side, we
    will customize these details and override them at build time. By customizing the
    property, `jkube.generator.name`, you can include a remote registry, repository,
    image name, and tag of choice:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了将开发部分与操作方面分开，我们将定制这些详细信息，并在构建时进行覆盖。通过自定义属性 `jkube.generator.name`，您可以包含远程注册表、仓库、镜像名称和选择的标签：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we can build an image for a remote container registry by using the following
    command:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过以下命令为远程容器注册表构建镜像：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you would like to build and push the image to the remote container registry,
    you can use this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要构建并推送图像到远程容器注册表，可以使用以下命令：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This command builds the image *quay.io/repo/demo:0.0.1* and pushes it to the
    respective remote registry.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令构建图像 *quay.io/repo/demo:0.0.1* 并将其推送到相应的远程注册表。
- en: Caution
  id: totrans-92
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'When using remote registries, you need to provide credentials. Eclipse JKube
    will search for these locations to obtain credentials:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用远程注册表时，您需要提供凭据。Eclipse JKube 将搜索这些位置以获取凭据：
- en: The system properties `jkube.docker.username` and `jkube​.docker.password`
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统属性 `jkube.docker.username` 和 `jkube.docker.password`
- en: The `<authConfig>` section in the plug-in configuration with the `<username>`
    and `<password>` elements
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插件配置中的 `<authConfig>` 部分，包含 `<username>` 和 `<password>` 元素
- en: A `<server>` configuration in *~/.m2/settings.xml*
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *~/.m2/settings.xml* 中的 `<server>` 配置
- en: Previous login into a registry with Docker login (credentials in a credential
    helper or in *~/.docker/config.json*)
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 先前使用 Docker 登录到注册表（凭据存储在凭据助手或 *~/.docker/config.json* 中）
- en: OpenShift configuration in *~/.config/kube*
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenShift 配置位于 *~/.config/kube*
- en: 'You can use the same steps to build and push container images using the [Eclipse
    JKube Kubernetes Gradle plug-in](https://oreil.ly/CeYVl). In that case, you should
    configure the plug-in in *build.gradle*:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 [Eclipse JKube Kubernetes Gradle 插件](https://oreil.ly/CeYVl) 的相同步骤构建和推送容器镜像。在这种情况下，您应在
    *build.gradle* 中配置插件：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: At the command line, you can build the container image by using `gradle k8sBuild`
    and push the result with `gradle k8sPush`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行上，您可以使用 `gradle k8sBuild` 构建容器镜像，并使用 `gradle k8sPush` 推送结果。
- en: Tip
  id: totrans-102
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: You can add `k8s:watch` goal to the plug-in configuration in order to automatically
    re-create images or copy new artifacts into running containers when your code
    changes.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在插件配置中添加 `k8s:watch` 目标，以便在代码更改时自动重新创建镜像或将新的构件复制到正在运行的容器中。
- en: Deploying to Kubernetes
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署到 Kubernetes
- en: With a good understanding of building and pushing container images, you can
    focus on running containers. When working with distributed systems, containers
    help you achieve deployment independency and can isolate application code from
    failures.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通过深入理解构建和推送容器镜像，您可以专注于运行容器。在处理分布式系统时，容器帮助您实现部署的独立性，并且可以将应用程序代码与故障隔离开来。
- en: 'Because a distributed system will likely have more than one microservice, you
    will need to figure out how to manage those using containers. Orchestration tools
    can help you manage a large number of containers as they typically provide the
    following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 因为分布式系统可能会有多个微服务，您需要找出如何使用容器管理这些微服务。编排工具可以帮助您管理大量容器，通常提供以下功能：
- en: A declarative system configuration
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明式系统配置
- en: Container provisioning and discovery
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器供给和发现
- en: System monitoring and crash recovery
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统监控和崩溃恢复
- en: Instruments for defining rules and constraints on container placement and performance.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于定义容器放置和性能规则的工具。
- en: '*Kubernetes* is an open source platform automating deployment, scaling, and
    management of containerized workloads. With Kubernetes, you can organize your
    deployments in such a way that the platform can spin up or remove instances to
    match the load demand. Furthermore, Kubernetes can replace and reschedule containers
    when nodes die.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*Kubernetes* 是一个开源平台，自动化部署、扩展和管理容器化工作负载。使用 Kubernetes，您可以组织部署以便平台可以根据负载需求增加或删除实例。此外，当节点失败时，Kubernetes
    可以替换和重新调度容器。'
- en: Features like portability and extensibility increased the popularity of Kubernetes,
    stimulating community contributions and vendors’ support. The proven success of
    Kubernetes to support increasingly complex categories of applications continues
    to enable enterprise transition to both hybrid cloud and microservices.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 的可移植性和可扩展性特性增加了其受欢迎程度，促进了社区贡献和供应商的支持。Kubernetes 成功支持越来越复杂的应用类别，继续推动企业向混合云和微服务的过渡。
- en: With Kubernetes, you can deploy your application(s) in such a way to have Kubernetes
    run more instances of your service if load increases, stop instances if load decreases,
    or spin up new instances should existing ones fail. As a developer, when you want
    to deploy to Kubernetes, you need access to a Kubernetes cluster. A *Kubernetes
    cluster* consists of a set of nodes that run containerized applications, as shown
    in [Figure 8-1](#components-of-kubernetes).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Kubernetes，您可以根据负载情况部署应用程序，如果负载增加，Kubernetes 将运行更多服务实例；如果负载减少，Kubernetes
    将停止实例；如果现有实例失败，Kubernetes 将启动新实例。作为开发者，在部署到 Kubernetes 时，您需要访问 Kubernetes 集群。*Kubernetes
    集群*由运行容器化应用程序的一组节点组成，如 [图 8-1](#components-of-kubernetes) 所示。
- en: '![The components of a Kubernetes cluster](Images/dtjd_0801.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![Kubernetes 集群的组件](Images/dtjd_0801.png)'
- en: Figure 8-1\. Kubernetes components (image adapted from [Kubernetes documentation](https://oreil.ly/nyzh7))
  id: totrans-115
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-1\. Kubernetes 组件（图片来源于 [Kubernetes 文档](https://oreil.ly/nyzh7)）
- en: Every cluster has at least one worker node, and each worker hosts Pods. Within
    a cluster, namespaces are used to isolate groups of resources (Pods included).
    Pods are the components in direct contact with your running containers, instantiated
    from container images previously built and pushed to a container registry.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 每个集群至少有一个工作节点，每个工作节点托管 Pod。在集群内，命名空间用于隔离资源组（包括 Pod）。Pod 是直接与正在运行的容器交互的组件，这些容器是从之前构建并推送到容器注册表的容器镜像实例化而来。
- en: When you work with Kubernetes, you are using a set of objects that are validated
    and accepted by the system. To work with Kubernetes objects, you need to use the
    Kubernetes API. Nowadays it’s possible to instrument Kubernetes deployments by
    using visual helpers, command-line interfaces, or Java add-ons like Dekorate and
    JKube to generate and deploy Kubernetes manifests.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用 Kubernetes 时，您使用一组对象，这些对象由系统验证并接受。要处理 Kubernetes 对象，您需要使用 Kubernetes API。现在可以通过使用可视化辅助工具、命令行界面或像
    Dekorate 和 JKube 这样的 Java 插件来生成和部署 Kubernetes 清单来实现 Kubernetes 部署。
- en: Local Setup for Deployment
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用于部署的本地设置
- en: 'As a developer, you are used to configuring a local setup to implement application
    features. Typically, this local setup involves having access to a version control
    system, and installing and configuring the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发人员，您习惯于配置本地设置以实现应用程序功能。通常，此本地设置包括访问版本控制系统，并安装和配置以下内容：
- en: A JDK
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 JDK
- en: Maven or Gradle
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Maven 或 Gradle
- en: An IDE like IntelliJ IDEA, Eclipse, or Visual Studio Code
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如 IntelliJ IDEA、Eclipse 或 Visual Studio Code 等 IDE
- en: Optionally, a database or middleware that integrates with your code
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选地，与您的代码集成的数据库或中间件
- en: 'One or more tools for building, running, and pushing container images: Docker,
    Podman, Buildah, Jib, JKube, etc.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于构建、运行和推送容器镜像的一个或多个工具：Docker、Podman、Buildah、Jib、JKube 等。
- en: 'A Kubernetes development cluster: [minikube](https://oreil.ly/SfNR3), [kind](https://oreil.ly/BcYHp),
    or [Red Hat CodeReady Containers](https://oreil.ly/iIkzu). For development purposes,
    [Docker Desktop](https://oreil.ly/gmh6B) also offers a single-node Kubernetes
    cluster that runs locally within your Docker instance. [Rancher Desktop](https://oreil.ly/09wOS)
    is another great tool that can help you locally with container management and
    running Kubernetes. If running a local development cluster consumes too many resources,
    you may prefer to have development namespaces in remote Kubernetes cluster(s)
    or use an already provisioned one like [Developer Sandbox for Red Hat OpenShift](https://oreil.ly/14VUx).'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 开发集群：[minikube](https://oreil.ly/SfNR3)、[kind](https://oreil.ly/BcYHp)
    或 [Red Hat CodeReady Containers](https://oreil.ly/iIkzu)。对于开发目的，[Docker Desktop](https://oreil.ly/gmh6B)
    还提供在 Docker 实例中本地运行的单节点 Kubernetes 集群。[Rancher Desktop](https://oreil.ly/09wOS)
    是另一个可以帮助您在本地管理容器并运行 Kubernetes 的优秀工具。如果运行本地开发集群消耗过多资源，您可能更喜欢在远程 Kubernetes 集群中具有开发命名空间，或者使用像
    [Developer Sandbox for Red Hat OpenShift](https://oreil.ly/14VUx) 这样已经预配好的集群。
- en: 'Before creating any Kubernetes resources, let’s summarize some Kubernetes concepts:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建任何 Kubernetes 资源之前，让我们总结一些 Kubernetes 概念：
- en: Cluster
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 集群
- en: A set of nodes where you can instruct Kubernetes on deploying containers.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一组节点，您可以指示 Kubernetes 在其中部署容器。
- en: Namespace
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间
- en: A Kubernetes object responsible for isolating groups’ resources based on different
    permissions.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Kubernetes 对象，根据不同的权限负责隔离组的资源。
- en: User
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 用户
- en: Interaction with the Kubernetes API requires a form of authentication managed
    through users.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Kubernetes API 的交互需要通过用户管理的认证形式。
- en: Context
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文
- en: A specific combination that contains a Kubernetes cluster, a user, and a namespace.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 包含 Kubernetes 集群、用户和命名空间的特定组合。
- en: Kubelet
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Kubelet
- en: The main agent that runs on each cluster node and ensures that containers are
    running and healthy, according to pod specifications.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个集群节点上运行的主要代理程序，根据 pod 规范确保容器正在运行且健康。
- en: Deployment
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Deployment
- en: A resource that instructs Kubernetes on creating or modifying instances of pods
    with a containerized application.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一个资源，指示 Kubernetes 创建或修改带有容器化应用程序的 pod 实例。
- en: ReplicaSet
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ReplicaSet
- en: Every time Kubernetes creates a deployment, this resource instantiates a ReplicaSet
    and delegates to it counting pods.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 每次 Kubernetes 创建一个部署时，此资源会实例化一个 ReplicaSet 并委托给它计算 pod 数。
- en: Service
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Service
- en: A way to expose an application having multiple instances in different pods as
    a network service.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一种将多个实例中不同的 pod 中的应用程序公开为网络服务的方式。
- en: Keeping in mind these concepts, let’s investigate how you can generate Kubernetes
    objects and deploy them.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 牢记这些概念，让我们看看如何生成 Kubernetes 对象并部署它们。
- en: Generate Kubernetes Manifests by Using Dekorate
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Dekorate 生成 Kubernetes 清单
- en: '[Dekorate](http://dekorate.io) can generate Kubernetes manifests at compile
    time, using Java annotations and standard Java framework configuration mechanisms.
    [Table 8-1](#dekorate_dependencies) shows Dekorate Maven dependencies available
    for Quarkus, Spring Boot, or a generic Java project.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[Dekorate](http://dekorate.io) 可以在编译时使用 Java 注解和标准 Java 框架配置机制生成 Kubernetes
    清单。[Table 8-1](#dekorate_dependencies) 显示了适用于 Quarkus、Spring Boot 或通用 Java 项目的
    Dekorate Maven 依赖项。'
- en: Table 8-1\. Dekorate Maven dependencies
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-1\. 使用 Dekorate Maven 依赖项
- en: '| Framework | Dependency |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 框架 | 依赖项 |'
- en: '| --- | --- |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Quarkus |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| Quarkus |'
- en: '[PRE14]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '|'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Spring Boot |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| Spring Boot |'
- en: '[PRE15]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '|'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Generic Java Application |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| 通用 Java 应用程序 |'
- en: '[PRE16]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '|'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Let’s create some Kubernetes resources by adding Dekorate to [Example 8-1](#example_0801):'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过将 Dekorate 添加到 [示例 8-1](#example_0801) 来创建一些 Kubernetes 资源：
- en: '[PRE17]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If no configuration is provided, Dekorate will produce a Deployment and Service
    resource in the manifest created under *target/classes/META-INF/dekorate*. This
    generated Service type is `ClusterIP` and makes the application available only
    within the Kubernetes cluster. If you want to expose the service externally, using
    the load balancer of a cloud provider, you can do that by using a Service resource
    of type `LoadBalancer`, as explained in the [Kubernetes documentation](https://oreil.ly/uPUm6).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未提供任何配置，Dekorate 将在 *target/classes/META-INF/dekorate* 下创建的清单中生成 Deployment
    和 Service 资源。生成的 Service 类型为 `ClusterIP`，仅在 Kubernetes 集群内部提供应用程序。如果要使用云提供商的负载均衡器将服务外部公开，可以使用类型为
    `LoadBalancer` 的 Service 资源，如 [Kubernetes 文档](https://oreil.ly/uPUm6) 中所述。
- en: 'When working with Dekorate, you can customize the generation of Kubernetes
    resources by using the following approaches:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Dekorate 时，您可以通过以下方式自定义生成的 Kubernetes 资源：
- en: Specifying configurations in `application.properies`
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `application.properies` 中指定配置
- en: Adding the `@KubernetesApplication` annotation to the `DemoApplication` class
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `@KubernetesApplication` 注解添加到 `DemoApplication` 类中
- en: 'To avoid tight coupling between infrastructure and application code, we customize
    the Service resource *src/main/resources/application.properties* by using the
    following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免基础设施和应用代码之间的紧耦合，我们通过以下方式自定义 *src/main/resources/application.properties*
    中的 Service 资源：
- en: '[PRE18]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To generate the Kubernetes objects, you can package the application like this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成 Kubernetes 对象，可以如此打包应用程序：
- en: '[PRE19]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After packaging the application, you will notice among the other files that
    are created, two files named *kubernetes.json* and *kubernetes.yml* in the *target/classes/META-INF/dekorate*
    directory. Either of these manifests can be used to deploy to Kubernetes:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 打包应用程序后，您会注意到在 *target/classes/META-INF/dekorate* 目录中创建的其他文件中，有两个文件命名为 *kubernetes.json*
    和 *kubernetes.yml*。这些清单中的任一个都可以用来部署到 Kubernetes：
- en: '[PRE20]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[![1](Images/1.png)](#co_deploying_for_developers_CO3-1)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_deploying_for_developers_CO3-1)'
- en: A Deployment provides declarative updates for Pods and ReplicaSets.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Deployment 为 Pods 和 ReplicaSets 提供声明性更新。
- en: '[![2](Images/2.png)](#co_deploying_for_developers_CO3-2)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_deploying_for_developers_CO3-2)'
- en: Labels are used by selectors to connect the Service to the Pods, but also to
    align the specifications of `Deployment` to ReplicaSets and Pods.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 标签被选择器用来将 Service 与 Pods 连接，同时将 `Deployment` 的规范与 ReplicaSets 和 Pods 对齐。
- en: '[![3](Images/3.png)](#co_deploying_for_developers_CO3-4)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_deploying_for_developers_CO3-4)'
- en: Name of the Deployment object.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Deployment 对象的名称。
- en: '[![4](Images/4.png)](#co_deploying_for_developers_CO3-9)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_deploying_for_developers_CO3-9)'
- en: Container image used by the Deployment.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Deployment 使用的容器镜像。
- en: '[![5](Images/5.png)](#co_deploying_for_developers_CO3-10)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](Images/5.png)](#co_deploying_for_developers_CO3-10)'
- en: Port exposed by the container and targeted by the Service.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 容器暴露的端口，服务所指向的端口。
- en: '[![6](Images/6.png)](#co_deploying_for_developers_CO3-11)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](Images/6.png)](#co_deploying_for_developers_CO3-11)'
- en: A Service exposes the application running on a set of Pods as a network service.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Service 将运行在一组 Pods 上的应用程序作为网络服务公开。
- en: '[![7](Images/7.png)](#co_deploying_for_developers_CO3-14)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](Images/7.png)](#co_deploying_for_developers_CO3-14)'
- en: Port used to serve incoming traffic.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 用于服务传入流量的端口。
- en: '[![8](Images/8.png)](#co_deploying_for_developers_CO3-16)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](Images/8.png)](#co_deploying_for_developers_CO3-16)'
- en: Expose the service externally using the load balancer of a cloud provider.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用云提供商的负载均衡器将服务外部公开。
- en: 'Assuming you have previously logged in a Kubernetes cluster, you can deploy
    to it using the command-line interface:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您以前已经登录到 Kubernetes 集群，您可以使用命令行界面进行部署：
- en: '[PRE21]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As a result, you can access the application by using the external IP (`LoadBalancer
    Ingress`) and port by Kubernetes after applying the manifests.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在应用清单之后，您可以通过 Kubernetes 使用外部 IP (`LoadBalancer Ingress`) 和端口访问应用程序。
- en: Generate and Deploy Kubernetes Manifests with Eclipse JKube
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Eclipse JKube 生成和部署 Kubernetes 清单
- en: 'Eclipse JKube can also generate and deploy Kubernetes/OpenShift manifests at
    compile time. In addition to creating Kubernetes descriptors (YAML files), you
    can adjust the output by using the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse JKube 还可以在编译时生成和部署 Kubernetes/OpenShift 清单。除了创建 Kubernetes 描述符（YAML
    文件）外，还可以通过以下方式调整输出：
- en: Inline configuration within the XML plug-in configuration
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML 插件配置内的内联配置
- en: External configuration templates of deployment descriptors
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部配置模板的部署描述符
- en: '[“Building Container Images with Eclipse JKube”](Images/#building-container-images-with-eclipse-jkube)
    explored building container images with JKube and with Docker daemon integration.
    We will reuse the Quarkus sample code from [“Managing Container Images by Using
    Jib”](Images/#managing-container-images-using-jib) to generate and deploy Kubernetes
    resources with Eclipse JKube and Jib.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '[“使用 Eclipse JKube 构建容器镜像”](Images/#building-container-images-with-eclipse-jkube)
    探讨了使用 JKube 和 Docker 守护程序集成来构建容器镜像。我们将重用 Quarkus 示例代码从 [“使用 Jib 管理容器镜像”](Images/#managing-container-images-using-jib)
    开始，通过 Eclipse JKube 和 Jib 生成和部署 Kubernetes 资源。'
- en: Example 8-2\. *pom.xml* configuration file for sampled Quarkus project
  id: totrans-194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-2\. Quarkus 项目的 *pom.xml* 配置文件
- en: '[PRE22]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[![1](Images/1.png)](#co_deploying_for_developers_CO4-1)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_deploying_for_developers_CO4-1)'
- en: For consistency, you can reuse the Quarkus extension properties within the JKube
    image name.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持一致性，您可以在 JKube 镜像名称中重复使用 Quarkus 扩展属性。
- en: '[![2](Images/2.png)](#co_deploying_for_developers_CO4-2)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_deploying_for_developers_CO4-2)'
- en: Expose the service on each node’s IP at a static port (the `NodePort`).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个节点的 IP 上使用静态端口（`NodePort`）公开服务。
- en: '[![3](Images/3.png)](#co_deploying_for_developers_CO4-3)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_deploying_for_developers_CO4-3)'
- en: Specify that the build strategy is Jib.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 指定构建策略为 Jib。
- en: 'We can now invoke the container image build (`k8s:build`) and create a Kubernetes
    resource (`k8s:resource`) in a single command:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以调用容器镜像构建（`k8s:build`）并在一个命令中创建 Kubernetes 资源（`k8s:resource`）：
- en: '[PRE23]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following structure will appear under *target/classes/META-INF/jkube*:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的结构将出现在 *target/classes/META-INF/jkube* 下：
- en: '[PRE24]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*kubernetes.yml* contains both the Deployment and the Service resource definition,
    while in the *kubernetes* folder you have them separated in two distinct files.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '*kubernetes.yml* 包含了部署和服务资源定义，而在 *kubernetes* 文件夹中，您可以将它们分开存放在两个不同的文件中。'
- en: 'As we did for the Dekorate manifest, we can deploy *kubernetes.yml* by using
    the command-line interface:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们为 Dekorate 清单所做的那样，我们可以通过命令行界面部署 *kubernetes.yml*：
- en: '[PRE25]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Or you can use the `k8s:apply` Maven goal of the JKube plug-in to achieve the
    same result:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 或者您可以使用 JKube 插件的 `k8s:apply` Maven 目标来实现相同的结果：
- en: '[PRE26]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This goal will search for the previously generated files and apply them to the
    connected Kubernetes cluster. The application will be reachable using the cluster
    IP and the assigned node port.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 此目标将搜索之前生成的文件并将其应用到连接的 Kubernetes 集群中。应用将通过集群 IP 和分配的节点端口可达。
- en: Furthermore, you can model the interaction between the generated resources and
    the Kubernetes cluster with more plug-in goals. [Table 8-2](#additional_jkube_goals)
    lists other goals available with the Kubernetes Maven plug-in.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可以通过更多的插件目标来模拟生成资源与 Kubernetes 集群之间的交互。[表 8-2](#additional_jkube_goals)
    列出了 Kubernetes Maven 插件中可用的其他目标。
- en: Table 8-2\. Eclipse JKube additional goals
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-2\. Eclipse JKube 额外目标
- en: '| Goal | Description |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| 目标 | 描述 |'
- en: '| --- | --- |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '`k8s:log`'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`k8s:log`'
- en: '| Gets the logs from your running container in Kubernetes |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| 从运行中的 Kubernetes 容器获取日志 |'
- en: '|'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '`k8s:debug`'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`k8s:debug`'
- en: '| Opens the debug port so that you can debug the application deployed in Kubernetes
    from your IDE |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| 打开调试端口，以便您可以从 IDE 调试 Kubernetes 中部署的应用程序 |'
- en: '|'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '`k8s:watch`'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`k8s:watch`'
- en: '| Does an automatic deployment of your application by watching your application
    context |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| 通过监视应用程序上下文自动部署您的应用程序 |'
- en: '|'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '`k8s:deploy`'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`k8s:deploy`'
- en: '| Forks the Install goal and applies your generated manifests onto a Kubernetes
    cluster |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| 分叉安装目标并将生成的清单应用于 Kubernetes 集群 |'
- en: '|'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '`k8s:undeploy`'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`k8s:undeploy`'
- en: '| Deletes all of the resources applied with `k8s:apply` |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| 删除使用 `k8s:apply` 应用的所有资源 |'
- en: Now that you have seen how to deploy to Kubernetes, let’s see how we can refine
    this by choosing and implementing a deployment strategy.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经看到如何部署到 Kubernetes，让我们看看如何通过选择和实施部署策略来优化这一过程。
- en: Choose and Implement a Deployment Strategy
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择和实施部署策略
- en: Deploying a single application to Kubernetes can be an easy task when using
    the right tools. As developers, we should also think ahead and decide how we might
    replace an old version of a microservice with a newer one without downtime.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中部署单个应用程序可以是一个简单的任务，当使用合适的工具时。作为开发者，我们还应该提前考虑并决定如何在不停机的情况下用新版本的微服务替换旧版本。
- en: 'When you choose a deployment strategy to Kubernetes, you need to look into
    establishing these quotas:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当您选择一个部署策略到 Kubernetes 时，您需要考虑建立这些配额：
- en: Number of desired instances for your application
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序所需实例数
- en: Minimum healthy running instances
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小健康运行实例
- en: Maximum instances
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大实例数
- en: The ideal situation is to have the number of desired running instances in the
    shortest time possible while using minimal resources (CPU, memory). But let’s
    try the already established methodologies and compare their performance.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况是在尽可能短的时间内拥有所需的运行实例数量，同时使用最少的资源（CPU、内存）。但让我们尝试已经建立的方法并比较它们的性能。
- en: 'All-in-one deployment using the `Recreate` strategy is the simplest available
    when using Kubernetes Deployment objects:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Recreate`策略进行一体化部署是在使用 Kubernetes 部署对象时最简单的方法：
- en: '[PRE27]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[![1](Images/1.png)](#co_deploying_for_developers_CO5-1)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_deploying_for_developers_CO5-1)'
- en: The deployment strategy is `Recreate`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 部署策略是`Recreate`。
- en: '[![2](Images/2.png)](#co_deploying_for_developers_CO5-2)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_deploying_for_developers_CO5-2)'
- en: You can set `revisionHistoryLimit` to specify the number of old ReplicaSets
    for this deployment that you want to retain. By default, Kubernetes stores the
    last 10 ReplicaSets.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以设置`revisionHistoryLimit`来指定您希望保留的此部署的旧 ReplicaSet 数量。默认情况下，Kubernetes 会存储最后
    10 个 ReplicaSet。
- en: Whenever the preceding specification is applied in a cluster, Kubernetes will
    take down all the current running pod instances, and once they are terminated,
    will bring up new ones. We do not need to set up a minimum and maximum number
    of instances, only the number of desired instances (4).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 每当在集群中应用前述规范时，Kubernetes 将关闭所有当前运行的 Pod 实例，一旦它们终止，将启动新的实例。我们不需要设置最小和最大实例数量，只需设置所需实例数（4）。
- en: In this example, Kubernetes does not delete the previous ReplicaSet immediately
    after performing an update. Instead, it keeps the ReplicaSet around with a replicas
    count of 0. If the deployment introduced a change that breaks the stability of
    the system, we can roll back to a previous working version by choosing from the
    old ReplicaSets.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，Kubernetes 在执行更新后不会立即删除先前的 ReplicaSet。相反，它会保留带有副本计数为 0 的 ReplicaSet。如果部署引入了破坏系统稳定性的更改，我们可以通过选择旧的
    ReplicaSets 中的一个回滚到以前的工作版本。
- en: 'You can find out the previous revisions by running the following command:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行以下命令了解之前的修订版本：
- en: '[PRE28]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'And roll back to a previous version by using the following:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 并通过以下方式回滚到先前的版本：
- en: '[PRE29]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Although this strategy is efficient in terms of memory and amount of CPU consumption,
    it introduces a gap in time when the microservice is unavailable.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种策略在内存和 CPU 消耗量方面是高效的，但在微服务不可用时引入了时间间隙。
- en: 'Another Kubernetes built-in strategy is `RollingUpdate`, where the current
    running instances are slowly replaced by the new ones:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个 Kubernetes 内置策略是`RollingUpdate`，其中当前运行的实例逐步被新实例替换：
- en: '[PRE30]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[![1](Images/1.png)](#co_deploying_for_developers_CO6-1)'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_deploying_for_developers_CO6-1)'
- en: Maximum number of Pods that can be unavailable when performing the deployment
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 执行部署时可以不可用的最大 Pod 数量
- en: '[![2](Images/2.png)](#co_deploying_for_developers_CO6-2)'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_deploying_for_developers_CO6-2)'
- en: Maximum number of Pods that can be created over the desired number of Pods
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在期望的 Pod 数量上创建的最大 Pod 数量
- en: '[![3](Images/3.png)](#co_deploying_for_developers_CO6-3)'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_deploying_for_developers_CO6-3)'
- en: Desired number of Pods
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: Pod 的期望数量
- en: By focusing on the maximum number of the unavailable Pods, this strategy safely
    upgrades your deployment, without experiencing any downtime. But, depending on
    your microservice startup time, the entire transition to the newer version of
    the deployment can take longer to complete. If the deployment introduces a change
    that breaks the stability of the system, Kubernetes will update the Deployment
    template but will keep the previous running Pods.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 通过关注不可用 Pod 的最大数量，这种策略可以安全地升级您的部署，而无需任何停机时间。但是，根据您的微服务启动时间，完全过渡到部署的新版本可能需要更长的时间。如果部署引入了破坏系统稳定性的更改，Kubernetes
    将更新部署模板但将保留先前运行的 Pod。
- en: Caution
  id: totrans-261
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The rolling deployment is the standard default deployment to Kubernetes if you
    do not fill in a strategy in the object `spec`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在对象`spec`中不填写策略，则滚动部署是 Kubernetes 的标准默认部署。
- en: If your application is using a database, you should consider the impact of having
    two application versions running simultaneously. Another disadvantage with this
    strategy is that during the upgrade, there will be a mix of old and new versions
    of the application. If you want to keep the zero downtime and avoid mixing application
    versions in production, take a look at the blue/green deployment technique.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序正在使用数据库，你应该考虑同时运行两个应用程序版本的影响。使用这种策略的另一个缺点是，在升级期间，将会存在新旧版本的应用程序混合。如果你想保持零停机并避免在生产中混合应用程序版本，请看一下蓝/绿部署技术。
- en: '*Blue/green deployment* is a strategy that reduces downtime and risk of failure
    by running two identical (production) environments named Blue and Green; see [Figure 8-2](#blue-green-setup).
    When using this deployment strategy, no new instances will serve user requests
    until all become available; at that moment, all old instances become instantly
    unavailable. You can achieve this by orchestrating services and routing requests.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '*蓝/绿部署*是一种通过运行两个相同（生产）环境命名为蓝色和绿色来减少停机时间和失败风险的策略；参见[图 8-2](#blue-green-setup)。当使用此部署策略时，新实例将不会为用户请求提供服务，直到所有实例都可用为止；在那一刻，所有旧实例立即变为不可用。你可以通过编排服务和路由请求来实现这一点。'
- en: '![Blue/Green deployment strategy](Images/dtjd_0802.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![蓝/绿部署策略](Images/dtjd_0802.png)'
- en: Figure 8-2\. Blue/green strategy
  id: totrans-266
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-2\. 蓝/绿策略
- en: 'Let’s observe how we can implement blue/green deployments by using standard
    Kubernetes objects:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用标准 Kubernetes 对象来实现蓝/绿部署：
- en: 'Apply the blue version of the microservice having the label `version: blue`.
    We will associate the convention of *blue deployment* by using the value of the
    label `version`:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '应用具有标签`version: blue`的微服务的蓝版本。我们将通过使用标签`version`的值来关联*蓝部署*的惯例：'
- en: '[PRE31]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Expose this deployment by using a Kubernetes Service. After this, traffic is
    served from the blue version:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用 Kubernetes Service 暴露此部署。之后，流量将从蓝版本提供：
- en: '[PRE33]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Apply the *green deployment* of a microservice having the label `version: green`:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '应用一个具有标签`version: green`的微服务的*绿部署*：'
- en: '[PRE34]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Switch the traffic from blue deployment to green by patching the Service object:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过修改 Service 对象将流量从蓝部署切换到绿部署：
- en: '[PRE36]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If the blue deployment is no longer needed, you can remove it by using `kubectl
    delete`.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果不再需要蓝部署，可以使用`kubectl delete`将其删除。
- en: Although this deployment strategy is more complex and requires more resources,
    you can shorten the time between software development and user feedback. This
    approach is less disruptive for experimenting with features; if any issues appear
    after a deployment, you can quickly route to a previous stable version.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种部署策略更复杂，需要更多资源，但你可以缩短软件开发和用户反馈之间的时间。这种方法对于试验功能来说更少干扰；如果在部署后出现任何问题，你可以快速切换到之前的稳定版本。
- en: Tip
  id: totrans-280
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: You can explore a blue/green deployment strategy with more cloud native tools
    that are compatible with Kubernetes, such as [Istio](https://istio.io) and [Knative](https://knative.dev).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用更多与 Kubernetes 兼容的云原生工具来探索蓝/绿部署策略，比如[Istio](https://istio.io)和[Knative](https://knative.dev)。
- en: The last strategy that we will look at is a *canary deployment*. This is a way
    to reduce risk and validate new system features by releasing software to a small
    percentage of users. Performing a canary deployment allows you to try out the
    new version of a microservice with a small user audience without replacing any
    of the existing instances of the application. To evaluate the behavior of the
    deployments (canary and existing), you should implement a load balancer configuration
    on top of the service instances and add weighted routing to choose how much traffic
    is routed to each resource.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看一下的最后一种策略是*金丝雀部署*。这是一种通过向小部分用户发布软件来减少风险并验证新系统功能的方法。执行金丝雀部署允许你尝试新版本的微服务，与应用程序的现有实例不发生任何替换的小用户群体。为了评估部署的行为（金丝雀和现有的），你应该在服务实例之上实现负载均衡器配置，并添加加权路由来选择将流量路由到每个资源的比例。
- en: Currently, the canary strategy can be achieved by adding an extra layer of tools
    ([Figure 8-3](#istio-canary-setup)). API gateways with weighted routing support
    let you manage your API endpoints and decide the amount of traffic routed toward
    them. Service mesh control planes like Istio are a solution compatible with Kubernetes
    that can help you to control service-to-service communication over a network and
    the percentage of user traffic to each service version.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，通过添加额外的工具层（[图 8-3](#istio-canary-setup)）可以实现金丝雀策略。带有加权路由支持的 API 网关可以帮助你管理
    API 端点，并决定向它们路由的流量量。像 Istio 这样的服务网格控制平面是与 Kubernetes 兼容的解决方案，可以帮助你控制网络上服务之间的通信和用户流量的百分比。
- en: '![Weighted traffic routing in Istio](Images/dtjd_0803.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![在 Istio 中加权流量路由](Images/dtjd_0803.png)'
- en: Figure 8-3\. Canary strategy using weighted traffic routing in Istio
  id: totrans-285
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-3\. 在 Istio 中使用加权流量路由的金丝雀策略
- en: If you still struggle to choose a deployment mechanism, check out [Table 8-3](#deployment_strategies),
    which summarizes characteristics of the previously discussed strategies.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍然在为选择部署机制而苦苦挣扎，请查看[表 8-3](#deployment_strategies)，它总结了先前讨论的策略的特性。
- en: Table 8-3\. Characteristics of the deployment strategies
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-3\. 部署策略的特性
- en: '|  | Re-create | Rolling update | Blue/green | Canary |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '|  | 重新创建 | 滚动更新 | 蓝绿部署 | 金丝雀发布 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| Out of the box in Kubernetes | Yes | Yes | No | No |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| Kubernetes 自带 | 是 | 是 | 否 | 否 |'
- en: '| Downtime occurrence | Yes | No | No | No |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| 发生停机时间 | 是 | 否 | 否 | 否 |'
- en: '| Rollback process | Manually roll out a previous version | Stop rollout and
    keep the previous version | Switch traffic to previous version | Delete canary
    instance |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| 回滚流程 | 手动回滚到先前版本 | 停止部署并保留先前版本 | 切换流量到先前版本 | 删除金丝雀实例 |'
- en: '| Traffic control | No | No | Yes | Yes |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| 流量控制 | 否 | 否 | 是 | 是 |'
- en: '| Traffic sent simultaneously to old and new version | No | Yes | No | Yes
    |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| 流量同时发送到旧版本和新版本 | 否 | 是 | 否 | 是 |'
- en: Managing Workloads in Kubernetes
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中管理工作负载
- en: 'An application running on Kubernetes is a *workload*. In the cluster, your
    workload will run on one or several Pods having a defined lifecycle. To simplify
    Pod lifecycle management, Kubernetes provides several built-in workload resources:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 运行在 Kubernetes 上的应用程序是一个*工作负载*。在集群中，你的工作负载将在一个或多个具有定义生命周期的 Pod 上运行。为了简化 Pod
    的生命周期管理，Kubernetes 提供了几种内置的工作负载资源：
- en: Deployment and ReplicaSet
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: Deployment 和 ReplicaSet
- en: Help manage a stateless application workload.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 帮助管理无状态应用程序的工作负载。
- en: StatefulSet
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: StatefulSet
- en: Enables you to run a stateful application either as a single instance or as
    a replicated set.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 可以让你以单个实例或复制集的形式运行有状态应用程序。
- en: Job and CronJob
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: Job 和 CronJob
- en: Define tasks that run to completion and then stop. These types of resources
    are useful when implementing batch-processing activities. Jobs are one-off tasks,
    while CronJobs run according to a schedule.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 定义运行完成后停止的任务。在执行批处理活动时，这些类型的资源非常有用。作业是一次性任务，而 CronJob 按计划运行。
- en: DaemonSet
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: DaemonSet
- en: Can help you to define Pods with functionalities impacting the entire node.
    Scheduling the workload using this type of resource is rare.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 可以帮助你定义影响整个节点的功能性 Pod。使用这种类型的资源调度工作负载是罕见的。
- en: Earlier, we generated and deployed Kubernetes manifests containing a Deployment
    specification, as typically microservices are stateless applications. But how
    can we prevent failure for those microservices that depend on an external service
    or persist their data in a database? Moreover, as a microservice codebase evolves,
    how can it use a fair share of memory and CPU?
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 早期，我们生成并部署了包含 Deployment 规范的 Kubernetes 清单，通常这些微服务是无状态应用程序。但是如何预防依赖外部服务或将其数据持久化在数据库中的微服务失败？此外，随着微服务代码库的演进，如何使用公平份额的内存和
    CPU？
- en: Setting Up Health Checks
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置健康检查
- en: 'Another benefit of working with distributed systems and in the cloud is that
    microservices independence often stimulates automated deployments. As automated
    deployments can occur several times per day, on multiple instances, you need a
    way to validate that your application is available and running as expected. Each
    increase in the number of components in the system brings with it an increase
    in the probability of failure: a deadlock, a host becoming unavailable, a hardware
    failure, etc. To detect issues before they propagate as outages, we can validate
    the status of a microservice by using health checks.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 与分布式系统和云中工作的另一个好处是，微服务的独立性通常会刺激自动化部署。由于自动化部署可能每天多次发生，且在多个实例上，因此您需要一种验证应用程序是否按预期可用和运行的方法。系统中组件数量的增加会增加故障的可能性：死锁、主机不可用、硬件故障等。为了在问题扩散为停机之前检测问题，我们可以通过健康检查验证微服务的状态。
- en: Health checks should span across the entire system, from application code to
    infrastructure. Infrastructure can use application health checks to determine
    when to serve traffic using readiness probes or to restart the container via liveness
    probes. You should know that a liveness probe does not always execute after the
    readiness probe succeeds. When your application needs additional time to initialize,
    you can define the amount of time in seconds to wait before executing the probe
    or use a startup probe to check if the container has started.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 健康检查应跨整个系统，从应用程序代码到基础设施。基础设施可以使用应用程序健康检查来确定何时使用就绪探针提供流量或通过存活探针重新启动容器。您应该知道，存活探针并不总是在就绪探针成功后执行。当您的应用程序需要额外的时间来初始化时，您可以定义等待多少秒后执行探针，或使用启动探针来检查容器是否已启动。
- en: 'At the Kubernetes level, the *kubelet* is the component that uses liveness,
    readiness, and startup probes to assess the state of your containers. The kubelet
    uses readiness probes to check when a container is ready to start accepting traffic,
    and liveness probes to know when to restart it. You can use any of these three
    mechanisms to implement liveness, readiness, or startup probes:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 层面，*kubelet* 是使用存活性、就绪性和启动探针来评估容器状态的组件。 kubelet 使用就绪探针来检查容器何时准备好接受流量，并使用存活探针来知道何时重新启动它。您可以使用这三种机制之一来实现存活性、就绪性或启动探针：
- en: Opening a TCP socket against a container
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开 TCP 套接字与容器的连接
- en: Making an HTTP request against a containerized application that exposes API
    endpoints
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向暴露 API 端点的容器化应用程序发出 HTTP 请求
- en: Running a command inside a container in case your application uses a protocol
    different from HTTP or TCP
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的应用程序使用不同于 HTTP 或 TCP 的协议，则在容器内运行命令
- en: Note
  id: totrans-313
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: With Kubernetes v1.23, a gRPC health probe mechanism is available as an alpha
    feature. Please keep an eye on the evolution of the [Kubernetes health probe documentation](https://oreil.ly/IDsqC).
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Kubernetes v1.23，gRPC 健康探针机制作为一项 alpha 功能可用。请注意关注 [Kubernetes 健康探针文档](https://oreil.ly/IDsqC)
    的演变。
- en: 'The simplest way of implementing a health check is to periodically evaluate
    the running application by sending requests to some of its API endpoints. You
    can determine the health of the system based on the response payload. Typically,
    these health endpoints are HTTP GET or HEAD requests that do not change the state
    of the system and perform a lightweight task. You can define a */health* endpoint
    in a RESTful API to check the internal status of your microservice or you can
    use framework-compatible dependencies:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 实施健康检查的最简单方法是定期评估正在运行的应用程序，通过向其一些 API 端点发送请求来确定系统的健康状况。通常，这些健康端点是 HTTP GET 或
    HEAD 请求，不会改变系统状态并执行轻量级任务。您可以在 RESTful API 中定义一个 */health* 端点来检查微服务的内部状态，或者您可以使用框架兼容的依赖项。
- en: The [Actuator](https://oreil.ly/rNxMx) module provides useful insight into a
    Spring environment running applications. Actuator has functions for health checking
    and gathers metrics by exposing multiple endpoints over HTTP and Java Management
    Extensions (JMX).
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '[执行器](https://oreil.ly/rNxMx) 模块为运行在 Spring 环境中的应用程序提供有用的见解。执行器具有健康检查和通过 HTTP
    和 Java 管理扩展（JMX）暴露多个端点来收集指标的功能。'
- en: You can add the Actuator module to your Spring Boot project as a Maven or Gradle
    dependency (see [Table 8-4](#actuator_dependency)) and can access the default
    health endpoints at */actuator/health*.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将执行器模块作为 Maven 或 Gradle 依赖项添加到您的 Spring Boot 项目中（参见 [表 8-4](#actuator_dependency)），并可以访问
    */actuator/health* 的默认健康端点。
- en: Table 8-4\. Actuator as Maven or Gradle dependency
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-4\. Actuator 作为 Maven 或 Gradle 依赖项示例
- en: '| Build tool | Definition |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| 构建工具 | 定义 |'
- en: '| --- | --- |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Maven |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| Maven |'
- en: '[PRE37]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '|'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Gradle |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| Gradle |'
- en: '[PRE38]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '|'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: With Actuator, you can check the health of individual components with health
    indicators or have a composite health check with composite health contributors.
    You can work with several predefined health indicators, including `DataSourceHealth​Indi⁠cator`,
    `MongoHealthIndicator`, `RedisHealthIndicator`, and `CassandraHealthIndicator`.
    These implement the `HealthIndicator` interface, which enables you to check the
    health of that component. For example, if your application is using a database
    to persist data, the database health indicator will be automatically added by
    Spring Boot if it detects a datasource. The health check consists of creating
    a connection to a database to perform a simple query.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Actuator，你可以使用健康指标检查各个组件的健康状态，或者使用组合健康贡献者进行组合健康检查。你可以使用多个预定义的健康指标，包括 `DataSourceHealthIndicator`、`MongoHealthIndicator`、`RedisHealthIndicator`
    和 `CassandraHealthIndicator`。这些实现了 `HealthIndicator` 接口，使你能够检查该组件的健康状态。例如，如果你的应用程序使用数据库来持久化数据，当
    Spring Boot 检测到数据源时，数据库健康指标将会自动添加。健康检查包括创建到数据库的连接以执行简单查询。
- en: Although using the built-in health indicators saves you development time, sometimes
    you should investigate the health of dependent systems aggregated together. Spring
    Boot will aggregate all health indicators it finds in the application context
    under the `/actuator/health` endpoint. Yet, if a health check on one of the dependent
    systems is unsuccessful, the composite probe will fail. For such cases, you should
    consider implementing the `CompositeHealthContributor` interface in a Spring bean
    or treating the potential failure by offering a fallback response.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用内置的健康指标可以节省开发时间，但有时候你需要调查整合在一起的依赖系统的健康情况。Spring Boot 将在应用程序上下文中的 `/actuator/health`
    端点下汇总所有找到的健康指标。然而，如果某个依赖系统的健康检查失败，组合探针将会失败。对于这种情况，你应该考虑在一个 Spring bean 中实现 `CompositeHealthContributor`
    接口，或者通过提供回退响应来处理潜在的失败。
- en: The MicroProfile Health module allows services to report their health, and it
    publishes the overall health status to a defined endpoint. Quarkus applications
    can use the [SmallRye Health extension](https://oreil.ly/r9QuE), which is an implementation
    of the Eclipse MicroProfile Health Check specification. You can add the extension
    to your Maven or Gradle configuration by using snippets from [Table 8-5](#smallrye_health_dependency).
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile Health 模块允许服务报告其健康状态，并将整体健康状态发布到定义的端点。Quarkus 应用程序可以使用 [SmallRye
    Health 扩展](https://oreil.ly/r9QuE)，这是 Eclipse MicroProfile 健康检查规范的实现。你可以通过 [表
    8-5](#smallrye_health_dependency) 中的片段将该扩展添加到你的 Maven 或 Gradle 配置中。
- en: Table 8-5\. SmallRye Health as Maven or Gradle dependency
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-5\. SmallRye Health 作为 Maven 或 Gradle 依赖项示例
- en: '| Build tool | Definition |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| 构建工具 | 定义 |'
- en: '| --- | --- |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Maven |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| Maven |'
- en: '[PRE39]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '|'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Gradle |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| Gradle |'
- en: '[PRE40]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '|'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: All health-check procedures in the application are accumulated in the `/q/health`
    REST endpoint. Some Quarkus extensions provide default health checks. This means
    that the extension can automatically register its health checks.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序中的所有健康检查过程都积累在 `/q/health` REST 端点中。一些 Quarkus 扩展提供默认的健康检查。这意味着扩展可以自动注册其健康检查。
- en: For example, when using a Quarkus datasource, the `quarkus-agroal` extension
    automatically registers a readiness health check that will validate that datasource.
    You can disable automatic registration of the extension health check via the property
    `quarkus.health.extensions.enabled`.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在使用 Quarkus 数据源时，`quarkus-agroal` 扩展会自动注册一个就绪状态健康检查来验证数据源。你可以通过属性 `quarkus.health.extensions.enabled`
    禁用扩展健康检查的自动注册。
- en: When you investigate the health of dependent systems, you can define your own
    health checks by implementing `org.eclipse.microprofile.health.HealthCheck` and
    use `@Liveness`, `@Readiness`, and `@Startup` to distinguish the role of each
    check. A composite health check inspects the condition of the dependent systems
    aggregated together. Yet this approach is counterproductive if one of the dependent
    systems fails. A more proactive strategy involves offering a fallback response
    and monitoring a set of metrics showing the application’s health. These are more
    useful as they offer early notifications about a system’s deteriorating health,
    giving us time to take mitigating measures.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 当您调查依赖系统的健康状况时，您可以通过实现 `org.eclipse.microprofile.health.HealthCheck` 来定义自己的健康检查，并使用
    `@Liveness`、`@Readiness` 和 `@Startup` 来区分每个检查的角色。 复合健康检查会检查聚合在一起的依赖系统的条件。 然而，如果其中一个依赖系统失败，这种方法是适得其反的。
    更积极的策略涉及提供备用响应并监控显示应用程序健康状况的一组指标。 这些更有用，因为它们提供关于系统健康恶化的早期通知，为我们提供采取缓解措施的时间。
- en: Tip
  id: totrans-342
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'Besides the automatic readiness probes when adding specific extensions, Quarkus
    comes with some health-check implementations for you to check the status of various
    components:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在添加特定扩展时的自动就绪探针外，Quarkus 还为您提供了一些用于检查各种组件状态的健康检查实现：
- en: '`SocketHealthCheck` checks if the host is reachable using a socket.'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SocketHealthCheck` 使用 socket 检查主机是否可达。'
- en: '`UrlHealthCheck` checks if the host is reachable using an HTTP URL connection.'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UrlHealthCheck` 使用 HTTP URL 连接检查主机是否可达。'
- en: '`InetAddressHealthCheck` checks if the host is reachable using the `InetAddress.isReachable`
    method.'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InetAddressHealthCheck` 使用 `InetAddress.isReachable` 方法检查主机是否可达。'
- en: 'When you implement health checks using REST endpoints at the application level,
    you will likely invoke those using an HTTP request from a probe. Kubernetes probes
    consult these endpoints to determine the health of your container. A probe has
    configuration parameters to control its behavior, including the following:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用级别使用 REST 端点实现健康检查时，您可能会通过探针使用 HTTP 请求调用这些端点。 Kubernetes 探针会查阅这些端点以确定容器的健康状况。
    探针具有配置参数来控制其行为，包括以下内容：
- en: How often to execute the probe (`periodSeconds`)
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多久执行一次探测（`periodSeconds`）。
- en: How long to wait after starting the container to initiate the probe (`initialDelaySeconds`)
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动容器后等待多少秒后开始探测（`initialDelaySeconds`）。
- en: Number of seconds after which the probe is considered failed (`timeoutSeconds`)
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探针被视为失败的秒数（`timeoutSeconds`）之后的秒数。
- en: Number of times the probe can fail before giving up (`failureThreshold`)
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探针可以放弃之前失败的次数（`failureThreshold`）。
- en: Minimum consecutive successes for the probe to be considered successful after
    having failed (`successThreshold`)
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探针被视为成功后的最小连续成功次数（`successThreshold`）。
- en: 'The tools we have previously used to generate Kubernetes manifests (Dekorate
    and Eclipse JKube) can help you start working with health probes. For example,
    let’s add the Actuator dependency to the Spring Boot project and package the application
    by using the following:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我们先前用于生成 Kubernetes 清单的工具（Dekorate 和 Eclipse JKube）可以帮助您开始使用健康探针。 例如，让我们将 Actuator
    依赖项添加到 Spring Boot 项目中，并使用以下方式打包应用程序：
- en: '[PRE41]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The Kubernetes manifest file from *target/classes/dekorate/* will contain specifications
    for health probes:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 *target/classes/dekorate/* 的 Kubernetes 清单文件将包含健康探针的规范：
- en: '[PRE42]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[![1](Images/1.png)](#co_deploying_for_developers_CO7-1)'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_deploying_for_developers_CO7-1)'
- en: Declaration of readiness and liveness probe is within the container specification.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 就容器规范而言，声明就绪和存活探针。
- en: '[![2](Images/2.png)](#co_deploying_for_developers_CO7-2)'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_deploying_for_developers_CO7-2)'
- en: The probe can fail three times before giving up.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 探针在放弃之前可以失败三次。
- en: '[![3](Images/3.png)](#co_deploying_for_developers_CO7-3)'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_deploying_for_developers_CO7-3)'
- en: The probe should make an HTTP GET request against the container.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 探针应该对容器进行 HTTP GET 请求。
- en: '[![4](Images/4.png)](#co_deploying_for_developers_CO7-4)'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_deploying_for_developers_CO7-4)'
- en: Wait 0 seconds after starting the container to initiate the probe.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 等待容器启动后 0 秒开始探测。
- en: '[![5](Images/5.png)](#co_deploying_for_developers_CO7-5)'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](Images/5.png)](#co_deploying_for_developers_CO7-5)'
- en: Execute the probe every 30 seconds.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 每 30 秒执行一次探测。
- en: '[![6](Images/6.png)](#co_deploying_for_developers_CO7-6)'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](Images/6.png)](#co_deploying_for_developers_CO7-6)'
- en: Minimum one consecutive success for the probe to be considered successful after
    having failed.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在失败后，探针被视为成功的最小连续成功次数。
- en: '[![7](Images/7.png)](#co_deploying_for_developers_CO7-7)'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](Images/7.png)](#co_deploying_for_developers_CO7-7)'
- en: After 10 seconds, the probe is considered failed.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 10 秒后，探测被视为失败。
- en: Tip
  id: totrans-371
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Depending on the tech stack that you use, [Eclipse JKube](https://oreil.ly/guUR9)
    has a list of enrichers that can help you adjust health checks.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您使用的技术堆栈不同，[Eclipse JKube](https://oreil.ly/guUR9) 提供了一系列增强器，可帮助您调整健康检查。
- en: Now that you have used application health checks to ensure that the system is
    performing as expected, we can look into fine-tuning resource quotas for containerized
    applications.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经使用应用程序健康检查确保系统正常运行，我们可以进一步调整容器化应用程序的资源配额。
- en: Adjusting Resource Quotas
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整资源配额
- en: A common practice is to have several users or teams share a cluster with a fixed
    number of nodes. To facilitate a fair share of resources for each deployed application,
    cluster administrators establish a `ResourceQuota` object. This object provides
    constraints that limit resource consumption for a namespace.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见做法是让多个用户或团队共享一个具有固定节点数量的集群。为了为每个部署的应用程序提供公平的资源份额，集群管理员会建立一个 `ResourceQuota`
    对象。此对象提供了限制命名空间内资源消耗的约束。
- en: When you define specifications for a Pod, you can specify the amount of resources
    each container will need. Requests define the minimum amount of resources that
    containers need, while limits define the maximum amount of resources that the
    container can consume. The kubelet enforces those limits for the running container.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 当您为 Pod 定义规范时，可以指定每个容器需要的资源量。请求（Requests）定义容器需要的最小资源量，而限制（Limits）定义容器可以消耗的最大资源量。Kubelet
    会强制执行这些限制，以确保运行中的容器遵循这些规定。
- en: 'For a container, the common resources to specify are CPU and memory. For each
    container of a Pod, you can define them as follows:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 对于容器来说，常见的资源是 CPU 和内存。对于 Pod 的每个容器，您可以按以下方式定义它们：
- en: '`spec.containers[].resources.limits.cpu`'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec.containers[].resources.limits.cpu`'
- en: '`spec.containers[].resources.limits.memory`'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec.containers[].resources.limits.memory`'
- en: '`spec.containers[].resources.requests.cpu`'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec.containers[].resources.requests.cpu`'
- en: '`spec.containers[].resources.requests.memory`'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec.containers[].resources.requests.memory`'
- en: In Kubernetes, the CPU is assigned with values in millicores or millicpu, and
    memory is measured in bytes. The kubelet collects metrics such as CPU and memory
    from your Pods and can check them using [Metrics Server](https://oreil.ly/31lKM).
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中，CPU 以毫核（millicores 或 millicpu）的值分配，而内存以字节为单位。Kubelet 会从您的 Pod
    中收集诸如 CPU 和内存之类的指标，并可以使用 [Metrics Server](https://oreil.ly/31lKM) 进行检查。
- en: 'As your containers start to compete for resources, you should carefully divide
    the CPU and memory based on limits and requests. To achieve that, you need the
    following:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的容器开始竞争资源时，应根据限制和请求仔细划分 CPU 和内存。为了实现这一点，您需要以下内容：
- en: A tool or practice to programmatically generate traffic for your application.
    For local development purposes, you can start with tools like [hey](https://oreil.ly/rJK0q)
    or [Apache JMeter](https://oreil.ly/pvNfd).
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种用于为应用程序生成流量的工具或实践。对于本地开发目的，您可以从诸如 [hey](https://oreil.ly/rJK0q) 或 [Apache
    JMeter](https://oreil.ly/pvNfd) 这样的工具开始。
- en: A tool or practice to collect metrics and decide how to set requests and limits
    for CPU and memory. For example, on local minikube installations, you can enable
    the [`metrics-server` add-on](https://oreil.ly/9Ix3p).
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种收集指标并决定如何为 CPU 和内存设置请求和限制的工具或实践。例如，在本地的 Minikube 安装中，您可以启用 [`metrics-server`
    add-on](https://oreil.ly/9Ix3p)。
- en: 'Next, you can add the resource limits and requests to your existing container
    specification. You can also have them generated if you are using Dekorate and
    have them defined at the application configuration level. For example, in the
    case of Quarkus, you can add the Kubernetes extension that includes Dekorate:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您可以将资源限制和请求添加到现有容器规范中。如果您使用 Dekorate 并在应用程序配置级别定义它们，则可以生成它们。例如，在 Quarkus
    的情况下，您可以添加包含 Dekorate 的 Kubernetes 扩展：
- en: '[PRE43]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'and configure them in *src/main/resources/application.properties*:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 并在 *src/main/resources/application.properties* 中进行配置：
- en: '[PRE44]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'These configurations can be customized when packaging the application. After
    running `mvn clean package`, note that the newly generated Deployment object includes
    resource specifications:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 这些配置可以在打包应用程序时进行定制。在运行 `mvn clean package` 后，请注意新生成的 Deployment 对象包含资源规格：
- en: '[PRE45]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[![1](Images/1.png)](#co_deploying_for_developers_CO8-1)'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_deploying_for_developers_CO8-1)'
- en: The container is limited to use maximum 200 millicores (m) and 230 mebibytes
    (MiB).
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的最大资源限制为 200 毫核（m）和 230 Mebibytes（MiB）。
- en: '[![2](Images/2.png)](#co_deploying_for_developers_CO8-3)'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_deploying_for_developers_CO8-3)'
- en: The container can request a minimum 100 m and 115 MiB.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 容器可以请求最低 100 m 和 115 MiB。
- en: Caution
  id: totrans-396
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If a container specifies a memory limit but does not specify a memory request,
    Kubernetes automatically assigns a memory request that matches the limit. If a
    container specifies a CPU limit but does not specify a CPU request, Kubernetes
    automatically assigns a CPU request that matches the limit.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 如果容器指定了内存限制但未指定内存请求，则 Kubernetes 会自动分配与限制匹配的内存请求。如果容器指定了 CPU 限制但未指定 CPU 请求，则
    Kubernetes 会自动分配与限制匹配的 CPU 请求。
- en: Working with Persistent Data Collections
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与持久化数据集合一起工作
- en: A basic principle of microservices is that each service manages its own data.
    If services share the same underlying data schemas, unintentional coupling between
    services can occur, thus endangering independent deployments.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务的一个基本原则是每个服务管理自己的数据。如果服务共享相同的底层数据模式，则服务之间可能会发生意外耦合，从而危及独立部署。
- en: If you are working with NoSQL databases, like CouchDB or MongoDB, don’t worry
    about database changes, as altering the data structure can be performed from application
    code.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 NoSQL 数据库，比如 CouchDB 或 MongoDB，请不要担心数据库的变化，因为可以从应用程序代码中进行数据结构的修改。
- en: On the other hand, if you are using a standard SQL database, you can use tools
    like [Flyway](https://flywaydb.org) or [Liquibase](https://liquibase.org) to handle
    schema changes. These tools can help you generate migration scripts and keep track
    of which of those were run in the database and which were not yet applied. When
    any of these migration tools is invoked, it will scan the available migration
    scripts, identify ones that have not been run on a particular database, and then
    execute those.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果您正在使用标准的 SQL 数据库，您可以使用类似于 [Flyway](https://flywaydb.org) 或 [Liquibase](https://liquibase.org)
    的工具来处理模式更改。这些工具可以帮助您生成迁移脚本，并跟踪哪些脚本在数据库中运行，哪些尚未应用。当调用任何这些迁移工具时，它将扫描可用的迁移脚本，识别尚未在特定数据库上运行的脚本，然后执行这些脚本。
- en: 'When investigating the options from [“Choose and Implement a Deployment Strategy”](#choosing-and-implementing-a-deployment-strategy),
    you should consider the following:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在从 [“选择并实施部署策略”](#choosing-and-implementing-a-deployment-strategy) 中探索选项时，您应该考虑以下内容：
- en: Both database schema versions must work well with the application versions used
    during the deployment phase.
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署阶段使用的应用程序版本必须与数据库模式版本相匹配。
- en: Ensure that you have a schema compatibility with the previous working version
    of your containerized application.
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保您的容器化应用程序的前一个工作版本与之前的模式兼容。
- en: Changing a column’s data type requires converting all values stored according
    to the old column definition.
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改列的数据类型需要转换按照旧列定义存储的所有值。
- en: Renaming a column, a table, or a view are backward-incompatible operations unless
    you use triggers or a programmatic migration script.
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重命名列、表或视图是不兼容的操作，除非使用触发器或编程化迁移脚本。
- en: By separating application deployments from applying migration scripts, you can
    independently manage your microservices. Most of the time, cloud providers offer
    several datasources as part of their cloud service. These types of offerings might
    be the right option for your workloads if you are looking for database solutions
    without having to manage and maintain the underlying layers. Nevertheless, also
    consider how to protect, manage, and secure sensitive data when using a managed
    database service.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将应用程序部署与应用迁移脚本分离，您可以独立管理您的微服务。大多数情况下，云服务提供商作为其云服务的一部分提供几种数据源。如果您正在寻找无需管理和维护底层层的数据库解决方案，这些类型的提供可能是您的工作负载的正确选择。然而，还要考虑在使用托管数据库服务时如何保护、管理和安全敏感数据。
- en: Should databases run in Kubernetes? The answer to this question depends on how
    the Kubernetes way to manage workload and traffic aligns with operational steps
    to maintain the database. Because maintaining databases requires more complex
    sequences of actions, the Kubernetes community resolved these challenges by implementing
    operators that incorporate logical domain and operational runbooks needed to run
    databases in Kubernetes. [OperatorHub.io](https://operatorhub.io) has an extensive
    list of operators.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库是否应该在 Kubernetes 中运行？这个问题的答案取决于 Kubernetes 的管理工作负载和流量的方式与维护数据库的操作步骤如何一致。因为维护数据库需要更复杂的操作序列，Kubernetes
    社区通过实现运算符来解决这些挑战，这些运算符包含在 Kubernetes 中运行数据库所需的逻辑域和操作运行簿。[OperatorHub.io](https://operatorhub.io)
    提供了一个庞大的运算符列表。
- en: Best Practices for Monitoring, Logging, and Tracing
  id: totrans-409
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控、日志记录和跟踪的最佳实践
- en: So far, we’ve been focusing on making containerized applications operational.
    On your local machine, you are the only end user of your work, but your application
    will face the rest of the world in production. To have your application aligned
    to the expectations of all your end users, you should observe its evolution in
    time under different conditions and environment instances.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直致力于使容器化应用程序运行。在您的本地计算机上，您是您工作的唯一终端用户，但您的应用程序将在生产环境中面对世界的其余部分。为了使您的应用程序与所有终端用户的期望保持一致，您应该观察其在不同条件和环境实例下的演变。
- en: In recent years, the term *observability* has become popular in the IT industry,
    but chances are that you have already been working on *observable* Java applications.
    Observability is the ability to measure a system’s current state based on the
    telemetry data it generates, such as logs, metrics, and traces. If you have implemented
    auditing, exception handling, or event logging, you have already started to observe
    your application behavior. Furthermore, to build observability for your distributed
    system, you will likely use different tools to implement monitoring, logging,
    and tracing practices.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，“可观测性”这个术语在IT行业变得流行，但很有可能您已经在开发“可观测”的Java应用程序。可观测性是基于系统生成的遥测数据（如日志、度量和跟踪）来衡量系统当前状态的能力。如果您已经实施了审计、异常处理或事件日志记录，那么您已经开始观察应用程序的行为。此外，为了为您的分布式系统构建可观测性，您可能会使用不同的工具来实现监控、日志记录和跟踪实践。
- en: Note
  id: totrans-412
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You should observe applications, networks, and infrastructures that you and
    your team(s) are responsible for, regardless of the tools used to implement them.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 无论使用何种工具实现，您和您的团队负责的应用程序、网络和基础设施都应该进行观察。
- en: Applications and the underlying infrastructure can produce useful metrics, logs,
    and traces to correctly observe a system. As shown in [Figure 8-4](#observability-overview),
    collecting this telemetry data contributes to visualizing the state of the system
    and to triggering notifications when a part of your system is underperforming.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序和底层基础设施可以生成有用的度量、日志和跟踪信息，以正确观察系统。如 [图 8-4](#observability-overview) 所示，收集这些遥测数据有助于可视化系统状态，并在系统的某一部分表现不佳时触发通知。
- en: '![Observability overview](Images/dtjd_0804.png)'
  id: totrans-415
  prefs: []
  type: TYPE_IMG
  zh: '![可观测性概览](Images/dtjd_0804.png)'
- en: Figure 8-4\. Gathering metrics, logs, and traces from applications and infrastructure
  id: totrans-416
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8-4\. 从应用程序和基础设施中收集度量、日志和跟踪信息
- en: Alerts help you acknowledge an unforeseen scenario and implement a recovery
    mechanism if the unexpected conditions reoccur. You can use distribution of notifications
    to identify a pattern in the normal workflow of the system. This pattern can further
    help you automate the recovery mechanism and use it whenever the alert is received.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 警报帮助您确认意外情况，并在意外情况再次发生时实施恢复机制。您可以使用通知的分发来识别系统正常工作流程中的模式。这种模式进一步帮助您自动化恢复机制，并在收到警报时使用它。
- en: As observability measures the state of a distributed system, you can have it
    as input to repair the faulty states of your microservices; see [Figure 8-5](Images/#observation-to-automatic-recovery).
    Kubernetes has a built-in self-healing mechanism that includes restarting failed
    containers, disposing of unhealthy containers, or not routing traffic to Pods
    that are not ready to serve traffic. At the node level, the control plane watches
    over the state of the worker nodes. Some practices for automating the recovery
    mechanism involve extending the Kubernetes self-healing mechanism by utilizing
    Job and DaemonSet resources. For example, you can use a DaemonSet to run a node-monitoring
    daemon on every worker, while a Job creates one or more Pods and retries execution
    of those until a specified number successfully terminate.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 由于可观测性可以衡量分布式系统的状态，您可以将其作为修复微服务故障状态的输入；参见 [图 8-5](Images/#observation-to-automatic-recovery)。
    Kubernetes具有内置的自我修复机制，其中包括重新启动失败的容器，处置不健康的容器，或者不将流量路由到尚未准备好提供流量的Pod。在节点级别，控制平面监视工作节点的状态。一些自动化恢复机制的做法涉及通过利用Job和DaemonSet资源扩展Kubernetes自我修复机制。例如，您可以使用DaemonSet在每个工作节点上运行一个节点监控守护程序，而Job则创建一个或多个Pod，并重试执行这些Pod直到指定数量成功终止。
- en: '![Observation to automatic recovery](Images/dtjd_0805.png)'
  id: totrans-419
  prefs: []
  type: TYPE_IMG
  zh: '![观察到自动恢复](Images/dtjd_0805.png)'
- en: Figure 8-5\. Improving from observation to automating recovery
  id: totrans-420
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8-5\. 从观察到自动恢复的改进
- en: Observability also helps you measure the state of the system when traffic spikes
    occur. Applications that respond with delay induce frustrations in end users.
    In such cases, you should investigate how you can scale your containerized applications.
    Moreover, autoscaling eliminates the need to respond manually to traffic spikes
    that need new resources and instances by automatically changing their active number.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 当流量激增时，可观性还帮助您测量系统状态。响应延迟的应用程序会引起终端用户的不满。在这种情况下，您应该调查如何扩展您的容器化应用程序。此外，自动缩放消除了手动响应需要新资源和实例的流量激增的必要性，它会自动更改它们的活动数量。
- en: In Kubernetes, a HorizontalPodAutoscaler (HPA) resource automatically updates
    a workload resource like Deployment, aiming to scale the workload to match demand
    automatically. A HorizontalPodAutoscaler resource responds to increased load by
    deploying more Pods. If the load diminishes and the number of Pods is above the
    minimum configured, the HorizontalPodAutoscaler requires the Deployment resource
    to scale down.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中，HorizontalPodAutoscaler (HPA) 资源会自动更新工作负载资源，如 Deployment，以自动缩放工作负载以匹配需求。HorizontalPodAutoscaler
    资源通过部署更多的 Pods 来响应增加的负载。如果负载减少且 Pod 数量高于最小配置，则 HorizontalPodAutoscaler 要求 Deployment
    资源进行缩减。
- en: 'As explained in the [Kubernetes documentation](https://oreil.ly/UWebg), the
    algorithm HorizontalPodAutoscaler uses the ratio of the desired metric value to
    the current metric value:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 正如 [Kubernetes 文档](https://oreil.ly/UWebg) 中所解释的，HorizontalPodAutoscaler 算法使用期望度量值与当前度量值的比率：
- en: '[PRE46]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To demonstrate how the preceding algorithm works when you set up a HorizontalPodAutoscaler
    resource, let’s reuse the example from [“Adjusting Resource Quotas”](#adjusting-resource-quotas),
    where we adjusted resource quotas:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示在设置 HorizontalPodAutoscaler 资源时前述算法的工作原理，让我们重用来自 [“调整资源配额”](#adjusting-resource-quotas)
    的示例，在该示例中我们调整了资源配额：
- en: '[PRE47]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Each Pod using the previous configuration can request a minimum 100 m for CPU.
    You can set up the HorizontalPodAutoscaler to maintain an average CPU utilization
    across all Pods of 80% for this deployment by using the following command:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 每个使用上述配置的 Pod 可以请求最小 100 m 的 CPU。您可以使用以下命令设置 HorizontalPodAutoscaler，以保持此部署中所有
    Pods 的平均 CPU 利用率为 80%：
- en: '[PRE48]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Assuming that the current metric value for CPU is 320 m and the desired value
    is 160 m, the number of replicas needed is 320 / 160 = 2.0. Based on the HorizontalPodAutoscaler
    configuration, the Deployment updates the ReplicaSet and then the ReplicaSet adds
    Pods to match the workload need. If the current metric value for CPU decreases
    at 120 m, the number of replicas needed will be 120 / 160 = 0.75, and the scale-down
    to one replica will occur gradually.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 假设当前 CPU 的度量值为 320 m，期望值为 160 m，所需的副本数为 320 / 160 = 2.0。基于 HorizontalPodAutoscaler
    配置，Deployment 更新 ReplicaSet，然后 ReplicaSet 添加 Pod 以匹配工作负载需求。如果当前 CPU 的度量值降至 120
    m，则所需的副本数将为 120 / 160 = 0.75，并且会逐渐缩减到一个副本。
- en: Another option to scale with Kubernetes is to use *vertical scaling*, which
    means to match the workload by assigning more resources to the Pods that are already
    running. [VerticalPodAutoscaler](https://oreil.ly/vTegk) (VPA) needs to be installed
    and enabled in order to further use its policies. To avoid undefined behavior
    over your Pods, do not use VerticalPodAutoscaler and HorizontalPodAutoscaler simultaneously
    to adjust CPU or memory of resources.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Kubernetes 进行缩放的另一种选项是使用*垂直缩放*，这意味着通过为已运行的 Pods 分配更多资源来匹配工作负载。[VerticalPodAutoscaler](https://oreil.ly/vTegk)
    (VPA) 需要被安装并启用以进一步使用其策略。为了避免在您的 Pods 上出现未定义的行为，请不要同时使用 VerticalPodAutoscaler 和
    HorizontalPodAutoscaler 来调整资源的 CPU 或内存。
- en: Let’s look into some monitoring, logging, and tracing recommendations to understand
    observability better when deploying, scaling, and maintaining containerized applications.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一些监控、日志记录和跟踪建议，以更好地理解在部署、扩展和维护容器化应用程序时的可观性。
- en: Monitoring
  id: totrans-432
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监控
- en: You can use monitoring to observe a system in near real-time. Typically, this
    practice involves setting up a technical solution that can gather logs and predefined
    sets of metrics, as shown in [Figure 8-6](#pull-and-query-metrics).
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用监控来实时观察系统。通常，这种做法涉及设置一个技术解决方案，该解决方案可以收集日志和预定义的一组指标，如 [图 8-6](#pull-and-query-metrics)
    所示。
- en: '![Pulling and querying metrics](Images/dtjd_0806.png)'
  id: totrans-434
  prefs: []
  type: TYPE_IMG
  zh: '![拉取和查询指标](Images/dtjd_0806.png)'
- en: Figure 8-6\. Pulling and querying metrics
  id: totrans-435
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-6\. 拉取和查询指标
- en: '*Metrics* are numeric values of system properties over time, like maximum Java
    heap memory available or the total number of garbage collections that occurred.
    [Table 8-6](#metrics_types) shows which metrics can help you when monitoring a
    system.'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '*度量指标* 是系统属性随时间变化的数值，例如可用的最大Java堆内存或发生的垃圾收集总数。[表 8-6](#metrics_types) 显示了在监视系统时哪些指标可以帮助您。'
- en: Table 8-6\. General types of metrics
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-6\. 指标的一般类型
- en: '| Name | Description |'
  id: totrans-438
  prefs: []
  type: TYPE_TB
  zh: '| Name | Description |'
- en: '| --- | --- |'
  id: totrans-439
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| *Counter* | A cumulative value based on incrementing an integer |'
  id: totrans-440
  prefs: []
  type: TYPE_TB
  zh: '| *计数器* | 基于递增整数的累计值 |'
- en: '| *Timer* | Measures both the count of timed events and the total time of all
    timed events |'
  id: totrans-441
  prefs: []
  type: TYPE_TB
  zh: '| *计时器* | 测量定时事件的计数和所有定时事件的总时间 |'
- en: '| *Gauge* | A single numerical value that can go up and down arbitrarily |'
  id: totrans-442
  prefs: []
  type: TYPE_TB
  zh: '| *计量表* | 一个可以任意上下波动的单一数值 |'
- en: '| *Histogram* | Measures distribution of values in a stream of data |'
  id: totrans-443
  prefs: []
  type: TYPE_TB
  zh: '| *直方图* | 测量数据流中值的分布 |'
- en: '| *Meter* | Indicates the rate at which a set of events occur |'
  id: totrans-444
  prefs: []
  type: TYPE_TB
  zh: '| *计量器* | 表示事件集发生速率 |'
- en: A few popular Java libraries for working with metrics include MicroProfile Metrics,
    Spring Boot Actuator, and Micrometer. For a better overview of your system behavior,
    you can collect and query these metrics with tools such as [Prometheus](https://prometheus.io).
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 一些流行的Java库用于处理指标，包括MicroProfile Metrics、Spring Boot Actuator和Micrometer。为了更好地了解系统行为，您可以使用诸如[Prometheus](https://prometheus.io)之类的工具收集和查询这些指标。
- en: To provide you with an example, we will reuse [Example 8-1](#example_0801),
    expose its metrics under */actuator/prometheus*, and send those to Prometheus
    by generating the container image and Kubernetes resources using Eclipse JKube.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 为了举例说明，我们将重新使用[示例 8-1](#example_0801)，将其指标暴露在*/actuator/prometheus*下，并通过使用Eclipse
    JKube生成容器镜像和Kubernetes资源将其发送到Prometheus。
- en: 'Let’s start by adding the Micrometer registry dependency, which specifically
    enables Prometheus support:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从添加Micrometer注册表依赖项开始，特别是启用Prometheus支持：
- en: '[PRE49]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Next, you need to instruct Spring Boot’s Actuator which endpoints it should
    expose by adding this line to *src/main/resources/application.properties*:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要通过将此行添加到*src/main/resources/application.properties*来指示Spring Boot的Actuator应该公开哪些端点：
- en: '[PRE50]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The Spring Boot application exposes the metrics under */actuator/prometheus*.
    Metrics related to JVM are also available at */actuator/prometheus*, such as `jvm.gc.pause`
    that measures garbage collection pause times. To further expose these metrics
    at the container and Kubernetes resource level, we can customize the Eclipse JKube
    setup with the following:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot应用程序在*/actuator/prometheus*下公开指标。与JVM相关的指标也可以在*/actuator/prometheus*下找到，例如`jvm.gc.pause`，用于测量垃圾收集暂停时间。为了进一步在容器和Kubernetes资源级别公开这些指标，我们可以通过以下方式自定义Eclipse
    JKube设置：
- en: '[PRE51]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[![1](Images/1.png)](#co_deploying_for_developers_CO9-1)'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_deploying_for_developers_CO9-1)'
- en: Execute this configuration with the `k8s:resource` goal.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`k8s:resource`目标执行此配置。
- en: '[![2](Images/2.png)](#co_deploying_for_developers_CO9-2)'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_deploying_for_developers_CO9-2)'
- en: Adjust the generated Docker image to expose the Prometheus port.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 调整生成的Docker镜像以公开Prometheus端口。
- en: '[![3](Images/3.png)](#co_deploying_for_developers_CO9-3)'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_deploying_for_developers_CO9-3)'
- en: Expose the 9779 port at the container-image level and have it in Kubernetes
    resources annotations.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器镜像级别公开9779端口，并在Kubernetes资源注释中进行配置。
- en: '[![4](Images/4.png)](#co_deploying_for_developers_CO9-4)'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_deploying_for_developers_CO9-4)'
- en: Generate Kubernetes resources helpful for Spring Boot applications.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 生成适用于Spring Boot应用程序的Kubernetes资源。
- en: 'To build the container image and generate the Kubernetes resources, run the
    following command:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建容器镜像并生成Kubernetes资源，请运行以下命令：
- en: '[PRE52]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The Kubernetes resources generated at *target/classes/META-INF/jkube/kubernetes.yml*
    will contain the Prometheus annotations controlling the metrics collection process:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的Kubernetes资源位于*target/classes/META-INF/jkube/kubernetes.yml*，其中包含控制度量收集过程的Prometheus注释：
- en: '[PRE53]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Once you deploy the generated resources, you can use a custom Prometheus query
    (PromQL) to query different metrics. For example, you can pick the `jvm.gc.pause`
    metric and run the following PromQL query to check the average time spent in garbage
    collection by cause:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦部署生成的资源，您可以使用自定义Prometheus查询（PromQL）来查询不同的指标。例如，您可以选择`jvm.gc.pause`指标并运行以下PromQL查询来检查垃圾收集的平均停顿时间：
- en: '[PRE54]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'When generating and capturing metrics, several best practices should be followed:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成和捕获指标时，应遵循几个最佳实践：
- en: As metrics can be defined at both the application and infrastructure level,
    have team members collaborate on defining those.
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于指标可以在应用程序和基础设施级别定义，请让团队成员共同定义这些指标。
- en: Always expose internal JVM metrics, such as number of threads, CPU usage, how
    often the garbage collector ran, heap, and nonheap memory usage.
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 始终公开内部JVM指标，例如线程数、CPU使用率、垃圾收集器运行频率、堆和非堆内存使用情况。
- en: Make an effort to create metrics for application-specific implementations that
    impact nonfunctional requirements. For example, cache statistics like size, hits,
    and entry time-to-live can offer you insights when assessing the performance of
    a functionality.
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 努力为影响非功能需求的应用程序特定实现创建指标。例如，缓存统计信息如大小、命中次数和条目生存时间可以在评估功能性能时提供洞察力。
- en: Tailor metrics that can support key performance indicators (KPIs) used by business
    people. For example, the number of end users who used a new functionality is a
    KPI that can be proven with software metrics.
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定制可以支持业务人员使用的关键绩效指标（KPI）的指标。例如，使用新功能的终端用户数量是可以通过软件指标证实的KPI。
- en: Measure and expose details about errors and exceptions that occur within your
    system. You can use these details later to establish error patterns and thus perform
    an enhancement.
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量并公开系统内发生的错误和异常的详细信息。稍后可以使用这些详细信息来建立错误模式，从而进行改进。
- en: Logging
  id: totrans-473
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录
- en: 'At the Java application level, developers use logging to record exceptional
    cases. Logs are useful to obtain insights with additional context information
    and can complement existing metrics. When it comes to logging, three formats are
    available: plain text, JSON or XML, and binary.'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java应用程序级别，开发人员使用日志记录异常情况。日志有助于获取具有附加上下文信息的洞察力，并可以补充现有的指标。在记录日志时，有三种格式可用：纯文本、JSON或XML以及二进制。
- en: 'Besides the Java language built-in log, several logging frameworks can help
    you achieve this task: [Simple Logging Facade for Java (SLF4J)](http://www.slf4j.org)
    and [Apache Log4j 2](https://oreil.ly/foEtO). Some logging best practices include
    the following:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Java语言内置的日志之外，还有几个日志框架可以帮助您完成此任务：[Simple Logging Facade for Java (SLF4J)](http://www.slf4j.org)
    和 [Apache Log4j 2](https://oreil.ly/foEtO)。一些日志记录最佳实践包括以下内容：
- en: Be conservative; log only details that are relevant to a particular functionality
    of your system.
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谨慎行事；只记录与系统特定功能相关的详细信息。
- en: Write meaningful information in the log message in order to help you and your
    colleagues troubleshoot future issues.
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在日志消息中写入有意义的信息，以帮助您和同事排除未来的问题。
- en: 'Use the correct log level: `TRACE` for capturing fine-grained insights, `DEBUG`
    for statements helpful when troubleshooting, `INFO` for general information, `WARN`
    and `ERROR` to signal events that might require action.'
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用正确的日志级别：`TRACE`用于捕获精细化洞察、`DEBUG`用于故障排除时有用的语句、`INFO`用于一般信息、`WARN`和`ERROR`用于标识可能需要采取行动的事件。
- en: Make sure you use guard clauses or lambda expressions to log messages if the
    corresponding log level is enabled.
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保使用守卫子句或Lambda表达式在相应的日志级别已启用时记录消息。
- en: Have the log level customizable via variables that can be set at container runtime.
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过可以在容器运行时设置的变量来自定义日志级别。
- en: Set appropriate permissions to locations where your log files will live.
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置适当的权限，以确定日志文件所在的位置。
- en: Customize layout of your logs to have region-specific formats.
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义日志布局以具有区域特定的格式。
- en: Protect sensitive data when logging. For example, logging personally identifiable
    information (PII) can lead not only to compliance violations, but also to security
    vulnerabilities.
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在记录日志时保护敏感数据。例如，记录个人可识别信息（PII）不仅可能导致合规性违规，还可能导致安全漏洞。
- en: Periodically rotate logs to prevent log files from growing too large or have
    them automatically discarded. Container and Pod logs are transient by default.
    This means that the container logs are gone when Pods are deleted, crashed, or
    scheduled on a different node. But you can stream your logs asynchronously to
    a centralized storage or service and keep locally a fixed number of rotated log
    files.
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定期旋转日志以防止日志文件过大或自动丢弃它们。容器和Pod日志默认是瞬时的。这意味着当Pod被删除、崩溃或在不同节点上调度时，容器日志就会消失。但是您可以异步地将日志流式传输到集中存储或服务，并在本地保留一定数量的旋转日志文件。
- en: Tracing
  id: totrans-485
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 追踪
- en: Within a distributed system, a request traverses multiple components. Tracing
    helps you capture metadata and timing details concerning the flow of a request
    to identify slow transactions or where failures occur.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式系统中，一个请求遍历多个组件。追踪帮助您捕获关于请求流程中的元数据和时序详细信息，以便识别慢速交易或故障发生的位置。
- en: 'Finding the right instrumentation to capture traces can be challenging for
    a developer. Proprietary agents can help you with that, but you should look into
    solutions aligned to vendor-neutral, open standards like [OpenCensus](https://opencensus.io)
    or [OpenTracing](https://opentracing.io). Many developers found it difficult to
    choose the best option for an application and have it work across vendors and
    projects, so OpenTracing and OpenCensus projects merged and formed another [CNCF](https://www.cncf.io)
    incubating project called [OpenTelemetry](https://oreil.ly/QyOhu). This collection
    of tools, APIs, and SDKs standardizes the way you collect and transmit metrics,
    logs, and traces. The OpenTelemetry tracing specification defines the following
    terms:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开发者来说，找到合适的工具来捕获追踪数据可能是具有挑战性的。专有代理可以帮助您完成这项工作，但是您应该考虑与供应商中立、开放标准如[OpenCensus](https://opencensus.io)或[OpenTracing](https://opentracing.io)对齐的解决方案。许多开发者发现选择最适合应用程序并在各种供应商和项目中运行的选项很困难，因此OpenTracing和OpenCensus项目合并并形成了另一个[CNCF](https://www.cncf.io)孵化项目，名为[OpenTelemetry](https://oreil.ly/QyOhu)。这一集合工具、API和SDK标准化了收集和传输指标、日志和追踪数据的方式。OpenTelemetry追踪规范定义了以下术语：
- en: Trace
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 追踪
- en: A single transaction request that uses other services and resources as it moves
    through a distributed system.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 单个事务请求在通过分布式系统时使用其他服务和资源。
- en: Span
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 跨度
- en: A named, timed operation representing a workflow piece. A trace contains multiple
    spans.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 代表工作流片段的命名的定时操作。一个追踪包含多个跨度。
- en: Attributes
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 属性
- en: Key/value pairs that you can use to query, filter, and comprehend trace data.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 可以用来查询、过滤和理解追踪数据的键/值对。
- en: Baggage items
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 行李项
- en: Key/value pairs that cross process boundaries.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 跨越进程边界的键/值对。
- en: Context propagation
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文传播
- en: A common subsystem shared by traces, metrics, and baggage. A developer can pass
    additional context information to a span by using attributes, logs, and baggage
    items.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 追踪、指标和行李共享的通用子系统。开发者可以通过使用属性、日志和行李项向一个跨度传递额外的上下文信息。
- en: '[Figure 8-7](#distributed-tracing) illustrates the trace for a transaction
    that begins with microservice Blue and traverses microservices Violet and Green.
    The trace has three spans, and attributes are set on the Violet and Green spans.'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '[图8-7](#distributed-tracing)说明了一个从微服务蓝开始并遍历微服务紫和绿的事务追踪。该追踪包含三个跨度，并在紫色和绿色跨度上设置了属性。'
- en: '![Distributed tracing example](Images/dtjd_0807.png)'
  id: totrans-499
  prefs: []
  type: TYPE_IMG
  zh: '![分布式追踪示例](Images/dtjd_0807.png)'
- en: Figure 8-7\. Distributed tracing example
  id: totrans-500
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8-7\. 分布式追踪示例
- en: To give an example that incorporates both metrics and traces, we will enhance
    [Example 8-2](#generate-kubernetes-resources-with-jkube) by tracing the request
    to the */greeting* endpoint and detecting the time spent to return a response
    with a Timer metric.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 为了举例说明如何同时包含指标和追踪数据，我们将通过追踪对`/greeting`端点的请求并检测返回响应所花费的时间来增强[示例 8-2](#generate-kubernetes-resources-with-jkube)。
- en: 'Next, let’s export the metrics to Prometheus and for further processing include
    OpenTelemetry support by adding the following Quarkus extensions:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将指标导出到Prometheus，并通过添加以下Quarkus扩展来进一步支持OpenTelemetry：
- en: '[PRE55]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Next, let’s customize the endpoint for sending spans by adding the following:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们通过添加以下内容来自定义发送跨度的端点：
- en: '[PRE56]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[![1](Images/1.png)](#co_deploying_for_developers_CO10-1)'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_deploying_for_developers_CO10-1)'
- en: 'Define the host as a configuration that you can parametrize. The default value
    for the host of the endpoint is `localhost`, but you can override it with `-Dexporter.host`:
    `mvn package -Dexporter.host=myhost`.'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 将主机定义为可以参数化的配置。端点的主机的默认值为`localhost`，但您可以通过`-Dexporter.host`进行覆盖：`mvn package
    -Dexporter.host=myhost`。
- en: '[![2](Images/2.png)](#co_deploying_for_developers_CO10-2)'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_deploying_for_developers_CO10-2)'
- en: At compile time, the `quarkus-kubernetes` extension that is already in the project
    will take into account this environment variable and autogenerate the configuration
    of the Kubernetes resources. The configuration reuses the value of `custom.host`.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译时，已经存在于项目中的`quarkus-kubernetes`扩展将考虑这个环境变量，并自动生成Kubernetes资源的配置。配置重用`custom.host`的值。
- en: '[![3](Images/3.png)](#co_deploying_for_developers_CO10-3)'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_deploying_for_developers_CO10-3)'
- en: The gRPC endpoint for sending spans that reuses the previous host definition.
    The configuration reuses the value of `custom.host`.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC端点用于发送跨度，重用先前的主机定义。配置重用`custom.host`的值。
- en: 'To measure the duration of a request sent to the */greeting* endpoint, we will
    annotate it with `@Timed` and instrument its traces by customizing a `Span` with
    two attributes:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 要测量发送到*/greeting*端点的请求持续时间，我们将用`@Timed`进行注释，并通过定制`Span`来进行其追踪，带有两个属性：
- en: '[PRE57]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[![1](Images/1.png)](#co_deploying_for_developers_CO11-1)'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_deploying_for_developers_CO11-1)'
- en: Attribute set to trace when the logic started.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 属性设置为在逻辑开始时跟踪。
- en: '[![2](Images/2.png)](#co_deploying_for_developers_CO11-2)'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_deploying_for_developers_CO11-2)'
- en: After recording the exception, set the attribute to trace the exception case.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 记录异常后，设置属性以跟踪异常情况。
- en: 'Given the changes introduced, you can rebuild and push the container image,
    and deploy the Kubernetes resources generated at compile time by using the following:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于引入的更改，您可以重新构建和推送容器映像，并使用编译时生成的Kubernetes资源进行部署，如下所示：
- en: '[PRE58]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: To instrument end-to-end distributed tracing, you can use a tool like [Jaeger](https://oreil.ly/Kp09K)
    ([Figure 8-8](#jaeger-filtered-trace)). This top-level [CNCF project](https://oreil.ly/vZRTZ)
    can easily integrate with Kubernetes. You can set up the value for `quarkus​.opentele⁠metry.tracer.exporter.otlp.endpoint`
    by using the Jaeger endpoint. Within the Jaeger UI, you can search traces by using
    the `pause` tag.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行端到端分布式追踪，您可以使用像[Jaeger](https://oreil.ly/Kp09K)这样的工具（[图8-8](#jaeger-filtered-trace)）。这个顶级[CNCF项目](https://oreil.ly/vZRTZ)可以轻松集成Kubernetes。您可以通过Jaeger端点设置`quarkus​.opentele⁠metry.tracer.exporter.otlp.endpoint`的值。在Jaeger
    UI中，您可以使用`pause`标签搜索追踪。
- en: '![Filtering traces by tag with Jaeger](Images/dtjd_0808.png)'
  id: totrans-521
  prefs: []
  type: TYPE_IMG
  zh: '![使用Jaeger按标签过滤追踪](Images/dtjd_0808.png)'
- en: Figure 8-8\. Filtering traces by tag with Jaeger
  id: totrans-522
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8-8\. 使用Jaeger按标签过滤追踪
- en: 'Furthermore, you can observe the requests that generated an exception as follows:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还可以观察生成异常的请求，如下所示：
- en: Search in the Jaeger UI for traces having `error=true` and `unexpec⁠ted​.pause=exception`
    tags.
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Jaeger UI中搜索具有`error=true`和`unexpec⁠ted​.pause=exception`标签的追踪。
- en: 'Utilize the `Timer` named `custom` in a Prometheus query like the following
    one:'
  id: totrans-525
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Prometheus查询中使用名为`custom`的`Timer`，如下所示：
- en: '[PRE59]'
  id: totrans-526
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Inspect logs for the message `Thread interrupted`.
  id: totrans-527
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查日志以获取消息`Thread interrupted`。
- en: 'Here are some recommended practices for tracing:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些追踪的推荐实践：
- en: Instrument a trace end-to-end, meaning forward the tracing headers to all the
    downstream services, data stores, or middleware part of your system.
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对追踪进行端到端的仪表化，意味着将追踪头部转发到所有下游服务、数据存储或中间件，这些都是系统的一部分。
- en: 'Report metrics related to request rate, errors, and their duration. The rate,
    errors, duration (RED) method is popular in the SRE world and focuses on instrumenting:
    request throughput, request error rate, latency, or response time.'
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 报告与请求速率、错误及其持续时间相关的度量。在SRE领域，使用率、错误、持续时间（RED）方法很受欢迎，并侧重于仪表化：请求吞吐量、请求错误率、延迟或响应时间。
- en: If you instrument your custom tracing spans, avoid using a lot of metadata.
  id: totrans-531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您为自定义追踪跨度添加仪表数据，请避免使用大量元数据。
- en: When searching for Java-compatible tracing solutions, look at the language-specific
    implementation of [OpenTelemetry in Java](https://oreil.ly/Df5RD).
  id: totrans-532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当寻找适用于Java的追踪解决方案时，请查看[Java中的OpenTelemetry实现](https://oreil.ly/Df5RD)的语言特定实现。
- en: When designing systems for observability, remember that your metrics and logs
    should be available for a later analysis. As a consequence, regardless of where
    you deploy, always have tools and practices that can reliably capture and store
    metrics and logging data.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计可观察性系统时，请记住您的度量和日志应可供以后分析。因此，无论部署在何处，始终要有能够可靠捕获和存储度量和日志数据的工具和实践。
- en: High Availability and Geographic Distribution
  id: totrans-534
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高可用性和地理分布
- en: When working on a software system, you have probably received a nonfunctional
    requirement indicating that your application(s) should be available 24/7. In the
    industry literature, *availability* refers to the probability that a system is
    operational at a given time; this is expressed as a percentage of uptime in a
    given year.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发软件系统时，您可能收到了一个非功能性要求，指出您的应用程序应该全天候可用。在行业文献中，*可用性*指的是系统在给定时间内运行的概率；这通常以每年的正常运行时间百分比表示。
- en: '*High availability* (HA) is the ability of a system to work continuously without
    failure for an established time. As developers, we create software with the intent
    to be always available for end users, but external factors like power outages,
    network failures, and underprovisioned environments can impact the quality of
    service received by consumers.'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '*高可用性*（HA）是系统在规定时间内连续工作而无故障的能力。作为开发人员，我们创建软件的目的是始终为最终用户提供可用性，但是诸如停电、网络故障和配置不足的环境等外部因素可能影响消费者接收到的服务质量。'
- en: Small-size container images and successful deployments to Kubernetes are the
    first steps toward having an application available on Kubernetes. For example,
    let’s assume you have to upgrade your worker nodes to a newer Kubernetes version.
    This operation includes that your nodes have to pull all the containers before
    working with the latest Kubernetes version. The longer it takes for each node
    to pull the containers, the lengthier it will be for the cluster to work as expected.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 小型容器镜像和成功部署到 Kubernetes 是将应用程序可用于 Kubernetes 的第一步。例如，假设您必须将工作节点升级到较新的 Kubernetes
    版本。此操作包括节点必须在使用最新 Kubernetes 版本之前拉取所有容器。每个节点拉取容器所需的时间越长，集群按预期工作的时间就越长。
- en: Different deployment strategies were explained in [“Choose and Implement a Deployment
    Strategy”](#choosing-and-implementing-a-deployment-strategy) because downtime,
    traffic routing between deployment versions, and the rollback process influence
    availability. In a failed deployment, a fast rollback process can save you from
    user discomfort, time, and compute resources. Moreover, you want your system to
    have a highly available state, and the way you define health checks and adjust
    resources for your containerized applications impacts its performance to work
    continuously without failure for an established time. Eventually, you can fine-tune
    your health checks, resource consumption, and deployments by observing your system’s
    behavior through logs, metrics, and traces.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '[“选择和实施部署策略”](#choosing-and-implementing-a-deployment-strategy) 中解释了不同的部署策略，因为停机时间、流量在部署版本之间的路由以及回滚过程会影响可用性。在部署失败时，快速回滚过程可以避免用户的不适、节省时间和计算资源。此外，您希望您的系统具有高度可用的状态，您为容器化应用程序定义健康检查和调整资源的方式会影响其在规定时间内连续工作而无故障的性能。最终，通过观察系统的行为，例如日志、度量和跟踪，您可以通过调整健康检查、资源消耗和部署来优化您的系统。'
- en: Availability is commonly defined as a percentage of uptime in a given year.
    [Table 8-7](#connecting-availability-and-downtime) shows the connection between
    a given availability percentage to the corresponding amount of downtime per year.
    The table uses a year with 365 days, and for consistency, all times are rounded
    to two decimal digits.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 可用性通常定义为一年中正常运行时间的百分比。[表 8-7](#connecting-availability-and-downtime) 显示了给定可用性百分比与每年停机时间的对应关系。该表使用一年
    365 天，为保持一致性，所有时间都四舍五入到两位小数。
- en: Table 8-7\. Connecting a certain availability percentage to downtime per year
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-7. 将某个可用性百分比与每年停机时间连接起来
- en: '| Availability % | Downtime in a year |'
  id: totrans-541
  prefs: []
  type: TYPE_TB
  zh: '| 可用性百分比 | 年度停机时间 |'
- en: '| --- | --- |'
  id: totrans-542
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 90% | 36.5 days |'
  id: totrans-543
  prefs: []
  type: TYPE_TB
  zh: '| 90% | 36.5 天 |'
- en: '| 95% | 18.25 days |'
  id: totrans-544
  prefs: []
  type: TYPE_TB
  zh: '| 95% | 18.25 天 |'
- en: '| 99% | 3.65 days |'
  id: totrans-545
  prefs: []
  type: TYPE_TB
  zh: '| 99% | 3.65 天 |'
- en: '| 99.9% | 8.76 hours |'
  id: totrans-546
  prefs: []
  type: TYPE_TB
  zh: '| 99.9% | 8.76 小时 |'
- en: '| 99.95% | 4.38 hours |'
  id: totrans-547
  prefs: []
  type: TYPE_TB
  zh: '| 99.95% | 4.38 小时 |'
- en: '| 99.99% | 52.56 minutes |'
  id: totrans-548
  prefs: []
  type: TYPE_TB
  zh: '| 99.99% | 52.56 分钟 |'
- en: '| 99.999% | 5.25 minutes |'
  id: totrans-549
  prefs: []
  type: TYPE_TB
  zh: '| 99.999% | 5.25 分钟 |'
- en: '| 99.9999% | 31.53 seconds |'
  id: totrans-550
  prefs: []
  type: TYPE_TB
  zh: '| 99.9999% | 31.53 秒 |'
- en: Nowadays, service providers use service-level indicators (SLIs) to measure the
    goal set by a service-level objective (SLO). SLOs are the individual commitments
    made by the service provider to a customer. You can incorporate the percentages
    from [Table 8-7](#connecting-availability-and-downtime) by setting a value for
    availability as part of the SLO. Tools like [Prometheus](https://prometheus.io)
    and [Grafana](https://grafana.com) can help you calculate the performance of your
    applications by incorporating the SLOs, querying metrics, and alerting when goals
    are endangered.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，服务提供商使用服务级别指标（SLIs）来衡量由服务级别目标（SLO）设定的目标。SLO 是服务提供商向客户作出的个别承诺。您可以通过将 [表 8-7](#connecting-availability-and-downtime)
    中的百分比作为 SLO 的一部分来设置可用性值。工具如 [Prometheus](https://prometheus.io) 和 [Grafana](https://grafana.com)
    可以通过整合 SLO、查询度量和在目标受到威胁时发出警报来帮助您计算应用程序的性能。
- en: 'To create highly available systems, reliability engineering offers three principles
    of systems design:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建高可用系统，可靠性工程提供了系统设计的三个原则：
- en: Eliminate single points of failure at the application, network, and infrastructure
    level. Because even the way you internally code your application can sometimes
    generate failures, you should properly test every software component. Observability
    and great deployment strategies help you eliminate the possible failures in your
    system.
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消除应用程序、网络和基础设施级别的单点故障。因为甚至您内部编写应用程序的方式有时也可能产生故障，所以您应该正确测试每个软件组件。可观测性和出色的部署策略有助于消除系统中可能的故障。
- en: Detect failures as they occur. Monitoring and alerting help discover when a
    system reaches critical conditions.
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当系统出现关键情况时，监控和警报有助于发现故障。
- en: Have a reliable transition to a running component when a failure occurs to another
    one. An efficient rollback process in case of deployment issues, the Kubernetes
    self-healing mechanism, and smooth traffic routing between Kubernetes resources
    help in this matter.
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当发生故障时，确保可以从一个组件有效过渡到另一个组件。在部署问题时进行高效的回滚流程，Kubernetes 自我修复机制以及 Kubernetes 资源之间的平滑流量路由都有助于解决此问题。
- en: 'A good plan for failure involves following the preceding principles and implementing
    them using several best practices:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 应对故障的良好计划包括遵循前述原则，并使用几种最佳实践来实施：
- en: Perform data backups, recovery, and replications.
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行数据备份、恢复和复制。
- en: Set up network load balancing to distribute the traffic efficiently when increased
    workloads are received by the critical features of your applications. Load balancing
    helps you eliminate single points of failure at the application level while using
    the network and infrastructure available.
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置网络负载均衡以在接收到应用程序关键功能的增加工作负载时有效分发流量。负载平衡帮助您消除应用程序级别的单点故障，同时利用可用的网络和基础设施。
- en: When it comes to natural disasters that could affect your system, having it
    deployed in multiple geographical locations can prevent service failure. It is
    critical to run independent application stacks in each location so the others
    can continue running if a failure occurs in one place. Ideally, these locations
    should spread globally and not be localized in a specific area.
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 针对可能影响系统的自然灾害，将系统部署在多个地理位置可以防止服务故障。在每个位置运行独立的应用堆栈是至关重要的，这样如果一个地方发生故障，其他地方仍然可以继续运行。理想情况下，这些位置应全球分布，而不是局限于特定地区。
- en: If you are worried about a Kubernetes cluster performance when a component or
    its control-plane node goes down, you should choose to have highly available Kubernetes
    [clusters](https://oreil.ly/9iTgz). Kubernetes high availability is about having
    a multiple control-plane setup behaving like a unified data center. A setup consisting
    of multiple control planes protects your system from losing a worker node to the
    failure of the control plane node’s etcd. Managing Kubernetes clusters is not
    an easy task, but you should know that a wide range of cloud providers will share
    this type of configuration up-front when setting the clusters for you.
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果担心 Kubernetes 群集性能在组件或其控制平面节点宕机时，应选择具有高可用性的 Kubernetes [群集](https://oreil.ly/9iTgz)。
    Kubernetes 的高可用性是指具有多个控制平面设置，行为类似于统一数据中心。由多个控制平面组成的设置可保护系统免受工作节点损失控制平面节点 etcd
    的故障。管理 Kubernetes 群集并非易事，但您应了解，在为您设置群集时，广泛的云提供商将共享这种类型的配置。
- en: Depending on your requirements, maintaining multiregion Kubernetes clusters
    can be unjustified. But you can still set up multiple namespaces to ensure availability
    across the same cluster.
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据您的要求，维护多地区 Kubernetes 群集可能是不合理的。但您仍然可以设置多个命名空间，以确保在同一群集中的可用性。
- en: Since one of the previous practices involved multiregional deployments, you
    should know that by using this technique, you can improve end-user experiences
    by keeping latencies low for a distributed user base. Your application architecture
    can achieve low latency because it would keep data close to end users distributed
    worldwide.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 由于先前的实践之一涉及多区域部署，您应该知道，通过使用此技术，可以通过为全球分布的用户基础保持低延迟来改善最终用户体验。您的应用程序架构可以实现低延迟，因为它会使数据靠近全球分布的最终用户。
- en: Another aspect to consider when having geographically distributed applications
    is the ability to comply with data privacy laws and regulations. As more and more
    social and economic activities occur online, the importance of privacy and data
    protection is increasingly recognized. In some countries, collection, usage, and
    sharing of personal information to different parties without notice or consent
    of consumers are considered illegal. According to [United Nations Conference on
    Trade and Development (UNCTAD)](https://oreil.ly/p0KH2), 128 out of 194 countries
    have put in place legislation to secure the protection of data and privacy.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有地理分布式应用程序时，还需考虑遵守数据隐私法律和法规的能力。随着越来越多的社会和经济活动在线进行，隐私和数据保护的重要性越来越被认可。在一些国家，未经消费者通知或同意向不同方收集、使用和分享个人信息被视为非法行为。根据[联合国贸易和发展会议（UNCTAD）](https://oreil.ly/p0KH2)，194个国家中有128个国家已经制定了保护数据和隐私的立法。
- en: As you start to understand the requirements on your end to ensure the high availability
    of a distributed system, let’s explore the cloud models that can help you achieve
    it.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 当您开始了解如何确保分布式系统高可用性的要求时，让我们探索一下可以帮助您实现这一目标的云模型。
- en: Hybrid and MultiCloud Architectures
  id: totrans-565
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合和多云架构
- en: The *cloud* is a collection of technologies to approach challenges like availability,
    scaling, security, and resilience. It can exist on premises, on a Kubernetes distribution,
    or in a public infrastructure. Often, you will see the terms *hybrid cloud* and
    *multicloud* used synonymously. The most intuitive definition for a multicloud
    architecture is that this type of architecture requires at least one public cloud.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: '*云* 是一组技术，用于解决可用性、扩展性、安全性和韧性等挑战。它可以存在于本地、Kubernetes 分发版或公共基础设施中。通常情况下，您会看到术语*混合云*和*多云*被用来表示类似的概念。对于多云架构的最直观定义是，这种类型的架构至少需要一个公共云。'
- en: Hybrid cloud architecture differs from multicloud by including a private cloud
    infrastructure component and at least one public cloud ([Figure 8-9](#multi-cloud-hybrid-cloud)).
    As a result, when a hybrid cloud architecture has more than one public offering,
    that architecture can be simultaneously a multicloud one.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 混合云架构与多云架构的区别在于包含私有云基础设施组件以及至少一个公共云（参见图 8-9](#multi-cloud-hybrid-cloud)）。因此，当混合云架构具有多个公共提供时，该架构可以同时是多云架构。
- en: '![Multi-cloud and Hybrid Cloud](Images/dtjd_0809.png)'
  id: totrans-568
  prefs: []
  type: TYPE_IMG
  zh: '![多云和混合云](Images/dtjd_0809.png)'
- en: Figure 8-9\. Multicloud and hybrid cloud
  id: totrans-569
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-9\. 多云和混合云
- en: 'When deploying on hybrid or multicloud infrastructures, you should take into
    consideration these cross-team aspects:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署在混合或多云基础设施上时，您应考虑以下跨团队的方面：
- en: Having a unified view over what and where you deployed.
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于您部署的内容及其位置，需要统一的视图。
- en: Replacing provider-specific SaaS and IaaS services.
  id: totrans-572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替换提供商特定的SaaS和IaaS服务。
- en: Following a unified approach for mitigating security vulnerabilities across
    clouds.
  id: totrans-573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遵循统一的方法来减少跨云安全漏洞。
- en: Scaling out and provisioning new resources seamlessly.
  id: totrans-574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无缝扩展和配置新资源。
- en: When you port applications across clouds, you need to avoid disconnection of
    services. There is a time to recovery when moving workloads between infrastructures,
    but you can provide an end-user flawless transition using appropriate network
    configurations and deployment strategies.
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在跨云端口应用程序时，需要避免服务断开。在将工作负载在不同基础设施之间移动时会有恢复时间，但可以通过适当的网络配置和部署策略为最终用户提供无缝过渡。
- en: At such a large scale, automation helps when orchestrating processes. Besides,
    the orchestrations platform for containerized applications, you and your team
    will likely add an extra layer of tools and processes to manage workloads.
  id: totrans-576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在如此大规模的情况下，自动化在编排过程时非常有帮助。此外，针对容器化应用的编排平台，您和您的团队可能会额外添加一层工具和流程来管理工作负载。
- en: 'From a developer point of view, you can contribute to a hybrid or multicloud
    strategy by taking care of these elements:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 从开发者的角度来看，您可以通过关注这些要素来为混合或多云策略做出贡献：
- en: Your application’s codebase should be the same regardless of the environment
    (namespace).
  id: totrans-578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的应用程序代码库在任何环境（命名空间）下都应保持一致。
- en: Your local building and deployment practice should be reproducible when other
    colleagues attempt to work with your code.
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当其他同事尝试使用您的代码时，您的本地构建和部署实践应该是可复制的。
- en: Avoid referencing local dependencies in your code or container image build.
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免在您的代码或容器镜像构建中引用本地依赖项。
- en: When possible, parameterize the container image through build-time variables
    or environment variables.
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能的话，通过构建时变量或环境变量参数化容器镜像。
- en: If you need to support environment customizations, propagate them with environment
    variables from the orchestration platform toward container/application code parameters.
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您需要支持环境定制，请通过编排平台的环境变量将它们传播到容器/应用程序代码参数。
- en: Use dependencies and images from repositories and registries that your organization
    has previously validated as trusted sources.
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用您的组织之前验证为可信来源的存储库和注册表中的依赖关系和镜像。
- en: Prefer volumes to share information among containers.
  id: totrans-584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更喜欢使用卷在容器之间共享信息。
- en: When working toward a hybrid or multicloud architecture, always ask yourself
    how you and your colleagues will evolve the software piece you are currently building.
    A progressive software architecture starts with a forward-thinking developer mindset.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 当努力朝向混合或多云架构时，请始终问自己和您的同事如何演进当前构建的软件部件。一个先进的软件架构始于具有前瞻性的开发者思维方式。
- en: Summary
  id: totrans-586
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter covered aspects of deployments that can concern a Java developer.
    Although the typical Java developer role does not involve infrastructure administration,
    you can influence the operational stages and processes of your application by
    doing the following:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了可能涉及Java开发人员的部署方面。尽管典型的Java开发人员角色不涉及基础设施管理，但您可以通过以下方式影响应用程序的运行阶段和流程：
- en: Building and pushing container images to container image registries by using
    Java-based tools like Jib and Eclipse JKube
  id: totrans-588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用像Jib和Eclipse JKube这样基于Java的工具构建和推送容器镜像到容器镜像注册表。
- en: Generating and deploying Kubernetes manifests by using Dekorate and Eclipse
    JKube
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Dekorate和Eclipse JKube生成和部署Kubernetes清单。
- en: Implementing health checks and coordinating their execution at the infrastructure
    level
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在基础设施级别实现健康检查并协调它们的执行。
- en: Observing the behavior of the distributed system in order to know when to introduce
    changes and which resources to adjust
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察分布式系统的行为，以便了解何时引入更改以及调整哪些资源
- en: Associating deployment aspects with high availability, hybrid, and multicloud
    architectures
  id: totrans-592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将部署方面与高可用性、混合云和多云架构相关联。
- en: Since you have a good understanding of deploying applications, the next chapter
    investigates DevOps workflows for mobile software.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 既然您对部署应用程序有了很好的理解，下一章将探讨移动软件的DevOps工作流程。
