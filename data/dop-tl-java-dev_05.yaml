- en: Chapter 5\. Continuous Integration
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章。持续集成
- en: Melissa McKay
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Melissa McKay
- en: Always make new mistakes.
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 始终犯新错误。
- en: ''
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Esther Dyson
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Esther Dyson
- en: Back in [Chapter 2](ch02.xhtml#the_system_of_truth), you learned the value of
    source control and a common code repository. After you have organized and settled
    on your source control solution, you need to take a few more steps to reach an
    end result where your users can bask in the perfect user experience of your delivered
    software.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 回到[第二章](ch02.xhtml#the_system_of_truth)时，你学到了源代码控制和常见代码库的价值。在你组织和确定了源代码控制解决方案后，你需要采取更多步骤，以达到一个最终结果，让你的用户可以享受到你交付的软件的完美用户体验。
- en: Think about the process that you would take as an individual developer to progress
    your software through the entire software development lifecycle. After determining
    the acceptance criteria for a particular feature or bug fix for your software,
    you would proceed with adding the actual lines of code along with the related
    unit tests to the codebase. Then, you would compile and run all of the unit tests
    to ensure that your new code works as you expect (or at least as defined by your
    unit tests) and doesn’t break known existing functionality. After you find that
    all tests pass, you would build and package your application and verify functionality
    in the form of integration tests in a quality assurance (QA) environment. Finally,
    happy with the green light from your well-oiled and maintained test suites, you
    would deliver and/or deploy your software to a production environment.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，作为个体开发者，你将如何推进软件通过整个软件开发生命周期。确定特定功能或软件bug修复的验收标准后，你会继续添加实际的代码行和相关的单元测试到代码库中。然后，你会编译并运行所有的单元测试，以确保你的新代码按照你的预期工作（或者至少是根据你的单元测试定义的），并且不会破坏已知的现有功能。在发现所有测试通过后，你将构建和打包应用程序，并在质量保证（QA）环境中进行集成测试的功能验证。最后，在测试套件给出绿灯的情况下，你将向生产环境交付和/或部署软件。
- en: If you have any development experience at all, you know as well as I do that
    software rarely falls into place so neatly. Strict implementation of the ideal
    workflow described is too simplistic when you begin working on a larger project
    with a team of developers. Multiple complications are introduced that can gum
    up the gears of the software delivery lifecycle and throw your schedule into a
    lurch. This chapter discusses how continuous integration and the related best
    practices and toolsets will help you steer clear of or mitigate the most common
    hurdles and headaches that software development projects often encounter on the
    path to delivery.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有任何开发经验，你就像我一样知道，软件很少会如此顺利地落实。当你开始与开发团队一起工作的较大项目时，严格实施理想的工作流程会显得太过简单化。会引入多种复杂因素，可能会干扰软件交付生命周期的进程，打乱你的计划。本章讨论了持续集成及相关的最佳实践和工具集如何帮助你避免或减轻软件开发项目在交付过程中常遇到的最常见障碍和头痛问题。
- en: Adopt Continuous Integration
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 采用持续集成
- en: '*Continuous integration* (CI) is most commonly described as frequently integrating
    code changes from multiple contributors into the main source code repository of
    a project. In practice, this definition by itself is a little vague. Exactly how
    often is *frequently*? What does integrating actually mean in this context? Is
    it enough just to coordinate pushing code changes to the source code repository?
    And most important, what problem does this process solve—for what benefit(s) should
    you adopt this practice?'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*持续集成*（CI）通常被描述为频繁地将多个贡献者的代码变更集成到项目的主源代码库中。实际上，这个定义本身有点模糊。在这个上下文中，“频繁”是指多频繁？集成的确切含义是什么？仅仅协调将代码变更推送到源代码库是否足够？最重要的是，这个过程解决了什么问题——你应该采纳这种实践有什么好处？'
- en: The concept of CI has been around now for quite some time. [According to Martin
    Fowler](https://oreil.ly/3sYHE), the term *continuous integration* originated
    with Kent Beck’s Extreme Programming development process, as one of its original
    12 practices. In the DevOps community, the term itself is now as common as butter
    on toast. But the way it is implemented may vary from team to team and project
    to project. The benefits are hit-or-miss if there isn’t a thorough understanding
    of the original intent or if best practices are abandoned.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: CI 的概念已经存在了相当长的时间了。[根据马丁·福勒的说法](https://oreil.ly/3sYHE)，*持续集成* 这个术语源自肯特·贝克的极限编程开发过程，作为其最初的
    12 项实践之一。在 DevOps 社区中，这个术语现在和面包上的黄油一样普遍。但它的实施方式可能因团队和项目而异。如果不彻底理解原始意图或放弃最佳实践，其益处可能是时有时无。
- en: It’s interesting to see how our understanding of CI has changed over time. The
    way we talk about it now is much different from when it was initially introduced
    by Beck to address the issues of concurrent development. The problems we have
    today are more about keeping regular and frequent builds efficient while minimizing
    bugs, whereas initially, CI and the proliferation of build tools that spun out
    from it was more about getting a project to build *at all* after development was
    complete. Instead of trying to assemble a project only *after* all the coding
    has been completed by the team, CI required a change in mindset—to regularly build
    *during* development.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 看到我们对 CI 的理解随时间而变化是很有趣的。现在我们谈论它的方式与贝克最初引入它来解决并发开发问题时大不相同。我们今天面临的问题更多地是保持定期和频繁的构建的效率，同时尽量减少错误，而最初，CI
    及其衍生的构建工具的普及更多地是为了在开发完成后使项目能够 *完整* 构建。而不是仅在团队完成所有编码之后才尝试组装项目，CI 要求改变思维方式——在开发过程中定期构建。
- en: Today, CI is meant to identify bugs and compatibility issues as quickly as possible
    in the development cycle through regular and frequent builds. The basic premise
    of CI is that if developers integrate changes often, bugs can be found sooner
    in the process, and less time is spent hunting down when and where a problem was
    introduced. The longer a bug goes undiscovered, the greater the potential for
    it to become entrenched in the surrounding codebase.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，CI 的目的是通过定期和频繁的构建尽快地识别开发周期中的错误和兼容性问题。CI 的基本前提是，如果开发人员经常集成变更，就可以更早地发现错误，并减少在寻找问题引入的时间和地点上的浪费。错误被发现的时间越长，它在周围代码库中变得根深蒂固的潜力就越大。
- en: It is much easier from a development perspective to find, catch, and fix bugs
    closer to when they are introduced rather than extract them from layers of code
    that have already moved to later stages of the delivery pipeline. Bugs that evade
    discovery until the latest acceptance phases, and especially those that escape
    all the way to release, directly translate to more money spent to fix and less
    time spent on new features. In the case of fixing a bug in production, in many
    instances, there is now a requirement to patch existing deployments in addition
    to including and documenting the fix in a new version. This inherently reduces
    the time the team has available to spend on the development of new features.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 从开发的角度来看，找到、捕捉和修复错误比从已经移动到交付管道后阶段的代码层中提取错误要容易得多。直到最新的验收阶段甚至直接发布的错误，直接转化为更多的修复开销和较少用于新功能开发的时间。在生产环境中修复错误的情况下，在许多情况下，现在要求在包括和记录修复的新版本中补丁现有部署。这从本质上减少了团队用于开发新功能的可用时间。
- en: 'It’s important to understand that implementing a CI solution does *not* equate
    to software that never has any bugs. It would be foolish to use such a definitive
    measure to determine whether the implementation of CI is worthy. A more valuable
    metric might be the number of bugs or compatibility issues that were caught by
    CI. In much the same way that a vaccine is never 100% effective in a large population,
    CI is simply another level of protection to filter the most obvious bugs from
    a release. By itself, CI will never replace the well-known benefits of software
    development best practices that are in the purview of the initial design and development
    steps. It will, however, provide a better safety net for software as it is repeatedly
    handled and massaged by multiple developers over time. Martin Fowler puts it this
    way: “Continuous integration doesn’t get rid of bugs, but it does make them dramatically
    easier to find and remove.”'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，实施持续集成解决方案*并不*等同于永远没有任何错误的软件。用这样一个明确的标准来判断持续集成的实施是否值得是愚蠢的。一个更有价值的指标可能是持续集成捕获的错误或兼容性问题的数量。就像疫苗在大规模人群中从未百分之百有效一样，持续集成只是在软件中提供了另一层保护，以便从发布中过滤掉最明显的错误。持续集成本身永远不会取代软件开发最佳实践的众所周知的好处，这些最佳实践属于最初的设计和开发步骤。然而，随着时间的推移，它将为软件提供一个更好的安全网，因为软件会被多个开发人员反复处理和调整。马丁·福勒这样描述：“持续集成并不能消除错误，但确实能够显著地帮助找到并移除它们。”
- en: My first experience with CI was during an internship at a small company that
    adopted the software development methodology of Extreme Programming (XP), of which
    CI is an important aspect. We did not have an incredibly fancy system using all
    of the latest and greatest DevOps tools. What we did have was a common code repository,
    and a single build server located in a small closet in the office.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我在一家小公司实习时的第一次持续集成经验，该公司采用极限编程（XP）的软件开发方法，其中持续集成是一个重要方面。我们没有使用所有最新和最伟大的DevOps工具的非常花哨的系统。我们拥有的是一个共享的代码仓库，以及一个位于办公室小壁橱中的单一构建服务器。
- en: Unbeknownst to me when I first joined the development team, a speaker was set
    up on the build server that would erupt in the sound of emergency sirens if a
    fresh checkout from source control resulted in the failure of a build or any automated
    tests. We were a relatively young team, so this part of our CI was mostly in jest,
    but guess who learned *remarkably* quickly not to push code to the main repository
    without first verifying that the project built successfully and passed unit tests?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当我首次加入开发团队时，并不知道构建服务器上设置了扬声器，如果从源代码控制进行的新检出导致构建失败或任何自动化测试失败，它就会发出紧急警报声。我们是一个相对年轻的团队，所以我们的持续集成的这一部分大多是戏谑，但猜猜谁学会了*非常*快速地在将代码推送到主代码仓库之前验证项目是否成功构建并通过单元测试？
- en: 'To this day, I feel exceptionally fortunate to have been exposed to this practice
    in this way. The simplicity of it underscored the most important aspects of CI.
    I want to call out three by-products of this simple setup:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 直至今天，我感到非常幸运能以这种方式接触到这种实践。这种简单性突显了持续集成的最重要方面。我想指出这种简单设置的三个副产品：
- en: Code integration was regular and rarely complicated
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 代码集成通常是定期的，很少复杂化。
- en: My team had agreed to follow XP practices, which encourage integration as often
    as [every few hours](https://oreil.ly/0A7P9). More important than a specific time
    interval was the amount of code requiring integration at any given point. When
    planning and breaking down actual development work, we focused our efforts on
    creating small, completable tasks, always beginning with the [simplest thing that
    can possibly work](https://oreil.ly/Scb94). By *completable*, I mean after the
    development task was complete, it could be integrated into the main code repository
    and the result would be expected to build successfully and pass all unit tests.
    This practice of organizing code updates in as small a package as possible made
    regular and frequent integration to the main source code repository a normal and
    unremarkable activity. Rarely was significant time spent on large integration
    efforts.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我的团队同意遵循XP实践，鼓励尽可能频繁地集成[每隔几个小时](https://oreil.ly/0A7P9)。比特定时间间隔更重要的是在任何给定时间点需要集成的代码量。在计划和拆分实际开发工作时，我们专注于创建小而可完成的任务，始终从[可能最简单的事情开始](https://oreil.ly/Scb94)。通过*可完成*，我指的是开发任务完成后，可以将其集成到主代码仓库中，并期望该结果能够成功构建并通过所有单元测试。将代码更新组织成尽可能小的包的这种做法，使得定期和频繁地将代码集成到主源代码仓库成为一种正常且不值一提的活动。很少有大量时间花费在大规模集成工作上。
- en: Build and test failures were relatively easy to troubleshoot
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 构建和测试失败相对较容易排查。
- en: Because the project was built and automated tests were run at regular intervals,
    it was readily apparent where to start troubleshooting any failures. A relatively
    small amount of code would have been touched since the latest successful build,
    and if the problem couldn’t immediately be identified and resolved, we would start
    with reverting the latest merge and work backward as needed to restore a clean
    build.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因为项目在常规间隔时间内构建并运行自动化测试，所以很容易看出从哪里开始排查任何失败。自上次成功构建以来，可能只有少量代码被修改，如果问题无法立即识别和解决，我们将从最新的合并开始，并按需向后工作以恢复干净的构建。
- en: Bugs and compatibility issues introduced by integration and caught by the CI
    system were fixed immediately
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由集成引入的错误和兼容性问题，通过 CI 系统立即修复。
- en: The loud sound of the siren let *everyone* on the team know that a problem needed
    to be addressed, a problem that could not be ignored. Because our CI system halted
    progress whenever a build or test failure occurred, everyone was on board to figure
    out what was wrong and what to do to fix the problem. Team communication, coordination,
    and cooperation were all in top shape because no one would be able to move forward
    until the issue was resolved. A majority of the time, the offending code could
    be identified simply by analyzing the most recent merge, and the responsibility
    to fix was assigned to that developer or pair of developers. At times, a discussion
    with the entire team was necessary because of a compatibility issue around multiple
    recent merges, as changes in one part of the system negatively affected another
    seemingly unrelated part. These instances required our team to reevaluate the
    code changes being made holistically and then decide together the best plan of
    action.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 警报器发出的巨大声响让*每个人*都知道需要解决一个无法忽视的问题。因为我们的 CI 系统在构建或测试失败时会暂停进度，所以每个人都会全力以赴找出问题所在以及如何解决问题。团队的沟通、协调和合作都处于最佳状态，因为除非问题解决，否则没有人能够继续前进。大多数情况下，可以通过分析最近的合并简单地确定有问题的代码，并将修复责任分配给该开发者或开发者组。有时，由于多个最近的合并引发了兼容性问题，影响了看似无关的系统其他部分，因此需要与整个团队讨论。这些情况需要我们的团队从整体上重新评估正在进行的代码更改，然后共同决定最佳行动方案。
- en: These three factors were key to the success of our CI solution. You might have
    discerned that all three imply the prerequisites of a healthy codebase and a healthy
    development team. Without these, the initial implementation of a CI solution will
    undoubtedly be more difficult. However, implementing a CI solution will in turn
    have a positive impact on the codebase, and taking the first steps will provide
    a measure of benefit that will be well worth the effort.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个因素是我们的 CI 解决方案成功的关键。您可能已经了解到这三个因素都暗示了健康的代码库和健康的开发团队的先决条件。没有这些因素，CI 解决方案的初始实施无疑会更加困难。然而，实施
    CI 解决方案将反过来对代码库产生积极影响，并且采取第一步将带来一定程度的收益，这将非常值得努力。
- en: It is true there is much more to an effective CI solution than simple coordination
    of code contribution to a shared repository and following a mandate to integrate
    at an agreed-upon frequency. The following sections will walk you through the
    essentials of a complete, practicable CI solution that will help unburden and
    accelerate the software development process.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有效的 CI 解决方案远不止是简单地协调代码对共享仓库的贡献，并遵循在约定频率上集成的命令。以下部分将为您介绍完整、实用的 CI 解决方案的基本要素，这将有助于减轻和加速软件开发过程。
- en: Declaratively Script Your Build
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明式地编写您的构建
- en: Regardless of the state of your project—whether it’s greenfield, legacy, a small
    individual library, or a large multimodule project—your first task in implementing
    a CI solution should be to *script your build*. Having a consistent and repeatable
    process that you can automate will help avoid the frustration of buggy build permutations
    due to the mismanagement of dependencies, forgetting to include needed resources
    when creating the distributable package, or unintentionally neglecting build steps,
    among other pitfalls.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 不   不论您的项目处于何种状态——无论是全新项目、遗留项目、小型个人库还是大型多模块项目——在实施 CI 解决方案时，您的第一个任务应该是*编写构建脚本*。拥有一致且可重复的流程，可以自动化的流程，将有助于避免由于依赖管理不当、在创建可分发包时忘记包含所需资源或无意间忽略构建步骤等导致的构建排列组合的痛苦。
- en: You will reap a tremendous amount of time savings from scripting your build.
    Your project *build lifecycle* (all of the discrete steps required to build your
    project) can easily grow more complicated over time, especially as you consume
    more and more dependencies, include various resources, add modules, and add tests.
    You may also need to build your project differently depending on the intended
    deployment environment. For example, you might need to enable debugging capabilities
    in a development or QA environment, but disable debugging in a build intended
    for release to production as well as prevent test classes from being included
    in the distributable package. Manually performing all of the required steps involved
    in building a Java project, including consideration for configuration differences
    per environment, is a hotbed for human error. The first time you neglect a step
    like building an updated dependency and consequently must repeat a build of a
    huge multimodule project to correct your mistake, you will appreciate the value
    of a build script.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 编写构建脚本时，通过脚本化你的构建可以节省大量时间。你的项目*构建生命周期*（构建项目所需的所有离散步骤）随着时间的推移可以变得更加复杂，特别是当你消耗更多依赖、包含各种资源、添加模块和测试时。你可能还需要根据预期的部署环境不同方式构建项目。例如，你可能需要在开发或QA环境中启用调试能力，但在构建用于发布到生产环境的版本时禁用调试，并防止测试类被包含在可分发包中。手动执行构建Java项目所需的所有步骤，包括考虑每个环境的配置差异，是人为错误的温床。第一次忽略构建更新的依赖项等步骤，并因此不得不重复构建一个庞大的多模块项目以纠正你的错误时，你会意识到构建脚本的价值。
- en: 'Whatever tool or framework you choose for scripting your build, take care to
    use a *declarative* approach rather than *imperative*. Here’s a quick reminder
    of the meaning of these terms:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择哪种工具或框架来编写你的构建脚本，都要注意使用*声明性*方法而不是*命令式*方法。这里简要提醒一下这些术语的含义：
- en: Imperative
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 命令式的
- en: Defining an exact procedure with implementation details
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个包含实施细节的确切过程
- en: Declarative
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 声明性的
- en: Defining an action without implementation details
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个没有实施细节的动作
- en: In other words, keep your build script focused on *what* you need to do rather
    than *how* to do it. This will help keep your script understandable, maintainable,
    testable, and scalable by encouraging reuse on other projects or modules. To accomplish
    this, you may need to establish or conform to a known convention, or write plug-ins
    or other external code referenced from your build script that provides the implementation
    details. Some build tools are more apt to foster a declarative approach than others.
    This usually comes with the cost of conforming to a convention versus flexibility.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，保持你的构建脚本专注于*需要*做的事情，而不是如何做。这将有助于保持你的脚本易于理解、可维护、可测试和可扩展，鼓励在其他项目或模块中重复使用。为了实现这一点，你可能需要建立或遵循一个已知的约定，或者编写插件或其他从你的构建脚本引用的外部代码，提供实施细节。一些构建工具更倾向于采用声明性方法而不是其他方法。这通常是在灵活性与遵循约定之间权衡的结果。
- en: The Java ecosystem has several well-established build tools available, so I
    would be surprised if you are currently manually compiling your project with `javac`
    and packaging your class files into a JAR or other package type. You likely already
    have some sort of build process and script established, but in the unlikely scenario
    that you do not, you are starting a brand-new Java project, or you are looking
    to improve an existing script to utilize best practices, this section summarizes
    a few of the most common build tools/frameworks available in the Java ecosystem
    and what they provide you out of the box.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Java生态系统有几个成熟的构建工具可用，所以如果你目前手动使用`javac`编译你的项目并将类文件打包成JAR或其他包类型，我会感到惊讶。你很可能已经有了某种构建流程和脚本，但在极少数情况下，如果你没有，你正在启动一个全新的Java项目，或者你希望改进现有的脚本以利用最佳实践，本节总结了Java生态系统中几种最常见的构建工具/框架及其开箱即用的功能。
- en: 'First, it is important to map out your build process, to determine what you
    need from your build script in order to gain the most benefit. To build a Java
    project, at the bare minimum you need to specify the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，重要的是绘制你的构建过程图，确定你需要从构建脚本中获得的东西以获得最大的效益。要构建一个Java项目，至少需要指定以下内容：
- en: Java version
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Java版本
- en: The version of Java required to compile the project
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 编译项目所需的Java版本
- en: Source directory path
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码目录路径
- en: The directory that includes all of the source code for the project
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 项目的源代码目录
- en: Destination directory path
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 目标目录路径
- en: The directory where compiled class files are expected to be placed
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 预期编译类文件放置的目录
- en: Names, locations, and versions of needed dependencies
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 需要的依赖项的名称、位置和版本
- en: The metadata necessary to locate and gather any dependencies required by your
    project
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 定位和收集项目所需的任何依赖项所需的元数据
- en: 'With this information, you should be able to execute a minimal build process
    with the following steps:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些信息，您应该能够执行以下步骤来执行最小的构建过程：
- en: Collect any needed dependencies.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收集所有必需的依赖项。
- en: Compile the code.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译代码。
- en: Run tests.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试。
- en: Package your application.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打包您的应用程序。
- en: The best way to show how to massage your build process into a build script is
    by example. The following examples demonstrate the use of three of the most common
    build tools to script the minimal build process described for a simple Hello World
    Java application. In no way do these examples explore all of the functionality
    available in these tools. They are simply meant as a crash course to help you
    either begin to understand your existing build script or write your first build
    script to benefit from a full CI solution.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 展示如何将您的构建过程调整为构建脚本的最佳方式是通过示例。以下示例演示了使用三种最常见的构建工具来脚本化为简单的 Hello World Java 应用程序描述的最小构建过程。这些示例无论如何都不会探索这些工具中可用的所有功能。它们只是作为一个速成课程，帮助您开始理解现有的构建脚本或编写您的第一个构建脚本以从完整的
    CI 解决方案中获益。
- en: In evaluating a build tool, bear in mind the actual process your project requires
    to complete a build. Your project may require scripting additional steps that
    are not shown here, and one build tool may be more suited than another to accomplish
    this. It is important that the tool you choose helps you programmatically define
    and accelerate the build process your project requires rather than arbitrarily
    force you to modify your process to fit the requirements of the tool. That said,
    when you learn the capabilities of a tool, reflect on your process and be mindful
    of changes that would benefit your team. This is most important with established
    projects. Changes to the process, however well-intentioned, can be painful for
    a development team. They should be made only intentionally, with a clear understanding
    of the reason for the change and, of course, a clear benefit.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估构建工具时，请记住您的项目完成构建所需的实际过程。您的项目可能需要脚本化其他未在此处显示的步骤，并且一个构建工具可能比另一个更适合完成这些步骤。选择的工具应帮助您以编程方式定义和加速项目所需的构建过程，而不是随意迫使您修改流程以适应工具的要求。话虽如此，当您了解工具的功能时，请反思您的流程，并注意会为您的团队带来好处的变化。这在已建立的项目中尤为重要。不论出于何种善意，对流程的更改对开发团队来说可能是痛苦的。只有在有意识地、明确理解变更原因和显著好处的情况下才应该进行这些更改。
- en: Build with Apache Ant
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Apache Ant 进行构建
- en: '*Apache Ant* is an open source project released under an Apache License by
    the Apache Software Foundation. According to the [Apache Ant documentation](https://ant.apache.org),
    the name is an acronym for Another Neat Tool and was initially part of the Tomcat
    codebase, written by James Duncan Davidson for the purpose of building Tomcat.
    Its first initial release was in 2000.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*Apache Ant* 是一个由 Apache 软件基金会发布的开源项目，根据 Apache 许可证发布。根据[Apache Ant 文档](https://ant.apache.org)，其名称是
    Another Neat Tool 的缩写，最初是 Tomcat 代码库的一部分，由 James Duncan Davidson 编写，用于构建 Tomcat。它的第一个初始版本发布于
    2000 年。'
- en: Apache Ant is a build tool written in Java that provides a way to describe a
    build process as declarative steps within an XML file. This is the first build
    tool that I was exposed to in my Java career, and although Ant has heavy competition
    today, it is still an active project and widely used often in combination with
    other tools.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Ant 是一个用 Java 编写的构建工具，提供了在 XML 文件中描述构建过程的声明性步骤的方式。这是我在我的 Java 生涯中接触的第一个构建工具，尽管
    Ant 今天面临激烈的竞争，但它仍然是一个活跃的项目，并经常与其他工具结合使用。
- en: '[Example 5-1](#ant_build_script_example) is a simple Ant build file I created
    and executed with Ant 1.10.8.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 5-1](#ant_build_script_example) 是我创建并使用 Ant 1.10.8 执行的一个简单的 Ant 构建文件。'
- en: Example 5-1\. Ant build script (build.xml)
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-1\. Ant 构建脚本 (build.xml)
- en: '[PRE0]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[![1](Images/1.png)](#co_continuous_integration_CO1-1)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_continuous_integration_CO1-1)'
- en: The value of the `default` attribute of the project can be set to the name of
    a default target to run when Ant is invoked without a target. For this project,
    the command `ant` without any arguments will run the *package* target.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将项目的 `default` 属性值设置为在没有目标的情况下调用 Ant 时要运行的默认目标的名称。对于这个项目，不带任何参数运行 `ant` 命令将运行
    *package* 目标。
- en: '[![2](Images/2.png)](#co_continuous_integration_CO1-2)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_continuous_integration_CO1-2)'
- en: Property elements are hardcoded, immutable values that may be used more than
    once in the rest of the build script. Using them helps with both readability and
    maintainability.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Property元素是硬编码的不可变值，可以在构建脚本的其余部分多次使用。使用它们有助于提高可读性和可维护性。
- en: '[![3](Images/3.png)](#co_continuous_integration_CO1-3)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_continuous_integration_CO1-3)'
- en: This path element is how I chose to manage the location of needed dependencies
    for this project. In this case, both the *junit* and *hamcrest-core* JARs are
    manually placed in the directory configured here. This technique implies that
    dependencies would be checked into source control along with the project. Although
    it was simple to do for this example, this is not a recommended practice. [Chapter 6](ch06.xhtml#package_management)
    discusses package management in detail.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 此路径元素是我选择用来管理此项目所需依赖项位置的方式。在这种情况下，*junit*和*hamcrest-core* JAR包都手动放置在这里配置的目录中。这种技术意味着依赖项将与项目一起提交到源代码控制中。尽管这在本例中很简单，但这并不是推荐的做法。[第6章](ch06.xhtml#package_management)详细讨论了包管理。
- en: '[![4](Images/4.png)](#co_continuous_integration_CO1-4)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_continuous_integration_CO1-4)'
- en: The `compile` target is responsible for the compilation of the source code (this
    project specifies Java 11) and placement of the resulting class files in the configured
    location. This target depends on the *clean* target, meaning the clean target
    will be run first, to ensure that compiled class files are fresh and not left
    over from an old build.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`compile`目标负责编译源代码（本项目指定Java 11），并将生成的类文件放置在配置的位置。此目标依赖于*clean*目标，这意味着将首先运行clean目标，以确保编译的类文件是新鲜的，而不是旧构建中遗留下来的。'
- en: '[![5](Images/5.png)](#co_continuous_integration_CO1-5)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](Images/5.png)](#co_continuous_integration_CO1-5)'
- en: The `test` target configures the JUnit Ant task that will run all of the available
    unit tests and print the results to the screen.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`test`目标配置了JUnit Ant任务，该任务将运行所有可用的单元测试并将结果打印到屏幕上。'
- en: '[![6](Images/6.png)](#co_continuous_integration_CO1-6)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](Images/6.png)](#co_continuous_integration_CO1-6)'
- en: The `package` target will assemble and place a final JAR file in the configured
    location.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`package`目标将组装并放置最终的JAR文件在配置的位置。'
- en: Executing the one-line command `ant package` will take our Java project, compile
    it, run unit tests, and then assemble a JAR file for us. Ant is flexible, rich
    in functionality, and satisfies our goal of scripting a minimal build. The XML
    configuration file is a clean, straightforward way of documenting the project’s
    build lifecycle. By itself, Ant is lacking in the way of dependency management.
    However, tools like [Apache Ivy](https://oreil.ly/7t5v5) have been developed to
    extend this functionality to Ant.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 执行一行命令`ant package`将接管我们的Java项目，编译它，运行单元测试，然后为我们组装一个JAR文件。Ant灵活且功能丰富，满足我们脚本化最小构建的目标。XML配置文件是记录项目构建生命周期的清晰简洁方式。单独使用Ant在依赖管理方面存在不足。但是，像[Apache
    Ivy](https://oreil.ly/7t5v5)这样的工具已被开发用来扩展此功能以适用于Ant。
- en: Build with Apache Maven
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Apache Maven构建
- en: According to the [Apache Maven Project documentation](https://oreil.ly/CziRT),
    *maven* is a Yiddish word meaning *accumulator of knowledge*. Like Apache Ant,
    Maven is also an open source project of the Apache Software Foundation. It began
    as an improvement to the Jakarta turbine project build that was utilizing varied
    configurations of Ant for each subproject. Its first official release was in 2004.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 根据[Apache Maven项目文档](https://oreil.ly/CziRT)，*maven*是意第绪语中的一个词，意为*知识的积累者*。与Apache
    Ant类似，Maven也是Apache软件基金会的一个开源项目。它起初是对Jakarta turbine项目构建的改进，该项目为每个子项目使用了各种Ant配置。它于2004年首次正式发布。
- en: Like Apache Ant, Maven uses an XML document, (a POM file) to describe and manage
    Java projects. This document records information about the project, including
    a unique identifier for the project, the required compiler version, configuration
    property values, and metadata on all required dependencies and their versions.
    One of the most powerful features of Maven is its dependency management and the
    ability to use repositories to share dependencies with other projects.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 与Apache Ant类似，Maven使用XML文档（POM文件）来描述和管理Java项目。该文档记录了项目的信息，包括项目的唯一标识符、所需的编译器版本、配置属性值以及所有必需依赖项及其版本的元数据。Maven最强大的功能之一是其依赖管理和使用存储库与其他项目共享依赖项的能力。
- en: Maven relies heavily on convention in order to provide a uniform method of managing
    and documenting a project that can easily scale across all projects using Maven.
    A project is expected to be laid out on the filesystem in a specific way. To keep
    the script declarative, customized implementations require building custom plug-ins.
    Although it can be extensively customized to override expected defaults, Maven
    works out of the box with little configuration if you conform to the expected
    project structure.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Maven 在提供一种统一的项目管理和文档化方法上依赖于约定，这可以轻松地跨所有使用 Maven 的项目进行扩展。期望将项目以特定方式布置在文件系统上。为了保持脚本声明性，定制实现需要构建自定义插件。虽然可以对预期的默认值进行广泛定制，但如果符合预期的项目结构，Maven
    就可以无需大量配置即可开箱即用。
- en: '[Example 5-2](#maven_pom_file_example) is a simple POM file I configured for
    my Java 11 environment using Maven 3.6.3.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 5-2](#maven_pom_file_example) 是我使用 Maven 3.6.3 配置的适用于我的 Java 11 环境的简单 POM
    文件。'
- en: Example 5-2\. Maven POM file (pom.xml)
  id: totrans-76
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-2\. Maven POM 文件（pom.xml）
- en: '[PRE1]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[![1](Images/1.png)](#co_continuous_integration_CO2-1)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_continuous_integration_CO2-1)'
- en: Every project is uniquely identified by its configured `groupId`, `artifactId`,
    and `version`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 每个项目都由其配置的 `groupId`、`artifactId` 和 `version` 唯一标识。
- en: '[![2](Images/2.png)](#co_continuous_integration_CO2-2)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_continuous_integration_CO2-2)'
- en: Properties are hardcoded values that can potentially be used in multiple places
    in the POM file. They can be either custom properties or built-in properties used
    by plug-ins or goals.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 属性是硬编码的值，可能在 POM 文件中的多个地方使用。它们可以是自定义属性，也可以是插件或目标使用的内置属性。
- en: '[![3](Images/3.png)](#co_continuous_integration_CO2-3)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_continuous_integration_CO2-3)'
- en: In the `dependencies` block, all direct dependencies of the project are identified.
    This project relies on JUnit to run the unit tests, so the *junit* dependency
    is specified here. JUnit has a dependency itself on *hamcrest-core*, but Maven
    is smart enough to figure that out without having to include it here. By default,
    Maven will pull these dependencies from Maven Central.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `dependencies` 块中，识别项目的所有直接依赖项。该项目依赖于 JUnit 运行单元测试，因此在此处指定了 *junit* 依赖项。JUnit
    本身又依赖于 *hamcrest-core*，但 Maven 足够智能，可以在此处包含它而无需在此处包含它。默认情况下，Maven 将从 Maven 中央拉取这些依赖项。
- en: '[![4](Images/4.png)](#co_continuous_integration_CO2-4)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_continuous_integration_CO2-4)'
- en: The `build` block is where plug-ins are configured. Unless there is configuration
    you want to override, this block isn’t required.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`build` 块是配置插件的地方。除非有配置要覆盖，否则不需要此块。'
- en: '[![5](Images/5.png)](#co_continuous_integration_CO2-5)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](Images/5.png)](#co_continuous_integration_CO2-5)'
- en: Default plug-in bindings exist for all of the lifecycle phases, but in this
    case, I wanted to configure `maven-compiler-plugin` to use Java version 11 rather
    than the default. The property that controls this for the plug-in is `maven​.com⁠piler.release`
    in the `properties` block. This configuration could have been put in the `plugins`
    block, but it makes sense to move it to the `properties` block for better visibility
    toward the top of the file. This property replaces `maven.compiler.source` and
    `maven.compiler.target` that is usually seen when using older versions of Java.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 所有生命周期阶段都存在默认的插件绑定，但在这种情况下，我想要配置 `maven-compiler-plugin` 来使用 Java 版本 11，而不是默认版本。控制此插件的属性是
    `properties` 块中的 `maven​.com⁠piler.release`。此配置可以放在 `plugins` 块中，但将其移动到 `properties`
    块以更好地向文件顶部显示更有意义。此属性替换了在使用较旧版本的 Java 时通常看到的 `maven.compiler.source` 和 `maven.compiler.target`。
- en: Warning
  id: totrans-88
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: It is a good idea to lock down all of your Maven plug-in versions to avoid using
    Maven defaults. Specifically, pay special attention to Maven instructions for
    configuring your build script when using older versions of Maven and Java versions
    9 or greater. The default plug-in versions of your Maven installation might not
    be compatible with later versions of Java.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 锁定所有 Maven 插件版本是个好主意，以避免使用 Maven 默认值。特别要注意当使用较旧版本的 Maven 和 Java 版本 9 或更高版本时，根据
    Maven 的配置构建脚本的说明。您的 Maven 安装的默认插件版本可能与较新版本的 Java 不兼容。
- en: Because of the strong reliance on convention, this Maven build script is quite
    brief. With this small POM file, I am able to execute `mvn package` to compile,
    run tests, and assemble a JAR file, all utilizing default settings. If you spend
    any time with Maven, you will quickly realize that it is much more than just a
    build tool and is chock-full of powerful features. For someone new to Maven, its
    potential complexity can be overwhelming. Also, customization through creating
    a new Maven plug-in is daunting when the customization is minor. At the time of
    this writing, the [Apache Maven Project](https://oreil.ly/CziRT) documentation
    contains excellent resources, including a [Maven in 5 Minutes](https://oreil.ly/dkxa6)
    guide. I highly recommend starting with these resources if you are unfamiliar
    with Maven.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于对约定的强烈依赖，这个 Maven 构建脚本非常简洁。有了这个小小的 POM 文件，我可以执行 `mvn package` 来编译、运行测试并组装一个
    JAR 文件，所有这些都使用默认设置。如果你花时间使用 Maven，你很快就会意识到它不仅仅是一个构建工具，而且充满了强大的功能。对于刚接触 Maven 的人来说，它的潜在复杂性可能会让人感到不知所措。此时，[Apache
    Maven 项目](https://oreil.ly/CziRT) 的文档包含了非常好的资源，包括 [Maven in 5 Minutes](https://oreil.ly/dkxa6)
    指南。如果你对 Maven 不熟悉，我强烈推荐从这些资源开始学习。
- en: Tip
  id: totrans-91
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Although the [Apache Maven Ant Plugin](https://oreil.ly/DOg5K) is no longer
    maintained, it is possible to generate an Ant build file from a Maven POM file.
    Doing this will help you appreciate everything you get out of the box with Maven’s
    convention and defaults! In the same directory as your *pom.xml* file, invoke
    the Maven plug-in with the command `mvn ant:ant`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 [Apache Maven Ant 插件](https://oreil.ly/DOg5K) 不再维护，但仍然可以从 Maven POM 文件生成一个
    Ant 构建文件。这样做将帮助你体会 Maven 的约定和默认设置所带来的一切！在与你的 *pom.xml* 文件相同的目录中，使用 `mvn ant:ant`
    命令调用 Maven 插件。
- en: Build with Gradle
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Gradle 进行构建
- en: '*Gradle* is an open source build tool under the Apache 2.0 license. Hans Dockter,
    the founder of Gradle, [explained in the Gradle Forums](https://oreil.ly/1mEwy)
    that his original idea was to call the project Cradle with a *C*. He ultimately
    decided on the name Gradle with a *G* since it used Apache Groovy for the domain-specific
    language (DSL). Gradle 1.0 was released in 2012, so in comparison to Apache Ant
    and Apache Maven, Gradle is the new kid on the block.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*Gradle* 是一个根据 Apache 2.0 许可发布的开源构建工具。Gradle 的创始人 Hans Dockter 在 [Gradle 论坛中解释](https://oreil.ly/1mEwy)，他最初的想法是将项目命名为带有
    *C* 的 Cradle。最终他决定使用带有 *G* 的 Gradle，因为它使用 Apache Groovy 作为领域特定语言（DSL）。Gradle 1.0
    于 2012 年发布，因此与 Apache Ant 和 Apache Maven 相比，Gradle 是新进者。'
- en: One of the biggest differences between Gradle and Maven and Ant is that the
    Gradle build script is not XML based. Instead, Gradle build scripts can be written
    with either a Groovy or Kotlin DSL. Like Maven, Gradle also utilizes convention,
    but is more flexible compared to Maven. The [Gradle documentation](https://oreil.ly/Vvhch)
    touts the flexibility of the tool and includes instructions on how to easily customize
    your build.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle 与 Maven 和 Ant 最大的区别之一是，Gradle 构建脚本不是基于 XML 的。相反，Gradle 构建脚本可以用 Groovy
    或 Kotlin DSL 编写。与 Maven 类似，Gradle 也利用约定，但比 Maven 更灵活。[Gradle 文档](https://oreil.ly/Vvhch)
    强调了该工具的灵活性，并包括了如何轻松定制你的构建的说明。
- en: Tip
  id: totrans-96
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Gradle has extensive online documentation on [migrating Maven builds to Gradle](https://oreil.ly/RqR1s).
    You can generate a Gradle build file from an existing Maven POM.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle 在 [将 Maven 构建迁移到 Gradle](https://oreil.ly/RqR1s) 方面有广泛的在线文档。你可以从现有的 Maven
    POM 文件生成一个 Gradle 构建文件。
- en: '[Example 5-3](#gradle_build_script_example) is a simple Gradle build file that
    I generated from the content of [Example 5-2](#maven_pom_file_example) in the
    previous section.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 5-3](#gradle_build_script_example) 是一个简单的 Gradle 构建文件，我从上一节的 [示例 5-2](#maven_pom_file_example)
    的内容生成的。'
- en: Example 5-3\. Gradle build script (build.gradle)
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-3\. Gradle 构建脚本（build.gradle）
- en: '[PRE2]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[![1](Images/1.png)](#co_continuous_integration_CO3-1)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_continuous_integration_CO3-1)'
- en: Gradle plug-ins are applied by adding their *plug-in ID* to the `plugins` block.
    The `java` plug-in is a Gradle Core plug-in that provides compilation, testing,
    packaging, and other functionality for Java projects.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle 插件通过将它们的 *插件 ID* 添加到 `plugins` 块来应用。`java` 插件是 Gradle 核心插件，为 Java 项目提供编译、测试、打包以及其他功能。
- en: '[![2](Images/2.png)](#co_continuous_integration_CO3-2)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_continuous_integration_CO3-2)'
- en: Repositories for dependencies are provided in the `repositories` block. Dependencies
    are resolved using these settings.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项的仓库在 `repositories` 块中提供。使用这些设置来解析依赖项。
- en: '[![3](Images/3.png)](#co_continuous_integration_CO3-3)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_continuous_integration_CO3-3)'
- en: Gradle handles dependencies similarly to Maven. The JUnit dependency is required
    for our unit tests, so it is included in the `dependencies` block.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle 处理依赖项的方式类似于 Maven。我们的单元测试需要 JUnit 依赖项，因此它被包含在 `dependencies` 块中。
- en: '[![4](Images/4.png)](#co_continuous_integration_CO3-4)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_continuous_integration_CO3-4)'
- en: The `sourceCompatibility` configuration setting is provided by the `java` plug-in
    and maps to the `source` option of `javac`. There is also a `targetCompatibility`
    configuration setting. Its default value is the value of `sourceCompatibility`,
    so there was no reason to add it to the build script.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`sourceCompatibility` 配置设置由 `java` 插件提供，并映射到 `javac` 的 `source` 选项。还有一个 `targetCompatibility`
    配置设置。其默认值是 `sourceCompatibility` 的值，因此没有必要将其添加到构建脚本中。'
- en: '[![5](Images/5.png)](#co_continuous_integration_CO3-5)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](Images/5.png)](#co_continuous_integration_CO3-5)'
- en: The flexibility of Gradle allows me to add explicit encoding for the Java compiler.
    A task provided by the `java` plug-in, called `compileJava`, is of the type `Java​Com⁠piler`.
    This code block sets the encoding property on this compile task.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle 的灵活性允许我为 Java 编译器添加显式编码设置。`java` 插件提供的一个任务称为 `compileJava`，其类型为 `Java​Com⁠piler`。此代码块在这个编译任务上设置了编码属性。
- en: This Gradle build script allows me to compile, run tests, and assemble a JAR
    file for my project by executing the single command `gradle build`. Because Gradle
    builds are based on well-known conventions, build scripts contain only what is
    needed that differentiates the build, helping to keep them small and maintainable.
    This simple script shows how powerful and flexible Gradle can be, especially for
    Java projects that have a more complicated build process. In that case, the up-front
    investment required to understand the Gradle DSL for customization is well worth
    the time.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Gradle 构建脚本允许我通过执行单个命令 `gradle build` 来编译、运行测试并组装项目的 JAR 文件。由于 Gradle 构建基于众所周知的约定，因此构建脚本仅包含区分构建所需的内容，有助于保持其小巧和可维护性。这个简单的脚本展示了
    Gradle 的强大和灵活性，特别适用于具有较复杂构建过程的 Java 项目。在这种情况下，投入时间去理解用于定制的 Gradle DSL 是非常值得的。
- en: All three of these tools for building your Java project have their own strengths
    and weaknesses. Choose a tool based on the needs of your project, the experience
    of your team, and the flexibility required. Wrangling together a build script—however
    you choose to do it—and with whatever tool you choose to do it, will increase
    your efficiency by leaps and bounds. Building a Java project is a repetitive process
    consisting of numerous steps, ripe for human error, and marvelously suitable for
    automation. Reducing your project build to a single command saves ramp-up time
    for new developers, increases efficiency during development tasks in a local development
    environment, and paves the way for build automation, an integral component of
    an effective CI solution.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种用于构建 Java 项目的工具各有优劣。选择一个工具应基于项目需求、团队经验和所需的灵活性。无论你如何选择和使用构建脚本，以及选择任何工具，都将极大地提高你的效率。构建
    Java 项目是一个重复的过程，包含许多步骤，容易出现人为错误，但非常适合自动化。将项目构建简化为单个命令可节省新开发人员的上手时间，在本地开发环境中增加开发任务的效率，并为构建自动化铺平道路，这是有效
    CI 解决方案的重要组成部分。
- en: Continuously Build
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续构建
- en: The most telltale sign that code integration was unsuccessful is the failure
    of a build. Therefore, it stands to reason that a project should be built often
    in order to detect and resolve any issues as soon as possible. In fact, *every
    contribution to the mainline codebase should be expected to result in a build
    that compiles successfully and passes all unit tests*.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 代码集成失败最明显的迹象是构建失败。因此，项目应经常构建，以尽早检测和解决任何问题。事实上，*对主线代码库的每一次贡献都应期望能够成功编译并通过所有单元测试*。
- en: Note
  id: totrans-115
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: When referring to building a project after code is merged into the mainline
    source code repository, I intentionally use the word *contribution* as opposed
    to *commit* or *check-in*. This is simply because your development team may have
    agreed to follow multiple development processes (all valid), and in some of these,
    a *contribution* to the mainline may be the merge of a branch or the merge of
    a pull request—both of which potentially consist of one or more commits.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当提及将代码合并到主干源代码库后构建项目时，我故意使用*contribution*一词，而不是*commit*或*check-in*。这仅是因为您的开发团队可能已同意遵循多个开发流程（都是有效的），在其中一些流程中，*contribution*到主干可能是一个分支的合并或拉取请求的合并——两者都可能包含一个或多个提交。
- en: 'The following is a typical developer workflow using test-driven development:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用测试驱动开发的典型开发者工作流程：
- en: Check out the latest code from source control to a local workspace.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从源代码控制中检出最新的代码到本地工作空间。
- en: Build and run all tests for the project to ensure a clean start. (There should
    be a build script for this. Refer to [“Declaratively Script Your Build”](#declaratively_script_your_build).)
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行项目的所有测试，以确保开始时处于干净状态。（应该有一个构建脚本来完成此操作。参见[“声明式地编写您的构建”](#declaratively_script_your_build)。）
- en: Write the code and related unit tests for the new feature or bug fix.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写新功能或错误修复的代码和相关单元测试。
- en: Run the new unit tests to ensure that they pass.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行新的单元测试，确保它们通过。
- en: Build and run *all* unit tests for the project to ensure that the new code doesn’t
    result in negative side effects when integrated with the existing code. (Again,
    use a build script for this.)
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行项目的*所有*单元测试，确保新代码在与现有代码集成时不会产生负面影响。（再次强调，使用构建脚本完成此操作。）
- en: Commit the new code along with the new tests to the codebase.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新代码与新测试一同提交到代码库。
- en: This process aims to prevent issues (including the introduction of bugs or loss
    of functionality) with integrating code before it leaves your local development
    workspace. However, problems can manifest during this workflow that will cause
    pain down the road. Some will be caused by the realities of human nature, and
    others arise because, regardless of how much effort is put into advanced planning,
    it is nearly impossible to prevent every potential incompatibility introduced
    by concurrent development. Do not misunderstand; I am *not* saying that this process
    is wrong and should be discarded altogether. Instead, this section explains how
    an automated CI implementation helps mitigate the problems that can arise during
    this workflow and bolster your efficiency and productivity as a developer.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 此流程旨在在代码离开您的本地开发工作空间之前防止问题（包括引入错误或功能丢失）。但是，在此工作流程期间可能会出现问题，这些问题会在今后带来痛苦。一些问题是由于人类本性的现实而引起的，而另一些则是因为无论进行多少先进的规划努力，几乎不可能防止由并行开发引入的每一个潜在不兼容性。不要误会；我*并不*是说这个过程是错误的，应该完全丢弃。相反，本节解释了自动化的持续集成实施如何帮助减轻可能在此工作流程中出现的问题，并增强您作为开发者的效率和生产力。
- en: It isn’t enough for a developer to successfully build a project in their own
    local environment. Even if every developer diligently abides by the agreed-upon
    process and commits code changes only after all tests pass, you shouldn’t rely
    on this alone. The simplest reason is that a developer might not have the latest
    changes from the mainline (an even more likely scenario when many developers are
    working in the same codebase). This could result in an incompatibility that isn’t
    discovered until after the code is merged.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开发人员来说，仅在自己的本地环境中成功构建项目是不够的。即使每个开发人员都严格遵守约定的流程，并且只有在所有测试通过后才提交代码更改，您也不应仅依赖于此。最简单的原因是，开发人员可能没有来自主干的最新更改（当许多开发人员在同一个代码库中工作时，这种情况更有可能发生）。这可能导致在代码合并后才发现的不兼容性。
- en: Sometimes issues with tests might surface only when someone else attempts to
    do a build or run tests in their own local development environment. For example,
    more than once I’ve embarrassingly forgotten to commit a new file or resource
    that I’ve created to the codebase. This means that the next developer who collects
    these changes gets to suffer through the annoyance of having either the build
    or tests fail immediately. Another issue I’ve seen is code written in such a way
    that it works in only a specific environment or a specific OS.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，测试问题可能只在其他人尝试在他们自己的本地开发环境中构建或运行测试时才会显露出来。例如，不止一次，我尴尬地忘记了提交我创建的新文件或资源到代码库中。这意味着接下来收集这些更改的开发人员将遭受要么立即构建失败，要么测试失败的烦恼。我见过的另一个问题是，代码写成只在特定环境或特定操作系统中才能工作。
- en: We all have bad days, and these problems slip by us from time to time even in
    the most ideal circumstances. But rather than let broken builds spread through
    the team like a virus, strategies can be put in place to help to mitigate integration
    issues like this. The most common is using automatic build servers, or CI servers.
    These servers are shared by development teams responsible for performing full
    builds, including running tests, and reporting the result of the build after code
    changes have been committed.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都会有不好的日子，即使在最理想的情况下，这些问题有时也会悄悄溜走。但与其让破碎的构建像病毒一样在团队中蔓延，不如采取策略来帮助减轻这类集成问题。最常见的方法是使用自动构建服务器或CI服务器。这些服务器由负责执行完整构建（包括运行测试）并在代码更改提交后报告构建结果的开发团队共享使用。
- en: Popular CI servers you might recognize include Jenkins, CircleCI, TeamCity,
    Bamboo, and GitLab. More options are coming on the scene like JFrog Pipelines,
    and some have more features and capabilities than others, but the primary objective
    is to establish a referee for the code changes coming in to the shared repository
    by building frequently and reporting when a problem occurs. Utilizing a CI server
    for the purpose of running builds automatically is the best way to ensure that
    builds are happening regularly, revealing any integrations issues early.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能熟悉的流行CI服务器包括Jenkins、CircleCI、TeamCity、Bamboo和GitLab。还有一些新选项正在涌现，如JFrog Pipelines，有些比其他服务器具有更多的功能和能力，但主要目标是通过经常构建并在出现问题时报告来为共享代码库中的代码更改建立一个裁判。利用CI服务器自动运行构建的目的是确保定期进行构建，早期发现任何集成问题。
- en: Automate Tests
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化测试
- en: Outside of running individual tests during development, most often within an
    IDE, a developer should have a quick method of running the full suite of automated
    tests prior to checking in new code to the codebase.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在开发过程中运行单个测试（通常在IDE内部），开发人员在将新代码提交到代码库之前，应该有一种快速运行完整自动化测试套件的方法。
- en: The minimal build process outlined in [“Declaratively Script Your Build”](#declaratively_script_your_build)
    includes a step for automatically running unit tests. Each build script example
    also includes this unit test step. This is no accident. In fact, this part of
    your build is absolutely essential for a healthy CI solution and is worthy of
    a decent amount of time and attention. One of the primary purposes of CI is having
    the ability to catch integration issues as early in the development process as
    possible.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“声明性地编写您的构建脚本”](#declaratively_script_your_build)中概述的最小构建过程包括自动运行单元测试的步骤。每个构建脚本示例都包括这个单元测试步骤。这并非偶然。事实上，您构建的这一部分对于健康的CI解决方案至关重要，并值得花费相当多的时间和注意力。CI的主要目的之一是尽可能早地在开发过程中捕捉集成问题的能力。
- en: Unit tests alone will not expose every single issue—that’s an unrealistic expectation.
    But writing a strong set of unit tests is one of the best proactive approaches
    to detecting the most obvious problems early on. Because unit tests can be run
    even prior to the first stages of formal quality assurance, they are an extremely
    valuable part of the development cycle. They are the first set of safety measures
    that you can take to ensure that your software will behave correctly in production.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试本身不会揭示每一个问题 —— 这是不现实的期望。但编写一组强大的单元测试是早期检测最明显问题的最佳预防性方法之一。因为甚至可以在正式质量保证的第一个阶段之前运行单元测试，所以它们是开发周期中非常有价值的一部分。它们是您可以采取的第一套安全措施，以确保您的软件在生产环境中的正确行为。
- en: This section does not go into specifics on how to write unit tests in Java.
    I assume that you understand and accept their importance, that your project has
    unit tests, and that you utilize a framework that facilitates automatically running
    them like JUnit or TestNG. If you do not, immediately stop and write a simple
    unit test for your project that can be automatically run during your build for
    the sake of having this step available to expand on in your CI solution. Then,
    schedule a time to sit down with your development team and strategize how you
    will write and maintain unit tests moving forward.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分不会详细说明如何在Java中编写单元测试。我假设你理解并接受它们的重要性，你的项目有单元测试，并且你使用了一个能够自动运行它们的框架，比如JUnit或TestNG。如果你没有，立即停下来为你的项目编写一个简单的单元测试，以便在构建过程中自动运行，以便在你的CI解决方案中扩展这一步骤。然后，安排时间与你的开发团队坐下来，策划你将如何编写和维护单元测试。
- en: Numerous test tools are available in the Java ecosystem, and this section is
    not meant to be an exhaustive comparison or an endorsement of one over another.
    Instead, I discuss how test automation should fit into your CI process, the qualities
    of your test suite to strive for, and how to avoid common pitfalls in the context
    of CI that will eat away at your efficiency.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Java生态系统中有许多测试工具可用，本节不旨在对它们进行详尽的比较或推荐其中一种。相反，我讨论测试自动化应该如何融入你的CI流程，你的测试套件应该追求的特性，以及在CI环境中如何避免常见的陷阱，这些陷阱会影响你的效率。
- en: Monitor and Maintain Tests
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控和维护测试
- en: Checking out the latest code to your local development workspace is pretty straightforward.
    Compiling and running all of the unit tests is straightforward as well. But as
    you add more modules, and your project becomes more complicated, doing a complete
    build and running all of the tests will begin to take more time. The longer your
    development process takes, the more likely that other code changes have been introduced
    to the mainline ahead of yours.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 将最新的代码检出到你的本地开发工作空间是相当简单的。编译和运行所有的单元测试也很简单。但随着你添加更多的模块，你的项目变得越来越复杂，进行完整的构建并运行所有的测试将会花费更多的时间。你的开发过程越长，其他代码更改就越有可能在你之前引入到主干线上。
- en: To prevent a potential break, you would have to check out the newest changes
    and run all of the tests again—not a very efficient process. Frustration can lead
    to developers taking shortcuts and skipping running the tests in an effort to
    commit code to the mainline before it is changed out from under them. Obviously,
    this is a slippery slope that is guaranteed to result in broken code in the mainline
    more often, slowing the entire team.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止潜在的中断，你将不得不检出最新的更改并重新运行所有的测试——这不是一个非常高效的过程。沮丧可能会导致开发人员采取捷径，跳过运行测试的步骤，以便在主干代码被更改之前提交代码。显然，这是一个很容易导致主干代码更频繁出现问题的泥潭，从而减慢整个团队的速度。
- en: It takes time to maintain tests, and this time should be regularly built in
    to the development schedule. Just like the rest of your codebase, tests require
    improvements and adjustments over time. When they become obsolete, they should
    be removed. When they break, they should be fixed. Often when browsing through
    various codebases, I’ll come across test cases that are commented out. This happens
    for a few reasons; none of them good. Sometimes it’s simply because a team was
    short on time and felt the need to force through a build to meet a deadline, with
    the promise of revisiting the tests at a later time. Sometimes, it’s because a
    particular test case inconsistently fails, known as a *flaky* test. This could
    be due to a race condition or a dynamic value that the test erroneously expects
    to be static.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 维护测试需要时间，这个时间应该定期纳入到开发进度中。就像你的代码库的其余部分一样，测试需要随着时间的推移进行改进和调整。当它们变得过时时，它们应该被移除。当它们失败时，它们应该被修复。经常在浏览各种代码库时，我会遇到被注释掉的测试用例。这发生的原因有几种；没有一种是好的。有时只是因为一个团队时间紧迫，感到需要强行通过一个构建过程以满足截止日期，并承诺稍后再次审查测试。有时，是因为一个特定的测试用例不一致地失败，这被称为*flaky*测试。这可能是由于竞争条件或测试错误地期望为静态的动态值。
- en: In either case, manipulating tests not to run is a dangerous business and indicates
    bigger problems afoot with the development team. A review of priorities is in
    order. Not addressing stale or brittle tests, or even worse, not writing them
    at all, removes the guardrails for your project and defeats the purpose of the
    CI process you have carefully put in place.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种情况，操控测试不运行都是一种危险的做法，表明开发团队存在更大的问题。需要重新审视优先事项。不处理过时或脆弱的测试，甚至更糟的是根本不编写测试，会削弱项目的防护措施，也违背了你精心设计的持续集成流程的初衷。
- en: Sometimes tests are not run because it is determined they take too much time.
    Use your CI server to regularly record how long test runs take and determine your
    acceptable threshold. As your project grows and you see the amount of time for
    builds increase beyond your acceptable threshold, stop to review your tests. Look
    for obsolete tests, duplicates, and tests that could be run in parallel. Considering
    how often you expect your build server to run (potentially after every code change),
    every second counts.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候测试不运行是因为确定它们耗时过长。利用你的持续集成服务器定期记录测试运行时间，并确定可接受的阈值。随着项目的增长，如果构建时间超出可接受的阈值，就要停下来检查你的测试。寻找过时的测试、重复的测试以及可以并行运行的测试。考虑你希望构建服务器多频繁运行（潜在地在每次代码变更后），每秒钟都很重要。
- en: Summary
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter presented continuous integration as an essential practice for a
    development team. Tools have developed over time that have helped increase our
    efficiency in building software projects. Automatically triggering builds as well
    as automatically running tests has helped developers better concentrate on coding
    and catch errant code earlier in the development process. It is easy to take for
    granted and enjoy the effort saved by automation, but it is important to understand
    the details underneath, especially when it comes to your test suite. Don’t let
    poorly maintained tests take away the benefit of your continuous integration system.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了持续集成作为开发团队的一项基本实践。随着时间的推移，开发的工具不断发展，帮助我们提高了在构建软件项目方面的效率。自动触发构建以及自动运行测试有助于开发人员更好地专注于编码，并在开发过程中更早地捕获错误代码。人们很容易想当然地享受自动化节省的工作量，但理解底层的细节尤为重要，特别是在涉及到你的测试套件时。不要让维护不良的测试削弱持续集成系统带来的好处。
