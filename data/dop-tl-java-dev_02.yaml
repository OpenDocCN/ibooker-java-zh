- en: Chapter 2\. The System of Truth
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章 真相系统
- en: Stephen Chin
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 斯蒂芬·钦
- en: A complex system that works is invariably found to have evolved from a simple
    system that worked.
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个复杂的运行良好的系统，往往是从一个简单的运行良好的系统演变而来的。
- en: ''
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: John Gall (Gall’s law)
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 约翰·高尔（高尔定律）
- en: To have an effective DevOps pipeline, it is important to have a single system
    of truth to understand what bits and bytes are being deployed into production.
    Typically, this starts with a source code management system that contains all
    of the source code that gets compiled and built into the production deployment.
    By tracing a production deployment back to a specific revision in source control,
    you can do root cause analysis of bugs, security holes, and performance issues.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建有效的DevOps流水线，重要的是要有一个统一的真相系统，以了解哪些位和字节正在被部署到生产环境中。通常，这始于一个包含所有源代码的源代码管理系统，这些代码被编译和构建成生产部署。通过将生产部署追溯到源代码控制中的特定修订版本，您可以对错误、安全漏洞和性能问题进行根本原因分析。
- en: 'Source code management solves several key roles in the software delivery lifecycle:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码管理在软件交付生命周期中发挥了几个关键角色：
- en: Collaboration
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 协作
- en: Large teams working on a single codebase would constantly get blocked by one
    another without effective source code management, reducing productivity as the
    team size grows.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 大型团队在单个代码库上工作时，如果没有有效的源代码管理，将不断地被彼此阻塞，随着团队规模的增长，生产力将降低。
- en: Versioning
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 版本控制
- en: Source code systems let you track versions of the code to identify what is being
    deployed into production or released to a customer.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码系统让您跟踪代码的版本，以确定部署到生产环境或发布给客户的内容。
- en: History
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 历史
- en: By keeping a chronological record of all versions of software as it is developed,
    it is possible to revert to an older version of the code or identify the specific
    change that caused a regression.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在开发软件时保留所有版本的时间记录，可以回滚到较旧的代码版本，或者确定导致回归的特定更改。
- en: Attribution
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 归属
- en: Knowing who made the changes in a particular file allows you to identify ownership,
    assess domain expertise, and assess risk when making changes.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 知道谁在特定文件中进行了更改，可以帮助您确定所有权，评估领域专业知识，并在进行更改时评估风险。
- en: Dependencies
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖
- en: Source code has become the canonical source for other key metadata about the
    project, like dependencies on other packages.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码已成为项目的其他关键元数据的规范来源，比如对其他软件包的依赖关系。
- en: Quality
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 质量
- en: A source code management system allows for easy peer review of changes before
    they are accepted, increasing the overall quality of the software.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码管理系统允许在接受更改之前轻松进行同行审查，从而提高软件的整体质量。
- en: Since source code management plays such a critical role in software development,
    it is important to understand how it works and select a system that best meets
    the needs of your organization and the desired DevOps workflow.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于源代码管理在软件开发中起着如此关键的作用，重要的是要了解它的工作原理，并选择一个最适合您的组织和期望的DevOps工作流程的系统。
- en: Three Generations of Source Code Management
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 源代码管理的三代
- en: Collaboration is a big part of software development, and as you scale with larger
    teams, the ability to collaborate effectively on a shared codebase often becomes
    a bottleneck to developer productivity. Also, the complexity of systems tends
    to increase, so rather than managing a dozen files or a handful of modules, it
    is common to see thousands of source files that need to be updated en masse to
    accomplish system-wide changes and refactorings.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 协作是软件开发的重要组成部分，随着团队规模的扩大，有效地在共享代码库上进行协作的能力通常成为开发人员生产力的瓶颈。此外，系统的复杂性往往会增加，因此，与管理十几个文件或少数模块不同，通常会看到需要大量更新的数千个源文件，以实现系统范围的更改和重构。
- en: 'To manage the need to collaborate on codebases, *source code management* *(SCM)*
    systems were created. The first-generation SCM systems handled collaboration via
    file locking. Examples of these are SCCS and RCS, which required that you lock
    files before editing, make your changes, and then release the lock for other folks
    to contribute. This seemingly eliminated the possibility of two developers making
    conflicting changes, with two major drawbacks:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了管理对代码库的协作需求，*源代码管理*（SCM）系统被创建了。第一代SCM系统通过文件锁定处理协作。其中的例子有SCCS和RCS，需要您在编辑之前锁定文件，进行更改，然后释放锁定以便其他人贡献。这似乎消除了两位开发者做出冲突更改的可能性，但存在两个主要缺点：
- en: Productivity was still impacted since you had to wait for other developers to
    finish their changes before editing. In systems with large files, this could effectively
    limit the concurrency to only one developer at a time.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生产力仍然受到影响，因为在编辑之前你必须等待其他开发人员完成他们的更改。在文件较大的系统中，这实际上可能将并发性限制为一次只能一个开发人员。
- en: This did not solve the problem of conflicts across files. It is still possible
    for two developers to modify different files with interdependencies and create
    a buggy or unstable system by introducing conflicting changes.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这并未解决跨文件的冲突问题。仍然可能存在两个开发人员修改具有相互依赖关系的不同文件，并通过引入冲突更改来创建错误或不稳定的系统。
- en: 'A substantial improvement was made in the second-generation version control
    systems, starting with Concurrent Versions System (CVS) created by Dick Grune.
    CVS was revolutionary in its approach to (or lack of) file locking. Rather than
    preventing you from changing files, it would allow multiple developers to make
    their simultaneous (and possibly conflicting) changes to the same files. This
    was later resolved via file merging: the conflicting files were analyzed via a
    difference (diff) algorithm, and any conflicting changes were presented to the
    user to resolve.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 第二代版本控制系统有了重大改进，始于由Dick Grune创建的Concurrent Versions System（CVS）。CVS在其处理文件锁定（或者说不处理）的方法上具有革命性。与其阻止您更改文件不同，它允许多个开发人员对同一文件进行同时（可能是冲突的）更改。后来通过文件合并解决了这一问题：通过差异（diff）算法分析冲突文件，并向用户展示需要解决的冲突更改。
- en: By delaying the resolution of conflicting changes to a check-in, CVS allowed
    multiple developers to freely modify and refactor a large codebase without becoming
    blocked on other changes to the same files. This not only increases developer
    productivity, but also allows for the isolation and testing of large features
    separately, which can later be merged into an integrated codebase.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通过延迟解决冲突更改到检入，CVS允许多个开发人员自由修改和重构大型代码库而不会被同一文件的其他更改阻塞。这不仅提高了开发人员的生产力，还允许将大型功能分离并单独测试，然后将其合并到集成的代码库中。
- en: The most popular second-generation SCM is currently Apache Subversion, which
    is designed as a drop-in replacement for CVS. It offers several advantages over
    CVS, including tracking commits as a single revision, which avoids file-update
    collisions that can corrupt the CVS repository state.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 目前最流行的第二代SCM是Apache Subversion，它被设计为CVS的即插即用替代品。它相比CVS有几个优点，包括将提交追踪为单个版本，从而避免可能损坏CVS仓库状态的文件更新冲突。
- en: The third generation of version control is distributed version control systems
    (DVCSs). In a DVCS, every developer has a copy of the entire repository along
    with the full history stored locally. Just as in a second-generation version control
    system, you check out a copy of the repository, make changes, and check it back
    in. However, to integrate those changes with other developers, you sync your entire
    repository in a peer-to-peer fashion.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 第三代版本控制是分布式版本控制系统（DVCS）。在DVCS中，每个开发人员都有整个仓库的副本以及本地存储的完整历史记录。与第二代版本控制系统一样，你首先检出仓库的副本，进行更改，然后再次提交。然而，为了将这些更改与其他开发人员集成，你需要以点对点的方式同步整个仓库。
- en: Several early DVCS systems existed, including GNU Arch, Monotone, and Darcs,
    but DVCS become popularized by Git and Mercurial. Git was developed as a direct
    response to the Linux team’s need for a stable and reliable version control system
    that could support the scale and requirements for open source operating system
    development, and it has become the de facto standard for both open source and
    commercial version control system usage.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 几种早期的DVCS系统存在，包括GNU Arch、Monotone和Darcs，但Git和Mercurial使得DVCS变得流行起来。Git是作为对Linux团队需求的直接响应而开发的，他们需要一个稳定可靠的版本控制系统，以支持开源操作系统开发的规模和要求，它已成为开源和商业版本控制系统使用的事实标准。
- en: 'DVCSs offer several advantages over server-based version control:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: DVCS相比基于服务器的版本控制系统提供了几个优点：
- en: Working entirely offline
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 完全脱机工作。
- en: Since you have a local copy of the repository, checking code in and out, merging,
    and managing branches can all be done without a network connection.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你拥有仓库的本地副本，因此可以在没有网络连接的情况下进行代码的检入、检出、合并和分支管理。
- en: No single point of failure
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 没有单一故障点。
- en: Unlike a server-based SCM, where only one copy of the entire repository with
    full history exists, a DVCS creates a copy of the repository on every developer’s
    machine, increasing redundancy.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 不像基于服务器的SCM那样，只有一个包含完整历史记录的存储库副本存在，DVCS在每个开发者的机器上创建存储库的副本，增加了冗余性。
- en: Faster local operations
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 更快的本地操作
- en: Since most version control operations are local to the machine, they are much
    faster and not affected by network speed or server load.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数版本控制操作都是在本地进行的，它们比网络速度或服务器负载不受影响，因此速度更快。
- en: Decentralized control
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 分散控制
- en: Since syncing the code involves copying the entire repository, this makes it
    much easier to fork a codebase, and in the case of open source projects can make
    it much easier to start an independent effort when the main project has stalled
    or taken an undesirable direction.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于同步代码涉及复制整个存储库，这使得分叉代码库变得更容易，在开源项目的情况下，当主项目停滞或走向不良时，这也使得启动独立努力变得更容易。
- en: Ease of migration
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移的便利性
- en: Converting from most SCM tools into Git is a relatively straightforward operation,
    and you can retain commit history.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 从大多数源代码管理工具转换到Git是一个相对简单的操作，并且你可以保留提交历史。
- en: 'And distributed version control has a few disadvantages, including these:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式版本控制也有一些缺点，包括以下几点：
- en: Slower initial repository sync
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 较慢的初始存储库同步
- en: The initial sync includes copying the entire repository history, which can be
    much slower.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 初始同步包括复制整个存储库历史记录，这可能会慢得多。
- en: Larger storage requirements
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 更大的存储需求
- en: Since everyone has a full copy of the repository and all history, very large
    and/or long-running projects may require a sizable disk requirement.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个人都拥有存储库的完整副本和所有历史记录，因此非常大和/或长期运行的项目可能需要大量的磁盘空间要求。
- en: No ability to lock files
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 没有锁定文件的能力
- en: Server-based version control systems offer some support for locking files when
    a binary file that cannot be merged needs to be edited. With DVCSs locking mechanics
    cannot be enforced, which means only files that can be merged (for example, text)
    are suitable for versioning.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 基于服务器的版本控制系统在需要编辑不能合并的二进制文件时提供了一些锁定文件的支持。DVCS的锁定机制不能被强制执行，这意味着只有可以合并的文件（例如文本）适合进行版本控制。
- en: Choosing Your Source Control
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择你的源代码控制
- en: Hopefully, by now you are convinced that using a modern DVCS is the way to go.
    It provides the best capabilities for local and remote development of any size
    team.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 希望到目前为止，你已经确信使用现代分布式版本控制系统（DVCS）是正确的方式。它为任何规模的团队提供了最佳的本地和远程开发能力。
- en: Also, of the commonly used version control systems, Git has become the clear
    winner in adoption. This is shown clearly by looking at the Google Trends analysis
    of the most commonly used version control systems, as shown in [Figure 2-1](#version_control_adoption).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在常用的版本控制系统中，Git 已经成为采纳的明显赢家。这在查看最常用的版本控制系统的Google趋势分析中清楚地显示出来，如[图 2-1](#version_control_adoption)所示。
- en: '![Line graph comparing popularity of Git,Mercurial,Subversion,and CVS](Images/dtjd_0201.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![线性图比较Git、Mercurial、Subversion和CVS的受欢迎程度](Images/dtjd_0201.png)'
- en: 'Figure 2-1\. Popularity of version control systems from 2004 through 2022 (source:
    [Google Trends](https://oreil.ly/qRxyG))'
  id: totrans-52
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-1\. 2004年至2022年版本控制系统的受欢迎程度（来源：[Google Trends](https://oreil.ly/qRxyG)）
- en: Git has become the de facto standard in the open source community, which means
    a wide base of support exists for its usage along with a rich ecosystem. However,
    sometimes convincing your boss or peers to adopt new technologies is difficult
    if they have a deep investment in a legacy source control technology.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Git 已经成为开源社区中的事实标准，这意味着支持其使用的广泛基础以及丰富的生态系统存在。然而，有时候说服老板或同事采用新技术可能会很困难，特别是如果他们对传统的源代码控制技术有深入的投资。
- en: 'Here are some reasons you can use to convince your boss to upgrade to Git:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些你可以用来说服老板升级到Git的理由：
- en: Reliability
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 可靠性
- en: Git is written like a filesystem, including a proper filesystem check tool (`git
    fsck`) and checksums to ensure data reliability. And given it is a DVCS, you probably
    have your data also pushed to multiple external repositories, creating several
    redundant backups of the data.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Git 的写法类似于文件系统，包括适当的文件系统检查工具（`git fsck`）和校验和以确保数据的可靠性。鉴于它是分布式版本控制系统（DVCS），你可能也将数据推送到多个外部存储库，从而创建数据的多个冗余备份。
- en: Performance
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 性能
- en: Git is not the first DVCS, but it is extremely performant. It was built from
    the ground up to support Linux development with extremely large codebases and
    thousands of developers. Git continues to be actively developed by a large open
    source community.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Git 并不是第一个分布式版本控制系统（DVCS），但它的性能非常出色。它从头开始设计，旨在支持 Linux 开发，能够处理极其庞大的代码库和数千名开发者。Git
    仍然由一个庞大的开源社区积极开发和维护。
- en: Tool support
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 工具支持
- en: There are over 40 frontends for Git and support in just about every major IDE
    (JetBrains IntelliJ IDEA, Microsoft Visual Studio Code, Eclipse, Apache NetBeans,
    etc.), so you are unlikely to find a development platform that does not fully
    support it.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Git 有超过 40 个前端界面，并且几乎在每个主要 IDE（JetBrains IntelliJ IDEA、Microsoft Visual Studio
    Code、Eclipse、Apache NetBeans 等）中都有完全支持，因此你不太可能找到一个不完全支持 Git 的开发平台。
- en: Integrations
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 集成
- en: Git has first-class integrations with IDEs, issue trackers, messaging platforms,
    continuous integration servers, security scanners, code review tools, dependency
    management, and cloud platforms.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Git 与 IDE、问题跟踪器、消息平台、持续集成服务器、安全扫描工具、代码审查工具、依赖管理和云平台有着一流的集成。
- en: Upgrade tools
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 升级工具
- en: There are migration tools to ease the transition from other version-control
    systems to Git, such as `git-svn` that supports bidirectional changes from Subversion
    to Git, or the Team Foundation Version Control (TFVC) repository import tool for
    Git.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 有迁移工具可简化从其他版本控制系统到 Git 的过渡，如支持从 Subversion 到 Git 的双向变更的 `git-svn`，或者为 Git 提供的
    Team Foundation Version Control (TFVC) 仓库导入工具。
- en: In summary, there is not much to lose by upgrading to Git, and a lot of additional
    capabilities and integrations to start to take advantage of. Getting started with
    Git is as simple as [downloading a release](https://oreil.ly/dxgt4) for your development
    machine and creating a local repository.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，升级到 Git 几乎没有什么损失，并且有很多额外的功能和集成可以开始利用。开始使用 Git 就像[下载适用于你的开发机器的版本](https://oreil.ly/dxgt4)并创建本地仓库一样简单。
- en: However, the real power comes in collaboration with the rest of your team, and
    this is most convenient if you have a central repository to push changes to and
    collaborate with. Several companies offer commercial Git repos that you can self-host
    or run on their cloud platform. These include AWS CodeCommit, Assembla, Azure
    DevOps, GitLab, SourceForge, GitHub, RhodeCode, Bitbucket, Gitcolony, and others.
    According to data from the JetBrains “State of the Developer Ecosystem 2020” report
    shown in [Figure 2-2](#version_control_service_chart), these Git-based source
    control systems accounted for over 96% of the commercial source control market.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，真正的力量在于与你的团队协作，如果你有一个中央仓库来推动变更并进行协作，这将非常方便。几家公司提供商业 Git 仓库，你可以自行托管或在它们的云平台上运行。这些包括
    AWS CodeCommit、Assembla、Azure DevOps、GitLab、SourceForge、GitHub、RhodeCode、Bitbucket、Gitcolony
    等。根据 JetBrains 2020 年“开发者生态系统现状”报告中显示的数据（见[图 2-2](#version_control_service_chart)），这些基于
    Git 的源代码管理系统占据了超过 96% 的商业源代码控制市场份额。
- en: '![Chart comparing the adoption of different CVS systems](Images/dtjd_0202.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![比较不同 CVS 系统采用情况的图表](Images/dtjd_0202.png)'
- en: 'Figure 2-2\. Data from the JetBrains [“State of the Developer Ecosystem 2020”](https://oreil.ly/e9yJu)
    report on usage of version control services (source: JetBrains [CC BY 4.0](https://oreil.ly/W5qPM))'
  id: totrans-68
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-2\. JetBrains [“开发者生态系统现状 2020”](https://oreil.ly/e9yJu) 报告关于版本控制服务使用情况的数据（来源：JetBrains
    [CC BY 4.0](https://oreil.ly/W5qPM)）
- en: 'All of these version control services offer additional services on top of basic
    version control, including capabilities like these:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些版本控制服务都提供基本版本控制之上的额外服务，包括以下功能：
- en: Collaboration
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协作
- en: Code reviews
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码审查
- en: Having an efficient system for code reviews is important to maintain code integrity,
    quality, and standards.
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 拥有有效的代码审查系统对于维护代码完整性、质量和标准至关重要。
- en: Advanced pull request/merge features
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 高级拉取请求/合并功能
- en: Many vendors implement advanced features on top of Git that help with multirepository
    and team workflows for more-efficient change request management.
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 许多供应商在 Git 的基础上实现了高级功能，帮助多仓库和团队工作流更高效地进行变更请求管理。
- en: Workflow automation
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 工作流自动化
- en: Approvals in a large organization can be both fluid and complicated, so having
    automation of team and corporate workflows improves efficiency.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在大型组织中，批准流程可能既流畅又复杂，因此通过团队和公司工作流程的自动化可以提高效率。
- en: Team comments/discussions
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 团队评论/讨论
- en: Effective team interaction and discussions that can be tied to specific pull
    requests and code changes help improve communication within and around the team.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有效的团队互动和讨论可以与特定的拉取请求和代码更改相关联，有助于改善团队内外的沟通。
- en: Online editing
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在线编辑
- en: In-browser IDEs allow for collaboration on source code from anywhere, on almost
    any device. GitHub even recently released [Codespaces](https://oreil.ly/1PKf4)
    to give you a fully functional development environment hosted by GitHub.
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在浏览器中的集成开发环境允许在几乎任何设备上从任何地方进行源代码协作。GitHub甚至最近发布了[Codespaces](https://oreil.ly/1PKf4)，提供了由GitHub托管的完整功能的开发环境。
- en: Compliance/security
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合规/安全性
- en: Tracking
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 追踪
- en: Being able to track the code history is a core feature of any version control
    system, but often additional compliance checks and reports are required.
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 能够追踪代码历史是任何版本控制系统的核心特性，但通常还需要额外的合规检查和报告。
- en: Auditing changes
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 审计变更
- en: For control and regulatory purposes, auditing the changes to a codebase is often
    required, so having tools to automate this can be helpful.
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 出于控制和法规目的，通常需要审计代码库的变更，因此具备自动化工具是有帮助的。
- en: Permissions management
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 权限管理
- en: Fine-grained roles and permissions allow for restricting access to sensitive
    files or codebases.
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 细粒度的角色和权限管理允许限制对敏感文件或代码库的访问。
- en: Bill of materials
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 物料清单
- en: For auditing purposes, a full list of all software modules and dependencies
    is often required, and can be generated off the source code.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 出于审计目的，通常需要一个完整的所有软件模块和依赖项的列表，并且可以从源代码生成。
- en: Security vulnerability scanning
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 安全漏洞扫描
- en: Many common security vulnerabilities can be uncovered by scanning the codebase
    and looking for common patterns that are used to exploit deployed applications.
    Using an automated vulnerability scanner on the source code can help identify
    vulnerabilities early in the development process.
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 许多常见的安全漏洞可以通过扫描代码库并查找用于利用已部署应用程序的常见模式来发现。在开发过程的早期阶段使用自动化漏洞扫描器可以帮助识别漏洞。
- en: Integration
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成
- en: Issue tracking
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 问题追踪
- en: By having tight integration with an issue tracker, you can tie specific changesets
    to a software defect, making it easier to identify the version a bug is fixed
    in and trace any regressions.
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过与问题追踪器的紧密集成，您可以将特定的变更集与软件缺陷关联起来，从而更容易地识别修复错误的版本并跟踪任何回归问题。
- en: CI/CD
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: CI/CD
- en: Typically, a continuous integration server will be used to build the code checked
    into source control. A tight integration makes it easier to kick off builds, report
    back on success and test results, and automate promotion and/or deployment of
    successful builds.
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通常，持续集成服务器将用于构建检入源代码。紧密集成使得更容易启动构建、报告成功和测试结果，并自动推广和/或部署成功的构建。
- en: Binary package repository
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 二进制包存储库
- en: Fetching dependencies from a binary repository and storing build results provides
    a central place to look for artifacts and to stage deployments.
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从二进制存储库获取依赖项并存储构建结果提供了一个中心位置来查找构件和分阶段部署。
- en: Messaging integration
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 消息集成
- en: Team collaboration is important to a successful development effort, and making
    it easy to discuss source files, check-ins, and other source control events simplifies
    communication with platforms like Slack, Microsoft Teams, Element, etc.
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 团队协作对于成功的开发工作至关重要，并且通过像Slack、Microsoft Teams、Element等平台简化讨论源文件、检入和其他源代码控制事件的功能，可以简化沟通。
- en: Clients (desktop/IDE)
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 客户端（桌面/IDE）
- en: A lot of free clients and plug-ins for various IDEs allow you to access your
    source control system, including open source clients from GitHub, Bitbucket, and
    others.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 许多免费客户端和各种IDE的插件允许您访问您的源代码控制系统，包括来自GitHub、Bitbucket等的开源客户端。
- en: When selecting a version control service, it is important to make sure that
    it fits into the development workflow of your team, integrates with other tools
    that you already use, and fits into your corporate security policies. Often companies
    have a version control system that is standardized across the organization, but
    there may be benefits to adopting a more modern version control system, especially
    if the corporate standard is not a DVCS like Git.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择版本控制服务时，重要的是确保它与团队的开发工作流程相匹配，与您已经使用的其他工具集成，并符合您公司的安全策略。通常公司会有一个在整个组织中标准化的版本控制系统，但是如果公司标准不是像Git这样的分布式版本控制系统，采用更现代的版本控制系统可能会有好处。
- en: Making Your First Pull Request
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何进行第一个拉取请求
- en: To get a feel for how version control works, we are going to run through a simple
    exercise to create your first pull request to the official book repository on
    GitHub. A section of the readme file is dedicated to reader comments, so you can
    join the rest of the readers in showing your accomplishment in learning modern
    DevOps best practices!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了感受版本控制的工作方式，我们将通过一个简单的练习来创建您的第一个拉取请求，以便将您的贡献加入GitHub上官方书籍存储库中的读者评论部分，让您可以与其他读者一起展示您掌握的现代DevOps最佳实践！
- en: This exercise doesn’t require installing any software or using the command line,
    so it should be easy and straightforward to accomplish. Finishing this exercise
    is highly recommended so you understand the basic concepts of distributed version
    control that we go into more detail on later in the chapter.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 此练习不需要安装任何软件或使用命令行，因此完成此练习应该是非常简单和直接的。强烈推荐完成此练习，以便您了解我们稍后在本章更详细介绍的分布式版本控制的基本概念。
- en: To start, you need to navigate to the [book repository](https://oreil.ly/ApzqX).
    For this exercise, you need to be logged in so you can create a pull request from
    the web user interface. If you don’t already have a GitHub account, signing up
    and getting started is easy and free.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要导航到[书籍存储库](https://oreil.ly/ApzqX)。在这个练习中，您需要登录以便可以从Web用户界面创建拉取请求。如果您还没有GitHub帐户，注册并开始使用非常简单和免费。
- en: The DevOps Tools for Java Developers repository GitHub page is shown in [Figure 2-3](#book_repository).
    The GitHub UI shows the root files and the contents of a special file called *README.md*
    by default. We are going to make edits to the readme file, which is coded in a
    visual text language called Markdown.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 显示Java开发人员的DevOps工具存储库GitHub页面如[图 2-3](#book_repository)所示。GitHub UI默认显示根文件和名为*README.md*的特殊文件的内容。我们将对Markdown语言的可视文本文件自述文件进行编辑。
- en: Since we have only read access to this repository, we are going to create a
    personal clone of the repository, known as a *fork*, that we can freely edit to
    make and propose the changes. Once you are logged in to GitHub, you can start
    this process by clicking the Fork button highlighted in the upper-right corner.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们仅具有对此存储库的读取访问权限，我们将创建一个称为*分支*的个人克隆存储库，可以自由编辑并提出更改。一旦您登录GitHub，您可以通过单击右上角突出显示的“分支”按钮来启动此过程。
- en: '![Website page showing the GitHub book repository](Images/dtjd_0203.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![显示 GitHub 书籍存储库的网页](Images/dtjd_0203.png)'
- en: Figure 2-3\. The GitHub repository containing this book’s samples
  id: totrans-111
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-3\. 包含本书示例的GitHub存储库
- en: 'Your new fork will get created under your personal account at GitHub. Once
    your fork is created, complete the following steps to open the web-based text
    editor:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您的新分支将在GitHub的个人帐户下创建。一旦创建了您的分支，请完成以下步骤以打开基于Web的文本编辑器：
- en: Click the *README.md* file that you want to edit to see the details page.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击*README.md*文件以编辑详细页面以查看详细信息。
- en: Click the pencil icon on the details page to edit the file.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击详细页面上的铅笔图标以编辑文件。
- en: Once you click the pencil icon, you will see the web-based text editor shown
    in [Figure 2-4](#edit_readme). Scroll down to the section with the visitor log,
    and add your own personal comment to the end to let folks know you completed this
    exercise.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦单击铅笔图标，您将看到基于Web的文本编辑器，如[图 2-4](#edit_readme)所示。滚动到访客日志部分，并在末尾添加您自己的个人评论，让大家知道您已完成此练习。
- en: '![Website page showing the GitHub text file editor](Images/dtjd_0204.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![显示 GitHub 文本文件编辑器的网页](Images/dtjd_0204.png)'
- en: Figure 2-4\. The GitHub web-based text editor for making quick changes to files
  id: totrans-117
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-4\. 用于快速更改文件的GitHub基于Web的文本编辑器
- en: 'The recommended format for visitor log entries is as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 访客日志条目的推荐格式如下：
- en: '[PRE0]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you want to be fancy on the Twitter handle and link to your profile, the
    Markdown syntax for Twitter links is as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在Twitter句柄上装点门面并链接到您的个人资料，Twitter链接的Markdown语法如下所示：
- en: '[PRE1]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To check your changes, you can click the “Preview changes” tab, which will show
    the rendered output once it’s inserted into the original readme.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看您的更改，可以单击“预览更改”选项卡，在将其插入原始自述文件后显示渲染的输出。
- en: When you are satisfied with your changes, scroll down to the code commit section
    shown in [Figure 2-5](#commit_changes). Enter a helpful description for the change
    to explain your updates. Then go ahead and click the “Commit changes” button.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当您满意您的更改后，请向下滚动到代码提交部分，如[图 2-5](#commit_changes)所示。输入有关更改的有用描述以解释您的更新。然后继续单击“提交更改”按钮。
- en: For this example, we will simply commit to the main branch, which is the default.
    However, if you were working in a shared repository, you would commit your pull
    request to a feature branch that can be integrated separately.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本例，我们将简单地提交到主分支，默认情况下是这样的。但是，如果您在共享存储库中工作，您将把拉取请求提交到可以单独集成的功能分支。
- en: '![Website page showing the code commit form](Images/dtjd_0205.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![显示代码提交表单的网站页面](Images/dtjd_0205.png)'
- en: Figure 2-5\. Using GitHub UI to commit changes to a repository you have write
    access to
  id: totrans-126
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-5\. 使用 GitHub UI 提交更改到您具有写入访问权限的存储库
- en: After you have made a change to your forked repository, you can submit this
    as a pull request for the original project. This will notify the project maintainers
    (in this case, the book authors) that a proposed change is waiting for review
    and let them choose whether to integrate it into the original project.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在您对分叉存储库进行更改后，您可以将其作为对原始项目的拉取请求提交。这将通知项目维护者（在本例中是书籍作者），等待审查的建议更改，并让他们选择是否将其集成到原始项目中。
- en: To do this, go to the “Pull requests” tab in the GitHub user interface. This
    screen has a button to create a “New pull request” that will present you with
    a choice of the “base” and “head” repository to be merged, as shown in [Figure 2-6](#create_pull_request).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，请转到 GitHub 用户界面中的“拉取请求”选项卡。此屏幕上有一个创建“新拉取请求”的按钮，将为您提供要合并的“基础”和“头”存储库的选择，如
    [图 2-6](#create_pull_request) 所示。
- en: In this case, since you have only one change, the default repositories should
    be selected correctly. Simply click the “Create pull request” button, and a new
    pull request against the original repository will be submitted for review.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，由于只有一个更改，应正确选择默认的存储库。只需单击“创建拉取请求”按钮，即可提交针对原始存储库的新拉取请求以供审查。
- en: '![Website page showing the GitHub pull request UI](Images/dtjd_0206.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![显示 GitHub 拉取请求 UI 的网站页面](Images/dtjd_0206.png)'
- en: Figure 2-6\. User interface for creating a pull request from a forked repository
  id: totrans-131
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-6\. 从分叉存储库创建拉取请求的用户界面
- en: This completes your submission of a pull request! Now it is up to the original
    repository owners to review and comment on, or accept/reject the pull request.
    While you don’t have write access to the original repository to see what this
    looks like, [Figure 2-7](#merge_pull_request) shows you what will be presented
    to the repository owners.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了您对拉取请求的提交！现在轮到原始存储库所有者审查、评论或接受/拒绝拉取请求了。虽然您没有写入原始存储库以查看其外观，但 [图 2-7](#merge_pull_request)
    显示了将呈现给存储库所有者的内容。
- en: Once the repository owners accept your pull request, your custom visitor log
    greeting will be added to the official book repository.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦存储库所有者接受您的拉取请求，您的自定义访客日志问候语将添加到官方书籍存储库中。
- en: '![Website page showing the GitHub merge resolution UI](Images/dtjd_0207.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![显示 GitHub 合并解决 UI 的网站页面](Images/dtjd_0207.png)'
- en: Figure 2-7\. The repository owner user interface for merging in the resulting
    pull request
  id: totrans-135
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-7\. 用于合并生成的拉取请求的存储库所有者用户界面
- en: This workflow is an example of the fork and pull request collaboration model
    for handling project integration. We will talk a bit more about collaboration
    patterns and the sort of projects and team structures they are most suitable for
    in [“Git Collaboration Patterns”](#git_collab_patterns).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工作流程是处理项目集成的分叉和拉取请求协作模型的一个示例。我们将稍微详细地讨论协作模式以及适合使用它们的项目和团队结构在 [“Git 协作模式”](#git_collab_patterns)
    中。
- en: Git Tools
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Git 工具
- en: 'In the previous section, we showed an entire web-based workflow for Git using
    the GitHub UI. However, other than code reviews and repository management, most
    developers spend the majority of their time in one of the client-based user interfaces
    to Git. The available client interfaces can be broadly split into the following
    categories:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们展示了使用 GitHub UI 进行 Git 的整个基于 Web 的工作流程。然而，除了代码审查和存储库管理之外，大多数开发人员在 Git
    的基于客户端的用户界面中度过了大部分时间。可用的客户端界面可以广泛分为以下几类：
- en: Command line
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行
- en: An official Git command-line client may already be installed on your system
    or is easily added.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 官方的 Git 命令行客户端可能已安装在您的系统上，或者很容易添加。
- en: GUI clients
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: GUI 客户端
- en: The official Git distribution comes with a couple of open source tools that
    can be used to more easily browse your revision history or to structure a commit.
    Also, several third-party free and open source Git tools can make working with
    your repository easier.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 官方的Git发行版附带了几个开源工具，可以更轻松地浏览您的修订历史或结构化提交。此外，还有几个第三方免费和开源的Git工具可以让您更轻松地使用您的仓库。
- en: Git IDE plug-ins
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Git的IDE插件
- en: Often you need to go no further than your favorite IDE to work with your distributed
    source control system. Many major IDEs have Git support packaged by default or
    offer a well-supported plug-in.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您只需使用您喜爱的IDE就能够使用分布式源代码控制系统。许多主要的IDE都默认支持Git，或者提供了一个良好支持的插件。
- en: Git Command-Line Basics
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Git命令行基础知识
- en: 'The Git command line is the most powerful interface to your source control
    system, allowing for all local and remote options to manage your repository. You
    can check whether you have the Git command line installed by typing the following
    on the console:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Git命令行是管理源代码控制系统的最强大接口，可以通过所有本地和远程选项来管理您的仓库。您可以在控制台上键入以下内容来检查是否已安装Git命令行：
- en: '[PRE2]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you have Git installed, the command will return the operating system and
    version that you are using, similar to this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已安装Git，命令将返回您使用的操作系统和版本，类似于此内容：
- en: '[PRE3]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'However, if you don’t have Git installed, here’s the easiest way to get it
    on various platforms:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，如果您尚未安装Git，以下是在各种平台上获取它的最简单方法：
- en: 'Linux distributions:'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux发行版：
- en: '*Debian-based:* `sudo apt install git-all`'
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基于Debian:* `sudo apt install git-all`'
- en: '*RPM-based:* `sudo dnf install git-all`'
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基于RPM:* `sudo dnf install git-all`'
- en: macOS
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: macOS
- en: Running `git` on macOS 10.9 or later will ask you to install it.
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在macOS 10.9或更高版本上运行`git`将提示您安装它。
- en: Another easy option is to install [GitHub Desktop](https://oreil.ly/0x2A3),
    which installs and configures the command-line tools.
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个简单的选项是安装[GitHub Desktop](https://oreil.ly/0x2A3)，它会安装并配置命令行工具。
- en: Windows
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows
- en: The easiest way is to simply install GitHub Desktop, which installs the command-line
    tools as well.
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最简单的方法是简单地安装GitHub Desktop，它会同时安装命令行工具。
- en: Another option is [Git for Windows](https://oreil.ly/BioSg).
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个选择是安装[Git for Windows](https://oreil.ly/BioSg)。
- en: Regardless of which approach you use to install Git, you will end up with the
    same great command-line tools, which are well supported across all desktop platforms.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您使用哪种方法来安装Git，您最终都将获得相同的出色命令行工具，这些工具在所有桌面平台上得到了良好的支持。
- en: To start with, it is helpful to understand the basic Git commands. [Figure 2-8](#git_repository_hierarchy)
    shows a typical repository hierarchy with one central repository and three clients
    who have cloned it locally. Notice that every client has a full copy of the repository
    as well as a working copy where they can make changes.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，了解基本的Git命令是很有帮助的。图2-8显示了一个典型的仓库层次结构，其中包含一个中央仓库和三个已经在本地克隆了它的客户端。请注意，每个客户端都有仓库的完整副本以及可以进行更改的工作副本。
- en: '![Diagram showing relationship of remote and local repositories, and the Git
    working copy](Images/dtjd_0208.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![显示远程和本地仓库以及Git工作副本关系的图表](Images/dtjd_0208.png)'
- en: Figure 2-8\. A typical central server pattern for distributed version control
    collaboration
  id: totrans-163
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-8. 分布式版本控制协作的典型中央服务器模式
- en: Some of the Git commands that allow you to move data between repositories as
    well as the working copy are shown. Now let’s go through some of the most common
    commands that are used to manage your repository and collaborate in Git.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下显示了一些Git命令，允许您在仓库和工作副本之间移动数据。现在让我们来看看一些最常用的命令，用于管理您的仓库和在Git中进行协作。
- en: 'Repository management:'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仓库管理：
- en: '`clone`'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`clone`'
- en: Makes a connected copy of another local or remote repository on the local filesystem.
    For those coming from a concurrent version control system like CVS or Subversion,
    this command serves a similar purpose to `checkout`, but is semantically different
    in that it creates a full copy of the remote repository. All of the clients in
    [Figure 2-8](#git_repository_hierarchy) would have cloned the central server to
    begin.
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在本地文件系统上创建与另一个本地或远程仓库的连接副本。对于那些从CVS或Subversion等并发版本控制系统过来的人来说，此命令的作用类似于`checkout`，但在语义上有所不同，因为它创建了远程仓库的完整副本。图中的所有客户端在开始时都会克隆中央服务器。所有的客户端都克隆了中央服务器。
- en: '`init`'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`init`'
- en: Creates a new, empty repository. However, most of the time you will start by
    cloning an existing repository.
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建一个新的空仓库。不过，大多数情况下，您会首先克隆一个现有的仓库。
- en: 'Changeset management:'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变更集管理：
- en: '`add`'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`add`'
- en: Adds file revisions to version control, which can be either a new file or modifications
    to an existing file. This is different from the `add` command in CVS or Subversion
    in that it does not *track* the file and needs to be called every time the file
    changes. Make sure to call `add` on all new and modified files before committing.
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将文件修订版添加到版本控制中，可以是新文件或对现有文件的修改。这与CVS或Subversion中的`add`命令不同，因为它不会*跟踪*文件，需要每次文件更改时调用。确保在提交之前调用`add`以添加所有新文件和修改文件。
- en: '`mv`'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`mv`'
- en: Renames or moves a file/directory, while also updating the version control record
    for the next commit. It is similar in use to the `mv` command in Unix and should
    be used instead of filesystem commands to keep version control history intact.
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重命名或移动文件/目录，并更新下一个提交的版本控制记录。在使用上类似于Unix中的`mv`命令，应该使用它来代替文件系统命令以保持版本控制历史完整。
- en: '`restore`'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`restore`'
- en: Allows you to restore files from the Git index if they are deleted or erroneously
    modified.
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 允许您从Git索引中恢复文件，如果它们被删除或错误修改。
- en: '`rm`'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`rm`'
- en: Removes a file or directory, while also updating the version control record
    for the next commit. It is similar in use to the `rm` command in Unix and should
    be used instead of filesystem commands to keep version control history intact.
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 移除文件或目录，并更新下一个提交的版本控制记录。在使用上类似于Unix中的`rm`命令，应该使用它来代替文件系统命令以保持版本控制历史完整。
- en: 'History control:'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 历史控制：
- en: '`branch`'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`branch`'
- en: With no arguments, lists all branches in the local repository. It can also be
    used to create a new branch or delete branches.
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果没有参数，则列出本地仓库中的所有分支。也可用于创建新分支或删除分支。
- en: '`commit`'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`commit`'
- en: Saves changes in the working copy to the local repository. Before running `commit`,
    make sure to register all your file changes by calling `add`, `mv`, and `rm` on
    files that have been added, modified, renamed, or moved. You also need to specify
    a commit message that can be done on the command line with the `-m` option; or
    if omitted, a text editor (such as `vi`) will be spawned to allow you to enter
    a message.
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将工作副本中的更改保存到本地仓库。在运行`commit`之前，请确保通过调用`add`、`mv`和`rm`对已添加、修改、重命名或移动的文件进行注册。您还需要指定一个提交消息，可以在命令行上使用`-m`选项完成；如果省略，则会生成一个文本编辑器（如`vi`）来允许您输入消息。
- en: '`merge`'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`merge`'
- en: Joins changes from the named commits into the current branch. If the merged
    history is already a descendant of the current branch, a “fast-forward” is used
    to combine the history sequentially. Otherwise, a merge is created that combines
    the history; the user is prompted to resolve any conflicts. This command is also
    used by `git pull` to integrate changes from the remote repository.
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将命名提交中的更改合并到当前分支。如果合并历史已经是当前分支的后代，则使用“快进”来按顺序组合历史。否则，将创建一个合并，合并历史；用户将提示解决任何冲突。此命令也被`git
    pull`使用来集成来自远程仓库的更改。
- en: '`rebase`'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`rebase`'
- en: Replays the commits from your current branch on the upstream branch. This is
    different from `merge` in that the result will be a linear history rather than
    a merge commit, which can make the revision history easier to follow. The disadvantage
    is that rebase creates entirely new commits when it moves the history, so if the
    current branch contains changes that have previously been pushed, you are rewriting
    history that other clients may depend upon.
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在上游分支上重播当前分支的提交。与`merge`不同之处在于结果将是线性历史，而不是合并提交，这可以使修订历史更容易遵循。缺点是当移动历史时，rebase会创建全新的提交，因此如果当前分支包含先前已推送的更改，则正在重写其他客户端可能依赖的历史。
- en: '`reset`'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`reset`'
- en: Reverts the `HEAD` to a previous state, and has several practical uses such
    as reverting an `add` or undoing a commit. However, if those changes have been
    pushed remotely, this can cause problems with the upstream repository. Use with
    care!
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将`HEAD`还原到先前状态，并具有几个实用用途，例如撤消`add`或撤消提交。但是，如果这些更改已经被推送到远程，这可能会导致与上游仓库的问题。请谨慎使用！
- en: '`switch`'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`switch`'
- en: Switches between branches for the working copy. If you have changes in the working
    copy, this can result in a three-way merge, so it is often better to commit or
    stash your changes first. With `-c`, this command will create a branch and immediately
    switch to it.
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 切换工作副本中的分支。如果您在工作副本中有更改，则可能会导致三向合并，因此最好先提交或隐藏您的更改。使用`-c`选项，此命令将创建一个分支并立即切换到它。
- en: '`tag`'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`tag`'
- en: Allows you to create a tag on a specific commit that is signed by PGP. This
    uses the default email address’s PGP key. Since tags are cryptographically signed
    and unique, they should not be reused or changed once pushed. Additional options
    on this command allow for deleting, verifying, and listing tags.
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 允许您在特定提交上创建一个由PGP签名的标签。这将使用默认电子邮件地址的PGP密钥。由于标签是经过加密签名和唯一的，因此在推送后不应该被重用或更改。此命令的其他选项允许删除、验证和列出标签。
- en: '`log`'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`log`'
- en: Shows the commit logs in a textual format. It can be used for a quick view of
    recent changes, and supports advanced options for the history subset shown and
    formatting of the output. Later in this chapter, we also show how to visually
    browse the history by using tools like `gitk`.
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以文本格式显示提交日志。它可用于快速查看最近的更改，并支持用于显示的历史子集和输出格式的高级选项。在本章的后面，我们还将介绍如何使用`gitk`等工具来可视化浏览历史记录。
- en: 'Collaboration:'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协作：
- en: '`fetch`'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`fetch`'
- en: Pulls the history from a remote repository into the local repository, but makes
    no attempt to merge it with local commits. This is a safe operation that can be
    performed at any time and repeatedly without causing merge conflicts or affecting
    the working copy.
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从远程仓库拉取历史记录到本地仓库，但不尝试将其与本地提交合并。这是一个安全的操作，可以在任何时候重复执行，而不会引起合并冲突或影响工作副本。
- en: '`pull`'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`pull`'
- en: Equivalent to a `git fetch` followed by `git merge FETCH_HEAD`. It is convenient
    for the common workflow of grabbing the latest changes from a remote repository
    and integrating it with your working copy. However, if you have local changes,
    `pull` can cause merge conflicts that you will be forced to resolve. For this
    reason, it is often safer to `fetch` first and then decide if a simple merge will
    suffice.
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 等效于`git fetch`后跟`git merge FETCH_HEAD`。它方便了从远程仓库抓取最新更改并将其与您的工作副本集成的常见工作流程。然而，如果您有本地更改，`pull`可能会导致合并冲突，您将被迫解决。因此，通常更安全的做法是先`fetch`，然后决定是否仅需简单合并。
- en: '`push`'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`push`'
- en: Sends changes to the upstream remote repository from the local repository. Use
    this after a `commit` to push your changes to the upstream repository so other
    developers can see your changes.
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将本地仓库中的更改发送到上游远程仓库。在`commit`后使用此命令将您的更改推送到上游仓库，以便其他开发人员可以看到您的更改。
- en: Now that you have a basic understanding of the Git commands, let’s put this
    knowledge into practice.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经对Git命令有了基本的了解，让我们将这些知识付诸实践。
- en: Git Command-Line Tutorial
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Git命令行教程
- en: To demonstrate how to use these commands, we will go through a simple example
    to create a new local repository from scratch. For this exercise, we are assuming
    you are on a system with a Bash-like command shell. This is the default on most
    Linux distributions as well as macOS. If you are on Windows, you can do this via
    Windows PowerShell, which has sufficient aliases to emulate Bash for basic commands.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何使用这些命令，我们将通过一个简单的示例来从头开始创建一个新的本地仓库。对于这个练习，我们假设您正在使用一个类似于Bash的命令行shell的系统。这是大多数Linux发行版以及macOS的默认设置。如果您使用的是Windows，您可以通过Windows
    PowerShell来完成这个操作，它有足够的别名来模拟基本命令的Bash。
- en: 'If this is your first time using Git, it is a good idea to put in your name
    and email, which will be associated with all of your version control operations.
    You can do this with the following commands:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是您第一次使用Git，建议您输入您的姓名和电子邮件，这将与您所有的版本控制操作相关联。您可以使用以下命令来实现这一点：
- en: '[PRE4]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'After configuring your personal information, go to a suitable directory to
    create your working project. First, create the project folder and initialize the
    repository:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 配置个人信息后，转到适当的目录创建您的工作项目。首先，创建项目文件夹并初始化仓库：
- en: '[PRE6]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This creates the repository and initializes it so you can start tracking revisions
    of files. Let’s create a new file that we can add to revision control:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建仓库并初始化，使您可以开始跟踪文件的修订版本。让我们创建一个可以添加到修订控制的新文件：
- en: '[PRE9]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To add this file to revision control, use the `git add` command as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此文件添加到修订控制中，请使用以下`git add`命令：
- en: '[PRE10]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And you can add this file to version control by using the `git commit` command:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`git commit`命令将此文件添加到版本控制中：
- en: '[PRE11]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Congratulations on making your first command-line commit using Git! You can
    double-check to make sure that your file is being tracked in revision control
    by using the `git log` command, which should return output similar to the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜您使用Git进行了第一次命令行提交！您可以通过使用`git log`命令来双重检查确保您的文件正在被修订控制跟踪，它应该返回类似以下的输出：
- en: '[PRE12]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: From this, you can see some of the details that Git stores in the repository,
    including branch information (the default branch is `master`), and revisions by
    globally unique identifiers (GUIDs). Though you can do a lot more from the command
    line, it is often easier to use a Git client built for your workflow or IDE integration
    that is designed for a developer workflow. The next couple of sections talk about
    these client options.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，您可以看到Git存储库中存储的一些细节，包括分支信息（默认分支是`master`）和按全局唯一标识符（GUID）分类的修订。虽然您可以从命令行做更多事情，但通常更容易使用为您的工作流程构建的Git客户端或IDE集成，该工具专为开发人员工作流程设计。接下来的几节将介绍这些客户端选项。
- en: Git Clients
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Git客户端
- en: Several free and open source clients that you can use to work with Git repos
    more easily are optimized for various different workflows. Most clients do not
    try to do everything, but specialize in visualizations and functionality for specific
    workflows.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 几个免费开源的客户端可供您使用，可使您更轻松地使用Git存储库，并针对不同的工作流程进行了优化。大多数客户端并不尝试做到一切，而是专注于为特定工作流程提供可视化和功能。
- en: The default Git installation comes with a couple of handy visual tools that
    make committing and viewing history easier. These tools are written in Tcl/Tk,
    are cross-platform, and are easily launched from the command line to supplement
    the Git command-line interface (CLI).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的Git安装附带了一些方便的可视化工具，使提交和查看历史更加容易。这些工具是用Tcl/Tk编写的，跨平台，并且可以轻松地从命令行启动，以补充Git命令行界面（CLI）。
- en: The first tool, `gitk`, provides an alternative to the command line for navigating,
    viewing, and searching the Git history of your local repository. The `gitk` user
    interface displaying the history for the ScalaFX open source project is shown
    in [Figure 2-9](#gitk).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个工具`gitk`提供了一个选择，用于浏览、查看和搜索本地存储库的Git历史，而不是使用命令行。显示ScalaFX开源项目历史记录的`gitk`用户界面显示在[图2-9](#gitk)中。
- en: '![User interface showing Git history visually via split panes with graphs and
    revision data](Images/dtjd_0209.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![用户界面通过分割窗格以图形和修订数据的形式可视化显示Git历史](Images/dtjd_0209.png)'
- en: Figure 2-9\. The bundled Git history viewer application
  id: totrans-227
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-9\. 捆绑的Git历史查看器应用程序
- en: The top pane of `gitk` displays the revision history with branching information
    drawn visually, which can be useful for deciphering complicated branch history.
    Below this are search filters that can be used to find commits containing specific
    text. Finally, for the selected changeset, you can see the changed files and a
    textual diff of the changes, which is also searchable.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`gitk`的顶部窗格显示具有分支信息的修订历史，以可视方式绘制，这对于解密复杂的分支历史非常有用。在此之下是可用于查找包含特定文本的提交的搜索过滤器。最后，对于所选更改集，您可以看到已更改的文件以及更改的文本差异，这也是可搜索的。'
- en: The other tool that comes bundled with Git is `git-gui`. Unlike `gitk`, which
    only shows information about the repository history, `git-gui` allows you to modify
    the repository by executing many of the Git commands including `commit`, `push`,
    `branch`, `merge`, and others.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Git随附的另一个工具是`git-gui`。与仅显示有关存储库历史的信息的`gitk`不同，`git-gui`允许您通过执行许多Git命令（包括`commit`、`push`、`branch`、`merge`等）来修改存储库。
- en: '[Figure 2-10](#git-gui) shows the `git-gui` user interface for editing the
    source code repository for this book. On the left side, all of the changes to
    the working copy are shown, with the unstaged changes on top and the files that
    will be included in the next commit on the bottom. The details for the selected
    file are shown on the right side with the full file contents for new files, or
    a diff for modified files. At the bottom right, buttons are provided for common
    operations like Rescan, Sign Off, Commit, and Push. Further commands are available
    in the menu for advanced operations like branching, merging, and remote repository
    management.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2-10](#git-gui)显示了用于编辑本书源代码存储库的`git-gui`用户界面。在左侧，显示了所有工作副本的更改，未暂存的更改显示在顶部，下一个提交中将包含的文件显示在底部。所选文件的详细信息显示在右侧，其中包括新文件的完整文件内容，或者修改文件的差异。在右下角，提供了用于常见操作（如重新扫描、签名、提交和推送）的按钮。高级操作（如分支、合并和远程存储库管理）的其他命令可在菜单中找到。'
- en: '![Screenshot of the bundled Git UI for reviewing and committing code](Images/dtjd_0210.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![用于审查和提交代码的捆绑式Git UI的屏幕截图](Images/dtjd_0210.png)'
- en: Figure 2-10\. The bundled Git collaboration application
  id: totrans-232
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-10\. 捆绑的Git协作应用程序
- en: '`git-gui` is an example of a workflow-driven user interface for Git. It doesn’t
    expose the full set of functionality available on the command line, but is convenient
    for the commonly used Git workflows.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`git-gui`是Git的一个以工作流驱动的用户界面的示例。它不公开命令行上可用的完整功能集，但对于常用的Git工作流程非常方便。'
- en: Another example of a workflow-driven user interface is *GitHub Desktop*. This
    is the most popular third-party GitHub user interface, and as mentioned earlier,
    also conveniently comes bundled with the command-line tools so you can use it
    as an installer for the Git CLI and aforementioned bundled GUIs.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个以工作流驱动的用户界面的例子是*GitHub Desktop*。这是最受欢迎的第三方GitHub用户界面，正如前面提到的，它还方便地与命令行工具捆绑在一起，因此您可以将其用作Git
    CLI和前述捆绑GUI的安装程序。
- en: GitHub Desktop is similar to `git-gui`, but is optimized for integration with
    GitHub’s service, and the user interface is designed to make it easy to follow
    workflows similar to GitHub Flow. The GitHub Desktop user interface editing the
    source repository for another great book, *The Definitive Guide to Modern Java
    Clients with JavaFX*, is shown in [Figure 2-11](#github_desktop).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Desktop类似于`git-gui`，但经过了优化以与GitHub的服务集成，并且用户界面设计得非常易于遵循类似于GitHub Flow的工作流程。编辑源存储库的GitHub
    Desktop用户界面，另一本优秀书籍*The Definitive Guide to Modern Java Clients with JavaFX*，显示在[图2-11](#github_desktop)中。
- en: '![Screenshot of the GitHub Desktop user interface](Images/dtjd_0211.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![GitHub Desktop用户界面的截图](Images/dtjd_0211.png)'
- en: Figure 2-11\. GitHub’s open source desktop client
  id: totrans-237
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-11\. GitHub的开源桌面客户端
- en: 'In addition to the same sort of capabilities as `git-gui` to view changes,
    commit revisions, and pull/push code, GitHub Desktop has a bunch of advanced features
    that make managing your code much easier:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 除了与`git-gui`具有相同类型的功能以查看更改、提交修订版本和拉取/推送代码之外，GitHub Desktop还具有许多高级功能，可使管理代码变得更加容易：
- en: Commit attribution
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交归因
- en: Syntax highlighted diffs
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语法高亮差异
- en: Image diff support
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像差异支持
- en: Editor and shell integration
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑器和shell集成
- en: CI status of pull requests
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拉取请求的CI状态
- en: 'GitHub Desktop can be used with any Git repo, but has features tailored specifically
    for use with GitHub-hosted repositories. Here are some other popular Git tools:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Desktop可以与任何Git存储库一起使用，但具有专门针对与GitHub托管存储库一起使用的功能。以下是一些其他受欢迎的Git工具：
- en: '[Sourcetree](https://www.sourcetreeapp.com)'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '[Sourcetree](https://www.sourcetreeapp.com)'
- en: A free, but proprietary, Git client made by Atlassian. It is a good alternative
    to GitHub Desktop and has only a slight bias toward Atlassian’s Git service, Bitbucket.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 由Atlassian制作的免费但专有的Git客户端。它是GitHub Desktop的一个很好的替代品，并且只对Atlassian的Git服务Bitbucket有轻微偏见。
- en: '[GitKraken Client](https://www.gitkraken.com)'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '[GitKraken客户端](https://www.gitkraken.com)'
- en: A commercial and featureful Git client. It is free for open source developers,
    but paid for commercial use.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 商业和功能丰富的Git客户端。对于开源开发者是免费的，但对于商业用途是付费的。
- en: '[TortoiseGit](https://tortoisegit.org)'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '[TortoiseGit](https://tortoisegit.org)'
- en: A free, GNU Public License (GPL), Git client based on TortoiseSVN. The only
    downside is that it is Windows only.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 基于TortoiseSVN的自由GNU公共许可证（GPL）的Git客户端。唯一的缺点是它只支持Windows。
- en: Others
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 其他
- en: A full list of Git GUI clients is maintained on the [Git website](https://oreil.ly/JPi0J).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Git GUI客户端的完整列表维护在[Git网站](https://oreil.ly/JPi0J)上。
- en: Git desktop clients are a great addition to the arsenal of available source
    control management tools you have available. However, the most useful Git interface
    may already be at your fingertips, right inside your IDE.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 'Git桌面客户端是您可以使用的可用源代码控制管理工具库的强大补充。然而，最有用的Git界面可能已经在您的IDE中就在您的指尖。 '
- en: Git IDE Integration
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Git IDE集成
- en: Many integrated development environments (IDEs) include Git support either as
    a standard feature, or as a well-supported plug-in. Chances are that you need
    to go no further than your favorite IDE to do basic version control operations
    like adding, moving, and removing files, committing code, and pushing your changes
    to an upstream repository.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 许多集成开发环境（IDE）都包含Git支持，要么作为标准功能，要么作为一个得到很好支持的插件。你很可能不需要去找其他东西，只需在你喜欢的IDE中进行基本的版本控制操作，如添加、移动和删除文件，提交代码和将更改推送到上游存储库。
- en: One of the most popular Java IDEs is JetBrains IntelliJ IDEA. It has a Community
    Edition that is open source as well as a commercial version with additional features
    for enterprise developers. The IntelliJ Git support is full featured, with the
    ability to sync changes from a remote repository, track and commit changes performed
    in the IDE, and integrate upstream changes. The integrated Commit tab for a Git
    changeset is shown in [Figure 2-12](#intellij_git_commit).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: JetBrains IntelliJ IDEA 是最受欢迎的 Java IDE 之一。它有一个开源的社区版，也有一个商业版，提供了额外的功能，适用于企业开发者。IntelliJ
    的 Git 支持功能齐全，能够同步远程仓库的更改，跟踪和提交在 IDE 中进行的更改，并集成上游更改。图中展示了 Git 更改集的集成提交选项卡 [Figure 2-12](#intellij_git_commit)。
- en: '![Screenshot of the IntelliJ commit tab](Images/dtjd_0212.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![IntelliJ 提交选项卡的截图](Images/dtjd_0212.png)'
- en: Figure 2-12\. IntelliJ Commit tab for managing working copy changes
  id: totrans-258
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-12\. IntelliJ 用于管理工作副本更改的提交选项卡
- en: IntelliJ offers a rich set of features that you can use to customize the Git
    behavior to your team workflow. For example, if your team prefers a git-flow or
    GitHub Flow workflow, you can choose to merge on update (more details on Git workflows
    in the next section). However, if your team wants to keep a linear history as
    prescribed in OneFlow, you can choose to rebase on update instead. IntelliJ also
    supports the native credential provider as well as the open source KeePass password
    manager.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: IntelliJ 提供了丰富的功能集，您可以使用它来定制 Git 的行为以适应团队的工作流程。例如，如果您的团队喜欢 git-flow 或 GitHub
    Flow 的工作流程，您可以选择在更新时合并（有关 Git 工作流的更多细节请参见下一节）。然而，如果您的团队希望保持像 OneFlow 中规定的线性历史，您可以选择在更新时进行变基。IntelliJ
    还支持本地凭据提供程序以及开源的 KeePass 密码管理器。
- en: Another IDE that offers great Git support is Eclipse, a fully open source IDE
    that has strong community support and is run by the Eclipse Foundation. The Eclipse
    Git support is provided by the EGit project, which is based on JGit, a pure Java
    implementation of the Git version control system.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个提供出色 Git 支持的 IDE 是 Eclipse，这是一个完全开源的 IDE，拥有强大的社区支持，并由 Eclipse Foundation
    运营。Eclipse 的 Git 支持由 EGit 项目提供，该项目基于 JGit，这是 Git 版本控制系统的纯 Java 实现。
- en: Because of the tight integration with the embedded Java implementation of Git,
    Eclipse has the most full-featured Git support. From the Eclipse user interface,
    you can accomplish almost everything that you would normally have to do from the
    command line, including rebasing, cherry-picking, tagging, patching, and more.
    The rich set of features is obvious from the Preferences dialog, shown in [Figure 2-13](#eclipse_git).
    This dialog has 12 configuration pages detailing how the Git integration works
    and is supported by a user guide that is almost a book itself at 161 pages.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 由于与嵌入式 Java 实现的 Git 紧密集成，Eclipse 提供了最全面的 Git 支持。从 Eclipse 用户界面，您几乎可以完成从命令行执行的所有操作，包括变基、挑选、打标签、打补丁等。从偏好设置对话框中可以看到丰富的功能集，如
    [Figure 2-13](#eclipse_git) 所示。该对话框有 12 个配置页面详细说明 Git 集成的工作，并支持一个长达 161 页的用户指南。
- en: '![Screenshot of the Eclipse settings dialog for Git configuration](Images/dtjd_0213.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![Eclipse 设置对话框中用于 Git 配置的截图](Images/dtjd_0213.png)'
- en: Figure 2-13\. Eclipse Preferences dialog for Git configuration
  id: totrans-263
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-13\. Eclipse 的 Git 配置偏好对话框
- en: 'Other Java IDEs that you can expect great Git support from include the following:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 其他可以期待有很好 Git 支持的 Java IDE 包括以下几款：
- en: NetBeans
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: NetBeans
- en: Offers a Git plug-in that fully supports workflow from the IDE.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了一个 Git 插件，完全支持从 IDE 进行的工作流程。
- en: Visual Studio Code
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio Code
- en: Supports Git along with other version control systems out of the box.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 支持 Git 以及其他开箱即用的版本控制系统。
- en: BlueJ
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: BlueJ
- en: A popular learning IDE built by King’s College London also supports Git in its
    team workflows.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 由伦敦国王学院构建的受欢迎的学习 IDE 还支持其团队工作流中的 Git。
- en: Oracle JDeveloper
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle JDeveloper
- en: While it doesn’t support complicated workflows, JDeveloper does have basic support
    for cloning, committing, and pushing to Git repos.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它不支持复杂的工作流程，JDeveloper 提供了对克隆、提交和推送到 Git 仓库的基本支持。
- en: So far in this chapter, you have added a whole set of new command-line, desktop,
    and integrated tools to your arsenal to work with Git repos. This range of community-
    and industry-supported tools means that no matter your operating system, project
    workflow, or even team preference, you will find full tooling support to be successful
    with your source control management. The next section goes into more detail on
    collaboration patterns that are well supported by the full range of Git tools.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章至今，您已经向您的工具库中添加了一整套新的命令行、桌面和集成工具，用于处理 Git 存储库。 这一系列社区和行业支持的工具意味着，无论您的操作系统、项目工作流程甚至团队偏好如何，您都会发现完整的工具支持可以让您在源代码控制管理方面取得成功。
    下一节将更详细地介绍由完整的 Git 工具范围支持的协作模式。
- en: Git Collaboration Patterns
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Git 协作模式
- en: DVCSs have a proven track record of scaling to extremely large teams with hundreds
    of collaborators. At this scale, it is necessary to agree on uniform collaboration
    patterns that help the team avoid rework, avoid large and unwieldy merges, and
    reduce the amount of time blocked on administering the version control history.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式版本控制系统已经被证明可以扩展到拥有数百名合作者的非常大的团队。 在这种规模下，需要就统一的协作模式达成一致，以帮助团队避免重复工作、避免大量且难以管理的合并，并减少在管理版本控制历史记录上的阻塞时间。
- en: 'Most projects follow a central repository model: a single repository is designated
    as the official repository for integrations, builds, and releases. Even though
    a DVCS allows for noncentralized peer-to-peer exchanges of revisions, these are
    best reserved for short-lived efforts among a small number of developers. For
    any large project, having a single system of truth is important and requires one
    repository that everyone agrees is the official codeline.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数项目遵循中央存储库模型：一个单一的存储库被指定为用于集成、构建和发布的官方存储库。 即使分布式版本控制系统允许非集中式的对等交换修订版，但最好将其保留给在少数开发人员之间进行短期努力的项目。
    对于任何大型项目，具有单一真实性的系统是重要的，并且需要一个所有人都同意是官方代码线的存储库。
- en: For open source projects, it is common for a limited set of developers to have
    write access to the central repository, while other committers *fork* the project
    and issue pull requests to have their changes included. Best practices are to
    have small pull requests, and to have someone other than the pull request creator
    accept them. This scales well to projects with thousands of contributors, and
    allows for review and oversight from a core team when the codebase is not well
    understood.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开源项目，常见的做法是一组有限的开发人员具有对中央存储库的写访问权限，而其他提交者则会*fork*该项目并发出拉取请求以包含他们的更改。 最佳实践是提出小型拉取请求，并且除了拉取请求创建者之外，还有其他人接受它们。
    这对于拥有数千名贡献者的项目具有很好的扩展性，并且在代码库不被充分理解时允许核心团队进行审查和监督。
- en: However, for most corporate projects, a shared repository with a single master
    branch is preferred. The same workflow with pull requests can be used to keep
    a central or release branch clean, but this simplifies the contribution process
    and encourages more frequent integration, which reduces the size and difficulty
    of merging in changes. For teams on tight deadlines or following an Agile process
    with short iterations, this also reduces the risk of last-minute integration failures.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于大多数企业项目来说，首选的是具有单个主分支的共享存储库。 使用拉取请求相同的工作流程可以使中央或发布分支保持清洁，但这简化了贡献过程，并鼓励更频繁的集成，从而减少了合并更改的大小和难度。
    对于有紧迫截止日期或遵循具有短周期迭代的敏捷过程的团队，这也减少了最后一刻集成失败的风险。
- en: The last best practice employed by most teams is to use branches to work on
    features, which then get integrated back into the main codeline. Git makes it
    inexpensive to create short-lived branches, so it is common to create and merge
    back in a branch for work that takes only a couple of hours. The risk with creating
    long-lived feature branches is that if they diverge too much from the main trunk
    of code development, they can become difficult to integrate back in.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数团队采用的最后一个最佳实践是使用分支来处理功能，然后将其集成回主要代码线。 Git 使得创建短期分支成本低廉，因此常见的做法是为仅需几个小时的工作创建一个分支，然后将其合并回来。
    创建长期功能分支的风险在于，如果它们与代码开发的主干分支相差太大，那么将它们集成回来就会变得困难。
- en: Following these general best practices for distributed version control, several
    collaboration models have emerged. They share a lot of commonalities and primarily
    diverge in their approach to branching, history management, and integration speed.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循这些分布式版本控制的通用最佳实践，出现了几种协作模式。 它们有很多共同之处，主要在于它们对分支、历史管理和集成速度的处理方式上有所不同。
- en: git-flow
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: git-flow
- en: '*Git-flow* is one of the earliest Git workflows and was inspired by a [blog
    post](https://oreil.ly/v6aI4) from Vincent Driessen. It laid the groundwork for
    later Git collaboration workflows like GitHub Flow; however, git-flow is a more
    complicated workflow than most projects require and can add additional branch
    management and integration work.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '*Git-flow*是最早的Git工作流之一，受到了Vincent Driessen的一篇[博客文章](https://oreil.ly/v6aI4)的启发。它为后来的Git协作工作流（如GitHub
    Flow）奠定了基础；然而，git-flow比大多数项目需要的工作流更为复杂，可能会增加额外的分支管理和集成工作。'
- en: 'Key attributes include the following:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 主要特点包括以下内容：
- en: Development branches
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 开发分支
- en: Branch per feature
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 每个特性都有一个分支
- en: Merge strategy
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 合并策略
- en: No fast-forward merges
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 不要快进合并
- en: Rebasing history
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 重置历史
- en: No rebasing
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 不进行重置
- en: Release strategy
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 发布策略
- en: Separate release branch
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 单独的发布分支
- en: 'In git-flow, there are two long-lived branches: one for development integration,
    called *develop*, and another for final releases, called *master*. Developers
    are expected to do all of their coding in feature branches that are named according
    to the feature they are working on and integrate that with the develop branch
    once complete. When the develop branch has the features necessary for a release,
    a new release branch is created that is used to stabilize the codebase with patches
    and bugfixes.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在git-flow中，有两个长期存在的分支：一个用于开发集成，称为*develop*，另一个用于最终发布，称为*master*。开发人员预计会在按照他们正在进行的特性命名的特性分支上进行所有编码，并在完成后将其与开发分支集成。当开发分支具有进行发布所需的特性时，将创建一个新的发布分支，用于通过补丁和错误修复稳定代码库。
- en: Once the release branch has stabilized and is ready for release, it is integrated
    into the master branch and given a release tag. Once on the master, only hotfixes
    are applied, which are small changes managed on a dedicated branch. These hotfixes
    also need to be applied back to the develop branch and any other concurrent releases
    that need the same fix. [Figure 2-14](#git_flow_diagram) shows a sample diagram
    for git-flow.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦发布分支稳定并准备好发布，它就会被整合到主分支，并添加一个发布标签。一旦在主分支上，只能应用热修复，这是在专用分支上管理的小改动。这些热修复还需要应用到开发分支和任何其他需要相同修复的并发发布。[图 2-14](#git_flow_diagram)展示了一个git-flow的示意图。
- en: Because of the design decisions on git-flow, it tends to create a complicated
    merge history. By not taking advantage of fast-forward merges or rebasing, every
    integration becomes a commit, and the number of concurrent branches can be hard
    to follow even with visual tools. Also, the complicated rules and branch strategy
    require team training and are difficult to enforce with tools, often requiring
    check-ins and integration to be done from the command-line interface.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 由于git-flow的设计决策，它往往会创建复杂的合并历史。通过不利用快速合并或重置，每次集成都会成为一个提交，即使使用可视工具也很难跟踪并发分支的数量。此外，复杂的规则和分支策略需要团队培训，并且难以用工具强制执行，通常需要通过命令行界面进行检查和集成。
- en: Tip
  id: totrans-295
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: Git-flow is best applied to explicitly versioned projects that have multiple
    releases needing to be maintained in parallel. Usually, this is not the case for
    web applications, which have only one *latest* version and can be managed with
    a single release branch.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: Git-flow最适用于需要同时维护多个发布版的显式版本化项目。通常情况下，这对于只有一个*最新*版本并且可以通过单一发布分支管理的Web应用来说并不适用。
- en: '![Diagram showing branches and integrations over time](Images/dtjd_0214.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![显示随时间变化的分支和集成的示意图](Images/dtjd_0214.png)'
- en: 'Figure 2-14\. Managing branches and integration with git-flow [(source: Vincent
    Driessen, Creative Commons BY-SA)](https://oreil.ly/baH6Z)'
  id: totrans-298
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-14\. 使用git-flow管理分支和集成 [(来源：Vincent Driessen，知识共享署名-相同方式共享)](https://oreil.ly/baH6Z)
- en: If your project is in the sweet spot where git-flow excels, it is a very well-thought-out
    collaboration model. Otherwise, you may find that a simpler collaboration model
    will suffice.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的项目正处于git-flow擅长的甜蜜点，那么它是一个非常经过深思熟虑的协作模型。否则，你可能会发现一个更简单的协作模型就足够了。
- en: GitHub Flow
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GitHub Flow
- en: '*GitHub Flow* is a simplified Git workflow launched in response to the complexity
    of git-flow by Scott Chacon in another prominent [blog](https://oreil.ly/l7gTx).
    GitHub Flow or a close variant has been adopted by most development teams, since
    it is easier to implement in practice, handles the common case for continuous
    released web development, and is well supported by tools.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '*GitHub Flow*是对git-flow复杂性的回应而推出的简化Git工作流，由Scott Chacon在另一篇著名的[博客文章](https://oreil.ly/l7gTx)中提出。GitHub
    Flow或类似的变种已被大多数开发团队采用，因为它在实践中更容易实现，处理了持续发布的Web开发的常见情况，并得到了良好的工具支持。'
- en: 'Key attributes include the following:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 关键特点包括以下几点：
- en: Development branches
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 开发分支
- en: Branch per feature
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 特性分支
- en: Merge strategy
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 合并策略
- en: No fast-forward merges
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 无快速向前合并
- en: Rebasing history
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 重置历史
- en: No rebasing
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 无重置
- en: Release strategy
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 发布策略
- en: No separate release branches
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 没有单独的发布分支
- en: GitHub Flow takes a simple approach to branch management, using *master* as
    the main codeline as well as the release branch. Developers do all of their work
    on short-lived feature branches and integrate them back into the master as soon
    as their code passes tests and code reviews.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 流采用简单的分支管理方法，将 *master* 作为主要代码线和发布分支。开发者在短暂的特性分支上完成所有工作，并在他们的代码通过测试和代码审查后立即将其集成回主分支。
- en: Tip
  id: totrans-312
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: In general, GitHub Flow makes good use of available tooling by having a straightforward
    workflow with a simple branching strategy and no use of complicated arguments
    to enable fast-forward merges or replace merges with rebasing. Developers who
    are not familiar with the team process or not as familiar with the command-line
    Git interface therefore find GitHub Flow easy to use.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，GitHub 流通过简单的工作流程和简单的分支策略充分利用了现有的工具。因此，不熟悉团队流程或不熟悉命令行 Git 界面的开发者发现 GitHub
    流易于使用。
- en: The GitHub Flow collaboration model works well for server-side and cloud-deployed
    applications, where the only meaningful version is the latest release. In fact,
    GitHub Flow recommends that teams continuously deploy to production to avoid feature
    stacking, in which a single release build has multiple features that increase
    complexity and make it harder to determine the breaking change. However, for more
    complicated workflows with multiple concurrent releases, GitHub Flow needs to
    be modified to accommodate.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 流协作模型非常适合服务器端和云部署应用程序，其中唯一有意义的版本是最新发布。事实上，GitHub 流建议团队持续部署到生产环境，以避免特性堆积，即单个发布构建中包含多个增加复杂性的特性，使得确定破坏性变更更加困难。然而，对于具有多个并发发布的更复杂工作流程，需要修改
    GitHub 流以适应。
- en: GitLab Flow
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GitLab 流
- en: '*GitLab Flow* is basically an extension of GitHub Flow, as documented on GitLab’s
    [website](https://oreil.ly/P1LzH). It takes the same core design principles about
    using a master as a single long-lived branch and doing the majority of development
    on feature branches. However, it adds a few extensions to support release branches
    and history cleanup that many teams have adopted as best practices.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '*GitLab 流* 实际上是 GitHub 流的扩展，在 GitLab 的 [网站](https://oreil.ly/P1LzH) 上有文档记录。它遵循相同的核心设计原则，使用主分支作为单个长期存在的分支，并在特性分支上进行大部分开发。然而，它添加了一些扩展以支持许多团队采用的发布分支和历史清理作为最佳实践。'
- en: 'Key attributes include the following:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 关键特点包括以下几点：
- en: Development branches
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 开发分支
- en: Branch per feature
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 特性分支
- en: Merge strategy
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 合并策略
- en: Open-ended
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 开放式
- en: Rebasing history
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 重置历史
- en: Optional
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 可选
- en: Release strategy
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 发布策略
- en: Separate release branches
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 单独的发布分支
- en: The key difference between GitHub Flow and GitLab Flow is the addition of release
    branches. This is recognition that most teams are not practicing continuous deployment
    at the level GitHub does. Having release branches allows stabilization of code
    before it gets pushed into production; however, GitLab Flow recommends making
    patches to the master and then cherry-picking them for release rather than having
    an extra hotfix branch like git-flow.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 流和 GitLab 流之间的关键区别在于添加了发布分支。这是因为大多数团队并不像 GitHub 那样实践持续部署。拥有发布分支可以在推送到生产之前稳定代码；然而，GitLab
    流建议在主分支上进行补丁，然后挑选它们进行发布，而不是像 git-flow 那样有额外的热修复分支。
- en: The other significant difference is the willingness to edit history using `rebase`
    and `squash`. By cleaning up the history before committing to master, it is easier
    to retroactively go back and read the history to discover when key changes or
    bugs were introduced. However, this involves rewriting the local history and can
    be dangerous when that history has already been pushed to the central repository.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的区别是愿意使用 `rebase` 和 `squash` 来编辑历史。通过在提交到主分支之前清理历史，可以更轻松地回溯历史，发现关键变更或引入的错误。然而，这涉及重写本地历史，在已经推送到中央仓库时可能会很危险。
- en: Tip
  id: totrans-328
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: GitLab Flow is a modern take on the GitHub Flow philosophy to collaboration
    workflow, but ultimately your team has to decide on the features and branch strategy
    based on your project’s needs.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab 流是对 GitHub 流协作工作流理念的现代演绎，但最终你的团队必须根据项目需求决定特性和分支策略。
- en: OneFlow
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OneFlow
- en: '*OneFlow*, another collaboration workflow based on git-flow, was proposed by
    Adam Ruka and introduced in a detailed [blog](https://oreil.ly/euJ37). OneFlow
    makes the same adaptation as GitHub/GitLab Flow in squashing the separate develop
    branch in favor of feature branches and direct integration on the main branch.
    However, it keeps the release and hotfix branches that are used in git-flow.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '*OneFlow*，另一种基于 git-flow 的协作工作流，由亚当·鲁卡提出，并在详细的 [博客](https://oreil.ly/euJ37)
    中介绍。OneFlow 与 GitHub/GitLab Flow 一样，在压缩独立的开发分支以支持特性分支和直接集成到主分支方面进行了相同的适应。然而，它保留了在
    git-flow 中使用的发布和热修复分支。'
- en: 'Key attributes include the following:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 'Key attributes include the following:'
- en: Development branches
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: Development branches
- en: Branch per feature
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 每个特性分支
- en: Merge strategy
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 合并策略
- en: No fast-forward merges without rebase
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: No fast-forward merges without rebase
- en: Rebasing history
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: Rebasing history
- en: Rebasing recommended
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐使用 rebase
- en: Release strategy
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 发布策略
- en: Separate release branches
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 单独的发布分支
- en: 'The other big deviation in OneFlow is that it heavily favors modifying history
    to keep the Git revision history readable. It offers three merge strategies that
    have varying levels of revision cleanliness and rollback friendliness:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: OneFlow 的另一个重大偏差是，它非常倾向于修改历史以保持 Git 修订历史的可读性。它提供了三种合并策略，具有不同程度的修订清洁度和回滚友好性：
- en: Rebase
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: Rebase
- en: This makes the merge history mostly linear and easy to follow. It has the usual
    caveat that changesets pushed to the central server should not be rebased and
    makes it more difficult to roll back changes since they are not captured in a
    single commit.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得合并历史基本上是线性的并且易于跟踪。它有一个通常的警告，即推送到中央服务器的变更集不应该进行 rebase，并且使得回滚变得更加困难，因为它们不会捕获在一个单一提交中。
- en: merge -no-ff
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: merge -no-ff
- en: This is the same strategy used in git-flow and has the disadvantage that the
    merge history is largely nonsequential and difficult to follow.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 git-flow 中使用的策略相同，并且其缺点是合并历史主要是非顺序的，难以跟踪。
- en: rebase + merge -no-ff
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: rebase + merge -no-ff
- en: This is a rebase workaround that tacks on an extra merge integration at the
    end so it can be rolled back as a unit even though it is still mostly sequential.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个重新基于 rebase 的解决方法，最后增加了额外的合并集成，以便可以作为一个单元回滚，尽管它仍然基本上是顺序的。
- en: Tip
  id: totrans-348
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Tip
- en: OneFlow is a thoughtful approach to a Git collaboration workflow that is created
    from the experience of developers on large enterprise projects. It can be seen
    as a modern variant on git-flow that should serve the needs of projects of any
    size.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: OneFlow 是一个经过深思熟虑的 Git 协作工作流，是根据大型企业项目开发人员的经验创建的。它可以看作是 git-flow 的现代变体，应该能够满足任何规模项目的需求。
- en: Trunk-Based Development
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Trunk-Based Development
- en: All of the aforementioned approaches are variants of the feature branch development
    model; all active development is done on branches that get merged into either
    the master or a dedicated development branch. They take advantage of the great
    support Git has for branch management, but if features are not granular enough,
    they suffer from the typical integration problems that have plagued teams for
    decades. The longer the feature branch is in active development, the higher the
    likelihood for merge conflicts with other features and maintenance going on in
    the master branch (or trunk).
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 所有上述方法都是特性分支开发模型的变种；所有活跃的开发都在分支上进行，然后合并到主分支或专用开发分支。它们充分利用了 Git 在分支管理方面的强大支持，但如果特性不够细粒度，就会遭受几十年来困扰团队的典型集成问题。特性分支在活跃开发越长，与主分支（或主干）同时进行的其他特性和维护发生冲突的可能性就越高。
- en: '*Trunk-based development* solves this problem by recommending that all development
    happen on the main branch with very short integrations that occur anytime that
    tests are passing, but not necessarily waiting for a full feature to be completed.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '*基于主干的开发* 通过建议所有开发都在主分支上进行，并且在测试通过时随时进行非常短的集成来解决这个问题，但不一定等待完整的特性完成。'
- en: 'Key attributes include the following:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 'Key attributes include the following:'
- en: Development branches
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 开发分支
- en: Optional, but no long-lived branches
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 可选，但不能有长期存在的分支
- en: Merge strategy
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: Merge strategy
- en: Only if using development branches
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: Only if using development branches
- en: Rebasing history
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: Rebasing history
- en: Rebasing recommended
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐使用 rebase
- en: Release strategy
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 发布策略
- en: Separate release branches
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: Separate release branches
- en: Paul Hammant, a strong advocate for trunk-based development, has set up a [full
    website](https://oreil.ly/HFo0J) and written a book on the topic. While this is
    not a new approach to collaboration on source control management systems, it is
    a proven approach to Agile development in large teams and works equally well on
    classic central SCMs like CVS and Subversion, and modern DVCSs like Git.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: Paul Hammant 是主张基于主干的开发的坚定支持者，他建立了一个[完整的网站](https://oreil.ly/HFo0J)，并撰写了一本相关主题的书籍。尽管这并不是协作源代码管理系统中的新方法，但它已被证明是大团队敏捷开发的有效方法，无论是在经典的中央化SCM如CVS和Subversion上，还是现代的分布式版本控制系统如Git上同样适用。
- en: Summary
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Good source control systems and practices lay the foundation for a solid DevOps
    approach to building, releasing, and deploying code quickly. In this chapter,
    we discussed the history of source control systems and explained why the world
    has moved to embrace distributed version control.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的源代码管理系统和实践为快速构建、发布和部署代码的稳健DevOps方法奠定了基础。在本章中，我们讨论了源代码管理系统的历史，并解释了为什么全球开始接受分布式版本控制。
- en: This consolidation has built a rich ecosystem of source control servers, developer
    tools, and commercial integrations. Finally, through the adoption of distributed
    version control by DevOps thought leaders, best practices and collaboration workflows
    have been established that you can follow to help make your team successful with
    adopting a modern SCM.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这种整合建立了丰富的源代码控制服务器、开发工具和商业集成生态系统。最终，通过DevOps思想领袖对分布式版本控制的采纳，建立了可以遵循的最佳实践和协作工作流程，以帮助您的团队成功采用现代化的源代码管理系统。
- en: In the next few chapters, we will drill into systems that connect to your source
    control management system, including continuous integration, package management,
    and security scanning, that allow you to rapidly deploy to traditional or cloud
    native environments. You are on the way to building a comprehensive DevOps platform
    that will support whatever workflow you need to meet your quality and deployment
    objectives.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几章中，我们将深入探讨与您的源代码管理系统连接的系统，包括持续集成、包管理和安全扫描，这些系统能让您快速部署到传统或云原生环境中。您正在打造一个全面支持您需要满足质量和部署目标的工作流的DevOps平台。
