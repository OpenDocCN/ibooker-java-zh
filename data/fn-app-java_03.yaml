- en: Chapter 2\. Functional Java
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章. 函数式Java
- en: Unsurprisingly, *lambda expressions* are the key to having a functional approach
    in Java.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，*lambda表达式*是在Java中采用函数式编程方法的关键。
- en: In this chapter, you will learn how to use lambdas in Java, why they are so
    important, how to use them efficiently, and how they work internally.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何在Java中使用lambda表达式，它们为何如此重要，如何高效使用它们以及它们的内部工作原理。
- en: What Are Java Lambdas?
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是Java Lambdas？
- en: 'A lambda expression is a single line or block of Java code that zero or more
    parameters and might return a value. From a simplified point of view, a lambda
    is like an *anonymous method* that doesn’t belong to any object:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式是一行或一块Java代码，它可能有零个或多个参数，并可能返回一个值。从简化的角度看，lambda就像一个不属于任何对象的*匿名方法*：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let’s look at the details of the syntax and how lambdas are implemented in Java.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看语法的详细信息以及如何在Java中实现lambda。
- en: Lambda Syntax
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lambda语法
- en: 'The Java syntax for lambdas is quite similar to the mathematical notation you
    saw in [Chapter 1](ch01.xhtml#_01-an-introduction) for lambda calculus:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Java中lambda的语法与你在[第1章](ch01.xhtml#_01-an-introduction)中看到的lambda演算的数学符号非常相似：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The syntax consists of three distinct parts:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 语法由三个不同部分组成：
- en: Parameters
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 参数
- en: A comma-separated list of parameters, just like a method argument list. Unlike
    method arguments, though, you can omit the argument types if the compiler can
    infer them. Mixing implicitly and explicitly typed parameters is not allowed.
    You don’t need parentheses for a single parameter, but they are required if none
    or more than one parameter is present.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一个逗号分隔的参数列表，就像方法参数列表一样。不过，与方法参数不同的是，如果编译器能够推断出参数类型，你可以省略参数类型。不允许混合使用隐式和显式类型的参数。对于单个参数，你不需要括号，但如果没有参数或多个参数，则需要括号。
- en: Arrow
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头
- en: The `->` (arrow) separates the parameters from the lambda body. It’s the equivalent
    to <math alttext="lamda"><mi>λ</mi></math> in lambda calculus.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`->`（箭头）将参数与lambda体分隔开来。它相当于lambda演算中的<math alttext="lambda"><mi>λ</mi></math>。'
- en: Body
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 体
- en: Either a single expression or a code block. Single-line expressions don’t require
    curly braces, and their evaluated result returns implicitly without a `return`
    statement. A typical Java code block is used if the body is represented by more
    than a single expression. It must be wrapped in curly braces and explicitly use
    a `return` statement if a value is supposed to be returned.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 可以是单个表达式或代码块。单行表达式不需要花括号，并且它们的计算结果隐式返回，不需要`return`语句。如果体由多个表达式组成，则使用典型的Java代码块。如果需要返回值，则必须用花括号明确地使用`return`语句。
- en: That is all the syntax definition there is for lambdas in Java. With its multiple
    ways of declaring a lambda, you can write the same lambda with different levels
    of verbosity, as seen in [Example 2-1](#_01-functions_java-lambdas_syntax-compare).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Java中关于lambda的语法定义。通过多种声明lambda的方式，你可以以不同程度的冗长写出相同的lambda表达式，就像在[示例 2-1](#_01-functions_java-lambdas_syntax-compare)中所见。
- en: Example 2-1\. Different ways of writing the same lambda
  id: totrans-18
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-1\. 写相同lambda的不同方法
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[![1](assets/1.png)](#co_functional_java_CO1-1)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_functional_java_CO1-1)'
- en: 'The most verbose variant: an explicitly typed parameter in parenthesis and
    a body block.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最冗长的变体：显式类型的参数在括号内，且有代码块体。
- en: '[![2](assets/2.png)](#co_functional_java_CO1-2)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_functional_java_CO1-2)'
- en: 'The first mixed variant: type inference for parameters allows removing the
    explicit type, and a single parameter doesn’t need parenthesis. That shortens
    the lambda declaration slightly without removing information due to the surrounding
    context.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种混合变体：参数类型推断允许省略显式类型，并且单个参数不需要括号。这样稍微缩短了lambda声明，但由于周围的上下文，不会丢失信息。
- en: '[![3](assets/3.png)](#co_functional_java_CO1-3)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_functional_java_CO1-3)'
- en: 'The second mixed variant: an explicitly typed parameter in parenthesis but
    a single expression body instead of a block, no curly braces or `return` statement
    are needed.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种混合变体：显式类型的参数在括号内，但只有单个表达式体而不是代码块，不需要花括号或`return`语句。
- en: '[![4](assets/4.png)](#co_functional_java_CO1-4)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_functional_java_CO1-4)'
- en: 'The most concise variant: As the body is reducible to a single expression.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最简洁的变体：由于体可以简化为单个表达式。
- en: Which variant to choose depends highly on the context and personal preference.
    Usually, the compiler can infer the types, but that doesn’t mean a human reader
    is as good at understanding the shortest code possible as a compiler does.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要选择哪种变体取决于上下文和个人偏好。通常，编译器可以推断类型，但这并不意味着人类读者能够像编译器一样理解最短的代码。
- en: Even though you should always strive for clean and more concise code, that doesn’t
    mean it has to be as minimal as possible. A certain amount of verbosity might
    help any reader — you included — to understand the reasoning behind the code better
    and make the mental model of your code more graspable.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管您应始终力求编写清晰和更简洁的代码，但这并不意味着它必须尽可能地简洁。适当的冗长可能有助于任何读者（包括您自己）更好地理解代码背后的原因，并使您的代码的心智模型更易于掌握。
- en: Functional Interfaces
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数接口
- en: So far, we’ve only looked at the general concept of lambdas in isolation. However,
    they still have to exist inside Java and its concepts and language rules as well.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只是孤立地看待lambda的一般概念。然而，它们仍然必须存在于Java及其概念和语言规则内部。
- en: Java is known for its backward compatibility. That’s why even though the lambda
    syntax is a breaking change to the Java syntax itself, they’re still based on
    ordinary interfaces to be backward compatible and feel quite familiar to any Java
    developer.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Java以其向后兼容性而闻名。这就是为什么尽管lambda语法是对Java语法本身的一个破坏性改变，它们仍然基于普通接口以保持向后兼容，并且对任何Java开发者来说都感觉非常熟悉。
- en: To achieve their *first-class citizenship*, lambdas in Java require a representation
    comparable to the existing types, like objects and primitives, as discussed in
    [“First-Class and Higher-Order Functions”](ch01.xhtml#_01-an-introduction_concepts_first-class).
    Therefore, lambdas are represented by a specialized subtype of interfaces, so-called
    *functional interfaces*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现它们的*一流公民地位*，Java 中的lambda需要与现有类型（如对象和原始类型）相比较的表示形式，如在[“一级和高阶函数”](ch01.xhtml#_01-an-introduction_concepts_first-class)中讨论的那样。因此，lambda通过所谓的*函数接口*的专门子类型来表示。
- en: There isn’t any explicit syntax or language keyword for *functional interfaces*.
    They look and feel like any other interface, can extend or be extended by other
    interfaces, and classes can implement them. If they are just like “normal” interfaces,
    what makes them a “functional” interface then? It’s their enforced requirement
    that they may only define a *single abstract method* (SAM).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数接口*没有明确的语法或语言关键字。它们看起来和感觉像任何其他接口，可以扩展或被其他接口扩展，类可以实现它们。如果它们就像“普通”接口一样，那么是什么使它们成为“函数”接口呢？这是它们强制要求只能定义一个*单一抽象方法*（SAM）。'
- en: As the name signifies, the SAM count only applies to `abstract` methods. There’s
    no limit to any additional, non-`abstract` methods. Neither `default` nor `static`
    methods are abstract, hence not relevant for the SAM count. That’s why they are
    often used to complement the capabilities of the lambda type.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 正如名称所示，SAM 计数仅适用于`abstract`方法。对于任何额外的非`abstract`方法没有限制。`default`和`static`方法都不是抽象的，因此对SAM
    计数不相关。这就是为什么它们经常用于补充lambda类型的功能。
- en: Tip
  id: totrans-36
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Most functional interfaces of the JDK give you additional `default` and `static`
    methods related to the type. Checking out the interface declarations of any functional
    interface might reveal many hidden gems of functionality.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: JDK 中的大多数函数接口为您提供与类型相关的额外`default`和`static`方法。检查任何函数接口的接口声明可能会揭示许多功能上的隐匿宝藏。
- en: Consider [Example 2-2](#_01-functions-functional-interfaces_predicate), which
    shows a simplified version^([1](ch02.xhtml#idm45115256766512)) of the functional
    interface `java.util.function.Predicate<T>`. A `Predicate` is a functional interface
    for testing conditions, which will be explained in more detail in [“The Big Four
    Functional Interface Categories”](ch03.xhtml#_01-functions_the-big-four). Besides
    having a single abstract method, `boolean test(T t)`, it provides five additional
    methods (three `default`, two `static`).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑[示例 2-2](#_01-functions-functional-interfaces_predicate)，展示了函数接口`java.util.function.Predicate<T>`的简化版本^([1](ch02.xhtml#idm45115256766512))。`Predicate`是一个用于测试条件的函数接口，将在[“四大函数接口类别详解”](ch03.xhtml#_01-functions_the-big-four)中详细解释。
- en: Example 2-2\. Simplified `java.util.functional.Predicate<T>`
  id: totrans-39
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-2\. 简化的`java.util.functional.Predicate<T>`
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[![1](assets/1.png)](#co_functional_java_CO2-1)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_functional_java_CO2-1)'
- en: The type has a `@FunctionalInterface` annotation, which isn’t explicitly required.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 类型有一个`@FunctionalInterface`注解，这不是强制要求的。
- en: '[![2](assets/2.png)](#co_functional_java_CO2-2)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_functional_java_CO2-2)'
- en: The single abstract method of the type `Predicate<T>`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 类型为`Predicate<T>`的单一抽象方法。
- en: '[![3](assets/3.png)](#co_functional_java_CO2-3)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_functional_java_CO2-3)'
- en: Several `default` methods provide support for functional composition.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 几个`default`方法提供了对函数组合的支持。
- en: '[![4](assets/4.png)](#co_functional_java_CO2-6)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_functional_java_CO2-6)'
- en: Convenience `static` methods are used to simplify creation or to wrap existing
    lambdas.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 便捷的`static`方法被用来简化创建或封装已存在的 lambdas。
- en: Any interface with a single abstract method is automatically a functional interface.
    Therefore, any of their implementations is representable by a lambda, too.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 任何具有单一抽象方法的接口都自动成为函数式接口。因此，它们的任何实现也可以用 lambda 表示。
- en: Java 8 added the marker annotation `@FunctionalInterface` to enforce the SAM
    requirement at the compiler level. It isn’t mandatory, but it tells the compiler
    and possibly other annotation-based tooling that an interface should be a functional
    interface and, therefore, that the single abstract method requirement must be
    enforced. If you add another `abstract` method, the Java compiler will refuse
    to compile your code. That’s why adding the annotation to any functional interface
    makes a lot of sense, even if you don’t explicitly need it. It clarifies the reasoning
    behind your code and the intention of such an interface and fortifies your code
    against unintentional changes that might break it in the future.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8 添加了标记注解`@FunctionalInterface`以在编译器级别强制执行 SAM 要求。这不是强制性的，但它告诉编译器和可能其他基于注解的工具，一个接口应该是一个函数式接口，因此，单一抽象方法的要求必须被执行。如果你添加了另一个`abstract`方法，Java
    编译器将拒绝编译你的代码。这就是为什么将注解添加到任何函数式接口都是有道理的，即使你并不明确需要它。它澄清了你的代码背后的原因和这种接口的意图，并且加强了你的代码，使其能够抵御未经意的更改，可能会在将来破坏它。
- en: The optional nature of the `@FunctionalInterface` annotation also enables the
    backward compatibility of existing interfaces. As long as an interface fulfills
    the SAM requirements, it’s representable as a lambda. I’ll talk about the functional
    interfaces of the JDK later in this chapter.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`@FunctionalInterface`注解的可选性也使现有接口的向后兼容性成为可能。只要一个接口满足 SAM 的要求，它就可以表示为一个 lambda。我将在本章稍后讨论
    JDK 的函数式接口。'
- en: Lambdas and Outside Variables
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lambda 函数和外部变量
- en: '[“Pure Functions and Referential Transparency”](ch01.xhtml#_01-an-introduction_pure-functions)
    introduced the concept of *pure* — self-contained and side-effect-free — functions
    that won’t affect any outside state and only rely on their arguments. Even though
    lambdas follow the same gist, they also allow a certain degree of impurity to
    be more flexible. They can “capture” constants and variables from their creation
    scope in which the lambda is defined, which makes such variables available to
    them even if the original scope no longer exists, as shown in [Example 2-3](#_01-functions_pure-lambas_capture).'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[“纯函数和引用透明度”](ch01.xhtml#_01-an-introduction_pure-functions)介绍了 *纯* — 自包含且无副作用 — 不会影响任何外部状态且只依赖于其参数的函数的概念。尽管
    lambdas 遵循相同的要点，但它们也允许一定程度的不纯度以获得更灵活性。它们可以在定义 lambda 的创建范围内“捕获”常量和变量，即使原始范围不再存在，也可以使这些变量对它们可用，如
    [示例 2-3](#_01-functions_pure-lambas_capture)所示。'
- en: Example 2-3\. Lambda variable capture
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-3\. Lambda 变量捕获
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[![1](assets/1.png)](#co_functional_java_CO3-1)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_functional_java_CO3-1)'
- en: The variable `theAnswer` is declared in the scope of `capture()`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`theAnswer`在`capture()`的范围内声明。
- en: '[![2](assets/2.png)](#co_functional_java_CO3-2)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_functional_java_CO3-2)'
- en: The lambda `printAnswer` captures the variable in its body.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda `printAnswer` 在其函数体内捕获了变量。
- en: '[![3](assets/3.png)](#co_functional_java_CO3-3)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_functional_java_CO3-3)'
- en: The lambda can be run in another method and scope but still has access to `theAnswer`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 可以在另一个方法和作用域中运行，但仍然可以访问 `theAnswer`。
- en: The big difference between *capture* and *non-capture* lambdas is the optimization
    strategies of the JVM. The JVM optimizes lambdas with different strategies based
    on their actual usage pattern. If no variables get captured, a lambda might end
    up being a simple `static` method behind the scenes, beating out the performance
    of alternative approaches like anonymous classes. The implications of capturing
    variables on performance are not as clear-cut, though.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*捕获* 和 *非捕获* Lambda 之间的主要区别在于 JVM 的优化策略。根据它们的实际使用模式，JVM 会优化不同的 Lambda。如果没有变量被捕获，一个
    Lambda 可能最终会成为幕后的一个简单的 `static` 方法，从而超越匿名类等替代方法的性能。尽管如此，捕获变量对性能的影响并不是那么明确。'
- en: There are multiple ways the JVM might translate your code if it captures variables,
    leading to additional object allocation, affecting performance, and garbage collector
    times. That doesn’t mean that capturing variables is inherently a bad design choice.
    The main goal of a more functional approach should be improved productivity, more
    straightforward reasoning, and more concise code. Still, you should avoid unnecessary
    capturing, especially if you require the least amount of allocations or the best
    performance possible.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: JVM 可能以多种方式翻译你的代码，如果捕获变量，会导致额外的对象分配，影响性能和垃圾回收时间。这并不意味着捕获变量本质上是一个不好的设计选择。更函数化方法的主要目标应该是提高生产力、更简单的推理和更简洁的代码。然而，你应该避免不必要的捕获，特别是如果你需要尽量减少分配或者获得最佳性能。
- en: Another reason to avoid capturing variables is their necessity of being *effectively*
    `final`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 避免捕获变量的另一个原因是它们必须是 *实质上* `final` 的。
- en: Effectively final
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实质上是最终的
- en: 'The JVM has to make special considerations to use captured variables safely
    and achieve the best performance possible. That’s why there’s an essential requirement:
    only *effectively* `final` variables are allowed to be captured.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: JVM 必须考虑安全地使用捕获的变量，并实现尽可能的最佳性能。这就是为什么有一个重要的要求：只有 *实质上* 是 `final` 的变量才允许被捕获。
- en: In simple terms, any captured variable must be an immutable reference that isn’t
    allowed to change after its initialization. They *must* be `final`, either by
    explicitly using the `final` keyword or by *never* changing after their initialization,
    making them *effectively* `final`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，任何被捕获的变量必须是一个不可变的引用，在初始化后不允许更改。它们必须是 `final`，要么通过显式使用 `final` 关键字，要么通过在初始化后
    *永不* 更改，使其 *实质上* 成为 `final`。
- en: Be aware that this requirement is actually for the *reference* to a variable
    and *not* the underlying data structure itself. A reference to a `List<String>`
    might be `final`, and therefore usable in a lambda, but you can still add new
    items, as seen in [Example 2-4](#_01-functions-effecitvely-final_mutable). Only
    reassigning the variable is prohibited.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个要求实际上是针对变量的 *引用* 而不是其底层数据结构本身。对 `List<String>` 的引用可能是 `final` 的，因此可以在
    Lambda 中使用，但你仍然可以添加新的项目，如 [示例 2-4](#_01-functions-effecitvely-final_mutable) 所示。只有重新分配变量是被禁止的。
- en: Example 2-4\. Change data behind a `final` variable
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-4\. 更改 `final` 变量后的数据
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[![1](assets/1.png)](#co_functional_java_CO4-1)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_functional_java_CO4-1)'
- en: The variable `list` is explicitly `final`, making the reference immutable.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `list` 显式地是 `final` 的，使得引用是不可变的。
- en: '[![2](assets/2.png)](#co_functional_java_CO4-2)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_functional_java_CO4-2)'
- en: Capturing and using the variable in a lambda works without problems. However,
    the `final keyword does not affect the +List` itself, allowing you to add additional
    items.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Lambda 中捕获和使用变量是没有问题的。然而，`final` 关键字并不影响 +List 本身，允许你添加额外的项目。
- en: '[![3](assets/3.png)](#co_functional_java_CO4-3)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_functional_java_CO4-3)'
- en: Reassigning the variable is prohibited due to the `final` keyword and won’t
    compile.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `final` 关键字，重新分配变量是被禁止的，并且不会编译通过。
- en: The simplest way to test whether a variable is *effectively* `final` or not
    is by making it explicitly `final`. If your code still compiles with the additional
    `final` keyword, it will compile without it. So why not make every variable `final`?
    Because the compiler ensures that “out-of-body” references are *effectively* `final`,
    the keyword won’t help with actual immutability anyways. Making every variable
    `final` would only create more visual noise in your code without much benefit.
    Adding a modifier like `final` should always be a conscious decision with intent.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 测试一个变量是否 *effectively* `final` 或者不是最简单的方法是将其显式声明为 `final`。如果你的代码在添加了 `final`
    关键字后仍然能够编译通过，那么它本来也可以编译通过。那为什么不将每个变量都声明为 `final` 呢？因为编译器确保“out-of-body”引用是 *effectively*
    `final` 的，所以这个关键字在实际上并不会帮助不可变性。将每个变量声明为 `final` 只会在你的代码中增加更多视觉噪音，而没有太多实际好处。添加
    `final` 这样的修饰符应该始终是有意识的决定。
- en: Warning
  id: totrans-78
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: If you run any of the shown *effectively* `final`-related examples in `jshell`,
    they might not behave as expected. That’s because `jshell` has special semantics
    regarding top-level expressions and declarations, which affects `final` or effectively
    `final` values at top-level^([2](ch02.xhtml#idm45115252733520)). Even though you
    can reassign any reference, making it non-effectively `final`, you can still use
    them in lambdas, as long as you’re not in the top-level scope.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 `jshell` 中运行任何显示的 *effectively* `final` 相关示例，它们可能不会如预期般运行。这是因为 `jshell`
    对于顶级表达式和声明具有特殊的语义，这影响了顶级处的 `final` 或 effectively `final` 值^([2](ch02.xhtml#idm45115252733520))。即使你可以重新分配任何引用，使其不再是
    effectively `final`，你仍然可以在 lambda 中使用它们，只要你不在顶级范围内。
- en: Re-finalizing a Reference
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重新final化一个引用
- en: Sometimes a reference might not be *effectively* `final`, but you still need
    them to be available in a lambda. If refactoring your code isn’t an option, there’s
    a simple trick to *re-finalize* them. Remember, the requirement is just for the
    reference and not the underlying data structure itself.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 有时一个引用可能不是 *effectively* `final`，但你仍然需要它们在 lambda 中可用。如果重构你的代码不是一个选项，有一个简单的技巧可以
    *re-finalize* 它们。记住，要求只是对引用而不是底层数据结构本身。
- en: You can create a new *effectively* `final` reference to the non-*effectively*
    `final` variable by simply referencing the original one and not changing it further,
    as shown in [Example 2-5](#_01-functions-effecitvely-final_refinalize).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过简单引用原始变量并且不再更改它来创建一个新的 *effectively* `final` 引用，示例见 [Example 2-5](#_01-functions-effecitvely-final_refinalize)。
- en: Example 2-5\. Re-finalize a variable
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-5\. 重新final化一个变量
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[![1](assets/1.png)](#co_functional_java_CO5-1)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_functional_java_CO5-1)'
- en: At this point, `nonEffectivelyFinal` is still *effectively* `final`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，`nonEffectivelyFinal` 仍然是 *effectively* `final`。
- en: '[![2](assets/2.png)](#co_functional_java_CO5-2)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_functional_java_CO5-2)'
- en: Changing the variable after its initialization makes it unusable in lambda.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化后更改变量会使其在 lambda 中无法使用。
- en: '[![3](assets/3.png)](#co_functional_java_CO5-3)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_functional_java_CO5-3)'
- en: By creating a new variable and not changing it after its initialization, you
    “re-finalized” the reference to the underlying data structure.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建一个新变量，并且在初始化后不再更改它，你“重新finalize”了对底层数据结构的引用。
- en: Keep in mind that re-finalizing a reference is just a “band-aid”, and needing
    a band-aid means you scraped your knees first. So the best approach is trying
    not to need it at all. Refactoring or redesigning your code should always be the
    preferred option instead of bending the code to your will with tricks like re-finalizing
    a reference.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，重新finalize一个引用只是一个“创可贴”，而需要创可贴意味着你先擦伤了你的膝盖。因此，最好的方法是尽量避免需要它。重构或重新设计你的代码应该始终是首选，而不是通过重新finalize一个引用这样的技巧来弯曲你的代码意愿。
- en: Such safeguards for using variables in lambdas like the effectively `final`
    requirement might feel like an additional burden at first. However, instead of
    capturing “out-of-body” variables, your lambdas should strive to be self-sufficient
    and require all necessary data as arguments. That automatically leads to more
    reasonable code, increased reusability, and allows for easier refactoring and
    testing.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像 effectively `final` 要求这样在 lambda 中使用变量的保护措施可能一开始会感觉像是额外的负担。然而，你的 lambda
    应该努力成为自给自足的，需要所有必要的数据作为参数。这会自动导致更加合理的代码，增加重用性，并且更容易进行重构和测试。
- en: What about Anonymous Classes?
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匿名类怎么办？
- en: 'After learning about lambdas and functional interfaces, you’re most likely
    reminded of their similarities to *anonymous inner classes*: the combined declaration
    and instantiation of types. An interface or extended class can be implemented
    “on-the-fly” without needing a separate Java class, so what differs between a
    lambda expression and an anonymous class if they both have to implement a concrete
    interface?'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解Lambda和功能接口之后，您很可能会想起它们与*匿名内部类*的相似之处：类型的联合声明和实例化。可以“即时”实现接口或扩展类，而无需单独的Java类，因此Lambda表达式和匿名类之间有什么不同，如果它们都必须实现一个具体的接口呢？
- en: On the surface, a functional interface implemented by an anonymous class looks
    quite similar to its lambda representation, except for the additional boilerplate,
    as seen in [Example 2-6](#_01-functions_java-lambdas_anonymous-classes).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 从表面上看，由匿名类实现的功能接口看起来与其Lambda表示相当相似，除了额外的样板代码，如[示例 2-6](#_01-functions_java-lambdas_anonymous-classes)所示。
- en: Example 2-6\. Anonymous class vs. lambda expression
  id: totrans-96
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-6\. 匿名类与Lambda表达式
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Does that mean that lambda expressions are just *syntactic sugar* for implementing
    a functional interface as an anonymous class then?
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，Lambda表达式是否只是实现一个功能接口作为匿名类的*语法糖*？
- en: Lambda expressions might look like syntactic sugar, but they’re so much more
    in reality. The *real* difference — besides verbosity — lies in the generated
    bytecode, as seen in [Example 2-7](#_01-functions_java-lambdas_syntax-lambda-as-anonymous_bytecode),
    and how the runtime handles it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式可能看起来像是语法糖，但实际上它们远不止于此。除了冗长之外，*真正的*区别在于生成的字节码，如[示例 2-7](#_01-functions_java-lambdas_syntax-lambda-as-anonymous_bytecode)所示，以及运行时如何处理它。
- en: Example 2-7\. Bytecode differences between anonymous classes and lambdas
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-7\. 匿名类和Lambda之间的字节码差异
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[![1](assets/1.png)](#co_functional_java_CO6-1)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_functional_java_CO6-1)'
- en: A new object of the anonymous inner class `HelloWorldAnonymous$1` is created
    in the surrounding class `HelloWorldAnonymous`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在外部类`HelloWorldAnonymous`中创建了匿名内部类`HelloWorldAnonymous$1`的新对象。
- en: '[![2](assets/2.png)](#co_functional_java_CO6-2)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_functional_java_CO6-2)'
- en: The constructor of the anonymous class is called. Object creation is a two-step
    process in the JVM.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 调用匿名类的构造函数。对象创建在JVM中是一个两步骤的过程。
- en: '[![3](assets/3.png)](#co_functional_java_CO6-3)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_functional_java_CO6-3)'
- en: The `invokedynamic` opcode hides the whole logic behind creating the lambda.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`invokedynamic`操作码隐藏了创建Lambda的整个逻辑。'
- en: Both variants have the `astore_1` call in common, which stores a reference into
    a local variable, and the `return` call, so both won’t be part of analyzing the
    bytecode.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 两种变体都共同拥有`astore_1`调用，该调用将引用存储到一个局部变量中，以及`return`调用，因此两者都不会成为字节码分析的一部分。
- en: 'The anonymous class version creates a new object of the anonymous type `Anonymous$1`,
    resulting in three opcodes:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名类版本创建了一个匿名类型`Anonymous$1`的新对象，导致三个操作码：
- en: '`new`'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`new`'
- en: Create a new uninitialized instance of a type.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的未初始化类型实例。
- en: '`dup`'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`dup`'
- en: Put the value on top of the stack by duplicating it.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通过复制将值放在堆栈顶部。
- en: '`invokespecial`'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`invokespecial`'
- en: Call the constructor method of the newly created object to finalize its initialization.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 调用新创建对象的构造方法以完成其初始化。
- en: 'The lambda version, on the other hand, doesn’t need to create an instance that
    needs to be put on the stack. Instead, it delegates the whole task of creating
    the lambda to the JVM with a single opcode: `invokedynamic`.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Lambda版本不需要创建必须放在堆栈上的实例。相反，它将整个创建Lambda的任务委托给JVM，使用单个操作码：`invokedynamic`。
- en: Another big difference between lambdas and anonymous inner classes is their
    respective scope. An inner class creates its own scope, hiding its local variables
    from the enclosing one. That’s why the keyword `this` references the instance
    of the inner class itself, not the surrounding scope. Lambdas, on the other hand,
    live fully in their surrounding scope. Variables can’t be re-declared with the
    same name, and `this` refers to the instance the lambda was created in, if not
    `static`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda和匿名内部类之间的另一个重大区别是它们各自的作用域。内部类创建了自己的作用域，隐藏了其局部变量，不让外部作用域看到。这就是为什么关键字`this`引用的是内部类实例本身，而不是外部作用域的原因。另一方面，Lambda完全存在于其外部作用域中。变量不能以相同的名称重新声明，而且`this`引用的是创建Lambda的实例，如果不是`static`的话。
- en: As you can see, lambda expressions are *not* syntactic sugar at all.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，Lambda表达式根本不是语法糖。
- en: Lambdas In Action
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda实战
- en: As you saw in the previous section, lambdas are an extraordinary addition to
    Java to improve its functional programming abilities that’s much more than just
    syntactic sugar for previously available approaches. Their first-class citizenship
    allows them to be statically typed, concise, and anonymous functions that are
    just like any other variable. Although the arrow syntax might be new, the overall
    use pattern should feel familiar to any programmer. In this section, we’ll jump
    right into actually using lambdas and seeing them in action.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前一节中看到的那样，lambda是Java中非凡的添加，以提高其函数式编程能力，远不止是先前可用方法的语法糖。它们作为一等公民的地位使它们可以被静态类型化，简洁且匿名，就像任何其他变量一样。虽然箭头语法可能是新的，但总体使用模式应该对任何程序员来说都是熟悉的。在本节中，我们将直接进入使用lambda并看到它们的实际应用。
- en: Creating Lambdas
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建Lambda表达式
- en: To create a lambda expression, it needs to represent a singular functional interface.
    The actual type might not be evident because a receiving method argument dictates
    the required type, or the compiler will infer it if possible.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建lambda表达式，它需要表示一个单一的函数接口。实际类型可能并不明显，因为接收方法参数决定所需的类型，或者如果可能的话，编译器将会推断它。
- en: Let’s take a look at `Predicate<T>` again to better illustrate that point.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看看`Predicate<T>`，以更好地说明这一点。
- en: 'Creating a new instance requires the type to be defined on the left-hand side:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新实例需要在左侧定义类型：
- en: '[PRE9]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Even if you use explicit types for the arguments, the functional interface
    type is still required:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您为参数使用显式类型，函数接口类型仍然是必需的：
- en: '[PRE10]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The method signature of `Predicate<String>` SAM might be inferable:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`Predicate<String>`的SAM方法签名可能是可推断的：'
- en: '[PRE11]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Still, the Java compiler requires a concrete type for the reference, not just
    a method signature. This requirement stems from Java’s propensity for backward
    compatibility, as I previously mentioned. By using the pre-existing statically-typed
    system, lambdas fit perfectly into Java, granting lambdas the same compile-time
    safety as any other type or approach before them.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，Java编译器要求引用的具体类型，而不仅仅是方法签名。这一要求源自Java对向后兼容性的倾向，正如我之前提到的那样。通过使用现有的静态类型系统，lambda可以完美地适应Java，赋予它们与任何其他类型或方法相同的编译时安全性。
- en: However, obeying the type system makes Java lambdas less dynamic than their
    counterparts in other languages. Just because two lambdas share the same SAM signature
    doesn’t mean they are interchangeable.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，遵循类型系统使得Java的lambda比其他语言中的lambda更少动态。仅仅因为两个lambda共享相同的SAM签名并不意味着它们可以互换使用。
- en: 'Take the following functional interface for example:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以以下函数接口为例：
- en: '[PRE12]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Even though it’s SAM is identical to `Predicate<T>`, the types can’t be used
    interchangeably, as shown in the following code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 即使它的SAM与`Predicate<T>`相同，这些类型也不能互换使用，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[![1](assets/1.png)](#co_functional_java_CO7-1)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_functional_java_CO7-1)'
- en: The lambda is created as before.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式与以往创建的方式一样。
- en: '[![2](assets/2.png)](#co_functional_java_CO7-2)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_functional_java_CO7-2)'
- en: Trying to assign it to a functional interface with an identical SAM won’t compile.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将其分配给具有相同SAM的函数接口不会编译。
- en: Due to this incompatibility, you should try to rely on the available interfaces
    in the `java.util.function` package that will be discussed in [Chapter 3](ch03.xhtml#_01-functional-jdk)
    to maximize interoperability. You’re still going to encounter pre-Java 8 interfaces
    like `java.util.concurrent.Callable<V>` that are identical to a Java 8+ one, in
    this case, `java.util.function.Supplier<T>`, though. If that happens, there’s
    a neat shortcut for switching a lambda to another identical type. You’ll learn
    about this in [“Bridging Functional Interfaces”](ch03.xhtml#_01-functional-jdk_bridging-functional-interfaces).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种不兼容性，您应该尽量依赖于`java.util.function`包中的可用接口，这将在[第3章](ch03.xhtml#_01-functional-jdk)中讨论以最大化互操作性。您仍然会遇到类似于`java.util.concurrent.Callable<V>`的Java
    8+之前的接口，与此情况相同，`java.util.function.Supplier<T>`。如果发生这种情况，有一个很好的快捷方式可以将lambda切换到另一个相同类型。您将在[“桥接功能接口”](ch03.xhtml#_01-functional-jdk_bridging-functional-interfaces)中了解到这一点。
- en: 'Ad-hoc created lambdas as method arguments and return types don’t suffer from
    any type incompatibility, as demonstrated by the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 作为方法参数和返回类型的临时创建的lambda不会受到任何类型不兼容性的影响，如下所示的演示：
- en: '[PRE14]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The compiler infers the type of ad-hoc lambdas directly from the method signature,
    so you can concentrate on *what* you want to achieve with the lambda. The same
    is true for return types:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器直接从方法签名推断出临时lambda的类型，因此您可以集中精力于*想要*使用lambda实现的内容。返回类型也是如此：
- en: '[PRE15]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now that you know how to create lambdas, you then need to call them.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何创建lambda表达式了，接下来需要调用它们。
- en: Calling Lambdas
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用Lambda
- en: As discussed, lambdas are effectively concrete implementations of their respective
    functional interfaces. Other, more functionally inclined languages are usually
    treating lambdas more dynamically. That’s why Java’s usage patterns can differ
    from such languages.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 正如讨论的那样，lambda表达式实际上是其相应功能接口的具体实现。其他更具功能性倾向的语言通常将lambda视为更动态的。这就是为什么Java的使用模式可能与这些语言不同的原因。
- en: 'In JavaScript, for example, you can call a lambda and pass an argument directly,
    as shown in the following code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在JavaScript中，您可以直接调用lambda并传递参数，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In Java, however, lambdas behave like any other instances of an interface,
    so you need to explicitly call its SAM, as demonstrated as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在Java中，lambda表现得像接口的任何其他实例一样，因此需要显式调用其SAM，如以下示例所示：
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Calling the *single abstract method* might not be as concise as in other languages,
    but the benefit is Java’s continued backward compatibility.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 调用*单一抽象方法*可能不像其他语言那样简洁，但好处是Java保持了向后兼容性。
- en: Method References
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法引用
- en: 'Besides lambdas, Java 8 introduced another new feature with a language syntax
    change as a new way to create lambda expressions: *method references*. It’s shorthand
    syntactic sugar, using the new `::` (double-colon) operator to reference an existing
    method in place of creating a lambda expression from an existing method, and therefore
    streamlining your functional code.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 除了lambda表达式，Java 8还引入了另一种新特性，语言语法发生变化，作为创建lambda表达式的一种新方式：*方法引用*。这是一种简写的语法糖，使用新的`::`（双冒号）运算符来引用现有方法，而不是从现有方法创建lambda表达式，从而简化您的函数式代码。
- en: '[Example 2-8](#_01-functions-method-references_stream) shows how a Stream pipeline’s
    readability is improved by converting the lambdas to method references. Don’t
    worry about the details! You will learn about Streams in [Chapter 6](ch06.xhtml#_02-data-processing),
    just think of it as a fluent call with lambda accepting methods.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 2-8](#_01-functions-method-references_stream) 展示了如何通过将lambda表达式转换为方法引用来改善流式处理管道的可读性。不要担心细节！你将在[第六章](ch06.xhtml#_02-data-processing)中学习有关流的知识，只需将其视为接受lambda的方法的流畅调用。'
- en: Example 2-8\. Method references and Streams
  id: totrans-156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-8\. 方法引用和流
- en: '[PRE18]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Replacing lambdas with method references removes a lot of *noise* without compromising
    the readability or understandability of your code too much. There is no need for
    the input arguments to have actual names or types, or to call the reference method
    explicitly. Also, modern IDEs usually provide you with automatic refactoring to
    convert lambdas to method references, if applicable.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 用方法引用替换lambda表达式可以消除很多*噪音*，而不会过多地影响代码的可读性或可理解性。输入参数不需要具有实际名称或类型，也不需要显式调用引用方法。此外，现代IDE通常会提供自动重构功能，将lambda表达式转换为方法引用（如果适用）。
- en: 'There are four types of method references you can use, depending on the lambda
    expression you want to replace and what kind of method you need to reference:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用四种类型的方法引用，具体取决于您想要替换的lambda表达式及需要引用的方法类型：
- en: Static method references
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态方法引用
- en: Bound non-`static` method references
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已绑定的非`static`方法引用
- en: Unbound non-`static` method references
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未绑定的非`static`方法引用
- en: Constructor references
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数引用
- en: Let’s take a look at the different kinds and how and when to use them.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看各种方法引用及其如何以及何时使用它们。
- en: Static Method References
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态方法引用
- en: 'A *static method reference* refers to a `static` method of a specific type,
    like the `toHexString` method available on `Integer`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*静态方法引用*指的是特定类型的`static`方法，例如`Integer`上可用的`toHexString`方法：'
- en: '[PRE19]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The general syntax for static method references is `ClassName::staticMethodName`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法引用的一般语法是`ClassName::staticMethodName`。
- en: Bound non-static Method References
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 已绑定的非静态方法引用
- en: 'If you want to refer to a non-`static` method of an already existing object,
    you need a *bound non-static method reference*. The lambda arguments are passed
    as the method arguments to the reference method of that specific object:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要引用已存在对象的非`static`方法，则需要*已绑定的非静态方法引用*。lambda参数作为特定对象的引用方法的方法参数传递：
- en: '[PRE20]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You don’t even need an intermediate variable; you can combine the return value
    of another method call or field access directly with `::` operator:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至不需要中间变量；您可以直接使用`::`运算符将另一个方法调用或字段访问的返回值与返回值组合：
- en: '[PRE21]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You can also reference methods from the current instance with `this::` or the
    `super` implementation with `super::`, as shown as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过`this::`引用当前实例的方法，或者通过`super::`引用`super`实现，如下所示：
- en: '[PRE22]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Bound method references are a great way to use already existing methods on variables,
    the current instance, or `super`. It also allows you to refactor non-trivial or
    more complex lambdas to methods and use method references instead. Especially
    fluent pipelines, like Streams in [Chapter 6](ch06.xhtml#_02-data-processing)
    or Optionals in [Chapter 9](ch09.xhtml#_02-optionals), profit immensely from the
    improved readability of short method references.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定方法引用是在变量、当前实例或`super`上使用已经存在的方法的好方法。它还允许您将非平凡或更复杂的lambda重构为方法，并改用方法引用。特别是像[第
    6 章](ch06.xhtml#_02-data-processing)中的流或[第 9 章](ch09.xhtml#_02-optionals)中的Optional这样的流畅管道，因其短方法引用的改进可读性而受益匪浅。
- en: The general syntax for bound non-static method references is `objectName::instanceMethodName`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定非静态方法引用的一般语法为`objectName::instanceMethodName`。
- en: Unbound non-static Method References
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 未绑定非静态方法引用
- en: '*Unbound non-static method references* are, as their name suggests, not bound
    to a specific object. Instead, they refer to an instance method of a type:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*未绑定的非静态方法引用*正如其名称所示，不绑定到特定对象。而是指向类型的实例方法：'
- en: '[PRE23]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The general syntax for unbound non-static method references is `ClassName::instanceMethodName`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 未绑定非静态方法引用的一般语法为`ClassName::instanceMethodName`。
- en: This type of method reference can be confused with a *static method reference*.
    For *Unbound non-static method references*, however, the `ClassName` signifies
    the instance type in which the referenced instance method is defined. It’s also
    the first argument of the lambda expression. This way, the reference method is
    called on the incoming instance and not on an explicitly referenced instance of
    that type.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的方法引用可能会与*静态方法引用*混淆。但对于*未绑定的非静态方法引用*，`ClassName`表示引用实例方法所在的实例类型。它也是lambda表达式的第一个参数。因此，引用方法是在传入实例上调用，而不是显式引用该类型的实例。
- en: Constructor References
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构造方法引用
- en: 'The last type of method reference refers to a type’s constructor. A constructor
    method reference looks like the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 方法引用的最后一种类型是类型的构造方法。构造方法引用的形式如下：
- en: '[PRE24]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: At first glance, constructor method references look like static or unbound non-static
    method references. The referenced method isn’t an actual method but a reference
    to a constructor via the `new` keyword.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，构造方法引用看起来像静态方法或未绑定的非静态方法引用。所引用的方法并非实际方法，而是通过`new`关键字引用的构造方法。
- en: The general syntax for constructor method references is `ClassName::new`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 构造方法引用的一般语法为`ClassName::new`。
- en: Functional Programming Concepts in Java
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 中的函数式编程概念
- en: '[Chapter 1](ch01.xhtml#_01-an-introduction) tackled the core concepts that
    make a programming language functional from a mostly theoretical viewpoint. So
    let’s take another look at them from a Java developer’s point of view.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 1 章](ch01.xhtml#_01-an-introduction)从大多数理论角度讨论了使编程语言从功能上变得功能强大的核心概念。因此，让我们从Java开发者的角度再次审视它们。'
- en: Pure Functions and Referential Transparency
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纯函数和引用透明性
- en: 'The concept of pure functions is based on two guarantees that aren’t necessarily
    bound to functional programming:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数的概念基于两个不一定与函数式编程绑定的保证：
- en: Function logic is self-contained without any kind of side effect.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数逻辑是自包含的，没有任何副作用。
- en: The *same* input will *always* create the same output. Therefore, repeated calls
    can be replaced by the initial result, making the call referentially transparent.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*相同*的输入将*始终*产生相同的输出。因此，可以用初始结果替换重复调用，使调用具有引用透明性。'
- en: These two principles make sense even in your imperative code. Making your code
    self-contained makes it predictable and more straightforward. From a Java perspective,
    how can you achieve these beneficial properties?
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个原则即使在命令式代码中也是有意义的。使您的代码自包含使其可预测且更简单。从Java的角度来看，您如何实现这些有益的属性？
- en: First, check for uncertainty. Is there non-predictive logic that doesn’t depend
    on the input arguments? Prime examples are random number generators or the current
    date. Using such data in a function removes a function’s predictability, making
    it *impure*.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，检查不确定性。有没有不依赖于输入参数的非预测逻辑？主要示例是随机数生成器或当前日期。在函数中使用这些数据会降低函数的可预测性，使其*不纯洁*。
- en: Next, look for side effects and mutable state.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，查找副作用和可变状态。
- en: Does your function affect any state outside of the function itself, like an
    instance or global variable?
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的函数是否影响函数本身之外的任何状态，比如实例或全局变量？
- en: Does it change the inner data of its arguments, like adding new elements to
    a collection or changing an object property?
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是否更改其参数的内部数据，比如向集合中添加新元素或更改对象属性？
- en: Does it do any other *impure* work, like I/O?
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否还有其他*不纯洁*的工作，比如 I/O？
- en: 'However, side effects aren’t restricted to mutable state. A simple `System.out.println(…​)`
    call is a side-effect, even if it might look harmless. Any kind of I/O, like accessing
    the file system, making network requests, or printing to `System.out` is a side-effect.
    The reasoning is simple: repeated calls with the same arguments can’t be replaced
    with the result of the first evaluation. A good indicator for an *impure* method
    is a `void` return type. If a method doesn’t return anything, all it does are
    side effects, or it does nothing at all.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，副作用并不局限于可变状态。一个简单的`System.out.println(…​)`调用是一个副作用，即使它看起来可能是无害的。任何类型的 I/O，比如访问文件系统，进行网络请求或打印到`System.out`都是副作用。推理很简单：具有相同参数的重复调用不能用第一次评估的结果替换。*不纯洁*方法的一个很好的指标是`void`返回类型。如果一个方法不返回任何内容，它所做的就是副作用，或者根本什么都不做。
- en: Pure functions are inherently *referentially transparent*. Hence, you can replace
    any subsequent calls with the same arguments with the previously calculated result.
    This interchangeability allows for an optimization technique called *memoization*.
    Originating from the Latin word “memorandum" — *to be remembered* --⁠, this technique
    describes “remembering” previously evaluated expressions. It trades memory *space*
    for saving computational *time*.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数本质上是*引用透明*的。因此，您可以用先前计算的结果替换任何具有相同参数的后续调用。这种可互换性允许一种称为*记忆化*的优化技术。这种技术源自拉丁词“memorandum”——*被记住*——描述了“记住”以前评估的表达式。它交换内存*空间*以节省计算*时间*。
- en: You’re most likely already using the general idea behind referential transparency
    in your code in the form of *caching*. From dedicated cache libraries, like Ehcache^([6](ch02.xhtml#idm45115250887264))
    to simple `HashMap`-based lookup tables, it’s all about “remembering” a value
    against a set of input arguments.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 您很可能已经在代码中使用引用透明性的一般思想，以*缓存*的形式。从专用缓存库，如 Ehcache^([6](ch02.xhtml#idm45115250887264))
    到简单的基于`HashMap`的查找表，都是关于针对一组输入参数“记住”值的。
- en: The Java compiler doesn’t support automatic memoization of lambda expressions
    or methods calls. Some frameworks provide annotations, like `@Cacheable` in Spring^([7](ch02.xhtml#idm45115250884688))
    or `@Cached` in Apache Tapestry^([8](ch02.xhtml#idm45115250882416)), and generate
    the required code automatically behind the scenes.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Java 编译器不支持 lambda 表达式或方法调用的自动记忆化。一些框架提供了注释，如 Spring 中的`@Cacheable`^([7](ch02.xhtml#idm45115250884688))
    或 Apache Tapestry 中的`@Cached`^([8](ch02.xhtml#idm45115250882416))，并在幕后自动生成所需的代码。
- en: Creating your own lambda expression caching isn’t too hard either, thanks to
    some of the newer additions to Java 8+. So let’s do that right now.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Java 8+ 的一些新添加，创建自己的 lambda 表达式缓存也不是太难。所以现在就让我们来做。
- en: 'Building your own *memoization* by creating an “on-demand” lookup table requires
    the answer to two questions:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建一个“按需”查找表来构建自己的*记忆化*需要回答两个问题：
- en: How do you identify the function and its input arguments uniquely?
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何唯一标识函数及其输入参数？
- en: How can you store the evaluated result?
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您如何存储评估的结果？
- en: If your function or method call has only a single argument with a constant `hashCode`
    or other deterministic value, you can create a simple `Map`-based lookup table.
    For multi-argument calls, you must first define how to create a lookup key.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的函数或方法调用只有一个带有常量`hashCode`或其他确定性值的参数，则可以创建一个简单的基于`Map`的查找表。对于多参数调用，必须首先定义如何创建查找键。
- en: Java 8 introduced multiple functional additions to the `Map<K, V>` type. One
    of these additions, the `computeIfAbsent` method, is a great aid to easily implement
    memoization, as shown in [Example 2-9](#_01-functions_memoization_computeIfAbsent).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8为`Map<K, V>`类型引入了多个功能增强。其中一个增强功能，`computeIfAbsent`方法，是实现记忆化的良好辅助工具，正如[示例2-9](#_01-functions_memoization_computeIfAbsent)中所示。
- en: Example 2-9\. Memoization with `Map#computeIfAbsent`
  id: totrans-210
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-9\. 使用`Map#computeIfAbsent`进行记忆化。
- en: '[PRE25]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[![1](assets/1.png)](#co_functional_java_CO8-2)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_functional_java_CO8-2)'
- en: The results are cached in a simple `HashMap<String, Object>` so it can cache
    any kind of call based on an identifier. Depending on your requirements, there
    might be special considerations, like caching results per request in a web application
    or requiring a “time-to-live” concept. This example is supposed to show the simplest
    form of a lookup table.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 结果被缓存在简单的`HashMap<String, Object>`中，因此可以缓存基于标识符的任何调用结果。根据您的需求，可能需要特别考虑，例如在Web应用程序中根据请求缓存结果或需要“存活时间”概念。此示例旨在展示查找表的最简单形式。
- en: '[![2](assets/2.png)](#co_functional_java_CO8-1)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_functional_java_CO8-1)'
- en: The `memoize` method accepts an identifier and a `Supplier<T>` in case the cache
    doesn’t have a result yet.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`memoize`方法接受一个标识符和一个`Supplier<T>`，以防缓存中尚未有结果。'
- en: '[![3](assets/3.png)](#co_functional_java_CO8-4)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_functional_java_CO8-4)'
- en: The `expensiveCall` is the method that gets memoized.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`expensiveCall`是被记忆化的方法。'
- en: '[![4](assets/4.png)](#co_functional_java_CO8-5)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_functional_java_CO8-5)'
- en: For convenience, a specialized memoized call method exists, so you don’t have
    to build an identifier manually each time you call `memoize`. It has the same
    arguments as the calculation method and delegates the actual memoization process.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 为方便起见，存在一个专门的记忆化调用方法，因此每次调用`memoize`时都无需手动构建标识符。它与计算方法具有相同的参数，并委托实际的记忆化过程。
- en: '[![5](assets/5.png)](#co_functional_java_CO8-6)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_functional_java_CO8-6)'
- en: The convenience method allows you to replace the method name of the call to
    use the memoized version instead of the original one.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 方便方法允许您替换调用的方法名，以使用记忆化版本而不是原始版本。
- en: '[![6](assets/6.png)](#co_functional_java_CO8-7)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_functional_java_CO8-7)'
- en: The second call returns the cached result immediately without any additional
    evaluation.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次调用将立即返回缓存的结果，无需进行任何额外的评估。
- en: This implementation is quite simplistic and is not a one-size-fits-all solution.
    Still, it confers the general concept of storing a call result via an intermediate
    method doing the actual memoization.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现相当简单，并非一刀切的解决方案。然而，它确实传达了通过一个实际的记忆化方法存储调用结果的一般概念。
- en: The functional additions to `Map<K, V>` don’t stop there. It provides the tools
    to create associations “on the fly,” and more tools giving you more fine-grained
    control if a value is already present or not. You will learn more about it in
    [Chapter 11](ch11.xhtml#_02-lazy-evaluation).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map<K, V>`的功能增强并不止于此。它提供了创建“即时”关联的工具，并提供更多细粒度控制的工具，用于判断值是否已经存在。你将在[第11章](ch11.xhtml#_02-lazy-evaluation)中了解更多相关内容。'
- en: Immutability
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不可变性
- en: The classical approach to Java with OOP is based on mutable program state, most
    prominently represented by JavaBeans and POJOs. There’s no clear definition of
    how program state should be handled in OOP, and immutability is no pre-requisite
    or unique feature of FP. Still, mutable state is a thorn in the side of many functional
    programming concepts because they expect *immutable* data structures to ensure
    data integrity and safe overall use.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程的经典Java方法中，基于可变程序状态，最显著的代表是JavaBeans和POJOs。关于如何处理程序状态在OOP中没有明确的定义，且不可变性不是FP的先决条件或唯一特性。尽管如此，可变状态仍然是许多函数编程概念的眼中钉，因为它们期望使用*不可变*数据结构来确保数据完整性和安全的整体使用。
- en: Note
  id: totrans-228
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: POJOs are “plain old Java Objects” that aren’t bound by special restrictions,
    other than those imposed by the Java language. JavaBeans are a special type of
    POJOs. You will learn more about them in [“Mutability and Data Structures in OOP”](ch04.xhtml#_02-data-sructures_mutability).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: POJO（“plain old Java Objects”）不受特殊限制约束，只受Java语言的限制。JavaBeans是POJO的一种特殊类型。你将在[“面向对象编程中的可变性和数据结构”](ch04.xhtml#_02-data-sructures_mutability)中了解更多信息。
- en: Java’s support for immutability is quite limited compared to other languages.
    That’s why it has to enforce constructs like *effectively* `final` as discussed
    in [“Lambdas and Outside Variables”](#_01-introduction_pure-lambas-effectively-final).
    To support “full” immutability, you need to design your data structures from the
    ground up as immutable, which can be cumbersome and error-prone. Third-party libraries
    are an often chosen approach to minimize the required boilerplate code and rely
    on battle-tested implementations. Finally, with Java 14+, immutable data classes — *Records* — were
    introduced to bridge the gap, which I will discuss in [Chapter 5](ch05.xhtml#_02-records).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Java 对不可变性的支持与其他语言相比相当有限。这就是为什么它必须强制执行类似于 *effective final* 的构造，如在 [“Lambdas
    and Outside Variables”](#_01-introduction_pure-lambas-effectively-final) 中讨论的那样。为了支持“完全”不可变性，您需要从头开始设计您的数据结构为不可变，这可能会很麻烦且容易出错。第三方库通常是一种选择，可以最小化所需的样板代码并依赖经过测试的实现。最后，随着
    Java 14+，引入了不可变数据类——*Records*——来弥合这一差距，我将在 [第五章](ch05.xhtml#_02-records) 中讨论。
- en: Immutability is a complex subject that you’ll learn more about and its importance
    and how to utilize it properly — either with built-in tools or with a do-it-yourself
    approach — in [Chapter 4](ch04.xhtml#_02-data-structures).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变性是一个复杂的主题，您将在 [第四章](ch04.xhtml#_02-data-structures) 中了解更多关于其重要性以及如何适当地利用它 — 无论是使用内置工具还是自己动手 — 。
- en: First-Class and Higher-Order
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一等与高阶
- en: With Java *lambas* being concrete implementations of functional interfaces,
    they gain *first-class* citizenship and are usable as variables, arguments, and
    return values, as seen in [Example 2-10](#_01-functions_first-class).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Java *lambas* 是功能接口的具体实现，它们获得了 *一等* 公民身份，并且可用作变量、参数和返回值，如在 [示例 2-10](#_01-functions_first-class)
    中所见。
- en: Example 2-10\. First-class Java Lambdas
  id: totrans-234
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-10\. 一等 Java Lambdas
- en: '[PRE26]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[![1](assets/1.png)](#co_functional_java_CO9-1)'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_functional_java_CO9-1)'
- en: Assigning a Java lambda to the variable `quadraticFn`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Java lambda 分配给变量 `quadraticFn`。
- en: '[![2](assets/2.png)](#co_functional_java_CO9-2)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_functional_java_CO9-2)'
- en: It can be used like any other “normal” Java variable, calling the `apply` method
    of its interface.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以像任何其他“正常”的 Java 变量一样使用，调用其接口的 `apply` 方法。
- en: '[![3](assets/3.png)](#co_functional_java_CO9-3)'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_functional_java_CO9-3)'
- en: Lambdas are usable like any other type for arguments.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Lambdas 可以像任何其他类型一样用于参数。
- en: '[![4](assets/4.png)](#co_functional_java_CO9-4)'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_functional_java_CO9-4)'
- en: Returning a lambda is like returning any other Java variable.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 lambda 就像返回任何其他 Java 变量一样。
- en: Accepting lambdas as arguments and returning lambdas is essential for the next
    concept, *functional composition*.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 接受 lambda 作为参数并返回 lambda 对于下一个概念——*函数组合*——至关重要。
- en: Functional Composition
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数组合
- en: The idea of creating complex systems by composing smaller components is a cornerstone
    of programming, regardless of the chosen paradigm to follow. In OOP, objects can
    be composed of smaller ones, building a more complex API. In FP, two functions
    are combined to build a new function, which then can be combined further.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 通过组合更小的组件创建复杂系统的想法是编程的基石，无论选择哪种范式来跟随。在面向对象编程中，对象可以由较小的对象组合而成，构建更复杂的 API。在函数编程中，两个函数被组合以构建一个新函数，然后可以进一步组合。
- en: Functional composition is arguably one of the essential aspects of a functional
    programming mindset. It allows you to build complex systems by composing smaller,
    reusable functions into a larger chain, fulfilling a more complex task, as illustrated
    in [Figure 2-1](#_01-functional-java_functional-composition).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 函数组合可以说是功能编程思维中的一个重要方面。它允许你通过将更小、可重用的函数组合成一个更大的链条来构建复杂系统，从而完成更复杂的任务，如在 [图 2-1](#_01-functional-java_functional-composition)
    中所示。
- en: '![Composing complex tasks from multiple functions](assets/afaj_0201.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![从多个函数组合复杂任务](assets/afaj_0201.png)'
- en: Figure 2-1\. Composing complex tasks from multiple functions
  id: totrans-249
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-1\. 从多个函数组合复杂任务
- en: Java’s functional composition capabilities depend highly on the involved concrete
    types. In [“Functional Composition”](ch03.xhtml#_01-functional-jdk_functional-composition),
    I will discuss how to combine the different functional interfaces provided by
    the JDK.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Java 的函数组合能力高度依赖于涉及的具体类型。在 [“函数组合”](ch03.xhtml#_01-functional-jdk_functional-composition)
    中，我将讨论如何结合 JDK 提供的不同函数接口。
- en: Lazy Evaluation
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 惰性求值
- en: 'Even though Java, at least in principle, is a non-lazy — *strict* or *eager* — language,
    it supports multiple lazy constructs:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 即使 Java 在原则上是一种非惰性——*严格* 或 *急切*——语言，它支持多个惰性结构：
- en: Logical short-circuit operators
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑短路运算符
- en: '`if`-`else` and the `:?` (ternary) operator'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if`-`else` 和 `:?`（三元）操作符'
- en: '`for` and `while` loops'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for` 和 `while` 循环'
- en: 'Logical short-circuit operators are a simple example of laziness:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑短路运算符是懒惰的一个简单示例：
- en: '[PRE27]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The evaluation `complex()` depends on the outcome of `simple()` and the logical
    operator used in the overall expression. That’s why the JVM can discard expressions
    that don’t need evaluation, as will be explained in more detail in [Chapter 11](ch11.xhtml#_02-lazy-evaluation).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 评估`complex()`取决于`simple()`的结果和整体表达式中使用的逻辑运算符。这就是为什么JVM可以丢弃不需要评估的表达式的原因，详细内容将在[第11章](ch11.xhtml#_02-lazy-evaluation)中详细解释。
- en: Takeaways
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要点
- en: Functional interfaces are concrete types and representations of Java lambdas.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数接口是Java lambda的具体类型和表示。
- en: Java’s lambda syntax is close to the underlying mathematical notation of lambda
    calculus.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java的lambda语法接近底层的lambda演算数学符号。
- en: Lambdas can be expressed with multiple levels of verbosity, depending on the
    surrounding context and your requirements. Shorter isn’t always as expressive
    as it should be, especially if others are reading your code.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据周围上下文和您的需求，lambda可以以多个级别的冗长表达。较短的表达式并不总是像应该的那样具有表达力，特别是其他人正在阅读您的代码时。
- en: Lamba expressions are not *syntactic sugar* thanks to the JVM using the opcode
    `invokedynamic`. This allows for multiple optimization techniques to get better
    performance as alternatives like anonymous classes.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于JVM使用操作码`invokedynamic`，lambda表达式并非*语法糖*。这允许多种优化技术以获得更好的性能，作为匿名类的替代品。
- en: Outside variables need to be *effectively* `final` to be used in lambdas, but
    this makes only the references immutable, not the underlying data structure.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部变量需要*有效*地`final`才能在lambda中使用，但这仅使引用不可变，而不是底层数据结构。
- en: Method references are a concise alternative for matching method signatures and
    lambda definitions. They even provide a simple way to use “identical but incompatible”
    functional interface types.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法引用是匹配方法签名和lambda定义的简洁替代方式。它们甚至提供了一种简单的方法来使用“相同但不兼容”的函数接口类型。
- en: '^([1](ch02.xhtml#idm45115256766512-marker)) The simplified version of `java.util.function.Predicate`
    is based on the source code for the latest Git tag of the LTS version at the time
    of writing: 17+35\. You can check out the [official source code repository](https://github.com/openjdk/jdk/blob/dfacda488bfbe2e11e8d607a6d08527710286982/src/java.base/share/classes/java/util/function/Predicate.java)
    to see the original file.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch02.xhtml#idm45115256766512-marker)) 简化版的`java.util.function.Predicate`基于撰写时最新Git标签的LTS版本的源代码：17+35\.
    您可以查看[官方源代码库](https://github.com/openjdk/jdk/blob/dfacda488bfbe2e11e8d607a6d08527710286982/src/java.base/share/classes/java/util/function/Predicate.java)查看原始文件。
- en: ^([2](ch02.xhtml#idm45115252733520-marker)) The [official documentation](https://docs.oracle.com/en/java/javase/17/docs/api/jdk.jshell/jdk/jshell/JShell.xhtml#eval(java.lang.String))
    sheds some light on the special semantics and requirements for top-level expressions
    and declarations.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch02.xhtml#idm45115252733520-marker)) [官方文档](https://docs.oracle.com/en/java/javase/17/docs/api/jdk.jshell/jdk/jshell/JShell.xhtml#eval(java.lang.String))为顶层表达式和声明的特殊语义和要求提供了一些指导。
- en: ^([3](ch02.xhtml#idm45115252515552-marker)) Landin, Peter J. (1964). “The mechanical
    evaluation of expressions.” [The Computer Journal. Computer Journal. 6 (4)](https://doi.org/10.1093/comjnl/6.4.308).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch02.xhtml#idm45115252515552-marker)) Landin, Peter J. (1964). “表达式的机械评估。”[《计算机杂志》。计算机杂志。6
    (4)](https://doi.org/10.1093/comjnl/6.4.308)。
- en: ^([4](ch02.xhtml#idm45115252465520-marker)) The Java Magazine has [an article](https://blogs.oracle.com/javamagazine/post/understanding-java-method-invocation-with-invokedynamic)
    by Java Champion Ben Evans that explains method invocation with `invokedynamic`
    in more detail.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch02.xhtml#idm45115252465520-marker)) Java Magazine有Java冠军本·埃文斯的[一篇文章](https://blogs.oracle.com/javamagazine/post/understanding-java-method-invocation-with-invokedynamic)，详细解释了`invokedynamic`方法调用。
- en: ^([5](ch02.xhtml#idm45115252462144-marker)) The class [`java.lang.invoke.LambdaMetaFactory`](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/invoke/LambdaMetafactory.xhtml)
    is responsible for creating “bootstrap methods.”
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch02.xhtml#idm45115252462144-marker)) 类[`java.lang.invoke.LambdaMetaFactory`](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/invoke/LambdaMetafactory.xhtml)负责创建“引导方法”。
- en: ^([6](ch02.xhtml#idm45115250887264-marker)) [Ehcache](https://www.ehcache.org/)
    is a widely-used Java cache library.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch02.xhtml#idm45115250887264-marker)) [Ehcache](https://www.ehcache.org/)是广泛使用的Java缓存库。
- en: ^([7](ch02.xhtml#idm45115250884688-marker)) The official documentation of [like
    `@Cacheable`](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/cache/annotation/Cacheable.xhtml)
    explains the inner workings including key mechanics.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch02.xhtml#idm45115250884688-marker)) [像 `@Cacheable` 这样的官方文档](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/cache/annotation/Cacheable.xhtml)
    解释了其内部工作原理，包括键的机制。
- en: ^([8](ch02.xhtml#idm45115250882416-marker)) The [Tapestry annotation](https://tapestry.apache.org/5.8.2/apidocs/org/apache/tapestry5/annotations/Cached.xhtml)
    doesn’t support key-based caching, but can be bound to a field instead.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](ch02.xhtml#idm45115250882416-marker)) [Tapestry 注解](https://tapestry.apache.org/5.8.2/apidocs/org/apache/tapestry5/annotations/Cached.xhtml)
    不支持基于键的缓存，但可以绑定到一个字段上。
