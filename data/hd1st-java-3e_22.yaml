- en: Appendix B. The top ten-ish topics that didn’t make it into the rest of the
    book...
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录 B. 没有包含在本书其余部分中的前十个主题……
- en: '![image](Images/f0683-01.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0683-01.png)'
- en: We covered a lot of ground, and you’re almost finished with this book. We’ll
    miss you, but before we let you go, we wouldn’t feel right about sending you out
    into JavaLand without a little more preparation. We can’t possibly fit everything
    you’ll need to know into this relatively small appendix. Actually, we *did* originally
    include everything you need to know about Java (not already covered by the other
    chapters), by reducing the type point size to .00003\. It all fit, but nobody
    could read it. So, we threw most of it away, but kept the best bits for this Top
    Ten-ish appendix. Yep, there’s more than ten Really Useful Things that you still
    need to know.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们涵盖了很多内容，你几乎完成了这本书的阅读。我们会想念你，但在让你进入 Java 世界之前，我们感觉不合适没有为你做更多准备。我们不可能将你需要知道的所有内容都放入这个相对较小的附录中。事实上，我们*确实*曾经包括了关于
    Java 的所有内容（其他章节未涵盖的部分），将字体大小缩小到 .00003，一切都合适，但没人能读懂它。所以，我们把大部分内容扔掉了，但保留了这个前十个主题附录中的最佳部分。是的，有超过十个真正有用的事情你仍然需要知道。
- en: This really *is* the end of the book. Except for the index (a must-read!).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这*真的是*本书的结尾。除了索引（必读！）。
- en: '#11 JShell (Java REPL)'
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#11 JShell（Java REPL）'
- en: '**Java 9+**'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java 9+**'
- en: Why do you care?
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你为什么在意？
- en: A REPL (Read Eval Print Loop) lets you run snippets of code without needing
    a full application or framework. It’s a great way to try out new features, experiment
    with new ideas, and get immediate feedback. We’ve put this right at the start
    of this appendix in case you want to use JShell to try out some of the features
    we’ll be talking about in the following pages.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: REPL（读取评估打印循环）允许你运行代码片段，而不需要完整的应用程序或框架。这是尝试新功能、实验新想法并获得即时反馈的好方法。我们将其放在本附录的开头，以便你可以使用
    JShell 尝试一些我们将在接下来的页面中讨论的功能。
- en: Starting the REPL
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动 REPL
- en: JShell is a command-line tool that comes part of the JDK. If JAVA_HOME/bin is
    on your system’s path, you can just type “jshell” from the command line (full
    details on getting started are in Oracle’s Introduction to JShell (*[https://oreil.ly/Ei3Df](https://oreil.ly/Ei3Df)*).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: JShell 是 JDK 的一部分的命令行工具。如果 JAVA_HOME/bin 在系统路径中，你可以直接从命令行输入 “jshell”（有关入门的详细信息，请参阅
    Oracle 的介绍 JShell (*[https://oreil.ly/Ei3Df](https://oreil.ly/Ei3Df)*)）。
- en: '![image](Images/f0684-01.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0684-01.png)'
- en: JShell is available only in **JDK 9 and higher**, but the good news is that
    even if you’re running code and applications on an older version of Java, you
    can still use JShell from a more recent version, since it’s completely independent
    of your “JAVA_HOME” or IDE’s version of Java. Just run it directly from the *bin*
    directory of whichever version of Java you want to use.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: JShell 仅在**JDK 9及更高版本**中可用，但好消息是，即使在旧版 Java 上运行代码和应用程序，你仍然可以从更高版本使用 JShell，因为它完全独立于你的
    “JAVA_HOME” 或 IDE 的 Java 版本。只需直接从你想要使用的任何 Java 版本的 *bin* 目录运行即可。
- en: Run Java code without a class
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行 Java 代码不需要类
- en: 'Try out some Java from the prompt:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在提示符下尝试一些 Java 代码：
- en: '![image](Images/f0684-02.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0684-02.png)'
- en: 'Note:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：
- en: No need for a class
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不需要类
- en: No need for a *public static main* method
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不需要 *public static main* 方法
- en: No need for a semicolon on the end of the line
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行末不需要分号
- en: Just start typing Java!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 直接开始输入 Java 代码！
- en: More than just lines of code
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不仅仅是代码行数
- en: 'You can define variables and methods:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以定义变量和方法：
- en: '![image](Images/f0684-03.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0684-03.png)'
- en: It supports *forward references*, so you can sketch out the shape of your code
    without having to define everything immediately.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 它支持*前向引用*，因此你可以草拟代码的结构，而不必立即定义一切。
- en: '![image](Images/f0684-04.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0684-04.png)'
- en: Code suggestions
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码建议
- en: If you press Tab halfway through typing, you’ll get code suggestions. You can
    also use the up and down arrows to cycle through the lines you’ve typed so far.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在输入时按 Tab 键，将会获得代码建议。你还可以使用上下箭头来循环浏览你到目前为止输入的行。
- en: '![image](Images/f0684-05.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0684-05.png)'
- en: Commands
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命令
- en: There are lots of helpful commands that are part of JShell and not part of Java.
    For example, type **`/vars`** to see all the variables you’ve declared. Type **`/exit`**
    to, er, exit. Use **`/help`** to see a list of commands and to get more information.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: JShell 中有许多有用的命令，这些命令不是 Java 的一部分。例如，输入 **`/vars`** 查看你声明的所有变量。输入 **`/exit`**
    来退出。使用 **`/help`** 查看命令列表和获取更多信息。
- en: Oracle has a very useful JShell User Guide (*[https://oreil.ly/Ei3Df](https://oreil.ly/Ei3Df)*),
    which also shows how to create and run scripts with JShell.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle有一个非常有用的JShell用户指南（*[https://oreil.ly/Ei3Df](https://oreil.ly/Ei3Df)*），还展示了如何使用JShell创建和运行脚本。
- en: '#10 Packages'
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#10 包'
- en: Packages prevent class name conflicts
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包可以防止类名冲突
- en: Although packages aren’t just for preventing name collisions, that’s a key feature.
    If part of the point of OO is to write reusable components, developers need to
    be able to piece together components from a variety of sources and build something
    new out of them. Your components have to be able to “play well with others,” including
    those you didn’t write or even know about.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然包不仅仅是为了防止名称冲突，但这是一个关键特性。如果面向对象的一部分目的是编写可重用的组件，开发人员需要能够从各种来源拼凑组件，并从中构建出新的东西。你的组件必须能够“与他人合作”，包括那些你没写过甚至不知道的组件。
- en: Remember way back in [Chapter 6](ch06.xhtml#using_the_java_library_get_to_know_the_j),
    *Using the Java Library*, when we discussed how a package name is like the full
    name of a class, technically known as the *fully qualified name*. Class List is
    really **`java.util.List`**, a GUI List is really **`java.awt.List`**, and Socket
    is really **`java.net.Socket`**. Hey presto, an example of how package names can
    help prevent name conflicts—there’s a List that’s a data structure and a List
    that’s a GUI element, and we can use the package names to tell them apart.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得很久以前在[第6章](ch06.xhtml#using_the_java_library_get_to_know_the_j)，*使用Java库*，当我们讨论包名如何像类的全名，技术上称为*完全限定名*吗？List实际上是**`java.util.List`**，GUI
    List实际上是**`java.awt.List`**，而Socket实际上是**`java.net.Socket`**。哎哟，一个例子，说明包名如何帮助防止名称冲突——有一个List是数据结构，另一个List是GUI元素，我们可以用包名来区分它们。
- en: Notice that these classes have *java* as their “first name.” In other words,
    the first part of their fully qualified names is “java”; think of a hierarchy
    when you think of package structures, and organize your classes accordingly.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这些类的“名字”都以*java*开头。换句话说，它们的完全限定名的第一部分是“java”；当你考虑包结构时，请考虑一个层次结构，并相应地组织你的类。
- en: '![image](Images/f0685-02.png)![image](Images/f0685-03.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0685-02.png)![image](Images/f0685-03.png)'
- en: '**What does this picture look like to you? Doesn’t it look a whole lot like
    a directory hierarchy?**'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**这张图片对你来说是什么样子？它看起来不就像一个目录层次结构吗？**'
- en: Preventing package name conflicts
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 防止包名称冲突
- en: The standard package naming convention is to prepend every class with your reverse
    domain name. Remember, domain names are guaranteed to be unique. Two different
    guys can be named Bartholomew Simpson, but two different domains cannot be named
    *[doh.com](http://doh.com)*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的包命名约定是用你的反向域名作为每个类的前缀。请记住，域名是唯一的。两个不同的人可以被命名为巴斯洛缪·辛普森，但是两个不同的域名不能被命名为*[doh.com](http://doh.com)*。
- en: '![image](Images/f0685-01.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0685-01.png)'
- en: When you look at the code samples at *[https://oreil.ly/hfJava_3e_examples](https://oreil.ly/hfJava_3e_examples)*,
    you’ll see we’ve put the classes into packages named after each chapter to clearly
    separate the examples.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当你查看*[https://oreil.ly/hfJava_3e_examples](https://oreil.ly/hfJava_3e_examples)*的代码示例时，你会看到我们已经把类分别放在每一章的包中，以明确区分这些例子。
- en: Note
  id: totrans-42
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**Packages can prevent name conflicts, but only if you choose a package name
    that’s guaranteed to be unique. The best way to do that is to preface your packages
    with your reverse domain name.**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**包可以防止名称冲突，但前提是你选择一个保证唯一的包名。最好的方法是用你的反向域名作为包名的前缀。**'
- en: '![image](Images/f0685-04.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0685-04.png)'
- en: 'To put your class in a package:'
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 要把你的类放入一个包中：
- en: '![Images](Images/1.png) **Choose a package name**'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Images](Images/1.png) **选择一个包名**'
- en: We’re using **`com.headfirstjava`** as our example. The class name is PackageExercise,
    so the fully qualified name of the class is now **`com.headfirstjava.PackageExercise`**.
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用**`com.headfirstjava`**作为示例。类名是PackageExercise，所以现在这个类的完全限定名是**`com.headfirstjava.PackageExercise`**。
- en: '![Images](Images/2.png) **Put a package statement in your class**'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Images](Images/2.png) **在你的类中放置一个包语句**'
- en: It must be the first statement in the source code file, above any import statements.
    There can be only one package statement per source code file, so **`all classes
    in a source file must be in the same package`**. That includes inner classes,
    of course.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这必须是源代码文件中的第一条语句，在任何导入语句之上。每个源代码文件中只能有一个包语句，所以**`所有类都必须在同一个包中`**。当然，这包括内部类。
- en: '![Images](Images/3.png) **Set up a matching directory structure**'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Images](Images/3.png) **建立匹配的目录结构**'
- en: It’s not enough to ***say*** your class is in a package by merely putting a
    package statement in the code. Your class isn’t *truly* in a package until you
    put the class in a matching directory structure. So, if the fully qualified class
    name is com.headfirstjava.PackageExercise, you *must* put the PackageExercise
    source code in a directory named **`headfirstjava`**, which ***must*** be in a
    directory named **`com`**.
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 仅仅在代码中放置一个包语句来***声明***你的类在一个包中是不够的。只有当你把类放在匹配的目录结构中时，你的类才*真正*属于一个包。因此，如果完全限定的类名是com.headfirstjava.PackageExercise，你*必须*把PackageExercise源代码放在一个名为**`headfirstjava`**的目录中，该目录***必须***位于名为**`com`**的目录中。
- en: '![image](Images/f0686-01.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0686-01.png)'
- en: A note on directories
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于目录的一点说明
- en: In the Real World, source files and class files are usually kept in separate
    directories—you don’t want to copy the source code to wherever it’s running (a
    customer’s computer or the cloud), only the class files.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，源文件和类文件通常保存在不同的目录中——你不希望将源代码复制到它正在运行的地方（客户的计算机或云端），只需复制类文件。
- en: 'The most common structure for Java projects is based off Maven’s* convention:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Java项目最常见的结构是基于Maven的*约定：
- en: '`**MyProject/src/main/java**` Application sources'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`**MyProject/src/main/java**` 应用程序源代码'
- en: '`**MyProject/src/test/java**` Test sources'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`**MyProject/src/test/java**` 测试源代码'
- en: 'The class files are placed elsewhere. Real enterprise systems usually use a
    build tool like Maven or Gradle to compile and build the application (our sample
    code uses Gradle). Each build tool puts the classes into different folders:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 类文件被放置在其他地方。真实的企业系统通常使用像Maven或Gradle这样的构建工具来编译和构建应用程序（我们的示例代码使用Gradle）。每个构建工具将类文件放入不同的文件夹中：
- en: '|  | Maven | Gradle |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '|  | Maven | Gradle |'
- en: '| --- | --- | --- |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Application classes | MyProject/target/classes | MyProject/out/production/classes
    |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 应用程序类 | MyProject/target/classes | MyProject/out/production/classes |'
- en: '| Test classes | MyProject/target/test-classes | MyProject/out/test/classes
    |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 测试类 | MyProject/target/test-classes | MyProject/out/test/classes |'
- en: '*Maven and Gradle are the most common build tools for Java projects.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*Maven和Gradle是Java项目中最常见的构建工具。'
- en: Compiling and running with packages
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译和运行带有包的代码
- en: We don’t need to use a build tool to separate our classes and source files.
    By using the `**-d**` flag, *you* get to decide which **`directory`** the compiled
    code lands in, rather than accepting the default of class files landing in the
    same directory as the source code.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要使用构建工具来分离我们的类和源文件。通过使用`**-d**`标志，*你*可以决定编译后的类文件落在哪个**`目录`**，而不是接受类文件默认落在与源代码相同的目录中。
- en: Compiling with the `**-d**` flag not only lets you send your compiled class
    files into a directory other than the one where the source file is, but it also
    knows to put the class into the correct directory structure for the package the
    class is in. Not only that, compiling with -d tells the compiler to *build* the
    directories if they don’t exist.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`**-d**`标志进行编译不仅可以让你将编译后的类文件发送到源文件所在的目录之外的目录中，而且还知道将类放入正确的包目录结构中。而且，使用-d进行编译告诉编译器如果目录不存在就*构建*这些目录。
- en: '**The `-d` flag tells the compiler, “Put the class into its package directory
    structure, using the class specified after the `-d` as the root directory. But...if
    the directories aren’t there, create them first and *then* put the class in the
    right place!”**'
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**`-d`标志告诉编译器，“将类放入其包目录结构中，使用`-d`后面指定的类作为根目录。但是...如果目录不存在，首先创建它们，*然后*将类放在正确的位置！”**'
- en: Compiling with the `-d` (directory) flag
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`-d`（目录）标志进行编译
- en: '![image](Images/f0687-01.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0687-01.png)'
- en: 'To compile all the .java files in the com.headfirstjava package, use:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译com.headfirstjava包中的所有.java文件，请使用：
- en: '![image](Images/f0687-03.png)![image](Images/f0687-02.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0687-03.png)![image](Images/f0687-02.png)'
- en: Running your code
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行你的代码
- en: '![image](Images/f0687-04.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0687-04.png)'
- en: '#9 Immutability in Strings and Wrappers'
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#9 字符串和包装类的不可变性'
- en: 'We talked about immutability in [Chapter 18](ch18.xhtml#dealing_with_concurrency_issues_race_con),
    and we’ll mention immutability in the last item of this appendix. This section
    is specifically about immutability in two important Java types: Strings and Wrappers.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第18章](ch18.xhtml#dealing_with_concurrency_issues_race_con)中讨论了不可变性，并且我们将在本附录的最后一项中提到不可变性。本节专门讨论两个重要的Java类型中的不可变性：字符串和包装类。
- en: Why do you care that Strings are immutable?
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么你要在意字符串是不可变的？
- en: 'For security purposes and for the sake of conserving memory (whether you’re
    running on phones, IoT devices, or the cloud, memory matters), Strings in Java
    are immutable. What this means is that when you say:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 出于安全目的和节省内存的考虑（无论您是在手机、物联网设备还是云上运行，内存都很重要），Java中的字符串是不可变的。这意味着当您说：
- en: '[PRE0]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: what’s actually happening is that you’re creating ten String objects (with values
    “0,” “01,” “012,” through “0123456789”). In the end, *s* is referring to the String
    with the value “0123456789,” but at this point there are *ten different* Strings
    in existence!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 实际发生的是您正在创建十个字符串对象（值为“0,” “01,” “012,” 到“0123456789”）。最终，*s*引用的是值为“0123456789”的字符串，但在此时存在*十个不同*的字符串！
- en: 'Similarly, if you use methods on String to “change” a String object, it doesn’t
    change that object at all; it creates a new one:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，如果您对字符串使用方法来“更改”字符串对象，则根本不会更改该对象；它会创建一个新的：
- en: '![image](Images/f0688-01.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0688-01.png)'
- en: How does this save memory?
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 这如何节省内存？
- en: Whenever you make a new String, the JVM puts it into a special part of memory
    called the “String Pool” (sounds refreshing, doesn’t it?). If there is already
    a String in the pool with the same value, the JVM *doesn’t create a duplicate*;
    it refers your reference variable to the *existing* entry. So you won’t have 500
    objects of the word “customer” (for example), but 500 references to the single
    “customer” String object.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您创建一个新的字符串时，JVM将其放入称为“字符串池”的特殊内存部分（听起来很清爽，不是吗？）。如果池中已经有一个具有相同值的字符串，则JVM *不会创建副本*；它会将您的引用变量引用到*现有*条目。因此，您不会有500个“customer”单词的对象（例如），而是对单个“customer”字符串对象的500个引用。
- en: '![image](Images/f0688-02.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0688-02.png)'
- en: Immutability makes reuse possible
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不可变性使得重用成为可能
- en: The JVM can get away with this because Strings are **`immutable`**; one reference
    variable can’t change a String’s value out from under another reference variable
    referring to the same String.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: JVM可以做到这一点，因为字符串是**`immutable`**的；一个引用变量不能在另一个引用变量正在引用的同一字符串下更改字符串的值。
- en: What happens to unused Strings?
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 未使用的字符串会发生什么？
- en: Our first example created a lot of intermediate Strings that weren’t used (“01,”
    “012,” etc). These were placed in the String Pool, which is on the heap and therefore
    eligible for Garbage Collection (see [Chapter 9](ch09.xhtml#life_and_death_of_an_object_constructors)).
    Strings that aren’t used will eventually be garbage-collected.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个示例创建了许多未使用的中间字符串（“01,” “012,”等）。这些放在字符串池中，位于堆上，因此可以进行垃圾回收（参见[第9章](ch09.xhtml#life_and_death_of_an_object_constructors)）。未使用的字符串最终将被垃圾回收。
- en: 'However, if you have to do a lot of String manipulations (like concatenations,
    etc.), you can avoid the creation of unnecessary strings by using a *StringBuilder*:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您必须进行大量的字符串操作（如连接等），可以通过使用*StringBuilder*来避免创建不必要的字符串：
- en: '[PRE1]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This way, the single *mutable* StringBuilder is updated every time to represent
    the intermediate states, instead of ten *immutable* String instances being created
    and the nine intermediate Strings being thrown away.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，单个*可变* StringBuilder 每次都会更新以表示中间状态，而不是创建十个*不可变*字符串实例并丢弃九个中间字符串。
- en: Why do you care that Wrappers are immutable?
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你为什么关心包装器是不可变的？
- en: 'In [Chapter 10](ch10.xhtml#numbers_matter_numbers_and_statics), we talked about
    the two main uses of the wrapper classes:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第10章](ch10.xhtml#numbers_matter_numbers_and_statics)中，我们讨论了包装类的两个主要用途：
- en: Wrapping a primitive so it can act like an object.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将原始类型包装起来，使其可以像对象一样操作。
- en: Using the static utility methods (e.g., Integer.parseInt()).
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用静态实用方法（例如Integer.parseInt()）。
- en: 'It’s important to remember that when you create a wrapper object like:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当您创建像这样的包装对象时很重要：
- en: '[PRE2]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: that’s it for that wrapper object. Its value will *always* be 42\. ***There
    is no setter method for a wrapper object.*** You can, of course, refer *iWrap*
    to a *different* wrapper object, but then you’ll have *two* objects. Once you
    create a wrapper object, there’s no way to change the *value* of that object!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 该包装对象到此为止。它的值将*永远*是42。***包装对象没有设置方法***。当然，您可以将*iWrap*指向*另一个*包装对象，但这样就会有*两个*对象。创建包装对象后，无法更改该对象的*值*！
- en: '#8 Access levels and access modifiers (who sees what)'
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#8 访问级别和访问修饰符（谁看到什么）'
- en: Java has four access levels and three access modifiers. There are only three
    modifiers because the default (what you get when you don’t use any access modifier)
    is one of the four access levels.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Java有四个访问级别和三个访问修饰符。之所以只有三个修饰符，是因为默认情况下（当您不使用任何访问修饰符时），其中一个是四个访问级别之一。
- en: '**Access levels** (in order of how restrictive they are, from least to most
    restrictive)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**访问级别**（按照从最不限制到最限制的顺序）'
- en: '![image](Images/f0689-01.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0689-01.png)'
- en: '**Access modifiers**'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**访问修饰符**'
- en: '[PRE3]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Most of the time you’ll use only public and private access levels.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，你只会使用公共（public）和私有（private）访问级别。
- en: '**public**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**public**'
- en: Use public for classes, constants (static final variables), and methods that
    you’re exposing to other code (for example getters and setters) and most constructors.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 public 用于你向其他代码公开的类、常量（静态常量变量）和方法（例如 getter 和 setter），以及大多数构造方法。
- en: '**private**'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**private**'
- en: Use private for virtually all instance variables, and for methods that you don’t
    want outside code to call (in other words, methods used by the public methods
    of your class).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于几乎所有实例变量和不希望外部代码调用的方法（换句话说，被类的公共方法使用的方法），使用 private。
- en: Although you might not use the other two (protected and default) much, you still
    need to know what they do because you’ll see them in other code.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可能不经常使用其他两种（protected 和 default），但你仍需要了解它们的作用，因为你会在其他代码中看到它们。
- en: '**default and protected**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**default 和 protected**'
- en: '**default**'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**default**'
- en: Both protected and default access levels are tied to packages. Default access
    is simple—it means that only code *within the same package* can access code with
    default access. So a default class, for example (which means a class that isn’t
    explicitly declared as *public*) can be accessed by only classes within the same
    package as the default class.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 保护（protected）和默认（default）访问级别都与包相关联。默认访问很简单——意味着只有 *同一个包内* 的代码可以访问具有默认访问权限的代码。因此，默认类（即没有显式声明为
    *public* 的类）只能由与默认类同一包中的类访问。
- en: But what does it really mean to *access* a class? Code that does not have access
    to a class is not allowed to even *think* about the class. And by think, we mean
    *use* the class in code. For example, if you don’t have access to a class, because
    of access restriction, you aren’t allowed to instantiate the class or even declare
    it as a type for a variable, argument, or return value. You simply can’t type
    it into your code at all! If you do, the compiler will complain.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 但是真正*访问*一个类是什么意思呢？没有访问权限的代码甚至不允许*考虑*这个类。通过考虑，我们的意思是在代码中*使用*这个类。例如，如果你没有对一个类的访问权限，因为有访问限制，你就不能实例化这个类，甚至不能将它作为变量、参数或返回值的类型声明。你根本无法在你的代码中输入它！如果你这样做，编译器会报错。
- en: Think about the implications—a default class with public methods means the public
    methods aren’t really public at all. You can’t access a method if you can’t *see*
    the class.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 想一想其含义——一个默认类有公共方法意味着这些公共方法实际上并不是公共的。如果你看不到这个类，你就不能访问这个方法。
- en: Why would anyone want to restrict access to code within the same package? Typically,
    packages are designed as a group of classes that work together as a related set.
    So it might make sense that classes within the same package need to access one
    another’s code, while as a package, only a small number of classes and methods
    are exposed to the outside world (i.e., code outside that package).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么有人想要限制对同一包内代码的访问呢？通常，包被设计为一组共同工作的类的集合。因此，在同一个包内的类需要访问彼此的代码可能是有道理的，而作为包，只有少数类和方法向外部公开（即包之外的代码）。
- en: OK, that’s default. It’s simple—if something has default access (which, remember,
    means no explicit access modifier!), only code within the same package as the
    default *thing* (class, variable, method, inner class) can access that *thing*.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这就是 default。它很简单——如果某物有默认访问权限（记住，意味着没有显式的访问修饰符！），只有与默认 *thing*（类、变量、方法、内部类）相同包中的代码可以访问该
    *thing*。
- en: Then what’s *protected* for?
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 那么保护访问到底有什么作用呢？
- en: '**protected**'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**protected**'
- en: 'Protected access is almost identical to default access, with one exception:
    it allows subclasses to *inherit* the protected thing, *even if those subclasses
    are outside the package of the superclass they extend*. That’s it. That’s *all*
    protected buys you—the ability to let your subclasses be outside your superclass
    package, yet still *inherit* pieces of the class, including methods and constructors.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 保护访问几乎与默认访问相同，只有一个例外：它允许子类*继承*受保护的东西，*即使这些子类位于扩展其超类的包之外*。就是这样。这就是保护访问带给你的一切——让你的子类可以在超类包之外，但仍*继承*类的片段，包括方法和构造方法。
- en: Many developers find very little reason to use protected, but it is used in
    some designs, and some day you might find it to be exactly what you need. One
    of the interesting things about protected is that—unlike the other access levels—protected
    access applies only to *inheritance*. If a subclass-outside-the-package has a
    *reference* to an instance of the superclass (the superclass that has, say, a
    protected method), the subclass can’t access the protected method using that superclass
    reference! The only way the subclass can access that method is by *inheriting*
    it. In other words, the subclass-outside-the-package doesn’t have *access* to
    the protected method; it just *has* the method, through inheritance.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发人员发现很少有理由使用受保护的访问级别，但在某些设计中会使用它，并且有一天你可能会发现它正是你所需要的。关于受保护的一个有趣之处是——与其他访问级别不同——受保护的访问仅适用于*继承*。如果一个子类在包外有一个对超类实例（具有受保护方法的超类，例如）的*引用*，那么子类不能使用该超类引用访问受保护的方法！子类访问该方法的唯一方式是*继承*它。换句话说，包外的子类没有*访问*受保护的方法；它只是通过继承*拥有*该方法。
- en: Note
  id: totrans-122
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Experienced developers writing libraries for other developers to use will find
    both default and protected access levels very helpful.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为其他开发者编写库的经验丰富的开发人员会发现默认和受保护的访问级别非常有帮助。
- en: These access levels can separate the internals of a library from the API that
    other developers will call from their code.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这些访问级别可以将库的内部与其他开发人员将从其代码中调用的API分开。
- en: '#7 Varargs'
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#7 可变参数'
- en: We saw varargs briefly in [Chapter 10](ch10.xhtml#numbers_matter_numbers_and_statics),
    *Numbers Matter,* when we looked at the String.format() method. You also saw them
    in [Chapter 11](ch11.xhtml#data_structures_collections_and_generics), *Data Structures*,
    when we looked at *convenience factory methods for Collections*. Varargs let a
    method take as many arguments as they want, as long as they’re of the same type.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第10章](ch10.xhtml#numbers_matter_numbers_and_statics) *数字的重要性*中简要看到了可变参数，当我们查看String.format()方法时。你也在[第11章](ch11.xhtml#data_structures_collections_and_generics)
    *数据结构*中看到了它们，当我们查看*集合的便捷工厂方法*时。可变参数让一个方法接受任意数量的相同类型的参数。
- en: Why do you care?
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你为什么在乎？
- en: Chances are, you won’t write many (or any!) methods with a vararg parameter.
    But you will likely use them, passing in varargs, since the Java libraries do
    provide helpful methods, like the ones we just mentioned, that can take as many
    arguments as they like.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能不会写很多（甚至一个！）带有可变参数的方法。但你可能会使用它们，传入可变参数，因为Java库确实提供了一些有用的方法，比如我们刚提到的那些方法，可以接受任意数量的参数。
- en: How can I tell if a method takes varargs?
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我怎样才能知道一个方法是否接受可变参数？
- en: 'Let’s look at the API documentation for String.format():'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下String.format()的API文档：
- en: '[PRE4]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The triple dot (...) says this is method takes an arbitrary number of Objects
    after the String argument, **`including zero`**. For example:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 三个点(...)表示这个方法在字符串参数之后接受任意数量的对象，**`包括零个`**。例如：
- en: '![image](Images/f0691-01.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0691-01.png)'
- en: Methods that take varargs generally don’t care how many arguments there are;
    it doesn’t matter much. Consider List.of(), for example. It doesn’t care how many
    items you want in the List; it will just use add all the arguments into the new
    list.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 接受可变参数的方法通常不在乎有多少个参数；这并不重要。例如考虑List.of()。它不在乎你想要在列表中有多少项；它只会将所有参数添加到新列表中。
- en: Creating a method that takes varargs
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个接受可变参数的方法
- en: 'You will generally be calling a method that takes varargs, not creating it,
    but let’s take a look anyway. If you wanted to define your own method that, for
    example, printed out everything passed into it, you could do it like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通常你会调用一个接受可变参数的方法，而不是创建它，但我们还是来看一下。如果你想定义自己的方法，例如，打印传入的所有内容，你可以这样做：
- en: '[PRE5]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The parameter *elements* is nothing magic; it’s actually just an array of Objects.
    So you can iterate over it the same way as if you’d created the method signature
    as:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 参数*elements*并不神奇；实际上它只是一个对象数组。因此，你可以像创建方法签名为以下方式那样迭代它：
- en: '[PRE6]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It’s the calling code that looks different. Instead of having to create an array
    of objects to pass in, you get the convenience of passing in an arbitrary number
    of parameters.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的是调用代码。你不需要创建要传入的对象数组，而是可以方便地传入任意数量的参数。
- en: Rules
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 规则
- en: A method can have only one varargs parameter.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个方法只能有一个可变参数。
- en: The varargs parameter must be the last parameter.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可变参数必须是最后一个参数。
- en: '#6 Annotations'
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#6 注解'
- en: Why do you care?
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你为什么在乎？
- en: 'We very briefly mentioned annotations back in [Chapter 12](ch12.xhtml#lambdas_and_streams_whatcomma_not_how_la),
    *Lambdas and Streams: What, Not How*, when we said that interfaces that can be
    implemented as a lambda expression may be marked with a “@FunctionalInterface”
    annotation.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第12章](ch12.xhtml#lambdas_and_streams_whatcomma_not_how_la)中简要提到了注解，*Lambda和Stream：What,
    Not How*，当时我们说可以用lambda表达式实现的接口可能会用“@FunctionalInterface”注解标记。
- en: Adding an annotation to your code can add extra behavior, or an annotation can
    be a kind of compiler-friendly documentation; i.e., you’re simply tagging the
    code with some additional information that could optionally be used by the compiler.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 向代码添加注解可以添加额外的行为，或者注解可以是一种友好于编译器的文档；也就是说，您只是用一些额外信息标记代码，这些信息可以选择性地被编译器使用。
- en: You will definitely see annotations used in the Real World, and very likely
    use them.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 您肯定会在现实世界中看到并很可能使用注解。
- en: Where will you see annotations?
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 您会在哪里看到注解？
- en: You will see annotations in code that uses libraries and frameworks like Java
    EE/Jakarta EE, Spring/Spring Boot, Hibernate and Jackson, all of which are very
    commonly used in the Java world for building large and small applications.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 您会在使用Java EE/Jakarta EE、Spring/Spring Boot、Hibernate和Jackson等库和框架的代码中看到注解，这些在Java世界中用于构建大型和小型应用程序的库和框架非常常用。
- en: '![image](Images/f0692-01.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0692-01.png)'
- en: Where you will definitely see annotations is in test code. Back in [Chapter 5](ch05.xhtml#extra-strength_methods_writing_a_program),
    *Extra-Strength Methods*, we introduced the idea of testing your code, but what
    we haven’t shown is the frameworks that make it much easier. The most common one
    is JUnit. If you look at the code samples at *[https://oreil.ly/hfJava_3e_examples](https://oreil.ly/hfJava_3e_examples)*,
    you’ll see there are some example test classes in the “test” folder.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您肯定会在测试代码中看到注解。回顾[第5章](ch05.xhtml#extra-strength_methods_writing_a_program)，*Extra-Strength
    Methods*，我们介绍了测试代码的概念，但我们还没有展示使其更容易的框架。最常见的是JUnit。如果您查看*[https://oreil.ly/hfJava_3e_examples](https://oreil.ly/hfJava_3e_examples)*中的代码示例，您会看到“test”文件夹中有一些示例测试类。
- en: '![image](Images/f0692-01a.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0692-01a.png)'
- en: Note
  id: totrans-154
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Annotations can be applied to classes and methods, to variables (local and instance)
    and parameters, and even some other places in the code.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注解可以应用于类和方法，变量（局部和实例）和参数，甚至代码中的其他一些位置。
- en: Annotations can have elements
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注解可以有元素
- en: Some annotations include elements, which are like parameters with names.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一些注解包含元素，类似于带有名称的参数。
- en: '[PRE7]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If the annotation has only one element, you don’t need to give the name.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果注解只有一个元素，则不需要给出名称。
- en: '[PRE8]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you saw in the earlier examples, you don’t need to add parentheses to an
    annotation that doesn’t have elements.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的示例中看到的，对于没有元素的注解，您不需要添加括号。
- en: You can add more than one annotation to the class, method, or variable that
    you’re annotating.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以向您正在注解的类、方法或变量添加多个注解。
- en: What do they do?
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它们的作用是什么？
- en: Well, it depends! Some can be used as a sort of compiler-safe documentation.
    If you add @FunctionalInterface to an interface with more than one abstract method,
    you’ll get a compiler error.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这取决于！有些可以用作一种编译器安全文档。如果您向具有多个抽象方法的接口添加@FunctionalInterface，您将收到编译器错误。
- en: Other annotations (like @NotNull) can be used by your IDE or by analysis tools
    to see if your code is correct.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 其他注解（如@NotNull）可以被您的IDE或分析工具使用，以查看您的代码是否正确。
- en: Many libraries provide annotations for you to use to tag parts of your code
    so the framework knows what to do with your code. For example, the @Test annotation
    tags methods that need to be run as individual tests by JUnit; @SpringBootApplication
    tags the class with the *main* method that’s the entry point of a Spring Boot
    application; @Entity tags a Java class as a data object that needs to be saved
    to a database by Hibernate.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 许多库提供了注解，供您使用来标记代码的部分，以便框架知道如何处理您的代码。例如，@Test注解标记了需要由JUnit作为单独测试运行的方法；@SpringBootApplication标记了具有*main*方法的类，这是Spring
    Boot应用程序的入口点；@Entity标记了Java类作为需要由Hibernate保存到数据库的数据对象。
- en: 'Some annotations provide behavior on top of your code. For example, Lombok
    can use annotations to generate common code: add @Data to the top of your class,
    and Lombok will generate constructors, getters and (if needed) setters, and hashCode,
    toString, and equals methods.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一些注解在您的代码之上提供行为。例如，Lombok可以使用注解生成通用代码：在类的顶部添加@Data，Lombok将生成构造函数、getter和（如果需要）setter，以及hashCode、toString和equals方法。
- en: '#5 Lambdas and Maps'
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#5 Lambda和Map'
- en: '**Java 8+**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java 8+**'
- en: Why do you care?
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你为什么要在意呢？
- en: Java 8 famously added lambdas and streams to Java, but what is less well-known
    is that java.util.Map also got a few new methods that take lambda expressions
    as arguments. These methods make it much easier to do common operations on Maps,
    which will save you time and brainpower.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8著名地向Java添加了lambda和streams，但不太为人所知的是java.util.Map也添加了一些以lambda表达式作为参数的新方法。这些方法使得在Map上执行常见操作变得更加容易，这将节省您的时间和精力。
- en: Create a new value if there isn’t one for the key
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如果键没有值，则创建一个新值
- en: 'Imagine you want to track what a customer does on your website, and you do
    this using an Actions object. You might have a Map of String username to Actions.
    When a customer performs some action that you want to add to their Actions object,
    you want to either:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你想追踪客户在你的网站上做了什么，你可以使用一个Actions对象来实现这一点。你可能有一个从String用户名到Actions的Map。当客户执行一些你想要添加到他们的Actions对象中的操作时，你要么：
- en: Create a new Actions object for this customer and add it to the Map
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为这个客户创建一个新的Actions对象并将其添加到Map中
- en: Get the existing Actions object for this customer
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取此客户的现有Actions对象
- en: 'It’s very common to use an *if* statement and a *null* check to do this (pre-Java
    8):'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 非常常见的是使用*if*语句和*null*检查来执行此操作（Java 8之前）：
- en: '![image](Images/f0693-01.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0693-01.png)'
- en: 'It’s not a lot of code, but it is a pattern that is used again and again. If
    you’re using Java 8 or higher, you don’t need to do this at all. Use **computeIfAbsent**,
    and give it a lambda expression that says how to “compute” the value that should
    go into the Map if there isn’t an entry for the given key:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是很多代码，但这是一个一再使用的模式。如果你使用的是Java 8或更高版本，你根本不需要这样做。使用**computeIfAbsent**，并给它一个lambda表达式，说明如果给定键没有条目时应该“计算”进Map的值：
- en: '![image](Images/f0693-02.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0693-02.png)'
- en: Update the value only if it already exists
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 只有在它已经存在时才更新值
- en: There may be other scenarios when you want to update a value in the Map only
    if it exists. For example, you might have a Map of things that you are counting,
    like metrics, and you want to update only the metrics that you care about. You
    don’t want to add any arbitrary new metric to the Map. Before Java 8, you might
    use a combination of *contains*, *get*, and *put* to check if the map has a value
    for this metric and update it if so.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 可能还有其他情况，当你只想在Map中存在时更新值。例如，你可能有一个计数的Map，比如指标，你只想更新你关心的指标。你不想向Map中添加任意新的指标。在Java
    8之前，你可能会使用*contains*，*get*和*put*的组合来检查Map是否有这个指标的值，如果有的话就更新它。
- en: '![image](Images/f0694-01.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0694-01.png)'
- en: 'Java 8 added **computeIfPresent**, which takes the key you’re looking for and
    a lambda expression, which you can use to describe how to calculate the updated
    value for the Map. Using this, the code above can be simplified to:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8添加了**computeIfPresent**，它接受你要查找的键和一个lambda表达式，你可以用它来描述如何计算Map的更新值。使用这个，上面的代码可以简化为：
- en: '![image](Images/f0694-02.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0694-02.png)'
- en: Other methods
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他方法
- en: There are other, more advanced methods on Map that can be useful when you want
    to “add a new value OR do something with the existing value” (or even remove a
    value), like *merge* and *compute*. There’s also *replaceAll*, which you can give
    a lambda expression that calculates a new value for all the values in the map
    (we could use this, for example, to increment ALL the metrics in our previous
    example, if we needed to). And, like all the collections, it has a *forEach* that
    lets us iterate over all the key/value pairs in the Map.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在Map上还有其他更高级的方法，当你想“添加一个新值或对现有值进行操作”（甚至删除一个值）时会很有用，比如*merge*和*compute*。还有*replaceAll*，你可以给它一个lambda表达式，计算Map中所有值的新值（例如，如果需要，我们可以使用这个来增加我们之前示例中的所有指标）。而且，像所有的集合一样，它有一个*forEach*，让我们可以迭代Map中的所有键/值对。
- en: The Java libraries continuously evolve, so even if you think you understand
    something you’ve used a lot, like List or Map, it’s always worth keeping an eye
    out for changes that may make your life easier.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Java库不断发展，所以即使你认为你已经很了解一些你经常使用的东西，比如List或Map，时刻关注可能让你的生活更轻松的变化也是值得的。
- en: Remember, the Java API documentation (*[https://oreil.ly/ln5xn](https://oreil.ly/ln5xn)*)
    is a great place to start if you want to see what methods are available on a class,
    and what they do.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，Java API文档（*[https://oreil.ly/ln5xn](https://oreil.ly/ln5xn)*）是一个很好的起点，如果你想查看一个类上有哪些方法以及它们的作用。
- en: '#4 Parallel Streams'
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#4 并行流'
- en: '**Java 8+**'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java 8+**'
- en: 'Back in [Chapter 12](ch12.xhtml#lambdas_and_streams_whatcomma_not_how_la),
    *Lambdas and Streams: What, Not How*, we took a long look at the Streams API.
    We did not look at one of the really interesting features of streams, which is
    that you can use them to take advantage of modern multicore, multi-CPU hardware
    and run your stream operations in parallel. Let’s look at that now.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 [第 12 章](ch12.xhtml#lambdas_and_streams_whatcomma_not_how_la) *Lambda 和 Streams：What,
    Not How* 中，我们详细讨论了 Streams API。我们没有看到 Streams 的一个非常有趣的特性，即可以利用现代多核、多 CPU 硬件并行运行流操作。现在让我们来看看这个。
- en: So far, we’ve used the Streams API to effectively “query” our data structures.
    Now, imagine those data structures can get big. We mean REALLY big. Like all the
    data from a database, or like a real-time stream of data from a social media API.
    We *could* plod over each of these items one by one, in **`serial`**, until we
    get the results we want. Or, we could split the work up into multiple operations
    and run them at the same time, in **`parallel`**, on different CPUs. After [Chapter 17](ch17.xhtml#make_a_connection_networking_and_threads)
    and [Chapter 18](ch18.xhtml#dealing_with_concurrency_issues_race_con) you might
    be tempted to run off and write a multithreaded application to do that, but *you
    don’t have to*!
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用 Streams API 有效地“查询”我们的数据结构。现在，想象这些数据结构可能变得非常大。我们是真的非常大。就像来自数据库的所有数据，或者来自社交媒体
    API 的实时数据流。我们*可以*逐一处理每个项目，以**`串行`**的方式，直到得到我们想要的结果。或者，我们可以将工作分解为多个操作，并在不同的 CPU
    上**`并行`**运行它们。在 [第 17 章](ch17.xhtml#make_a_connection_networking_and_threads)
    和 [第 18 章](ch18.xhtml#dealing_with_concurrency_issues_race_con) 中，您可能会被诱惑去编写一个多线程应用程序来完成这项工作，但*您并不需要*！
- en: Going parallel
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转向并行
- en: You can simply tell the Streams API you want your stream pipeline to be run
    on multiple CPU cores. There are two ways to do this.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以简单地告诉 Streams API 您希望您的流管道在多个 CPU 核心上运行。有两种方法可以做到这一点。
- en: '**Start a parallelStream**'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**启动 parallelStream**'
- en: '![image](Images/f0695-01.png)'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0695-01.png)'
- en: '**Add parallel() to the stream pipeline**'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将 parallel() 添加到流管道**'
- en: '[PRE9]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: They both do the same thing, and you can choose whichever approach you prefer.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 两者都执行相同的操作，您可以选择您喜欢的任何一种方法。
- en: OK now what?
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 好了现在怎么办？
- en: 'Now, you just write a stream pipeline just like we did in [Chapter 12](ch12.xhtml#lambdas_and_streams_whatcomma_not_how_la),
    adding the operations you want and finishing off with a terminator. The Java libraries
    will take care of figuring out:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只需像在 [第 12 章](ch12.xhtml#lambdas_and_streams_whatcomma_not_how_la) 中那样编写一个流管道，添加所需的操作，并以终结符结束。Java
    库将负责找出：
- en: How to split the data to run the stream pipeline on multiple CPU cores
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将数据分割以在多个 CPU 核心上运行流管道
- en: How many parallel operations to run
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行多少个并行操作
- en: How to merge the results of the multiple operations
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何合并多个操作的结果
- en: Multithreading is taken care of
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多线程已经处理
- en: Under the covers, parallel streams use the [Fork-Join framework](https://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html)
    (which we did not cover in this book; see *[https://oreil.ly/XJ6eH](https://oreil.ly/XJ6eH)*),
    yet another type of thread pool (which we did talk about in [Chapter 17](ch17.xhtml#make_a_connection_networking_and_threads),
    *Make a Connection*). With parallel streams, you’ll find the number of threads
    is equal to the number of cores available wherever your application is running.
    There are ways to change this setup, but it’s recommended to stick with the defaults
    unless you *really* know what you’re doing.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在背后，parallel streams 使用 [Fork-Join 框架](https://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html)（本书未涉及；参见
    *[https://oreil.ly/XJ6eH](https://oreil.ly/XJ6eH)*），这是另一种类型的线程池（我们在 [第 17 章](ch17.xhtml#make_a_connection_networking_and_threads)
    *建立连接* 中有所涉及）。使用 parallel streams 时，线程数量与应用程序运行的核心数量相等。有方法可以更改此设置，但建议除非你*真的*知道自己在做什么，否则应坚持使用默认设置。
- en: Do not use parallel everywhere!
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不要到处都使用 parallel！
- en: Before you going running off and making all your stream calls parallel, **wait**!
    Remember we said back in [Chapter 18](ch18.xhtml#dealing_with_concurrency_issues_race_con),
    *Dealing with Concurrency Issues*, that multithreaded programming was hard, because
    the solutions you choose depend a lot on your application, your data, and your
    environment? The same applies to using parallel streams. Going parallel and making
    use of multiple CPU cores is ***not*** free and does ***not*** automatically mean
    your application will run faster.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在你急于使所有流调用并行化之前，请**等待**！记得我们在[第18章](ch18.xhtml#dealing_with_concurrency_issues_race_con)中提到过，*处理并发问题*，多线程编程很难，因为你选择的解决方案很大程度上取决于你的应用程序、数据和环境？同样适用于使用并行流。并行处理并利用多个CPU核心***不是***免费的，也***不***自动意味着你的应用程序会运行得更快。
- en: There is a cost to running a stream pipeline in parallel. The data needs to
    be split up, the operations need to be run on each bit of data on separate threads,
    and then at the end the results of each separate parallel operation need to be
    combined in some way to give a final result. All of that adds time.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 并行运行流管道是有成本的。数据需要分割，操作需要在各个数据片段上独立线程运行，然后在最后需要以某种方式组合每个独立并行操作的结果以得出最终结果。所有这些都会增加时间成本。
- en: 'If the data going into your stream pipeline is a simple collection, like the
    examples we looked at in [Chapter 12](ch12.xhtml#lambdas_and_streams_whatcomma_not_how_la)
    (indeed, in *most* places streams are used today), using serial streams is almost
    definitely going to be faster. Yes, you read that correctly: for most ordinary
    use cases, you do ***not*** want to go parallel.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果进入流管道的数据是一个简单的集合，就像我们在[第12章](ch12.xhtml#lambdas_and_streams_whatcomma_not_how_la)中看到的例子一样（事实上，在大多数地方使用流的情况下），使用串行流几乎肯定会更快。是的，你没看错：对于大多数普通用例，你***不***想并行处理。
- en: 'Parallel streams can improve performance when:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 并行流在以下情况下可以提高性能：
- en: The input collection is BIG (think hundreds of thousands of elements at least)
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入集合非常大（至少考虑数十万个元素）
- en: The stream pipeline is performing complicated, long-running operations
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流管道正在执行复杂且长时间运行的操作。
- en: The decomposition (splitting) of the data/operations and merging of the results
    are not too costly.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据/操作的分解（拆分）和结果的合并并不太昂贵。
- en: You should measure the performance with and without parallel before using it.
    If you want to learn more, Richard Warburton’s *Java 8 Lambdas* book has an excellent
    section on data parallelism.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用之前，你应该测量并行和非并行的性能差异。如果想了解更多，Richard Warburton的《Java 8 Lambdas》书中有一节关于数据并行性的优秀内容。
- en: '#3 Enumerations (also called enumerated types or enums)'
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#3 枚举（也称为枚举类型或枚举）'
- en: We’ve talked about constants that are defined in the API, for instance, `**JFrame.EXIT_ON_CLOSE**`.
    You can also create your own constants by marking a variable `**static final**`.
    But sometimes you’ll want to create a set of constant values to represent the
    ***only*** valid values for a variable. This set of valid values is commonly referred
    to as an enumeration. Full-fledged enumerations were introduce way back in Java
    5.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了API中定义的常量，例如`**JFrame.EXIT_ON_CLOSE**`。你也可以通过将变量标记为`**static final**`来创建自己的常量。但有时你会想要创建一组常量值来表示变量的***唯一***有效值。这组有效值通常称为枚举。完整的枚举在Java
    5中引入。
- en: Who’s in the band?
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 乐队中有谁？
- en: Let’s say that you’re creating a website for your favorite band, and you want
    to make sure that all of the comments are directed to a particular band member.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在为你最喜欢的乐队创建一个网站，并且你希望确保所有的评论都指向特定的乐队成员。
- en: 'The old way to fake an “enum”:'
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 伪造“枚举”的旧方法：
- en: '![image](Images/f0696-01.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0696-01.png)'
- en: The good news about this technique is that it DOES make the code easier to read.
    The other good news is that you can’t ever change the value of the fake enums
    you’ve created; `KEVIN` will always be `1`. The bad news is that there’s no easy
    or good way to make sure that the value of `selectedBandMember` will always be
    `1, 2`, or `3`. If some hard-to-find piece of code sets `selectedBandMember` equal
    to `812`, it’s pretty likely your code will break.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术的好消息是确实使代码更易读。另一个好消息是，你永远不能改变你创建的伪枚举的值；`KEVIN`将永远是`1`。坏消息是，没有简单或良好的方法来确保`selectedBandMember`的值始终是`1,
    2`或`3`。如果某些难以找到的代码片段将`selectedBandMember`设置为`812`，你的代码很可能会崩溃。
- en: Note
  id: totrans-223
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This IS the OLD way to fake an enum, but you will still see code like this in
    Real Life (e.g., the older Java libraries like AWT).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这是伪造枚举的老方法，但你仍然会在现实生活中看到这样的代码（例如，旧的 Java 库，如 AWT）。
- en: However, if you have any control over the code, try to use enums instead of
    constants like this. See the next page...
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，如果你能控制代码，尝试使用枚举而不是像这样的常量。看看下一页……
- en: Let’s see what the band members would look like with a “real” enum. While this
    is a very basic enumeration, most enumerations usually are this simple.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看乐队成员在“真正”的枚举中会是什么样子。虽然这是一个非常基本的枚举，但大多数枚举通常都很简单。
- en: An official “enum”
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个官方的“enum”
- en: '![image](Images/f0697-01.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0697-01.png)'
- en: Your enum extends java.lang.Enum
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你的枚举扩展了 java.lang.Enum
- en: When you create an enum, you’re creating a new class, and ***you’re implicitly
    extending*** `***java.lang.Enum***`. You can declare an enum as its own standalone
    class, in its own source file, or as a member of another class.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个枚举时，你正在创建一个新类，并且***你隐式地扩展*** `***java.lang.Enum***`。你可以将枚举声明为独立的类，在自己的源文件中，或者作为另一个类的成员。
- en: Using “if” and “switch” with enums
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用枚举进行“if”和“switch”操作
- en: Using the enum we just created, we can perform branches in our code using either
    the `if` or `switch` statement. Also notice that we can compare enum instances
    using either `==` or the `.equals()` method. Usually `==` is considered better
    style.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们刚创作的枚举，我们可以在代码中使用 `if` 或 `switch` 语句进行分支。还请注意，我们可以使用 `==` 或 `.equals()`
    方法比较枚举实例。通常认为 `==` 是更好的风格。
- en: '![image](Images/f0697-02.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0697-02.png)'
- en: You can add a bunch of things to your enum like a constructor, methods, variables,
    and something called a constant-specific class body. They’re not common, but you
    might run into them.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以向你的枚举添加很多东西，比如构造函数、方法、变量，以及称为常量特定类体的东西。它们并不常见，但你可能会遇到它们。
- en: 'Answer:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：
- en: King Bob
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 金·鲍勃
- en: Banana!
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 香蕉！
- en: '#2 Local Variable Type Inference (var)'
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#2 本地变量类型推断（var）'
- en: '**Java 10+**'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java 10+**'
- en: If you’re using Java 10 or higher, you can use **`var`** when you’re declaring
    your *local* variables (i.e., variables inside methods, **not** method parameters
    or instance variables).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 Java 10 或更高版本，可以在声明*本地*变量（即方法内的变量，**不是**方法参数或实例变量）时使用 **`var`**。
- en: '![image](Images/f0698-01.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0698-01.png)'
- en: This is another example of *type inference*, where the compiler can use what
    it already knows about the types to save you from writing more. The compiler knows
    *name* is a String because it was declared as a String on the right hand side
    of the equals sign.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个*类型推断*的例子，编译器可以利用它已知的类型信息来减少你的编写工作。编译器知道 *name* 是一个字符串，因为它在等号的右侧被声明为字符串。
- en: '![image](Images/f0698-02.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0698-02.png)'
- en: Type inference, NOT dynamic types
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型推断，不是动态类型
- en: When you declare your variable using *var*, ***it still has a type***. It’s
    not a way of adding dynamic or optional types to Java (it’s **not** like Groovy’s
    *def*). It’s simply a way of avoiding writing that type twice.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 *var* 声明变量时，***它仍然有一个类型***。这不是在 Java 中添加动态或可选类型的一种方式（它不像 Groovy 的 *def*）。这只是避免两次写入类型的一种方式。
- en: 'You do have to somehow tell the compiler what the type is when you declare
    the variable. You can’t assign it later. So, you ***can’t*** do this:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当你声明变量时，确实必须以某种方式告诉编译器它的类型。你不能稍后再赋值。所以，你***不能***这样做：
- en: '![image](Images/f0698-03.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0698-03.png)'
- en: because the compiler has no idea what type *name* is.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 因为编译器不知道 *name* 的类型。
- en: 'It also means that you can’t change its type later:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着你不能稍后更改它的类型：
- en: '![image](Images/f0698-04.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0698-04.png)'
- en: Someone has to read your code
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 必须有人读你的代码
- en: Using *var* does make the code shorter, and an IDE can tell you exactly what
    type your variable is, so you might be tempted to use var everywhere.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *var* 确实可以使代码更简洁，而且 IDE 可以准确告诉你变量的类型，因此你可能会倾向于在所有地方都使用 var。
- en: However, someone reading your code might not be using an IDE or have the same
    understanding of the code as you.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，阅读你的代码的人可能没有使用 IDE 或者与你对代码的理解相同。
- en: We did not use var in this book (even though it would have been easier to fit
    the code on the pages), because we wanted to be explicit to you, the reader, about
    what the code was doing.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这本书中没有使用 var（即使这样会更容易地将代码放在页面上），因为我们想要向你明确地说明代码在做什么。
- en: 'Tip: Better with useful variable names'
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提示：更好的变量名会更有用
- en: If you don’t have the type information visible in the code, descriptive variable
    and method names will be extra helpful to a reader.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在代码中看不到类型信息，具有描述性的变量名和方法名对读者会特别有帮助。
- en: '![image](Images/f0698-05.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0698-05.png)'
- en: 'Tip: Variable will be the concrete type'
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'Tip: 变量将会是具体类型'
- en: 'In [Chapter 11](ch11.xhtml#data_structures_collections_and_generics) we started
    “programming to interfaces”; i.e., we declared our variables as the interface
    type, not the implementation:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 11 章](ch11.xhtml#data_structures_collections_and_generics)中，我们开始“面向接口编程”，即将变量声明为接口类型，而不是实现类型：
- en: '[PRE10]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you’re using var, you can’t do this. The type will be the type from the
    right-hand side:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 var，就不能这样做。类型将是右侧的类型：
- en: '![image](Images/f0698-06.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0698-06.png)'
- en: 'Tip: Don’t use var with the diamond operator'
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'Tip: 不要在 diamond operator 中使用 var'
- en: Look at the last example. We declared list first as a List<String> and used
    the diamond operator (<>) on the right-hand side. The compiler knows the type
    of the list element is a String from the lefthand side.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 看看最后一个例子。我们首先将 list 声明为 List<String>，然后在右侧使用了 diamond operator (<>)。编译器从左侧知道列表元素的类型是
    String。
- en: If you use var, like we did in the second example, the compiler no longer has
    this information. If you want the list to still be a list of Strings, you need
    to declare that on the righthand side; otherwise, it will contain Objects.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果像第二个例子中使用 var，编译器将不再具有这些信息。如果你希望列表仍然是一个 String 的列表，你需要在右侧声明；否则，它将包含 Objects。
- en: '![image](Images/f0698-07.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0698-07.png)'
- en: Read all the style guidelines from the OpenJDK developers (*[https://oreil.ly/eVfSd](https://oreil.ly/eVfSd)*).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读来自 OpenJDK 开发者的所有风格指南（*[https://oreil.ly/eVfSd](https://oreil.ly/eVfSd)*）。
- en: '#1 Records'
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#1 Records'
- en: Why do you care?
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你为什么关心？
- en: A “simple” Java data object is often not simple at all. Even a data class (sometimes
    called a Java Bean, for historical reasons) with only a couple of fields requires
    quite a lot more code than you might expect.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 一个“简单”的 Java 数据对象通常并不简单。即使是一个只有几个字段的数据类（有时因历史原因称为 Java Bean），它需要的代码比你想象的要多得多。
- en: A Java data class, before Java 16
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Java 16 之前的 Java 数据类
- en: 'Imagine a basic Customer class, with a name and an ID:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个基本的 Customer 类，有一个名字和一个 ID：
- en: '[PRE11]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We’ve left out the details of the equals, hashCode, and toString methods, but
    you would probably want to implement those methods, especially if you’re going
    to use this object in any collections. We’ve also left off the “setters”; this
    is an immutable object with final fields, but in some cases you might want setters
    as well.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们省略了 equals、hashCode 和 toString 方法的细节，但如果你要在任何集合中使用这个对象，你可能想要实现这些方法。我们还省略了“setters”；这是一个带有
    final 字段的不可变对象，但在某些情况下，你可能也需要 setters。
- en: That’s a lot of code! It’s a simple class with two fields, and the full code,
    including implementation, is 41 lines!
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一大段代码！这是一个只有两个字段的简单类，包括实现在内，总共有 41 行代码！
- en: What if there was a special syntax for data classes?
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如果有一种特殊的语法用于数据类会怎样？
- en: Guess what? If you’re using **Java 16** or higher, there is! Instead of creating
    a *class*, you create a *record*.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 猜猜看？如果你使用的是**Java 16**或更高版本，就有了！你不再创建一个*class*，而是创建一个*record*。
- en: '![image](Images/f0699-01.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0699-01.png)'
- en: That’s it. That’s all you need to do to replace the 42 lines of code of the
    “old” Customer data class.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。这就是你用来取代“旧”的 Customer 数据类 42 行代码所需要做的一切。
- en: A record like this one has instance variables, a constructor, accessor methods,
    and equals, hashCode, and toString methods.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样的一个 record 具有实例变量、构造函数、访问方法以及 equals、hashCode 和 toString 方法。
- en: Using a record
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 record
- en: 'When you’re using a record that’s already been defined, it looks exactly the
    same as it would if the record class was a standard data class:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用已经定义好的 record 时，它看起来和如果 record 类是一个标准数据类时完全一样：
- en: '![image](Images/f0699-02.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0699-02.png)'
- en: 'The output looks like:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来像：
- en: '![image](Images/f0699-03.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0699-03.png)'
- en: Goodbye “get”
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Goodbye “get”
- en: Did you notice something? Records don’t use the classic “get” prefix for the
    methods that let you read the instance variables (hence we carefully called them
    “accessors” and not “getters”). They just use the name of the record component
    as the method name.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到了什么？Records 不使用经典的“get”前缀来读取实例变量的方法（因此我们小心地称它们为“accessors”，而不是“getters”）。它们只是使用记录组件的名称作为方法名。
- en: You can override constructors
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你可以重写构造函数
- en: The constructor, accessors, and equals, hashCode, and toString methods are all
    provided by default, but you can still override their behavior if you need something
    specific.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下提供了构造函数、访问方法以及 equals、hashCode 和 toString 方法，但如果需要特定行为，你仍然可以重写它们。
- en: Most of the time, you probably won’t need to. But if you want, for example,
    to add validation when you create the record, you can do that by overriding the
    constructor.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，你可能不需要。但如果你想，在创建记录时添加验证，可以通过覆盖构造函数来实现。
- en: '[PRE12]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Actually, it’s even easier than that. The example above is a ***canonical constructor***,
    i.e., the normal kind of constructor we’ve been using everywhere. But records
    also have a ***compact constructor***. This compact constructor assumes all the
    normal stuff is taken care of (having the right number of parameters in the right
    order, and all assigned to the instance variables) and lets you define only the
    other stuff that matters, like validation:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这比上面的例子更简单。上面的例子是一个***规范构造函数***，即我们在所有地方都在使用的常规构造函数。但记录还有一个***紧凑构造函数***。这个紧凑构造函数假定所有正常的事情都已处理好（按正确顺序有正确数量的参数，并且所有参数都分配给实例变量），让你只定义其他重要的部分，比如验证：
- en: '![image](Images/f0699-04.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0699-04.png)'
- en: When you call the Customer’s constructor, you still need to pass it an ID and
    a name, and they will still be assigned to the instance variables (that’s all
    defined by the record header). All you need to do to add validation to the constructor
    is use the compact form and let the compiler take care of all of the rest.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用Customer的构造函数时，仍然需要传递一个ID和一个名称，并且它们仍然会分配给实例变量（这些都由记录头定义）。要向构造函数添加验证，只需使用紧凑形式，让编译器处理所有其他事情。
- en: '![image](Images/f0700-01.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0700-01.png)'
- en: You can override or add methods
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你可以覆盖或添加方法。
- en: You can override any of the methods and add your own (public, default, or private)
    methods. If you are migrating existing data classes to use records, you may want
    to keep your old equals, hashCode, and toString methods.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以覆盖任何方法并添加自己的（公共、默认或私有）方法。如果你正在将现有数据类迁移到使用记录，则可能希望保留旧的equals、hashCode和toString方法。
- en: '![image](Images/f0700-02.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0700-02.png)'
- en: You can create a protected method; the compiler won’t stop you, but there’s
    no point—records are always *final* classes and can’t be subclassed.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建受保护的方法；编译器不会阻止你，但这没有意义——记录始终是*final*类，不能被子类化。
- en: Records are immutable
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 记录是不可变的。
- en: In [Chapter 18](ch18.xhtml#dealing_with_concurrency_issues_race_con), we talked
    about making data objects *immutable*. Immutable objects are safer to use in concurrent
    applications, because you know that it’s impossible for more than one thread to
    change the data.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第18章](ch18.xhtml#dealing_with_concurrency_issues_race_con)中，我们讨论了使数据对象*不可变*。不可变对象在并发应用中使用更安全，因为你知道不可能有多个线程改变数据。
- en: 'It’s also easier to reason about what’s happening in your application if you
    know the data classes can’t change, so even in applications that aren’t multithreaded,
    you may find immutable data objects being used. And in #9 in this appendix we
    saw how immutability in Strings can save memory.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道数据类不能改变，那么在应用程序中更容易理解发生的事情，所以即使在非多线程应用程序中，你也可能会发现使用不可变数据对象。在附录中的第9部分，我们看到不可变字符串如何节省内存。
- en: Records are immutable. You can’t change the values in a record Object after
    you have created it; there are no “setters” and no way to change the instance
    variables. You can’t access them directly from outside the record, only read them
    via the accessor method.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 记录是不可变的。创建记录对象后，无法更改记录对象中的值；没有“setter”方法，也没有更改实例变量的方法。你不能直接从记录外部访问它们，只能通过访问器方法读取它们。
- en: If you try to change one of the record’s instance variables from inside the
    record, the compiler will throw an exception. A record’s instance variables are
    *final*.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你试图从记录内部更改其中一个实例变量，编译器会抛出异常。记录的实例变量是*final*的。
- en: Find out more about records in Oracle’s Record Classes documentation (*[https://oreil.ly/D7fh3](https://oreil.ly/D7fh3)*).
    There, you can also read about some of the other new language features available
    in Java 17 that we didn’t get a chance to cover, like Pattern Matching, Sealed
    Classes, Switch Expressions, and the very useful Text Blocks.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 了解更多关于Oracle记录类的信息（*[https://oreil.ly/D7fh3](https://oreil.ly/D7fh3)*）。在那里，你也可以阅读关于Java
    17中其他新语言特性的信息，例如模式匹配、封闭类、开关表达式以及非常有用的文本块，这些我们没有时间涵盖。
